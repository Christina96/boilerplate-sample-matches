
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.51668286362164%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs.cpp</h3>
            <pre><code>1  #include "paragraphs.h"
2  #include "helpers.h"             
3  #include "host.h"                
4  #include "mutableiterator.h"     
5  #include "ocrblock.h"            
6  #include "ocrpara.h"             
7  #include "ocrrow.h"              
8  #include "pageres.h"             
9  #include "paragraphs_internal.h" 
10  #include "pdblock.h"             
11  #include "polyblk.h"             
12  #include "ratngs.h"              
13  #include "rect.h"                
14  #include "statistc.h"            
15  #include "tprintf.h"             
16  #include "unicharset.h"          
17  #include "werd.h"                
18  #include <tesseract/pageiterator.h> 
19  #include <tesseract/publictypes.h>  
20  #include <tesseract/unichar.h>      
21  #include <algorithm> 
22  #include <cctype>    
23  #include <cmath>     
24  #include <cstdio>    
25  #include <cstdlib>   
26  #include <cstring>   
27  #include <memory>    
28  static const char *const kRLE = "\u202A"; 
29  static const char *const kPDF = "\u202C"; 
30  namespace tesseract {
31  const ParagraphModel *kCrownLeft =
32      reinterpret_cast<ParagraphModel *>(static_cast<uintptr_t>(0xDEAD111F));
33  const ParagraphModel *kCrownRight =
34      reinterpret_cast<ParagraphModel *>(static_cast<uintptr_t>(0xDEAD888F));
35  static bool LikelyParagraphStart(const RowScratchRegisters &before,
36                                   const RowScratchRegisters &after,
37                                   tesseract::ParagraphJustification j);
38  static int Epsilon(int space_pix) {
39    return space_pix * 4 / 5;
40  }
41  static bool AcceptableRowArgs(int debug_level, int min_num_rows, const char *function_name,
42                                const std::vector<RowScratchRegisters> *rows, int row_start,
43                                int row_end) {
44    if (row_start < 0 || static_cast<size_t>(row_end) > rows->size() || row_start > row_end) {
45      tprintf("Invalid arguments rows[%d, %d) while rows is of size %zu.\n", row_start, row_end,
46              rows->size());
47      return false;
48    }
49    if (row_end - row_start < min_num_rows) {
50      if (debug_level > 1) {
51        tprintf("# Too few rows[%d, %d) for %s.\n", row_start, row_end, function_name);
52      }
53      return false;
54    }
55    return true;
56  }
57  static void PrintTable(const std::vector<std::vector<std::string>> &rows, const char *colsep) {
58    std::vector<int> max_col_widths;
59    for (const auto &row : rows) {
60      auto num_columns = row.size();
61      for (size_t c = 0; c < num_columns; c++) {
62        int num_unicodes = 0;
63        for (char i : row[c]) {
64          if ((i & 0xC0) != 0x80) {
65            num_unicodes++;
66          }
67        }
68        if (c >= max_col_widths.size()) {
69          max_col_widths.push_back(num_unicodes);
70        } else {
71          if (num_unicodes > max_col_widths[c]) {
72            max_col_widths[c] = num_unicodes;
73          }
74        }
75      }
76    }
77    std::vector<std::string> col_width_patterns;
78    col_width_patterns.reserve(max_col_widths.size());
79    for (int max_col_width : max_col_widths) {
80      col_width_patterns.push_back(std::string("%-") + std::to_string(max_col_width) + "s");
81    }
82    for (const auto &row : rows) {
83      for (unsigned c = 0; c < row.size(); c++) {
84        if (c > 0) {
85          tprintf("%s", colsep);
86        }
87        tprintf(col_width_patterns[c].c_str(), row[c].c_str());
88      }
89      tprintf("\n");
90    }
91  }
92  static std::string RtlEmbed(const std::string &word, bool rtlify) {
93    if (rtlify) {
94      return std::string(kRLE) + word + std::string(kPDF);
95    }
96    return word;
97  }
98  static void PrintDetectorState(const ParagraphTheory &theory,
99                                 const std::vector<RowScratchRegisters> &rows) {
100    std::vector<std::vector<std::string>> output;
101    output.emplace_back();
102    output.back().push_back("#row");
103    output.back().push_back("space");
104    output.back().push_back("..");
105    output.back().push_back("lword[widthSEL]");
106    output.back().push_back("rword[widthSEL]");
107    RowScratchRegisters::AppendDebugHeaderFields(output.back());
108    output.back().push_back("text");
109    for (unsigned i = 0; i < rows.size(); i++) {
110      output.emplace_back();
111      std::vector<std::string> &row = output.back();
112      const RowInfo &ri = *rows[i].ri_;
113      row.push_back(std::to_string(i));
114      row.push_back(std::to_string(ri.average_interword_space));
115      row.emplace_back(ri.has_leaders ? ".." : " ");
116      row.push_back(RtlEmbed(ri.lword_text, !ri.ltr) + "[" + std::to_string(ri.lword_box.width()) +
117                    (ri.lword_likely_starts_idea ? "S" : "s") +
118                    (ri.lword_likely_ends_idea ? "E" : "e") +
119                    (ri.lword_indicates_list_item ? "L" : "l") + "]");
120      row.push_back(RtlEmbed(ri.rword_text, !ri.ltr) + "[" + std::to_string(ri.rword_box.width()) +
121                    (ri.rword_likely_starts_idea ? "S" : "s") +
122                    (ri.rword_likely_ends_idea ? "E" : "e") +
123                    (ri.rword_indicates_list_item ? "L" : "l") + "]");
124      rows[i].AppendDebugInfo(theory, row);
125      row.push_back(RtlEmbed(ri.text, !ri.ltr));
126    }
127    PrintTable(output, " ");
128    tprintf("Active Paragraph Models:\n");
129    unsigned m = 0;
130    for (const auto &model : theory.models()) {
131      tprintf(" %d: %s\n", ++m, model->ToString().c_str());
132    }
133  }
134  static void DebugDump(bool should_print, const char *phase, const ParagraphTheory &theory,
135                        const std::vector<RowScratchRegisters> &rows) {
136    if (!should_print) {
137      return;
138    }
139    tprintf("# %s\n", phase);
140    PrintDetectorState(theory, rows);
141  }
142  static void PrintRowRange(const std::vector<RowScratchRegisters> &rows, int row_start,
143                            int row_end) {
144    tprintf("======================================\n");
145    for (int row = row_start; row < row_end; row++) {
146      tprintf("%s\n", rows[row].ri_->text.c_str());
147    }
148    tprintf("======================================\n");
149  }
150  static bool IsLatinLetter(int ch) {
151    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
152  }
153  static bool IsDigitLike(int ch) {
154    return ch == 'o' || ch == 'O' || ch == 'l' || ch == 'I';
155  }
156  static bool IsOpeningPunct(int ch) {
157    return strchr("'\"({[", ch) != nullptr;
158  }
159  static bool IsTerminalPunct(int ch) {
160    return strchr(":'\".?!]})", ch) != nullptr;
161  }
162  static const char *SkipChars(const char *str, const char *toskip) {
163    while (*str != '\0' && strchr(toskip, *str)) {
164      str++;
165    }
166    return str;
167  }
168  static const char *SkipChars(const char *str, bool (*skip)(int)) {
169    while (*str != '\0' && skip(*str)) {
170      str++;
171    }
172    return str;
173  }
174  static const char *SkipOne(const char *str, const char *toskip) {
175    if (*str != '\0' && strchr(toskip, *str)) {
176      return str + 1;
177    }
178    return str;
179  }
180  static bool LikelyListNumeral(const std::string &word) {
181    const char *kRomans = "ivxlmdIVXLMD";
182    const char *kDigits = "012345789";
183    const char *kOpen = "[{(";
184    const char *kSep = ":;-.,";
185    const char *kClose = "]})";
186    int num_segments = 0;
187    const char *pos = word.c_str();
188    while (*pos != '\0' && num_segments < 3) {
189      const char *numeral_start = SkipOne(SkipOne(pos, kOpen), kOpen);
190      const char *numeral_end = SkipChars(numeral_start, kRomans);
191      if (numeral_end != numeral_start) {
192      } else {
193        numeral_end = SkipChars(numeral_start, kDigits);
194        if (numeral_end == numeral_start) {
195          numeral_end = SkipChars(numeral_start, IsLatinLetter);
196          if (numeral_end - numeral_start != 1) {
197            break;
198          }
199        }
200      }
201      num_segments++;
202      pos = SkipChars(SkipChars(numeral_end, kClose), kSep);
203      if (pos == numeral_end) {
204        break;
205      }
206    }
207    return *pos == '\0';
208  }
209  static bool LikelyListMark(const std::string &word) {
210    const char *kListMarks = "0Oo*.,+.";
211    return word.size() == 1 && strchr(kListMarks, word[0]) != nullptr;
212  }
213  bool AsciiLikelyListItem(const std::string &word) {
214    return LikelyListMark(word) || LikelyListNumeral(word);
215  }
216  static int UnicodeFor(const UNICHARSET *u, const WERD_CHOICE *werd, unsigned pos) {
217    if (!u || !werd || pos > werd->length()) {
218      return 0;
219    }
220    return UNICHAR(u->id_to_unichar(werd->unichar_id(pos)), -1).first_uni();
221  }
222  class UnicodeSpanSkipper {
223  public:
224    UnicodeSpanSkipper(const UNICHARSET *unicharset, const WERD_CHOICE *word)
225        : u_(unicharset), word_(word), wordlen_(word->length()) {
226    }
227    unsigned SkipPunc(unsigned pos);
228    unsigned SkipDigits(unsigned pos);
229    unsigned SkipRomans(unsigned pos);
230    unsigned SkipAlpha(unsigned pos);
231  private:
232    const UNICHARSET *u_;
233    const WERD_CHOICE *word_;
234    unsigned wordlen_;
235  };
236  unsigned UnicodeSpanSkipper::SkipPunc(unsigned pos) {
237    while (pos < wordlen_ && u_->get_ispunctuation(word_->unichar_id(pos))) {
238      pos++;
239    }
240    return pos;
241  }
242  unsigned UnicodeSpanSkipper::SkipDigits(unsigned pos) {
243    while (pos < wordlen_ &&
244           (u_->get_isdigit(word_->unichar_id(pos)) || IsDigitLike(UnicodeFor(u_, word_, pos)))) {
245      pos++;
246    }
247    return pos;
248  }
249  unsigned UnicodeSpanSkipper::SkipRomans(unsigned pos) {
250    const char *kRomans = "ivxlmdIVXLMD";
251    while (pos < wordlen_) {
252      int ch = UnicodeFor(u_, word_, pos);
253      if (ch >= 0xF0 || strchr(kRomans, ch) == nullptr) {
254        break;
255      }
256      pos++;
257    }
258    return pos;
259  }
260  unsigned UnicodeSpanSkipper::SkipAlpha(unsigned pos) {
261    while (pos < wordlen_ && u_->get_isalpha(word_->unichar_id(pos))) {
262      pos++;
263    }
264    return pos;
265  }
266  static bool LikelyListMarkUnicode(int ch) {
267    if (ch < 0x80) {
268      std::string single_ch;
269      single_ch += ch;
270      return LikelyListMark(single_ch);
271    }
272    switch (ch) {
273      case 0x00B0: 
274      case 0x2022: 
275      case 0x25E6: 
276      case 0x00B7: 
277      case 0x25A1: 
278      case 0x25A0: 
279      case 0x25AA: 
280      case 0x2B1D: 
281      case 0x25BA: 
282      case 0x25CF: 
283      case 0x25CB: 
284        return true;
285      default:
286        break; 
287    }
288    return false;
289  }
290  static bool UniLikelyListItem(const UNICHARSET *u, const WERD_CHOICE *werd) {
291    if (werd->length() == 1 && LikelyListMarkUnicode(UnicodeFor(u, werd, 0))) {
292      return true;
293    }
294    UnicodeSpanSkipper m(u, werd);
295    int num_segments = 0;
296    unsigned pos = 0;
297    while (pos < werd->length() && num_segments < 3) {
298      auto numeral_start = m.SkipPunc(pos);
299      if (numeral_start > pos + 1) {
300        break;
301      }
302      auto numeral_end = m.SkipRomans(numeral_start);
303      if (numeral_end == numeral_start) {
304        numeral_end = m.SkipDigits(numeral_start);
305        if (numeral_end == numeral_start) {
306          numeral_end = m.SkipAlpha(numeral_start);
307          if (numeral_end - numeral_start != 1) {
308            break;
309          }
310        }
311      }
312      num_segments++;
313      pos = m.SkipPunc(numeral_end);
314      if (pos == numeral_end) {
315        break;
316      }
317    }
318    return pos == werd->length();
319  }
320  template<class T>
321  void push_back_new(std::vector<T> &vector, const T &data) {
322    if (std::find(vector.begin(), vector.end(), data) == vector.end()) {
323      vector.push_back(data);
324    }
325  }
326  void LeftWordAttributes(const UNICHARSET *unicharset, const WERD_CHOICE *werd, const std::string &utf8,
327                          bool *is_list, bool *starts_idea, bool *ends_idea) {
328    *is_list = false;
329    *starts_idea = false;
330    *ends_idea = false;
331    if (utf8.empty() || (werd != nullptr && werd->empty())) { 
332      *ends_idea = true;
333      return;
334    }
335    if (unicharset && werd) { 
336      if (UniLikelyListItem(unicharset, werd)) {
337        *is_list = true;
338        *starts_idea = true;
339        *ends_idea = true;
340      }
341      if (unicharset->get_isupper(werd->unichar_id(0))) {
342        *starts_idea = true;
343      }
344      if (unicharset->get_ispunctuation(werd->unichar_id(0))) {
345        *starts_idea = true;
346        *ends_idea = true;
347      }
348    } else { 
349      if (AsciiLikelyListItem(utf8)) {
350        *is_list = true;
351        *starts_idea = true;
352      }
353      int start_letter = utf8[0];
354      if (IsOpeningPunct(start_letter)) {
355        *starts_idea = true;
356      }
357      if (IsTerminalPunct(start_letter)) {
358        *ends_idea = true;
359      }
360      if (start_letter >= 'A' && start_letter <= 'Z') {
361        *starts_idea = true;
362      }
363    }
364  }
365  void RightWordAttributes(const UNICHARSET *unicharset, const WERD_CHOICE *werd, const std::string &utf8,
366                           bool *is_list, bool *starts_idea, bool *ends_idea) {
367    *is_list = false;
368    *starts_idea = false;
369    *ends_idea = false;
370    if (utf8.empty() || (werd != nullptr && werd->empty())) { 
371      *ends_idea = true;
372      return;
373    }
374    if (unicharset && werd) { 
375      if (UniLikelyListItem(unicharset, werd)) {
376        *is_list = true;
377        *starts_idea = true;
378      }
379      UNICHAR_ID last_letter = werd->unichar_id(werd->length() - 1);
380      if (unicharset->get_ispunctuation(last_letter)) {
381        *ends_idea = true;
382      }
383    } else { 
384      if (AsciiLikelyListItem(utf8)) {
385        *is_list = true;
386        *starts_idea = true;
387      }
388      int last_letter = utf8[utf8.size() - 1];
389      if (IsOpeningPunct(last_letter) || IsTerminalPunct(last_letter)) {
390        *ends_idea = true;
391      }
392    }
393  }
394  void RowScratchRegisters::AppendDebugHeaderFields(std::vector<std::string> &header) {
395    header.emplace_back("[lmarg,lind;rind,rmarg]");
396    header.emplace_back("model");
397  }
398  void RowScratchRegisters::AppendDebugInfo(const ParagraphTheory &theory,
399                                            std::vector<std::string> &dbg) const {
400    char s[60];
401    snprintf(s, sizeof(s), "[%4d,%5d;%5d,%4d]", lmargin_, lindent_, rindent_, rmargin_);
402    dbg.emplace_back(s);
403    std::string model_string;
404    model_string += static_cast<char>(GetLineType());
405    model_string += ":";
406    int model_numbers = 0;
407    for (const auto &hypothese : hypotheses_) {
408      if (hypothese.model == nullptr) {
409        continue;
410      }
411      if (model_numbers > 0) {
412        model_string += ",";
413      }
414      if (StrongModel(hypothese.model)) {
415        model_string += std::to_string(1 + theory.IndexOf(hypothese.model));
416      } else if (hypothese.model == kCrownLeft) {
417        model_string += "CrL";
418      } else if (hypothese.model == kCrownRight) {
419        model_string += "CrR";
420      }
421      model_numbers++;
422    }
423    if (model_numbers == 0) {
424      model_string += "0";
425    }
426    dbg.push_back(model_string);
427  }
428  void RowScratchRegisters::Init(const RowInfo &row) {
429    ri_ = &row;
430    lmargin_ = 0;
431    lindent_ = row.pix_ldistance;
432    rmargin_ = 0;
433    rindent_ = row.pix_rdistance;
434  }
435  LineType RowScratchRegisters::GetLineType() const {
436    if (hypotheses_.empty()) {
437      return LT_UNKNOWN;
438    }
439    bool has_start = false;
440    bool has_body = false;
441    for (const auto &hypothese : hypotheses_) {
442      switch (hypothese.ty) {
443        case LT_START:
444          has_start = true;
445          break;
446        case LT_BODY:
447          has_body = true;
448          break;
449        default:
450          tprintf("Encountered bad value in hypothesis list: %c\n", hypothese.ty);
451          break;
452      }
453    }
454    if (has_start && has_body) {
455      return LT_MULTIPLE;
456    }
457    return has_start ? LT_START : LT_BODY;
458  }
459  LineType RowScratchRegisters::GetLineType(const ParagraphModel *model) const {
460    if (hypotheses_.empty()) {
461      return LT_UNKNOWN;
462    }
463    bool has_start = false;
464    bool has_body = false;
465    for (const auto &hypothese : hypotheses_) {
466      if (hypothese.model != model) {
467        continue;
468      }
469      switch (hypothese.ty) {
470        case LT_START:
471          has_start = true;
472          break;
473        case LT_BODY:
474          has_body = true;
475          break;
476        default:
477          tprintf("Encountered bad value in hypothesis list: %c\n", hypothese.ty);
478          break;
479      }
480    }
481    if (has_start && has_body) {
482      return LT_MULTIPLE;
483    }
484    return has_start ? LT_START : LT_BODY;
485  }
486  void RowScratchRegisters::SetStartLine() {
487    LineType current_lt = GetLineType();
488    if (current_lt != LT_UNKNOWN && current_lt != LT_START) {
489      tprintf("Trying to set a line to be START when it's already BODY.\n");
490    }
491    if (current_lt == LT_UNKNOWN || current_lt == LT_BODY) {
492      push_back_new(hypotheses_, LineHypothesis(LT_START, nullptr));
493    }
494  }
495  void RowScratchRegisters::SetBodyLine() {
496    LineType current_lt = GetLineType();
497    if (current_lt != LT_UNKNOWN && current_lt != LT_BODY) {
498      tprintf("Trying to set a line to be BODY when it's already START.\n");
499    }
500    if (current_lt == LT_UNKNOWN || current_lt == LT_START) {
501      push_back_new(hypotheses_, LineHypothesis(LT_BODY, nullptr));
502    }
503  }
504  void RowScratchRegisters::AddStartLine(const ParagraphModel *model) {
505    push_back_new(hypotheses_, LineHypothesis(LT_START, model));
506    auto found = std::find(hypotheses_.begin(), hypotheses_.end(), LineHypothesis(LT_START, nullptr));
507    if (found != hypotheses_.end()) {
508      hypotheses_.erase(found);
509    }
510  }
511  void RowScratchRegisters::AddBodyLine(const ParagraphModel *model) {
512    push_back_new(hypotheses_, LineHypothesis(LT_BODY, model));
513    auto found = std::find(hypotheses_.begin(), hypotheses_.end(), LineHypothesis(LT_BODY, nullptr));
514    if (found != hypotheses_.end()) {
515      hypotheses_.erase(found);
516    }
517  }
518  void RowScratchRegisters::StartHypotheses(SetOfModels *models) const {
519    for (const auto &hypothese : hypotheses_) {
520      if (hypothese.ty == LT_START && StrongModel(hypothese.model)) {
521        push_back_new(*models, hypothese.model);
522      }
523    }
524  }
525  void RowScratchRegisters::StrongHypotheses(SetOfModels *models) const {
526    for (const auto &hypothese : hypotheses_) {
527      if (StrongModel(hypothese.model)) {
528        push_back_new(*models, hypothese.model);
529      }
530    }
531  }
532  void RowScratchRegisters::NonNullHypotheses(SetOfModels *models) const {
533    for (const auto &hypothese : hypotheses_) {
534      if (hypothese.model != nullptr) {
535        push_back_new(*models, hypothese.model);
536      }
537    }
538  }
539  const ParagraphModel *RowScratchRegisters::UniqueStartHypothesis() const {
540    if (hypotheses_.size() != 1 || hypotheses_[0].ty != LT_START) {
541      return nullptr;
542    }
543    return hypotheses_[0].model;
544  }
545  const ParagraphModel *RowScratchRegisters::UniqueBodyHypothesis() const {
546    if (hypotheses_.size() != 1 || hypotheses_[0].ty != LT_BODY) {
547      return nullptr;
548    }
549    return hypotheses_[0].model;
550  }
551  void RowScratchRegisters::DiscardNonMatchingHypotheses(const SetOfModels &models) {
552    if (models.empty()) {
553      return;
554    }
555    for (int h = hypotheses_.size() - 1; h >= 0; h--) {
556      if (!contains(models, hypotheses_[h].model)) {
557        hypotheses_.erase(hypotheses_.begin() + h);
558      }
559    }
560  }
561  struct Cluster {
562    Cluster() : center(0), count(0) {}
563    Cluster(int cen, int num) : center(cen), count(num) {}
564    int center; 
565    int count;  
566  };
567  class SimpleClusterer {
568  public:
569    explicit SimpleClusterer(int max_cluster_width) : max_cluster_width_(max_cluster_width) {}
570    void Add(int value) {
571      values_.push_back(value);
572    }
573    size_t size() const {
574      return values_.size();
575    }
576    void GetClusters(std::vector<Cluster> *clusters);
577  private:
578    int max_cluster_width_;
579    std::vector<int> values_;
580  };
581  static int ClosestCluster(const std::vector<Cluster> &clusters, int value) {
582    unsigned best_index = 0;
583    for (unsigned i = 0; i < clusters.size(); i++) {
584      if (abs(value - clusters[i].center) < abs(value - clusters[best_index].center)) {
585        best_index = i;
586      }
587    }
588    return best_index;
589  }
590  void SimpleClusterer::GetClusters(std::vector<Cluster> *clusters) {
591    clusters->clear();
592    std::sort(values_.begin(), values_.end());
593    for (unsigned i = 0; i < values_.size();) {
594      int orig_i = i;
595      int lo = values_[i];
596      int hi = lo;
597      while (++i < values_.size() && values_[i] <= lo + max_cluster_width_) {
598        hi = values_[i];
599      }
600      clusters->push_back(Cluster((hi + lo) / 2, i - orig_i));
601    }
602  }
603  static void CalculateTabStops(std::vector<RowScratchRegisters> *rows, int row_start, int row_end,
604                                int tolerance, std::vector<Cluster> *left_tabs,
605                                std::vector<Cluster> *right_tabs) {
606    if (!AcceptableRowArgs(0, 1, __func__, rows, row_start, row_end)) {
607      return;
608    }
609    SimpleClusterer initial_lefts(tolerance);
610    SimpleClusterer initial_rights(tolerance);
611    std::vector<Cluster> initial_left_tabs;
612    std::vector<Cluster> initial_right_tabs;
613    for (int i = row_start; i < row_end; i++) {
614      initial_lefts.Add((*rows)[i].lindent_);
615      initial_rights.Add((*rows)[i].rindent_);
616    }
617    initial_lefts.GetClusters(&initial_left_tabs);
618    initial_rights.GetClusters(&initial_right_tabs);
619    SimpleClusterer lefts(tolerance);
620    SimpleClusterer rights(tolerance);
621    int infrequent_enough_to_ignore = 0;
622    if (row_end - row_start >= 8) {
623      infrequent_enough_to_ignore = 1;
624    }
625    if (row_end - row_start >= 20) {
626      infrequent_enough_to_ignore = 2;
627    }
628    for (int i = row_start; i < row_end; i++) {
629      int lidx = ClosestCluster(initial_left_tabs, (*rows)[i].lindent_);
630      int ridx = ClosestCluster(initial_right_tabs, (*rows)[i].rindent_);
631      if (initial_left_tabs[lidx].count > infrequent_enough_to_ignore ||
632          initial_right_tabs[ridx].count > infrequent_enough_to_ignore) {
633        lefts.Add((*rows)[i].lindent_);
634        rights.Add((*rows)[i].rindent_);
635      }
636    }
637    lefts.GetClusters(left_tabs);
638    rights.GetClusters(right_tabs);
639    if ((left_tabs->size() == 1 && right_tabs->size() >= 4) ||
640        (right_tabs->size() == 1 && left_tabs->size() >= 4)) {
641      for (int i = row_start; i < row_end; i++) {
642        int lidx = ClosestCluster(initial_left_tabs, (*rows)[i].lindent_);
643        int ridx = ClosestCluster(initial_right_tabs, (*rows)[i].rindent_);
644        if (!(initial_left_tabs[lidx].count > infrequent_enough_to_ignore ||
645              initial_right_tabs[ridx].count > infrequent_enough_to_ignore)) {
646          lefts.Add((*rows)[i].lindent_);
647          rights.Add((*rows)[i].rindent_);
648        }
649      }
650    }
651    lefts.GetClusters(left_tabs);
652    rights.GetClusters(right_tabs);
653    if (left_tabs->size() == 3 && right_tabs->size() >= 4) {
654      int to_prune = -1;
655      for (int i = left_tabs->size() - 1; i >= 0; i--) {
656        if (to_prune < 0 || (*left_tabs)[i].count < (*left_tabs)[to_prune].count) {
657          to_prune = i;
658        }
659      }
660      if (to_prune >= 0 && (*left_tabs)[to_prune].count <= infrequent_enough_to_ignore) {
661        left_tabs->erase(left_tabs->begin() + to_prune);
662      }
663    }
664    if (right_tabs->size() == 3 && left_tabs->size() >= 4) {
665      int to_prune = -1;
666      for (int i = right_tabs->size() - 1; i >= 0; i--) {
667        if (to_prune < 0 || (*right_tabs)[i].count < (*right_tabs)[to_prune].count) {
668          to_prune = i;
669        }
670      }
671      if (to_prune >= 0 && (*right_tabs)[to_prune].count <= infrequent_enough_to_ignore) {
672        right_tabs->erase(right_tabs->begin() + to_prune);
673      }
674    }
675  }
676  static void MarkRowsWithModel(std::vector<RowScratchRegisters> *rows, int row_start, int row_end,
677                                const ParagraphModel *model, bool ltr, int eop_threshold) {
678    if (!AcceptableRowArgs(0, 0, __func__, rows, row_start, row_end)) {
679      return;
680    }
681    for (int row = row_start; row < row_end; row++) {
682      bool valid_first = ValidFirstLine(rows, row, model);
683      bool valid_body = ValidBodyLine(rows, row, model);
684      if (valid_first && !valid_body) {
685        (*rows)[row].AddStartLine(model);
686      } else if (valid_body && !valid_first) {
687        (*rows)[row].AddBodyLine(model);
688      } else if (valid_body && valid_first) {
689        bool after_eop = (row == row_start);
690        if (row > row_start) {
691          if (eop_threshold > 0) {
692            if (model->justification() == JUSTIFICATION_LEFT) {
693              after_eop = (*rows)[row - 1].rindent_ > eop_threshold;
694            } else {
695              after_eop = (*rows)[row - 1].lindent_ > eop_threshold;
696            }
697          } else {
698            after_eop = FirstWordWouldHaveFit((*rows)[row - 1], (*rows)[row], model->justification());
699          }
700        }
701        if (after_eop) {
702          (*rows)[row].AddStartLine(model);
703        } else {
704          (*rows)[row].AddBodyLine(model);
705        }
706      } else {
707      }
708    }
709  }
710  struct GeometricClassifierState {
711    GeometricClassifierState(int dbg_level, std::vector<RowScratchRegisters> *r, int r_start,
712                             int r_end)
713        : debug_level(dbg_level), rows(r), row_start(r_start), row_end(r_end) {
714      tolerance = InterwordSpace(*r, r_start, r_end);
715      CalculateTabStops(r, r_start, r_end, tolerance, &left_tabs, &right_tabs);
716      if (debug_level >= 3) {
717        tprintf(
718            "Geometry: TabStop cluster tolerance = %d; "
719            "%zu left tabs; %zu right tabs\n",
720            tolerance, left_tabs.size(), right_tabs.size());
721      }
722      ltr = (*r)[r_start].ri_->ltr;
723    }
724    void AssumeLeftJustification() {
725      just = tesseract::JUSTIFICATION_LEFT;
726      margin = (*rows)[row_start].lmargin_;
727    }
728    void AssumeRightJustification() {
729      just = tesseract::JUSTIFICATION_RIGHT;
730      margin = (*rows)[row_start].rmargin_;
731    }
732    const std::vector<Cluster> &AlignTabs() const {
733      if (just == tesseract::JUSTIFICATION_RIGHT) {
734        return right_tabs;
735      }
736      return left_tabs;
737    }
738    const std::vector<Cluster> &OffsideTabs() const {
739      if (just == tesseract::JUSTIFICATION_RIGHT) {
740        return left_tabs;
741      }
742      return right_tabs;
743    }
744    bool IsFullRow(int i) const {
745      return ClosestCluster(left_tabs, (*rows)[i].lindent_) == 0 &&
746             ClosestCluster(right_tabs, (*rows)[i].rindent_) == 0;
747    }
748    int AlignsideTabIndex(int row_idx) const {
749      return ClosestCluster(AlignTabs(), (*rows)[row_idx].AlignsideIndent(just));
750    }
751    bool FirstWordWouldHaveFit(int row_a, int row_b) {
752      return ::tesseract::FirstWordWouldHaveFit((*rows)[row_a], (*rows)[row_b], just);
753    }
754    void PrintRows() const {
755      PrintRowRange(*rows, row_start, row_end);
756    }
757    void Fail(int min_debug_level, const char *why) const {
758      if (debug_level < min_debug_level) {
759        return;
760      }
761      tprintf("# %s\n", why);
762      PrintRows();
763    }
764    ParagraphModel Model() const {
765      return ParagraphModel(just, margin, first_indent, body_indent, tolerance);
766    }
767    int debug_level = 0;
768    std::vector<RowScratchRegisters> *rows;
769    int row_start = 0;
770    int row_end = 0;
771    int tolerance = 0;
772    bool ltr = false;
773    std::vector<Cluster> left_tabs;
774    std::vector<Cluster> right_tabs;
775    tesseract::ParagraphJustification just = JUSTIFICATION_UNKNOWN;
776    int margin = 0;
777    int first_indent = 0;
778    int body_indent = 0;
779    int eop_threshold = 0;
780  };
781  static void GeometricClassifyThreeTabStopTextBlock(int debug_level, GeometricClassifierState &s,
782                                                     ParagraphTheory *theory) {
783    int num_rows = s.row_end - s.row_start;
784    int num_full_rows = 0;
785    int last_row_full = 0;
786    for (int i = s.row_start; i < s.row_end; i++) {
787      if (s.IsFullRow(i)) {
788        num_full_rows++;
789        if (i == s.row_end - 1) {
790          last_row_full++;
791        }
792      }
793    }
794    if (num_full_rows < 0.7 * num_rows) {
795      s.Fail(1, "Not enough full lines to know which lines start paras.");
796      return;
797    }
798    s.eop_threshold = 0;
799    if (s.ltr) {
800      s.AssumeLeftJustification();
801    } else {
802      s.AssumeRightJustification();
803    }
804    if (debug_level > 0) {
805      tprintf(
806          "# Not enough variety for clear outline classification. "
807          "Guessing these are %s aligned based on script.\n",
808          s.ltr ? "left" : "right");
809      s.PrintRows();
810    }
811    if (s.AlignTabs().size() == 2) { 
812      s.first_indent = s.AlignTabs()[1].center;
813      s.body_indent = s.AlignTabs()[0].center;
814    } else { 
815      if (num_rows - 1 == num_full_rows - last_row_full) {
816        const ParagraphModel *model = s.ltr ? kCrownLeft : kCrownRight;
817        (*s.rows)[s.row_start].AddStartLine(model);
818        for (int i = s.row_start + 1; i < s.row_end; i++) {
819          (*s.rows)[i].AddBodyLine(model);
820        }
821        return;
822      } else {
823        s.first_indent = s.body_indent = s.AlignTabs()[0].center;
824        s.eop_threshold = (s.OffsideTabs()[0].center + s.OffsideTabs()[1].center) / 2;
825      }
826    }
827    const ParagraphModel *model = theory->AddModel(s.Model());
828    MarkRowsWithModel(s.rows, s.row_start, s.row_end, model, s.ltr, s.eop_threshold);
829    return;
830  }
831  static void GeometricClassify(int debug_level, std::vector<RowScratchRegisters> *rows,
832                                int row_start, int row_end, ParagraphTheory *theory) {
833    if (!AcceptableRowArgs(debug_level, 4, __func__, rows, row_start, row_end)) {
834      return;
835    }
836    if (debug_level > 1) {
837      tprintf("###############################################\n");
838      tprintf("##### GeometricClassify( rows[%d:%d) )   ####\n", row_start, row_end);
839      tprintf("###############################################\n");
840    }
841    RecomputeMarginsAndClearHypotheses(rows, row_start, row_end, 10);
842    GeometricClassifierState s(debug_level, rows, row_start, row_end);
843    if (s.left_tabs.size() > 2 && s.right_tabs.size() > 2) {
844      s.Fail(2, "Too much variety for simple outline classification.");
845      return;
846    }
847    if (s.left_tabs.size() <= 1 && s.right_tabs.size() <= 1) {
848      s.Fail(1, "Not enough variety for simple outline classification.");
849      return;
850    }
851    if (s.left_tabs.size() + s.right_tabs.size() == 3) {
852      GeometricClassifyThreeTabStopTextBlock(debug_level, s, theory);
853      return;
854    }
855    if (s.right_tabs.size() > 2) {
856      s.AssumeLeftJustification();
857    } else if (s.left_tabs.size() > 2) {
858      s.AssumeRightJustification();
859    } else if (s.ltr) { 
860      s.AssumeLeftJustification();
861    } else {
862      s.AssumeRightJustification();
863    }
864    if (s.AlignTabs().size() == 2) {
865      int firsts[2] = {0, 0};
866      firsts[s.AlignsideTabIndex(s.row_start)]++;
867      bool jam_packed = true;
868      for (int i = s.row_start + 1; i < s.row_end; i++) {
869        if (s.FirstWordWouldHaveFit(i - 1, i)) {
870          firsts[s.AlignsideTabIndex(i)]++;
871          jam_packed = false;
872        }
873      }
874      if (jam_packed && s.FirstWordWouldHaveFit(s.row_end - 1, s.row_end - 1)) {
875        firsts[1 - s.AlignsideTabIndex(s.row_end - 1)]++;
876      }
877      int percent0firsts, percent1firsts;
878      percent0firsts = (100 * firsts[0]) / s.AlignTabs()[0].count;
879      percent1firsts = (100 * firsts[1]) / s.AlignTabs()[1].count;
880      if ((percent0firsts < 20 && 30 < percent1firsts) || percent0firsts + 30 < percent1firsts) {
881        s.first_indent = s.AlignTabs()[1].center;
882        s.body_indent = s.AlignTabs()[0].center;
883      } else if ((percent1firsts < 20 && 30 < percent0firsts) ||
884                 percent1firsts + 30 < percent0firsts) {
885        s.first_indent = s.AlignTabs()[0].center;
886        s.body_indent = s.AlignTabs()[1].center;
887      } else {
888        if (debug_level > 1) {
889          tprintf("# Cannot determine %s indent likely to start paragraphs.\n",
890                  s.just == tesseract::JUSTIFICATION_LEFT ? "left" : "right");
891          tprintf("# Indent of %d looks like a first line %d%% of the time.\n",
892                  s.AlignTabs()[0].center, percent0firsts);
893          tprintf("# Indent of %d looks like a first line %d%% of the time.\n",
894                  s.AlignTabs()[1].center, percent1firsts);
895          s.PrintRows();
896        }
897        return;
898      }
899    } else {
900      s.first_indent = s.body_indent = s.AlignTabs()[0].center;
901    }
902    const ParagraphModel *model = theory->AddModel(s.Model());
903    s.eop_threshold = (s.OffsideTabs()[0].center + s.OffsideTabs()[1].center) / 2;
904    if (s.AlignTabs().size() == 2) {
905      for (int i = s.row_start; i < s.row_end - 1; i++) {
906        if (ValidFirstLine(s.rows, i + 1, model) &&
907            !NearlyEqual(s.OffsideTabs()[0].center, (*s.rows)[i].OffsideIndent(s.just),
908                         s.tolerance)) {
909          s.eop_threshold = 0;
910          break;
911        }
912      }
913    } else {
914      for (int i = s.row_start; i < s.row_end - 1; i++) {
915        if (!s.FirstWordWouldHaveFit(i, i + 1) &&
916            !NearlyEqual(s.OffsideTabs()[0].center, (*s.rows)[i].OffsideIndent(s.just),
917                         s.tolerance)) {
918          s.eop_threshold = 0;
919          break;
920        }
921      }
922    }
923    MarkRowsWithModel(rows, row_start, row_end, model, s.ltr, s.eop_threshold);
924  }
925  const ParagraphModel *ParagraphTheory::AddModel(const ParagraphModel &model) {
926    for (const auto &m : *models_) {
927      if (m->Comparable(model)) {
928        return m;
929      }
930    }
931    auto *m = new ParagraphModel(model);
932    models_->push_back(m);
933    push_back_new(models_we_added_, m);
934    return m;
935  }
936  void ParagraphTheory::DiscardUnusedModels(const SetOfModels &used_models) {
937    size_t w = 0;
938    for (size_t r = 0; r < models_->size(); r++) {
939      ParagraphModel *m = (*models_)[r];
940      if (!contains(used_models, static_cast<const ParagraphModel *>(m)) && contains(models_we_added_, m)) {
941        delete m;
942      } else {
943        if (r > w) {
944          (*models_)[w] = m;
945        }
946        w++;
947      }
948    }
949    models_->resize(w);
950  }
951  const ParagraphModel *ParagraphTheory::Fits(const std::vector<RowScratchRegisters> *rows,
952                                              int start, int end) const {
953    for (const auto *model : *models_) {
954      if (model->justification() != JUSTIFICATION_CENTER && RowsFitModel(rows, start, end, model)) {
955        return model;
956      }
957    }
958    return nullptr;
959  }
960  void ParagraphTheory::NonCenteredModels(SetOfModels *models) {
961    for (const auto *model : *models_) {
962      if (model->justification() != JUSTIFICATION_CENTER) {
963        push_back_new(*models, model);
964      }
965    }
966  }
967  int ParagraphTheory::IndexOf(const ParagraphModel *model) const {
968    int i = 0;
969    for (const auto *m : *models_) {
970      if (m == model) {
971        return i;
972      }
973      i++;
974    }
975    return -1;
976  }
977  bool ValidFirstLine(const std::vector<RowScratchRegisters> *rows, int row,
978                      const ParagraphModel *model) {
979    if (!StrongModel(model)) {
980      tprintf("ValidFirstLine() should only be called with strong models!\n");
981    }
982    return StrongModel(model) && model->ValidFirstLine((*rows)[row].lmargin_, (*rows)[row].lindent_,
983                                                       (*rows)[row].rindent_, (*rows)[row].rmargin_);
984  }
985  bool ValidBodyLine(const std::vector<RowScratchRegisters> *rows, int row,
986                     const ParagraphModel *model) {
987    if (!StrongModel(model)) {
988      tprintf("ValidBodyLine() should only be called with strong models!\n");
989    }
990    return StrongModel(model) && model->ValidBodyLine((*rows)[row].lmargin_, (*rows)[row].lindent_,
991                                                      (*rows)[row].rindent_, (*rows)[row].rmargin_);
992  }
993  bool CrownCompatible(const std::vector<RowScratchRegisters> *rows, int a, int b,
994                       const ParagraphModel *model) {
995    if (model != kCrownRight && model != kCrownLeft) {
996      tprintf("CrownCompatible() should only be called with crown models!\n");
997      return false;
998    }
999    auto &row_a = (*rows)[a];
1000    auto &row_b = (*rows)[b];
1001    if (model == kCrownRight) {
1002      return NearlyEqual(row_a.rindent_ + row_a.rmargin_, row_b.rindent_ + row_b.rmargin_,
1003                         Epsilon(row_a.ri_->average_interword_space));
1004    }
1005    return NearlyEqual(row_a.lindent_ + row_a.lmargin_, row_b.lindent_ + row_b.lmargin_,
1006                       Epsilon(row_a.ri_->average_interword_space));
1007  }
1008  ParagraphModelSmearer::ParagraphModelSmearer(std::vector<RowScratchRegisters> *rows,
1009                                               int row_start, int row_end, ParagraphTheory *theory)
1010      : theory_(theory), rows_(rows), row_start_(row_start), row_end_(row_end) {
1011    if (!AcceptableRowArgs(0, 0, __func__, rows, row_start, row_end)) {
1012      row_start_ = 0;
1013      row_end_ = 0;
1014      return;
1015    }
1016    open_models_.resize(open_models_.size() + row_end - row_start + 2);
1017  }
1018  void ParagraphModelSmearer::CalculateOpenModels(int row_start, int row_end) {
1019    SetOfModels no_models;
1020    if (row_start < row_start_) {
1021      row_start = row_start_;
1022    }
1023    if (row_end > row_end_) {
1024      row_end = row_end_;
1025    }
1026    for (int row = (row_start > 0) ? row_start - 1 : row_start; row < row_end; row++) {
1027      if ((*rows_)[row].ri_->num_words == 0) {
1028        OpenModels(row + 1) = no_models;
1029      } else {
1030        SetOfModels &opened = OpenModels(row);
1031        (*rows_)[row].StartHypotheses(&opened);
1032        SetOfModels still_open;
1033        for (auto &m : opened) {
1034          if (ValidFirstLine(rows_, row, m) || ValidBodyLine(rows_, row, m)) {
1035            push_back_new(still_open, m);
1036          }
1037        }
1038        OpenModels(row + 1) = still_open;
1039      }
1040    }
1041  }
1042  void ParagraphModelSmearer::Smear() {
1043    CalculateOpenModels(row_start_, row_end_);
1044    for (int i = row_start_; i < row_end_; i++) {
1045      RowScratchRegisters &row = (*rows_)[i];
1046      if (row.ri_->num_words == 0) {
1047        continue;
1048      }
1049      bool left_align_open = false;
1050      bool right_align_open = false;
1051      for (auto &m : OpenModels(i)) {
1052        switch (m->justification()) {
1053          case JUSTIFICATION_LEFT:
1054            left_align_open = true;
1055            break;
1056          case JUSTIFICATION_RIGHT:
1057            right_align_open = true;
1058            break;
1059          default:
1060            left_align_open = right_align_open = true;
1061        }
1062      }
1063      bool likely_start;
1064      if (i == 0) {
1065        likely_start = true;
1066      } else {
1067        if ((left_align_open && right_align_open) || (!left_align_open && !right_align_open)) {
1068          likely_start = LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_LEFT) ||
1069                         LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_RIGHT);
1070        } else if (left_align_open) {
1071          likely_start = LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_LEFT);
1072        } else {
1073          likely_start = LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_RIGHT);
1074        }
1075      }
1076      if (likely_start) {
1077        for (unsigned m = 0; m < OpenModels(i).size(); m++) {
1078          if (ValidFirstLine(rows_, i, OpenModels(i)[m])) {
1079            row.AddStartLine(OpenModels(i)[m]);
1080          }
1081        }
1082      } else {
1083        SetOfModels last_line_models;
1084        if (i > 0) {
1085          (*rows_)[i - 1].StrongHypotheses(&last_line_models);
1086        } else {
1087          theory_->NonCenteredModels(&last_line_models);
1088        }
1089        for (auto model : last_line_models) {
1090          if (ValidBodyLine(rows_, i, model)) {
1091            row.AddBodyLine(model);
1092          }
1093        }
1094      }
1095      if (row.GetLineType() == LT_UNKNOWN ||
1096          (row.GetLineType() == LT_START && !row.UniqueStartHypothesis())) {
1097        SetOfModels all_models;
1098        theory_->NonCenteredModels(&all_models);
1099        for (auto &all_model : all_models) {
1100          if (ValidFirstLine(rows_, i, all_model)) {
1101            row.AddStartLine(all_model);
1102          }
1103        }
1104      }
1105      if (row.GetLineType() != LT_UNKNOWN) {
1106        CalculateOpenModels(i + 1, row_end_);
1107      }
1108    }
1109  }
1110  static void DiscardUnusedModels(const std::vector<RowScratchRegisters> &rows,
1111                                  ParagraphTheory *theory) {
1112    SetOfModels used_models;
1113    for (const auto &row : rows) {
1114      row.StrongHypotheses(&used_models);
1115    }
1116    theory->DiscardUnusedModels(used_models);
1117  }
1118  static void DowngradeWeakestToCrowns(int debug_level, ParagraphTheory *theory,
1119                                       std::vector<RowScratchRegisters> *rows) {
1120    int start;
1121    for (int end = rows->size(); end > 0; end = start) {
1122      const ParagraphModel *model = nullptr;
1123      while (end > 0 && (model = (*rows)[end - 1].UniqueBodyHypothesis()) == nullptr) {
1124        end--;
1125      }
1126      if (end == 0) {
1127        break;
1128      }
1129      start = end - 1;
1130      while (start >= 0 && (*rows)[start].UniqueBodyHypothesis() == model) {
1131        start--; 
1132      }
1133      if (start >= 0 && (*rows)[start].UniqueStartHypothesis() == model && StrongModel(model) &&
1134          NearlyEqual(model->first_indent(), model->body_indent(), model->tolerance())) {
1135        start--;
1136      }
1137      start++;
1138      if (StrongModel(model) && model->justification() == JUSTIFICATION_CENTER) {
1139        continue;
1140      }
1141      if (!StrongModel(model)) {
1142        while (start > 0 && CrownCompatible(rows, start - 1, start, model)) {
1143          start--;
1144        }
1145      }
1146      if (start == 0 || (!StrongModel(model)) ||
1147          (StrongModel(model) && !ValidFirstLine(rows, start - 1, model))) {
1148        const ParagraphModel *crown_model = model;
1149        if (StrongModel(model)) {
1150          if (model->justification() == JUSTIFICATION_LEFT) {
1151            crown_model = kCrownLeft;
1152          } else {
1153            crown_model = kCrownRight;
1154          }
1155        }
1156        (*rows)[start].SetUnknown();
1157        (*rows)[start].AddStartLine(crown_model);
1158        for (int row = start + 1; row < end; row++) {
1159          (*rows)[row].SetUnknown();
1160          (*rows)[row].AddBodyLine(crown_model);
1161        }
1162      }
1163    }
1164    DiscardUnusedModels(*rows, theory);
1165  }
1166  void RecomputeMarginsAndClearHypotheses(std::vector<RowScratchRegisters> *rows, int start,
1167                                          int end, int percentile) {
1168    if (!AcceptableRowArgs(0, 0, __func__, rows, start, end)) {
1169      return;
1170    }
1171    int lmin, lmax, rmin, rmax;
1172    lmin = lmax = (*rows)[start].lmargin_ + (*rows)[start].lindent_;
1173    rmin = rmax = (*rows)[start].rmargin_ + (*rows)[start].rindent_;
1174    for (int i = start; i < end; i++) {
1175      RowScratchRegisters &sr = (*rows)[i];
1176      sr.SetUnknown();
1177      if (sr.ri_->num_words == 0) {
1178        continue;
1179      }
1180      UpdateRange(sr.lmargin_ + sr.lindent_, &lmin, &lmax);
1181      UpdateRange(sr.rmargin_ + sr.rindent_, &rmin, &rmax);
1182    }
1183    STATS lefts(lmin, lmax);
1184    STATS rights(rmin, rmax);
1185    for (int i = start; i < end; i++) {
1186      RowScratchRegisters &sr = (*rows)[i];
1187      if (sr.ri_->num_words == 0) {
1188        continue;
1189      }
1190      lefts.add(sr.lmargin_ + sr.lindent_, 1);
1191      rights.add(sr.rmargin_ + sr.rindent_, 1);
1192    }
1193    int ignorable_left = lefts.ile(ClipToRange(percentile, 0, 100) / 100.0);
1194    int ignorable_right = rights.ile(ClipToRange(percentile, 0, 100) / 100.0);
1195    for (int i = start; i < end; i++) {
1196      RowScratchRegisters &sr = (*rows)[i];
1197      int ldelta = ignorable_left - sr.lmargin_;
1198      sr.lmargin_ += ldelta;
1199      sr.lindent_ -= ldelta;
1200      int rdelta = ignorable_right - sr.rmargin_;
1201      sr.rmargin_ += rdelta;
1202      sr.rindent_ -= rdelta;
1203    }
1204  }
1205  int InterwordSpace(const std::vector<RowScratchRegisters> &rows, int row_start, int row_end) {
1206    if (row_end < row_start + 1) {
1207      return 1;
1208    }
1209    int word_height =
1210        (rows[row_start].ri_->lword_box.height() + rows[row_end - 1].ri_->lword_box.height()) / 2;
1211    int word_width =
1212        (rows[row_start].ri_->lword_box.width() + rows[row_end - 1].ri_->lword_box.width()) / 2;
1213    STATS spacing_widths(0, 4 + word_width);
1214    for (int i = row_start; i < row_end; i++) {
1215      if (rows[i].ri_->num_words > 1) {
1216        spacing_widths.add(rows[i].ri_->average_interword_space, 1);
1217      }
1218    }
1219    int minimum_reasonable_space = word_height / 3;
1220    if (minimum_reasonable_space < 2) {
1221      minimum_reasonable_space = 2;
1222    }
1223    int median = spacing_widths.median();
1224    return (median > minimum_reasonable_space) ? median : minimum_reasonable_space;
1225  }
1226  bool FirstWordWouldHaveFit(const RowScratchRegisters &before, const RowScratchRegisters &after,
1227                             tesseract::ParagraphJustification justification) {
1228    if (before.ri_->num_words == 0 || after.ri_->num_words == 0) {
1229      return true;
1230    }
1231    if (justification == JUSTIFICATION_UNKNOWN) {
1232      tprintf("Don't call FirstWordWouldHaveFit(r, s, JUSTIFICATION_UNKNOWN).\n");
1233    }
1234    int available_space;
1235    if (justification == JUSTIFICATION_CENTER) {
1236      available_space = before.lindent_ + before.rindent_;
1237    } else {
1238      available_space = before.OffsideIndent(justification);
1239    }
1240    available_space -= before.ri_->average_interword_space;
1241    if (before.ri_->ltr) {
1242      return after.ri_->lword_box.width() < available_space;
1243    }
1244    return after.ri_->rword_box.width() < available_space;
1245  }
1246  bool FirstWordWouldHaveFit(const RowScratchRegisters &before, const RowScratchRegisters &after) {
1247    if (before.ri_->num_words == 0 || after.ri_->num_words == 0) {
1248      return true;
1249    }
1250    int available_space = before.lindent_;
1251    if (before.rindent_ > available_space) {
1252      available_space = before.rindent_;
1253    }
1254    available_space -= before.ri_->average_interword_space;
1255    if (before.ri_->ltr) {
1256      return after.ri_->lword_box.width() < available_space;
1257    }
1258    return after.ri_->rword_box.width() < available_space;
1259  }
1260  static bool TextSupportsBreak(const RowScratchRegisters &before, const RowScratchRegisters &after) {
1261    if (before.ri_->ltr) {
1262      return before.ri_->rword_likely_ends_idea && after.ri_->lword_likely_starts_idea;
1263    } else {
1264      return before.ri_->lword_likely_ends_idea && after.ri_->rword_likely_starts_idea;
1265    }
1266  }
1267  static bool LikelyParagraphStart(const RowScratchRegisters &before,
1268                                   const RowScratchRegisters &after,
1269                                   tesseract::ParagraphJustification j) {
1270    return before.ri_->num_words == 0 ||
1271           (FirstWordWouldHaveFit(before, after, j) && TextSupportsBreak(before, after));
1272  }
1273  static ParagraphModel InternalParagraphModelByOutline(
1274      const std::vector<RowScratchRegisters> *rows, int start, int end, int tolerance,
1275      bool *consistent) {
1276    int ltr_line_count = 0;
1277    for (int i = start; i < end; i++) {
1278      ltr_line_count += static_cast<int>((*rows)[i].ri_->ltr);
1279    }
1280    bool ltr = (ltr_line_count >= (end - start) / 2);
1281    *consistent = true;
1282    if (!AcceptableRowArgs(0, 2, __func__, rows, start, end)) {
1283      return ParagraphModel();
1284    }
1285    int lmargin = (*rows)[start].lmargin_;
1286    int rmargin = (*rows)[start].rmargin_;
1287    int lmin, lmax, rmin, rmax, cmin, cmax;
1288    lmin = lmax = (*rows)[start + 1].lindent_;
1289    rmin = rmax = (*rows)[start + 1].rindent_;
1290    cmin = cmax = 0;
1291    for (int i = start + 1; i < end; i++) {
1292      if ((*rows)[i].lmargin_ != lmargin || (*rows)[i].rmargin_ != rmargin) {
1293        tprintf("Margins don't match! Software error.\n");
1294        *consistent = false;
1295        return ParagraphModel();
1296      }
1297      UpdateRange((*rows)[i].lindent_, &lmin, &lmax);
1298      UpdateRange((*rows)[i].rindent_, &rmin, &rmax);
1299      UpdateRange((*rows)[i].rindent_ - (*rows)[i].lindent_, &cmin, &cmax);
1300    }
1301    int ldiff = lmax - lmin;
1302    int rdiff = rmax - rmin;
1303    int cdiff = cmax - cmin;
1304    if (rdiff > tolerance && ldiff > tolerance) {
1305      if (cdiff < tolerance * 2) {
1306        if (end - start < 3) {
1307          return ParagraphModel();
1308        }
1309        return ParagraphModel(JUSTIFICATION_CENTER, 0, 0, 0, tolerance);
1310      }
1311      *consistent = false;
1312      return ParagraphModel();
1313    }
1314    if (end - start < 3) { 
1315      return ParagraphModel();
1316    }
1317    bool body_admits_left_alignment = ldiff < tolerance;
1318    bool body_admits_right_alignment = rdiff < tolerance;
1319    ParagraphModel left_model = ParagraphModel(JUSTIFICATION_LEFT, lmargin, (*rows)[start].lindent_,
1320                                               (lmin + lmax) / 2, tolerance);
1321    ParagraphModel right_model = ParagraphModel(JUSTIFICATION_RIGHT, rmargin, (*rows)[start].rindent_,
1322                                                (rmin + rmax) / 2, tolerance);
1323    bool text_admits_left_alignment = ltr || left_model.is_flush();
1324    bool text_admits_right_alignment = !ltr || right_model.is_flush();
1325    if (tolerance < rdiff) {
1326      if (body_admits_left_alignment && text_admits_left_alignment) {
1327        return left_model;
1328      }
1329      *consistent = false;
1330      return ParagraphModel();
1331    }
1332    if (tolerance < ldiff) {
1333      if (body_admits_right_alignment && text_admits_right_alignment) {
1334        return right_model;
1335      }
1336      *consistent = false;
1337      return ParagraphModel();
1338    }
1339    int first_left = (*rows)[start].lindent_;
1340    int first_right = (*rows)[start].rindent_;
1341    if (ltr && body_admits_left_alignment && (first_left < lmin || first_left > lmax)) {
1342      return left_model;
1343    }
1344    if (!ltr && body_admits_right_alignment && (first_right < rmin || first_right > rmax)) {
1345      return right_model;
1346    }
1347    *consistent = false;
1348    return ParagraphModel();
1349  }
1350  static ParagraphModel ParagraphModelByOutline(int debug_level,
1351                                                const std::vector<RowScratchRegisters> *rows,
1352                                                int start, int end, int tolerance) {
1353    bool unused_consistent;
1354    ParagraphModel retval =
1355        InternalParagraphModelByOutline(rows, start, end, tolerance, &unused_consistent);
1356    if (debug_level >= 2 && retval.justification() == JUSTIFICATION_UNKNOWN) {
1357      tprintf("Could not determine a model for this paragraph:\n");
1358      PrintRowRange(*rows, start, end);
1359    }
1360    return retval;
1361  }
1362  bool RowsFitModel(const std::vector<RowScratchRegisters> *rows, int start, int end,
1363                    const ParagraphModel *model) {
1364    if (!AcceptableRowArgs(0, 1, __func__, rows, start, end)) {
1365      return false;
1366    }
1367    if (!ValidFirstLine(rows, start, model)) {
1368      return false;
1369    }
1370    for (int i = start + 1; i < end; i++) {
1371      if (!ValidBodyLine(rows, i, model)) {
1372        return false;
1373      }
1374    }
1375    return true;
1376  }
1377  static void MarkStrongEvidence(std::vector<RowScratchRegisters> *rows, int row_start,
1378                                 int row_end) {
1379    for (int i = row_start + 1; i < row_end; i++) {
1380      const RowScratchRegisters &prev = (*rows)[i - 1];
1381      RowScratchRegisters &curr = (*rows)[i];
1382      tesseract::ParagraphJustification typical_justification =
1383          prev.ri_->ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1384      if (!curr.ri_->rword_likely_starts_idea && !curr.ri_->lword_likely_starts_idea &&
1385          !FirstWordWouldHaveFit(prev, curr, typical_justification)) {
1386        curr.SetBodyLine();
1387      }
1388    }
1389    {
1390      RowScratchRegisters &curr = (*rows)[row_start];
1391      RowScratchRegisters &next = (*rows)[row_start + 1];
1392      tesseract::ParagraphJustification j = curr.ri_->ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1393      if (curr.GetLineType() == LT_UNKNOWN && !FirstWordWouldHaveFit(curr, next, j) &&
1394          (curr.ri_->lword_likely_starts_idea || curr.ri_->rword_likely_starts_idea)) {
1395        curr.SetStartLine();
1396      }
1397    }
1398    for (int i = row_start + 1; i < row_end - 1; i++) {
1399      RowScratchRegisters &prev = (*rows)[i - 1];
1400      RowScratchRegisters &curr = (*rows)[i];
1401      RowScratchRegisters &next = (*rows)[i + 1];
1402      tesseract::ParagraphJustification j = curr.ri_->ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1403      if (curr.GetLineType() == LT_UNKNOWN && !FirstWordWouldHaveFit(curr, next, j) &&
1404          LikelyParagraphStart(prev, curr, j)) {
1405        curr.SetStartLine();
1406      }
1407    }
1408    { 
1409      RowScratchRegisters &prev = (*rows)[row_end - 2];
1410      RowScratchRegisters &curr = (*rows)[row_end - 1];
1411      tesseract::ParagraphJustification j = curr.ri_->ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1412      if (curr.GetLineType() == LT_UNKNOWN && !FirstWordWouldHaveFit(curr, curr, j) &&
1413          LikelyParagraphStart(prev, curr, j)) {
1414        curr.SetStartLine();
1415      }
1416    }
1417  }
1418  static void ModelStrongEvidence(int debug_level, std::vector<RowScratchRegisters> *rows,
1419                                  int row_start, int row_end, bool allow_flush_models,
1420                                  ParagraphTheory *theory) {
1421    if (!AcceptableRowArgs(debug_level, 2, __func__, rows, row_start, row_end)) {
1422      return;
1423    }
1424    int start = row_start;
1425    while (start < row_end) {
1426      while (start < row_end && (*rows)[start].GetLineType() != LT_START) {
1427        start++;
1428      }
1429      if (start >= row_end - 1) {
1430        break;
1431      }
1432      int tolerance = Epsilon((*rows)[start + 1].ri_->average_interword_space);
1433      int end = start;
1434      ParagraphModel last_model;
1435      bool next_consistent;
1436      do {
1437        ++end;
1438        if (end < row_end - 1) {
1439          RowScratchRegisters &next = (*rows)[end];
1440          LineType lt = next.GetLineType();
1441          next_consistent = lt == LT_BODY || (lt == LT_UNKNOWN &&
1442                                              !FirstWordWouldHaveFit((*rows)[end - 1], (*rows)[end]));
1443        } else {
1444          next_consistent = false;
1445        }
1446        if (next_consistent) {
1447          ParagraphModel next_model =
1448              InternalParagraphModelByOutline(rows, start, end + 1, tolerance, &next_consistent);
1449          if (((*rows)[start].ri_->ltr && last_model.justification() == JUSTIFICATION_LEFT &&
1450               next_model.justification() != JUSTIFICATION_LEFT) ||
1451              (!(*rows)[start].ri_->ltr && last_model.justification() == JUSTIFICATION_RIGHT &&
1452               next_model.justification() != JUSTIFICATION_RIGHT)) {
1453            next_consistent = false;
1454          }
1455          last_model = next_model;
1456        } else {
1457          next_consistent = false;
1458        }
1459      } while (next_consistent && end < row_end);
1460      if (end > start + 1) {
1461        const ParagraphModel *model = nullptr;
1462        ParagraphModel new_model = ParagraphModelByOutline(
1463            debug_level, rows, start, end, Epsilon(InterwordSpace(*rows, start, end)));
1464        if (new_model.justification() == JUSTIFICATION_UNKNOWN) {
1465        } else if (new_model.is_flush()) {
1466          if (end == start + 2) {
1467            end = start + 1;
1468          } else if (start == row_start) {
1469            if (new_model.justification() == JUSTIFICATION_LEFT) {
1470              model = kCrownLeft;
1471            } else {
1472              model = kCrownRight;
1473            }
1474          } else if (allow_flush_models) {
1475            model = theory->AddModel(new_model);
1476          }
1477        } else {
1478          model = theory->AddModel(new_model);
1479        }
1480        if (model) {
1481          (*rows)[start].AddStartLine(model);
1482          for (int i = start + 1; i < end; i++) {
1483            (*rows)[i].AddBodyLine(model);
1484          }
1485        }
1486      }
1487      start = end;
1488    }
1489  }
1490  static void StrongEvidenceClassify(int debug_level, std::vector<RowScratchRegisters> *rows,
1491                                     int row_start, int row_end, ParagraphTheory *theory) {
1492    if (!AcceptableRowArgs(debug_level, 2, __func__, rows, row_start, row_end)) {
1493      return;
1494    }
1495    if (debug_level > 1) {
1496      tprintf("#############################################\n");
1497      tprintf("# StrongEvidenceClassify( rows[%d:%d) )\n", row_start, row_end);
1498      tprintf("#############################################\n");
1499    }
1500    RecomputeMarginsAndClearHypotheses(rows, row_start, row_end, 10);
1501    MarkStrongEvidence(rows, row_start, row_end);
1502    DebugDump(debug_level > 2, "Initial strong signals.", *theory, *rows);
1503    ModelStrongEvidence(debug_level, rows, row_start, row_end, false, theory);
1504    DebugDump(debug_level > 2, "Unsmeared hypotheses.s.", *theory, *rows);
1505    ParagraphModelSmearer smearer(rows, row_start, row_end, theory);
1506    smearer.Smear();
1507  }
1508  static void SeparateSimpleLeaderLines(std::vector<RowScratchRegisters> *rows, int row_start,
1509                                        int row_end, ParagraphTheory *theory) {
1510    for (int i = row_start + 1; i < row_end - 1; i++) {
1511      if ((*rows)[i - 1].ri_->has_leaders && (*rows)[i].ri_->has_leaders &&
1512          (*rows)[i + 1].ri_->has_leaders) {
1513        const ParagraphModel *model =
1514            theory->AddModel(ParagraphModel(JUSTIFICATION_UNKNOWN, 0, 0, 0, 0));
1515        (*rows)[i].AddStartLine(model);
1516      }
1517    }
1518  }
1519  static void ConvertHypothesizedModelRunsToParagraphs(int debug_level,
1520                                                       std::vector<RowScratchRegisters> &rows,
1521                                                       std::vector<PARA *> *row_owners,
1522                                                       ParagraphTheory *theory) {
1523    int end = rows.size();
1524    int start;
1525    for (; end > 0; end = start) {
1526      start = end - 1;
1527      const ParagraphModel *model = nullptr;
1528      bool single_line_paragraph = false;
1529      SetOfModels models;
1530      rows[start].NonNullHypotheses(&models);
1531      if (!models.empty()) {
1532        model = models[0];
1533        if (rows[start].GetLineType(model) != LT_BODY) {
1534          single_line_paragraph = true;
1535        }
1536      }
1537      if (model && !single_line_paragraph) {
1538        while (--start > 0 && rows[start].GetLineType(model) == LT_BODY) {
1539        }
1540        if (start < 0 || rows[start].GetLineType(model) != LT_START) {
1541          model = nullptr;
1542        }
1543      }
1544      if (model == nullptr) {
1545        continue;
1546      }
1547      PARA *p = new PARA();
1548      if (model == kCrownLeft || model == kCrownRight) {
1549        p->is_very_first_or_continuation = true;
1550        for (unsigned row = end; row < rows.size(); row++) {
1551          if ((*row_owners)[row] &&
1552              (ValidBodyLine(&rows, start, (*row_owners)[row]->model) &&
1553               (start == 0 || ValidFirstLine(&rows, start, (*row_owners)[row]->model)))) {
1554            model = (*row_owners)[row]->model;
1555            break;
1556          }
1557        }
1558        if (model == kCrownLeft) {
1559          model = theory->AddModel(ParagraphModel(JUSTIFICATION_LEFT,
1560                                                  rows[start].lmargin_ + rows[start].lindent_, 0, 0,
1561                                                  Epsilon(rows[start].ri_->average_interword_space)));
1562        } else if (model == kCrownRight) {
1563          model = theory->AddModel(ParagraphModel(JUSTIFICATION_RIGHT,
1564                                                  rows[start].rmargin_ + rows[start].rmargin_, 0, 0,
1565                                                  Epsilon(rows[start].ri_->average_interword_space)));
1566        }
1567      }
1568      rows[start].SetUnknown();
1569      rows[start].AddStartLine(model);
1570      for (int i = start + 1; i < end; i++) {
1571        rows[i].SetUnknown();
1572        rows[i].AddBodyLine(model);
1573      }
1574      p->model = model;
1575      p->has_drop_cap = rows[start].ri_->has_drop_cap;
1576      p->is_list_item = model->justification() == JUSTIFICATION_RIGHT
1577                            ? rows[start].ri_->rword_indicates_list_item
1578                            : rows[start].ri_->lword_indicates_list_item;
1579      for (int row = start; row < end; row++) {
1580        if ((*row_owners)[row] != nullptr) {
1581          tprintf(
1582              "Memory leak! ConvertHypothesizeModelRunsToParagraphs() called "
1583              "more than once!\n");
1584          delete (*row_owners)[row];
1585        }
1586        (*row_owners)[row] = p;
1587      }
1588    }
1589  }
1590  struct Interval {
1591    Interval() : begin(0), end(0) {}
1592    Interval(int b, int e) : begin(b), end(e) {}
1593    int begin;
1594    int end;
1595  };
1596  static bool RowIsStranded(const std::vector<RowScratchRegisters> &rows, int row) {
1597    SetOfModels row_models;
1598    rows[row].StrongHypotheses(&row_models);
1599    for (auto &row_model : row_models) {
1600      bool all_starts = rows[row].GetLineType();
1601      int run_length = 1;
1602      bool continues = true;
1603      for (int i = row - 1; i >= 0 && continues; i--) {
1604        SetOfModels models;
1605        rows[i].NonNullHypotheses(&models);
1606        switch (rows[i].GetLineType(row_model)) {
1607          case LT_START:
1608            run_length++;
1609            break;
1610          case LT_MULTIPLE: 
1611          case LT_BODY:
1612            run_length++;
1613            all_starts = false;
1614            break;
1615          case LT_UNKNOWN: 
1616          default:
1617            continues = false;
1618        }
1619      }
1620      continues = true;
1621      for (unsigned i = row + 1; i < rows.size() && continues; i++) {
1622        SetOfModels models;
1623        rows[i].NonNullHypotheses(&models);
1624        switch (rows[i].GetLineType(row_model)) {
1625          case LT_START:
1626            run_length++;
1627            break;
1628          case LT_MULTIPLE: 
1629          case LT_BODY:
1630            run_length++;
1631            all_starts = false;
1632            break;
1633          case LT_UNKNOWN: 
1634          default:
1635            continues = false;
1636        }
1637      }
1638      if (run_length > 2 || (!all_starts && run_length > 1)) {
1639        return false;
1640      }
1641    }
1642    return true;
1643  }
1644  static void LeftoverSegments(const std::vector<RowScratchRegisters> &rows,
1645                               std::vector<Interval> *to_fix, int row_start, int row_end) {
1646    to_fix->clear();
1647    for (int i = row_start; i < row_end; i++) {
1648      bool needs_fixing = false;
1649      SetOfModels models;
1650      SetOfModels models_w_crowns;
1651      rows[i].StrongHypotheses(&models);
1652      rows[i].NonNullHypotheses(&models_w_crowns);
1653      if (models.empty() && !models_w_crowns.empty()) {
1654        for (unsigned end = i + 1; end < rows.size(); end++) {
1655          SetOfModels end_models;
1656          SetOfModels strong_end_models;
1657          rows[end].NonNullHypotheses(&end_models);
1658          rows[end].StrongHypotheses(&strong_end_models);
1659          if (end_models.empty()) {
1660            needs_fixing = true;
1661            break;
1662          } else if (!strong_end_models.empty()) {
1663            needs_fixing = false;
1664            break;
1665          }
1666        }
1667      } else if (models.empty() && rows[i].ri_->num_words > 0) {
1668        needs_fixing = true;
1669      }
1670      if (!needs_fixing && !models.empty()) {
1671        needs_fixing = RowIsStranded(rows, i);
1672      }
1673      if (needs_fixing) {
1674        if (!to_fix->empty() && to_fix->back().end == i - 1) {
1675          to_fix->back().end = i;
1676        } else {
1677          to_fix->push_back(Interval(i, i));
1678        }
1679      }
1680    }
1681    for (auto &i : *to_fix) {
1682      i.end = i.end + 1;
1683    }
1684  }
1685  void CanonicalizeDetectionResults(std::vector<PARA *> *row_owners, PARA_LIST *paragraphs) {
1686    std::vector<PARA *> &rows = *row_owners;
1687    paragraphs->clear();
1688    PARA_IT out(paragraphs);
1689    PARA *formerly_null = nullptr;
1690    for (unsigned i = 0; i < rows.size(); i++) {
1691      if (rows[i] == nullptr) {
1692        if (i == 0 || rows[i - 1] != formerly_null) {
1693          rows[i] = formerly_null = new PARA();
1694        } else {
1695          rows[i] = formerly_null;
1696          continue;
1697        }
1698      } else if (i > 0 && rows[i - 1] == rows[i]) {
1699        continue;
1700      }
1701      out.add_after_then_move(rows[i]);
1702    }
1703  }
1704  void DetectParagraphs(int debug_level, std::vector<RowInfo> *row_infos,
1705                        std::vector<PARA *> *row_owners, PARA_LIST *paragraphs,
1706                        std::vector<ParagraphModel *> *models) {
1707    ParagraphTheory theory(models);
1708    row_owners->clear();
1709    row_owners->resize(row_infos->size());
1710    std::vector<RowScratchRegisters> rows(row_infos->size());
1711    for (unsigned i = 0; i < row_infos->size(); i++) {
1712      rows[i].Init((*row_infos)[i]);
1713    }
1714    SeparateSimpleLeaderLines(&rows, 0, rows.size(), &theory);
1715    DebugDump(debug_level > 1, "End of Pass 1", theory, rows);
1716    std::vector<Interval> leftovers;
1717    LeftoverSegments(rows, &leftovers, 0, rows.size());
1718    for (auto &leftover : leftovers) {
1719      StrongEvidenceClassify(debug_level, &rows, leftover.begin, leftover.end, &theory);
1720      std::vector<Interval> leftovers2;
1721      LeftoverSegments(rows, &leftovers2, leftover.begin, leftover.end);
1722      bool pass2a_was_useful =
1723          leftovers2.size() > 1 ||
1724          (leftovers2.size() == 1 && (leftovers2[0].begin != 0 || static_cast<size_t>(leftovers2[0].end) != rows.size()));
1725      if (pass2a_was_useful) {
1726        for (auto &leftover2 : leftovers2) {
1727          StrongEvidenceClassify(debug_level, &rows, leftover2.begin, leftover2.end, &theory);
1728        }
1729      }
1730    }
1731    DebugDump(debug_level > 1, "End of Pass 2", theory, rows);
1732    LeftoverSegments(rows, &leftovers, 0, rows.size());
1733    for (auto &leftover : leftovers) {
1734      GeometricClassify(debug_level, &rows, leftover.begin, leftover.end, &theory);
1735    }
1736    DowngradeWeakestToCrowns(debug_level, &theory, &rows);
1737    DebugDump(debug_level > 1, "End of Pass 3", theory, rows);
1738    LeftoverSegments(rows, &leftovers, 0, rows.size());
1739    for (auto &leftover : leftovers) {
1740      for (int j = leftover.begin; j < leftover.end; j++) {
1741        rows[j].SetUnknown();
1742      }
1743    }
1744    DebugDump(debug_level > 1, "End of Pass 4", theory, rows);
1745    ConvertHypothesizedModelRunsToParagraphs(debug_level, rows, row_owners, &theory);
1746    DebugDump(debug_level > 0, "Final Paragraph Segmentation", theory, rows);
1747    CanonicalizeDetectionResults(row_owners, paragraphs);
1748  }
1749  static void InitializeTextAndBoxesPreRecognition(const MutableIterator &it, RowInfo *info) {
1750    std::string fake_text;
1751    PageIterator pit(static_cast<const PageIterator &>(it));
1752    bool first_word = true;
1753    if (!pit.Empty(RIL_WORD)) {
1754      do {
1755        fake_text += "x";
1756        if (first_word) {
1757          info->lword_text += "x";
1758        }
1759        info->rword_text += "x";
1760        if (pit.IsAtFinalElement(RIL_WORD, RIL_SYMBOL) &&
1761            !pit.IsAtFinalElement(RIL_TEXTLINE, RIL_SYMBOL)) {
1762          fake_text += " ";
1763          info->rword_text = "";
1764          first_word = false;
1765        }
1766      } while (!pit.IsAtFinalElement(RIL_TEXTLINE, RIL_SYMBOL) && pit.Next(RIL_SYMBOL));
1767    }
1768    if (fake_text.empty()) {
1769      return;
1770    }
1771    int lspaces = info->pix_ldistance / info->average_interword_space;
1772    for (int i = 0; i < lspaces; i++) {
1773      info->text += ' ';
1774    }
1775    info->text += fake_text;
1776    PAGE_RES_IT page_res_it = *it.PageResIt();
1777    WERD_RES *word_res = page_res_it.restart_row();
1778    ROW_RES *this_row = page_res_it.row();
1779    WERD_RES *lword = nullptr;
1780    WERD_RES *rword = nullptr;
1781    info->num_words = 0;
1782    do {
1783      if (word_res) {
1784        if (!lword) {
1785          lword = word_res;
1786        }
1787        if (rword != word_res) {
1788          info->num_words++;
1789        }
1790        rword = word_res;
1791      }
1792      word_res = page_res_it.forward();
1793    } while (page_res_it.row() == this_row);
1794    if (lword) {
1795      info->lword_box = lword->word->bounding_box();
1796    }
1797    if (rword) {
1798      info->rword_box = rword->word->bounding_box();
1799    }
1800  }
1801  static void InitializeRowInfo(bool after_recognition, const MutableIterator &it, RowInfo *info) {
1802    if (it.PageResIt()->row() != nullptr) {
1803      ROW *row = it.PageResIt()->row()->row;
1804      info->pix_ldistance = row->lmargin();
1805      info->pix_rdistance = row->rmargin();
1806      info->average_interword_space =
1807          row->space() > 0 ? row->space() : std::max(static_cast<int>(row->x_height()), 1);
1808      info->pix_xheight = row->x_height();
1809      info->has_leaders = false;
1810      info->has_drop_cap = row->has_drop_cap();
1811      info->ltr = true; 
1812    } else {
1813      info->pix_ldistance = info->pix_rdistance = 0;
1814      info->average_interword_space = 1;
1815      info->pix_xheight = 1.0;
1816      info->has_leaders = false;
1817      info->has_drop_cap = false;
1818      info->ltr = true;
1819    }
1820    info->num_words = 0;
1821    info->lword_indicates_list_item = false;
1822    info->lword_likely_starts_idea = false;
1823    info->lword_likely_ends_idea = false;
1824    info->rword_indicates_list_item = false;
1825    info->rword_likely_starts_idea = false;
1826    info->rword_likely_ends_idea = false;
1827    info->has_leaders = false;
1828    info->ltr = true;
1829    if (!after_recognition) {
1830      InitializeTextAndBoxesPreRecognition(it, info);
1831      return;
1832    }
1833    info->text = "";
1834    const std::unique_ptr<const char[]> text(it.GetUTF8Text(RIL_TEXTLINE));
1835    int trailing_ws_idx = strlen(text.get()); 
1836    while (trailing_ws_idx > 0 &&
1837           isascii(text[trailing_ws_idx - 1]) && isspace(text[trailing_ws_idx - 1])) {
1838      trailing_ws_idx--;
1839    }
1840    if (trailing_ws_idx > 0) {
1841      int lspaces = info->pix_ldistance / info->average_interword_space;
1842      for (int i = 0; i < lspaces; i++) {
1843        info->text += ' ';
1844      }
1845      for (int i = 0; i < trailing_ws_idx; i++) {
1846        info->text += text[i];
1847      }
1848    }
1849    if (info->text.empty()) {
1850      return;
1851    }
<span onclick='openModal()' class='match'>1852    PAGE_RES_IT page_res_it = *it.PageResIt();
1853    std::vector<WERD_RES *> werds;
1854    WERD_RES *word_res = page_res_it.restart_row();
1855    ROW_RES *this_row = page_res_it.row();
</span>1856    int num_leaders = 0;
1857    int ltr = 0;
1858    int rtl = 0;
1859    do {
1860      if (word_res && word_res->best_choice->unichar_string().length() > 0) {
1861        werds.push_back(word_res);
1862        ltr += word_res->AnyLtrCharsInWord() ? 1 : 0;
1863        rtl += word_res->AnyRtlCharsInWord() ? 1 : 0;
1864        if (word_res->word->flag(W_REP_CHAR)) {
1865          num_leaders++;
1866        }
1867      }
1868      word_res = page_res_it.forward();
1869    } while (page_res_it.row() == this_row);
1870    info->ltr = ltr >= rtl;
1871    info->has_leaders = num_leaders > 3;
1872    info->num_words = werds.size();
1873    if (!werds.empty()) {
1874      WERD_RES *lword = werds[0], *rword = werds[werds.size() - 1];
1875      info->lword_text = lword->best_choice->unichar_string().c_str();
1876      info->rword_text = rword->best_choice->unichar_string().c_str();
1877      info->lword_box = lword->word->bounding_box();
1878      info->rword_box = rword->word->bounding_box();
1879      LeftWordAttributes(lword->uch_set, lword->best_choice, info->lword_text,
1880                         &info->lword_indicates_list_item, &info->lword_likely_starts_idea,
1881                         &info->lword_likely_ends_idea);
1882      RightWordAttributes(rword->uch_set, rword->best_choice, info->rword_text,
1883                          &info->rword_indicates_list_item, &info->rword_likely_starts_idea,
1884                          &info->rword_likely_ends_idea);
1885    }
1886  }
1887  void DetectParagraphs(int debug_level, bool after_text_recognition,
1888                        const MutableIterator *block_start, std::vector<ParagraphModel *> *models) {
1889    if (block_start->Empty(RIL_TEXTLINE)) {
1890      return;
1891    }
1892    BLOCK *block = block_start->PageResIt()->block()->block;
1893    block->para_list()->clear();
1894    bool is_image_block = block->pdblk.poly_block() && !block->pdblk.poly_block()->IsText();
1895    MutableIterator row(*block_start);
1896    if (row.Empty(RIL_TEXTLINE)) {
1897      return; 
1898    }
1899    std::vector<RowInfo> row_infos;
1900    do {
1901      if (!row.PageResIt()->row()) {
1902        continue; 
1903      }
1904      row.PageResIt()->row()->row->set_para(nullptr);
1905      row_infos.emplace_back();
1906      RowInfo &ri = row_infos.back();
1907      InitializeRowInfo(after_text_recognition, row, &ri);
1908    } while (!row.IsAtFinalElement(RIL_BLOCK, RIL_TEXTLINE) && row.Next(RIL_TEXTLINE));
1909    if (!row_infos.empty()) {
1910      int min_lmargin = row_infos[0].pix_ldistance;
1911      int min_rmargin = row_infos[0].pix_rdistance;
1912      for (unsigned i = 1; i < row_infos.size(); i++) {
1913        if (row_infos[i].pix_ldistance < min_lmargin) {
1914          min_lmargin = row_infos[i].pix_ldistance;
1915        }
1916        if (row_infos[i].pix_rdistance < min_rmargin) {
1917          min_rmargin = row_infos[i].pix_rdistance;
1918        }
1919      }
1920      if (min_lmargin > 0 || min_rmargin > 0) {
1921        for (auto &row_info : row_infos) {
1922          row_info.pix_ldistance -= min_lmargin;
1923          row_info.pix_rdistance -= min_rmargin;
1924        }
1925      }
1926    }
1927    std::vector<PARA *> row_owners;
1928    std::vector<PARA *> the_paragraphs;
1929    if (!is_image_block) {
1930      DetectParagraphs(debug_level, &row_infos, &row_owners, block->para_list(), models);
1931    } else {
1932      row_owners.resize(row_infos.size());
1933      CanonicalizeDetectionResults(&row_owners, block->para_list());
1934    }
1935    row = *block_start;
1936    for (auto &row_owner : row_owners) {
1937      while (!row.PageResIt()->row()) {
1938        row.Next(RIL_TEXTLINE);
1939      }
1940      row.PageResIt()->row()->row->set_para(row_owner);
1941      row.Next(RIL_TEXTLINE);
1942    }
1943  }
1944  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.cpp</h3>
            <pre><code>1  int TVizMapLink::GetPointN(const int& PointN) const {
2      if (SrcPointN == PointN) { return DstPointN; }
3      else if (DstPointN == PointN) { return SrcPointN; }
4      else { return -1; }
5  }
6  TVizMapLandscape::TVizMapLandscape(const TVizMapLandscapeV& CatLandscapeV,
7          const PVizMapLandscape& FullLandscape, const TIntH& CatIdH,
8          const double& MxCover, const double& MnCover, const int& MnCats) {
9      const int Cats = CatLandscapeV.Len();
10      IAssert(Cats > 0); IAssert(Cats < TInt::Mx);
11      const int XDim = CatLandscapeV[0]->GetXDim();
12      const int YDim = CatLandscapeV[0]->GetYDim();
13      IAssert(FullLandscape->GetXDim() == XDim);
14      IAssert(FullLandscape->GetYDim() == YDim);
15      HeightMatrixVV.Gen(XDim, YDim); HeightMatrixVV.PutAll(0.0);
16      for (int XPos = 0; XPos < XDim; XPos++) {
17          for (int YPos = 0; YPos < YDim; YPos++) {
18              HeightMatrixVV(XPos, YPos) = sdouble(FullLandscape->GetHeight(XPos, YPos));
19          }
20      }
21      TIntH CatIdToCountH; TIntH EdgeCatH;
22      forever {
23          const int ActiveCats = CatIdH.Len() - EdgeCatH.Len();
24          if (ActiveCats <= MnCats) { break; }
25          CatIdToCountH.Clr();
26          for (int XPos = 0; XPos < XDim; XPos++) {
27              for (int YPos = 0; YPos < YDim; YPos++) {
28                  double MxHeight = 0.0; int MxCatId = -1;
29                  for (int CatId = 0; CatId < Cats; CatId++) {
30                      if (EdgeCatH.IsKey(CatId)) { continue; }
31                      const double Height = CatLandscapeV[CatId]->GetHeight(XPos, YPos);
32                      if (Height > MxHeight) { MxHeight = Height; MxCatId = CatId; }
33                  }
34                  if (MxCatId != -1) { CatIdToCountH.AddDat(MxCatId)++; }
35              }
36          }
37          int MxCount = 0, MxCatId = -1;
38          int MnCount = XDim * YDim, MnCatId = -1;
39          int CatKeyId = CatIdToCountH.FFirstKeyId();
40          while (CatIdToCountH.FNextKeyId(CatKeyId)) {
41              const int CatId = CatIdToCountH.GetKey(CatKeyId);
42              const int CatCount = CatIdToCountH[CatKeyId];
43              if (CatCount > MxCount) { MxCount = CatCount; MxCatId = CatId; }
44              if (CatCount < MnCount) { MnCount = CatCount; MnCatId = CatId; }
45          }
46          const double TopCover = double(MxCount) / double(XDim * YDim);
47          const double BottomCover = double(MnCount) / double(XDim * YDim);
48          if (TopCover > MxCover && MxCatId != -1) {
49              printf("RemovingT %d (cover: %.4f), Left: %d\n", MxCatId, TopCover, ActiveCats-1);
50              EdgeCatH.AddDat(MxCatId);
51          } else if (BottomCover < MnCover && MnCatId != -1) {
52              printf("RemovingB %d (cover: %.4f), Left: %d\n", MnCatId, BottomCover, ActiveCats-1);
53              EdgeCatH.AddDat(MnCatId);
54          } else {
55              break; 
56          }
57      }
58      TIntV SelCatIdV;
59      for (int CatId = 0; CatId < Cats; CatId++) {
60          if (EdgeCatH.IsKey(CatId)) { continue; }
61          SelCatIdV.Add(CatId);
62      }
63      CatIdToCountH.Clr(); CatIdToCenterH.Clr();
64      CatMatrixVV.Gen(XDim, YDim); CatMatrixVV.PutAll(-1);
65      for (int XPos = 0; XPos < XDim; XPos++) {
66          for (int YPos = 0; YPos < YDim; YPos++) {
67              double MxHeight = 0.0; int MxCatIdN = -1;
68              for (int CatN = 0; CatN < SelCatIdV.Len(); CatN++) {
69                  const int CatIdN = SelCatIdV[CatN];
70                  const double Height = CatLandscapeV[CatIdN]->GetHeight(XPos, YPos);
71                  if (Height > MxHeight) { MxHeight = Height; MxCatIdN = CatIdN; }
72              }
73              if (MxCatIdN != -1) {
74                  const int MxCatId = CatIdH.GetKey(MxCatIdN);
75                  CatMatrixVV(XPos, YPos) = MxCatId;
76                  CatIdToCountH.AddDat(MxCatId)++;
77                  CatIdToCenterH.AddDat(MxCatId).Val1 += double(XPos) / double(XDim - 1);
78                  CatIdToCenterH.AddDat(MxCatId).Val2 += double(YPos) / double(YDim - 1);
79              }
80          }
81      }
82      int CatKeyId = CatIdToCenterH.FFirstKeyId();
83      while (CatIdToCenterH.FNextKeyId(CatKeyId)) {
84          const int CatId = CatIdToCenterH.GetKey(CatKeyId);
85          const double CatCount = double(CatIdToCountH.GetDat(CatId));
86          IAssert(CatCount > 0);
87          CatIdToCenterH[CatKeyId].Val1 = CatIdToCenterH[CatKeyId].Val1 / CatCount;
88          CatIdToCenterH[CatKeyId].Val2 = CatIdToCenterH[CatKeyId].Val2 / CatCount;
89      }
90      LevelV = FullLandscape->GetLevelV();
91  }
92  void TVizMapLandscape::PutCatVV(const TIntVV& _CatMatrixVV) {
93      IAssert(_CatMatrixVV.GetXDim() == GetXDim());
94      IAssert(_CatMatrixVV.GetYDim() == GetYDim());
95      CatMatrixVV = _CatMatrixVV;
96  }
97  int TVizMapLandscape::GetCatFromCoord(const double& X, const double& Y) {
98      const int XPos = TFlt::Round(X * double(GetXDim() - 1));
99      const int YPos = TFlt::Round(Y * double(GetYDim() - 1));
100      return GetCat(XPos, YPos);
101  }
102  void TVizMapLandscape::CalcStart(const int& XDim, const int& YDim, const double& Sigma) {
103      PKernel Kernel = TRadialKernel::New(1/Sigma);
104      CalcMatrixVV.Gen(XDim, YDim);
105      CalcMatrixVV.PutAll(0.0);
106      const double Threshold = 1e-10 * Kernel->Calc(0.0,0.0,0.0);
107      const double w = XDim, h = YDim;
108      int StampWidth = 0, StampHeight = 0;
109      while (Kernel->Calc(0,0,TMath::Sqr(StampWidth/w)) > Threshold) { StampWidth++; }
110      while (Kernel->Calc(0,0,TMath::Sqr(StampHeight/h)) > Threshold) { StampHeight++; }
111      StampWidth = TInt::GetMn(StampWidth, XDim);
112      StampHeight = TInt::GetMn(StampHeight, YDim);
113      CalcStampVV.Gen(StampWidth, StampHeight);
114      for (int x = 0; x < StampWidth; x++) {
115          const double X = x/w;
116          for (int y = 0; y < StampHeight; y++) {
117              const double Y = y/h;
118              CalcStampVV(x,y) = Kernel->Calc(0.0,0.0,X*X+Y*Y);
119          }
120      }
121  }
122  void TVizMapLandscape::CalcPutStamp(const double& PointX,
123          const double& PointY, const double& PointWgt) {
124      const int Width = CalcMatrixVV.GetXDim();
125      const int Height = CalcMatrixVV.GetYDim();
126      const int StampWidth = CalcStampVV.GetXDim();
127      const int StampHeight = CalcStampVV.GetYDim();
128      const int DocX = TFlt::Round(PointX * Width);
129      const int DocY = TFlt::Round(PointY * Height);
130      const int LowX = TInt::GetMx(DocX-StampWidth, -1);
131      const int LowY = TInt::GetMx(DocY-StampHeight, -1);
132      const int HighX = TInt::GetMn(DocX+StampWidth, Width);
133      const int HighY = TInt::GetMn(DocY+StampHeight, Height);
134      for (int x = DocX; x < HighX; x++) {
135          for (int y = DocY; y < HighY; y++) {
136              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
137              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
138              EAssertR(0 <= x-DocX && x-DocX < StampWidth, TInt(x).GetStr());
139              EAssertR(0 <= y-DocY && y-DocY < StampHeight, TInt(y).GetStr());
140              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(x-DocX,y-DocY);
141          }
142      }
143      for (int x = DocX-1; x > LowX; x--) {
144          for (int y = DocY; y < HighY; y++) {
145              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
146              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
147              EAssertR(0 <= DocX-x && DocX-x < StampWidth, TInt(x).GetStr());
148              EAssertR(0 <= y-DocY && y-DocY < StampHeight, TInt(y).GetStr());
149              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(DocX-x,y-DocY);
150          }
151      }
152      for (int x = DocX; x < HighX; x++) {
153          for (int y = DocY-1; y > LowY; y--) {
154              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
155              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
156              EAssertR(0 <= x-DocX && x-DocX < StampWidth, TInt(x).GetStr());
157              EAssertR(0 <= DocY-y && DocY-y < StampHeight, TInt(y).GetStr());
158              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(x-DocX,DocY-y);
159          }
160      }
161      for (int x = DocX-1; x > LowX; x--) {
162          for (int y = DocY-1; y > LowY; y--) {
163              EAssertR(0 <= x && x < Width, TInt(x).GetStr());
164              EAssertR(0 <= y && y < Height, TInt(y).GetStr());
165              EAssertR(0 <= DocX-x && DocX-x < StampWidth, TInt(x).GetStr());
166              EAssertR(0 <= DocY-y && DocY-y < StampHeight, TInt(y).GetStr());
167              CalcMatrixVV(x,y) += PointWgt * CalcStampVV(DocX-x,DocY-y);
168          }
169      }
170  }
171  void TVizMapLandscape::CalcFinish(const double& MxVal, const int& Levels) {
172      const int Width = CalcMatrixVV.GetXDim();
173      const int Height = CalcMatrixVV.GetYDim();
174      double Mn = TFlt::Mx, Mx = 0.0;
175      for (int x = 0; x < Width; x++) {
176          for (int y = 0; y < Height; y++) {
177              Mx = TFlt::GetMx(Mx, CalcMatrixVV(x,y));
178              Mn = TFlt::GetMn(Mn, CalcMatrixVV(x,y));
179          }
180      }
181      double Diff = Mx - Mn; EAssert(Diff > 0.0);
182      HeightMatrixVV.Gen(Width, Height);
183      TSFltV HeightV(Width*Height, 0);
184      for (int x = 0; x < Width; x++) {
185          for (int y = 0; y < Height; y++) {
186              HeightMatrixVV(x,y) = sdouble(MxVal * (CalcMatrixVV(x,y)-Mn)/Diff);
187              HeightV.Add(HeightMatrixVV(x,y));
188          }
189      }
190      CalcMatrixVV.Clr(); CalcStampVV.Clr();
191      HeightV.Sort(); LevelV.Gen(Levels-1, 0);
192      for (int LevelN = 1; LevelN < Levels; LevelN++) {
193          LevelV.Add(LevelN * HeightV[HeightV.Len()/Levels]);
194      }
195  }
196  TVizMapFrame::TVizMapFrame(): PointV(), LinkV(), FrameSortN(-1) {
197  }
198  TVizMapFrame::TVizMapFrame(TSIn& SIn) {
199      PointV.Load(SIn); LinkV.Load(SIn);
200      FrameNmStr.Load(SIn); FrameSortN.Load(SIn);
201      LandscapeV.Load(SIn);
202      QueryLandscape = PVizMapLandscape(SIn);
203      PointBowDocBs = PBowDocBs(SIn);
204      KeyWdBowDocBs = PBowDocBs(SIn);
205      KeyWdSpVV.Load(SIn);
206      LinkBowDocBs = PBowDocBs(SIn);
207      LinkSpVV.Load(SIn);
208      KeyWdPointV.Load(SIn); KeyWdV.Load(SIn);
209      CatNmH.Load(SIn); DId2PointNMap.Load(SIn);
210  }
211  TVizMapFrame::TVizMapFrame(TSIn& SIn, PBowDocBs _PointBowDocBs,
212          PBowDocBs _KeyWdBowDocBs, PBowDocBs _LinkBowDocBs) {
213      PointV.Load(SIn); LinkV.Load(SIn);
214      FrameNmStr.Load(SIn); FrameSortN.Load(SIn);
215      LandscapeV.Load(SIn);
216      QueryLandscape = PVizMapLandscape(SIn);
217      PointBowDocBs = _PointBowDocBs;
218      KeyWdBowDocBs = _KeyWdBowDocBs;
219      KeyWdSpVV.Load(SIn);
220      LinkBowDocBs = _LinkBowDocBs;
221      LinkSpVV.Load(SIn);
222      KeyWdPointV.Load(SIn); KeyWdV.Load(SIn);
223      CatNmH.Load(SIn); DId2PointNMap.Load(SIn);
224  }
225  void TVizMapFrame::Save(TSOut& SOut, const bool& SaveBows) const {
226      PointV.Save(SOut); LinkV.Save(SOut);
227      FrameNmStr.Save(SOut); FrameSortN.Save(SOut);
228      LandscapeV.Save(SOut); QueryLandscape.Save(SOut);
229      if (SaveBows) { PointBowDocBs.Save(SOut); }
230      if (SaveBows) { KeyWdBowDocBs.Save(SOut); } KeyWdSpVV.Save(SOut);
231      if (SaveBows) { LinkBowDocBs.Save(SOut); } LinkSpVV.Save(SOut);
232      KeyWdPointV.Save(SOut); KeyWdV.Save(SOut);
233      CatNmH.Save(SOut); DId2PointNMap.Save(SOut);
234  }
235  int TVizMapFrame::GetPointN(const TFltV& CoordV, const double& Radius) const {
236      const int Points = PointV.Len();
237      int MnPointN = -1; double MnDist = TFlt::Mx;
238      for (int PointN = 0; PointN < Points; PointN++) {
239          const double Dist = TLinAlg::EuclDist2(CoordV, GetPoint(PointN)->GetCoordV());
240          if (MnDist > Dist) {
241              MnPointN = PointN; MnDist = Dist;
242          }
243      }
244      if (sqrt(MnDist) > Radius) { MnPointN = -1; }
245      return MnPointN;
246  }
247  int TVizMapFrame::GetRectPointV(const TFltRect& Rect, TIntV& RectPointV) const {
248      const int Points = PointV.Len(); RectPointV.Clr();
249      for (int PointN = 0; PointN < Points; PointN++) {
250          PVizMapPoint Point = GetPoint(PointN);
251          if (Rect.IsXYIn(Point->GetPointX(), Point->GetPointY())) {
252              RectPointV.Add(PointN);
253          }
254      }
255      return RectPointV.Len();
256  }
257  int TVizMapFrame::AddLink(PVizMapLink VizMapLink) {
258      EAssert(IsPointN(VizMapLink->GetSrcPointN()));
259      EAssert(IsPointN(VizMapLink->GetDstPointN()));
260      int LinkN = LinkV.Add(VizMapLink);
261      PointV[VizMapLink->GetSrcPointN()]->PutLinkN(LinkN);
262      PointV[VizMapLink->GetDstPointN()]->PutLinkN(LinkN);
263      return LinkN;
264  }
265  void TVizMapFrame::AddLandscape(const int& XDim, const int& YDim,
266          const double& Sigma, const bool& PointWgtP) {
267      PVizMapLandscape NewLandscape = TVizMapLandscape::New();
268      NewLandscape->CalcStart(XDim, YDim, Sigma);
269      const int Points = GetPoints();
270      for (int PointN = 0; PointN < Points; PointN++) {
271          const PVizMapPoint VizMapPoint = GetPoint(PointN);
272          const double PointWgt = PointWgtP ? VizMapPoint->GetWgt() : 1.0;
273          NewLandscape->CalcPutStamp(VizMapPoint->GetPointX(),
274              VizMapPoint->GetPointY(), PointWgt);
275      }
276      NewLandscape->CalcFinish(1.0, 3);
277      LandscapeV.Add(NewLandscape);
278  }
279  void TVizMapFrame::AddLandscapeFromLndMrk(const int& XDim,
280          const int& YDim, const double& Sigma,
281          const TVec<TFltV>& LndMrkPointV) {
282      PVizMapLandscape NewLandscape = TVizMapLandscape::New();
283      NewLandscape->CalcStart(XDim, YDim, Sigma);
284      const int LndMrkPoints = LndMrkPointV.Len();
285      for (int LndMrkPointN = 0; LndMrkPointN < LndMrkPoints; LndMrkPointN++) {
286          const TFltV LndMrkPoint = LndMrkPointV[LndMrkPointN];
287          IAssert(LndMrkPoint.Len() == 2);
288          NewLandscape->CalcPutStamp(LndMrkPoint[0], LndMrkPoint[1], 1.0);
289      }
290      NewLandscape->CalcFinish(1.0, 3);
291      LandscapeV.Add(NewLandscape);
292  }
293  void TVizMapFrame::AddLandscapeWithCats(const int& XDim, const int& YDim,
294          const double& Sigma, const bool& PointWgtP) {
295      TIntKdV CountCatIdV;
296      {int CatId = CatNmH.FFirstKeyId();
297      while (CatNmH.FNextKeyId(CatId)) {
298          const int Count = CatNmH[CatId];
299          CountCatIdV.Add(TIntKd(Count, CatId));
300      }}
301      CountCatIdV.Sort(false); const int MxCats = 20;
302      if (CountCatIdV.Len() > MxCats) { CountCatIdV.Trunc(MxCats); }
303      TIntH BigCatIdH;
304      for (int CatN = 0; CatN < CountCatIdV.Len(); CatN++) {
305          BigCatIdH.AddKey(CountCatIdV[CatN].Dat); }
306      const int Cats = BigCatIdH.Len(); IAssert(Cats > 0);
307      TVizMapLandscapeV CatLandscapeV(Cats, 0);
308      for (int CatIdN = 0; CatIdN < Cats; CatIdN++) {
309          PVizMapLandscape CatLandscape = TVizMapLandscape::New();
310          CatLandscape->CalcStart(XDim, YDim, Sigma);
311          CatLandscapeV.Add(CatLandscape);
312      }
313      PVizMapLandscape FullLandscape = TVizMapLandscape::New();
314      FullLandscape->CalcStart(XDim, YDim, Sigma);
315      const int Points = GetPoints();
316      for (int PointN = 0; PointN < Points; PointN++) {
317          const PVizMapPoint VizMapPoint = GetPoint(PointN);
318          const double PointWgt = PointWgtP ? VizMapPoint->GetWgt() : 1.0;
319          for (int CatIdN = 0; CatIdN < VizMapPoint->GetCats(); CatIdN++) {
320              const int CatId = VizMapPoint->GetCatId(CatIdN);
321              if (BigCatIdH.IsKey(CatId)) {
322                  CatLandscapeV[BigCatIdH.GetKeyId(CatId)]->CalcPutStamp(
323                      VizMapPoint->GetPointX(), VizMapPoint->GetPointY(), PointWgt);
324              }
325          }
326          FullLandscape->CalcPutStamp(VizMapPoint->GetPointX(),
327              VizMapPoint->GetPointY(), PointWgt);
328      }
329      for (int CatIdN = 0; CatIdN < Cats; CatIdN++) {
330          const int CatId = BigCatIdH.GetKey(CatIdN);
331          const double MxVal = double(CatNmH[CatId]) / double(Points);
332          CatLandscapeV[CatIdN]->CalcFinish(MxVal, 3);
333      }
334      FullLandscape->CalcFinish(1.0, 3);
335      LandscapeV.Add(TVizMapLandscape::New(CatLandscapeV,
336          FullLandscape, BigCatIdH, 0.6, 0.1, 2));
337  }
338  int TVizMapFrame::GetDocId(const int& PointN) const {
339      if (!IsPointN(PointN)) { return -1; }
340      PVizMapPoint Point = GetPoint(PointN);
341      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return -1; }
342      return Point->GetDocId();
343  }
344  TStr TVizMapFrame::GetDocNm(const int& PointN) const {
345      if (!IsPointN(PointN)) { return ""; }
346      PVizMapPoint Point = GetPoint(PointN);
347      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
348      return PointBowDocBs->GetDocNm(Point->GetDocId());
349  }
350  TStr TVizMapFrame::GetDocBody(const int& PointN) const {
351      if (!IsPointN(PointN)) { return ""; }
352      PVizMapPoint Point = GetPoint(PointN);
353      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
354      return PointBowDocBs->GetDocStr(Point->GetDocId());
355  }
356  TStr TVizMapFrame::GetDocUrl(const int& PointN) const {
357      if (!IsPointN(PointN)) { return ""; }
358      PVizMapPoint Point = GetPoint(PointN);
359      if (PointBowDocBs.Empty() || !Point->IsDocId()) { return ""; }
360      TStr UrlStr = PointBowDocBs->GetDocDescStr(Point->GetDocId());
361      if (UrlStr.SearchStr(":&bsol;&bsol;") != -1) { return UrlStr; }
362      else { return ""; }
363  }
364  int TVizMapFrame::GenKeyWd(const TFltV& CoordV, const double& Radius,
365          const int& MxKeyWd, TStrV& KeyWdStrV, const bool& DistWgtP,
366          const bool& PointWgtP, const bool& BackKeyWdP) const {
367      if (KeyWdBowDocBs.Empty() || KeyWdSpVV.Empty()) {
368          KeyWdStrV.Clr(); return 0; }
369      TFltV FullKeyWdStrV(KeyWdBowDocBs->GetWords());
370      FullKeyWdStrV.PutAll(0.0);
371      const TVizMapPointV& _PointV = KeyWdPointV.Empty() ? PointV : KeyWdPointV;
372      const int Points = _PointV.Len(); int UsedPoints = 0, CenterPoints = 0;
373      bool PPQuad = false, PNQuad = false, NPQuad = false, NNQuad = false;
374      const double CoordX = CoordV[0], CoordY = CoordV[1];
375      for (int PointN = 0; PointN < Points; PointN++) {
376          PVizMapPoint Point = _PointV[PointN];
377          const double Dist = TLinAlg::EuclDist(CoordV, Point->GetCoordV());
378          if (Dist < Radius) {
379              PBowSpV DocSpV = KeyWdSpVV[PointN];
380              const double DistWgt = DistWgtP ? (Radius - Dist)/Radius : 1.0;
381              const double PointWgt = PointWgtP ? Point->GetWgt() : 1.0;
382              TBowLinAlg::AddVec(DistWgt*PointWgt, DocSpV, FullKeyWdStrV);
383              UsedPoints++; if (Dist < (Radius/3.0)) { CenterPoints++; }
384              const double DiffX = CoordX - Point->GetPointX();
385              const double DiffY = CoordY - Point->GetPointY();
386              PPQuad = PPQuad || (DiffX > 0 && DiffY > 0);
387              PNQuad = PNQuad || (DiffX > 0 && DiffY < 0);
388              NPQuad = NPQuad || (DiffX < 0 && DiffY > 0);
389              NNQuad = NNQuad || (DiffX < 0 && DiffY < 0);
390          }
391      }
392      if (UsedPoints == 0) { KeyWdStrV.Clr(); return 0; }
393      if (BackKeyWdP) {
394          if (CenterPoints == 5) { KeyWdStrV.Clr(); return 0; }
395          if (!(PPQuad && PNQuad && NPQuad && NNQuad)) { KeyWdStrV.Clr(); return 0; }
396      }
397      TLinAlg::NormalizeL1(FullKeyWdStrV);
398      TFltIntKdV WgtWIdKdV(FullKeyWdStrV.Len(), 0);
399      for (int WId = 0; WId < FullKeyWdStrV.Len(); WId++) {
400          WgtWIdKdV.Add(TFltIntKd(FullKeyWdStrV[WId], WId));
401      }
402      WgtWIdKdV.Sort(false);
403      KeyWdStrV.Gen(MxKeyWd, 0); int WIdN = 0;
404      while (WIdN < MxKeyWd) {
405          if (WIdN >= WgtWIdKdV.Len()) { return UsedPoints; }
406          if (WgtWIdKdV[WIdN].Key.Val < 0.001) { return UsedPoints; }
407          const int WId = WgtWIdKdV[WIdN].Dat;
408          KeyWdStrV.Add(KeyWdBowDocBs->GetWordStr(WId));
409          WIdN++;
410      }
411      return UsedPoints;
412  }
413  void TVizMapFrame::GenKeyWds(const int& KeyWds, const double& Radius,
414          const int& Candidantes, const int& RndSeed, const TFltRect& Rect) {
415      KeyWdV.Gen(KeyWds, 0); TRnd Rnd(RndSeed); TStrV KeyWdStrV;
416      const double MnX = Rect.GetMnX(), MnY = Rect.GetMnY();
417      const double LenX = Rect.GetXLen(), LenY = Rect.GetYLen();
418      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
419          const double X = MnX + Rnd.GetUniDev() * LenX;
420          const double Y = MnY + Rnd.GetUniDev() * LenY;
421          GenKeyWd(TFltV::GetV(X, Y), Radius, Candidantes, KeyWdStrV, false, false, true);
422          if (!KeyWdStrV.Empty()) {
423              const int KeyWdStrN = Rnd.GetUniDevInt(KeyWdStrV.Len());
424              TStr KeyWdStr = KeyWdStrV[KeyWdStrN];
425              KeyWdV.Add(TVizMapKeyWd::New(TFltV::GetV(X, Y), KeyWdStr));
426          }
427      }
428  }
429  void TVizMapFrame::AddCat(const int& PointN, const int& CatId) {
430      IAssert(IsPointN(PointN)); IAssert(CatNmH.IsKeyId(CatId));
431      CatNmH[CatId]++; GetPoint(PointN)->AddCat(CatId);
432  }
433  void TVizMapFrame::CalcDId2PointNMap() {
434      DId2PointNMap.Clr(); const int Points = GetPoints();
435      for (int PointN = 0; PointN < Points; PointN++) {
436          const PVizMapPoint VizMapPoint = GetPoint(PointN);
437          EAssert(VizMapPoint->IsDocId());
438          DId2PointNMap.AddDat(VizMapPoint->GetDocId(), PointN);
439      }
440  }
441  void TVizMapFrame::SaveVrml(const TStr& VrmlFNm, PVizMapLandscape Landscape,
442          const bool& ShowDocNmP, const bool& ShowDocPtP,
443          const bool& ShowKeyWdP, const double& FontSize,
444          const TStr& SkyColor, const TStr& TerrainColor,
445          const TStr& KeywordColor, const TStr& DocNmColor) {
446      PSOut SOut = TFOut::New(VrmlFNm);
447      TVrml::InsertHeader(SOut, SkyColor);
<span onclick='openModal()' class='match'>448      const TSFltVV& Rlf = Landscape->HeightVV(); TFltVV NewRlf;
449      const double Scale = TVrml::InsertEvelationGrid(SOut,
450          Rlf, NewRlf, TerrainColor, 5, 15.0, 0.7);
451      TStr DocSize = TStr::Fmt("%.3f %.3f %.3f",
</span>452        FontSize, FontSize, FontSize);
453      for (int PointN = 0; PointN < GetPoints(); PointN++) {
454          TStr OrgDocNm = TStr::GetFNmStr(GetPoint(PointN)->GetPointNm());
455          const double PosX = GetPoint(PointN)->GetPointX();
456          const double PosY = GetPoint(PointN)->GetPointY();
457          TVrml::InsertBillboard(SOut, NewRlf, OrgDocNm, KeywordColor,
458            DocSize, PosX, PosY, 1.1, Scale, ShowDocNmP, ShowDocPtP);
459      }
460      if (ShowKeyWdP) {
461          TStr KeyWdSize = TStr::Fmt("%.3f %.3f %.3f",
462            0.5*FontSize, 0.5*FontSize, 0.5*FontSize);
463          TRnd Rnd(0);
464          for (int WdC = 0; WdC < 100; WdC++) {
465              const double PosX = Rnd.GetUniDev();
466              const double PosY = Rnd.GetUniDev();
467              TStrV KeyWdV; GenKeyWd(TFltV::GetV(PosX, PosY),
468                  0.3, 4, KeyWdV, false, false, true);
469              if (KeyWdV.Len() > 0) {
470                  TVrml::InsertBillboard(SOut, NewRlf,
471                    KeyWdV[Rnd.GetUniDevInt(KeyWdV.Len())], DocNmColor,
472                    KeyWdSize, PosX, PosY, 2.0, Scale, true, false);
473              }
474          }
475          for (int WdC = 0; WdC < 50; WdC++) {
476              const double PosX = Rnd.GetUniDev();
477              const double PosY = Rnd.GetUniDev();
478              TStrV KeyWdV; GenKeyWd(TFltV::GetV(PosX, PosY),
479                  0.2, 4, KeyWdV, false, false, true);
480              if (KeyWdV.Len() > 0) {
481                  TVrml::InsertBillboard(SOut, NewRlf,
482                    KeyWdV[Rnd.GetUniDevInt(KeyWdV.Len())], DocNmColor,
483                    KeyWdSize, PosX, PosY, 2.0, Scale, true, false);
484              }
485          }
486      }
487  }
488  void TVizMapFrame::SaveLegend(const TStr& TxtFNm, const int& LegendGridWidth,
489          const int& LegendGridHeight) {
490      TFOut FOut(TxtFNm);
491      for (int PointN = 0; PointN < GetPoints(); PointN++) {
492          PVizMapPoint Point = GetPoint(PointN);
493          const int XMark = (int)floor(Point->GetPointX() * LegendGridWidth);
494          const int YMark = (int)floor(Point->GetPointY() * LegendGridHeight) + 1;
495          const char XMarkCh = 'A' + XMark;
496          FOut.PutStrLn(Point->GetPointNm() + "\t" + TStr(XMarkCh) + TInt::GetStr(YMark));
497      }
498      FOut.Flush();
499  }
500  TVizMap::TVizMap(TSIn& SIn) {
501      TBool AllSameP(SIn);
502      if (AllSameP) {
503          PBowDocBs PointBowDocBs(SIn);
504          PBowDocBs KeyWdBowDocBs(SIn);
505          PBowDocBs LinkBowDocBs(SIn);
506          TInt Frames(SIn);
507          VizMapFrameV.Gen(Frames, 0);
508          for (int FrameN = 0; FrameN < Frames; FrameN++) {
509              PVizMapFrame Frame = TVizMapFrame::Load(SIn,
510                  PointBowDocBs, KeyWdBowDocBs, LinkBowDocBs);
511              VizMapFrameV.Add(Frame);
512          }
513      } else {
514          VizMapFrameV.Load(SIn);
515      }
516  }
517  void TVizMap::Save(TSOut& SOut) const {
518      TBool AllSameP = true;
519      for (int FrameN = 1; FrameN < VizMapFrameV.Len(); FrameN++) {
520          PVizMapFrame PrevFrame = VizMapFrameV[FrameN - 1];
521          PVizMapFrame Frame = VizMapFrameV[FrameN];
522          const bool PointBowP =
523              (Frame->GetPointBow().Empty() && PrevFrame->GetPointBow().Empty()) ||
524              (Frame->GetPointBow()->GetSig() == PrevFrame->GetPointBow()->GetSig());
525          const bool KeyWdBowP =
526              (Frame->GetKeyWdBow().Empty() && PrevFrame->GetKeyWdBow().Empty()) ||
527              (Frame->GetKeyWdBow()->GetSig() == PrevFrame->GetKeyWdBow()->GetSig());
528          const bool LinkBowP =
529              (Frame->GetLinkBow().Empty() && PrevFrame->GetLinkBow().Empty()) ||
530              (Frame->GetLinkBow()->GetSig() == PrevFrame->GetLinkBow()->GetSig());
531          AllSameP = PointBowP && KeyWdBowP && LinkBowP;
532          if (!AllSameP) { break; }
533      }
534      AllSameP.Save(SOut);
535      if (AllSameP) {
536          PVizMapFrame Frame = VizMapFrameV[0];
537          Frame->GetPointBow().Save(SOut);
538          Frame->GetKeyWdBow().Save(SOut);
539          Frame->GetLinkBow().Save(SOut);
540          TInt Frames = VizMapFrameV.Len(); Frames.Save(SOut);
541          for (int FrameN = 0; FrameN < Frames; FrameN++) {
542              VizMapFrameV[FrameN]->Save(SOut, false);
543          }
544      } else {
545          VizMapFrameV.Save(SOut);
546      }
547  }
548  void TVizMap::AddVizMapFrame(const PVizMapFrame& VizMapFrame, const bool& SortedP) {
549      if (SortedP) { VizMapFrameV.Add(VizMapFrame); }
550      else { VizMapFrameV.AddSorted(VizMapFrame); }
551  }
552  void TVizMap::SaveXmlDoc(TSOut& SOut, const TStr& Nm, const TStr& Body,
553          const TStr& DisplayBody, const TStrV& CatNmV, const TStrV& AuthorV,
554          const TStr& FrameNm, const int& FrameSortN) {
555      SOut.PutStrLn(" <document>");
556      SOut.PutStrLn("  <name>" + TXmlDoc::GetXmlStr(Nm) + "</name>");
557      SOut.PutStrLn("  <body>" + TXmlDoc::GetXmlStr(Body) + "</body>");
558      if (!DisplayBody.Empty()) {
559          SOut.PutStrLn("  <display_body>" + TXmlDoc::GetXmlStr(DisplayBody) + "</display_body>");
560      }
561      if (!CatNmV.Empty()) {
562          SOut.PutStrLn("  <categories>");
563          for (int CatNmN = 0; CatNmN < CatNmV.Len(); CatNmN++) {
564              SOut.PutStrLn("   <category>" +
565                  TXmlDoc::GetXmlStr(CatNmV[CatNmN]) + "</category>");
566          }
567          SOut.PutStrLn("  </categories>");
568      }
569      if (!AuthorV.Empty()) {
570          SOut.PutStrLn("  <authors>");
571          for (int AuthorN = 0; AuthorN < AuthorV.Len(); AuthorN++) {
572              SOut.PutStrLn("   <author>" +
573                  TXmlDoc::GetXmlStr(AuthorV[AuthorN]) + "</author>");
574          }
575          SOut.PutStrLn("  </authors>");
576      }
577      if (!FrameNm.Empty() && (FrameSortN != -1)) {
578          SOut.PutStrLn(TStr::Fmt("  <frame id=\"%d\">%s</frame>",
579              FrameSortN, TXmlDoc::GetXmlStr(FrameNm).CStr()));
580      }
581      SOut.PutStrLn(" </document>");
582  }
583  int TVizMapXmlDoc::AddToBowDocBs(PVizMapXmlDocBs VizMapXmlDocBs, PBowDocBs BowDocBs) const {
584      TStr DocNm = Nm;
585      if (BowDocBs->IsDocNm(DocNm)) {
586          int Count = 2; TStr NewDocNm;
587          do { NewDocNm = TStr::Fmt("%s (%3d)", DocNm.CStr(), Count++);
588          } while (BowDocBs->IsDocNm(NewDocNm));
589          DocNm = NewDocNm;
590      }
591      TStr DocBody = Body;
592      TStrV CatNmV;
593      for (int CatIdN = 0; CatIdN < CatIdV.Len(); CatIdN++) {
594          const int CatId = CatIdV[CatIdN];
595          CatNmV.Add(VizMapXmlDocBs->CatNmH.GetKey(CatId));
596      }
597      const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, true);
598      TStr AuthorStr;
599      for (int AuthorIdN = 0; AuthorIdN < AuthorIdV.Len(); AuthorIdN++) {
600          const int AuthorId = AuthorIdV[AuthorIdN];
601          if (AuthorIdN > 0) { AuthorStr + ", "; }
602          AuthorStr += VizMapXmlDocBs->AuthorNmH.GetKey(AuthorId);
603      }
604      if (!DisplayBody.Empty()) {
605          TStr DisplayBody = AuthorStr.Empty() ? DisplayBody :
606              AuthorStr + "\r\n" + DisplayBody;
607          BowDocBs->PutDocStr(DId, DisplayBody);
608      } else if (!AuthorStr.Empty()) {
609          BowDocBs->PutDocStr(DId, AuthorStr + "\r\n" + DocBody);
610      }
611      return DId;
612  }
613  TVizMapXmlDocBs::TVizMapXmlDocBs(const TStr& XmlFNm, const PNotify& Notify) {
614      PSIn XmlSIn = TFIn::New(XmlFNm); TXmlDoc::SkipTopTag(XmlSIn);
615      PXmlDoc XmlDoc; int XmlDocs=0;
616      forever {
617          XmlDoc = TXmlDoc::LoadTxt(XmlSIn); XmlDocs++;
618          if (!XmlDoc->IsOk()) { &bsol;*InfoNotify(XmlDoc->GetMsgStr());*/ break; }
619          if (XmlDocs % 10 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", XmlDocs)); }
620          PXmlTok XmlTok = XmlDoc->GetTok();
621          TVizMapXmlDoc VizMapXmlDoc;
622          VizMapXmlDoc.Nm = XmlTok->GetTagVal("name", false);
623          VizMapXmlDoc.Body = XmlTok->GetTagVal("body", false);
624          if (XmlTok->IsTagTok("display_body")) {
625              VizMapXmlDoc.DisplayBody = XmlTok->GetTagVal("display_body", false); }
626          TXmlTokV CatTokV; XmlTok->GetTagTokV("categories|category", CatTokV);
627          for (int CatTokN = 0; CatTokN < CatTokV.Len(); CatTokN++) {
628              TStr CatNm = CatTokV[CatTokN]->GetTokStr(false);
629              int CatId = CatNmH.AddKey(CatNm.GetTrunc());
630              VizMapXmlDoc.CatIdV.Add(CatId);
631          }
632          TXmlTokV AuthorTokV; XmlTok->GetTagTokV("authors|author", AuthorTokV);
633          for (int AuthorTokN = 0; AuthorTokN < AuthorTokV.Len(); AuthorTokN++) {
634              TStr AuthorNm = AuthorTokV[AuthorTokN]->GetTokStr(false);
635              int AuthorId = AuthorNmH.AddKey(AuthorNm.GetTrunc());
636              VizMapXmlDoc.AuthorIdV.Add(AuthorId);
637          }
638          if (XmlTok->IsSubTag("frame")) {
639              TStr FrameNm = XmlTok->GetTagVal("frame", false);
640              const int FrameSortN = XmlTok->GetTagTok("frame")->GetIntArgVal("id", -1);
641              if (FrameNmToSortN.IsKey(FrameNm)) {
642                  IAssert(FrameSortN == FrameNmToSortN(FrameNm));
643              } else {
644                  FrameNmToSortN.AddDat(FrameNm, FrameSortN);
645              }
646              VizMapXmlDoc.FrameNm = FrameNm.GetTrunc();
647              VizMapXmlDoc.FrameSortN = FrameSortN;
648          } else {
649              IAssert(FrameNmToSortN.Empty());
650          }
651          const int DocId = XmlDocV.Add(VizMapXmlDoc);
652          if (!FrameNmToSortN.Empty()) {
653              FrameSortNToDocId.AddDat(VizMapXmlDoc.FrameSortN).Add(DocId);
654          }
655      }
656      Notify->OnStatus(TStr::Fmt("%d", XmlDocs-1));
657  }
658  TVizMapXmlDocBs::TVizMapXmlDocBs(const PWdGixRSet& RSet,
659          const TVizMapXmlDocGrouping& Grouping, const PNotify& Notify) {
660      const int Docs = RSet->GetDocs();
661      for (int DocN = 0; DocN < Docs; DocN++) {
662          TVizMapXmlDoc VizMapXmlDoc;
663          TTm DateTm = RSet->GetDocDateTime(DocN);
664          int FrameSortN = 0; TStr FrameNm = "";
665          if (Grouping == vmxdgDay) {
666              FrameNm = DateTm.GetWebLogDateStr();
667              FrameSortN = TTm::GetDateIntFromTm(DateTm);
668          } else if (Grouping == vmxdgMonth) {
669              FrameNm = TStr::Fmt("%04d-%02d", DateTm.GetYear(), DateTm.GetMonth());
670              FrameSortN = TTm::GetMonthIntFromTm(DateTm);
671          } else if (Grouping == vmxdgYear) {
672              FrameNm = TStr::Fmt("%04d", DateTm.GetYear());
673              FrameSortN = DateTm.GetYear();
674          }
675          if (Grouping == vmxdgNone) {
676              IAssert(FrameNmToSortN.Empty());
677          } else {
678              if (FrameNmToSortN.IsKey(FrameNm)) {
679                  IAssert(FrameSortN == FrameNmToSortN(FrameNm));
680              } else {
681                  FrameNmToSortN.AddDat(FrameNm, FrameSortN);
682              }
683          }
684          VizMapXmlDoc.FrameNm = FrameNm;
685          VizMapXmlDoc.FrameSortN = FrameSortN;
686          PXmlDoc Doc=TXmlDoc::LoadStr(RSet->GetDocStr(DocN));
687          IAssertR(Doc->IsOk(), Doc->GetMsgStr());
688          VizMapXmlDoc.Nm =Doc->GetTagTok("doc|title")->GetTokStr(false);
689          TChA BodyChA; VizMapXmlDoc.AuthorIdV.Clr();
690          TXmlTokV ParTokV; Doc->GetTagTokV("doc|body|p", ParTokV);
691          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
692              TStr ParStr = ParTokV[ParTokN]->GetTokStr(false);
693              if (!BodyChA.Empty()) { BodyChA += "\r\n"; }
694              BodyChA += ParStr;
695              TXmlTokV NmEnTokV; ParTokV[ParTokN]->GetTagTokV("nmobj", NmEnTokV);
696              for (int NmEnTokN = 0; NmEnTokN < NmEnTokV.Len(); NmEnTokN++) {
697                  TStr NmEnStr = NmEnTokV[NmEnTokN]->GetTokStr(false);
698                  const int NmEnId = AuthorNmH.AddKey(NmEnStr);
699                  VizMapXmlDoc.AuthorIdV.AddMerged(NmEnId);
700              }
701          }
702          VizMapXmlDoc.Body = BodyChA;
703          VizMapXmlDoc.CatIdV.Clr();
704          const TStrV& CatNmV = RSet->GetDocCatNmV(DocN);
705          for (int CatNmN = 0; CatNmN < CatNmV.Len(); CatNmN++) {
706              const TStr& CatNm = CatNmV[CatNmN];
707              const int CatId = CatNmH.AddKey(CatNm); CatNmH[CatId]++;
708              VizMapXmlDoc.CatIdV.AddMerged(CatId);
709          }
710          const int DocId = XmlDocV.Add(VizMapXmlDoc);
711          if (!FrameNmToSortN.Empty()) {
712              FrameSortNToDocId.AddDat(VizMapXmlDoc.FrameSortN).Add(DocId);
713          }
714      }
715  }
716  PBowDocBs TVizMapXmlDocBs::LoadBowDocBs(const TStr& XmlFNm, PSwSet SwSet,
717          PStemmer Stemmer, const int& MxNGramLen, const int& MnNGramFq) {
718      PVizMapXmlDocBs XmlDocBs = TVizMapXmlDocBs::New(XmlFNm);
719      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
720      PNGramBs NGramBs = NULL;
721      if (MxNGramLen > 1) {
722          TStrV DocBodyV(XmlDocV.Len(), 0);
723          for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
724              const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
725              DocBodyV.Add(XmlDoc.Nm + "\n" + XmlDoc.Body);
726          }
727          NGramBs = TNGramBs::GetNGramBsFromHtmlStrV(DocBodyV,
728              MxNGramLen, MnNGramFq, SwSet, Stemmer);
729      }
730      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NGramBs);
731      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
732          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
733          TStr DocNm = XmlDoc.Nm, DocBody = XmlDoc.Body;
734          TStrV CatNmV;
735          for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
736              const int CatId = XmlDoc.CatIdV[CatIdN];
737              CatNmV.Add(XmlDocBs->CatNmH.GetKey(CatId));
738          }
739          TStr AuthorStr;
740          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
741              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
742              if (AuthorIdN > 0) { AuthorStr + ", "; }
743              AuthorStr += XmlDocBs->AuthorNmH.GetKey(AuthorId);
744          }
745          if (AuthorStr.Empty()) { DocBody = DocBody; }
746          else { DocBody = AuthorStr + "\r\n" + DocBody;}
747          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, true);
748          if (!XmlDoc.DisplayBody.Empty()) {
749              TStr DisplayBody = AuthorStr.Empty() ? XmlDoc.DisplayBody :
750                  AuthorStr + "\r\n" + XmlDoc.DisplayBody;
751              BowDocBs->PutDocStr(DId, DisplayBody);
752          }
753      }
754      return BowDocBs;
755  }
756  void TVizMapFactory::CG(const TMatrix& Matrix, const TFltV& b,
757          TFltV& x, PNotify Notify, const int& MaxStep, const double& EpsTer) {
758      int M = x.Len(), R = b.Len(), i;
759      TFltV r(M), p(M), q(M), tmp(R);
760      x.PutAll(0.0);
761      Matrix.MultiplyT(b, r);
762      double nro, ro, alpha, beta;
763      nro = TLinAlg::Norm2(r);
764      int k=1;
765      while (k <= MaxStep && nro > EpsTer && k <= M){
766          if (k == 1) {
767              p = r;
768          } else {
769              beta = nro / ro;
770              for (i = 0; i < M; i++)
771                  p[i] = r[i] + beta*p[i];
772          }
773          Matrix.Multiply(p, tmp);
774          Matrix.MultiplyT(tmp, q);
775          alpha = nro / TLinAlg::DotProduct(p, q);
776          for (i = 0; i < M; i++) {
777              x[i] = x[i] + alpha * p[i];
778              r[i] = r[i] - alpha * q[i];
779          }
780          ro = nro;
781          nro = TLinAlg::Norm2(r);
782          k++;
783      }
784  }
785  void TVizMapFactory::MakeFlat(PSVMTrainSet Set,
786          const TVizDistType& DistType, TVec<TFltV>& DocPointV,
787          const int& MxStep, const int& MxSecs, const double& MnDiff,
788          const bool& RndStartPos, PNotify Notify) {
789      const int Len = Set->Len();
790      const int EqN = (Len*(Len - 1))/2;
791      Notify->OnStatus(TStr::Fmt("matrix size: %d x %d", EqN, 2*Len));
792      TFltV x(Len), y(Len), dxdy(Len + Len);
793      if (RndStartPos) {
794          TRnd Rnd1(1), Rnd2(2);
795          TLAMisc::FillRnd(x, Rnd1); TLAMisc::FillRnd(y, Rnd2);
796      } else {
797          EAssertR(DocPointV.Len() == Len, TStr::Fmt("%d == %d", DocPointV.Len(), Len));
798          for (int PntN = 0; PntN < Len; PntN++) {
799              x[PntN] = DocPointV[PntN][0];
800              y[PntN] = DocPointV[PntN][1];
801          }
802      }
803      TFltV b(EqN), z(2*Len);
804      TSparseRowMatrix B; B.RowN = EqN; B.ColN = 2*Len; B.DocSpVV.Gen(EqN);
805      for (int i = 0; i < B.RowN; i++) B.DocSpVV[i].Gen(4);
806      int Step = 0; TTm StartTm = TTm::GetCurUniTm();
807      int PrevTimeSec = 0;
808      forever {
809          b.PutAll(0.0); z.PutAll(0.0);
810          int k = 0;
811          TVec<TIntFltKdV>& RowVV = B.DocSpVV;
812          for (int i = 0; i < Len; i++) {
813              for (int j = i+1; j < Len; j++) {
814                  TIntFltKdV& RowV = RowVV[k];
815                  RowV[0] = TIntFltKd(i, x[i] - x[j]);
816                  RowV[1] = TIntFltKd(j, x[j] - x[i]);
817                  RowV[2] = TIntFltKd(Len+i, y[i] - y[j]);
818                  RowV[3] = TIntFltKd(Len+j, y[j] - y[i]);
819                  double Dij = 0.0;
820                  switch (DistType) {
821                      case vdtEucl:    Dij = Set->EuclDist(i, j); break;
822                      case vdtCos: Dij = 1.0 - Set->DotProduct(i, j); break;
823                      case vdtSqrtCos: Dij = 1.0 - sqrt(Set->DotProduct(i, j)); break;
824                      default: TExcept::Throw("Wrong DistType!");
825                  }
826                  b[k] = (TMath::Sqr(Dij) - TMath::Sqr(x[j]-x[i]) - TMath::Sqr(y[j]-y[i])) / 2;
827                  k++;
828              }
829          }
830          dxdy.PutAll(0.0);
831          CG(B, b, dxdy, Notify);
832          double Diff = TMath::Mx(TFlt::Abs(dxdy[0]), TFlt::Abs(dxdy[Len]));
833          for (int i = 0; i < Len; i++) {
834              x[i] += dxdy[i]; y[i] += dxdy[Len+i];
835              Diff = TMath::Mx(Diff, TFlt::Abs(dxdy[i]), TFlt::Abs(dxdy[Len+i]));
836          }
837          Step = Step + 1;
838          const int RunTimeSec =
839            int(TTm::GetDiffMSecs(StartTm, TTm::GetCurUniTm()) / 1000);
840          if (PrevTimeSec < RunTimeSec) {
841              PrevTimeSec = RunTimeSec;
842              Notify->OnStatus(TStr::Fmt("[Step:%5d, Time:%4d, Diff %8.5f]\r", Step, RunTimeSec, Diff));
843          }
844          if ((MxStep > 0) && (Step > MxStep))  { break; }
845          if ((MxSecs > 0) && (RunTimeSec > MxSecs))  { break; }
846          if ((Diff >= 0.0) && (Diff < MnDiff))  { break; }
847      }
848      Notify->OnStatus("\n");
849      DocPointV.Gen(Len, 0);
850      for (int i = 0; i < Len; i++) {
851          DocPointV.Add(TFltV::GetV(x[i], y[i]));
852      }
853  }
854  void TVizMapFactory::NormalizePoints(TVec<TFltV>& PointV) {
855      const int Dim = PointV[0].Len();
856      for (int d = 0; d < Dim; d++) {
857          double Min = PointV[0][d];
858          double Max = PointV[0][d];
859          for (int i = 1; i < PointV.Len(); i++) {
860              const double PointVal = PointV[i][d];
861              Min = TFlt::GetMn(Min, PointVal);
862              Max = TFlt::GetMx(Max, PointVal);
863          }
864          double Diff = Max - Min; IAssert(Diff > 0);
865          for (int i = 0; i < PointV.Len(); i++) {
866              const double OldVal = PointV[i][d];
867              const double NewVal = 0.96*(OldVal - Min)/Diff + 0.02;
868              EAssertR(0.0 <= NewVal && NewVal <= 1.0,
869                TStr::Fmt("%d:%d %g %g %g %g %g", i,
870                PointV.Len(), Min, Max, Diff, OldVal, NewVal));
871              PointV[i][d] = NewVal;
872          }
873      }
874  }
875  void TVizMapFactory::LsiMds(TVec<PBowSpV> DocSpV, PSemSpace SemSpace,
876          TVec<TFltV>& DocPointV, const double& SemSpaceThresh,
877          const int& MxStep, const int& MxSecs, const double& MnDiff,
878          PNotify Notify) {
879      double ApproxVal;
880      Notify->OnStatus(TStr::Fmt("Approximating %d docs ...\n", DocSpV.Len()));
881      int SemSpcDim = SemSpace->GetDimNeededForApprox(
882          DocSpV, SemSpaceThresh, ApproxVal, 3);
883      EAssert((SemSpcDim == -1) || (SemSpcDim > 0));
884      if (SemSpcDim == -1) { SemSpcDim = SemSpace->GetVecs(); }
885      Notify->OnStatus(TStr::Fmt("Norm(dim:%d) = [avg: %.3f, mn:%.3f]",
886          SemSpcDim, ApproxVal, SemSpaceThresh));
887      Notify->OnStatus("Multidimensional Scaling:");
888      const int Docs = DocSpV.Len();
889      TVec<PBowSpV> ProjDocSpV(Docs, 0);
890      for (int DocN = 0; DocN < Docs; DocN++) {
891          ProjDocSpV.Add(SemSpace->ProjectSpV(DocSpV[DocN], SemSpcDim, false)); }
892      PSVMTrainSet DocSet = TBowDocBs2TrainSet::NewBowNoCat(ProjDocSpV);
893      MakeFlat(DocSet, vdtEucl, DocPointV, MxStep,
894          MxSecs, MnDiff, DocPointV.Empty(), Notify);
895      NormalizePoints(DocPointV);
896  }
897  PVizMapFrame TVizMapFactory::DocLsiMds(PBowDocWgtBs BowDocWgtBs,
898          PSemSpace SemSpace, const TVec<TFltV>& _DocPointV,
899          const double& SemSpaceThresh, const int& MxStep,
900          const int& MxSecs, const double& MnDiff, PNotify Notify) {
901      const int Docs = BowDocWgtBs->GetDocs();
902      TVec<PBowSpV> DocSpV(Docs, 0);
903      for (int DIdN = 0; DIdN < Docs; DIdN++) {
904          const int DId = BowDocWgtBs->GetDId(DIdN);
905          DocSpV.Add(BowDocWgtBs->GetSpV(DId));
906      }
907      TVec<TFltV> DocPointV = _DocPointV;
908      LsiMds(DocSpV, SemSpace, DocPointV, SemSpaceThresh, MxStep, MxSecs, MnDiff, Notify);
909      PVizMapFrame VizMapFrame = TVizMapFrame::New();
910      for (int DIdN = 0; DIdN < Docs; DIdN++) {
911          const int DId = BowDocWgtBs->GetDId(DIdN);
912          PVizMapPoint DocPoint = TVizMapPoint::New(DocPointV[DIdN]);
913          DocPoint->PutDocId(DId); VizMapFrame->AddPoint(DocPoint);
914      }
915      VizMapFrame->CalcDId2PointNMap();
916      return VizMapFrame;
917  }
918  void TVizMapFactory::AddDocMetadata(PVizMapFrame VizMapFrame,
919          PBowDocBs PointBowDocBs, PBowDocBs KeyWdBowDocBs,
920          PBowDocWgtBs KeyWdBowDocWgtBs, PVizMapLndMrk VizMapLndMrk) {
921      for (int CId = 0; CId < PointBowDocBs->GetCats(); CId++) {
922          TStr CatNm = PointBowDocBs->GetCatNm(CId);
923          const int NewCId = VizMapFrame->AddCatNm(CatNm);
924          IAssert(NewCId == CId);
925      }
926      VizMapFrame->PutPointBow(PointBowDocBs);
927      const int PointDocs = PointBowDocBs->GetDocs();
928      for (int PointDId = 0; PointDId < PointDocs; PointDId++) {
929          if (VizMapFrame->IsInDId(PointDId)) {
930              const int PointN = VizMapFrame->GetPointN(PointDId);
931              VizMapFrame->GetPoint(PointN)->PutPointNm(PointBowDocBs->GetDocNm(PointDId));
932              const int PointCIds = PointBowDocBs->GetDocCIds(PointDId);
933              for (int PointCIdN = 0; PointCIdN < PointCIds; PointCIdN++) {
934                  const int PointCId = PointBowDocBs->GetDocCId(PointDId, PointCIdN);
935                  VizMapFrame->AddCat(PointN, PointCId);
936              }
937          }
938      }
939      if (VizMapLndMrk.Empty()) {
940          TBowSpVV KeyWdSpVV;
941          const int Points = VizMapFrame->GetPoints();
942          for (int PointN = 0; PointN <  Points; PointN++) {
943              const int PointDId = VizMapFrame->GetPoint(PointN)->GetDocId();
944              PBowSpV KeyWdSpV = KeyWdBowDocWgtBs->GetSpV(PointDId);
945              KeyWdSpVV.Add(KeyWdSpV);
946          }
947          VizMapFrame->PutKeyWdBow(KeyWdBowDocBs, KeyWdSpVV);
948      } else {
949          TBowSpVV KeyWdSpVV;
950          const int LndMrks = VizMapLndMrk->GetLndMrks();
951          for (int LndMrkN = 0; LndMrkN < LndMrks; LndMrkN++) {
952              PVizMapPoint KeyWdPoint =
953                  TVizMapPoint::New(VizMapLndMrk->GetLndMrkPointV(LndMrkN));
954              VizMapFrame->AddKeyWdPoint(KeyWdPoint);
955              PBowSpV KeyWdSpV = VizMapLndMrk->GetLndMrkSpV(LndMrkN);
956              KeyWdSpVV.Add(KeyWdSpV);
957          }
958          VizMapFrame->PutKeyWdBow(KeyWdBowDocBs, KeyWdSpVV);
959      }
960  }
961  void TVizMapFactory::LndMrk(PBowDocWgtBs BowDocWgtBs, PBowSim BowSim,
962          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
963          TVec<TFltV>& DocPointV, const int& LinCombNum, PNotify Notify) {
964      const int Clusts = ClustSpV.Len();
965      const int TopClustN = TInt::GetMn(LinCombNum, Clusts);
966      const int Docs = BowDocWgtBs->GetDocs();
967      Notify->OnStatus(TStr::Fmt("Positioning %d documents using %d landmarks:", Docs, Clusts));
968      DocPointV.Gen(Docs, 0);
969      for (int DocN = 0; DocN < Docs; DocN++) {
970          Notify->OnStatus(TStr::Fmt("%d\r", DocN));
971          const int DId = BowDocWgtBs->GetDId(DocN);
972          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
973          TFltIntKdV SimClustV(Clusts, 0);
974          for (int ClustId = 0; ClustId < Clusts; ClustId++) {
975              const double ClustSim = BowSim->GetSim(DocSpV, ClustSpV[ClustId]);
976              SimClustV.Add(TFltIntKd(ClustSim, ClustId));
977          }
978          SimClustV.Sort(false);
979          double SimSum = 0.0;
980          for (int ClustN = 0; ClustN < TopClustN; ClustN++) {
981              SimSum += SimClustV[ClustN].Key; }
982          DocPointV.Add(TFltV::GetV(0.0, 0.0));
983          for (int ClustN = 0; ClustN < TopClustN; ClustN++) {
984              const double SumWgt = (SimSum > 1e-7) ?
985                  SimClustV[ClustN].Key / SimSum : 0.0;
986              const int ClustId = SimClustV[ClustN].Dat;
987              TLinAlg::AddVec(SumWgt, ClustPointV[ClustId],
988                  DocPointV.Last(), DocPointV.Last());
989          }
990      }
991      Notify->OnStatus("");
992  }
993  PVizMapFrame TVizMapFactory::DocLndMrk(PBowDocWgtBs BowDocWgtBs,
994          const TVec<PBowSpV>& ClustSpV, const TVec<TFltV>& ClustPointV,
995          const int& LinCombNum, PNotify Notify) {
996      TVec<TFltV> DocPointV;
997      PBowSim BowSim = TBowSim::New(bstCos);
998      LndMrk(BowDocWgtBs, BowSim, ClustSpV, ClustPointV, DocPointV, LinCombNum, Notify);
999      PVizMapFrame VizMapFrame = TVizMapFrame::New();
1000      const int Docs = BowDocWgtBs->GetDocs();
1001      for (int DIdN = 0; DIdN < Docs; DIdN++) {
1002          const int DId = BowDocWgtBs->GetDId(DIdN);
1003          PVizMapPoint DocPoint = TVizMapPoint::New(DocPointV[DIdN]);
1004          DocPoint->PutDocId(DId); VizMapFrame->AddPoint(DocPoint);
1005      }
1006      VizMapFrame->CalcDId2PointNMap();
1007      return VizMapFrame;
1008  }
1009  PVizMapFrame TVizMapFactory::ClustLsiMdsDocLndMrk(PBowDocWgtBs BowDocWgtBs,
1010          PBowDocPart BowDocPart, PSemSpace SemSpace, const int& LinCombNum,
1011          const double& SemSpaceThresh, const int& MxStep, const int& MxSecs,
1012          const double& MnDiff, PNotify Notify) {
1013      const int Clusts = BowDocPart->GetClusts();
1014      TVec<PBowSpV> ClustSpV(Clusts, 0);
1015      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
1016          ClustSpV.Add(BowDocPart->GetClust(ClustN)->GetConceptSpV()); }
1017      TVec<TFltV> ClustPointV; EAssert(ClustPointV.Empty());
1018      LsiMds(ClustSpV, SemSpace, ClustPointV,
1019          SemSpaceThresh, MxStep, MxSecs, MnDiff, Notify);
1020      return DocLndMrk(BowDocWgtBs, ClustSpV, ClustPointV, LinCombNum, Notify);
1021  }
1022  PVizMapFrame TVizMapFactory::NewVizMapFrame(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1023          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
1024          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1025          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1026      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); PVizMapFrame VizMapFrame;
1027      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocBs->GetDocs()));
1028      if (BowDocBs->GetDocs() < ThDocs) {
1029          Notify->OnStatus("Calculating semantic space ... ");
1030          PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(
1031              BowDocWgtBs, AllDIdV, BowDocBs->GetDocs());
1032          Notify->OnStatus("Calculating visualization map ... ");
1033          VizMapFrame = TVizMapFactory::DocLsiMds(BowDocWgtBs, SemSpace,
1034              TVec<TFltV>(), 0.93 * SvdThreshold, 5000, 500, 0.0001, Notify);
1035          Notify->OnStatus("Adding metadata ... ");
1036          TVizMapFactory::AddDocMetadata(VizMapFrame,
1037              KeyWdBowDocBs, KeyWdBowDocBs, KeyWdBowDocWgtBs);
1038          Notify->OnStatus("Calculating background landscapes ... ");
1039          if (CalcLandscapeP && KeyWdBowDocBs->IsCats()) {
1040              VizMapFrame->AddLandscape(400, 400, 0.02, LndPointWgt);
1041          } else if (CalcLandscapeP) {
1042              VizMapFrame->AddLandscape(400, 400, 0.02, LndPointWgt);
1043          }
1044      } else {
1045          Notify->OnStatus("Using large-scale pipeline ...");
1046          PBowSim BowSim = TBowSim::New(bstCos);
1047          TRnd Rnd(1);
1048          PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
1049              Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd, Clusts, 1, 10, 1);
1050          Notify->OnStatus("Calculating LSI ...");
1051          const int LndMrks = BowDocPart->GetClusts();
1052          TVec<PBowSpV> LndMrkSpV(LndMrks, 0);
1053          for (int LndMrkN = 0; LndMrkN < LndMrks; LndMrkN++) {
1054              LndMrkSpV.Add(BowDocPart->GetClust(LndMrkN)->GetConceptSpV()); }
1055          PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(LndMrkSpV, LndMrks-1);
1056          Notify->OnStatus("Calculating visualization map ... ");
1057          VizMapFrame = TVizMapFactory::ClustLsiMdsDocLndMrk(BowDocWgtBs, BowDocPart,
1058              SemSpace, 3, SvdThreshold, 5000, 500, 0.0001, Notify);
1059          Notify->OnStatus("Adding metadata ... ");
1060          TVizMapFactory::AddDocMetadata(VizMapFrame,
1061              KeyWdBowDocBs, KeyWdBowDocBs, KeyWdBowDocWgtBs);
1062          Notify->OnStatus("Calculating background landscapes ... ");
1063          double BellSize = 0.02;
1064          if (BowDocBs->GetDocs() > 1500) BellSize *= 0.7;
1065          if (BowDocBs->GetDocs() > 2000) BellSize *= 0.7;
1066          if (BowDocBs->GetDocs() > 3000) BellSize *= 0.5;
1067          if (BowDocBs->GetDocs() > 4000) BellSize *= 0.5;
1068          if (CalcLandscapeP && KeyWdBowDocBs->IsCats()) {
1069              VizMapFrame->AddLandscape(400, 400, BellSize, LndPointWgt);
1070          } else if (CalcLandscapeP) {
1071              VizMapFrame->AddLandscape(400, 400, BellSize, LndPointWgt);
1072          }
1073      }
1074      Notify->OnStatus("Done ... ");
1075      return VizMapFrame;
1076  }
1077  PVizMapFrame TVizMapFactory::NewVizMapFrame(PBowDocBs BowDocBs, const int& ThDocs,
1078          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1079          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1080      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF);
1081      return NewVizMapFrame(BowDocBs, BowDocWgtBs, BowDocBs, BowDocWgtBs,
1082          ThDocs, Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1083  }
1084  PVizMapFrame TVizMapFactory::NewVizMapFrameFromLndMrk(PBowDocBs BowDocBs,
1085          PBowDocWgtBs BowDocWgtBs, PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP,
1086          const bool& LndMrkKeyWdP, const PNotify& Notify) { 
1087      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocWgtBs->GetDocs()));
1088      Notify->OnStatus("Calculating visualization map ... ");
1089      const TBowSpVV& LndMrkSpVV = VizMapLndMrk->GetLndMrkSpVV();
1090      const TVec<TFltV>& LndMrkPointVV = VizMapLndMrk->GetLndMrkPointVV();
1091      PVizMapFrame VizMapFrame = DocLndMrk(BowDocWgtBs,
1092          LndMrkSpVV, LndMrkPointVV, 20, Notify);
1093      Notify->OnStatus("Adding metadata ... ");
1094      if (LndMrkKeyWdP) {
1095          AddDocMetadata(VizMapFrame, BowDocBs, VizMapLndMrk->GetBowDocBs(),
1096              VizMapLndMrk->GetBowDocWgtBs(), VizMapLndMrk);
1097      } else {
1098          AddDocMetadata(VizMapFrame, BowDocBs, BowDocBs, BowDocWgtBs);
1099      }
1100      Notify->OnStatus("Calculating background landscapes ... ");
1101      double BellSize = 0.02;
1102      if (BowDocBs->GetDocs() > 1500) BellSize *= 0.7;
1103      if (BowDocBs->GetDocs() > 2000) BellSize *= 0.7;
1104      if (BowDocBs->GetDocs() > 3000) BellSize *= 0.5;
1105      if (BowDocBs->GetDocs() > 4000) BellSize *= 0.5;
1106      if (!LndMrkLndP && BowDocBs->IsCats()) {
1107          VizMapFrame->AddLandscape(400, 400, BellSize, false);
1108      } else if (!LndMrkLndP) {
1109          VizMapFrame->AddLandscape(400, 400, BellSize, false);
1110      } else {
1111          VizMapFrame->AddLandscapeFromLndMrk(400, 400, BellSize, LndMrkPointVV);
1112      }
1113      Notify->OnStatus("Done ... ");
1114      return VizMapFrame;
1115  }
1116  PVizMap TVizMapFactory::NewVizMap(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1117          PBowDocBs KeyWdBowDocBs, PBowDocWgtBs KeyWdBowDocWgtBs, const int& ThDocs,
1118          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1119          const bool& LndPointWgtP, const bool& CalcLandscapeP) {
1120      return TVizMap::New(NewVizMapFrame(BowDocBs, BowDocWgtBs, KeyWdBowDocBs,
1121          KeyWdBowDocWgtBs, ThDocs, Clusts, SvdThreshold, Notify, LndPointWgtP,
1122          CalcLandscapeP));
1123  }
1124  PVizMap TVizMapFactory::NewVizMap(PBowDocBs BowDocBs, const int& ThDocs,
1125          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1126          const bool& LndPointWgtP, const bool& CalcLandscapeP) {
1127      return TVizMap::New(NewVizMapFrame(BowDocBs, ThDocs, Clusts,
1128          SvdThreshold, Notify, LndPointWgtP, CalcLandscapeP));
1129  }
1130  PVizMap TVizMapFactory::NewVizMapStaticDoc(const PVizMapXmlDocBs& XmlDocBs,
1131          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1132          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1133          const bool& CalcLandscapeP) {
1134      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1135      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1136      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1137          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1138          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs);
1139          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1140      }
1141      return NewVizMap(BowDocBs, ThDocs, Clusts, SvdThreshold,
1142          Notify, LndPointWgt, CalcLandscapeP);
1143  }
1144  PVizMap TVizMapFactory::NewVizMapDynamicDoc(const PVizMapXmlDocBs& XmlDocBs,
1145          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1146          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1147          const bool& CalcLandscapeP) {
1148      TIntStrH FrameSortNToNmH; TIntIntVH FrameSortNToDIdVH;
1149      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1150      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1151      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1152          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1153          const int FrameSortN = XmlDoc.FrameSortN;
1154          const TStr& FrameNm = XmlDoc.FrameNm;
1155          if (FrameSortNToNmH.IsKey(FrameSortN)) {
1156              IAssertR(FrameSortNToNmH.GetDat(FrameSortN) == FrameNm,
1157                  FrameSortNToNmH.GetDat(FrameSortN) + " != " + FrameNm);
1158          } else {
1159              FrameSortNToNmH.AddDat(FrameSortN, FrameNm);
1160          }
1161          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs);
1162          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1163          FrameSortNToDIdVH.AddDat(FrameSortN).Add(DId);
1164      }
1165      FrameSortNToNmH.SortByKey();
1166      PVizMapLndMrk VizMapLndMrk = TVizMapFactory::NewVizMapLndMrk(
1167          BowDocBs, TIntV(), ThDocs, Clusts, SvdThreshold, Notify);
1168      PVizMap VizMap = TVizMap::New();
1169      Notify->OnStatus(TStr::Fmt("Processing %d frames ... ", FrameSortNToNmH.Len()));
1170      int FrameKeyId = FrameSortNToNmH.FFirstKeyId();
1171      while (FrameSortNToNmH.FNextKeyId(FrameKeyId)) {
1172          const int FrameSortN = FrameSortNToNmH.GetKey(FrameKeyId);
1173          const TIntV& FrameDIdV = FrameSortNToDIdVH.GetDat(FrameSortN);
1174          Notify->OnStatus(TStr::Fmt("Frame %d/%d (%d)... ",
1175              FrameKeyId+1, FrameSortNToNmH.Len(), FrameDIdV.Len()));
1176          PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1177              BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, FrameDIdV);
1178          PVizMapFrame VizMapFrame = NewVizMapFrameFromLndMrk(BowDocBs,
1179              BowDocWgtBs, VizMapLndMrk, false, false, Notify);
1180          Notify->OnStatus("Adding metadata ... ");
1181          VizMapFrame->PutFrameNm(FrameSortNToNmH.GetDat(FrameSortN));
1182          VizMap->AddVizMapFrame(VizMapFrame, true);
1183      }
1184      Notify->OnStatus("Done");
1185      return VizMap;
1186  }
1187  PVizMap TVizMapFactory::NewVizMapStaticAuthor(const PVizMapXmlDocBs& XmlDocBs,
1188          PSwSet SwSet, PStemmer Stemmer, const int& MxAuthors, const int& ThDocs,
1189          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1190          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1191      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1192      TIntH AuthorIdToFqH;
1193      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1194          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1195          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1196              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1197              AuthorIdToFqH.AddDat(AuthorId)++;
1198          }
1199      }
1200      IAssert(!AuthorIdToFqH.Empty()); AuthorIdToFqH.SortByDat(false);
1201      TIntH FqAuthorIdH;
1202      int AuthorKeyId = AuthorIdToFqH.FFirstKeyId();
1203      while (AuthorIdToFqH.FNextKeyId(AuthorKeyId)) {
1204          if (FqAuthorIdH.Len() == MxAuthors) { break; }
1205          const int AuthorId = AuthorIdToFqH.GetKey(AuthorKeyId);
1206          FqAuthorIdH.AddKey(AuthorId);
1207      }
1208      THash<TInt, TChA> AuthorIdToBodyH, AuthorIdToDisplayBodyH;
1209      TIntStrVH AuthorIdToCatNmVH;
1210      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1211          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1212          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1213              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1214              if (!FqAuthorIdH.IsKey(AuthorId)) { continue; }
1215              AuthorIdToBodyH.AddDat(AuthorId) += XmlDoc.Nm + " -- " + XmlDoc.Body + "\r\n";
1216              TStr DisplayBody = XmlDoc.DisplayBody.Empty() ? XmlDoc.Body : XmlDoc.DisplayBody;
1217              AuthorIdToDisplayBodyH.AddDat(AuthorId) += XmlDoc.Nm + " -- " + DisplayBody + "\r\n";
1218              for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
1219                  const int CatId = XmlDoc.CatIdV[CatIdN];
1220                  AuthorIdToCatNmVH.AddDat(AuthorId).Add(
1221                      XmlDocBs->CatNmH.GetKey(CatId));
1222              }
1223          }
1224      }
1225      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1226      TIntH AuthorIdToDIdH; TIntV AuthorDIdV;
1227      AuthorKeyId = AuthorIdToBodyH.FFirstKeyId();
1228      while (AuthorIdToBodyH.FNextKeyId(AuthorKeyId)) {
1229          const int AuthorId = AuthorIdToBodyH.GetKey(AuthorKeyId);
1230          TStr DocNm = XmlDocBs->AuthorNmH.GetKey(AuthorId);
1231          TStr DocBody = AuthorIdToBodyH.GetDat(AuthorId);
1232          const TStrV& CatNmV = AuthorIdToCatNmVH.AddDat(AuthorId);
1233          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, false);
1234          AuthorDIdV.Add(DId);
1235          BowDocBs->PutDocStr(DId, AuthorIdToDisplayBodyH.GetDat(AuthorId));
1236          AuthorIdToDIdH.AddDat(AuthorId, DId);
1237      }
1238      PVizMapFrame VizMapFrame = NewVizMapFrame(BowDocBs, 300, 200, 0.8, Notify, false, true);
1239      const int MxAuthorFq = AuthorIdToFqH[0];
1240      AuthorKeyId = AuthorIdToDIdH.FFirstKeyId();
1241      while (AuthorIdToDIdH.FNextKeyId(AuthorKeyId)) {
1242          const int AuthorId = AuthorIdToDIdH.GetKey(AuthorKeyId);
1243          const int AuthorDId = AuthorIdToDIdH[AuthorKeyId];
1244          const int AuthorFq = AuthorIdToFqH.GetDat(AuthorId);
1245          const double AuthorWgt = double(AuthorFq) / double(MxAuthorFq);
1246          const int PointN = VizMapFrame->GetPointN(AuthorDId);
1247          VizMapFrame->GetPoint(PointN)->PutWgt(AuthorWgt);
1248      }
1249      return TVizMap::New(VizMapFrame);
1250  }
1251  PVizMap TVizMapFactory::NewVizMapDynamicAuthor(const PVizMapXmlDocBs& XmlDocBs,
1252          PSwSet SwSet, PStemmer Stemmer, const int& MxFrames,
1253          const int& MxAuthors, const int& ThDocs,
1254          const int& Clusts, const double& SvdThreshold, const PNotify& Notify,
1255          const bool& LndPointWgt, const bool& CalcLandscapeP) {
1256      const TVizMapXmlDocV& XmlDocV = XmlDocBs->XmlDocV;
1257      TIntH AuthorIdToFqH;
1258      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1259          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1260          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1261              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1262              AuthorIdToFqH.AddDat(AuthorId)++;
1263          }
1264      }
1265      IAssert(!AuthorIdToFqH.Empty()); AuthorIdToFqH.SortByDat(false);
1266      TIntH FqAuthorIdH;
1267      int AuthorKeyId = AuthorIdToFqH.FFirstKeyId();
1268      while (AuthorIdToFqH.FNextKeyId(AuthorKeyId)) {
1269          if (FqAuthorIdH.Len() == MxAuthors) { break; }
1270          const int AuthorId = AuthorIdToFqH.GetKey(AuthorKeyId);
1271          FqAuthorIdH.AddKey(AuthorId);
1272      }
1273      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
1274      TIntStrH FrameSortNToNmH; TIntIntHH FrameSortNToAuthorIdHH;
1275      THash<TIntPr, TChA> FrameAuthorIdToBodyH, FrameAuthorIdToDisplayBodyH;
1276      TIntPrStrVH FrameAuthorIdToCatNmVH; TIntV DocDIdV;
1277      for (int XmlDocN = 0; XmlDocN < XmlDocV.Len(); XmlDocN++) {
1278          const TVizMapXmlDoc& XmlDoc = XmlDocV[XmlDocN];
1279          const int FrameSortN = XmlDoc.FrameSortN;
1280          const TStr& FrameNm = XmlDoc.FrameNm;
1281          if (FrameSortNToNmH.IsKey(FrameSortN)) {
1282              IAssertR(FrameSortNToNmH.GetDat(FrameSortN) == FrameNm,
1283                  FrameSortNToNmH.GetDat(FrameSortN) + " != " + FrameNm);
1284          } else {
1285              FrameSortNToNmH.AddDat(FrameSortN, FrameNm);
1286          }
1287          for (int AuthorIdN = 0; AuthorIdN < XmlDoc.AuthorIdV.Len(); AuthorIdN++) {
1288              const int AuthorId = XmlDoc.AuthorIdV[AuthorIdN];
1289              if (!FqAuthorIdH.IsKey(AuthorId)) { continue; }
1290              TIntPr FrameAuthorId(FrameSortN, AuthorId);
1291              FrameSortNToAuthorIdHH.AddDat(FrameSortN).AddDat(AuthorId)++;
1292              FrameAuthorIdToBodyH.AddDat(FrameAuthorId) +=
1293                  XmlDoc.Nm + " -- " + XmlDoc.Body + "\r\n";
1294              TStr DisplayBody = XmlDoc.DisplayBody.Empty() ?
1295                  XmlDoc.Body : XmlDoc.DisplayBody;
1296              FrameAuthorIdToDisplayBodyH.AddDat(FrameAuthorId) +=
1297                  XmlDoc.Nm + " -- " + DisplayBody + "\r\n";
1298              for (int CatIdN = 0; CatIdN < XmlDoc.CatIdV.Len(); CatIdN++) {
1299                  const int CatId = XmlDoc.CatIdV[CatIdN];
1300                  FrameAuthorIdToCatNmVH.AddDat(FrameAuthorId).Add(
1301                      XmlDocBs->CatNmH.GetKey(CatId));
1302              }
1303          }
1304          const int DId = XmlDoc.AddToBowDocBs(XmlDocBs, BowDocBs); DocDIdV.Add(DId);
1305          IAssertR(DId == XmlDocN, TStr::Fmt("%d-%d", DId, XmlDocN));
1306      }
1307      FrameSortNToNmH.SortByKey();
1308      TIntPrIntH FrameAuthorIdToDIdH; TIntIntVH FrameToDIdVH;
1309      int FrameAuthorKeyId = FrameAuthorIdToBodyH.FFirstKeyId();
1310      while (FrameAuthorIdToBodyH.FNextKeyId(FrameAuthorKeyId)) {
1311          const TIntPr& FrameAuthorId = FrameAuthorIdToBodyH.GetKey(FrameAuthorKeyId);
1312          const int FrameSortN = FrameAuthorId.Val1;
1313          const int AuthorId = FrameAuthorId.Val2;
1314          TStr DocNm = TStr::Fmt("%s [[%d]]",
1315              XmlDocBs->AuthorNmH.GetKey(AuthorId).CStr(), FrameSortN);
1316          TStr DocBody = FrameAuthorIdToBodyH.GetDat(FrameAuthorId);
1317          const TStrV& CatNmV = FrameAuthorIdToCatNmVH.GetDat(FrameAuthorId);
1318          const int DId = BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocBody, false);
1319          BowDocBs->PutDocStr(DId, FrameAuthorIdToDisplayBodyH.GetDat(FrameAuthorId));
1320          FrameAuthorIdToDIdH.AddDat(FrameAuthorId, DId);
1321          FrameToDIdVH.AddDat(FrameSortN).Add(DId);
1322      }
1323      PVizMapLndMrk VizMapLndMrk = TVizMapFactory::NewVizMapLndMrk(
1324          BowDocBs, DocDIdV, ThDocs, Clusts, SvdThreshold, Notify);
1325      PVizMap VizMap = TVizMap::New();
1326      Notify->OnStatus(TStr::Fmt("Processing %d frames ... ", FrameSortNToNmH.Len()));
1327      int FrameKeyId = FrameSortNToNmH.FFirstKeyId();
1328      while (FrameSortNToNmH.FNextKeyId(FrameKeyId)) {
1329          const int FrameSortN = FrameSortNToNmH.GetKey(FrameKeyId);
1330          Notify->OnStatus(TStr::Fmt("Frame %d/%d... ",
1331              FrameKeyId+1, FrameSortNToNmH.Len()));
1332          const TIntV& FrameDIdV = FrameToDIdVH.GetDat(FrameSortN);
1333          PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1334              BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, FrameDIdV);
1335          PVizMapFrame VizMapFrame = NewVizMapFrameFromLndMrk(BowDocBs,
1336              BowDocWgtBs, VizMapLndMrk, false, false, Notify);
1337          Notify->OnStatus("Adding metadata ... ");
1338          VizMapFrame->PutFrameNm(FrameSortNToNmH.GetDat(FrameSortN));
1339          const TIntH& AuthorIdH = FrameSortNToAuthorIdHH.GetDat(FrameSortN);
1340          int MxAuthorFq = 1, AuthorKeyId = AuthorIdH.FFirstKeyId();
1341          while (AuthorIdH.FNextKeyId(AuthorKeyId)) {
1342              MxAuthorFq = TInt::GetMx(MxAuthorFq, AuthorIdH[AuthorKeyId]); }
1343          AuthorKeyId = AuthorIdH.FFirstKeyId();
1344          while (AuthorIdH.FNextKeyId(AuthorKeyId)) {
1345              const int AuthorId = AuthorIdH.GetKey(AuthorKeyId);
1346              const int AuthorDId = FrameAuthorIdToDIdH.GetDat(TIntPr(FrameSortN, AuthorId));
1347              const int PointN = VizMapFrame->GetPointN(AuthorDId);
1348              const int AuthorFq = AuthorIdH[AuthorKeyId];
1349              const double AuthorWgt = double(AuthorFq) / double(MxAuthorFq);
1350              VizMapFrame->GetPoint(PointN)->PutWgt(AuthorWgt);
1351          }
1352          VizMap->AddVizMapFrame(VizMapFrame, true);
1353      }
1354      Notify->OnStatus("Done");
1355      return VizMap;
1356  }
1357  PVizMap TVizMapFactory::NewVizMap(const PVizMapXmlDocBs& XmlDocBs,
1358          const TVizXmlMapType& VizXmlMapType, PSwSet SwSet, PStemmer Stemmer,
1359          const int& ThDocs, const int& Clusts, const double& SvdThreshold,
1360          const PNotify& Notify, const bool& LndPointWgt, const bool& CalcLandscapeP) {
1361      if (VizXmlMapType == vxmtStaticDoc) {
1362          return NewVizMapStaticDoc(XmlDocBs, SwSet, Stemmer, ThDocs,
1363              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1364      } else if (VizXmlMapType == vxmtDynamicAuthor) {
1365          return NewVizMapDynamicDoc(XmlDocBs, SwSet, Stemmer, ThDocs,
1366              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1367      } else if (VizXmlMapType == vxmtStaticAuthor) {
1368          return NewVizMapStaticAuthor(XmlDocBs, SwSet, Stemmer, -1, ThDocs,
1369              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1370      } else if (VizXmlMapType == vxmtDynamicAuthor) {
1371          return NewVizMapDynamicAuthor(XmlDocBs, SwSet, Stemmer, -1, -1, ThDocs,
1372              Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1373      }
1374      Fail; return NULL;
1375  }
1376  PVizMap TVizMapFactory::NewVizMap(const TStr& XmlFNm, const TVizXmlMapType& VizXmlMapType,
1377          PSwSet SwSet, PStemmer Stemmer, const int& ThDocs, const int& Clusts,
1378          const double& SvdThreshold, const PNotify& Notify, const bool& LndPointWgt,
1379          const bool& CalcLandscapeP) {
1380      PVizMapXmlDocBs XmlDocBs = TVizMapXmlDocBs::New(XmlFNm, Notify);
1381      return NewVizMap(XmlDocBs, VizXmlMapType, SwSet, Stemmer,
1382          ThDocs, Clusts, SvdThreshold, Notify, LndPointWgt, CalcLandscapeP);
1383  }
1384  PVizMapLndMrk TVizMapFactory::NewVizMapLndMrk(PBowDocBs BowDocBs,
1385          PBowDocWgtBs BowDocWgtBs, const int& ThDocs, const int& Clusts,
1386          const double& SvdThreshold, const PNotify& Notify) {
1387      Notify->OnStatus(TStr::Fmt("Size of dataset: %d docs", BowDocWgtBs->GetDocs()));
1388      TVec<PBowSpV> LndMrkSpV;
1389      if (BowDocWgtBs->GetDocs() < ThDocs) {
1390          const int Docs = BowDocWgtBs->GetDocs();
1391          LndMrkSpV.Gen(Docs, 0);
1392          for (int DIdN = 0; DIdN < Docs; DIdN++) {
1393              const int DId = BowDocWgtBs->GetDId(DIdN);
1394              PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
1395              LndMrkSpV.Add(DocSpV);
1396          }
1397      } else {
1398          Notify->OnStatus("Using large-scale pipeline ...");
1399          PBowSim BowSim = TBowSim::New(bstCos);
1400          TRnd Rnd(1);
1401          PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
1402              Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd, Clusts, 1, 10, 1);
1403          const int Clusts = BowDocPart->GetClusts();
1404          LndMrkSpV.Gen(Clusts, 0);
1405          for (int ClustN = 0; ClustN < Clusts; ClustN++) {
1406              LndMrkSpV.Add(BowDocPart->GetClust(ClustN)->GetConceptSpV()); }
1407      }
1408      const int LndMrks = LndMrkSpV.Len();
1409      Notify->OnStatus(TStr::Fmt("Calculating LSI on %d landmarks ...", LndMrks));
1410      PSemSpace SemSpace = TSemSpaceAlg::CalcFullLSI(LndMrkSpV, LndMrks-1);
1411      Notify->OnStatus("Calculating LndMrk map ... ");
1412      TVec<TFltV> LndMrkPointV;
1413      LsiMds(LndMrkSpV, SemSpace, LndMrkPointV, SvdThreshold, 5000, 500, 0.0001, Notify);
1414      Notify->OnStatus("Done ... ");
1415      return TVizMapLndMrk::New(BowDocBs, BowDocWgtBs, LndMrkSpV, LndMrkPointV);
1416  }
1417  PVizMapLndMrk TVizMapFactory::NewVizMapLndMrk(PBowDocBs BowDocBs,
1418          const TIntV& DIdV, const int& ThDocs, const int& Clusts,
1419          const double& SvdThreshold, const PNotify& Notify) {
1420      TIntV NewDIdV;
1421      if (DIdV.Empty()) { BowDocBs->GetAllDIdV(NewDIdV); } else { NewDIdV = DIdV; }
1422      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF, 0, 0, NewDIdV);
1423      return NewVizMapLndMrk(BowDocBs, BowDocWgtBs, ThDocs, Clusts, SvdThreshold, Notify);
1424  }
1425  PVizMap TVizMapFactory::NewVizMapFromLndMrk(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
1426          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP, const bool& LndMrkKeyWdP,
1427          const PNotify& Notify) {
1428      return TVizMap::New(NewVizMapFrameFromLndMrk(BowDocBs, BowDocWgtBs,
1429          VizMapLndMrk, LndMrkLndP, LndMrkKeyWdP, Notify));
1430  }
1431  PVizMap TVizMapFactory::NewVizMapFromLndMrk(PBowDocBs BowDocBs, const TIntV& DIdV,
1432          PVizMapLndMrk VizMapLndMrk, const bool& LndMrkLndP, const bool& LndMrkKeyWdP,
1433          const TBowWordWgtType& WgtType, const PNotify& Notify) {
1434      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, WgtType, 0, 0, DIdV);
1435      return TVizMap::New(NewVizMapFrameFromLndMrk(BowDocBs, BowDocWgtBs,
1436          VizMapLndMrk, LndMrkLndP, LndMrkKeyWdP, Notify));
1437  }
1438  void TVrml::InsertHeader(PSOut SOut, const TStr& SkyColor) {
1439      SOut->PutStrLn("#VRML V2.0 utf8");
1440      SOut->PutStrLn("WorldInfo {");
1441      SOut->PutStrLn("  title \"Semantic Wonderland\"");
1442      SOut->PutStrLn("  info [\"Spluf\"]");
1443      SOut->PutStrLn("}");
1444      SOut->PutStrLn("Background {");
1445      SOut->PutStrLn("  skyColor [0 0 0 , " + SkyColor + "]");
1446      SOut->PutStrLn("  skyAngle [3.14]");
1447      SOut->PutStrLn("}");
1448      SOut->PutStrLn("PointLight {");
1449      SOut->PutStrLn("  location 0 3.5 1");
1450      SOut->PutStrLn("}");
1451  }
1452  double TVrml::InsertEvelationGrid(PSOut SOut, const TSFltVV& Rlf,
1453          TFltVV& NewRlf, const TStr& TerrainColor, const int& N,
1454          const double& Height, const double& Spacing) {
1455      NewRlf.Gen(Rlf.GetXDim()/N, Rlf.GetYDim()/N);
1456      NewRlf.PutAll(0.0);
1457      for (int x = 0; x < Rlf.GetXDim(); x++) {
1458          for (int y = 0; y < Rlf.GetYDim(); y++) {
1459              NewRlf(x/N,y/N) += double(Rlf(x,y));
1460          }
1461      }
1462      SOut->PutStrLn("Transform {");
1463      SOut->PutStrLn("   translation 0 0 0");
1464      SOut->PutStrLn("   children [");
1465      SOut->PutStrLn("      Shape {");
1466      SOut->PutStrLn("         appearance Appearance {");
1467      SOut->PutStrLn("            material Material {");
1468      SOut->PutStrLn("               diffuseColor " + TerrainColor);
1469      SOut->PutStrLn("            }");
1470      SOut->PutStrLn("         }");
1471      SOut->PutStrLn("         geometry ElevationGrid {");
1472      SOut->PutStrLn("            xDimension " + TInt::GetStr(NewRlf.GetXDim()));
1473      SOut->PutStrLn("            zDimension " + TInt::GetStr(NewRlf.GetYDim()));
1474      SOut->PutStrLn(TStr::Fmt("            xSpacing %.2f", Spacing));
1475      SOut->PutStrLn(TStr::Fmt("            zSpacing %.2f", Spacing));
1476      SOut->PutStrLn("            height [");
1477      for (int x = 0; x < NewRlf.GetXDim(); x++) {
1478          for (int y = 0; y < NewRlf.GetYDim(); y++) {
1479              IAssertR(NewRlf(x,y) <= N*N, TStr::Fmt("%d:%d:%g", x, y, NewRlf(x,y)()));
1480              NewRlf(x,y) = Height * NewRlf(x,y)/(N*N);
1481              SOut->PutStr(TStr::Fmt("%.4f ", NewRlf(x,y)()));
1482          }
1483          SOut->PutLn();
1484      }
1485      SOut->PutStrLn("            ]");
1486      SOut->PutStrLn("         }");
1487      SOut->PutStrLn("      }");
1488      SOut->PutStrLn("   ]");
1489      SOut->PutStrLn("}");
1490      return NewRlf.GetXDim() * Spacing;
1491  }
1492  void TVrml::InsertBillboard(PSOut SOut, const TFltVV& Rlf,
1493          const TStr& Text, const TStr& Color, const TStr& Size,
1494          const double& x, const double& y, const double& Height,
1495          const double& Scale, bool DoText, bool DoPoint) {
1496      const double Spacing = Scale / Rlf.GetXDim();
1497      int PosX = TFlt::Round(Scale*x/Spacing);
1498      int PosY = TFlt::Round(Scale*y/Spacing);
1499      if (PosX < 0) PosX = 0; if (PosY < 0) PosY = 0;
1500      if (PosX >= Rlf.GetXDim()) PosX = Rlf.GetXDim() - 1;
1501      if (PosY >= Rlf.GetYDim()) PosY = Rlf.GetYDim() - 1;
1502      const double z = Rlf(PosX, PosY) + Height;
1503      if (DoText) {
1504          SOut->PutStrLn("Transform {");
1505          SOut->PutStrLn(TStr::Fmt("  translation %.3f %.3f %.3f", Scale*y, z, Scale*x));
1506          SOut->PutStrLn("  scale " + Size);
1507          SOut->PutStrLn("  children Billboard {");
1508        SOut->PutStrLn("  axisOfRotation 0 0 0");
1509        SOut->PutStrLn("  children [");
1510          SOut->PutStrLn("    Shape {");
1511          SOut->PutStrLn("      appearance Appearance { material Material {");
1512          SOut->PutStrLn("                 diffuseColor " + Color + " } }");
1513          SOut->PutStrLn("      geometry Text { fontStyle FontStyle {justify \"MIDDLE\"} string \"" + Text + "\" }");
1514          SOut->PutStrLn("     }]");
1515          SOut->PutStrLn("  }");
1516          SOut->PutStrLn("}");
1517      }
1518      if (DoPoint) {
1519          SOut->PutStrLn("Anchor {");
1520          SOut->PutStrLn("  children [");
1521          SOut->PutStrLn("    Transform {");
1522          SOut->PutStrLn(TStr::Fmt("      translation %.3f %.3f %.3f", Scale*y, z - 0.95*Height, Scale*x));
1523          SOut->PutStrLn("      rotation 0 0 1 0");
1524          SOut->PutStrLn("      children Shape {");
1525          SOut->PutStrLn("        appearance Appearance { material Material { diffuseColor " + Color + "  } }");
1526          SOut->PutStrLn("        geometry Sphere { radius 0.1 }");
1527          SOut->PutStrLn("      }                                     ");
1528          SOut->PutStrLn("    }");
1529          SOut->PutStrLn("  ]");
1530          SOut->PutStrLn("  description \"" + Text + "\"");
1531          SOut->PutStrLn("}");
1532      }
1533  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmap.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1852    PAGE_RES_IT page_res_it = *it.PageResIt();
1853    std::vector<WERD_RES *> werds;
1854    WERD_RES *word_res = page_res_it.restart_row();
1855    ROW_RES *this_row = page_res_it.row();
</pre></code></div>
                <div class="column column_space"><pre><code>448      const TSFltVV& Rlf = Landscape->HeightVV(); TFltVV NewRlf;
449      const double Scale = TVrml::InsertEvelationGrid(SOut,
450          Rlf, NewRlf, TerrainColor, 5, 15.0, 0.7);
451      TStr DocSize = TStr::Fmt("%.3f %.3f %.3f",
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    