
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.793686583990981%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockprocessor.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/blocks.hpp>
3  #include <nano/node/blocking_observer.hpp>
4  #include <nano/node/state_block_signature_verification.hpp>
5  #include <nano/secure/common.hpp>
6  #include <chrono>
7  #include <future>
8  #include <memory>
9  #include <thread>
10  namespace nano
11  {
12  class node;
13  class read_transaction;
14  class transaction;
15  class write_transaction;
16  class write_database_queue;
17  class block_processor final
18  {
19  public:
20  	explicit block_processor (nano::node &, nano::write_database_queue &);
21  	void stop ();
22  	void flush ();
23  	std::size_t size ();
24  	bool full ();
25  	bool half_full ();
26  	void add (std::shared_ptr<nano::block> const &);
27  	std::optional<nano::process_return> add_blocking (std::shared_ptr<nano::block> const & block);
28  	void force (std::shared_ptr<nano::block> const &);
29  	bool should_log ();
30  	bool have_blocks_ready ();
31  	bool have_blocks ();
32  	void process_blocks ();
33  	std::atomic<bool> flushing{ false };
34  	static std::chrono::milliseconds constexpr confirmation_request_delay{ 1500 };
35  public: 
<span onclick='openModal()' class='match'>36  	using processed_t = std::pair<nano::process_return, std::shared_ptr<nano::block>>;
37  	nano::observer_set<nano::process_return const &, std::shared_ptr<nano::block>> processed;
38  	nano::observer_set<std::deque<processed_t> const &> batch_processed;
39  private:
40  	blocking_observer blocking;
</span>41  private:
42  	nano::process_return process_one (nano::write_transaction const &, std::shared_ptr<nano::block> block, bool const = false);
43  	void queue_unchecked (nano::write_transaction const &, nano::hash_or_account const &);
44  	std::deque<processed_t> process_batch (nano::unique_lock<nano::mutex> &);
45  	void process_verified_state_blocks (std::deque<nano::state_block_signature_verification::value_type> &, std::vector<int> const &, std::vector<nano::block_hash> const &, std::vector<nano::signature> const &);
46  	void add_impl (std::shared_ptr<nano::block> block);
47  	bool stopped{ false };
48  	bool active{ false };
49  	std::chrono::steady_clock::time_point next_log;
50  	std::deque<std::shared_ptr<nano::block>> blocks;
51  	std::deque<std::shared_ptr<nano::block>> forced;
52  	nano::condition_variable condition;
53  	nano::node & node;
54  	nano::write_database_queue & write_database_queue;
55  	nano::mutex mutex{ mutex_identifier (mutexes::block_processor) };
56  	nano::state_block_signature_verification state_block_signature_verification;
57  	std::thread processing_thread;
58  	friend std::unique_ptr<container_info_component> collect_container_info (block_processor & block_processor, std::string const & name);
59  };
60  std::unique_ptr<nano::container_info_component> collect_container_info (block_processor & block_processor, std::string const & name);
61  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam.cpp</h3>
            <pre><code>1  #include "recodebeam.h"
2  #include "networkio.h"
3  #include "pageres.h"
4  #include "unicharcompress.h"
5  #include <algorithm> 
6  namespace tesseract {
7  const int RecodeBeamSearch::kBeamWidths[RecodedCharID::kMaxCodeLen + 1] = {
8      5, 10, 16, 16, 16, 16, 16, 16, 16, 16,
9  };
10  static const char *kNodeContNames[] = {"Anything", "OnlyDup", "NoDup"};
11  void RecodeNode::Print(int null_char, const UNICHARSET &unicharset,
12                         int depth) const {
13    if (code == null_char) {
14      tprintf("null_char");
15    } else {
16      tprintf("label=%d, uid=%d=%s", code, unichar_id,
17              unicharset.debug_str(unichar_id).c_str());
18    }
19    tprintf(" score=%g, c=%g,%s%s%s perm=%d, hash=%" PRIx64, score, certainty,
20            start_of_dawg ? " DawgStart" : "", start_of_word ? " Start" : "",
21            end_of_word ? " End" : "", permuter, code_hash);
22    if (depth > 0 && prev != nullptr) {
23      tprintf(" prev:");
24      prev->Print(null_char, unicharset, depth - 1);
25    } else {
26      tprintf("\n");
27    }
28  }
29  RecodeBeamSearch::RecodeBeamSearch(const UnicharCompress &recoder,
30                                     int null_char, bool simple_text, Dict *dict)
31      : recoder_(recoder),
32        beam_size_(0),
33        top_code_(-1),
34        second_code_(-1),
35        dict_(dict),
36        space_delimited_(true),
37        is_simple_text_(simple_text),
38        null_char_(null_char) {
39    if (dict_ != nullptr && !dict_->IsSpaceDelimitedLang()) {
40      space_delimited_ = false;
41    }
42  }
43  RecodeBeamSearch::~RecodeBeamSearch() {
44    for (auto data : beam_) {
45      delete data;
46    }
47    for (auto data : secondary_beam_) {
48      delete data;
49    }
50  }
51  void RecodeBeamSearch::Decode(const NetworkIO &output, double dict_ratio,
52                                double cert_offset, double worst_dict_cert,
53                                const UNICHARSET *charset, int lstm_choice_mode) {
54    beam_size_ = 0;
55    int width = output.Width();
56    if (lstm_choice_mode) {
57      timesteps.clear();
58    }
59    for (int t = 0; t < width; ++t) {
60      ComputeTopN(output.f(t), output.NumFeatures(), kBeamWidths[0]);
61      DecodeStep(output.f(t), t, dict_ratio, cert_offset, worst_dict_cert,
62                 charset);
63      if (lstm_choice_mode) {
64        SaveMostCertainChoices(output.f(t), output.NumFeatures(), charset, t);
65      }
66    }
67  }
68  void RecodeBeamSearch::Decode(const GENERIC_2D_ARRAY<float> &output,
69                                double dict_ratio, double cert_offset,
70                                double worst_dict_cert,
71                                const UNICHARSET *charset) {
72    beam_size_ = 0;
73    int width = output.dim1();
74    for (int t = 0; t < width; ++t) {
75      ComputeTopN(output[t], output.dim2(), kBeamWidths[0]);
76      DecodeStep(output[t], t, dict_ratio, cert_offset, worst_dict_cert, charset);
77    }
78  }
79  void RecodeBeamSearch::DecodeSecondaryBeams(
80      const NetworkIO &output, double dict_ratio, double cert_offset,
81      double worst_dict_cert, const UNICHARSET *charset, int lstm_choice_mode) {
82    for (auto data : secondary_beam_) {
83      delete data;
84    }
85    secondary_beam_.clear();
86    if (character_boundaries_.size() < 2) {
87      return;
88    }
89    int width = output.Width();
90    unsigned bucketNumber = 0;
91    for (int t = 0; t < width; ++t) {
92      while ((bucketNumber + 1) < character_boundaries_.size() &&
93             t >= character_boundaries_[bucketNumber + 1]) {
94        ++bucketNumber;
95      }
96      ComputeSecTopN(&(excludedUnichars)[bucketNumber], output.f(t),
97                     output.NumFeatures(), kBeamWidths[0]);
98      DecodeSecondaryStep(output.f(t), t, dict_ratio, cert_offset,
99                          worst_dict_cert, charset);
100    }
101  }
102  void RecodeBeamSearch::SaveMostCertainChoices(const float *outputs,
103                                                int num_outputs,
104                                                const UNICHARSET *charset,
105                                                int xCoord) {
106    std::vector<std::pair<const char *, float>> choices;
107    for (int i = 0; i < num_outputs; ++i) {
108      if (outputs[i] >= 0.01f) {
109        const char *character;
110        if (i + 2 >= num_outputs) {
111          character = "";
112        } else if (i > 0) {
113          character = charset->id_to_unichar_ext(i + 2);
114        } else {
115          character = charset->id_to_unichar_ext(i);
116        }
117        size_t pos = 0;
118        while (choices.size() > pos && choices[pos].second > outputs[i]) {
119          pos++;
120        }
121        choices.insert(choices.begin() + pos,
122                       std::pair<const char *, float>(character, outputs[i]));
123      }
124    }
125    timesteps.push_back(choices);
126  }
127  void RecodeBeamSearch::segmentTimestepsByCharacters() {
128    for (unsigned i = 1; i < character_boundaries_.size(); ++i) {
129      std::vector<std::vector<std::pair<const char *, float>>> segment;
130      for (int j = character_boundaries_[i - 1]; j < character_boundaries_[i];
131           ++j) {
132        segment.push_back(timesteps[j]);
133      }
134      segmentedTimesteps.push_back(segment);
135    }
136  }
137  std::vector<std::vector<std::pair<const char *, float>>>
138  RecodeBeamSearch::combineSegmentedTimesteps(
139      std::vector<std::vector<std::vector<std::pair<const char *, float>>>>
140          *segmentedTimesteps) {
141    std::vector<std::vector<std::pair<const char *, float>>> combined_timesteps;
142    for (auto &segmentedTimestep : *segmentedTimesteps) {
143      for (auto &j : segmentedTimestep) {
144        combined_timesteps.push_back(j);
145      }
146    }
147    return combined_timesteps;
148  }
149  void RecodeBeamSearch::calculateCharBoundaries(std::vector<int> *starts,
150                                                 std::vector<int> *ends,
151                                                 std::vector<int> *char_bounds_,
152                                                 int maxWidth) {
153    char_bounds_->push_back(0);
154    for (unsigned i = 0; i < ends->size(); ++i) {
155      int middle = ((*starts)[i + 1] - (*ends)[i]) / 2;
156      char_bounds_->push_back((*ends)[i] + middle);
157    }
158    char_bounds_->pop_back();
159    char_bounds_->push_back(maxWidth);
160  }
161  void RecodeBeamSearch::ExtractBestPathAsLabels(
162      std::vector<int> *labels, std::vector<int> *xcoords) const {
163    labels->clear();
164    xcoords->clear();
165    std::vector<const RecodeNode *> best_nodes;
166    ExtractBestPaths(&best_nodes, nullptr);
167    int t = 0;
168    int width = best_nodes.size();
169    while (t < width) {
170      int label = best_nodes[t]->code;
171      if (label != null_char_) {
172        labels->push_back(label);
173        xcoords->push_back(t);
174      }
175      while (++t < width && !is_simple_text_ && best_nodes[t]->code == label) {
176      }
177    }
178    xcoords->push_back(width);
179  }
180  void RecodeBeamSearch::ExtractBestPathAsUnicharIds(
181      bool debug, const UNICHARSET *unicharset, std::vector<int> *unichar_ids,
182      std::vector<float> *certs, std::vector<float> *ratings,
183      std::vector<int> *xcoords) const {
184    std::vector<const RecodeNode *> best_nodes;
185    ExtractBestPaths(&best_nodes, nullptr);
186    ExtractPathAsUnicharIds(best_nodes, unichar_ids, certs, ratings, xcoords);
187    if (debug) {
188      DebugPath(unicharset, best_nodes);
189      DebugUnicharPath(unicharset, best_nodes, *unichar_ids, *certs, *ratings,
190                       *xcoords);
191    }
192  }
193  void RecodeBeamSearch::ExtractBestPathAsWords(const TBOX &line_box,
194                                                float scale_factor, bool debug,
195                                                const UNICHARSET *unicharset,
196                                                PointerVector<WERD_RES> *words,
197                                                int lstm_choice_mode) {
198    words->truncate(0);
199    std::vector<int> unichar_ids;
200    std::vector<float> certs;
201    std::vector<float> ratings;
202    std::vector<int> xcoords;
203    std::vector<const RecodeNode *> best_nodes;
204    std::vector<const RecodeNode *> second_nodes;
205    character_boundaries_.clear();
206    ExtractBestPaths(&best_nodes, &second_nodes);
207    if (debug) {
208      DebugPath(unicharset, best_nodes);
209      ExtractPathAsUnicharIds(second_nodes, &unichar_ids, &certs, &ratings,
210                              &xcoords);
211      tprintf("\nSecond choice path:\n");
212      DebugUnicharPath(unicharset, second_nodes, unichar_ids, certs, ratings,
213                       xcoords);
214    }
215    ExtractPathAsUnicharIds(best_nodes, &unichar_ids, &certs, &ratings, &xcoords,
216                            &character_boundaries_);
217    int num_ids = unichar_ids.size();
218    if (debug) {
219      DebugUnicharPath(unicharset, best_nodes, unichar_ids, certs, ratings,
220                       xcoords);
221    }
222    int word_end = 0;
223    float prev_space_cert = 0.0f;
224    for (int word_start = 0; word_start < num_ids; word_start = word_end) {
225      for (word_end = word_start + 1; word_end < num_ids; ++word_end) {
226        if (unichar_ids[word_end] == UNICHAR_SPACE) {
227          break;
228        }
229        int index = xcoords[word_end];
230        if (best_nodes[index]->start_of_word) {
231          break;
232        }
233        if (best_nodes[index]->permuter == TOP_CHOICE_PERM &&
234            (!unicharset->IsSpaceDelimited(unichar_ids[word_end]) ||
235             !unicharset->IsSpaceDelimited(unichar_ids[word_end - 1]))) {
236          break;
237        }
238      }
239      float space_cert = 0.0f;
240      if (word_end < num_ids && unichar_ids[word_end] == UNICHAR_SPACE) {
241        space_cert = certs[word_end];
242      }
243      bool leading_space =
244          word_start > 0 && unichar_ids[word_start - 1] == UNICHAR_SPACE;
245      WERD_RES *word_res =
246          InitializeWord(leading_space, line_box, word_start, word_end,
247                         std::min(space_cert, prev_space_cert), unicharset,
248                         xcoords, scale_factor);
249      for (int i = word_start; i < word_end; ++i) {
250        auto *choices = new BLOB_CHOICE_LIST;
251        BLOB_CHOICE_IT bc_it(choices);
252        auto *choice = new BLOB_CHOICE(unichar_ids[i], ratings[i], certs[i], -1,
253                                       1.0f, static_cast<float>(INT16_MAX), 0.0f,
254                                       BCC_STATIC_CLASSIFIER);
255        int col = i - word_start;
256        choice->set_matrix_cell(col, col);
257        bc_it.add_after_then_move(choice);
258        word_res->ratings->put(col, col, choices);
259      }
260      int index = xcoords[word_end - 1];
261      word_res->FakeWordFromRatings(best_nodes[index]->permuter);
262      words->push_back(word_res);
263      prev_space_cert = space_cert;
264      if (word_end < num_ids && unichar_ids[word_end] == UNICHAR_SPACE) {
265        ++word_end;
266      }
267    }
268  }
269  struct greater_than {
270    inline bool operator()(const RecodeNode *&node1, const RecodeNode *&node2) const {
271      return (node1->score > node2->score);
272    }
273  };
274  void RecodeBeamSearch::PrintBeam2(bool uids, int num_outputs,
275                                    const UNICHARSET *charset,
276                                    bool secondary) const {
277    std::vector<std::vector<const RecodeNode *>> topology;
278    std::unordered_set<const RecodeNode *> visited;
279    const std::vector<RecodeBeam *> &beam = !secondary ? beam_ : secondary_beam_;
280    for (int step = beam.size() - 1; step >= 0; --step) {
281      std::vector<const RecodeNode *> layer;
282      topology.push_back(layer);
283    }
284    for (int step = beam.size() - 1; step >= 0; --step) {
285      std::vector<tesseract::RecodePair> &heaps = beam.at(step)->beams_->heap();
286      for (auto &&node : heaps) {
287        int backtracker = 0;
288        const RecodeNode *curr = &node.data();
289        while (curr != nullptr && !visited.count(curr)) {
290          visited.insert(curr);
291          topology[step - backtracker].push_back(curr);
292          curr = curr->prev;
293          ++backtracker;
294        }
295      }
296    }
297    int ct = 0;
298    unsigned cb = 1;
299    for (const std::vector<const RecodeNode *> &layer : topology) {
300      if (cb >= character_boundaries_.size()) {
301        break;
302      }
303      if (ct == character_boundaries_[cb]) {
304        tprintf("***\n");
305        ++cb;
306      }
307      for (const RecodeNode *node : layer) {
308        const char *code;
309        int intCode;
310        if (node->unichar_id != INVALID_UNICHAR_ID) {
311          code = charset->id_to_unichar(node->unichar_id);
312          intCode = node->unichar_id;
313        } else if (node->code == null_char_) {
314          intCode = 0;
315          code = " ";
316        } else {
317          intCode = 666;
318          code = "*";
319        }
320        int intPrevCode = 0;
321        const char *prevCode;
322        float prevScore = 0;
323        if (node->prev != nullptr) {
324          prevScore = node->prev->score;
325          if (node->prev->unichar_id != INVALID_UNICHAR_ID) {
326            prevCode = charset->id_to_unichar(node->prev->unichar_id);
327            intPrevCode = node->prev->unichar_id;
328          } else if (node->code == null_char_) {
329            intPrevCode = 0;
330            prevCode = " ";
331          } else {
332            prevCode = "*";
333            intPrevCode = 666;
334          }
335        } else {
336          prevCode = " ";
337        }
338        if (uids) {
339          tprintf("%x(|)%f(>)%x(|)%f\n", intPrevCode, prevScore, intCode,
340                  node->score);
341        } else {
342          tprintf("%s(|)%f(>)%s(|)%f\n", prevCode, prevScore, code, node->score);
343        }
344      }
345      tprintf("-\n");
346      ++ct;
347    }
348    tprintf("***\n");
349  }
350  void RecodeBeamSearch::extractSymbolChoices(const UNICHARSET *unicharset) {
351    if (character_boundaries_.size() < 2) {
352      return;
353    }
354    std::vector<RecodeBeam *> &currentBeam =
355        secondary_beam_.empty() ? beam_ : secondary_beam_;
356    character_boundaries_[0] = 0;
357    for (unsigned j = 1; j < character_boundaries_.size(); ++j) {
358      std::vector<int> unichar_ids;
359      std::vector<float> certs;
360      std::vector<float> ratings;
361      std::vector<int> xcoords;
362      int backpath = character_boundaries_[j] - character_boundaries_[j - 1];
363      std::vector<tesseract::RecodePair> &heaps =
364          currentBeam.at(character_boundaries_[j] - 1)->beams_->heap();
365      std::vector<const RecodeNode *> best_nodes;
366      std::vector<const RecodeNode *> best;
367      for (auto &&entry : heaps) {
368        bool validChar = false;
369        int backcounter = 0;
370        const RecodeNode *node = &entry.data();
371        while (node != nullptr && backcounter < backpath) {
372          if (node->code != null_char_ &&
373              node->unichar_id != INVALID_UNICHAR_ID) {
374            validChar = true;
375            break;
376          }
377          node = node->prev;
378          ++backcounter;
379        }
380        if (validChar) {
381          best.push_back(&entry.data());
382        }
383      }
384      if (!best.empty()) {
385        std::sort(best.begin(), best.end(), greater_than());
386        ExtractPath(best[0], &best_nodes, backpath);
387        ExtractPathAsUnicharIds(best_nodes, &unichar_ids, &certs, &ratings,
388                                &xcoords);
389      }
390      if (!unichar_ids.empty()) {
391        int bestPos = 0;
392        for (unsigned i = 1; i < unichar_ids.size(); ++i) {
393          if (ratings[i] < ratings[bestPos]) {
394            bestPos = i;
395          }
396        }
397  #if 0 
398        int bestCode = -10;
399        for (auto &node : best_nodes) {
400          if (node->unichar_id == unichar_ids[bestPos]) {
401            bestCode = node->code;
402          }
403        }
404  #endif
405        std::unordered_set<int> excludeCodeList;
406        for (auto &best_node : best_nodes) {
407          if (best_node->code != null_char_) {
408            excludeCodeList.insert(best_node->code);
409          }
410        }
411        if (j - 1 < excludedUnichars.size()) {
412          for (auto elem : excludeCodeList) {
413            excludedUnichars[j - 1].insert(elem);
414          }
415        } else {
416          excludedUnichars.push_back(excludeCodeList);
417        }
418        if (j - 1 < ctc_choices.size()) {
419          int id = unichar_ids[bestPos];
420          const char *result = unicharset->id_to_unichar_ext(id);
421          float rating = ratings[bestPos];
422          ctc_choices[j - 1].push_back(
423              std::pair<const char *, float>(result, rating));
424        } else {
425          std::vector<std::pair<const char *, float>> choice;
426          int id = unichar_ids[bestPos];
427          const char *result = unicharset->id_to_unichar_ext(id);
428          float rating = ratings[bestPos];
429          choice.emplace_back(result, rating);
430          ctc_choices.push_back(choice);
431        }
432      } else {
433        if (j - 1 >= excludedUnichars.size()) {
434          std::unordered_set<int> excludeCodeList;
435          excludedUnichars.push_back(excludeCodeList);
436        }
437        if (j - 1 >= ctc_choices.size()) {
438          std::vector<std::pair<const char *, float>> choice;
439          ctc_choices.push_back(choice);
440        }
441      }
442    }
443    for (auto data : secondary_beam_) {
444      delete data;
445    }
446    secondary_beam_.clear();
447  }
448  void RecodeBeamSearch::DebugBeams(const UNICHARSET &unicharset) const {
449    for (int p = 0; p < beam_size_; ++p) {
450      for (int d = 0; d < 2; ++d) {
451        for (int c = 0; c < NC_COUNT; ++c) {
452          auto cont = static_cast<NodeContinuation>(c);
453          int index = BeamIndex(d, cont, 0);
454          if (beam_[p]->beams_[index].empty()) {
455            continue;
456          }
457          tprintf("Position %d: %s+%s beam\n", p, d ? "Dict" : "Non-Dict",
458                  kNodeContNames[c]);
459          DebugBeamPos(unicharset, beam_[p]->beams_[index]);
460        }
461      }
462    }
463  }
464  void RecodeBeamSearch::DebugBeamPos(const UNICHARSET &unicharset,
465                                      const RecodeHeap &heap) const {
466    std::vector<const RecodeNode *> unichar_bests(unicharset.size());
467    const RecodeNode *null_best = nullptr;
468    int heap_size = heap.size();
469    for (int i = 0; i < heap_size; ++i) {
470      const RecodeNode *node = &heap.get(i).data();
471      if (node->unichar_id == INVALID_UNICHAR_ID) {
472        if (null_best == nullptr || null_best->score < node->score) {
473          null_best = node;
474        }
475      } else {
476        if (unichar_bests[node->unichar_id] == nullptr ||
477            unichar_bests[node->unichar_id]->score < node->score) {
478          unichar_bests[node->unichar_id] = node;
479        }
480      }
481    }
482    for (auto &unichar_best : unichar_bests) {
483      if (unichar_best != nullptr) {
484        const RecodeNode &node = *unichar_best;
485        node.Print(null_char_, unicharset, 1);
486      }
487    }
488    if (null_best != nullptr) {
489      null_best->Print(null_char_, unicharset, 1);
490    }
491  }
492  void RecodeBeamSearch::ExtractPathAsUnicharIds(
493      const std::vector<const RecodeNode *> &best_nodes,
494      std::vector<int> *unichar_ids, std::vector<float> *certs,
495      std::vector<float> *ratings, std::vector<int> *xcoords,
496      std::vector<int> *character_boundaries) {
497    unichar_ids->clear();
498    certs->clear();
499    ratings->clear();
500    xcoords->clear();
501    std::vector<int> starts;
502    std::vector<int> ends;
503    int t = 0;
504    int width = best_nodes.size();
505    while (t < width) {
506      double certainty = 0.0;
507      double rating = 0.0;
508      while (t < width && best_nodes[t]->unichar_id == INVALID_UNICHAR_ID) {
509        double cert = best_nodes[t++]->certainty;
510        if (cert < certainty) {
511          certainty = cert;
512        }
513        rating -= cert;
514      }
515      starts.push_back(t);
516      if (t < width) {
517        int unichar_id = best_nodes[t]->unichar_id;
518        if (unichar_id == UNICHAR_SPACE && !certs->empty() &&
519            best_nodes[t]->permuter != NO_PERM) {
520          if (certainty < certs->back()) {
521            certs->back() = certainty;
522          }
523          ratings->back() += rating;
524          certainty = 0.0;
525          rating = 0.0;
526        }
527        unichar_ids->push_back(unichar_id);
528        xcoords->push_back(t);
529        do {
530          double cert = best_nodes[t++]->certainty;
531          if (cert < certainty || (unichar_id == UNICHAR_SPACE &&
532                                   best_nodes[t - 1]->permuter == NO_PERM)) {
533            certainty = cert;
534          }
535          rating -= cert;
536        } while (t < width && best_nodes[t]->duplicate);
537        ends.push_back(t);
538        certs->push_back(certainty);
539        ratings->push_back(rating);
540      } else if (!certs->empty()) {
541        if (certainty < certs->back()) {
542          certs->back() = certainty;
543        }
544        ratings->back() += rating;
545      }
546    }
547    starts.push_back(width);
548    if (character_boundaries != nullptr) {
549      calculateCharBoundaries(&starts, &ends, character_boundaries, width);
550    }
551    xcoords->push_back(width);
552  }
553  WERD_RES *RecodeBeamSearch::InitializeWord(bool leading_space,
554                                             const TBOX &line_box, int word_start,
555                                             int word_end, float space_certainty,
556                                             const UNICHARSET *unicharset,
557                                             const std::vector<int> &xcoords,
558                                             float scale_factor) {
559    C_BLOB_LIST blobs;
560    C_BLOB_IT b_it(&blobs);
561    for (int i = word_start; i < word_end; ++i) {
562      if (static_cast<unsigned>(i + 1) < character_boundaries_.size()) {
563        TBOX box(static_cast<int16_t>(
564                     std::floor(character_boundaries_[i] * scale_factor)) +
565                     line_box.left(),
566                 line_box.bottom(),
567                 static_cast<int16_t>(
568                     std::ceil(character_boundaries_[i + 1] * scale_factor)) +
569                     line_box.left(),
570                 line_box.top());
571        b_it.add_after_then_move(C_BLOB::FakeBlob(box));
572      }
573    }
574    WERD *word = new WERD(&blobs, leading_space, nullptr);
575    auto *word_res = new WERD_RES(word);
576    word_res->end = word_end - word_start + leading_space;
577    word_res->uch_set = unicharset;
578    word_res->combination = true; 
579    word_res->space_certainty = space_certainty;
580    word_res->ratings = new MATRIX(word_end - word_start, 1);
581    return word_res;
582  }
583  void RecodeBeamSearch::ComputeTopN(const float *outputs, int num_outputs,
584                                     int top_n) {
585    top_n_flags_.clear();
586    top_n_flags_.resize(num_outputs, TN_ALSO_RAN);
587    top_code_ = -1;
588    second_code_ = -1;
589    top_heap_.clear();
590    for (int i = 0; i < num_outputs; ++i) {
591      if (top_heap_.size() < top_n || outputs[i] > top_heap_.PeekTop().key()) {
592        TopPair entry(outputs[i], i);
593        top_heap_.Push(&entry);
594        if (top_heap_.size() > top_n) {
595          top_heap_.Pop(&entry);
596        }
597      }
598    }
599    while (!top_heap_.empty()) {
600      TopPair entry;
601      top_heap_.Pop(&entry);
602      if (top_heap_.size() > 1) {
603        top_n_flags_[entry.data()] = TN_TOPN;
604      } else {
605        top_n_flags_[entry.data()] = TN_TOP2;
606        if (top_heap_.empty()) {
607          top_code_ = entry.data();
608        } else {
609          second_code_ = entry.data();
610        }
611      }
612    }
613    top_n_flags_[null_char_] = TN_TOP2;
614  }
615  void RecodeBeamSearch::ComputeSecTopN(std::unordered_set<int> *exList,
616                                        const float *outputs, int num_outputs,
617                                        int top_n) {
618    top_n_flags_.clear();
619    top_n_flags_.resize(num_outputs, TN_ALSO_RAN);
620    top_code_ = -1;
621    second_code_ = -1;
622    top_heap_.clear();
623    for (int i = 0; i < num_outputs; ++i) {
624      if ((top_heap_.size() < top_n || outputs[i] > top_heap_.PeekTop().key()) &&
625          !exList->count(i)) {
626        TopPair entry(outputs[i], i);
627        top_heap_.Push(&entry);
628        if (top_heap_.size() > top_n) {
629          top_heap_.Pop(&entry);
630        }
631      }
632    }
633    while (!top_heap_.empty()) {
634      TopPair entry;
635      top_heap_.Pop(&entry);
636      if (top_heap_.size() > 1) {
637        top_n_flags_[entry.data()] = TN_TOPN;
638      } else {
639        top_n_flags_[entry.data()] = TN_TOP2;
640        if (top_heap_.empty()) {
641          top_code_ = entry.data();
642        } else {
643          second_code_ = entry.data();
644        }
645      }
646    }
647    top_n_flags_[null_char_] = TN_TOP2;
648  }
649  void RecodeBeamSearch::DecodeStep(const float *outputs, int t,
650                                    double dict_ratio, double cert_offset,
651                                    double worst_dict_cert,
652                                    const UNICHARSET *charset, bool debug) {
653    if (t == static_cast<int>(beam_.size())) {
654      beam_.push_back(new RecodeBeam);
655    }
656    RecodeBeam *step = beam_[t];
657    beam_size_ = t + 1;
658    step->Clear();
659    if (t == 0) {
660      ContinueContext(nullptr, BeamIndex(false, NC_ANYTHING, 0), outputs, TN_TOP2,
661                      charset, dict_ratio, cert_offset, worst_dict_cert, step);
662      if (dict_ != nullptr) {
663        ContinueContext(nullptr, BeamIndex(true, NC_ANYTHING, 0), outputs,
664                        TN_TOP2, charset, dict_ratio, cert_offset,
665                        worst_dict_cert, step);
666      }
667    } else {
668      RecodeBeam *prev = beam_[t - 1];
669      if (debug) {
670        int beam_index = BeamIndex(true, NC_ANYTHING, 0);
671        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
672          std::vector<const RecodeNode *> path;
673          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
674          tprintf("Step %d: Dawg beam %d:\n", t, i);
675          DebugPath(charset, path);
676        }
677        beam_index = BeamIndex(false, NC_ANYTHING, 0);
678        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
679          std::vector<const RecodeNode *> path;
680          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
681          tprintf("Step %d: Non-Dawg beam %d:\n", t, i);
682          DebugPath(charset, path);
683        }
684      }
685      int total_beam = 0;
686      for (int tn = 0; tn < TN_COUNT && total_beam == 0; ++tn) {
687        auto top_n = static_cast<TopNState>(tn);
688        for (int index = 0; index < kNumBeams; ++index) {
689          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
690            ContinueContext(&prev->beams_[index].get(i).data(), index, outputs,
691                            top_n, charset, dict_ratio, cert_offset,
692                            worst_dict_cert, step);
693          }
694        }
695        for (int index = 0; index < kNumBeams; ++index) {
696          if (ContinuationFromBeamsIndex(index) == NC_ANYTHING) {
697            total_beam += step->beams_[index].size();
698          }
699        }
700      }
701      for (int c = 0; c < NC_COUNT; ++c) {
702        if (step->best_initial_dawgs_[c].code >= 0) {
703          int index = BeamIndex(true, static_cast<NodeContinuation>(c), 0);
704          RecodeHeap *dawg_heap = &step->beams_[index];
705          PushHeapIfBetter(kBeamWidths[0], &step->best_initial_dawgs_[c],
706                           dawg_heap);
707        }
708      }
709    }
710  }
711  void RecodeBeamSearch::DecodeSecondaryStep(
712      const float *outputs, int t, double dict_ratio, double cert_offset,
713      double worst_dict_cert, const UNICHARSET *charset, bool debug) {
714    if (t == static_cast<int>(secondary_beam_.size())) {
715      secondary_beam_.push_back(new RecodeBeam);
716    }
717    RecodeBeam *step = secondary_beam_[t];
718    step->Clear();
719    if (t == 0) {
720      ContinueContext(nullptr, BeamIndex(false, NC_ANYTHING, 0), outputs, TN_TOP2,
721                      charset, dict_ratio, cert_offset, worst_dict_cert, step);
722      if (dict_ != nullptr) {
723        ContinueContext(nullptr, BeamIndex(true, NC_ANYTHING, 0), outputs,
724                        TN_TOP2, charset, dict_ratio, cert_offset,
725                        worst_dict_cert, step);
726      }
727    } else {
728      RecodeBeam *prev = secondary_beam_[t - 1];
729      if (debug) {
730        int beam_index = BeamIndex(true, NC_ANYTHING, 0);
731        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
732          std::vector<const RecodeNode *> path;
733          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
734          tprintf("Step %d: Dawg beam %d:\n", t, i);
735          DebugPath(charset, path);
736        }
737        beam_index = BeamIndex(false, NC_ANYTHING, 0);
738        for (int i = prev->beams_[beam_index].size() - 1; i >= 0; --i) {
739          std::vector<const RecodeNode *> path;
740          ExtractPath(&prev->beams_[beam_index].get(i).data(), &path);
741          tprintf("Step %d: Non-Dawg beam %d:\n", t, i);
742          DebugPath(charset, path);
743        }
744      }
745      int total_beam = 0;
746      for (int tn = 0; tn < TN_COUNT && total_beam == 0; ++tn) {
747        auto top_n = static_cast<TopNState>(tn);
748        for (int index = 0; index < kNumBeams; ++index) {
749          for (int i = prev->beams_[index].size() - 1; i >= 0; --i) {
750            ContinueContext(&prev->beams_[index].get(i).data(), index, outputs,
751                            top_n, charset, dict_ratio, cert_offset,
752                            worst_dict_cert, step);
753          }
754        }
755        for (int index = 0; index < kNumBeams; ++index) {
756          if (ContinuationFromBeamsIndex(index) == NC_ANYTHING) {
757            total_beam += step->beams_[index].size();
758          }
759        }
760      }
761      for (int c = 0; c < NC_COUNT; ++c) {
762        if (step->best_initial_dawgs_[c].code >= 0) {
763          int index = BeamIndex(true, static_cast<NodeContinuation>(c), 0);
764          RecodeHeap *dawg_heap = &step->beams_[index];
765          PushHeapIfBetter(kBeamWidths[0], &step->best_initial_dawgs_[c],
766                           dawg_heap);
767        }
768      }
769    }
770  }
771  void RecodeBeamSearch::ContinueContext(
772      const RecodeNode *prev, int index, const float *outputs,
773      TopNState top_n_flag, const UNICHARSET *charset, double dict_ratio,
774      double cert_offset, double worst_dict_cert, RecodeBeam *step) {
775    RecodedCharID prefix;
776    RecodedCharID full_code;
777    const RecodeNode *previous = prev;
778    int length = LengthFromBeamsIndex(index);
779    bool use_dawgs = IsDawgFromBeamsIndex(index);
780    NodeContinuation prev_cont = ContinuationFromBeamsIndex(index);
781    for (int p = length - 1; p >= 0; --p, previous = previous->prev) {
782      while (previous != nullptr &&
783             (previous->duplicate || previous->code == null_char_)) {
784        previous = previous->prev;
785      }
786      if (previous != nullptr) {
787        prefix.Set(p, previous->code);
788        full_code.Set(p, previous->code);
789      }
790    }
791    if (prev != nullptr && !is_simple_text_) {
792      if (top_n_flags_[prev->code] == top_n_flag) {
793        if (prev_cont != NC_NO_DUP) {
794          float cert =
795              NetworkIO::ProbToCertainty(outputs[prev->code]) + cert_offset;
796          PushDupOrNoDawgIfBetter(length, true, prev->code, prev->unichar_id,
797                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
798                                  NC_ANYTHING, prev, step);
799        }
800        if (prev_cont == NC_ANYTHING && top_n_flag == TN_TOP2 &&
801            prev->code != null_char_) {
802          float cert = NetworkIO::ProbToCertainty(outputs[prev->code] +
803                                                  outputs[null_char_]) +
804                       cert_offset;
805          PushDupOrNoDawgIfBetter(length, true, prev->code, prev->unichar_id,
806                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
807                                  NC_NO_DUP, prev, step);
808        }
809      }
810      if (prev_cont == NC_ONLY_DUP) {
811        return;
812      }
813      if (prev->code != null_char_ && length > 0 &&
814          top_n_flags_[null_char_] == top_n_flag) {
815        float cert =
816            NetworkIO::ProbToCertainty(outputs[null_char_]) + cert_offset;
817        PushDupOrNoDawgIfBetter(length, false, null_char_, INVALID_UNICHAR_ID,
818                                cert, worst_dict_cert, dict_ratio, use_dawgs,
819                                NC_ANYTHING, prev, step);
820      }
821    }
822    const std::vector<int> *final_codes = recoder_.GetFinalCodes(prefix);
823    if (final_codes != nullptr) {
824      for (int code : *final_codes) {
825        if (top_n_flags_[code] != top_n_flag) {
826          continue;
827        }
828        if (prev != nullptr && prev->code == code && !is_simple_text_) {
829          continue;
830        }
831        float cert = NetworkIO::ProbToCertainty(outputs[code]) + cert_offset;
832        if (cert < kMinCertainty && code != null_char_) {
833          continue;
834        }
835        full_code.Set(length, code);
836        int unichar_id = recoder_.DecodeUnichar(full_code);
837        if (length == 0 && code == null_char_) {
838          unichar_id = INVALID_UNICHAR_ID;
839        }
840        if (unichar_id != INVALID_UNICHAR_ID && charset != nullptr &&
841            !charset->get_enabled(unichar_id)) {
842          continue; 
843        }
844        ContinueUnichar(code, unichar_id, cert, worst_dict_cert, dict_ratio,
845                        use_dawgs, NC_ANYTHING, prev, step);
846        if (top_n_flag == TN_TOP2 && code != null_char_) {
847          float prob = outputs[code] + outputs[null_char_];
848          if (prev != nullptr && prev_cont == NC_ANYTHING &&
849              prev->code != null_char_ &&
850              ((prev->code == top_code_ && code == second_code_) ||
851               (code == top_code_ && prev->code == second_code_))) {
852            prob += outputs[prev->code];
853          }
854          cert = NetworkIO::ProbToCertainty(prob) + cert_offset;
855          ContinueUnichar(code, unichar_id, cert, worst_dict_cert, dict_ratio,
856                          use_dawgs, NC_ONLY_DUP, prev, step);
857        }
858      }
859    }
860    const std::vector<int> *next_codes = recoder_.GetNextCodes(prefix);
861    if (next_codes != nullptr) {
862      for (int code : *next_codes) {
863        if (top_n_flags_[code] != top_n_flag) {
864          continue;
865        }
866        if (prev != nullptr && prev->code == code && !is_simple_text_) {
867          continue;
868        }
869        float cert = NetworkIO::ProbToCertainty(outputs[code]) + cert_offset;
870        PushDupOrNoDawgIfBetter(length + 1, false, code, INVALID_UNICHAR_ID, cert,
871                                worst_dict_cert, dict_ratio, use_dawgs,
872                                NC_ANYTHING, prev, step);
873        if (top_n_flag == TN_TOP2 && code != null_char_) {
874          float prob = outputs[code] + outputs[null_char_];
875          if (prev != nullptr && prev_cont == NC_ANYTHING &&
876              prev->code != null_char_ &&
877              ((prev->code == top_code_ && code == second_code_) ||
878               (code == top_code_ && prev->code == second_code_))) {
879            prob += outputs[prev->code];
880          }
881          cert = NetworkIO::ProbToCertainty(prob) + cert_offset;
882          PushDupOrNoDawgIfBetter(length + 1, false, code, INVALID_UNICHAR_ID,
883                                  cert, worst_dict_cert, dict_ratio, use_dawgs,
884                                  NC_ONLY_DUP, prev, step);
885        }
886      }
887    }
888  }
889  void RecodeBeamSearch::ContinueUnichar(int code, int unichar_id, float cert,
890                                         float worst_dict_cert, float dict_ratio,
891                                         bool use_dawgs, NodeContinuation cont,
892                                         const RecodeNode *prev,
893                                         RecodeBeam *step) {
894    if (use_dawgs) {
895      if (cert > worst_dict_cert) {
896        ContinueDawg(code, unichar_id, cert, cont, prev, step);
897      }
898    } else {
899      RecodeHeap *nodawg_heap = &step->beams_[BeamIndex(false, cont, 0)];
900      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, TOP_CHOICE_PERM, false,
901                       false, false, false, cert * dict_ratio, prev, nullptr,
902                       nodawg_heap);
903      if (dict_ != nullptr &&
904          ((unichar_id == UNICHAR_SPACE && cert > worst_dict_cert) ||
905           !dict_->getUnicharset().IsSpaceDelimited(unichar_id))) {
906        float dawg_cert = cert;
907        PermuterType permuter = TOP_CHOICE_PERM;
908        if (unichar_id == UNICHAR_SPACE) {
909          permuter = NO_PERM;
910        } else {
911          dawg_cert *= dict_ratio;
912        }
913        PushInitialDawgIfBetter(code, unichar_id, permuter, false, false,
914                                dawg_cert, cont, prev, step);
915      }
916    }
917  }
918  void RecodeBeamSearch::ContinueDawg(int code, int unichar_id, float cert,
919                                      NodeContinuation cont,
920                                      const RecodeNode *prev, RecodeBeam *step) {
921    RecodeHeap *dawg_heap = &step->beams_[BeamIndex(true, cont, 0)];
922    RecodeHeap *nodawg_heap = &step->beams_[BeamIndex(false, cont, 0)];
923    if (unichar_id == INVALID_UNICHAR_ID) {
924      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, NO_PERM, false, false,
925                       false, false, cert, prev, nullptr, dawg_heap);
926      return;
927    }
928    float score = cert;
929    if (prev != nullptr) {
930      score += prev->score;
931    }
932    if (dawg_heap->size() >= kBeamWidths[0] &&
933        score <= dawg_heap->PeekTop().data().score &&
934        nodawg_heap->size() >= kBeamWidths[0] &&
935        score <= nodawg_heap->PeekTop().data().score) {
936      return;
937    }
938    const RecodeNode *uni_prev = prev;
939    while (uni_prev != nullptr &&
940           (uni_prev->unichar_id == INVALID_UNICHAR_ID || uni_prev->duplicate)) {
941      uni_prev = uni_prev->prev;
942    }
943    if (unichar_id == UNICHAR_SPACE) {
944      if (uni_prev != nullptr && uni_prev->end_of_word) {
945        PushInitialDawgIfBetter(code, unichar_id, uni_prev->permuter, false,
946                                false, cert, cont, prev, step);
947        PushHeapIfBetter(kBeamWidths[0], code, unichar_id, uni_prev->permuter,
948                         false, false, false, false, cert, prev, nullptr,
949                         nodawg_heap);
950      }
951      return;
952    } else if (uni_prev != nullptr && uni_prev->start_of_dawg &&
953               uni_prev->unichar_id != UNICHAR_SPACE &&
954               dict_->getUnicharset().IsSpaceDelimited(uni_prev->unichar_id) &&
955               dict_->getUnicharset().IsSpaceDelimited(unichar_id)) {
956      return; 
957    }
958    DawgPositionVector initial_dawgs;
959    auto *updated_dawgs = new DawgPositionVector;
960    DawgArgs dawg_args(&initial_dawgs, updated_dawgs, NO_PERM);
961    bool word_start = false;
962    if (uni_prev == nullptr) {
963      dict_->default_dawgs(&initial_dawgs, false);
964      word_start = true;
965    } else if (uni_prev->dawgs != nullptr) {
966      dawg_args.active_dawgs = uni_prev->dawgs;
967      word_start = uni_prev->start_of_dawg;
968    } else {
969      return; 
970    }
971    auto permuter = static_cast<PermuterType>(dict_->def_letter_is_okay(
972        &dawg_args, dict_->getUnicharset(), unichar_id, false));
973    if (permuter != NO_PERM) {
974      PushHeapIfBetter(kBeamWidths[0], code, unichar_id, permuter, false,
975                       word_start, dawg_args.valid_end, false, cert, prev,
976                       dawg_args.updated_dawgs, dawg_heap);
977      if (dawg_args.valid_end && !space_delimited_) {
978        PushInitialDawgIfBetter(code, unichar_id, permuter, word_start, true,
979                                cert, cont, prev, step);
980        PushHeapIfBetter(kBeamWidths[0], code, unichar_id, permuter, false,
981                         word_start, true, false, cert, prev, nullptr,
982                         nodawg_heap);
983      }
984    } else {
985      delete updated_dawgs;
986    }
987  }
988  void RecodeBeamSearch::PushInitialDawgIfBetter(int code, int unichar_id,
989                                                 PermuterType permuter,
990                                                 bool start, bool end, float cert,
991                                                 NodeContinuation cont,
992                                                 const RecodeNode *prev,
993                                                 RecodeBeam *step) {
994    RecodeNode *best_initial_dawg = &step->best_initial_dawgs_[cont];
995    float score = cert;
996    if (prev != nullptr) {
997      score += prev->score;
998    }
999    if (best_initial_dawg->code < 0 || score > best_initial_dawg->score) {
1000      auto *initial_dawgs = new DawgPositionVector;
1001      dict_->default_dawgs(initial_dawgs, false);
1002      RecodeNode node(code, unichar_id, permuter, true, start, end, false, cert,
1003                      score, prev, initial_dawgs,
1004                      ComputeCodeHash(code, false, prev));
1005      *best_initial_dawg = node;
1006    }
1007  }
1008  void RecodeBeamSearch::PushDupOrNoDawgIfBetter(
<span onclick='openModal()' class='match'>1009      int length, bool dup, int code, int unichar_id, float cert,
1010      float worst_dict_cert, float dict_ratio, bool use_dawgs,
1011      NodeContinuation cont, const RecodeNode *prev, RecodeBeam *step) {
1012    int index = BeamIndex(use_dawgs, cont, length);
</span>1013    if (use_dawgs) {
1014      if (cert > worst_dict_cert) {
1015        PushHeapIfBetter(kBeamWidths[length], code, unichar_id,
1016                         prev ? prev->permuter : NO_PERM, false, false, false,
1017                         dup, cert, prev, nullptr, &step->beams_[index]);
1018      }
1019    } else {
1020      cert *= dict_ratio;
1021      if (cert >= kMinCertainty || code == null_char_) {
1022        PushHeapIfBetter(kBeamWidths[length], code, unichar_id,
1023                         prev ? prev->permuter : TOP_CHOICE_PERM, false, false,
1024                         false, dup, cert, prev, nullptr, &step->beams_[index]);
1025      }
1026    }
1027  }
1028  void RecodeBeamSearch::PushHeapIfBetter(int max_size, int code, int unichar_id,
1029                                          PermuterType permuter, bool dawg_start,
1030                                          bool word_start, bool end, bool dup,
1031                                          float cert, const RecodeNode *prev,
1032                                          DawgPositionVector *d,
1033                                          RecodeHeap *heap) {
1034    float score = cert;
1035    if (prev != nullptr) {
1036      score += prev->score;
1037    }
1038    if (heap->size() < max_size || score > heap->PeekTop().data().score) {
1039      uint64_t hash = ComputeCodeHash(code, dup, prev);
1040      RecodeNode node(code, unichar_id, permuter, dawg_start, word_start, end,
1041                      dup, cert, score, prev, d, hash);
1042      if (UpdateHeapIfMatched(&node, heap)) {
1043        return;
1044      }
1045      RecodePair entry(score, node);
1046      heap->Push(&entry);
1047      ASSERT_HOST(entry.data().dawgs == nullptr);
1048      if (heap->size() > max_size) {
1049        heap->Pop(&entry);
1050      }
1051    } else {
1052      delete d;
1053    }
1054  }
1055  void RecodeBeamSearch::PushHeapIfBetter(int max_size, RecodeNode *node,
1056                                          RecodeHeap *heap) {
1057    if (heap->size() < max_size || node->score > heap->PeekTop().data().score) {
1058      if (UpdateHeapIfMatched(node, heap)) {
1059        return;
1060      }
1061      RecodePair entry(node->score, *node);
1062      heap->Push(&entry);
1063      ASSERT_HOST(entry.data().dawgs == nullptr);
1064      if (heap->size() > max_size) {
1065        heap->Pop(&entry);
1066      }
1067    }
1068  }
1069  bool RecodeBeamSearch::UpdateHeapIfMatched(RecodeNode *new_node,
1070                                             RecodeHeap *heap) {
1071    std::vector<RecodePair> &nodes = heap->heap();
1072    for (auto &i : nodes) {
1073      RecodeNode &node = i.data();
1074      if (node.code == new_node->code && node.code_hash == new_node->code_hash &&
1075          node.permuter == new_node->permuter &&
1076          node.start_of_dawg == new_node->start_of_dawg) {
1077        if (new_node->score > node.score) {
1078          node = *new_node;
1079          i.key() = node.score;
1080          heap->Reshuffle(&i);
1081        }
1082        return true;
1083      }
1084    }
1085    return false;
1086  }
1087  uint64_t RecodeBeamSearch::ComputeCodeHash(int code, bool dup,
1088                                             const RecodeNode *prev) const {
1089    uint64_t hash = prev == nullptr ? 0 : prev->code_hash;
1090    if (!dup && code != null_char_) {
1091      int num_classes = recoder_.code_range();
1092      uint64_t carry = (((hash >> 32) * num_classes) >> 32);
1093      hash *= num_classes;
1094      hash += carry;
1095      hash += code;
1096    }
1097    return hash;
1098  }
1099  void RecodeBeamSearch::ExtractBestPaths(
1100      std::vector<const RecodeNode *> *best_nodes,
1101      std::vector<const RecodeNode *> *second_nodes) const {
1102    const RecodeNode *best_node = nullptr;
1103    const RecodeNode *second_best_node = nullptr;
1104    const RecodeBeam *last_beam = beam_[beam_size_ - 1];
1105    for (int c = 0; c < NC_COUNT; ++c) {
1106      if (c == NC_ONLY_DUP) {
1107        continue;
1108      }
1109      auto cont = static_cast<NodeContinuation>(c);
1110      for (int is_dawg = 0; is_dawg < 2; ++is_dawg) {
1111        int beam_index = BeamIndex(is_dawg, cont, 0);
1112        int heap_size = last_beam->beams_[beam_index].size();
1113        for (int h = 0; h < heap_size; ++h) {
1114          const RecodeNode *node = &last_beam->beams_[beam_index].get(h).data();
1115          if (is_dawg) {
1116            const RecodeNode *dawg_node = node;
1117            while (dawg_node != nullptr &&
1118                   (dawg_node->unichar_id == INVALID_UNICHAR_ID ||
1119                    dawg_node->duplicate)) {
1120              dawg_node = dawg_node->prev;
1121            }
1122            if (dawg_node == nullptr ||
1123                (!dawg_node->end_of_word &&
1124                 dawg_node->unichar_id != UNICHAR_SPACE)) {
1125              continue;
1126            }
1127          }
1128          if (best_node == nullptr || node->score > best_node->score) {
1129            second_best_node = best_node;
1130            best_node = node;
1131          } else if (second_best_node == nullptr ||
1132                     node->score > second_best_node->score) {
1133            second_best_node = node;
1134          }
1135        }
1136      }
1137    }
1138    if (second_nodes != nullptr) {
1139      ExtractPath(second_best_node, second_nodes);
1140    }
1141    ExtractPath(best_node, best_nodes);
1142  }
1143  void RecodeBeamSearch::ExtractPath(
1144      const RecodeNode *node, std::vector<const RecodeNode *> *path) const {
1145    path->clear();
1146    while (node != nullptr) {
1147      path->push_back(node);
1148      node = node->prev;
1149    }
1150    std::reverse(path->begin(), path->end());
1151  }
1152  void RecodeBeamSearch::ExtractPath(const RecodeNode *node,
1153                                     std::vector<const RecodeNode *> *path,
1154                                     int limiter) const {
1155    int pathcounter = 0;
1156    path->clear();
1157    while (node != nullptr && pathcounter < limiter) {
1158      path->push_back(node);
1159      node = node->prev;
1160      ++pathcounter;
1161    }
1162    std::reverse(path->begin(), path->end());
1163  }
1164  void RecodeBeamSearch::DebugPath(
1165      const UNICHARSET *unicharset,
1166      const std::vector<const RecodeNode *> &path) const {
1167    for (unsigned c = 0; c < path.size(); ++c) {
1168      const RecodeNode &node = *path[c];
1169      tprintf("%u ", c);
1170      node.Print(null_char_, *unicharset, 1);
1171    }
1172  }
1173  void RecodeBeamSearch::DebugUnicharPath(
1174      const UNICHARSET *unicharset, const std::vector<const RecodeNode *> &path,
1175      const std::vector<int> &unichar_ids, const std::vector<float> &certs,
1176      const std::vector<float> &ratings, const std::vector<int> &xcoords) const {
1177    auto num_ids = unichar_ids.size();
1178    double total_rating = 0.0;
1179    for (unsigned c = 0; c < num_ids; ++c) {
1180      int coord = xcoords[c];
1181      tprintf("%d %d=%s r=%g, c=%g, s=%d, e=%d, perm=%d\n", coord, unichar_ids[c],
1182              unicharset->debug_str(unichar_ids[c]).c_str(), ratings[c], certs[c],
1183              path[coord]->start_of_word, path[coord]->end_of_word,
1184              path[coord]->permuter);
1185      total_rating += ratings[c];
1186    }
1187    tprintf("Path total rating = %g\n", total_rating);
1188  }
1189  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockprocessor.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam.cpp</div>
                </div>
                <div class="column column_space"><pre><code>36  	using processed_t = std::pair<nano::process_return, std::shared_ptr<nano::block>>;
37  	nano::observer_set<nano::process_return const &, std::shared_ptr<nano::block>> processed;
38  	nano::observer_set<std::deque<processed_t> const &> batch_processed;
39  private:
40  	blocking_observer blocking;
</pre></code></div>
                <div class="column column_space"><pre><code>1009      int length, bool dup, int code, int unichar_id, float cert,
1010      float worst_dict_cert, float dict_ratio, bool use_dawgs,
1011      NodeContinuation cont, const RecodeNode *prev, RecodeBeam *step) {
1012    int index = BeamIndex(use_dawgs, cont, length);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    