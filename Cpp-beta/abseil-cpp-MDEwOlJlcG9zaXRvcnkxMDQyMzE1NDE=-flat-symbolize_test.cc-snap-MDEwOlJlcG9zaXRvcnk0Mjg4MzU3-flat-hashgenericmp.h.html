
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.0654044750430294%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-symbolize_test.cc</h3>
            <pre><code>1  #include "absl/debugging/symbolize.h"
2  #ifndef _WIN32
3  #include <fcntl.h>
4  #include <sys/mman.h>
5  #endif
6  #include <cstring>
7  #include <iostream>
8  #include <memory>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/casts.h"
13  #include "absl/base/config.h"
14  #include "absl/base/internal/per_thread_tls.h"
15  #include "absl/base/optimization.h"
16  #include "absl/debugging/internal/stack_consumption.h"
17  #include "absl/log/check.h"
18  #include "absl/log/log.h"
19  #include "absl/memory/memory.h"
20  #include "absl/strings/string_view.h"
21  using testing::Contains;
22  #ifdef _WIN32
23  #define ABSL_SYMBOLIZE_TEST_NOINLINE __declspec(noinline)
24  #else
25  #define ABSL_SYMBOLIZE_TEST_NOINLINE ABSL_ATTRIBUTE_NOINLINE
26  #endif
27  extern "C" {
28  ABSL_SYMBOLIZE_TEST_NOINLINE void nonstatic_func() {
29    volatile int x = __LINE__;
30    static_cast<void>(x);
31    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
32  }
33  ABSL_SYMBOLIZE_TEST_NOINLINE static void static_func() {
34    volatile int x = __LINE__;
35    static_cast<void>(x);
36    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
37  }
38  }  
39  struct Foo {
40    static void func(int x);
41  };
42  ABSL_SYMBOLIZE_TEST_NOINLINE void Foo::func(int) {
43    volatile int x = __LINE__;
44    static_cast<void>(x);
45    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
46  }
47  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.unlikely) unlikely_func() {
48    return 0;
49  }
50  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.hot) hot_func() {
51    return 0;
52  }
53  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.startup) startup_func() {
54    return 0;
55  }
56  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.exit) exit_func() {
57    return 0;
58  }
59  int &bsol;*ABSL_ATTRIBUTE_SECTION_VARIABLE(.text)*/ regular_func() {
60    return 0;
61  }
62  #if ABSL_PER_THREAD_TLS
63  static ABSL_PER_THREAD_TLS_KEYWORD char symbolize_test_thread_small[1];
64  static ABSL_PER_THREAD_TLS_KEYWORD char
65      symbolize_test_thread_big[2 * 1024 * 1024];
66  #endif
67  #if !defined(__EMSCRIPTEN__)
68  static volatile bool volatile_bool = false;
69  static constexpr size_t kHpageSize = 1 << 21;
70  const char kHpageTextPadding[kHpageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(
71      .text) = "";
72  #endif  
73  static char try_symbolize_buffer[4096];
74  static const char *TrySymbolizeWithLimit(void *pc, int limit) {
75    CHECK_LE(limit, sizeof(try_symbolize_buffer))
76        << "try_symbolize_buffer is too small";
77    auto heap_buffer = absl::make_unique<char[]>(sizeof(try_symbolize_buffer));
78    bool found = absl::Symbolize(pc, heap_buffer.get(), limit);
79    if (found) {
80      CHECK_LT(static_cast<int>(
81                   strnlen(heap_buffer.get(), static_cast<size_t>(limit))),
82               limit)
83          << "absl::Symbolize() did not properly terminate the string";
84      strncpy(try_symbolize_buffer, heap_buffer.get(),
85              sizeof(try_symbolize_buffer) - 1);
86      try_symbolize_buffer[sizeof(try_symbolize_buffer) - 1] = '\0';
87    }
88    return found ? try_symbolize_buffer : nullptr;
89  }
90  static const char *TrySymbolize(void *pc) {
91    return TrySymbolizeWithLimit(pc, sizeof(try_symbolize_buffer));
92  }
93  #if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) ||    \
94      defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE) || \
95      defined(ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE)
96  void ABSL_ATTRIBUTE_NOINLINE TestWithReturnAddress() {
97  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
98    void *return_address = __builtin_return_address(0);
99    const char *symbol = TrySymbolize(return_address);
100    CHECK_NE(symbol, nullptr) << "TestWithReturnAddress failed";
101    CHECK_STREQ(symbol, "main") << "TestWithReturnAddress failed";
102    std::cout << "TestWithReturnAddress passed" << std::endl;
103  #endif
104  }
105  #ifndef ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE
106  TEST(Symbolize, Cached) {
107    EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));
108    const char *static_func_symbol = TrySymbolize((void *)(&static_func));
109    EXPECT_TRUE(strcmp("static_func", static_func_symbol) == 0 ||
110                strcmp("static_func()", static_func_symbol) == 0);
111    EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
112  }
113  TEST(Symbolize, Truncation) {
114    constexpr char kNonStaticFunc[] = "nonstatic_func";
115    EXPECT_STREQ("nonstatic_func",
116                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
117                                       strlen(kNonStaticFunc) + 1));
118    EXPECT_STREQ("nonstatic_...",
119                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
120                                       strlen(kNonStaticFunc) + 0));
121    EXPECT_STREQ("nonstatic...",
122                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
123                                       strlen(kNonStaticFunc) - 1));
124    EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
125    EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
126    EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
127    EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
128    EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
129    EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
130  }
131  TEST(Symbolize, SymbolizeWithDemangling) {
132    Foo::func(100);
133    EXPECT_STREQ("Foo::func()", TrySymbolize((void *)(&Foo::func)));
134  }
135  TEST(Symbolize, SymbolizeSplitTextSections) {
136    EXPECT_STREQ("unlikely_func()", TrySymbolize((void *)(&unlikely_func)));
137    EXPECT_STREQ("hot_func()", TrySymbolize((void *)(&hot_func)));
138    EXPECT_STREQ("startup_func()", TrySymbolize((void *)(&startup_func)));
139    EXPECT_STREQ("exit_func()", TrySymbolize((void *)(&exit_func)));
140    EXPECT_STREQ("regular_func()", TrySymbolize((void *)(&regular_func)));
141  }
142  #ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
143  static void *g_pc_to_symbolize;
144  static char g_symbolize_buffer[4096];
145  static char *g_symbolize_result;
146  static void SymbolizeSignalHandler(int signo) {
147    if (absl::Symbolize(g_pc_to_symbolize, g_symbolize_buffer,
148                        sizeof(g_symbolize_buffer))) {
149      g_symbolize_result = g_symbolize_buffer;
150    } else {
151      g_symbolize_result = nullptr;
152    }
153  }
154  static const char *SymbolizeStackConsumption(void *pc, int *stack_consumed) {
155    g_pc_to_symbolize = pc;
156    *stack_consumed = absl::debugging_internal::GetSignalHandlerStackConsumption(
157        SymbolizeSignalHandler);
158    return g_symbolize_result;
159  }
160  static int GetStackConsumptionUpperLimit() {
161    int stack_consumption_upper_limit = 2048;
162  #if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
163      defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
164    stack_consumption_upper_limit *= 5;
165  #endif
166    return stack_consumption_upper_limit;
167  }
168  TEST(Symbolize, SymbolizeStackConsumption) {
169    int stack_consumed = 0;
170    const char *symbol =
171        SymbolizeStackConsumption((void *)(&nonstatic_func), &stack_consumed);
172    EXPECT_STREQ("nonstatic_func", symbol);
173    EXPECT_GT(stack_consumed, 0);
174    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
175    symbol = SymbolizeStackConsumption((void *)(&static_func), &stack_consumed);
176    EXPECT_TRUE(strcmp("static_func", symbol) == 0 ||
177                strcmp("static_func()", symbol) == 0);
178    EXPECT_GT(stack_consumed, 0);
179    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
180  }
181  TEST(Symbolize, SymbolizeWithDemanglingStackConsumption) {
182    Foo::func(100);
183    int stack_consumed = 0;
184    const char *symbol =
185        SymbolizeStackConsumption((void *)(&Foo::func), &stack_consumed);
186    EXPECT_STREQ("Foo::func()", symbol);
187    EXPECT_GT(stack_consumed, 0);
188    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
189  }
190  #endif  
191  #ifndef ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
192  const size_t kPageSize = 64 << 10;
193  const char kPadding0[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) =
194      "";
195  const char kPadding1[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) =
196      "";
197  static int FilterElfHeader(struct dl_phdr_info *info, size_t size, void *data) {
198    for (int i = 0; i < info->dlpi_phnum; i++) {
199      if (info->dlpi_phdr[i].p_type == PT_LOAD &&
200          info->dlpi_phdr[i].p_flags == (PF_R | PF_X)) {
201        const void *const vaddr =
202            absl::bit_cast<void *>(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);
203        const auto segsize = info->dlpi_phdr[i].p_memsz;
204        const char *self_exe;
205        if (info->dlpi_name != nullptr && info->dlpi_name[0] != '\0') {
206          self_exe = info->dlpi_name;
207        } else {
208          self_exe = "/proc/self/exe";
209        }
210        absl::debugging_internal::RegisterFileMappingHint(
211            vaddr, reinterpret_cast<const char *>(vaddr) + segsize,
212            info->dlpi_phdr[i].p_offset, self_exe);
213        return 1;
214      }
215    }
216    return 1;
217  }
218  TEST(Symbolize, SymbolizeWithMultipleMaps) {
219    if (volatile_bool) {
220      LOG(INFO) << kPadding0;
221      LOG(INFO) << kPadding1;
222    }
223    char buf[512];
224    memset(buf, 0, sizeof(buf));
225    absl::Symbolize(kPadding0, buf, sizeof(buf));
226    EXPECT_STREQ("kPadding0", buf);
227    memset(buf, 0, sizeof(buf));
228    absl::Symbolize(kPadding1, buf, sizeof(buf));
229    EXPECT_STREQ("kPadding1", buf);
230    dl_iterate_phdr(FilterElfHeader, nullptr);
231    const char *ptrs[] = {kPadding0, kPadding1};
232    for (const char *ptr : ptrs) {
233      const int kMapFlags = MAP_ANONYMOUS | MAP_PRIVATE;
234      void *addr = mmap(nullptr, kPageSize, PROT_READ, kMapFlags, 0, 0);
235      ASSERT_NE(addr, MAP_FAILED);
236      void *remapped = reinterpret_cast<void *>(
237          reinterpret_cast<uintptr_t>(ptr + kPageSize) & ~(kPageSize - 1ULL));
238      const int kMremapFlags = (MREMAP_MAYMOVE | MREMAP_FIXED);
239      void *ret = mremap(addr, kPageSize, kPageSize, kMremapFlags, remapped);
240      ASSERT_NE(ret, MAP_FAILED);
241    }
242    absl::Symbolize(nullptr, buf, sizeof(buf));
243    const char *expected[] = {"kPadding0", "kPadding1"};
244    const size_t offsets[] = {0, kPageSize, 2 * kPageSize, 3 * kPageSize};
245    for (int i = 0; i < 2; i++) {
246      for (size_t offset : offsets) {
247        memset(buf, 0, sizeof(buf));
248        absl::Symbolize(ptrs[i] + offset, buf, sizeof(buf));
249        EXPECT_STREQ(expected[i], buf);
250      }
251    }
252  }
253  static void DummySymbolDecorator(
254      const absl::debugging_internal::SymbolDecoratorArgs *args) {
255    std::string *message = static_cast<std::string *>(args->arg);
256    strncat(args->symbol_buf, message->c_str(),
<span onclick='openModal()' class='match'>257            args->symbol_buf_size - strlen(args->symbol_buf) - 1);
258  }
259  TEST(Symbolize, InstallAndRemoveSymbolDecorators) {
260    int ticket_a;
261    std::string a_message("a");
262    EXPECT_GE(ticket_a = absl::debugging_internal::InstallSymbolDecorator(
</span>263                  DummySymbolDecorator, &a_message),
264              0);
265    int ticket_b;
266    std::string b_message("b");
267    EXPECT_GE(ticket_b = absl::debugging_internal::InstallSymbolDecorator(
268                  DummySymbolDecorator, &b_message),
269              0);
270    int ticket_c;
271    std::string c_message("c");
272    EXPECT_GE(ticket_c = absl::debugging_internal::InstallSymbolDecorator(
273                  DummySymbolDecorator, &c_message),
274              0);
275    char *address = reinterpret_cast<char *>(4);
276    EXPECT_STREQ("abc", TrySymbolize(address));
277    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_b));
278    EXPECT_STREQ("ac", TrySymbolize(address + 4));
279    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_a));
280    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_c));
281  }
282  static int in_data_section = 1;
283  TEST(Symbolize, ForEachSection) {
284    int fd = TEMP_FAILURE_RETRY(open("/proc/self/exe", O_RDONLY));
285    ASSERT_NE(fd, -1);
286    std::vector<std::string> sections;
287    ASSERT_TRUE(absl::debugging_internal::ForEachSection(
288        fd, [&sections](const absl::string_view name, const ElfW(Shdr) &) {
289          sections.emplace_back(name);
290          return true;
291        }));
292    EXPECT_THAT(sections, Contains(".text"));
293    EXPECT_THAT(sections, Contains(".rodata"));
294    EXPECT_THAT(sections, Contains(".bss"));
295    ++in_data_section;
296    EXPECT_THAT(sections, Contains(".data"));
297    close(fd);
298  }
299  #endif  
300  #endif  
301  extern "C" {
302  inline void *ABSL_ATTRIBUTE_ALWAYS_INLINE inline_func() {
303    void *pc = nullptr;
304  #if defined(__i386__)
305    __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [ PC ] "=r"(pc));
306  #elif defined(__x86_64__)
307    __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [ PC ] "=r"(pc));
308  #endif
309    return pc;
310  }
311  void *ABSL_ATTRIBUTE_NOINLINE non_inline_func() {
312    void *pc = nullptr;
313  #if defined(__i386__)
314    __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [ PC ] "=r"(pc));
315  #elif defined(__x86_64__)
316    __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [ PC ] "=r"(pc));
317  #endif
318    return pc;
319  }
320  void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideNonInlineFunction() {
321  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE) && \
322      (defined(__i386__) || defined(__x86_64__))
323    void *pc = non_inline_func();
324    const char *symbol = TrySymbolize(pc);
325    CHECK_NE(symbol, nullptr) << "TestWithPCInsideNonInlineFunction failed";
326    CHECK_STREQ(symbol, "non_inline_func")
327        << "TestWithPCInsideNonInlineFunction failed";
328    std::cout << "TestWithPCInsideNonInlineFunction passed" << std::endl;
329  #endif
330  }
331  void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideInlineFunction() {
332  #if defined(ABSL_HAVE_ATTRIBUTE_ALWAYS_INLINE) && \
333      (defined(__i386__) || defined(__x86_64__))
334    void *pc = inline_func();  
335    const char *symbol = TrySymbolize(pc);
336    CHECK_NE(symbol, nullptr) << "TestWithPCInsideInlineFunction failed";
337    CHECK_STREQ(symbol, __FUNCTION__) << "TestWithPCInsideInlineFunction failed";
338    std::cout << "TestWithPCInsideInlineFunction passed" << std::endl;
339  #endif
340  }
341  }
342  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
343      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
344  __attribute__((target("thumb"))) int ArmThumbOverlapThumb(int x) {
345    return x * x * x;
346  }
347  __attribute__((target("arm"))) int ArmThumbOverlapArm(int x) {
348    return x * x * x;
349  }
350  void ABSL_ATTRIBUTE_NOINLINE TestArmThumbOverlap() {
351  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
352    const char *symbol = TrySymbolize((void *)&ArmThumbOverlapArm);
353    CHECK_NE(symbol, nullptr) << "TestArmThumbOverlap failed";
354    CHECK_STREQ("ArmThumbOverlapArm()", symbol) << "TestArmThumbOverlap failed";
355    std::cout << "TestArmThumbOverlap passed" << std::endl;
356  #endif
357  }
358  #endif  
359  #elif defined(_WIN32)
360  #if !defined(ABSL_CONSUME_DLL)
361  TEST(Symbolize, Basics) {
362    EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));
363    const char *static_func_symbol = TrySymbolize((void *)(&static_func));
364    ASSERT_TRUE(static_func_symbol != nullptr);
365    EXPECT_TRUE(strstr(static_func_symbol, "static_func") != nullptr);
366    EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
367  }
368  TEST(Symbolize, Truncation) {
369    constexpr char kNonStaticFunc[] = "nonstatic_func";
370    EXPECT_STREQ("nonstatic_func",
371                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
372                                       strlen(kNonStaticFunc) + 1));
373    EXPECT_STREQ("nonstatic_...",
374                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
375                                       strlen(kNonStaticFunc) + 0));
376    EXPECT_STREQ("nonstatic...",
377                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
378                                       strlen(kNonStaticFunc) - 1));
379    EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
380    EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
381    EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
382    EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
383    EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
384    EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
385  }
386  TEST(Symbolize, SymbolizeWithDemangling) {
387    const char *result = TrySymbolize((void *)(&Foo::func));
388    ASSERT_TRUE(result != nullptr);
389    EXPECT_TRUE(strstr(result, "Foo::func") != nullptr) << result;
390  }
391  #endif  
392  #else  
393  TEST(Symbolize, Unimplemented) {
394    char buf[64];
395    EXPECT_FALSE(absl::Symbolize((void *)(&nonstatic_func), buf, sizeof(buf)));
396    EXPECT_FALSE(absl::Symbolize((void *)(&static_func), buf, sizeof(buf)));
397    EXPECT_FALSE(absl::Symbolize((void *)(&Foo::func), buf, sizeof(buf)));
398  }
399  #endif
400  int main(int argc, char **argv) {
401  #if !defined(__EMSCRIPTEN__)
402    if (volatile_bool) {
403      LOG(INFO) << kHpageTextPadding;
404    }
405  #endif  
406  #if ABSL_PER_THREAD_TLS
407    symbolize_test_thread_small[0] = 0;
408    symbolize_test_thread_big[0] = 0;
409  #endif
410    absl::InitializeSymbolizer(argv[0]);
411    testing::InitGoogleTest(&argc, argv);
412  #if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) || \
413      defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE)
414    TestWithPCInsideInlineFunction();
415    TestWithPCInsideNonInlineFunction();
416    TestWithReturnAddress();
417  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
418      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
419    TestArmThumbOverlap();
420  #endif
421  #endif
422    return RUN_ALL_TESTS();
423  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashgenericmp.h</h3>
            <pre><code>1  #include "bd.h"
2  #ifdef GLib_GLIBC
3  inline unsigned int __sync_fetch_and_add_2(volatile unsigned int* p, unsigned int incr)
4  {
5      unsigned int result;
6      asm volatile("lock; xadd %0, %1" :
7              "=r"(result), "=m"(*p):
8              "0"(incr), "m"(*p) :
9              "memory");
10      return result + 1;
11  }
12  #endif
13  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
14  class THashGenericMP{
15  public:
16    enum {HashPrimes=32};
17    static const unsigned int HashPrimeT[HashPrimes];
18  public:
19    typedef THashKeyDatI<TKey, TDat> TIter;
20  private:
21    typedef THashKeyDat<TKey, TDat> THKeyDat;
22    typedef TPair<TKey, TDat> TKeyDatP;
23    TIntV PortV;
24    TIntV PortLockV;
25    TVec<THKeyDat> KeyDatV;
26    TBool AutoSizeP;
27    TInt FFreeKeyId, FreeKeys;
28  private:
29    class THashKeyDatCmp {
30    public:
31      const THash<TKey, TDat, THashFunc>& Hash;
32      bool CmpKey, Asc;
33      THashKeyDatCmp(THash<TKey, TDat, THashFunc>& _Hash, const bool& _CmpKey, const bool& _Asc) :
34        Hash(_Hash), CmpKey(_CmpKey), Asc(_Asc) { }
35      bool operator () (const int& KeyId1, const int& KeyId2) const {
36        if (CmpKey) {
37          if (Asc) { return Hash.GetKey(KeyId1) < Hash.GetKey(KeyId2); }
38          else { return Hash.GetKey(KeyId2) < Hash.GetKey(KeyId1); } }
39        else {
40          if (Asc) { return Hash[KeyId1] < Hash[KeyId2]; }
41          else { return Hash[KeyId2] < Hash[KeyId1]; } } }
42    };
43  private:
44    THKeyDat& GetHashKeyDat(const int& KeyId){
45      THKeyDat& KeyDat=KeyDatV[KeyId];
46      Assert(KeyDat.HashCd!=-1); return KeyDat;}
47    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
48      const THKeyDat& KeyDat=KeyDatV[KeyId];
49      Assert(KeyDat.HashCd!=-1); return KeyDat;}
50    uint GetNextPrime(const uint& Val) const;
51    void Resize();
52  public:
53    THashGenericMP():
54      PortV(), KeyDatV(),
55      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0){
56      }
57    THashGenericMP(const THashGenericMP& Hash):
58      PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
59      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys) {
60      }
61    explicit THashGenericMP(const int& ExpectVals, const bool& _AutoSizeP=false);
62    explicit THashGenericMP(TSIn& SIn):
63      PortV(SIn), KeyDatV(SIn),
64      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){
65      SIn.LoadCs();
66    }
67    void Load(TSIn& SIn){
68      PortV.Load(SIn); KeyDatV.Load(SIn);
69      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
70      SIn.LoadCs();
71    }
72    void Save(TSOut& SOut) const {
73      PortV.Save(SOut); KeyDatV.Save(SOut);
74      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
75      SOut.SaveCs();
76    }
77    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
78    void SaveXml(TSOut& SOut, const TStr& Nm);
79    void ResizePar(int);
80    THashGenericMP& operator=(const THashGenericMP& Hash){
81      if (this!=&Hash){
82        PortV=Hash.PortV; KeyDatV=Hash.KeyDatV; AutoSizeP=Hash.AutoSizeP;
83        FFreeKeyId=Hash.FFreeKeyId; FreeKeys=Hash.FreeKeys;}
84      return *this;}
85    bool operator==(const THashGenericMP& Hash) const; 
86    bool operator < (const THashGenericMP& Hash) const { Fail; return true; }
87    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
88    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
89    TDat& operator()(const TKey& Key){return AddDat(Key);}
90    ::TSize GetMemUsed() const {
91        int64 MemUsed = sizeof(bool)+2*sizeof(int);
92        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
93        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
94            MemUsed += int64(2 * sizeof(TInt));
95            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
96            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
97        }
98        return ::TSize(MemUsed);
99    }
100    TIter BegI() const {
101      if (Len() == 0){return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
102      if (IsKeyIdEqKeyN()) { return TIter(KeyDatV.BegI(), KeyDatV.EndI());}
103      int FKeyId=-1;  FNextKeyId(FKeyId);
104      return TIter(KeyDatV.BegI()+FKeyId, KeyDatV.EndI()); }
105    TIter EndI() const {return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
106    TIter GetI(const TKey& Key) const {return TIter(&KeyDatV[GetKeyId(Key)], KeyDatV.EndI());}
107    void Gen(const int& ExpectVals){
108      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyDatV.Gen(ExpectVals, 0);
109      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1));}
110    void Clr(const bool& DoDel=true, const int& NoDelLim=-1, const bool& ResetDat=true);
111    bool Empty() const {return Len()==0;}
112    int Len() const {return KeyDatV.Len()-FreeKeys;}
113    int GetPorts() const {return PortV.Len();}
114    bool IsAutoSize() const {return AutoSizeP;}
115    int GetMxKeyIds() const {return KeyDatV.Len();}
116    int GetReservedKeyIds() const {return KeyDatV.Reserved();}
117    bool IsKeyIdEqKeyN() const {return FreeKeys==0;}
118    int AddKey(const TKey& Key);
119    int AddKeyPar(const TKey& Key);
120    TDat& AddDatId(const TKey& Key){
121      int KeyId=AddKey(Key); return KeyDatV[KeyId].Dat=KeyId;}
122    TDat& AddDat(const TKey& Key){return KeyDatV[AddKey(Key)].Dat;}
123    TDat& AddDat(const TKey& Key, const TDat& Dat){
124      return KeyDatV[AddKey(Key)].Dat=Dat;}
125    bool AddDatIfNotExist(const TKey& Key, const TDat& Dat);
126    int AddDatPar(const TKey& Key, const TInt& Dat) {
127      const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
128      const int HashCd=abs(THashFunc::GetSecHashCd(Key));
129      int PrevKeyId=-1;
130      int KeyId;
131      int Ret;
132      bool done = false;
133      while(!done) {
134        bool port_lock = false;
135        int old;
136        int *ptr = &PortLockV[PortN].Val;
137        old = PortLockV[PortN];
138        if (old == -2) {
139          port_lock = false;
140        }
141        else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
142          port_lock = true;
143        }
144        KeyId = PortV[PortN];
145        while ((KeyId!=-1) &&
146            !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
147          PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
148        if (KeyId==-1) {
149          if (port_lock == false) continue;
150          volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
151          KeyId = __sync_fetch_and_add(p, 1);
152          KeyDatV[KeyId].Next=-1;
153          KeyDatV[KeyId].HashCd=HashCd;
154          KeyDatV[KeyId].Key=Key;
155          int temp;
156          int* pt = &KeyDatV[KeyId].Next.Val;
157          while(true) {
158            temp = KeyDatV[KeyId].Next;
159            if (temp == -2) continue;
160            if (__sync_bool_compare_and_swap(pt, temp, -2)) {
161              KeyDatV[KeyId].Dat.Val1 = 0;
162              KeyDatV[KeyId].Dat.Val2.Add(Dat);
163              *pt = temp;
164              done = true;
165  	          Ret = 0;
166              break;
167            }
168          }
169          if (PrevKeyId==-1){
170            PortV[PortN] = KeyId;
171          } else {
172            KeyDatV[PrevKeyId].Next=KeyId;
173          }
174          *ptr = old;
175        }
176        else {
177          int temp, temp1;
178          int* pt = &KeyDatV[KeyId].Next.Val;
179          while(true) {
180            temp = KeyDatV[KeyId].Next;
181            temp1 = __sync_val_compare_and_swap(pt, temp, -2);
182            if (temp1 == temp && temp1 != -2) {
183              KeyDatV[KeyId].Dat.Val2.Add(Dat);
184              *pt = temp;
185              if (port_lock) *ptr = old;
186              done = true;
187  	          Ret = KeyDatV[KeyId].Dat.Val1;
188              break;
189            }
190            else {
191              usleep(20);
192            }
193          }
194        }
195      }
196      return Ret;
197    }
198    void DelKey(const TKey& Key);
199    bool DelIfKey(const TKey& Key){
200      int KeyId; if (IsKey(Key, KeyId)){DelKeyId(KeyId); return true;} return false;}
201    void DelKeyId(const int& KeyId){DelKey(GetKey(KeyId));}
202    void DelKeyIdV(const TIntV& KeyIdV){
203      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++){DelKeyId(KeyIdV[KeyIdN]);}}
204    void MarkDelKey(const TKey& Key); 
205    void MarkDelKeyId(const int& KeyId){MarkDelKey(GetKey(KeyId));}
206    const TKey& GetKey(const int& KeyId) const { return GetHashKeyDat(KeyId).Key;}
207    int GetKeyId(const TKey& Key) const;
208    int GetRndKeyId(TRnd& Rnd) const;
209    int GetRndKeyId(TRnd& Rnd, const double& EmptyFrac);
210    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1;}
211    bool IsKey(const TKey& Key, int& KeyId) const { KeyId=GetKeyId(Key); return KeyId!=-1;}
212    bool IsKeyId(const int& KeyId) const {
213      return (0<=KeyId)&&(KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd!=-1);}
214    const TDat& GetDat(const TKey& Key) const {return KeyDatV[GetKeyId(Key)].Dat;}
<span onclick='openModal()' class='match'>215    TDat& GetDat(const TKey& Key){return KeyDatV[GetKeyId(Key)].Dat;}
216    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
217      const THKeyDat& KeyDat=GetHashKeyDat(KeyId);
</span>218      Key=KeyDat.Key; Dat=KeyDat.Dat;}
219    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const {int KeyId;
220      if (IsKey(Key, KeyId)){Dat=GetHashKeyDat(KeyId).Dat; return true;}
221      else {return false;}}
222    int FFirstKeyId() const {return 0-1;}
223    bool FNextKeyId(int& KeyId) const;
224    void GetKeyV(TVec<TKey>& KeyV) const;
225    void GetDatV(TVec<TDat>& DatV) const;
226    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
227    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
228    void GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const;
229    void GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const;
230    void Swap(THashGenericMP& Hash);
231    void Defrag();
232    void Pack(){KeyDatV.Pack();}
233    void Sort(const bool& CmpKey, const bool& Asc);
234    void SortByKey(const bool& Asc=true) { Sort(true, Asc); }
235    void SortByDat(const bool& Asc=true) { Sort(false, Asc); }
236  };
237  template<class TKey, class TDat, class THashFunc>
238  const unsigned int THashGenericMP<TKey, TDat, THashFunc>::HashPrimeT[HashPrimes]={
239    3ul, 5ul, 11ul, 23ul,
240    53ul,         97ul,         193ul,       389ul,       769ul,
241    1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
242    49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
243    1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
244    50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
245    1610612741ul, 3221225473ul, 4294967291ul
246  };
247  template<class TKey, class TDat, class THashFunc>
248  uint THashGenericMP<TKey, TDat, THashFunc>::GetNextPrime(const uint& Val) const {
249    const uint* f=(const uint*)HashPrimeT, *m, *l=(const uint*)HashPrimeT + (int)HashPrimes;
250    int h, len = (int)HashPrimes;
251    while (len > 0) {
252      h = len >> 1;  m = f + h;
253      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
254      else len = h;
255    }
256    return f == l ? *(l - 1) : *f;
257  }
258  template<class TKey, class TDat, class THashFunc>
259  void THashGenericMP<TKey, TDat, THashFunc>::ResizePar(int sz){
260    if (PortV.Len()==0){
261      PortV.Gen(sz);
262      KeyDatV.Gen(sz);
263      PortLockV.Gen(sz);
264    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
265      PortV.Gen(GetNextPrime(PortV.Len()+1));
266    } else {
267      return;
268    }
269    PortV.PutAll(TInt(-1));
270    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
271      THKeyDat& KeyDat=KeyDatV[KeyId];
272      if (KeyDat.HashCd!=-1){
273        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
274        KeyDat.Next=PortV[PortN];
275        PortV[PortN]=KeyId;
276      }
277    }
278  }
279  template<class TKey, class TDat, class THashFunc>
280  void THashGenericMP<TKey, TDat, THashFunc>::Resize(){
281    if (PortV.Len()==0){
282      PortV.Gen(17);
283    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
284      PortV.Gen(GetNextPrime(PortV.Len()+1));
285    } else {
286      return;
287    }
288    PortV.PutAll(TInt(-1));
289    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
290      THKeyDat& KeyDat=KeyDatV[KeyId];
291      if (KeyDat.HashCd!=-1){
292        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
293        KeyDat.Next=PortV[PortN];
294        PortV[PortN]=KeyId;
295      }
296    }
297  }
298  template<class TKey, class TDat, class THashFunc>
299  THashGenericMP<TKey, TDat, THashFunc>::THashGenericMP(const int& ExpectVals, const bool& _AutoSizeP):
300    PortV(GetNextPrime(ExpectVals/2)), KeyDatV(ExpectVals, 0),
301    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0){
302    PortV.PutAll(TInt(-1));
303  }
304  template<class TKey, class TDat, class THashFunc>
305  bool THashGenericMP<TKey, TDat, THashFunc>::operator==(const THashGenericMP& Hash) const {
306    if (Len() != Hash.Len()) { return false; }
307    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
308      const TKey& Key = GetKey(i);
309      if (! Hash.IsKey(Key)) { return false; }
310      if (GetDat(Key) != Hash.GetDat(Key)) { return false; }
311    }
312    return true;
313  }
314  template<class TKey, class TDat, class THashFunc>
315  void THashGenericMP<TKey, TDat, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim, const bool& ResetDat){
316    if (DoDel){
317      PortV.Clr(); KeyDatV.Clr();
318    } else {
319      PortV.PutAll(TInt(-1));
320      KeyDatV.Clr(DoDel, NoDelLim);
321      if (ResetDat){KeyDatV.PutAll(THKeyDat());}
322    }
323    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
324  }
325  template<class TKey, class TDat, class THashFunc>
326  int THashGenericMP<TKey, TDat, THashFunc>::AddKey(const TKey& Key){
327    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
328    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
329    int PrevKeyId=-1;
330    int KeyId=PortV[PortN];
331    while ((KeyId!=-1) &&
332     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
333      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
334    if (KeyId==-1){
335      if (FFreeKeyId==-1){
336        KeyId=KeyDatV.Add(THKeyDat(-1, HashCd, Key));
337      } else {
338        KeyId=FFreeKeyId; FFreeKeyId=KeyDatV[FFreeKeyId].Next; FreeKeys--;
339        KeyDatV[KeyId].Next=-1;
340        KeyDatV[KeyId].HashCd=HashCd;
341        KeyDatV[KeyId].Key=Key;
342      }
343      if (PrevKeyId==-1){
344        PortV[PortN]=KeyId;
345      } else {
346        KeyDatV[PrevKeyId].Next=KeyId;
347      }
348    }
349    return KeyId;
350  }
351  template<class TKey, class TDat, class THashFunc>
352  int THashGenericMP<TKey, TDat, THashFunc>::AddKeyPar(const TKey& Key){
353      const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
354      const int HashCd=abs(THashFunc::GetSecHashCd(Key));
355      int PrevKeyId=-1;
356      int KeyId;
357      bool done = false;
358      while(!done) {
359        bool port_lock = false;
360        int old;
361        int *ptr = &PortLockV[PortN].Val;
362        old = PortLockV[PortN];
363        if (old == -2) {
364          port_lock = false;
365        }
366        else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
367          port_lock = true;
368        }
369        KeyId = PortV[PortN];
370        while ((KeyId!=-1) &&
371            !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
372          PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
373        if (KeyId==-1) {
374          if (port_lock == false) continue;
375          volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
376          KeyId = __sync_fetch_and_add(p, 1);
377          KeyDatV[KeyId].Next=-1;
378          KeyDatV[KeyId].HashCd=HashCd;
379          KeyDatV[KeyId].Key=Key;
380          if (PrevKeyId==-1){
381            PortV[PortN] = KeyId;
382          } else {
383            KeyDatV[PrevKeyId].Next=KeyId;
384          }
385          *ptr = old;
386          done = true;
387        }
388        else {
389          done = true;
390        }
391      }
392      return KeyId;
393  }
394  template<class TKey, class TDat, class THashFunc>
395  void THashGenericMP<TKey, TDat, THashFunc>::DelKey(const TKey& Key){
396    IAssert(!PortV.Empty());
397    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
398    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
399    int PrevKeyId=-1;
400    int KeyId=PortV[PortN];
401    while ((KeyId!=-1) &&
402     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
403      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
404    IAssert(KeyId!=-1); 
405    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
406    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
407    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
408    KeyDatV[KeyId].HashCd=TInt(-1);
409    KeyDatV[KeyId].Key=TKey();
410    KeyDatV[KeyId].Dat=TDat();
411  }
412  template<class TKey, class TDat, class THashFunc>
413  void THashGenericMP<TKey, TDat, THashFunc>::MarkDelKey(const TKey& Key){
414    IAssert(!PortV.Empty());
415    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
416    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
417    int PrevKeyId=-1;
418    int KeyId=PortV[PortN];
419    while ((KeyId!=-1) &&
420     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
421      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
422    IAssertR(KeyId!=-1, Key.GetStr());
423    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
424    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
425    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
426    KeyDatV[KeyId].HashCd=TInt(-1);
427  }
428  template<class TKey, class TDat, class THashFunc>
429  int THashGenericMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd) const  {
430    IAssert(! Empty());
431    int KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len()));
432    while (KeyDatV[KeyId].HashCd == -1) { 
433      KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len())); }
434    return KeyId; 
435  }
436  template<class TKey, class TDat, class THashFunc>
437  int THashGenericMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd, const double& EmptyFrac) {
438    IAssert(! Empty());
439    if (FreeKeys/double(Len()+FreeKeys) > EmptyFrac) { Defrag(); }
440    int KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
441    while (KeyDatV[KeyId].HashCd == -1) { 
442      KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
443    }
444    return KeyId;
445  }
446  template<class TKey, class TDat, class THashFunc>
447  int THashGenericMP<TKey, TDat, THashFunc>::GetKeyId(const TKey& Key) const {
448    if (PortV.Empty()){return -1;}
449    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
450    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
451    int KeyId=PortV[PortN];
452    while ((KeyId!=-1) &&
453     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
454      KeyId=KeyDatV[KeyId].Next;}
455    return KeyId;
456  }
457  template<class TKey, class TDat, class THashFunc>
458  bool THashGenericMP<TKey, TDat, THashFunc>::FNextKeyId(int& KeyId) const {
459    do {KeyId++;} while ((KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd==-1));
460    return KeyId<KeyDatV.Len();
461  }
462  template<class TKey, class TDat, class THashFunc>
463  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
464    KeyV.Gen(Len(), 0);
465    int KeyId=FFirstKeyId();
466    while (FNextKeyId(KeyId)){
467      KeyV.Add(GetKey(KeyId));}
468  }
469  template<class TKey, class TDat, class THashFunc>
470  void THashGenericMP<TKey, TDat, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
471    DatV.Gen(Len(), 0);
472    int KeyId=FFirstKeyId();
473    while (FNextKeyId(KeyId)){
474      DatV.Add(GetHashKeyDat(KeyId).Dat);}
475  }
476  template<class TKey, class TDat, class THashFunc>
477  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
478    KeyDatPrV.Gen(Len(), 0);
479    TKey Key; TDat Dat;
480    int KeyId=FFirstKeyId();
481    while (FNextKeyId(KeyId)){
482      GetKeyDat(KeyId, Key, Dat);
483      KeyDatPrV.Add(TPair<TKey, TDat>(Key, Dat));
484    }
485  }
486  template<class TKey, class TDat, class THashFunc>
487  void THashGenericMP<TKey, TDat, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
488    DatKeyPrV.Gen(Len(), 0);
489    TKey Key; TDat Dat;
490    int KeyId=FFirstKeyId();
491    while (FNextKeyId(KeyId)){
492      GetKeyDat(KeyId, Key, Dat);
493      DatKeyPrV.Add(TPair<TDat, TKey>(Dat, Key));
494    }
495  }
496  template<class TKey, class TDat, class THashFunc>
497  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const {
498    KeyDatKdV.Gen(Len(), 0);
499    TKey Key; TDat Dat;
500    int KeyId=FFirstKeyId();
501    while (FNextKeyId(KeyId)){
502      GetKeyDat(KeyId, Key, Dat);
503      KeyDatKdV.Add(TKeyDat<TKey, TDat>(Key, Dat));
504    }
505  }
506  template<class TKey, class TDat, class THashFunc>
507  void THashGenericMP<TKey, TDat, THashFunc>::GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const {
508    DatKeyKdV.Gen(Len(), 0);
509    TKey Key; TDat Dat;
510    int KeyId=FFirstKeyId();
511    while (FNextKeyId(KeyId)){
512      GetKeyDat(KeyId, Key, Dat);
513      DatKeyKdV.Add(TKeyDat<TDat, TKey>(Dat, Key));
514    }
515  }
516  template<class TKey, class TDat, class THashFunc>
517  void THashGenericMP<TKey, TDat, THashFunc>::Swap(THashGenericMP& Hash) {
518    if (this!=&Hash){
519      PortV.Swap(Hash.PortV);
520      KeyDatV.Swap(Hash.KeyDatV);
521      ::Swap(AutoSizeP, Hash.AutoSizeP);
522      ::Swap(FFreeKeyId, Hash.FFreeKeyId);
523      ::Swap(FreeKeys, Hash.FreeKeys);
524    }
525  }
526  template<class TKey, class TDat, class THashFunc>
527  void THashGenericMP<TKey, TDat, THashFunc>::Defrag(){
528    if (!IsKeyIdEqKeyN()){
529      THashGenericMP<TKey, TDat, THashFunc> Hash(PortV.Len());
530      int KeyId=FFirstKeyId(); TKey Key; TDat Dat;
531      while (FNextKeyId(KeyId)){
532        GetKeyDat(KeyId, Key, Dat);
533        Hash.AddDat(Key, Dat);
534      }
535      Pack();
536      operator=(Hash);
537      IAssert(IsKeyIdEqKeyN());
538    }
539  }
540  template<class TKey, class TDat, class THashFunc>
541  void THashGenericMP<TKey, TDat, THashFunc>::Sort(const bool& CmpKey, const bool& Asc) {
542    IAssertR(IsKeyIdEqKeyN(), "THash::Sort only works when table has no deleted keys.");
543    TIntV TargV(Len()), MapV(Len()), StateV(Len());
544    for (int i = 0; i < TargV.Len(); i++) {
545      TargV[i] = i; MapV[i] = i; StateV[i] = i;
546    }
547    THashKeyDatCmp HashCmp(*this, CmpKey, Asc);
548    TargV.SortCmp(HashCmp);
549    THashKeyDat<TKey, TDat> Tmp;
550    for (int i = 0; i < TargV.Len()-1; i++) {
551      const int SrcPos = MapV[TargV[i]];
552      const int Loc = i;
553      Tmp = KeyDatV[SrcPos];
554      KeyDatV[SrcPos] = KeyDatV[Loc];
555      KeyDatV[Loc] = Tmp;
556      MapV[StateV[i]] = SrcPos;
557      StateV.Swap(Loc, SrcPos);
558    }
559    for (int i = 0; i < TargV.Len(); i++) {
560      MapV[TargV[i]] = i; }
561    for (int p = 0; p < PortV.Len(); p++) {
562      if (PortV[p] != -1) {
563        PortV[p] = MapV[PortV[p]]; } }
564    for (int i = 0; i < KeyDatV.Len(); i++) {
565      if (KeyDatV[i].Next != -1) {
566        KeyDatV[i].Next = MapV[KeyDatV[i].Next]; }
567    }
568  }
569  template<class TKey, class TDat, class THashFunc>
570  bool THashGenericMP<TKey, TDat, THashFunc>::AddDatIfNotExist(const TKey& Key, const TDat& Dat) {
571    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
572    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
573    int PrevKeyId=-1;
574    int KeyId;
575    bool done = false;
576    while(!done) {
577      bool port_lock = false;
578      int old;
579      int *ptr = &PortLockV[PortN].Val;
580      old = PortLockV[PortN];
581      if (old == -2) {
582        port_lock = false;
583      }
584      else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
585        port_lock = true;
586      }
587      KeyId = PortV[PortN];
588      while ((KeyId!=-1) &&
589          !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
590        PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
591      if (KeyId==-1) {
592        if (port_lock == false) continue;
593        volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
594        KeyId = __sync_fetch_and_add(p, 1);
595        KeyDatV[KeyId].Next=-1;
596        KeyDatV[KeyId].HashCd=HashCd;
597        KeyDatV[KeyId].Key=Key;
598        int temp;
599        int* pt = &KeyDatV[KeyId].Next.Val;
600        while(true) {
601          temp = KeyDatV[KeyId].Next;
602          if (temp == -2) continue;
603          if (__sync_bool_compare_and_swap(pt, temp, -2)) {
604            KeyDatV[KeyId].Dat = Dat;
605            *pt = temp;
606            done = true;
607            break;
608          }
609        }
610        if (PrevKeyId==-1){
611          PortV[PortN] = KeyId;
612        } else {
613          KeyDatV[PrevKeyId].Next=KeyId;
614        }
615        *ptr = old;
616      }
617      else {
618        if (port_lock) *ptr = old;
619        break;
620      }
621    }
622    return done;
623  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-symbolize_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashgenericmp.h</div>
                </div>
                <div class="column column_space"><pre><code>257            args->symbol_buf_size - strlen(args->symbol_buf) - 1);
258  }
259  TEST(Symbolize, InstallAndRemoveSymbolDecorators) {
260    int ticket_a;
261    std::string a_message("a");
262    EXPECT_GE(ticket_a = absl::debugging_internal::InstallSymbolDecorator(
</pre></code></div>
                <div class="column column_space"><pre><code>215    TDat& GetDat(const TKey& Key){return KeyDatV[GetKeyId(Key)].Dat;}
216    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
217      const THKeyDat& KeyDat=GetHashKeyDat(KeyId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    