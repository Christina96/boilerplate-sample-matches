
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.4477766287487073%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-ggen.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  class GGenTest { };  
4  TEST(GGenTest, GenGrid) {
5    const int RowsStart = 1;
6    const int RowsEnd = 20;
7    const int ColsStart = 1;
8    const int ColsEnd = 15;
9    PUNGraph UNGraph;
10    PNGraph NGraph;
11    for (int Rows = RowsStart; Rows < RowsEnd; Rows++) {
12      for (int Cols = ColsStart; Cols < ColsEnd; Cols++) {
13        int NumEdges = 0;
14        if (Cols > 1) {
15          NumEdges += (Rows - 1) * 2;
16        }
17        else {
18          NumEdges += Rows - 1;
19        }
20        if (Rows > 1) {
21          NumEdges += (Cols - 1) * 2;
22        }
23        else {
24          NumEdges += Cols - 1;
25        }
26        if (Rows > 1 && Cols > 1) {
27          if (Cols >= 2) {
28            NumEdges += Cols - 2;
29          }
30          if (Rows >= 2) {
31            NumEdges += Rows - 2;
32          }
33          if (Rows >= 3 || Cols >= 3) {
34            NumEdges += (Rows-2) * (Cols-2) * 2;
35          }
36        }
37        UNGraph = TSnap::GenGrid<PUNGraph>(Rows, Cols, false);
38        EXPECT_FALSE(UNGraph->Empty());
39        EXPECT_TRUE(UNGraph->IsOk());
40        EXPECT_EQ(Rows*Cols, UNGraph->GetNodes());
41        EXPECT_EQ(NumEdges, UNGraph->GetEdges());
42        int NodeCount = 0;
43        int EdgeCount = 0;
44        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
45          NodeCount++;
46          for (int e = 0; e < NI.GetOutDeg(); e++) {
47            EdgeCount++;
48          }
49        }
50        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
51        EXPECT_EQ(EdgeCount/2, UNGraph->GetEdges());
52        EdgeCount = 0;
53        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
54          EdgeCount++;
55        }
56        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
57        NGraph = TSnap::GenGrid<PNGraph>(Rows, Cols, true);
58        EXPECT_FALSE(NGraph->Empty());
59        EXPECT_TRUE(NGraph->IsOk());
60        EXPECT_EQ(Rows*Cols, NGraph->GetNodes());
61        EXPECT_EQ(NumEdges, NGraph->GetEdges());
62        NodeCount = 0;
63        for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
64          NodeCount++;
65          for (int e = 0; e < NI.GetOutDeg(); e++) {
66            EdgeCount++;
67          }
68        }
69        EXPECT_EQ(NodeCount, NGraph->GetNodes());
70        EXPECT_EQ(EdgeCount/2, NGraph->GetEdges());
71        EdgeCount = 0;
72        for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
73          EdgeCount++;
74        }
75        EXPECT_EQ(EdgeCount, NGraph->GetEdges());
76      } 
77    } 
78  }
79  TEST(GGenTest, GenStar) {
80    const int NNodesMax = 1000;
81    PUNGraph UNGraph;
82    PNGraph NGraph;
83    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
84      int NumEdges = NNodes-1;
85      UNGraph = TSnap::GenStar<PUNGraph>(NNodes, false);
86      EXPECT_FALSE(UNGraph->Empty());
87      EXPECT_TRUE(UNGraph->IsOk());
88      EXPECT_EQ(NumEdges, UNGraph->GetEdges());
89      int NodeCount = 0;
90      int EdgeCount = 0;
91      for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
92        NodeCount++;
93        for (int e = 0; e < NI.GetOutDeg(); e++) {
94          EdgeCount++;
95        }
96      }
97      EXPECT_EQ(NodeCount, UNGraph->GetNodes());
98      EXPECT_EQ(EdgeCount/2, UNGraph->GetEdges());
99      EdgeCount = 0;
100      for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
101        EdgeCount++;
102      }
103      EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
104      NGraph = TSnap::GenStar<PNGraph>(NNodes, true);
105      EXPECT_FALSE(NGraph->Empty());
106      EXPECT_TRUE(NGraph->IsOk());
107      EXPECT_EQ(NumEdges, NGraph->GetEdges());
108      NodeCount = 0;
109      for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
110        NodeCount++;
111        for (int e = 0; e < NI.GetOutDeg(); e++) {
112          EdgeCount++;
113        }
114      }
115      EXPECT_EQ(NodeCount, NGraph->GetNodes());
116      EXPECT_EQ(EdgeCount/2, NGraph->GetEdges());
117      EdgeCount = 0;
118      for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
119        EdgeCount++;
120      }
121      EXPECT_EQ(EdgeCount, NGraph->GetEdges());
122    } 
123  }
124  TEST(GGenTest, GenCircle) {
125    const int NNodesMax = 500;
126    const int NodeOutDegMax = 5;
127    PUNGraph UNGraph;
128    PNGraph NGraph;
129    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
130      for (int NodeOutDeg = 1; NodeOutDeg < NodeOutDegMax; NodeOutDeg++) {
131        UNGraph = TSnap::GenCircle<PUNGraph>(NNodes, NodeOutDeg, false);
132        EXPECT_FALSE(UNGraph->Empty());
133        EXPECT_TRUE(UNGraph->IsOk());
134        int NodeCount = 0;
135        int EdgeCount = 0;
136        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
137          NodeCount++;
138        }
139        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
140        EdgeCount = 0;
141        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
142          EdgeCount++;
143        }
144        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
145        NGraph = TSnap::GenCircle<PNGraph>(NNodes, NodeOutDeg, true);
146        EXPECT_FALSE(NGraph->Empty());
147        EXPECT_TRUE(NGraph->IsOk());
148        NodeCount = 0;
149        for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
150          NodeCount++;
151        }
152        EXPECT_EQ(NodeCount, NGraph->GetNodes());
153        EdgeCount = 0;
154        for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
155          EdgeCount++;
156        }
157        EXPECT_EQ(EdgeCount, NGraph->GetEdges());
158      }
159    } 
160  }
161  TEST(GGenTest, GenFull) {
162    const int NNodesMax = 100;
163    PUNGraph UNGraph;
164    PNGraph NGraph;
165    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
166      UNGraph = TSnap::GenFull<PUNGraph>(NNodes);
167      EXPECT_FALSE(UNGraph->Empty());
168      EXPECT_TRUE(UNGraph->IsOk());
169      int NumEdges = NNodes * (NNodes - 1) / 2;
170      EXPECT_EQ(NumEdges, UNGraph->GetEdges());
171      int NodeCount = 0;
172      int EdgeCount = 0;
173      for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
174        NodeCount++;
175      }
176      EXPECT_EQ(NodeCount, UNGraph->GetNodes());
177      EdgeCount = 0;
178      for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
179        EdgeCount++;
180      }
181      EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
182      NGraph = TSnap::GenFull<PNGraph>(NNodes);
183      EXPECT_FALSE(NGraph->Empty());
184      EXPECT_TRUE(NGraph->IsOk());
185      NumEdges = NNodes * (NNodes - 1);
186      EXPECT_EQ(NumEdges, NGraph->GetEdges());
187      NodeCount = 0;
188      for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
189        NodeCount++;
190      }
191      EXPECT_EQ(NodeCount, NGraph->GetNodes());
192      EdgeCount = 0;
193      for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
194        EdgeCount++;
195      }
196      EXPECT_EQ(EdgeCount, NGraph->GetEdges());
197    } 
198  }
199  TEST(GGenTest, GenTree) {
200    const int FanoutMax = 10;
201    const int LevelsMax = 5;
202    PUNGraph UNGraph;
203    PNGraph NGraph;
204    for (int Fanout = 2; Fanout < FanoutMax; Fanout++) {
205      for (int Levels = 1; Levels < LevelsMax; Levels++) {
206        UNGraph = TSnap::GenTree<PUNGraph>(Fanout, Levels, false);
207        EXPECT_FALSE(UNGraph->Empty());
208        EXPECT_TRUE(UNGraph->IsOk());
209        int NodeCount = 0;
210        int EdgeCount = 0;
211        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
212          NodeCount++;
213        }
214        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
215        EdgeCount = 0;
216        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
217          EdgeCount++;
218        }
219        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
220        NGraph = TSnap::GenTree<PNGraph>(Fanout, Levels, true, true);
221        EXPECT_FALSE(NGraph->Empty());
222        EXPECT_TRUE(NGraph->IsOk());
223        NodeCount = 0;
224        for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
225          NodeCount++;
226        }
227        EXPECT_EQ(NodeCount, NGraph->GetNodes());
228        EdgeCount = 0;
229        for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
230          EdgeCount++;
231        }
232        EXPECT_EQ(EdgeCount, NGraph->GetEdges());
233      } 
234    } 
235  }
236  TEST(GGenTest, GenBaraHierar) {
237    const int LevelsMax = 8;
238    PUNGraph UNGraph;
239    PNGraph NGraph;
240    for (int Levels = 1; Levels < LevelsMax; Levels++) {
241      UNGraph = TSnap::GenBaraHierar<PUNGraph>(Levels);
242      EXPECT_FALSE(UNGraph->Empty());
243      EXPECT_TRUE(UNGraph->IsOk());
244      int NodeCount = 0;
245      int EdgeCount = 0;
246      for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
247        NodeCount++;
248      }
249      EXPECT_EQ(NodeCount, UNGraph->GetNodes());
250      EdgeCount = 0;
251      for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
252        EdgeCount++;
253      }
254      EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
255      NGraph = TSnap::GenBaraHierar<PNGraph>(Levels);
256      EXPECT_FALSE(NGraph->Empty());
257      EXPECT_TRUE(NGraph->IsOk());
258      NodeCount = 0;
259      for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
260        NodeCount++;
261      }
262      EXPECT_EQ(NodeCount, NGraph->GetNodes());
263      EdgeCount = 0;
264      for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
265        EdgeCount++;
266      }
267      EXPECT_EQ(EdgeCount, NGraph->GetEdges());
268    } 
269  }
270  TEST(GGenTest, GenRndGnm) {
271    const int NNodesMax = 30;
272    const int NEdgesMax = 50;
273    int NodeCount = 0;
274    int EdgeCount = 0;
275    PUNGraph UNGraph;
276    PNGraph NGraph;
277    TInt::Rnd.PutSeed(0);
278    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
279      for (int NEdges = 0; NEdges < NEdgesMax; NEdges++) {
280        if (NNodes * (NNodes-1) / 2 >= NEdges) {
281          UNGraph = TSnap::GenRndGnm<PUNGraph>(NNodes, NEdges, false, TInt::Rnd);
282          EXPECT_FALSE(UNGraph->Empty());
283          EXPECT_TRUE(UNGraph->IsOk());
284          NodeCount = 0;
285          EdgeCount = 0;
286          for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
287            NodeCount++;
288          }
289          EXPECT_EQ(NodeCount, UNGraph->GetNodes());
290          EdgeCount = 0;
291          for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
292            EdgeCount++;
293          }
294          EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
295        }
296        else if (NNodes * (NNodes-1) >= NEdges) {
297          NGraph = TSnap::GenRndGnm<PNGraph>(NNodes, NEdges, true, TInt::Rnd);
298          EXPECT_FALSE(NGraph->Empty());
299          EXPECT_TRUE(NGraph->IsOk());
300          NodeCount = 0;
301          for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
302            NodeCount++;
303          }
304          EXPECT_EQ(NodeCount, NGraph->GetNodes());
305          EdgeCount = 0;
306          for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
307            EdgeCount++;
308          }
309          EXPECT_EQ(EdgeCount, NGraph->GetEdges());
310        }
311      } 
312    } 
313  }
<span onclick='openModal()' class='match'>314  TEST(GGenTest, GenRndBipart) {
315    const int LeftNodesMin = 8;
316    const int LeftNodesMax = 20;
317    const int RightNodesMin = 8;
318    const int RightNodesMax = 50;
319    const int EdgesMin = 5;
</span>320    const int EdgesMax = 30;
321    PBPGraph Graph;
322    TInt::Rnd.PutSeed(0);
323    for (int LeftNodes = LeftNodesMin; LeftNodes < LeftNodesMax; LeftNodes++) {
324      for (int RightNodes = RightNodesMin; RightNodes < RightNodesMax; RightNodes++) {
325        for (int Edges = EdgesMin;  Edges < EdgesMax; Edges++) {
326          if (Edges > LeftNodes * RightNodes) {
327            continue;
328          }
329          Graph = TSnap::GenRndBipart(LeftNodes, RightNodes, Edges, TInt::Rnd);
330          EXPECT_FALSE(Graph->Empty());
331          int NodeCount = 0;
332          int EdgeCount = 0;
333          for (TBPGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
334            NodeCount++;
335          }
336          EXPECT_EQ(NodeCount, Graph->GetNodes());
337          EdgeCount = 0;
338          for (TBPGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
339            EdgeCount++;
340          }
341          EXPECT_EQ(EdgeCount, Graph->GetEdges());
342        } 
343      } 
344    } 
345  }
346  TEST(GGenTest, GenRndPowerLaw) {
347    const int NNodesMin = 10;
348    const int NNodesMax = 1000;
349    const double PowerExpMin = 2.0;
350    const double PowerExpMax = 3.0;
351    int NodeCount = 0;
352    int EdgeCount = 0;
353    PUNGraph UNGraph;
354    TInt::Rnd.PutSeed(0);
355    for (int NNodes = NNodesMin; NNodes <= NNodesMax; NNodes += (NNodesMax - NNodesMin)/2) {
356      for (double PowerExp = PowerExpMin; PowerExp <= PowerExpMax; PowerExp += 1.0) {
357        UNGraph = TSnap::GenRndPowerLaw(NNodes, PowerExp);
358        EXPECT_FALSE(UNGraph->Empty());
359        EXPECT_TRUE(UNGraph->IsOk());
360        NodeCount = 0;
361        EdgeCount = 0;
362        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
363          NodeCount++;
364        }
365        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
366        EdgeCount = 0;
367        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
368          EdgeCount++;
369        }
370        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
371      } 
372    } 
373  }
374  TEST(GGenTest, DISABLED_GenDegSeq) {
375    const int NNodesMax = 15;
376    const int NumIterations = 10;  
377    PUNGraph UNGraph;
378    TIntV DegSeqV;
379    TInt::Rnd.PutSeed(0);
380    int NodeCount = 0;
381    int EdgeCount = 0;
382    for (int i = 0; i < NumIterations; i++) {
383      for (int NNodes = 4; NNodes < NNodesMax; NNodes+=NNodesMax/5) {
384        DegSeqV.Gen(NNodes);
385        int DegSum = 0;
386        for (int n = 0; n < DegSeqV.Len()/4; n++) {
387          DegSeqV[n] = TInt::Rnd.GetUniDevInt(1, NNodes/2);
388          DegSum += DegSeqV[n];
389        }
390        for (int n = DegSeqV.Len()/4; n < DegSeqV.Len(); n++) {
391          DegSeqV[n] = 1;
392          DegSum += DegSeqV[n];
393        }
394        if (DegSum % 2 != 0) {
395          DegSeqV[(int)TInt::Rnd.GetUniDevInt(NNodes)]++;
396        }
397        DegSeqV.Sort();
398        DegSeqV.Reverse();
399        printf("NNodes=%d, ", NNodes);
400        printf("DegSeqV = { ");
401        for (int i = 0; i < DegSeqV.Len(); i++) {
402          printf("%d ", (int)DegSeqV[i]);
403        }
404        printf("}\n");
405        UNGraph = TSnap::GenDegSeq(DegSeqV);
406        EXPECT_FALSE(UNGraph->Empty());
407        EXPECT_TRUE(UNGraph->IsOk());
408        NodeCount = 0;
409        EdgeCount = 0;
410        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
411          NodeCount++;
412        }
413        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
414        EdgeCount = 0;
415        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
416          EdgeCount++;
417        }
418        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
419      }
420    }
421  }
422  TEST(GGenTest, GenPrefAttach) {
423    const int NNodesMax = 100;
424    const int NodeOutDegMax = 15;
425    PUNGraph UNGraph;
426    for (int NNodes = 0; NNodes < NNodesMax; NNodes++) {
427      for (int NodeOutDeg = 0; NodeOutDeg < NodeOutDegMax; NodeOutDeg++) {
428        int NodeCount = 0;
429        int EdgeCount = 0;
430        UNGraph = TSnap::GenPrefAttach(NNodes, NodeOutDeg);
431        EXPECT_FALSE(UNGraph->Empty());
432        EXPECT_TRUE(UNGraph->IsOk());
433        NodeCount = 0;
434        EdgeCount = 0;
435        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
436          NodeCount++;
437        }
438        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
439        EdgeCount = 0;
440        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
441          EdgeCount++;
442        }
443        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
444      } 
445    } 
446  }
447  TEST(GGenTest, GenGeoPrefAttach) {
448    const int NNodesMax = 100;
449    const int NodeOutDegMax = 15;
450    const double BetaMax = 2.0;
451    PUNGraph UNGraph;
452    PNGraph NGraph;
453    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
454      for (int NodeOutDeg = 0; NodeOutDeg < NodeOutDegMax; NodeOutDeg++) {
455        for (double Beta = -1*BetaMax; Beta < BetaMax; Beta += 0.2) {
456          int NodeCount = 0;
457          int EdgeCount = 0;
458          UNGraph = TSnap::GenGeoPrefAttach(NNodes, NodeOutDeg, Beta);
459          EXPECT_FALSE(UNGraph->Empty());
460          EXPECT_TRUE(UNGraph->IsOk());
461          NodeCount = 0;
462          EdgeCount = 0;
463          for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
464            NodeCount++;
465          }
466          EXPECT_EQ(NodeCount, UNGraph->GetNodes());
467          EdgeCount = 0;
468          for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
469            EdgeCount++;
470          }
471          EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
472        } 
473      } 
474    } 
475  }
476  TEST(GGenTest, GenSmallWorld) {
477    const int NNodesMax = 1000;
478    const double RewireProbMax = 1.0;
479    PUNGraph UNGraph;
480    for (int NNodes = 1; NNodes < NNodesMax; NNodes+=NNodesMax/20) {
481      for (int NodeOutDeg = 1; NodeOutDeg < 10; NodeOutDeg++) {
482        for (double RewireProb = 0.0; RewireProb <= RewireProbMax; RewireProb += 0.2) {
483          int NodeCount = 0;
484          int EdgeCount = 0;
485          if (NNodes <= NodeOutDeg) {
486            continue;
487          }
488          UNGraph = TSnap::GenSmallWorld(NNodes, NodeOutDeg, RewireProb);
489          EXPECT_FALSE(UNGraph->Empty());
490          EXPECT_TRUE(UNGraph->IsOk());
491          NodeCount = 0;
492          EdgeCount = 0;
493          for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
494            NodeCount++;
495          }
496          EXPECT_EQ(NodeCount, UNGraph->GetNodes());
497          EdgeCount = 0;
498          for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
499            EdgeCount++;
500          }
501          EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
502        } 
503      } 
504    } 
505  }
506  TEST(GGenTest, GenForestFire) {
507    const int NNodesMax = 1000;
508    const double FwdProbMax = 1.0;
509    const double BckProbMax = 1.0;
510    for (int NNodes = 0; NNodes < NNodesMax; NNodes += NNodesMax/2) {
511      for (double FwdProb = 0.1; FwdProb < FwdProbMax; FwdProb += 0.5) {
512        for (double BckProb = 0.1; BckProb < BckProbMax; BckProb += 0.5) {
513          int NodeCount = 0;
514          int EdgeCount = 0;
515          PNGraph Graph = TSnap::GenForestFire(NNodes, FwdProb, BckProb);
516          if (0 != NNodes) {
517            EXPECT_FALSE(Graph->Empty());
518          }
519          EXPECT_TRUE(Graph->IsOk());
520          NodeCount = 0;
521          EdgeCount = 0;
522          for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
523            NodeCount++;
524          }
525          EXPECT_EQ(NodeCount, Graph->GetNodes());
526          EdgeCount = 0;
527          for (TNGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
528            EdgeCount++;
529          }
530          EXPECT_EQ(EdgeCount, Graph->GetEdges());
531        } 
532      } 
533    } 
534  }
535  TEST(GGenTest, GenCopyModel) {
536    const int NNodesMax = 100;
537    const double BetaMax = 2.0;
538    PNGraph Graph;
539    for (int NNodes = 0; NNodes < NNodesMax; NNodes++) {
540      for (double Beta = -1*BetaMax; Beta < BetaMax; Beta += 0.2) {
541        int NodeCount = 0;
542        int EdgeCount = 0;
543        Graph = TSnap::GenCopyModel(NNodes, Beta);
544        EXPECT_FALSE(Graph->Empty());
545        EXPECT_TRUE(Graph->IsOk());
546        NodeCount = 0;
547        EdgeCount = 0;
548        for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
549          NodeCount++;
550        }
551        EXPECT_EQ(NodeCount, Graph->GetNodes());
552        EdgeCount = 0;
553        for (TNGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
554          EdgeCount++;
555        }
556        EXPECT_EQ(EdgeCount, Graph->GetEdges());
557      } 
558    } 
559  }
560  TEST(GGenTest, GenRMat) {
561    const int NNodesMax = 10000;
562    const int NEdgesMax = 100;
563    int NodeCount = 0;
564    int EdgeCount = 0;
565    PNGraph Graph;
566    TInt::Rnd.PutSeed(0);
567    TFlt A, B, C;
568    TFltTrV Vals;
569    Vals.Add(TFltTr(0.15, 0.2, 0.35));
570    Vals.Add(TFltTr(0.2, 0.2, 0.55));
571    Vals.Add(TFltTr(0.4, 0.15, 0.2));
572    for (int NNodes = 50; NNodes < NNodesMax; NNodes+=NNodesMax/2) {
573      for (int NEdges = 5; NEdges < NEdgesMax; NEdges+=NEdgesMax/4) {
574        for (int i = 0; i < Vals.Len(); i++) {
575          A = Vals[i].Val1;
576          B = Vals[i].Val2;
577          C = Vals[i].Val3;
578          Graph = TSnap::GenRMat(NNodes, NEdges, A, B, C);
579          EXPECT_FALSE(Graph->Empty());
580          EXPECT_TRUE(Graph->IsOk());
581          NodeCount = 0;
582          EdgeCount = 0;
583          for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
584            NodeCount++;
585          }
586          EXPECT_EQ(NodeCount, Graph->GetNodes());
587          EdgeCount = 0;
588          for (TNGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
589            EdgeCount++;
590          }
591          EXPECT_EQ(EdgeCount, Graph->GetEdges());
592        }
593      } 
594    } 
595  }
596  template <class PGraph> void TestRewire(const PGraph& Graph) {
597    PGraph GraphOut;
598    TIntPrV DegToCntV;
599    TIntPrV DegToCntV1;
600    int CntLoops;
601    GraphOut = TSnap::GenRewire(Graph, 10, TInt::Rnd);
602    TSnap::GetDegCnt(Graph, DegToCntV);
603    TSnap::GetDegCnt(GraphOut, DegToCntV1);
604    EXPECT_EQ(DegToCntV.Len(), DegToCntV1.Len());
605    for (int i = 0; i < DegToCntV.Len(); i++) {
606      EXPECT_EQ(DegToCntV[i].Val1.Val, DegToCntV1[i].Val1.Val);
607    }
608    TSnap::GetInDegCnt(Graph, DegToCntV);
609    TSnap::GetInDegCnt(GraphOut, DegToCntV1);
610    EXPECT_EQ(DegToCntV.Len(), DegToCntV1.Len());
611    for (int i = 0; i < DegToCntV.Len(); i++) {
612      EXPECT_EQ(DegToCntV[i].Val1.Val, DegToCntV1[i].Val1.Val);
613    }
614    TSnap::GetOutDegCnt(Graph, DegToCntV);
615    TSnap::GetOutDegCnt(GraphOut, DegToCntV1);
616    EXPECT_EQ(DegToCntV.Len(), DegToCntV1.Len());
617    for (int i = 0; i < DegToCntV.Len(); i++) {
618      EXPECT_EQ(DegToCntV[i].Val1.Val, DegToCntV1[i].Val1.Val);
619    }
620    CntLoops = TSnap::CntSelfEdges<PGraph>(GraphOut);
621    EXPECT_EQ(CntLoops, 0);
622  }
623  TEST(GGenRewire, GenRewire) {
624    PNGraph GraphFF;
625    PNGraph Graph;
626    PUNGraph UGraph;
627    const int NNodes = 100000;
628    const double FwdProb = 0.35;
629    const double BckProb = 0.32;
630    GraphFF = TSnap::GenForestFire(NNodes, FwdProb, BckProb);
631    TestRewire<PNGraph>(GraphFF);
632    UGraph = TSnap::ConvertGraph<PUNGraph, PNGraph>(GraphFF);
633    TestRewire<PUNGraph>(UGraph);
634  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_creator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_CREATOR_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_CREATOR_HPP
3  #ifdef BOOST_REGEX_MSVC
4  #  pragma warning(push)
5  #pragma warning(disable:4459)
6  #if BOOST_REGEX_MSVC < 1910
7  #pragma warning(disable:4800)
8  #endif
9  #endif
10  #include <set>
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template <class charT>
14  struct digraph : public std::pair<charT, charT>
15  {
16     digraph() : std::pair<charT, charT>(charT(0), charT(0)){}
17     digraph(charT c1) : std::pair<charT, charT>(c1, charT(0)){}
18     digraph(charT c1, charT c2) : std::pair<charT, charT>(c1, c2)
19     {}
20     digraph(const digraph<charT>& d) : std::pair<charT, charT>(d.first, d.second){}
21     digraph<charT>& operator=(const digraph<charT>&) = default;
22     template <class Seq>
23     digraph(const Seq& s) : std::pair<charT, charT>()
24     {
25        BOOST_REGEX_ASSERT(s.size() <= 2);
26        BOOST_REGEX_ASSERT(s.size());
27        this->first = s[0];
28        this->second = (s.size() > 1) ? s[1] : 0;
29     }
30  };
31  template <class charT, class traits>
32  class basic_char_set
33  {
34  public:
35     typedef digraph<charT>                   digraph_type;
36     typedef typename traits::string_type     string_type;
37     typedef typename traits::char_class_type m_type;
38     basic_char_set()
39     {
40        m_negate = false;
41        m_has_digraphs = false;
42        m_classes = 0;
43        m_negated_classes = 0;
44        m_empty = true;
45     }
46     void add_single(const digraph_type& s)
47     {
48        m_singles.insert(s);
49        if(s.second)
50           m_has_digraphs = true;
51        m_empty = false;
52     }
53     void add_range(const digraph_type& first, const digraph_type& end)
54     {
55        m_ranges.push_back(first);
56        m_ranges.push_back(end);
57        if(first.second)
58        {
59           m_has_digraphs = true;
60           add_single(first);
61        }
62        if(end.second)
63        {
64           m_has_digraphs = true;
65           add_single(end);
66        }
67        m_empty = false;
68     }
69     void add_class(m_type m)
70     {
71        m_classes |= m;
72        m_empty = false;
73     }
74     void add_negated_class(m_type m)
75     {
76        m_negated_classes |= m;
77        m_empty = false;
78     }
79     void add_equivalent(const digraph_type& s)
80     {
81        m_equivalents.insert(s);
82        if(s.second)
83        {
84           m_has_digraphs = true;
85           add_single(s);
86        }
87        m_empty = false;
88     }
89     void negate()
90     { 
91        m_negate = true;
92     }
93     bool has_digraphs()const
94     {
95        return m_has_digraphs;
96     }
97     bool is_negated()const
98     {
99        return m_negate;
100     }
101     typedef typename std::vector<digraph_type>::const_iterator  list_iterator;
102     typedef typename std::set<digraph_type>::const_iterator     set_iterator;
103     set_iterator singles_begin()const
104     {
105        return m_singles.begin();
106     }
107     set_iterator singles_end()const
108     {
109        return m_singles.end();
110     }
111     list_iterator ranges_begin()const
112     {
113        return m_ranges.begin();
114     }
115     list_iterator ranges_end()const
116     {
117        return m_ranges.end();
118     }
119     set_iterator equivalents_begin()const
120     {
121        return m_equivalents.begin();
122     }
123     set_iterator equivalents_end()const
124     {
125        return m_equivalents.end();
126     }
127     m_type classes()const
128     {
129        return m_classes;
130     }
131     m_type negated_classes()const
132     {
133        return m_negated_classes;
134     }
135     bool empty()const
136     {
137        return m_empty;
138     }
139  private:
140     std::set<digraph_type>    m_singles;         
141     std::vector<digraph_type> m_ranges;          
142     bool                      m_negate;          
143     bool                      m_has_digraphs;    
144     m_type                    m_classes;         
145     m_type                    m_negated_classes; 
146     bool                      m_empty;           
147     std::set<digraph_type>    m_equivalents;     
148  };
149  template <class charT, class traits>
150  class basic_regex_creator
151  {
152  public:
153     basic_regex_creator(regex_data<charT, traits>* data);
154     std::ptrdiff_t getoffset(void* addr)
155     {
156        return getoffset(addr, m_pdata->m_data.data());
157     }
158     std::ptrdiff_t getoffset(const void* addr, const void* base)
159     {
160        return static_cast<const char*>(addr) - static_cast<const char*>(base);
161     }
162     re_syntax_base* getaddress(std::ptrdiff_t off)
163     {
164        return getaddress(off, m_pdata->m_data.data());
165     }
166     re_syntax_base* getaddress(std::ptrdiff_t off, void* base)
167     {
168        return static_cast<re_syntax_base*>(static_cast<void*>(static_cast<char*>(base) + off));
169     }
170     void init(unsigned l_flags)
171     {
172        m_pdata->m_flags = l_flags;
173        m_icase = l_flags & regex_constants::icase;
174     }
175     regbase::flag_type flags()
176     {
177        return m_pdata->m_flags;
178     }
179     void flags(regbase::flag_type f)
180     {
181        m_pdata->m_flags = f;
182        if(m_icase != static_cast<bool>(f & regbase::icase))
183        {
184           m_icase = static_cast<bool>(f & regbase::icase);
185        }
186     }
187     re_syntax_base* append_state(syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
188     re_syntax_base* insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
189     re_literal* append_literal(charT c);
190     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set);
191     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, false>*);
192     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, true>*);
193     void finalize(const charT* p1, const charT* p2);
194  protected:
195     regex_data<charT, traits>*    m_pdata;              
196     const ::boost::regex_traits_wrapper<traits>&  
197                                   m_traits;             
198     re_syntax_base*               m_last_state;         
199     bool                          m_icase;              
200     unsigned                      m_repeater_id;        
201     bool                          m_has_backrefs;       
202     std::uintmax_t                m_bad_repeats;        
203     bool                          m_has_recursions;     
204     std::vector<unsigned char>    m_recursion_checks;   
205     typename traits::char_class_type m_word_mask;       
206     typename traits::char_class_type m_mask_space;      
207     typename traits::char_class_type m_lower_mask;       
208     typename traits::char_class_type m_upper_mask;      
209     typename traits::char_class_type m_alpha_mask;      
210  private:
211     basic_regex_creator& operator=(const basic_regex_creator&);
212     basic_regex_creator(const basic_regex_creator&);
213     void fixup_pointers(re_syntax_base* state);
214     void fixup_recursions(re_syntax_base* state);
215     void create_startmaps(re_syntax_base* state);
216     int calculate_backstep(re_syntax_base* state);
217     void create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask);
218     unsigned get_restart_type(re_syntax_base* state);
219     void set_all_masks(unsigned char* bits, unsigned char);
220     bool is_bad_repeat(re_syntax_base* pt);
221     void set_bad_repeat(re_syntax_base* pt);
222     syntax_element_type get_repeat_type(re_syntax_base* state);
223     void probe_leading_repeat(re_syntax_base* state);
224  };
225  template <class charT, class traits>
226  basic_regex_creator<charT, traits>::basic_regex_creator(regex_data<charT, traits>* data)
227     : m_pdata(data), m_traits(*(data->m_ptraits)), m_last_state(0), m_icase(false), m_repeater_id(0), 
228     m_has_backrefs(false), m_bad_repeats(0), m_has_recursions(false), m_word_mask(0), m_mask_space(0), m_lower_mask(0), m_upper_mask(0), m_alpha_mask(0)
229  {
230     m_pdata->m_data.clear();
231     m_pdata->m_status = ::boost::regex_constants::error_ok;
232     static const charT w = 'w';
233     static const charT s = 's';
234     static const charT l[5] = { 'l', 'o', 'w', 'e', 'r', };
235     static const charT u[5] = { 'u', 'p', 'p', 'e', 'r', };
236     static const charT a[5] = { 'a', 'l', 'p', 'h', 'a', };
237     m_word_mask = m_traits.lookup_classname(&w, &w +1);
238     m_mask_space = m_traits.lookup_classname(&s, &s +1);
239     m_lower_mask = m_traits.lookup_classname(l, l + 5);
240     m_upper_mask = m_traits.lookup_classname(u, u + 5);
241     m_alpha_mask = m_traits.lookup_classname(a, a + 5);
242     m_pdata->m_word_mask = m_word_mask;
243     BOOST_REGEX_ASSERT(m_word_mask != 0); 
244     BOOST_REGEX_ASSERT(m_mask_space != 0); 
245     BOOST_REGEX_ASSERT(m_lower_mask != 0); 
246     BOOST_REGEX_ASSERT(m_upper_mask != 0); 
247     BOOST_REGEX_ASSERT(m_alpha_mask != 0); 
248  }
249  template <class charT, class traits>
250  re_syntax_base* basic_regex_creator<charT, traits>::append_state(syntax_element_type t, std::size_t s)
251  {
252     if(t == syntax_element_backref)
253        this->m_has_backrefs = true;
254     m_pdata->m_data.align();
255     if(m_last_state)
256        m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);
257     m_last_state = static_cast<re_syntax_base*>(m_pdata->m_data.extend(s));
258     m_last_state->next.i = 0;
259     m_last_state->type = t;
260     return m_last_state;
261  }
262  template <class charT, class traits>
263  re_syntax_base* basic_regex_creator<charT, traits>::insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)
264  {
265     m_pdata->m_data.align();
266     if(m_last_state)
267        m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);
268     std::ptrdiff_t off = getoffset(m_last_state) + s;
269     re_syntax_base* new_state = static_cast<re_syntax_base*>(m_pdata->m_data.insert(pos, s));
270     new_state->next.i = s;
271     new_state->type = t;
272     m_last_state = getaddress(off);
273     return new_state;
274  }
275  template <class charT, class traits>
276  re_literal* basic_regex_creator<charT, traits>::append_literal(charT c)
277  {
278     re_literal* result;
279     if((0 == m_last_state) || (m_last_state->type != syntax_element_literal))
280     {
281        result = static_cast<re_literal*>(append_state(syntax_element_literal, sizeof(re_literal) + sizeof(charT)));
282        result->length = 1;
283        *static_cast<charT*>(static_cast<void*>(result+1)) = m_traits.translate(c, m_icase);
284     }
285     else
286     {
287        std::ptrdiff_t off = getoffset(m_last_state);
288        m_pdata->m_data.extend(sizeof(charT));
289        m_last_state = result = static_cast<re_literal*>(getaddress(off));
290        charT* characters = static_cast<charT*>(static_cast<void*>(result+1));
291        characters[result->length] = m_traits.translate(c, m_icase);
292        result->length += 1;
293     }
294     return result;
295  }
296  template <class charT, class traits>
297  inline re_syntax_base* basic_regex_creator<charT, traits>::append_set(
298     const basic_char_set<charT, traits>& char_set)
299  {
300     typedef std::integral_constant<bool, (sizeof(charT) == 1) > truth_type;
301     return char_set.has_digraphs() 
302        ? append_set(char_set, static_cast<std::integral_constant<bool, false>*>(0))
303        : append_set(char_set, static_cast<truth_type*>(0));
304  }
305  template <class charT, class traits>
306  re_syntax_base* basic_regex_creator<charT, traits>::append_set(
307     const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, false>*)
308  {
309     typedef typename traits::string_type string_type;
310     typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
311     typedef typename basic_char_set<charT, traits>::set_iterator  set_iterator;
312     typedef typename traits::char_class_type m_type;
313     re_set_long<m_type>* result = static_cast<re_set_long<m_type>*>(append_state(syntax_element_long_set, sizeof(re_set_long<m_type>)));
314     result->csingles = static_cast<unsigned int>(std::distance(char_set.singles_begin(), char_set.singles_end()));
315     result->cranges = static_cast<unsigned int>(std::distance(char_set.ranges_begin(), char_set.ranges_end())) / 2;
316     result->cequivalents = static_cast<unsigned int>(std::distance(char_set.equivalents_begin(), char_set.equivalents_end()));
317     result->cclasses = char_set.classes();
318     result->cnclasses = char_set.negated_classes();
319     if(flags() & regbase::icase)
320     {
321        if(((result->cclasses & m_lower_mask) == m_lower_mask) || ((result->cclasses & m_upper_mask) == m_upper_mask))
322           result->cclasses |= m_alpha_mask;
323        if(((result->cnclasses & m_lower_mask) == m_lower_mask) || ((result->cnclasses & m_upper_mask) == m_upper_mask))
324           result->cnclasses |= m_alpha_mask;
325     }
326     result->isnot = char_set.is_negated();
327     result->singleton = !char_set.has_digraphs();
328     std::ptrdiff_t offset = getoffset(result);
329     item_iterator first, last;
330     set_iterator sfirst, slast;
331     sfirst = char_set.singles_begin();
332     slast = char_set.singles_end();
333     while(sfirst != slast)
334     {
335        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (sfirst->first == static_cast<charT>(0) ? 1 : sfirst->second ? 3 : 2)));
336        p[0] = m_traits.translate(sfirst->first, m_icase);
337        if(sfirst->first == static_cast<charT>(0))
338        {
339           p[0] = 0;
340        }
341        else if(sfirst->second)
342        {
343           p[1] = m_traits.translate(sfirst->second, m_icase);
344           p[2] = 0;
345        }
346        else
347           p[1] = 0;
348        ++sfirst;
349     }
350     first = char_set.ranges_begin();
351     last = char_set.ranges_end();
352     while(first != last)
353     {
354        digraph<charT> c1 = *first;
355        c1.first = this->m_traits.translate(c1.first, this->m_icase);
356        c1.second = this->m_traits.translate(c1.second, this->m_icase);
357        ++first;
358        digraph<charT> c2 = *first;
359        c2.first = this->m_traits.translate(c2.first, this->m_icase);
360        c2.second = this->m_traits.translate(c2.second, this->m_icase);
361        ++first;
362        string_type s1, s2;
363        if(flags() & regex_constants::collate)
364        {
365           charT a1[3] = { c1.first, c1.second, charT(0), };
366           charT a2[3] = { c2.first, c2.second, charT(0), };
367           s1 = this->m_traits.transform(a1, (a1[1] ? a1+2 : a1+1));
368           s2 = this->m_traits.transform(a2, (a2[1] ? a2+2 : a2+1));
369           if(s1.empty())
370              s1 = string_type(1, charT(0));
371           if(s2.empty())
372              s2 = string_type(1, charT(0));
373        }
374        else
375        {
376           if(c1.second)
377           {
378              s1.insert(s1.end(), c1.first);
379              s1.insert(s1.end(), c1.second);
380           }
381           else
382              s1 = string_type(1, c1.first);
383           if(c2.second)
384           {
385              s2.insert(s2.end(), c2.first);
386              s2.insert(s2.end(), c2.second);
387           }
388           else
389              s2.insert(s2.end(), c2.first);
390        }
391        if(s1 > s2)
392        {
393           return 0;
394        }
395        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s1.size() + s2.size() + 2) ) );
396        BOOST_REGEX_DETAIL_NS::copy(s1.begin(), s1.end(), p);
397        p[s1.size()] = charT(0);
398        p += s1.size() + 1;
399        BOOST_REGEX_DETAIL_NS::copy(s2.begin(), s2.end(), p);
400        p[s2.size()] = charT(0);
401     }
402     sfirst = char_set.equivalents_begin();
403     slast = char_set.equivalents_end();
404     while(sfirst != slast)
405     {
406        string_type s;
407        if(sfirst->second)
408        {
409           charT cs[3] = { sfirst->first, sfirst->second, charT(0), };
410           s = m_traits.transform_primary(cs, cs+2);
411        }
412        else
413           s = m_traits.transform_primary(&sfirst->first, &sfirst->first+1);
414        if(s.empty())
415           return 0;  
416        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s.size()+1) ) );
417        BOOST_REGEX_DETAIL_NS::copy(s.begin(), s.end(), p);
418        p[s.size()] = charT(0);
419        ++sfirst;
420     }
421     m_last_state = result = static_cast<re_set_long<m_type>*>(getaddress(offset));
422     return result;
423  }
424  template<class T>
425  inline bool char_less(T t1, T t2)
426  {
427     return t1 < t2;
428  }
429  inline bool char_less(char t1, char t2)
430  {
431     return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
432  }
433  inline bool char_less(signed char t1, signed char t2)
434  {
435     return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
436  }
437  template <class charT, class traits>
438  re_syntax_base* basic_regex_creator<charT, traits>::append_set(
439     const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, true>*)
440  {
441     typedef typename traits::string_type string_type;
442     typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
443     typedef typename basic_char_set<charT, traits>::set_iterator set_iterator;
444     re_set* result = static_cast<re_set*>(append_state(syntax_element_set, sizeof(re_set)));
445     bool negate = char_set.is_negated();
446     std::memset(result->_map, 0, sizeof(result->_map));
447     item_iterator first, last;
448     set_iterator sfirst, slast;
449     sfirst = char_set.singles_begin();
450     slast = char_set.singles_end();
451     while(sfirst != slast)
452     {
453        for(unsigned int i = 0; i < (1 << CHAR_BIT); ++i)
454        {
455           if(this->m_traits.translate(static_cast<charT>(i), this->m_icase)
456              == this->m_traits.translate(sfirst->first, this->m_icase))
457              result->_map[i] = true;
458        }
459        ++sfirst;
460     }
461     first = char_set.ranges_begin();
462     last = char_set.ranges_end();
463     while(first != last)
464     {
465        charT c1 = this->m_traits.translate(first->first, this->m_icase);
466        ++first;
467        charT c2 = this->m_traits.translate(first->first, this->m_icase);
468        ++first;
469        if(flags() & regex_constants::collate)
470        {
471           charT c3[2] = { c1, charT(0), };
472           string_type s1 = this->m_traits.transform(c3, c3+1);
473           c3[0] = c2;
474           string_type s2 = this->m_traits.transform(c3, c3+1);
475           if(s1 > s2)
476           {
477              return 0;
478           }
479           BOOST_REGEX_ASSERT(c3[1] == charT(0));
480           for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
481           {
482              c3[0] = static_cast<charT>(i);
483              string_type s3 = this->m_traits.transform(c3, c3 +1);
484              if((s1 <= s3) && (s3 <= s2))
485                 result->_map[i] = true;
486           }
487        }
488        else
489        {
490           if(char_less(c2, c1))
491           {
492              return 0;
493           }
494           std::memset(result->_map + static_cast<unsigned char>(c1), true, static_cast<unsigned char>(1u) + static_cast<unsigned char>(static_cast<unsigned char>(c2) - static_cast<unsigned char>(c1)));
495        }
496     }
497     typedef typename traits::char_class_type m_type;
498     m_type m = char_set.classes();
499     if(flags() & regbase::icase)
500     {
501        if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
502           m |= m_alpha_mask;
503     }
504     if(m != 0)
505     {
506        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
507        {
508           if(this->m_traits.isctype(static_cast<charT>(i), m))
509              result->_map[i] = true;
510        }
511     }
512     m = char_set.negated_classes();
513     if(flags() & regbase::icase)
514     {
515        if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
516           m |= m_alpha_mask;
517     }
518     if(m != 0)
519     {
520        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
521        {
522           if(0 == this->m_traits.isctype(static_cast<charT>(i), m))
523              result->_map[i] = true;
524        }
525     }
526     sfirst = char_set.equivalents_begin();
527     slast = char_set.equivalents_end();
528     while(sfirst != slast)
529     {
530        string_type s;
531        BOOST_REGEX_ASSERT(static_cast<charT>(0) == sfirst->second);
532        s = m_traits.transform_primary(&sfirst->first, &sfirst->first+1);
533        if(s.empty())
534           return 0;  
535        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
536        {
537           charT c[2] = { (static_cast<charT>(i)), charT(0), };
538           string_type s2 = this->m_traits.transform_primary(c, c+1);
539           if(s == s2)
540              result->_map[i] = true;
541        }
542        ++sfirst;
543     }
544     if(negate)
545     {
546        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
547        {
548           result->_map[i] = !(result->_map[i]);
549        }
550     }
551     return result;
552  }
553  template <class charT, class traits>
554  void basic_regex_creator<charT, traits>::finalize(const charT* p1, const charT* p2)
555  {
556     if(this->m_pdata->m_status)
557        return;
558     append_state(syntax_element_match);
559     std::ptrdiff_t len = p2 - p1;
560     m_pdata->m_expression_len = len;
561     charT* ps = static_cast<charT*>(m_pdata->m_data.extend(sizeof(charT) * (1 + (p2 - p1))));
562     m_pdata->m_expression = ps;
563     BOOST_REGEX_DETAIL_NS::copy(p1, p2, ps);
564     ps[p2 - p1] = 0;
565     m_pdata->m_status = 0;
566     m_pdata->m_first_state = static_cast<re_syntax_base*>(m_pdata->m_data.data());
567     fixup_pointers(m_pdata->m_first_state);
568     if(m_has_recursions)
569     {
570        m_pdata->m_has_recursions = true;
571        fixup_recursions(m_pdata->m_first_state);
572        if(this->m_pdata->m_status)
573           return;
574     }
575     else
576        m_pdata->m_has_recursions = false;
577     create_startmaps(m_pdata->m_first_state);
578     std::memset(m_pdata->m_startmap, 0, sizeof(m_pdata->m_startmap));
579     m_pdata->m_can_be_null = 0;
580     m_bad_repeats = 0;
581     if(m_has_recursions)
582        m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
583     create_startmap(m_pdata->m_first_state, m_pdata->m_startmap, &(m_pdata->m_can_be_null), mask_all);
584     m_pdata->m_restart_type = get_restart_type(m_pdata->m_first_state);
585     probe_leading_repeat(m_pdata->m_first_state);
586  }
587  template <class charT, class traits>
588  void basic_regex_creator<charT, traits>::fixup_pointers(re_syntax_base* state)
589  {
590     while(state)
591     {
592        switch(state->type)
593        {
594        case syntax_element_recurse:
595           m_has_recursions = true;
596           if(state->next.i)
597              state->next.p = getaddress(state->next.i, state);
598           else
599              state->next.p = 0;
600           break;
601        case syntax_element_rep:
602        case syntax_element_dot_rep:
603        case syntax_element_char_rep:
604        case syntax_element_short_set_rep:
605        case syntax_element_long_set_rep:
606           static_cast<re_repeat*>(state)->state_id = m_repeater_id++;
607           BOOST_REGEX_FALLTHROUGH;
608        case syntax_element_alt:
609           std::memset(static_cast<re_alt*>(state)->_map, 0, sizeof(static_cast<re_alt*>(state)->_map));
610           static_cast<re_alt*>(state)->can_be_null = 0;
611           BOOST_REGEX_FALLTHROUGH;
612        case syntax_element_jump:
613           static_cast<re_jump*>(state)->alt.p = getaddress(static_cast<re_jump*>(state)->alt.i, state);
614           BOOST_REGEX_FALLTHROUGH;
615        default:
616           if(state->next.i)
617              state->next.p = getaddress(state->next.i, state);
618           else
619              state->next.p = 0;
620        }
621        state = state->next.p;
622     }
623  }
624  template <class charT, class traits>
625  void basic_regex_creator<charT, traits>::fixup_recursions(re_syntax_base* state)
626  {
627     re_syntax_base* base = state;
628     while(state)
629     {
630        switch(state->type)
631        {
632        case syntax_element_assert_backref:
633           {
634              int idx = static_cast<const re_brace*>(state)->index;
635              if(idx < 0)
636              {
637                 idx = -idx-1;
638                 if(idx >= hash_value_mask)
639                 {
640                    idx = m_pdata->get_id(idx);
641                    if(idx <= 0)
642                    {
643                       if(0 == this->m_pdata->m_status) 
644                          this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
645                       this->m_pdata->m_expression = 0;
646                       this->m_pdata->m_expression_len = 0;
647                       if(0 == (this->flags() & regex_constants::no_except))
648                       {
649                          std::string message = "Encountered a forward reference to a marked sub-expression that does not exist.";
650                          boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
651                          e.raise();
652                       }
653                    }
654                 }
655              }
656           }
657           break;
658        case syntax_element_recurse:
659           {
660              bool ok = false;
661              re_syntax_base* p = base;
662              std::ptrdiff_t idx = static_cast<re_jump*>(state)->alt.i;
663              if(idx >= hash_value_mask)
664              {
665                 idx = m_pdata->get_id(static_cast<int>(idx));
666              }
667              if(idx < 0)
668              {
669                 ok = false;
670              }
671              else
672              {
673                 while(p)
674                 {
675                    if((p->type == syntax_element_startmark) && (static_cast<re_brace*>(p)->index == idx))
676                    {
677                       static_cast<re_jump*>(state)->alt.p = p;
678                       ok = true;
679                       p = p->next.p;
680                       int next_rep_id = 0;
681                       while(p)
682                       {
683                          switch(p->type)
684                          {
685                          case syntax_element_rep:
686                          case syntax_element_dot_rep:
687                          case syntax_element_char_rep:
688                          case syntax_element_short_set_rep:
689                          case syntax_element_long_set_rep:
690                             next_rep_id = static_cast<re_repeat*>(p)->state_id;
691                             break;
692                          case syntax_element_endmark:
693                             if(static_cast<const re_brace*>(p)->index == idx)
694                                next_rep_id = -1;
695                             break;
696                          default:
697                             break;
698                          }
699                          if(next_rep_id)
700                             break;
701                          p = p->next.p;
702                       }
703                       if(next_rep_id > 0)
704                       {
705                          static_cast<re_recurse*>(state)->state_id = next_rep_id - 1;
706                       }
707                       break;
708                    }
709                    p = p->next.p;
710                 }
711              }
712              if(!ok)
713              {
714                 if(0 == this->m_pdata->m_status) 
715                    this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
716                 this->m_pdata->m_expression = 0;
717                 this->m_pdata->m_expression_len = 0;
718                 if(0 == (this->flags() & regex_constants::no_except))
719                 {
720                    std::string message = "Encountered a forward reference to a recursive sub-expression that does not exist.";
721                    boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
722                    e.raise();
723                 }
724              }
725           }
726           break;
727        default:
728           break;
729        }
730        state = state->next.p;
731     }
732  }
733  template <class charT, class traits>
734  void basic_regex_creator<charT, traits>::create_startmaps(re_syntax_base* state)
735  {
736     bool l_icase = m_icase;
737     std::vector<std::pair<bool, re_syntax_base*> > v;
738     while(state)
739     {
740        switch(state->type)
741        {
742        case syntax_element_toggle_case:
743           m_icase = static_cast<re_case*>(state)->icase;
744           state = state->next.p;
745           continue;
746        case syntax_element_alt:
747        case syntax_element_rep:
748        case syntax_element_dot_rep:
749        case syntax_element_char_rep:
750        case syntax_element_short_set_rep:
751        case syntax_element_long_set_rep:
752           v.push_back(std::pair<bool, re_syntax_base*>(m_icase, state));
753           state = state->next.p;
754           break;
755        case syntax_element_backstep:
756           static_cast<re_brace*>(state)->index
757              = this->calculate_backstep(state->next.p);
758           if(static_cast<re_brace*>(state)->index < 0)
759           {
760              if(0 == this->m_pdata->m_status) 
761                 this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
762              this->m_pdata->m_expression = 0;
763              this->m_pdata->m_expression_len = 0;
764              if(0 == (this->flags() & regex_constants::no_except))
765              {
766                 std::string message = "Invalid lookbehind assertion encountered in the regular expression.";
767                 boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
768                 e.raise();
769              }
770           }
771           BOOST_REGEX_FALLTHROUGH;
772        default:
773           state = state->next.p;
774        }
775     }
776     while(!v.empty())
777     {
778        if(m_has_recursions)
779           m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
780        const std::pair<bool, re_syntax_base*>& p = v.back();
781        m_icase = p.first;
782        state = p.second;
783        v.pop_back();
784        m_bad_repeats = 0;
785        create_startmap(state->next.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_take);
786        m_bad_repeats = 0;
787        if(m_has_recursions)
788           m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
789        create_startmap(static_cast<re_alt*>(state)->alt.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_skip);
790        state->type = this->get_repeat_type(state);
791     }
792     m_icase = l_icase;
793  }
794  template <class charT, class traits>
795  int basic_regex_creator<charT, traits>::calculate_backstep(re_syntax_base* state)
796  {
797     typedef typename traits::char_class_type m_type;
798     int result = 0;
799     while(state)
800     {
801        switch(state->type)
802        {
803        case syntax_element_startmark:
804           if((static_cast<re_brace*>(state)->index == -1)
805              || (static_cast<re_brace*>(state)->index == -2))
806           {
807              state = static_cast<re_jump*>(state->next.p)->alt.p->next.p;
808              continue;
809           }
810           else if(static_cast<re_brace*>(state)->index == -3)
811           {
812              state = state->next.p->next.p;
813              continue;
814           }
815           break;
816        case syntax_element_endmark:
817           if((static_cast<re_brace*>(state)->index == -1)
818              || (static_cast<re_brace*>(state)->index == -2))
819              return result;
820           break;
821        case syntax_element_literal:
822           result += static_cast<re_literal*>(state)->length;
823           break;
824        case syntax_element_wild:
825        case syntax_element_set:
826           result += 1;
827           break;
828        case syntax_element_dot_rep:
829        case syntax_element_char_rep:
830        case syntax_element_short_set_rep:
831        case syntax_element_backref:
832        case syntax_element_rep:
833        case syntax_element_combining:
834        case syntax_element_long_set_rep:
835        case syntax_element_backstep:
836           {
837              re_repeat* rep = static_cast<re_repeat *>(state);
838              state->type = this->get_repeat_type(state);
839              if((state->type == syntax_element_dot_rep) 
840                 || (state->type == syntax_element_char_rep)
841                 || (state->type == syntax_element_short_set_rep))
842              {
843                 if(rep->max != rep->min)
844                    return -1;
845                 if (static_cast<std::size_t>((std::numeric_limits<int>::max)() - result) < rep->min)
846                    return -1; 
847                 result += static_cast<int>(rep->min);
848                 state = rep->alt.p;
849                 continue;
850              }
851              else if(state->type == syntax_element_long_set_rep)
852              {
853                 BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_long_set);
854                 if(static_cast<re_set_long<m_type>*>(rep->next.p)->singleton == 0)
855                    return -1;
856                 if(rep->max != rep->min)
857                    return -1;
858                 result += static_cast<int>(rep->min);
859                 state = rep->alt.p;
860                 continue;
861              }
862           }
863           return -1;
864        case syntax_element_long_set:
865           if(static_cast<re_set_long<m_type>*>(state)->singleton == 0)
866              return -1;
867           result += 1;
868           break;
869        case syntax_element_jump:
870           state = static_cast<re_jump*>(state)->alt.p;
871           continue;
872        case syntax_element_alt:
873           {
874              int r1 = calculate_backstep(state->next.p);
875              int r2 = calculate_backstep(static_cast<re_alt*>(state)->alt.p);
876              if((r1 < 0) || (r1 != r2))
877                 return -1;
878              return result + r1;
879           }
880        default:
881           break;
882        }
883        state = state->next.p;
884     }
885     return -1;
886  }
887  struct recursion_saver
888  {
889     std::vector<unsigned char> saved_state;
890     std::vector<unsigned char>* state;
891     recursion_saver(std::vector<unsigned char>* p) : saved_state(*p), state(p) {}
892     ~recursion_saver()
893     {
894        state->swap(saved_state);
895     }
896  };
897  template <class charT, class traits>
<span onclick='openModal()' class='match'>898  void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
899  {
900     recursion_saver saved_recursions(&m_recursion_checks);
901     int not_last_jump = 1;
902     re_syntax_base* recursion_start = 0;
903     int recursion_sub = 0;
904     re_syntax_base* recursion_restart = 0;
905     bool l_icase = m_icase;
</span>906     while(state)
907     {
908        switch(state->type)
909        {
910        case syntax_element_toggle_case:
911           l_icase = static_cast<re_case*>(state)->icase;
912           state = state->next.p;
913           break;
914        case syntax_element_literal:
915        {
916           if(l_map)
917           {
918              l_map[0] |= mask_init;
919              charT first_char = *static_cast<charT*>(static_cast<void*>(static_cast<re_literal*>(state) + 1));
920              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
921              {
922                 if(m_traits.translate(static_cast<charT>(i), l_icase) == first_char)
923                    l_map[i] |= mask;
924              }
925           }
926           return;
927        }
928        case syntax_element_end_line:
929        {
930           if(l_map)
931           {
932              l_map[0] |= mask_init;
933              l_map[static_cast<unsigned>('\n')] |= mask;
934              l_map[static_cast<unsigned>('\r')] |= mask;
935              l_map[static_cast<unsigned>('\f')] |= mask;
936              l_map[0x85] |= mask;
937           }
938           if(pnull)
939              create_startmap(state->next.p, 0, pnull, mask);
940           return;
941        }
942        case syntax_element_recurse:
943           {
944              BOOST_REGEX_ASSERT(static_cast<const re_jump*>(state)->alt.p->type == syntax_element_startmark);
945              recursion_sub = static_cast<re_brace*>(static_cast<const re_jump*>(state)->alt.p)->index;
946              if(m_recursion_checks[recursion_sub] & 1u)
947              {
948                 if(0 == this->m_pdata->m_status) 
949                    this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
950                 this->m_pdata->m_expression = 0;
951                 this->m_pdata->m_expression_len = 0;
952                 if(0 == (this->flags() & regex_constants::no_except))
953                 {
954                    std::string message = "Encountered an infinite recursion.";
955                    boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
956                    e.raise();
957                 }
958              }
959              else if(recursion_start == 0)
960              {
961                 recursion_start = state;
962                 recursion_restart = state->next.p;
963                 state = static_cast<re_jump*>(state)->alt.p;
964                 m_recursion_checks[recursion_sub] |= 1u;
965                 break;
966              }
967              m_recursion_checks[recursion_sub] |= 1u;
968              BOOST_REGEX_FALLTHROUGH;
969           }
970        case syntax_element_backref:
971           if(pnull)
972              *pnull |= mask;
973           BOOST_REGEX_FALLTHROUGH;
974        case syntax_element_wild:
975        {
976           set_all_masks(l_map, mask);
977           return;
978        }
979        case syntax_element_accept:
980        case syntax_element_match:
981        {
982           set_all_masks(l_map, mask);
983           if(pnull)
984              *pnull |= mask;
985           return;
986        }
987        case syntax_element_word_start:
988        {
989           create_startmap(state->next.p, l_map, pnull, mask);
990           if(l_map)
991           {
992              l_map[0] |= mask_init;
993              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
994              {
995                 if(!m_traits.isctype(static_cast<charT>(i), m_word_mask))
996                    l_map[i] &= static_cast<unsigned char>(~mask);
997              }
998           }
999           return;
1000        }
1001        case syntax_element_word_end:
1002        {
1003           create_startmap(state->next.p, l_map, pnull, mask);
1004           if(l_map)
1005           {
1006              l_map[0] |= mask_init;
1007              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1008              {
1009                 if(m_traits.isctype(static_cast<charT>(i), m_word_mask))
1010                    l_map[i] &= static_cast<unsigned char>(~mask);
1011              }
1012           }
1013           return;
1014        }
1015        case syntax_element_buffer_end:
1016        {
1017           if(pnull)
1018              *pnull |= mask;
1019           return;
1020        }
1021        case syntax_element_long_set:
1022           if(l_map)
1023           {
1024              typedef typename traits::char_class_type m_type;
1025              if(static_cast<re_set_long<m_type>*>(state)->singleton)
1026              {
1027                 l_map[0] |= mask_init;
1028                 for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1029                 {
1030                    charT c = static_cast<charT>(i);
1031                    if(&c != re_is_set_member(&c, &c + 1, static_cast<re_set_long<m_type>*>(state), *m_pdata, l_icase))
1032                       l_map[i] |= mask;
1033                 }
1034              }
1035              else
1036                 set_all_masks(l_map, mask);
1037           }
1038           return;
1039        case syntax_element_set:
1040           if(l_map)
1041           {
1042              l_map[0] |= mask_init;
1043              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1044              {
1045                 if(static_cast<re_set*>(state)->_map[
1046                    static_cast<unsigned char>(m_traits.translate(static_cast<charT>(i), l_icase))])
1047                    l_map[i] |= mask;
1048              }
1049           }
1050           return;
1051        case syntax_element_jump:
1052           state = static_cast<re_alt*>(state)->alt.p;
1053           not_last_jump = -1;
1054           break;
1055        case syntax_element_alt:
1056        case syntax_element_rep:
1057        case syntax_element_dot_rep:
1058        case syntax_element_char_rep:
1059        case syntax_element_short_set_rep:
1060        case syntax_element_long_set_rep:
1061           {
1062              re_alt* rep = static_cast<re_alt*>(state);
1063              if(rep->_map[0] & mask_init)
1064              {
1065                 if(l_map)
1066                 {
1067                    l_map[0] |= mask_init;
1068                    for(unsigned int i = 0; i <= UCHAR_MAX; ++i)
1069                    {
1070                       if(rep->_map[i] & mask_any)
1071                          l_map[i] |= mask;
1072                    }
1073                 }
1074                 if(pnull)
1075                 {
1076                    if(rep->can_be_null & mask_any)
1077                       *pnull |= mask;
1078                 }
1079              }
1080              else
1081              {
1082                 if(is_bad_repeat(state))
1083                 {
1084                    set_all_masks(l_map, mask);
1085                    if(pnull)
1086                       *pnull |= mask;
1087                    return;
1088                 }
1089                 set_bad_repeat(state);
1090                 create_startmap(state->next.p, l_map, pnull, mask);
1091                 if((state->type == syntax_element_alt)
1092                    || (static_cast<re_repeat*>(state)->min == 0)
1093                    || (not_last_jump == 0))
1094                    create_startmap(rep->alt.p, l_map, pnull, mask);
1095              }
1096           }
1097           return;
1098        case syntax_element_soft_buffer_end:
1099           if(l_map)
1100           {
1101              l_map[0] |= mask_init;
1102              l_map[static_cast<unsigned>('\n')] |= mask;
1103              l_map[static_cast<unsigned>('\r')] |= mask;
1104           }
1105           if(pnull)
1106              *pnull |= mask;
1107           return;
1108        case syntax_element_endmark:
1109           if(static_cast<re_brace*>(state)->index < 0)
1110           {
1111              set_all_masks(l_map, mask);
1112              if(pnull)
1113                 *pnull |= mask;
1114              return;
1115           }
1116           else if(recursion_start && (recursion_sub != 0) && (recursion_sub == static_cast<re_brace*>(state)->index))
1117           {
1118              recursion_start = 0;
1119              state = recursion_restart;
1120              break;
1121           }
1122           if(m_pdata->m_has_recursions && static_cast<re_brace*>(state)->index)
1123           {
1124              bool ok = false;
1125              re_syntax_base* p = m_pdata->m_first_state;
1126              while(p)
1127              {
1128                 if(p->type == syntax_element_recurse)
1129                 {
1130                    re_brace* p2 = static_cast<re_brace*>(static_cast<re_jump*>(p)->alt.p);
1131                    if((p2->type == syntax_element_startmark) && (p2->index == static_cast<re_brace*>(state)->index))
1132                    {
1133                       ok = true;
1134                       break;
1135                    }
1136                 }
1137                 p = p->next.p;
1138              }
1139              if(ok && ((m_recursion_checks[static_cast<re_brace*>(state)->index] & 2u) == 0))
1140              {
1141                 m_recursion_checks[static_cast<re_brace*>(state)->index] |= 2u;
1142                 create_startmap(p->next.p, l_map, pnull, mask);
1143              }
1144           }
1145           state = state->next.p;
1146           break;
1147        case syntax_element_commit:
1148           set_all_masks(l_map, mask);
1149           state = state->next.p;
1150           break;
1151        case syntax_element_startmark:
1152           if(static_cast<re_brace*>(state)->index == -3)
1153           {
1154              state = state->next.p->next.p;
1155              break;
1156           }
1157           BOOST_REGEX_FALLTHROUGH;
1158        default:
1159           state = state->next.p;
1160        }
1161        ++not_last_jump;
1162     }
1163  }
1164  template <class charT, class traits>
1165  unsigned basic_regex_creator<charT, traits>::get_restart_type(re_syntax_base* state)
1166  {
1167     while(state)
1168     {
1169        switch(state->type)
1170        {
1171        case syntax_element_startmark:
1172        case syntax_element_endmark:
1173           state = state->next.p;
1174           continue;
1175        case syntax_element_start_line:
1176           return regbase::restart_line;
1177        case syntax_element_word_start:
1178           return regbase::restart_word;
1179        case syntax_element_buffer_start:
1180           return regbase::restart_buf;
1181        case syntax_element_restart_continue:
1182           return regbase::restart_continue;
1183        default:
1184           state = 0;
1185           continue;
1186        }
1187     }
1188     return regbase::restart_any;
1189  }
1190  template <class charT, class traits>
1191  void basic_regex_creator<charT, traits>::set_all_masks(unsigned char* bits, unsigned char mask)
1192  {
1193     if(bits)
1194     {
1195        if(bits[0] == 0)
1196           (std::memset)(bits, mask, 1u << CHAR_BIT);
1197        else
1198        {
1199           for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
1200              bits[i] |= mask;
1201        }
1202        bits[0] |= mask_init;
1203     }
1204  }
1205  template <class charT, class traits>
1206  bool basic_regex_creator<charT, traits>::is_bad_repeat(re_syntax_base* pt)
1207  {
1208     switch(pt->type)
1209     {
1210     case syntax_element_rep:
1211     case syntax_element_dot_rep:
1212     case syntax_element_char_rep:
1213     case syntax_element_short_set_rep:
1214     case syntax_element_long_set_rep:
1215        {
1216           unsigned state_id = static_cast<re_repeat*>(pt)->state_id;
1217           if(state_id >= sizeof(m_bad_repeats) * CHAR_BIT)
1218              return true;  
1219           static const std::uintmax_t one = 1uL;
1220           return m_bad_repeats & (one << state_id);
1221        }
1222     default:
1223        return false;
1224     }
1225  }
1226  template <class charT, class traits>
1227  void basic_regex_creator<charT, traits>::set_bad_repeat(re_syntax_base* pt)
1228  {
1229     switch(pt->type)
1230     {
1231     case syntax_element_rep:
1232     case syntax_element_dot_rep:
1233     case syntax_element_char_rep:
1234     case syntax_element_short_set_rep:
1235     case syntax_element_long_set_rep:
1236        {
1237           unsigned state_id = static_cast<re_repeat*>(pt)->state_id;
1238           static const std::uintmax_t one = 1uL;
1239           if(state_id <= sizeof(m_bad_repeats) * CHAR_BIT)
1240              m_bad_repeats |= (one << state_id);
1241        }
1242        break;
1243     default:
1244        break;
1245     }
1246  }
1247  template <class charT, class traits>
1248  syntax_element_type basic_regex_creator<charT, traits>::get_repeat_type(re_syntax_base* state)
1249  {
1250     typedef typename traits::char_class_type m_type;
1251     if(state->type == syntax_element_rep)
1252     {
1253        if(state->next.p->next.p->next.p == static_cast<re_alt*>(state)->alt.p)
1254        {
1255           switch(state->next.p->type)
1256           {
1257           case BOOST_REGEX_DETAIL_NS::syntax_element_wild:
1258              return BOOST_REGEX_DETAIL_NS::syntax_element_dot_rep;
1259           case BOOST_REGEX_DETAIL_NS::syntax_element_literal:
1260              return BOOST_REGEX_DETAIL_NS::syntax_element_char_rep;
1261           case BOOST_REGEX_DETAIL_NS::syntax_element_set:
1262              return BOOST_REGEX_DETAIL_NS::syntax_element_short_set_rep;
1263           case BOOST_REGEX_DETAIL_NS::syntax_element_long_set:
1264              if(static_cast<BOOST_REGEX_DETAIL_NS::re_set_long<m_type>*>(state->next.p)->singleton)
1265                 return BOOST_REGEX_DETAIL_NS::syntax_element_long_set_rep;
1266              break;
1267           default:
1268              break;
1269           }
1270        }
1271     }
1272     return state->type;
1273  }
1274  template <class charT, class traits>
1275  void basic_regex_creator<charT, traits>::probe_leading_repeat(re_syntax_base* state)
1276  {
1277     do
1278     {
1279        switch(state->type)
1280        {
1281        case syntax_element_startmark:
1282           if(static_cast<re_brace*>(state)->index >= 0)
1283           {
1284              state = state->next.p;
1285              continue;
1286           }
1287  #ifdef BOOST_REGEX_MSVC
1288  #  pragma warning(push)
1289  #pragma warning(disable:6011)
1290  #endif
1291           if((static_cast<re_brace*>(state)->index == -1)
1292              || (static_cast<re_brace*>(state)->index == -2))
1293           {
1294              state = static_cast<const re_jump*>(state->next.p)->alt.p->next.p;
1295              continue;
1296           }
1297  #ifdef BOOST_REGEX_MSVC
1298  #  pragma warning(pop)
1299  #endif
1300           if(static_cast<re_brace*>(state)->index == -3)
1301           {
1302              state = state->next.p->next.p;
1303              continue;
1304           }
1305           return;
1306        case syntax_element_endmark:
1307        case syntax_element_start_line:
1308        case syntax_element_end_line:
1309        case syntax_element_word_boundary:
1310        case syntax_element_within_word:
1311        case syntax_element_word_start:
1312        case syntax_element_word_end:
1313        case syntax_element_buffer_start:
1314        case syntax_element_buffer_end:
1315        case syntax_element_restart_continue:
1316           state = state->next.p;
1317           break;
1318        case syntax_element_dot_rep:
1319        case syntax_element_char_rep:
1320        case syntax_element_short_set_rep:
1321        case syntax_element_long_set_rep:
1322           if(this->m_has_backrefs == 0)
1323              static_cast<re_repeat*>(state)->leading = true;
1324           BOOST_REGEX_FALLTHROUGH;
1325        default:
1326           return;
1327        }
1328     }while(state);
1329  }
1330  } 
1331  } 
1332  #ifdef BOOST_REGEX_MSVC
1333  #  pragma warning(pop)
1334  #endif
1335  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-ggen.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_creator.hpp</div>
                </div>
                <div class="column column_space"><pre><code>314  TEST(GGenTest, GenRndBipart) {
315    const int LeftNodesMin = 8;
316    const int LeftNodesMax = 20;
317    const int RightNodesMin = 8;
318    const int RightNodesMax = 50;
319    const int EdgesMin = 5;
</pre></code></div>
                <div class="column column_space"><pre><code>898  void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
899  {
900     recursion_saver saved_recursions(&m_recursion_checks);
901     int not_last_jump = 1;
902     re_syntax_base* recursion_start = 0;
903     int recursion_sub = 0;
904     re_syntax_base* recursion_restart = 0;
905     bool l_icase = m_icase;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    