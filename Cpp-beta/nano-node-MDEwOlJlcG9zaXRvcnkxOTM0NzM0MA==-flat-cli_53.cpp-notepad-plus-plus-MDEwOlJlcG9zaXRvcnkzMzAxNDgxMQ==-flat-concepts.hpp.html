
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.964033397559408%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cli_53.cpp</h3>
            <pre><code>1  #include <nano/lib/cli.hpp>
2  #include <nano/lib/tlsconfig.hpp>
3  #include <nano/lib/tomlconfig.hpp>
4  #include <nano/node/cli.hpp>
5  #include <nano/node/common.hpp>
6  #include <nano/node/daemonconfig.hpp>
7  #include <nano/node/node.hpp>
8  #include <boost/format.hpp>
9  namespace
10  {
11  void reset_confirmation_heights (nano::write_transaction const & transaction, nano::ledger_constants & constants, nano::store & store);
12  bool is_using_rocksdb (boost::filesystem::path const & data_path, boost::program_options::variables_map const & vm, std::error_code & ec);
13  }
14  std::string nano::error_cli_messages::message (int ev) const
15  {
16  	switch (static_cast<nano::error_cli> (ev))
17  	{
18  		case nano::error_cli::generic:
19  			return "Unknown error";
20  		case nano::error_cli::parse_error:
21  			return "Coud not parse command line";
22  		case nano::error_cli::invalid_arguments:
23  			return "Invalid arguments";
24  		case nano::error_cli::unknown_command:
25  			return "Unknown command";
26  		case nano::error_cli::database_write_error:
27  			return "Database write error";
28  		case nano::error_cli::reading_config:
29  			return "Config file read error";
30  		case nano::error_cli::ambiguous_pruning_voting_options:
31  			return "Flag --enable_pruning and enable_voting in node config cannot be used together";
32  	}
33  	return "Invalid error code";
34  }
<span onclick='openModal()' class='match'>35  void nano::add_node_options (boost::program_options::options_description & description_a)
36  {
37  	description_a.add_options ()
</span>38  	("initialize", "Initialize the data folder, if it is not already initialised. This command is meant to be run when the data folder is empty, to populate it with the genesis block.")
39  	("account_create", "Insert next deterministic key in to <wallet>")
40  	("account_get", "Get account number for the <key>")
41  	("account_key", "Get the public key for <account>")
42  	("vacuum", "Compact database. If data_path is missing, the database in data directory is compacted.")
43  	("snapshot", "Compact database and create snapshot, functions similar to vacuum but does not replace the existing database")
44  	("data_path", boost::program_options::value<std::string> (), "Use the supplied path as the data directory")
45  	("network", boost::program_options::value<std::string> (), "Use the supplied network (live, test, beta or dev)")
46  	("clear_send_ids", "Remove all send IDs from the database (dangerous: not intended for production use)")
47  	("online_weight_clear", "Clear online weight history records")
48  	("peer_clear", "Clear online peers database dump")
49  	("unchecked_clear", "Clear unchecked blocks")
50  	("confirmation_height_clear", "Clear confirmation height. Requires an <account> option that can be 'all' to clear all accounts")
51  	("final_vote_clear", "Clear final votes")
52  	("rebuild_database", "Rebuild LMDB database with vacuum for best compaction")
53  	("migrate_database_lmdb_to_rocksdb", "Migrates LMDB database to RocksDB")
54  	("diagnostics", "Run internal diagnostics")
55  	("generate_config", boost::program_options::value<std::string> (), "Write configuration to stdout, populated with defaults suitable for this system. Pass the configuration type node, rpc or tls. See also use_defaults.")
56  	("key_create", "Generates a adhoc random keypair and prints it to stdout")
57  	("key_expand", "Derive public key and account number from <key>")
58  	("wallet_add_adhoc", "Insert <key> in to <wallet>")
59  	("wallet_create", "Creates a new wallet and prints the ID")
60  	("wallet_change_seed", "Changes seed for <wallet> to <key>")
61  	("wallet_decrypt_unsafe", "Decrypts <wallet> using <password>, !!THIS WILL PRINT YOUR PRIVATE KEY TO STDOUT!!")
62  	("wallet_destroy", "Destroys <wallet> and all keys it contains")
63  	("wallet_import", "Imports keys in <file> using <password> in to <wallet>")
64  	("wallet_list", "Dumps wallet IDs and public keys")
65  	("wallet_remove", "Remove <account> from <wallet>")
66  	("wallet_representative_get", "Prints default representative for <wallet>")
67  	("wallet_representative_set", "Set <account> as default representative for <wallet>")
68  	("all", "Only valid with --final_vote_clear")
69  	("account", boost::program_options::value<std::string> (), "Defines <account> for other commands")
70  	("root", boost::program_options::value<std::string> (), "Defines <root> for other commands")
71  	("file", boost::program_options::value<std::string> (), "Defines <file> for other commands")
72  	("key", boost::program_options::value<std::string> (), "Defines the <key> for other commands, hex")
73  	("seed", boost::program_options::value<std::string> (), "Defines the <seed> for other commands, hex")
74  	("password", boost::program_options::value<std::string> (), "Defines <password> for other commands")
75  	("wallet", boost::program_options::value<std::string> (), "Defines <wallet> for other commands")
76  	("force", boost::program_options::value<bool>(), "Bool to force command if allowed")
77  	("use_defaults", "If present, the generate_config command will generate uncommented entries");
78  }
79  void nano::add_node_flag_options (boost::program_options::options_description & description_a)
80  {
81  	description_a.add_options()
82  		("disable_add_initial_peers", "Disable contacting the peer in the peers table at startup")
83  		("disable_backup", "Disable wallet automatic backups")
84  		("disable_lazy_bootstrap", "Disables lazy bootstrap")
85  		("disable_legacy_bootstrap", "Disables legacy bootstrap")
86  		("disable_wallet_bootstrap", "Disables wallet lazy bootstrap")
87  		("disable_ongoing_bootstrap", "Disable ongoing bootstrap")
88  		("disable_ascending_bootstrap", "Disable ascending bootstrap")
89  		("disable_rep_crawler", "Disable rep crawler")
90  		("disable_request_loop", "Disable request loop")
91  		("disable_bootstrap_listener", "Disables bootstrap processing for TCP listener (not including realtime network TCP connections)")
92  		("disable_unchecked_cleanup", "Disables periodic cleanup of old records from unchecked table")
93  		("disable_unchecked_drop", "Disables drop of unchecked table at startup")
94  		("disable_providing_telemetry_metrics", "Disable using any node information in the telemetry_ack messages.")
95  		("disable_block_processor_unchecked_deletion", "Disable deletion of unchecked blocks after processing")
96  		("enable_pruning", "Enable experimental ledger pruning")
97  		("allow_bootstrap_peers_duplicates", "Allow multiple connections to same peer in bootstrap attempts")
98  		("fast_bootstrap", "Increase bootstrap speed for high end nodes with higher limits")
99  		("block_processor_batch_size", boost::program_options::value<std::size_t>(), "Increase block processor transaction batch write size, default 0 (limited by config block_processor_batch_max_time), 256k for fast_bootstrap")
100  		("block_processor_full_size", boost::program_options::value<std::size_t>(), "Increase block processor allowed blocks queue size before dropping live network packets and holding bootstrap download, default 65536, 1 million for fast_bootstrap")
101  		("block_processor_verification_size", boost::program_options::value<std::size_t>(), "Increase batch signature verification size in block processor, default 0 (limited by config signature_checker_threads), unlimited for fast_bootstrap")
102  		("inactive_votes_cache_size", boost::program_options::value<std::size_t>(), "Increase cached votes without active elections size, default 16384")
103  		("vote_processor_capacity", boost::program_options::value<std::size_t>(), "Vote processor queue size before dropping votes, default 144k")
104  		;
105  }
106  std::error_code nano::update_flags (nano::node_flags & flags_a, boost::program_options::variables_map const & vm)
107  {
108  	std::error_code ec;
109  	flags_a.disable_add_initial_peers = (vm.count ("disable_add_initial_peers") > 0);
110  	flags_a.disable_backup = (vm.count ("disable_backup") > 0);
111  	flags_a.disable_lazy_bootstrap = (vm.count ("disable_lazy_bootstrap") > 0);
112  	flags_a.disable_legacy_bootstrap = (vm.count ("disable_legacy_bootstrap") > 0);
113  	flags_a.disable_wallet_bootstrap = (vm.count ("disable_wallet_bootstrap") > 0);
114  	flags_a.disable_ongoing_bootstrap = (vm.count ("disable_ongoing_bootstrap") > 0);
115  	flags_a.disable_ascending_bootstrap = (vm.count ("disable_ascending_bootstrap") > 0);
116  	flags_a.disable_rep_crawler = (vm.count ("disable_rep_crawler") > 0);
117  	flags_a.disable_request_loop = (vm.count ("disable_request_loop") > 0);
118  	if (!flags_a.inactive_node)
119  	{
120  		flags_a.disable_bootstrap_listener = (vm.count ("disable_bootstrap_listener") > 0);
121  	}
122  	flags_a.disable_providing_telemetry_metrics = (vm.count ("disable_providing_telemetry_metrics") > 0);
123  	flags_a.disable_unchecked_cleanup = (vm.count ("disable_unchecked_cleanup") > 0);
124  	flags_a.disable_unchecked_drop = (vm.count ("disable_unchecked_drop") > 0);
125  	flags_a.disable_block_processor_unchecked_deletion = (vm.count ("disable_block_processor_unchecked_deletion") > 0);
126  	flags_a.enable_pruning = (vm.count ("enable_pruning") > 0);
127  	flags_a.allow_bootstrap_peers_duplicates = (vm.count ("allow_bootstrap_peers_duplicates") > 0);
128  	flags_a.fast_bootstrap = (vm.count ("fast_bootstrap") > 0);
129  	if (flags_a.fast_bootstrap)
130  	{
131  		flags_a.disable_block_processor_unchecked_deletion = true;
132  		flags_a.block_processor_batch_size = 256 * 1024;
133  		flags_a.block_processor_full_size = 1024 * 1024;
134  		flags_a.block_processor_verification_size = std::numeric_limits<std::size_t>::max ();
135  	}
136  	auto block_processor_batch_size_it = vm.find ("block_processor_batch_size");
137  	if (block_processor_batch_size_it != vm.end ())
138  	{
139  		flags_a.block_processor_batch_size = block_processor_batch_size_it->second.as<std::size_t> ();
140  	}
141  	auto block_processor_full_size_it = vm.find ("block_processor_full_size");
142  	if (block_processor_full_size_it != vm.end ())
143  	{
144  		flags_a.block_processor_full_size = block_processor_full_size_it->second.as<std::size_t> ();
145  	}
146  	auto block_processor_verification_size_it = vm.find ("block_processor_verification_size");
147  	if (block_processor_verification_size_it != vm.end ())
148  	{
149  		flags_a.block_processor_verification_size = block_processor_verification_size_it->second.as<std::size_t> ();
150  	}
151  	auto inactive_votes_cache_size_it = vm.find ("inactive_votes_cache_size");
152  	if (inactive_votes_cache_size_it != vm.end ())
153  	{
154  		flags_a.inactive_votes_cache_size = inactive_votes_cache_size_it->second.as<std::size_t> ();
155  	}
156  	auto vote_processor_capacity_it = vm.find ("vote_processor_capacity");
157  	if (vote_processor_capacity_it != vm.end ())
158  	{
159  		flags_a.vote_processor_capacity = vote_processor_capacity_it->second.as<std::size_t> ();
160  	}
161  	auto config (vm.find ("config"));
162  	if (config != vm.end ())
163  	{
164  		flags_a.config_overrides = nano::config_overrides (config->second.as<std::vector<nano::config_key_value_pair>> ());
165  	}
166  	auto rpcconfig (vm.find ("rpcconfig"));
167  	if (rpcconfig != vm.end ())
168  	{
169  		flags_a.rpc_config_overrides = nano::config_overrides (rpcconfig->second.as<std::vector<nano::config_key_value_pair>> ());
170  	}
171  	return ec;
172  }
173  std::error_code nano::flags_config_conflicts (nano::node_flags const & flags_a, nano::node_config const & config_a)
174  {
175  	std::error_code ec;
176  	if (flags_a.enable_pruning && config_a.enable_voting)
177  	{
178  		ec = nano::error_cli::ambiguous_pruning_voting_options;
179  	}
180  	return ec;
181  }
182  namespace
183  {
184  void database_write_lock_error (std::error_code & ec)
185  {
186  	std::cerr << "Write database error, this cannot be run while the node is already running\n";
187  	ec = nano::error_cli::database_write_error;
188  }
189  bool copy_database (boost::filesystem::path const & data_path, boost::program_options::variables_map const & vm, boost::filesystem::path const & output_path, std::error_code & ec)
190  {
191  	bool success = false;
192  	bool needs_to_write = vm.count ("unchecked_clear") || vm.count ("clear_send_ids") || vm.count ("online_weight_clear") || vm.count ("peer_clear") || vm.count ("confirmation_height_clear") || vm.count ("final_vote_clear") || vm.count ("rebuild_database");
193  	auto node_flags = nano::inactive_node_flag_defaults ();
194  	node_flags.read_only = !needs_to_write;
195  	nano::update_flags (node_flags, vm);
196  	nano::inactive_node node (data_path, node_flags);
197  	if (!node.node->init_error ())
198  	{
199  		auto & store (node.node->store);
200  		if (vm.count ("unchecked_clear"))
201  		{
202  			node.node->unchecked.clear ();
203  		}
204  		if (vm.count ("clear_send_ids"))
205  		{
206  			node.node->wallets.clear_send_ids (node.node->wallets.tx_begin_write ());
207  		}
208  		if (vm.count ("online_weight_clear"))
209  		{
210  			node.node->store.online_weight.clear (store.tx_begin_write ());
211  		}
212  		if (vm.count ("peer_clear"))
213  		{
214  			node.node->store.peer.clear (store.tx_begin_write ());
215  		}
216  		if (vm.count ("confirmation_height_clear"))
217  		{
218  			reset_confirmation_heights (store.tx_begin_write (), node.node->network_params.ledger, store);
219  		}
220  		if (vm.count ("final_vote_clear"))
221  		{
222  			node.node->store.final_vote.clear (store.tx_begin_write ());
223  		}
224  		if (vm.count ("rebuild_database"))
225  		{
226  			node.node->store.rebuild_db (store.tx_begin_write ());
227  		}
228  		success = node.node->copy_with_compaction (output_path);
229  	}
230  	else
231  	{
232  		database_write_lock_error (ec);
233  	}
234  	return success;
235  }
236  }
237  std::error_code nano::handle_node_options (boost::program_options::variables_map const & vm)
238  {
239  	std::error_code ec;
240  	boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
241  	if (vm.count ("initialize"))
242  	{
243  		auto node_flags = nano::inactive_node_flag_defaults ();
244  		node_flags.read_only = false;
245  		nano::update_flags (node_flags, vm);
246  		nano::inactive_node node (data_path, node_flags);
247  	}
248  	else if (vm.count ("account_create"))
249  	{
250  		if (vm.count ("wallet") == 1)
251  		{
252  			nano::wallet_id wallet_id;
253  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
254  			{
255  				std::string password;
256  				if (vm.count ("password") > 0)
257  				{
258  					password = vm["password"].as<std::string> ();
259  				}
260  				auto inactive_node = nano::default_inactive_node (data_path, vm);
261  				auto wallet (inactive_node->node->wallets.open (wallet_id));
262  				if (wallet != nullptr)
263  				{
264  					auto transaction (wallet->wallets.tx_begin_write ());
265  					if (!wallet->enter_password (transaction, password))
266  					{
267  						auto pub (wallet->store.deterministic_insert (transaction));
268  						std::cout << boost::str (boost::format ("Account: %1%\n") % pub.to_account ());
269  					}
270  					else
271  					{
272  						std::cerr << "Invalid password\n";
273  						ec = nano::error_cli::invalid_arguments;
274  					}
275  				}
276  				else
277  				{
278  					std::cerr << "Wallet doesn't exist\n";
279  					ec = nano::error_cli::invalid_arguments;
280  				}
281  			}
282  			else
283  			{
284  				std::cerr << "Invalid wallet id\n";
285  				ec = nano::error_cli::invalid_arguments;
286  			}
287  		}
288  		else
289  		{
290  			std::cerr << "account_create command requires one <wallet> option and optionally one <password> option\n";
291  			ec = nano::error_cli::invalid_arguments;
292  		}
293  	}
294  	else if (vm.count ("account_get") > 0)
295  	{
296  		if (vm.count ("key") == 1)
297  		{
298  			nano::account pub;
299  			pub.decode_hex (vm["key"].as<std::string> ());
300  			std::cout << "Account: " << pub.to_account () << std::endl;
301  		}
302  		else
303  		{
304  			std::cerr << "account comand requires one <key> option\n";
305  			ec = nano::error_cli::invalid_arguments;
306  		}
307  	}
308  	else if (vm.count ("account_key") > 0)
309  	{
310  		if (vm.count ("account") == 1)
311  		{
312  			nano::account account;
313  			account.decode_account (vm["account"].as<std::string> ());
314  			std::cout << "Hex: " << account.to_string () << std::endl;
315  		}
316  		else
317  		{
318  			std::cerr << "account_key command requires one <account> option\n";
319  			ec = nano::error_cli::invalid_arguments;
320  		}
321  	}
322  	else if (vm.count ("vacuum") > 0)
323  	{
324  		try
325  		{
326  			auto using_rocksdb = is_using_rocksdb (data_path, vm, ec);
327  			if (!ec)
328  			{
329  				std::cout << "Vacuuming database copy in ";
330  				boost::filesystem::path source_path;
331  				boost::filesystem::path backup_path;
332  				boost::filesystem::path vacuum_path;
333  				if (using_rocksdb)
334  				{
335  					source_path = data_path / "rocksdb";
336  					backup_path = source_path / "backup";
337  					vacuum_path = backup_path / "vacuumed";
338  					if (!boost::filesystem::exists (vacuum_path))
339  					{
340  						boost::filesystem::create_directories (vacuum_path);
341  					}
342  					std::cout << source_path << "\n";
343  				}
344  				else
345  				{
346  					source_path = data_path / "data.ldb";
347  					backup_path = data_path / "backup.vacuum.ldb";
348  					vacuum_path = data_path / "vacuumed.ldb";
349  					std::cout << data_path << "\n";
350  				}
351  				std::cout << "This may take a while..." << std::endl;
352  				bool success = copy_database (data_path, vm, vacuum_path, ec);
353  				if (success)
354  				{
355  					std::cout << "Finalizing" << std::endl;
356  					if (using_rocksdb)
357  					{
358  						nano::remove_all_files_in_dir (backup_path);
359  						nano::move_all_files_to_dir (source_path, backup_path);
360  						nano::move_all_files_to_dir (vacuum_path, source_path);
361  						boost::filesystem::remove_all (vacuum_path);
362  					}
363  					else
364  					{
365  						boost::filesystem::remove (backup_path);
366  						boost::filesystem::rename (source_path, backup_path);
367  						boost::filesystem::rename (vacuum_path, source_path);
368  					}
369  					std::cout << "Vacuum completed" << std::endl;
370  				}
371  				else
372  				{
373  					std::cerr << "Vacuum failed (copying returned false)" << std::endl;
374  				}
375  			}
376  			else
377  			{
378  				std::cerr << "Vacuum failed. RocksDB is enabled but the node has not been built with RocksDB support" << std::endl;
379  			}
380  		}
381  		catch (boost::filesystem::filesystem_error const & ex)
382  		{
383  			std::cerr << "Vacuum failed during a file operation: " << ex.what () << std::endl;
384  		}
385  		catch (...)
386  		{
387  			std::cerr << "Vacuum failed (unknown reason)" << std::endl;
388  		}
389  	}
390  	else if (vm.count ("snapshot"))
391  	{
392  		try
393  		{
394  			auto using_rocksdb = is_using_rocksdb (data_path, vm, ec);
395  			if (!ec)
396  			{
397  				boost::filesystem::path source_path;
398  				boost::filesystem::path snapshot_path;
399  				if (using_rocksdb)
400  				{
401  					source_path = data_path / "rocksdb";
402  					snapshot_path = source_path / "backup";
403  				}
404  				else
405  				{
406  					source_path = data_path / "data.ldb";
407  					snapshot_path = data_path / "snapshot.ldb";
408  				}
409  				std::cout << "Database snapshot of " << source_path << " to " << snapshot_path << " in progress" << std::endl;
410  				std::cout << "This may take a while..." << std::endl;
411  				bool success = copy_database (data_path, vm, snapshot_path, ec);
412  				if (success)
413  				{
414  					std::cout << "Snapshot completed, This can be found at " << snapshot_path << std::endl;
415  				}
416  				else
417  				{
418  					std::cerr << "Snapshot failed (copying returned false)" << std::endl;
419  				}
420  			}
421  			else
422  			{
423  				std::cerr << "Snapshot failed. RocksDB is enabled but the node has not been built with RocksDB support" << std::endl;
424  			}
425  		}
426  		catch (boost::filesystem::filesystem_error const & ex)
427  		{
428  			std::cerr << "Snapshot failed during a file operation: " << ex.what () << std::endl;
429  		}
430  		catch (...)
431  		{
432  			std::cerr << "Snapshot failed (unknown reason)" << std::endl;
433  		}
434  	}
435  	else if (vm.count ("migrate_database_lmdb_to_rocksdb"))
436  	{
437  		auto data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
438  		auto node_flags = nano::inactive_node_flag_defaults ();
439  		node_flags.config_overrides.push_back ("node.rocksdb.enable=false");
440  		nano::update_flags (node_flags, vm);
441  		nano::inactive_node node (data_path, node_flags);
442  		auto error (false);
443  		if (!node.node->init_error ())
444  		{
445  			std::cout << "Migrating LMDB database to RocksDB, might take a while..." << std::endl;
446  			error = node.node->ledger.migrate_lmdb_to_rocksdb (data_path);
447  		}
448  		else
449  		{
450  			error = true;
451  		}
452  		if (!error)
453  		{
454  			std::cout << "Migration completed, after confirming it is correct the data.ldb file can be deleted if no longer required" << std::endl;
455  		}
456  		else
457  		{
458  			std::cerr << "There was an error migrating" << std::endl;
459  		}
460  	}
461  	else if (vm.count ("unchecked_clear"))
462  	{
463  		boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
464  		auto node_flags = nano::inactive_node_flag_defaults ();
465  		node_flags.read_only = false;
466  		nano::update_flags (node_flags, vm);
467  		nano::inactive_node node (data_path, node_flags);
468  		if (!node.node->init_error ())
469  		{
470  			auto transaction (node.node->store.tx_begin_write ());
471  			node.node->unchecked.clear ();
472  			std::cout << "Unchecked blocks deleted" << std::endl;
473  		}
474  		else
475  		{
476  			database_write_lock_error (ec);
477  		}
478  	}
479  	else if (vm.count ("clear_send_ids"))
480  	{
481  		boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
482  		auto node_flags = nano::inactive_node_flag_defaults ();
483  		node_flags.read_only = false;
484  		nano::update_flags (node_flags, vm);
485  		nano::inactive_node node (data_path, node_flags);
486  		if (!node.node->init_error ())
487  		{
488  			auto transaction (node.node->wallets.tx_begin_write ());
489  			node.node->wallets.clear_send_ids (transaction);
490  			std::cout << "Send IDs deleted" << std::endl;
491  		}
492  		else
493  		{
494  			database_write_lock_error (ec);
495  		}
496  	}
497  	else if (vm.count ("online_weight_clear"))
498  	{
499  		boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
500  		auto node_flags = nano::inactive_node_flag_defaults ();
501  		node_flags.read_only = false;
502  		nano::update_flags (node_flags, vm);
503  		nano::inactive_node node (data_path, node_flags);
504  		if (!node.node->init_error ())
505  		{
506  			auto transaction (node.node->store.tx_begin_write ());
507  			node.node->store.online_weight.clear (transaction);
508  			std::cout << "Online weight records are removed" << std::endl;
509  		}
510  		else
511  		{
512  			database_write_lock_error (ec);
513  		}
514  	}
515  	else if (vm.count ("peer_clear"))
516  	{
517  		boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
518  		auto node_flags = nano::inactive_node_flag_defaults ();
519  		node_flags.read_only = false;
520  		nano::update_flags (node_flags, vm);
521  		nano::inactive_node node (data_path, node_flags);
522  		if (!node.node->init_error ())
523  		{
524  			auto transaction (node.node->store.tx_begin_write ());
525  			node.node->store.peer.clear (transaction);
526  			std::cout << "Database peers are removed" << std::endl;
527  		}
528  		else
529  		{
530  			database_write_lock_error (ec);
531  		}
532  	}
533  	else if (vm.count ("confirmation_height_clear"))
534  	{
535  		boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
536  		auto node_flags = nano::inactive_node_flag_defaults ();
537  		node_flags.read_only = false;
538  		nano::update_flags (node_flags, vm);
539  		nano::inactive_node node (data_path, node_flags);
540  		if (!node.node->init_error ())
541  		{
542  			if (vm.count ("account") == 1)
543  			{
544  				auto account_str = vm["account"].as<std::string> ();
545  				nano::account account;
546  				if (!account.decode_account (account_str))
547  				{
548  					nano::confirmation_height_info confirmation_height_info;
549  					if (!node.node->store.confirmation_height.get (node.node->store.tx_begin_read (), account, confirmation_height_info))
550  					{
551  						auto transaction (node.node->store.tx_begin_write ());
552  						auto conf_height_reset_num = 0;
553  						if (account == node.node->network_params.ledger.genesis->account ())
554  						{
555  							conf_height_reset_num = 1;
556  							node.node->store.confirmation_height.put (transaction, account, { confirmation_height_info.height, node.node->network_params.ledger.genesis->hash () });
557  						}
558  						else
559  						{
560  							node.node->store.confirmation_height.clear (transaction, account);
561  						}
562  						std::cout << "Confirmation height of account " << account_str << " is set to " << conf_height_reset_num << std::endl;
563  					}
564  					else
565  					{
566  						std::cerr << "Could not find account" << std::endl;
567  						ec = nano::error_cli::generic;
568  					}
569  				}
570  				else if (account_str == "all")
571  				{
572  					auto transaction (node.node->store.tx_begin_write ());
573  					reset_confirmation_heights (transaction, node.node->network_params.ledger, node.node->store);
574  					std::cout << "Confirmation heights of all accounts (except genesis which is set to 1) are set to 0" << std::endl;
575  				}
576  				else
577  				{
578  					std::cerr << "Specify either valid account id or 'all'\n";
579  					ec = nano::error_cli::invalid_arguments;
580  				}
581  			}
582  			else
583  			{
584  				std::cerr << "confirmation_height_clear command requires one <account> option that may contain an account or the value 'all'\n";
585  				ec = nano::error_cli::invalid_arguments;
586  			}
587  		}
588  		else
589  		{
590  			database_write_lock_error (ec);
591  		}
592  	}
593  	else if (vm.count ("final_vote_clear"))
594  	{
595  		boost::filesystem::path data_path = vm.count ("data_path") ? boost::filesystem::path (vm["data_path"].as<std::string> ()) : nano::working_path ();
596  		auto node_flags = nano::inactive_node_flag_defaults ();
597  		node_flags.read_only = false;
598  		nano::update_flags (node_flags, vm);
599  		nano::inactive_node node (data_path, node_flags);
600  		if (!node.node->init_error ())
601  		{
602  			if (auto root_it = vm.find ("root"); root_it != vm.cend ())
603  			{
604  				auto root_str = root_it->second.as<std::string> ();
605  				auto transaction (node.node->store.tx_begin_write ());
606  				nano::root root;
607  				if (!root.decode_hex (root_str))
608  				{
609  					node.node->store.final_vote.clear (transaction, root);
610  					std::cout << "Successfully cleared final votes" << std::endl;
611  				}
612  				else
613  				{
614  					std::cerr << "Invalid root" << std::endl;
615  					ec = nano::error_cli::invalid_arguments;
616  				}
617  			}
618  			else if (vm.count ("all"))
619  			{
620  				node.node->store.final_vote.clear (node.node->store.tx_begin_write ());
621  				std::cout << "All final votes are cleared" << std::endl;
622  			}
623  			else
624  			{
625  				std::cerr << "Either specify a single --root to clear or --all to clear all final votes (not recommended)" << std::endl;
626  			}
627  		}
628  		else
629  		{
630  			database_write_lock_error (ec);
631  		}
632  	}
633  	else if (vm.count ("generate_config"))
634  	{
635  		auto type = vm["generate_config"].as<std::string> ();
636  		nano::tomlconfig toml;
637  		bool valid_type = false;
638  		if (type == "node")
639  		{
640  			valid_type = true;
641  			nano::network_params network_params{ nano::network_constants::active_network };
642  			nano::daemon_config config{ data_path, network_params };
643  			config.node.peering_port = network_params.network.default_node_port;
644  			config.serialize_toml (toml);
645  		}
646  		else if (type == "rpc")
647  		{
648  			valid_type = true;
649  			nano::rpc_config config{ nano::dev::network_params.network };
650  			config.serialize_toml (toml);
651  		}
652  		else if (type == "tls")
653  		{
654  			valid_type = true;
655  			nano::tls_config config;
656  			config.serialize_toml (toml);
657  		}
658  		else
659  		{
660  			std::cerr << "Invalid configuration type " << type << ". Must be node or rpc." << std::endl;
661  		}
662  		if (valid_type)
663  		{
664  			std::cout << "# This is an example configuration file for Nano. Visit https:&bsol;&bsol;docs.nano.org/running-a-node/configuration/ for more information.\n#\n"
665  					  << "# Fields may need to be defined in the context of a [category] above them.\n"
666  					  << "# The desired configuration changes should be placed in config-" << type << ".toml in the node data path.\n"
667  					  << "# To change a value from its default, uncomment (erasing #) the corresponding field.\n"
668  					  << "# It is not recommended to uncomment every field, as the default value for important fields may change in the future. Only change what you need.\n"
669  					  << "# Additional information for notable configuration options is available in https:&bsol;&bsol;docs.nano.org/running-a-node/configuration/#notable-configuration-options\n";
670  			if (vm.count ("use_defaults"))
671  			{
672  				std::cout << toml.to_string () << std::endl;
673  			}
674  			else
675  			{
676  				std::cout << toml.to_string_commented_entries () << std::endl;
677  			}
678  		}
679  	}
680  	else if (vm.count ("diagnostics"))
681  	{
682  		auto inactive_node = nano::default_inactive_node (data_path, vm);
683  		std::cout << "Testing hash function" << std::endl;
684  		nano::raw_key key;
685  		key.clear ();
686  		nano::send_block send (0, 0, 0, key, 0, 0);
687  		std::cout << "Testing key derivation function" << std::endl;
688  		nano::raw_key junk1;
689  		junk1.clear ();
690  		nano::uint256_union junk2 (0);
691  		nano::kdf kdf{ inactive_node->node->config.network_params.kdf_work };
692  		kdf.phs (junk1, "", junk2);
693  		std::cout << "Testing time retrieval latency... " << std::flush;
694  		nano::timer<std::chrono::nanoseconds> timer (nano::timer_state::started);
695  		auto const iters = 2'000'000;
696  		for (auto i (0); i < iters; ++i)
697  		{
698  			(void)std::chrono::steady_clock::now ();
699  		}
700  		std::cout << timer.stop ().count () / iters << " " << timer.unit () << std::endl;
701  		std::cout << "Dumping OpenCL information" << std::endl;
702  		bool error (false);
703  		nano::opencl_environment environment (error);
704  		if (!error)
705  		{
706  			environment.dump (std::cout);
707  			std::stringstream stream;
708  			environment.dump (stream);
709  			inactive_node->node->logger.always_log (stream.str ());
710  		}
711  		else
712  		{
713  			std::cerr << "Error initializing OpenCL" << std::endl;
714  			ec = nano::error_cli::generic;
715  		}
716  	}
717  	else if (vm.count ("key_create"))
718  	{
719  		nano::keypair pair;
720  		std::cout << "Private: " << pair.prv.to_string () << std::endl
721  				  << "Public: " << pair.pub.to_string () << std::endl
722  				  << "Account: " << pair.pub.to_account () << std::endl;
723  	}
724  	else if (vm.count ("key_expand"))
725  	{
726  		if (vm.count ("key") == 1)
727  		{
728  			nano::raw_key prv;
729  			prv.decode_hex (vm["key"].as<std::string> ());
730  			nano::public_key pub (nano::pub_key (prv));
731  			std::cout << "Private: " << prv.to_string () << std::endl
732  					  << "Public: " << pub.to_string () << std::endl
733  					  << "Account: " << pub.to_account () << std::endl;
734  		}
735  		else
736  		{
737  			std::cerr << "key_expand command requires one <key> option\n";
738  			ec = nano::error_cli::invalid_arguments;
739  		}
740  	}
741  	else if (vm.count ("wallet_add_adhoc"))
742  	{
743  		if (vm.count ("wallet") == 1 && vm.count ("key") == 1)
744  		{
745  			nano::wallet_id wallet_id;
746  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
747  			{
748  				std::string password;
749  				if (vm.count ("password") > 0)
750  				{
751  					password = vm["password"].as<std::string> ();
752  				}
753  				auto inactive_node = nano::default_inactive_node (data_path, vm);
754  				auto wallet (inactive_node->node->wallets.open (wallet_id));
755  				if (wallet != nullptr)
756  				{
757  					auto transaction (wallet->wallets.tx_begin_write ());
758  					if (!wallet->enter_password (transaction, password))
759  					{
760  						nano::raw_key key;
761  						if (!key.decode_hex (vm["key"].as<std::string> ()))
762  						{
763  							wallet->store.insert_adhoc (transaction, key);
764  						}
765  						else
766  						{
767  							std::cerr << "Invalid key\n";
768  							ec = nano::error_cli::invalid_arguments;
769  						}
770  					}
771  					else
772  					{
773  						std::cerr << "Invalid password\n";
774  						ec = nano::error_cli::invalid_arguments;
775  					}
776  				}
777  				else
778  				{
779  					std::cerr << "Wallet doesn't exist\n";
780  					ec = nano::error_cli::invalid_arguments;
781  				}
782  			}
783  			else
784  			{
785  				std::cerr << "Invalid wallet id\n";
786  				ec = nano::error_cli::invalid_arguments;
787  			}
788  		}
789  		else
790  		{
791  			std::cerr << "wallet_add command requires one <wallet> option and one <key> option and optionally one <password> option\n";
792  			ec = nano::error_cli::invalid_arguments;
793  		}
794  	}
795  	else if (vm.count ("wallet_change_seed"))
796  	{
797  		if (vm.count ("wallet") == 1 && (vm.count ("seed") == 1 || vm.count ("key") == 1))
798  		{
799  			nano::wallet_id wallet_id;
800  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
801  			{
802  				std::string password;
803  				if (vm.count ("password") > 0)
804  				{
805  					password = vm["password"].as<std::string> ();
806  				}
807  				auto inactive_node = nano::default_inactive_node (data_path, vm);
808  				auto wallet (inactive_node->node->wallets.open (wallet_id));
809  				if (wallet != nullptr)
810  				{
811  					auto transaction (wallet->wallets.tx_begin_write ());
812  					if (!wallet->enter_password (transaction, password))
813  					{
814  						nano::raw_key seed;
815  						if (vm.count ("seed"))
816  						{
817  							if (seed.decode_hex (vm["seed"].as<std::string> ()))
818  							{
819  								std::cerr << "Invalid seed\n";
820  								ec = nano::error_cli::invalid_arguments;
821  							}
822  						}
823  						else if (seed.decode_hex (vm["key"].as<std::string> ()))
824  						{
825  							std::cerr << "Invalid key seed\n";
826  							ec = nano::error_cli::invalid_arguments;
827  						}
828  						if (!ec)
829  						{
830  							std::cout << "Changing seed and caching work. Please wait..." << std::endl;
831  							wallet->change_seed (transaction, seed);
832  						}
833  					}
834  					else
835  					{
836  						std::cerr << "Invalid password\n";
837  						ec = nano::error_cli::invalid_arguments;
838  					}
839  				}
840  				else
841  				{
842  					std::cerr << "Wallet doesn't exist\n";
843  					ec = nano::error_cli::invalid_arguments;
844  				}
845  			}
846  			else
847  			{
848  				std::cerr << "Invalid wallet id\n";
849  				ec = nano::error_cli::invalid_arguments;
850  			}
851  		}
852  		else
853  		{
854  			std::cerr << "wallet_change_seed command requires one <wallet> option and one <seed> option and optionally one <password> option\n";
855  			ec = nano::error_cli::invalid_arguments;
856  		}
857  	}
858  	else if (vm.count ("wallet_create"))
859  	{
860  		nano::raw_key seed_key;
861  		if (vm.count ("seed") == 1)
862  		{
863  			if (seed_key.decode_hex (vm["seed"].as<std::string> ()))
864  			{
865  				std::cerr << "Invalid seed\n";
866  				ec = nano::error_cli::invalid_arguments;
867  			}
868  		}
869  		else if (vm.count ("seed") > 1)
870  		{
871  			std::cerr << "wallet_create command allows one optional <seed> parameter\n";
872  			ec = nano::error_cli::invalid_arguments;
873  		}
874  		else if (vm.count ("key") == 1)
875  		{
876  			if (seed_key.decode_hex (vm["key"].as<std::string> ()))
877  			{
878  				std::cerr << "Invalid seed key\n";
879  				ec = nano::error_cli::invalid_arguments;
880  			}
881  		}
882  		else if (vm.count ("key") > 1)
883  		{
884  			std::cerr << "wallet_create command allows one optional <key> seed parameter\n";
885  			ec = nano::error_cli::invalid_arguments;
886  		}
887  		if (!ec)
888  		{
889  			auto inactive_node = nano::default_inactive_node (data_path, vm);
890  			auto wallet_key = nano::random_wallet_id ();
891  			auto wallet (inactive_node->node->wallets.create (wallet_key));
892  			if (wallet != nullptr)
893  			{
894  				if (vm.count ("password") > 0)
895  				{
896  					std::string password (vm["password"].as<std::string> ());
897  					auto transaction (wallet->wallets.tx_begin_write ());
898  					auto error (wallet->store.rekey (transaction, password));
899  					if (error)
900  					{
901  						std::cerr << "Password change error\n";
902  						ec = nano::error_cli::invalid_arguments;
903  					}
904  				}
905  				if (vm.count ("seed") || vm.count ("key"))
906  				{
907  					auto transaction (wallet->wallets.tx_begin_write ());
908  					wallet->change_seed (transaction, seed_key);
909  				}
910  				std::cout << wallet_key.to_string () << std::endl;
911  			}
912  			else
913  			{
914  				std::cerr << "Wallet creation error\n";
915  				ec = nano::error_cli::invalid_arguments;
916  			}
917  		}
918  	}
919  	else if (vm.count ("wallet_decrypt_unsafe"))
920  	{
921  		if (vm.count ("wallet") == 1)
922  		{
923  			std::string password;
924  			if (vm.count ("password") == 1)
925  			{
926  				password = vm["password"].as<std::string> ();
927  			}
928  			nano::wallet_id wallet_id;
929  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
930  			{
931  				auto inactive_node = nano::default_inactive_node (data_path, vm);
932  				auto node = inactive_node->node;
933  				auto existing (inactive_node->node->wallets.items.find (wallet_id));
934  				if (existing != inactive_node->node->wallets.items.end ())
935  				{
936  					auto transaction (existing->second->wallets.tx_begin_write ());
937  					if (!existing->second->enter_password (transaction, password))
938  					{
939  						nano::raw_key seed;
940  						existing->second->store.seed (seed, transaction);
941  						std::cout << boost::str (boost::format ("Seed: %1%\n") % seed.to_string ());
942  						for (auto i (existing->second->store.begin (transaction)), m (existing->second->store.end ()); i != m; ++i)
943  						{
944  							nano::account const & account (i->first);
945  							nano::raw_key key;
946  							auto error (existing->second->store.fetch (transaction, account, key));
947  							(void)error;
948  							debug_assert (!error);
949  							std::cout << boost::str (boost::format ("Pub: %1% Prv: %2%\n") % account.to_account () % key.to_string ());
950  							if (nano::pub_key (key) != account)
951  							{
952  								std::cerr << boost::str (boost::format ("Invalid private key %1%\n") % key.to_string ());
953  							}
954  						}
955  					}
956  					else
957  					{
958  						std::cerr << "Invalid password\n";
959  						ec = nano::error_cli::invalid_arguments;
960  					}
961  				}
962  				else
963  				{
964  					std::cerr << "Wallet doesn't exist\n";
965  					ec = nano::error_cli::invalid_arguments;
966  				}
967  			}
968  			else
969  			{
970  				std::cerr << "Invalid wallet id\n";
971  				ec = nano::error_cli::invalid_arguments;
972  			}
973  		}
974  		else
975  		{
976  			std::cerr << "wallet_decrypt_unsafe requires one <wallet> option\n";
977  			ec = nano::error_cli::invalid_arguments;
978  		}
979  	}
980  	else if (vm.count ("wallet_destroy"))
981  	{
982  		if (vm.count ("wallet") == 1)
983  		{
984  			nano::wallet_id wallet_id;
985  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
986  			{
987  				auto inactive_node = nano::default_inactive_node (data_path, vm);
988  				auto node = inactive_node->node;
989  				if (node->wallets.items.find (wallet_id) != node->wallets.items.end ())
990  				{
991  					node->wallets.destroy (wallet_id);
992  				}
993  				else
994  				{
995  					std::cerr << "Wallet doesn't exist\n";
996  					ec = nano::error_cli::invalid_arguments;
997  				}
998  			}
999  			else
1000  			{
1001  				std::cerr << "Invalid wallet id\n";
1002  				ec = nano::error_cli::invalid_arguments;
1003  			}
1004  		}
1005  		else
1006  		{
1007  			std::cerr << "wallet_destroy requires one <wallet> option\n";
1008  			ec = nano::error_cli::invalid_arguments;
1009  		}
1010  	}
1011  	else if (vm.count ("wallet_import"))
1012  	{
1013  		if (vm.count ("file") == 1)
1014  		{
1015  			std::string filename (vm["file"].as<std::string> ());
1016  			std::ifstream stream;
1017  			stream.open (filename.c_str ());
1018  			if (!stream.fail ())
1019  			{
1020  				std::stringstream contents;
1021  				contents << stream.rdbuf ();
1022  				std::string password;
1023  				if (vm.count ("password") == 1)
1024  				{
1025  					password = vm["password"].as<std::string> ();
1026  				}
1027  				bool forced (false);
1028  				if (vm.count ("force") == 1)
1029  				{
1030  					forced = vm["force"].as<bool> ();
1031  				}
1032  				if (vm.count ("wallet") == 1)
1033  				{
1034  					nano::wallet_id wallet_id;
1035  					if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
1036  					{
1037  						auto inactive_node = nano::default_inactive_node (data_path, vm);
1038  						auto node = inactive_node->node;
1039  						auto existing (node->wallets.items.find (wallet_id));
1040  						if (existing != node->wallets.items.end ())
1041  						{
1042  							bool valid (false);
1043  							{
1044  								auto transaction (node->wallets.tx_begin_write ());
1045  								valid = existing->second->store.valid_password (transaction);
1046  								if (!valid)
1047  								{
1048  									valid = !existing->second->enter_password (transaction, password);
1049  								}
1050  							}
1051  							if (valid)
1052  							{
1053  								if (existing->second->import (contents.str (), password))
1054  								{
1055  									std::cerr << "Unable to import wallet\n";
1056  									ec = nano::error_cli::invalid_arguments;
1057  								}
1058  								else
1059  								{
1060  									std::cout << "Import completed\n";
1061  								}
1062  							}
1063  							else
1064  							{
1065  								std::cerr << boost::str (boost::format ("Invalid password for wallet %1%\nNew wallet should have empty (default) password or passwords for new wallet & json file should match\n") % wallet_id.to_string ());
1066  								ec = nano::error_cli::invalid_arguments;
1067  							}
1068  						}
1069  						else
1070  						{
1071  							if (!forced)
1072  							{
1073  								std::cerr << "Wallet doesn't exist\n";
1074  								ec = nano::error_cli::invalid_arguments;
1075  							}
1076  							else
1077  							{
1078  								bool error (true);
1079  								{
1080  									nano::lock_guard<nano::mutex> lock{ node->wallets.mutex };
1081  									auto transaction (node->wallets.tx_begin_write ());
1082  									nano::wallet wallet (error, transaction, node->wallets, wallet_id.to_string (), contents.str ());
1083  								}
1084  								if (error)
1085  								{
1086  									std::cerr << "Unable to import wallet\n";
1087  									ec = nano::error_cli::invalid_arguments;
1088  								}
1089  								else
1090  								{
1091  									node->wallets.reload ();
1092  									nano::lock_guard<nano::mutex> lock{ node->wallets.mutex };
1093  									release_assert (node->wallets.items.find (wallet_id) != node->wallets.items.end ());
1094  									std::cout << "Import completed\n";
1095  								}
1096  							}
1097  						}
1098  					}
1099  					else
1100  					{
1101  						std::cerr << "Invalid wallet id\n";
1102  						ec = nano::error_cli::invalid_arguments;
1103  					}
1104  				}
1105  				else
1106  				{
1107  					std::cerr << "wallet_import requires one <wallet> option\n";
1108  					ec = nano::error_cli::invalid_arguments;
1109  				}
1110  			}
1111  			else
1112  			{
1113  				std::cerr << "Unable to open <file>\n";
1114  				ec = nano::error_cli::invalid_arguments;
1115  			}
1116  		}
1117  		else
1118  		{
1119  			std::cerr << "wallet_import requires one <file> option\n";
1120  			ec = nano::error_cli::invalid_arguments;
1121  		}
1122  	}
1123  	else if (vm.count ("wallet_list"))
1124  	{
1125  		auto inactive_node = nano::default_inactive_node (data_path, vm);
1126  		auto node = inactive_node->node;
1127  		for (auto i (node->wallets.items.begin ()), n (node->wallets.items.end ()); i != n; ++i)
1128  		{
1129  			std::cout << boost::str (boost::format ("Wallet ID: %1%\n") % i->first.to_string ());
1130  			auto transaction (i->second->wallets.tx_begin_read ());
1131  			for (auto j (i->second->store.begin (transaction)), m (i->second->store.end ()); j != m; ++j)
1132  			{
1133  				std::cout << nano::account (j->first).to_account () << '\n';
1134  			}
1135  		}
1136  	}
1137  	else if (vm.count ("wallet_remove"))
1138  	{
1139  		if (vm.count ("wallet") == 1 && vm.count ("account") == 1)
1140  		{
1141  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1142  			auto node = inactive_node->node;
1143  			nano::wallet_id wallet_id;
1144  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
1145  			{
1146  				auto wallet (node->wallets.items.find (wallet_id));
1147  				if (wallet != node->wallets.items.end ())
1148  				{
1149  					nano::account account_id;
1150  					if (!account_id.decode_account (vm["account"].as<std::string> ()))
1151  					{
1152  						auto transaction (wallet->second->wallets.tx_begin_write ());
1153  						auto account (wallet->second->store.find (transaction, account_id));
1154  						if (account != wallet->second->store.end ())
1155  						{
1156  							wallet->second->store.erase (transaction, account_id);
1157  						}
1158  						else
1159  						{
1160  							std::cerr << "Account not found in wallet\n";
1161  							ec = nano::error_cli::invalid_arguments;
1162  						}
1163  					}
1164  					else
1165  					{
1166  						std::cerr << "Invalid account id\n";
1167  						ec = nano::error_cli::invalid_arguments;
1168  					}
1169  				}
1170  				else
1171  				{
1172  					std::cerr << "Wallet not found\n";
1173  					ec = nano::error_cli::invalid_arguments;
1174  				}
1175  			}
1176  			else
1177  			{
1178  				std::cerr << "Invalid wallet id\n";
1179  				ec = nano::error_cli::invalid_arguments;
1180  			}
1181  		}
1182  		else
1183  		{
1184  			std::cerr << "wallet_remove command requires one <wallet> and one <account> option\n";
1185  			ec = nano::error_cli::invalid_arguments;
1186  		}
1187  	}
1188  	else if (vm.count ("wallet_representative_get"))
1189  	{
1190  		if (vm.count ("wallet") == 1)
1191  		{
1192  			nano::wallet_id wallet_id;
1193  			if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
1194  			{
1195  				auto inactive_node = nano::default_inactive_node (data_path, vm);
1196  				auto node = inactive_node->node;
1197  				auto wallet (node->wallets.items.find (wallet_id));
1198  				if (wallet != node->wallets.items.end ())
1199  				{
1200  					auto transaction (wallet->second->wallets.tx_begin_read ());
1201  					auto representative (wallet->second->store.representative (transaction));
1202  					std::cout << boost::str (boost::format ("Representative: %1%\n") % representative.to_account ());
1203  				}
1204  				else
1205  				{
1206  					std::cerr << "Wallet not found\n";
1207  					ec = nano::error_cli::invalid_arguments;
1208  				}
1209  			}
1210  			else
1211  			{
1212  				std::cerr << "Invalid wallet id\n";
1213  				ec = nano::error_cli::invalid_arguments;
1214  			}
1215  		}
1216  		else
1217  		{
1218  			std::cerr << "wallet_representative_get requires one <wallet> option\n";
1219  			ec = nano::error_cli::invalid_arguments;
1220  		}
1221  	}
1222  	else if (vm.count ("wallet_representative_set"))
1223  	{
1224  		if (vm.count ("wallet") == 1)
1225  		{
1226  			if (vm.count ("account") == 1)
1227  			{
1228  				nano::wallet_id wallet_id;
1229  				if (!wallet_id.decode_hex (vm["wallet"].as<std::string> ()))
1230  				{
1231  					nano::account account;
1232  					if (!account.decode_account (vm["account"].as<std::string> ()))
1233  					{
1234  						auto inactive_node = nano::default_inactive_node (data_path, vm);
1235  						auto node = inactive_node->node;
1236  						auto wallet (node->wallets.items.find (wallet_id));
1237  						if (wallet != node->wallets.items.end ())
1238  						{
1239  							auto transaction (wallet->second->wallets.tx_begin_write ());
1240  							wallet->second->store.representative_set (transaction, account);
1241  						}
1242  						else
1243  						{
1244  							std::cerr << "Wallet not found\n";
1245  							ec = nano::error_cli::invalid_arguments;
1246  						}
1247  					}
1248  					else
1249  					{
1250  						std::cerr << "Invalid account\n";
1251  						ec = nano::error_cli::invalid_arguments;
1252  					}
1253  				}
1254  				else
1255  				{
1256  					std::cerr << "Invalid wallet id\n";
1257  					ec = nano::error_cli::invalid_arguments;
1258  				}
1259  			}
1260  			else
1261  			{
1262  				std::cerr << "wallet_representative_set requires one <account> option\n";
1263  				ec = nano::error_cli::invalid_arguments;
1264  			}
1265  		}
1266  		else
1267  		{
1268  			std::cerr << "wallet_representative_set requires one <wallet> option\n";
1269  			ec = nano::error_cli::invalid_arguments;
1270  		}
1271  	}
1272  	else
1273  	{
1274  		ec = nano::error_cli::unknown_command;
1275  	}
1276  	return ec;
1277  }
1278  std::unique_ptr<nano::inactive_node> nano::default_inactive_node (boost::filesystem::path const & path_a, boost::program_options::variables_map const & vm_a)
1279  {
1280  	auto node_flags = nano::inactive_node_flag_defaults ();
1281  	nano::update_flags (node_flags, vm_a);
1282  	return std::make_unique<nano::inactive_node> (path_a, node_flags);
1283  }
1284  namespace
1285  {
1286  void reset_confirmation_heights (nano::write_transaction const & transaction, nano::ledger_constants & constants, nano::store & store)
1287  {
1288  	store.confirmation_height.clear (transaction);
1289  	store.confirmation_height.put (transaction, constants.genesis->account (), { 1, constants.genesis->hash () });
1290  }
1291  bool is_using_rocksdb (boost::filesystem::path const & data_path, boost::program_options::variables_map const & vm, std::error_code & ec)
1292  {
1293  	nano::network_params network_params{ nano::network_constants::active_network };
1294  	nano::daemon_config config{ data_path, network_params };
1295  	auto config_arg (vm.find ("config"));
1296  	std::vector<std::string> config_overrides;
1297  	if (config_arg != vm.end ())
1298  	{
1299  		config_overrides = nano::config_overrides (config_arg->second.as<std::vector<nano::config_key_value_pair>> ());
1300  	}
1301  	auto error = nano::read_node_config_toml (data_path, config, config_overrides);
1302  	if (!error)
1303  	{
1304  		return config.node.rocksdb_config.enable;
1305  	}
1306  	else
1307  	{
1308  		ec = nano::error_cli::reading_config;
1309  	}
1310  	return false;
1311  }
1312  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_CONCEPTS_HPP_INCLUDED
2  #define BOOST_REGEX_CONCEPTS_HPP_INCLUDED
3  #include <boost/concept_archetype.hpp>
4  #include <boost/concept_check.hpp>
5  #include <boost/type_traits/is_enum.hpp>
6  #include <boost/type_traits/is_base_and_derived.hpp>
7  #include <boost/static_assert.hpp>
8  #ifndef BOOST_TEST_TR1_REGEX
9  #include <boost/regex.hpp>
10  #endif
11  #include <bitset>
12  #include <vector>
13  #include <ostream>
14  #ifdef BOOST_REGEX_CXX03
15  #define RW_NS boost
16  #else
17  #define RW_NS std
18  #endif
19  namespace boost{
20  typedef std::bitset<512> bitmask_archetype;
21  struct char_architype
22  {
23     char_architype();
24     char_architype(const char_architype&);
25     char_architype& operator=(const char_architype&);
26     char_architype(unsigned long val);
27     bool operator==(const char_architype&)const;
28     bool operator!=(const char_architype&)const;
29     bool operator<(const char_architype&)const;
30     bool operator<=(const char_architype&)const;
31     bool operator>=(const char_architype&)const;
32     bool operator>(const char_architype&)const;
33     operator long()const;
34  };
35  inline long hash_value(char_architype val)
36  {  return val;  }
37  } 
38  namespace std{
39     template<> struct char_traits<boost::char_architype>
40     {
41        typedef boost::char_architype char_type;
42     };
43  }
44  template <class T>
45  class allocator_architype
46  {
47  public:
48     typedef T* pointer;
49     typedef const T* const_pointer;
50     typedef T& reference;
51     typedef const T& const_reference;
52     typedef T value_type;
53     typedef unsigned size_type;
54     typedef int difference_type;
55     template <class U>
56     struct rebind
57     {
58        typedef allocator_architype<U> other;
59     };
60     pointer address(reference r){ return &r; }
61     const_pointer address(const_reference r) { return &r; }
62     pointer allocate(size_type n) { return static_cast<pointer>(std::malloc(n)); }
63     pointer allocate(size_type n, pointer) { return static_cast<pointer>(std::malloc(n)); }
64     void deallocate(pointer p, size_type) { std::free(p); }
65     size_type max_size()const { return UINT_MAX; }
66     allocator_architype(){}
67     allocator_architype(const allocator_architype&){}
68     template <class Other>
69     allocator_architype(const allocator_architype<Other>&){}
70     void construct(pointer p, const_reference r) { new (p)T(r); }
71     void destroy(pointer p) { p->~T(); }
72  };
73  template <class T>
74  bool operator == (const allocator_architype<T>&, const allocator_architype<T>&) {return true; }
75  template <class T>
76  bool operator != (const allocator_architype<T>&, const allocator_architype<T>&) { return false; }
77  namespace boost{
78  template <class charT>
79  struct regex_traits_architype
80  {
81  public:
82     regex_traits_architype(){}
83     typedef charT char_type;
84     typedef std::vector<char_type> string_type;
85     typedef copy_constructible_archetype<assignable_archetype<> > locale_type;
86     typedef bitmask_archetype char_class_type;
87     static std::size_t length(const char_type* ) { return 0; }
88     charT translate(charT ) const { return charT(); }
89     charT translate_nocase(charT ) const { return static_object<charT>::get(); }
90     template <class ForwardIterator>
91     string_type transform(ForwardIterator , ForwardIterator ) const
92     { return static_object<string_type>::get(); }
93     template <class ForwardIterator>
94     string_type transform_primary(ForwardIterator , ForwardIterator ) const
95     { return static_object<string_type>::get(); }
96     template <class ForwardIterator>
97     char_class_type lookup_classname(ForwardIterator , ForwardIterator ) const
98     { return static_object<char_class_type>::get(); }
99     template <class ForwardIterator>
100     string_type lookup_collatename(ForwardIterator , ForwardIterator ) const
101     { return static_object<string_type>::get(); }
102     bool isctype(charT, char_class_type) const
103     { return false; }
104     int value(charT, int) const
105     { return 0; }
106     locale_type imbue(locale_type l)
107     { return l; }
108     locale_type getloc()const
109     { return static_object<locale_type>::get(); }
110  private:
111     regex_traits_architype(const regex_traits_architype&){}
112     regex_traits_architype& operator=(const regex_traits_architype&){ return *this; }
113  };
114  #ifndef BOOST_TEST_TR1_REGEX
115  namespace global_regex_namespace = ::boost;
116  #else
117  namespace global_regex_namespace = ::std::tr1;
118  #endif
119  template <class Bitmask>
120  struct BitmaskConcept
121  {
122     void constraints() 
123     {
124        function_requires<CopyConstructibleConcept<Bitmask> >();
125        function_requires<AssignableConcept<Bitmask> >();
126        m_mask1 = m_mask2 | m_mask3;
127        m_mask1 = m_mask2 & m_mask3;
128        m_mask1 = m_mask2 ^ m_mask3;
129        m_mask1 = ~m_mask2;
130        m_mask1 |= m_mask2;
131        m_mask1 &= m_mask2;
132        m_mask1 ^= m_mask2;
133     }
134     Bitmask m_mask1, m_mask2, m_mask3;
135  };
136  template <class traits>
137  struct RegexTraitsConcept
138  {
139     RegexTraitsConcept();
140     typedef typename traits::char_type char_type;
141     typedef typename traits::string_type string_type;
142     typedef typename traits::locale_type locale_type;
143     typedef typename traits::char_class_type char_class_type;
144     void constraints() 
145     {
146        function_requires<RandomAccessContainerConcept<string_type> >();
147        function_requires<DefaultConstructibleConcept<locale_type> >();
148        function_requires<CopyConstructibleConcept<locale_type> >();
149        function_requires<AssignableConcept<locale_type> >();
150        function_requires<BitmaskConcept<char_class_type> >();
151        std::size_t n = traits::length(m_pointer);
152        ignore_unused_variable_warning(n);
153        char_type c = m_ctraits.translate(m_char);
154        ignore_unused_variable_warning(c);
155        c = m_ctraits.translate_nocase(m_char);
156        string_type s1 = m_ctraits.transform(m_pointer, m_pointer);
157        ignore_unused_variable_warning(s1);
158        string_type s2 = m_ctraits.transform_primary(m_pointer, m_pointer);
159        ignore_unused_variable_warning(s2);
160        char_class_type cc = m_ctraits.lookup_classname(m_pointer, m_pointer);
161        ignore_unused_variable_warning(cc);
162        string_type s3 = m_ctraits.lookup_collatename(m_pointer, m_pointer);
163        ignore_unused_variable_warning(s3);
164        bool b = m_ctraits.isctype(m_char, cc);
165        ignore_unused_variable_warning(b);
166        int v = m_ctraits.value(m_char, 16);
167        ignore_unused_variable_warning(v);
168        locale_type l(m_ctraits.getloc());
169        m_traits.imbue(l);
170        ignore_unused_variable_warning(l);
171     }
172     traits m_traits;
173     const traits m_ctraits;
174     const char_type* m_pointer;
175     char_type m_char;
176  private:
177     RegexTraitsConcept& operator=(RegexTraitsConcept&);
178  };
179  template <class Regex>
180  struct regex_traits_computer;
181  template <class charT, class traits>
182  struct regex_traits_computer< global_regex_namespace::basic_regex<charT, traits> >
183  {
184     typedef traits type;
185  };
186  template <class Regex>
187  struct BaseRegexConcept
188  {
189     typedef typename Regex::value_type value_type;
190     typedef typename Regex::flag_type flag_type;
191     typedef typename Regex::locale_type locale_type;
192     typedef input_iterator_archetype<value_type> input_iterator_type;
193     typedef const value_type* pointer_type;
194     typedef bidirectional_iterator_archetype<value_type> BidiIterator;
195     typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;
196     typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;
197     typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;
198     typedef output_iterator_archetype<value_type> OutIterator;
199     typedef typename regex_traits_computer<Regex>::type traits_type;
200     typedef global_regex_namespace::regex_iterator<BidiIterator, value_type, traits_type> regex_iterator_type;
201     typedef global_regex_namespace::regex_token_iterator<BidiIterator, value_type, traits_type> regex_token_iterator_type;
202     void global_constraints()
203     {
204        function_requires<BitmaskConcept<global_regex_namespace::regex_constants::syntax_option_type> >();
205        global_regex_namespace::regex_constants::syntax_option_type opts
206           = global_regex_namespace::regex_constants::icase
207           | global_regex_namespace::regex_constants::nosubs
208           | global_regex_namespace::regex_constants::optimize
209           | global_regex_namespace::regex_constants::collate
210           | global_regex_namespace::regex_constants::ECMAScript
211           | global_regex_namespace::regex_constants::basic
212           | global_regex_namespace::regex_constants::extended
213           | global_regex_namespace::regex_constants::awk
214           | global_regex_namespace::regex_constants::grep
215           | global_regex_namespace::regex_constants::egrep;
216        ignore_unused_variable_warning(opts);
217        function_requires<BitmaskConcept<global_regex_namespace::regex_constants::match_flag_type> >();
218        global_regex_namespace::regex_constants::match_flag_type mopts
219           = global_regex_namespace::regex_constants::match_default
220           | global_regex_namespace::regex_constants::match_not_bol
221           | global_regex_namespace::regex_constants::match_not_eol
222           | global_regex_namespace::regex_constants::match_not_bow
223           | global_regex_namespace::regex_constants::match_not_eow
224           | global_regex_namespace::regex_constants::match_any
225           | global_regex_namespace::regex_constants::match_not_null
226           | global_regex_namespace::regex_constants::match_continuous
227           | global_regex_namespace::regex_constants::match_prev_avail
228           | global_regex_namespace::regex_constants::format_default
229           | global_regex_namespace::regex_constants::format_sed
230           | global_regex_namespace::regex_constants::format_no_copy
231           | global_regex_namespace::regex_constants::format_first_only;
232        ignore_unused_variable_warning(mopts);
233        BOOST_STATIC_ASSERT((::boost::is_enum<global_regex_namespace::regex_constants::error_type>::value));
234        global_regex_namespace::regex_constants::error_type e1 = global_regex_namespace::regex_constants::error_collate;
235        ignore_unused_variable_warning(e1);
236        e1 = global_regex_namespace::regex_constants::error_ctype;
237        ignore_unused_variable_warning(e1);
238        e1 = global_regex_namespace::regex_constants::error_escape;
239        ignore_unused_variable_warning(e1);
240        e1 = global_regex_namespace::regex_constants::error_backref;
241        ignore_unused_variable_warning(e1);
242        e1 = global_regex_namespace::regex_constants::error_brack;
243        ignore_unused_variable_warning(e1);
244        e1 = global_regex_namespace::regex_constants::error_paren;
245        ignore_unused_variable_warning(e1);
246        e1 = global_regex_namespace::regex_constants::error_brace;
247        ignore_unused_variable_warning(e1);
248        e1 = global_regex_namespace::regex_constants::error_badbrace;
249        ignore_unused_variable_warning(e1);
250        e1 = global_regex_namespace::regex_constants::error_range;
251        ignore_unused_variable_warning(e1);
252        e1 = global_regex_namespace::regex_constants::error_space;
253        ignore_unused_variable_warning(e1);
254        e1 = global_regex_namespace::regex_constants::error_badrepeat;
255        ignore_unused_variable_warning(e1);
256        e1 = global_regex_namespace::regex_constants::error_complexity;
257        ignore_unused_variable_warning(e1);
258        e1 = global_regex_namespace::regex_constants::error_stack;
259        ignore_unused_variable_warning(e1);
260        BOOST_STATIC_ASSERT((::boost::is_base_and_derived<std::runtime_error, global_regex_namespace::regex_error>::value  ));
261        const global_regex_namespace::regex_error except(e1);
262        e1 = except.code();
263        typedef typename Regex::value_type regex_value_type;
264        function_requires< RegexTraitsConcept<global_regex_namespace::regex_traits<char> > >();
265        function_requires< BaseRegexConcept<global_regex_namespace::basic_regex<char> > >();
266     }
267     void constraints() 
268     {
269        global_constraints();
270        BOOST_STATIC_ASSERT((::boost::is_same< flag_type, global_regex_namespace::regex_constants::syntax_option_type>::value));
271        flag_type opts
272           = Regex::icase
273           | Regex::nosubs
274           | Regex::optimize
275           | Regex::collate
276           | Regex::ECMAScript
277           | Regex::basic
278           | Regex::extended
279           | Regex::awk
280           | Regex::grep
281           | Regex::egrep;
282        ignore_unused_variable_warning(opts);
283        function_requires<DefaultConstructibleConcept<Regex> >();
284        function_requires<CopyConstructibleConcept<Regex> >();
285        Regex e1(m_pointer);
286        ignore_unused_variable_warning(e1);
287        Regex e2(m_pointer, m_flags);
288        ignore_unused_variable_warning(e2);
289        Regex e3(m_pointer, m_size, m_flags);
290        ignore_unused_variable_warning(e3);
291        Regex e4(in1, in2);
292        ignore_unused_variable_warning(e4);
293        Regex e5(in1, in2, m_flags);
294        ignore_unused_variable_warning(e5);
295        Regex e;
296        e = m_pointer;
297        e = e1;
298        e.assign(e1);
299        e.assign(m_pointer);
300        e.assign(m_pointer, m_flags);
301        e.assign(m_pointer, m_size, m_flags);
302        e.assign(in1, in2);
303        e.assign(in1, in2, m_flags);
304        const Regex ce;
305        typename Regex::size_type i = ce.mark_count();
306        ignore_unused_variable_warning(i);
307        m_flags = ce.flags();
308        e.imbue(ce.getloc());
309        e.swap(e1);
310        global_regex_namespace::swap(e, e1);
311        BOOST_STATIC_ASSERT((::boost::is_base_and_derived<std::pair<BidiIterator, BidiIterator>, sub_match_type>::value));
312        typedef typename sub_match_type::value_type sub_value_type;
313        typedef typename sub_match_type::difference_type sub_diff_type;
314        typedef typename sub_match_type::iterator sub_iter_type;
315        BOOST_STATIC_ASSERT((::boost::is_same<sub_value_type, value_type>::value));
316        BOOST_STATIC_ASSERT((::boost::is_same<sub_iter_type, BidiIterator>::value));
317        bool b = m_sub.matched;
318        ignore_unused_variable_warning(b);
319        BidiIterator bi = m_sub.first;
320        ignore_unused_variable_warning(bi);
321        bi = m_sub.second;
322        ignore_unused_variable_warning(bi);
323        sub_diff_type diff = m_sub.length();
324        ignore_unused_variable_warning(diff);
325        typedef typename match_results_type::value_type mr_value_type;
326        typedef typename match_results_type::const_reference mr_const_reference;
327        typedef typename match_results_type::reference mr_reference;
328        typedef typename match_results_type::const_iterator mr_const_iterator;
329        typedef typename match_results_type::iterator mr_iterator;
330        typedef typename match_results_type::difference_type mr_difference_type;
331        typedef typename match_results_type::size_type mr_size_type;
332        typedef typename match_results_type::allocator_type mr_allocator_type;
333        typedef typename match_results_type::char_type mr_char_type;
334        typedef typename match_results_type::string_type mr_string_type;
335        match_results_type m1;
336        mr_allocator_type at;
337        match_results_type m2(at);
338        match_results_type m3(m1);
339        m1 = m2;
340        int ival = 0;
341        mr_size_type mrs = m_cresults.size();
342        ignore_unused_variable_warning(mrs);
343        mrs = m_cresults.max_size();
344        ignore_unused_variable_warning(mrs);
345        b = m_cresults.empty();
346        ignore_unused_variable_warning(b);
347        mr_difference_type mrd = m_cresults.length();
348        ignore_unused_variable_warning(mrd);
349        mrd = m_cresults.length(ival);
350        ignore_unused_variable_warning(mrd);
351        mrd = m_cresults.position();
352        ignore_unused_variable_warning(mrd);
353        mrd = m_cresults.position(mrs);
354        ignore_unused_variable_warning(mrd);
355        mr_const_reference mrcr = m_cresults[ival];
356        ignore_unused_variable_warning(mrcr);
357        mr_const_reference mrcr2 = m_cresults.prefix();
358        ignore_unused_variable_warning(mrcr2);
359        mr_const_reference mrcr3 = m_cresults.suffix();
360        ignore_unused_variable_warning(mrcr3);
361        mr_const_iterator mrci = m_cresults.begin();
362        ignore_unused_variable_warning(mrci);
363        mrci = m_cresults.end();
364        ignore_unused_variable_warning(mrci);
365        (void) m_cresults.get_allocator();
366        m_results.swap(m_results);
367        global_regex_namespace::swap(m_results, m_results);
368        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e);
369        ignore_unused_variable_warning(b);
370        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e, m_mft);
371        ignore_unused_variable_warning(b);
372        b = global_regex_namespace::regex_match(m_in, m_in, e);
373        ignore_unused_variable_warning(b);
374        b = global_regex_namespace::regex_match(m_in, m_in, e, m_mft);
375        ignore_unused_variable_warning(b);
376        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e);
377        ignore_unused_variable_warning(b);
378        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e, m_mft);
379        ignore_unused_variable_warning(b);
380        b = global_regex_namespace::regex_match(m_pointer, e);
381        ignore_unused_variable_warning(b);
382        b = global_regex_namespace::regex_match(m_pointer, e, m_mft);
383        ignore_unused_variable_warning(b);
384        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e);
385        ignore_unused_variable_warning(b);
386        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e, m_mft);
387        ignore_unused_variable_warning(b);
388        b = global_regex_namespace::regex_search(m_in, m_in, e);
389        ignore_unused_variable_warning(b);
390        b = global_regex_namespace::regex_search(m_in, m_in, e, m_mft);
391        ignore_unused_variable_warning(b);
392        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e);
393        ignore_unused_variable_warning(b);
394        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e, m_mft);
395        ignore_unused_variable_warning(b);
396        b = global_regex_namespace::regex_search(m_pointer, e);
397        ignore_unused_variable_warning(b);
398        b = global_regex_namespace::regex_search(m_pointer, e, m_mft);
399        ignore_unused_variable_warning(b);
400        typedef typename regex_iterator_type::regex_type rit_regex_type;
401        typedef typename regex_iterator_type::value_type rit_value_type;
402        typedef typename regex_iterator_type::difference_type rit_difference_type;
403        typedef typename regex_iterator_type::pointer rit_pointer;
404        typedef typename regex_iterator_type::reference rit_reference;
405        typedef typename regex_iterator_type::iterator_category rit_iterator_category;
406        BOOST_STATIC_ASSERT((::boost::is_same<rit_regex_type, Regex>::value));
407        BOOST_STATIC_ASSERT((::boost::is_same<rit_value_type, match_results_default_type>::value));
408        BOOST_STATIC_ASSERT((::boost::is_same<rit_difference_type, std::ptrdiff_t>::value));
409        BOOST_STATIC_ASSERT((::boost::is_same<rit_pointer, const match_results_default_type*>::value));
410        BOOST_STATIC_ASSERT((::boost::is_same<rit_reference, const match_results_default_type&>::value));
411        BOOST_STATIC_ASSERT((::boost::is_convertible<rit_iterator_category*, std::forward_iterator_tag*>::value));
412        function_requires<ForwardIteratorConcept<regex_iterator_type> >();
413        regex_iterator_type iter1(m_in, m_in, e);
414        ignore_unused_variable_warning(iter1);
<span onclick='openModal()' class='match'>415        regex_iterator_type iter2(m_in, m_in, e, m_mft);
416        ignore_unused_variable_warning(iter2);
417        typedef typename regex_token_iterator_type::regex_type rtit_regex_type;
418        typedef typename regex_token_iterator_type::value_type rtit_value_type;
419        typedef typename regex_token_iterator_type::difference_type rtit_difference_type;
420        typedef typename regex_token_iterator_type::pointer rtit_pointer;
421        typedef typename regex_token_iterator_type::reference rtit_reference;
422        typedef typename regex_token_iterator_type::iterator_category rtit_iterator_category;
423        BOOST_STATIC_ASSERT((::boost::is_same<rtit_regex_type, Regex>::value));
424        BOOST_STATIC_ASSERT((::boost::is_same<rtit_value_type, sub_match_type>::value));
425        BOOST_STATIC_ASSERT((::boost::is_same<rtit_difference_type, std::ptrdiff_t>::value));
426        BOOST_STATIC_ASSERT((::boost::is_same<rtit_pointer, const sub_match_type*>::value));
427        BOOST_STATIC_ASSERT((::boost::is_same<rtit_reference, const sub_match_type&>::value));
428        BOOST_STATIC_ASSERT((::boost::is_convertible<rtit_iterator_category*, std::forward_iterator_tag*>::value));
429        function_requires<ForwardIteratorConcept<regex_token_iterator_type> >();
430        regex_token_iterator_type ti1(m_in, m_in, e);
</span>431        ignore_unused_variable_warning(ti1);
432        regex_token_iterator_type ti2(m_in, m_in, e, 0);
433        ignore_unused_variable_warning(ti2);
434        regex_token_iterator_type ti3(m_in, m_in, e, 0, m_mft);
435        ignore_unused_variable_warning(ti3);
436        std::vector<int> subs;
437        regex_token_iterator_type ti4(m_in, m_in, e, subs);
438        ignore_unused_variable_warning(ti4);
439        regex_token_iterator_type ti5(m_in, m_in, e, subs, m_mft);
440        ignore_unused_variable_warning(ti5);
441        static const int i_array[3] = { 1, 2, 3, };
442        regex_token_iterator_type ti6(m_in, m_in, e, i_array);
443        ignore_unused_variable_warning(ti6);
444        regex_token_iterator_type ti7(m_in, m_in, e, i_array, m_mft);
445        ignore_unused_variable_warning(ti7);
446     }
447     pointer_type m_pointer;
448     flag_type m_flags;
449     std::size_t m_size;
450     input_iterator_type in1, in2;
451     const sub_match_type m_sub;
452     const value_type m_char;
453     match_results_type m_results;
454     const match_results_type m_cresults;
455     OutIterator m_out;
456     BidiIterator m_in;
457     global_regex_namespace::regex_constants::match_flag_type m_mft;
458     global_regex_namespace::match_results<
459        pointer_type, 
460        allocator_architype<global_regex_namespace::sub_match<pointer_type> > > 
461        m_pmatch;
462     BaseRegexConcept();
463     BaseRegexConcept(const BaseRegexConcept&);
464     BaseRegexConcept& operator=(const BaseRegexConcept&);
465  };
466  template <class Regex>
467  struct RegexConcept
468  {
469     typedef typename Regex::value_type value_type;
470     typedef typename Regex::flag_type flag_type;
471     typedef typename Regex::locale_type locale_type;
472     typedef const value_type* pointer_type;
473     typedef std::basic_string<value_type> string_type;
474     typedef boost::bidirectional_iterator_archetype<value_type> BidiIterator;
475     typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;
476     typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;
477     typedef output_iterator_archetype<value_type> OutIterator;
478     void constraints() 
479     {
480        function_requires<BaseRegexConcept<Regex> >();
481        Regex e1(m_string);
482        ignore_unused_variable_warning(e1);
483        Regex e2(m_string, m_flags);
484        ignore_unused_variable_warning(e2);
485        Regex e;
486        e = m_string;
487        e.assign(m_string);
488        e.assign(m_string, m_flags);
489        string_type s(m_sub);
490        ignore_unused_variable_warning(s);
491        s = m_sub.str();
492        ignore_unused_variable_warning(s);
493        int i = m_sub.compare(m_string);
494        ignore_unused_variable_warning(i);
495        int i2 = m_sub.compare(m_sub);
496        ignore_unused_variable_warning(i2);
497        i2 = m_sub.compare(m_pointer);
498        ignore_unused_variable_warning(i2);
499        bool b = m_sub == m_sub;
500        ignore_unused_variable_warning(b);
501        b = m_sub != m_sub;
502        ignore_unused_variable_warning(b);
503        b = m_sub <= m_sub;
504        ignore_unused_variable_warning(b);
505        b = m_sub <= m_sub;
506        ignore_unused_variable_warning(b);
507        b = m_sub > m_sub;
508        ignore_unused_variable_warning(b);
509        b = m_sub >= m_sub;
510        ignore_unused_variable_warning(b);
511        b = m_sub == m_pointer;
512        ignore_unused_variable_warning(b);
513        b = m_sub != m_pointer;
514        ignore_unused_variable_warning(b);
515        b = m_sub <= m_pointer;
516        ignore_unused_variable_warning(b);
517        b = m_sub <= m_pointer;
518        ignore_unused_variable_warning(b);
519        b = m_sub > m_pointer;
520        ignore_unused_variable_warning(b);
521        b = m_sub >= m_pointer;
522        ignore_unused_variable_warning(b);
523        b = m_pointer == m_sub;
524        ignore_unused_variable_warning(b);
525        b = m_pointer != m_sub;
526        ignore_unused_variable_warning(b);
527        b = m_pointer <= m_sub;
528        ignore_unused_variable_warning(b);
529        b = m_pointer <= m_sub;
530        ignore_unused_variable_warning(b);
531        b = m_pointer > m_sub;
532        ignore_unused_variable_warning(b);
533        b = m_pointer >= m_sub;
534        ignore_unused_variable_warning(b);
535        b = m_sub == m_char;
536        ignore_unused_variable_warning(b);
537        b = m_sub != m_char;
538        ignore_unused_variable_warning(b);
539        b = m_sub <= m_char;
540        ignore_unused_variable_warning(b);
541        b = m_sub <= m_char;
542        ignore_unused_variable_warning(b);
543        b = m_sub > m_char;
544        ignore_unused_variable_warning(b);
545        b = m_sub >= m_char;
546        ignore_unused_variable_warning(b);
547        b = m_char == m_sub;
548        ignore_unused_variable_warning(b);
549        b = m_char != m_sub;
550        ignore_unused_variable_warning(b);
551        b = m_char <= m_sub;
552        ignore_unused_variable_warning(b);
553        b = m_char <= m_sub;
554        ignore_unused_variable_warning(b);
555        b = m_char > m_sub;
556        ignore_unused_variable_warning(b);
557        b = m_char >= m_sub;
558        ignore_unused_variable_warning(b);
559        b = m_sub == m_string;
560        ignore_unused_variable_warning(b);
561        b = m_sub != m_string;
562        ignore_unused_variable_warning(b);
563        b = m_sub <= m_string;
564        ignore_unused_variable_warning(b);
565        b = m_sub <= m_string;
566        ignore_unused_variable_warning(b);
567        b = m_sub > m_string;
568        ignore_unused_variable_warning(b);
569        b = m_sub >= m_string;
570        ignore_unused_variable_warning(b);
571        b = m_string == m_sub;
572        ignore_unused_variable_warning(b);
573        b = m_string != m_sub;
574        ignore_unused_variable_warning(b);
575        b = m_string <= m_sub;
576        ignore_unused_variable_warning(b);
577        b = m_string <= m_sub;
578        ignore_unused_variable_warning(b);
579        b = m_string > m_sub;
580        ignore_unused_variable_warning(b);
581        b = m_string >= m_sub;
582        ignore_unused_variable_warning(b);
583        m_string = m_results.str();
584        ignore_unused_variable_warning(m_string);
585        m_string = m_results.str(0);
586        ignore_unused_variable_warning(m_string);
587        m_out = m_cresults.format(m_out, m_string);
588        m_out = m_cresults.format(m_out, m_string, m_mft);
589        m_string = m_cresults.format(m_string);
590        ignore_unused_variable_warning(m_string);
591        m_string = m_cresults.format(m_string, m_mft);
592        ignore_unused_variable_warning(m_string);
593        b = global_regex_namespace::regex_match(m_string, m_smatch, e);
594        ignore_unused_variable_warning(b);
595        b = global_regex_namespace::regex_match(m_string, m_smatch, e, m_mft);
596        ignore_unused_variable_warning(b);
597        b = global_regex_namespace::regex_match(m_string, e);
598        ignore_unused_variable_warning(b);
599        b = global_regex_namespace::regex_match(m_string, e, m_mft);
600        ignore_unused_variable_warning(b);
601        b = global_regex_namespace::regex_search(m_string, m_smatch, e);
602        ignore_unused_variable_warning(b);
603        b = global_regex_namespace::regex_search(m_string, m_smatch, e, m_mft);
604        ignore_unused_variable_warning(b);
605        b = global_regex_namespace::regex_search(m_string, e);
606        ignore_unused_variable_warning(b);
607        b = global_regex_namespace::regex_search(m_string, e, m_mft);
608        ignore_unused_variable_warning(b);
609        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string, m_mft);
610        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string);
611        m_string = global_regex_namespace::regex_replace(m_string, e, m_string, m_mft);
612        ignore_unused_variable_warning(m_string);
613        m_string = global_regex_namespace::regex_replace(m_string, e, m_string);
614        ignore_unused_variable_warning(m_string);
615     }
616     flag_type m_flags;
617     string_type m_string;
618     const sub_match_type m_sub;
619     match_results_type m_results;
620     pointer_type m_pointer;
621     value_type m_char;
622     const match_results_type m_cresults;
623     OutIterator m_out;
624     BidiIterator m_in;
625     global_regex_namespace::regex_constants::match_flag_type m_mft;
626     global_regex_namespace::match_results<typename string_type::const_iterator, allocator_architype<global_regex_namespace::sub_match<typename string_type::const_iterator> > > m_smatch;
627     RegexConcept();
628     RegexConcept(const RegexConcept&);
629     RegexConcept& operator=(const RegexConcept&);
630  };
631  #ifndef BOOST_REGEX_TEST_STD
632  template <class M>
633  struct functor1
634  {
635     typedef typename M::char_type char_type;
636     const char_type* operator()(const M&)const
637     {
638        static const char_type c = static_cast<char_type>(0);
639        return &c;
640     }
641  };
642  template <class M>
643  struct functor1b
644  {
645     typedef typename M::char_type char_type;
646     std::vector<char_type> operator()(const M&)const
647     {
648        static const std::vector<char_type> c;
649        return c;
650     }
651  };
652  template <class M>
653  struct functor2
654  {
655     template <class O>
656     O operator()(const M& &bsol;*m*/, O i)const
657     {
658        return i;
659     }
660  };
661  template <class M>
662  struct functor3
663  {
664     template <class O>
665     O operator()(const M& &bsol;*m*/, O i, regex_constants::match_flag_type)const
666     {
667        return i;
668     }
669  };
670  template <class Regex>
671  struct BoostRegexConcept
672  {
673     typedef typename Regex::value_type value_type;
674     typedef typename Regex::size_type size_type;
675     typedef typename Regex::flag_type flag_type;
676     typedef typename Regex::locale_type locale_type;
677     typedef const value_type* pointer_type;
678     typedef std::basic_string<value_type> string_type;
679     typedef typename Regex::const_iterator const_iterator;
680     typedef bidirectional_iterator_archetype<value_type> BidiIterator;
681     typedef output_iterator_archetype<value_type> OutputIterator;
682     typedef global_regex_namespace::sub_match<BidiIterator> sub_match_type;
683     typedef global_regex_namespace::match_results<BidiIterator, allocator_architype<sub_match_type> > match_results_type;
684     typedef global_regex_namespace::match_results<BidiIterator> match_results_default_type;
685     void constraints() 
686     {
687        global_regex_namespace::regex_constants::match_flag_type mopts
688           = global_regex_namespace::regex_constants::match_default
689           | global_regex_namespace::regex_constants::match_not_bol
690           | global_regex_namespace::regex_constants::match_not_eol
691           | global_regex_namespace::regex_constants::match_not_bow
692           | global_regex_namespace::regex_constants::match_not_eow
693           | global_regex_namespace::regex_constants::match_any
694           | global_regex_namespace::regex_constants::match_not_null
695           | global_regex_namespace::regex_constants::match_continuous
696           | global_regex_namespace::regex_constants::match_partial
697           | global_regex_namespace::regex_constants::match_prev_avail
698           | global_regex_namespace::regex_constants::format_default
699           | global_regex_namespace::regex_constants::format_sed
700           | global_regex_namespace::regex_constants::format_perl
701           | global_regex_namespace::regex_constants::format_no_copy
702           | global_regex_namespace::regex_constants::format_first_only;
703        (void)mopts;
704        function_requires<RegexConcept<Regex> >();
705        const global_regex_namespace::regex_error except(global_regex_namespace::regex_constants::error_collate);
706        std::ptrdiff_t pt = except.position();
707        ignore_unused_variable_warning(pt);
708        const Regex ce, ce2;
709  #ifndef BOOST_NO_STD_LOCALE
710        m_stream << ce;
711  #endif
712        unsigned i = ce.error_code();
713        ignore_unused_variable_warning(i);
714        pointer_type p = ce.expression();
715        ignore_unused_variable_warning(p);
716        int i2 = ce.compare(ce2);
717        ignore_unused_variable_warning(i2);
718        bool b = ce == ce2;
719        ignore_unused_variable_warning(b);
720        b = ce.empty();
721        ignore_unused_variable_warning(b);
722        b = ce != ce2;
723        ignore_unused_variable_warning(b);
724        b = ce < ce2;
725        ignore_unused_variable_warning(b);
726        b = ce > ce2;
727        ignore_unused_variable_warning(b);
728        b = ce <= ce2;
729        ignore_unused_variable_warning(b);
730        b = ce >= ce2;
731        ignore_unused_variable_warning(b);
732        i = ce.status();
733        ignore_unused_variable_warning(i);
734        size_type s = ce.max_size();
735        ignore_unused_variable_warning(s);
736        s = ce.size();
737        ignore_unused_variable_warning(s);
738        const_iterator pi = ce.begin();
739        ignore_unused_variable_warning(pi);
740        pi = ce.end();
741        ignore_unused_variable_warning(pi);
742        string_type s2 = ce.str();
743        ignore_unused_variable_warning(s2);
744        m_string = m_sub + m_sub;
745        ignore_unused_variable_warning(m_string);
746        m_string = m_sub + m_pointer;
747        ignore_unused_variable_warning(m_string);
748        m_string = m_pointer + m_sub;
749        ignore_unused_variable_warning(m_string);
750        m_string = m_sub + m_string;
751        ignore_unused_variable_warning(m_string);
752        m_string = m_string + m_sub;
753        ignore_unused_variable_warning(m_string);
754        m_string = m_sub + m_char;
755        ignore_unused_variable_warning(m_string);
756        m_string = m_char + m_sub;
757        ignore_unused_variable_warning(m_string);
758        m_sub = m_cresults[&m_char];
759        ignore_unused_variable_warning(m_sub);
760        m_sub = m_cresults[m_string];
761        ignore_unused_variable_warning(m_sub);
762        m_sub = m_cresults[""];
763        ignore_unused_variable_warning(m_sub);
764        m_sub = m_cresults[std::string("")];
765        ignore_unused_variable_warning(m_sub);
766        m_string = m_cresults.str(&m_char);
767        ignore_unused_variable_warning(m_string);
768        m_string = m_cresults.str(m_string);
769        ignore_unused_variable_warning(m_string);
770        m_string = m_cresults.str("");
771        ignore_unused_variable_warning(m_string);
772        m_string = m_cresults.str(std::string(""));
773        ignore_unused_variable_warning(m_string);
774        typename match_results_type::difference_type diff;
775        diff = m_cresults.length(&m_char);
776        ignore_unused_variable_warning(diff);
777        diff = m_cresults.length(m_string);
778        ignore_unused_variable_warning(diff);
779        diff = m_cresults.length("");
780        ignore_unused_variable_warning(diff);
781        diff = m_cresults.length(std::string(""));
782        ignore_unused_variable_warning(diff);
783        diff = m_cresults.position(&m_char);
784        ignore_unused_variable_warning(diff);
785        diff = m_cresults.position(m_string);
786        ignore_unused_variable_warning(diff);
787        diff = m_cresults.position("");
788        ignore_unused_variable_warning(diff);
789        diff = m_cresults.position(std::string(""));
790        ignore_unused_variable_warning(diff);
791  #ifndef BOOST_NO_STD_LOCALE
792        m_stream << m_sub;
793        m_stream << m_cresults;
794  #endif
795        regex_constants::match_flag_type f = regex_constants::match_default;
796        OutputIterator out = static_object<OutputIterator>::get();
797        functor3<match_results_default_type> func3;
798        functor2<match_results_default_type> func2;
799        functor1<match_results_default_type> func1;
800        functor3<match_results_type> func3b;
801        functor2<match_results_type> func2b;
802        functor1<match_results_type> func1b;
803        out = regex_format(out, m_cresults, func3b, f);
804        out = regex_format(out, m_cresults, func3b);
805        out = regex_format(out, m_cresults, func2b, f);
806        out = regex_format(out, m_cresults, func2b);
807        out = regex_format(out, m_cresults, func1b, f);
808        out = regex_format(out, m_cresults, func1b);
809        out = regex_format(out, m_cresults, RW_NS::ref(func3b), f);
810        out = regex_format(out, m_cresults, RW_NS::ref(func3b));
811        out = regex_format(out, m_cresults, RW_NS::ref(func2b), f);
812        out = regex_format(out, m_cresults, RW_NS::ref(func2b));
813        out = regex_format(out, m_cresults, RW_NS::ref(func1b), f);
814        out = regex_format(out, m_cresults, RW_NS::ref(func1b));
815        out = regex_format(out, m_cresults, RW_NS::cref(func3b), f);
816        out = regex_format(out, m_cresults, RW_NS::cref(func3b));
817        out = regex_format(out, m_cresults, RW_NS::cref(func2b), f);
818        out = regex_format(out, m_cresults, RW_NS::cref(func2b));
819        out = regex_format(out, m_cresults, RW_NS::cref(func1b), f);
820        out = regex_format(out, m_cresults, RW_NS::cref(func1b));
821        m_string += regex_format(m_cresults, func3b, f);
822        m_string += regex_format(m_cresults, func3b);
823        m_string += regex_format(m_cresults, func2b, f);
824        m_string += regex_format(m_cresults, func2b);
825        m_string += regex_format(m_cresults, func1b, f);
826        m_string += regex_format(m_cresults, func1b);
827        m_string += regex_format(m_cresults, RW_NS::ref(func3b), f);
828        m_string += regex_format(m_cresults, RW_NS::ref(func3b));
829        m_string += regex_format(m_cresults, RW_NS::ref(func2b), f);
830        m_string += regex_format(m_cresults, RW_NS::ref(func2b));
831        m_string += regex_format(m_cresults, RW_NS::ref(func1b), f);
832        m_string += regex_format(m_cresults, RW_NS::ref(func1b));
833        m_string += regex_format(m_cresults, RW_NS::cref(func3b), f);
834        m_string += regex_format(m_cresults, RW_NS::cref(func3b));
835        m_string += regex_format(m_cresults, RW_NS::cref(func2b), f);
836        m_string += regex_format(m_cresults, RW_NS::cref(func2b));
837        m_string += regex_format(m_cresults, RW_NS::cref(func1b), f);
838        m_string += regex_format(m_cresults, RW_NS::cref(func1b));
839        out = m_cresults.format(out, func3b, f);
840        out = m_cresults.format(out, func3b);
841        out = m_cresults.format(out, func2b, f);
842        out = m_cresults.format(out, func2b);
843        out = m_cresults.format(out, func1b, f);
844        out = m_cresults.format(out, func1b);
845        out = m_cresults.format(out, RW_NS::ref(func3b), f);
846        out = m_cresults.format(out, RW_NS::ref(func3b));
847        out = m_cresults.format(out, RW_NS::ref(func2b), f);
848        out = m_cresults.format(out, RW_NS::ref(func2b));
849        out = m_cresults.format(out, RW_NS::ref(func1b), f);
850        out = m_cresults.format(out, RW_NS::ref(func1b));
851        out = m_cresults.format(out, RW_NS::cref(func3b), f);
852        out = m_cresults.format(out, RW_NS::cref(func3b));
853        out = m_cresults.format(out, RW_NS::cref(func2b), f);
854        out = m_cresults.format(out, RW_NS::cref(func2b));
855        out = m_cresults.format(out, RW_NS::cref(func1b), f);
856        out = m_cresults.format(out, RW_NS::cref(func1b));
857        m_string += m_cresults.format(func3b, f);
858        m_string += m_cresults.format(func3b);
859        m_string += m_cresults.format(func2b, f);
860        m_string += m_cresults.format(func2b);
861        m_string += m_cresults.format(func1b, f);
862        m_string += m_cresults.format(func1b);
863        m_string += m_cresults.format(RW_NS::ref(func3b), f);
864        m_string += m_cresults.format(RW_NS::ref(func3b));
865        m_string += m_cresults.format(RW_NS::ref(func2b), f);
866        m_string += m_cresults.format(RW_NS::ref(func2b));
867        m_string += m_cresults.format(RW_NS::ref(func1b), f);
868        m_string += m_cresults.format(RW_NS::ref(func1b));
869        m_string += m_cresults.format(RW_NS::cref(func3b), f);
870        m_string += m_cresults.format(RW_NS::cref(func3b));
871        m_string += m_cresults.format(RW_NS::cref(func2b), f);
872        m_string += m_cresults.format(RW_NS::cref(func2b));
873        m_string += m_cresults.format(RW_NS::cref(func1b), f);
874        m_string += m_cresults.format(RW_NS::cref(func1b));
875        out = regex_replace(out, m_in, m_in, ce, func3, f);
876        out = regex_replace(out, m_in, m_in, ce, func3);
877        out = regex_replace(out, m_in, m_in, ce, func2, f);
878        out = regex_replace(out, m_in, m_in, ce, func2);
879        out = regex_replace(out, m_in, m_in, ce, func1, f);
880        out = regex_replace(out, m_in, m_in, ce, func1);
881        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3), f);
882        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3));
883        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2), f);
884        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2));
885        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1), f);
886        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1));
887        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3), f);
888        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3));
889        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2), f);
890        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2));
891        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1), f);
892        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1));
893        functor3<match_results<typename string_type::const_iterator> > func3s;
894        functor2<match_results<typename string_type::const_iterator> > func2s;
895        functor1<match_results<typename string_type::const_iterator> > func1s;
896        m_string += regex_replace(m_string, ce, func3s, f);
897        m_string += regex_replace(m_string, ce, func3s);
898        m_string += regex_replace(m_string, ce, func2s, f);
899        m_string += regex_replace(m_string, ce, func2s);
900        m_string += regex_replace(m_string, ce, func1s, f);
901        m_string += regex_replace(m_string, ce, func1s);
902        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s), f);
903        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s));
904        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s), f);
905        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s));
906        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s), f);
907        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s));
908        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s), f);
909        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s));
910        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s), f);
911        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s));
912        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s), f);
913        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s));
914     }
915     std::basic_ostream<value_type> m_stream;
916     sub_match_type m_sub;
917     pointer_type m_pointer;
918     string_type m_string;
919     const value_type m_char;
920     match_results_type m_results;
921     const match_results_type m_cresults;
922     BidiIterator m_in;
923     BoostRegexConcept();
924     BoostRegexConcept(const BoostRegexConcept&);
925     BoostRegexConcept& operator=(const BoostRegexConcept&);
926  };
927  #endif 
928  }
929  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cli_53.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</div>
                </div>
                <div class="column column_space"><pre><code>35  void nano::add_node_options (boost::program_options::options_description & description_a)
36  {
37  	description_a.add_options ()
</pre></code></div>
                <div class="column column_space"><pre><code>415        regex_iterator_type iter2(m_in, m_in, e, m_mft);
416        ignore_unused_variable_warning(iter2);
417        typedef typename regex_token_iterator_type::regex_type rtit_regex_type;
418        typedef typename regex_token_iterator_type::value_type rtit_value_type;
419        typedef typename regex_token_iterator_type::difference_type rtit_difference_type;
420        typedef typename regex_token_iterator_type::pointer rtit_pointer;
421        typedef typename regex_token_iterator_type::reference rtit_reference;
422        typedef typename regex_token_iterator_type::iterator_category rtit_iterator_category;
423        BOOST_STATIC_ASSERT((::boost::is_same<rtit_regex_type, Regex>::value));
424        BOOST_STATIC_ASSERT((::boost::is_same<rtit_value_type, sub_match_type>::value));
425        BOOST_STATIC_ASSERT((::boost::is_same<rtit_difference_type, std::ptrdiff_t>::value));
426        BOOST_STATIC_ASSERT((::boost::is_same<rtit_pointer, const sub_match_type*>::value));
427        BOOST_STATIC_ASSERT((::boost::is_same<rtit_reference, const sub_match_type&>::value));
428        BOOST_STATIC_ASSERT((::boost::is_convertible<rtit_iterator_category*, std::forward_iterator_tag*>::value));
429        function_requires<ForwardIteratorConcept<regex_token_iterator_type> >();
430        regex_token_iterator_type ti1(m_in, m_in, e);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    