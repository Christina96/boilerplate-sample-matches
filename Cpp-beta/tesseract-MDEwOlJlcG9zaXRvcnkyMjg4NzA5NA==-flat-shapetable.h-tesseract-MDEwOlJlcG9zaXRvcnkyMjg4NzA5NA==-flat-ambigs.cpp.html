
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.365159128978225%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.h</h3>
            <pre><code>1  #ifndef TESSERACT_CLASSIFY_SHAPETABLE_H_
2  #define TESSERACT_CLASSIFY_SHAPETABLE_H_
3  #include "bitvector.h"
4  #include "fontinfo.h"
5  #include "genericheap.h"
6  #include "intmatcher.h"
7  namespace tesseract {
8  class UNICHARSET;
9  class ShapeTable;
10  struct UnicharRating {
11    UnicharRating() : unichar_id(0), rating(0.0f), adapted(false), config(0), feature_misses(0) {}
12    UnicharRating(int u, float r)
13        : unichar_id(u), rating(r), adapted(false), config(0), feature_misses(0) {}
14    void Print() const {
15      tprintf(
16          "Unichar-id=%d, rating=%g, adapted=%d, config=%d, misses=%u,"
17          " %zu fonts\n",
18          unichar_id, static_cast<double>(rating), adapted, config, feature_misses, fonts.size());
19    }
<span onclick='openModal()' class='match'>20    static int FirstResultWithUnichar(const std::vector<UnicharRating> &results,
21                                      UNICHAR_ID unichar_id);
22    UNICHAR_ID unichar_id;
23    float rating;
24    bool adapted;
25    uint8_t config;
</span>26    uint16_t feature_misses;
27    std::vector<ScoredFont> fonts;
28  };
29  struct ShapeRating {
30    ShapeRating() : shape_id(0), rating(0.0f), raw(0.0f), font(0.0f), joined(false), broken(false) {}
31    ShapeRating(int s, float r)
32        : shape_id(s), rating(r), raw(1.0f), font(0.0f), joined(false), broken(false) {}
33    static int FirstResultWithUnichar(const std::vector<ShapeRating> &results,
34                                      const ShapeTable &shape_table, UNICHAR_ID unichar_id);
35    int shape_id;
36    float rating;
37    float raw;
38    float font;
39    bool joined;
40    bool broken;
41  };
42  struct ShapeQueueEntry {
43    ShapeQueueEntry() : result(ShapeRating(0, 0.0f)), level(0) {}
44    ShapeQueueEntry(const ShapeRating &rating, int level0) : result(rating), level(level0) {}
45    bool operator<(const ShapeQueueEntry &other) const {
46      if (result.rating > other.result.rating) {
47        return true;
48      }
49      if (result.rating == other.result.rating) {
50        return level > other.level;
51      }
52      return false;
53    }
54    ShapeRating result;
55    int level;
56  };
57  using ShapeQueue = GenericHeap<ShapeQueueEntry>;
58  struct UnicharAndFonts {
59    UnicharAndFonts() : unichar_id(0) {}
60    UnicharAndFonts(int uni_id, int font_id) : unichar_id(uni_id) {
61      font_ids.push_back(font_id);
62    }
63    bool Serialize(FILE *fp) const;
64    bool DeSerialize(TFile *fp);
65    static int SortByUnicharId(const void *v1, const void *v2);
66    static bool StdSortByUnicharId(const UnicharAndFonts &v1, const UnicharAndFonts &v2);
67    std::vector<int32_t> font_ids;
68    int32_t unichar_id;
69  };
70  class TESS_API Shape {
71  public:
72    Shape() : destination_index_(-1) {}
73    bool Serialize(FILE *fp) const;
74    bool DeSerialize(TFile *fp);
75    int destination_index() const {
76      return destination_index_;
77    }
78    void set_destination_index(int index) {
79      destination_index_ = index;
80    }
81    int size() const {
82      return unichars_.size();
83    }
84    const UnicharAndFonts &operator[](int index) const {
85      return unichars_[index];
86    }
87    void SetUnicharId(int index, int unichar_id) {
88      unichars_[index].unichar_id = unichar_id;
89    }
90    void AddToShape(int unichar_id, int font_id);
91    void AddShape(const Shape &other);
92    bool ContainsUnicharAndFont(int unichar_id, int font_id) const;
93    bool ContainsUnichar(int unichar_id) const;
94    bool ContainsFont(int font_id) const;
95    bool ContainsFontProperties(const FontInfoTable &font_table, uint32_t properties) const;
96    bool ContainsMultipleFontProperties(const FontInfoTable &font_table) const;
97    bool operator==(const Shape &other) const;
98    bool IsSubsetOf(const Shape &other) const;
99    bool IsEqualUnichars(Shape *other);
100  private:
101    void SortUnichars();
102    bool unichars_sorted_ = false;
103    int destination_index_ = 0;
104    std::vector<UnicharAndFonts> unichars_;
105  };
106  class TESS_API ShapeTable {
107  public:
108    ShapeTable();
109    explicit ShapeTable(const UNICHARSET &unicharset);
110    ~ShapeTable() {
111      for (auto data : shape_table_) {
112        delete data;
113      }
114    }
115    bool Serialize(FILE *fp) const;
116    bool DeSerialize(TFile *fp);
117    unsigned NumShapes() const {
118      return shape_table_.size();
119    }
120    const UNICHARSET &unicharset() const {
121      return *unicharset_;
122    }
123    int NumFonts() const;
124    void set_unicharset(const UNICHARSET &unicharset) {
125      unicharset_ = &unicharset;
126    }
127    void ReMapClassIds(const std::vector<int> &unicharset_map);
128    std::string DebugStr(unsigned shape_id) const;
129    std::string SummaryStr() const;
130    unsigned AddShape(int unichar_id, int font_id);
131    unsigned AddShape(const Shape &other);
132    void DeleteShape(unsigned shape_id);
133    void AddToShape(unsigned shape_id, int unichar_id, int font_id);
134    void AddShapeToShape(unsigned shape_id, const Shape &other);
135    int FindShape(int unichar_id, int font_id) const;
136    void GetFirstUnicharAndFont(unsigned shape_id, int *unichar_id, int *font_id) const;
137    const Shape &GetShape(unsigned shape_id) const {
138      return *shape_table_[shape_id];
139    }
140    Shape *MutableShape(unsigned shape_id) {
141      return shape_table_[shape_id];
142    }
143    int BuildFromShape(const Shape &shape, const ShapeTable &master_shapes);
144    bool AlreadyMerged(unsigned shape_id1, unsigned shape_id2) const;
145    bool AnyMultipleUnichars() const;
146    int MaxNumUnichars() const;
147    void ForceFontMerges(unsigned start, unsigned end);
148    unsigned MasterUnicharCount(unsigned shape_id) const;
149    int MasterFontCount(unsigned shape_id) const;
150    int MergedUnicharCount(unsigned shape_id1, unsigned shape_id2) const;
151    void MergeShapes(unsigned shape_id1, unsigned shape_id2);
152    void SwapShapes(unsigned shape_id1, unsigned shape_id2);
153    void AppendMasterShapes(const ShapeTable &other, std::vector<int> *shape_map);
154    int NumMasterShapes() const;
155    unsigned MasterDestinationIndex(unsigned shape_id) const;
156    bool SubsetUnichar(unsigned shape_id1, unsigned shape_id2) const;
157    bool MergeSubsetUnichar(int merge_id1, int merge_id2, unsigned shape_id) const;
158    bool EqualUnichars(unsigned shape_id1, unsigned shape_id2) const;
159    bool MergeEqualUnichars(int merge_id1, int merge_id2, unsigned shape_id) const;
160    bool CommonUnichars(unsigned shape_id1, unsigned shape_id2) const;
161    bool CommonFont(unsigned shape_id1, unsigned shape_id2) const;
162    void AddShapeToResults(const ShapeRating &shape_rating, std::vector<int> *unichar_map,
163                           std::vector<UnicharRating> *results) const;
164  private:
165    int AddUnicharToResults(int unichar_id, float rating, std::vector<int> *unichar_map,
166                            std::vector<UnicharRating> *results) const;
167    const UNICHARSET *unicharset_;
168    std::vector<Shape *> shape_table_;
169    mutable int num_fonts_;
170  };
171  } 
172  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ambigs.cpp</h3>
            <pre><code>1  #include "ambigs.h"
2  #include "helpers.h"
3  #include "universalambigs.h"
4  #include <cstdio>
5  #if defined(_WIN32) && !defined(__GNUC__)
6  #  define strtok_r(str, delim, saveptr) strtok_s(str, delim, saveptr)
7  #endif &bsol;* _WIN32 && !__GNUC__ */
8  namespace tesseract {
9  static const char kAmbigDelimiters[] = "\t ";
10  static const char kIllegalMsg[] = "Illegal ambiguity specification on line %d\n";
11  static const char kIllegalUnicharMsg[] = "Illegal unichar %s in ambiguity specification\n";
12  const int kMaxAmbigStringSize = UNICHAR_LEN * (MAX_AMBIG_SIZE + 1);
13  AmbigSpec::AmbigSpec() {
14    wrong_ngram[0] = INVALID_UNICHAR_ID;
15    correct_fragments[0] = INVALID_UNICHAR_ID;
16    correct_ngram_id = INVALID_UNICHAR_ID;
17    type = NOT_AMBIG;
18    wrong_ngram_size = 0;
19  }
20  void UnicharAmbigs::InitUnicharAmbigs(const UNICHARSET &unicharset, bool use_ambigs_for_adaption) {
21    for (unsigned i = 0; i < unicharset.size(); ++i) {
22      replace_ambigs_.push_back(nullptr);
23      dang_ambigs_.push_back(nullptr);
24      one_to_one_definite_ambigs_.push_back(nullptr);
25      if (use_ambigs_for_adaption) {
26        ambigs_for_adaption_.push_back(nullptr);
27        reverse_ambigs_for_adaption_.push_back(nullptr);
28      }
29    }
30  }
31  void UnicharAmbigs::LoadUniversal(const UNICHARSET &encoder_set, UNICHARSET *unicharset) {
32    TFile file;
33    if (!file.Open(kUniversalAmbigsFile, ksizeofUniversalAmbigsFile)) {
34      return;
35    }
36    LoadUnicharAmbigs(encoder_set, &file, 0, false, unicharset);
37  }
38  void UnicharAmbigs::LoadUnicharAmbigs(const UNICHARSET &encoder_set, TFile *ambig_file,
39                                        int debug_level, bool use_ambigs_for_adaption,
40                                        UNICHARSET *unicharset) {
41    UnicharIdVector *adaption_ambigs_entry;
42    if (debug_level) {
43      tprintf("Reading ambiguities\n");
44    }
45    int test_ambig_part_size;
46    int replacement_ambig_part_size;
47    const int kBufferSize = 10 + 2 * kMaxAmbigStringSize;
48    char *buffer = new char[kBufferSize];
49    char replacement_string[kMaxAmbigStringSize];
50    UNICHAR_ID test_unichar_ids[MAX_AMBIG_SIZE + 1];
51    int line_num = 0;
52    int type = NOT_AMBIG;
53    int version = 0;
54    ASSERT_HOST(ambig_file->FGets(buffer, kBufferSize) != nullptr && buffer[0] != '\0');
55    if (*buffer == 'v') {
56      version = static_cast<int>(strtol(buffer + 1, nullptr, 10));
57      ++line_num;
58    } else {
59      ambig_file->Rewind();
60    }
61    while (ambig_file->FGets(buffer, kBufferSize) != nullptr) {
62      chomp_string(buffer);
63      if (debug_level > 2) {
64        tprintf("read line %s\n", buffer);
65      }
66      ++line_num;
67      if (!ParseAmbiguityLine(line_num, version, debug_level, encoder_set, buffer,
68                              &test_ambig_part_size, test_unichar_ids, &replacement_ambig_part_size,
69                              replacement_string, &type)) {
70        continue;
71      }
72      auto *ambig_spec = new AmbigSpec();
73      if (!InsertIntoTable((type == REPLACE_AMBIG) ? replace_ambigs_ : dang_ambigs_,
74                           test_ambig_part_size, test_unichar_ids, replacement_ambig_part_size,
75                           replacement_string, type, ambig_spec, unicharset)) {
76        continue;
77      }
78      if (test_ambig_part_size == 1 && replacement_ambig_part_size == 1 && type == DEFINITE_AMBIG) {
79        if (one_to_one_definite_ambigs_[test_unichar_ids[0]] == nullptr) {
80          one_to_one_definite_ambigs_[test_unichar_ids[0]] = new UnicharIdVector();
81        }
82        one_to_one_definite_ambigs_[test_unichar_ids[0]]->push_back(ambig_spec->correct_ngram_id);
83      }
84      if (use_ambigs_for_adaption) {
85        std::vector<UNICHAR_ID> encoding;
86        if (unicharset->encode_string(replacement_string, true, &encoding, nullptr, nullptr)) {
87          for (int i = 0; i < test_ambig_part_size; ++i) {
88            if (ambigs_for_adaption_[test_unichar_ids[i]] == nullptr) {
89              ambigs_for_adaption_[test_unichar_ids[i]] = new UnicharIdVector();
90            }
91            adaption_ambigs_entry = ambigs_for_adaption_[test_unichar_ids[i]];
92            for (int id_to_insert : encoding) {
93              ASSERT_HOST(id_to_insert != INVALID_UNICHAR_ID);
94              size_t j;
95              for (j = 0;
96                   j < adaption_ambigs_entry->size() && (*adaption_ambigs_entry)[j] > id_to_insert;
97                   ++j) {
98              }
99              if (j < adaption_ambigs_entry->size()) {
100                if ((*adaption_ambigs_entry)[j] != id_to_insert) {
101                  adaption_ambigs_entry->insert(adaption_ambigs_entry->begin() + j, id_to_insert);
102                }
103              } else {
104                adaption_ambigs_entry->push_back(id_to_insert);
105              }
106            }
107          }
108        }
109      }
110    }
111    delete[] buffer;
112    if (use_ambigs_for_adaption) {
113      for (size_t i = 0; i < ambigs_for_adaption_.size(); ++i) {
114        adaption_ambigs_entry = ambigs_for_adaption_[i];
115        if (adaption_ambigs_entry == nullptr) {
116          continue;
117        }
118        for (size_t j = 0; j < adaption_ambigs_entry->size(); ++j) {
119          UNICHAR_ID ambig_id = (*adaption_ambigs_entry)[j];
120          if (reverse_ambigs_for_adaption_[ambig_id] == nullptr) {
121            reverse_ambigs_for_adaption_[ambig_id] = new UnicharIdVector();
122          }
123          reverse_ambigs_for_adaption_[ambig_id]->push_back(i);
124        }
125      }
126    }
127    if (debug_level > 1) {
128      for (int tbl = 0; tbl < 2; ++tbl) {
129        const UnicharAmbigsVector &print_table = (tbl == 0) ? replace_ambigs_ : dang_ambigs_;
130        for (size_t i = 0; i < print_table.size(); ++i) {
131          AmbigSpec_LIST *lst = print_table[i];
132          if (lst == nullptr) {
133            continue;
134          }
135          if (!lst->empty()) {
136            tprintf("%s Ambiguities for %s:\n", (tbl == 0) ? "Replaceable" : "Dangerous",
137                    unicharset->debug_str(i).c_str());
138          }
139          AmbigSpec_IT lst_it(lst);
140          for (lst_it.mark_cycle_pt(); !lst_it.cycled_list(); lst_it.forward()) {
141            AmbigSpec *ambig_spec = lst_it.data();
142            tprintf("wrong_ngram:");
143            UnicharIdArrayUtils::print(ambig_spec->wrong_ngram, *unicharset);
144            tprintf("correct_fragments:");
145            UnicharIdArrayUtils::print(ambig_spec->correct_fragments, *unicharset);
146          }
147        }
148      }
149      if (use_ambigs_for_adaption) {
150        for (int vec_id = 0; vec_id < 2; ++vec_id) {
151          const std::vector<UnicharIdVector *> &vec =
152              (vec_id == 0) ? ambigs_for_adaption_ : reverse_ambigs_for_adaption_;
153          for (size_t i = 0; i < vec.size(); ++i) {
154            adaption_ambigs_entry = vec[i];
155            if (adaption_ambigs_entry != nullptr) {
156              tprintf("%sAmbigs for adaption for %s:\n", (vec_id == 0) ? "" : "Reverse ",
157                      unicharset->debug_str(i).c_str());
158              for (size_t j = 0; j < adaption_ambigs_entry->size(); ++j) {
159                tprintf("%s ", unicharset->debug_str((*adaption_ambigs_entry)[j]).c_str());
160              }
161              tprintf("\n");
162            }
163          }
164        }
165      }
166    }
167  }
<span onclick='openModal()' class='match'>168  bool UnicharAmbigs::ParseAmbiguityLine(int line_num, int version, int debug_level,
169                                         const UNICHARSET &unicharset, char *buffer,
170                                         int *test_ambig_part_size, UNICHAR_ID *test_unichar_ids,
171                                         int *replacement_ambig_part_size, char *replacement_string,
172                                         int *type) {
</span>173    if (version > 1) {
174      std::string input(buffer);
175      std::vector<std::string> fields = split(input, ' ');
176      if (fields.size() != 3) {
177        if (debug_level) {
178          tprintf(kIllegalMsg, line_num);
179        }
180        return false;
181      }
182      std::vector<UNICHAR_ID> unichars;
183      if (!unicharset.encode_string(fields[0].c_str(), true, &unichars, nullptr, nullptr)) {
184        return false;
185      }
186      *test_ambig_part_size = unichars.size();
187      if (*test_ambig_part_size > MAX_AMBIG_SIZE) {
188        if (debug_level) {
189          tprintf("Too many unichars in ambiguity on line %d\n", line_num);
190        }
191        return false;
192      }
193      for (size_t i = 0; i < unichars.size(); ++i) {
194        test_unichar_ids[i] = unichars[i];
195      }
196      test_unichar_ids[unichars.size()] = INVALID_UNICHAR_ID;
197      if (!unicharset.encode_string(fields[1].c_str(), true, &unichars, nullptr, nullptr)) {
198        return false;
199      }
200      *replacement_ambig_part_size = unichars.size();
201      if (*replacement_ambig_part_size > MAX_AMBIG_SIZE) {
202        if (debug_level) {
203          tprintf("Too many unichars in ambiguity on line %d\n", line_num);
204        }
205        return false;
206      }
207      if (sscanf(fields[2].c_str(), "%d", type) != 1) {
208        if (debug_level) {
209          tprintf(kIllegalMsg, line_num);
210        }
211        return false;
212      }
213      snprintf(replacement_string, kMaxAmbigStringSize, "%s", fields[1].c_str());
214      return true;
215    }
216    int i;
217    char *token;
218    char *next_token;
219    if (!(token = strtok_r(buffer, kAmbigDelimiters, &next_token)) ||
220        !sscanf(token, "%d", test_ambig_part_size) || *test_ambig_part_size <= 0) {
221      if (debug_level) {
222        tprintf(kIllegalMsg, line_num);
223      }
224      return false;
225    }
226    if (*test_ambig_part_size > MAX_AMBIG_SIZE) {
227      if (debug_level) {
228        tprintf("Too many unichars in ambiguity on line %d\n", line_num);
229      }
230      return false;
231    }
232    for (i = 0; i < *test_ambig_part_size; ++i) {
233      if (!(token = strtok_r(nullptr, kAmbigDelimiters, &next_token))) {
234        break;
235      }
236      if (!unicharset.contains_unichar(token)) {
237        if (debug_level) {
238          tprintf(kIllegalUnicharMsg, token);
239        }
240        break;
241      }
242      test_unichar_ids[i] = unicharset.unichar_to_id(token);
243    }
244    test_unichar_ids[i] = INVALID_UNICHAR_ID;
245    if (i != *test_ambig_part_size || !(token = strtok_r(nullptr, kAmbigDelimiters, &next_token)) ||
246        !sscanf(token, "%d", replacement_ambig_part_size) || *replacement_ambig_part_size <= 0) {
247      if (debug_level) {
248        tprintf(kIllegalMsg, line_num);
249      }
250      return false;
251    }
252    if (*replacement_ambig_part_size > MAX_AMBIG_SIZE) {
253      if (debug_level) {
254        tprintf("Too many unichars in ambiguity on line %d\n", line_num);
255      }
256      return false;
257    }
258    replacement_string[0] = '\0';
259    for (i = 0; i < *replacement_ambig_part_size; ++i) {
260      if (!(token = strtok_r(nullptr, kAmbigDelimiters, &next_token))) {
261        break;
262      }
263      strcat(replacement_string, token);
264      if (!unicharset.contains_unichar(token)) {
265        if (debug_level) {
266          tprintf(kIllegalUnicharMsg, token);
267        }
268        break;
269      }
270    }
271    if (i != *replacement_ambig_part_size) {
272      if (debug_level) {
273        tprintf(kIllegalMsg, line_num);
274      }
275      return false;
276    }
277    if (version > 0) {
278      if (!(token = strtok_r(nullptr, kAmbigDelimiters, &next_token)) || !sscanf(token, "%d", type)) {
279        if (debug_level) {
280          tprintf(kIllegalMsg, line_num);
281        }
282        return false;
283      }
284    }
285    return true;
286  }
287  bool UnicharAmbigs::InsertIntoTable(UnicharAmbigsVector &table, int test_ambig_part_size,
288                                      UNICHAR_ID *test_unichar_ids, int replacement_ambig_part_size,
289                                      const char *replacement_string, int type, AmbigSpec *ambig_spec,
290                                      UNICHARSET *unicharset) {
291    ambig_spec->type = static_cast<AmbigType>(type);
292    if (test_ambig_part_size == 1 && replacement_ambig_part_size == 1 &&
293        unicharset->to_lower(test_unichar_ids[0]) ==
294            unicharset->to_lower(unicharset->unichar_to_id(replacement_string))) {
295      ambig_spec->type = CASE_AMBIG;
296    }
297    ambig_spec->wrong_ngram_size =
298        UnicharIdArrayUtils::copy(test_unichar_ids, ambig_spec->wrong_ngram);
299    unicharset->unichar_insert(replacement_string, OldUncleanUnichars::kTrue);
300    ambig_spec->correct_ngram_id = unicharset->unichar_to_id(replacement_string);
301    if (replacement_ambig_part_size > 1) {
302      unicharset->set_isngram(ambig_spec->correct_ngram_id, true);
303    }
304    int i;
305    for (i = 0; i < test_ambig_part_size; ++i) {
306      UNICHAR_ID unichar_id;
307      if (test_ambig_part_size == 1) {
308        unichar_id = ambig_spec->correct_ngram_id;
309      } else {
310        std::string frag_str =
311            CHAR_FRAGMENT::to_string(replacement_string, i, test_ambig_part_size, false);
312        unicharset->unichar_insert(frag_str.c_str(), OldUncleanUnichars::kTrue);
313        unichar_id = unicharset->unichar_to_id(frag_str.c_str());
314      }
315      ambig_spec->correct_fragments[i] = unichar_id;
316    }
317    ambig_spec->correct_fragments[i] = INVALID_UNICHAR_ID;
318    if (table[test_unichar_ids[0]] == nullptr) {
319      table[test_unichar_ids[0]] = new AmbigSpec_LIST();
320    }
321    if (table[test_unichar_ids[0]]->add_sorted(AmbigSpec::compare_ambig_specs, true, ambig_spec)) {
322      return true;
323    }
324    delete ambig_spec;
325    return false;
326  }
327  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ambigs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>20    static int FirstResultWithUnichar(const std::vector<UnicharRating> &results,
21                                      UNICHAR_ID unichar_id);
22    UNICHAR_ID unichar_id;
23    float rating;
24    bool adapted;
25    uint8_t config;
</pre></code></div>
                <div class="column column_space"><pre><code>168  bool UnicharAmbigs::ParseAmbiguityLine(int line_num, int version, int debug_level,
169                                         const UNICHARSET &unicharset, char *buffer,
170                                         int *test_ambig_part_size, UNICHAR_ID *test_unichar_ids,
171                                         int *replacement_ambig_part_size, char *replacement_string,
172                                         int *type) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    