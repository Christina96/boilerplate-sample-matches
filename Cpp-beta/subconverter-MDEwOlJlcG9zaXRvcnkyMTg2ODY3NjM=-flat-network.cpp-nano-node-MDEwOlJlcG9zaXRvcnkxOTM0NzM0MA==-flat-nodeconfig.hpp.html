
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.591836734693878%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-network.cpp</h3>
            <pre><code>1  #include <string>
2  #include <vector>
3  #include <sstream>
4  #include "../server/socket.h"
5  #include "string.h"
6  #include "regexp.h"
7  std::string hostnameToIPAddr(const std::string &host)
8  {
9      int retVal;
10      std::string retAddr;
11      char cAddr[128] = {};
12      struct sockaddr_in *target;
13      struct sockaddr_in6 *target6;
14      struct addrinfo hint = {}, *retAddrInfo, *cur;
15      retVal = getaddrinfo(host.data(), NULL, &hint, &retAddrInfo);
16      if(retVal != 0)
17      {
18          freeaddrinfo(retAddrInfo);
19          return std::string();
20      }
21      for(cur = retAddrInfo; cur != NULL; cur = cur->ai_next)
22      {
23          if(cur->ai_family == AF_INET)
24          {
25              target = reinterpret_cast<struct sockaddr_in *>(cur->ai_addr);
26              inet_ntop(AF_INET, &target->sin_addr, cAddr, sizeof(cAddr));
27              break;
28          }
29          else if(cur->ai_family == AF_INET6)
30          {
31              target6 = reinterpret_cast<struct sockaddr_in6 *>(cur->ai_addr);
32              inet_ntop(AF_INET6, &target6->sin6_addr, cAddr, sizeof(cAddr));
33              break;
34          }
35      }
36      retAddr.assign(cAddr);
37      freeaddrinfo(retAddrInfo);
38      return retAddr;
39  }
40  bool isIPv4(const std::string &address)
41  {
42      return regMatch(address, "^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$");
43  }
44  bool isIPv6(const std::string &address)
45  {
46      std::vector<std::string> regLists = {"^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$", "^((?:[0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4})*)?)::((?:([0-9A-Fa-f]{1,4}:)*[0-9A-Fa-f]{1,4})?)$", "^(::(?:[0-9A-Fa-f]{1,4})(?::[0-9A-Fa-f]{1,4}){5})|((?:[0-9A-Fa-f]{1,4})(?::[0-9A-Fa-f]{1,4}){5}::)$"};
47      for(unsigned int i = 0; i < regLists.size(); i++)
48      {
49          if(regMatch(address, regLists[i]))
50              return true;
51      }
52      return false;
53  }
54  void urlParse(std::string &url, std::string &host, std::string &path, int &port, bool &isTLS)
55  {
56      std::vector<std::string> args;
57      string_size pos;
58      if(regMatch(url, "^https:&bsol;&bsol;(.*)"))
59          isTLS = true;
60      url = regReplace(url, "^(http|https):&bsol;&bsol;", "");
61      pos = url.find("/");
62      if(pos == url.npos)
63      {
64          host = url;
65          path = "/";
66      }
67      else
68      {
69          host = url.substr(0, pos);
70          path = url.substr(pos);
71      }
72      pos = host.rfind(":");
73      if(regFind(host, "\\[(.*)\\]")) 
74      {
75          args = split(regReplace(host, "\\[(.*)\\](.*)", "$1,$2"), ",");
76          if(args.size() == 2) 
77              port = to_int(args[1].substr(1));
78          host = args[0];
79      }
80      else if(pos != host.npos)
81      {
82          port = to_int(host.substr(pos + 1));
83          host = host.substr(0, pos);
84      }
85      if(port == 0)
86      {
87          if(isTLS)
88              port = 443;
89          else
90              port = 80;
91      }
92  }
<span onclick='openModal()' class='match'>93  std::string getFormData(const std::string &raw_data)
94  {
95      std::stringstream strstrm;
96      std::string line;
97      std::string boundary;
98      std::string file; &bsol;* actual file content */
99      int i = 0;
</span>100      strstrm<<raw_data;
101      while (std::getline(strstrm, line))
102      {
103          if(i == 0)
104              boundary = line.substr(0, line.length() - 1); 
105          else if(startsWith(line, boundary))
106              break; 
107          else if(line.length() == 1)
108          {
109              char c;
110              int bl = boundary.length();
111              bool endfile = false;
112              char buffer[256];
113              while(!endfile)
114              {
115                  int j = 0;
116                  while(j < 256 && strstrm.get(c) && !endfile)
117                  {
118                      buffer[j] = c;
119                      int k = 0;
120                      while(boundary[bl - 1 - k] == buffer[j - k])
121                      {
122                          if(k >= bl - 1)
123                          {
124                              endfile = true;
125                              break;
126                          }
127                          k++;
128                      }
129                      j++;
130                  }
131                  file.append(buffer, j);
132                  j = 0;
133              };
134              file.erase(file.length() - bl);
135              break;
136          }
137          i++;
138      }
139      return file;
140  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-nodeconfig.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/config.hpp>
3  #include <nano/lib/diagnosticsconfig.hpp>
4  #include <nano/lib/errors.hpp>
5  #include <nano/lib/lmdbconfig.hpp>
6  #include <nano/lib/numbers.hpp>
7  #include <nano/lib/rocksdbconfig.hpp>
8  #include <nano/lib/stats.hpp>
9  #include <nano/node/bootstrap/bootstrap_config.hpp>
10  #include <nano/node/ipc/ipc_config.hpp>
11  #include <nano/node/logging.hpp>
12  #include <nano/node/scheduler/optimistic.hpp>
13  #include <nano/node/websocketconfig.hpp>
14  #include <nano/secure/common.hpp>
15  #include <chrono>
16  #include <optional>
17  #include <vector>
18  namespace nano
19  {
20  class tomlconfig;
21  enum class frontiers_confirmation_mode : uint8_t
22  {
23  	always, 
24  	automatic, 
25  	disabled, 
26  	invalid
27  };
28  class node_config
29  {
30  public:
<span onclick='openModal()' class='match'>31  	node_config (nano::network_params & network_params = nano::dev::network_params);
32  	node_config (const std::optional<uint16_t> &, nano::logging const &, nano::network_params & network_params = nano::dev::network_params);
33  	nano::error serialize_toml (nano::tomlconfig &) const;
34  	nano::error deserialize_toml (nano::tomlconfig &);
35  	bool upgrade_json (unsigned, nano::jsonconfig &);
36  	nano::account random_representative () const;
37  	nano::network_params network_params;
</span>38  	std::optional<uint16_t> peering_port{};
39  	nano::scheduler::optimistic_config optimistic_scheduler;
40  	nano::logging logging;
41  	std::vector<std::pair<std::string, uint16_t>> work_peers;
42  	std::vector<std::pair<std::string, uint16_t>> secondary_work_peers{ { "127.0.0.1", 8076 } }; &bsol;* Default of nano-pow-server */
43  	std::vector<std::string> preconfigured_peers;
44  	std::vector<nano::account> preconfigured_representatives;
45  	unsigned bootstrap_fraction_numerator{ 1 };
46  	nano::amount receive_minimum{ nano::xrb_ratio };
47  	nano::amount vote_minimum{ nano::Gxrb_ratio };
48  	nano::amount rep_crawler_weight_minimum{ "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" };
49  	std::chrono::milliseconds vote_generator_delay{ std::chrono::milliseconds (100) };
50  	unsigned vote_generator_threshold{ 3 };
51  	nano::amount online_weight_minimum{ 60000 * nano::Gxrb_ratio };
52  	unsigned election_hint_weight_percent{ 50 };
53  	unsigned password_fanout{ 1024 };
54  	unsigned io_threads{ std::max (4u, nano::hardware_concurrency ()) };
55  	unsigned network_threads{ std::max (4u, nano::hardware_concurrency ()) };
56  	unsigned work_threads{ std::max (4u, nano::hardware_concurrency ()) };
57  	unsigned background_threads{ std::max (4u, nano::hardware_concurrency ()) };
58  	unsigned signature_checker_threads{ std::max (2u, nano::hardware_concurrency () / 2) };
59  	bool enable_voting{ false };
60  	unsigned bootstrap_connections{ 4 };
61  	unsigned bootstrap_connections_max{ 64 };
62  	unsigned bootstrap_initiator_threads{ 1 };
63  	unsigned bootstrap_serving_threads{ std::max (2u, nano::hardware_concurrency () / 2) };
64  	uint32_t bootstrap_frontier_request_count{ 1024 * 1024 };
65  	nano::websocket::config websocket_config;
66  	nano::diagnostics_config diagnostics_config;
67  	std::size_t confirmation_history_size{ 2048 };
68  	std::string callback_address;
69  	uint16_t callback_port{ 0 };
70  	std::string callback_target;
71  	bool allow_local_peers{ !(network_params.network.is_live_network () || network_params.network.is_test_network ()) }; 
72  	nano::stats_config stats_config;
73  	nano::ipc::ipc_config ipc_config;
74  	std::string external_address;
75  	uint16_t external_port{ 0 };
76  	std::chrono::milliseconds block_processor_batch_max_time{ std::chrono::milliseconds (500) };
77  	std::chrono::seconds block_process_timeout{ 15 };
78  	std::chrono::seconds unchecked_cutoff_time{ std::chrono::seconds (4 * 60 * 60) }; 
79  	std::chrono::seconds tcp_io_timeout{ (network_params.network.is_dev_network () && !is_sanitizer_build ()) ? std::chrono::seconds (5) : std::chrono::seconds (15) };
80  	std::chrono::nanoseconds pow_sleep_interval{ 0 };
81  	std::size_t active_elections_size{ 5000 };
82  	std::size_t active_elections_hinted_limit_percentage{ 20 };
83  	std::size_t active_elections_optimistic_limit_percentage{ 10 };
84  	unsigned tcp_incoming_connections_max{ 2048 };
85  	bool use_memory_pools{ true };
86  	static std::chrono::minutes constexpr wallet_backup_interval = std::chrono::minutes (5);
87  	std::size_t bandwidth_limit{ 10 * 1024 * 1024 };
88  	double bandwidth_limit_burst_ratio{ 3. };
89  	std::size_t bootstrap_bandwidth_limit{ 5 * 1024 * 1024 };
90  	double bootstrap_bandwidth_burst_ratio{ 1. };
91  	nano::bootstrap_ascending_config bootstrap_ascending;
92  	std::chrono::milliseconds conf_height_processor_batch_min_time{ 50 };
93  	bool backup_before_upgrade{ false };
94  	double max_work_generate_multiplier{ 64. };
95  	uint32_t max_queued_requests{ 512 };
96  	std::chrono::seconds max_pruning_age{ !network_params.network.is_beta_network () ? std::chrono::seconds (24 * 60 * 60) : std::chrono::seconds (5 * 60) }; 
97  	uint64_t max_pruning_depth{ 0 };
98  	nano::rocksdb_config rocksdb_config;
99  	nano::lmdb_config lmdb_config;
100  	nano::frontiers_confirmation_mode frontiers_confirmation{ nano::frontiers_confirmation_mode::automatic };
101  	unsigned backlog_scan_batch_size{ 10 * 1000 };
102  	unsigned backlog_scan_frequency{ 10 };
103  public:
104  	std::string serialize_frontiers_confirmation (nano::frontiers_confirmation_mode) const;
105  	nano::frontiers_confirmation_mode deserialize_frontiers_confirmation (std::string const &);
106  	void deserialize_address (std::string const &, std::vector<std::pair<std::string, uint16_t>> &) const;
107  };
108  class node_flags final
109  {
110  public:
111  	std::vector<std::string> config_overrides;
112  	std::vector<std::string> rpc_config_overrides;
113  	bool disable_add_initial_peers{ false }; 
114  	bool disable_backup{ false };
115  	bool disable_lazy_bootstrap{ false };
116  	bool disable_legacy_bootstrap{ false };
117  	bool disable_wallet_bootstrap{ false };
118  	bool disable_bootstrap_listener{ false };
119  	bool disable_bootstrap_bulk_pull_server{ false };
120  	bool disable_bootstrap_bulk_push_client{ false };
121  	bool disable_ongoing_bootstrap{ false }; 
122  	bool disable_ascending_bootstrap{ false };
123  	bool disable_rep_crawler{ false };
124  	bool disable_request_loop{ false }; 
125  	bool disable_tcp_realtime{ false };
126  	bool disable_unchecked_cleanup{ false };
127  	bool disable_unchecked_drop{ true };
128  	bool disable_providing_telemetry_metrics{ false };
129  	bool disable_ongoing_telemetry_requests{ false };
130  	bool disable_block_processor_unchecked_deletion{ false };
131  	bool disable_block_processor_republishing{ false };
132  	bool allow_bootstrap_peers_duplicates{ false };
133  	bool disable_max_peers_per_ip{ false }; 
134  	bool disable_max_peers_per_subnetwork{ false }; 
135  	bool force_use_write_database_queue{ false }; 
136  	bool disable_search_pending{ false }; 
137  	bool enable_pruning{ false };
138  	bool fast_bootstrap{ false };
139  	bool read_only{ false };
140  	bool disable_connection_cleanup{ false };
141  	nano::confirmation_height_mode confirmation_height_processor_mode{ nano::confirmation_height_mode::automatic };
142  	nano::generate_cache generate_cache;
143  	bool inactive_node{ false };
144  	std::size_t block_processor_batch_size{ 0 };
145  	std::size_t block_processor_full_size{ 65536 };
146  	std::size_t block_processor_verification_size{ 0 };
147  	std::size_t inactive_votes_cache_size{ 1024 * 128 };
148  	std::size_t vote_processor_capacity{ 144 * 1024 };
149  	std::size_t bootstrap_interval{ 0 }; 
150  };
151  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-network.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-nodeconfig.hpp</div>
                </div>
                <div class="column column_space"><pre><code>93  std::string getFormData(const std::string &raw_data)
94  {
95      std::stringstream strstrm;
96      std::string line;
97      std::string boundary;
98      std::string file; &bsol;* actual file content */
99      int i = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>31  	node_config (nano::network_params & network_params = nano::dev::network_params);
32  	node_config (const std::optional<uint16_t> &, nano::logging const &, nano::network_params & network_params = nano::dev::network_params);
33  	nano::error serialize_toml (nano::tomlconfig &) const;
34  	nano::error deserialize_toml (nano::tomlconfig &);
35  	bool upgrade_json (unsigned, nano::jsonconfig &);
36  	nano::account random_representative () const;
37  	nano::network_params network_params;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    