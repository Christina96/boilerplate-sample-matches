
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.493893816685949%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</h3>
            <pre><code>1  #ifdef GLib_LINUX
2  extern "C" {
3  	#include <sys/mman.h>
4  }
5  #endif
6  const int TCs::MxMask=0x0FFFFFFF;
7  TCs TCs::GetCsFromBf(char* Bf, const int& BfL){
8    TCs Cs;
9    for (int BfC=0; BfC<BfL; BfC++){Cs+=Bf[BfC];}
10    return Cs;
11  }
12  TStr TSBase::GetSNm() const {
13    return TStr(SNm.CStr());
14  }
15  TSIn::TSIn(const TStr& Str) : TSBase(Str.CStr()), FastMode(false){}
16  void TSIn::LoadCs(){
17    TCs CurCs=Cs; TCs TestCs;
18    Cs+=GetBf(&TestCs, sizeof(TestCs));
19    EAssertR(CurCs==TestCs, "Invalid checksum reading '"+GetSNm()+"'.");
20  }
21  void TSIn::Load(char*& CStr){
22    char Ch; Load(Ch);
23    int CStrLen=int(Ch);
24    EAssertR(CStrLen>=0, "Error reading stream '"+GetSNm()+"'.");
25    CStr=new char[CStrLen+1];
26    if (CStrLen>0){Cs+=GetBf(CStr, CStrLen);}
27    CStr[CStrLen]=TCh::NullCh;
28  }
29  bool TSIn::GetNextLn(TStr& LnStr){
30    TChA LnChA;
31    const bool IsNext=GetNextLn(LnChA);
32    LnStr=LnChA;
33    return IsNext;
34  }
35  bool TSIn::GetNextLn(TChA& LnChA){
36    LnChA.Clr();
37    while (!Eof()){
38      const char Ch=GetCh();
39      if (Ch=='\n'){return true;}
40      if (Ch=='\r' && PeekCh()=='\n'){GetCh(); return true;}
41      LnChA.AddCh(Ch);
42    }
43    return !LnChA.Empty();
44  }
45  const PSIn TSIn::StdIn=PSIn(new TStdIn());
46  TStdIn::TStdIn(): TSBase("Standard input"), TSIn("Standard input") {}
47  TSOut::TSOut(const TStr& Str):
48    TSBase(Str.CStr()), MxLnLen(-1), LnLen(0){}
49  int TSOut::UpdateLnLen(const int& StrLen, const bool& ForceInLn){
50    int Cs=0;
51    if (MxLnLen!=-1){
52      if ((!ForceInLn)&&(LnLen+StrLen>MxLnLen)){Cs+=PutLn();}
53      LnLen+=StrLen;
54    }
55    return Cs;
56  }
57  int TSOut::PutMem(const TMem& Mem){
58    return PutBf(Mem(), Mem.Len());
59  }
60  int TSOut::PutCh(const char& Ch, const int& Chs){
61    int Cs=0;
62    for (int ChN=0; ChN<Chs; ChN++){Cs+=PutCh(Ch);}
63    return Cs;
64  }
65  int TSOut::PutBool(const bool& Bool){
66    return PutStr(TBool::GetStr(Bool));
67  }
68  int TSOut::PutInt(const int& Int){
69    return PutStr(TInt::GetStr(Int));
70  }
71  int TSOut::PutInt(const int& Int, const char* FmtStr){
72    return PutStr(TInt::GetStr(Int, FmtStr));
73  }
74  int TSOut::PutUInt(const uint& UInt){
75    return PutStr(TUInt::GetStr(UInt));
76  }
77  int TSOut::PutUInt(const uint& UInt, const char* FmtStr){
78    return PutStr(TUInt::GetStr(UInt, FmtStr));
79  }
80  int TSOut::PutFlt(const double& Flt){
81    return PutStr(TFlt::GetStr(Flt));
82  }
83  int TSOut::PutFlt(const double& Flt, const char* FmtStr){
84    return PutStr(TFlt::GetStr(Flt, FmtStr));
85  }
86  int TSOut::PutStr(const char* CStr){
87    int Cs=UpdateLnLen(int(strlen(CStr)));
88    return Cs+PutBf(CStr, int(strlen(CStr)));
89  }
90  int TSOut::PutStr(const TChA& ChA){
91    int Cs=UpdateLnLen(ChA.Len());
92    return Cs+PutBf(ChA.CStr(), ChA.Len());
93  }
94  int TSOut::PutStr(const TStr& Str, const char* FmtStr){
95    return PutStr(TStr::GetStr(Str, FmtStr));
96  }
97  int TSOut::PutStr(const TStr& Str, const bool& ForceInLn){
98    int Cs=UpdateLnLen(Str.Len(), ForceInLn);
<span onclick='openModal()' class='match'>99    return Cs+PutBf(Str.CStr(), Str.Len());
100  }
101  int TSOut::PutStrFmt(const char *FmtStr, ...){
102    char Bf[10*1024];
103    va_list valist;
104    va_start(valist, FmtStr);
</span>105    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
106    va_end(valist);
107    return RetVal!=-1 ? PutStr(TStr(Bf)) : 0;	
108  }
109  int TSOut::PutStrFmtLn(const char *FmtStr, ...){
110    char Bf[10*1024];
111    va_list valist;
112    va_start(valist, FmtStr);
113    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
114    va_end(valist);
115    return RetVal!=-1 ? PutStrLn(TStr(Bf)) : PutLn();	
116  }
117  int TSOut::PutIndent(const int& IndentLev){
118    return PutCh(' ', IndentLev*2);
119  }
120  int TSOut::PutLn(const int& Lns){
121    LnLen=0; int Cs=0;
122    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh('\n');}
123    return Cs;
124  }
125  int TSOut::PutDosLn(const int& Lns){
126    LnLen=0; int Cs=0;
127    for (int LnN=0; LnN<Lns; LnN++){Cs+=PutCh(TCh::CrCh)+PutCh(TCh::LfCh);}
128    return Cs;
129  }
130  int TSOut::PutSep(const int& NextStrLen){
131    int Cs=0;
132    if (MxLnLen==-1){
133      Cs+=PutCh(' ');
134    } else {
135      if (LnLen>0){
136        if (LnLen+1+NextStrLen>MxLnLen){Cs+=PutLn();} else {Cs+=PutCh(' ');}
137      }
138    }
139    return Cs;
140  }
141  int TSOut::PutSepLn(const int& Lns){
142    int Cs=0;
143    if (LnLen>0){Cs+=PutLn();}
144    Cs+=PutLn(Lns);
145    return Cs;
146  }
147  void TSOut::Save(const char* CStr){
148    int CStrLen=int(strlen(CStr));
149    EAssertR(CStrLen<=127, "Error writting stream '"+GetSNm()+"'.");
150    Save(char(CStrLen));
151    if (CStrLen>0){Cs+=PutBf(CStr, CStrLen);}
152  }
153  void TSOut::Save(TSIn& SIn, const TSize& BfL){
154    Fail;
155    if (BfL==0){ 
156      while (!SIn.Eof()){Save(SIn.GetCh());}
157    } else {
158      for (TSize BfC=0; BfC<BfL; BfC++){Save(SIn.GetCh());}
159    }
160  }
161  TSOut& TSOut::operator<<(TSIn& SIn) {
162    while (!SIn.Eof())
163      operator<<((char)SIn.GetCh());
164    return *this;
165  }
166  const PSOut TSOut::StdOut=PSOut(new TStdOut());
167  TStdOut::TStdOut(): TSBase(TSStr("Standard output")), TSOut("Standard output"){}
168  int TStdIn::GetBf(const void* LBf, const TSize& LBfL){
169    int LBfS=0;
170    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
171      LBfS+=(((char*)LBf)[LBfC]=GetCh());}
172    return LBfS;
173  }
174  bool TStdIn::GetNextLnBf(TChA& LnChA){
175    FailR(TStr::Fmt("TStdIn::GetNextLnBf: not implemented").CStr());
176    return false;
177  }
178  int TStdOut::PutBf(const void* LBf, const TSize& LBfL){
179    int LBfS=0;
180    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
181      LBfS+=PutCh(((char*)LBf)[LBfC]);}
182    return LBfS;
183  }
184  const int TFIn::MxBfL=16*1024;
185  void TFIn::SetFPos(const int& FPos) const {
186    EAssertR(
187     fseek(FileId, FPos, SEEK_SET)==0,
188     "Error seeking into file '"+GetSNm()+"'.");
189  }
190  int TFIn::GetFPos() const {
191    const int FPos=(int)ftell(FileId);
192    EAssertR(FPos!=-1, "Error seeking into file '"+GetSNm()+"'.");
193    return FPos;
194  }
195  int TFIn::GetFLen() const {
196    const int FPos=GetFPos();
197    EAssertR(
198     fseek(FileId, 0, SEEK_END)==0,
199     "Error seeking into file '"+GetSNm()+"'.");
200    const int FLen=GetFPos(); SetFPos(FPos);
201    return FLen;
202  }
203  void TFIn::FillBf(){
204    EAssertR(
205     (BfC==BfL)&&((BfL==-1)||(BfL==MxBfL)),
206     "Error reading file '"+GetSNm()+"'.");
207    BfL=int(fread(Bf, 1, MxBfL, FileId));
208    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"'.");
209    BfC=0;
210  }
211  TFIn::TFIn(const TStr& FNm):
212    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
213    EAssertR(!FNm.Empty(), "Empty file-name.");
214    FileId=fopen(FNm.CStr(), "rb");
215    EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
216    Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();
217  }
218  TFIn::TFIn(const TStr& FNm, bool& OpenedP):
219    TSBase(FNm.CStr()), TSIn(FNm), FileId(NULL), Bf(NULL), BfC(0), BfL(0){
220    EAssertR(!FNm.Empty(), "Empty file-name.");
221    FileId=fopen(FNm.CStr(), "rb");
222    OpenedP=(FileId!=NULL);
223    if (OpenedP){
224      Bf=new char[MxBfL]; BfC=BfL=-1; FillBf();}
225  }
226  PSIn TFIn::New(const TStr& FNm){
227    try {
228      return PSIn(new TFIn(FNm));
229    } catch (PExcept& Except) {
230      printf("*** Exception: %s\n", Except->GetMsgStr().CStr());
231      EFailR(Except->GetMsgStr());
232    }
233    return PSIn(new TFIn(FNm));
234  }
235  PSIn TFIn::New(const TStr& FNm, bool& OpenedP){
236    return PSIn(new TFIn(FNm, OpenedP));
237  }
238  TFIn::~TFIn(){
239    if (FileId!=NULL){
240      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
241    if (Bf!=NULL){delete[] Bf;}
242  }
243  int TFIn::GetBf(const void* LBf, const TSize& LBfL){
244    int LBfS=0;
245    if (TSize(BfC+LBfL)>TSize(BfL)){
246      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
247        if (BfC==BfL){FillBf();}
248        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
249    } else {
250      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
251        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
252    }
253    return LBfS;
254  }
255  bool TFIn::GetNextLnBf(TChA& LnChA) {
256    int Status;
257    int BfN;        
258    int BfP;        
259    bool CrEnd;     
260    LnChA.Clr();
261    CrEnd = false;
262    do {
263      if (BfC >= BfL) {
264        BfP = 0;
265      } else {
266        BfP = BfC;
267      }
268      Status = FindEol(BfN,CrEnd);
269      if (Status >= 0) {
270        if (BfN-BfP > 0) {
271          LnChA.AddBf(&Bf[BfP],BfN-BfP);
272        }
273        if (Status == 1) {
274          return true;
275        }
276      }
277    } while (Status == 0);
278    return !LnChA.Empty();
279  }
280  int TFIn::FindEol(int& BfN, bool& CrEnd) {
281    char Ch;
282    if (BfC >= BfL) {
283      if (Eof()) {
284        return -1;
285      }
286      if (CrEnd && Bf[BfC]=='\n') {
287        BfC++;
288        BfN = BfC-1;
289        return 1;
290      }
291    }
292    CrEnd = false;
293    while (BfC < BfL) {
294      Ch = Bf[BfC++];
295      if (Ch=='\n') {
296        BfN = BfC-1;
297        return 1;
298      }
299      if (Ch=='\r') {
300        if (BfC == BfL) {
301          CrEnd = true;
302          BfN = BfC-1;
303          return 0;
304        } else if (Bf[BfC]=='\n') {
305          BfC++;
306          BfN = BfC-2;
307          return 1;
308        }
309      }
310    }
311    BfN = BfC;
312    return 0;
313  }
314  const TSize TFOut::MxBfL=16*1024;;
315  void TFOut::FlushBf(){
316    EAssertR(
317     fwrite(Bf, 1, BfL, FileId)==BfL,
318     "Error writting to the file '"+GetSNm()+"'.");
319    BfL=0;
320  }
321  TFOut::TFOut(const TStr& FNm, const bool& Append):
322    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
323    if (FNm.GetUc()=="CON"){
324      FileId=stdout;
325    } else {
326      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
327      else {FileId=fopen(FNm.CStr(), "w+b");}
328      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
329      Bf=new char[MxBfL]; BfL=0;
330    }
331  }
332  TFOut::TFOut(const TStr& FNm, const bool& Append, bool& OpenedP):
333    TSBase(FNm.CStr()), TSOut(FNm), FileId(NULL), Bf(NULL), BfL(0){
334    if (FNm.GetUc()=="CON"){
335      FileId=stdout;
336    } else {
337      if (Append){FileId=fopen(FNm.CStr(), "a+b");}
338      else {FileId=fopen(FNm.CStr(), "w+b");}
339      OpenedP=(FileId!=NULL);
340      if (OpenedP){
341        Bf=new char[MxBfL]; BfL=0;}
342    }
343  }
344  PSOut TFOut::New(const TStr& FNm, const bool& Append){
345    return PSOut(new TFOut(FNm, Append));
346  }
347  PSOut TFOut::New(const TStr& FNm, const bool& Append, bool& OpenedP){
348    PSOut SOut=PSOut(new TFOut(FNm, Append, OpenedP));
349    if (OpenedP){return SOut;} else {return NULL;}
350  }
351  TFOut::~TFOut(){
352    if (FileId!=NULL){FlushBf();}
353    if (Bf!=NULL){delete[] Bf;}
354    if (FileId!=NULL){
355      EAssertR(fclose(FileId)==0, "Can not close file '"+GetSNm()+"'.");}
356  }
357  int TFOut::PutCh(const char& Ch){
358    if (BfL==TSize(MxBfL)){FlushBf();}
359    return Bf[BfL++]=Ch;
360  }
361  int TFOut::PutBf(const void* LBf, const TSize& LBfL){
362    int LBfS=0;
363    if (BfL+LBfL>MxBfL){
364      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
365        LBfS+=PutCh(((char*)LBf)[LBfC]);}
366    } else {
367      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
368        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
369    }
370    return LBfS;
371  }
372  void TFOut::Flush(){
373    FlushBf();
374    EAssertR(fflush(FileId)==0, "Can not flush file '"+GetSNm()+"'.");
375  }
376  TFInOut::TFInOut(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) :
377   TSBase(TSStr(FNm.CStr())), FileId(NULL) {
378    switch (FAccess){
379      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
380      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
381      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
382        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
383      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
384      default: Fail;
385    }
386    if ((FileId==NULL)&&(CreateIfNo)){FileId=fopen(FNm.CStr(), "w+b");}
387    IAssert(FileId!=NULL);
388  }
389  PSInOut TFInOut::New(const TStr& FNm, const TFAccess& FAccess, const bool& CreateIfNo) {
390    return PSInOut(new TFInOut(FNm, FAccess, CreateIfNo));
391  }
392  int TFInOut::GetSize() const {
393    const int FPos = GetPos();
394    IAssert(fseek(FileId, 0, SEEK_END) == 0);
395    const int FLen = GetPos();
396    IAssert(fseek(FileId, FPos, SEEK_SET) == 0);
397    return FLen;
398  }
399  int TFInOut::PutBf(const void* LBf, const TSize& LBfL) {
400    int LBfS = 0;
401    for (TSize i = 0; i < LBfL; i++) {
402      LBfS += ((char *)LBf)[i];
403    }
404    IAssert(fwrite(LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
405    return LBfS;
406  }
407  int TFInOut::GetBf(const void* LBf, const TSize& LBfL) {
408    IAssert(fread((void *)LBf, sizeof(char), LBfL, FileId) == (size_t) LBfL);
409    int LBfS = 0;
410    for (TSize i = 0; i < LBfL; i++) {
411      LBfS += ((char *)LBf)[i];
412    }
413    return LBfS;
414  }
415  bool TFInOut::GetNextLnBf(TChA& LnChA){
416    FailR(TStr::Fmt("TFInOut::GetNextLnBf: not implemented").CStr());
417    return false;
418  }
419  TStr TFInOut::GetFNm() const {
420    return GetSNm();
421  }
422  TShMIn::TShMIn(const TStr& Str): TSBase("Input-Shared_Memory"), 
423      TSIn("Input-Shared_Memory"), TotalLength(0),
424      SizeLeft(0) {
425  #ifdef GLib_LINUX
426        TStr FNm = Str;
427        TFileId FileId;
428        int fd;
429        uint64 FLen;
430        EAssertR(!FNm.Empty(), "Empty file-name.");
431        FileId=fopen(FNm.CStr(), "rb");
432        fd = fileno(FileId);
433        EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
434        EAssertR(
435            fseek(FileId, 0, SEEK_END)==0,
436            "Error seeking into file '"+TStr(FNm)+"'.");
437        FLen=(uint64)ftell(FileId);
438        EAssertR(
439            fseek(FileId, 0, SEEK_SET)==0,
440            "Error seeking into file '"+TStr(FNm)+"'.");
441        char *Mapped;
442        Mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
443        EAssertR(Mapped!=MAP_FAILED, "mmap failed in TShMIn.");
444        OriginalBuffer = Mapped;
445        Cursor = OriginalBuffer;
446        SizeLeft = FLen;
447        TotalLength = FLen;
448        IsMemoryMapped = true;
449  #else
450        TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
451  #endif
452      }
453  TShMIn::TShMIn(void* _Bf, const TSize& _BfL): TSBase("Input-Shared_Memory"), 
454    TSIn("Input-Shared_Memory"), TotalLength(_BfL), SizeLeft(_BfL), IsMemoryMapped(false) {
455      OriginalBuffer = (char*)_Bf;
456      Cursor = (char*)_Bf;
457    }
458  void TShMIn::CloseMapping() {
459    if (OriginalBuffer!=NULL){
460      if (IsMemoryMapped) {
461  #ifdef GLib_LINUX
462        munmap(OriginalBuffer, TotalLength);
463        IsMemoryMapped = false;
464        OriginalBuffer = NULL;
465        Cursor = NULL;
466        TotalLength= 0;
467        SizeLeft = 0;
468  #endif
469      }
470    }
471  }
472  TMIn::TMIn(const void* _Bf, const uint64& _BfL, const bool& TakeBf):
473    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(_BfL), IsMemoryMapped(false){
474    if (TakeBf){
475      Bf=(char*)_Bf;
476    } else {
477      Bf=new char[static_cast<size_t>(BfL)]; memmove(Bf, _Bf, static_cast<size_t>(BfL));
478    }
479  }
480  TMIn::TMIn(TSIn& SIn):
481    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
482    BfL=SIn.Len(); Bf=new char[static_cast<size_t>(BfL)];
483    for (uint64 BfC=0; BfC<BfL; BfC++){Bf[BfC]=SIn.GetCh();}
484  }
485  TMIn::TMIn(const char* CStr):
486    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
487    BfL=uint64(strlen(CStr)); Bf=new char[static_cast<size_t>(BfL+1)]; strcpy(Bf, CStr);
488  }
489  TMIn::TMIn(const TStr& Str, bool FromFile):
490    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0){
491    if (FromFile == false) {
492      BfL=Str.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, Str.CStr(), static_cast<size_t>(BfL));
493      IsMemoryMapped = false;
494    }
495    else {
496  #ifdef GLib_LINUX
497      TStr FNm = Str;
498      TFileId FileId;
499      int fd;
500      uint64 FLen;
501      EAssertR(!FNm.Empty(), "Empty file-name.");
502      FileId=fopen(FNm.CStr(), "rb");
503      fd = fileno(FileId);
504      EAssertR(FileId!=NULL, "Can not open file '"+FNm+"'.");
505      EAssertR(
506          fseek(FileId, 0, SEEK_END)==0,
507          "Error seeking into file '"+TStr(FNm)+"'.");
508      FLen=(uint64)ftell(FileId);
509      EAssertR(
510          fseek(FileId, 0, SEEK_SET)==0,
511          "Error seeking into file '"+TStr(FNm)+"'.");
512      char *mapped;
513      mapped = (char *) mmap (0, FLen, PROT_READ, MAP_PRIVATE, fd, 0);
514      IsMemoryMapped = true;
515      if (mapped == MAP_FAILED) {
516        printf("mmap failed: %d %s\n", fd, strerror (errno));
517        Bf = NULL;
518        BfC = BfL = 0;
519      }
520      else {
521        Bf = mapped;
522        BfC = 0;
523        BfL = FLen;
524      }
525      IsMemoryMapped = true;
526  #else
527      TExcept::Throw("TMIn::TMIn(TStr, Bool): GLib_LINUX undefined.\n");
528  #endif
529    }
530  }
531  TMIn::TMIn(const TChA& ChA):
532    TSBase("Input-Memory"), TSIn("Input-Memory"), Bf(NULL), BfC(0), BfL(0), IsMemoryMapped(false){
533    BfL=ChA.Len(); Bf=new char[static_cast<size_t>(BfL)]; strncpy(Bf, ChA.CStr(), static_cast<size_t>(BfL));
534  }
535  PSIn TMIn::New(const void* _Bf, const uint64& _BfL, const bool& TakeBf){
536    return PSIn(new TMIn(_Bf, _BfL, TakeBf));
537  }
538  PSIn TMIn::New(const char* CStr){
539    return PSIn(new TMIn(CStr));
540  }
541  PSIn TMIn::New(const TStr& Str){
542    return PSIn(new TMIn(Str));
543  }
544  PMIn TMIn::New(const TStr& Str, bool FromFile){
545    return new TMIn(Str, FromFile);
546  }
547  PSIn TMIn::New(const TChA& ChA){
548    return PSIn(new TMIn(ChA));
549  }
550  TMIn::~TMIn(){
551    if (Bf!=NULL){
552      if (IsMemoryMapped) {
553  #ifdef GLib_LINUX
554        munmap(Bf, BfL);
555  #endif
556      }
557      else {
558        delete[] Bf;
559      }
560    }
561  }
562  char TMIn::GetCh(){
563    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
564    return Bf[BfC++];
565  }
566  char TMIn::PeekCh(){
567    EAssertR(BfC<BfL, "Reading beyond the end of stream.");
568    return Bf[BfC];
569  }
570  int TMIn::GetBf(const void* LBf, const TSize& LBfL){
571    EAssertR(TSize(BfC+LBfL)<=TSize(BfL), "Reading beyond the end of stream.");
572    int LBfS=0;
573    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
574      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
575    return LBfS;
576  }
577  int TMIn::FindEol(uint64& BfN, bool& CrEnd) {
578    char Ch;
579    if (BfC >= BfL) {
580      if (Eof()) {
581        return -1;
582      }
583      if (CrEnd && Bf[BfC]=='\n') {
584        BfC++;
585        BfN = BfC-1;
586        return 1;
587      }
588    }
589    CrEnd = false;
590    while (BfC < BfL) {
591      Ch = Bf[BfC++];
592      if (Ch=='\n') {
593        BfN = BfC-1;
594        return 1;
595      }
596      if (Ch=='\r') {
597        if (BfC == BfL) {
598          CrEnd = true;
599          BfN = BfC-1;
600          return 0;
601        } else if (Bf[BfC]=='\n') {
602          BfC++;
603          BfN = BfC-2;
604          return 1;
605        }
606      }
607    }
608    BfN = BfC;
609    return 0;
610  }
611  bool TMIn::GetNextLnBf(TChA& LnChA){
612    FailR(TStr::Fmt("TMIn::GetNextLnBf: not implemented").CStr());
613    return false;
614  }
615  uint64 TMIn::GetBfC() {
616    return BfC;
617  }
618  uint64 TMIn::GetBfL() {
619    return BfL;
620  }
621  void TMIn::SetBfC(uint64 Pos) {
622    BfC = Pos;
623  }
624  uint64 TMIn::CountNewLinesInRange(uint64 Lb, uint64 Ub) {
625    uint64 Cnt = 0;
626    if (Lb >= BfL) {
627      return 0;
628    }
629    for (uint64 i = Lb; i < Ub; i++) {
630      if (Bf[i] == '\n') {
631        Cnt += 1;
632      }
633    }
634    return Cnt;
635  }
636  uint64 TMIn::GetLineStartPos(uint64 Ind) {
637    while (Ind > 0 && Bf[Ind-1] != '\n') {
638      Ind--;
639    }
640    return Ind;
641  }
642  uint64 TMIn::GetLineEndPos(uint64 Ind) {
643    while (Ind < BfL && Bf[Ind] != '\n') {
644      Ind++;
645    }
646    if (Ind == BfL) Ind--;
647    return Ind;
648  }
649  char* TMIn::GetLine(uint64 Index) {
650    return &Bf[Index];
651  }
652  void TMIn::SkipCommentLines() {
653    while (BfC < BfL && TCh::IsHashCh(Bf[BfC])) {
654      while (BfC < BfL && Bf[BfC] != '\n') {
655        BfC++;
656      }
657      BfC++;
658    }
659  }
660  void TMOut::Resize(const int& ReqLen){
661    IAssert(OwnBf&&(BfL==MxBfL || ReqLen >= 0));
662    if (Bf==NULL){
663      IAssert(MxBfL==0); 
664      if (ReqLen < 0) Bf=new char[MxBfL=1024];
665      else Bf=new char[MxBfL=ReqLen];
666    } else {
667      if (ReqLen < 0){ MxBfL*=2; }
668      else if (ReqLen < MxBfL){ return; } 
669      else { MxBfL=(2*MxBfL < ReqLen ? ReqLen : 2*MxBfL); }
670      char* NewBf=new char[MxBfL];
671      memmove(NewBf, Bf, BfL); delete[] Bf; Bf=NewBf;
672    }
673  }
674  TMOut::TMOut(const int& _MxBfL):
675    TSBase("Output-Memory"), TSOut("Output-Memory"),
676    Bf(NULL), BfL(0), MxBfL(0), OwnBf(true){
677    MxBfL=_MxBfL>0?_MxBfL:1024;
678    Bf=new char[MxBfL];
679  }
680  TMOut::TMOut(char* _Bf, const int& _MxBfL):
681    TSBase("Output-Memory"), TSOut("Output-Memory"),
682    Bf(_Bf), BfL(0), MxBfL(_MxBfL), OwnBf(false){}
683  void TMOut::AppendBf(const void* LBf, const TSize& LBfL) {
684    Resize(Len() + (int)LBfL);
685    memcpy(Bf + BfL, LBf, LBfL);
686    BfL += (int)LBfL;
687  }
688  int TMOut::PutBf(const void* LBf, const TSize& LBfL){
689    int LBfS=0;
690    if (TSize(BfL+LBfL)>TSize(MxBfL)){
691      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
692        LBfS+=PutCh(((char*)LBf)[LBfC]);}
693    } else {
694      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
695        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
696    }
697    return LBfS;
698  }
699  TStr TMOut::GetAsStr() const {
700    TChA ChA(BfL);
701    for (int BfC=0; BfC<BfL; BfC++){ChA+=Bf[BfC];}
702    return ChA;
703  }
704  void TMOut::CutBf(const int& CutBfL){
705    IAssert((0<=CutBfL)&&(CutBfL<=BfL));
706    if (CutBfL==BfL){BfL=0;}
707    else {memmove(Bf, Bf+CutBfL, BfL-CutBfL); BfL=BfL-CutBfL;}
708  }
709  PSIn TMOut::GetSIn(const bool& IsCut, const int& CutBfL){
710    IAssert((CutBfL==-1)||((0<=CutBfL)));
711    int SInBfL= (CutBfL==-1) ? BfL : TInt::GetMn(BfL, CutBfL);
712    PSIn SIn;
713    if (OwnBf&&IsCut&&(SInBfL==BfL)){
714      SIn=PSIn(new TMIn(Bf, SInBfL, true));
715      Bf=NULL; BfL=MxBfL=0; OwnBf=true;
716    } else {
717      SIn=PSIn(new TMIn(Bf, SInBfL, false));
718      if (IsCut){CutBf(SInBfL);}
719    }
720    return SIn;
721  }
722  bool TMOut::IsCrLfLn() const {
723    for (int BfC=0; BfC<BfL; BfC++){
724      if ((Bf[BfC]==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){return true;}}
725    return false;
726  }
727  TStr TMOut::GetCrLfLn(){
728    IAssert(IsCrLfLn());
729    TChA Ln;
730    for (int BfC=0; BfC<BfL; BfC++){
731      char Ch=Bf[BfC];
732      if ((Ch==TCh::CrCh)&&((BfC+1<BfL)&&(Bf[BfC+1]==TCh::LfCh))){
733        Ln+=TCh::CrCh; Ln+=TCh::LfCh; CutBf(BfC+1+1); break;
734      } else {
735        Ln+=Ch;
736      }
737    }
738    return Ln;
739  }
740  bool TMOut::IsEolnLn() const {
741    for (int BfC=0; BfC<BfL; BfC++){
742      if ((Bf[BfC]==TCh::CrCh)||(Bf[BfC]==TCh::LfCh)){return true;}
743    }
744    return false;
745  }
746  TStr TMOut::GetEolnLn(const bool& DoAddEoln, const bool& DoCutBf){
747    IAssert(IsEolnLn());
748    int LnChs=0; TChA Ln;
749    for (int BfC=0; BfC<BfL; BfC++){
750      char Ch=Bf[BfC];
751      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
752        LnChs++; if (DoAddEoln){Ln+=Ch;}
753        if (BfC+1<BfL){
754          char NextCh=Bf[BfC+1];
755          if (((Ch==TCh::CrCh)&&(NextCh==TCh::LfCh))||
756           ((Ch==TCh::LfCh)&&(NextCh==TCh::CrCh))){
757            LnChs++; if (DoAddEoln){Ln+=NextCh;}
758          }
759        }
760        break;
761      } else {
762        LnChs++; Ln+=Ch;
763      }
764    }
765    if (DoCutBf){
766      CutBf(LnChs);
767    }
768    return Ln;
769  }
770  void TMOut::MkEolnLn(){
771    if (!IsEolnLn()){
772      PutCh(TCh::CrCh); PutCh(TCh::LfCh);}
773  }
774  bool TLnRet::NextLn(TStr& LnStr) {
775      if (SIn->Eof()) { return false; }
776      TChA LnChA; char Ch = TCh::EofCh;
777      while (!SIn->Eof() && ((Ch=SIn->GetCh())!='\n')) {
778          if (Ch != '\r') { LnChA += Ch; }
779      }
780      LnStr = LnChA; return true;
781  }
782  #ifndef SEEK_SET
783  #define SEEK_CUR    1
784  #define SEEK_END    2
785  #define SEEK_SET    0
786  #endif
787  void TFRnd::RefreshFPos(){
788    EAssertR(
789     fseek(FileId, 0, SEEK_CUR)==0,
790     "Error seeking into file '"+TStr(FNm)+"'.");
791  }
792  TFRnd::TFRnd(const TStr& _FNm, const TFAccess& FAccess,
793   const bool& CreateIfNo, const int& _HdLen, const int& _RecLen):
794    FileId(NULL), FNm(_FNm.CStr()),
795    RecAct(false), HdLen(_HdLen), RecLen(_RecLen){
796    RecAct=(HdLen>=0)&&(RecLen>0);
797    switch (FAccess){
798      case faCreate: FileId=fopen(FNm.CStr(), "w+b"); break;
799      case faUpdate: FileId=fopen(FNm.CStr(), "r+b"); break;
800      case faAppend: FileId=fopen(FNm.CStr(), "r+b");
801        if (FileId!=NULL){fseek(FileId, SEEK_END, 0);} break;
802      case faRdOnly: FileId=fopen(FNm.CStr(), "rb"); break;
803      default: Fail;
804    }
805    if ((FileId==NULL)&&(CreateIfNo)){
806      FileId=fopen(FNm.CStr(), "w+b");}
807    EAssertR(FileId!=NULL, "Can not open file '"+_FNm+"'.");
808  }
809  TFRnd::~TFRnd(){
810    EAssertR(fclose(FileId)==0, "Can not close file '"+TStr(FNm)+"'.");
811  }
812  TStr TFRnd::GetFNm() const {
813    return FNm.CStr();
814  }
815  void TFRnd::SetFPos(const int& FPos){
816    EAssertR(
817     fseek(FileId, FPos, SEEK_SET)==0,
818     "Error seeking into file '"+TStr(FNm)+"'.");
819  }
820  void TFRnd::MoveFPos(const int& DFPos){
821    EAssertR(
822     fseek(FileId, DFPos, SEEK_CUR)==0,
823     "Error seeking into file '"+TStr(FNm)+"'.");
824  }
825  int TFRnd::GetFPos(){
826    int FPos= (int) ftell(FileId);
827    EAssertR(FPos!=-1, "Error seeking into file '"+TStr(FNm)+"'.");
828    return FPos;
829  }
830  int TFRnd::GetFLen(){
831    int FPos=GetFPos();
832    EAssertR(
833     fseek(FileId, 0, SEEK_END)==0,
834     "Error seeking into file '"+TStr(FNm)+"'.");
835    int FLen=GetFPos(); SetFPos(FPos); return FLen;
836  }
837  void TFRnd::SetRecN(const int& RecN){
838    IAssert(RecAct);
839    SetFPos(HdLen+RecN*RecLen);
840  }
841  int TFRnd::GetRecN(){
842    IAssert(RecAct);
843    int FPos=GetFPos()-HdLen;
844    EAssertR(FPos%RecLen==0, "Invalid position in file'"+TStr(FNm)+"'.");
845    return FPos/RecLen;
846  }
847  int TFRnd::GetRecs(){
848    IAssert(RecAct);
849    int FLen=GetFLen()-HdLen;
850    EAssertR(FLen%RecLen==0, "Invalid length of file'"+TStr(FNm)+"'.");
851    return FLen/RecLen;
852  }
853  void TFRnd::GetBf(void* Bf, const TSize& BfL){
854    RefreshFPos();
855    EAssertR(
856     fread(Bf, 1, BfL, FileId)==BfL,
857     "Error reading file '"+TStr(FNm)+"'.");
858  }
859  void TFRnd::PutBf(const void* Bf, const TSize& BfL){
860    RefreshFPos();
861    EAssertR(
862     fwrite(Bf, 1, BfL, FileId)==BfL,
863     "Error writting to the file '"+TStr(FNm)+"'.");
864  }
865  void TFRnd::Flush(){
866    EAssertR(fflush(FileId)==0, "Can not flush file '"+TStr(FNm)+"'.");
867  }
868  void TFRnd::PutCh(const char& Ch, const int& Chs){
869    if (Chs>0){
870      char* CStr=new char[Chs];
871      for (int ChN=0; ChN<Chs; ChN++){CStr[ChN]=Ch;}
872      PutBf(CStr, Chs);
873      delete[] CStr;
874    }
875  }
876  void TFRnd::PutStr(const TStr& Str){
877    PutBf(Str.CStr(), Str.Len()+1);
878  }
879  TStr TFRnd::GetStr(const int& StrLen, bool& IsOk){
880    IsOk=false; TStr Str;
881    if (GetFPos()+StrLen+1<=GetFLen()){
882      char* CStr=new char[StrLen+1];
883      GetBf(CStr, StrLen+1);
884      if (CStr[StrLen+1-1]==TCh::NullCh){IsOk=true; Str=CStr;}
885      delete[] CStr;
886    }
887    return Str;
888  }
889  TStr TFRnd::GetStr(const int& StrLen){
890    TStr Str;
891    char* CStr=new char[StrLen+1];
892    GetBf(CStr, StrLen+1);
893    EAssertR(CStr[StrLen+1-1]==TCh::NullCh, "Error reading file '"+TStr(FNm)+"'.");
894    Str=CStr;
895    delete[] CStr;
896    return Str;
897  }
898  void TFRnd::PutSIn(const PSIn& SIn, TCs& Cs){
899    int BfL=SIn->Len();
900    char* Bf=new char[BfL];
901    SIn->GetBf(Bf, BfL);
902    Cs=TCs::GetCsFromBf(Bf, BfL);
903    PutBf(Bf, BfL);
904    delete[] Bf;
905  }
906  PSIn TFRnd::GetSIn(const int& BfL, TCs& Cs){
907    char* Bf=new char[BfL];
908    GetBf(Bf, BfL);
909    Cs=TCs::GetCsFromBf(Bf, BfL);
910    PSIn SIn=PSIn(new TMIn(Bf, BfL, true));
911    return SIn;
912  }
913  TStr TFRnd::GetStrFromFAccess(const TFAccess& FAccess){
914    switch (FAccess){
915      case faCreate: return "Create";
916      case faUpdate: return "Update";
917      case faAppend: return "Append";
918      case faRdOnly: return "ReadOnly";
919      case faRestore: return "Restore";
920      default: Fail; return TStr();
921    }
922  }
923  TFAccess TFRnd::GetFAccessFromStr(const TStr& Str){
924    TStr UcStr=Str.GetUc();
925    if (UcStr=="CREATE"){return faCreate;}
926    if (UcStr=="UPDATE"){return faUpdate;}
927    if (UcStr=="APPEND"){return faAppend;}
928    if (UcStr=="READONLY"){return faRdOnly;}
929    if (UcStr=="RESTORE"){return faRestore;}
930    if (UcStr=="NEW"){return faCreate;}
931    if (UcStr=="CONT"){return faUpdate;}
932    if (UcStr=="CONTINUE"){return faUpdate;}
933    if (UcStr=="REST"){return faRestore;}
934    if (UcStr=="RESTORE"){return faRestore;}
935    return faUndef;
936  }
937  const TStr TFile::TxtFExt=".Txt";
938  const TStr TFile::HtmlFExt=".Html";
939  const TStr TFile::HtmFExt=".Htm";
940  const TStr TFile::GifFExt=".Gif";
941  const TStr TFile::JarFExt=".Jar";
942  bool TFile::Exists(const TStr& FNm){
943    if (FNm.Empty()) { return false; }
944    bool DoExists;
945    TFIn FIn(FNm, DoExists);
946    return DoExists;
947  }
948  #if defined(GLib_WIN32)
949  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm, 
950   const bool& ThrowExceptP, const bool& FailIfExistsP){
951    if (ThrowExceptP){
952      if (CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP) == 0) {
953          int ErrorCode = (int)GetLastError();
954          TExcept::Throw(TStr::Fmt(
955              "Error %d copying file '%s' to '%s'.", 
956              ErrorCode, SrcFNm.CStr(), DstFNm.CStr()));
957      }
958    } else {
959      CopyFile(SrcFNm.CStr(), DstFNm.CStr(), FailIfExistsP);
960    }
961  }
962  #elif defined(GLib_LINUX)
963  void TFile::Copy(const TStr& SrcFNm, const TStr& DstFNm,
964   const bool& ThrowExceptP, const bool& FailIfExistsP){
965  	int input, output;
966  	size_t filesize;
967  	void *source, *target;
968  	if( (input = open(SrcFNm.CStr(), O_RDONLY)) == -1) {
969  		if (ThrowExceptP) {
970  			TExcept::Throw(TStr::Fmt(
971  			            "Error copying file '%s' to '%s': cannot open source file for reading.",
972  			            SrcFNm.CStr(), DstFNm.CStr()));
973  		} else {
974  			return;
975  		}
976  	}
977  	if( (output = open(DstFNm.CStr(), O_RDWR | O_CREAT | O_TRUNC, 0666)) == -1)	{
978  		close(input);
979  		if (ThrowExceptP) {
980  			TExcept::Throw(TStr::Fmt(
981  			            "Error copying file '%s' to '%s': cannot open destination file for writing.",
982  			            SrcFNm.CStr(), DstFNm.CStr()));
983  		} else {
984  			return;
985  		}
986  	}
987  	filesize = lseek(input, 0, SEEK_END);
988  	lseek(output, filesize - 1, SEEK_SET);
989  	write(output, '\0', 1);
990  	if((source = mmap(0, filesize, PROT_READ, MAP_SHARED, input, 0)) == (void *) -1) {
991  		close(input);
992  		close(output);
993  		if (ThrowExceptP) {
994  			TExcept::Throw(TStr::Fmt(
995  						"Error copying file '%s' to '%s': cannot mmap input file.",
996  						SrcFNm.CStr(), DstFNm.CStr()));
997  		} else {
998  			return;
999  		}
1000  	}
1001  	if((target = mmap(0, filesize, PROT_WRITE, MAP_SHARED, output, 0)) == (void *) -1) {
1002  		munmap(source, filesize);
1003  		close(input);
1004  		close(output);
1005  		if (ThrowExceptP) {
1006  			TExcept::Throw(TStr::Fmt(
1007  						"Error copying file '%s' to '%s': cannot mmap output file.",
1008  						SrcFNm.CStr(), DstFNm.CStr()));
1009  		} else {
1010  			return;
1011  		}
1012  	}
1013  	memcpy(target, source, filesize);
1014  	munmap(source, filesize);
1015  	munmap(target, filesize);
1016  	close(input);
1017  	close(output);
1018  }
1019  #endif
1020  void TFile::Del(const TStr& FNm, const bool& ThrowExceptP){
1021    if (ThrowExceptP){
1022      EAssertR(
1023       remove(FNm.CStr())==0,
1024       "Error removing file '"+FNm+"'.");
1025    } else {
1026      remove(FNm.CStr());
1027    }
1028  }
1029  void TFile::DelWc(const TStr& WcStr, const bool& RecurseDirP){
1030    TStrV FNmV;
1031    TFFile FFile(WcStr, RecurseDirP); TStr FNm;
1032    while (FFile.Next(FNm)){
1033      FNmV.Add(FNm);}
1034    for (int FNmN=0; FNmN<FNmV.Len(); FNmN++){
1035      Del(FNmV[FNmN], false);}
1036  }
1037  void TFile::Rename(const TStr& SrcFNm, const TStr& DstFNm){
1038    EAssertR(
1039     rename(SrcFNm.CStr(), DstFNm.CStr())==0,
1040     "Error renaming file '"+SrcFNm+"' to "+DstFNm+"'.");
1041  }
1042  TStr TFile::GetUniqueFNm(const TStr& FNm){
1043    int Cnt=1; int ch;
1044    TStr NewFNm; TStr TmpFNm=FNm;
1045    if (FNm.SearchCh('#') == -1) {
1046      for (ch = FNm.Len()-1; ch >= 0; ch--) if (FNm[ch] == '.') break;
1047      if (ch != -1) TmpFNm.InsStr(ch, ".#");
1048      else TmpFNm += ".#";
1049    }
1050    forever{
1051      NewFNm=TmpFNm;
1052      NewFNm.ChangeStr("#", TStr::Fmt("%03d", Cnt)); Cnt++;
1053      if (!TFile::Exists(NewFNm)){break;}
1054    }
1055    return NewFNm;
1056  }
1057  #ifdef GLib_WIN
1058  uint64 TFile::GetSize(const TStr& FNm) {
1059      HANDLE hFile = CreateFile(
1060         FNm.CStr(),            
1061         GENERIC_READ,          
1062         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1063         NULL,                  
1064         OPEN_EXISTING,         
1065         FILE_ATTRIBUTE_NORMAL, 
1066         NULL);                 
1067      if (hFile == INVALID_HANDLE_VALUE) {
1068          TExcept::Throw("Can not open file " + FNm + "!"); }
1069      LARGE_INTEGER lpFileSizeHigh;
1070  	if (!GetFileSizeEx(hFile, &lpFileSizeHigh)) {
1071          TExcept::Throw("Can not read size of file " + FNm + "!"); }
1072      CloseHandle(hFile);
1073  	return uint64(lpFileSizeHigh.QuadPart);
1074  }
1075  uint64 TFile::GetCreateTm(const TStr& FNm) {
1076      HANDLE hFile = CreateFile(
1077         FNm.CStr(),            
1078         GENERIC_READ,          
1079         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1080         NULL,                  
1081         OPEN_EXISTING,         
1082         FILE_ATTRIBUTE_NORMAL, 
1083         NULL);                 
1084      if (hFile == INVALID_HANDLE_VALUE) {
1085          TExcept::Throw("Can not open file " + FNm + "!"); }
1086      FILETIME lpCreationTime;
1087      if (!GetFileTime(hFile, &lpCreationTime, NULL, NULL)) {
1088          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1089      CloseHandle(hFile);
1090      TUInt64 UInt64(uint(lpCreationTime.dwHighDateTime), 
1091          uint(lpCreationTime.dwLowDateTime));
1092      return UInt64.Val / uint64(10000);
1093  }
1094  uint64 TFile::GetLastAccessTm(const TStr& FNm) {
1095      HANDLE hFile = CreateFile(
1096         FNm.CStr(),            
1097         GENERIC_READ,          
1098         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1099         NULL,                  
1100         OPEN_EXISTING,         
1101         FILE_ATTRIBUTE_NORMAL, 
1102         NULL);                 
1103      if (hFile == INVALID_HANDLE_VALUE) {
1104          TExcept::Throw("Can not open file " + FNm + "!"); }
1105      FILETIME lpLastAccessTime;
1106      if (!GetFileTime(hFile, NULL, &lpLastAccessTime, NULL)) {
1107          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1108      CloseHandle(hFile);
1109      TUInt64 UInt64(uint(lpLastAccessTime.dwHighDateTime), 
1110          uint(lpLastAccessTime.dwLowDateTime));
1111      return UInt64.Val / uint64(10000);
1112  }
1113  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1114      HANDLE hFile = CreateFile(
1115         FNm.CStr(),            
1116         GENERIC_READ,          
1117         FILE_SHARE_READ | FILE_SHARE_WRITE,       
1118         NULL,                  
1119         OPEN_EXISTING,         
1120         FILE_ATTRIBUTE_NORMAL, 
1121         NULL);                 
1122      if (hFile == INVALID_HANDLE_VALUE) {
1123          TExcept::Throw("Can not open file " + FNm + "!"); }
1124      FILETIME lpLastWriteTime;
1125      if (!GetFileTime(hFile, NULL, NULL, &lpLastWriteTime)) {
1126          TExcept::Throw("Can not read time from file " + FNm + "!"); }
1127      CloseHandle(hFile);
1128      TUInt64 UInt64(uint(lpLastWriteTime.dwHighDateTime), 
1129          uint(lpLastWriteTime.dwLowDateTime));
1130      return UInt64.Val / uint64(10000);
1131  }
1132  #elif defined(GLib_LINUX)
1133  uint64 TFile::GetSize(const TStr& FNm) {
1134  	Fail; return 0;
1135  }
1136  uint64 TFile::GetCreateTm(const TStr& FNm) {
1137  	return GetLastWriteTm(FNm);
1138  }
1139  uint64 TFile::GetLastWriteTm(const TStr& FNm) {
1140  	struct stat st;
1141  	if (stat(FNm.CStr(), &st) != 0) {
1142  		TExcept::Throw("Cannot read tile from file " + FNm + "!");
1143  	}
1144  	return uint64(st.st_mtime);
1145  }
1146  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/node/election.hpp>
3  #include <nano/node/scheduler/buckets.hpp>
4  #include <nano/node/scheduler/component.hpp>
5  #include <nano/node/transport/fake.hpp>
6  #include <nano/node/transport/inproc.hpp>
7  #include <nano/test_common/network.hpp>
8  #include <nano/test_common/system.hpp>
9  #include <nano/test_common/testutil.hpp>
10  #include <gtest/gtest.h>
11  #include <boost/filesystem.hpp>
12  #include <boost/make_shared.hpp>
13  #include <boost/optional.hpp>
14  #include <fstream>
15  #include <numeric>
16  using namespace std::chrono_literals;
17  TEST (node, null_account)
18  {
19  	auto const & null_account = nano::account::null ();
20  	ASSERT_TRUE (null_account == nullptr);
21  	ASSERT_FALSE (null_account != nullptr);
22  	nano::account default_account{};
23  	ASSERT_FALSE (default_account == nullptr);
24  	ASSERT_TRUE (default_account != nullptr);
25  }
26  TEST (node, stop)
27  {
28  	nano::test::system system (1);
29  	ASSERT_NE (system.nodes[0]->wallets.items.end (), system.nodes[0]->wallets.items.begin ());
30  	system.nodes[0]->stop ();
31  	system.io_ctx.run ();
32  	ASSERT_TRUE (true);
33  }
34  TEST (node, work_generate)
35  {
36  	nano::test::system system (1);
37  	auto & node (*system.nodes[0]);
38  	nano::block_hash root{ 1 };
39  	nano::work_version version{ nano::work_version::work_1 };
40  	{
41  		auto difficulty = nano::difficulty::from_multiplier (1.5, node.network_params.work.base);
42  		auto work = node.work_generate_blocking (version, root, difficulty);
43  		ASSERT_TRUE (work.is_initialized ());
44  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
45  	}
46  	{
47  		auto difficulty = nano::difficulty::from_multiplier (0.5, node.network_params.work.base);
48  		boost::optional<uint64_t> work;
49  		do
50  		{
51  			work = node.work_generate_blocking (version, root, difficulty);
52  		} while (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
<span onclick='openModal()' class='match'>53  		ASSERT_TRUE (work.is_initialized ());
54  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
55  		ASSERT_FALSE (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
56  	}
57  }
58  TEST (node, block_store_path_failure)
59  {
60  	nano::test::system system;
61  	auto service (boost::make_shared<boost::asio::io_context> ());
</span>62  	auto path (nano::unique_path ());
63  	nano::logging logging;
64  	logging.init (path);
65  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
66  	auto node (std::make_shared<nano::node> (*service, system.get_available_port (), path, logging, pool));
67  	ASSERT_TRUE (node->wallets.items.empty ());
68  	node->stop ();
69  }
70  #if defined(__clang__) && defined(__linux__) && CI
71  TEST (node_DeathTest, DISABLED_readonly_block_store_not_exist)
72  #else
73  TEST (node_DeathTest, readonly_block_store_not_exist)
74  #endif
75  {
76  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
77  	{
78  		nano::inactive_node node (nano::unique_path (), nano::inactive_node_flag_defaults ());
79  		ASSERT_TRUE (node.node->init_error ());
80  	}
81  	else
82  	{
83  		ASSERT_EXIT (nano::inactive_node node (nano::unique_path (), nano::inactive_node_flag_defaults ()), ::testing::ExitedWithCode (1), "");
84  	}
85  }
86  TEST (node, password_fanout)
87  {
88  	nano::test::system system;
89  	boost::asio::io_context io_ctx;
90  	auto path (nano::unique_path ());
91  	nano::node_config config;
92  	config.peering_port = system.get_available_port ();
93  	config.logging.init (path);
94  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
95  	config.password_fanout = 10;
96  	nano::node node (io_ctx, path, config, pool);
97  	auto wallet (node.wallets.create (100));
98  	ASSERT_EQ (10, wallet->store.password.values.size ());
99  	node.stop ();
100  }
101  TEST (node, balance)
102  {
103  	nano::test::system system (1);
104  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
105  	auto transaction (system.nodes[0]->store.tx_begin_write ());
106  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max (), system.nodes[0]->ledger.account_balance (transaction, nano::dev::genesis_key.pub));
107  }
108  TEST (node, representative)
109  {
110  	nano::test::system system (1);
111  	auto block1 (system.nodes[0]->rep_block (nano::dev::genesis_key.pub));
112  	{
113  		auto transaction (system.nodes[0]->store.tx_begin_read ());
114  		ASSERT_TRUE (system.nodes[0]->ledger.store.block.exists (transaction, block1));
115  	}
116  	nano::keypair key;
117  	ASSERT_TRUE (system.nodes[0]->rep_block (key.pub).is_zero ());
118  }
119  TEST (node, send_unkeyed)
120  {
121  	nano::test::system system (1);
122  	nano::keypair key2;
123  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
124  	system.wallet (0)->store.password.value_set (nano::keypair ().prv);
125  	ASSERT_EQ (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
126  }
127  TEST (node, send_self)
128  {
129  	nano::test::system system (1);
130  	nano::keypair key2;
131  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
132  	system.wallet (0)->insert_adhoc (key2.prv);
133  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
134  	ASSERT_TIMELY (10s, !system.nodes[0]->balance (key2.pub).is_zero ());
135  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
136  }
137  TEST (node, send_single)
138  {
139  	nano::test::system system (2);
140  	nano::keypair key2;
141  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
142  	system.wallet (1)->insert_adhoc (key2.prv);
143  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
144  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
145  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
146  	ASSERT_TIMELY (10s, !system.nodes[0]->balance (key2.pub).is_zero ());
147  }
148  TEST (node, send_single_observing_peer)
149  {
150  	nano::test::system system (3);
151  	nano::keypair key2;
152  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
153  	system.wallet (1)->insert_adhoc (key2.prv);
154  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
155  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
156  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
157  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return !node_a->balance (key2.pub).is_zero (); }));
158  }
159  TEST (node, send_out_of_order)
160  {
161  	nano::test::system system (2);
162  	auto & node1 (*system.nodes[0]);
163  	nano::keypair key2;
164  	nano::send_block_builder builder;
165  	auto send1 = builder.make_block ()
166  				 .previous (nano::dev::genesis->hash ())
167  				 .destination (key2.pub)
168  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
169  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
170  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
171  				 .build_shared ();
172  	auto send2 = builder.make_block ()
173  				 .previous (send1->hash ())
174  				 .destination (key2.pub)
175  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 2 * node1.config.receive_minimum.number ())
176  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
177  				 .work (*system.work.generate (send1->hash ()))
178  				 .build_shared ();
179  	auto send3 = builder.make_block ()
180  				 .previous (send2->hash ())
181  				 .destination (key2.pub)
182  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 3 * node1.config.receive_minimum.number ())
183  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
184  				 .work (*system.work.generate (send2->hash ()))
185  				 .build_shared ();
186  	node1.process_active (send3);
187  	node1.process_active (send2);
188  	node1.process_active (send1);
189  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return node_a->balance (nano::dev::genesis_key.pub) == nano::dev::constants.genesis_amount - node1.config.receive_minimum.number () * 3; }));
190  }
191  TEST (node, quick_confirm)
192  {
193  	nano::test::system system (1);
194  	auto & node1 (*system.nodes[0]);
195  	nano::keypair key;
196  	nano::block_hash previous (node1.latest (nano::dev::genesis_key.pub));
197  	auto genesis_start_balance (node1.balance (nano::dev::genesis_key.pub));
198  	system.wallet (0)->insert_adhoc (key.prv);
199  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
200  	auto send = nano::send_block_builder ()
201  				.previous (previous)
202  				.destination (key.pub)
203  				.balance (node1.online_reps.delta () + 1)
204  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
205  				.work (*system.work.generate (previous))
206  				.build_shared ();
207  	node1.process_active (send);
208  	ASSERT_TIMELY (10s, !node1.balance (key.pub).is_zero ());
209  	ASSERT_EQ (node1.balance (nano::dev::genesis_key.pub), node1.online_reps.delta () + 1);
210  	ASSERT_EQ (node1.balance (key.pub), genesis_start_balance - (node1.online_reps.delta () + 1));
211  }
212  TEST (node, node_receive_quorum)
213  {
214  	nano::test::system system (1);
215  	auto & node1 = *system.nodes[0];
216  	nano::keypair key;
217  	nano::block_hash previous (node1.latest (nano::dev::genesis_key.pub));
218  	system.wallet (0)->insert_adhoc (key.prv);
219  	auto send = nano::send_block_builder ()
220  				.previous (previous)
221  				.destination (key.pub)
222  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
223  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
224  				.work (*system.work.generate (previous))
225  				.build_shared ();
226  	node1.process_active (send);
227  	ASSERT_TIMELY (10s, node1.ledger.block_or_pruned_exists (send->hash ()));
228  	ASSERT_TIMELY (10s, node1.active.election (nano::qualified_root (previous, previous)) != nullptr);
229  	auto election (node1.active.election (nano::qualified_root (previous, previous)));
230  	ASSERT_NE (nullptr, election);
231  	ASSERT_FALSE (election->confirmed ());
232  	ASSERT_EQ (1, election->votes ().size ());
233  	nano::test::system system2;
234  	system2.add_node ();
235  	system2.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
236  	ASSERT_TRUE (node1.balance (key.pub).is_zero ());
237  	node1.network.tcp_channels.start_tcp (system2.nodes[0]->network.endpoint ());
238  	while (node1.balance (key.pub).is_zero ())
239  	{
240  		ASSERT_NO_ERROR (system.poll ());
241  		ASSERT_NO_ERROR (system2.poll ());
242  	}
243  }
244  TEST (node, auto_bootstrap)
245  {
246  	nano::test::system system;
247  	nano::node_config config (system.get_available_port (), system.logging);
248  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
249  	nano::node_flags node_flags;
250  	node_flags.disable_bootstrap_bulk_push_client = true;
251  	node_flags.disable_lazy_bootstrap = true;
252  	auto node0 = system.add_node (config, node_flags);
253  	nano::keypair key2;
254  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
255  	system.wallet (0)->insert_adhoc (key2.prv);
256  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0->config.receive_minimum.number ()));
257  	ASSERT_NE (nullptr, send1);
258  	ASSERT_TIMELY (10s, node0->balance (key2.pub) == node0->config.receive_minimum.number ());
259  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
260  	ASSERT_FALSE (node1->init_error ());
261  	node1->start ();
262  	system.nodes.push_back (node1);
263  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
264  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
265  	ASSERT_TIMELY (10s, node1->balance (key2.pub) == node0->config.receive_minimum.number ());
266  	ASSERT_TIMELY (10s, !node1->bootstrap_initiator.in_progress ());
267  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send1->hash ()));
268  	ASSERT_TIMELY (5s, node1->ledger.cache.block_count == 3);
269  	ASSERT_TIMELY (5s, node1->ledger.cache.cemented_count == 3);
270  	node1->stop ();
271  }
272  TEST (node, auto_bootstrap_reverse)
273  {
274  	nano::test::system system;
275  	nano::node_config config (system.get_available_port (), system.logging);
276  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
277  	nano::node_flags node_flags;
278  	node_flags.disable_bootstrap_bulk_push_client = true;
279  	node_flags.disable_lazy_bootstrap = true;
280  	auto node0 = system.add_node (config, node_flags);
281  	nano::keypair key2;
282  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
283  	system.wallet (0)->insert_adhoc (key2.prv);
284  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
285  	ASSERT_FALSE (node1->init_error ());
286  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0->config.receive_minimum.number ()));
287  	node1->start ();
288  	system.nodes.push_back (node1);
289  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node0, node1->network.endpoint ()));
290  	ASSERT_TIMELY (10s, node1->balance (key2.pub) == node0->config.receive_minimum.number ());
291  }
292  TEST (node, auto_bootstrap_age)
293  {
294  	nano::test::system system;
295  	nano::node_config config (system.get_available_port (), system.logging);
296  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
297  	nano::node_flags node_flags;
298  	node_flags.disable_bootstrap_bulk_push_client = true;
299  	node_flags.disable_lazy_bootstrap = true;
300  	node_flags.bootstrap_interval = 1;
301  	auto node0 = system.add_node (config, node_flags);
302  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
303  	ASSERT_FALSE (node1->init_error ());
304  	node1->start ();
305  	system.nodes.push_back (node1);
306  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
307  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
308  	ASSERT_TIMELY (10s, node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out) >= 3);
309  	ASSERT_GE (node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out), node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate, nano::stat::dir::out));
310  	node1->stop ();
311  }
312  TEST (node, receive_gap)
313  {
314  	nano::test::system system (1);
315  	auto & node1 (*system.nodes[0]);
316  	ASSERT_EQ (0, node1.gap_cache.size ());
317  	auto block = nano::send_block_builder ()
318  				 .previous (5)
319  				 .destination (1)
320  				 .balance (2)
321  				 .sign (nano::keypair ().prv, 4)
322  				 .work (0)
323  				 .build_shared ();
324  	node1.work_generate_blocking (*block);
325  	nano::publish message{ nano::dev::network_params.network, block };
326  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
327  	node1.network.inbound (message, channel1);
328  	node1.block_processor.flush ();
329  	ASSERT_EQ (1, node1.gap_cache.size ());
330  }
331  TEST (node, merge_peers)
332  {
333  	nano::test::system system (1);
334  	std::array<nano::endpoint, 8> endpoints;
335  	endpoints.fill (nano::endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ()));
336  	endpoints[0] = nano::endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
337  	system.nodes[0]->network.merge_peers (endpoints);
338  	ASSERT_EQ (0, system.nodes[0]->network.size ());
339  }
340  TEST (node, search_receivable)
341  {
342  	nano::test::system system (1);
343  	auto node (system.nodes[0]);
344  	nano::keypair key2;
345  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
346  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
347  	system.wallet (0)->insert_adhoc (key2.prv);
348  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
349  	ASSERT_TIMELY (10s, !node->balance (key2.pub).is_zero ());
350  }
351  TEST (node, search_receivable_same)
352  {
353  	nano::test::system system (1);
354  	auto node (system.nodes[0]);
355  	nano::keypair key2;
356  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
357  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
358  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
359  	system.wallet (0)->insert_adhoc (key2.prv);
360  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
361  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
362  }
363  TEST (node, search_receivable_multiple)
364  {
365  	nano::test::system system (1);
366  	auto node (system.nodes[0]);
367  	nano::keypair key2;
368  	nano::keypair key3;
369  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
370  	system.wallet (0)->insert_adhoc (key3.prv);
371  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key3.pub, node->config.receive_minimum.number ()));
372  	ASSERT_TIMELY (10s, !node->balance (key3.pub).is_zero ());
373  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
374  	ASSERT_NE (nullptr, system.wallet (0)->send_action (key3.pub, key2.pub, node->config.receive_minimum.number ()));
375  	system.wallet (0)->insert_adhoc (key2.prv);
376  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
377  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
378  }
379  TEST (node, search_receivable_confirmed)
380  {
381  	nano::test::system system;
382  	nano::node_config node_config (system.get_available_port (), system.logging);
383  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
384  	auto node = system.add_node (node_config);
385  	nano::keypair key2;
386  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
387  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
388  	ASSERT_NE (nullptr, send1);
389  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
390  	ASSERT_NE (nullptr, send2);
391  	ASSERT_TIMELY (10s, node->active.empty ());
392  	bool confirmed (false);
393  	system.deadline_set (5s);
394  	while (!confirmed)
395  	{
396  		auto transaction (node->store.tx_begin_read ());
397  		confirmed = node->ledger.block_confirmed (transaction, send2->hash ());
398  		ASSERT_NO_ERROR (system.poll ());
399  	}
400  	{
401  		auto transaction (node->wallets.tx_begin_write ());
402  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
403  	}
404  	system.wallet (0)->insert_adhoc (key2.prv);
405  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
406  	{
407  		ASSERT_FALSE (node->active.active (send1->hash ()));
408  		ASSERT_FALSE (node->active.active (send2->hash ()));
409  	}
410  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
411  }
412  TEST (node, search_receivable_pruned)
413  {
414  	nano::test::system system;
415  	nano::node_config node_config (system.get_available_port (), system.logging);
416  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
417  	auto node1 = system.add_node (node_config);
418  	nano::node_flags node_flags;
419  	node_flags.enable_pruning = true;
420  	nano::node_config config (system.get_available_port (), system.logging);
421  	config.enable_voting = false; 
422  	auto node2 = system.add_node (config, node_flags);
423  	nano::keypair key2;
424  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
425  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node2->config.receive_minimum.number ()));
426  	ASSERT_NE (nullptr, send1);
427  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node2->config.receive_minimum.number ()));
428  	ASSERT_NE (nullptr, send2);
429  	ASSERT_TIMELY (10s, node1->active.empty () && node2->active.empty ());
430  	ASSERT_TIMELY (5s, node1->ledger.block_confirmed (node1->store.tx_begin_read (), send2->hash ()));
431  	ASSERT_TIMELY (5s, node2->ledger.cache.cemented_count == 3);
432  	system.wallet (0)->store.erase (node1->wallets.tx_begin_write (), nano::dev::genesis_key.pub);
433  	{
434  		auto transaction (node2->store.tx_begin_write ());
435  		ASSERT_EQ (1, node2->ledger.pruning_action (transaction, send1->hash (), 1));
436  	}
437  	ASSERT_EQ (1, node2->ledger.cache.pruned_count);
438  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ())); 
439  	system.wallet (1)->insert_adhoc (key2.prv);
440  	ASSERT_FALSE (system.wallet (1)->search_receivable (system.wallet (1)->wallets.tx_begin_read ()));
441  	ASSERT_TIMELY (10s, node2->balance (key2.pub) == 2 * node2->config.receive_minimum.number ());
442  }
443  TEST (node, unlock_search)
444  {
445  	nano::test::system system (1);
446  	auto node (system.nodes[0]);
447  	nano::keypair key2;
448  	nano::uint128_t balance (node->balance (nano::dev::genesis_key.pub));
449  	{
450  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
451  		system.wallet (0)->store.rekey (transaction, "");
452  	}
453  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
454  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
455  	ASSERT_TIMELY (10s, node->balance (nano::dev::genesis_key.pub) != balance);
456  	ASSERT_TIMELY (10s, node->active.empty ());
457  	system.wallet (0)->insert_adhoc (key2.prv);
458  	{
459  		nano::lock_guard<std::recursive_mutex> lock{ system.wallet (0)->store.mutex };
460  		system.wallet (0)->store.password.value_set (nano::keypair ().prv);
461  	}
462  	{
463  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
464  		ASSERT_FALSE (system.wallet (0)->enter_password (transaction, ""));
465  	}
466  	ASSERT_TIMELY (10s, !node->balance (key2.pub).is_zero ());
467  }
468  TEST (node, working)
469  {
470  	auto path (nano::working_path ());
471  	ASSERT_FALSE (path.empty ());
472  }
473  TEST (node, price)
474  {
475  	nano::test::system system (1);
476  	auto price1 (system.nodes[0]->price (nano::Gxrb_ratio, 1));
477  	ASSERT_EQ (nano::node::price_max * 100.0, price1);
478  	auto price2 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff + 1), 1));
479  	ASSERT_EQ (0, price2);
480  	auto price3 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff + 2) / 2, 1));
481  	ASSERT_EQ (nano::node::price_max * 100.0 / 2, price3);
482  	auto price4 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff) * 2, 1));
483  	ASSERT_EQ (0, price4);
484  }
485  TEST (node, confirm_locked)
486  {
487  	nano::test::system system (1);
488  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
489  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
490  	system.wallet (0)->enter_password (transaction, "1");
491  	auto block = nano::send_block_builder ()
492  				 .previous (0)
493  				 .destination (0)
494  				 .balance (0)
495  				 .sign (nano::keypair ().prv, 0)
496  				 .work (0)
497  				 .build_shared ();
498  	system.nodes[0]->network.flood_block (block);
499  }
500  TEST (node_config, random_rep)
501  {
502  	auto path (nano::unique_path ());
503  	nano::logging logging1;
504  	logging1.init (path);
505  	nano::node_config config1 (100, logging1);
506  	auto rep (config1.random_representative ());
507  	ASSERT_NE (config1.preconfigured_representatives.end (), std::find (config1.preconfigured_representatives.begin (), config1.preconfigured_representatives.end (), rep));
508  }
509  TEST (node, fork_publish)
510  {
511  	std::weak_ptr<nano::node> node0;
512  	{
513  		nano::test::system system (1);
514  		node0 = system.nodes[0];
515  		auto & node1 (*system.nodes[0]);
516  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
517  		nano::keypair key1;
518  		nano::send_block_builder builder;
519  		auto send1 = builder.make_block ()
520  					 .previous (nano::dev::genesis->hash ())
521  					 .destination (key1.pub)
522  					 .balance (nano::dev::constants.genesis_amount - 100)
523  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
524  					 .work (0)
525  					 .build_shared ();
526  		node1.work_generate_blocking (*send1);
527  		nano::keypair key2;
528  		auto send2 = builder.make_block ()
529  					 .previous (nano::dev::genesis->hash ())
530  					 .destination (key2.pub)
531  					 .balance (nano::dev::constants.genesis_amount - 100)
532  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
533  					 .work (0)
534  					 .build_shared ();
535  		node1.work_generate_blocking (*send2);
536  		node1.process_active (send1);
537  		node1.block_processor.flush ();
538  		ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
539  		auto election (node1.active.election (send1->qualified_root ()));
540  		ASSERT_NE (nullptr, election);
541  		ASSERT_TIMELY (1s, election->votes ().size () == 2);
542  		node1.process_active (send2);
543  		node1.block_processor.flush ();
544  		auto votes1 (election->votes ());
545  		auto existing1 (votes1.find (nano::dev::genesis_key.pub));
546  		ASSERT_NE (votes1.end (), existing1);
547  		ASSERT_EQ (send1->hash (), existing1->second.hash);
548  		auto winner (*election->tally ().begin ());
549  		ASSERT_EQ (*send1, *winner.second);
550  		ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
551  	}
552  	ASSERT_TRUE (node0.expired ());
553  }
554  TEST (node, fork_publish_inactive)
555  {
556  	nano::test::system system (1);
557  	auto & node = *system.nodes[0];
558  	nano::keypair key1;
559  	nano::keypair key2;
560  	nano::send_block_builder builder;
561  	auto send1 = builder.make_block ()
562  				 .previous (nano::dev::genesis->hash ())
563  				 .destination (key1.pub)
564  				 .balance (nano::dev::constants.genesis_amount - 100)
565  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
566  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
567  				 .build_shared ();
568  	auto send2 = builder.make_block ()
569  				 .previous (nano::dev::genesis->hash ())
570  				 .destination (key2.pub)
571  				 .balance (nano::dev::constants.genesis_amount - 100)
572  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
573  				 .work (send1->block_work ())
574  				 .build_shared ();
575  	node.process_active (send1);
576  	ASSERT_TIMELY (5s, node.block (send1->hash ()));
577  	std::shared_ptr<nano::election> election;
578  	ASSERT_TIMELY (5s, election = node.active.election (send1->qualified_root ()));
579  	ASSERT_EQ (nano::process_result::fork, node.process_local (send2).value ().code);
580  	auto blocks = election->blocks ();
581  	ASSERT_TIMELY_EQ (5s, blocks.size (), 2);
582  	ASSERT_NE (blocks.end (), blocks.find (send1->hash ()));
583  	ASSERT_NE (blocks.end (), blocks.find (send2->hash ()));
584  	ASSERT_EQ (election->winner ()->hash (), send1->hash ());
585  	ASSERT_NE (election->winner ()->hash (), send2->hash ());
586  }
587  TEST (node, fork_keep)
588  {
589  	nano::test::system system (2);
590  	auto & node1 (*system.nodes[0]);
591  	auto & node2 (*system.nodes[1]);
592  	ASSERT_EQ (1, node1.network.size ());
593  	nano::keypair key1;
594  	nano::keypair key2;
595  	nano::send_block_builder builder;
596  	auto send1 = builder.make_block ()
597  				 .previous (nano::dev::genesis->hash ())
598  				 .destination (key1.pub)
599  				 .balance (nano::dev::constants.genesis_amount - 100)
600  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
601  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
602  				 .build_shared ();
603  	auto send2 = builder.make_block ()
604  				 .previous (nano::dev::genesis->hash ())
605  				 .destination (key2.pub)
606  				 .balance (nano::dev::constants.genesis_amount - 100)
607  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
608  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
609  				 .build_shared ();
610  	node1.process_active (send1);
611  	node1.block_processor.flush ();
612  	node2.process_active (send1);
613  	node2.block_processor.flush ();
614  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
615  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
616  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
617  	node1.process_active (send2);
618  	node1.block_processor.flush ();
619  	node2.process_active (send2);
620  	node2.block_processor.flush ();
621  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
622  	ASSERT_NE (nullptr, election1);
623  	ASSERT_EQ (1, election1->votes ().size ());
624  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
625  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1->hash ()));
626  	ASSERT_TIMELY (1.5min, election1->votes ().size () != 1);
627  	auto transaction0 (node1.store.tx_begin_read ());
628  	auto transaction1 (node2.store.tx_begin_read ());
629  	auto winner (*election1->tally ().begin ());
630  	ASSERT_EQ (*send1, *winner.second);
631  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
632  	ASSERT_TRUE (node1.store.block.exists (transaction0, send1->hash ()));
633  	ASSERT_TRUE (node2.store.block.exists (transaction1, send1->hash ()));
634  }
635  TEST (node, fork_flip)
636  {
637  	nano::test::system system (2);
638  	auto & node1 (*system.nodes[0]);
639  	auto & node2 (*system.nodes[1]);
640  	ASSERT_EQ (1, node1.network.size ());
641  	nano::keypair key1;
642  	nano::send_block_builder builder;
643  	auto send1 = builder.make_block ()
644  				 .previous (nano::dev::genesis->hash ())
645  				 .destination (key1.pub)
646  				 .balance (nano::dev::constants.genesis_amount - 100)
647  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
648  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
649  				 .build_shared ();
650  	nano::publish publish1{ nano::dev::network_params.network, send1 };
651  	nano::keypair key2;
652  	auto send2 = builder.make_block ()
653  				 .previous (nano::dev::genesis->hash ())
654  				 .destination (key2.pub)
655  				 .balance (nano::dev::constants.genesis_amount - 100)
656  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
657  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
658  				 .build_shared ();
659  	nano::publish publish2{ nano::dev::network_params.network, send2 };
660  	auto ignored_channel{ std::make_shared<nano::transport::channel_tcp> (node1, std::weak_ptr<nano::transport::socket> ()) };
661  	node1.network.inbound (publish1, ignored_channel);
662  	node1.block_processor.flush ();
663  	node2.network.inbound (publish2, ignored_channel);
664  	node2.block_processor.flush ();
665  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
666  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
667  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
668  	node1.network.inbound (publish2, ignored_channel);
669  	node1.block_processor.flush ();
670  	node2.network.inbound (publish1, ignored_channel);
671  	node2.block_processor.flush ();
672  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
673  	ASSERT_NE (nullptr, election1);
674  	ASSERT_EQ (1, election1->votes ().size ());
675  	ASSERT_NE (nullptr, node1.block (publish1.block->hash ()));
676  	ASSERT_NE (nullptr, node2.block (publish2.block->hash ()));
677  	ASSERT_TIMELY (10s, node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
678  	auto winner (*election1->tally ().begin ());
679  	ASSERT_EQ (*publish1.block, *winner.second);
680  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
681  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
682  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
683  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
684  }
685  TEST (node, fork_multi_flip)
686  {
687  	auto type = nano::transport::transport_type::tcp;
688  	nano::test::system system;
689  	nano::node_flags node_flags;
690  	nano::node_config node_config (system.get_available_port (), system.logging);
691  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
692  	auto & node1 (*system.add_node (node_config, node_flags, type));
693  	node_config.peering_port = system.get_available_port ();
694  	auto & node2 (*system.add_node (node_config, node_flags, type));
695  	ASSERT_EQ (1, node1.network.size ());
696  	nano::keypair key1;
697  	nano::send_block_builder builder;
698  	auto send1 = builder.make_block ()
699  				 .previous (nano::dev::genesis->hash ())
700  				 .destination (key1.pub)
701  				 .balance (nano::dev::constants.genesis_amount - 100)
702  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
703  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
704  				 .build_shared ();
705  	nano::publish publish1{ nano::dev::network_params.network, send1 };
706  	nano::keypair key2;
707  	auto send2 = builder.make_block ()
708  				 .previous (nano::dev::genesis->hash ())
709  				 .destination (key2.pub)
710  				 .balance (nano::dev::constants.genesis_amount - 100)
711  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
712  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
713  				 .build_shared ();
714  	nano::publish publish2{ nano::dev::network_params.network, send2 };
715  	auto send3 = builder.make_block ()
716  				 .previous (publish2.block->hash ())
717  				 .destination (key2.pub)
718  				 .balance (nano::dev::constants.genesis_amount - 100)
719  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
720  				 .work (*system.work.generate (publish2.block->hash ()))
721  				 .build_shared ();
722  	nano::publish publish3{ nano::dev::network_params.network, send3 };
723  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
724  	auto channel2 = std::make_shared<nano::transport::fake::channel> (node2);
725  	node1.network.inbound (publish1, channel1);
726  	node2.network.inbound (publish2, channel2);
727  	node2.network.inbound (publish3, channel2);
728  	node1.block_processor.flush ();
729  	node2.block_processor.flush ();
730  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
731  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
732  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
733  	node1.network.inbound (publish2, channel1);
734  	node1.network.inbound (publish3, channel1);
735  	node1.block_processor.flush ();
736  	node2.network.inbound (publish1, channel2);
737  	node2.block_processor.flush ();
738  	ASSERT_TIMELY (5s, node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
739  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
740  	ASSERT_NE (nullptr, election1);
741  	ASSERT_EQ (1, election1->votes ().size ());
742  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
743  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
744  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish3.block->hash ()));
745  	ASSERT_TIMELY (10s, node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
746  	auto winner (*election1->tally ().begin ());
747  	ASSERT_EQ (*publish1.block, *winner.second);
748  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
749  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
750  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
751  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
752  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish3.block->hash ()));
753  }
754  TEST (node, fork_bootstrap_flip)
755  {
756  	nano::test::system system;
757  	nano::test::system system0;
758  	nano::test::system system1;
759  	nano::node_config config0{ system.get_available_port (), system0.logging };
760  	config0.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
761  	nano::node_flags node_flags;
762  	node_flags.disable_bootstrap_bulk_push_client = true;
763  	node_flags.disable_lazy_bootstrap = true;
764  	auto & node1 = *system0.add_node (config0, node_flags);
765  	nano::node_config config1 (system.get_available_port (), system1.logging);
766  	auto & node2 = *system1.add_node (config1, node_flags);
767  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
768  	nano::block_hash latest = node1.latest (nano::dev::genesis_key.pub);
769  	nano::keypair key1;
770  	nano::send_block_builder builder;
771  	auto send1 = builder.make_block ()
772  				 .previous (latest)
773  				 .destination (key1.pub)
774  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
775  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
776  				 .work (*system0.work.generate (latest))
777  				 .build_shared ();
778  	nano::keypair key2;
779  	auto send2 = builder.make_block ()
780  				 .previous (latest)
781  				 .destination (key2.pub)
782  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
783  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
784  				 .work (*system0.work.generate (latest))
785  				 .build_shared ();
786  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (node1.store.tx_begin_write (), *send1).code);
787  	ASSERT_EQ (nano::process_result::progress, node2.ledger.process (node2.store.tx_begin_write (), *send2).code);
788  	ASSERT_TRUE (node2.store.block.exists (node2.store.tx_begin_read (), send2->hash ()));
789  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint ()); 
790  	auto again (true);
791  	system0.deadline_set (50s);
792  	system1.deadline_set (50s);
793  	while (again)
794  	{
795  		ASSERT_NO_ERROR (system0.poll ());
796  		ASSERT_NO_ERROR (system1.poll ());
797  		again = !node2.store.block.exists (node2.store.tx_begin_read (), send1->hash ());
798  	}
799  }
800  TEST (node, fork_open)
801  {
802  	nano::test::system system (1);
803  	auto & node = *system.nodes[0];
804  	std::shared_ptr<nano::election> election;
805  	nano::keypair key1;
806  	auto send1 = nano::send_block_builder ()
807  				 .previous (nano::dev::genesis->hash ())
808  				 .destination (key1.pub)
809  				 .balance (0)
810  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
811  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
812  				 .build_shared ();
813  	nano::publish publish1{ nano::dev::network_params.network, send1 };
814  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node);
815  	node.network.inbound (publish1, channel1);
816  	ASSERT_TIMELY (5s, (election = node.active.election (publish1.block->qualified_root ())) != nullptr);
817  	election->force_confirm ();
818  	ASSERT_TIMELY (5s, node.active.empty () && node.block_confirmed (publish1.block->hash ()));
819  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
820  	nano::open_block_builder builder;
821  	auto open1 = builder.make_block ()
822  				 .source (publish1.block->hash ())
823  				 .representative (1)
824  				 .account (key1.pub)
825  				 .sign (key1.prv, key1.pub)
826  				 .work (*system.work.generate (key1.pub))
827  				 .build_shared ();
828  	nano::publish publish2{ nano::dev::network_params.network, open1 };
829  	node.network.inbound (publish2, channel1);
830  	ASSERT_TIMELY (5s, 1 == node.active.size ());
831  	auto open2 = builder.make_block ()
832  				 .source (publish1.block->hash ())
833  				 .representative (2)
834  				 .account (key1.pub)
835  				 .sign (key1.prv, key1.pub)
836  				 .work (*system.work.generate (key1.pub))
837  				 .build_shared ();
838  	nano::publish publish3{ nano::dev::network_params.network, open2 };
839  	node.network.inbound (publish3, channel1);
840  	ASSERT_TIMELY (5s, (election = node.active.election (publish3.block->qualified_root ())) != nullptr);
841  	ASSERT_TIMELY (5s, 2 == election->blocks ().size ());
842  	ASSERT_EQ (publish2.block->hash (), election->winner ()->hash ());
843  	system.delay_ms (1000ms);
844  	ASSERT_FALSE (election->confirmed ());
845  	ASSERT_TIMELY (5s, node.block (publish2.block->hash ()));
846  	ASSERT_FALSE (node.block (publish3.block->hash ()));
847  }
848  TEST (node, fork_open_flip)
849  {
850  	nano::test::system system (1);
851  	auto & node1 = *system.nodes[0];
852  	std::shared_ptr<nano::election> election;
853  	nano::keypair key1;
854  	nano::keypair rep1;
855  	nano::keypair rep2;
856  	auto send1 = nano::send_block_builder ()
857  				 .previous (nano::dev::genesis->hash ())
858  				 .destination (key1.pub)
859  				 .balance (nano::dev::constants.genesis_amount - 1)
860  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
861  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
862  				 .build_shared ();
863  	node1.process_active (send1);
864  	nano::open_block_builder builder;
865  	auto open1 = builder.make_block ()
866  				 .source (send1->hash ())
867  				 .representative (rep1.pub)
868  				 .account (key1.pub)
869  				 .sign (key1.prv, key1.pub)
870  				 .work (*system.work.generate (key1.pub))
871  				 .build_shared ();
872  	auto open2 = builder.make_block ()
873  				 .source (send1->hash ())
874  				 .representative (rep2.pub)
875  				 .account (key1.pub)
876  				 .sign (key1.prv, key1.pub)
877  				 .work (*system.work.generate (key1.pub))
878  				 .build_shared ();
879  	ASSERT_FALSE (*open1 == *open2);
880  	node1.process_active (open1);
881  	ASSERT_TIMELY (5s, node1.block (open1->hash ()) != nullptr);
882  	node1.scheduler.buckets.manual (open1);
883  	ASSERT_TIMELY (5s, (election = node1.active.election (open1->qualified_root ())) != nullptr);
884  	election->transition_active ();
885  	system.initialization_blocks.push_back (send1);
886  	system.initialization_blocks.push_back (open2);
887  	auto & node2 = *system.add_node ();
888  	system.initialization_blocks.clear ();
889  	ASSERT_TIMELY (5s, node2.block (open2->hash ()) != nullptr);
890  	node2.scheduler.buckets.manual (open2);
891  	ASSERT_TIMELY (5s, (election = node2.active.election (open2->qualified_root ())) != nullptr);
892  	election->transition_active ();
893  	ASSERT_TIMELY (5s, 2 == node1.active.size ());
894  	ASSERT_TIMELY (5s, 2 == node2.active.size ());
895  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
896  	ASSERT_TIMELY (5s, node1.block_confirmed (open1->hash ()));
897  	node1.process_active (open2);
898  	node2.process_active (open1);
899  	ASSERT_TIMELY (5s, 2 == election->votes ().size ()); 
900  	ASSERT_TIMELY (10s, node2.block (open1->hash ()));
901  	ASSERT_TIMELY (5s, node1.block_confirmed (open1->hash ()));
902  	auto winner = *election->tally ().begin ();
903  	ASSERT_EQ (*open1, *winner.second);
904  	ASSERT_EQ (nano::dev::constants.genesis_amount - 1, winner.first);
905  	auto transaction1 (node1.store.tx_begin_read ());
906  	auto transaction2 (node2.store.tx_begin_read ());
907  	ASSERT_TRUE (node1.store.block.exists (transaction1, open1->hash ()));
908  	ASSERT_TRUE (node2.store.block.exists (transaction2, open1->hash ()));
909  	ASSERT_FALSE (node2.store.block.exists (transaction2, open2->hash ()));
910  }
911  TEST (node, coherent_observer)
912  {
913  	nano::test::system system (1);
914  	auto & node1 (*system.nodes[0]);
915  	node1.observers.blocks.add ([&node1] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const &, nano::account const &, nano::uint128_t const &, bool, bool) {
916  		auto transaction (node1.store.tx_begin_read ());
917  		ASSERT_TRUE (node1.store.block.exists (transaction, status_a.winner->hash ()));
918  	});
919  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
920  	nano::keypair key;
921  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1);
922  }
923  TEST (node, fork_no_vote_quorum)
924  {
925  	nano::test::system system (3);
926  	auto & node1 (*system.nodes[0]);
927  	auto & node2 (*system.nodes[1]);
928  	auto & node3 (*system.nodes[2]);
929  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
930  	auto key4 (system.wallet (0)->deterministic_insert ());
931  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key4, nano::dev::constants.genesis_amount / 4);
932  	auto key1 (system.wallet (1)->deterministic_insert ());
933  	{
934  		auto transaction (system.wallet (1)->wallets.tx_begin_write ());
935  		system.wallet (1)->store.representative_set (transaction, key1);
936  	}
937  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1, node1.config.receive_minimum.number ()));
938  	ASSERT_NE (nullptr, block);
939  	ASSERT_TIMELY (30s, node3.balance (key1) == node1.config.receive_minimum.number () && node2.balance (key1) == node1.config.receive_minimum.number () && node1.balance (key1) == node1.config.receive_minimum.number ());
940  	ASSERT_EQ (node1.config.receive_minimum.number (), node1.weight (key1));
941  	ASSERT_EQ (node1.config.receive_minimum.number (), node2.weight (key1));
942  	ASSERT_EQ (node1.config.receive_minimum.number (), node3.weight (key1));
943  	nano::block_builder builder;
944  	auto send1 = builder
945  				 .state ()
946  				 .account (nano::dev::genesis_key.pub)
947  				 .previous (block->hash ())
948  				 .representative (nano::dev::genesis_key.pub)
949  				 .balance ((nano::dev::constants.genesis_amount / 4) - (node1.config.receive_minimum.number () * 2))
950  				 .link (key1)
951  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
952  				 .work (*system.work.generate (block->hash ()))
953  				 .build ();
954  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
955  	ASSERT_EQ (nano::process_result::progress, node2.process (*send1).code);
956  	ASSERT_EQ (nano::process_result::progress, node3.process (*send1).code);
957  	auto key2 (system.wallet (2)->deterministic_insert ());
958  	auto send2 = nano::send_block_builder ()
959  				 .previous (block->hash ())
960  				 .destination (key2)
961  				 .balance ((nano::dev::constants.genesis_amount / 4) - (node1.config.receive_minimum.number () * 2))
962  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
963  				 .work (*system.work.generate (block->hash ()))
964  				 .build_shared ();
965  	nano::raw_key key3;
966  	auto transaction (system.wallet (1)->wallets.tx_begin_read ());
967  	ASSERT_FALSE (system.wallet (1)->store.fetch (transaction, key1, key3));
968  	auto vote = std::make_shared<nano::vote> (key1, key3, 0, 0, std::vector<nano::block_hash>{ send2->hash () });
969  	nano::confirm_ack confirm{ nano::dev::network_params.network, vote };
970  	std::vector<uint8_t> buffer;
971  	{
972  		nano::vectorstream stream (buffer);
973  		confirm.serialize (stream);
974  	}
975  	auto channel = node2.network.find_node_id (node3.node_id.pub);
976  	ASSERT_NE (nullptr, channel);
977  	channel->send_buffer (nano::shared_const_buffer (std::move (buffer)));
978  	ASSERT_TIMELY (10s, node3.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::in) >= 3);
979  	ASSERT_TRUE (node1.latest (nano::dev::genesis_key.pub) == send1->hash ());
980  	ASSERT_TRUE (node2.latest (nano::dev::genesis_key.pub) == send1->hash ());
981  	ASSERT_TRUE (node3.latest (nano::dev::genesis_key.pub) == send1->hash ());
982  }
983  TEST (node, DISABLED_fork_pre_confirm)
984  {
985  	nano::test::system system (3);
986  	auto & node0 (*system.nodes[0]);
987  	auto & node1 (*system.nodes[1]);
988  	auto & node2 (*system.nodes[2]);
989  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
990  	nano::keypair key1;
991  	system.wallet (1)->insert_adhoc (key1.prv);
992  	{
993  		auto transaction (system.wallet (1)->wallets.tx_begin_write ());
994  		system.wallet (1)->store.representative_set (transaction, key1.pub);
995  	}
996  	nano::keypair key2;
997  	system.wallet (2)->insert_adhoc (key2.prv);
998  	{
999  		auto transaction (system.wallet (2)->wallets.tx_begin_write ());
1000  		system.wallet (2)->store.representative_set (transaction, key2.pub);
1001  	}
1002  	auto block0 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, nano::dev::constants.genesis_amount / 3));
1003  	ASSERT_NE (nullptr, block0);
1004  	ASSERT_TIMELY (30s, node0.balance (key1.pub) != 0);
1005  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, nano::dev::constants.genesis_amount / 3));
1006  	ASSERT_NE (nullptr, block1);
1007  	ASSERT_TIMELY (30s, node0.balance (key2.pub) != 0);
1008  	nano::keypair key3;
1009  	nano::keypair key4;
1010  	nano::state_block_builder builder;
1011  	auto block2 = builder.make_block ()
1012  				  .account (nano::dev::genesis_key.pub)
1013  				  .previous (node0.latest (nano::dev::genesis_key.pub))
1014  				  .representative (key3.pub)
1015  				  .balance (node0.balance (nano::dev::genesis_key.pub))
1016  				  .link (0)
1017  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1018  				  .work (0)
1019  				  .build_shared ();
1020  	auto block3 = builder.make_block ()
1021  				  .account (nano::dev::genesis_key.pub)
1022  				  .previous (node0.latest (nano::dev::genesis_key.pub))
1023  				  .representative (key4.pub)
1024  				  .balance (node0.balance (nano::dev::genesis_key.pub))
1025  				  .link (0)
1026  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1027  				  .work (0)
1028  				  .build_shared ();
1029  	node0.work_generate_blocking (*block2);
1030  	node0.work_generate_blocking (*block3);
1031  	node0.process_active (block2);
1032  	node1.process_active (block2);
1033  	node2.process_active (block3);
1034  	auto done (false);
1035  	system.deadline_set (70s);
1036  	while (!done)
1037  	{
1038  		done |= node0.latest (nano::dev::genesis_key.pub) == block2->hash () && node1.latest (nano::dev::genesis_key.pub) == block2->hash () && node2.latest (nano::dev::genesis_key.pub) == block2->hash ();
1039  		done |= node0.latest (nano::dev::genesis_key.pub) == block3->hash () && node1.latest (nano::dev::genesis_key.pub) == block3->hash () && node2.latest (nano::dev::genesis_key.pub) == block3->hash ();
1040  		ASSERT_NO_ERROR (system.poll ());
1041  	}
1042  }
1043  TEST (node, DISABLED_fork_stale)
1044  {
1045  	nano::test::system system1 (1);
1046  	system1.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1047  	nano::test::system system2 (1);
1048  	auto & node1 (*system1.nodes[0]);
1049  	auto & node2 (*system2.nodes[0]);
1050  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint (), false);
1051  	auto channel = nano::test::establish_tcp (system1, node2, node1.network.endpoint ());
1052  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> ());
1053  	node2.rep_crawler.response (channel, vote);
1054  	nano::keypair key1;
1055  	nano::keypair key2;
1056  	nano::state_block_builder builder;
1057  	auto send3 = builder.make_block ()
1058  				 .account (nano::dev::genesis_key.pub)
1059  				 .previous (nano::dev::genesis->hash ())
1060  				 .representative (nano::dev::genesis_key.pub)
1061  				 .balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1062  				 .link (key1.pub)
1063  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1064  				 .work (0)
1065  				 .build_shared ();
1066  	node1.work_generate_blocking (*send3);
1067  	node1.process_active (send3);
1068  	system2.deadline_set (10s);
1069  	while (node2.block (send3->hash ()) == nullptr)
1070  	{
1071  		system1.poll ();
1072  		ASSERT_NO_ERROR (system2.poll ());
1073  	}
1074  	auto send1 = builder.make_block ()
1075  				 .account (nano::dev::genesis_key.pub)
1076  				 .previous (send3->hash ())
1077  				 .representative (nano::dev::genesis_key.pub)
1078  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Mxrb_ratio)
1079  				 .link (key1.pub)
1080  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1081  				 .work (0)
1082  				 .build_shared ();
1083  	node1.work_generate_blocking (*send1);
1084  	auto send2 = builder.make_block ()
1085  				 .account (nano::dev::genesis_key.pub)
1086  				 .previous (send3->hash ())
1087  				 .representative (nano::dev::genesis_key.pub)
1088  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Mxrb_ratio)
1089  				 .link (key2.pub)
1090  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1091  				 .work (0)
1092  				 .build_shared ();
1093  	node1.work_generate_blocking (*send2);
1094  	{
1095  		auto transaction1 (node1.store.tx_begin_write ());
1096  		ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction1, *send1).code);
1097  		auto transaction2 (node2.store.tx_begin_write ());
1098  		ASSERT_EQ (nano::process_result::progress, node2.ledger.process (transaction2, *send2).code);
1099  	}
1100  	node1.process_active (send1);
1101  	node1.process_active (send2);
1102  	node2.process_active (send1);
1103  	node2.process_active (send2);
1104  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint (), false);
1105  	while (node2.block (send1->hash ()) == nullptr)
1106  	{
1107  		system1.poll ();
1108  		ASSERT_NO_ERROR (system2.poll ());
1109  	}
1110  }
1111  TEST (node, DISABLED_broadcast_elected)
1112  {
1113  	auto type = nano::transport::transport_type::tcp;
1114  	nano::node_flags node_flags;
1115  	nano::test::system system;
1116  	nano::node_config node_config (system.get_available_port (), system.logging);
1117  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1118  	auto node0 = system.add_node (node_config, node_flags, type);
1119  	node_config.peering_port = system.get_available_port ();
1120  	auto node1 = system.add_node (node_config, node_flags, type);
1121  	node_config.peering_port = system.get_available_port ();
1122  	auto node2 = system.add_node (node_config, node_flags, type);
1123  	nano::keypair rep_big;
1124  	nano::keypair rep_small;
1125  	nano::keypair rep_other;
1126  	nano::block_builder builder;
1127  	{
1128  		auto transaction0 (node0->store.tx_begin_write ());
1129  		auto transaction1 (node1->store.tx_begin_write ());
1130  		auto transaction2 (node2->store.tx_begin_write ());
1131  		auto fund_big = *builder.send ()
1132  						 .previous (nano::dev::genesis->hash ())
1133  						 .destination (rep_big.pub)
1134  						 .balance (nano::Gxrb_ratio * 5)
1135  						 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1136  						 .work (*system.work.generate (nano::dev::genesis->hash ()))
1137  						 .build ();
1138  		auto open_big = *builder.open ()
1139  						 .source (fund_big.hash ())
1140  						 .representative (rep_big.pub)
1141  						 .account (rep_big.pub)
1142  						 .sign (rep_big.prv, rep_big.pub)
1143  						 .work (*system.work.generate (rep_big.pub))
1144  						 .build ();
1145  		auto fund_small = *builder.send ()
1146  						   .previous (fund_big.hash ())
1147  						   .destination (rep_small.pub)
1148  						   .balance (nano::Gxrb_ratio * 2)
1149  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1150  						   .work (*system.work.generate (fund_big.hash ()))
1151  						   .build ();
1152  		auto open_small = *builder.open ()
1153  						   .source (fund_small.hash ())
1154  						   .representative (rep_small.pub)
1155  						   .account (rep_small.pub)
1156  						   .sign (rep_small.prv, rep_small.pub)
1157  						   .work (*system.work.generate (rep_small.pub))
1158  						   .build ();
1159  		auto fund_other = *builder.send ()
1160  						   .previous (fund_small.hash ())
1161  						   .destination (rep_other.pub)
1162  						   .balance (nano::Gxrb_ratio)
1163  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1164  						   .work (*system.work.generate (fund_small.hash ()))
1165  						   .build ();
1166  		auto open_other = *builder.open ()
1167  						   .source (fund_other.hash ())
1168  						   .representative (rep_other.pub)
1169  						   .account (rep_other.pub)
1170  						   .sign (rep_other.prv, rep_other.pub)
1171  						   .work (*system.work.generate (rep_other.pub))
1172  						   .build ();
1173  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_big).code);
1174  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_big).code);
1175  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_big).code);
1176  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_big).code);
1177  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_big).code);
1178  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_big).code);
1179  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_small).code);
1180  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_small).code);
1181  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_small).code);
1182  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_small).code);
1183  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_small).code);
1184  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_small).code);
1185  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_other).code);
1186  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_other).code);
1187  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_other).code);
1188  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_other).code);
1189  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_other).code);
1190  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_other).code);
1191  	}
1192  	for (auto & node : system.nodes)
1193  	{
1194  		auto block (node->block (node->latest (nano::dev::genesis_key.pub)));
1195  		ASSERT_NE (nullptr, block);
1196  		node->block_confirm (block);
1197  		auto election (node->active.election (block->qualified_root ()));
1198  		ASSERT_NE (nullptr, election);
1199  		election->force_confirm ();
1200  		ASSERT_TIMELY (5s, 4 == node->ledger.cache.cemented_count)
1201  	}
1202  	system.wallet (0)->insert_adhoc (rep_big.prv);
1203  	system.wallet (1)->insert_adhoc (rep_small.prv);
1204  	system.wallet (2)->insert_adhoc (rep_other.prv);
1205  	auto fork0 = builder.send ()
1206  				 .previous (node2->latest (nano::dev::genesis_key.pub))
1207  				 .destination (rep_small.pub)
1208  				 .balance (0)
1209  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1210  				 .work (*node0->work_generate_blocking (node2->latest (nano::dev::genesis_key.pub)))
1211  				 .build_shared ();
1212  	auto fork0_copy (std::make_shared<nano::send_block> (*fork0));
1213  	node0->process_active (fork0);
1214  	node1->process_active (fork0_copy);
1215  	auto fork1 = builder.send ()
1216  				 .previous (node2->latest (nano::dev::genesis_key.pub))
1217  				 .destination (rep_big.pub)
1218  				 .balance (0)
1219  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1220  				 .work (*node0->work_generate_blocking (node2->latest (nano::dev::genesis_key.pub)))
1221  				 .build_shared ();
1222  	system.wallet (2)->insert_adhoc (rep_small.prv);
1223  	node2->process_active (fork1);
1224  	ASSERT_TIMELY (10s, node0->ledger.block_or_pruned_exists (fork0->hash ()) && node1->ledger.block_or_pruned_exists (fork0->hash ()));
1225  	system.deadline_set (50s);
1226  	while (!node2->ledger.block_or_pruned_exists (fork0->hash ()))
1227  	{
1228  		auto ec = system.poll ();
1229  		ASSERT_TRUE (node0->ledger.block_or_pruned_exists (fork0->hash ()));
1230  		ASSERT_TRUE (node1->ledger.block_or_pruned_exists (fork0->hash ()));
1231  		ASSERT_NO_ERROR (ec);
1232  	}
1233  	ASSERT_TIMELY (5s, node1->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out) != 0);
1234  }
1235  TEST (node, rep_self_vote)
1236  {
1237  	nano::test::system system;
1238  	nano::node_config node_config (system.get_available_port (), system.logging);
1239  	node_config.online_weight_minimum = std::numeric_limits<nano::uint128_t>::max ();
1240  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1241  	auto node0 = system.add_node (node_config);
1242  	nano::keypair rep_big;
1243  	nano::block_builder builder;
1244  	auto fund_big = *builder.send ()
1245  					 .previous (nano::dev::genesis->hash ())
1246  					 .destination (rep_big.pub)
1247  					 .balance (nano::uint128_t{ "0xb0000000000000000000000000000000" })
1248  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1249  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
1250  					 .build ();
1251  	auto open_big = *builder.open ()
1252  					 .source (fund_big.hash ())
1253  					 .representative (rep_big.pub)
1254  					 .account (rep_big.pub)
1255  					 .sign (rep_big.prv, rep_big.pub)
1256  					 .work (*system.work.generate (rep_big.pub))
1257  					 .build ();
1258  	ASSERT_EQ (nano::process_result::progress, node0->process (fund_big).code);
1259  	ASSERT_EQ (nano::process_result::progress, node0->process (open_big).code);
1260  	node0->block_confirm (node0->block (open_big.hash ()));
1261  	auto election = node0->active.election (open_big.qualified_root ());
1262  	ASSERT_NE (nullptr, election);
1263  	election->force_confirm ();
1264  	system.wallet (0)->insert_adhoc (rep_big.prv);
1265  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1266  	ASSERT_EQ (system.wallet (0)->wallets.reps ().voting, 2);
1267  	auto block0 = builder.send ()
1268  				  .previous (fund_big.hash ())
1269  				  .destination (rep_big.pub)
1270  				  .balance (nano::uint128_t ("0x60000000000000000000000000000000"))
1271  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1272  				  .work (*system.work.generate (fund_big.hash ()))
1273  				  .build_shared ();
1274  	ASSERT_EQ (nano::process_result::progress, node0->process (*block0).code);
1275  	auto & active = node0->active;
1276  	auto & scheduler = node0->scheduler;
1277  	scheduler.buckets.activate (nano::dev::genesis_key.pub, node0->store.tx_begin_read ());
1278  	ASSERT_TIMELY (5s, active.election (block0->qualified_root ()));
1279  	auto election1 = active.election (block0->qualified_root ());
1280  	ASSERT_NE (nullptr, election1);
1281  	ASSERT_TIMELY (1s, election1->votes ().size () == 3);
1282  	auto rep_votes (election1->votes ());
1283  	ASSERT_NE (rep_votes.end (), rep_votes.find (nano::dev::genesis_key.pub));
1284  	ASSERT_NE (rep_votes.end (), rep_votes.find (rep_big.pub));
1285  }
1286  TEST (node, DISABLED_bootstrap_no_publish)
1287  {
1288  	nano::test::system system0 (1);
1289  	nano::test::system system1 (1);
1290  	auto node0 (system0.nodes[0]);
1291  	auto node1 (system1.nodes[0]);
1292  	nano::keypair key0;
1293  	nano::block_builder builder;
1294  	auto send0 = builder
1295  				 .send ()
1296  				 .previous (node0->latest (nano::dev::genesis_key.pub))
1297  				 .destination (key0.pub)
1298  				 .balance (500)
1299  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1300  				 .work (0)
1301  				 .build ();
1302  	{
1303  		auto transaction (node0->store.tx_begin_write ());
1304  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *send0).code);
1305  	}
1306  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1307  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
1308  	ASSERT_TRUE (node1->active.empty ());
1309  	system1.deadline_set (10s);
1310  	while (node1->block (send0->hash ()) == nullptr)
1311  	{
1312  		system0.poll ();
1313  		auto ec = system1.poll ();
1314  		ASSERT_TRUE (node1->active.empty ());
1315  		ASSERT_NO_ERROR (ec);
1316  	}
1317  }
1318  TEST (node, DISABLED_bootstrap_bulk_push)
1319  {
1320  	nano::test::system system;
1321  	nano::test::system system0;
1322  	nano::test::system system1;
1323  	nano::node_config config0 (system.get_available_port (), system0.logging);
1324  	config0.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1325  	auto node0 (system0.add_node (config0));
1326  	nano::node_config config1 (system.get_available_port (), system1.logging);
1327  	config1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1328  	auto node1 (system1.add_node (config1));
1329  	nano::keypair key0;
1330  	auto send0 = nano::send_block_builder ()
1331  				 .previous (nano::dev::genesis->hash ())
1332  				 .destination (key0.pub)
1333  				 .balance (500)
1334  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1335  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1336  				 .build_shared ();
1337  	ASSERT_EQ (nano::process_result::progress, node0->process (*send0).code);
1338  	ASSERT_FALSE (node0->bootstrap_initiator.in_progress ());
1339  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1340  	ASSERT_TRUE (node1->active.empty ());
1341  	node0->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
1342  	system1.deadline_set (10s);
1343  	while (node1->block (send0->hash ()) == nullptr)
1344  	{
1345  		ASSERT_NO_ERROR (system0.poll ());
1346  		ASSERT_NO_ERROR (system1.poll ());
1347  	}
1348  	system1.deadline_set (10s);
1349  	while (node1->active.empty ())
1350  	{
1351  		ASSERT_NO_ERROR (system0.poll ());
1352  		ASSERT_NO_ERROR (system1.poll ());
1353  	}
1354  }
1355  TEST (node, bootstrap_fork_open)
1356  {
1357  	nano::test::system system;
1358  	nano::node_config node_config (system.get_available_port (), system.logging);
1359  	auto node0 = system.add_node (node_config);
1360  	node_config.peering_port = system.get_available_port ();
1361  	auto node1 = system.add_node (node_config);
1362  	nano::keypair key0;
1363  	nano::block_builder builder;
1364  	auto send0 = *builder.send ()
1365  				  .previous (nano::dev::genesis->hash ())
1366  				  .destination (key0.pub)
1367  				  .balance (nano::dev::constants.genesis_amount - 500)
1368  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1369  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
1370  				  .build ();
1371  	auto open0 = *builder.open ()
1372  				  .source (send0.hash ())
1373  				  .representative (1)
1374  				  .account (key0.pub)
1375  				  .sign (key0.prv, key0.pub)
1376  				  .work (*system.work.generate (key0.pub))
1377  				  .build ();
1378  	auto open1 = *builder.open ()
1379  				  .source (send0.hash ())
1380  				  .representative (2)
1381  				  .account (key0.pub)
1382  				  .sign (key0.prv, key0.pub)
1383  				  .work (*system.work.generate (key0.pub))
1384  				  .build ();
1385  	ASSERT_EQ (nano::process_result::progress, node0->process (send0).code);
1386  	ASSERT_EQ (nano::process_result::progress, node1->process (send0).code);
1387  	for (auto node : system.nodes)
1388  	{
1389  		node->block_confirm (node->block (node->latest (nano::dev::genesis_key.pub)));
1390  		ASSERT_TIMELY (1s, node->active.election (send0.qualified_root ()));
1391  		auto election = node->active.election (send0.qualified_root ());
1392  		ASSERT_NE (nullptr, election);
1393  		election->force_confirm ();
1394  		ASSERT_TIMELY (2s, node->active.empty ());
1395  	}
1396  	ASSERT_TIMELY (3s, node0->block_confirmed (send0.hash ()));
1397  	ASSERT_EQ (nano::process_result::progress, node0->process (open0).code);
1398  	ASSERT_EQ (nano::process_result::progress, node1->process (open1).code);
1399  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1400  	ASSERT_FALSE (node1->ledger.block_or_pruned_exists (open0.hash ()));
1401  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1402  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
1403  	ASSERT_TIMELY (1s, node1->active.empty ());
1404  	ASSERT_TIMELY (10s, !node1->ledger.block_or_pruned_exists (open1.hash ()) && node1->ledger.block_or_pruned_exists (open0.hash ()));
1405  }
1406  TEST (node, bootstrap_confirm_frontiers)
1407  {
1408  	nano::test::system system0 (1);
1409  	nano::test::system system1 (1);
1410  	auto node0 = system0.nodes[0];
1411  	auto node1 = system1.nodes[0];
1412  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1413  	nano::keypair key0;
1414  	auto send0 = nano::send_block_builder ()
1415  				 .previous (nano::dev::genesis->hash ())
1416  				 .destination (key0.pub)
1417  				 .balance (nano::dev::constants.genesis_amount - 500)
1418  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1419  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1420  				 .build_shared ();
1421  	ASSERT_EQ (nano::process_result::progress, node0->process (*send0).code);
1422  	ASSERT_FALSE (node0->bootstrap_initiator.in_progress ());
1423  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1424  	ASSERT_TRUE (node1->active.empty ());
1425  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint ());
1426  	system0.deadline_set (10s);
1427  	system1.deadline_set (10s);
1428  	while (!node1->ledger.block_confirmed (node1->store.tx_begin_read (), send0->hash ()))
1429  	{
1430  		ASSERT_NO_ERROR (system0.poll (std::chrono::milliseconds (1)));
1431  		ASSERT_NO_ERROR (system1.poll (std::chrono::milliseconds (1)));
1432  	}
1433  }
1434  TEST (node, unconfirmed_send)
1435  {
1436  	nano::test::system system{};
1437  	auto & node1 = *system.add_node ();
1438  	auto wallet1 = system.wallet (0);
1439  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
1440  	nano::keypair key2{};
1441  	auto & node2 = *system.add_node ();
1442  	auto wallet2 = system.wallet (1);
1443  	wallet2->insert_adhoc (key2.prv);
1444  	auto send1 = wallet1->send_action (nano::dev::genesis->account (), key2.pub, 2 * nano::Mxrb_ratio);
1445  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
1446  	ASSERT_TIMELY (5s, node2.block_confirmed (send1->hash ()));
1447  	ASSERT_TIMELY (5s, node2.get_confirmation_height (node2.store.tx_begin_read (), key2.pub) == 1);
1448  	ASSERT_EQ (node2.balance (key2.pub), 2 * nano::Mxrb_ratio);
1449  	auto recv1 = node2.ledger.find_receive_block_by_send_hash (node2.store.tx_begin_read (), key2.pub, send1->hash ());
1450  	auto send2 = nano::state_block_builder{}
1451  				 .make_block ()
1452  				 .account (key2.pub)
1453  				 .previous (recv1->hash ())
1454  				 .representative (nano::dev::genesis_key.pub)
1455  				 .balance (nano::Mxrb_ratio)
1456  				 .link (nano::dev::genesis->account ())
1457  				 .sign (key2.prv, key2.pub)
1458  				 .work (*system.work.generate (recv1->hash ()))
1459  				 .build_shared ();
1460  	ASSERT_EQ (nano::process_result::progress, node2.process (*send2).code);
1461  	auto send3 = wallet2->send_action (key2.pub, nano::dev::genesis->account (), nano::Mxrb_ratio);
1462  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
1463  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
1464  	ASSERT_TIMELY (5s, node2.block_confirmed (send3->hash ()));
1465  	ASSERT_TIMELY (5s, node1.block_confirmed (send3->hash ()));
1466  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 7);
1467  	ASSERT_TIMELY (5s, node1.balance (nano::dev::genesis->account ()) == nano::dev::constants.genesis_amount);
1468  }
1469  TEST (node, rep_list)
1470  {
1471  	nano::test::system system (2);
1472  	auto & node1 (*system.nodes[1]);
1473  	auto wallet0 (system.wallet (0));
1474  	auto wallet1 (system.wallet (1));
1475  	wallet0->insert_adhoc (nano::dev::genesis_key.prv);
1476  	nano::keypair key1;
1477  	wallet0->send_action (nano::dev::genesis_key.pub, key1.pub, nano::Mxrb_ratio);
1478  	ASSERT_EQ (0, node1.rep_crawler.representatives (1).size ());
1479  	system.deadline_set (10s);
1480  	auto done (false);
1481  	while (!done)
1482  	{
1483  		auto reps = node1.rep_crawler.representatives (1);
1484  		if (!reps.empty ())
1485  		{
1486  			if (!node1.ledger.weight (reps[0].account).is_zero ())
1487  			{
1488  				done = true;
1489  			}
1490  		}
1491  		ASSERT_NO_ERROR (system.poll ());
1492  	}
1493  }
1494  TEST (node, rep_weight)
1495  {
1496  	nano::test::system system;
1497  	auto add_node = [&system] {
1498  		auto node = std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work);
1499  		node->start ();
1500  		system.nodes.push_back (node);
1501  		return node;
1502  	};
1503  	auto & node = *add_node ();
1504  	auto & node1 = *add_node ();
1505  	auto & node2 = *add_node ();
1506  	auto & node3 = *add_node ();
1507  	nano::keypair keypair1;
1508  	nano::keypair keypair2;
1509  	nano::block_builder builder;
1510  	auto amount_pr (node.minimum_principal_weight () + 100);
1511  	auto amount_not_pr (node.minimum_principal_weight () - 100);
1512  	std::shared_ptr<nano::block> block1 = builder
1513  										  .state ()
1514  										  .account (nano::dev::genesis_key.pub)
1515  										  .previous (nano::dev::genesis->hash ())
1516  										  .representative (nano::dev::genesis_key.pub)
1517  										  .balance (nano::dev::constants.genesis_amount - amount_not_pr)
1518  										  .link (keypair1.pub)
1519  										  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1520  										  .work (*system.work.generate (nano::dev::genesis->hash ()))
1521  										  .build ();
1522  	std::shared_ptr<nano::block> block2 = builder
1523  										  .state ()
1524  										  .account (keypair1.pub)
1525  										  .previous (0)
1526  										  .representative (keypair1.pub)
1527  										  .balance (amount_not_pr)
1528  										  .link (block1->hash ())
1529  										  .sign (keypair1.prv, keypair1.pub)
1530  										  .work (*system.work.generate (keypair1.pub))
1531  										  .build ();
1532  	std::shared_ptr<nano::block> block3 = builder
1533  										  .state ()
1534  										  .account (nano::dev::genesis_key.pub)
1535  										  .previous (block1->hash ())
1536  										  .representative (nano::dev::genesis_key.pub)
1537  										  .balance (nano::dev::constants.genesis_amount - amount_not_pr - amount_pr)
1538  										  .link (keypair2.pub)
1539  										  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1540  										  .work (*system.work.generate (block1->hash ()))
1541  										  .build ();
1542  	std::shared_ptr<nano::block> block4 = builder
1543  										  .state ()
1544  										  .account (keypair2.pub)
1545  										  .previous (0)
1546  										  .representative (keypair2.pub)
1547  										  .balance (amount_pr)
1548  										  .link (block3->hash ())
1549  										  .sign (keypair2.prv, keypair2.pub)
1550  										  .work (*system.work.generate (keypair2.pub))
1551  										  .build ();
1552  	{
1553  		auto transaction = node.store.tx_begin_write ();
1554  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block1).code);
1555  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block2).code);
1556  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block3).code);
1557  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block4).code);
1558  	}
1559  	ASSERT_TRUE (node.rep_crawler.representatives (1).empty ());
1560  	std::shared_ptr<nano::transport::channel> channel1 = nano::test::establish_tcp (system, node, node1.network.endpoint ());
1561  	ASSERT_NE (nullptr, channel1);
1562  	std::shared_ptr<nano::transport::channel> channel2 = nano::test::establish_tcp (system, node, node2.network.endpoint ());
1563  	ASSERT_NE (nullptr, channel2);
1564  	std::shared_ptr<nano::transport::channel> channel3 = nano::test::establish_tcp (system, node, node3.network.endpoint ());
1565  	ASSERT_NE (nullptr, channel3);
1566  	auto vote0 = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1567  	auto vote1 = std::make_shared<nano::vote> (keypair1.pub, keypair1.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1568  	auto vote2 = std::make_shared<nano::vote> (keypair2.pub, keypair2.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1569  	node.rep_crawler.response (channel1, vote0);
1570  	node.rep_crawler.response (channel2, vote1);
1571  	node.rep_crawler.response (channel3, vote2);
1572  	ASSERT_TIMELY (5s, node.rep_crawler.representative_count () == 2);
1573  	auto reps = node.rep_crawler.representatives (1);
1574  	ASSERT_EQ (1, reps.size ());
1575  	ASSERT_EQ (node.balance (nano::dev::genesis_key.pub), node.ledger.weight (reps[0].account));
1576  	ASSERT_EQ (nano::dev::genesis_key.pub, reps[0].account);
1577  	ASSERT_EQ (*channel1, reps[0].channel_ref ());
1578  	ASSERT_TRUE (node.rep_crawler.is_pr (*channel1));
1579  	ASSERT_FALSE (node.rep_crawler.is_pr (*channel2));
1580  	ASSERT_TRUE (node.rep_crawler.is_pr (*channel3));
1581  }
1582  TEST (node, rep_remove)
1583  {
1584  	nano::test::system system;
1585  	auto & searching_node = *system.add_node (); 
1586  	nano::keypair keys_rep1; 
1587  	nano::keypair keys_rep2; 
1588  	nano::block_builder builder;
1589  	std::shared_ptr<nano::block> send_to_rep1 = builder
1590  												.state ()
1591  												.account (nano::dev::genesis_key.pub)
1592  												.previous (nano::dev::genesis->hash ())
1593  												.representative (nano::dev::genesis_key.pub)
1594  												.balance (nano::dev::constants.genesis_amount - searching_node.minimum_principal_weight () * 2)
1595  												.link (keys_rep1.pub)
1596  												.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1597  												.work (*system.work.generate (nano::dev::genesis->hash ()))
1598  												.build ();
1599  	std::shared_ptr<nano::block> receive_rep1 = builder
1600  												.state ()
1601  												.account (keys_rep1.pub)
1602  												.previous (0)
1603  												.representative (keys_rep1.pub)
1604  												.balance (searching_node.minimum_principal_weight () * 2)
1605  												.link (send_to_rep1->hash ())
1606  												.sign (keys_rep1.prv, keys_rep1.pub)
1607  												.work (*system.work.generate (keys_rep1.pub))
1608  												.build ();
1609  	std::shared_ptr<nano::block> send_to_rep2 = builder
1610  												.state ()
1611  												.account (nano::dev::genesis_key.pub)
1612  												.previous (send_to_rep1->hash ())
1613  												.representative (nano::dev::genesis_key.pub)
1614  												.balance (nano::dev::constants.genesis_amount - searching_node.minimum_principal_weight () * 4)
1615  												.link (keys_rep2.pub)
1616  												.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1617  												.work (*system.work.generate (send_to_rep1->hash ()))
1618  												.build ();
1619  	std::shared_ptr<nano::block> receive_rep2 = builder
1620  												.state ()
1621  												.account (keys_rep2.pub)
1622  												.previous (0)
1623  												.representative (keys_rep2.pub)
1624  												.balance (searching_node.minimum_principal_weight () * 2)
1625  												.link (send_to_rep2->hash ())
1626  												.sign (keys_rep2.prv, keys_rep2.pub)
1627  												.work (*system.work.generate (keys_rep2.pub))
1628  												.build ();
1629  	{
1630  		auto transaction = searching_node.store.tx_begin_write ();
1631  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *send_to_rep1).code);
1632  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *receive_rep1).code);
1633  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *send_to_rep2).code);
1634  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *receive_rep2).code);
1635  	}
1636  	auto channel_rep1 (std::make_shared<nano::transport::fake::channel> (searching_node));
1637  	auto vote_rep1 = std::make_shared<nano::vote> (keys_rep1.pub, keys_rep1.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1638  	ASSERT_FALSE (searching_node.rep_crawler.response (channel_rep1, vote_rep1, true));
1639  	ASSERT_TIMELY (5s, searching_node.rep_crawler.representative_count () == 1);
1640  	auto reps (searching_node.rep_crawler.representatives (1));
1641  	ASSERT_EQ (1, reps.size ());
1642  	ASSERT_EQ (searching_node.minimum_principal_weight () * 2, searching_node.ledger.weight (reps[0].account));
1643  	ASSERT_EQ (keys_rep1.pub, reps[0].account);
1644  	ASSERT_EQ (*channel_rep1, reps[0].channel_ref ());
1645  	channel_rep1->close ();
1646  	ASSERT_TIMELY (5s, searching_node.rep_crawler.representative_count () == 0);
1647  	auto node_genesis_rep = system.add_node (nano::node_config (system.get_available_port (), system.logging));
1648  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1649  	auto channel_genesis_rep (searching_node.network.find_node_id (node_genesis_rep->get_node_id ()));
1650  	ASSERT_NE (nullptr, channel_genesis_rep);
1651  	auto vote_genesis_rep = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1652  	searching_node.rep_crawler.response (channel_genesis_rep, vote_genesis_rep, true);
1653  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 1);
1654  	auto node_rep2 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), nano::node_config (system.get_available_port (), system.logging), system.work));
1655  	node_rep2->start ();
1656  	searching_node.network.tcp_channels.start_tcp (node_rep2->network.endpoint ());
1657  	std::shared_ptr<nano::transport::channel> channel_rep2;
1658  	ASSERT_TIMELY (10s, (channel_rep2 = searching_node.network.tcp_channels.find_node_id (node_rep2->get_node_id ())) != nullptr);
1659  	auto vote_rep2 = std::make_shared<nano::vote> (keys_rep2.pub, keys_rep2.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1660  	ASSERT_FALSE (searching_node.rep_crawler.response (channel_rep2, vote_rep2, true));
1661  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 2);
1662  	node_rep2->stop ();
1663  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 1);
1664  	reps = searching_node.rep_crawler.representatives (1);
1665  	ASSERT_EQ (nano::dev::genesis_key.pub, reps[0].account);
1666  	ASSERT_TIMELY_EQ (5s, searching_node.network.size (), 1);
1667  	auto list (searching_node.network.list (1));
1668  	ASSERT_EQ (node_genesis_rep->network.endpoint (), list[0]->get_endpoint ());
1669  }
1670  TEST (node, rep_connection_close)
1671  {
1672  	nano::test::system system (2);
1673  	auto & node1 (*system.nodes[0]);
1674  	auto & node2 (*system.nodes[1]);
1675  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1676  	ASSERT_TIMELY (10s, node1.rep_crawler.representative_count () == 1);
1677  	node2.stop ();
1678  	ASSERT_TIMELY (10s, node1.rep_crawler.representative_count () == 0);
1679  }
1680  TEST (node, no_voting)
1681  {
1682  	nano::test::system system (1);
1683  	auto & node0 (*system.nodes[0]);
1684  	nano::node_config node_config (system.get_available_port (), system.logging);
1685  	node_config.enable_voting = false;
1686  	system.add_node (node_config);
1687  	auto wallet0 (system.wallet (0));
1688  	auto wallet1 (system.wallet (1));
1689  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
1690  	nano::keypair key1;
1691  	wallet1->insert_adhoc (key1.prv);
1692  	wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, nano::Mxrb_ratio);
1693  	ASSERT_TIMELY (10s, node0.active.empty ());
1694  	ASSERT_EQ (0, node0.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::in));
1695  }
1696  TEST (node, send_callback)
1697  {
1698  	nano::test::system system (1);
1699  	auto & node0 (*system.nodes[0]);
1700  	nano::keypair key2;
1701  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1702  	system.wallet (0)->insert_adhoc (key2.prv);
1703  	node0.config.callback_address = "localhost";
1704  	node0.config.callback_port = 8010;
1705  	node0.config.callback_target = "/";
1706  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0.config.receive_minimum.number ()));
1707  	ASSERT_TIMELY (10s, node0.balance (key2.pub).is_zero ());
1708  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - node0.config.receive_minimum.number (), node0.balance (nano::dev::genesis_key.pub));
1709  }
1710  TEST (node, balance_observer)
1711  {
1712  	nano::test::system system (1);
1713  	auto & node1 (*system.nodes[0]);
1714  	std::atomic<int> balances (0);
1715  	nano::keypair key;
1716  	node1.observers.account_balance.add ([&key, &balances] (nano::account const & account_a, bool is_pending) {
1717  		if (key.pub == account_a && is_pending)
1718  		{
1719  			balances++;
1720  		}
1721  		else if (nano::dev::genesis_key.pub == account_a && !is_pending)
1722  		{
1723  			balances++;
1724  		}
1725  	});
1726  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1727  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1);
1728  	system.deadline_set (10s);
1729  	auto done (false);
1730  	while (!done)
1731  	{
1732  		auto ec = system.poll ();
1733  		done = balances.load () == 2;
1734  		ASSERT_NO_ERROR (ec);
1735  	}
1736  }
1737  TEST (node, bootstrap_connection_scaling)
1738  {
1739  	nano::test::system system (1);
1740  	auto & node1 (*system.nodes[0]);
1741  	ASSERT_EQ (34, node1.bootstrap_initiator.connections->target_connections (5000, 1));
1742  	ASSERT_EQ (4, node1.bootstrap_initiator.connections->target_connections (0, 1));
1743  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1744  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 1));
1745  	ASSERT_EQ (32, node1.bootstrap_initiator.connections->target_connections (5000, 0));
1746  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (0, 0));
1747  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 0));
1748  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 0));
1749  	ASSERT_EQ (36, node1.bootstrap_initiator.connections->target_connections (5000, 2));
1750  	ASSERT_EQ (8, node1.bootstrap_initiator.connections->target_connections (0, 2));
1751  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1752  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 2));
1753  	node1.config.bootstrap_connections = 128;
1754  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (0, 1));
1755  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1756  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (0, 2));
1757  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1758  	node1.config.bootstrap_connections_max = 256;
1759  	ASSERT_EQ (128, node1.bootstrap_initiator.connections->target_connections (0, 1));
1760  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1761  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (0, 2));
1762  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1763  	node1.config.bootstrap_connections_max = 0;
1764  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (0, 1));
1765  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1766  }
1767  TEST (node, stat_counting)
1768  {
1769  	nano::test::system system (1);
1770  	auto & node1 (*system.nodes[0]);
1771  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 1);
1772  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 5);
1773  	node1.stats.inc (nano::stat::type::ledger, nano::stat::dir::in);
1774  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in);
1775  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in);
1776  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::receive, nano::stat::dir::in);
1777  	ASSERT_EQ (10, node1.stats.count (nano::stat::type::ledger, nano::stat::dir::in));
1778  	ASSERT_EQ (2, node1.stats.count (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in));
1779  	ASSERT_EQ (1, node1.stats.count (nano::stat::type::ledger, nano::stat::detail::receive, nano::stat::dir::in));
1780  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 0);
1781  	ASSERT_EQ (10, node1.stats.count (nano::stat::type::ledger, nano::stat::dir::in));
1782  }
1783  TEST (node, stat_histogram)
1784  {
1785  	nano::test::system system (1);
1786  	auto & node1 (*system.nodes[0]);
1787  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in, { 1, 6, 10, 16 });
1788  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in, 1, 50);
1789  	auto histogram_req (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in));
1790  	ASSERT_EQ (histogram_req->get_bins ()[0].value, 50);
1791  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, { 1, 13 }, 12);
1792  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 1);
1793  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 8, 10);
1794  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 100);
1795  	auto histogram_ack (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in));
1796  	ASSERT_EQ (histogram_ack->get_bins ()[0].value, 1);
1797  	ASSERT_EQ (histogram_ack->get_bins ()[7].value, 10);
1798  	ASSERT_EQ (histogram_ack->get_bins ()[11].value, 1);
1799  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, { 1, 11 }, 2);
1800  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, 1, 1);
1801  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, 6, 1);
1802  	auto histogram_ack_out (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out));
1803  	ASSERT_EQ (histogram_ack_out->get_bins ()[0].value, 1);
1804  	ASSERT_EQ (histogram_ack_out->get_bins ()[1].value, 1);
1805  }
1806  TEST (node, online_reps)
1807  {
1808  	nano::test::system system (1);
1809  	auto & node1 (*system.nodes[0]);
1810  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1811  	auto vote (std::make_shared<nano::vote> ());
1812  	ASSERT_EQ (0, node1.online_reps.online ());
1813  	node1.online_reps.observe (nano::dev::genesis_key.pub);
1814  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.online ());
1815  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1816  	node1.online_reps.sample ();
1817  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.trended ());
1818  	node1.online_reps.clear ();
1819  	node1.online_reps.sample ();
1820  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1821  }
1822  namespace nano
1823  {
1824  TEST (node, online_reps_rep_crawler)
1825  {
1826  	nano::test::system system;
1827  	nano::node_flags flags;
1828  	flags.disable_rep_crawler = true;
1829  	auto & node1 = *system.add_node (flags);
1830  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1831  	ASSERT_EQ (0, node1.online_reps.online ());
1832  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1833  	ASSERT_EQ (0, node1.online_reps.online ());
1834  	{
1835  		nano::lock_guard<nano::mutex> guard{ node1.rep_crawler.probable_reps_mutex };
1836  		node1.rep_crawler.active.insert (nano::dev::genesis->hash ());
1837  	}
1838  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1839  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.online ());
1840  }
1841  }
1842  TEST (node, online_reps_election)
1843  {
1844  	nano::test::system system;
1845  	nano::node_flags flags;
1846  	flags.disable_rep_crawler = true;
1847  	auto & node1 = *system.add_node (flags);
1848  	nano::keypair key;
1849  	nano::state_block_builder builder;
1850  	auto send1 = builder.make_block ()
1851  				 .account (nano::dev::genesis_key.pub)
1852  				 .previous (nano::dev::genesis->hash ())
1853  				 .representative (nano::dev::genesis_key.pub)
1854  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1855  				 .link (key.pub)
1856  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1857  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1858  				 .build_shared ();
1859  	node1.process_active (send1);
1860  	node1.block_processor.flush ();
1861  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
1862  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), 0, std::vector<nano::block_hash>{ send1->hash () });
1863  	ASSERT_EQ (0, node1.online_reps.online ());
1864  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1865  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, node1.online_reps.online ());
1866  }
1867  TEST (node, block_confirm)
1868  {
1869  	auto type = nano::transport::transport_type::tcp;
1870  	nano::node_flags node_flags;
1871  	nano::test::system system (2, type, node_flags);
1872  	auto & node1 (*system.nodes[0]);
1873  	auto & node2 (*system.nodes[1]);
1874  	nano::keypair key;
1875  	nano::state_block_builder builder;
1876  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1877  	auto send1 = builder.make_block ()
1878  				 .account (nano::dev::genesis_key.pub)
1879  				 .previous (nano::dev::genesis->hash ())
1880  				 .representative (nano::dev::genesis_key.pub)
1881  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1882  				 .link (key.pub)
1883  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1884  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1885  				 .build_shared ();
1886  	auto send1_copy = builder.make_block ()
1887  					  .from (*send1)
1888  					  .build_shared ();
1889  	node1.block_processor.add (send1);
1890  	node2.block_processor.add (send1_copy);
1891  	ASSERT_TIMELY (5s, node1.ledger.block_or_pruned_exists (send1->hash ()) && node2.ledger.block_or_pruned_exists (send1_copy->hash ()));
1892  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
1893  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1_copy->hash ()));
1894  	node2.block_confirm (send1_copy);
1895  	auto election = node2.active.election (send1_copy->qualified_root ());
1896  	ASSERT_NE (nullptr, election);
1897  	ASSERT_TIMELY (10s, node1.active.recently_cemented.list ().size () == 1);
1898  }
1899  TEST (node, block_arrival)
1900  {
1901  	nano::test::system system (1);
1902  	auto & node (*system.nodes[0]);
1903  	ASSERT_EQ (0, node.block_arrival.arrival.size ());
1904  	nano::block_hash hash1 (1);
1905  	node.block_arrival.add (hash1);
1906  	ASSERT_EQ (1, node.block_arrival.arrival.size ());
1907  	node.block_arrival.add (hash1);
1908  	ASSERT_EQ (1, node.block_arrival.arrival.size ());
1909  	nano::block_hash hash2 (2);
1910  	node.block_arrival.add (hash2);
1911  	ASSERT_EQ (2, node.block_arrival.arrival.size ());
1912  }
1913  TEST (node, block_arrival_size)
1914  {
1915  	nano::test::system system (1);
1916  	auto & node (*system.nodes[0]);
1917  	auto time (std::chrono::steady_clock::now () - nano::block_arrival::arrival_time_min - std::chrono::seconds (5));
1918  	nano::block_hash hash (0);
1919  	for (auto i (0); i < nano::block_arrival::arrival_size_min * 2; ++i)
1920  	{
1921  		node.block_arrival.arrival.push_back (nano::block_arrival_info{ time, hash });
1922  		++hash.qwords[0];
1923  	}
1924  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1925  	node.block_arrival.recent (0);
1926  	ASSERT_EQ (nano::block_arrival::arrival_size_min, node.block_arrival.arrival.size ());
1927  }
1928  TEST (node, block_arrival_time)
1929  {
1930  	nano::test::system system (1);
1931  	auto & node (*system.nodes[0]);
1932  	auto time (std::chrono::steady_clock::now ());
1933  	nano::block_hash hash (0);
1934  	for (auto i (0); i < nano::block_arrival::arrival_size_min * 2; ++i)
1935  	{
1936  		node.block_arrival.arrival.push_back (nano::block_arrival_info{ time, hash });
1937  		++hash.qwords[0];
1938  	}
1939  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1940  	node.block_arrival.recent (0);
1941  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1942  }
1943  TEST (node, confirm_quorum)
1944  {
1945  	nano::test::system system (1);
1946  	auto & node1 = *system.nodes[0];
1947  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1948  	nano::amount new_balance = node1.online_reps.delta () - nano::Gxrb_ratio;
1949  	auto send1 = nano::state_block_builder ()
1950  				 .account (nano::dev::genesis_key.pub)
1951  				 .previous (nano::dev::genesis->hash ())
1952  				 .representative (nano::dev::genesis_key.pub)
1953  				 .balance (new_balance)
1954  				 .link (nano::dev::genesis_key.pub)
1955  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1956  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1957  				 .build_shared ();
1958  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
1959  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, new_balance.number ());
1960  	ASSERT_TIMELY (2s, node1.active.election (send1->qualified_root ()));
1961  	auto election = node1.active.election (send1->qualified_root ());
1962  	ASSERT_NE (nullptr, election);
1963  	ASSERT_FALSE (election->confirmed ());
1964  	ASSERT_EQ (1, election->votes ().size ());
1965  	ASSERT_EQ (0, node1.balance (nano::dev::genesis_key.pub));
1966  }
1967  TEST (node, local_votes_cache)
1968  {
1969  	nano::test::system system;
1970  	nano::node_config node_config (system.get_available_port (), system.logging);
1971  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1972  	node_config.receive_minimum = nano::dev::constants.genesis_amount;
1973  	auto & node (*system.add_node (node_config));
1974  	nano::state_block_builder builder;
1975  	auto send1 = builder.make_block ()
1976  				 .account (nano::dev::genesis_key.pub)
1977  				 .previous (nano::dev::genesis->hash ())
1978  				 .representative (nano::dev::genesis_key.pub)
1979  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1980  				 .link (nano::dev::genesis_key.pub)
1981  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1982  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
1983  				 .build_shared ();
1984  	auto send2 = builder.make_block ()
1985  				 .account (nano::dev::genesis_key.pub)
1986  				 .previous (send1->hash ())
1987  				 .representative (nano::dev::genesis_key.pub)
1988  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
1989  				 .link (nano::dev::genesis_key.pub)
1990  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1991  				 .work (*node.work_generate_blocking (send1->hash ()))
1992  				 .build_shared ();
1993  	auto send3 = builder.make_block ()
1994  				 .account (nano::dev::genesis_key.pub)
1995  				 .previous (send2->hash ())
1996  				 .representative (nano::dev::genesis_key.pub)
1997  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
1998  				 .link (nano::dev::genesis_key.pub)
1999  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2000  				 .work (*node.work_generate_blocking (send2->hash ()))
2001  				 .build_shared ();
2002  	{
2003  		auto transaction (node.store.tx_begin_write ());
2004  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send1).code);
2005  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send2).code);
2006  	}
2007  	node.block_confirm (send2);
2008  	auto election = node.active.election (send2->qualified_root ());
2009  	ASSERT_NE (nullptr, election);
2010  	election->force_confirm ();
2011  	ASSERT_TIMELY (3s, node.ledger.cache.cemented_count == 3);
2012  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2013  	nano::confirm_req message1{ nano::dev::network_params.network, send1 };
2014  	nano::confirm_req message2{ nano::dev::network_params.network, send2 };
2015  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2016  	node.network.inbound (message1, channel);
2017  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 1);
2018  	node.network.inbound (message2, channel);
2019  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2020  	for (auto i (0); i < 100; ++i)
2021  	{
2022  		node.network.inbound (message1, channel);
2023  		node.network.inbound (message2, channel);
2024  	}
2025  	for (int i = 0; i < 4; ++i)
2026  	{
2027  		ASSERT_NO_ERROR (system.poll (node.aggregator.max_delay));
2028  	}
2029  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2030  	{
2031  		auto transaction (node.store.tx_begin_write ());
2032  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send3).code);
2033  	}
2034  	nano::confirm_req message3{ nano::dev::network_params.network, send3 };
2035  	for (auto i (0); i < 100; ++i)
2036  	{
2037  		node.network.inbound (message3, channel);
2038  	}
2039  	for (int i = 0; i < 4; ++i)
2040  	{
2041  		ASSERT_NO_ERROR (system.poll (node.aggregator.max_delay));
2042  	}
2043  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 3);
2044  	ASSERT_TIMELY (3s, !node.history.votes (send1->root (), send1->hash ()).empty ());
2045  	ASSERT_TIMELY (3s, !node.history.votes (send2->root (), send2->hash ()).empty ());
2046  	ASSERT_TIMELY (3s, !node.history.votes (send3->root (), send3->hash ()).empty ());
2047  }
2048  TEST (node, DISABLED_local_votes_cache_batch)
2049  {
2050  	nano::test::system system;
2051  	nano::node_config node_config (system.get_available_port (), system.logging);
2052  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2053  	auto & node (*system.add_node (node_config));
2054  	ASSERT_GE (node.network_params.voting.max_cache, 2);
2055  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2056  	nano::keypair key1;
2057  	auto send1 = nano::state_block_builder ()
2058  				 .account (nano::dev::genesis_key.pub)
2059  				 .previous (nano::dev::genesis->hash ())
2060  				 .representative (nano::dev::genesis_key.pub)
2061  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2062  				 .link (key1.pub)
2063  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2064  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2065  				 .build_shared ();
2066  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send1).code);
2067  	node.confirmation_height_processor.add (send1);
2068  	ASSERT_TIMELY (5s, node.ledger.block_confirmed (node.store.tx_begin_read (), send1->hash ()));
2069  	auto send2 = nano::state_block_builder ()
2070  				 .account (nano::dev::genesis_key.pub)
2071  				 .previous (send1->hash ())
2072  				 .representative (nano::dev::genesis_key.pub)
2073  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2074  				 .link (nano::dev::genesis_key.pub)
2075  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2076  				 .work (*node.work_generate_blocking (send1->hash ()))
2077  				 .build_shared ();
2078  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send2).code);
2079  	auto receive1 = nano::state_block_builder ()
2080  					.account (key1.pub)
2081  					.previous (0)
2082  					.representative (nano::dev::genesis_key.pub)
2083  					.balance (nano::Gxrb_ratio)
2084  					.link (send1->hash ())
2085  					.sign (key1.prv, key1.pub)
2086  					.work (*node.work_generate_blocking (key1.pub))
2087  					.build_shared ();
2088  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *receive1).code);
2089  	std::vector<std::pair<nano::block_hash, nano::root>> batch{ { send2->hash (), send2->root () }, { receive1->hash (), receive1->root () } };
2090  	nano::confirm_req message{ nano::dev::network_params.network, batch };
2091  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2092  	node.network.inbound (message, channel);
2093  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 1);
2094  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2095  	ASSERT_FALSE (node.history.votes (send2->root (), send2->hash ()).empty ());
2096  	ASSERT_FALSE (node.history.votes (receive1->root (), receive1->hash ()).empty ());
2097  	node.network.inbound (message, channel);
2098  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 2);
2099  	ASSERT_EQ (2, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2100  	node.history.erase (send2->root ());
2101  	node.history.erase (receive1->root ());
2102  	node.network.inbound (nano::confirm_req{ nano::dev::network_params.network, send2->hash (), send2->root () }, channel);
2103  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 3);
2104  	ASSERT_EQ (3, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2105  	node.network.inbound (nano::confirm_req{ nano::dev::network_params.network, receive1->hash (), receive1->root () }, channel);
2106  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 4);
2107  	ASSERT_EQ (4, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2108  	node.network.inbound (message, channel);
2109  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 6);
2110  	ASSERT_EQ (6, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2111  }
2112  TEST (node, local_votes_cache_generate_new_vote)
2113  {
2114  	nano::test::system system;
2115  	nano::node_config node_config (system.get_available_port (), system.logging);
2116  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2117  	auto & node (*system.add_node (node_config));
2118  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2119  	nano::confirm_req message1{ nano::dev::network_params.network, nano::dev::genesis };
2120  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2121  	node.network.inbound (message1, channel);
2122  	ASSERT_TIMELY (5s, !node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ()).empty ());
2123  	auto votes1 = node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ());
2124  	ASSERT_EQ (1, votes1.size ());
2125  	ASSERT_EQ (1, votes1[0]->hashes.size ());
2126  	ASSERT_EQ (nano::dev::genesis->hash (), votes1[0]->hashes[0]);
2127  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 1);
2128  	auto send1 = nano::state_block_builder ()
2129  				 .account (nano::dev::genesis_key.pub)
2130  				 .previous (nano::dev::genesis->hash ())
2131  				 .representative (nano::dev::genesis_key.pub)
2132  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2133  				 .link (nano::dev::genesis_key.pub)
2134  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2135  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2136  				 .build_shared ();
2137  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
2138  	std::vector<std::pair<nano::block_hash, nano::root>> roots_hashes{ std::make_pair (nano::dev::genesis->hash (), nano::dev::genesis->root ()), std::make_pair (send1->hash (), send1->root ()) };
2139  	nano::confirm_req message2{ nano::dev::network_params.network, roots_hashes };
2140  	node.network.inbound (message2, channel);
2141  	ASSERT_TIMELY (3s, !node.history.votes (send1->root (), send1->hash ()).empty ());
2142  	auto votes2 (node.history.votes (send1->root (), send1->hash ()));
2143  	ASSERT_EQ (1, votes2.size ());
2144  	ASSERT_EQ (1, votes2[0]->hashes.size ());
2145  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2146  	ASSERT_FALSE (node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ()).empty ());
2147  	ASSERT_FALSE (node.history.votes (send1->root (), send1->hash ()).empty ());
2148  	ASSERT_TIMELY (3s, 3 == node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2149  }
2150  TEST (node, local_votes_cache_fork)
2151  {
2152  	nano::test::system system;
2153  	nano::node_flags node_flags;
2154  	node_flags.disable_bootstrap_bulk_push_client = true;
2155  	node_flags.disable_bootstrap_bulk_pull_server = true;
2156  	node_flags.disable_bootstrap_listener = true;
2157  	node_flags.disable_lazy_bootstrap = true;
2158  	node_flags.disable_legacy_bootstrap = true;
2159  	node_flags.disable_wallet_bootstrap = true;
2160  	nano::node_config node_config (system.get_available_port (), system.logging);
2161  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2162  	auto & node1 (*system.add_node (node_config, node_flags));
2163  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2164  	auto send1 = nano::state_block_builder ()
2165  				 .account (nano::dev::genesis_key.pub)
2166  				 .previous (nano::dev::genesis->hash ())
2167  				 .representative (nano::dev::genesis_key.pub)
2168  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2169  				 .link (nano::dev::genesis_key.pub)
2170  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2171  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
2172  				 .build_shared ();
2173  	auto send1_fork = nano::state_block_builder ()
2174  					  .account (nano::dev::genesis_key.pub)
2175  					  .previous (nano::dev::genesis->hash ())
2176  					  .representative (nano::dev::genesis_key.pub)
2177  					  .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2178  					  .link (nano::dev::genesis_key.pub)
2179  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2180  					  .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
2181  					  .build_shared ();
2182  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
2183  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
2184  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2185  	node1.history.add (send1->root (), send1->hash (), vote);
2186  	auto votes2 (node1.history.votes (send1->root (), send1->hash ()));
2187  	ASSERT_EQ (1, votes2.size ());
2188  	ASSERT_EQ (1, votes2[0]->hashes.size ());
2189  	node_config.peering_port = system.get_available_port ();
2190  	auto & node2 (*system.add_node (node_config, node_flags));
2191  	node2.process_active (send1_fork);
2192  	node2.block_processor.flush ();
2193  	ASSERT_TIMELY (5s, node2.ledger.block_or_pruned_exists (send1->hash ()));
2194  }
2195  TEST (node, vote_republish)
2196  {
2197  	nano::test::system system (2);
2198  	auto & node1 = *system.nodes[0];
2199  	auto & node2 = *system.nodes[1];
2200  	nano::keypair key2;
2201  	system.wallet (1)->insert_adhoc (key2.prv);
2202  	nano::send_block_builder builder;
2203  	auto send1 = builder.make_block ()
2204  				 .previous (nano::dev::genesis->hash ())
2205  				 .destination (key2.pub)
2206  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2207  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2208  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2209  				 .build_shared ();
2210  	auto send2 = builder.make_block ()
2211  				 .previous (nano::dev::genesis->hash ())
2212  				 .destination (key2.pub)
2213  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2214  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2215  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2216  				 .build_shared ();
2217  	node1.process_active (send1);
2218  	ASSERT_TIMELY (5s, node2.block (send1->hash ()));
2219  	ASSERT_TIMELY (5s, node1.active.active (*send1));
2220  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2221  	node1.process_active (send2);
2222  	ASSERT_TIMELY (5s, node1.active.active (*send2));
2223  	ASSERT_FALSE (node1.block (send2->hash ()));
2224  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send2->hash () }));
2225  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2226  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
2227  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
2228  	ASSERT_FALSE (node1.block (send1->hash ()));
2229  	ASSERT_FALSE (node2.block (send1->hash ()));
2230  	ASSERT_TIMELY (5s, node2.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2231  	ASSERT_TIMELY (5s, node1.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2232  }
2233  TEST (node, vote_by_hash_bundle)
2234  {
2235  	std::atomic<size_t> max_hashes{ 0 };
2236  	nano::test::system system (1);
2237  	auto & node = *system.nodes[0];
2238  	nano::state_block_builder builder;
2239  	std::vector<std::shared_ptr<nano::state_block>> blocks;
2240  	auto block = builder.make_block ()
2241  				 .account (nano::dev::genesis_key.pub)
2242  				 .previous (nano::dev::genesis->hash ())
2243  				 .representative (nano::dev::genesis_key.pub)
2244  				 .balance (nano::dev::constants.genesis_amount - 1)
2245  				 .link (nano::dev::genesis_key.pub)
2246  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2247  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2248  				 .build_shared ();
2249  	blocks.push_back (block);
2250  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *blocks.back ()).code);
2251  	for (auto i = 2; i < 200; ++i)
2252  	{
2253  		auto block = builder.make_block ()
2254  					 .from (*blocks.back ())
2255  					 .previous (blocks.back ()->hash ())
2256  					 .balance (nano::dev::constants.genesis_amount - i)
2257  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2258  					 .work (*system.work.generate (blocks.back ()->hash ()))
2259  					 .build_shared ();
2260  		blocks.push_back (block);
2261  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *blocks.back ()).code);
2262  	}
2263  	ASSERT_TIMELY (5s, nano::test::confirm (node, { blocks.back () }));
2264  	ASSERT_TIMELY (5s, nano::test::confirmed (node, { blocks.back () }));
2265  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2266  	nano::keypair key1;
2267  	system.wallet (0)->insert_adhoc (key1.prv);
2268  	system.nodes[0]->observers.vote.add ([&max_hashes] (std::shared_ptr<nano::vote> const & vote_a, std::shared_ptr<nano::transport::channel> const &, nano::vote_code) {
2269  		if (vote_a->hashes.size () > max_hashes)
2270  		{
2271  			max_hashes = vote_a->hashes.size ();
2272  		}
2273  	});
2274  	for (auto const & block : blocks)
2275  	{
2276  		system.nodes[0]->generator.add (block->root (), block->hash ());
2277  	}
2278  	ASSERT_TIMELY (20s, max_hashes.load () >= 3);
2279  }
2280  TEST (node, vote_by_hash_republish)
2281  {
2282  	nano::test::system system{ 2 };
2283  	auto & node1 = *system.nodes[0];
2284  	auto & node2 = *system.nodes[1];
2285  	nano::keypair key2;
2286  	system.wallet (1)->insert_adhoc (key2.prv);
2287  	nano::send_block_builder builder;
2288  	auto send1 = builder.make_block ()
2289  				 .previous (nano::dev::genesis->hash ())
2290  				 .destination (key2.pub)
2291  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2292  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2293  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2294  				 .build_shared ();
2295  	auto send2 = builder.make_block ()
2296  				 .previous (nano::dev::genesis->hash ())
2297  				 .destination (key2.pub)
2298  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2299  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2300  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2301  				 .build_shared ();
2302  	node1.process_active (send1);
2303  	ASSERT_TIMELY (5s, node1.active.active (*send1));
2304  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2305  	node1.network.publish_filter.clear ();
2306  	node1.process_active (send2);
2307  	ASSERT_TIMELY (5s, node1.active.active (*send2));
2308  	std::vector<nano::block_hash> vote_blocks;
2309  	vote_blocks.push_back (send2->hash ());
2310  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, vote_blocks);
2311  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2312  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
2313  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
2314  	ASSERT_FALSE (node1.block (send1->hash ()));
2315  	ASSERT_FALSE (node2.block (send1->hash ()));
2316  	ASSERT_TIMELY (5s, node2.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2317  	ASSERT_TIMELY (5s, node1.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2318  }
2319  TEST (node, DISABLED_vote_by_hash_epoch_block_republish)
2320  {
2321  	nano::test::system system (2);
2322  	auto & node1 (*system.nodes[0]);
2323  	auto & node2 (*system.nodes[1]);
2324  	nano::keypair key2;
2325  	system.wallet (1)->insert_adhoc (key2.prv);
2326  	auto send1 = nano::send_block_builder ()
2327  				 .previous (nano::dev::genesis->hash ())
2328  				 .destination (key2.pub)
2329  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2330  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2331  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2332  				 .build_shared ();
2333  	auto epoch1 = nano::state_block_builder ()
2334  				  .account (nano::dev::genesis->account ())
2335  				  .previous (nano::dev::genesis->hash ())
2336  				  .representative (nano::dev::genesis->account ())
2337  				  .balance (nano::dev::constants.genesis_amount)
2338  				  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
2339  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2340  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
2341  				  .build_shared ();
2342  	node1.process_active (send1);
2343  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2344  	node1.active.publish (epoch1);
2345  	std::vector<nano::block_hash> vote_blocks;
2346  	vote_blocks.push_back (epoch1->hash ());
2347  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, vote_blocks));
2348  	ASSERT_TRUE (node1.active.active (*send1));
2349  	ASSERT_TRUE (node2.active.active (*send1));
2350  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2351  	ASSERT_TIMELY (10s, node1.block (epoch1->hash ()));
2352  	ASSERT_TIMELY (10s, node2.block (epoch1->hash ()));
2353  	ASSERT_FALSE (node1.block (send1->hash ()));
2354  	ASSERT_FALSE (node2.block (send1->hash ()));
2355  }
2356  TEST (node, epoch_conflict_confirm)
2357  {
2358  	nano::test::system system;
2359  	nano::node_config node_config (system.get_available_port (), system.logging);
2360  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2361  	auto & node0 = *system.add_node (node_config);
2362  	node_config.peering_port = system.get_available_port ();
2363  	auto & node1 = *system.add_node (node_config);
2364  	nano::keypair key;
2365  	nano::keypair epoch_signer (nano::dev::genesis_key);
2366  	nano::state_block_builder builder;
2367  	auto send = builder.make_block ()
2368  				.account (nano::dev::genesis_key.pub)
2369  				.previous (nano::dev::genesis->hash ())
2370  				.representative (nano::dev::genesis_key.pub)
2371  				.balance (nano::dev::constants.genesis_amount - 1)
2372  				.link (key.pub)
2373  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2374  				.work (*system.work.generate (nano::dev::genesis->hash ()))
2375  				.build_shared ();
2376  	auto open = builder.make_block ()
2377  				.account (key.pub)
2378  				.previous (0)
2379  				.representative (key.pub)
2380  				.balance (1)
2381  				.link (send->hash ())
2382  				.sign (key.prv, key.pub)
2383  				.work (*system.work.generate (key.pub))
2384  				.build_shared ();
2385  	auto change = builder.make_block ()
2386  				  .account (key.pub)
2387  				  .previous (open->hash ())
2388  				  .representative (key.pub)
2389  				  .balance (1)
2390  				  .link (0)
2391  				  .sign (key.prv, key.pub)
2392  				  .work (*system.work.generate (open->hash ()))
2393  				  .build_shared ();
2394  	auto send2 = builder.make_block ()
2395  				 .account (nano::dev::genesis_key.pub)
2396  				 .previous (send->hash ())
2397  				 .representative (nano::dev::genesis_key.pub)
2398  				 .balance (nano::dev::constants.genesis_amount - 2)
2399  				 .link (open->hash ())
2400  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2401  				 .work (*system.work.generate (send->hash ()))
2402  				 .build_shared ();
2403  	auto epoch_open = builder.make_block ()
2404  					  .account (change->root ().as_account ())
2405  					  .previous (0)
2406  					  .representative (0)
2407  					  .balance (0)
2408  					  .link (node0.ledger.epoch_link (nano::epoch::epoch_1))
2409  					  .sign (epoch_signer.prv, epoch_signer.pub)
2410  					  .work (*system.work.generate (open->hash ()))
2411  					  .build_shared ();
2412  	ASSERT_TRUE (nano::test::process (node1, { send, send2, open }));
2413  	ASSERT_TIMELY (5s, nano::test::confirm (node1, { open }));
2414  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { open }));
2415  	ASSERT_TRUE (nano::test::process (node0, { send, send2, open }));
2416  	ASSERT_TRUE (nano::test::process_live (node0, { change, epoch_open }));
2417  	ASSERT_TIMELY (5s, nano::test::exists (node0, { change, epoch_open }));
2418  	ASSERT_TIMELY (5s, nano::test::exists (node1, { change, epoch_open }));
2419  	ASSERT_TIMELY (5s, nano::test::confirm (node1, { change, epoch_open, send2 }));
2420  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { change, epoch_open, send2 }));
2421  	ASSERT_TRUE (nano::test::activate (node0, { change, epoch_open }));
2422  	ASSERT_TIMELY (5s, nano::test::active (node0, { change, epoch_open }));
2423  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
2424  	ASSERT_TIMELY (5s, nano::test::active (node0, { change, epoch_open }));
2425  	ASSERT_TIMELY (5s, nano::test::confirmed (node0, { change, epoch_open }));
2426  }
2427  TEST (node, DISABLED_fork_invalid_block_signature)
2428  {
2429  	nano::test::system system;
2430  	nano::node_flags node_flags;
2431  	node_flags.disable_block_processor_republishing = true;
2432  	auto & node1 (*system.add_node (node_flags));
2433  	auto & node2 (*system.add_node (node_flags));
2434  	nano::keypair key2;
2435  	nano::send_block_builder builder;
2436  	auto send1 = builder.make_block ()
2437  				 .previous (nano::dev::genesis->hash ())
2438  				 .destination (key2.pub)
2439  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2440  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2441  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2442  				 .build_shared ();
2443  	auto send2 = builder.make_block ()
2444  				 .previous (nano::dev::genesis->hash ())
2445  				 .destination (key2.pub)
2446  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2447  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2448  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2449  				 .build_shared ();
2450  	auto send2_corrupt (std::make_shared<nano::send_block> (*send2));
2451  	send2_corrupt->signature = nano::signature (123);
2452  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send2->hash () }));
2453  	auto vote_corrupt (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send2_corrupt->hash () }));
2454  	node1.process_active (send1);
2455  	ASSERT_TIMELY (5s, node1.block (send1->hash ()));
2456  	node2.network.flood_vote (vote_corrupt, 1.0f);
2457  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::rollback, nano::stat::detail::all));
2458  	node2.network.flood_vote (vote, 1.0f);
2459  	ASSERT_TIMELY (10s, !node1.block (send1->hash ()));
2460  	ASSERT_TIMELY (10s, node1.block (send2->hash ()));
2461  	ASSERT_EQ (node1.block (send2->hash ())->block_signature (), send2->block_signature ());
2462  }
2463  TEST (node, fork_election_invalid_block_signature)
2464  {
2465  	nano::test::system system (1);
2466  	auto & node1 (*system.nodes[0]);
2467  	nano::block_builder builder;
2468  	auto send1 = builder.state ()
2469  				 .account (nano::dev::genesis_key.pub)
2470  				 .previous (nano::dev::genesis->hash ())
2471  				 .representative (nano::dev::genesis_key.pub)
2472  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2473  				 .link (nano::dev::genesis_key.pub)
2474  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2475  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2476  				 .build_shared ();
2477  	auto send2 = builder.state ()
2478  				 .account (nano::dev::genesis_key.pub)
2479  				 .previous (nano::dev::genesis->hash ())
2480  				 .representative (nano::dev::genesis_key.pub)
2481  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2482  				 .link (nano::dev::genesis_key.pub)
2483  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2484  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2485  				 .build_shared ();
2486  	auto send3 = builder.state ()
2487  				 .account (nano::dev::genesis_key.pub)
2488  				 .previous (nano::dev::genesis->hash ())
2489  				 .representative (nano::dev::genesis_key.pub)
2490  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2491  				 .link (nano::dev::genesis_key.pub)
2492  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2493  				 .sign (nano::dev::genesis_key.prv, 0) 
2494  				 .build_shared ();
2495  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
2496  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send1 }, channel1);
2497  	ASSERT_TIMELY (5s, node1.active.active (send1->qualified_root ()));
2498  	auto election (node1.active.election (send1->qualified_root ()));
2499  	ASSERT_NE (nullptr, election);
2500  	ASSERT_EQ (1, election->blocks ().size ());
2501  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send3 }, channel1);
2502  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send2 }, channel1);
2503  	ASSERT_TIMELY (3s, election->blocks ().size () > 1);
2504  	ASSERT_EQ (election->blocks ()[send2->hash ()]->block_signature (), send2->block_signature ());
2505  }
2506  TEST (node, block_processor_signatures)
2507  {
2508  	nano::test::system system{ 1 };
2509  	auto & node1 = *system.nodes[0];
2510  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2511  	nano::block_hash latest = system.nodes[0]->latest (nano::dev::genesis_key.pub);
2512  	nano::state_block_builder builder;
2513  	nano::keypair key1;
2514  	nano::keypair key2;
2515  	nano::keypair key3;
2516  	auto send1 = builder.make_block ()
2517  				 .account (nano::dev::genesis_key.pub)
2518  				 .previous (latest)
2519  				 .representative (nano::dev::genesis_key.pub)
2520  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2521  				 .link (key1.pub)
2522  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2523  				 .work (*node1.work_generate_blocking (latest))
2524  				 .build_shared ();
2525  	auto send2 = builder.make_block ()
2526  				 .account (nano::dev::genesis_key.pub)
2527  				 .previous (send1->hash ())
2528  				 .representative (nano::dev::genesis_key.pub)
2529  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2530  				 .link (key2.pub)
2531  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2532  				 .work (*node1.work_generate_blocking (send1->hash ()))
2533  				 .build_shared ();
2534  	auto send3 = builder.make_block ()
2535  				 .account (nano::dev::genesis_key.pub)
2536  				 .previous (send2->hash ())
2537  				 .representative (nano::dev::genesis_key.pub)
2538  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2539  				 .link (key3.pub)
2540  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2541  				 .work (*node1.work_generate_blocking (send2->hash ()))
2542  				 .build_shared ();
2543  	auto send4 = builder.make_block ()
2544  				 .account (nano::dev::genesis_key.pub)
2545  				 .previous (send3->hash ())
2546  				 .representative (nano::dev::genesis_key.pub)
2547  				 .balance (nano::dev::constants.genesis_amount - 4 * nano::Gxrb_ratio)
2548  				 .link (key3.pub)
2549  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2550  				 .work (*node1.work_generate_blocking (send3->hash ()))
2551  				 .build_shared ();
2552  	send4->signature.bytes[32] ^= 0x1;
2553  	auto send5 = builder.make_block ()
2554  				 .account (nano::dev::genesis_key.pub)
2555  				 .previous (send3->hash ())
2556  				 .representative (nano::dev::genesis_key.pub)
2557  				 .balance (nano::dev::constants.genesis_amount - 5 * nano::Gxrb_ratio)
2558  				 .link (key3.pub)
2559  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2560  				 .work (*node1.work_generate_blocking (send3->hash ()))
2561  				 .build_shared ();
2562  	send5->signature.bytes[32] ^= 0x1;
2563  	node1.unchecked.put (send5->previous (), nano::unchecked_info{ send5 });
2564  	auto receive1 = builder.make_block ()
2565  					.account (key1.pub)
2566  					.previous (0)
2567  					.representative (nano::dev::genesis_key.pub)
2568  					.balance (nano::Gxrb_ratio)
2569  					.link (send1->hash ())
2570  					.sign (key1.prv, key1.pub)
2571  					.work (*node1.work_generate_blocking (key1.pub))
2572  					.build_shared ();
2573  	auto receive2 = builder.make_block ()
2574  					.account (key2.pub)
2575  					.previous (0)
2576  					.representative (nano::dev::genesis_key.pub)
2577  					.balance (nano::Gxrb_ratio)
2578  					.link (send2->hash ())
2579  					.sign (key2.prv, key2.pub)
2580  					.work (*node1.work_generate_blocking (key2.pub))
2581  					.build_shared ();
2582  	auto receive3 = builder.make_block ()
2583  					.account (key3.pub)
2584  					.previous (0)
2585  					.representative (nano::dev::genesis_key.pub)
2586  					.balance (nano::Gxrb_ratio)
2587  					.link (send3->hash ())
2588  					.sign (key2.prv, key3.pub)
2589  					.work (*node1.work_generate_blocking (key3.pub))
2590  					.build_shared ();
2591  	node1.process_active (send1);
2592  	node1.process_active (send2);
2593  	node1.process_active (send3);
2594  	node1.process_active (send4);
2595  	node1.process_active (receive1);
2596  	node1.process_active (receive2);
2597  	node1.process_active (receive3);
2598  	ASSERT_TIMELY (5s, node1.block (receive2->hash ()) != nullptr); 
2599  	ASSERT_TIMELY (5s, node1.unchecked.count () == 0);
2600  	ASSERT_EQ (nullptr, node1.block (receive3->hash ())); 
2601  	ASSERT_EQ (nullptr, node1.block (send4->hash ())); 
2602  	ASSERT_EQ (nullptr, node1.block (send5->hash ())); 
2603  }
2604  TEST (node, block_processor_reject_state)
2605  {
2606  	nano::test::system system (1);
2607  	auto & node (*system.nodes[0]);
2608  	nano::state_block_builder builder;
2609  	auto send1 = builder.make_block ()
2610  				 .account (nano::dev::genesis_key.pub)
2611  				 .previous (nano::dev::genesis->hash ())
2612  				 .representative (nano::dev::genesis_key.pub)
2613  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2614  				 .link (nano::dev::genesis_key.pub)
2615  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2616  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2617  				 .build_shared ();
2618  	send1->signature.bytes[0] ^= 1;
2619  	ASSERT_FALSE (node.ledger.block_or_pruned_exists (send1->hash ()));
2620  	node.process_active (send1);
2621  	auto flushed = std::async (std::launch::async, [&node] { node.block_processor.flush (); });
2622  	ASSERT_NE (std::future_status::timeout, flushed.wait_for (5s));
2623  	ASSERT_FALSE (node.ledger.block_or_pruned_exists (send1->hash ()));
2624  	auto send2 = builder.make_block ()
2625  				 .account (nano::dev::genesis_key.pub)
2626  				 .previous (nano::dev::genesis->hash ())
2627  				 .representative (nano::dev::genesis_key.pub)
2628  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2629  				 .link (nano::dev::genesis_key.pub)
2630  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2631  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2632  				 .build_shared ();
2633  	node.process_active (send2);
2634  	auto flushed2 = std::async (std::launch::async, [&node] { node.block_processor.flush (); });
2635  	ASSERT_NE (std::future_status::timeout, flushed2.wait_for (5s));
2636  	ASSERT_TRUE (node.ledger.block_or_pruned_exists (send2->hash ()));
2637  }
2638  TEST (node, block_processor_full)
2639  {
2640  	nano::test::system system;
2641  	nano::node_flags node_flags;
2642  	node_flags.force_use_write_database_queue = true;
2643  	node_flags.block_processor_full_size = 3;
2644  	auto & node = *system.add_node (nano::node_config (system.get_available_port (), system.logging), node_flags);
2645  	nano::state_block_builder builder;
2646  	auto send1 = builder.make_block ()
2647  				 .account (nano::dev::genesis_key.pub)
2648  				 .previous (nano::dev::genesis->hash ())
2649  				 .representative (nano::dev::genesis_key.pub)
2650  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2651  				 .link (nano::dev::genesis_key.pub)
2652  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2653  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2654  				 .build_shared ();
2655  	auto send2 = builder.make_block ()
2656  				 .account (nano::dev::genesis_key.pub)
2657  				 .previous (nano::dev::genesis->hash ())
2658  				 .representative (nano::dev::genesis_key.pub)
2659  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2660  				 .link (nano::dev::genesis_key.pub)
2661  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2662  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2663  				 .build_shared ();
2664  	auto send3 = builder.make_block ()
2665  				 .account (nano::dev::genesis_key.pub)
2666  				 .previous (nano::dev::genesis->hash ())
2667  				 .representative (nano::dev::genesis_key.pub)
2668  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2669  				 .link (nano::dev::genesis_key.pub)
2670  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2671  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2672  				 .build_shared ();
2673  	node.block_processor.stop (); 
2674  	node.block_processor.add (send1);
2675  	ASSERT_FALSE (node.block_processor.full ());
2676  	node.block_processor.add (send2);
2677  	ASSERT_FALSE (node.block_processor.full ());
2678  	node.block_processor.add (send3);
2679  	ASSERT_TIMELY (5s, node.block_processor.full ());
2680  }
2681  TEST (node, block_processor_half_full)
2682  {
2683  	nano::test::system system;
2684  	nano::node_flags node_flags;
2685  	node_flags.block_processor_full_size = 6;
2686  	node_flags.force_use_write_database_queue = true;
2687  	auto & node = *system.add_node (nano::node_config (system.get_available_port (), system.logging), node_flags);
2688  	nano::state_block_builder builder;
2689  	auto send1 = builder.make_block ()
2690  				 .account (nano::dev::genesis_key.pub)
2691  				 .previous (nano::dev::genesis->hash ())
2692  				 .representative (nano::dev::genesis_key.pub)
2693  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2694  				 .link (nano::dev::genesis_key.pub)
2695  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2696  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2697  				 .build_shared ();
2698  	auto send2 = builder.make_block ()
2699  				 .account (nano::dev::genesis_key.pub)
2700  				 .previous (send1->hash ())
2701  				 .representative (nano::dev::genesis_key.pub)
2702  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2703  				 .link (nano::dev::genesis_key.pub)
2704  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2705  				 .work (*node.work_generate_blocking (send1->hash ()))
2706  				 .build_shared ();
2707  	auto send3 = builder.make_block ()
2708  				 .account (nano::dev::genesis_key.pub)
2709  				 .previous (send2->hash ())
2710  				 .representative (nano::dev::genesis_key.pub)
2711  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2712  				 .link (nano::dev::genesis_key.pub)
2713  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2714  				 .work (*node.work_generate_blocking (send2->hash ()))
2715  				 .build_shared ();
2716  	auto write_guard = node.write_database_queue.wait (nano::writer::testing);
2717  	node.block_processor.add (send1);
2718  	ASSERT_FALSE (node.block_processor.half_full ());
2719  	node.block_processor.add (send2);
2720  	ASSERT_FALSE (node.block_processor.half_full ());
2721  	node.block_processor.add (send3);
2722  	ASSERT_TIMELY (2s, node.block_processor.half_full ());
2723  	ASSERT_FALSE (node.block_processor.full ());
2724  }
2725  TEST (node, confirm_back)
2726  {
2727  	nano::test::system system (1);
2728  	nano::keypair key;
2729  	auto & node (*system.nodes[0]);
2730  	auto genesis_start_balance (node.balance (nano::dev::genesis_key.pub));
2731  	auto send1 = nano::send_block_builder ()
2732  				 .previous (nano::dev::genesis->hash ())
2733  				 .destination (key.pub)
2734  				 .balance (genesis_start_balance - 1)
2735  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2736  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2737  				 .build_shared ();
2738  	nano::state_block_builder builder;
2739  	auto open = builder.make_block ()
2740  				.account (key.pub)
2741  				.previous (0)
2742  				.representative (key.pub)
2743  				.balance (1)
2744  				.link (send1->hash ())
2745  				.sign (key.prv, key.pub)
2746  				.work (*system.work.generate (key.pub))
2747  				.build_shared ();
2748  	auto send2 = builder.make_block ()
2749  				 .account (key.pub)
2750  				 .previous (open->hash ())
2751  				 .representative (key.pub)
2752  				 .balance (0)
2753  				 .link (nano::dev::genesis_key.pub)
2754  				 .sign (key.prv, key.pub)
2755  				 .work (*system.work.generate (open->hash ()))
2756  				 .build_shared ();
2757  	node.process_active (send1);
2758  	node.process_active (open);
2759  	node.process_active (send2);
2760  	ASSERT_TIMELY (5s, node.block (send2->hash ()) != nullptr);
2761  	nano::test::start_elections (system, node, { send1, open, send2 });
2762  	ASSERT_EQ (3, node.active.size ());
2763  	std::vector<nano::block_hash> vote_blocks;
2764  	vote_blocks.push_back (send2->hash ());
2765  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, vote_blocks));
2766  	node.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node));
2767  	ASSERT_TIMELY (10s, node.active.empty ());
2768  }
2769  TEST (node, peers)
2770  {
2771  	nano::test::system system (1);
2772  	auto node1 (system.nodes[0]);
2773  	ASSERT_TRUE (node1->network.empty ());
2774  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
2775  	system.nodes.push_back (node2);
2776  	auto endpoint = node1->network.endpoint ();
2777  	nano::endpoint_key endpoint_key{ endpoint.address ().to_v6 ().to_bytes (), endpoint.port () };
2778  	auto & store = node2->store;
2779  	{
2780  		auto transaction (store.tx_begin_write ());
2781  		store.peer.put (transaction, endpoint_key);
2782  		store.peer.put (transaction, nano::endpoint_key{ boost::asio::ip::address_v6::any ().to_bytes (), 55555 });
2783  	}
2784  	node2->start ();
2785  	ASSERT_TIMELY (10s, !node2->network.empty () && !node1->network.empty ())
2786  	ASSERT_TIMELY (10s, node1->tcp_listener.realtime_count != 0 && node2->tcp_listener.realtime_count != 0);
2787  	ASSERT_EQ (1, node1->network.size ());
2788  	auto list1 (node1->network.list (2));
2789  	ASSERT_EQ (node2->get_node_id (), list1[0]->get_node_id ());
2790  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
2791  	ASSERT_EQ (1, node2->network.size ());
2792  	auto list2 (node2->network.list (2));
2793  	ASSERT_EQ (node1->get_node_id (), list2[0]->get_node_id ());
2794  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
2795  	ASSERT_TIMELY_EQ (5s, store.peer.count (store.tx_begin_read ()), 1);
2796  	ASSERT_TRUE (store.peer.exists (store.tx_begin_read (), endpoint_key));
2797  	node1->stop ();
2798  	ASSERT_TIMELY (10s, node2->network.empty ());
2799  }
2800  TEST (node, peer_cache_restart)
2801  {
2802  	nano::test::system system (1);
2803  	auto node1 (system.nodes[0]);
2804  	ASSERT_TRUE (node1->network.empty ());
2805  	auto endpoint = node1->network.endpoint ();
2806  	nano::endpoint_key endpoint_key{ endpoint.address ().to_v6 ().to_bytes (), endpoint.port () };
2807  	auto path (nano::unique_path ());
2808  	{
2809  		auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), path, system.logging, system.work));
2810  		system.nodes.push_back (node2);
2811  		auto & store = node2->store;
2812  		{
2813  			auto transaction (store.tx_begin_write ());
2814  			store.peer.put (transaction, endpoint_key);
2815  		}
2816  		node2->start ();
2817  		ASSERT_TIMELY (10s, !node2->network.empty ());
2818  		auto list (node2->network.list (2));
2819  		ASSERT_EQ (node1->network.endpoint (), list[0]->get_endpoint ());
2820  		ASSERT_EQ (1, node2->network.size ());
2821  		node2->stop ();
2822  	}
2823  	{
2824  		nano::node_flags node_flags;
2825  		node_flags.read_only = true;
2826  		auto node3 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), path, system.logging, system.work, node_flags));
2827  		system.nodes.push_back (node3);
2828  		node3->network.start ();
2829  		node3->add_initial_peers ();
2830  		auto & store = node3->store;
2831  		{
2832  			auto transaction (store.tx_begin_read ());
2833  			ASSERT_EQ (store.peer.count (transaction), 1);
2834  			ASSERT_TRUE (store.peer.exists (transaction, endpoint_key));
2835  		}
2836  		ASSERT_TIMELY (10s, !node3->network.empty ());
2837  		auto list (node3->network.list (2));
2838  		ASSERT_EQ (node1->network.endpoint (), list[0]->get_endpoint ());
2839  		ASSERT_EQ (1, node3->network.size ());
2840  		node3->stop ();
2841  	}
2842  }
2843  TEST (node, unchecked_cleanup)
2844  {
2845  	nano::test::system system{};
2846  	nano::node_flags node_flags{};
2847  	node_flags.disable_unchecked_cleanup = true;
2848  	nano::keypair key{};
2849  	auto & node = *system.add_node (node_flags);
2850  	auto open = nano::state_block_builder ()
2851  				.account (key.pub)
2852  				.previous (0)
2853  				.representative (key.pub)
2854  				.balance (1)
2855  				.link (key.pub)
2856  				.sign (key.prv, key.pub)
2857  				.work (*system.work.generate (key.pub))
2858  				.build_shared ();
2859  	std::vector<uint8_t> bytes;
2860  	{
2861  		nano::vectorstream stream (bytes);
2862  		open->serialize (stream);
2863  	}
2864  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2865  	node.process_active (open);
2866  	ASSERT_TIMELY (15s, 1 == node.unchecked.count ());
2867  	node.config.unchecked_cutoff_time = std::chrono::seconds (2);
2868  	ASSERT_EQ (1, node.unchecked.count ());
2869  	std::this_thread::sleep_for (std::chrono::seconds (1));
2870  	node.unchecked_cleanup ();
2871  	ASSERT_TRUE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2872  	ASSERT_EQ (1, node.unchecked.count ());
2873  	std::this_thread::sleep_for (std::chrono::seconds (2));
2874  	node.unchecked_cleanup ();
2875  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2876  	ASSERT_EQ (0, node.unchecked.count ());
2877  }
2878  TEST (node, dont_write_lock_node)
2879  {
2880  	auto path = nano::unique_path ();
2881  	std::promise<void> write_lock_held_promise;
2882  	std::promise<void> finished_promise;
2883  	std::thread ([&path, &write_lock_held_promise, &finished_promise] () {
2884  		nano::logger_mt logger;
2885  		auto store = nano::make_store (logger, path, nano::dev::constants, false, true);
2886  		{
2887  			nano::ledger_cache ledger_cache;
2888  			auto transaction (store->tx_begin_write ());
2889  			store->initialize (transaction, ledger_cache, nano::dev::constants);
2890  		}
2891  		auto transaction (store->tx_begin_write ());
2892  		write_lock_held_promise.set_value ();
2893  		finished_promise.get_future ().wait ();
2894  	})
2895  	.detach ();
2896  	write_lock_held_promise.get_future ().wait ();
2897  	nano::inactive_node node (path, nano::inactive_node_flag_defaults ());
2898  	finished_promise.set_value ();
2899  }
2900  TEST (node, bidirectional_tcp)
2901  {
2902  #ifdef _WIN32
2903  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2904  	{
2905  		GTEST_SKIP ();
2906  	}
2907  #endif
2908  	nano::test::system system;
2909  	nano::node_flags node_flags;
2910  	node_flags.disable_legacy_bootstrap = true;
2911  	node_flags.disable_lazy_bootstrap = true;
2912  	node_flags.disable_wallet_bootstrap = true;
2913  	nano::node_config node_config (system.get_available_port (), system.logging);
2914  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2915  	auto node1 = system.add_node (node_config, node_flags);
2916  	node_config.peering_port = system.get_available_port ();
2917  	node_config.tcp_incoming_connections_max = 0; 
2918  	auto node2 = system.add_node (node_config, node_flags);
2919  	ASSERT_EQ (1, node1->network.size ());
2920  	ASSERT_EQ (1, node2->network.size ());
2921  	auto list1 (node1->network.list (1));
2922  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
2923  	ASSERT_NE (node2->network.endpoint (), list1[0]->get_endpoint ()); 
2924  	ASSERT_EQ (node2->node_id.pub, list1[0]->get_node_id ());
2925  	auto list2 (node2->network.list (1));
2926  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
2927  	ASSERT_EQ (node1->network.endpoint (), list2[0]->get_endpoint ());
2928  	ASSERT_EQ (node1->node_id.pub, list2[0]->get_node_id ());
2929  	nano::keypair key;
2930  	nano::state_block_builder builder;
2931  	auto send1 = builder.make_block ()
2932  				 .account (nano::dev::genesis_key.pub)
2933  				 .previous (nano::dev::genesis->hash ())
2934  				 .representative (nano::dev::genesis_key.pub)
2935  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2936  				 .link (key.pub)
2937  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2938  				 .work (*node1->work_generate_blocking (nano::dev::genesis->hash ()))
2939  				 .build_shared ();
2940  	node1->process_active (send1);
2941  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send1->hash ()) && node2->ledger.block_or_pruned_exists (send1->hash ()));
2942  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2943  	ASSERT_TIMELY (10s, node2->rep_crawler.representative_count () != 0);
2944  	bool confirmed (false);
2945  	system.deadline_set (10s);
2946  	while (!confirmed)
2947  	{
2948  		auto transaction2 (node2->store.tx_begin_read ());
2949  		confirmed = node2->ledger.block_confirmed (transaction2, send1->hash ());
2950  		ASSERT_NO_ERROR (system.poll ());
2951  	}
2952  	{
2953  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
2954  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
2955  	}
2956  	auto send2 = builder.make_block ()
2957  				 .account (nano::dev::genesis_key.pub)
2958  				 .previous (send1->hash ())
2959  				 .representative (nano::dev::genesis_key.pub)
2960  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2961  				 .link (key.pub)
2962  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2963  				 .work (*node1->work_generate_blocking (send1->hash ()))
2964  				 .build_shared ();
2965  	node2->process_active (send2);
2966  	node2->block_processor.flush ();
2967  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send2->hash ()) && node2->ledger.block_or_pruned_exists (send2->hash ()));
2968  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
2969  	ASSERT_TIMELY (10s, node1->rep_crawler.representative_count () != 0);
2970  	confirmed = false;
2971  	system.deadline_set (20s);
2972  	while (!confirmed)
2973  	{
2974  		auto transaction1 (node1->store.tx_begin_read ());
2975  		confirmed = node1->ledger.block_confirmed (transaction1, send2->hash ());
2976  		ASSERT_NO_ERROR (system.poll ());
2977  	}
2978  }
2979  TEST (node, node_sequence)
2980  {
2981  	nano::test::system system (3);
2982  	ASSERT_EQ (0, system.nodes[0]->node_seq);
2983  	ASSERT_EQ (0, system.nodes[0]->node_seq);
2984  	ASSERT_EQ (1, system.nodes[1]->node_seq);
2985  	ASSERT_EQ (2, system.nodes[2]->node_seq);
2986  }
2987  TEST (node, rollback_vote_self)
2988  {
2989  	nano::test::system system;
2990  	nano::node_flags flags;
2991  	flags.disable_request_loop = true;
2992  	auto & node = *system.add_node (flags);
2993  	nano::state_block_builder builder;
2994  	nano::keypair key;
2995  	auto send1 = builder.make_block ()
2996  				 .account (nano::dev::genesis_key.pub)
2997  				 .previous (nano::dev::genesis->hash ())
2998  				 .representative (nano::dev::genesis_key.pub)
2999  				 .link (key.pub)
3000  				 .balance (nano::dev::constants.genesis_amount - (nano::dev::constants.genesis_amount / 2))
3001  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3002  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3003  				 .build_shared ();
3004  	auto open = builder.make_block ()
3005  				.account (key.pub)
3006  				.previous (0)
3007  				.representative (key.pub)
3008  				.link (send1->hash ())
3009  				.balance (nano::dev::constants.genesis_amount / 2)
3010  				.sign (key.prv, key.pub)
3011  				.work (*system.work.generate (key.pub))
3012  				.build_shared ();
3013  	auto send2 = builder.make_block ()
3014  				 .from (*send1)
3015  				 .previous (send1->hash ())
3016  				 .balance (send1->balance ().number () - 1)
3017  				 .link (nano::dev::genesis_key.pub)
3018  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3019  				 .work (*system.work.generate (send1->hash ()))
3020  				 .build_shared ();
3021  	auto fork = builder.make_block ()
3022  				.from (*send2)
3023  				.balance (send1->balance ().number () - 2)
3024  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3025  				.build_shared ();
3026  	ASSERT_TRUE (nano::test::process (node, { send1, open }));
3027  	ASSERT_TIMELY (5s, nano::test::confirm (node, { send1, open }));
3028  	ASSERT_TIMELY (5s, node.ledger.cache.cemented_count == 3);
3029  	ASSERT_TIMELY_EQ (5s, nano::dev::constants.genesis_amount / 2, node.weight (key.pub));
3030  	node.process_active (send2);
3031  	std::shared_ptr<nano::election> election;
3032  	ASSERT_TIMELY (5s, election = node.active.election (send2->qualified_root ()));
3033  	node.process_active (fork);
3034  	ASSERT_TIMELY_EQ (5s, 2, election->blocks ().size ());
3035  	ASSERT_EQ (election->winner ()->hash (), send2->hash ());
3036  	{
3037  		auto write_guard = node.write_database_queue.wait (nano::writer::testing);
3038  		ASSERT_EQ (0, election->votes_with_weight ().size ());
3039  		election->vote (key.pub, 0, fork->hash ());
3040  		ASSERT_EQ (1, election->votes_with_weight ().size ());
3041  		ASSERT_EQ (election->winner ()->hash (), fork->hash ());
3042  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3043  		ASSERT_TRUE (node.history.votes (send2->root (), send2->hash ()).empty ());
3044  		ASSERT_TRUE (node.history.votes (fork->root (), fork->hash ()).empty ());
3045  		auto channel = std::make_shared<nano::transport::fake::channel> (node);
3046  		node.aggregator.add (channel, { { send2->hash (), send2->root () } });
3047  		ASSERT_TIMELY (5s, !node.history.votes (fork->root (), fork->hash ()).empty ());
3048  		ASSERT_TRUE (node.history.votes (send2->root (), send2->hash ()).empty ());
3049  	}
3050  	auto is_genesis_vote = [] (nano::vote_with_weight_info info) {
3051  		return info.representative == nano::dev::genesis_key.pub;
3052  	};
3053  	ASSERT_TIMELY_EQ (5s, 2, election->votes_with_weight ().size ());
3054  	auto votes_with_weight = election->votes_with_weight ();
3055  	ASSERT_EQ (1, std::count_if (votes_with_weight.begin (), votes_with_weight.end (), is_genesis_vote));
3056  	auto vote = std::find_if (votes_with_weight.begin (), votes_with_weight.end (), is_genesis_vote);
3057  	ASSERT_NE (votes_with_weight.end (), vote);
3058  	ASSERT_EQ (fork->hash (), vote->hash);
3059  }
3060  TEST (node, rollback_gap_source)
3061  {
3062  	nano::test::system system;
3063  	nano::node_config node_config (system.get_available_port (), system.logging);
3064  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3065  	auto & node = *system.add_node (node_config);
3066  	nano::state_block_builder builder;
3067  	nano::keypair key;
3068  	auto send1 = builder.make_block ()
3069  				 .account (nano::dev::genesis_key.pub)
3070  				 .previous (nano::dev::genesis->hash ())
3071  				 .representative (nano::dev::genesis_key.pub)
3072  				 .link (key.pub)
3073  				 .balance (nano::dev::constants.genesis_amount - 1)
3074  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3075  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3076  				 .build_shared ();
3077  	auto fork1a = builder.make_block ()
3078  				  .account (key.pub)
3079  				  .previous (0)
3080  				  .representative (key.pub)
3081  				  .link (send1->hash ())
3082  				  .balance (1)
3083  				  .sign (key.prv, key.pub)
3084  				  .work (*system.work.generate (key.pub))
3085  				  .build_shared ();
3086  	auto send2 = builder.make_block ()
3087  				 .from (*send1)
3088  				 .previous (send1->hash ())
3089  				 .balance (send1->balance ().number () - 1)
3090  				 .link (key.pub)
3091  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3092  				 .work (*system.work.generate (send1->hash ()))
3093  				 .build_shared ();
3094  	auto fork1b = builder.make_block ()
3095  				  .from (*fork1a)
3096  				  .link (send2->hash ())
3097  				  .sign (key.prv, key.pub)
3098  				  .build_shared ();
3099  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
3100  	ASSERT_EQ (nano::process_result::progress, node.process (*fork1a).code);
3101  	ASSERT_EQ (nullptr, node.block (send2->hash ()));
3102  	node.block_processor.force (fork1b);
3103  	ASSERT_TIMELY (5s, node.block (fork1a->hash ()) == nullptr);
3104  	ASSERT_TIMELY (5s, node.stats.count (nano::stat::type::rollback, nano::stat::detail::open) == 1);
3105  	ASSERT_EQ (nullptr, node.block (fork1b->hash ()));
3106  	node.process_active (fork1a);
3107  	ASSERT_TIMELY (5s, node.block (fork1a->hash ()) != nullptr);
3108  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
3109  	node.block_processor.force (fork1b);
3110  	ASSERT_TIMELY (5s, node.stats.count (nano::stat::type::rollback, nano::stat::detail::open) == 2);
3111  	ASSERT_TIMELY (5s, node.block (fork1b->hash ()) != nullptr);
3112  	ASSERT_EQ (nullptr, node.block (fork1a->hash ()));
3113  }
3114  TEST (node, dependency_graph)
3115  {
3116  	nano::test::system system;
3117  	nano::node_config config (system.get_available_port (), system.logging);
3118  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3119  	auto & node = *system.add_node (config);
3120  	nano::state_block_builder builder;
3121  	nano::keypair key1, key2, key3;
3122  	auto gen_send1 = builder.make_block ()
3123  					 .account (nano::dev::genesis_key.pub)
3124  					 .previous (nano::dev::genesis->hash ())
3125  					 .representative (nano::dev::genesis_key.pub)
3126  					 .link (key1.pub)
3127  					 .balance (nano::dev::constants.genesis_amount - 1)
3128  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3129  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
3130  					 .build_shared ();
3131  	auto key1_open = builder.make_block ()
3132  					 .account (key1.pub)
3133  					 .previous (0)
3134  					 .representative (key1.pub)
3135  					 .link (gen_send1->hash ())
3136  					 .balance (1)
3137  					 .sign (key1.prv, key1.pub)
3138  					 .work (*system.work.generate (key1.pub))
3139  					 .build ();
3140  	auto key1_send1 = builder.make_block ()
3141  					  .account (key1.pub)
3142  					  .previous (key1_open->hash ())
3143  					  .representative (key1.pub)
3144  					  .link (nano::dev::genesis_key.pub)
3145  					  .balance (0)
3146  					  .sign (key1.prv, key1.pub)
3147  					  .work (*system.work.generate (key1_open->hash ()))
3148  					  .build ();
3149  	auto gen_receive = builder.make_block ()
3150  					   .from (*gen_send1)
3151  					   .previous (gen_send1->hash ())
3152  					   .link (key1_send1->hash ())
3153  					   .balance (nano::dev::constants.genesis_amount)
3154  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3155  					   .work (*system.work.generate (gen_send1->hash ()))
3156  					   .build ();
3157  	auto gen_send2 = builder.make_block ()
3158  					 .from (*gen_receive)
3159  					 .previous (gen_receive->hash ())
3160  					 .link (key2.pub)
3161  					 .balance (gen_receive->balance ().number () - 2)
3162  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3163  					 .work (*system.work.generate (gen_receive->hash ()))
3164  					 .build ();
3165  	auto key2_open = builder.make_block ()
3166  					 .account (key2.pub)
3167  					 .previous (0)
3168  					 .representative (key2.pub)
3169  					 .link (gen_send2->hash ())
3170  					 .balance (2)
3171  					 .sign (key2.prv, key2.pub)
3172  					 .work (*system.work.generate (key2.pub))
3173  					 .build ();
3174  	auto key2_send1 = builder.make_block ()
3175  					  .account (key2.pub)
3176  					  .previous (key2_open->hash ())
3177  					  .representative (key2.pub)
3178  					  .link (key3.pub)
3179  					  .balance (1)
3180  					  .sign (key2.prv, key2.pub)
3181  					  .work (*system.work.generate (key2_open->hash ()))
3182  					  .build ();
3183  	auto key3_open = builder.make_block ()
3184  					 .account (key3.pub)
3185  					 .previous (0)
3186  					 .representative (key3.pub)
3187  					 .link (key2_send1->hash ())
3188  					 .balance (1)
3189  					 .sign (key3.prv, key3.pub)
3190  					 .work (*system.work.generate (key3.pub))
3191  					 .build ();
3192  	auto key2_send2 = builder.make_block ()
3193  					  .from (*key2_send1)
3194  					  .previous (key2_send1->hash ())
3195  					  .link (key1.pub)
3196  					  .balance (key2_send1->balance ().number () - 1)
3197  					  .sign (key2.prv, key2.pub)
3198  					  .work (*system.work.generate (key2_send1->hash ()))
3199  					  .build ();
3200  	auto key1_receive = builder.make_block ()
3201  						.from (*key1_send1)
3202  						.previous (key1_send1->hash ())
3203  						.link (key2_send2->hash ())
3204  						.balance (key1_send1->balance ().number () + 1)
3205  						.sign (key1.prv, key1.pub)
3206  						.work (*system.work.generate (key1_send1->hash ()))
3207  						.build ();
3208  	auto key1_send2 = builder.make_block ()
3209  					  .from (*key1_receive)
3210  					  .previous (key1_receive->hash ())
3211  					  .link (key3.pub)
3212  					  .balance (key1_receive->balance ().number () - 1)
3213  					  .sign (key1.prv, key1.pub)
3214  					  .work (*system.work.generate (key1_receive->hash ()))
3215  					  .build ();
3216  	auto key3_receive = builder.make_block ()
3217  						.from (*key3_open)
3218  						.previous (key3_open->hash ())
3219  						.link (key1_send2->hash ())
3220  						.balance (key3_open->balance ().number () + 1)
3221  						.sign (key3.prv, key3.pub)
3222  						.work (*system.work.generate (key3_open->hash ()))
3223  						.build ();
3224  	auto key3_epoch = builder.make_block ()
3225  					  .from (*key3_receive)
3226  					  .previous (key3_receive->hash ())
3227  					  .link (node.ledger.epoch_link (nano::epoch::epoch_1))
3228  					  .balance (key3_receive->balance ())
3229  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3230  					  .work (*system.work.generate (key3_receive->hash ()))
3231  					  .build ();
3232  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_send1).code);
3233  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_open).code);
3234  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_send1).code);
3235  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_receive).code);
3236  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_send2).code);
3237  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_open).code);
3238  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_send1).code);
3239  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_open).code);
3240  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_send2).code);
3241  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_receive).code);
3242  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_send2).code);
3243  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_receive).code);
3244  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_epoch).code);
3245  	ASSERT_TRUE (node.active.empty ());
3246  	std::unordered_map<nano::block_hash, std::vector<nano::block_hash>> dependency_graph{
3247  		{ key1_open->hash (), { gen_send1->hash () } },
3248  		{ key1_send1->hash (), { key1_open->hash () } },
3249  		{ gen_receive->hash (), { gen_send1->hash (), key1_open->hash () } },
3250  		{ gen_send2->hash (), { gen_receive->hash () } },
3251  		{ key2_open->hash (), { gen_send2->hash () } },
3252  		{ key2_send1->hash (), { key2_open->hash () } },
3253  		{ key3_open->hash (), { key2_send1->hash () } },
3254  		{ key2_send2->hash (), { key2_send1->hash () } },
3255  		{ key1_receive->hash (), { key1_send1->hash (), key2_send2->hash () } },
3256  		{ key1_send2->hash (), { key1_send1->hash () } },
3257  		{ key3_receive->hash (), { key3_open->hash (), key1_send2->hash () } },
3258  		{ key3_epoch->hash (), { key3_receive->hash () } },
3259  	};
3260  	ASSERT_EQ (node.ledger.cache.block_count - 2, dependency_graph.size ());
3261  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3262  	node.block_confirm (gen_send1);
3263  	ASSERT_NO_ERROR (system.poll_until_true (15s, [&] {
3264  		EXPECT_LT (node.active.size (), 6);
3265  		auto error = std::any_of (dependency_graph.cbegin (), dependency_graph.cend (), [&] (auto entry) {
3266  			if (node.active.active (entry.first))
3267  			{
3268  				for (auto ancestor : entry.second)
3269  				{
3270  					if (!node.block_confirmed (ancestor))
3271  					{
3272  						return true;
3273  					}
3274  				}
3275  			}
3276  			return false;
3277  		});
3278  		EXPECT_FALSE (error);
3279  		return error || node.ledger.cache.cemented_count == node.ledger.cache.block_count;
3280  	}));
3281  	ASSERT_EQ (node.ledger.cache.cemented_count, node.ledger.cache.block_count);
3282  	ASSERT_TIMELY (5s, node.active.empty ());
3283  }
3284  TEST (node, dependency_graph_frontier)
3285  {
3286  	nano::test::system system;
3287  	nano::node_config config (system.get_available_port (), system.logging);
3288  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3289  	auto & node1 = *system.add_node (config);
3290  	config.peering_port = system.get_available_port ();
3291  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::always;
3292  	auto & node2 = *system.add_node (config);
3293  	nano::state_block_builder builder;
3294  	nano::keypair key1, key2, key3;
3295  	auto gen_send1 = builder.make_block ()
3296  					 .account (nano::dev::genesis_key.pub)
3297  					 .previous (nano::dev::genesis->hash ())
3298  					 .representative (nano::dev::genesis_key.pub)
3299  					 .link (key1.pub)
3300  					 .balance (nano::dev::constants.genesis_amount - 1)
3301  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3302  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
3303  					 .build_shared ();
3304  	auto key1_open = builder.make_block ()
3305  					 .account (key1.pub)
3306  					 .previous (0)
3307  					 .representative (key1.pub)
3308  					 .link (gen_send1->hash ())
3309  					 .balance (1)
3310  					 .sign (key1.prv, key1.pub)
3311  					 .work (*system.work.generate (key1.pub))
3312  					 .build ();
3313  	auto key1_send1 = builder.make_block ()
3314  					  .account (key1.pub)
3315  					  .previous (key1_open->hash ())
3316  					  .representative (key1.pub)
3317  					  .link (nano::dev::genesis_key.pub)
3318  					  .balance (0)
3319  					  .sign (key1.prv, key1.pub)
3320  					  .work (*system.work.generate (key1_open->hash ()))
3321  					  .build ();
3322  	auto gen_receive = builder.make_block ()
3323  					   .from (*gen_send1)
3324  					   .previous (gen_send1->hash ())
3325  					   .link (key1_send1->hash ())
3326  					   .balance (nano::dev::constants.genesis_amount)
3327  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3328  					   .work (*system.work.generate (gen_send1->hash ()))
3329  					   .build ();
3330  	auto gen_send2 = builder.make_block ()
3331  					 .from (*gen_receive)
3332  					 .previous (gen_receive->hash ())
3333  					 .link (key2.pub)
3334  					 .balance (gen_receive->balance ().number () - 2)
3335  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3336  					 .work (*system.work.generate (gen_receive->hash ()))
3337  					 .build ();
3338  	auto key2_open = builder.make_block ()
3339  					 .account (key2.pub)
3340  					 .previous (0)
3341  					 .representative (key2.pub)
3342  					 .link (gen_send2->hash ())
3343  					 .balance (2)
3344  					 .sign (key2.prv, key2.pub)
3345  					 .work (*system.work.generate (key2.pub))
3346  					 .build ();
3347  	auto key2_send1 = builder.make_block ()
3348  					  .account (key2.pub)
3349  					  .previous (key2_open->hash ())
3350  					  .representative (key2.pub)
3351  					  .link (key3.pub)
3352  					  .balance (1)
3353  					  .sign (key2.prv, key2.pub)
3354  					  .work (*system.work.generate (key2_open->hash ()))
3355  					  .build ();
3356  	auto key3_open = builder.make_block ()
3357  					 .account (key3.pub)
3358  					 .previous (0)
3359  					 .representative (key3.pub)
3360  					 .link (key2_send1->hash ())
3361  					 .balance (1)
3362  					 .sign (key3.prv, key3.pub)
3363  					 .work (*system.work.generate (key3.pub))
3364  					 .build ();
3365  	auto key2_send2 = builder.make_block ()
3366  					  .from (*key2_send1)
3367  					  .previous (key2_send1->hash ())
3368  					  .link (key1.pub)
3369  					  .balance (key2_send1->balance ().number () - 1)
3370  					  .sign (key2.prv, key2.pub)
3371  					  .work (*system.work.generate (key2_send1->hash ()))
3372  					  .build ();
3373  	auto key1_receive = builder.make_block ()
3374  						.from (*key1_send1)
3375  						.previous (key1_send1->hash ())
3376  						.link (key2_send2->hash ())
3377  						.balance (key1_send1->balance ().number () + 1)
3378  						.sign (key1.prv, key1.pub)
3379  						.work (*system.work.generate (key1_send1->hash ()))
3380  						.build ();
3381  	auto key1_send2 = builder.make_block ()
3382  					  .from (*key1_receive)
3383  					  .previous (key1_receive->hash ())
3384  					  .link (key3.pub)
3385  					  .balance (key1_receive->balance ().number () - 1)
3386  					  .sign (key1.prv, key1.pub)
3387  					  .work (*system.work.generate (key1_receive->hash ()))
3388  					  .build ();
3389  	auto key3_receive = builder.make_block ()
3390  						.from (*key3_open)
3391  						.previous (key3_open->hash ())
3392  						.link (key1_send2->hash ())
3393  						.balance (key3_open->balance ().number () + 1)
3394  						.sign (key3.prv, key3.pub)
3395  						.work (*system.work.generate (key3_open->hash ()))
3396  						.build ();
3397  	auto key3_epoch = builder.make_block ()
3398  					  .from (*key3_receive)
3399  					  .previous (key3_receive->hash ())
3400  					  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
3401  					  .balance (key3_receive->balance ())
3402  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3403  					  .work (*system.work.generate (key3_receive->hash ()))
3404  					  .build ();
3405  	for (auto const & node : system.nodes)
3406  	{
3407  		auto transaction (node->store.tx_begin_write ());
3408  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_send1).code);
3409  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_open).code);
3410  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_send1).code);
3411  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_receive).code);
3412  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_send2).code);
3413  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_open).code);
3414  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_send1).code);
3415  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_open).code);
3416  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_send2).code);
3417  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_receive).code);
3418  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_send2).code);
3419  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_receive).code);
3420  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_epoch).code);
3421  	}
3422  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3423  	ASSERT_TIMELY (10s, node2.active.active (gen_send1->qualified_root ()));
3424  	node1.block_confirm (gen_send1);
3425  	ASSERT_TIMELY (15s, node1.ledger.cache.cemented_count == node1.ledger.cache.block_count);
3426  	ASSERT_TIMELY (15s, node2.ledger.cache.cemented_count == node2.ledger.cache.block_count);
3427  }
3428  namespace nano
3429  {
3430  TEST (node, deferred_dependent_elections)
3431  {
3432  	nano::test::system system;
3433  	nano::node_config node_config_1{ system.get_available_port (), system.logging };
3434  	node_config_1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3435  	nano::node_config node_config_2{ system.get_available_port (), system.logging };
3436  	node_config_2.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3437  	nano::node_flags flags;
3438  	flags.disable_request_loop = true;
3439  	auto & node = *system.add_node (node_config_1, flags);
3440  	auto & node2 = *system.add_node (node_config_2, flags); 
3441  	nano::state_block_builder builder;
3442  	nano::keypair key;
3443  	auto send1 = builder.make_block ()
3444  				 .account (nano::dev::genesis_key.pub)
3445  				 .previous (nano::dev::genesis->hash ())
3446  				 .representative (nano::dev::genesis_key.pub)
3447  				 .link (key.pub)
3448  				 .balance (nano::dev::constants.genesis_amount - 1)
3449  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3450  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3451  				 .build_shared ();
3452  	auto open = builder.make_block ()
3453  				.account (key.pub)
3454  				.previous (0)
3455  				.representative (key.pub)
3456  				.link (send1->hash ())
3457  				.balance (1)
3458  				.sign (key.prv, key.pub)
3459  				.work (*system.work.generate (key.pub))
3460  				.build_shared ();
3461  	auto send2 = builder.make_block ()
3462  				 .from (*send1)
3463  				 .previous (send1->hash ())
3464  				 .balance (send1->balance ().number () - 1)
3465  				 .link (key.pub)
3466  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3467  				 .work (*system.work.generate (send1->hash ()))
3468  				 .build_shared ();
3469  	auto receive = builder.make_block ()
3470  				   .from (*open)
3471  				   .previous (open->hash ())
3472  				   .link (send2->hash ())
3473  				   .balance (2)
3474  				   .sign (key.prv, key.pub)
3475  				   .work (*system.work.generate (open->hash ()))
3476  				   .build_shared ();
3477  	auto fork = builder.make_block ()
3478  				.from (*receive)
3479  				.representative (nano::dev::genesis_key.pub) 
3480  				.sign (key.prv, key.pub)
3481  				.build_shared ();
3482  	nano::test::process (node, { send1 });
3483  	auto election_send1 = nano::test::start_election (system, node, send1->hash ());
3484  	ASSERT_NE (nullptr, election_send1);
3485  	nano::test::process (node, { open, send2 });
3486  	ASSERT_TIMELY (5s, node.block (open->hash ()));
3487  	ASSERT_TIMELY (5s, node.block (send2->hash ()));
3488  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()) || node.active.active (send2->qualified_root ()));
3489  	ASSERT_TIMELY (5s, node2.block (open->hash ()));
3490  	ASSERT_TIMELY (5s, node2.block (send2->hash ()));
3491  	node.work_generate_blocking (*open, nano::dev::network_params.work.difficulty (*open) + 1);
3492  	node.process_local (open);
3493  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()));
3494  	ASSERT_TRUE (nano::test::start_election (system, node, open->hash ()));
3495  	node.active.erase (*open);
3496  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3497  	node.work_generate_blocking (*open, nano::dev::network_params.work.difficulty (*open) + 1);
3498  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3499  	node.process_local (open);
3500  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()));
3501  	node.active.erase (*open);
3502  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3503  	node.active.erase (*send2);
3504  	ASSERT_FALSE (node.active.active (send2->qualified_root ()));
3505  	election_send1->force_confirm ();
3506  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
3507  	ASSERT_TIMELY (5s, node.active.active (open->qualified_root ()));
3508  	ASSERT_TIMELY (5s, node.active.active (send2->qualified_root ()));
3509  	auto election_open = node.active.election (open->qualified_root ());
3510  	ASSERT_NE (nullptr, election_open);
3511  	auto election_send2 = node.active.election (send2->qualified_root ());
3512  	ASSERT_NE (nullptr, election_open);
3513  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
3514  	ASSERT_FALSE (node.active.active (receive->qualified_root ()));
3515  	election_open->force_confirm ();
3516  	ASSERT_TIMELY (5s, node.block_confirmed (open->hash ()));
3517  	ASSERT_FALSE (node.ledger.dependents_confirmed (node.store.tx_begin_read (), *receive));
3518  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3519  	ASSERT_FALSE (node.ledger.rollback (node.store.tx_begin_write (), receive->hash ()));
3520  	ASSERT_FALSE (node.block (receive->hash ()));
3521  	node.process_local (receive);
3522  	ASSERT_TIMELY (5s, node.block (receive->hash ()));
3523  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3524  	ASSERT_EQ (nano::process_result::fork, node.process (*fork).code);
3525  	node.process_local (fork);
3526  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3527  	election_send2->force_confirm ();
3528  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
3529  	ASSERT_TIMELY (5s, node.active.active (receive->qualified_root ()));
3530  }
3531  }
3532  TEST (rep_crawler, recently_confirmed)
3533  {
3534  	nano::test::system system (1);
3535  	auto & node1 (*system.nodes[0]);
3536  	ASSERT_EQ (1, node1.ledger.cache.block_count);
3537  	auto const block = nano::dev::genesis;
3538  	node1.active.recently_confirmed.put (block->qualified_root (), block->hash ());
3539  	auto & node2 (*system.add_node ());
3540  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
3541  	auto channel = node1.network.find_node_id (node2.get_node_id ());
3542  	ASSERT_NE (nullptr, channel);
3543  	node1.rep_crawler.query (channel);
3544  	ASSERT_TIMELY (3s, node1.rep_crawler.representative_count () == 1);
3545  }
3546  namespace nano
3547  {
3548  TEST (rep_crawler, local)
3549  {
3550  	nano::test::system system;
3551  	nano::node_flags flags;
3552  	flags.disable_rep_crawler = true;
3553  	auto & node = *system.add_node (flags);
3554  	auto loopback = std::make_shared<nano::transport::inproc::channel> (node, node);
3555  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector{ nano::dev::genesis->hash () });
3556  	{
3557  		nano::lock_guard<nano::mutex> guard{ node.rep_crawler.probable_reps_mutex };
3558  		node.rep_crawler.active.insert (nano::dev::genesis->hash ());
3559  		node.rep_crawler.responses.emplace_back (loopback, vote);
3560  	}
3561  	node.rep_crawler.validate ();
3562  	ASSERT_EQ (0, node.rep_crawler.representative_count ());
3563  }
3564  }
3565  TEST (node, pruning_automatic)
3566  {
3567  	nano::test::system system{};
3568  	nano::node_config node_config{ system.get_available_port (), system.logging };
3569  	node_config.enable_voting = false;
3570  	node_config.max_pruning_age = std::chrono::seconds (1);
3571  	nano::node_flags node_flags{};
3572  	node_flags.enable_pruning = true;
3573  	auto & node1 = *system.add_node (node_config, node_flags);
3574  	nano::keypair key1{};
3575  	nano::send_block_builder builder{};
3576  	auto latest_hash = nano::dev::genesis->hash ();
3577  	auto send1 = builder.make_block ()
3578  				 .previous (latest_hash)
3579  				 .destination (key1.pub)
3580  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3581  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3582  				 .work (*system.work.generate (latest_hash))
3583  				 .build_shared ();
3584  	node1.process_active (send1);
3585  	latest_hash = send1->hash ();
3586  	auto send2 = builder.make_block ()
3587  				 .previous (latest_hash)
3588  				 .destination (key1.pub)
3589  				 .balance (0)
3590  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3591  				 .work (*system.work.generate (latest_hash))
3592  				 .build_shared ();
3593  	node1.process_active (send2);
3594  	ASSERT_TIMELY (5s, node1.block (send2->hash ()) != nullptr);
3595  	node1.process_confirmed (nano::election_status{ send1 });
3596  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3597  	node1.process_confirmed (nano::election_status{ send2 });
3598  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3599  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3600  	ASSERT_TIMELY (5s, node1.ledger.cache.pruned_count == 1);
3601  	ASSERT_TIMELY (5s, node1.store.pruned.count (node1.store.tx_begin_read ()) == 1);
3602  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3603  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3604  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3605  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3606  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3607  }
3608  TEST (node, pruning_age)
3609  {
3610  	nano::test::system system{};
3611  	nano::node_config node_config{ system.get_available_port (), system.logging };
3612  	node_config.enable_voting = false;
3613  	nano::node_flags node_flags{};
3614  	node_flags.enable_pruning = true;
3615  	auto & node1 = *system.add_node (node_config, node_flags);
3616  	nano::keypair key1{};
3617  	nano::send_block_builder builder{};
3618  	auto latest_hash = nano::dev::genesis->hash ();
3619  	auto send1 = builder.make_block ()
3620  				 .previous (latest_hash)
3621  				 .destination (key1.pub)
3622  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3623  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3624  				 .work (*system.work.generate (latest_hash))
3625  				 .build_shared ();
3626  	node1.process_active (send1);
3627  	latest_hash = send1->hash ();
3628  	auto send2 = builder.make_block ()
3629  				 .previous (latest_hash)
3630  				 .destination (key1.pub)
3631  				 .balance (0)
3632  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3633  				 .work (*system.work.generate (latest_hash))
3634  				 .build_shared ();
3635  	node1.process_active (send2);
3636  	node1.process_confirmed (nano::election_status{ send1 });
3637  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3638  	node1.process_confirmed (nano::election_status{ send2 });
3639  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3640  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3641  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3642  	node1.ledger_pruning (1, true, false);
3643  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3644  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3645  	node1.config.max_pruning_age = std::chrono::seconds{ 0 };
3646  	node1.ledger_pruning (1, true, false);
3647  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3648  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3649  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3650  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3651  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3652  }
3653  TEST (node, pruning_depth)
3654  {
3655  	nano::test::system system{};
3656  	nano::node_config node_config{ system.get_available_port (), system.logging };
3657  	node_config.enable_voting = false;
3658  	nano::node_flags node_flags{};
3659  	node_flags.enable_pruning = true;
3660  	auto & node1 = *system.add_node (node_config, node_flags);
3661  	nano::keypair key1{};
3662  	nano::send_block_builder builder{};
3663  	auto latest_hash = nano::dev::genesis->hash ();
3664  	auto send1 = builder.make_block ()
3665  				 .previous (latest_hash)
3666  				 .destination (key1.pub)
3667  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3668  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3669  				 .work (*system.work.generate (latest_hash))
3670  				 .build_shared ();
3671  	node1.process_active (send1);
3672  	latest_hash = send1->hash ();
3673  	auto send2 = builder.make_block ()
3674  				 .previous (latest_hash)
3675  				 .destination (key1.pub)
3676  				 .balance (0)
3677  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3678  				 .work (*system.work.generate (latest_hash))
3679  				 .build_shared ();
3680  	node1.process_active (send2);
3681  	node1.process_confirmed (nano::election_status{ send1 });
3682  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3683  	node1.process_confirmed (nano::election_status{ send2 });
3684  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3685  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3686  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3687  	node1.ledger_pruning (1, true, false);
3688  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3689  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3690  	node1.config.max_pruning_depth = 1;
3691  	node1.ledger_pruning (1, true, false);
3692  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3693  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3694  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3695  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3696  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3697  }
3698  TEST (node_config, node_id_private_key_persistence)
3699  {
3700  	nano::logger_mt logger;
3701  	auto path = nano::unique_path ();
3702  	ASSERT_TRUE (boost::filesystem::create_directories (path));
3703  	auto priv_key_filename = path / "node_id_private.key";
3704  	nano::keypair kp1 = nano::load_or_create_node_id (path, logger);
3705  	boost::filesystem::remove (priv_key_filename);
3706  	nano::keypair kp2 = nano::load_or_create_node_id (path, logger);
3707  	ASSERT_NE (kp1.prv, kp2.prv);
3708  	nano::keypair kp3 = nano::load_or_create_node_id (path, logger);
3709  	ASSERT_EQ (kp2.prv, kp3.prv);
3710  	std::ofstream ofs (priv_key_filename.string (), std::ofstream::out | std::ofstream::trunc);
3711  	ofs << "3F28D035B8AA75EA53DF753BFD065CF6138E742971B2C99B84FD8FE328FED2D9" << std::flush;
3712  	ofs.close ();
3713  	nano::keypair kp4 = nano::load_or_create_node_id (path, logger);
3714  	ASSERT_EQ (kp4.prv, nano::keypair ("3F28D035B8AA75EA53DF753BFD065CF6138E742971B2C99B84FD8FE328FED2D9").prv);
3715  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-fl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.cpp</div>
                </div>
                <div class="column column_space"><pre><code>99    return Cs+PutBf(Str.CStr(), Str.Len());
100  }
101  int TSOut::PutStrFmt(const char *FmtStr, ...){
102    char Bf[10*1024];
103    va_list valist;
104    va_start(valist, FmtStr);
</pre></code></div>
                <div class="column column_space"><pre><code>53  		ASSERT_TRUE (work.is_initialized ());
54  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
55  		ASSERT_FALSE (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
56  	}
57  }
58  TEST (node, block_store_path_failure)
59  {
60  	nano::test::system system;
61  	auto service (boost::make_shared<boost::asio::io_context> ());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    