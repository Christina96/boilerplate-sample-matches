
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5460636515912896%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_math_functions.cpp</h3>
            <pre><code>1  #include <stdint.h>  
2  #include <time.h>
3  #include <cmath>  
4  #include "gtest/gtest.h"
5  #include "caffe/blob.hpp"
6  #include "caffe/common.hpp"
7  #include "caffe/filler.hpp"
8  #include "caffe/util/math_functions.hpp"
9  #include "caffe/test/test_caffe_main.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MathFunctionsTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MathFunctionsTest()
16        : blob_bottom_(new Blob<Dtype>()),
17          blob_top_(new Blob<Dtype>()) {
18    }
19    virtual void SetUp() {
20      Caffe::set_random_seed(1701);
21      this->blob_bottom_->Reshape(11, 17, 19, 23);
22      this->blob_top_->Reshape(11, 17, 19, 23);
23      FillerParameter filler_param;
24      GaussianFiller<Dtype> filler(filler_param);
25      filler.Fill(this->blob_bottom_);
26      filler.Fill(this->blob_top_);
27    }
28    virtual ~MathFunctionsTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31    }
32    Blob<Dtype>* const blob_bottom_;
33    Blob<Dtype>* const blob_top_;
34  };
35  template <typename Dtype>
36  class CPUMathFunctionsTest
37    : public MathFunctionsTest<CPUDevice<Dtype> > {
38  };
39  TYPED_TEST_CASE(CPUMathFunctionsTest, TestDtypes);
40  TYPED_TEST(CPUMathFunctionsTest, TestNothing) {
41  }
42  TYPED_TEST(CPUMathFunctionsTest, TestAsum) {
43    int n = this->blob_bottom_->count();
44    const TypeParam* x = this->blob_bottom_->cpu_data();
45    TypeParam std_asum = 0;
46    for (int i = 0; i < n; ++i) {
47      std_asum += std::fabs(x[i]);
48    }
49    TypeParam cpu_asum = caffe_cpu_asum<TypeParam>(n, x);
50    EXPECT_LT((cpu_asum - std_asum) / std_asum, 1e-2);
51  }
52  TYPED_TEST(CPUMathFunctionsTest, TestSign) {
53    int n = this->blob_bottom_->count();
54    const TypeParam* x = this->blob_bottom_->cpu_data();
55    caffe_cpu_sign<TypeParam>(n, x, this->blob_bottom_->mutable_cpu_diff());
56    const TypeParam* signs = this->blob_bottom_->cpu_diff();
57    for (int i = 0; i < n; ++i) {
58      EXPECT_EQ(signs[i], x[i] > 0 ? 1 : (x[i] < 0 ? -1 : 0));
59    }
60  }
61  TYPED_TEST(CPUMathFunctionsTest, TestSgnbit) {
62    int n = this->blob_bottom_->count();
63    const TypeParam* x = this->blob_bottom_->cpu_data();
64    caffe_cpu_sgnbit<TypeParam>(n, x, this->blob_bottom_->mutable_cpu_diff());
65    const TypeParam* signbits = this->blob_bottom_->cpu_diff();
66    for (int i = 0; i < n; ++i) {
67      EXPECT_EQ(signbits[i], x[i] < 0 ? 1 : 0);
68    }
69  }
70  TYPED_TEST(CPUMathFunctionsTest, TestFabs) {
71    int n = this->blob_bottom_->count();
72    const TypeParam* x = this->blob_bottom_->cpu_data();
73    caffe_abs<TypeParam>(n, x, this->blob_bottom_->mutable_cpu_diff());
74    const TypeParam* abs_val = this->blob_bottom_->cpu_diff();
75    for (int i = 0; i < n; ++i) {
76      EXPECT_EQ(abs_val[i], x[i] > 0 ? x[i] : -x[i]);
77    }
78  }
79  TYPED_TEST(CPUMathFunctionsTest, TestScale) {
<span onclick='openModal()' class='match'>80    int n = this->blob_bottom_->count();
81    TypeParam alpha = this->blob_bottom_->cpu_diff()[caffe_rng_rand() %
82                                                     this->blob_bottom_->count()];
83    caffe_cpu_scale<TypeParam>(n, alpha, this->blob_bottom_->cpu_data(),
</span>84                               this->blob_bottom_->mutable_cpu_diff());
85    const TypeParam* scaled = this->blob_bottom_->cpu_diff();
86    const TypeParam* x = this->blob_bottom_->cpu_data();
87    for (int i = 0; i < n; ++i) {
88      EXPECT_EQ(scaled[i], x[i] * alpha);
89    }
90  }
91  TYPED_TEST(CPUMathFunctionsTest, TestCopy) {
92    const int n = this->blob_bottom_->count();
93    const TypeParam* bottom_data = this->blob_bottom_->cpu_data();
94    TypeParam* top_data = this->blob_top_->mutable_cpu_data();
95    caffe_copy(n, bottom_data, top_data);
96    for (int i = 0; i < n; ++i) {
97      EXPECT_EQ(bottom_data[i], top_data[i]);
98    }
99  }
100  #ifndef CPU_ONLY
101  template <typename Dtype>
102  class GPUMathFunctionsTest : public MathFunctionsTest<GPUDevice<Dtype> > {
103  };
104  TYPED_TEST_CASE(GPUMathFunctionsTest, TestDtypes);
105  TYPED_TEST(GPUMathFunctionsTest, TestAsum) {
106    int n = this->blob_bottom_->count();
107    const TypeParam* x = this->blob_bottom_->cpu_data();
108    TypeParam std_asum = 0;
109    for (int i = 0; i < n; ++i) {
110      std_asum += std::fabs(x[i]);
111    }
112    TypeParam gpu_asum;
113    caffe_gpu_asum<TypeParam>(n, this->blob_bottom_->gpu_data(), &gpu_asum);
114    EXPECT_LT((gpu_asum - std_asum) / std_asum, 1e-2);
115  }
116  TYPED_TEST(GPUMathFunctionsTest, TestSign) {
117    int n = this->blob_bottom_->count();
118    caffe_gpu_sign<TypeParam>(n, this->blob_bottom_->gpu_data(),
119                              this->blob_bottom_->mutable_gpu_diff());
120    const TypeParam* signs = this->blob_bottom_->cpu_diff();
121    const TypeParam* x = this->blob_bottom_->cpu_data();
122    for (int i = 0; i < n; ++i) {
123      EXPECT_EQ(signs[i], x[i] > 0 ? 1 : (x[i] < 0 ? -1 : 0));
124    }
125  }
126  TYPED_TEST(GPUMathFunctionsTest, TestSgnbit) {
127    int n = this->blob_bottom_->count();
128    caffe_gpu_sgnbit<TypeParam>(n, this->blob_bottom_->gpu_data(),
129                              this->blob_bottom_->mutable_gpu_diff());
130    const TypeParam* signbits = this->blob_bottom_->cpu_diff();
131    const TypeParam* x = this->blob_bottom_->cpu_data();
132    for (int i = 0; i < n; ++i) {
133      EXPECT_EQ(signbits[i], x[i] < 0 ? 1 : 0);
134    }
135  }
136  TYPED_TEST(GPUMathFunctionsTest, TestFabs) {
137    int n = this->blob_bottom_->count();
138    caffe_gpu_abs<TypeParam>(n, this->blob_bottom_->gpu_data(),
139                              this->blob_bottom_->mutable_gpu_diff());
140    const TypeParam* abs_val = this->blob_bottom_->cpu_diff();
141    const TypeParam* x = this->blob_bottom_->cpu_data();
142    for (int i = 0; i < n; ++i) {
143      EXPECT_EQ(abs_val[i], x[i] > 0 ? x[i] : -x[i]);
144    }
145  }
146  TYPED_TEST(GPUMathFunctionsTest, TestScale) {
147    int n = this->blob_bottom_->count();
148    TypeParam alpha = this->blob_bottom_->cpu_diff()[caffe_rng_rand() %
149                                                     this->blob_bottom_->count()];
150    caffe_gpu_scale<TypeParam>(n, alpha, this->blob_bottom_->gpu_data(),
151                               this->blob_bottom_->mutable_gpu_diff());
152    const TypeParam* scaled = this->blob_bottom_->cpu_diff();
153    const TypeParam* x = this->blob_bottom_->cpu_data();
154    for (int i = 0; i < n; ++i) {
155      EXPECT_EQ(scaled[i], x[i] * alpha);
156    }
157  }
158  TYPED_TEST(GPUMathFunctionsTest, TestCopy) {
159    const int n = this->blob_bottom_->count();
160    const TypeParam* bottom_data = this->blob_bottom_->gpu_data();
161    TypeParam* top_data = this->blob_top_->mutable_gpu_data();
162    caffe_copy(n, bottom_data, top_data);
163    bottom_data = this->blob_bottom_->cpu_data();
164    top_data = this->blob_top_->mutable_cpu_data();
165    for (int i = 0; i < n; ++i) {
166      EXPECT_EQ(bottom_data[i], top_data[i]);
167    }
168  }
169  #endif
170  }  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-bootstrap.cpp</h3>
            <pre><code>1  #include <nano/node/bootstrap/block_deserializer.hpp>
2  #include <nano/node/bootstrap/bootstrap_frontier.hpp>
3  #include <nano/node/bootstrap/bootstrap_lazy.hpp>
4  #include <nano/test_common/network.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  using namespace std::chrono_literals;
9  TEST (bulk_pull, no_address)
10  {
11  	nano::test::system system (1);
12  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
13  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
14  	req->start = 1;
15  	req->end = 2;
16  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
17  	ASSERT_EQ (request->current, request->request->end);
18  	ASSERT_TRUE (request->current.is_zero ());
19  }
20  TEST (bulk_pull, genesis_to_end)
21  {
22  	nano::test::system system (1);
23  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
24  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
25  	req->start = nano::dev::genesis_key.pub;
26  	req->end.clear ();
27  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
28  	ASSERT_EQ (system.nodes[0]->latest (nano::dev::genesis_key.pub), request->current);
29  	ASSERT_EQ (request->request->end, request->request->end);
30  }
31  TEST (bulk_pull, no_end)
32  {
33  	nano::test::system system (1);
34  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
35  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
36  	req->start = nano::dev::genesis_key.pub;
37  	req->end = 1;
38  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
39  	ASSERT_EQ (system.nodes[0]->latest (nano::dev::genesis_key.pub), request->current);
40  	ASSERT_TRUE (request->request->end.is_zero ());
41  }
42  TEST (bulk_pull, end_not_owned)
43  {
44  	nano::test::system system (1);
45  	nano::keypair key2;
46  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
47  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 100));
48  	nano::block_hash latest (system.nodes[0]->latest (nano::dev::genesis_key.pub));
49  	nano::block_builder builder;
50  	auto open = builder
51  				.open ()
52  				.source (0)
53  				.representative (1)
54  				.account (2)
55  				.sign (nano::keypair ().prv, 4)
56  				.work (5)
57  				.build ();
58  	open->hashables.account = key2.pub;
59  	open->hashables.representative = key2.pub;
60  	open->hashables.source = latest;
61  	open->refresh ();
62  	open->signature = nano::sign_message (key2.prv, key2.pub, open->hash ());
63  	system.nodes[0]->work_generate_blocking (*open);
64  	ASSERT_EQ (nano::process_result::progress, system.nodes[0]->process (*open).code);
65  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
66  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
67  	req->start = key2.pub;
68  	req->end = nano::dev::genesis->hash ();
69  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
70  	ASSERT_EQ (request->current, request->request->end);
71  }
72  TEST (bulk_pull, none)
73  {
74  	nano::test::system system (1);
75  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
76  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
77  	req->start = nano::dev::genesis_key.pub;
78  	req->end = nano::dev::genesis->hash ();
79  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
80  	auto block (request->get_next ());
81  	ASSERT_EQ (nullptr, block);
82  }
83  TEST (bulk_pull, get_next_on_open)
84  {
85  	nano::test::system system (1);
86  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
87  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
88  	req->start = nano::dev::genesis_key.pub;
89  	req->end.clear ();
90  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
91  	auto block (request->get_next ());
92  	ASSERT_NE (nullptr, block);
93  	ASSERT_TRUE (block->previous ().is_zero ());
94  	ASSERT_EQ (request->current, request->request->end);
95  }
96  TEST (bulk_pull, ascending_one_hash)
97  {
98  	nano::test::system system{ 1 };
99  	auto & node = *system.nodes[0];
100  	nano::state_block_builder builder;
101  	auto block1 = builder
102  				  .account (nano::dev::genesis_key.pub)
103  				  .previous (nano::dev::genesis->hash ())
104  				  .representative (nano::dev::genesis_key.pub)
105  				  .balance (nano::dev::constants.genesis_amount - 100)
106  				  .link (nano::dev::genesis_key.pub)
107  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
108  				  .work (0)
109  				  .build_shared ();
110  	node.work_generate_blocking (*block1);
111  	ASSERT_EQ (nano::process_result::progress, node.process (*block1).code);
112  	auto socket = std::make_shared<nano::transport::socket> (node, nano::transport::socket::endpoint_type_t::server);
113  	auto connection = std::make_shared<nano::transport::tcp_server> (socket, system.nodes[0]);
114  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
115  	req->start = nano::dev::genesis->hash ();
116  	req->end.clear ();
117  	req->header.flag_set (nano::message_header::bulk_pull_ascending_flag);
118  	auto request = std::make_shared<nano::bulk_pull_server> (connection, std::move (req));
119  	auto block_out1 = request->get_next ();
120  	ASSERT_NE (nullptr, block_out1);
121  	ASSERT_EQ (block_out1->hash (), block1->hash ());
122  	ASSERT_EQ (nullptr, request->get_next ());
123  }
124  TEST (bulk_pull, ascending_two_account)
125  {
126  	nano::test::system system{ 1 };
127  	auto & node = *system.nodes[0];
128  	nano::state_block_builder builder;
129  	auto block1 = builder
130  				  .account (nano::dev::genesis_key.pub)
131  				  .previous (nano::dev::genesis->hash ())
132  				  .representative (nano::dev::genesis_key.pub)
133  				  .balance (nano::dev::constants.genesis_amount - 100)
134  				  .link (nano::dev::genesis_key.pub)
135  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
136  				  .work (0)
137  				  .build_shared ();
138  	node.work_generate_blocking (*block1);
139  	ASSERT_EQ (nano::process_result::progress, node.process (*block1).code);
140  	auto socket = std::make_shared<nano::transport::socket> (node, nano::transport::socket::endpoint_type_t::server);
141  	auto connection = std::make_shared<nano::transport::tcp_server> (socket, system.nodes[0]);
142  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
143  	req->start = nano::dev::genesis->account ();
144  	req->end.clear ();
145  	req->header.flag_set (nano::message_header::bulk_pull_ascending_flag);
146  	auto request = std::make_shared<nano::bulk_pull_server> (connection, std::move (req));
147  	auto block_out1 = request->get_next ();
148  	ASSERT_NE (nullptr, block_out1);
149  	ASSERT_EQ (block_out1->hash (), nano::dev::genesis->hash ());
150  	auto block_out2 = request->get_next ();
151  	ASSERT_NE (nullptr, block_out2);
152  	ASSERT_EQ (block_out2->hash (), block1->hash ());
153  	ASSERT_EQ (nullptr, request->get_next ());
154  }
155  TEST (bulk_pull, ascending_end)
156  {
157  	nano::test::system system{ 1 };
158  	auto & node = *system.nodes[0];
159  	nano::state_block_builder builder;
160  	auto block1 = builder
161  				  .account (nano::dev::genesis_key.pub)
162  				  .previous (nano::dev::genesis->hash ())
163  				  .representative (nano::dev::genesis_key.pub)
164  				  .balance (nano::dev::constants.genesis_amount - 100)
165  				  .link (nano::dev::genesis_key.pub)
166  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
167  				  .work (0)
168  				  .build_shared ();
169  	node.work_generate_blocking (*block1);
170  	ASSERT_EQ (nano::process_result::progress, node.process (*block1).code);
171  	auto socket = std::make_shared<nano::transport::socket> (node, nano::transport::socket::endpoint_type_t::server);
172  	auto connection = std::make_shared<nano::transport::tcp_server> (socket, system.nodes[0]);
173  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
174  	req->start = nano::dev::genesis_key.pub;
175  	req->end = block1->hash ();
176  	req->header.flag_set (nano::message_header::bulk_pull_ascending_flag);
<span onclick='openModal()' class='match'>177  	auto request = std::make_shared<nano::bulk_pull_server> (connection, std::move (req));
178  	auto block_out1 = request->get_next ();
179  	ASSERT_NE (nullptr, block_out1);
180  	ASSERT_EQ (block_out1->hash (), nano::dev::genesis->hash ());
181  	ASSERT_EQ (nullptr, request->get_next ());
</span>182  }
183  TEST (bulk_pull, by_block)
184  {
185  	nano::test::system system (1);
186  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
187  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
188  	req->start = nano::dev::genesis->hash ();
189  	req->end.clear ();
190  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
191  	auto block (request->get_next ());
192  	ASSERT_NE (nullptr, block);
193  	ASSERT_EQ (block->hash (), nano::dev::genesis->hash ());
194  	block = request->get_next ();
195  	ASSERT_EQ (nullptr, block);
196  }
197  TEST (bulk_pull, by_block_single)
198  {
199  	nano::test::system system (1);
200  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
201  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
202  	req->start = nano::dev::genesis->hash ();
203  	req->end = nano::dev::genesis->hash ();
204  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
205  	auto block (request->get_next ());
206  	ASSERT_NE (nullptr, block);
207  	ASSERT_EQ (block->hash (), nano::dev::genesis->hash ());
208  	block = request->get_next ();
209  	ASSERT_EQ (nullptr, block);
210  }
211  TEST (bulk_pull, count_limit)
212  {
213  	nano::test::system system (1);
214  	auto node0 (system.nodes[0]);
215  	nano::block_builder builder;
216  	auto send1 = builder
217  				 .send ()
218  				 .previous (node0->latest (nano::dev::genesis_key.pub))
219  				 .destination (nano::dev::genesis_key.pub)
220  				 .balance (1)
221  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
222  				 .work (*system.work.generate (node0->latest (nano::dev::genesis_key.pub)))
223  				 .build_shared ();
224  	ASSERT_EQ (nano::process_result::progress, node0->process (*send1).code);
225  	auto receive1 = builder
226  					.receive ()
227  					.previous (send1->hash ())
228  					.source (send1->hash ())
229  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
230  					.work (*system.work.generate (send1->hash ()))
231  					.build_shared ();
232  	ASSERT_EQ (nano::process_result::progress, node0->process (*receive1).code);
233  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node0, nano::transport::socket::endpoint_type_t::server), node0));
234  	auto req = std::make_unique<nano::bulk_pull> (nano::dev::network_params.network);
235  	req->start = receive1->hash ();
236  	req->set_count_present (true);
237  	req->count = 2;
238  	auto request (std::make_shared<nano::bulk_pull_server> (connection, std::move (req)));
239  	ASSERT_EQ (request->max_count, 2);
240  	ASSERT_EQ (request->sent_count, 0);
241  	auto block (request->get_next ());
242  	ASSERT_NE (nullptr, block);
243  	ASSERT_EQ (receive1->hash (), block->hash ());
244  	block = request->get_next ();
245  	ASSERT_EQ (send1->hash (), block->hash ());
246  	block = request->get_next ();
247  	ASSERT_EQ (nullptr, block);
248  }
249  TEST (bootstrap_processor, DISABLED_process_none)
250  {
251  	nano::test::system system (1);
252  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
253  	ASSERT_FALSE (node1->init_error ());
254  	auto done (false);
255  	node1->bootstrap_initiator.bootstrap (system.nodes[0]->network.endpoint (), false);
256  	while (!done)
257  	{
258  		system.io_ctx.run_one ();
259  	}
260  	node1->stop ();
261  }
262  TEST (bootstrap_processor, process_one)
263  {
264  	nano::test::system system;
265  	nano::node_config node_config = system.default_config ();
266  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
267  	node_config.enable_voting = false;
268  	nano::node_flags node_flags;
269  	node_flags.disable_bootstrap_bulk_push_client = true;
270  	auto node0 = system.add_node (node_config, node_flags);
271  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
272  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 100));
273  	ASSERT_NE (nullptr, send);
274  	node_config.peering_port = system.get_available_port ();
275  	node_flags.disable_rep_crawler = true;
276  	auto node1 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), node_config, system.work, node_flags));
277  	nano::block_hash hash1 (node0->latest (nano::dev::genesis_key.pub));
278  	nano::block_hash hash2 (node1->latest (nano::dev::genesis_key.pub));
279  	ASSERT_NE (hash1, hash2);
280  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
281  	ASSERT_NE (node1->latest (nano::dev::genesis_key.pub), node0->latest (nano::dev::genesis_key.pub));
282  	ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == node0->latest (nano::dev::genesis_key.pub));
283  	node1->stop ();
284  }
285  TEST (bootstrap_processor, process_two)
286  {
287  	nano::test::system system;
288  	nano::node_config config = system.default_config ();
289  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
290  	nano::node_flags node_flags;
291  	node_flags.disable_bootstrap_bulk_push_client = true;
292  	auto node0 (system.add_node (config, node_flags));
293  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
294  	nano::block_hash hash1 (node0->latest (nano::dev::genesis_key.pub));
295  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 50));
296  	nano::block_hash hash2 (node0->latest (nano::dev::genesis_key.pub));
297  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 50));
298  	nano::block_hash hash3 (node0->latest (nano::dev::genesis_key.pub));
299  	ASSERT_NE (hash1, hash2);
300  	ASSERT_NE (hash1, hash3);
301  	ASSERT_NE (hash2, hash3);
302  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
303  	ASSERT_FALSE (node1->init_error ());
304  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
305  	ASSERT_NE (node1->latest (nano::dev::genesis_key.pub), node0->latest (nano::dev::genesis_key.pub));
306  	ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == node0->latest (nano::dev::genesis_key.pub));
307  	node1->stop ();
308  }
309  TEST (bootstrap_processor, process_state)
310  {
311  	nano::test::system system;
312  	nano::node_config config = system.default_config ();
313  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
314  	nano::node_flags node_flags;
315  	node_flags.disable_bootstrap_bulk_push_client = true;
316  	auto node0 (system.add_node (config, node_flags));
317  	nano::state_block_builder builder;
318  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
319  	auto block1 = builder
320  				  .account (nano::dev::genesis_key.pub)
321  				  .previous (node0->latest (nano::dev::genesis_key.pub))
322  				  .representative (nano::dev::genesis_key.pub)
323  				  .balance (nano::dev::constants.genesis_amount - 100)
324  				  .link (nano::dev::genesis_key.pub)
325  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
326  				  .work (0)
327  				  .build_shared ();
328  	auto block2 = builder
329  				  .make_block ()
330  				  .account (nano::dev::genesis_key.pub)
331  				  .previous (block1->hash ())
332  				  .representative (nano::dev::genesis_key.pub)
333  				  .balance (nano::dev::constants.genesis_amount)
334  				  .link (block1->hash ())
335  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
336  				  .work (0)
337  				  .build_shared ();
338  	node0->work_generate_blocking (*block1);
339  	node0->work_generate_blocking (*block2);
340  	ASSERT_EQ (nano::process_result::progress, node0->process (*block1).code);
341  	ASSERT_EQ (nano::process_result::progress, node0->process (*block2).code);
342  	config.peering_port = system.get_available_port ();
343  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
344  	ASSERT_EQ (node0->latest (nano::dev::genesis_key.pub), block2->hash ());
345  	ASSERT_NE (node1->latest (nano::dev::genesis_key.pub), block2->hash ());
346  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
347  	ASSERT_NE (node1->latest (nano::dev::genesis_key.pub), node0->latest (nano::dev::genesis_key.pub));
348  	ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == node0->latest (nano::dev::genesis_key.pub));
349  	node1->stop ();
350  }
351  TEST (bootstrap_processor, process_new)
352  {
353  	nano::test::system system;
354  	nano::node_config config = system.default_config ();
355  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
356  	nano::node_flags node_flags;
357  	node_flags.disable_bootstrap_bulk_push_client = true;
358  	auto node1 (system.add_node (config, node_flags));
359  	config.peering_port = system.get_available_port ();
360  	auto node2 (system.add_node (config, node_flags));
361  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
362  	nano::keypair key2;
363  	system.wallet (1)->insert_adhoc (key2.prv);
364  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node1->config.receive_minimum.number ()));
365  	ASSERT_NE (nullptr, send);
366  	ASSERT_TIMELY (10s, !node1->balance (key2.pub).is_zero ());
367  	auto receive (node2->block (node2->latest (key2.pub)));
368  	ASSERT_NE (nullptr, receive);
369  	nano::uint128_t balance1 (node1->balance (nano::dev::genesis_key.pub));
370  	nano::uint128_t balance2 (node1->balance (key2.pub));
371  	ASSERT_TIMELY (10s, node1->block_confirmed (send->hash ()) && node1->block_confirmed (receive->hash ()) && node1->active.empty () && node2->active.empty ()); 
372  	auto node3 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
373  	ASSERT_FALSE (node3->init_error ());
374  	node3->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
375  	ASSERT_TIMELY (10s, node3->balance (key2.pub) == balance2);
376  	ASSERT_EQ (balance1, node3->balance (nano::dev::genesis_key.pub));
377  	node3->stop ();
378  }
379  TEST (bootstrap_processor, pull_diamond)
380  {
381  	nano::test::system system;
382  	nano::node_config config = system.default_config ();
383  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
384  	nano::node_flags node_flags;
385  	node_flags.disable_bootstrap_bulk_push_client = true;
386  	auto node0 (system.add_node (config, node_flags));
387  	nano::keypair key;
388  	nano::block_builder builder;
389  	auto send1 = builder
390  				 .send ()
391  				 .previous (node0->latest (nano::dev::genesis_key.pub))
392  				 .destination (key.pub)
393  				 .balance (0)
394  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
395  				 .work (*system.work.generate (node0->latest (nano::dev::genesis_key.pub)))
396  				 .build_shared ();
397  	ASSERT_EQ (nano::process_result::progress, node0->process (*send1).code);
398  	auto open = builder
399  				.open ()
400  				.source (send1->hash ())
401  				.representative (1)
402  				.account (key.pub)
403  				.sign (key.prv, key.pub)
404  				.work (*system.work.generate (key.pub))
405  				.build_shared ();
406  	ASSERT_EQ (nano::process_result::progress, node0->process (*open).code);
407  	auto send2 = builder
408  				 .send ()
409  				 .previous (open->hash ())
410  				 .destination (nano::dev::genesis_key.pub)
411  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 100)
412  				 .sign (key.prv, key.pub)
413  				 .work (*system.work.generate (open->hash ()))
414  				 .build_shared ();
415  	ASSERT_EQ (nano::process_result::progress, node0->process (*send2).code);
416  	auto receive = builder
417  				   .receive ()
418  				   .previous (send1->hash ())
419  				   .source (send2->hash ())
420  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
421  				   .work (*system.work.generate (send1->hash ()))
422  				   .build_shared ();
423  	ASSERT_EQ (nano::process_result::progress, node0->process (*receive).code);
424  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
425  	ASSERT_FALSE (node1->init_error ());
426  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
427  	ASSERT_TIMELY (10s, node1->balance (nano::dev::genesis_key.pub) == 100);
428  	ASSERT_EQ (100, node1->balance (nano::dev::genesis_key.pub));
429  	node1->stop ();
430  }
431  TEST (bootstrap_processor, DISABLED_pull_requeue_network_error)
432  {
433  	nano::test::system system;
434  	nano::node_config config = system.default_config ();
435  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
436  	nano::node_flags node_flags;
437  	node_flags.disable_bootstrap_bulk_push_client = true;
438  	auto node1 (system.add_node (config, node_flags));
439  	config.peering_port = system.get_available_port ();
440  	auto node2 (system.add_node (config, node_flags));
441  	nano::keypair key1;
442  	nano::state_block_builder builder;
443  	auto send1 = builder
444  				 .account (nano::dev::genesis_key.pub)
445  				 .previous (nano::dev::genesis->hash ())
446  				 .representative (nano::dev::genesis_key.pub)
447  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
448  				 .link (key1.pub)
449  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
450  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
451  				 .build_shared ();
452  	node1->bootstrap_initiator.bootstrap (node2->network.endpoint ());
453  	auto attempt (node1->bootstrap_initiator.current_attempt ());
454  	ASSERT_NE (nullptr, attempt);
455  	ASSERT_TIMELY (2s, attempt->frontiers_received);
456  	{
457  		nano::unique_lock<nano::mutex> lock{ node1->bootstrap_initiator.connections->mutex };
458  		ASSERT_FALSE (attempt->stopped);
459  		++attempt->pulling;
460  		node1->bootstrap_initiator.connections->pulls.emplace_back (nano::dev::genesis_key.pub, send1->hash (), nano::dev::genesis->hash (), attempt->incremental_id);
461  		node1->bootstrap_initiator.connections->request_pull (lock);
462  		node2->stop ();
463  	}
464  	ASSERT_TIMELY (5s, attempt == nullptr || attempt->requeued_pulls == 1);
465  	ASSERT_EQ (0, node1->stats.count (nano::stat::type::bootstrap, nano::stat::detail::bulk_pull_failed_account, nano::stat::dir::in)); 
466  }
467  TEST (bootstrap_processor, DISABLED_push_diamond)
468  {
469  	nano::test::system system;
470  	nano::node_config config = system.default_config ();
471  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
472  	auto node0 (system.add_node (config));
473  	nano::keypair key;
474  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
475  	ASSERT_FALSE (node1->init_error ());
476  	auto wallet1 (node1->wallets.create (100));
477  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
478  	wallet1->insert_adhoc (key.prv);
479  	nano::block_builder builder;
480  	auto send1 = builder
481  				 .send ()
482  				 .previous (node0->latest (nano::dev::genesis_key.pub))
483  				 .destination (key.pub)
484  				 .balance (0)
485  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
486  				 .work (*system.work.generate (node0->latest (nano::dev::genesis_key.pub)))
487  				 .build_shared ();
488  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
489  	auto open = builder
490  				.open ()
491  				.source (send1->hash ())
492  				.representative (1)
493  				.account (key.pub)
494  				.sign (key.prv, key.pub)
495  				.work (*system.work.generate (key.pub))
496  				.build_shared ();
497  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
498  	auto send2 = builder
499  				 .send ()
500  				 .previous (open->hash ())
501  				 .destination (nano::dev::genesis_key.pub)
502  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 100)
503  				 .sign (key.prv, key.pub)
504  				 .work (*system.work.generate (open->hash ()))
505  				 .build_shared ();
506  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
507  	auto receive = builder
508  				   .receive ()
509  				   .previous (send1->hash ())
510  				   .source (send2->hash ())
511  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
512  				   .work (*system.work.generate (send1->hash ()))
513  				   .build_shared ();
514  	ASSERT_EQ (nano::process_result::progress, node1->process (*receive).code);
515  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
516  	ASSERT_TIMELY (10s, node0->balance (nano::dev::genesis_key.pub) == 100);
517  	ASSERT_EQ (100, node0->balance (nano::dev::genesis_key.pub));
518  	node1->stop ();
519  }
520  TEST (bootstrap_processor, DISABLED_push_diamond_pruning)
521  {
522  	nano::test::system system;
523  	nano::node_config config = system.default_config ();
524  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
525  	auto node0 (system.add_node (config));
526  	nano::keypair key;
527  	config.peering_port = system.get_available_port ();
528  	config.enable_voting = false; 
529  	nano::node_flags node_flags;
530  	node_flags.enable_pruning = true;
531  	auto node1 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), config, system.work, node_flags, 1));
532  	ASSERT_FALSE (node1->init_error ());
533  	auto latest (node0->latest (nano::dev::genesis_key.pub));
534  	nano::block_builder builder;
535  	auto send1 = builder
536  				 .send ()
537  				 .previous (latest)
538  				 .destination (key.pub)
539  				 .balance (0)
540  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
541  				 .work (*system.work.generate (latest))
542  				 .build_shared ();
543  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
544  	auto open = builder
545  				.open ()
546  				.source (send1->hash ())
547  				.representative (1)
548  				.account (key.pub)
549  				.sign (key.prv, key.pub)
550  				.work (*system.work.generate (key.pub))
551  				.build_shared ();
552  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
553  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
554  	ASSERT_TIMELY (10s, node0->balance (key.pub) == nano::dev::constants.genesis_amount);
555  	auto send2 = builder
556  				 .send ()
557  				 .previous (open->hash ())
558  				 .destination (nano::dev::genesis_key.pub)
559  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 100)
560  				 .sign (key.prv, key.pub)
561  				 .work (*system.work.generate (open->hash ()))
562  				 .build_shared ();
563  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
564  	auto receive = builder
565  				   .receive ()
566  				   .previous (send1->hash ())
567  				   .source (send2->hash ())
568  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
569  				   .work (*system.work.generate (send1->hash ()))
570  				   .build_shared ();
571  	ASSERT_EQ (nano::process_result::progress, node1->process (*receive).code);
572  	{
573  		auto transaction (node1->store.tx_begin_write ());
574  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 2));
575  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, open->hash (), 1));
576  		ASSERT_TRUE (node1->store.block.exists (transaction, latest));
577  		ASSERT_FALSE (node1->store.block.exists (transaction, send1->hash ()));
578  		ASSERT_TRUE (node1->store.pruned.exists (transaction, send1->hash ()));
579  		ASSERT_FALSE (node1->store.block.exists (transaction, open->hash ()));
580  		ASSERT_TRUE (node1->store.pruned.exists (transaction, open->hash ()));
581  		ASSERT_TRUE (node1->store.block.exists (transaction, send2->hash ()));
582  		ASSERT_TRUE (node1->store.block.exists (transaction, receive->hash ()));
583  		ASSERT_EQ (2, node1->ledger.cache.pruned_count);
584  		ASSERT_EQ (5, node1->ledger.cache.block_count);
585  	}
586  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
587  	ASSERT_TIMELY (10s, node0->balance (nano::dev::genesis_key.pub) == 100);
588  	ASSERT_EQ (100, node0->balance (nano::dev::genesis_key.pub));
589  	node1->stop ();
590  }
591  TEST (bootstrap_processor, push_one)
592  {
593  	nano::test::system system;
594  	nano::node_config config = system.default_config ();
595  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
596  	auto node0 (system.add_node (config));
597  	nano::keypair key1;
598  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
599  	auto wallet (node1->wallets.create (nano::random_wallet_id ()));
600  	ASSERT_NE (nullptr, wallet);
601  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
602  	nano::uint128_t balance1 (node1->balance (nano::dev::genesis_key.pub));
603  	auto send (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, 100));
604  	ASSERT_NE (nullptr, send);
605  	ASSERT_NE (balance1, node1->balance (nano::dev::genesis_key.pub));
606  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
607  	ASSERT_TIMELY (10s, node0->balance (nano::dev::genesis_key.pub) != balance1);
608  	node1->stop ();
609  }
610  TEST (bootstrap_processor, lazy_hash)
611  {
612  	nano::test::system system;
613  	nano::node_config config = system.default_config ();
614  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
615  	nano::node_flags node_flags;
616  	node_flags.disable_bootstrap_bulk_push_client = true;
617  	auto node0 (system.add_node (config, node_flags));
618  	nano::keypair key1;
619  	nano::keypair key2;
620  	nano::state_block_builder builder;
621  	auto send1 = builder
622  				 .account (nano::dev::genesis_key.pub)
623  				 .previous (nano::dev::genesis->hash ())
624  				 .representative (nano::dev::genesis_key.pub)
625  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
626  				 .link (key1.pub)
627  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
628  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
629  				 .build_shared ();
630  	auto receive1 = builder
631  					.make_block ()
632  					.account (key1.pub)
633  					.previous (0)
634  					.representative (key1.pub)
635  					.balance (nano::Gxrb_ratio)
636  					.link (send1->hash ())
637  					.sign (key1.prv, key1.pub)
638  					.work (*node0->work_generate_blocking (key1.pub))
639  					.build_shared ();
640  	auto send2 = builder
641  				 .make_block ()
642  				 .account (key1.pub)
643  				 .previous (receive1->hash ())
644  				 .representative (key1.pub)
645  				 .balance (0)
646  				 .link (key2.pub)
647  				 .sign (key1.prv, key1.pub)
648  				 .work (*node0->work_generate_blocking (receive1->hash ()))
649  				 .build_shared ();
650  	auto receive2 = builder
651  					.make_block ()
652  					.account (key2.pub)
653  					.previous (0)
654  					.representative (key2.pub)
655  					.balance (nano::Gxrb_ratio)
656  					.link (send2->hash ())
657  					.sign (key2.prv, key2.pub)
658  					.work (*node0->work_generate_blocking (key2.pub))
659  					.build_shared ();
660  	node0->block_processor.add (send1);
661  	node0->block_processor.add (receive1);
662  	node0->block_processor.add (send2);
663  	node0->block_processor.add (receive2);
664  	node0->block_processor.flush ();
665  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
666  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
667  	node1->bootstrap_initiator.bootstrap_lazy (receive2->hash (), true);
668  	{
669  		auto lazy_attempt (node1->bootstrap_initiator.current_lazy_attempt ());
670  		ASSERT_NE (nullptr, lazy_attempt);
671  		ASSERT_EQ (receive2->hash ().to_string (), lazy_attempt->id);
672  	}
673  	ASSERT_TIMELY (10s, node1->balance (key2.pub) != 0);
674  	node1->stop ();
675  }
676  TEST (bootstrap_processor, lazy_hash_bootstrap_id)
677  {
678  	nano::test::system system;
679  	nano::node_config config = system.default_config ();
680  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
681  	nano::node_flags node_flags;
682  	node_flags.disable_bootstrap_bulk_push_client = true;
683  	auto node0 (system.add_node (config, node_flags));
684  	nano::keypair key1;
685  	nano::keypair key2;
686  	nano::state_block_builder builder;
687  	auto send1 = builder
688  				 .account (nano::dev::genesis_key.pub)
689  				 .previous (nano::dev::genesis->hash ())
690  				 .representative (nano::dev::genesis_key.pub)
691  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
692  				 .link (key1.pub)
693  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
694  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
695  				 .build_shared ();
696  	auto receive1 = builder
697  					.make_block ()
698  					.account (key1.pub)
699  					.previous (0)
700  					.representative (key1.pub)
701  					.balance (nano::Gxrb_ratio)
702  					.link (send1->hash ())
703  					.sign (key1.prv, key1.pub)
704  					.work (*node0->work_generate_blocking (key1.pub))
705  					.build_shared ();
706  	auto send2 = builder
707  				 .make_block ()
708  				 .account (key1.pub)
709  				 .previous (receive1->hash ())
710  				 .representative (key1.pub)
711  				 .balance (0)
712  				 .link (key2.pub)
713  				 .sign (key1.prv, key1.pub)
714  				 .work (*node0->work_generate_blocking (receive1->hash ()))
715  				 .build_shared ();
716  	auto receive2 = builder
717  					.make_block ()
718  					.account (key2.pub)
719  					.previous (0)
720  					.representative (key2.pub)
721  					.balance (nano::Gxrb_ratio)
722  					.link (send2->hash ())
723  					.sign (key2.prv, key2.pub)
724  					.work (*node0->work_generate_blocking (key2.pub))
725  					.build_shared ();
726  	node0->block_processor.add (send1);
727  	node0->block_processor.add (receive1);
728  	node0->block_processor.add (send2);
729  	node0->block_processor.add (receive2);
730  	node0->block_processor.flush ();
731  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
732  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
733  	node1->bootstrap_initiator.bootstrap_lazy (receive2->hash (), true, "123456");
734  	{
735  		auto lazy_attempt (node1->bootstrap_initiator.current_lazy_attempt ());
736  		ASSERT_NE (nullptr, lazy_attempt);
737  		ASSERT_EQ ("123456", lazy_attempt->id);
738  	}
739  	ASSERT_TIMELY (10s, node1->balance (key2.pub) != 0);
740  	node1->stop ();
741  }
742  TEST (bootstrap_processor, lazy_hash_pruning)
743  {
744  	nano::test::system system;
745  	nano::node_config config = system.default_config ();
746  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
747  	config.enable_voting = false; 
748  	nano::node_flags node_flags;
749  	node_flags.disable_bootstrap_bulk_push_client = true;
750  	node_flags.enable_pruning = true;
751  	auto node0 (system.add_node (config, node_flags));
752  	nano::keypair key1;
753  	nano::keypair key2;
754  	nano::state_block_builder builder;
755  	auto send1 = builder
756  				 .account (nano::dev::genesis_key.pub)
757  				 .previous (nano::dev::genesis->hash ())
758  				 .representative (nano::dev::genesis_key.pub)
759  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
760  				 .link (nano::dev::genesis_key.pub)
761  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
762  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
763  				 .build_shared ();
764  	auto receive1 = builder
765  					.make_block ()
766  					.account (nano::dev::genesis_key.pub)
767  					.previous (send1->hash ())
768  					.representative (nano::dev::genesis_key.pub)
769  					.balance (nano::dev::constants.genesis_amount)
770  					.link (send1->hash ())
771  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
772  					.work (*node0->work_generate_blocking (send1->hash ()))
773  					.build_shared ();
774  	auto change1 = builder
775  				   .make_block ()
776  				   .account (nano::dev::genesis_key.pub)
777  				   .previous (receive1->hash ())
778  				   .representative (key1.pub)
779  				   .balance (nano::dev::constants.genesis_amount)
780  				   .link (0)
781  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
782  				   .work (*node0->work_generate_blocking (receive1->hash ()))
783  				   .build_shared ();
784  	auto change2 = builder
785  				   .make_block ()
786  				   .account (nano::dev::genesis_key.pub)
787  				   .previous (change1->hash ())
788  				   .representative (key2.pub)
789  				   .balance (nano::dev::constants.genesis_amount)
790  				   .link (0)
791  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
792  				   .work (*node0->work_generate_blocking (change1->hash ()))
793  				   .build_shared ();
794  	auto send2 = builder
795  				 .make_block ()
796  				 .account (nano::dev::genesis_key.pub)
797  				 .previous (change2->hash ())
798  				 .representative (nano::dev::genesis_key.pub)
799  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
800  				 .link (key1.pub)
801  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
802  				 .work (*node0->work_generate_blocking (change2->hash ()))
803  				 .build_shared ();
804  	auto receive2 = builder
805  					.make_block ()
806  					.account (key1.pub)
807  					.previous (0)
808  					.representative (key1.pub)
809  					.balance (nano::Gxrb_ratio)
810  					.link (send2->hash ())
811  					.sign (key1.prv, key1.pub)
812  					.work (*node0->work_generate_blocking (key1.pub))
813  					.build_shared ();
814  	auto send3 = builder
815  				 .make_block ()
816  				 .account (key1.pub)
817  				 .previous (receive2->hash ())
818  				 .representative (key1.pub)
819  				 .balance (0)
820  				 .link (key2.pub)
821  				 .sign (key1.prv, key1.pub)
822  				 .work (*node0->work_generate_blocking (receive2->hash ()))
823  				 .build_shared ();
824  	auto receive3 = builder
825  					.make_block ()
826  					.account (key2.pub)
827  					.previous (0)
828  					.representative (key2.pub)
829  					.balance (nano::Gxrb_ratio)
830  					.link (send3->hash ())
831  					.sign (key2.prv, key2.pub)
832  					.work (*node0->work_generate_blocking (key2.pub))
833  					.build_shared ();
834  	node0->block_processor.add (send1);
835  	node0->block_processor.add (receive1);
836  	node0->block_processor.add (change1);
837  	node0->block_processor.add (change2);
838  	node0->block_processor.add (send2);
839  	node0->block_processor.add (receive2);
840  	node0->block_processor.add (send3);
841  	node0->block_processor.add (receive3);
842  	ASSERT_TIMELY_EQ (5s, 9, node0->ledger.cache.block_count);
843  	config.peering_port = system.get_available_port ();
844  	auto node1 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), config, system.work, node_flags, 1));
845  	node1->start ();
846  	node1->process_active (send1);
847  	node1->process_active (receive1);
848  	node1->process_active (change1);
849  	node1->process_active (change2);
850  	ASSERT_TIMELY (5s, node1->block (change2->hash ()) != nullptr);
851  	nano::test::start_elections (system, *node1, { send1, receive1, change1, change2 }, true);
852  	ASSERT_TIMELY (5s, node1->block_confirmed (send1->hash ()) && node1->block_confirmed (receive1->hash ()) && node1->block_confirmed (change1->hash ()) && node1->block_confirmed (change2->hash ()) && node1->active.empty ());
853  	ASSERT_EQ (5, node1->ledger.cache.block_count);
854  	ASSERT_EQ (5, node1->ledger.cache.cemented_count);
855  	node1->ledger_pruning (2, false, false);
856  	ASSERT_EQ (9, node0->ledger.cache.block_count);
857  	ASSERT_EQ (0, node0->ledger.cache.pruned_count);
858  	ASSERT_EQ (5, node1->ledger.cache.block_count);
859  	ASSERT_EQ (3, node1->ledger.cache.pruned_count);
860  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
861  	node1->bootstrap_initiator.bootstrap_lazy (receive3->hash (), true);
862  	ASSERT_TIMELY (5s, node1->ledger.cache.block_count == 9);
863  	ASSERT_TIMELY (5s, node1->balance (key2.pub) != 0);
864  	ASSERT_TIMELY (5s, !node1->bootstrap_initiator.in_progress ());
865  	node1->stop ();
866  }
867  TEST (bootstrap_processor, lazy_max_pull_count)
868  {
869  	nano::test::system system;
870  	nano::node_config config = system.default_config ();
871  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
872  	nano::node_flags node_flags;
873  	node_flags.disable_bootstrap_bulk_push_client = true;
874  	auto node0 (system.add_node (config, node_flags));
875  	nano::keypair key1;
876  	nano::keypair key2;
877  	nano::state_block_builder builder;
878  	auto send1 = builder
879  				 .account (nano::dev::genesis_key.pub)
880  				 .previous (nano::dev::genesis->hash ())
881  				 .representative (nano::dev::genesis_key.pub)
882  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
883  				 .link (key1.pub)
884  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
885  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
886  				 .build_shared ();
887  	auto receive1 = builder
888  					.make_block ()
889  					.account (key1.pub)
890  					.previous (0)
891  					.representative (key1.pub)
892  					.balance (nano::Gxrb_ratio)
893  					.link (send1->hash ())
894  					.sign (key1.prv, key1.pub)
895  					.work (*node0->work_generate_blocking (key1.pub))
896  					.build_shared ();
897  	auto send2 = builder
898  				 .make_block ()
899  				 .account (key1.pub)
900  				 .previous (receive1->hash ())
901  				 .representative (key1.pub)
902  				 .balance (0)
903  				 .link (key2.pub)
904  				 .sign (key1.prv, key1.pub)
905  				 .work (*node0->work_generate_blocking (receive1->hash ()))
906  				 .build_shared ();
907  	auto receive2 = builder
908  					.make_block ()
909  					.account (key2.pub)
910  					.previous (0)
911  					.representative (key2.pub)
912  					.balance (nano::Gxrb_ratio)
913  					.link (send2->hash ())
914  					.sign (key2.prv, key2.pub)
915  					.work (*node0->work_generate_blocking (key2.pub))
916  					.build_shared ();
917  	auto change1 = builder
918  				   .make_block ()
919  				   .account (key2.pub)
920  				   .previous (receive2->hash ())
921  				   .representative (key1.pub)
922  				   .balance (nano::Gxrb_ratio)
923  				   .link (0)
924  				   .sign (key2.prv, key2.pub)
925  				   .work (*node0->work_generate_blocking (receive2->hash ()))
926  				   .build_shared ();
927  	auto change2 = builder
928  				   .make_block ()
929  				   .account (key2.pub)
930  				   .previous (change1->hash ())
931  				   .representative (nano::dev::genesis_key.pub)
932  				   .balance (nano::Gxrb_ratio)
933  				   .link (0)
934  				   .sign (key2.prv, key2.pub)
935  				   .work (*node0->work_generate_blocking (change1->hash ()))
936  				   .build_shared ();
937  	auto change3 = builder
938  				   .make_block ()
939  				   .account (key2.pub)
940  				   .previous (change2->hash ())
941  				   .representative (key2.pub)
942  				   .balance (nano::Gxrb_ratio)
943  				   .link (0)
944  				   .sign (key2.prv, key2.pub)
945  				   .work (*node0->work_generate_blocking (change2->hash ()))
946  				   .build_shared ();
947  	node0->block_processor.add (send1);
948  	node0->block_processor.add (receive1);
949  	node0->block_processor.add (send2);
950  	node0->block_processor.add (receive2);
951  	node0->block_processor.add (change1);
952  	node0->block_processor.add (change2);
953  	node0->block_processor.add (change3);
954  	node0->block_processor.flush ();
955  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
956  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
957  	node1->bootstrap_initiator.bootstrap_lazy (change3->hash ());
958  	ASSERT_TIMELY (10s, node1->block (change3->hash ()));
959  	node1->stop ();
960  }
961  TEST (bootstrap_processor, DISABLED_lazy_unclear_state_link)
962  {
963  	nano::test::system system;
964  	nano::node_config config = system.default_config ();
965  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
966  	nano::node_flags node_flags;
967  	node_flags.disable_bootstrap_bulk_push_client = true;
968  	node_flags.disable_legacy_bootstrap = true;
969  	auto node1 = system.add_node (config, node_flags);
970  	nano::keypair key;
971  	nano::block_builder builder;
972  	auto send1 = builder
973  				 .state ()
974  				 .account (nano::dev::genesis_key.pub)
975  				 .previous (nano::dev::genesis->hash ())
976  				 .representative (nano::dev::genesis_key.pub)
977  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
978  				 .link (key.pub)
979  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
980  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
981  				 .build_shared ();
982  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
983  	auto send2 = builder
984  				 .state ()
985  				 .account (nano::dev::genesis_key.pub)
986  				 .previous (send1->hash ())
987  				 .representative (nano::dev::genesis_key.pub)
988  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
989  				 .link (key.pub)
990  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
991  				 .work (*system.work.generate (send1->hash ()))
992  				 .build_shared ();
993  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
994  	auto open = builder
995  				.open ()
996  				.source (send1->hash ())
997  				.representative (key.pub)
998  				.account (key.pub)
999  				.sign (key.prv, key.pub)
1000  				.work (*system.work.generate (key.pub))
1001  				.build_shared ();
1002  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
1003  	auto receive = builder
1004  				   .state ()
1005  				   .account (key.pub)
1006  				   .previous (open->hash ())
1007  				   .representative (key.pub)
1008  				   .balance (2 * nano::Gxrb_ratio)
1009  				   .link (send2->hash ())
1010  				   .sign (key.prv, key.pub)
1011  				   .work (*system.work.generate (open->hash ()))
1012  				   .build_shared ();
1013  	ASSERT_EQ (nano::process_result::progress, node1->process (*receive).code);
1014  	auto node2 = system.add_node (system.default_config (), node_flags);
1015  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
1016  	node2->bootstrap_initiator.bootstrap_lazy (receive->hash ());
1017  	ASSERT_TIMELY (10s, !node2->bootstrap_initiator.in_progress ());
1018  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (send1->hash ()));
1019  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (send2->hash ()));
1020  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (open->hash ()));
1021  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (receive->hash ()));
1022  	ASSERT_EQ (0, node2->stats.count (nano::stat::type::bootstrap, nano::stat::detail::bulk_pull_failed_account, nano::stat::dir::in));
1023  }
1024  TEST (bootstrap_processor, lazy_unclear_state_link_not_existing)
1025  {
1026  	nano::test::system system;
1027  	nano::node_config config = system.default_config ();
1028  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1029  	nano::node_flags node_flags;
1030  	node_flags.disable_bootstrap_bulk_push_client = true;
1031  	node_flags.disable_legacy_bootstrap = true;
1032  	auto node1 = system.add_node (config, node_flags);
1033  	nano::keypair key, key2;
1034  	nano::block_builder builder;
1035  	auto send1 = builder
1036  				 .state ()
1037  				 .account (nano::dev::genesis_key.pub)
1038  				 .previous (nano::dev::genesis->hash ())
1039  				 .representative (nano::dev::genesis_key.pub)
1040  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1041  				 .link (key.pub)
1042  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1043  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
1044  				 .build_shared ();
1045  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
1046  	auto open = builder
1047  				.open ()
1048  				.source (send1->hash ())
1049  				.representative (key.pub)
1050  				.account (key.pub)
1051  				.sign (key.prv, key.pub)
1052  				.work (*system.work.generate (key.pub))
1053  				.build_shared ();
1054  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
1055  	auto send2 = builder
1056  				 .state ()
1057  				 .account (key.pub)
1058  				 .previous (open->hash ())
1059  				 .representative (key.pub)
1060  				 .balance (0)
1061  				 .link (key2.pub)
1062  				 .sign (key.prv, key.pub)
1063  				 .work (*system.work.generate (open->hash ()))
1064  				 .build_shared ();
1065  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
1066  	auto node2 = system.add_node (system.default_config (), node_flags);
1067  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
1068  	node2->bootstrap_initiator.bootstrap_lazy (send2->hash ());
1069  	ASSERT_TIMELY (15s, !node2->bootstrap_initiator.in_progress ());
1070  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (send1->hash ()));
1071  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (open->hash ()));
1072  	ASSERT_TIMELY (5s, node2->ledger.block_or_pruned_exists (send2->hash ()));
1073  	ASSERT_EQ (1, node2->stats.count (nano::stat::type::bootstrap, nano::stat::detail::bulk_pull_failed_account, nano::stat::dir::in));
1074  }
1075  TEST (bootstrap_processor, DISABLED_lazy_destinations)
1076  {
1077  	nano::test::system system;
1078  	nano::node_config config = system.default_config ();
1079  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1080  	nano::node_flags node_flags;
1081  	node_flags.disable_bootstrap_bulk_push_client = true;
1082  	node_flags.disable_legacy_bootstrap = true;
1083  	auto node1 = system.add_node (config, node_flags);
1084  	nano::keypair key1, key2;
1085  	nano::block_builder builder;
1086  	auto send1 = builder
1087  				 .state ()
1088  				 .account (nano::dev::genesis_key.pub)
1089  				 .previous (nano::dev::genesis->hash ())
1090  				 .representative (nano::dev::genesis_key.pub)
1091  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1092  				 .link (key1.pub)
1093  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1094  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
1095  				 .build_shared ();
1096  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
1097  	auto send2 = builder
1098  				 .state ()
1099  				 .account (nano::dev::genesis_key.pub)
1100  				 .previous (send1->hash ())
1101  				 .representative (nano::dev::genesis_key.pub)
1102  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
1103  				 .link (key2.pub)
1104  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1105  				 .work (*system.work.generate (send1->hash ()))
1106  				 .build_shared ();
1107  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
1108  	auto open = builder
1109  				.open ()
1110  				.source (send1->hash ())
1111  				.representative (key1.pub)
1112  				.account (key1.pub)
1113  				.sign (key1.prv, key1.pub)
1114  				.work (*system.work.generate (key1.pub))
1115  				.build_shared ();
1116  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
1117  	auto state_open = builder
1118  					  .state ()
1119  					  .account (key2.pub)
1120  					  .previous (0)
1121  					  .representative (key2.pub)
1122  					  .balance (nano::Gxrb_ratio)
1123  					  .link (send2->hash ())
1124  					  .sign (key2.prv, key2.pub)
1125  					  .work (*system.work.generate (key2.pub))
1126  					  .build_shared ();
1127  	ASSERT_EQ (nano::process_result::progress, node1->process (*state_open).code);
1128  	auto node2 = system.add_node (system.default_config (), node_flags);
1129  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
1130  	node2->bootstrap_initiator.bootstrap_lazy (send2->hash ());
1131  	ASSERT_TIMELY (10s, !node2->bootstrap_initiator.in_progress ());
1132  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ()));
1133  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send2->hash ()));
1134  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (open->hash ()));
1135  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (state_open->hash ()));
1136  }
1137  TEST (bootstrap_processor, lazy_pruning_missing_block)
1138  {
1139  	nano::test::system system;
1140  	nano::node_config config = system.default_config ();
1141  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1142  	config.enable_voting = false; 
1143  	nano::node_flags node_flags;
1144  	node_flags.disable_bootstrap_bulk_push_client = true;
1145  	node_flags.disable_legacy_bootstrap = true;
1146  	node_flags.enable_pruning = true;
1147  	auto node1 = system.add_node (config, node_flags);
1148  	nano::keypair key1, key2;
1149  	nano::block_builder builder;
1150  	auto send1 = builder
1151  				 .state ()
1152  				 .account (nano::dev::genesis_key.pub)
1153  				 .previous (nano::dev::genesis->hash ())
1154  				 .representative (nano::dev::genesis_key.pub)
1155  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1156  				 .link (key1.pub)
1157  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1158  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
1159  				 .build_shared ();
1160  	node1->process_active (send1);
1161  	auto send2 = builder
1162  				 .state ()
1163  				 .account (nano::dev::genesis_key.pub)
1164  				 .previous (send1->hash ())
1165  				 .representative (nano::dev::genesis_key.pub)
1166  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
1167  				 .link (key2.pub)
1168  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1169  				 .work (*system.work.generate (send1->hash ()))
1170  				 .build_shared ();
1171  	node1->process_active (send2);
1172  	auto open = builder
1173  				.open ()
1174  				.source (send1->hash ())
1175  				.representative (key1.pub)
1176  				.account (key1.pub)
1177  				.sign (key1.prv, key1.pub)
1178  				.work (*system.work.generate (key1.pub))
1179  				.build_shared ();
1180  	node1->process_active (open);
1181  	auto state_open = builder
1182  					  .state ()
1183  					  .account (key2.pub)
1184  					  .previous (0)
1185  					  .representative (key2.pub)
1186  					  .balance (nano::Gxrb_ratio)
1187  					  .link (send2->hash ())
1188  					  .sign (key2.prv, key2.pub)
1189  					  .work (*system.work.generate (key2.pub))
1190  					  .build_shared ();
1191  	node1->process_active (state_open);
1192  	ASSERT_TIMELY (5s, node1->block (state_open->hash ()) != nullptr);
1193  	nano::test::start_elections (system, *node1, { send1, send2, open, state_open }, true);
1194  	ASSERT_TIMELY (5s, node1->block_confirmed (send2->hash ()) && node1->block_confirmed (open->hash ()) && node1->block_confirmed (state_open->hash ()));
1195  	ASSERT_EQ (5, node1->ledger.cache.block_count);
1196  	ASSERT_EQ (5, node1->ledger.cache.cemented_count);
1197  	node1->ledger_pruning (2, false, false);
1198  	ASSERT_EQ (5, node1->ledger.cache.block_count);
1199  	ASSERT_EQ (1, node1->ledger.cache.pruned_count);
1200  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send1->hash ())); 
1201  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send2->hash ()));
1202  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (open->hash ()));
1203  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (state_open->hash ()));
1204  	config.peering_port = system.get_available_port ();
1205  	auto node2 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), config, system.work, node_flags, 1));
1206  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
1207  	node2->bootstrap_initiator.bootstrap_lazy (send2->hash ());
1208  	auto lazy_attempt (node2->bootstrap_initiator.current_lazy_attempt ());
1209  	ASSERT_NE (nullptr, lazy_attempt);
1210  	ASSERT_TIMELY (5s, lazy_attempt == nullptr || lazy_attempt->stopped || lazy_attempt->requeued_pulls >= 4);
1211  	node2->block_processor.flush ();
1212  	ASSERT_EQ (1, node2->ledger.cache.block_count);
1213  	ASSERT_FALSE (node2->ledger.block_or_pruned_exists (send1->hash ()));
1214  	ASSERT_FALSE (node2->ledger.block_or_pruned_exists (send2->hash ()));
1215  	ASSERT_FALSE (node2->ledger.block_or_pruned_exists (open->hash ()));
1216  	ASSERT_FALSE (node2->ledger.block_or_pruned_exists (state_open->hash ()));
1217  	{
1218  		auto transaction (node2->store.tx_begin_read ());
1219  		ASSERT_TRUE (node2->unchecked.exists (nano::unchecked_key (send2->root ().as_block_hash (), send2->hash ())));
1220  	}
1221  	node2->process_active (send1);
1222  	node2->block_processor.flush ();
1223  	ASSERT_TIMELY (5s, !node2->bootstrap_initiator.in_progress ());
1224  	node2->block_processor.flush ();
1225  	ASSERT_EQ (3, node2->ledger.cache.block_count);
1226  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ()));
1227  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send2->hash ()));
1228  	ASSERT_FALSE (node2->ledger.block_or_pruned_exists (open->hash ()));
1229  	ASSERT_FALSE (node2->ledger.block_or_pruned_exists (state_open->hash ()));
1230  	node2->stop ();
1231  }
1232  TEST (bootstrap_processor, lazy_cancel)
1233  {
1234  	nano::test::system system;
1235  	nano::node_config config = system.default_config ();
1236  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1237  	nano::node_flags node_flags;
1238  	node_flags.disable_bootstrap_bulk_push_client = true;
1239  	auto node0 (system.add_node (config, node_flags));
1240  	nano::keypair key1;
1241  	nano::state_block_builder builder;
1242  	auto send1 = builder
1243  				 .account (nano::dev::genesis_key.pub)
1244  				 .previous (nano::dev::genesis->hash ())
1245  				 .representative (nano::dev::genesis_key.pub)
1246  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1247  				 .link (key1.pub)
1248  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1249  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1250  				 .build_shared ();
1251  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
1252  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
1253  	node1->bootstrap_initiator.bootstrap_lazy (send1->hash (), true); 
1254  	{
1255  		auto lazy_attempt (node1->bootstrap_initiator.current_lazy_attempt ());
1256  		ASSERT_NE (nullptr, lazy_attempt);
1257  		ASSERT_EQ (send1->hash ().to_string (), lazy_attempt->id);
1258  	}
1259  	ASSERT_TIMELY (10s, !node1->bootstrap_initiator.in_progress ());
1260  	node1->stop ();
1261  }
1262  TEST (bootstrap_processor, wallet_lazy_frontier)
1263  {
1264  	nano::test::system system;
1265  	nano::node_config config = system.default_config ();
1266  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1267  	nano::node_flags node_flags;
1268  	node_flags.disable_bootstrap_bulk_push_client = true;
1269  	node_flags.disable_legacy_bootstrap = true;
1270  	auto node0 = system.add_node (config, node_flags);
1271  	nano::keypair key1;
1272  	nano::keypair key2;
1273  	nano::state_block_builder builder;
1274  	auto send1 = builder
1275  				 .account (nano::dev::genesis_key.pub)
1276  				 .previous (nano::dev::genesis->hash ())
1277  				 .representative (nano::dev::genesis_key.pub)
1278  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1279  				 .link (key1.pub)
1280  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1281  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1282  				 .build_shared ();
1283  	auto receive1 = builder
1284  					.make_block ()
1285  					.account (key1.pub)
1286  					.previous (0)
1287  					.representative (key1.pub)
1288  					.balance (nano::Gxrb_ratio)
1289  					.link (send1->hash ())
1290  					.sign (key1.prv, key1.pub)
1291  					.work (*node0->work_generate_blocking (key1.pub))
1292  					.build_shared ();
1293  	auto send2 = builder
1294  				 .make_block ()
1295  				 .account (key1.pub)
1296  				 .previous (receive1->hash ())
1297  				 .representative (key1.pub)
1298  				 .balance (0)
1299  				 .link (key2.pub)
1300  				 .sign (key1.prv, key1.pub)
1301  				 .work (*node0->work_generate_blocking (receive1->hash ()))
1302  				 .build_shared ();
1303  	auto receive2 = builder
1304  					.make_block ()
1305  					.account (key2.pub)
1306  					.previous (0)
1307  					.representative (key2.pub)
1308  					.balance (nano::Gxrb_ratio)
1309  					.link (send2->hash ())
1310  					.sign (key2.prv, key2.pub)
1311  					.work (*node0->work_generate_blocking (key2.pub))
1312  					.build_shared ();
1313  	node0->block_processor.add (send1);
1314  	node0->block_processor.add (receive1);
1315  	node0->block_processor.add (send2);
1316  	node0->block_processor.add (receive2);
1317  	node0->block_processor.flush ();
1318  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
1319  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
1320  	auto wallet (node1->wallets.create (nano::random_wallet_id ()));
1321  	ASSERT_NE (nullptr, wallet);
1322  	wallet->insert_adhoc (key2.prv);
1323  	node1->bootstrap_wallet ();
1324  	{
1325  		auto wallet_attempt (node1->bootstrap_initiator.current_wallet_attempt ());
1326  		ASSERT_NE (nullptr, wallet_attempt);
1327  		ASSERT_EQ (key2.pub.to_account (), wallet_attempt->id);
1328  	}
1329  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (receive2->hash ()));
1330  	node1->stop ();
1331  }
1332  TEST (bootstrap_processor, wallet_lazy_pending)
1333  {
1334  	nano::test::system system;
1335  	nano::node_config config = system.default_config ();
1336  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1337  	nano::node_flags node_flags;
1338  	node_flags.disable_bootstrap_bulk_push_client = true;
1339  	node_flags.disable_legacy_bootstrap = true;
1340  	auto node0 = system.add_node (config, node_flags);
1341  	nano::keypair key1;
1342  	nano::keypair key2;
1343  	nano::state_block_builder builder;
1344  	auto send1 = builder
1345  				 .account (nano::dev::genesis_key.pub)
1346  				 .previous (nano::dev::genesis->hash ())
1347  				 .representative (nano::dev::genesis_key.pub)
1348  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1349  				 .link (key1.pub)
1350  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1351  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1352  				 .build_shared ();
1353  	auto receive1 = builder
1354  					.make_block ()
1355  					.account (key1.pub)
1356  					.previous (0)
1357  					.representative (key1.pub)
1358  					.balance (nano::Gxrb_ratio)
1359  					.link (send1->hash ())
1360  					.sign (key1.prv, key1.pub)
1361  					.work (*node0->work_generate_blocking (key1.pub))
1362  					.build_shared ();
1363  	auto send2 = builder
1364  				 .make_block ()
1365  				 .account (key1.pub)
1366  				 .previous (receive1->hash ())
1367  				 .representative (key1.pub)
1368  				 .balance (0)
1369  				 .link (key2.pub)
1370  				 .sign (key1.prv, key1.pub)
1371  				 .work (*node0->work_generate_blocking (receive1->hash ()))
1372  				 .build_shared ();
1373  	node0->block_processor.add (send1);
1374  	node0->block_processor.add (receive1);
1375  	node0->block_processor.add (send2);
1376  	node0->block_processor.flush ();
1377  	auto node1 = system.add_node ();
1378  	nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
1379  	auto wallet (node1->wallets.create (nano::random_wallet_id ()));
1380  	ASSERT_NE (nullptr, wallet);
1381  	wallet->insert_adhoc (key2.prv);
1382  	node1->bootstrap_wallet ();
1383  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send2->hash ()));
1384  }
1385  TEST (bootstrap_processor, multiple_attempts)
1386  {
1387  	nano::test::system system;
1388  	nano::node_config config = system.default_config ();
1389  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1390  	nano::node_flags node_flags;
1391  	node_flags.disable_bootstrap_bulk_push_client = true;
1392  	auto node1 = system.add_node (config, node_flags);
1393  	nano::keypair key1;
1394  	nano::keypair key2;
1395  	nano::state_block_builder builder;
1396  	auto send1 = builder
1397  				 .account (nano::dev::genesis_key.pub)
1398  				 .previous (nano::dev::genesis->hash ())
1399  				 .representative (nano::dev::genesis_key.pub)
1400  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1401  				 .link (key1.pub)
1402  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1403  				 .work (*node1->work_generate_blocking (nano::dev::genesis->hash ()))
1404  				 .build_shared ();
1405  	auto receive1 = builder
1406  					.make_block ()
1407  					.account (key1.pub)
1408  					.previous (0)
1409  					.representative (key1.pub)
1410  					.balance (nano::Gxrb_ratio)
1411  					.link (send1->hash ())
1412  					.sign (key1.prv, key1.pub)
1413  					.work (*node1->work_generate_blocking (key1.pub))
1414  					.build_shared ();
1415  	auto send2 = builder
1416  				 .make_block ()
1417  				 .account (key1.pub)
1418  				 .previous (receive1->hash ())
1419  				 .representative (key1.pub)
1420  				 .balance (0)
1421  				 .link (key2.pub)
1422  				 .sign (key1.prv, key1.pub)
1423  				 .work (*node1->work_generate_blocking (receive1->hash ()))
1424  				 .build_shared ();
1425  	auto receive2 = builder
1426  					.make_block ()
1427  					.account (key2.pub)
1428  					.previous (0)
1429  					.representative (key2.pub)
1430  					.balance (nano::Gxrb_ratio)
1431  					.link (send2->hash ())
1432  					.sign (key2.prv, key2.pub)
1433  					.work (*node1->work_generate_blocking (key2.pub))
1434  					.build_shared ();
1435  	node1->block_processor.add (send1);
1436  	node1->block_processor.add (receive1);
1437  	node1->block_processor.add (send2);
1438  	node1->block_processor.add (receive2);
1439  	node1->block_processor.flush ();
1440  	nano::node_config node_config = system.default_config ();
1441  	node_config.bootstrap_initiator_threads = 3;
1442  	auto node2 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), node_config, system.work));
1443  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
1444  	node2->bootstrap_initiator.bootstrap_lazy (receive2->hash (), true);
1445  	node2->bootstrap_initiator.bootstrap ();
1446  	auto lazy_attempt (node2->bootstrap_initiator.current_lazy_attempt ());
1447  	auto legacy_attempt (node2->bootstrap_initiator.current_attempt ());
1448  	ASSERT_TIMELY (5s, lazy_attempt->started && legacy_attempt->started);
1449  	ASSERT_FALSE (lazy_attempt->stopped);
1450  	ASSERT_FALSE (legacy_attempt->stopped);
1451  	ASSERT_GE (node2->bootstrap_initiator.attempts.size (), 2);
1452  	ASSERT_TIMELY (10s, node2->balance (key2.pub) != 0);
1453  	ASSERT_TIMELY (5s, node2->bootstrap_initiator.attempts.size () == 0);
1454  	node2->stop ();
1455  }
1456  TEST (frontier_req_response, DISABLED_destruction)
1457  {
1458  	{
1459  		std::shared_ptr<nano::frontier_req_server> hold; 
1460  		{
1461  			nano::test::system system (1);
1462  			auto connection (std::make_shared<nano::transport::tcp_server> (nullptr, system.nodes[0]));
1463  			auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1464  			req->start.clear ();
1465  			req->age = std::numeric_limits<decltype (req->age)>::max ();
1466  			req->count = std::numeric_limits<decltype (req->count)>::max ();
1467  			hold = std::make_shared<nano::frontier_req_server> (connection, std::move (req));
1468  		}
1469  	}
1470  	ASSERT_TRUE (true);
1471  }
1472  TEST (frontier_req, begin)
1473  {
1474  	nano::test::system system (1);
1475  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1476  	auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1477  	req->start.clear ();
1478  	req->age = std::numeric_limits<decltype (req->age)>::max ();
1479  	req->count = std::numeric_limits<decltype (req->count)>::max ();
1480  	auto request (std::make_shared<nano::frontier_req_server> (connection, std::move (req)));
1481  	ASSERT_EQ (nano::dev::genesis_key.pub, request->current);
1482  	ASSERT_EQ (nano::dev::genesis->hash (), request->frontier);
1483  }
1484  TEST (frontier_req, end)
1485  {
1486  	nano::test::system system (1);
1487  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1488  	auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1489  	req->start = nano::dev::genesis_key.pub.number () + 1;
1490  	req->age = std::numeric_limits<decltype (req->age)>::max ();
1491  	req->count = std::numeric_limits<decltype (req->count)>::max ();
1492  	auto request (std::make_shared<nano::frontier_req_server> (connection, std::move (req)));
1493  	ASSERT_TRUE (request->current.is_zero ());
1494  }
1495  TEST (frontier_req, count)
1496  {
1497  	nano::test::system system (1);
1498  	auto node1 = system.nodes[0];
1499  	nano::keypair key1 ("ED5AE0A6505B14B67435C29FD9FEEBC26F597D147BC92F6D795FFAD7AFD3D967");
1500  	nano::state_block_builder builder;
1501  	auto send1 = builder
1502  				 .account (nano::dev::genesis_key.pub)
1503  				 .previous (nano::dev::genesis->hash ())
1504  				 .representative (nano::dev::genesis_key.pub)
1505  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1506  				 .link (key1.pub)
1507  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1508  				 .work (0)
1509  				 .build_shared ();
1510  	node1->work_generate_blocking (*send1);
1511  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
1512  	auto receive1 = builder
1513  					.make_block ()
1514  					.account (key1.pub)
1515  					.previous (0)
1516  					.representative (nano::dev::genesis_key.pub)
1517  					.balance (nano::Gxrb_ratio)
1518  					.link (send1->hash ())
1519  					.sign (key1.prv, key1.pub)
1520  					.work (0)
1521  					.build_shared ();
1522  	node1->work_generate_blocking (*receive1);
1523  	ASSERT_EQ (nano::process_result::progress, node1->process (*receive1).code);
1524  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1525  	auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1526  	req->start.clear ();
1527  	req->age = std::numeric_limits<decltype (req->age)>::max ();
1528  	req->count = 1;
1529  	auto request (std::make_shared<nano::frontier_req_server> (connection, std::move (req)));
1530  	ASSERT_EQ (nano::dev::genesis_key.pub, request->current);
1531  	ASSERT_EQ (send1->hash (), request->frontier);
1532  }
1533  TEST (frontier_req, time_bound)
1534  {
1535  	nano::test::system system (1);
1536  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1537  	auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1538  	req->start.clear ();
1539  	req->age = 1;
1540  	req->count = std::numeric_limits<decltype (req->count)>::max ();
1541  	auto request (std::make_shared<nano::frontier_req_server> (connection, std::move (req)));
1542  	ASSERT_EQ (nano::dev::genesis_key.pub, request->current);
1543  	std::this_thread::sleep_for (std::chrono::milliseconds (2100));
1544  	auto req2 (std::make_unique<nano::frontier_req> (nano::dev::network_params.network));
1545  	req2->start.clear ();
1546  	req2->age = 1;
1547  	req2->count = std::numeric_limits<decltype (req2->count)>::max ();
1548  	auto connection2 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1549  	auto request2 (std::make_shared<nano::frontier_req_server> (connection, std::move (req2)));
1550  	ASSERT_TRUE (request2->current.is_zero ());
1551  }
1552  TEST (frontier_req, time_cutoff)
1553  {
1554  	nano::test::system system (1);
1555  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1556  	auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1557  	req->start.clear ();
1558  	req->age = 3;
1559  	req->count = std::numeric_limits<decltype (req->count)>::max ();
1560  	auto request (std::make_shared<nano::frontier_req_server> (connection, std::move (req)));
1561  	ASSERT_EQ (nano::dev::genesis_key.pub, request->current);
1562  	ASSERT_EQ (nano::dev::genesis->hash (), request->frontier);
1563  	std::this_thread::sleep_for (std::chrono::milliseconds (4100));
1564  	auto req2 (std::make_unique<nano::frontier_req> (nano::dev::network_params.network));
1565  	req2->start.clear ();
1566  	req2->age = 3;
1567  	req2->count = std::numeric_limits<decltype (req2->count)>::max ();
1568  	auto connection2 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1569  	auto request2 (std::make_shared<nano::frontier_req_server> (connection, std::move (req2)));
1570  	ASSERT_TRUE (request2->frontier.is_zero ());
1571  }
1572  TEST (frontier_req, confirmed_frontier)
1573  {
1574  	nano::test::system system (1);
1575  	auto node1 = system.nodes[0];
1576  	nano::keypair key_before_genesis;
1577  	while (key_before_genesis.pub.number () >= nano::dev::genesis_key.pub.number ())
1578  	{
1579  		key_before_genesis = nano::keypair ();
1580  	}
1581  	nano::keypair key_after_genesis;
1582  	while (key_after_genesis.pub.number () <= nano::dev::genesis_key.pub.number ())
1583  	{
1584  		key_after_genesis = nano::keypair ();
1585  	}
1586  	nano::state_block_builder builder;
1587  	auto send1 = builder
1588  				 .account (nano::dev::genesis_key.pub)
1589  				 .previous (nano::dev::genesis->hash ())
1590  				 .representative (nano::dev::genesis_key.pub)
1591  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1592  				 .link (key_before_genesis.pub)
1593  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1594  				 .work (0)
1595  				 .build_shared ();
1596  	node1->work_generate_blocking (*send1);
1597  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
1598  	auto send2 = builder
1599  				 .make_block ()
1600  				 .account (nano::dev::genesis_key.pub)
1601  				 .previous (send1->hash ())
1602  				 .representative (nano::dev::genesis_key.pub)
1603  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
1604  				 .link (key_after_genesis.pub)
1605  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1606  				 .work (0)
1607  				 .build_shared ();
1608  	node1->work_generate_blocking (*send2);
1609  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
1610  	auto receive1 = builder
1611  					.make_block ()
1612  					.account (key_before_genesis.pub)
1613  					.previous (0)
1614  					.representative (nano::dev::genesis_key.pub)
1615  					.balance (nano::Gxrb_ratio)
1616  					.link (send1->hash ())
1617  					.sign (key_before_genesis.prv, key_before_genesis.pub)
1618  					.work (0)
1619  					.build_shared ();
1620  	node1->work_generate_blocking (*receive1);
1621  	ASSERT_EQ (nano::process_result::progress, node1->process (*receive1).code);
1622  	auto receive2 = builder
1623  					.make_block ()
1624  					.account (key_after_genesis.pub)
1625  					.previous (0)
1626  					.representative (nano::dev::genesis_key.pub)
1627  					.balance (nano::Gxrb_ratio)
1628  					.link (send2->hash ())
1629  					.sign (key_after_genesis.prv, key_after_genesis.pub)
1630  					.work (0)
1631  					.build_shared ();
1632  	node1->work_generate_blocking (*receive2);
1633  	ASSERT_EQ (nano::process_result::progress, node1->process (*receive2).code);
1634  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1635  	auto req = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1636  	req->start.clear ();
1637  	req->age = std::numeric_limits<decltype (req->age)>::max ();
1638  	req->count = std::numeric_limits<decltype (req->count)>::max ();
1639  	ASSERT_FALSE (req->header.frontier_req_is_only_confirmed_present ());
1640  	req->header.flag_set (nano::message_header::frontier_req_only_confirmed);
1641  	ASSERT_TRUE (req->header.frontier_req_is_only_confirmed_present ());
1642  	auto request (std::make_shared<nano::frontier_req_server> (connection, std::move (req)));
1643  	ASSERT_EQ (nano::dev::genesis_key.pub, request->current);
1644  	ASSERT_EQ (nano::dev::genesis->hash (), request->frontier);
1645  	auto connection2 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1646  	auto req2 = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1647  	req2->start = key_before_genesis.pub;
1648  	req2->age = std::numeric_limits<decltype (req2->age)>::max ();
1649  	req2->count = std::numeric_limits<decltype (req2->count)>::max ();
1650  	ASSERT_FALSE (req2->header.frontier_req_is_only_confirmed_present ());
1651  	req2->header.flag_set (nano::message_header::frontier_req_only_confirmed);
1652  	ASSERT_TRUE (req2->header.frontier_req_is_only_confirmed_present ());
1653  	auto request2 (std::make_shared<nano::frontier_req_server> (connection2, std::move (req2)));
1654  	ASSERT_EQ (nano::dev::genesis_key.pub, request2->current);
1655  	ASSERT_EQ (nano::dev::genesis->hash (), request2->frontier);
1656  	auto connection3 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1657  	auto req3 = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1658  	req3->start = key_after_genesis.pub;
1659  	req3->age = std::numeric_limits<decltype (req3->age)>::max ();
1660  	req3->count = std::numeric_limits<decltype (req3->count)>::max ();
1661  	ASSERT_FALSE (req3->header.frontier_req_is_only_confirmed_present ());
1662  	req3->header.flag_set (nano::message_header::frontier_req_only_confirmed);
1663  	ASSERT_TRUE (req3->header.frontier_req_is_only_confirmed_present ());
1664  	auto request3 (std::make_shared<nano::frontier_req_server> (connection3, std::move (req3)));
1665  	ASSERT_TRUE (request3->current.is_zero ());
1666  	ASSERT_TRUE (request3->frontier.is_zero ());
1667  	auto connection4 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1668  	auto req4 = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1669  	req4->start.clear ();
1670  	req4->age = std::numeric_limits<decltype (req4->age)>::max ();
1671  	req4->count = std::numeric_limits<decltype (req4->count)>::max ();
1672  	ASSERT_FALSE (req4->header.frontier_req_is_only_confirmed_present ());
1673  	auto request4 (std::make_shared<nano::frontier_req_server> (connection4, std::move (req4)));
1674  	ASSERT_EQ (key_before_genesis.pub, request4->current);
1675  	ASSERT_EQ (receive1->hash (), request4->frontier);
1676  	auto connection5 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1677  	auto req5 = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1678  	req5->start = key_after_genesis.pub;
1679  	req5->age = std::numeric_limits<decltype (req5->age)>::max ();
1680  	req5->count = std::numeric_limits<decltype (req5->count)>::max ();
1681  	ASSERT_FALSE (req5->header.frontier_req_is_only_confirmed_present ());
1682  	auto request5 (std::make_shared<nano::frontier_req_server> (connection5, std::move (req5)));
1683  	ASSERT_EQ (key_after_genesis.pub, request5->current);
1684  	ASSERT_EQ (receive2->hash (), request5->frontier);
1685  	nano::test::start_elections (system, *node1, { send1, receive1 }, true);
1686  	ASSERT_TIMELY (5s, node1->block_confirmed (send1->hash ()) && node1->block_confirmed (receive1->hash ()));
1687  	auto connection6 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1688  	auto req6 = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1689  	req6->start = key_before_genesis.pub;
1690  	req6->age = std::numeric_limits<decltype (req6->age)>::max ();
1691  	req6->count = std::numeric_limits<decltype (req6->count)>::max ();
1692  	ASSERT_FALSE (req6->header.frontier_req_is_only_confirmed_present ());
1693  	req6->header.flag_set (nano::message_header::frontier_req_only_confirmed);
1694  	ASSERT_TRUE (req6->header.frontier_req_is_only_confirmed_present ());
1695  	auto request6 (std::make_shared<nano::frontier_req_server> (connection6, std::move (req6)));
1696  	ASSERT_EQ (key_before_genesis.pub, request6->current);
1697  	ASSERT_EQ (receive1->hash (), request6->frontier);
1698  	nano::test::start_elections (system, *node1, { send2, receive2 }, true);
1699  	ASSERT_TIMELY (5s, node1->block_confirmed (send2->hash ()) && node1->block_confirmed (receive2->hash ()));
1700  	auto connection7 (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*node1, nano::transport::socket::endpoint_type_t::server), node1));
1701  	auto req7 = std::make_unique<nano::frontier_req> (nano::dev::network_params.network);
1702  	req7->start = key_after_genesis.pub;
1703  	req7->age = std::numeric_limits<decltype (req7->age)>::max ();
1704  	req7->count = std::numeric_limits<decltype (req7->count)>::max ();
1705  	ASSERT_FALSE (req7->header.frontier_req_is_only_confirmed_present ());
1706  	req7->header.flag_set (nano::message_header::frontier_req_only_confirmed);
1707  	ASSERT_TRUE (req7->header.frontier_req_is_only_confirmed_present ());
1708  	auto request7 (std::make_shared<nano::frontier_req_server> (connection7, std::move (req7)));
1709  	ASSERT_EQ (key_after_genesis.pub, request7->current);
1710  	ASSERT_EQ (receive2->hash (), request7->frontier);
1711  }
1712  TEST (bulk, genesis)
1713  {
1714  	nano::test::system system;
1715  	nano::node_config config (system.get_available_port (), system.logging);
1716  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1717  	nano::node_flags node_flags;
1718  	node_flags.disable_bootstrap_bulk_push_client = true;
1719  	node_flags.disable_lazy_bootstrap = true;
1720  	auto node1 = system.add_node (config, node_flags);
1721  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1722  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
1723  	ASSERT_FALSE (node2->init_error ());
1724  	nano::block_hash latest1 (node1->latest (nano::dev::genesis_key.pub));
1725  	nano::block_hash latest2 (node2->latest (nano::dev::genesis_key.pub));
1726  	ASSERT_EQ (latest1, latest2);
1727  	nano::keypair key2;
1728  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 100));
1729  	ASSERT_NE (nullptr, send);
1730  	nano::block_hash latest3 (node1->latest (nano::dev::genesis_key.pub));
1731  	ASSERT_NE (latest1, latest3);
1732  	node2->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
1733  	ASSERT_TIMELY (10s, node2->latest (nano::dev::genesis_key.pub) == node1->latest (nano::dev::genesis_key.pub));
1734  	ASSERT_EQ (node2->latest (nano::dev::genesis_key.pub), node1->latest (nano::dev::genesis_key.pub));
1735  	node2->stop ();
1736  }
1737  TEST (bulk, offline_send)
1738  {
1739  	nano::test::system system;
1740  	nano::node_config config (system.get_available_port (), system.logging);
1741  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1742  	nano::node_flags node_flags;
1743  	node_flags.disable_bootstrap_bulk_push_client = true;
1744  	node_flags.disable_lazy_bootstrap = true;
1745  	auto node1 = system.add_node (config, node_flags);
1746  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1747  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
1748  	ASSERT_FALSE (node2->init_error ());
1749  	node2->start ();
1750  	system.nodes.push_back (node2);
1751  	nano::keypair key2;
1752  	auto wallet (node2->wallets.create (nano::random_wallet_id ()));
1753  	wallet->insert_adhoc (key2.prv);
1754  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node1->config.receive_minimum.number ()));
1755  	ASSERT_NE (nullptr, send1);
1756  	ASSERT_NE (std::numeric_limits<nano::uint256_t>::max (), node1->balance (nano::dev::genesis_key.pub));
1757  	node1->block_processor.flush ();
1758  	ASSERT_TIMELY (10s, node1->active.empty ());
1759  	ASSERT_TIMELY (10s, node1->block_confirmed (send1->hash ()));
1760  	node2->bootstrap_initiator.bootstrap (node1->network.endpoint ());
1761  	system.deadline_set (10s);
1762  	do
1763  	{
1764  		ASSERT_NO_ERROR (system.poll ());
1765  	} while (node1->network.empty () || node2->network.empty ());
1766  	ASSERT_TIMELY (10s, node2->balance (nano::dev::genesis_key.pub) != std::numeric_limits<nano::uint256_t>::max ());
1767  	ASSERT_TIMELY (20s, node2->balance (key2.pub) == node1->config.receive_minimum.number ());
1768  	node2->stop ();
1769  }
1770  TEST (bulk, DISABLED_genesis_pruning)
1771  {
1772  	nano::test::system system;
1773  	nano::node_config config (system.get_available_port (), system.logging);
1774  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1775  	config.enable_voting = false; 
1776  	nano::node_flags node_flags;
1777  	node_flags.disable_bootstrap_bulk_push_client = true;
1778  	node_flags.disable_lazy_bootstrap = true;
1779  	node_flags.disable_ongoing_bootstrap = true;
1780  	node_flags.enable_pruning = true;
1781  	auto node1 = system.add_node (config, node_flags);
1782  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1783  	node_flags.enable_pruning = false;
1784  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
1785  	ASSERT_FALSE (node2->init_error ());
1786  	nano::block_hash latest1 (node1->latest (nano::dev::genesis_key.pub));
1787  	nano::block_hash latest2 (node2->latest (nano::dev::genesis_key.pub));
1788  	ASSERT_EQ (latest1, latest2);
1789  	nano::keypair key2;
1790  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 100));
1791  	ASSERT_NE (nullptr, send1);
1792  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 100));
1793  	ASSERT_NE (nullptr, send2);
1794  	auto send3 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 100));
1795  	ASSERT_NE (nullptr, send3);
1796  	{
1797  		auto transaction (node1->wallets.tx_begin_write ());
1798  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
1799  	}
1800  	nano::block_hash latest3 (node1->latest (nano::dev::genesis_key.pub));
1801  	ASSERT_NE (latest1, latest3);
1802  	ASSERT_EQ (send3->hash (), latest3);
1803  	{
1804  		auto election = node1->active.election (send1->qualified_root ());
1805  		ASSERT_NE (nullptr, election);
1806  		election->force_confirm ();
1807  	}
1808  	ASSERT_TIMELY (2s, node1->block_confirmed (send1->hash ()) && node1->active.active (send2->qualified_root ()));
1809  	ASSERT_EQ (0, node1->ledger.cache.pruned_count);
1810  	{
1811  		auto election = node1->active.election (send2->qualified_root ());
1812  		ASSERT_NE (nullptr, election);
1813  		election->force_confirm ();
1814  	}
1815  	ASSERT_TIMELY (2s, node1->block_confirmed (send2->hash ()) && node1->active.active (send3->qualified_root ()));
1816  	ASSERT_EQ (0, node1->ledger.cache.pruned_count);
1817  	{
1818  		auto election = node1->active.election (send3->qualified_root ());
1819  		ASSERT_NE (nullptr, election);
1820  		election->force_confirm ();
1821  	}
1822  	ASSERT_TIMELY (2s, node1->active.empty () && node1->block_confirmed (send3->hash ()));
1823  	node1->ledger_pruning (2, false, false);
1824  	ASSERT_EQ (2, node1->ledger.cache.pruned_count);
1825  	ASSERT_EQ (4, node1->ledger.cache.block_count);
1826  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send1->hash ())); 
1827  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send2->hash ())); 
1828  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send3->hash ()));
1829  	node2->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
1830  	node2->network.merge_peer (node1->network.endpoint ());
1831  	ASSERT_TIMELY (25s, node2->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate, nano::stat::dir::out) >= 1 && !node2->bootstrap_initiator.in_progress ());
1832  	ASSERT_EQ (1, node2->ledger.cache.block_count);
1833  	{
1834  		auto transaction (node2->store.tx_begin_write ());
1835  		node2->unchecked.clear ();
1836  	}
1837  	node2->process_active (send1);
1838  	node2->process_active (send2);
1839  	node2->block_processor.flush ();
1840  	ASSERT_EQ (3, node2->ledger.cache.block_count);
1841  	ASSERT_TIMELY (5s, node2->bootstrap_initiator.connections->connections_count == 0);
1842  	node2->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
1843  	ASSERT_TIMELY (10s, node2->latest (nano::dev::genesis_key.pub) == node1->latest (nano::dev::genesis_key.pub));
1844  	ASSERT_EQ (node2->latest (nano::dev::genesis_key.pub), node1->latest (nano::dev::genesis_key.pub));
1845  	node2->stop ();
1846  }
1847  TEST (bulk_pull_account, basics)
1848  {
1849  	nano::test::system system (1);
1850  	system.nodes[0]->config.receive_minimum = 20;
1851  	nano::keypair key1;
1852  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1853  	system.wallet (0)->insert_adhoc (key1.prv);
1854  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis->account (), key1.pub, 25));
1855  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis->account (), key1.pub, 10));
1856  	auto send3 (system.wallet (0)->send_action (nano::dev::genesis->account (), key1.pub, 2));
1857  	ASSERT_TIMELY (5s, system.nodes[0]->balance (key1.pub) == 25);
1858  	auto connection (std::make_shared<nano::transport::tcp_server> (std::make_shared<nano::transport::socket> (*system.nodes[0], nano::transport::socket::endpoint_type_t::server), system.nodes[0]));
1859  	{
1860  		auto req = std::make_unique<nano::bulk_pull_account> (nano::dev::network_params.network);
1861  		req->account = key1.pub;
1862  		req->minimum_amount = 5;
1863  		req->flags = nano::bulk_pull_account_flags ();
1864  		auto request (std::make_shared<nano::bulk_pull_account_server> (connection, std::move (req)));
1865  		ASSERT_FALSE (request->invalid_request);
1866  		ASSERT_FALSE (request->pending_include_address);
1867  		ASSERT_FALSE (request->pending_address_only);
1868  		ASSERT_EQ (request->current_key.account, key1.pub);
1869  		ASSERT_EQ (request->current_key.hash, 0);
1870  		auto block_data (request->get_next ());
1871  		ASSERT_EQ (send2->hash (), block_data.first.get ()->hash);
1872  		ASSERT_EQ (nano::uint128_union (10), block_data.second.get ()->amount);
1873  		ASSERT_EQ (nano::dev::genesis->account (), block_data.second.get ()->source);
1874  		ASSERT_EQ (nullptr, request->get_next ().first.get ());
1875  	}
1876  	{
1877  		auto req = std::make_unique<nano::bulk_pull_account> (nano::dev::network_params.network);
1878  		req->account = key1.pub;
1879  		req->minimum_amount = 0;
1880  		req->flags = nano::bulk_pull_account_flags::pending_address_only;
1881  		auto request (std::make_shared<nano::bulk_pull_account_server> (connection, std::move (req)));
1882  		ASSERT_TRUE (request->pending_address_only);
1883  		auto block_data (request->get_next ());
1884  		ASSERT_NE (nullptr, block_data.first.get ());
1885  		ASSERT_NE (nullptr, block_data.second.get ());
1886  		ASSERT_EQ (nano::dev::genesis->account (), block_data.second.get ()->source);
1887  		block_data = request->get_next ();
1888  		ASSERT_EQ (nullptr, block_data.first.get ());
1889  		ASSERT_EQ (nullptr, block_data.second.get ());
1890  	}
1891  }
1892  TEST (block_deserializer, construction)
1893  {
1894  	auto deserializer = std::make_shared<nano::bootstrap::block_deserializer> ();
1895  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_math_functions.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-bootstrap.cpp</div>
                </div>
                <div class="column column_space"><pre><code>80    int n = this->blob_bottom_->count();
81    TypeParam alpha = this->blob_bottom_->cpu_diff()[caffe_rng_rand() %
82                                                     this->blob_bottom_->count()];
83    caffe_cpu_scale<TypeParam>(n, alpha, this->blob_bottom_->cpu_data(),
</pre></code></div>
                <div class="column column_space"><pre><code>177  	auto request = std::make_shared<nano::bulk_pull_server> (connection, std::move (req));
178  	auto block_out1 = request->get_next ();
179  	ASSERT_NE (nullptr, block_out1);
180  	ASSERT_EQ (block_out1->hash (), nano::dev::genesis->hash ());
181  	ASSERT_EQ (nullptr, request->get_next ());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    