
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.876132930513595%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lang_model_helpers.cpp</h3>
            <pre><code>1  #include "lang_model_helpers.h"
2  #include "dawg.h"
3  #include "fileio.h"
4  #include "tessdatamanager.h"
5  #include "trie.h"
6  #include "unicharcompress.h"
7  #include <cstdlib>
8  #include <sys/stat.h>
9  #include <sys/types.h>
10  #if defined(_WIN32)
11  #  include <direct.h>
12  #endif
13  namespace tesseract {
14  bool WriteFile(const std::string &output_dir, const std::string &lang, const std::string &suffix,
15                 const std::vector<char> &data, FileWriter writer) {
16    if (lang.empty()) {
17      return true;
18    }
19    std::string dirname = output_dir + "/" + lang;
20  #if defined(_WIN32)
21    _mkdir(dirname.c_str());
22  #else
23    mkdir(dirname.c_str(), S_IRWXU | S_IRWXG);
24  #endif
25    std::string filename = dirname + "/" + lang + suffix;
26    if (writer == nullptr) {
27      return SaveDataToFile(data, filename.c_str());
28    } else {
29      return (*writer)(data, filename.c_str());
30    }
31  }
32  std::string ReadFile(const std::string &filename, FileReader reader) {
33    if (filename.empty()) {
34      return std::string();
35    }
36    std::vector<char> data;
37    bool read_result;
38    if (reader == nullptr) {
39      read_result = LoadDataFromFile(filename.c_str(), &data);
40    } else {
41      read_result = (*reader)(filename.c_str(), &data);
42    }
43    if (read_result) {
44      return std::string(&data[0], data.size());
45    }
46    tprintf("Failed to read data from: %s\n", filename.c_str());
47    return std::string();
48  }
49  bool WriteUnicharset(const UNICHARSET &unicharset, const std::string &output_dir,
50                       const std::string &lang, FileWriter writer, TessdataManager *traineddata) {
51    std::vector<char> unicharset_data;
52    TFile fp;
53    fp.OpenWrite(&unicharset_data);
54    if (!unicharset.save_to_file(&fp)) {
55      return false;
56    }
57    traineddata->OverwriteEntry(TESSDATA_LSTM_UNICHARSET, &unicharset_data[0],
58                                unicharset_data.size());
59    return WriteFile(output_dir, lang, ".unicharset", unicharset_data, writer);
60  }
61  bool WriteRecoder(const UNICHARSET &unicharset, bool pass_through, const std::string &output_dir,
62                    const std::string &lang, FileWriter writer, std::string *radical_table_data,
63                    TessdataManager *traineddata) {
64    UnicharCompress recoder;
65    if (pass_through) {
66      recoder.SetupPassThrough(unicharset);
67    } else {
68      int null_char = unicharset.has_special_codes() ? UNICHAR_BROKEN : unicharset.size();
69      tprintf("Null char=%d\n", null_char);
70      if (!recoder.ComputeEncoding(unicharset, null_char, radical_table_data)) {
71        tprintf("Creation of encoded unicharset failed!!\n");
72        return false;
73      }
74    }
75    TFile fp;
76    std::vector<char> recoder_data;
77    fp.OpenWrite(&recoder_data);
78    if (!recoder.Serialize(&fp)) {
79      return false;
80    }
81    traineddata->OverwriteEntry(TESSDATA_LSTM_RECODER, &recoder_data[0], recoder_data.size());
82    std::string encoding = recoder.GetEncodingAsString(unicharset);
83    recoder_data.resize(encoding.length(), 0);
84    memcpy(&recoder_data[0], &encoding[0], encoding.length());
85    std::string suffix;
86    suffix += ".charset_size=" + std::to_string(recoder.code_range());
87    suffix += ".txt";
88    return WriteFile(output_dir, lang, suffix.c_str(), recoder_data, writer);
89  }
90  static bool WriteDawg(const std::vector<std::string> &words, const UNICHARSET &unicharset,
91                        Trie::RTLReversePolicy reverse_policy, TessdataType file_type,
92                        TessdataManager *traineddata) {
93    Trie trie(DAWG_TYPE_WORD, "", SYSTEM_DAWG_PERM, unicharset.size(), 0);
94    trie.add_word_list(words, unicharset, reverse_policy);
95    tprintf("Reducing Trie to SquishedDawg\n");
96    std::unique_ptr<SquishedDawg> dawg(trie.trie_to_dawg());
97    if (dawg == nullptr || dawg->NumEdges() == 0) {
98      return false;
99    }
100    TFile fp;
101    std::vector<char> dawg_data;
102    fp.OpenWrite(&dawg_data);
103    if (!dawg->write_squished_dawg(&fp)) {
104      return false;
105    }
106    traineddata->OverwriteEntry(file_type, &dawg_data[0], dawg_data.size());
107    return true;
108  }
109  static bool WriteDawgs(const std::vector<std::string> &words, const std::vector<std::string> &puncs,
110                         const std::vector<std::string> &numbers, bool lang_is_rtl,
111                         const UNICHARSET &unicharset, TessdataManager *traineddata) {
112    if (puncs.empty()) {
113      tprintf("Must have non-empty puncs list to use language models!!\n");
114      return false;
115    }
116    if (!words.empty() && !WriteDawg(words, unicharset, Trie::RRP_REVERSE_IF_HAS_RTL,
117                                     TESSDATA_LSTM_SYSTEM_DAWG, traineddata)) {
118      return false;
119    }
120    Trie::RTLReversePolicy reverse_policy =
121        lang_is_rtl ? Trie::RRP_FORCE_REVERSE : Trie::RRP_DO_NO_REVERSE;
122    if (!WriteDawg(puncs, unicharset, reverse_policy, TESSDATA_LSTM_PUNC_DAWG, traineddata)) {
123      return false;
124    }
125    if (!numbers.empty() && !WriteDawg(numbers, unicharset, Trie::RRP_DO_NO_REVERSE,
126                                       TESSDATA_LSTM_NUMBER_DAWG, traineddata)) {
127      return false;
128    }
129    return true;
<span onclick='openModal()' class='match'>130  }
131  int CombineLangModel(const UNICHARSET &unicharset, const std::string &script_dir,
132                       const std::string &version_str, const std::string &output_dir,
133                       const std::string &lang, bool pass_through_recoder,
134                       const std::vector<std::string> &words, const std::vector<std::string> &puncs,
135                       const std::vector<std::string> &numbers, bool lang_is_rtl, FileReader reader,
136                       FileWriter writer) {
137    TessdataManager traineddata;
</span>138    if (!version_str.empty()) {
139      traineddata.SetVersionString(traineddata.VersionString() + ":" + version_str);
140    }
141    if (!WriteUnicharset(unicharset, output_dir, lang, writer, &traineddata)) {
142      tprintf("Error writing unicharset!!\n");
143      return EXIT_FAILURE;
144    } else {
145      tprintf("Config file is optional, continuing...\n");
146    }
147    std::string config_filename = script_dir + "/" + lang + "/" + lang + ".config";
148    std::string config_file = ReadFile(config_filename, reader);
149    if (config_file.length() > 0) {
150      traineddata.OverwriteEntry(TESSDATA_LANG_CONFIG, &config_file[0], config_file.length());
151    }
152    std::string radical_filename = script_dir + "/radical-stroke.txt";
153    std::string radical_data = ReadFile(radical_filename, reader);
154    if (radical_data.empty()) {
155      tprintf("Error reading radical code table %s\n", radical_filename.c_str());
156      return EXIT_FAILURE;
157    }
158    if (!WriteRecoder(unicharset, pass_through_recoder, output_dir, lang, writer, &radical_data,
159                      &traineddata)) {
160      tprintf("Error writing recoder!!\n");
161    }
162    if (!words.empty() || !puncs.empty() || !numbers.empty()) {
163      if (!WriteDawgs(words, puncs, numbers, lang_is_rtl, unicharset, &traineddata)) {
164        tprintf("Error during conversion of wordlists to DAWGs!!\n");
165        return EXIT_FAILURE;
166      }
167    }
168    std::vector<char> traineddata_data;
169    traineddata.Serialize(&traineddata_data);
170    if (!WriteFile(output_dir, lang, ".traineddata", traineddata_data, writer)) {
171      tprintf("Error writing output traineddata file!!\n");
172      return EXIT_FAILURE;
173    }
174    tprintf("Created %s/%s/%s.traineddata", output_dir.c_str(), lang.c_str(), lang.c_str());
175    return EXIT_SUCCESS;
176  }
177  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-drawtord.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "drawtord.h"
5  #include "pithsync.h"
6  #include "topitch.h"
7  namespace tesseract {
8  #define TO_WIN_XPOS 0 
9  #define TO_WIN_YPOS 0
10  #define TO_WIN_NAME "Textord"
11  BOOL_VAR(textord_show_fixed_cuts, false, "Draw fixed pitch cell boundaries");
12  ScrollView *to_win = nullptr;
13  #ifndef GRAPHICS_DISABLED
14  ScrollView *create_to_win(ICOORD page_tr) {
15    if (to_win != nullptr) {
16      return to_win;
17    }
18    to_win = new ScrollView(TO_WIN_NAME, TO_WIN_XPOS, TO_WIN_YPOS, page_tr.x() + 1, page_tr.y() + 1,
19                            page_tr.x(), page_tr.y(), true);
20    return to_win;
21  }
22  void close_to_win() {
23    if (to_win != nullptr) {
24      to_win->Update();
25    }
26  }
27  void plot_box_list(               
28      ScrollView *win,              
29      BLOBNBOX_LIST *list,          
30      ScrollView::Color body_colour 
31  ) {
32    BLOBNBOX_IT it = list; 
33    win->Pen(body_colour);
34    win->Brush(ScrollView::NONE);
35    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
36      it.data()->bounding_box().plot(win);
37    }
38  }
39  void plot_to_row(             
40      TO_ROW *row,              
41      ScrollView::Color colour, 
42      FCOORD rotation           
43  ) {
44    FCOORD plot_pt; 
45    BLOBNBOX_IT it = row->blob_list();
46    float left, right; 
47    if (it.empty()) {
48      tprintf("No blobs in row at %g\n", row->parallel_c());
49      return;
50    }
51    left = it.data()->bounding_box().left();
52    it.move_to_last();
53    right = it.data()->bounding_box().right();
54    plot_blob_list(to_win, row->blob_list(), colour, ScrollView::BROWN);
55    to_win->Pen(colour);
56    plot_pt = FCOORD(left, row->line_m() * left + row->line_c());
57    plot_pt.rotate(rotation);
58    to_win->SetCursor(plot_pt.x(), plot_pt.y());
59    plot_pt = FCOORD(right, row->line_m() * right + row->line_c());
60    plot_pt.rotate(rotation);
61    to_win->DrawTo(plot_pt.x(), plot_pt.y());
62  }
63  void plot_parallel_row(       
64      TO_ROW *row,              
65      float gradient,           
66      int32_t left,             
67      ScrollView::Color colour, 
68      FCOORD rotation           
69  ) {
70    FCOORD plot_pt; 
71    BLOBNBOX_IT it = row->blob_list();
72    auto fleft = static_cast<float>(left); 
73    float right;                           
74    it.move_to_last();
75    right = it.data()->bounding_box().right();
76    plot_blob_list(to_win, row->blob_list(), colour, ScrollView::BROWN);
77    to_win->Pen(colour);
78    plot_pt = FCOORD(fleft, gradient * left + row->max_y());
79    plot_pt.rotate(rotation);
80    to_win->SetCursor(plot_pt.x(), plot_pt.y());
81    plot_pt = FCOORD(fleft, gradient * left + row->min_y());
82    plot_pt.rotate(rotation);
83    to_win->DrawTo(plot_pt.x(), plot_pt.y());
84    plot_pt = FCOORD(fleft, gradient * left + row->parallel_c());
85    plot_pt.rotate(rotation);
86    to_win->SetCursor(plot_pt.x(), plot_pt.y());
87    plot_pt = FCOORD(right, gradient * right + row->parallel_c());
88    plot_pt.rotate(rotation);
89    to_win->DrawTo(plot_pt.x(), plot_pt.y());
90  }
91  void draw_occupation(                    
92      int32_t xleft,                       
93      int32_t ybottom,                     
94      int32_t min_y,                       
95      int32_t max_y, int32_t occupation[], 
96      int32_t thresholds[]                 
97  ) {
98    int32_t line_index;                     
99    ScrollView::Color colour;               
100    auto fleft = static_cast<float>(xleft); 
101    colour = ScrollView::WHITE;
102    to_win->Pen(colour);
103    to_win->SetCursor(fleft, static_cast<float>(ybottom));
104    for (line_index = min_y; line_index <= max_y; line_index++) {
105      if (occupation[line_index - min_y] < thresholds[line_index - min_y]) {
106        if (colour != ScrollView::BLUE) {
107          colour = ScrollView::BLUE;
108          to_win->Pen(colour);
109        }
110      } else {
111        if (colour != ScrollView::WHITE) {
112          colour = ScrollView::WHITE;
113          to_win->Pen(colour);
114        }
115      }
116      to_win->DrawTo(fleft + occupation[line_index - min_y] / 10.0, static_cast<float>(line_index));
117    }
118    colour = ScrollView::STEEL_BLUE;
119    to_win->Pen(colour);
120    to_win->SetCursor(fleft, static_cast<float>(ybottom));
121    for (line_index = min_y; line_index <= max_y; line_index++) {
122      to_win->DrawTo(fleft + thresholds[line_index - min_y] / 10.0, static_cast<float>(line_index));
123    }
124  }
125  void draw_meanlines(          
126      TO_BLOCK *block,          
127      float gradient,           
128      int32_t left,             
129      ScrollView::Color colour, 
130      FCOORD rotation           
131  ) {
132    FCOORD plot_pt; 
133    TO_ROW_IT row_it = block->get_rows();
134    TO_ROW *row;         
135    BLOBNBOX_IT blob_it; 
136    float right;         
137    to_win->Pen(colour);
138    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
139      row = row_it.data();
140      blob_it.set_to_list(row->blob_list());
141      blob_it.move_to_last();
142      right = blob_it.data()->bounding_box().right();
143      plot_pt = FCOORD(static_cast<float>(left), gradient * left + row->parallel_c() + row->xheight);
144      plot_pt.rotate(rotation);
145      to_win->SetCursor(plot_pt.x(), plot_pt.y());
146      plot_pt = FCOORD(right, gradient * right + row->parallel_c() + row->xheight);
147      plot_pt.rotate(rotation);
148      to_win->DrawTo(plot_pt.x(), plot_pt.y());
149    }
150  }
151  void plot_word_decisions( 
152      ScrollView *win,      
153      int16_t pitch,        
154      TO_ROW *row           
155  ) {
156    ScrollView::Color colour = ScrollView::MAGENTA; 
157    ScrollView::Color rect_colour;                  
158    int32_t prev_x;                                 
159    int16_t blob_count;                             
160    BLOBNBOX *blob;                                 
161    TBOX blob_box;                                  
162    BLOBNBOX_IT blob_it = row->blob_list();
163    BLOBNBOX_IT start_it = blob_it; 
164    rect_colour = ScrollView::BLACK;
165    prev_x = -INT16_MAX;
166    blob_count = 0;
167    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
168      blob = blob_it.data();
169      blob_box = blob->bounding_box();
170      if (!blob->joined_to_prev() && blob_box.left() - prev_x > row->max_nonspace) {
171        if ((blob_box.left() - prev_x >= row->min_space ||
172             blob_box.left() - prev_x > row->space_threshold) &&
173            blob_count > 0) {
174          if (pitch > 0 && textord_show_fixed_cuts) {
175            plot_fp_cells(win, colour, &start_it, pitch, blob_count, &row->projection,
176                          row->projection_left, row->projection_right,
177                          row->xheight * textord_projection_scale);
178          }
179          blob_count = 0;
180          start_it = blob_it;
181        }
182        if (colour == ScrollView::MAGENTA) {
183          colour = ScrollView::RED;
184        } else {
185          colour = static_cast<ScrollView::Color>(colour + 1);
186        }
187        if (blob_box.left() - prev_x < row->min_space) {
188          if (blob_box.left() - prev_x > row->space_threshold) {
189            rect_colour = ScrollView::GOLDENROD;
190          } else {
191            rect_colour = ScrollView::CORAL;
192          }
193          win->Brush(rect_colour);
194          win->Rectangle(prev_x, blob_box.bottom(), blob_box.left(), blob_box.top());
195        }
196      }
197      if (!blob->joined_to_prev()) {
198        prev_x = blob_box.right();
199      }
200      if (blob->cblob() != nullptr) {
201        blob->cblob()->plot(win, colour, colour);
202      }
203      if (!blob->joined_to_prev() && blob->cblob() != nullptr) {
204        blob_count++;
205      }
206    }
207    if (pitch > 0 && textord_show_fixed_cuts && blob_count > 0) {
208      plot_fp_cells(win, colour, &start_it, pitch, blob_count, &row->projection, row->projection_left,
209                    row->projection_right, row->xheight * textord_projection_scale);
210    }
<span onclick='openModal()' class='match'>211  }
212  void plot_fp_cells(           
213      ScrollView *win,          
214      ScrollView::Color colour, 
215      BLOBNBOX_IT *blob_it,     
216      int16_t pitch,            
217      int16_t blob_count,       
218      STATS *projection,        
219      int16_t projection_left,  
220      int16_t projection_right, float projection_scale) {
221    int16_t occupation;    
222    TBOX word_box;         
223    FPSEGPT_LIST seg_list; 
224    FPSEGPT_IT seg_it;
</span>225    FPSEGPT *segpt; 
226    if (pitsync_linear_version) {
227      check_pitch_sync2(blob_it, blob_count, pitch, 2, projection, projection_left, projection_right,
228                        projection_scale, occupation, &seg_list, 0, 0);
229    } else {
230      check_pitch_sync(blob_it, blob_count, pitch, 2, projection, &seg_list);
231    }
232    word_box = blob_it->data()->bounding_box();
233    for (; blob_count > 0; blob_count--) {
234      word_box += box_next(blob_it);
235    }
236    seg_it.set_to_list(&seg_list);
237    for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
238      segpt = seg_it.data();
239      if (segpt->faked) {
240        colour = ScrollView::WHITE;
241        win->Pen(colour);
242      } else {
243        win->Pen(colour);
244      }
245      win->Line(segpt->position(), word_box.bottom(), segpt->position(), word_box.top());
246    }
247  }
248  void plot_fp_cells2(          
249      ScrollView *win,          
250      ScrollView::Color colour, 
251      TO_ROW *row,              
252      FPSEGPT_LIST *seg_list    
253  ) {
254    TBOX word_box; 
255    FPSEGPT_IT seg_it = seg_list;
256    BLOBNBOX_IT blob_it = row->blob_list();
257    FPSEGPT *segpt; 
258    word_box = blob_it.data()->bounding_box();
259    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list();) {
260      word_box += box_next(&blob_it);
261    }
262    for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
263      segpt = seg_it.data();
264      if (segpt->faked) {
265        colour = ScrollView::WHITE;
266        win->Pen(colour);
267      } else {
268        win->Pen(colour);
269      }
270      win->Line(segpt->position(), word_box.bottom(), segpt->position(), word_box.top());
271    }
272  }
273  void plot_row_cells(          
274      ScrollView *win,          
275      ScrollView::Color colour, 
276      TO_ROW *row,              
277      float xshift,             
278      ICOORDELT_LIST *cells     
279  ) {
280    TBOX word_box; 
281    ICOORDELT_IT cell_it = cells;
282    BLOBNBOX_IT blob_it = row->blob_list();
283    ICOORDELT *cell; 
284    word_box = blob_it.data()->bounding_box();
285    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list();) {
286      word_box += box_next(&blob_it);
287    }
288    win->Pen(colour);
289    for (cell_it.mark_cycle_pt(); !cell_it.cycled_list(); cell_it.forward()) {
290      cell = cell_it.data();
291      win->Line(cell->x() + xshift, word_box.bottom(), cell->x() + xshift, word_box.top());
292    }
293  }
294  #endif 
295  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lang_model_helpers.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-drawtord.cpp</div>
                </div>
                <div class="column column_space"><pre><code>130  }
131  int CombineLangModel(const UNICHARSET &unicharset, const std::string &script_dir,
132                       const std::string &version_str, const std::string &output_dir,
133                       const std::string &lang, bool pass_through_recoder,
134                       const std::vector<std::string> &words, const std::vector<std::string> &puncs,
135                       const std::vector<std::string> &numbers, bool lang_is_rtl, FileReader reader,
136                       FileWriter writer) {
137    TessdataManager traineddata;
</pre></code></div>
                <div class="column column_space"><pre><code>211  }
212  void plot_fp_cells(           
213      ScrollView *win,          
214      ScrollView::Color colour, 
215      BLOBNBOX_IT *blob_it,     
216      int16_t pitch,            
217      int16_t blob_count,       
218      STATS *projection,        
219      int16_t projection_left,  
220      int16_t projection_right, float projection_scale) {
221    int16_t occupation;    
222    TBOX word_box;         
223    FPSEGPT_LIST seg_list; 
224    FPSEGPT_IT seg_it;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    