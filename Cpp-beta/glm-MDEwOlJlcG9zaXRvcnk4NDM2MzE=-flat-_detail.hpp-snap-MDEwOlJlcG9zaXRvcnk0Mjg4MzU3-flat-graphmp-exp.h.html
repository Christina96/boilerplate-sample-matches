
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.668508287292818%, Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-_detail.hpp</h3>
            <pre><code>1  #ifndef glm_core_detail
2  #define glm_core_detail
3  #include "setup.hpp"
4  #include <cassert>
5  #if(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))
6  #include <cstdint>
7  #endif
8  namespace glm{
9  namespace detail
10  {
11  	class half;
12  #if(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) 
13  	typedef int64_t								sint64;
14  	typedef uint64_t							uint64;
15  #elif(GLM_COMPILER & GLM_COMPILER_VC)
16  	typedef signed __int64						sint64;
17  	typedef unsigned __int64					uint64;
18  #elif(GLM_COMPILER & (GLM_COMPILER_GCC | GLM_COMPILER_LLVM_GCC | GLM_COMPILER_CLANG))
19  	__extension__ typedef signed long long		sint64;
20  	__extension__ typedef unsigned long long	uint64;
21  #elif(GLM_COMPILER & GLM_COMPILER_BC)
22  	typedef Int64								sint64;
23  	typedef Uint64								uint64;
24  #else
25  	typedef signed long	long					sint64;
26  	typedef unsigned long long					uint64;
27  #endif
28  	template<bool C>
29  	struct If
30  	{
31  		template<typename F, typename T>
32  		static GLM_FUNC_QUALIFIER T apply(F functor, const T& val)
33  		{
34  			return functor(val);
35  		}
36  	};
37  	template<>
38  	struct If<false>
39  	{
40  		template<typename F, typename T>
41  		static GLM_FUNC_QUALIFIER T apply(F, const T& val)
42  		{
43  			return val;
44  		}
45  	};
46  	union uif32
47  	{
48  		GLM_FUNC_QUALIFIER uif32() :
49  			i(0)
50  		{}
51  		GLM_FUNC_QUALIFIER uif32(float f) :
52  			f(f)
53  		{}
54  		GLM_FUNC_QUALIFIER uif32(unsigned int i) :
55  			i(i)
56  		{}
57  		float f;
58  		unsigned int i;
59  	};
60  	union uif64
61  	{
62  		GLM_FUNC_QUALIFIER uif64() :
63  			i(0)
64  		{}
65  		GLM_FUNC_QUALIFIER uif64(double f) :
66  			f(f)
67  		{}
68  		GLM_FUNC_QUALIFIER uif64(uint64 i) :
69  			i(i)
70  		{}
71  		double f;
72  		uint64 i;
73  	};
74  	typedef uif32 uif;
75  	template <typename T>
76  	struct is_int
77  	{
78  		enum is_int_enum
79  		{
80  			_YES = 0,
81  			_NO = 1
82  		};
83  	};
84  #define GLM_DETAIL_IS_INT(T)	\
85  	template <>					\
86  	struct is_int<T>			\
87  	{							\
88  		enum is_int_enum		\
89  		{						\
90  			_YES = 1,			\
91  			_NO = 0				\
92  		};						\
93  	}
94  	template <typename T>
95  	struct is_uint
96  	{
97  		enum is_uint_enum
98  		{
99  			_YES = 0,
100  			_NO = 1
101  		};
102  	};
103  #define GLM_DETAIL_IS_UINT(T)	\
104  	template <>					\
105  	struct is_uint<T>			\
106  	{							\
107  		enum is_uint_enum		\
108  		{						\
109  			_YES = 1,			\
110  			_NO = 0				\
111  		};						\
112  	}
113  	template <typename T>
114  	struct is_float
115  	{
116  		enum is_float_enum
117  		{
118  			_YES = 0,
119  			_NO = 1
120  		};
121  	};
122  #define GLM_DETAIL_IS_FLOAT(T)	\
123  	template <>					\
124  	struct is_float<T>			\
125  	{							\
126  		enum is_float_enum		\
127  		{						\
128  			_YES = 1,			\
129  			_NO = 0				\
130  		};						\
131  	}
132  	GLM_DETAIL_IS_FLOAT(detail::half);
133  	GLM_DETAIL_IS_FLOAT(float);
134  	GLM_DETAIL_IS_FLOAT(double);
135  	GLM_DETAIL_IS_FLOAT(long double);
136  	template <typename T>
137  	struct is_bool
138  	{
139  		enum is_bool_enum
140  		{
141  			_YES = 0,
142  			_NO = 1
143  		};
144  	};
145  	template <>
146  	struct is_bool<bool>
147  	{
148  		enum is_bool_enum
149  		{
150  			_YES = 1,
151  			_NO = 0
152  		};
153  	};
154  	template <typename T>
155  	struct is_vector
156  	{
157  		enum is_vector_enum
158  		{
159  			_YES = 0,
160  			_NO = 1
161  		};
162  	};
163  #	define GLM_DETAIL_IS_VECTOR(TYPE) \
164  		template <typename T> \
165  		struct is_vector<TYPE<T> > \
166  		{ \
167  			enum is_vector_enum \
168  			{ \
169  				_YES = 1, \
170  				_NO = 0 \
171  			}; \
172  		}
173  	template <typename T>
174  	struct is_matrix
175  	{
176  		enum is_matrix_enum
177  		{
178  			_YES = 0,
179  			_NO = 1
180  		};
181  	};
182  #define GLM_DETAIL_IS_MATRIX(T)	\
183  	template <>					\
184  	struct is_matrix			\
185  	{							\
186  		enum is_matrix_enum		\
187  		{						\
188  			_YES = 1,			\
189  			_NO = 0				\
190  		};						\
191  	}
192  	template <typename T>
193  	struct type
194  	{
195  		enum type_enum
196  		{
197  			is_float = is_float<T>::_YES,
198  			is_int = is_int<T>::_YES,
199  			is_uint = is_uint<T>::_YES,
200  			is_bool = is_bool<T>::_YES
201  		};
202  	};
<span onclick='openModal()' class='match'>203  	typedef signed char							int8;
204  	typedef signed short						int16;
205  	typedef signed int							int32;
206  	typedef detail::sint64						int64;
207  	typedef unsigned char						uint8;
208  	typedef unsigned short						uint16;
209  	typedef unsigned int						uint32;
210  	typedef detail::uint64						uint64;
211  	typedef detail::half						float16;
212  	typedef float								float32;
213  	typedef double								float64;
</span>214  	struct float_or_int_value
215  	{
216  		enum
217  		{
218  			GLM_ERROR,
219  			GLM_FLOAT,
220  			GLM_INT
221  		};
222  	};
223  	template <typename T>
224  	struct float_or_int_trait
225  	{
226  		enum{ID = float_or_int_value::GLM_ERROR};
227  	};
228  	template <>
229  	struct float_or_int_trait<int8>
230  	{
231  		enum{ID = float_or_int_value::GLM_INT};
232  	};
233  	template <>
234  	struct float_or_int_trait<int16>
235  	{
236  		enum{ID = float_or_int_value::GLM_INT};
237  	};
238  	template <>
239  	struct float_or_int_trait<int32>
240  	{
241  		enum{ID = float_or_int_value::GLM_INT};
242  	};
243  	template <>
244  	struct float_or_int_trait<int64>
245  	{
246  		enum{ID = float_or_int_value::GLM_INT};
247  	};
248  	template <>
249  	struct float_or_int_trait<uint8>
250  	{
251  		enum{ID = float_or_int_value::GLM_INT};
252  	};
253  	template <>
254  	struct float_or_int_trait<uint16>
255  	{
256  		enum{ID = float_or_int_value::GLM_INT};
257  	};
258  	template <>
259  	struct float_or_int_trait<uint32>
260  	{
261  		enum{ID = float_or_int_value::GLM_INT};
262  	};
263  	template <>
264  	struct float_or_int_trait<uint64>
265  	{
266  		enum{ID = float_or_int_value::GLM_INT};
267  	};
268  	template <>
269  	struct float_or_int_trait<float16>
270  	{
271  		enum{ID = float_or_int_value::GLM_FLOAT};
272  	};
273  	template <>
274  	struct float_or_int_trait<float32>
275  	{
276  		enum{ID = float_or_int_value::GLM_FLOAT};
277  	};
278  	template <>
279  	struct float_or_int_trait<float64>
280  	{
281  		enum{ID = float_or_int_value::GLM_FLOAT};
282  	};
283  }
284  }
285  #if((GLM_COMPILER & GLM_COMPILER_VC) && (GLM_COMPILER >= GLM_COMPILER_VC2005))
286  #	define GLM_DEPRECATED __declspec(deprecated)
287  #	define GLM_ALIGN(x) __declspec(align(x)) 
288  #	define GLM_ALIGNED_STRUCT(x) __declspec(align(x)) struct 
289  #	define GLM_RESTRICT __declspec(restrict)
290  #	define GLM_RESTRICT_VAR __restrict
291  #elif((GLM_COMPILER & (GLM_COMPILER_GCC | GLM_COMPILER_LLVM_GCC)) && (GLM_COMPILER >= GLM_COMPILER_GCC31))
292  #	define GLM_DEPRECATED __attribute__((__deprecated__))
293  #	define GLM_ALIGN(x) __attribute__((aligned(x)))
294  #	define GLM_ALIGNED_STRUCT(x) struct __attribute__((aligned(x)))
295  #	if(GLM_COMPILER >= GLM_COMPILER_GCC33)
296  #		define GLM_RESTRICT __restrict__
297  #		define GLM_RESTRICT_VAR __restrict__
298  #	else
299  #		define GLM_RESTRICT
300  #		define GLM_RESTRICT_VAR
301  #	endif
302  #	define GLM_RESTRICT __restrict__
303  #	define GLM_RESTRICT_VAR __restrict__
304  #else
305  #	define GLM_DEPRECATED
306  #	define GLM_ALIGN
307  #	define GLM_ALIGNED_STRUCT(x) 
308  #	define GLM_RESTRICT
309  #	define GLM_RESTRICT_VAR
310  #endif
311  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp-exp.h</h3>
            <pre><code>1  #ifdef GCC_ATOMIC
2  class TUNGraphMP;
3  typedef TPt<TUNGraphMP> PUNGraphMP;
4  class TUNGraphMP {
5  public:
6    class TNode {
7    private:
8      TInt Id;
9      TIntV NIdV;
10    public:
11      TNode() : Id(-1), NIdV() {}
12      TNode(const int& NId) : Id(NId), NIdV() { }
13      TNode(const TNode& Node) : Id(Node.Id), NIdV(Node.NIdV) { }
14      TNode(TSIn& SIn) : Id(SIn), NIdV(SIn) { }
15      void Save(TSOut& SOut) const { Id.Save(SOut); NIdV.Save(SOut); }
16      int GetId() const { return Id; }
17      int GetDeg() const { return NIdV.Len(); }
18      int GetInDeg() const { return GetDeg();}
19      int GetOutDeg() const { return GetDeg(); }
20      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
21      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
22      int GetNbrNId(const int& NodeN) const { return NIdV[NodeN]; }
23      bool IsInNId(const int& NId) const { return IsNbrNId(NId);}
24      bool IsOutNId(const int& NId) const { return IsNbrNId(NId); }
25      bool IsNbrNId(const int& NId) const { return NIdV.SearchBin(NId) != -1;}
26      void PackOutNIdV() { NIdV.Pack(); }
27      void PackNIdV() { NIdV.Pack(); }
28      void SortNIdV() { NIdV.Sort(); }
29      friend class TUNGraphMP;
30    };
31    class TNodeI {
32    private:
33      typedef THashMP<TInt, TNode>::TIter THashIter;
34      THashIter NodeHI;
35    public:
36      TNodeI() : NodeHI() { }
37      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
38      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
39      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
40      TNodeI& operator++ (int) { NodeHI++; return *this; }
41      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
42      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
43      int GetId() const { return NodeHI.GetDat().GetId(); }
44      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
45      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
46      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
47      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
48      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
49      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
50      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
51      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
52      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
53      bool IsNbrNId(const int& NId) const { return NodeHI.GetDat().IsNbrNId(NId); }
54      friend class TUNGraphMP;
55    };
56    class TEdgeI {
57    private:
58      TNodeI CurNode, EndNode;
59      int CurEdge;
60    public:
61      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
62      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
63      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
64      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
65      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
66        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
67      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
68      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
69      int GetId() const { return -1; }
70      int GetSrcNId() const { return CurNode.GetId(); }
71      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
72      friend class TUNGraphMP;
73    };
74  private:
75    TCRef CRef;
76    TInt MxNId, NEdges;
77    THashMP<TInt, TNode> NodeH;
78  private:
79    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
80    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
81  public:
82    TUNGraphMP() : CRef(), MxNId(0), NEdges(0), NodeH() { }
83    explicit TUNGraphMP(const int& Nodes, const int& Edges) : MxNId(0), NEdges(0) { Reserve(Nodes, Edges); }
84    TUNGraphMP(const TUNGraphMP& Graph) : MxNId(Graph.MxNId), NEdges(Graph.NEdges), NodeH(Graph.NodeH) { }
85    TUNGraphMP(TSIn& SIn) : MxNId(SIn), NEdges(SIn), NodeH(SIn) { }
86    void Save(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut); }
87    static PUNGraphMP New() { return new TUNGraphMP(); }
88    static PUNGraphMP New(const int& Nodes, const int& Edges) { return new TUNGraphMP(Nodes, Edges); }
89    static PUNGraphMP Load(TSIn& SIn) { return PUNGraphMP(new TUNGraphMP(SIn)); }
90    bool HasFlag(const TGraphFlag& Flag) const;
91    TUNGraphMP& operator = (const TUNGraphMP& Graph) {
92      if (this!=&Graph) { MxNId=Graph.MxNId; NEdges=Graph.NEdges; NodeH=Graph.NodeH; }  return *this; }
93    int GetNodes() const { return NodeH.Len(); }
94    void SetNodes(const int& Length) { NodeH.SetLen(Length); }
95    int AddNode(int NId = -1);
96    int AddNodeUnchecked(int NId = -1);
97    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
98    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
99    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
100    void DelNode(const int& NId);
101    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
102    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
103    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
104    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
105    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
106    int GetMxNId() const { return MxNId; }
107    int Reserved() const {return NodeH.GetReservedKeyIds();}
108    int GetEdges() const;
109    int AddEdge(const int& SrcNId, const int& DstNId);
110    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
111    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
<span onclick='openModal()' class='match'>112    int AddOutEdge1(int& SrcIdx, const int& SrcNId, const int& DstNId);
113    int AddInEdge1(int& DstIdx, const int& SrcNId, const int& DstNId);
114    void AddOutEdge2(const int& SrcNId, const int& DstNId);
</span>115    void AddInEdge2(const int& SrcNId, const int& DstNId);
116    void AddNodeWithEdges(const TInt& NId, TIntV& InNIdV, TIntV& OutNIdV);
117    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
118    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
119    TEdgeI BegEI() const { TNodeI NI=BegNI(); while(NI<EndNI() && NI.GetOutDeg()==0){NI++;} return TEdgeI(NI, EndNI()); }
120    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
121    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
122    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
123    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
124    void GetNIdV(TIntV& NIdV) const;
125    bool Empty() const { return GetNodes()==0; }
126    void Clr() { MxNId=0; NodeH.Clr(); }
127    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes); } }
128    void ReserveNIdDeg(const int& NId, const int& Deg) { GetNode(NId).NIdV.Reserve(Deg); }
129    void SortEdges(const int& Idx, const int& Deg) { if (Deg > 0) NodeH[Idx].NIdV.Sort(); }
130    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
131    void Defrag(const bool& OnlyNodeLinks=false);
132    bool IsOk(const bool& ThrowExcept=true) const;
133    void Dump(FILE *OutF=stdout) const;
134    static PUNGraphMP GetSmallGraph();
135    friend class TPt<TUNGraphMP>;
136    friend class TUNGraphMPMtx;
137  };
138  namespace TSnap {
139  template <> struct IsDirected<TUNGraphMP> { enum { Val = 1 }; };
140  }
141  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-_detail.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp-exp.h</div>
                </div>
                <div class="column column_space"><pre><code>203  	typedef signed char							int8;
204  	typedef signed short						int16;
205  	typedef signed int							int32;
206  	typedef detail::sint64						int64;
207  	typedef unsigned char						uint8;
208  	typedef unsigned short						uint16;
209  	typedef unsigned int						uint32;
210  	typedef detail::uint64						uint64;
211  	typedef detail::half						float16;
212  	typedef float								float32;
213  	typedef double								float64;
</pre></code></div>
                <div class="column column_space"><pre><code>112    int AddOutEdge1(int& SrcIdx, const int& SrcNId, const int& DstNId);
113    int AddInEdge1(int& DstIdx, const int& SrcNId, const int& DstNId);
114    void AddOutEdge2(const int& SrcNId, const int& DstNId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    