
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.576659038901601%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_softmax_layer.cpp</h3>
            <pre><code>1  #include <cmath>
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/softmax_layer.hpp"
8  #ifdef USE_CUDNN
9  #include "caffe/layers/cudnn_softmax_layer.hpp"
10  #endif
11  #include "caffe/test/test_caffe_main.hpp"
12  #include "caffe/test/test_gradient_check_util.hpp"
13  namespace caffe {
14  template <typename TypeParam>
15  class SoftmaxLayerTest : public MultiDeviceTest<TypeParam> {
16    typedef typename TypeParam::Dtype Dtype;
17   protected:
18    SoftmaxLayerTest()
19        : blob_bottom_(new Blob<Dtype>(2, 10, 2, 3)),
20          blob_top_(new Blob<Dtype>()) {
21      FillerParameter filler_param;
22      GaussianFiller<Dtype> filler(filler_param);
23      filler.Fill(this->blob_bottom_);
24      blob_bottom_vec_.push_back(blob_bottom_);
25      blob_top_vec_.push_back(blob_top_);
26    }
27    virtual ~SoftmaxLayerTest() { delete blob_bottom_; delete blob_top_; }
28    Blob<Dtype>* const blob_bottom_;
29    Blob<Dtype>* const blob_top_;
30    vector<Blob<Dtype>*> blob_bottom_vec_;
31    vector<Blob<Dtype>*> blob_top_vec_;
32  };
33  TYPED_TEST_CASE(SoftmaxLayerTest, TestDtypesAndDevices);
34  TYPED_TEST(SoftmaxLayerTest, TestForward) {
35    typedef typename TypeParam::Dtype Dtype;
36    LayerParameter layer_param;
37    SoftmaxLayer<Dtype> layer(layer_param);
38    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
39    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
40    for (int i = 0; i < this->blob_bottom_->num(); ++i) {
41      for (int k = 0; k < this->blob_bottom_->height(); ++k) {
42        for (int l = 0; l < this->blob_bottom_->width(); ++l) {
43          Dtype sum = 0;
44          for (int j = 0; j < this->blob_top_->channels(); ++j) {
45            sum += this->blob_top_->data_at(i, j, k, l);
46          }
47          EXPECT_GE(sum, 0.999);
48          EXPECT_LE(sum, 1.001);
49          Dtype scale = 0;
50          for (int j = 0; j < this->blob_bottom_->channels(); ++j) {
51            scale += exp(this->blob_bottom_->data_at(i, j, k, l));
52          }
53          for (int j = 0; j < this->blob_bottom_->channels(); ++j) {
54            EXPECT_GE(this->blob_top_->data_at(i, j, k, l) + 1e-4,
55                exp(this->blob_bottom_->data_at(i, j, k, l)) / scale)
56                << "debug: " << i << " " << j;
57            EXPECT_LE(this->blob_top_->data_at(i, j, k, l) - 1e-4,
58                exp(this->blob_bottom_->data_at(i, j, k, l)) / scale)
59                << "debug: " << i << " " << j;
60          }
61        }
<span onclick='openModal()' class='match'>62      }
63    }
64  }
65  TYPED_TEST(SoftmaxLayerTest, TestGradient) {
66    typedef typename TypeParam::Dtype Dtype;
67    LayerParameter layer_param;
68    SoftmaxLayer<Dtype> layer(layer_param);
69    GradientChecker<Dtype> checker(1e-2, 1e-3);
</span>70    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
71        this->blob_top_vec_);
72  }
73  #ifdef USE_CUDNN
74  template <typename Dtype>
75  class CuDNNSoftmaxLayerTest : public GPUDeviceTest<Dtype> {
76   protected:
77    CuDNNSoftmaxLayerTest()
78        : blob_bottom_(new Blob<Dtype>(2, 10, 2, 3)),
79          blob_top_(new Blob<Dtype>()) {
80      FillerParameter filler_param;
81      GaussianFiller<Dtype> filler(filler_param);
82      filler.Fill(this->blob_bottom_);
83      blob_bottom_vec_.push_back(blob_bottom_);
84      blob_top_vec_.push_back(blob_top_);
85    }
86    virtual ~CuDNNSoftmaxLayerTest() { delete blob_bottom_; delete blob_top_; }
87    Blob<Dtype>* const blob_bottom_;
88    Blob<Dtype>* const blob_top_;
89    vector<Blob<Dtype>*> blob_bottom_vec_;
90    vector<Blob<Dtype>*> blob_top_vec_;
91  };
92  TYPED_TEST_CASE(CuDNNSoftmaxLayerTest, TestDtypes);
93  TYPED_TEST(CuDNNSoftmaxLayerTest, TestForwardCuDNN) {
94    LayerParameter layer_param;
95    CuDNNSoftmaxLayer<TypeParam> layer(layer_param);
96    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
97    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
98    for (int i = 0; i < this->blob_bottom_->num(); ++i) {
99      for (int k = 0; k < this->blob_bottom_->height(); ++k) {
100        for (int l = 0; l < this->blob_bottom_->width(); ++l) {
101          TypeParam sum = 0;
102          for (int j = 0; j < this->blob_top_->channels(); ++j) {
103            sum += this->blob_top_->data_at(i, j, k, l);
104          }
105          EXPECT_GE(sum, 0.999);
106          EXPECT_LE(sum, 1.001);
107          TypeParam scale = 0;
108          for (int j = 0; j < this->blob_bottom_->channels(); ++j) {
109            scale += exp(this->blob_bottom_->data_at(i, j, k, l));
110          }
111          for (int j = 0; j < this->blob_bottom_->channels(); ++j) {
112            EXPECT_GE(this->blob_top_->data_at(i, j, k, l) + 1e-4,
113                exp(this->blob_bottom_->data_at(i, j, k, l)) / scale)
114                << "debug: " << i << " " << j;
115            EXPECT_LE(this->blob_top_->data_at(i, j, k, l) - 1e-4,
116                exp(this->blob_bottom_->data_at(i, j, k, l)) / scale)
117                << "debug: " << i << " " << j;
118          }
119        }
120      }
121    }
122  }
123  TYPED_TEST(CuDNNSoftmaxLayerTest, TestGradientCuDNN) {
124    LayerParameter layer_param;
125    CuDNNSoftmaxLayer<TypeParam> layer(layer_param);
126    GradientChecker<TypeParam> checker(1e-2, 1e-3);
127    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
128        this->blob_top_vec_);
129  }
130  #endif
131  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_bigint_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/charconv_bigint.h"
2  #include <string>
3  #include "gtest/gtest.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace strings_internal {
7  TEST(BigUnsigned, ShiftLeft) {
8    {
9      BigUnsigned<4> num(3u);
10      num.ShiftLeft(100);
11      EXPECT_EQ(num, BigUnsigned<4>("3802951800684688204490109616128"));
12    }
13    {
14      BigUnsigned<4> a(15u);
15      BigUnsigned<4> b(7u);
16      BigUnsigned<4> c(3u);
17      a.ShiftLeft(125);
18      b.ShiftLeft(125);
19      c.ShiftLeft(125);
20      EXPECT_EQ(a, b);
21      EXPECT_NE(a, c);
22    }
23    {
24      BigUnsigned<84> a(15u);
25      BigUnsigned<84> b(7u);
26      BigUnsigned<84> c(3u);
27      a.ShiftLeft(84 * 32 - 3);
28      b.ShiftLeft(84 * 32 - 3);
29      c.ShiftLeft(84 * 32 - 3);
30      EXPECT_EQ(a, b);
31      EXPECT_NE(a, c);
32    }
33    {
34      const std::string seed = "1234567890123456789012345678901234567890";
35      BigUnsigned<84> a(seed);
36      for (int i = 1; i <= 84 * 32; ++i) {
37        a.ShiftLeft(1);
38        BigUnsigned<84> b(seed);
39        b.ShiftLeft(i);
40        EXPECT_EQ(a, b);
41      }
42      EXPECT_EQ(a, BigUnsigned<84>(0u));
43    }
44    {
45      const BigUnsigned<84> all_bits_one(
46          "1474444211396924248063325089479706787923460402125687709454567433186613"
47          "6228083464060749874845919674257665016359189106695900028098437021384227"
48          "3285029708032466536084583113729486015826557532750465299832071590813090"
49          "2011853039837649252477307070509704043541368002938784757296893793903797"
50          "8180292336310543540677175225040919704702800559606097685920595947397024"
51          "8303316808753252115729411497720357971050627997031988036134171378490368"
52          "6008000778741115399296162550786288457245180872759047016734959330367829"
53          "5235612397427686310674725251378116268607113017720538636924549612987647"
54          "5767411074510311386444547332882472126067840027882117834454260409440463"
55          "9345147252664893456053258463203120637089916304618696601333953616715125"
56          "2115882482473279040772264257431663818610405673876655957323083702713344"
57          "4201105427930770976052393421467136557055");
58      const BigUnsigned<84> zero(0u);
59      const BigUnsigned<84> one(1u);
60      for (int i = 1; i < 84*32; ++i) {
61        BigUnsigned<84> big_shifted = all_bits_one;
62        big_shifted.ShiftLeft(i);
63        EXPECT_GT(all_bits_one, big_shifted);
64        BigUnsigned<84> small_shifted = one;
65        small_shifted.ShiftLeft(i);
66        EXPECT_LT(one, small_shifted);
67      }
68      for (int no_op_shift : {0, -1, -84 * 32, std::numeric_limits<int>::min()}) {
69        BigUnsigned<84> big_shifted = all_bits_one;
70        big_shifted.ShiftLeft(no_op_shift);
71        EXPECT_EQ(all_bits_one, big_shifted);
72        BigUnsigned<84> small_shifted = one;
73        big_shifted.ShiftLeft(no_op_shift);
74        EXPECT_EQ(one, small_shifted);
75      }
76      for (int out_of_bounds_shift :
77           {84 * 32, 84 * 32 + 1, std::numeric_limits<int>::max()}) {
78        BigUnsigned<84> big_shifted = all_bits_one;
79        big_shifted.ShiftLeft(out_of_bounds_shift);
80        EXPECT_EQ(zero, big_shifted);
81        BigUnsigned<84> small_shifted = one;
82        small_shifted.ShiftLeft(out_of_bounds_shift);
83        EXPECT_EQ(zero, small_shifted);
84      }
85    }
86  }
87  TEST(BigUnsigned, MultiplyByUint32) {
88    const BigUnsigned<84> factorial_100(
89        "933262154439441526816992388562667004907159682643816214685929638952175999"
90        "932299156089414639761565182862536979208272237582511852109168640000000000"
91        "00000000000000");
92    BigUnsigned<84> a(1u);
93    for (uint32_t i = 1; i <= 100; ++i) {
94      a.MultiplyBy(i);
95    }
96    EXPECT_EQ(a, BigUnsigned<84>(factorial_100));
97  }
98  TEST(BigUnsigned, MultiplyByBigUnsigned) {
99    {
100      const BigUnsigned<84> factorial_200(
101          "7886578673647905035523632139321850622951359776871732632947425332443594"
102          "4996340334292030428401198462390417721213891963883025764279024263710506"
103          "1926624952829931113462857270763317237396988943922445621451664240254033"
104          "2918641312274282948532775242424075739032403212574055795686602260319041"
105          "7032406235170085879617892222278962370389737472000000000000000000000000"
106          "0000000000000000000000000");
107      BigUnsigned<84> evens(1u);
108      BigUnsigned<84> odds(1u);
109      for (uint32_t i = 1; i < 200; i += 2) {
110        odds.MultiplyBy(i);
111        evens.MultiplyBy(i + 1);
112      }
113      evens.MultiplyBy(odds);
114      EXPECT_EQ(evens, factorial_200);
115    }
116    {
117      for (int a = 0 ; a < 700; a += 25) {
118        SCOPED_TRACE(a);
119        BigUnsigned<84> a_value("3" + std::string(a, '0'));
120        for (int b = 0; b < (700 - a); b += 25) {
121          SCOPED_TRACE(b);
122          BigUnsigned<84> b_value("2" + std::string(b, '0'));
123          BigUnsigned<84> expected_product("6" + std::string(a + b, '0'));
124          b_value.MultiplyBy(a_value);
125          EXPECT_EQ(b_value, expected_product);
<span onclick='openModal()' class='match'>126        }
127      }
128    }
129  }
130  TEST(BigUnsigned, MultiplyByOverflow) {
131    {
132      BigUnsigned<4> all_bits_on("340282366920938463463374607431768211455");
133      all_bits_on.MultiplyBy(all_bits_on);
134      EXPECT_EQ(all_bits_on, BigUnsigned<4>(1u));
135    }
136    {
137      BigUnsigned<4> value_1("12345678901234567890123456789012345678");
138      BigUnsigned<4> value_2("12345678901234567890123456789012345678");
</span>139      BigUnsigned<4> two_to_fiftieth(1u);
140      two_to_fiftieth.ShiftLeft(50);
141      value_1.ShiftLeft(50);
142      value_2.MultiplyBy(two_to_fiftieth);
143      EXPECT_EQ(value_1, value_2);
144    }
145  }
146  TEST(BigUnsigned, FiveToTheNth) {
147    {
148      for (int i = 0; i < 1160; ++i) {
149        SCOPED_TRACE(i);
150        BigUnsigned<84> value_1(123u);
151        BigUnsigned<84> value_2(123u);
152        value_1.MultiplyByFiveToTheNth(i);
153        for (int j = 0; j < i; j++) {
154          value_2.MultiplyBy(5u);
155        }
156        EXPECT_EQ(value_1, value_2);
157      }
158    }
159    {
160      for (int i = 0; i < 1160; ++i) {
161        SCOPED_TRACE(i);
162        BigUnsigned<84> value_1(1u);
163        value_1.MultiplyByFiveToTheNth(i);
164        BigUnsigned<84> value_2 = BigUnsigned<84>::FiveToTheNth(i);
165        EXPECT_EQ(value_1, value_2);
166      }
167    }
168  }
169  TEST(BigUnsigned, TenToTheNth) {
170    {
171      for (int i = 0; i < 800; ++i) {
172        SCOPED_TRACE(i);
173        BigUnsigned<84> value_1(123u);
174        BigUnsigned<84> value_2(123u);
175        value_1.MultiplyByTenToTheNth(i);
176        for (int j = 0; j < i; j++) {
177          value_2.MultiplyBy(10u);
178        }
179        EXPECT_EQ(value_1, value_2);
180      }
181    }
182    {
183      for (int i = 0; i < 200; ++i) {
184        SCOPED_TRACE(i);
185        BigUnsigned<84> value_1(135u);
186        value_1.MultiplyByTenToTheNth(i);
187        BigUnsigned<84> value_2("135" + std::string(i, '0'));
188        EXPECT_EQ(value_1, value_2);
189      }
190    }
191  }
192  }  
193  ABSL_NAMESPACE_END
194  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_softmax_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_bigint_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>62      }
63    }
64  }
65  TYPED_TEST(SoftmaxLayerTest, TestGradient) {
66    typedef typename TypeParam::Dtype Dtype;
67    LayerParameter layer_param;
68    SoftmaxLayer<Dtype> layer(layer_param);
69    GradientChecker<Dtype> checker(1e-2, 1e-3);
</pre></code></div>
                <div class="column column_space"><pre><code>126        }
127      }
128    }
129  }
130  TEST(BigUnsigned, MultiplyByOverflow) {
131    {
132      BigUnsigned<4> all_bits_on("340282366920938463463374607431768211455");
133      all_bits_on.MultiplyBy(all_bits_on);
134      EXPECT_EQ(all_bits_on, BigUnsigned<4>(1u));
135    }
136    {
137      BigUnsigned<4> value_1("12345678901234567890123456789012345678");
138      BigUnsigned<4> value_2("12345678901234567890123456789012345678");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    