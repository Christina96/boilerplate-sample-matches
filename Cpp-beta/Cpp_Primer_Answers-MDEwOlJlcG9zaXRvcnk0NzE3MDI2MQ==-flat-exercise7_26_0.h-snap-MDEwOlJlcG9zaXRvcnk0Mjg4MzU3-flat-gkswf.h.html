
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.037593984962406%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Cpp_Primer_Answers-MDEwOlJlcG9zaXRvcnk0NzE3MDI2MQ==-flat-exercise7_26_0.h</h3>
            <pre><code>1  #ifndef CP5_ex7_26_h
2  #define CP5_ex7_26_h
3  #include <string>
4  #include <iostream>
5  class Sales_data
6  {
<span onclick='openModal()' class='match'>7  	friend std::istream &read(std::istream &is, Sales_data &item);
8  	friend std::ostream &print(std::ostream &os, const Sales_data &item);
</span>9  	friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
10  public:
11  	Sales_data() = default;
12  	Sales_data(const std::string &s) :bookNo(s) {}
13  	Sales_data(const std::string &s, unsigned n, double p) :bookNo(s), units_sold(n), revenue(n*p) {}
14  	Sales_data(std::istream &is) { read(is, *this); }
15  	std::string isbn() const { return bookNo; };
16  	Sales_data& combine(const Sales_data&);
17  private:
18  	inline double avg_price() const;
19  private:
20  	std::string bookNo;
21  	unsigned units_sold = 0;
22  	double revenue = 0.0;
23  };
24  inline
25  double Sales_data::avg_price() const
26  {
27  	return units_sold ? revenue / units_sold : 0;
28  }
29  std::istream &read(std::istream &is, Sales_data &item);
30  std::ostream &print(std::ostream &os, const Sales_data &item);
31  Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
32  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gkswf.h</h3>
            <pre><code>1  #ifndef gkswf_h
2  #define gkswf_h
3  #include "gks.h"
4  #include <gdiplus.h>
5  class TWfGks: public TGks {
6  private:
<span onclick='openModal()' class='match'>7      mutable Gdiplus::Graphics* GdiGraphics;
8      mutable PGksPen GksPen;
9      mutable Gdiplus::Pen GdiPen;
10      mutable PGksBrush GksBrush;
11      mutable Gdiplus::Brush *GdiBrush;
12      mutable PGksFont GksFont;
13      mutable Gdiplus::Font *GdiFont;
14      mutable Gdiplus::Brush *GdiFontBrush;
15      mutable int Width;
16      mutable int Height;
</span>17  private:
18      Gdiplus::Color Gks2GdiColor(const TGksColor& GksCl) const {
19          return Gdiplus::Color(GksCl.GetAVal(), GksCl.GetRVal(), GksCl.GetGVal(), GksCl.GetBVal());
20      }
21      (Gdiplus::Point*) LoadTGksSPointV(const TGksSPointV& PointV) {
22          Gdiplus::Point *Pts = new Gdiplus::Point[PointV.Len()];
23          for (int PtC = 0; PtC < PointV.Len(); PtC++) {
24              Pts[PtC] = Gdiplus::Point(PointV[PtC].X, PointV[PtC].Y);
25          }
26          return Pts;
27      }
28      (WCHAR*) TStr2WCHAR(const TStr& Str) {
29          WCHAR *lpWideCharStr = new WCHAR[Str.Len()+1];
30          const int Res = MultiByteToWideChar(CP_ACP, 0, 
31              Str.CStr(), Str.Len()+1, lpWideCharStr, Str.Len()+1);
32          return lpWideCharStr;
33      }
34      void InvArgbP(const int Len, uint* ScanP) {
35          for (int Elt = 0; Elt < Len; Elt++) {
36              ScanP[Elt] = TGksColor::GetInvArgbVal(ScanP[Elt]);
37          }
38      }
39      void MeasureString(const TStr& Str, int& Width, int& Height) {
40          WCHAR *lpWideCharStr = TStr2WCHAR(Str);
41          Gdiplus::RectF layoutRect(0, 0, 2000, 2000), boundRect;
42          GdiGraphics->MeasureString(lpWideCharStr, 
43              Str.Len(), GdiFont, layoutRect, &boundRect);
44          Width = (int)ceil(boundRect.Width);
45          Height = (int)ceil(boundRect.Height);
46          delete lpWideCharStr;
47      }
48  public:
49      TWfGks(): GdiGraphics(NULL), GdiPen(Gdiplus::Color()), 
50          GdiBrush(new Gdiplus::SolidBrush(Gdiplus::Color(0,0,0))), 
51          GdiFontBrush(new Gdiplus::SolidBrush(Gdiplus::Color(0,0,0))), 
52          GdiFont(new Gdiplus::Font(L"ARIAL", 10, Gdiplus::FontStyleRegular, Gdiplus::UnitPixel, NULL)),
53          Width(0), Height(0) { };
54      static PGks New() { return new TWfGks(); }
55      ~TWfGks() { 
56          IAssert(GdiBrush != NULL); delete GdiBrush; 
57          IAssert(GdiFont != NULL); delete GdiFont; }
58      void BeginPaint(HDC Hdc = 0, HANDLE Handle = 0) const { 
59          IAssert(GdiGraphics == NULL);
60          if (Handle == 0) {
61              GdiGraphics = new Gdiplus::Graphics(Hdc);
62          } else {
63              GdiGraphics = new Gdiplus::Graphics(Hdc, Handle);
64          }
65          GdiGraphics->SetSmoothingMode(Gdiplus::SmoothingModeHighQuality);
66          Gdiplus::Rect boundRect;
67          GdiGraphics->GetVisibleClipBounds(&boundRect);
68          Width = boundRect.Width;
69          Height = boundRect.Height;
70      }
71      void EndPaint() const {
72          if (GdiGraphics != NULL)  delete GdiGraphics;
73          GdiGraphics = NULL;
74      }
75      int GetWidth() const { return Width; }
76      int GetHeight() const { return Height; }
77      void Clr() const {
78          Gdiplus::Rect boundRect;
79          GdiGraphics->GetVisibleClipBounds(&boundRect);
80          GdiGraphics->FillRectangle(
81              &Gdiplus::SolidBrush(Gdiplus::Color(255, 255, 255, 255)), boundRect);
82      }
83      void Inv() const { &bsol;* what is this? */ } 
84      void SetPen(const PGksPen& Pen){ 
85          GksPen = Pen;
86          GdiPen.SetColor(Gks2GdiColor(Pen->GetColor()));
87          GdiPen.SetWidth((Gdiplus::REAL)Pen->GetWidth());
88      }
89      PGksPen GetPen(){ return GksPen; }
90      void SetBrush(const PGksBrush& Brush){
91          GksBrush = Brush;      
92          ((Gdiplus::SolidBrush*)GdiBrush)->SetColor(
93              Gks2GdiColor(Brush->GetColor()));
94      }
95      PGksBrush GetBrush(){ return GksBrush; }
96      void SetFont(const PGksFont& Font){ 
97          GksFont = Font;
98          ((Gdiplus::SolidBrush*)GdiFontBrush)->SetColor(
99              Gks2GdiColor(Font->GetColor()));
100          IAssert(GdiFont != NULL); delete GdiFont;
101          GdiFont = new Gdiplus::Font(L"ARIAL", (float)Font->GetSize(), 
102              Font->GetStyle().In(gfsBold) ? Gdiplus::FontStyleBold : Gdiplus::FontStyleRegular, 
103              Gdiplus::UnitPixel, NULL);
104      }
105      PGksFont GetFont(){ return GksFont; }
106      void PutPixel(const int& X, const int& Y, const TGksColor& GksColor) { Fail; }
107      TGksColor GetPixel(const int& X, const int& Y) { Fail; return NULL; }
108      void Line(const int& X1, const int& Y1, const int& X2, const int& Y2) { 
109          GdiGraphics->DrawLine(&GdiPen, X1, Y1, X2, Y2);
110      }
111      void PolyLine(const TGksSPointV& PointV) { 
112          Gdiplus::Point* Pts = LoadTGksSPointV(PointV);
113          GdiGraphics->DrawLines(&GdiPen, Pts, PointV.Len());
114          delete[] Pts;
115      }
116      void Polygon(const TGksSPointV& PointV) {
117          Gdiplus::Point* Pts = LoadTGksSPointV(PointV);
118          GdiGraphics->DrawPolygon(&GdiPen, Pts, PointV.Len());
119          delete[] Pts;
120      }
121      void PolyBezier(const TGksSPointV& PointV) { 
122          Gdiplus::Point* Pts = LoadTGksSPointV(PointV);
123          GdiGraphics->DrawCurve(&GdiPen, Pts, PointV.Len());
124          delete[] Pts;
125      }
126      void FrameRect(const int& X1, const int& Y1, const int& X2, const int& Y2) { 
127          TGksSPointV PointV(5, 0);
128          PointV.Add(TGksSPoint(X1, Y1)); PointV.Add(TGksSPoint(X1, Y2));
129          PointV.Add(TGksSPoint(X2, Y2)); PointV.Add(TGksSPoint(X2, Y1));
130          PointV.Add(TGksSPoint(X1, Y1));
131          PolyLine(PointV);
132      }
133      void FillRect(const int& X1, const int& Y1, const int& X2, const int& Y2) {
134          const int x = TInt::GetMn(X1,X2), width = TInt::Abs(X1-X2);
135          const int y = TInt::GetMn(Y1,Y2), height = TInt::Abs(Y1-Y2);
136          GdiGraphics->FillRectangle(GdiBrush, x, y, width, height);
137      }
138      void Rectangle(const int& X1, const int& Y1, const int& X2, const int& Y2) {
139          const int x = TInt::GetMn(X1,X2), width = TInt::Abs(X1-X2);
140          const int y = TInt::GetMn(Y1,Y2), height = TInt::Abs(Y1-Y2);
141          GdiGraphics->FillRectangle(GdiBrush, x, y, width, height);
142          GdiGraphics->DrawRectangle(&GdiPen, x, y, width, height);
143      }
144      void RoundRect(const int& X1, const int& Y1, const int& X2, 
145              const int& Y2, const int& EWidthXX, const int& EHeightXX) {
146          const int EWidth = 5, EHeight = 5;
147          const int x = TInt::GetMn(X1,X2), width = TInt::Abs(X1-X2);
148          const int y = TInt::GetMn(Y1,Y2), height = TInt::Abs(Y1-Y2);
149          GdiGraphics->FillRectangle(GdiBrush, x+EWidth, y, width-2*EWidth, height); 
150          GdiGraphics->FillRectangle(GdiBrush, x, y+EHeight, width, height-2*EHeight); 
151          GdiGraphics->FillPie(GdiBrush, x, y, 2*EWidth, 2*EHeight, 180.0, 90.0);
152          GdiGraphics->FillPie(GdiBrush, x+width-2*EWidth, y, 2*EWidth, 2*EHeight, 270.0, 90.0);
153          GdiGraphics->FillPie(GdiBrush, x, y+height-2*EHeight, 2*EWidth, 2*EHeight, 90.0, 90.0);
154          GdiGraphics->FillPie(GdiBrush, x+width-2*EWidth, y+height-2*EHeight, 2*EWidth, 2*EHeight, 0.0, 90.0);
155          Line(x+EWidth, y, x + width - EWidth, y);
156          Line(x+EWidth, y+height, x + width - EWidth, y+height);
157          Line(x, y+EHeight, x, y + height - EHeight+1);
158          Line(x+width, y+EHeight, x+width, y + height - EHeight+1);
159          GdiGraphics->DrawArc(&GdiPen, x, y, 2*EWidth, 2*EHeight, 180.0, 90.0);
160          GdiGraphics->DrawArc(&GdiPen, x+width-2*EWidth, y, 2*EWidth, 2*EHeight, 270.0, 90.0);
161          GdiGraphics->DrawArc(&GdiPen, x, y+height-2*EHeight, 2*EWidth, 2*EHeight, 90.0, 90.0);
162          GdiGraphics->DrawArc(&GdiPen, x+width-2*EWidth, y+height-2*EHeight, 2*EWidth, 2*EHeight, 0.0, 90.0);
163      }
164      void Ellipse(const int& X1, const int& Y1, const int& X2, const int& Y2) {
165          const int x = TInt::GetMn(X1,X2), width = TInt::Abs(X1-X2);
166          const int y = TInt::GetMn(Y1,Y2), height = TInt::Abs(Y1-Y2);
167          GdiGraphics->DrawEllipse(&GdiPen, x, y, width, height);
168      }
169      void FillEllipse(const int& X1, const int& Y1, const int& X2, const int& Y2) {
170          const int x = TInt::GetMn(X1,X2), width = TInt::Abs(X1-X2);
171          const int y = TInt::GetMn(Y1,Y2), height = TInt::Abs(Y1-Y2);
172          GdiGraphics->FillEllipse(GdiBrush, x, y, width, height);
173      }
174      void Arc(const int& X1, const int& Y1, const int& X2, const int& Y2,
175          const int& X3, const int& Y3, const int& X4, const int& Y4) {
176          Fail;
177      }
178      void Bitmap(const PGksBitmap& Bmp, const int& X, const int& Y) {
179          const int Width = Bmp->GetWidth(), Height = Bmp->GetHeight();
180          uint* ScanP = Bmp->GetPixelV().BegI(); InvArgbP(Width*Height, ScanP);
181          Gdiplus::Bitmap* GdiBmp = new Gdiplus::Bitmap(Width, Height, 
182              sizeof(uint)*Width, PixelFormat32bppRGB, (BYTE*)ScanP);
183          GdiGraphics->DrawImage(GdiBmp, X, Y); 
184          delete GdiBmp; InvArgbP(Width*Height, ScanP); 
185      }
186      void Bitmap(const PGksBitmap& Bmp, const int& X1, 
187              const int& Y1, const int& X2, const int& Y2) {
188          const int Width = Bmp->GetWidth(), Height = Bmp->GetHeight();
189          uint* ScanP = Bmp->GetPixelV().BegI(); InvArgbP(Width*Height, ScanP);
190          Gdiplus::Bitmap* GdiBmp = new Gdiplus::Bitmap(Width, Height, 
191              sizeof(uint)*Width, PixelFormat32bppRGB, (BYTE*)ScanP);
192          Gdiplus::RectF GdiRectF(
193              (Gdiplus::REAL)TInt::GetMn(X1, X2), (Gdiplus::REAL)TInt::GetMn(Y1, Y2), 
194              (Gdiplus::REAL)TInt::Abs(X2 - X1),  (Gdiplus::REAL)TInt::Abs(Y2 - Y1));
195          GdiGraphics->DrawImage(GdiBmp, GdiRectF);
196          delete GdiBmp; InvArgbP(Width*Height, ScanP); 
197      }
198      int GetTxtWidth(const TStr& TxtStr) { 
199          int Width, Height; MeasureString(TxtStr, Width, Height); return Width; }
200      int GetTxtHeight(const TStr& TxtStr) {
201          int Width, Height; MeasureString(TxtStr, Width, Height); return Height; }
202      void PutTxt(const TStr& TxtStr, const int& X, const int& Y) { 
203          WCHAR *lpWideCharStr = TStr2WCHAR(TxtStr);
204          GdiGraphics->DrawString(lpWideCharStr, TxtStr.Len(), GdiFont, 
205              Gdiplus::PointF((float)X, (float)Y), GdiFontBrush);
206          delete lpWideCharStr;
207      }
208      void PutTxt(const TStr& TxtStr, const int& X, const int& Y, const TGksRect& ClipRect) { 
209          Gdiplus::RectF Rct((float)ClipRect.GetX1(), (float)ClipRect.GetX2(),
210              (float)ClipRect.GetXLen(), (float)ClipRect.GetYLen());
211          Gdiplus::StringFormat StrF;
212          WCHAR *lpWideCharStr = TStr2WCHAR(TxtStr);
213          GdiGraphics->DrawString(lpWideCharStr, TxtStr.Len(), 
214              GdiFont, Rct, &StrF, GdiFontBrush);
215          delete lpWideCharStr;
216      }
217  };
218  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Cpp_Primer_Answers-MDEwOlJlcG9zaXRvcnk0NzE3MDI2MQ==-flat-exercise7_26_0.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gkswf.h</div>
                </div>
                <div class="column column_space"><pre><code>7  	friend std::istream &read(std::istream &is, Sales_data &item);
8  	friend std::ostream &print(std::ostream &os, const Sales_data &item);
</pre></code></div>
                <div class="column column_space"><pre><code>7      mutable Gdiplus::Graphics* GdiGraphics;
8      mutable PGksPen GksPen;
9      mutable Gdiplus::Pen GdiPen;
10      mutable PGksBrush GksBrush;
11      mutable Gdiplus::Brush *GdiBrush;
12      mutable PGksFont GksFont;
13      mutable Gdiplus::Font *GdiFont;
14      mutable Gdiplus::Brush *GdiFontBrush;
15      mutable int Width;
16      mutable int Height;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    