
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.48074807480748%, Tokens: 34, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-voting.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/locks.hpp>
3  #include <nano/lib/numbers.hpp>
4  #include <nano/lib/processing_queue.hpp>
5  #include <nano/lib/utility.hpp>
6  #include <nano/node/wallet.hpp>
7  #include <nano/secure/common.hpp>
8  #include <boost/multi_index/hashed_index.hpp>
9  #include <boost/multi_index/member.hpp>
10  #include <boost/multi_index/ordered_index.hpp>
11  #include <boost/multi_index/sequenced_index.hpp>
12  #include <boost/multi_index_container.hpp>
13  #include <condition_variable>
14  #include <deque>
15  #include <thread>
16  namespace mi = boost::multi_index;
17  namespace nano
18  {
19  class ledger;
20  class network;
21  class node_config;
22  class stats;
23  class vote_processor;
24  class wallets;
25  namespace transport
26  {
27  	class channel;
28  }
29  class vote_spacing final
30  {
31  	class entry
32  	{
33  	public:
34  		nano::root root;
35  		std::chrono::steady_clock::time_point time;
36  		nano::block_hash hash;
37  	};
38  	boost::multi_index_container<entry,
39  	mi::indexed_by<
40  	mi::hashed_non_unique<mi::tag<class tag_root>,
41  	mi::member<entry, nano::root, &entry::root>>,
42  	mi::ordered_non_unique<mi::tag<class tag_time>,
43  	mi::member<entry, std::chrono::steady_clock::time_point, &entry::time>>>>
44  	recent;
45  	std::chrono::milliseconds const delay;
46  	void trim ();
47  public:
48  	vote_spacing (std::chrono::milliseconds const & delay) :
49  		delay{ delay }
50  	{
51  	}
52  	bool votable (nano::root const & root_a, nano::block_hash const & hash_a) const;
53  	void flag (nano::root const & root_a, nano::block_hash const & hash_a);
54  	std::size_t size () const;
55  };
56  class local_vote_history final
57  {
58  	class local_vote final
59  	{
60  	public:
61  		local_vote (nano::root const & root_a, nano::block_hash const & hash_a, std::shared_ptr<nano::vote> const & vote_a) :
62  			root (root_a),
63  			hash (hash_a),
64  			vote (vote_a)
65  		{
66  		}
67  		nano::root root;
68  		nano::block_hash hash;
69  		std::shared_ptr<nano::vote> vote;
70  	};
71  public:
72  	local_vote_history (nano::voting_constants const & constants) :
73  		constants{ constants }
74  	{
<span onclick='openModal()' class='match'>75  	}
76  	void add (nano::root const & root_a, nano::block_hash const & hash_a, std::shared_ptr<nano::vote> const & vote_a);
77  	void erase (nano::root const & root_a);
78  	std::vector<std::shared_ptr<nano::vote>> votes (nano::root const & root_a, nano::block_hash const & hash_a, bool const is_final_a = false) const;
79  	bool exists (nano::root const &) const;
80  	std::size_t size () const;
81  private:
82  	boost::multi_index_container<local_vote,
83  	mi::indexed_by<
84  		mi::hashed_non_unique<mi::tag<class tag_root>,
85  			mi::member<local_vote, nano::root, &local_vote::root>>,
86  		mi::sequenced<mi::tag<class tag_sequence>>>>
</span>87  	history;
88  	nano::voting_constants const & constants;
89  	void clean ();
90  	std::vector<std::shared_ptr<nano::vote>> votes (nano::root const & root_a) const;
91  	bool consistency_check (nano::root const &) const;
92  	mutable nano::mutex mutex;
93  	friend std::unique_ptr<container_info_component> collect_container_info (local_vote_history & history, std::string const & name);
94  	friend class local_vote_history_basic_Test;
95  };
96  std::unique_ptr<container_info_component> collect_container_info (local_vote_history & history, std::string const & name);
97  class vote_generator final
98  {
99  private:
100  	using candidate_t = std::pair<nano::root, nano::block_hash>;
101  	using request_t = std::pair<std::vector<candidate_t>, std::shared_ptr<nano::transport::channel>>;
102  	using queue_entry_t = std::pair<nano::root, nano::block_hash>;
103  public:
104  	vote_generator (nano::node_config const & config_a, nano::ledger & ledger_a, nano::wallets & wallets_a, nano::vote_processor & vote_processor_a, nano::local_vote_history & history_a, nano::network & network_a, nano::stats & stats_a, bool is_final_a);
105  	~vote_generator ();
106  	void add (nano::root const &, nano::block_hash const &);
107  	std::size_t generate (std::vector<std::shared_ptr<nano::block>> const & blocks_a, std::shared_ptr<nano::transport::channel> const & channel_a);
108  	void set_reply_action (std::function<void (std::shared_ptr<nano::vote> const &, std::shared_ptr<nano::transport::channel> const &)>);
109  	void start ();
110  	void stop ();
111  private:
112  	void run ();
113  	void broadcast (nano::unique_lock<nano::mutex> &);
114  	void reply (nano::unique_lock<nano::mutex> &, request_t &&);
115  	void vote (std::vector<nano::block_hash> const &, std::vector<nano::root> const &, std::function<void (std::shared_ptr<nano::vote> const &)> const &);
116  	void broadcast_action (std::shared_ptr<nano::vote> const &) const;
117  	void process_batch (std::deque<queue_entry_t> & batch);
118  	void process (nano::write_transaction const &, nano::root const &, nano::block_hash const &);
119  private:
120  	std::function<void (std::shared_ptr<nano::vote> const &, std::shared_ptr<nano::transport::channel> &)> reply_action; 
121  private: 
122  	nano::node_config const & config;
123  	nano::ledger & ledger;
124  	nano::wallets & wallets;
125  	nano::vote_processor & vote_processor;
126  	nano::local_vote_history & history;
127  	nano::vote_spacing spacing;
128  	nano::network & network;
129  	nano::stats & stats;
130  private:
131  	processing_queue<queue_entry_t> vote_generation_queue;
132  private:
133  	const bool is_final;
134  	mutable nano::mutex mutex;
135  	nano::condition_variable condition;
136  	static std::size_t constexpr max_requests{ 2048 };
137  	std::deque<request_t> requests;
138  	std::deque<candidate_t> candidates;
139  	std::atomic<bool> stopped{ false };
140  	std::thread thread;
141  	friend std::unique_ptr<container_info_component> collect_container_info (vote_generator & vote_generator, std::string const & name);
142  };
143  std::unique_ptr<container_info_component> collect_container_info (vote_generator & generator, std::string const & name);
144  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-arg.cc</h3>
            <pre><code>1  #include "absl/strings/internal/str_format/arg.h"
2  #include <cassert>
3  #include <cerrno>
4  #include <cstdlib>
5  #include <string>
6  #include <type_traits>
7  #include "absl/base/port.h"
8  #include "absl/strings/internal/str_format/float_conversion.h"
9  #include "absl/strings/numbers.h"
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace str_format_internal {
13  namespace {
14  void ReducePadding(string_view s, size_t *capacity) {
15    *capacity = Excess(s.size(), *capacity);
16  }
17  void ReducePadding(size_t n, size_t *capacity) {
18    *capacity = Excess(n, *capacity);
19  }
20  template <typename T>
21  struct MakeUnsigned : std::make_unsigned<T> {};
22  template <>
23  struct MakeUnsigned<absl::int128> {
24    using type = absl::uint128;
25  };
26  template <>
27  struct MakeUnsigned<absl::uint128> {
28    using type = absl::uint128;
29  };
30  template <typename T>
31  struct IsSigned : std::is_signed<T> {};
32  template <>
33  struct IsSigned<absl::int128> : std::true_type {};
34  template <>
35  struct IsSigned<absl::uint128> : std::false_type {};
36  class IntDigits {
37   public:
38    template <typename T>
39    void PrintAsOct(T v) {
40      static_assert(!IsSigned<T>::value, "");
41      char *p = storage_ + sizeof(storage_);
42      do {
43        *--p = static_cast<char>('0' + (static_cast<size_t>(v) & 7));
44        v >>= 3;
45      } while (v);
46      start_ = p;
47      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
48    }
49    template <typename T>
50    void PrintAsDec(T v) {
51      static_assert(std::is_integral<T>::value, "");
52      start_ = storage_;
53      size_ = static_cast<size_t>(numbers_internal::FastIntToBuffer(v, storage_) -
54                                  storage_);
55    }
56    void PrintAsDec(int128 v) {
57      auto u = static_cast<uint128>(v);
58      bool add_neg = false;
59      if (v < 0) {
60        add_neg = true;
61        u = uint128{} - u;
62      }
63      PrintAsDec(u, add_neg);
64    }
65    void PrintAsDec(uint128 v, bool add_neg = false) {
66      char *p = storage_ + sizeof(storage_);
67      do {
68        p -= 2;
69        numbers_internal::PutTwoDigits(static_cast<uint32_t>(v % 100), p);
70        v /= 100;
71      } while (v);
72      if (p[0] == '0') {
73        ++p;
74      }
75      if (add_neg) {
76        *--p = '-';
77      }
78      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
79      start_ = p;
80    }
81    template <typename T>
82    void PrintAsHexLower(T v) {
83      static_assert(!IsSigned<T>::value, "");
84      char *p = storage_ + sizeof(storage_);
85      do {
86        p -= 2;
87        constexpr const char* table = numbers_internal::kHexTable;
88        std::memcpy(p, table + 2 * (static_cast<size_t>(v) & 0xFF), 2);
89        if (sizeof(T) == 1) break;
90        v >>= 8;
91      } while (v);
92      if (p[0] == '0') {
93        ++p;
94      }
95      start_ = p;
96      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
97    }
98    template <typename T>
99    void PrintAsHexUpper(T v) {
100      static_assert(!IsSigned<T>::value, "");
101      char *p = storage_ + sizeof(storage_);
102      do {
103        *--p = "0123456789ABCDEF"[static_cast<size_t>(v) & 15];
104        v >>= 4;
105      } while (v);
106      start_ = p;
107      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
108    }
109    string_view with_neg_and_zero() const { return {start_, size_}; }
110    string_view without_neg_or_zero() const {
111      static_assert('-' < '0', "The check below verifies both.");
112      size_t advance = start_[0] <= '0' ? 1 : 0;
113      return {start_ + advance, size_ - advance};
114    }
115    bool is_negative() const { return start_[0] == '-'; }
116   private:
117    const char *start_;
118    size_t size_;
119    char storage_[128 / 3 + 1 + 1];
120  };
121  string_view BaseIndicator(const IntDigits &as_digits,
122                            const FormatConversionSpecImpl conv) {
123    bool alt = conv.has_alt_flag() ||
124               conv.conversion_char() == FormatConversionCharInternal::p;
125    bool hex = (conv.conversion_char() == FormatConversionCharInternal::x ||
126                conv.conversion_char() == FormatConversionCharInternal::X ||
127                conv.conversion_char() == FormatConversionCharInternal::p);
128    if (alt && hex && !as_digits.without_neg_or_zero().empty()) {
129      return conv.conversion_char() == FormatConversionCharInternal::X ? "0X"
130                                                                       : "0x";
131    }
132    return {};
133  }
134  string_view SignColumn(bool neg, const FormatConversionSpecImpl conv) {
135    if (conv.conversion_char() == FormatConversionCharInternal::d ||
136        conv.conversion_char() == FormatConversionCharInternal::i) {
137      if (neg) return "-";
138      if (conv.has_show_pos_flag()) return "+";
139      if (conv.has_sign_col_flag()) return " ";
140    }
141    return {};
142  }
143  bool ConvertCharImpl(char v,
144                       const FormatConversionSpecImpl conv,
145                       FormatSinkImpl* sink) {
146    size_t fill = 0;
147    if (conv.width() >= 0)
148      fill = static_cast<size_t>(conv.width());
149    ReducePadding(1, &fill);
150    if (!conv.has_left_flag()) sink->Append(fill, ' ');
151    sink->Append(1, v);
152    if (conv.has_left_flag()) sink->Append(fill, ' ');
153    return true;
154  }
155  bool ConvertIntImplInnerSlow(const IntDigits &as_digits,
156                               const FormatConversionSpecImpl conv,
157                               FormatSinkImpl *sink) {
158    size_t fill = 0;
159    if (conv.width() >= 0)
160      fill = static_cast<size_t>(conv.width());
161    string_view formatted = as_digits.without_neg_or_zero();
162    ReducePadding(formatted, &fill);
163    string_view sign = SignColumn(as_digits.is_negative(), conv);
164    ReducePadding(sign, &fill);
165    string_view base_indicator = BaseIndicator(as_digits, conv);
166    ReducePadding(base_indicator, &fill);
167    bool precision_specified = conv.precision() >= 0;
168    size_t precision =
169        precision_specified ? static_cast<size_t>(conv.precision()) : size_t{1};
170    if (conv.has_alt_flag() &&
171        conv.conversion_char() == FormatConversionCharInternal::o) {
172      if (formatted.empty() || *formatted.begin() != '0') {
173        size_t needed = formatted.size() + 1;
174        precision = std::max(precision, needed);
175      }
176    }
177    size_t num_zeroes = Excess(formatted.size(), precision);
178    ReducePadding(num_zeroes, &fill);
179    size_t num_left_spaces = !conv.has_left_flag() ? fill : 0;
180    size_t num_right_spaces = conv.has_left_flag() ? fill : 0;
181    if (!precision_specified && conv.has_zero_flag()) {
182      num_zeroes += num_left_spaces;
183      num_left_spaces = 0;
184    }
185    sink->Append(num_left_spaces, ' ');
186    sink->Append(sign);
187    sink->Append(base_indicator);
188    sink->Append(num_zeroes, '0');
189    sink->Append(formatted);
190    sink->Append(num_right_spaces, ' ');
191    return true;
192  }
193  template <typename T>
194  bool ConvertFloatArg(T v, FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
195    if (conv.conversion_char() == FormatConversionCharInternal::v) {
196      conv.set_conversion_char(FormatConversionCharInternal::g);
197    }
198    return FormatConversionCharIsFloat(conv.conversion_char()) &&
199           ConvertFloatImpl(v, conv, sink);
200  }
201  inline bool ConvertStringArg(string_view v, const FormatConversionSpecImpl conv,
202                               FormatSinkImpl *sink) {
203    if (conv.is_basic()) {
204      sink->Append(v);
205      return true;
206    }
207    return sink->PutPaddedString(v, conv.width(), conv.precision(),
208                                 conv.has_left_flag());
209  }
210  }  
211  bool ConvertBoolArg(bool v, FormatSinkImpl *sink) {
212    if (v) {
213      sink->Append("true");
214    } else {
215      sink->Append("false");
216    }
217    return true;
218  }
219  template <typename T>
220  bool ConvertIntArg(T v, FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
221    using U = typename MakeUnsigned<T>::type;
222    IntDigits as_digits;
223    switch (static_cast<uint8_t>(conv.conversion_char())) {
224      case static_cast<uint8_t>(FormatConversionCharInternal::c):
225        return ConvertCharImpl(static_cast<char>(v), conv, sink);
226      case static_cast<uint8_t>(FormatConversionCharInternal::o):
227        as_digits.PrintAsOct(static_cast<U>(v));
228        break;
229      case static_cast<uint8_t>(FormatConversionCharInternal::x):
230        as_digits.PrintAsHexLower(static_cast<U>(v));
231        break;
232      case static_cast<uint8_t>(FormatConversionCharInternal::X):
233        as_digits.PrintAsHexUpper(static_cast<U>(v));
234        break;
235      case static_cast<uint8_t>(FormatConversionCharInternal::u):
236        as_digits.PrintAsDec(static_cast<U>(v));
237        break;
238      case static_cast<uint8_t>(FormatConversionCharInternal::d):
239      case static_cast<uint8_t>(FormatConversionCharInternal::i):
240      case static_cast<uint8_t>(FormatConversionCharInternal::v):
241        as_digits.PrintAsDec(v);
242        break;
243      case static_cast<uint8_t>(FormatConversionCharInternal::a):
244      case static_cast<uint8_t>(FormatConversionCharInternal::e):
245      case static_cast<uint8_t>(FormatConversionCharInternal::f):
246      case static_cast<uint8_t>(FormatConversionCharInternal::g):
247      case static_cast<uint8_t>(FormatConversionCharInternal::A):
248      case static_cast<uint8_t>(FormatConversionCharInternal::E):
249      case static_cast<uint8_t>(FormatConversionCharInternal::F):
250      case static_cast<uint8_t>(FormatConversionCharInternal::G):
251        return ConvertFloatImpl(static_cast<double>(v), conv, sink);
252      default:
253        ABSL_ASSUME(false);
254    }
255    if (conv.is_basic()) {
256      sink->Append(as_digits.with_neg_and_zero());
257      return true;
258    }
259    return ConvertIntImplInnerSlow(as_digits, conv, sink);
<span onclick='openModal()' class='match'>260  }
261  template bool ConvertIntArg<char>(char v, FormatConversionSpecImpl conv,
262                                    FormatSinkImpl *sink);
263  template bool ConvertIntArg<signed char>(signed char v,
264                                           FormatConversionSpecImpl conv,
265                                           FormatSinkImpl *sink);
266  template bool ConvertIntArg<unsigned char>(unsigned char v,
267                                             FormatConversionSpecImpl conv,
268                                             FormatSinkImpl *sink);
269  template bool ConvertIntArg<short>(short v,  
270                                     FormatConversionSpecImpl conv,
271                                     FormatSinkImpl *sink);
272  template bool ConvertIntArg<unsigned short>(unsigned short v,  
273                                              FormatConversionSpecImpl conv,
274                                              FormatSinkImpl *sink);
275  template bool ConvertIntArg<int>(int v, FormatConversionSpecImpl conv,
276                                   FormatSinkImpl *sink);
277  template bool ConvertIntArg<unsigned int>(unsigned int v,
278                                            FormatConversionSpecImpl conv,
279                                            FormatSinkImpl *sink);
280  template bool ConvertIntArg<long>(long v,  
281                                    FormatConversionSpecImpl conv,
282                                    FormatSinkImpl *sink);
283  template bool ConvertIntArg<unsigned long>(unsigned long v,  
284                                             FormatConversionSpecImpl conv,
285                                             FormatSinkImpl *sink);
286  template bool ConvertIntArg<long long>(long long v,  
287                                         FormatConversionSpecImpl conv,
288                                         FormatSinkImpl *sink);
289  template bool ConvertIntArg<unsigned long long>(unsigned long long v,  
290                                                  FormatConversionSpecImpl conv,
291                                                  FormatSinkImpl *sink);
</span>292  StringConvertResult FormatConvertImpl(const std::string &v,
293                                        const FormatConversionSpecImpl conv,
294                                        FormatSinkImpl *sink) {
295    return {ConvertStringArg(v, conv, sink)};
296  }
297  StringConvertResult FormatConvertImpl(string_view v,
298                                        const FormatConversionSpecImpl conv,
299                                        FormatSinkImpl *sink) {
300    return {ConvertStringArg(v, conv, sink)};
301  }
302  ArgConvertResult<FormatConversionCharSetUnion(
303      FormatConversionCharSetInternal::s, FormatConversionCharSetInternal::p)>
304  FormatConvertImpl(const char *v, const FormatConversionSpecImpl conv,
305                    FormatSinkImpl *sink) {
306    if (conv.conversion_char() == FormatConversionCharInternal::p)
307      return {FormatConvertImpl(VoidPtr(v), conv, sink).value};
308    size_t len;
309    if (v == nullptr) {
310      len = 0;
311    } else if (conv.precision() < 0) {
312      len = std::strlen(v);
313    } else {
314      len = static_cast<size_t>(std::find(v, v + conv.precision(), '\0') - v);
315    }
316    return {ConvertStringArg(string_view(v, len), conv, sink)};
317  }
318  ArgConvertResult<FormatConversionCharSetInternal::p> FormatConvertImpl(
319      VoidPtr v, const FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
320    if (!v.value) {
321      sink->Append("(nil)");
322      return {true};
323    }
324    IntDigits as_digits;
325    as_digits.PrintAsHexLower(v.value);
326    return {ConvertIntImplInnerSlow(as_digits, conv, sink)};
327  }
328  FloatingConvertResult FormatConvertImpl(float v,
329                                          const FormatConversionSpecImpl conv,
330                                          FormatSinkImpl *sink) {
331    return {ConvertFloatArg(v, conv, sink)};
332  }
333  FloatingConvertResult FormatConvertImpl(double v,
334                                          const FormatConversionSpecImpl conv,
335                                          FormatSinkImpl *sink) {
336    return {ConvertFloatArg(v, conv, sink)};
337  }
338  FloatingConvertResult FormatConvertImpl(long double v,
339                                          const FormatConversionSpecImpl conv,
340                                          FormatSinkImpl *sink) {
341    return {ConvertFloatArg(v, conv, sink)};
342  }
343  CharConvertResult FormatConvertImpl(char v, const FormatConversionSpecImpl conv,
344                                      FormatSinkImpl *sink) {
345    return {ConvertIntArg(v, conv, sink)};
346  }
347  IntegralConvertResult FormatConvertImpl(signed char v,
348                                          const FormatConversionSpecImpl conv,
349                                          FormatSinkImpl *sink) {
350    return {ConvertIntArg(v, conv, sink)};
351  }
352  IntegralConvertResult FormatConvertImpl(unsigned char v,
353                                          const FormatConversionSpecImpl conv,
354                                          FormatSinkImpl *sink) {
355    return {ConvertIntArg(v, conv, sink)};
356  }
357  IntegralConvertResult FormatConvertImpl(short v,  
358                                          const FormatConversionSpecImpl conv,
359                                          FormatSinkImpl *sink) {
360    return {ConvertIntArg(v, conv, sink)};
361  }
362  IntegralConvertResult FormatConvertImpl(unsigned short v,  
363                                          const FormatConversionSpecImpl conv,
364                                          FormatSinkImpl *sink) {
365    return {ConvertIntArg(v, conv, sink)};
366  }
367  IntegralConvertResult FormatConvertImpl(int v,
368                                          const FormatConversionSpecImpl conv,
369                                          FormatSinkImpl *sink) {
370    return {ConvertIntArg(v, conv, sink)};
371  }
372  IntegralConvertResult FormatConvertImpl(unsigned v,
373                                          const FormatConversionSpecImpl conv,
374                                          FormatSinkImpl *sink) {
375    return {ConvertIntArg(v, conv, sink)};
376  }
377  IntegralConvertResult FormatConvertImpl(long v,  
378                                          const FormatConversionSpecImpl conv,
379                                          FormatSinkImpl *sink) {
380    return {ConvertIntArg(v, conv, sink)};
381  }
382  IntegralConvertResult FormatConvertImpl(unsigned long v,  
383                                          const FormatConversionSpecImpl conv,
384                                          FormatSinkImpl *sink) {
385    return {ConvertIntArg(v, conv, sink)};
386  }
387  IntegralConvertResult FormatConvertImpl(long long v,  
388                                          const FormatConversionSpecImpl conv,
389                                          FormatSinkImpl *sink) {
390    return {ConvertIntArg(v, conv, sink)};
391  }
392  IntegralConvertResult FormatConvertImpl(unsigned long long v,  
393                                          const FormatConversionSpecImpl conv,
394                                          FormatSinkImpl *sink) {
395    return {ConvertIntArg(v, conv, sink)};
396  }
397  IntegralConvertResult FormatConvertImpl(absl::int128 v,
398                                          const FormatConversionSpecImpl conv,
399                                          FormatSinkImpl *sink) {
400    return {ConvertIntArg(v, conv, sink)};
401  }
402  IntegralConvertResult FormatConvertImpl(absl::uint128 v,
403                                          const FormatConversionSpecImpl conv,
404                                          FormatSinkImpl *sink) {
405    return {ConvertIntArg(v, conv, sink)};
406  }
407  ABSL_INTERNAL_FORMAT_DISPATCH_OVERLOADS_EXPAND_();
408  }  
409  ABSL_NAMESPACE_END
410  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-voting.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-arg.cc</div>
                </div>
                <div class="column column_space"><pre><code>75  	}
76  	void add (nano::root const & root_a, nano::block_hash const & hash_a, std::shared_ptr<nano::vote> const & vote_a);
77  	void erase (nano::root const & root_a);
78  	std::vector<std::shared_ptr<nano::vote>> votes (nano::root const & root_a, nano::block_hash const & hash_a, bool const is_final_a = false) const;
79  	bool exists (nano::root const &) const;
80  	std::size_t size () const;
81  private:
82  	boost::multi_index_container<local_vote,
83  	mi::indexed_by<
84  		mi::hashed_non_unique<mi::tag<class tag_root>,
85  			mi::member<local_vote, nano::root, &local_vote::root>>,
86  		mi::sequenced<mi::tag<class tag_sequence>>>>
</pre></code></div>
                <div class="column column_space"><pre><code>260  }
261  template bool ConvertIntArg<char>(char v, FormatConversionSpecImpl conv,
262                                    FormatSinkImpl *sink);
263  template bool ConvertIntArg<signed char>(signed char v,
264                                           FormatConversionSpecImpl conv,
265                                           FormatSinkImpl *sink);
266  template bool ConvertIntArg<unsigned char>(unsigned char v,
267                                             FormatConversionSpecImpl conv,
268                                             FormatSinkImpl *sink);
269  template bool ConvertIntArg<short>(short v,  
270                                     FormatConversionSpecImpl conv,
271                                     FormatSinkImpl *sink);
272  template bool ConvertIntArg<unsigned short>(unsigned short v,  
273                                              FormatConversionSpecImpl conv,
274                                              FormatSinkImpl *sink);
275  template bool ConvertIntArg<int>(int v, FormatConversionSpecImpl conv,
276                                   FormatSinkImpl *sink);
277  template bool ConvertIntArg<unsigned int>(unsigned int v,
278                                            FormatConversionSpecImpl conv,
279                                            FormatSinkImpl *sink);
280  template bool ConvertIntArg<long>(long v,  
281                                    FormatConversionSpecImpl conv,
282                                    FormatSinkImpl *sink);
283  template bool ConvertIntArg<unsigned long>(unsigned long v,  
284                                             FormatConversionSpecImpl conv,
285                                             FormatSinkImpl *sink);
286  template bool ConvertIntArg<long long>(long long v,  
287                                         FormatConversionSpecImpl conv,
288                                         FormatSinkImpl *sink);
289  template bool ConvertIntArg<unsigned long long>(unsigned long long v,  
290                                                  FormatConversionSpecImpl conv,
291                                                  FormatSinkImpl *sink);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    