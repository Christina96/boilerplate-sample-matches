
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 28.401084010840112%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_H_
2  #define ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_H_
3  #include <cassert>
4  #include <cstdint>
5  #include <iosfwd>
6  #include "absl/base/config.h"
7  #include "absl/base/internal/raw_logging.h"
8  #include "absl/base/optimization.h"
9  #include "absl/strings/internal/cord_data_edge.h"
10  #include "absl/strings/internal/cord_internal.h"
11  #include "absl/strings/internal/cord_rep_flat.h"
12  #include "absl/strings/string_view.h"
13  #include "absl/types/span.h"
14  namespace absl {
15  ABSL_NAMESPACE_BEGIN
16  namespace cord_internal {
17  void SetCordBtreeExhaustiveValidation(bool do_exaustive_validation);
18  bool IsCordBtreeExhaustiveValidationEnabled();
19  class CordRepBtreeNavigator;
20  class CordRepBtree : public CordRep {
21   public:
22    enum class EdgeType { kFront, kBack };
23    static constexpr EdgeType kFront = EdgeType::kFront;
24    static constexpr EdgeType kBack = EdgeType::kBack;
25    static constexpr size_t kMaxCapacity = 6;
26    static constexpr size_t kMaxDepth = 12;
27    static constexpr int kMaxHeight = static_cast<int>(kMaxDepth - 1);
28    enum Action { kSelf, kCopied, kPopped };
29    struct OpResult {
30      CordRepBtree* tree;
31      Action action;
32    };
33    struct CopyResult {
34      CordRep* edge;
35      int height;
36    };
37    struct Position {
38      size_t index;
39      size_t n;
40    };
41    static CordRepBtree* Create(CordRep* rep);
42    static void Destroy(CordRepBtree* tree);
43    static void Delete(CordRepBtree* tree) { delete tree; }
44    using CordRep::Unref;
45    static void Unref(absl::Span<CordRep* const> edges);
46    static CordRepBtree* Append(CordRepBtree* tree, CordRep* rep);
47    static CordRepBtree* Prepend(CordRepBtree* tree, CordRep* rep);
48    static CordRepBtree* Append(CordRepBtree* tree, string_view data,
49                                size_t extra = 0);
50    static CordRepBtree* Prepend(CordRepBtree* tree, string_view data,
51                                 size_t extra = 0);
52    CordRep* SubTree(size_t offset, size_t n);
53    static CordRep* RemoveSuffix(CordRepBtree* tree, size_t n);
54    char GetCharacter(size_t offset) const;
55    bool IsFlat(absl::string_view* fragment) const;
56    bool IsFlat(size_t offset, size_t n, absl::string_view* fragment) const;
57    Span<char> GetAppendBuffer(size_t size);
58    static ExtractResult ExtractAppendBuffer(CordRepBtree* tree,
59                                             size_t extra_capacity = 1);
60    int height() const { return static_cast<int>(storage[0]); }
61    size_t begin() const { return static_cast<size_t>(storage[1]); }
62    size_t back() const { return static_cast<size_t>(storage[2]) - 1; }
63    size_t end() const { return static_cast<size_t>(storage[2]); }
64    size_t index(EdgeType edge) const {
65      return edge == kFront ? begin() : back();
66    }
67    size_t size() const { return end() - begin(); }
68    size_t capacity() const { return kMaxCapacity; }
69    inline CordRep* Edge(size_t index) const;
70    inline CordRep* Edge(EdgeType edge_type) const;
71    inline absl::Span<CordRep* const> Edges() const;
72    inline absl::Span<CordRep* const> Edges(size_t begin, size_t end) const;
73    inline absl::string_view Data(size_t index) const;
74    static bool IsValid(const CordRepBtree* tree, bool shallow = false);
75    static CordRepBtree* AssertValid(CordRepBtree* tree, bool shallow = true);
76    static const CordRepBtree* AssertValid(const CordRepBtree* tree,
77                                           bool shallow = true);
78    static void Dump(const CordRep* rep, std::ostream& stream);
79    static void Dump(const CordRep* rep, absl::string_view label,
80                     std::ostream& stream);
81    static void Dump(const CordRep* rep, absl::string_view label,
82                     bool include_contents, std::ostream& stream);
83    template <EdgeType edge_type>
84    inline OpResult AddEdge(bool owned, CordRep* edge, size_t delta);
85    template <EdgeType edge_type>
86    OpResult SetEdge(bool owned, CordRep* edge, size_t delta);
87    static CordRepBtree* New(int height = 0);
88    static CordRepBtree* New(CordRep* rep);
89    static CordRepBtree* New(CordRepBtree* front, CordRepBtree* back);
90    static CordRepBtree* Rebuild(CordRepBtree* tree);
91   private:
92    CordRepBtree() = default;
93    ~CordRepBtree() = default;
94    inline void InitInstance(int height, size_t begin = 0, size_t end = 0);
95    void set_begin(size_t begin) { storage[1] = static_cast<uint8_t>(begin); }
96    void set_end(size_t end) { storage[2] = static_cast<uint8_t>(end); }
97    size_t sub_fetch_begin(size_t n) {
98      storage[1] -= static_cast<uint8_t>(n);
99      return storage[1];
100    }
101    size_t fetch_add_end(size_t n) {
102      const uint8_t current = storage[2];
103      storage[2] = static_cast<uint8_t>(current + n);
104      return current;
105    }
106    Position IndexOf(size_t offset) const;
107    Position IndexBefore(size_t offset) const;
108    Position IndexOfLength(size_t n) const;
109    Position IndexBefore(Position front, size_t offset) const;
110    Position IndexBeyond(size_t offset) const;
111    template <EdgeType edge_type>
112    static CordRepBtree* NewLeaf(absl::string_view data, size_t extra);
113    CordRepBtree* CopyRaw(size_t new_length) const;
114    CordRepBtree* Copy() const;
115    CordRepBtree* CopyBeginTo(size_t end, size_t new_length) const;
116    static CordRepBtree* ConsumeBeginTo(CordRepBtree* tree, size_t end,
117                                        size_t new_length);
118    CordRepBtree* CopyToEndFrom(size_t begin, size_t new_length) const;
119    static CordRep* ExtractFront(CordRepBtree* tree);
120    static CordRepBtree* MergeTrees(CordRepBtree* left, CordRepBtree* right);
121    static CordRepBtree* CreateSlow(CordRep* rep);
122    static CordRepBtree* AppendSlow(CordRepBtree*, CordRep* rep);
123    static CordRepBtree* PrependSlow(CordRepBtree*, CordRep* rep);
124    static void Rebuild(CordRepBtree** stack, CordRepBtree* tree, bool consume);
125    inline void AlignBegin();
126    inline void AlignEnd();
127    template <EdgeType edge_type>
128    inline void Add(CordRep* rep);
129    template <EdgeType edge_type>
130    inline void Add(absl::Span<CordRep* const>);
131    template <EdgeType edge_type>
132    absl::string_view AddData(absl::string_view data, size_t extra);
<span onclick='openModal()' class='match'>133    template <EdgeType edge_type>
134    inline void SetEdge(CordRep* edge);
135    CopyResult CopyPrefix(size_t n, bool allow_folding = true);
136    CopyResult CopySuffix(size_t offset);
137    inline OpResult ToOpResult(bool owned);
</span>138    template <EdgeType edge_type>
139    static CordRepBtree* AddCordRep(CordRepBtree* tree, CordRep* rep);
140    template <EdgeType edge_type>
141    static CordRepBtree* AddData(CordRepBtree* tree, absl::string_view data,
142                                 size_t extra = 0);
143    template <EdgeType edge_type>
144    static CordRepBtree* Merge(CordRepBtree* dst, CordRepBtree* src);
145    Span<char> GetAppendBufferSlow(size_t size);
146    CordRep* edges_[kMaxCapacity];
147    friend class CordRepBtreeTestPeer;
148    friend class CordRepBtreeNavigator;
149  };
150  inline CordRepBtree* CordRep::btree() {
151    assert(IsBtree());
152    return static_cast<CordRepBtree*>(this);
153  }
154  inline const CordRepBtree* CordRep::btree() const {
155    assert(IsBtree());
156    return static_cast<const CordRepBtree*>(this);
157  }
158  inline void CordRepBtree::InitInstance(int height, size_t begin, size_t end) {
159    tag = BTREE;
160    storage[0] = static_cast<uint8_t>(height);
161    storage[1] = static_cast<uint8_t>(begin);
162    storage[2] = static_cast<uint8_t>(end);
163  }
164  inline CordRep* CordRepBtree::Edge(size_t index) const {
165    assert(index >= begin());
166    assert(index < end());
167    return edges_[index];
168  }
169  inline CordRep* CordRepBtree::Edge(EdgeType edge_type) const {
170    return edges_[edge_type == kFront ? begin() : back()];
171  }
172  inline absl::Span<CordRep* const> CordRepBtree::Edges() const {
173    return {edges_ + begin(), size()};
174  }
175  inline absl::Span<CordRep* const> CordRepBtree::Edges(size_t begin,
176                                                        size_t end) const {
177    assert(begin <= end);
178    assert(begin >= this->begin());
179    assert(end <= this->end());
180    return {edges_ + begin, static_cast<size_t>(end - begin)};
181  }
182  inline absl::string_view CordRepBtree::Data(size_t index) const {
183    assert(height() == 0);
184    return EdgeData(Edge(index));
185  }
186  inline CordRepBtree* CordRepBtree::New(int height) {
187    CordRepBtree* tree = new CordRepBtree;
188    tree->length = 0;
189    tree->InitInstance(height);
190    return tree;
191  }
192  inline CordRepBtree* CordRepBtree::New(CordRep* rep) {
193    CordRepBtree* tree = new CordRepBtree;
194    int height = rep->IsBtree() ? rep->btree()->height() + 1 : 0;
195    tree->length = rep->length;
196    tree->InitInstance(height, &bsol;*begin=*/0, &bsol;*end=*/1);
197    tree->edges_[0] = rep;
198    return tree;
199  }
200  inline CordRepBtree* CordRepBtree::New(CordRepBtree* front,
201                                         CordRepBtree* back) {
202    assert(front->height() == back->height());
203    CordRepBtree* tree = new CordRepBtree;
204    tree->length = front->length + back->length;
205    tree->InitInstance(front->height() + 1, &bsol;*begin=*/0, &bsol;*end=*/2);
206    tree->edges_[0] = front;
207    tree->edges_[1] = back;
208    return tree;
209  }
210  inline void CordRepBtree::Unref(absl::Span<CordRep* const> edges) {
211    for (CordRep* edge : edges) {
212      if (ABSL_PREDICT_FALSE(!edge->refcount.Decrement())) {
213        CordRep::Destroy(edge);
214      }
215    }
216  }
217  inline CordRepBtree* CordRepBtree::CopyRaw(size_t new_length) const {
218    CordRepBtree* tree = new CordRepBtree;
219    tree->length = new_length;
220    uint8_t* dst = &tree->tag;
221    const uint8_t* src = &tag;
222    const ptrdiff_t offset = src - reinterpret_cast<const uint8_t*>(this);
223    memcpy(dst, src, sizeof(CordRepBtree) - static_cast<size_t>(offset));
224    return tree;
225  }
226  inline CordRepBtree* CordRepBtree::Copy() const {
227    CordRepBtree* tree = CopyRaw(length);
228    for (CordRep* rep : Edges()) CordRep::Ref(rep);
229    return tree;
230  }
231  inline CordRepBtree* CordRepBtree::CopyToEndFrom(size_t begin,
232                                                   size_t new_length) const {
233    assert(begin >= this->begin());
234    assert(begin <= this->end());
235    CordRepBtree* tree = CopyRaw(new_length);
236    tree->set_begin(begin);
237    for (CordRep* edge : tree->Edges()) CordRep::Ref(edge);
238    return tree;
239  }
240  inline CordRepBtree* CordRepBtree::CopyBeginTo(size_t end,
241                                                 size_t new_length) const {
242    assert(end <= capacity());
243    assert(end >= this->begin());
244    CordRepBtree* tree = CopyRaw(new_length);
245    tree->set_end(end);
246    for (CordRep* edge : tree->Edges()) CordRep::Ref(edge);
247    return tree;
248  }
249  inline void CordRepBtree::AlignBegin() {
250    const size_t delta = begin();
251    if (ABSL_PREDICT_FALSE(delta != 0)) {
252      const size_t new_end = end() - delta;
253      set_begin(0);
254      set_end(new_end);
255      ABSL_ASSUME(new_end <= kMaxCapacity);
256  #ifdef __clang__
257  #pragma unroll 1
258  #endif
259      for (size_t i = 0; i < new_end; ++i) {
260        edges_[i] = edges_[i + delta];
261      }
262    }
263  }
264  inline void CordRepBtree::AlignEnd() {
265    const size_t delta = capacity() - end();
266    if (delta != 0) {
267      const size_t new_begin = begin() + delta;
268      const size_t new_end = end() + delta;
269      set_begin(new_begin);
270      set_end(new_end);
271      ABSL_ASSUME(new_end <= kMaxCapacity);
272  #ifdef __clang__
273  #pragma unroll 1
274  #endif
275      for (size_t i = new_end - 1; i >= new_begin; --i) {
276        edges_[i] = edges_[i - delta];
277      }
278    }
279  }
280  template <>
281  inline void CordRepBtree::Add<CordRepBtree::kBack>(CordRep* rep) {
282    AlignBegin();
283    edges_[fetch_add_end(1)] = rep;
284  }
285  template <>
286  inline void CordRepBtree::Add<CordRepBtree::kBack>(
287      absl::Span<CordRep* const> edges) {
288    AlignBegin();
289    size_t new_end = end();
290    for (CordRep* edge : edges) edges_[new_end++] = edge;
291    set_end(new_end);
292  }
293  template <>
294  inline void CordRepBtree::Add<CordRepBtree::kFront>(CordRep* rep) {
295    AlignEnd();
296    edges_[sub_fetch_begin(1)] = rep;
297  }
298  template <>
299  inline void CordRepBtree::Add<CordRepBtree::kFront>(
300      absl::Span<CordRep* const> edges) {
301    AlignEnd();
302    size_t new_begin = begin() - edges.size();
303    set_begin(new_begin);
304    for (CordRep* edge : edges) edges_[new_begin++] = edge;
305  }
306  template <CordRepBtree::EdgeType edge_type>
307  inline void CordRepBtree::SetEdge(CordRep* edge) {
308    const int idx = edge_type == kFront ? begin() : back();
309    CordRep::Unref(edges_[idx]);
310    edges_[idx] = edge;
311  }
312  inline CordRepBtree::OpResult CordRepBtree::ToOpResult(bool owned) {
313    return owned ? OpResult{this, kSelf} : OpResult{Copy(), kCopied};
314  }
315  inline CordRepBtree::Position CordRepBtree::IndexOf(size_t offset) const {
316    assert(offset < length);
317    size_t index = begin();
318    while (offset >= edges_[index]->length) offset -= edges_[index++]->length;
319    return {index, offset};
320  }
321  inline CordRepBtree::Position CordRepBtree::IndexBefore(size_t offset) const {
322    assert(offset > 0);
323    assert(offset <= length);
324    size_t index = begin();
325    while (offset > edges_[index]->length) offset -= edges_[index++]->length;
326    return {index, offset};
327  }
328  inline CordRepBtree::Position CordRepBtree::IndexBefore(Position front,
329                                                          size_t offset) const {
330    size_t index = front.index;
331    offset = offset + front.n;
332    while (offset > edges_[index]->length) offset -= edges_[index++]->length;
333    return {index, offset};
334  }
335  inline CordRepBtree::Position CordRepBtree::IndexOfLength(size_t n) const {
336    assert(n <= length);
337    size_t index = back();
338    size_t strip = length - n;
339    while (strip >= edges_[index]->length) strip -= edges_[index--]->length;
340    return {index, edges_[index]->length - strip};
341  }
342  inline CordRepBtree::Position CordRepBtree::IndexBeyond(
343      const size_t offset) const {
344    size_t off = 0;
345    size_t index = begin();
346    while (offset > off) off += edges_[index++]->length;
347    return {index, off - offset};
348  }
349  inline CordRepBtree* CordRepBtree::Create(CordRep* rep) {
350    if (IsDataEdge(rep)) return New(rep);
351    return CreateSlow(rep);
352  }
353  inline Span<char> CordRepBtree::GetAppendBuffer(size_t size) {
354    assert(refcount.IsOne());
355    CordRepBtree* tree = this;
356    const int height = this->height();
357    CordRepBtree* n1 = tree;
358    CordRepBtree* n2 = tree;
359    CordRepBtree* n3 = tree;
360    switch (height) {
361      case 3:
362        tree = tree->Edge(kBack)->btree();
363        if (!tree->refcount.IsOne()) return {};
364        n2 = tree;
365        ABSL_FALLTHROUGH_INTENDED;
366      case 2:
367        tree = tree->Edge(kBack)->btree();
368        if (!tree->refcount.IsOne()) return {};
369        n1 = tree;
370        ABSL_FALLTHROUGH_INTENDED;
371      case 1:
372        tree = tree->Edge(kBack)->btree();
373        if (!tree->refcount.IsOne()) return {};
374        ABSL_FALLTHROUGH_INTENDED;
375      case 0:
376        CordRep* edge = tree->Edge(kBack);
377        if (!edge->refcount.IsOne()) return {};
378        if (edge->tag < FLAT) return {};
379        size_t avail = edge->flat()->Capacity() - edge->length;
380        if (avail == 0) return {};
381        size_t delta = (std::min)(size, avail);
382        Span<char> span = {edge->flat()->Data() + edge->length, delta};
383        edge->length += delta;
384        switch (height) {
385          case 3:
386            n3->length += delta;
387            ABSL_FALLTHROUGH_INTENDED;
388          case 2:
389            n2->length += delta;
390            ABSL_FALLTHROUGH_INTENDED;
391          case 1:
392            n1->length += delta;
393            ABSL_FALLTHROUGH_INTENDED;
394          case 0:
395            tree->length += delta;
396            return span;
397        }
398        break;
399    }
400    return GetAppendBufferSlow(size);
401  }
402  extern template CordRepBtree* CordRepBtree::AddCordRep<CordRepBtree::kBack>(
403      CordRepBtree* tree, CordRep* rep);
404  extern template CordRepBtree* CordRepBtree::AddCordRep<CordRepBtree::kFront>(
405      CordRepBtree* tree, CordRep* rep);
406  inline CordRepBtree* CordRepBtree::Append(CordRepBtree* tree, CordRep* rep) {
407    if (ABSL_PREDICT_TRUE(IsDataEdge(rep))) {
408      return CordRepBtree::AddCordRep<kBack>(tree, rep);
409    }
410    return AppendSlow(tree, rep);
411  }
412  inline CordRepBtree* CordRepBtree::Prepend(CordRepBtree* tree, CordRep* rep) {
413    if (ABSL_PREDICT_TRUE(IsDataEdge(rep))) {
414      return CordRepBtree::AddCordRep<kFront>(tree, rep);
415    }
416    return PrependSlow(tree, rep);
417  }
418  #ifdef NDEBUG
419  inline CordRepBtree* CordRepBtree::AssertValid(CordRepBtree* tree,
420                                                 bool &bsol;* shallow */) {
421    return tree;
422  }
423  inline const CordRepBtree* CordRepBtree::AssertValid(const CordRepBtree* tree,
424                                                       bool &bsol;* shallow */) {
425    return tree;
426  }
427  #endif
428  }  
429  ABSL_NAMESPACE_END
430  }  
431  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.h</h3>
            <pre><code>1  class TCrossValid {
2  public:
3      static void PrepareFolds(const int& Folds, TIntV& DIdV, const int& Seed,
4          TVec<TIntV>& DIdVFoldV);
5      static void PrepareSplit(const int& FoldN, const TVec<TIntV>& DIdVFoldV,
6          TIntV& TrainSubDIdV, TIntV& TestSubDIdV);
7    static void PrepareSubDIdV(const TIntV& SubSet, const int& DataSetLen, TIntV& DIdV);
8  };
9  class TSparseTrainSet : public TSVMTrainSet {
10  private:
11      static bool IsReg;
12      static bool MkReg(){return TSVMTrainSet::Reg(TTypeNm<TSparseTrainSet>(), &Load);}
13  private:
14      TInt MaxDim; 
15      TFltV ClsV, NormV;
16      TVec<TIntFltKdV> TrainV;
17      TSparseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
18          const TFltV& _NormV, const TVec<TIntFltKdV>& _TrainV);
19      static PSVMTrainSet New(const TIntV& VecIdV, const int& _MaxDim,
20          const TFltV& _ClsV, const TFltV& _NormV, const TVec<TIntFltKdV>& _TrainV) {
21              return new TSparseTrainSet(VecIdV, _MaxDim, _ClsV, _NormV, _TrainV); }
22  public:
23      TSparseTrainSet(const int& PredSize = 0):
24        TSVMTrainSet(ststSparse), MaxDim(0), ClsV(PredSize, 0),
25        NormV(PredSize, 0), TrainV(PredSize, 0) { };
26      static PSVMTrainSet New(const int& PredSize = 0) {
27          return new TSparseTrainSet(PredSize); }
28      TSparseTrainSet(TSIn& SIn): TSVMTrainSet(SIn) {
29          MaxDim.Load(SIn); ClsV.Load(SIn); NormV.Load(SIn); TrainV.Load(SIn); }
30      static PSVMTrainSet Load(TSIn& SIn) { return new TSparseTrainSet(SIn); }
31      void Save(TSOut& SOut) const {
32          TSVMTrainSet::Save(SOut); MaxDim.Save(SOut);
33          ClsV.Save(SOut); NormV.Save(SOut); TrainV.Save(SOut); }
34      void SaveTxt(const TStr& OutFNm) const;
35      void SaveMatlab(const TStr& OutFNm) const;
36      int Len() const { return ClsV.Len(); }
37      int Dim() const { return MaxDim; }
38      double GetNorm2(const int& VecId) const { return NormV[VecId]; }
39      double GetVecParam(const int& VecId) const { return ClsV[VecId]; }
40      double DotProduct(const int& VecId1, const int& VecId2) const {
41          return TLinAlg::DotProduct(TrainV[VecId1], TrainV[VecId2]); }
42      double DotProduct(const int& VecId1, double* vec2, const int& n) const;
43      double DotProduct(const int& VecId1, const TFltV& vec2) const {
44          return TLinAlg::DotProduct(vec2, TrainV[VecId1]); }
45      void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const;
46      void AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
47          TLinAlg::AddVec(K, TrainV[VecId1], vec2); }
48      PSVMTrainSet Clone(const TIntV& VecIdV) const {
49          return TSparseTrainSet::New(VecIdV, MaxDim, ClsV, NormV, TrainV); }
50      int AddAttrV(const TIntFltKdV& AttrV, const double& Cls, const bool& Normalize);
51      const TIntFltKdV& GetAttrSparseV(const int& VecId) const { return TrainV[VecId]; }
52      void RemoveAttrV(const int& VecId) {
53          ClsV.Del(VecId); NormV.Del(VecId); TrainV.Del(VecId); }
54      void SetVecParam(const int& VecId, const double& Cls) { ClsV[VecId] = Cls; }
55      double DotProduct(const int& VecId1, const TIntFltKdV& Vec2) const {
56          return TLinAlg::DotProduct(TrainV[VecId1], Vec2); }
57      void Shuffle(TRnd& Rnd);
58      static PSVMTrainSet LoadTxt(PSIn SIn, const bool& Normalize, const int& verbosity = 1);
59      static PSVMTrainSet LoadTxt(const TStr& fname, const bool& Normalize,
60          const int& verbosity = 1) { return LoadTxt(TFIn::New(fname), Normalize, verbosity); }
61  };
62  class TDenseTrainSet : public TSVMTrainSet {
63  private:
64      static bool IsReg;
65      static bool MkReg(){return TSVMTrainSet::Reg(TTypeNm<TDenseTrainSet>(), &Load);}
66  private:
67      TInt MaxDim; 
68      TFltV ClsV, NormV;
69      TVec<TFltV> TrainV;
70      TDenseTrainSet(const TIntV& VecIdV, const int& _MaxDim,
71          const TFltV& _ClsV, const TFltV& _NormV, const TVec<TFltV>& _TrainV);
72      static PSVMTrainSet New(const TIntV& VecIdV, const int& _MaxDim,
73          const TFltV& _ClsV, const TFltV& _NormV, const TVec<TFltV>& _TrainV) {
74              return new TDenseTrainSet(VecIdV, _MaxDim, _ClsV, _NormV, _TrainV); }
75  public:
76      TDenseTrainSet(const int& PredSize = 0):
77          TSVMTrainSet(ststDense), MaxDim(0), ClsV(PredSize, 0),
78          NormV(PredSize, 0), TrainV(PredSize, 0) { }
79      static PSVMTrainSet New(const int& PredSize = 0) {
80          return new TDenseTrainSet(PredSize); }
81      static PSVMTrainSet LoadFromSparse(PSVMTrainSet SparseSet);
82      TDenseTrainSet(TSIn& SIn): TSVMTrainSet(SIn) {
83          MaxDim.Load(SIn); ClsV.Load(SIn); NormV.Load(SIn); TrainV.Load(SIn); }
84      static PSVMTrainSet Load(TSIn& SIn) { return new TDenseTrainSet(SIn); }
85      void Save(TSOut& SOut) const {
86          TSVMTrainSet::Save(SOut); MaxDim.Save(SOut);
87          ClsV.Save(SOut); NormV.Save(SOut); TrainV.Save(SOut); }
88      void SaveTxt(const TStr& OutFNm) const;
89      int Len() const { return ClsV.Len(); }
90      int Dim() const { return MaxDim; }
91      double GetNorm2(const int& VecId) const { return NormV[VecId]; }
92      double GetVecParam(const int& VecId) const { return ClsV[VecId]; }
93      double DotProduct(const int& VecId1, const int& VecId2) const {
94          return TLinAlg::DotProduct(TrainV[VecId1], TrainV[VecId2]); }
95      double DotProduct(const int& VecId1, double* vec2, const int& n) const;
96      double DotProduct(const int& VecId1, const TFltV& vec2) const {
97          return TLinAlg::DotProduct(TrainV[VecId1], vec2); }
98      void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const;
99      void AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
100          TLinAlg::AddVec(K, TrainV[VecId1], vec2, vec2); }
101      PSVMTrainSet Clone(const TIntV& VecIdV) const {
102          return TDenseTrainSet::New(VecIdV, MaxDim, ClsV, NormV, TrainV); }
103      int AddAttrV(const TFltV& AttrV, const double& Cls, const bool& Normalize);
104      const TFltV& GetAttrDenseV(const int& VecId) const { return TrainV[VecId]; }
105      void RemoveAttrV(const int& VecId) {
106          ClsV.Del(VecId); NormV.Del(VecId); TrainV.Del(VecId); }
107      void SetVecParam(const int& VecId, const double& Cls) { ClsV[VecId] = Cls; }
108      double DotProduct(const int& VecId1, const TIntFltKdV& Vec2) const {
109          return TLinAlg::DotProduct(TrainV[VecId1], Vec2); }
110      void Shuffle(TRnd& Rnd);
111      static PSVMTrainSet LoadTxt(PSIn SIn, const bool& Normalize, const int& verbosity = 1) {
112          PSVMTrainSet SparseSet = TSparseTrainSet::LoadTxt(SIn, Normalize, verbosity);
113          return TDenseTrainSet::LoadFromSparse(SparseSet); }
114      static PSVMTrainSet LoadTxt(const TStr& fname, const bool& Normalize,
115          const int& verbosity = 1) { return LoadTxt(TFIn::New(fname), Normalize, verbosity); }
116      static PSVMTrainSet ProjectLin(PSVMTrainSet Set, const TFltVV& Basis,
117          const bool& Normalize, const int& NewDim = -1);
118      static PSVMTrainSet ProjectLin(PSVMTrainSet Set, const TVec<TFltV>& Basis,
119          const bool& Normalize, const int& NewDim = -1);
120  };
121  class TBowTrainSet: public TSVMTrainSet {
122  private:
123      static bool IsReg;
124      static bool MkReg(){return TSVMTrainSet::Reg(TTypeNm<TBowTrainSet>(), &Load);}
125  private:
126      TInt MaxDim;
127      TIntV DIdV;
128      TVec<PBowSpV> TrainV;
129      TFltV ClsV;
130      TBowTrainSet(const TIntV& VecIdV, const int& _MaxDim,
131          const TIntV& _DIdV, const TVec<PBowSpV>& _TrainV, const TFltV& _ClsV);
132      static PSVMTrainSet New(const TIntV& VecIdV, const int& _MaxDim,
133          const TIntV& _DIdV, const TVec<PBowSpV>& _TrainV, const TFltV& _ClsV) {
134              return new TBowTrainSet(VecIdV, _MaxDim, _DIdV, _TrainV, _ClsV); }
135  public:
136      TBowTrainSet(const int& PredSize = 0): TSVMTrainSet(ststBow), MaxDim(0),
137        DIdV(PredSize, 0), TrainV(PredSize, 0), ClsV(PredSize, 0) {};
138      static PSVMTrainSet New(const int& PredSize = 0) { return new TBowTrainSet(PredSize); }
139      TBowTrainSet(TSIn& SIn): TSVMTrainSet(SIn) {
140          MaxDim.Load(SIn); DIdV.Load(SIn); TrainV.Load(SIn); ClsV.Load(SIn); }
141      static PSVMTrainSet Load(TSIn& SIn) { return new TBowTrainSet(SIn); }
142      void Save(TSOut& SOut) const {
143          TSVMTrainSet::Save(SOut); MaxDim.Save(SOut);
144          DIdV.Save(SOut); TrainV.Save(SOut); ClsV.Save(SOut); }
145      void SaveTxt(const TStr& OutFNm) const;
146      int Len() const { return TrainV.Len(); }
147      int Dim() const { return MaxDim; }
148      double GetNorm2(const int& VecId) const {
149          return TMath::Sqr(TrainV[VecId]->GetNorm()); }
150      double GetVecParam(const int& VecId) const { return ClsV[VecId]; }
151      double DotProduct(const int& VecId1, const int& VecId2) const {
152          return TBowLinAlg::DotProduct(TrainV[VecId1], TrainV[VecId2]); }
153      double DotProduct(const int& VecId1, double* vec2, const int& n) const;
154      double DotProduct(const int& VecId1, const TFltV& vec2) const {
155          return TBowLinAlg::DotProduct(vec2, TrainV[VecId1]); }
<span onclick='openModal()' class='match'>156    void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const;
157    void AddVec(const int& VecId1, TFltV& vec2, const double& K) const;
</span>158      PSVMTrainSet Clone(const TIntV& VecIdV) const {
159          return TBowTrainSet::New(VecIdV, MaxDim, DIdV, TrainV, ClsV); }
160      int AddAttrV(const int& DId, PBowSpV SpVec, const double& Cls);
161      PBowSpV GetAttrBowV(const int& VecId) const { return TrainV[VecId]; }
162      int GetVecDId(const int& VecId) const { return DIdV[VecId]; }
163      void RemoveAttrV(const int& VecId) {
164          DIdV.Del(VecId); TrainV.Del(VecId); ClsV.Del(VecId); }
165      void SetVecParam(const int& VecId, const double& Cls) { ClsV[VecId] = Cls; }
166      double DotProduct(const int& VecId1, PBowSpV Vec2) const {
167          return TBowLinAlg::DotProduct(TrainV[VecId1], Vec2); }
168      void Shuffle(TRnd& Rnd);
169  };
170  class TStringTrainSet : public TSVMTrainSet {
171  private:
172      static bool IsReg;
173      static bool MkReg(){return TSVMTrainSet::Reg(TTypeNm<TStringTrainSet>(), &Load);}
174  private:
175      TFltV ClsV, NormV;
176      TVec<TIntV> TrainV;
177      PStrParser Parser;
178      TInt AlphN; 
179      PStringKernel StrKer;
180      void UpdateAlphN(const TIntV& Vec);
181      TStringTrainSet(const TIntV& VecIdV, const TFltV& _ClsV,
182          const TFltV& _NormV, const TVec<TIntV>& _TrainV, PStrParser _Parser,
183          const int& _AlphN, PStringKernel _StrKer);
184      static PSVMTrainSet New(const TIntV& VecIdV, const TFltV& _ClsV,
185          const TFltV& _NormV, const TVec<TIntV>& _TrainV, PStrParser _Parser,
186          const int& _AlphN, PStringKernel _StrKer) {
187              return new TStringTrainSet(VecIdV, _ClsV, _NormV,
188                  _TrainV, _Parser, _AlphN, _StrKer); }
189  public:
190      TStringTrainSet(PStrParser _Parser, PStringKernel _StrKer, const int& PredSize = 0):
191          TSVMTrainSet(ststString), ClsV(PredSize, 0), NormV(PredSize, 0),
192          TrainV(PredSize, 0), Parser(_Parser), AlphN(_Parser->GetWords()),
193          StrKer(_StrKer) { }
194      static PSVMTrainSet New(PStrParser _Parser, PStringKernel _StrKer,
195          const int& PredSize = 0) { return new TStringTrainSet(_Parser, _StrKer, PredSize); }
196      TStringTrainSet(TSIn& SIn): TSVMTrainSet(SIn) {
197          ClsV.Load(SIn); NormV.Load(SIn); TrainV.Load(SIn);
198          Parser = TStrParser::Load(SIn); AlphN.Load(SIn);
199          StrKer = TStringKernel::Load(SIn); }
200      static PSVMTrainSet Load(TSIn& SIn) { return new TStringTrainSet(SIn); }
201      void Save(TSOut& SOut) const {
202          TSVMTrainSet::Save(SOut); ClsV.Save(SOut); NormV.Save(SOut);
203          TrainV.Save(SOut); Parser->Save(SOut); AlphN.Save(SOut);
204          StrKer->Save(SOut); }
205      int Len() const { return ClsV.Len(); }
206      int Dim() const { return 1; } 
207      double GetNorm2(const int& VecId) const { return 1.0; } 
208      double GetVecParam(const int& VecId) const { return ClsV[VecId]; }
209      double DotProduct(const int& VecId1, const int& VecId2) const {
210          return StrKer->CalcKernel(TrainV[VecId1], TrainV[VecId2]) /
211                  sqrt(NormV[VecId1] * NormV[VecId2]); }
212      double DotProduct(const int& VecId1, double* vec2, const int& n) const  {
213          Fail; return 0.0; } 
214      double DotProduct(const int& VecId1, const TFltV& vec2) const {
215          Fail; return 0.0; } 
216      void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const {
217          Fail; } 
218      void AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
219          Fail; } 
220      PSVMTrainSet Clone(const TIntV& VecIdV) const {
221          return TStringTrainSet::New(VecIdV, ClsV, NormV, TrainV, Parser, AlphN, StrKer); }
222      int AddAttrV(const TStr& AttrV, const double& Cls);
223      int AddAttrV(const TIntV& AttrV, const double& Cls);
224      const TIntV& GetAttrStringV(const int& VecId) const { return TrainV[VecId]; }
225      void RemoveAttrV(const int& VecId) {
226          ClsV.Del(VecId); NormV.Del(VecId); TrainV.Del(VecId); }
227      void SetVecParam(const int& VecId, const double& Cls) { ClsV[VecId] = Cls; }
228      double DotProduct(const int& VecId1, const TStr& Vec2) const;
229      double DotProduct(const int& VecId1, const TIntV& Vec2) const;
230      void Shuffle(TRnd& Rnd);
231  };
232  class TSimMatrixTrainSet : public TSVMTrainSet {
233  private:
234      static bool IsReg;
235      static bool MkReg(){return TSVMTrainSet::Reg(TTypeNm<TSimMatrixTrainSet>(), &Load);}
236  private:
237      TFltV ClsV;
238      TFltVV SimMatrix;
239      TSimMatrixTrainSet(const TIntV& VecIdV, const TFltV& _ClsV, const TFltVV& _SimMatrix);
240      static PSVMTrainSet New(const TIntV& VecIdV, const TFltV& _ClsV, const TFltVV& _SimMatrix) {
241              return new TSimMatrixTrainSet(VecIdV, _ClsV, _SimMatrix); }
242  public:
243      TSimMatrixTrainSet(const TFltVV& _SimMatrix, const TFltV& _ClsV = TFltV());
244      static PSVMTrainSet New(const TFltVV& _SimMatrix, const TFltV& _ClsV = TFltV()) {
245          return new TSimMatrixTrainSet(_SimMatrix, _ClsV); }
246      TSimMatrixTrainSet(TSIn& SIn): TSVMTrainSet(SIn) {
247          ClsV.Load(SIn); SimMatrix = TFltVV(SIn);}
248      static PSVMTrainSet Load(TSIn& SIn) {
249          return new TSimMatrixTrainSet(SIn); }
250      void Save(TSOut& SOut) const {
251          TSVMTrainSet::Save(SOut); ClsV.Save(SOut); SimMatrix.Save(SOut); }
252      int Len() const { return ClsV.Len(); }
253      int Dim() const { return 1; } 
254      double GetNorm2(const int& VecId) const { return SimMatrix(VecId,VecId); }
255      double GetVecParam(const int& VecId) const { return ClsV[VecId]; }
256      double DotProduct(const int& VecId1, const int& VecId2) const {
257          return SimMatrix(VecId1, VecId2); }
258      double DotProduct(const int& VecId1, double* vec2, const int& n) const  {
259          Fail; return 0.0; } 
260      double DotProduct(const int& VecId1, const TFltV& vec2) const {
261          Fail; return 0.0; } 
262      void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const {
263          Fail; } 
264      void AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
265          Fail; } 
266      PSVMTrainSet Clone(const TIntV& VecIdV) const {
267          return TSimMatrixTrainSet::New(VecIdV, ClsV, SimMatrix); }
268  };
269  class TBowDocBs2TrainSet {
270  private:
271      static void MakeSpVec(PBowSpV BowVec, TIntFltKdV& SpVec);
272  public:
273      static PSVMTrainSet NewBowNoCat(const TVec<PBowSpV>& BowSpV,
274          const double& DefParam = 1.0);
275      static PSVMTrainSet NewBowNoCat(PBowDocWgtBs BowDocWgtBs,
276          const TIntV& DIdV, const double& DefParam = 1.0);
277      static PSVMTrainSet NewSparseNoCat(const TVec<PBowSpV>& BowSpV,
278          const double& DefParam = 1.0);
279      static PSVMTrainSet NewSparseNoCat(PBowDocWgtBs BowDocWgtBs,
280          const TIntV& DIdV, const double& DefParam = 1.0);
281      static PSVMTrainSet NewBowOneCat(const PBowDocBs& BowDocBs,
282          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV);
283      static PSVMTrainSet NewSparseOneCat(const PBowDocBs& BowDocBs,
284          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV);
285      static PSVMTrainSet NewStringOneCat(const PBowDocBs& BowDocBs,
286          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer);
287      static PSVMTrainSet NewBowAllCat(const PBowDocBs& BowDocBs,
288          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV,
289          const double& SampleNegP = -1.0);
290      static PSVMTrainSet NewSparseAllCat(const PBowDocBs& BowDocBs,
291          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV);
292      static PSVMTrainSet NewStringAllCat(const PBowDocBs& BowDocBs,
293          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer);
294      static PSVMTrainSet NewBowAllCatV(PBowDocWgtBs BowDocWgtBs,
295          const TIntV& AllDIdV, const TIntV& CatDIdV);
296      static PSVMTrainSet NewSparseAllCatV(PBowDocWgtBs BowDocWgtBs,
297          const TIntV& AllDIdV, const TIntV& CatDIdV);
298      static PSVMTrainSet NewBowFromCat(const PBowDocBs& BowDocBs,
299          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV);
300      static PSVMTrainSet NewSparseFromCat(const PBowDocBs& BowDocBs,
301          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV);
302      static PSVMTrainSet NewBow(PBowDocPart BowDocPart);
303      static PSVMTrainSet NewSparse(PBowDocPart BowDocPart);
304  };
305  ClassTP(TSVMModel, PSVMModel) 
306  private:
307      TFltV AlphaV; 
308      TFlt Thresh; 
309      TBool Linear; 
310      TFltV WgtV; 
311      PSVMTrainSet SupVecs; 
312      PKernel Kernel; 
313      TBool IsSigDef;
314      TSigmoid Sigmoid;
315  private:
316      static PSVMModel MakeModel(const bool& Linear, const PKernel& ker,
317          const PSVMTrainSet& TrainSet, const TIntV& SubSet,
318          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam);
319      static TCfyRes CrossValidation(const int& Folds, const int&Seed,
320          const bool& Linear, const PKernel& ker,
321          const PSVMTrainSet& TrainSet, const TIntV& SubSet,
322          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam);
323      TSVMModel(): Thresh(TFlt::Mn), Linear(true), IsSigDef(false) { }
324      static PSVMModel New() { return new TSVMModel(); }
325  public:
326      static PSVMModel NewEmptyModel() { return new TSVMModel(); }
327      TSVMModel(TSIn& SIn);
328      static PSVMModel Load(TSIn& SIn) { return new TSVMModel(SIn); }
329      void Save(TSOut& SOut);
330      static PSVMModel LoadBin(const TStr& FNm) { TFIn FIn(FNm); return new TSVMModel(FIn); }
331      void SaveBin(const TStr& FNm) { TFOut FOut(FNm); Save(FOut); }
332      double GetRes(const TIntFltKdV& Vec) const;
333      double GetRes(const TFltV& Vec) const;
334      double GetRes(const TStr& Vec) const;
335      double GetRes(const TIntV& Vec) const;
336      double GetRes(PBowSpV Vec) const;
337      double GetRes(const int& VecId) const;
338      double GetCfy(const TIntFltKdV& Vec) const { return GetRes(Vec) > 0.0 ? 1.0 : -1.0; }
339      double GetCfy(const TFltV& Vec) const { return GetRes(Vec) > 0.0 ? 1.0 : -1.0; }
340      double GetCfy(const TStr& Vec) const { return GetRes(Vec) > 0.0 ? 1.0 : -1.0; }
341      double GetCfy(const TIntV& Vec) const { return GetRes(Vec) > 0.0 ? 1.0 : -1.0; }
342      double GetCfy(PBowSpV Vec) const { return GetRes(Vec) > 0.0 ? 1.0 : -1.0; }
343      double GetCfy(const int& VecId) const { return GetRes(VecId) > 0.0 ? 1.0 : -1.0; }
344      bool GetCfyBool(const TIntFltKdV& Vec) const { return GetRes(Vec) > 0.0 ? true : false; }
345      bool GetCfyBool(const TFltV& Vec) const { return GetRes(Vec) > 0.0 ? true : false; }
346      bool GetCfyBool(const TStr& Vec) const { return GetRes(Vec) > 0.0 ? true : false; }
347      bool GetCfyBool(const TIntV& Vec) const { return GetRes(Vec) > 0.0 ? true : false; }
348      bool GetCfyBool(PBowSpV Vec) const { return GetRes(Vec) > 0.0 ? true : false; }
349      bool GetCfyBool(const int& VecId) const { return GetRes(VecId) > 0.0 ? true : false; }
350      TCfyRes Test(const PSVMTrainSet& TestSet, const TIntV& SubSet = TIntV()) const;
351      bool IsProb() const { return IsSigDef; }
352      void MakeProb(const PSVMTrainSet& TrainSet, const TIntV& SubSet = TIntV());
353      double GetProbCfy(const TIntFltKdV& Vec) const { Assert(IsProb()); return Sigmoid(GetRes(Vec)); }
354      double GetProbCfy(const TFltV& Vec) const { Assert(IsProb()); return Sigmoid(GetRes(Vec)); }
355      double GetProbCfy(const TStr& Vec) const { Assert(IsProb()); return Sigmoid(GetRes(Vec)); }
356      double GetProbCfy(const TIntV& Vec) const { Assert(IsProb()); return Sigmoid(GetRes(Vec)); }
357      double GetProbCfy(PBowSpV Vec) const { Assert(IsProb()); return Sigmoid(GetRes(Vec)); }
358      double GetProbCfy(const int VecId) const { Assert(IsProb()); return Sigmoid(GetRes(VecId)); }
359      double GetMargin() const;
360      void GetAlphaV(TFltV& _AlphaV) const { _AlphaV = AlphaV; }
361      double GetThresh() const { return Thresh; }
362      bool IsLinear() const { return Linear; }
363      void GetWgtV(TFltV& _WgtV) const { IAssert(IsLinear()); _WgtV = WgtV; }
364      PSVMTrainSet GetSupVecs() const { IAssert(!IsLinear()); return SupVecs; }
365      PKernel GetKernel() const { IAssert(!IsLinear()); return Kernel; }
366      TSigmoid GetSigmoid() const { IAssert(IsProb()); return Sigmoid; }
367      static PSVMModel NewClsLinear(const PSVMTrainSet& TrainSet, const double& C,
368          const double& j = 1.0, const TIntV& SubSet = TIntV(),
369          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin()) {
370              return MakeModel(true, NULL, TrainSet, SubSet,
371                  TSVMModelParam::Classification(C, j), LearnParam); }
372      static PSVMModel NewCls(const PSVMTrainSet& TrainSet, const PKernel& ker,
373          const double& C, const double& j = 1.0, const TIntV& SubSet = TIntV(),
374          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin()) {
375              return MakeModel(false, ker, TrainSet, SubSet,
376                  TSVMModelParam::Classification(C, j), LearnParam); }
377      static TCfyRes CrossValidClsLinear(const int& Folds, const int&Seed,
378          const PSVMTrainSet& TrainSet, const double& C,
379          const double& j = 1.0, const TIntV& SubSet = TIntV(),
380          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin()) {
381              return CrossValidation(Folds, Seed, true, NULL, TrainSet, SubSet,
382                  TSVMModelParam::Classification(C, j), LearnParam); }
383      static TCfyRes CrossValidCls(const int& Folds, const int&Seed,
384          const PSVMTrainSet& TrainSet, const PKernel& ker, const double& C,
385          const double& j = 1.0, const TIntV& SubSet = TIntV(),
386          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin()) {
387              return CrossValidation(Folds, Seed, false, ker, TrainSet, SubSet,
388                  TSVMModelParam::Classification(C, j), LearnParam); }
389      static PSVMModel NewOneClassLinear(const PSVMTrainSet& TrainSet,
390          const double& nu, const TIntV& SubSet = TIntV(),
391          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin()) {
392              return MakeModel(true, NULL, TrainSet, SubSet,
393                  TSVMModelParam::OneClass(nu), LearnParam); }
394      static PSVMModel NewOneClass(const PSVMTrainSet& TrainSet, const PKernel& ker,
395          const double& nu, const TIntV& SubSet = TIntV(),
396          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin()) {
397              return MakeModel(false, ker, TrainSet, SubSet,
398                  TSVMModelParam::OneClass(nu), LearnParam); }
399      static TCfyRes CrossValidOneClassLinear(const int& Folds, const int&Seed,
400          const PSVMTrainSet& TrainSet, const double& nu, const TIntV& SubSet = TIntV(),
401          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin()) {
402              return CrossValidation(Folds, Seed, true, NULL, TrainSet, SubSet,
403                  TSVMModelParam::OneClass(nu), LearnParam); }
404      static TCfyRes CrossValidOneClass(const int& Folds, const int&Seed,
405          const PSVMTrainSet& TrainSet, const PKernel& ker,
406          const double& nu, const TIntV& SubSet = TIntV(),
407          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin()) {
408              return CrossValidation(Folds, Seed, false, ker, TrainSet, SubSet,
409                  TSVMModelParam::OneClass(nu), LearnParam); }
410      static PSVMModel NewRegLinear(const PSVMTrainSet& TrainSet,
411          const double& E, const double& C, const TIntV& SubSet = TIntV(),
412          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin()) {
413              return MakeModel(true, NULL, TrainSet, SubSet,
414                  TSVMModelParam::Regression(E, C), LearnParam); }
415      static PSVMModel NewReg(const PSVMTrainSet& TrainSet, const PKernel& ker,
416          const double& E, const double& C, const TIntV& SubSet = TIntV(),
417          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin()) {
418              return MakeModel(false, ker, TrainSet, SubSet,
419                  TSVMModelParam::Regression(E, C), LearnParam); }
420  };
421  class TBowSVMMd: public TBowMd {
422  private:
423      static bool IsReg;
424      static bool MkReg(){return TBowMd::Reg(TTypeNm<TBowSVMMd>(), &Load);}
425  private:
426      TStr CatNm;
427      PSVMModel Model;
428  private:
429      static PSVMTrainSet PrepareClsTrainSet(PBowDocBs BowDocBs,
430          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
431          const double& SampleNegP = -1.0);
432      static PSVMTrainSet PrepareOneClassTrainSet(PBowDocBs BowDocBs,
433          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV);
434      static PSVMTrainSet PrepareClsTrainSet(PBowDocBs BowDocBs,
435          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV, const TIntV& CatDIdV);
436      static PBowSpV GetKeywords(const PSVMTrainSet& TrainSet,
437          const PSVMModel& SVMModel, const int WdN,
438          const double& VecSign, const double& WgtSign, const bool& AvgOverSet);
439  public:
440      TBowSVMMd(const PBowDocBs& BowDocBs, const TStr& _CatNm, PSVMModel _Model):
441        TBowMd(BowDocBs), CatNm(_CatNm), Model(_Model) {}
442      static PBowMd New(const PBowDocBs& BowDocBs, const TStr& _CatNm,
443          PSVMModel _Model) { return new TBowSVMMd(BowDocBs, _CatNm, _Model); }
444      TBowSVMMd(TSIn& SIn);
445      static PBowMd Load(TSIn& SIn){return PBowMd(new TBowSVMMd(SIn));}
446      void Save(TSOut& SOut);
447      void GetCfy(const PBowSpV& QueryBowSpV, TFltStrPrV& WgtCatNmPrV);
448      static TCfyRes Test(PBowMd BowMd, PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
449          const TIntV& DIdV, const TStr& CatNm);
450      bool IsCat() const {return !CatNm.Empty();}
451      TStr GetCatNm() const {IAssert(IsCat()); return CatNm;}
452      bool IsLinComb() const {return Model->IsLinear();}
453      void GetLinComb(
454       const PBowDocBs& BowDocBs, TFltStrPrV& WgtStrPrV, double& Tsh) const;
455      void SaveTxt(const TStr& FNm, const PBowDocBs& BowDocBs,
456          const PBowDocWgtBs& BowDocWgtBs);
457      static PBowMd NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
458          const TStr& CatNm, const TIntV& TrainDIdV, const double& C, const double& j = 1.0,
459          const bool& ProbabilisticP = false, const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
460      static PBowMd NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
461          const TIntV& TrainDIdV, const TIntV& CatDIdV, const double& C, const double& j = 1.0,
462          const bool& ProbabilisticP = false, const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
463      static PBowMd NewCls(const PKernel& ker, const PBowDocBs& BowDocBs,
464          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
465          const double& C, const double& j = 1.0, const bool& ProbabilisticP = false,
466          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin());
467      static TCfyRes CrossValidClsLinear(const int& Folds, const int& Seed,
468          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
469          const TIntV& TrainDIdV, const double& C, const double& j = 1.0,
470          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
471      static TCfyRes CrossValidClsLinear(const int& Folds, const int& Seed,
472          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TIntV& TrainDIdV,
473          const TIntV& CatDIdV, const double& C, const double& j = 1.0,
474          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
475      static TCfyRes CrossValidCls(const int& Folds, const int& Seed,
476          const PKernel& ker, const PBowDocBs& BowDocBs,
477          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
478          const TIntV& TrainDIdV, const double& C, const double& j = 1.0,
479          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin());
480      static PBowMd NewMultiClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
481          const TIntV& TrainDIdV, const double& C, const double& j = 1.0,
482          const bool& SampleNegP = false, const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
483      static TCfyRes CrossValidMultiClsLinear(const int& Folds, const int& Seed,
484          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
485          const double& C, const double& j = 1.0, const bool& SampleNegP = false,
486          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
487      static PBowMd NewOneClassLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
488          const TStr& CatNm, const TIntV& TrainDIdV, const double& nu,
489          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
490      static PBowMd NewOneClass(const PKernel& ker, const PBowDocBs& BowDocBs,
491          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
492          const double& nu, const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin());
493      static TCfyRes CrossValidOneClassLinear(const int& Folds, const int&Seed,
494          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
495          const TStr& CatNm, const TIntV& TrainDIdV, const double& nu,
496          const TSVMLearnParam& LearnParam = TSVMLearnParam::Lin());
497      static TCfyRes CrossValidOneClass(const int& Folds, const int&Seed,
498          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
499          const TStr& CatNm, const TIntV& TrainDIdV, const double& nu,
500          const TSVMLearnParam& LearnParam = TSVMLearnParam::NonLin());
501      static PBowSpV GetKeywords(const PBowDocBs& BowDocBs,
502          const TIntV& TrainDIdV, const TIntV& CatDIdV,
503          const int WdN = 10, const double& C = 1.0,
504          const double& j = 1.0, const int& Time = 10,
505          const TBowWordWgtType& SvmWordWgtType = bwwtLogDFNrmTFIDF,
506          const double& VecSign = 1.0, const double& WgtSign = 1.0,
507          const bool& AvgOverSet = true);
508      static PBowSpV GetKeywords(const PBowDocBs& BowDocBs,
509          PBowDocWgtBs BowDocWgtBs, const TIntV& TrainDIdV,
510          const TIntV& CatDIdV, const int WdN = 10, const double& C = 1.0,
511          const double& j = 1.0, const int& Time = 10,
512          const double& VecSign = 1.0, const double& WgtSign = 1.0,
513          const bool& AvgOverSet = true);
514      static PBowSpV GetKeywords(const PBowDocBs& BowDocBs,
515          const TIntV& TrainDIdV, const TStr& CatNm,
516          const int WdN = 10, const double& C = 1.0,
517          const double& j = 1.0, const int& Time = 10,
518          const TBowWordWgtType& SvmWordWgtType = bwwtLogDFNrmTFIDF,
519          const double& VecSign = 1.0, const double& WgtSign = 1.0,
520          const bool& AvgOverSet = true);
521      static PBowSpV GetKeywords(const PBowDocBs& BowDocBs,
522          PBowDocWgtBs BowDocWgtBs, const TIntV& TrainDIdV,
523          const TStr& CatNm, const int WdN = 10, const double& C = 1.0,
524          const double& j = 1.0, const int& Time = 10,
525          const double& VecSign = 1.0, const double& WgtSign = 1.0,
526          const bool& AvgOverSet = true);
527  };
528  class TSVMTrainSetCsv {
529  private:
530      ClassTP(TFtrGen, PFtrGen)
531      public:
532          TFtrGen() { }
533          virtual ~TFtrGen() { }
534          virtual void Update(const TStr& Val) = 0;
535          virtual void Add(const TStr& Val, TIntFltKdV& SpV, int& Offset) const = 0;
536          virtual void AddWds(const TStr& Prefix,
537              const PBowDocBs& BowDocBs, int& Offset) const;
538          virtual int GetVals() const = 0;
539          virtual TStr GetVal(const int& ValN) const = 0;
540          virtual void GetValV(const TStr& Str, TStrV& ValV) const = 0;
541      };
542      class TFtrGenNumeric : public TFtrGen {
543      public: static TStr Type;
544      private:
545          TFlt MnVal;
546          TFlt MxVal;
547          double Trans(const double& Val) const;
548          double GetFlt(const TStr& Str) const;
549      public:
550          TFtrGenNumeric(): MnVal(TFlt::Mx), MxVal(TFlt::Mn) { }
551          static PFtrGen New() { return new TFtrGenNumeric; }
552          void Update(const TStr& Val);
553          void Add(const TStr& Val, TIntFltKdV& SpV, int& Offset) const;
554          int GetVals() const { return 1; }
555          TStr GetVal(const int& ValN) const { return Type; }
556          void GetValV(const TStr& Str, TStrV& ValV) const { Fail; }
557      };
558      class TFtrGenNominal : public TFtrGen {
559      public: static TStr Type;
560      private:
561          TStrH ValH;
562      public:
563          TFtrGenNominal() { }
564          static PFtrGen New() { return new TFtrGenNominal; }
565          void Update(const TStr& Val);
566          void Add(const TStr& Val, TIntFltKdV& SpV, int& Offset) const;
567          int GetVals() const { return ValH.Len(); }
568          TStr GetVal(const int& ValN) const { return Type + ":" + ValH.GetKey(ValN); }
569          void GetValV(const TStr& Str, TStrV& ValV) const { ValV = TStrV::GetV(Str); }
570      };
571      class TFtrGenToken : public TFtrGen {
572      public: static TStr Type;
573      private:
574          PSwSet SwSet;
575          PStemmer Stemmer;
576          TInt Docs;
577          TStrH TokenH;
578          void GetTokenV(const TStr& Str, TStrV& TokenStrV) const;
579      public:
580          TFtrGenToken(PSwSet _SwSet, PStemmer _Stemmer):
581            SwSet(_SwSet), Stemmer(_Stemmer) { }
582          static PFtrGen New(PSwSet SwSet, PStemmer Stemmer) {
583              return new TFtrGenToken(SwSet, Stemmer); }
584          void Update(const TStr& Val);
585          void Add(const TStr& Val, TIntFltKdV& SpV, int& Offset) const;
586          int GetVals() const { return TokenH.Len(); }
587          TStr GetVal(const int& ValN) const { return Type + ":" + TokenH.GetKey(ValN); }
588          void GetValV(const TStr& Str, TStrV& ValV) const { Fail; }
589      };
590      class TFtrGenSparseNumeric : public TFtrGen {
591      public: static TStr Type;
592      private:
593          TInt MxId;
594          TFtrGenNumeric FtrGen;
595          void Split(const TStr& Str, int& Id, TStr& Val) const;
596      public:
597          TFtrGenSparseNumeric() { }
598          static PFtrGen New() { return new TFtrGenSparseNumeric(); }
599          void Update(const TStr& Str);
600          void Add(const TStr& Str, TIntFltKdV& SpV, int& Offset) const;
601          int GetVals() const { return MxId + 1; }
602          TStr GetVal(const int& ValN) const;
603          void GetValV(const TStr& Str, TStrV& ValV) const { Fail; }
604      };
605      class TFtrGenMultiNom : public TFtrGen {
606      public: static TStr Type;
607      private:
608          TFtrGenNominal FtrGen;
609      public:
610          TFtrGenMultiNom() { }
611          static PFtrGen New() { return new TFtrGenMultiNom(); }
612          void Update(const TStr& Str);
613          void Add(const TStr& Str, TIntFltKdV& SpV, int& Offset) const;
614          int GetVals() const { return FtrGen.GetVals(); }
615          TStr GetVal(const int& ValN) const;
616          void GetValV(const TStr& Str, TStrV& ValV) const;
617      };
618  public:
619      static PBowDocBs LoadCsv(TStr& FNm, const int& ClassId,
620          const TIntV& IgnoreIdV, const int& TrainLen);
621  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.h</div>
                </div>
                <div class="column column_space"><pre><code>133    template <EdgeType edge_type>
134    inline void SetEdge(CordRep* edge);
135    CopyResult CopyPrefix(size_t n, bool allow_folding = true);
136    CopyResult CopySuffix(size_t offset);
137    inline OpResult ToOpResult(bool owned);
</pre></code></div>
                <div class="column column_space"><pre><code>156    void AddVec(const int& VecId1, double* vec2, const int& n, const double& K) const;
157    void AddVec(const int& VecId1, TFltV& vec2, const double& K) const;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    