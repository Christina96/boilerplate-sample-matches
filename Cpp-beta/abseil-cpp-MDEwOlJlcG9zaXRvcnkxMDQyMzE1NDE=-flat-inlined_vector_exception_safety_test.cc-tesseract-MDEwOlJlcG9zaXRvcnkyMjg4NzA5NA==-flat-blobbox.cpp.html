
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6748329621380846%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_exception_safety_test.cc</h3>
            <pre><code>1  #include "absl/container/inlined_vector.h"
2  #include "absl/base/config.h"
3  #if defined(ABSL_HAVE_EXCEPTIONS)
4  #include <array>
5  #include <initializer_list>
6  #include <iterator>
7  #include <memory>
8  #include <utility>
9  #include "gtest/gtest.h"
10  #include "absl/base/internal/exception_safety_testing.h"
11  namespace {
12  constexpr size_t kInlinedCapacity = 4;
13  constexpr size_t kLargeSize = kInlinedCapacity * 2;
14  constexpr size_t kSmallSize = kInlinedCapacity / 2;
15  using Thrower = testing::ThrowingValue<>;
16  using MovableThrower = testing::ThrowingValue<testing::TypeSpec::kNoThrowMove>;
17  using ThrowAlloc = testing::ThrowingAllocator<Thrower>;
18  using ThrowerVec = absl::InlinedVector<Thrower, kInlinedCapacity>;
19  using MovableThrowerVec = absl::InlinedVector<MovableThrower, kInlinedCapacity>;
20  using ThrowAllocThrowerVec =
21      absl::InlinedVector<Thrower, kInlinedCapacity, ThrowAlloc>;
22  using ThrowAllocMovableThrowerVec =
23      absl::InlinedVector<MovableThrower, kInlinedCapacity, ThrowAlloc>;
24  #define ABSL_INTERNAL_MAKE_INIT_LIST(T, N)                     \
25    (N > kInlinedCapacity                                        \
26         ? std::initializer_list<T>{T(0, testing::nothrow_ctor), \
27                                    T(1, testing::nothrow_ctor), \
28                                    T(2, testing::nothrow_ctor), \
29                                    T(3, testing::nothrow_ctor), \
30                                    T(4, testing::nothrow_ctor), \
31                                    T(5, testing::nothrow_ctor), \
32                                    T(6, testing::nothrow_ctor), \
33                                    T(7, testing::nothrow_ctor)} \
34                                                                 \
35         : std::initializer_list<T>{T(0, testing::nothrow_ctor), \
36                                    T(1, testing::nothrow_ctor)})
37  static_assert(kLargeSize == 8, "Must update ABSL_INTERNAL_MAKE_INIT_LIST(...)");
38  static_assert(kSmallSize == 2, "Must update ABSL_INTERNAL_MAKE_INIT_LIST(...)");
39  template <typename TheVecT, size_t... TheSizes>
40  class TestParams {
41   public:
42    using VecT = TheVecT;
43    constexpr static size_t GetSizeAt(size_t i) { return kSizes[1 + i]; }
44   private:
45    constexpr static size_t kSizes[1 + sizeof...(TheSizes)] = {1, TheSizes...};
46  };
47  using NoSizeTestParams =
48      ::testing::Types<TestParams<ThrowerVec>, TestParams<MovableThrowerVec>,
49                       TestParams<ThrowAllocThrowerVec>,
50                       TestParams<ThrowAllocMovableThrowerVec>>;
51  using OneSizeTestParams =
52      ::testing::Types<TestParams<ThrowerVec, kLargeSize>,
53                       TestParams<ThrowerVec, kSmallSize>,
54                       TestParams<MovableThrowerVec, kLargeSize>,
55                       TestParams<MovableThrowerVec, kSmallSize>,
56                       TestParams<ThrowAllocThrowerVec, kLargeSize>,
57                       TestParams<ThrowAllocThrowerVec, kSmallSize>,
58                       TestParams<ThrowAllocMovableThrowerVec, kLargeSize>,
59                       TestParams<ThrowAllocMovableThrowerVec, kSmallSize>>;
60  using TwoSizeTestParams = ::testing::Types<
61      TestParams<ThrowerVec, kLargeSize, kLargeSize>,
62      TestParams<ThrowerVec, kLargeSize, kSmallSize>,
63      TestParams<ThrowerVec, kSmallSize, kLargeSize>,
64      TestParams<ThrowerVec, kSmallSize, kSmallSize>,
65      TestParams<MovableThrowerVec, kLargeSize, kLargeSize>,
66      TestParams<MovableThrowerVec, kLargeSize, kSmallSize>,
67      TestParams<MovableThrowerVec, kSmallSize, kLargeSize>,
68      TestParams<MovableThrowerVec, kSmallSize, kSmallSize>,
69      TestParams<ThrowAllocThrowerVec, kLargeSize, kLargeSize>,
70      TestParams<ThrowAllocThrowerVec, kLargeSize, kSmallSize>,
71      TestParams<ThrowAllocThrowerVec, kSmallSize, kLargeSize>,
72      TestParams<ThrowAllocThrowerVec, kSmallSize, kSmallSize>,
73      TestParams<ThrowAllocMovableThrowerVec, kLargeSize, kLargeSize>,
74      TestParams<ThrowAllocMovableThrowerVec, kLargeSize, kSmallSize>,
75      TestParams<ThrowAllocMovableThrowerVec, kSmallSize, kLargeSize>,
76      TestParams<ThrowAllocMovableThrowerVec, kSmallSize, kSmallSize>>;
77  template <typename>
78  struct NoSizeTest : ::testing::Test {};
79  TYPED_TEST_SUITE(NoSizeTest, NoSizeTestParams);
80  template <typename>
81  struct OneSizeTest : ::testing::Test {};
82  TYPED_TEST_SUITE(OneSizeTest, OneSizeTestParams);
83  template <typename>
84  struct TwoSizeTest : ::testing::Test {};
85  TYPED_TEST_SUITE(TwoSizeTest, TwoSizeTestParams);
86  template <typename VecT>
87  bool InlinedVectorInvariants(VecT* vec) {
88    if (*vec != *vec) return false;
89    if (vec->size() > vec->capacity()) return false;
90    if (vec->size() > vec->max_size()) return false;
91    if (vec->capacity() > vec->max_size()) return false;
92    if (vec->data() != std::addressof(vec->at(0))) return false;
93    if (vec->data() != vec->begin()) return false;
94    if (*vec->data() != *vec->begin()) return false;
<span onclick='openModal()' class='match'>95    if (vec->begin() > vec->end()) return false;
96    if ((vec->end() - vec->begin()) != vec->size()) return false;
97    if (std::distance(vec->begin(), vec->end()) != vec->size()) return false;
</span>98    return true;
99  }
100  template <typename VecT>
101  bool NoThrowGuarantee(VecT* &bsol;* vec */) {
102    return false;
103  }
104  TYPED_TEST(NoSizeTest, DefaultConstructor) {
105    using VecT = typename TypeParam::VecT;
106    using allocator_type = typename VecT::allocator_type;
107    testing::TestThrowingCtor<VecT>();
108    testing::TestThrowingCtor<VecT>(allocator_type{});
109  }
110  TYPED_TEST(OneSizeTest, SizeConstructor) {
111    using VecT = typename TypeParam::VecT;
112    using allocator_type = typename VecT::allocator_type;
113    constexpr static auto size = TypeParam::GetSizeAt(0);
114    testing::TestThrowingCtor<VecT>(size);
115    testing::TestThrowingCtor<VecT>(size, allocator_type{});
116  }
117  TYPED_TEST(OneSizeTest, SizeRefConstructor) {
118    using VecT = typename TypeParam::VecT;
119    using value_type = typename VecT::value_type;
120    using allocator_type = typename VecT::allocator_type;
121    constexpr static auto size = TypeParam::GetSizeAt(0);
122    testing::TestThrowingCtor<VecT>(size, value_type{});
123    testing::TestThrowingCtor<VecT>(size, value_type{}, allocator_type{});
124  }
125  TYPED_TEST(OneSizeTest, InitializerListConstructor) {
126    using VecT = typename TypeParam::VecT;
127    using value_type = typename VecT::value_type;
128    using allocator_type = typename VecT::allocator_type;
129    constexpr static auto size = TypeParam::GetSizeAt(0);
130    testing::TestThrowingCtor<VecT>(
131        ABSL_INTERNAL_MAKE_INIT_LIST(value_type, size));
132    testing::TestThrowingCtor<VecT>(
133        ABSL_INTERNAL_MAKE_INIT_LIST(value_type, size), allocator_type{});
134  }
135  TYPED_TEST(OneSizeTest, RangeConstructor) {
136    using VecT = typename TypeParam::VecT;
137    using value_type = typename VecT::value_type;
138    using allocator_type = typename VecT::allocator_type;
139    constexpr static auto size = TypeParam::GetSizeAt(0);
140    std::array<value_type, size> arr{};
141    testing::TestThrowingCtor<VecT>(arr.begin(), arr.end());
142    testing::TestThrowingCtor<VecT>(arr.begin(), arr.end(), allocator_type{});
143  }
144  TYPED_TEST(OneSizeTest, CopyConstructor) {
145    using VecT = typename TypeParam::VecT;
146    using allocator_type = typename VecT::allocator_type;
147    constexpr static auto size = TypeParam::GetSizeAt(0);
148    VecT other_vec{size};
149    testing::TestThrowingCtor<VecT>(other_vec);
150    testing::TestThrowingCtor<VecT>(other_vec, allocator_type{});
151  }
152  TYPED_TEST(OneSizeTest, MoveConstructor) {
153    using VecT = typename TypeParam::VecT;
154    using allocator_type = typename VecT::allocator_type;
155    constexpr static auto size = TypeParam::GetSizeAt(0);
156    if (!absl::allocator_is_nothrow<allocator_type>::value) {
157      testing::TestThrowingCtor<VecT>(VecT{size});
158      testing::TestThrowingCtor<VecT>(VecT{size}, allocator_type{});
159    }
160  }
161  TYPED_TEST(TwoSizeTest, Assign) {
162    using VecT = typename TypeParam::VecT;
163    using value_type = typename VecT::value_type;
164    constexpr static auto from_size = TypeParam::GetSizeAt(0);
165    constexpr static auto to_size = TypeParam::GetSizeAt(1);
166    auto tester = testing::MakeExceptionSafetyTester()
167                      .WithInitialValue(VecT{from_size})
168                      .WithContracts(InlinedVectorInvariants<VecT>);
169    EXPECT_TRUE(tester.Test([](VecT* vec) {
170      *vec = ABSL_INTERNAL_MAKE_INIT_LIST(value_type, to_size);
171    }));
172    EXPECT_TRUE(tester.Test([](VecT* vec) {
173      VecT other_vec{to_size};
174      *vec = other_vec;
175    }));
176    EXPECT_TRUE(tester.Test([](VecT* vec) {
177      VecT other_vec{to_size};
178      *vec = std::move(other_vec);
179    }));
180    EXPECT_TRUE(tester.Test([](VecT* vec) {
181      value_type val{};
182      vec->assign(to_size, val);
183    }));
184    EXPECT_TRUE(tester.Test([](VecT* vec) {
185      vec->assign(ABSL_INTERNAL_MAKE_INIT_LIST(value_type, to_size));
186    }));
187    EXPECT_TRUE(tester.Test([](VecT* vec) {
188      std::array<value_type, to_size> arr{};
189      vec->assign(arr.begin(), arr.end());
190    }));
191  }
192  TYPED_TEST(TwoSizeTest, Resize) {
193    using VecT = typename TypeParam::VecT;
194    using value_type = typename VecT::value_type;
195    constexpr static auto from_size = TypeParam::GetSizeAt(0);
196    constexpr static auto to_size = TypeParam::GetSizeAt(1);
197    auto tester = testing::MakeExceptionSafetyTester()
198                      .WithInitialValue(VecT{from_size})
199                      .WithContracts(InlinedVectorInvariants<VecT>,
200                                     testing::strong_guarantee);
201    EXPECT_TRUE(tester.Test([](VecT* vec) {
202      vec->resize(to_size);  
203    }));
204    EXPECT_TRUE(tester.Test([](VecT* vec) {
205      vec->resize(to_size, value_type{});  
206    }));
207  }
208  TYPED_TEST(OneSizeTest, Insert) {
209    using VecT = typename TypeParam::VecT;
210    using value_type = typename VecT::value_type;
211    constexpr static auto from_size = TypeParam::GetSizeAt(0);
212    auto tester = testing::MakeExceptionSafetyTester()
213                      .WithInitialValue(VecT{from_size})
214                      .WithContracts(InlinedVectorInvariants<VecT>);
215    EXPECT_TRUE(tester.Test([](VecT* vec) {
216      auto it = vec->begin();
217      vec->insert(it, value_type{});
218    }));
219    EXPECT_TRUE(tester.Test([](VecT* vec) {
220      auto it = vec->begin() + (vec->size() / 2);
221      vec->insert(it, value_type{});
222    }));
223    EXPECT_TRUE(tester.Test([](VecT* vec) {
224      auto it = vec->end();
225      vec->insert(it, value_type{});
226    }));
227  }
228  TYPED_TEST(TwoSizeTest, Insert) {
229    using VecT = typename TypeParam::VecT;
230    using value_type = typename VecT::value_type;
231    constexpr static auto from_size = TypeParam::GetSizeAt(0);
232    constexpr static auto count = TypeParam::GetSizeAt(1);
233    auto tester = testing::MakeExceptionSafetyTester()
234                      .WithInitialValue(VecT{from_size})
235                      .WithContracts(InlinedVectorInvariants<VecT>);
236    EXPECT_TRUE(tester.Test([](VecT* vec) {
237      auto it = vec->begin();
238      vec->insert(it, count, value_type{});
239    }));
240    EXPECT_TRUE(tester.Test([](VecT* vec) {
241      auto it = vec->begin() + (vec->size() / 2);
242      vec->insert(it, count, value_type{});
243    }));
244    EXPECT_TRUE(tester.Test([](VecT* vec) {
245      auto it = vec->end();
246      vec->insert(it, count, value_type{});
247    }));
248    EXPECT_TRUE(tester.Test([](VecT* vec) {
249      auto it = vec->begin();
250      vec->insert(it, ABSL_INTERNAL_MAKE_INIT_LIST(value_type, count));
251    }));
252    EXPECT_TRUE(tester.Test([](VecT* vec) {
253      auto it = vec->begin() + (vec->size() / 2);
254      vec->insert(it, ABSL_INTERNAL_MAKE_INIT_LIST(value_type, count));
255    }));
256    EXPECT_TRUE(tester.Test([](VecT* vec) {
257      auto it = vec->end();
258      vec->insert(it, ABSL_INTERNAL_MAKE_INIT_LIST(value_type, count));
259    }));
260    EXPECT_TRUE(tester.Test([](VecT* vec) {
261      auto it = vec->begin();
262      std::array<value_type, count> arr{};
263      vec->insert(it, arr.begin(), arr.end());
264    }));
265    EXPECT_TRUE(tester.Test([](VecT* vec) {
266      auto it = vec->begin() + (vec->size() / 2);
267      std::array<value_type, count> arr{};
268      vec->insert(it, arr.begin(), arr.end());
269    }));
270    EXPECT_TRUE(tester.Test([](VecT* vec) {
271      auto it = vec->end();
272      std::array<value_type, count> arr{};
273      vec->insert(it, arr.begin(), arr.end());
274    }));
275  }
276  TYPED_TEST(OneSizeTest, EmplaceBack) {
277    using VecT = typename TypeParam::VecT;
278    constexpr static auto size = TypeParam::GetSizeAt(0);
279    VecT full_vec{size};
280    full_vec.resize(full_vec.capacity());
281    VecT nonfull_vec{size};
282    nonfull_vec.reserve(size + 1);
283    auto tester = testing::MakeExceptionSafetyTester().WithContracts(
284        InlinedVectorInvariants<VecT>);
285    EXPECT_TRUE(tester.WithInitialValue(nonfull_vec).Test([](VecT* vec) {
286      vec->emplace_back();
287    }));
288    EXPECT_TRUE(tester.WithInitialValue(full_vec).Test(
289        [](VecT* vec) { vec->emplace_back(); }));
290  }
291  TYPED_TEST(OneSizeTest, PopBack) {
292    using VecT = typename TypeParam::VecT;
293    constexpr static auto size = TypeParam::GetSizeAt(0);
294    auto tester = testing::MakeExceptionSafetyTester()
295                      .WithInitialValue(VecT{size})
296                      .WithContracts(NoThrowGuarantee<VecT>);
297    EXPECT_TRUE(tester.Test([](VecT* vec) {
298      vec->pop_back();  
299    }));
300  }
301  TYPED_TEST(OneSizeTest, Erase) {
302    using VecT = typename TypeParam::VecT;
303    constexpr static auto size = TypeParam::GetSizeAt(0);
304    auto tester = testing::MakeExceptionSafetyTester()
305                      .WithInitialValue(VecT{size})
306                      .WithContracts(InlinedVectorInvariants<VecT>);
307    EXPECT_TRUE(tester.Test([](VecT* vec) {
308      auto it = vec->begin();
309      vec->erase(it);
310    }));
311    EXPECT_TRUE(tester.Test([](VecT* vec) {
312      auto it = vec->begin() + (vec->size() / 2);
313      vec->erase(it);
314    }));
315    EXPECT_TRUE(tester.Test([](VecT* vec) {
316      auto it = vec->begin() + (vec->size() - 1);
317      vec->erase(it);
318    }));
319    EXPECT_TRUE(tester.Test([](VecT* vec) {
320      auto it = vec->begin();
321      vec->erase(it, it);
322    }));
323    EXPECT_TRUE(tester.Test([](VecT* vec) {
324      auto it = vec->begin() + (vec->size() / 2);
325      vec->erase(it, it);
326    }));
327    EXPECT_TRUE(tester.Test([](VecT* vec) {
328      auto it = vec->begin() + (vec->size() - 1);
329      vec->erase(it, it);
330    }));
331    EXPECT_TRUE(tester.Test([](VecT* vec) {
332      auto it = vec->begin();
333      vec->erase(it, it + 1);
334    }));
335    EXPECT_TRUE(tester.Test([](VecT* vec) {
336      auto it = vec->begin() + (vec->size() / 2);
337      vec->erase(it, it + 1);
338    }));
339    EXPECT_TRUE(tester.Test([](VecT* vec) {
340      auto it = vec->begin() + (vec->size() - 1);
341      vec->erase(it, it + 1);
342    }));
343  }
344  TYPED_TEST(OneSizeTest, Clear) {
345    using VecT = typename TypeParam::VecT;
346    constexpr static auto size = TypeParam::GetSizeAt(0);
347    auto tester = testing::MakeExceptionSafetyTester()
348                      .WithInitialValue(VecT{size})
349                      .WithContracts(NoThrowGuarantee<VecT>);
350    EXPECT_TRUE(tester.Test([](VecT* vec) {
351      vec->clear();  
352    }));
353  }
354  TYPED_TEST(TwoSizeTest, Reserve) {
355    using VecT = typename TypeParam::VecT;
356    constexpr static auto from_size = TypeParam::GetSizeAt(0);
357    constexpr static auto to_capacity = TypeParam::GetSizeAt(1);
358    auto tester = testing::MakeExceptionSafetyTester()
359                      .WithInitialValue(VecT{from_size})
360                      .WithContracts(InlinedVectorInvariants<VecT>);
361    EXPECT_TRUE(tester.Test([](VecT* vec) { vec->reserve(to_capacity); }));
362  }
363  TYPED_TEST(OneSizeTest, ShrinkToFit) {
364    using VecT = typename TypeParam::VecT;
365    constexpr static auto size = TypeParam::GetSizeAt(0);
366    auto tester = testing::MakeExceptionSafetyTester()
367                      .WithInitialValue(VecT{size})
368                      .WithContracts(InlinedVectorInvariants<VecT>);
369    EXPECT_TRUE(tester.Test([](VecT* vec) {
370      vec->shrink_to_fit();  
371    }));
372  }
373  TYPED_TEST(TwoSizeTest, Swap) {
374    using VecT = typename TypeParam::VecT;
375    constexpr static auto from_size = TypeParam::GetSizeAt(0);
376    constexpr static auto to_size = TypeParam::GetSizeAt(1);
377    auto tester = testing::MakeExceptionSafetyTester()
378                      .WithInitialValue(VecT{from_size})
379                      .WithContracts(InlinedVectorInvariants<VecT>);
380    EXPECT_TRUE(tester.Test([](VecT* vec) {
381      VecT other_vec{to_size};
382      vec->swap(other_vec);
383    }));
384    EXPECT_TRUE(tester.Test([](VecT* vec) {
385      using std::swap;
386      VecT other_vec{to_size};
387      swap(*vec, other_vec);
388    }));
389  }
390  }  
391  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobbox.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "blobbox.h"
5  #include "blobs.h"   
6  #include "coutln.h"  
7  #include "environ.h" 
8  #include "host.h"    
9  #include "points.h"  
10  #include "helpers.h" 
11  #include <allheaders.h> 
12  #include <algorithm> 
13  #include <cmath>
14  #include <cstdint>   
15  #define PROJECTION_MARGIN 10 
16  namespace tesseract {
17  const double kCosSmallAngle = 0.866;
18  const double kDefiniteAspectRatio = 2.0;
19  const double kComplexShapePerimeterRatio = 1.5;
20  const double kMinMediumSizeRatio = 0.25;
21  const double kMaxMediumSizeRatio = 4.0;
22  void BLOBNBOX::rotate(FCOORD rotation) {
23    cblob_ptr->rotate(rotation);
24    rotate_box(rotation);
25    compute_bounding_box();
26  }
27  void BLOBNBOX::reflect_box_in_y_axis() {
28    int left = -box.right();
29    box.set_right(-box.left());
30    box.set_left(left);
31  }
32  void BLOBNBOX::rotate_box(FCOORD rotation) {
33    if (IsDiacritic()) {
34      ASSERT_HOST(rotation.x() >= kCosSmallAngle);
35      ICOORD top_pt((box.left() + box.right()) / 2, base_char_top_);
36      ICOORD bottom_pt(top_pt.x(), base_char_bottom_);
37      top_pt.rotate(rotation);
38      base_char_top_ = top_pt.y();
39      bottom_pt.rotate(rotation);
40      base_char_bottom_ = bottom_pt.y();
41      box.rotate(rotation);
42    } else {
43      box.rotate(rotation);
44      set_diacritic_box(box);
45    }
46  }
47  void BLOBNBOX::merge(  
48      BLOBNBOX *nextblob 
49  ) {
50    box += nextblob->box; 
51    set_diacritic_box(box);
52    nextblob->joined = true;
53  }
54  void BLOBNBOX::really_merge(BLOBNBOX *other) {
55    if (other->cblob_ptr != nullptr) {
56      C_OUTLINE_IT ol_it(cblob_ptr->out_list());
57      ol_it.add_list_after(other->cblob_ptr->out_list());
58    }
59    compute_bounding_box();
60  }
61  void BLOBNBOX::chop(       
62      BLOBNBOX_IT *start_it, 
63      BLOBNBOX_IT *end_it,   
64      FCOORD rotation,       
65      float xheight          
66  ) {
67    int16_t blobcount;          
68    BLOBNBOX *newblob;          
69    BLOBNBOX *blob;             
70    int16_t blobindex;          
71    int16_t leftx;              
72    float blobwidth;            
73    float rightx;               
74    float ymin, ymax;           
75    float test_ymin, test_ymax; 
76    ICOORD bl, tr;              
77    BLOBNBOX_IT blob_it;        
78    blobcount = static_cast<int16_t>(std::floor(box.width() / xheight));
79    if (blobcount > 1 && cblob_ptr != nullptr) {
80      blobwidth = static_cast<float>(box.width() + 1) / blobcount;
81      for (blobindex = blobcount - 1, rightx = box.right(); blobindex >= 0;
82           blobindex--, rightx -= blobwidth) {
83        ymin = static_cast<float>(INT32_MAX);
84        ymax = static_cast<float>(-INT32_MAX);
85        blob_it = *start_it;
86        do {
87          blob = blob_it.data();
88          find_cblob_vlimits(blob->cblob_ptr, rightx - blobwidth, rightx,
89                              test_ymin, test_ymax);
90          blob_it.forward();
91          UpdateRange(test_ymin, test_ymax, &ymin, &ymax);
92        } while (blob != end_it->data());
93        if (ymin < ymax) {
94          leftx = static_cast<int16_t>(std::floor(rightx - blobwidth));
95          if (leftx < box.left()) {
96            leftx = box.left(); 
97          }
98          bl = ICOORD(leftx, static_cast<int16_t>(std::floor(ymin)));
99          tr = ICOORD(static_cast<int16_t>(std::ceil(rightx)), static_cast<int16_t>(std::ceil(ymax)));
100          if (blobindex == 0) {
101            box = TBOX(bl, tr); 
102          } else {
103            newblob = new BLOBNBOX;
104            newblob->box = TBOX(bl, tr);
105            newblob->base_char_top_ = tr.y();
106            newblob->base_char_bottom_ = bl.y();
107            end_it->add_after_stay_put(newblob);
108          }
109        }
110      }
111    }
112  }
113  void BLOBNBOX::NeighbourGaps(int gaps[BND_COUNT]) const {
114    for (int dir = 0; dir < BND_COUNT; ++dir) {
115      gaps[dir] = INT16_MAX;
116      BLOBNBOX *neighbour = neighbours_[dir];
117      if (neighbour != nullptr) {
118        const TBOX &n_box = neighbour->bounding_box();
119        if (dir == BND_LEFT || dir == BND_RIGHT) {
120          gaps[dir] = box.x_gap(n_box);
121        } else {
122          gaps[dir] = box.y_gap(n_box);
123        }
124      }
125    }
126  }
127  void BLOBNBOX::MinMaxGapsClipped(int *h_min, int *h_max, int *v_min, int *v_max) const {
128    int max_dimension = std::max(box.width(), box.height());
129    int gaps[BND_COUNT];
130    NeighbourGaps(gaps);
131    *h_min = std::min(gaps[BND_LEFT], gaps[BND_RIGHT]);
132    *h_max = std::max(gaps[BND_LEFT], gaps[BND_RIGHT]);
133    if (*h_max > max_dimension && *h_min < max_dimension) {
134      *h_max = *h_min;
135    }
136    *v_min = std::min(gaps[BND_ABOVE], gaps[BND_BELOW]);
137    *v_max = std::max(gaps[BND_ABOVE], gaps[BND_BELOW]);
138    if (*v_max > max_dimension && *v_min < max_dimension) {
139      *v_max = *v_min;
140    }
141  }
142  void BLOBNBOX::CleanNeighbours() {
143    for (int dir = 0; dir < BND_COUNT; ++dir) {
144      BLOBNBOX *neighbour = neighbours_[dir];
145      if (neighbour != nullptr && neighbour->DeletableNoise()) {
146        neighbours_[dir] = nullptr;
147        good_stroke_neighbours_[dir] = false;
148      }
149    }
150  }
151  int BLOBNBOX::GoodTextBlob() const {
152    int score = 0;
153    for (int dir = 0; dir < BND_COUNT; ++dir) {
154      auto bnd = static_cast<BlobNeighbourDir>(dir);
155      if (good_stroke_neighbour(bnd)) {
156        ++score;
157      }
158    }
159    return score;
160  }
161  int BLOBNBOX::NoisyNeighbours() const {
162    int count = 0;
163    for (int dir = 0; dir < BND_COUNT; ++dir) {
164      auto bnd = static_cast<BlobNeighbourDir>(dir);
165      BLOBNBOX *blob = neighbour(bnd);
166      if (blob != nullptr && blob->region_type() == BRT_NOISE) {
167        ++count;
168      }
169    }
170    return count;
171  }
172  bool BLOBNBOX::DefiniteIndividualFlow() {
173    if (cblob() == nullptr) {
174      return false;
175    }
176    int box_perimeter = 2 * (box.height() + box.width());
177    if (box.width() > box.height() * kDefiniteAspectRatio) {
178      int perimeter = cblob()->perimeter();
179      if (vert_stroke_width() > 0 || perimeter <= 0) {
180        perimeter -= 2 * vert_stroke_width();
181      } else {
182        perimeter -= 4 * cblob()->area() / perimeter;
183      }
184      perimeter -= 2 * box.width();
185      if (perimeter > kComplexShapePerimeterRatio * box_perimeter) {
186        set_vert_possible(false);
187        set_horz_possible(true);
188        return true;
189      }
190    }
191    if (box.height() > box.width() * kDefiniteAspectRatio) {
192      int perimeter = cblob()->perimeter();
193      if (horz_stroke_width() > 0 || perimeter <= 0) {
194        perimeter -= 2 * horz_stroke_width();
195      } else {
196        perimeter -= 4 * cblob()->area() / perimeter;
197      }
198      perimeter -= 2 * box.height();
199      if (perimeter > kComplexShapePerimeterRatio * box_perimeter) {
200        set_vert_possible(true);
201        set_horz_possible(false);
202        return true;
203      }
204    }
205    return false;
206  }
207  bool BLOBNBOX::ConfirmNoTabViolation(const BLOBNBOX &other) const {
<span onclick='openModal()' class='match'>208    if (box.left() < other.box.left() && box.left() < other.left_rule_) {
209      return false;
210    }
211    if (other.box.left() < box.left() && other.box.left() < left_rule_) {
212      return false;
213    }
214    if (box.right() > other.box.right() && box.right() > other.right_rule_) {
</span>215      return false;
216    }
217    if (other.box.right() > box.right() && other.box.right() > right_rule_) {
218      return false;
219    }
220    return true;
221  }
222  bool BLOBNBOX::MatchingStrokeWidth(const BLOBNBOX &other, double fractional_tolerance,
223                                     double constant_tolerance) const {
224    double p_width = area_stroke_width();
225    double n_p_width = other.area_stroke_width();
226    float h_tolerance = horz_stroke_width_ * fractional_tolerance + constant_tolerance;
227    float v_tolerance = vert_stroke_width_ * fractional_tolerance + constant_tolerance;
228    double p_tolerance = p_width * fractional_tolerance + constant_tolerance;
229    bool h_zero = horz_stroke_width_ == 0.0f || other.horz_stroke_width_ == 0.0f;
230    bool v_zero = vert_stroke_width_ == 0.0f || other.vert_stroke_width_ == 0.0f;
231    bool h_ok = !h_zero && NearlyEqual(horz_stroke_width_, other.horz_stroke_width_, h_tolerance);
232    bool v_ok = !v_zero && NearlyEqual(vert_stroke_width_, other.vert_stroke_width_, v_tolerance);
233    bool p_ok = h_zero && v_zero && NearlyEqual(p_width, n_p_width, p_tolerance);
234    return p_ok || ((v_ok || h_ok) && (h_ok || h_zero) && (v_ok || v_zero));
235  }
236  TBOX BLOBNBOX::BoundsWithinLimits(int left, int right) {
237    FCOORD no_rotation(1.0f, 0.0f);
238    float top = box.top();
239    float bottom = box.bottom();
240    if (cblob_ptr != nullptr) {
241      find_cblob_limits(cblob_ptr, static_cast<float>(left), static_cast<float>(right), no_rotation,
242                        bottom, top);
243    }
244    if (top < bottom) {
245      top = box.top();
246      bottom = box.bottom();
247    }
248    FCOORD bot_left(left, bottom);
249    FCOORD top_right(right, top);
250    TBOX shrunken_box(bot_left);
251    TBOX shrunken_box2(top_right);
252    shrunken_box += shrunken_box2;
253    return shrunken_box;
254  }
255  void BLOBNBOX::EstimateBaselinePosition() {
256    baseline_y_ = box.bottom(); 
257    if (cblob_ptr == nullptr) {
258      return;
259    }
260    baseline_y_ = cblob_ptr->EstimateBaselinePosition();
261  }
262  void BLOBNBOX::CleanNeighbours(BLOBNBOX_LIST *blobs) {
263    BLOBNBOX_IT blob_it(blobs);
264    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
265      blob_it.data()->CleanNeighbours();
266    }
267  }
268  void BLOBNBOX::DeleteNoiseBlobs(BLOBNBOX_LIST *blobs) {
269    BLOBNBOX_IT blob_it(blobs);
270    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
271      BLOBNBOX *blob = blob_it.data();
272      if (blob->DeletableNoise()) {
273        delete blob->remove_cblob();
274        delete blob_it.extract();
275      }
276    }
277  }
278  void BLOBNBOX::ComputeEdgeOffsets(Image thresholds, Image grey, BLOBNBOX_LIST *blobs) {
279    int grey_height = 0;
280    int thr_height = 0;
281    int scale_factor = 1;
282    if (thresholds != nullptr && grey != nullptr) {
283      grey_height = pixGetHeight(grey);
284      thr_height = pixGetHeight(thresholds);
285      scale_factor = IntCastRounded(static_cast<double>(grey_height) / thr_height);
286    }
287    BLOBNBOX_IT blob_it(blobs);
288    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
289      BLOBNBOX *blob = blob_it.data();
290      if (blob->cblob() != nullptr) {
291        l_uint32 threshold = 128;
292        if (thresholds != nullptr && grey != nullptr) {
293          const TBOX &box = blob->cblob()->bounding_box();
294          TPOINT pt((box.left() + box.right()) / 2, (box.top() + box.bottom()) / 2);
295          pixGetPixel(thresholds, pt.x / scale_factor, thr_height - 1 - pt.y / scale_factor,
296                      &threshold);
297        }
298        blob->cblob()->ComputeEdgeOffsets(threshold, grey);
299      }
300    }
301  }
302  #ifndef GRAPHICS_DISABLED
303  void BLOBNBOX::PlotBlobs(BLOBNBOX_LIST *list, ScrollView::Color body_colour,
304                           ScrollView::Color child_colour, ScrollView *win) {
305    BLOBNBOX_IT it(list);
306    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
307      it.data()->plot(win, body_colour, child_colour);
308    }
309  }
310  void BLOBNBOX::PlotNoiseBlobs(BLOBNBOX_LIST *list, ScrollView::Color body_colour,
311                                ScrollView::Color child_colour, ScrollView *win) {
312    BLOBNBOX_IT it(list);
313    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
314      BLOBNBOX *blob = it.data();
315      if (blob->DeletableNoise()) {
316        blob->plot(win, body_colour, child_colour);
317      }
318    }
319  }
320  ScrollView::Color BLOBNBOX::TextlineColor(BlobRegionType region_type, BlobTextFlowType flow_type) {
321    switch (region_type) {
322      case BRT_HLINE:
323        return ScrollView::BROWN;
324      case BRT_VLINE:
325        return ScrollView::DARK_GREEN;
326      case BRT_RECTIMAGE:
327        return ScrollView::RED;
328      case BRT_POLYIMAGE:
329        return ScrollView::ORANGE;
330      case BRT_UNKNOWN:
331        return flow_type == BTFT_NONTEXT ? ScrollView::CYAN : ScrollView::WHITE;
332      case BRT_VERT_TEXT:
333        if (flow_type == BTFT_STRONG_CHAIN || flow_type == BTFT_TEXT_ON_IMAGE) {
334          return ScrollView::GREEN;
335        }
336        if (flow_type == BTFT_CHAIN) {
337          return ScrollView::LIME_GREEN;
338        }
339        return ScrollView::YELLOW;
340      case BRT_TEXT:
341        if (flow_type == BTFT_STRONG_CHAIN) {
342          return ScrollView::BLUE;
343        }
344        if (flow_type == BTFT_TEXT_ON_IMAGE) {
345          return ScrollView::LIGHT_BLUE;
346        }
347        if (flow_type == BTFT_CHAIN) {
348          return ScrollView::MEDIUM_BLUE;
349        }
350        if (flow_type == BTFT_LEADER) {
351          return ScrollView::WHEAT;
352        }
353        if (flow_type == BTFT_NONTEXT) {
354          return ScrollView::PINK;
355        }
356        return ScrollView::MAGENTA;
357      default:
358        return ScrollView::GREY;
359    }
360  }
361  ScrollView::Color BLOBNBOX::BoxColor() const {
362    return TextlineColor(region_type_, flow_);
363  }
364  void BLOBNBOX::plot(ScrollView *window,               
365                      ScrollView::Color blob_colour,    
366                      ScrollView::Color child_colour) { 
367    if (cblob_ptr != nullptr) {
368      cblob_ptr->plot(window, blob_colour, child_colour);
369    }
370  }
371  #endif
372  void find_cblob_limits( 
373      C_BLOB *blob,       
374      float leftx,        
375      float rightx,
376      FCOORD rotation, 
377      float &ymin,     
378      float &ymax) {
379    int16_t stepindex;  
380    ICOORD pos;         
381    ICOORD vec;         
382    C_OUTLINE *outline; 
383    C_OUTLINE_IT out_it = blob->out_list();
384    ymin = static_cast<float>(INT32_MAX);
385    ymax = static_cast<float>(-INT32_MAX);
386    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
387      outline = out_it.data();
388      pos = outline->start_pos(); 
389      pos.rotate(rotation);
390      for (stepindex = 0; stepindex < outline->pathlength(); stepindex++) {
391        if (pos.x() >= leftx && pos.x() <= rightx) {
392          UpdateRange(pos.y(), &ymin, &ymax);
393        }
394        vec = outline->step(stepindex);
395        vec.rotate(rotation);
396        pos += vec; 
397      }
398    }
399  }
400  void find_cblob_vlimits( 
401      C_BLOB *blob,        
402      float leftx,         
403      float rightx,
404      float &ymin, 
405      float &ymax) {
406    int16_t stepindex;  
407    ICOORD pos;         
408    ICOORD vec;         
409    C_OUTLINE *outline; 
410    C_OUTLINE_IT out_it = blob->out_list();
411    ymin = static_cast<float>(INT32_MAX);
412    ymax = static_cast<float>(-INT32_MAX);
413    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
414      outline = out_it.data();
415      pos = outline->start_pos(); 
416      for (stepindex = 0; stepindex < outline->pathlength(); stepindex++) {
417        if (pos.x() >= leftx && pos.x() <= rightx) {
418          UpdateRange(pos.y(), &ymin, &ymax);
419        }
420        vec = outline->step(stepindex);
421        pos += vec; 
422      }
423    }
424  }
425  void find_cblob_hlimits( 
426      C_BLOB *blob,        
427      float bottomy,       
428      float topy,
429      float &xmin, 
430      float &xmax) {
431    int16_t stepindex;  
432    ICOORD pos;         
433    ICOORD vec;         
434    C_OUTLINE *outline; 
435    C_OUTLINE_IT out_it = blob->out_list();
436    xmin = static_cast<float>(INT32_MAX);
437    xmax = static_cast<float>(-INT32_MAX);
438    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
439      outline = out_it.data();
440      pos = outline->start_pos(); 
441      for (stepindex = 0; stepindex < outline->pathlength(); stepindex++) {
442        if (pos.y() >= bottomy && pos.y() <= topy) {
443          UpdateRange(pos.x(), &xmin, &xmax);
444        }
445        vec = outline->step(stepindex);
446        pos += vec; 
447      }
448    }
449  }
450  C_BLOB *crotate_cblob( 
451      C_BLOB *blob,      
452      FCOORD rotation    
453  ) {
454    C_OUTLINE_LIST out_list; 
455    C_OUTLINE_IT in_it = blob->out_list();
456    C_OUTLINE_IT out_it = &out_list;
457    for (in_it.mark_cycle_pt(); !in_it.cycled_list(); in_it.forward()) {
458      out_it.add_after_then_move(new C_OUTLINE(in_it.data(), rotation));
459    }
460    return new C_BLOB(&out_list);
461  }
462  TBOX box_next(      
463      BLOBNBOX_IT *it 
464  ) {
465    BLOBNBOX *blob; 
466    TBOX result;    
467    blob = it->data();
468    result = blob->bounding_box();
469    do {
470      it->forward();
471      blob = it->data();
472      if (blob->cblob() == nullptr) {
473        result += blob->bounding_box();
474      }
475    }
476    while ((blob->cblob() == nullptr) || blob->joined_to_prev());
477    return result;
478  }
479  TBOX box_next_pre_chopped( 
480      BLOBNBOX_IT *it        
481  ) {
482    BLOBNBOX *blob; 
483    TBOX result;    
484    blob = it->data();
485    result = blob->bounding_box();
486    do {
487      it->forward();
488      blob = it->data();
489    }
490    while (blob->joined_to_prev());
491    return result;
492  }
493  TO_ROW::TO_ROW(     
494      BLOBNBOX *blob, 
495      float top,      
496      float bottom,   
497      float row_size  
498  ) {
499    clear();
500    y_min = bottom;
501    y_max = top;
502    initial_y_min = bottom;
503    float diff;              
504    BLOBNBOX_IT it = &blobs; 
505    it.add_to_end(blob);
506    diff = top - bottom - row_size;
507    if (diff > 0) {
508      y_max -= diff / 2;
509      y_min += diff / 2;
510    }
511    else if ((top - bottom) * 3 < row_size) {
512      diff = row_size / 3 + bottom - top;
513      y_max += diff / 2;
514      y_min -= diff / 2;
515    }
516  }
517  void TO_ROW::print() const {
518    tprintf(
519        "pitch=%d, fp=%g, fps=%g, fpns=%g, prs=%g, prns=%g,"
520        " spacing=%g xh=%g y_origin=%g xev=%d, asc=%g, desc=%g,"
521        " body=%g, minsp=%d maxnsp=%d, thr=%d kern=%g sp=%g\n",
522        pitch_decision, fixed_pitch, fp_space, fp_nonsp, pr_space, pr_nonsp, spacing, xheight,
523        y_origin, xheight_evidence, ascrise, descdrop, body_size, min_space, max_nonspace,
524        space_threshold, kern_size, space_size);
525  }
526  void TO_ROW::add_blob( 
527      BLOBNBOX *blob,    
528      float top,         
529      float bottom,      
530      float row_size     
531  ) {
532    float allowed;           
533    float available;         
534    BLOBNBOX_IT it = &blobs; 
535    it.add_to_end(blob);
536    allowed = row_size + y_min - y_max;
537    if (allowed > 0) {
538      available = top > y_max ? top - y_max : 0;
539      if (bottom < y_min) {
540        available += y_min - bottom;
541      }
542      if (available > 0) {
543        available += available; 
544        if (available < allowed) {
545          available = allowed;
546        }
547        if (bottom < y_min) {
548          y_min -= (y_min - bottom) * allowed / available;
549        }
550        if (top > y_max) {
551          y_max += (top - y_max) * allowed / available;
552        }
553      }
554    }
555  }
556  void TO_ROW::insert_blob( 
557      BLOBNBOX *blob        
558  ) {
559    BLOBNBOX_IT it = &blobs; 
560    if (it.empty()) {
561      it.add_before_then_move(blob);
562    } else {
563      it.mark_cycle_pt();
564      while (!it.cycled_list() && it.data()->bounding_box().left() <= blob->bounding_box().left()) {
565        it.forward();
566      }
567      if (it.cycled_list()) {
568        it.add_to_end(blob);
569      } else {
570        it.add_before_stay_put(blob);
571      }
572    }
573  }
574  void TO_ROW::compute_vertical_projection() { 
575    TBOX row_box;                              
576    BLOBNBOX *blob;                            
577    TBOX blob_box;                             
578    BLOBNBOX_IT blob_it = blob_list();
579    if (blob_it.empty()) {
580      return;
581    }
582    row_box = blob_it.data()->bounding_box();
583    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
584      row_box += blob_it.data()->bounding_box();
585    }
586    projection.set_range(row_box.left() - PROJECTION_MARGIN, row_box.right() + PROJECTION_MARGIN - 1);
587    projection_left = row_box.left() - PROJECTION_MARGIN;
588    projection_right = row_box.right() + PROJECTION_MARGIN;
589    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
590      blob = blob_it.data();
591      if (blob->cblob() != nullptr) {
592        vertical_cblob_projection(blob->cblob(), &projection);
593      }
594    }
595  }
596  void TO_ROW::clear() {
597    all_caps = false;
598    used_dm_model = false;
599    projection_left = 0;
600    projection_right = 0;
601    pitch_decision = PITCH_DUNNO;
602    fixed_pitch = 0.0;
603    fp_space = 0.0;
604    fp_nonsp = 0.0;
605    pr_space = 0.0;
606    pr_nonsp = 0.0;
607    spacing = 0.0;
608    xheight = 0.0;
609    xheight_evidence = 0;
610    body_size = 0.0;
611    ascrise = 0.0;
612    descdrop = 0.0;
613    min_space = 0;
614    max_nonspace = 0;
615    space_threshold = 0;
616    kern_size = 0.0;
617    space_size = 0.0;
618    y_min = 0.0;
619    y_max = 0.0;
620    initial_y_min = 0.0;
621    m = 0.0;
622    c = 0.0;
623    error = 0.0;
624    para_c = 0.0;
625    para_error = 0.0;
626    y_origin = 0.0;
627    credibility = 0.0;
628    num_repeated_sets_ = -1;
629  }
630  void vertical_cblob_projection( 
631      C_BLOB *blob,               
632      STATS *stats                
633  ) {
634    C_OUTLINE_IT out_it = blob->out_list();
635    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
636      vertical_coutline_projection(out_it.data(), stats);
637    }
638  }
639  void vertical_coutline_projection( 
640      C_OUTLINE *outline,            
641      STATS *stats                   
642  ) {
643    ICOORD pos;        
644    ICOORD step;       
645    int32_t length;    
646    int16_t stepindex; 
647    C_OUTLINE_IT out_it = outline->child();
648    pos = outline->start_pos();
649    length = outline->pathlength();
650    for (stepindex = 0; stepindex < length; stepindex++) {
651      step = outline->step(stepindex);
652      if (step.x() > 0) {
653        stats->add(pos.x(), -pos.y());
654      } else if (step.x() < 0) {
655        stats->add(pos.x() - 1, pos.y());
656      }
657      pos += step;
658    }
659    for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
660      vertical_coutline_projection(out_it.data(), stats);
661    }
662  }
663  TO_BLOCK::TO_BLOCK(  
664      BLOCK *src_block 
665  ) {
666    clear();
667    block = src_block;
668  }
669  void TO_BLOCK::clear() {
670    block = nullptr;
671    pitch_decision = PITCH_DUNNO;
672    line_spacing = 0.0;
673    line_size = 0.0;
674    max_blob_size = 0.0;
675    baseline_offset = 0.0;
676    xheight = 0.0;
677    fixed_pitch = 0.0;
678    kern_size = 0.0;
679    space_size = 0.0;
680    min_space = 0;
681    max_nonspace = 0;
682    fp_space = 0.0;
683    fp_nonsp = 0.0;
684    pr_space = 0.0;
685    pr_nonsp = 0.0;
686    key_row = nullptr;
687  }
688  TO_BLOCK::~TO_BLOCK() {
689    BLOBNBOX::clear_blobnboxes(&blobs);
690    BLOBNBOX::clear_blobnboxes(&underlines);
691    BLOBNBOX::clear_blobnboxes(&noise_blobs);
692    BLOBNBOX::clear_blobnboxes(&small_blobs);
693    BLOBNBOX::clear_blobnboxes(&large_blobs);
694  }
695  static void SizeFilterBlobs(int min_height, int max_height, BLOBNBOX_LIST *src_list,
696                              BLOBNBOX_LIST *noise_list, BLOBNBOX_LIST *small_list,
697                              BLOBNBOX_LIST *medium_list, BLOBNBOX_LIST *large_list) {
698    BLOBNBOX_IT noise_it(noise_list);
699    BLOBNBOX_IT small_it(small_list);
700    BLOBNBOX_IT medium_it(medium_list);
701    BLOBNBOX_IT large_it(large_list);
702    for (BLOBNBOX_IT src_it(src_list); !src_it.empty(); src_it.forward()) {
703      BLOBNBOX *blob = src_it.extract();
704      blob->ReInit();
705      int width = blob->bounding_box().width();
706      int height = blob->bounding_box().height();
707      if (height < min_height && (width < min_height || width > max_height)) {
708        noise_it.add_after_then_move(blob);
709      } else if (height > max_height) {
710        large_it.add_after_then_move(blob);
711      } else if (height < min_height) {
712        small_it.add_after_then_move(blob);
713      } else {
714        medium_it.add_after_then_move(blob);
715      }
716    }
717  }
718  void TO_BLOCK::ReSetAndReFilterBlobs() {
719    int min_height = IntCastRounded(kMinMediumSizeRatio * line_size);
720    int max_height = IntCastRounded(kMaxMediumSizeRatio * line_size);
721    BLOBNBOX_LIST noise_list;
722    BLOBNBOX_LIST small_list;
723    BLOBNBOX_LIST medium_list;
724    BLOBNBOX_LIST large_list;
725    SizeFilterBlobs(min_height, max_height, &blobs, &noise_list, &small_list, &medium_list,
726                    &large_list);
727    SizeFilterBlobs(min_height, max_height, &large_blobs, &noise_list, &small_list, &medium_list,
728                    &large_list);
729    SizeFilterBlobs(min_height, max_height, &small_blobs, &noise_list, &small_list, &medium_list,
730                    &large_list);
731    SizeFilterBlobs(min_height, max_height, &noise_blobs, &noise_list, &small_list, &medium_list,
732                    &large_list);
733    BLOBNBOX_IT blob_it(&blobs);
734    blob_it.add_list_after(&medium_list);
735    blob_it.set_to_list(&large_blobs);
736    blob_it.add_list_after(&large_list);
737    blob_it.set_to_list(&small_blobs);
738    blob_it.add_list_after(&small_list);
739    blob_it.set_to_list(&noise_blobs);
740    blob_it.add_list_after(&noise_list);
741  }
742  void TO_BLOCK::DeleteUnownedNoise() {
743    BLOBNBOX::CleanNeighbours(&blobs);
744    BLOBNBOX::CleanNeighbours(&small_blobs);
745    BLOBNBOX::CleanNeighbours(&noise_blobs);
746    BLOBNBOX::CleanNeighbours(&large_blobs);
747    BLOBNBOX::DeleteNoiseBlobs(&blobs);
748    BLOBNBOX::DeleteNoiseBlobs(&small_blobs);
749    BLOBNBOX::DeleteNoiseBlobs(&noise_blobs);
750    BLOBNBOX::DeleteNoiseBlobs(&large_blobs);
751  }
752  void TO_BLOCK::ComputeEdgeOffsets(Image thresholds, Image grey) {
753    BLOBNBOX::ComputeEdgeOffsets(thresholds, grey, &blobs);
754    BLOBNBOX::ComputeEdgeOffsets(thresholds, grey, &small_blobs);
755    BLOBNBOX::ComputeEdgeOffsets(thresholds, grey, &noise_blobs);
756  }
757  #ifndef GRAPHICS_DISABLED
758  void TO_BLOCK::plot_noise_blobs(ScrollView *win) {
759    BLOBNBOX::PlotNoiseBlobs(&noise_blobs, ScrollView::RED, ScrollView::RED, win);
760    BLOBNBOX::PlotNoiseBlobs(&small_blobs, ScrollView::RED, ScrollView::RED, win);
761    BLOBNBOX::PlotNoiseBlobs(&large_blobs, ScrollView::RED, ScrollView::RED, win);
762    BLOBNBOX::PlotNoiseBlobs(&blobs, ScrollView::RED, ScrollView::RED, win);
763  }
764  void TO_BLOCK::plot_graded_blobs(ScrollView *win) {
765    BLOBNBOX::PlotBlobs(&noise_blobs, ScrollView::CORAL, ScrollView::BLUE, win);
766    BLOBNBOX::PlotBlobs(&small_blobs, ScrollView::GOLDENROD, ScrollView::YELLOW, win);
767    BLOBNBOX::PlotBlobs(&large_blobs, ScrollView::DARK_GREEN, ScrollView::YELLOW, win);
768    BLOBNBOX::PlotBlobs(&blobs, ScrollView::WHITE, ScrollView::BROWN, win);
769  }
770  void plot_blob_list(ScrollView *win,                  
771                      BLOBNBOX_LIST *list,              
772                      ScrollView::Color body_colour,    
773                      ScrollView::Color child_colour) { 
774    BLOBNBOX_IT it = list;
775    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
776      it.data()->plot(win, body_colour, child_colour);
777    }
778  }
779  #endif 
780  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_exception_safety_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobbox.cpp</div>
                </div>
                <div class="column column_space"><pre><code>95    if (vec->begin() > vec->end()) return false;
96    if ((vec->end() - vec->begin()) != vec->size()) return false;
97    if (std::distance(vec->begin(), vec->end()) != vec->size()) return false;
</pre></code></div>
                <div class="column column_space"><pre><code>208    if (box.left() < other.box.left() && box.left() < other.left_rule_) {
209      return false;
210    }
211    if (other.box.left() < box.left() && other.box.left() < left_rule_) {
212      return false;
213    }
214    if (box.right() > other.box.right() && box.right() > other.right_rule_) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    