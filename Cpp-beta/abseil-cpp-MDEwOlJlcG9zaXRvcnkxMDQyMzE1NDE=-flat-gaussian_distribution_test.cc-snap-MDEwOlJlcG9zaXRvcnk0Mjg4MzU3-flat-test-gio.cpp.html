
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.255144032921811%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-gaussian_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/gaussian_distribution.h"
2  #include <algorithm>
3  #include <cmath>
4  #include <cstddef>
5  #include <ios>
6  #include <iterator>
7  #include <random>
8  #include <string>
9  #include <type_traits>
10  #include <vector>
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/base/macros.h"
14  #include "absl/log/log.h"
15  #include "absl/numeric/internal/representation.h"
16  #include "absl/random/internal/chi_square.h"
17  #include "absl/random/internal/distribution_test_util.h"
18  #include "absl/random/internal/sequence_urbg.h"
19  #include "absl/random/random.h"
20  #include "absl/strings/str_cat.h"
21  #include "absl/strings/str_format.h"
22  #include "absl/strings/str_replace.h"
23  #include "absl/strings/strip.h"
24  namespace {
25  using absl::random_internal::kChiSquared;
26  template <typename RealType>
27  class GaussianDistributionInterfaceTest : public ::testing::Test {};
28  using RealTypes =
29      std::conditional<absl::numeric_internal::IsDoubleDouble(),
30                       ::testing::Types<float, double>,
31                       ::testing::Types<float, double, long double>>::type;
32  TYPED_TEST_SUITE(GaussianDistributionInterfaceTest, RealTypes);
33  TYPED_TEST(GaussianDistributionInterfaceTest, SerializeTest) {
34    using param_type =
35        typename absl::gaussian_distribution<TypeParam>::param_type;
36    const TypeParam kParams[] = {
37        1,                                           
38        std::nextafter(TypeParam(1), TypeParam(0)),  
39        std::nextafter(TypeParam(1), TypeParam(2)),  
40        TypeParam(1e-8), TypeParam(1e-4), TypeParam(2), TypeParam(1e4),
41        TypeParam(1e8), TypeParam(1e20), TypeParam(2.5),
42        std::numeric_limits<TypeParam>::infinity(),
43        std::numeric_limits<TypeParam>::max(),
44        std::numeric_limits<TypeParam>::epsilon(),
45        std::nextafter(std::numeric_limits<TypeParam>::min(),
46                       TypeParam(1)),           
47        std::numeric_limits<TypeParam>::min(),  
48        std::numeric_limits<TypeParam>::denorm_min(),  
49        std::numeric_limits<TypeParam>::min() / 2,
50        std::nextafter(std::numeric_limits<TypeParam>::min(),
51                       TypeParam(0)),  
52    };
53    constexpr int kCount = 1000;
54    absl::InsecureBitGen gen;
55    for (const auto mod : {0, 1, 2, 3}) {
56      for (const auto x : kParams) {
57        if (!std::isfinite(x)) continue;
58        for (const auto y : kParams) {
59          const TypeParam mean = (mod & 0x1) ? -x : x;
60          const TypeParam stddev = (mod & 0x2) ? -y : y;
61          const param_type param(mean, stddev);
62          absl::gaussian_distribution<TypeParam> before(mean, stddev);
63          EXPECT_EQ(before.mean(), param.mean());
64          EXPECT_EQ(before.stddev(), param.stddev());
65          {
66            absl::gaussian_distribution<TypeParam> via_param(param);
67            EXPECT_EQ(via_param, before);
68            EXPECT_EQ(via_param.param(), before.param());
69          }
<span onclick='openModal()' class='match'>70          auto sample_min = before.max();
71          auto sample_max = before.min();
72          for (int i = 0; i < kCount; i++) {
73            auto sample = before(gen);
</span>74            if (sample > sample_max) sample_max = sample;
75            if (sample < sample_min) sample_min = sample;
76            EXPECT_GE(sample, before.min()) << before;
77            EXPECT_LE(sample, before.max()) << before;
78          }
79          if (!std::is_same<TypeParam, long double>::value) {
80            LOG(INFO) << "Range{" << mean << ", " << stddev << "}: " << sample_min
81                      << ", " << sample_max;
82          }
83          std::stringstream ss;
84          ss << before;
85          if (!std::isfinite(mean) || !std::isfinite(stddev)) {
86            continue;
87          }
88          absl::gaussian_distribution<TypeParam> after(-0.53f, 2.3456f);
89          EXPECT_NE(before.mean(), after.mean());
90          EXPECT_NE(before.stddev(), after.stddev());
91          EXPECT_NE(before.param(), after.param());
92          EXPECT_NE(before, after);
93          ss >> after;
94          EXPECT_EQ(before.mean(), after.mean());
95          EXPECT_EQ(before.stddev(), after.stddev())  
96              << ss.str() << " "                      
97              << (ss.good() ? "good " : "")           
98              << (ss.bad() ? "bad " : "")             
99              << (ss.eof() ? "eof " : "")             
100              << (ss.fail() ? "fail " : "");
101        }
102      }
103    }
104  }
105  class GaussianModel {
106   public:
107    GaussianModel(double mean, double stddev) : mean_(mean), stddev_(stddev) {}
108    double mean() const { return mean_; }
109    double variance() const { return stddev() * stddev(); }
110    double stddev() const { return stddev_; }
111    double skew() const { return 0; }
112    double kurtosis() const { return 3.0; }
113    double InverseCDF(double p) {
114      ABSL_ASSERT(p >= 0.0);
115      ABSL_ASSERT(p < 1.0);
116      return mean() + stddev() * -absl::random_internal::InverseNormalSurvival(p);
117    }
118   private:
119    const double mean_;
120    const double stddev_;
121  };
122  struct Param {
123    double mean;
124    double stddev;
125    double p_fail;  
126    int trials;     
127  };
128  class GaussianDistributionTests : public testing::TestWithParam<Param>,
129                                    public GaussianModel {
130   public:
131    GaussianDistributionTests()
132        : GaussianModel(GetParam().mean, GetParam().stddev) {}
133    template <typename D>
134    bool SingleZTest(const double p, const size_t samples);
135    template <typename D>
136    double SingleChiSquaredTest();
137    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
138  };
139  template <typename D>
140  bool GaussianDistributionTests::SingleZTest(const double p,
141                                              const size_t samples) {
142    D dis(mean(), stddev());
143    std::vector<double> data;
144    data.reserve(samples);
145    for (size_t i = 0; i < samples; i++) {
146      const double x = dis(rng_);
147      data.push_back(x);
148    }
149    const double max_err = absl::random_internal::MaxErrorTolerance(p);
150    const auto m = absl::random_internal::ComputeDistributionMoments(data);
151    const double z = absl::random_internal::ZScore(mean(), m);
152    const bool pass = absl::random_internal::Near("z", z, 0.0, max_err);
153    const double jb =
154        static_cast<double>(m.n) / 6.0 *
155        (std::pow(m.skewness, 2.0) + std::pow(m.kurtosis - 3.0, 2.0) / 4.0);
156    if (!pass || jb > 9.21) {
157      LOG(INFO)
158          << "p=" << p << " max_err=" << max_err << "\n"
159             " mean=" << m.mean << " vs. " << mean() << "\n"
160             " stddev=" << std::sqrt(m.variance) << " vs. " << stddev() << "\n"
161             " skewness=" << m.skewness << " vs. " << skew() << "\n"
162             " kurtosis=" << m.kurtosis << " vs. " << kurtosis() << "\n"
163             " z=" << z << " vs. 0\n"
164             " jb=" << jb << " vs. 9.21";
165    }
166    return pass;
167  }
168  template <typename D>
169  double GaussianDistributionTests::SingleChiSquaredTest() {
170    const size_t kSamples = 10000;
171    const int kBuckets = 50;
172    std::vector<double> cutoffs;
173    const double kInc = 1.0 / static_cast<double>(kBuckets);
174    for (double p = kInc; p < 1.0; p += kInc) {
175      cutoffs.push_back(InverseCDF(p));
176    }
177    if (cutoffs.back() != std::numeric_limits<double>::infinity()) {
178      cutoffs.push_back(std::numeric_limits<double>::infinity());
179    }
180    D dis(mean(), stddev());
181    std::vector<int32_t> counts(cutoffs.size(), 0);
182    for (int j = 0; j < kSamples; j++) {
183      const double x = dis(rng_);
184      auto it = std::upper_bound(cutoffs.begin(), cutoffs.end(), x);
185      counts[std::distance(cutoffs.begin(), it)]++;
186    }
187    const int dof = static_cast<int>(counts.size()) - 1;
188    const double threshold = absl::random_internal::ChiSquareValue(dof, 0.98);
189    const double expected =
190        static_cast<double>(kSamples) / static_cast<double>(counts.size());
191    double chi_square = absl::random_internal::ChiSquareWithExpected(
192        std::begin(counts), std::end(counts), expected);
193    double p = absl::random_internal::ChiSquarePValue(chi_square, dof);
194    if (chi_square > threshold) {
195      for (size_t i = 0; i < cutoffs.size(); i++) {
196        LOG(INFO) << i << " : (" << cutoffs[i] << ") = " << counts[i];
197      }
198      LOG(INFO) << "mean=" << mean() << " stddev=" << stddev() << "\n"
199                   " expected " << expected << "\n"
200                << kChiSquared << " " << chi_square << " (" << p << ")\n"
201                << kChiSquared << " @ 0.98 = " << threshold;
202    }
203    return p;
204  }
205  TEST_P(GaussianDistributionTests, ZTest) {
206    const size_t kSamples = 10000;
207    const auto& param = GetParam();
208    const int expected_failures =
209        std::max(1, static_cast<int>(std::ceil(param.trials * param.p_fail)));
210    const double p = absl::random_internal::RequiredSuccessProbability(
211        param.p_fail, param.trials);
212    int failures = 0;
213    for (int i = 0; i < param.trials; i++) {
214      failures +=
215          SingleZTest<absl::gaussian_distribution<double>>(p, kSamples) ? 0 : 1;
216    }
217    EXPECT_LE(failures, expected_failures);
218  }
219  TEST_P(GaussianDistributionTests, ChiSquaredTest) {
220    const int kTrials = 20;
221    int failures = 0;
222    for (int i = 0; i < kTrials; i++) {
223      double p_value =
224          SingleChiSquaredTest<absl::gaussian_distribution<double>>();
225      if (p_value < 0.0025) {  
226        failures++;
227      }
228    }
229    EXPECT_LE(failures, 4);
230  }
231  std::vector<Param> GenParams() {
232    return {
233        Param{0.0, 1.0, 0.01, 100},
234        Param{0.0, 1e2, 0.01, 100},
235        Param{0.0, 1e4, 0.01, 100},
236        Param{0.0, 1e8, 0.01, 100},
237        Param{0.0, 1e16, 0.01, 100},
238        Param{0.0, 1e-3, 0.01, 100},
239        Param{0.0, 1e-5, 0.01, 100},
240        Param{0.0, 1e-9, 0.01, 100},
241        Param{0.0, 1e-17, 0.01, 100},
242        Param{1.0, 1.0, 0.01, 100},
243        Param{1.0, 1e2, 0.01, 100},
244        Param{1.0, 1e-2, 0.01, 100},
245        Param{1e2, 1.0, 0.01, 100},
246        Param{-1e2, 1.0, 0.01, 100},
247        Param{1e2, 1e6, 0.01, 100},
248        Param{-1e2, 1e6, 0.01, 100},
249        Param{1e4, 1e4, 0.01, 100},
250        Param{1e8, 1e4, 0.01, 100},
251        Param{1e12, 1e4, 0.01, 100},
252    };
253  }
254  std::string ParamName(const ::testing::TestParamInfo<Param>& info) {
255    const auto& p = info.param;
256    std::string name = absl::StrCat("mean_", absl::SixDigits(p.mean), "__stddev_",
257                                    absl::SixDigits(p.stddev));
258    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
259  }
260  INSTANTIATE_TEST_SUITE_P(All, GaussianDistributionTests,
261                           ::testing::ValuesIn(GenParams()), ParamName);
262  TEST(GaussianDistributionTest, StabilityTest) {
263    absl::random_internal::sequence_urbg urbg(
264        {0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull, 0xC332DDEFBE6C5AA5ull,
265         0x6558218568AB9702ull, 0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull,
266         0xECDD4775619F1510ull, 0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull,
267         0xB5735C904C70A239ull, 0xD59E9E0BCBAADE14ull, 0xEECC86BC60622CA7ull});
268    std::vector<int> output(11);
269    {
270      absl::gaussian_distribution<double> dist;
271      std::generate(std::begin(output), std::end(output),
272                    [&] { return static_cast<int>(10000000.0 * dist(urbg)); });
273      EXPECT_EQ(13, urbg.invocations());
274      EXPECT_THAT(output,  
275                  testing::ElementsAre(1494, 25518841, 9991550, 1351856,
276                                       -20373238, 3456682, 333530, -6804981,
277                                       -15279580, -16459654, 1494));
278    }
279    urbg.reset();
280    {
281      absl::gaussian_distribution<float> dist;
282      std::generate(std::begin(output), std::end(output),
283                    [&] { return static_cast<int>(1000000.0f * dist(urbg)); });
284      EXPECT_EQ(13, urbg.invocations());
285      EXPECT_THAT(
286          output,  
287          testing::ElementsAre(149, 2551884, 999155, 135185, -2037323, 345668,
288                               33353, -680498, -1527958, -1645965, 149));
289    }
290  }
291  TEST(GaussianDistributionTest, AlgorithmBounds) {
292    absl::gaussian_distribution<double> dist;
293    const uint64_t kValues[] = {
294        0x1000000000000100ull, 0x2000000000000100ull, 0x3000000000000100ull,
295        0x4000000000000100ull, 0x5000000000000100ull, 0x6000000000000100ull,
296        0x9000000000000100ull, 0xa000000000000100ull, 0xb000000000000100ull,
297        0xc000000000000100ull, 0xd000000000000100ull, 0xe000000000000100ull};
298    const uint64_t kExtraValues[] = {
299        0x7000000000000100ull, 0x7800000000000100ull,  
300        0x7c00000000000100ull, 0x7e00000000000100ull,  
301        0xf000000000000100ull, 0xf800000000000100ull,  
302        0xfc00000000000100ull, 0xfe00000000000100ull};
303    auto make_box = [](uint64_t v, uint64_t box) {
304      return (v & 0xffffffffffffff80ull) | box;
305    };
306    for (uint64_t box = 0; box < 0x7f; box++) {
307      for (const uint64_t v : kValues) {
308        absl::random_internal::sequence_urbg urbg(
309            {make_box(v, box), 0x0003eb76f6f7f755ull, 0x5FCEA50FDB2F953Bull});
310        auto a = dist(urbg);
311        EXPECT_EQ(1, urbg.invocations()) << box << " " << std::hex << v;
312        if (v & 0x8000000000000000ull) {
313          EXPECT_LT(a, 0.0) << box << " " << std::hex << v;
314        } else {
315          EXPECT_GT(a, 0.0) << box << " " << std::hex << v;
316        }
317      }
318      if (box > 10 && box < 100) {
319        for (const uint64_t v : kExtraValues) {
320          absl::random_internal::sequence_urbg urbg(
321              {make_box(v, box), 0x0003eb76f6f7f755ull, 0x5FCEA50FDB2F953Bull});
322          auto a = dist(urbg);
323          EXPECT_EQ(1, urbg.invocations()) << box << " " << std::hex << v;
324          if (v & 0x8000000000000000ull) {
325            EXPECT_LT(a, 0.0) << box << " " << std::hex << v;
326          } else {
327            EXPECT_GT(a, 0.0) << box << " " << std::hex << v;
328          }
329        }
330      }
331    }
332    auto make_fallback = [](uint64_t v) { return (v & 0xffffffffffffff80ull); };
333    double tail[2];
334    {
335      absl::random_internal::sequence_urbg urbg(
336          {make_fallback(0x7800000000000000ull), 0x13CCA830EB61BD96ull,
337           0x00000076f6f7f755ull});
338      tail[0] = dist(urbg);
339      EXPECT_EQ(3, urbg.invocations());
340      EXPECT_GT(tail[0], 0);
341    }
342    {
343      absl::random_internal::sequence_urbg urbg(
344          {make_fallback(0xf800000000000000ull), 0x13CCA830EB61BD96ull,
345           0x00000076f6f7f755ull});
346      tail[1] = dist(urbg);
347      EXPECT_EQ(3, urbg.invocations());
348      EXPECT_LT(tail[1], 0);
349    }
350    EXPECT_EQ(tail[0], -tail[1]);
351    EXPECT_EQ(418610, static_cast<int64_t>(tail[0] * 100000.0));
352    {
353      absl::random_internal::sequence_urbg urbg(
354          {make_box(0x7f00000000000000ull, 120), 0xe000000000000001ull,
355           0x13CCA830EB61BD96ull});
356      tail[0] = dist(urbg);
357      EXPECT_EQ(2, urbg.invocations());
358      EXPECT_GT(tail[0], 0);
359    }
360    {
361      absl::random_internal::sequence_urbg urbg(
362          {make_box(0xff00000000000000ull, 120), 0xe000000000000001ull,
363           0x13CCA830EB61BD96ull});
364      tail[1] = dist(urbg);
365      EXPECT_EQ(2, urbg.invocations());
366      EXPECT_LT(tail[1], 0);
367    }
368    EXPECT_EQ(tail[0], -tail[1]);
369    EXPECT_EQ(61948, static_cast<int64_t>(tail[0] * 100000.0));
370    {
371      absl::random_internal::sequence_urbg urbg(
372          {make_box(0xff00000000000000ull, 120), 0x1000000000000001,
373           make_box(0x1000000000000100ull, 50), 0x13CCA830EB61BD96ull});
374      dist(urbg);
375      EXPECT_EQ(3, urbg.invocations());
376    }
377  }
378  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-gio.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  #include "test-helper.h"
4  class GIOTest { };  
5  using namespace TSnap;
6  template <class PGraph>
7  void TestEdgeList() {
8    const int NNodes = 10000;
9    const int NEdges = 100000;
10    const char *FName = "test.graph.dat";
11    const char *Desc = "Randomly generated graph for input/output.";
12    PGraph GOut, GIn;
13    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
14    SaveEdgeList(GOut, FName, Desc);
15    EXPECT_TRUE(fileExists(FName));
16    EXPECT_FALSE(GOut->Empty());
17    GIn = LoadEdgeList<PGraph>(FName);
18    THashSet<TInt> OutNIdH, InNIdH;
19    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
20      if (NI.GetDeg() > 0) {
21        OutNIdH.AddKey(NI.GetId());
22      }
23    }
24    for (typename PGraph::TObj::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
25      InNIdH.AddKey(NI.GetId());
26    }
27    EXPECT_TRUE(OutNIdH == InNIdH);
28    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
29      TInt Src = EI.GetSrcNId();
30      TInt Dst = EI.GetDstNId();
31      EXPECT_TRUE(GIn->IsEdge(Src, Dst));
32    }
33    for (typename PGraph::TObj::TEdgeI EI = GIn->BegEI(); EI < GIn->EndEI(); EI++) {
34      TInt Src = EI.GetSrcNId();
35      TInt Dst = EI.GetDstNId();
36      EXPECT_TRUE(GOut->IsEdge(Src, Dst));
37    }
38    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());
39  }
40  TEST(GIOTest, SaveLoadEdgeList) {
41    TestEdgeList<PUNGraph>();
42    TestEdgeList<PNGraph>();
43    TestEdgeList<PNEGraph>();
44  }
45  template <class PGraph>
46  void TestEdgeListStr() {
47    const int NNodes = 1000;
48    const int NEdges = 10000;
49    const char *FName = "test.graph.dat";
50    PGraph GOut, GIn;
51    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
52    TIntStrH OutNIdStrH;
53    TStrHash<TInt> OutStrNIdH;
54    TStr RandStr;
55    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
56      do {
<span onclick='openModal()' class='match'>57        RandStr.Clr();
58        TInt RandLen = TInt::Rnd.GetUniDevInt(5, 30);
59        for (int i = 0; i < RandLen; i++) {
60          TStr RandChar(TInt::Rnd.GetUniDevInt(33, 126));
</span>61          RandStr += RandChar;
62        }
63      }
64      while (OutStrNIdH.IsKey(RandStr) || RandStr[0] == '#'); 
65      OutNIdStrH.AddDat(NI.GetId(), RandStr);
66      OutStrNIdH.AddDat(RandStr, NI.GetId());
67    }
68    FILE *F = fopen(FName, "w");
69    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
70      TInt Src = EI.GetSrcNId();
71      TInt Dst = EI.GetDstNId();
72      fprintf(F, "%s %s\n", OutNIdStrH[Src].CStr(), OutNIdStrH[Dst].CStr());
73    }
74    fclose(F);
75    ASSERT_TRUE(fileExists(FName));
76    EXPECT_FALSE(GOut->Empty());
77    TStrHash<TInt> InStrToNIdH;
78    GIn = LoadEdgeListStr<PGraph>(FName, 0, 1, InStrToNIdH);
79    ASSERT_TRUE(InStrToNIdH.Len() == GOut->GetNodes());
80    for (typename PGraph::TObj::TEdgeI EI = GIn->BegEI(); EI < GIn->EndEI(); EI++) {
81      TStr SrcStr = InStrToNIdH.GetKey(EI.GetSrcNId());
82      TStr DstStr = InStrToNIdH.GetKey(EI.GetDstNId());
83      TInt OutSrc = OutStrNIdH.GetKeyId(SrcStr);
84      TInt OutDst = OutStrNIdH.GetKeyId(DstStr);
85      ASSERT_TRUE(GOut->IsEdge(OutSrc, OutDst));
86    }
87    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
88      TStr SrcStr = OutStrNIdH.GetKey(EI.GetSrcNId());
89      TStr DstStr = OutStrNIdH.GetKey(EI.GetDstNId());
90      TInt InSrc = InStrToNIdH.GetKeyId(SrcStr);
91      TInt InDst = InStrToNIdH.GetKeyId(DstStr);
92      ASSERT_TRUE(GIn->IsEdge(InSrc, InDst));
93    }
94    EXPECT_TRUE(GIn->GetNodes() == GOut->GetNodes());
95    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());
96  }
97  TEST(GIOTest, SaveLoadEdgeListStr) {
98    TestEdgeListStr<PUNGraph>();
99    TestEdgeListStr<PNGraph>();
100    TestEdgeListStr<PNEGraph>();
101  }
102  template <class PGraph>
103  void TestConnList() {
104    const int NNodes = 10000;
105    const int NEdges = 100000;
106    const char *FName = "test.graph.dat";
107    PGraph GOut, GIn;
108    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
109    FILE *F = fopen(FName, "w");
110    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
111      fprintf(F, "%d", NI.GetId());
112      for (int i = 0; i < NI.GetOutDeg(); i++) {
113        fprintf(F, " %d", NI.GetOutNId(i));
114      }
115      fprintf(F, "\n");
116    }
117    fclose(F);
118    ASSERT_TRUE(fileExists(FName));
119    EXPECT_FALSE(GOut->Empty());
120    TStrHash<TInt> InStrToNIdH;
121    GIn = LoadConnList<PGraph>(FName);
122    THashSet<TInt> OutNIdH, InNIdH;
123    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
124      if (NI.GetDeg() > 0) {
125        OutNIdH.AddKey(NI.GetId());
126      }
127    }
128    for (typename PGraph::TObj::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
129      InNIdH.AddKey(NI.GetId());
130    }
131    EXPECT_TRUE(OutNIdH == InNIdH);
132    EXPECT_TRUE(GIn->GetNodes() == GOut->GetNodes());
133    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
134      TInt Src = EI.GetSrcNId();
135      TInt Dst = EI.GetDstNId();
136      EXPECT_TRUE(GIn->IsEdge(Src, Dst));
137    }
138    for (typename PGraph::TObj::TEdgeI EI = GIn->BegEI(); EI < GIn->EndEI(); EI++) {
139      TInt Src = EI.GetSrcNId();
140      TInt Dst = EI.GetDstNId();
141      EXPECT_TRUE(GOut->IsEdge(Src, Dst));
142    }
143    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());
144  }
145  TEST(GIOTest, LoadConnList) {
146    TestConnList<PUNGraph>();
147    TestConnList<PNGraph>();
148    TestConnList<PNEGraph>();
149  }
150  template <class PGraph>
151  void TestConnListStr() {
152    const int NNodes = 10000;
153    const int NEdges = 100000;
154    const char *FName = "test.graph.dat";
155    PGraph GOut, GIn;
156    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
157    TIntStrH OutNIdStrH;
158    TStrHash<TInt> OutStrNIdH;
159    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
160      TStr RandStr = "";
161      do {
162        TInt RandLen = TInt::Rnd.GetUniDevInt(5, 10);
163        for (int i = 0; i < RandLen; i++) {
164          TStr RandChar(TInt::Rnd.GetUniDevInt(97, 122));
165          RandStr += RandChar;
166        }
167      }
168      while (OutStrNIdH.IsKey(RandStr) || RandStr[0] == '#');
169      OutNIdStrH.AddDat(NI.GetId(), RandStr);
170      OutStrNIdH.AddDat(RandStr, NI.GetId());
171    }
172    FILE *F = fopen(FName, "w");
173    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
174      fprintf(F, "%s", OutNIdStrH[NI.GetId()].CStr());
175      for (int e = 0; e < NI.GetOutDeg(); e++) {
176        fprintf(F, " %s", OutNIdStrH[NI.GetOutNId(e)].CStr());
177      }
178      fprintf(F, "\n");
179    }
180    fclose(F);
181    ASSERT_TRUE(fileExists(FName));
182    EXPECT_FALSE(GOut->Empty());
183    TStrHash<TInt> InStrToNIdH;
184    GIn = LoadConnListStr<PGraph>(FName, InStrToNIdH);
185    ASSERT_TRUE(InStrToNIdH.Len() == GOut->GetNodes());
186    for (typename PGraph::TObj::TEdgeI EI = GIn->BegEI(); EI < GIn->EndEI(); EI++) {
187      TStr SrcStr = InStrToNIdH.GetKey(EI.GetSrcNId());
188      TStr DstStr = InStrToNIdH.GetKey(EI.GetDstNId());
189      TInt OutSrc = OutStrNIdH.GetKeyId(SrcStr);
190      TInt OutDst = OutStrNIdH.GetKeyId(DstStr);
191      EXPECT_TRUE(GOut->IsEdge(OutSrc, OutDst));
192    }
193    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
194      TStr SrcStr = OutStrNIdH.GetKey(EI.GetSrcNId());
195      TStr DstStr = OutStrNIdH.GetKey(EI.GetDstNId());
196      TInt InSrc = InStrToNIdH.GetKeyId(SrcStr);
197      TInt InDst = InStrToNIdH.GetKeyId(DstStr);
198      EXPECT_TRUE(GIn->IsEdge(InSrc, InDst));
199    }
200    EXPECT_TRUE(GIn->GetNodes() == GOut->GetNodes());
201    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());  
202  }
203  TEST(GIOTest, LoadConnListStr) {
204    TestConnListStr<PUNGraph>();
205    TestConnListStr<PNGraph>();
206    TestConnListStr<PNEGraph>();
207  }
208  template <class PGraph>
209  void TestPajek() {
210    const int NNodes = 10000;
211    const int NEdges = 100000;
212    const char *FName = "test.paj.dat";
213    PGraph GOut, GIn;
214    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
215    SavePajek(GOut, FName);
216    EXPECT_TRUE(fileExists(FName));
217    EXPECT_FALSE(GOut->Empty());
218    GIn = LoadPajek<PGraph>(FName);
219    TIntV OutNIdV, InNIdV;
220    GOut->GetNIdV(OutNIdV);
221    for (int i = 0; i < OutNIdV.Len(); i++) {
222      OutNIdV[i]++;
223    }
224    GIn->GetNIdV(InNIdV);
225    EXPECT_TRUE(OutNIdV == InNIdV);
226    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
227      TInt Src = EI.GetSrcNId();
228      TInt Dst = EI.GetDstNId();
229      EXPECT_TRUE(GIn->IsEdge(Src+1, Dst+1));
230    }
231    for (typename PGraph::TObj::TEdgeI EI = GIn->BegEI(); EI < GIn->EndEI(); EI++) {
232      TInt Src = EI.GetSrcNId();
233      TInt Dst = EI.GetDstNId();
234      EXPECT_TRUE(GOut->IsEdge(Src-1, Dst-1));
235    }
236    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());
237  }
238  TEST(GIOTest, SaveLoadPajek) {
239    TestPajek<PUNGraph>();
240    TestPajek<PNGraph>();
241    TestPajek<PNEGraph>();
242  }
243  template <class PGraph>
244  void TestMatlabSparseMtx() {
245    const int NNodes = 10000;
246    const int NEdges = 100000;
247    const char *FName = "test.graph.dat";
248    PGraph GOut, GIn;
249    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
250    SaveMatlabSparseMtx(GOut, FName);
251    GIn = PGraph::TObj::New();
252    GIn->Reserve(NNodes, NEdges);
253    FILE *F = fopen(FName, "r");
254    while (! feof(F)) {
255      int Src, Dst, Edge;
256      EXPECT_TRUE(fscanf(F, "%d %d %d\n", &Src, &Dst, &Edge) == 3);
257      Src--; Dst--;             
258      if (not GIn->IsNode(Src)) {
259        GIn->AddNode(Src);
260      }
261      if (not GIn->IsNode(Dst)) {
262        GIn->AddNode(Dst);
263      }
264      GIn->AddEdge(Src, Dst);
265    }
266    fclose(F);
267    THashSet<TInt> OutNIdH, InNIdH;
268    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
269      if (NI.GetDeg() > 0) {
270        OutNIdH.AddKey(NI.GetId());
271      }
272    }
273    for (typename PGraph::TObj::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
274      InNIdH.AddKey(NI.GetId());
275    }
276    EXPECT_TRUE(OutNIdH == InNIdH);
277    for (typename PGraph::TObj::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
278      TInt Src = EI.GetSrcNId();
279      TInt Dst = EI.GetDstNId();
280      EXPECT_TRUE(GIn->IsEdge(Src, Dst));
281    }
282    for (typename PGraph::TObj::TEdgeI EI = GIn->BegEI(); EI < GIn->EndEI(); EI++) {
283      TInt Src = EI.GetSrcNId();
284      TInt Dst = EI.GetDstNId();
285      EXPECT_TRUE(GOut->IsEdge(Src, Dst));
286    }
287    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());
288  }
289  TEST(GIOTest, SaveMatlabSparseMtx) {
290    TestMatlabSparseMtx<PUNGraph>();
291    TestMatlabSparseMtx<PNGraph>();
292    TestMatlabSparseMtx<PNEGraph>();
293  }
294  template <class PGraph>
295  void TestSaveGViz() {
296    const int NNodes = 5;
297    const int NEdges = 8;
298    const char *FName1 = "test1.dot.dat", *FName2 = "test2.dot.dat";
299    const char *Desc = "Randomly generated GgraphVizp for input/output.";
300    PGraph GOut;
301    GOut = GenRndGnm<PGraph>(NNodes, NEdges);
302    SaveGViz(GOut, FName1);
303    EXPECT_TRUE(fileExists(FName1));
304    TIntStrH NIdLabelH;
305    for (typename PGraph::TObj::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
306      NIdLabelH.AddDat(NI.GetId(), TStr::Fmt("Node%d", NI.GetId()));
307    }
308    SaveGViz(GOut, FName2, Desc, NIdLabelH);
309    EXPECT_TRUE(fileExists(FName2));
310    EXPECT_FALSE(GOut->Empty());
311  }
312  TEST(GIOTest, SaveGViz) {
313    TestSaveGViz<PUNGraph>();
314    TestSaveGViz<PNGraph>();
315    TestSaveGViz<PNEGraph>();
316  }
317  TEST(GIOTest, LoadDyNet) {
318    const int NNodes = 10000;
319    const int NEdges = 100000;
320    const char *FName = "test.xml.dat";
321    PNGraph GOut, GIn;
322    GOut = GenRndGnm<PNGraph>(NNodes, NEdges);
323    FILE *F = fopen(FName, "w");
324    fprintf(F, "<network>\n");
325    for (TNGraph::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
326      TInt Src = EI.GetSrcNId();
327      TInt Dst = EI.GetDstNId();
328      fprintf(F, "\t<link source=\"%d\" target=\"%d\"/>\n", Src.Val, Dst.Val);
329    }
330    fprintf(F, "</network>\n");
331    fclose(F);
332    GIn = LoadDyNet(FName);
333    EXPECT_TRUE(GIn->GetNodes() == GOut->GetNodes());
334    TIntV GOutInDegV, GOutOutDegV, GInInDegV, GInOutDegV;
335    GetDegSeqV(GOut, GOutInDegV, GOutOutDegV);
336    GetDegSeqV(GOut, GInInDegV, GInOutDegV);
337    EXPECT_TRUE(GOutInDegV == GInInDegV);
338    EXPECT_TRUE(GOutOutDegV == GInOutDegV);
339    EXPECT_TRUE(GIn->GetEdges() == GOut->GetEdges());
340  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-gaussian_distribution_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-gio.cpp</div>
                </div>
                <div class="column column_space"><pre><code>70          auto sample_min = before.max();
71          auto sample_max = before.min();
72          for (int i = 0; i < kCount; i++) {
73            auto sample = before(gen);
</pre></code></div>
                <div class="column column_space"><pre><code>57        RandStr.Clr();
58        TInt RandLen = TInt::Rnd.GetUniDevInt(5, 30);
59        for (int i = 0; i < RandLen; i++) {
60          TStr RandChar(TInt::Rnd.GetUniDevInt(33, 126));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    