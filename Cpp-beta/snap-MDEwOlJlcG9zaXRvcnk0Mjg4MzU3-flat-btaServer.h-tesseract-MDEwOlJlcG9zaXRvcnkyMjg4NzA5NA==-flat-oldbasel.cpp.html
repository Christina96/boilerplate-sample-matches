
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 25.513513513513512%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btaServer.h</h3>
            <pre><code>1  #ifndef btaserver_h
2  #define btaserver_h
3  #include "btalarms.h"
4  #include "mine.h"
5  #include "net.h"
6  class TBTAServer: public TWebSrv {
7  private:
8      static int MnSeverity;
9      static int ListItemsPerPage;
10      static int DetailItemsPerPage;
11      static int ListEventsPerPage;
12      static int64 RootCouseTimeWnd;
13      static int RootCouseEventWnd;
14      static int64 BoardTimeWnd;
15      static int BoardEventWnd;
16      static int MnBeforeCount;
17      static double MxChiProb;
18      static double MnChiVal;
19      static double MnCorrProb;
20      static int MnIpNumsPerPlot;
21      typedef TPair<TUInt64, TInt> TUInt64IntPr;
22      typedef TVec<TUInt64IntPr> TUInt64IntPrV;
23      typedef THash<TUInt64, TIntPr> TUInt64IntPrH;
24      typedef TPair<TUInt64, TIntPr> TUInt64IntPrPr;
25      typedef TVec<TUInt64IntPrPr> TUInt64IntPrPrV;
26  private:
27      TStr BinFPath;
28      TStr DumpFPath;
29      TStr GnuPlotPath;
30      PBtaEventBs BtaEventBs;
31      PBtaDevDefBs BtaDevDefBs;
32      PBtaCorrBs BtaCorrBs;
33      PBtaLongBs BtaLongBs;
34      TIntV AllEventIdV;
35      TIntV CaseIdEventIdV;
36      TIntV WeekChiSortProjIdV;
37      TIntV MonthChiSortProjIdV;
38  private:
39      int GetTotalFq(const TIntPrV& IdFqV);
40      TStr TruncStr(const TStr& FullStr, const int& MxLen);
41      TTm GetBreakDate(const int& Days) const;
42      void GetIpNumEventCount(const int& IpNumId, const TTm& StartDate, const TTm& BreakDate, 
43          const TTm& EndDate, double& AvgCount, int& LastCount) const;
44      void MakeEventsPage(const TIntV& EventV, const TStr& SortTypeStr, 
45          const int& PageNum, TChA& HtmlChA);
46      void MakeEventPage(const int& EventId, TChA& HtmlChA);
47      void MakeEventFullPage(const int& EventId, TChA& HtmlChA);
48      void MakeIpNumPage(const int& IpNumId, TChA& HtmlChA);
49      void MakeProjectPage(const int& ProjId, TChA& HtmlChA);
<span onclick='openModal()' class='match'>50      void MakeIpNumEventsPage(const int& IpNumId, const TIntV& EventV,
51          const int& PageNum, TChA& HtmlChA);
52      void MakeProjEventsPage(const int& ProjId, const TIntV& EventV,
53          const int& PageNum, TChA& HtmlChA);
</span>54      void MakeIpNumCorrEventPage(const int& IpNumId, 
55          const int& CorrIpNumId, const int& PageNum, TChA& HtmlChA);
56      void MakeLongPage(const TIntV& SortProjIdV,
57          const int& PageNum, const TStr& PeriodStr, TChA& HtmlChA);
58      void MakeProjLongPage(const int& ProjId,
59          const int& PageNum, const TStr& PeriodStr, TChA& HtmlChA);
60  	void MakeShortEventPage(const int& EventId, TChA& HtmlChA);
61  	void MakeShortPredIpNumsPage(const int& EventId, TChA& HtmlChA);
62  	void MakeShortIpNumPage(const int& EventId, TChA& HtmlChA);
63      void MakeBoardPage(const int& ProjCount, const int& RefreshTmSec, TChA& HtmlChA);
64      TStr GetIpNumLink(const int& IpNumId);
65      TStr GetProjLink(const int& IpNumId);
66      TStr GetProjLinkFromProj(const int& ProjId);
67      TStr GetBar(const double& Val, const double& MxVal);
68      void EventStat(const int& EventId, TChA& HtmlChA);
69      void EventShortStat(const int& EventId, TChA& HtmlChA);
70      void EventFullStat(const int& EventId, TChA& HtmlChA);
71      void EventRootCause(const int& EventId, TChA& HtmlChA);
72      void EventShortRootCause(const int& EventId, TChA& HtmlChA);
73      void EventPredIpNums(const int& EventId, TChA& HtmlChA);
74      void EventShortPredIpNums(const int& EventId, TChA& HtmlChA);
75      void DisplayEventHeader(const bool& HdSortP, const bool& ScoreP, 
76          const bool& LinkP, TChA& HtmlChA);
77      void DisplayEventRow(const int& EventN, const TBtaEvent& Event, 
78          const TBtaEventDat& EventDat, const bool& HdSortP, const bool& ScoreP, 
79          const double& Score, const double& MxScore, const int& IpNumId, 
80          const int& CorrIpNumId, TChA& HtmlChA);
81      void DisplayShortEventHeader(const bool& ScoreP, TChA& HtmlChA);
82      void DisplayShortEventRow(const int& EventN, const TBtaEvent& Event, 
83          const TBtaEventDat& EventDat, const bool& ScoreP, const double& Score, 
84          const double& MxScore, TChA& HtmlChA);
85  	void MakeEventList(const TIntV& EventV, const bool& HdSortP, 
86          const int& DispPageN, TChA& HtmlChA);
87      void MakeEventPrList(const TIntPrV& EventV, const int& DispPageN, TChA& HtmlChA);
88  	void MakeShortEventList(const TIntV& EventV, TChA& HtmlChA);
89      void IpNumDevCorrStat(const int& IpNumId, TChA& HtmlChA);
90      void ShortIpNumStat(const int& IpNumId, TChA& HtmlChA);
91      void MakeIpNumPrList(const TIntV& DevKeyIdV, const int& DispPageN, TChA& HtmlChA);
92      void ProjWithinCorrStat(const int& ProjId, TChA& HtmlChA);
93      void ProjCorrStat(const int& ProjId, TChA& HtmlChA);
94      void ShortProjStat(const int& ProjId, TChA& HtmlChA, const bool& ProjNmLinkP = false);
95      void MakeLongProjList(const TIntV& SortProjIdV, 
96          const int& DispPageN, const TStr& PeriodStr, TChA& HtmlChA);
97      void MakeLongIpNumList(const int& ProjId, 
98          const int& DispPageN, const TStr& PeriodStr, TChA& HtmlChA);
99      void RunGnuPlot(const TStr& PlotFNm) const;
100      void PlotEventV(const TStr& TitleStr, const TIntV& EventV, 
101          const TStr& PlotFNm, const int& Width = 700, const int& Height = 300);
102      void PlotEventV(const TStr& TitleStr, const TIntV& EventV, 
103          const TStr& CorrTitleStr, const TIntV& CorrEventV, 
104          const TStr& PlotFNm);
105      void PlotLongIpNum(const TStr& TitleStr, const TStr& PlotFNm,
106          const int& ProjId, const TTm& StartDate, const TTm& BreakDate, 
107          const TTm& EndDate, const TStr& PeriodStr, const int& MxIpNums, 
108          const bool& BigP);
109      int ProcessNewBuffer();
110      void ProcessDumpBuffer();
111      int RescueFromDumpBuffer();
112      void SaveAndExit();
113  public:
114      TBTAServer(const int& WebSrvPortN, const TStr& _BinFPath, 
115          const TStr& _DumpFPath, const POdbcDb& OdbcDb, const TStr& _GnuPlotPath);
116      static PWebSrv New(const int& WebSrvPortN, const TStr& BinFPath, 
117          const TStr& DumpFPath, const POdbcDb& OdbcDb, const TStr& GnuPlotPath) { 
118              return new TBTAServer(WebSrvPortN, BinFPath, 
119                  DumpFPath, OdbcDb, GnuPlotPath); }
120      void OnHttpRq(const int& SockId, const PHttpRq& HttpRq);
121  };
122  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-oldbasel.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "oldbasel.h"
5  #include "ccstruct.h"
6  #include "detlinefit.h"
7  #include "drawtord.h"
8  #include "makerow.h"
9  #include "quadlsq.h"
10  #include "statistc.h"
11  #include "textord.h"
12  #include "tprintf.h"
13  #include <cmath>
14  #include <vector> 
15  #include <algorithm>
16  namespace tesseract {
17  static BOOL_VAR(textord_really_old_xheight, false, "Use original wiseowl xheight");
18  BOOL_VAR(textord_oldbl_debug, false, "Debug old baseline generation");
19  static BOOL_VAR(textord_debug_baselines, false, "Debug baseline generation");
20  static BOOL_VAR(textord_oldbl_paradef, true, "Use para default mechanism");
21  static BOOL_VAR(textord_oldbl_split_splines, true, "Split stepped splines");
22  static BOOL_VAR(textord_oldbl_merge_parts, true, "Merge suspect partitions");
23  static BOOL_VAR(oldbl_corrfix, true, "Improve correlation of heights");
24  static BOOL_VAR(oldbl_xhfix, false, "Fix bug in modes threshold for xheights");
25  static BOOL_VAR(textord_ocropus_mode, false, "Make baselines for ocropus");
26  static double_VAR(oldbl_xhfract, 0.4, "Fraction of est allowed in calc");
27  static INT_VAR(oldbl_holed_losscount, 10, "Max lost before fallback line used");
28  static double_VAR(oldbl_dot_error_size, 1.26, "Max aspect ratio of a dot");
29  static double_VAR(textord_oldbl_jumplimit, 0.15, "X fraction for new partition");
30  #define TURNLIMIT 1            &bsol;*min size for turning point */
31  #define X_HEIGHT_FRACTION 0.7  &bsol;*x-height/caps height */
32  #define DESCENDER_FRACTION 0.5 &bsol;*descender/x-height */
33  #define MIN_ASC_FRACTION 0.20  &bsol;*min size of ascenders */
34  #define MIN_DESC_FRACTION 0.25 &bsol;*min size of descenders */
35  #define MINASCRISE 2.0         &bsol;*min ascender/desc step */
36  #define MAXHEIGHTVARIANCE 0.15 &bsol;*accepted variation in x-height */
37  #define MAXHEIGHT 300          &bsol;*max blob height */
38  #define MAXOVERLAP 0.1         &bsol;*max 10% missed overlap */
39  #define MAXBADRUN 2            &bsol;*max non best for failed */
40  #define HEIGHTBUCKETS 200      &bsol;* Num of buckets */
41  #define MODENUM 10
42  #define MAXPARTS 6
43  #define SPLINESIZE 23
44  #define ABS(x) ((x) < 0 ? (-(x)) : (x))
45  void Textord::make_old_baselines(TO_BLOCK *block, 
46                                   bool testing_on, 
47                                   float gradient) {
48    QSPLINE *prev_baseline; 
49    TO_ROW *row;            
50    TO_ROW_IT row_it = block->get_rows();
51    BLOBNBOX_IT blob_it;
52    prev_baseline = nullptr; 
53    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
54      row = row_it.data();
55      find_textlines(block, row, 2, nullptr);
56      if (row->xheight <= 0 && prev_baseline != nullptr) {
57        find_textlines(block, row, 2, prev_baseline);
58      }
59      if (row->xheight > 0) { 
60        prev_baseline = &row->baseline;
61      } else {
62        prev_baseline = nullptr;
63        blob_it.set_to_list(row->blob_list());
64        if (textord_debug_baselines) {
65          tprintf("Row baseline generation failed on row at (%d,%d)\n",
66                  blob_it.data()->bounding_box().left(), blob_it.data()->bounding_box().bottom());
67        }
68      }
69    }
70    correlate_lines(block, gradient);
71    block->block->set_xheight(block->xheight);
72  }
73  void Textord::correlate_lines(TO_BLOCK *block, float gradient) {
74    int rowcount; &bsol;*no of rows to do */
75    int rowindex; &bsol;*no of row */
76    TO_ROW_IT row_it = block->get_rows();
77    rowcount = row_it.length();
78    if (rowcount == 0) {
79      block->xheight = block->line_size;
80      return; &bsol;*none to do */
81    }
82    std::vector<TO_ROW *> rows(rowcount);
83    rowindex = 0;
84    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
85      rows[rowindex++] = row_it.data();
86    }
87    correlate_neighbours(block, &rows[0], rowcount);
88    if (textord_really_old_xheight || textord_old_xheight) {
89      block->xheight = static_cast<float>(correlate_with_stats(&rows[0], rowcount, block));
90      if (block->xheight <= 0) {
91        block->xheight = block->line_size * tesseract::CCStruct::kXHeightFraction;
92      }
93      if (block->xheight < textord_min_xheight) {
94        block->xheight = (float)textord_min_xheight;
95      }
96    } else {
97      compute_block_xheight(block, gradient);
98    }
99  }
100  void Textord::correlate_neighbours(TO_BLOCK *block, 
101                                     TO_ROW **rows,   
102                                     int rowcount) {  
103    TO_ROW *row;                                      &bsol;*current row */
104    int rowindex;                                     &bsol;*no of row */
105    int otherrow;                                     &bsol;*second row */
106    int upperrow;                                     &bsol;*row above to use */
107    int lowerrow;                                     &bsol;*row below to use */
108    float biggest;
109    for (rowindex = 0; rowindex < rowcount; rowindex++) {
110      row = rows[rowindex]; &bsol;*current row */
111      if (row->xheight < 0) {
112        for (otherrow = rowindex - 2;
113             otherrow >= 0 && (rows[otherrow]->xheight < 0.0 ||
114                               !row->baseline.overlap(&rows[otherrow]->baseline, MAXOVERLAP));
115             otherrow--) {
116        }
117        upperrow = otherrow; &bsol;*decent row above */
118        for (otherrow = rowindex + 1;
119             otherrow < rowcount && (rows[otherrow]->xheight < 0.0 ||
120                                     !row->baseline.overlap(&rows[otherrow]->baseline, MAXOVERLAP));
121             otherrow++) {
122        }
123        lowerrow = otherrow; &bsol;*decent row below */
124        if (upperrow >= 0) {
125          find_textlines(block, row, 2, &rows[upperrow]->baseline);
126        }
127        if (row->xheight < 0 && lowerrow < rowcount) {
128          find_textlines(block, row, 2, &rows[lowerrow]->baseline);
129        }
130        if (row->xheight < 0) {
131          if (upperrow >= 0) {
132            find_textlines(block, row, 1, &rows[upperrow]->baseline);
133          } else if (lowerrow < rowcount) {
134            find_textlines(block, row, 1, &rows[lowerrow]->baseline);
135          }
136        }
137      }
138    }
139    for (biggest = 0.0f, rowindex = 0; rowindex < rowcount; rowindex++) {
140      row = rows[rowindex]; &bsol;*current row */
141      if (row->xheight < 0) { &bsol;*linear failed */
142        row->xheight = -row->xheight;
143      }
144      biggest = std::max(biggest, row->xheight);
145    }
146  }
147  int Textord::correlate_with_stats(TO_ROW **rows, 
148                                    int rowcount,  
149                                    TO_BLOCK *block) {
150    TO_ROW *row;         &bsol;*current row */
151    int rowindex;        &bsol;*no of row */
152    float lineheight;    &bsol;*mean x-height */
153    float ascheight;     &bsol;*average ascenders */
154    float minascheight;  &bsol;*min allowed ascheight */
155    int xcount;          &bsol;*no of samples for xheight */
156    float fullheight;    &bsol;*mean top height */
157    int fullcount;       &bsol;*no of samples */
158    float descheight;    &bsol;*mean descender drop */
159    float mindescheight; &bsol;*min allowed descheight */
160    int desccount;       &bsol;*no of samples */
161    xcount = fullcount = desccount = 0;
162    lineheight = ascheight = fullheight = descheight = 0.0;
163    for (rowindex = 0; rowindex < rowcount; rowindex++) {
164      row = rows[rowindex];         &bsol;*current row */
165      if (row->ascrise > 0.0) {     &bsol;*got ascenders? */
166        lineheight += row->xheight; &bsol;*average x-heights */
167        ascheight += row->ascrise;  &bsol;*average ascenders */
168        xcount++;
169      } else {
170        fullheight += row->xheight; &bsol;*assume full height */
171        fullcount++;
172      }
173      if (row->descdrop < 0.0) { &bsol;*got descenders? */
174        descheight += row->descdrop;
175        desccount++;
176      }
177    }
178    if (xcount > 0 && (!oldbl_corrfix || xcount >= fullcount)) {
179      lineheight /= xcount; &bsol;*average x-height */
180      fullheight = lineheight + ascheight / xcount;
181      if (fullheight < lineheight * (1 + MIN_ASC_FRACTION)) {
182        fullheight = lineheight * (1 + MIN_ASC_FRACTION);
183      }
184    } else {
185      fullheight /= fullcount; &bsol;*average max height */
186      lineheight = fullheight * X_HEIGHT_FRACTION;
187    }
188    if (desccount > 0 && (!oldbl_corrfix || desccount >= rowcount / 2)) {
189      descheight /= desccount; &bsol;*average descenders */
190    } else {
191      descheight = -lineheight * DESCENDER_FRACTION;
192    }
193    if (lineheight > 0.0f) {
194      block->block->set_cell_over_xheight((fullheight - descheight) / lineheight);
195    }
196    minascheight = lineheight * MIN_ASC_FRACTION;
197    mindescheight = -lineheight * MIN_DESC_FRACTION;
198    for (rowindex = 0; rowindex < rowcount; rowindex++) {
199      row = rows[rowindex]; &bsol;*do each row */
200      row->all_caps = false;
201      if (row->ascrise / row->xheight < MIN_ASC_FRACTION) {
202        if (row->xheight >= lineheight * (1 - MAXHEIGHTVARIANCE) &&
203            row->xheight <= lineheight * (1 + MAXHEIGHTVARIANCE)) {
204          row->ascrise = fullheight - lineheight;
205          row->xheight = lineheight;
206        } else if (row->xheight >= fullheight * (1 - MAXHEIGHTVARIANCE) &&
207                   row->xheight <= fullheight * (1 + MAXHEIGHTVARIANCE)) {
208          row->ascrise = row->xheight - lineheight;
209          row->xheight = lineheight;
210          row->all_caps = true;
211        } else {
212          row->ascrise = (fullheight - lineheight) * row->xheight / fullheight;
213          row->xheight -= row->ascrise;
214          row->all_caps = true;
215        }
216        if (row->ascrise < minascheight) {
217          row->ascrise = row->xheight * ((1.0 - X_HEIGHT_FRACTION) / X_HEIGHT_FRACTION);
218        }
219      }
220      if (row->descdrop > mindescheight) {
221        if (row->xheight >= lineheight * (1 - MAXHEIGHTVARIANCE) &&
222            row->xheight <= lineheight * (1 + MAXHEIGHTVARIANCE)) {
223          row->descdrop = descheight;
224        } else {
225          row->descdrop = -row->xheight * DESCENDER_FRACTION;
226        }
227      }
228    }
229    return static_cast<int>(lineheight); 
230  }
231  void Textord::find_textlines(TO_BLOCK *block,   
232                               TO_ROW *row,       
233                               int degree,        
234                               QSPLINE *spline) { 
235    int partcount;                                &bsol;*no of partitions of */
236    bool holed_line = false;                      
237    int bestpart;                                 &bsol;*biggest partition */
238    int partsizes[MAXPARTS];                      &bsol;*no in each partition */
239    int lineheight;                               &bsol;*guessed x-height */
240    float jumplimit;                              &bsol;*allowed delta change */
241    int blobcount;                                &bsol;*no of blobs on line */
242    int pointcount;                               &bsol;*no of coords */
243    int xstarts[SPLINESIZE + 1];                  
244    int segments;                                 
245    blobcount = row->blob_list()->length();
246    std::vector<char> partids(blobcount);
247    std::vector<int> xcoords(blobcount);
248    std::vector<int> ycoords(blobcount);
249    std::vector<TBOX> blobcoords(blobcount);
250    std::vector<float> ydiffs(blobcount);
251    lineheight = get_blob_coords(row, static_cast<int>(block->line_size), &blobcoords[0], holed_line,
252                                 blobcount);
253    jumplimit = lineheight * textord_oldbl_jumplimit;
254    if (jumplimit < MINASCRISE) {
255      jumplimit = MINASCRISE;
256    }
257    if (textord_oldbl_debug) {
258      tprintf("\nInput height=%g, Estimate x-height=%d pixels, jumplimit=%.2f\n", block->line_size,
259              lineheight, jumplimit);
260    }
261    if (holed_line) {
262      make_holed_baseline(&blobcoords[0], blobcount, spline, &row->baseline, row->line_m());
263    } else {
264      make_first_baseline(&blobcoords[0], blobcount, &xcoords[0], &ycoords[0], spline, &row->baseline,
265                          jumplimit);
266    }
267  #ifndef GRAPHICS_DISABLED
268    if (textord_show_final_rows) {
269      row->baseline.plot(to_win, ScrollView::GOLDENROD);
270    }
271  #endif
272    if (blobcount > 1) {
273      bestpart = partition_line(&blobcoords[0], blobcount, &partcount, &partids[0], partsizes,
274                                &row->baseline, jumplimit, &ydiffs[0]);
275      pointcount = partition_coords(&blobcoords[0], blobcount, &partids[0], bestpart, &xcoords[0],
276                                    &ycoords[0]);
277      segments = segment_spline(&blobcoords[0], blobcount, &xcoords[0], &ycoords[0], degree,
278                                pointcount, xstarts);
279      if (!holed_line) {
280        do {
281          row->baseline = QSPLINE(xstarts, segments, &xcoords[0], &ycoords[0], pointcount, degree);
282        } while (textord_oldbl_split_splines &&
283                 split_stepped_spline(&row->baseline, jumplimit / 2, &xcoords[0], xstarts, segments));
284      }
285      find_lesser_parts(row, &blobcoords[0], blobcount, &partids[0], partsizes, partcount, bestpart);
286    } else {
287      row->xheight = -1.0f; &bsol;*failed */
288      row->descdrop = 0.0f;
289      row->ascrise = 0.0f;
290    }
291    row->baseline.extrapolate(row->line_m(), block->block->pdblk.bounding_box().left(),
292                              block->block->pdblk.bounding_box().right());
293    if (textord_really_old_xheight) {
294      old_first_xheight(row, &blobcoords[0], lineheight, blobcount, &row->baseline, jumplimit);
295    } else if (textord_old_xheight) {
296      make_first_xheight(row, &blobcoords[0], lineheight, static_cast<int>(block->line_size),
297                         blobcount, &row->baseline, jumplimit);
298    } else {
299      compute_row_xheight(row, block->block->classify_rotation(), row->line_m(), block->line_size);
300    }
301  }
302  int get_blob_coords(    
303      TO_ROW *row,        
304      int32_t lineheight, 
305      TBOX *blobcoords,   
306      bool &holed_line,   
307      int &outcount       
308  ) {
309    BLOBNBOX_IT blob_it = row->blob_list();
310    int blobindex;    &bsol;*no along text line */
311    int losscount;    
312    int maxlosscount; 
313    STATS heightstat(0, MAXHEIGHT - 1);
314    if (blob_it.empty()) {
315      return 0; 
316    }
317    maxlosscount = 0;
318    losscount = 0;
319    blob_it.mark_cycle_pt();
320    blobindex = 0;
321    do {
322      blobcoords[blobindex] = box_next_pre_chopped(&blob_it);
323      if (blobcoords[blobindex].height() > lineheight * 0.25) {
324        heightstat.add(blobcoords[blobindex].height(), 1);
325      }
326      if (blobindex == 0 || blobcoords[blobindex].height() > lineheight * 0.25 ||
327          blob_it.cycled_list()) {
328        blobindex++; &bsol;*no of merged blobs */
329        losscount = 0;
330      } else {
331        if (blobcoords[blobindex].height() < blobcoords[blobindex].width() * oldbl_dot_error_size &&
332            blobcoords[blobindex].width() < blobcoords[blobindex].height() * oldbl_dot_error_size) {
333          blobindex++;
334          losscount = 0;
335        } else {
336          losscount++; 
337          if (losscount > maxlosscount) {
338            maxlosscount = losscount;
339          }
340        }
341      }
342    } while (!blob_it.cycled_list());
343    holed_line = maxlosscount > oldbl_holed_losscount;
344    outcount = blobindex; &bsol;*total blobs */
345    if (heightstat.get_total() > 1) {
346      return static_cast<int>(heightstat.ile(0.25));
347    } else {
348      return blobcoords[0].height();
349    }
350  }
351  void make_first_baseline( 
<span onclick='openModal()' class='match'>352      TBOX blobcoords[],    &bsol;*blob bounding boxes */
353      int blobcount,        &bsol;*no of blobcoords */
354      int xcoords[],        &bsol;*coords for spline */
355      int ycoords[],        &bsol;*approximator */
356      QSPLINE *spline,      &bsol;*initial spline */
357      QSPLINE *baseline,    &bsol;*output spline */
358      float jumplimit       &bsol;*guess half descenders */
359  ) {
360    int leftedge;              &bsol;*left edge of line */
361    int rightedge;             &bsol;*right edge of line */
362    int blobindex;             &bsol;*current blob */
363    int segment;               &bsol;*current segment */
364    float prevy, thisy, nexty; &bsol;*3 y coords */
365    float y1, y2, y3;          &bsol;*3 smooth blobs */
366    float maxmax, minmin;      &bsol;*absolute limits */
367    int x2 = 0;                &bsol;*right edge of old y3 */
</span>368    int ycount;                &bsol;*no of ycoords in use */
369    float yturns[SPLINESIZE];  &bsol;*y coords of turn pts */
370    int xturns[SPLINESIZE];    &bsol;*xcoords of turn pts */
371    int xstarts[SPLINESIZE + 1];
372    int segments; 
373    ICOORD shift; 
374    prevy = 0;
375    leftedge = blobcoords[0].left();
376    rightedge = blobcoords[blobcount - 1].right();
377    if (spline == nullptr       &bsol;*no given spline */
378        || spline->segments < 3 &bsol;*or trivial */
379        || spline->xcoords[1] > leftedge + MAXOVERLAP * (rightedge - leftedge) ||
380        spline->xcoords[spline->segments - 1] < rightedge - MAXOVERLAP * (rightedge - leftedge)) {
381      if (textord_oldbl_paradef) {
382        return; 
383      }
384      xstarts[0] = blobcoords[0].left() - 1;
385      for (blobindex = 0; blobindex < blobcount; blobindex++) {
386        xcoords[blobindex] = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) / 2;
387        ycoords[blobindex] = blobcoords[blobindex].bottom();
388      }
389      xstarts[1] = blobcoords[blobcount - 1].right() + 1;
390      segments = 1; &bsol;*no of segments */
391      *baseline = QSPLINE(xstarts, segments, xcoords, ycoords, blobcount, 1);
392      if (blobcount >= 3) {
393        y1 = y2 = y3 = 0.0f;
394        ycount = 0;
395        segment = 0; &bsol;*no of segments */
396        maxmax = minmin = 0.0f;
397        thisy = ycoords[0] - baseline->y(xcoords[0]);
398        nexty = ycoords[1] - baseline->y(xcoords[1]);
399        for (blobindex = 2; blobindex < blobcount; blobindex++) {
400          prevy = thisy; &bsol;*shift ycoords */
401          thisy = nexty;
402          nexty = ycoords[blobindex] - baseline->y(xcoords[blobindex]);
403          if (ABS(thisy - prevy) < jumplimit && ABS(thisy - nexty) < jumplimit) {
404            y1 = y2; &bsol;*shift window */
405            y2 = y3;
406            y3 = thisy; &bsol;*middle point */
407            ycount++;
408            if (ycount >= 3 && ((y1 < y2 && y2 >= y3)
409                                || (y1 > y2 && y2 <= y3))) {
410              if (segment < SPLINESIZE - 2) {
411                xturns[segment] = x2;
412                yturns[segment] = y2;
413                segment++; &bsol;*no of spline segs */
414              }
415            }
416            if (ycount == 1) {
417              maxmax = minmin = y3; &bsol;*initialise limits */
418            } else {
419              if (y3 > maxmax) {
420                maxmax = y3; &bsol;*biggest max */
421              }
422              if (y3 < minmin) {
423                minmin = y3; &bsol;*smallest min */
424              }
425            }
426            x2 = blobcoords[blobindex - 1].right();
427          }
428        }
429        jumplimit *= 1.2f;
430        if (maxmax - minmin > jumplimit) {
431          ycount = segment; &bsol;*no of segments */
432          for (blobindex = 0, segment = 1; blobindex < ycount; blobindex++) {
433            if (yturns[blobindex] > minmin + jumplimit || yturns[blobindex] < maxmax - jumplimit) {
434              if (segment == 1 || yturns[blobindex] > prevy + jumplimit ||
435                  yturns[blobindex] < prevy - jumplimit) {
436                xstarts[segment] = xturns[blobindex];
437                segment++;
438                prevy = yturns[blobindex];
439              }
440              else if ((prevy > minmin + jumplimit && yturns[blobindex] > prevy)
441                       || (prevy < maxmax - jumplimit && yturns[blobindex] < prevy)) {
442                xstarts[segment - 1] = xturns[blobindex];
443                prevy = yturns[blobindex];
444              }
445            }
446          }
447          xstarts[segment] = blobcoords[blobcount - 1].right() + 1;
448          segments = segment; &bsol;*no of segments */
449          *baseline = QSPLINE(xstarts, segments, xcoords, ycoords, blobcount, 1);
450        }
451      }
452    } else {
453      *baseline = *spline; &bsol;*copy it */
454      shift =
455          ICOORD(0, static_cast<int16_t>(blobcoords[0].bottom() - spline->y(blobcoords[0].right())));
456      baseline->move(shift);
457    }
458  }
459  void make_holed_baseline( 
460      TBOX blobcoords[],    &bsol;*blob bounding boxes */
461      int blobcount,        &bsol;*no of blobcoords */
462      QSPLINE *spline,      &bsol;*initial spline */
463      QSPLINE *baseline,    &bsol;*output spline */
464      float gradient        
465  ) {
466    int leftedge;  &bsol;*left edge of line */
467    int rightedge; &bsol;*right edge of line */
468    int blobindex; &bsol;*current blob */
469    float x;       
470    ICOORD shift;  
471    tesseract::DetLineFit lms; 
472    int32_t xstarts[2];        
473    double coeffs[3];
474    float c; 
475    leftedge = blobcoords[0].left();
476    rightedge = blobcoords[blobcount - 1].right();
477    for (blobindex = 0; blobindex < blobcount; blobindex++) {
478      lms.Add(ICOORD((blobcoords[blobindex].left() + blobcoords[blobindex].right()) / 2,
479                     blobcoords[blobindex].bottom()));
480    }
481    lms.ConstrainedFit(gradient, &c);
482    xstarts[0] = leftedge;
483    xstarts[1] = rightedge;
484    coeffs[0] = 0;
485    coeffs[1] = gradient;
486    coeffs[2] = c;
487    *baseline = QSPLINE(1, xstarts, coeffs);
488    if (spline != nullptr        &bsol;*no given spline */
489        && spline->segments >= 3 &bsol;*or trivial */
490        && spline->xcoords[1] <= leftedge + MAXOVERLAP * (rightedge - leftedge) &&
491        spline->xcoords[spline->segments - 1] >= rightedge - MAXOVERLAP * (rightedge - leftedge)) {
492      *baseline = *spline; &bsol;*copy it */
493      x = (leftedge + rightedge) / 2.0;
494      shift = ICOORD(0, static_cast<int16_t>(gradient * x + c - spline->y(x)));
495      baseline->move(shift);
496    }
497  }
498  int partition_line(    
499      TBOX blobcoords[], 
500      int blobcount,     &bsol;*no of blobs on row */
501      int *numparts,     &bsol;*number of partitions */
502      char partids[],    &bsol;*partition no of each blob */
503      int partsizes[],   &bsol;*no in each partition */
504      QSPLINE *spline,   &bsol;*curve to fit to */
505      float jumplimit,   &bsol;*allowed delta change */
506      float ydiffs[]     &bsol;*diff from spline */
507  ) {
508    int blobindex;             &bsol;*no along text line */
509    int bestpart;              &bsol;*best new partition */
510    int biggestpart;           &bsol;*part with most members */
511    float diff;                &bsol;*difference from line */
512    int startx;                &bsol;*index of start blob */
513    float partdiffs[MAXPARTS]; &bsol;*step between parts */
514    for (bestpart = 0; bestpart < MAXPARTS; bestpart++) {
515      partsizes[bestpart] = 0; &bsol;*zero them all */
516    }
517    startx = get_ydiffs(blobcoords, blobcount, spline, ydiffs);
518    *numparts = 1; &bsol;*1 partition */
519    bestpart = -1; &bsol;*first point */
520    float drift = 0.0f;
521    float last_delta = 0.0f;
522    for (blobindex = startx; blobindex < blobcount; blobindex++) {
523      diff = ydiffs[blobindex]; &bsol;*diff from line */
524      if (textord_oldbl_debug) {
525        tprintf("%d(%d,%d), ", blobindex, blobcoords[blobindex].left(),
526                blobcoords[blobindex].bottom());
527      }
528      bestpart =
529          choose_partition(diff, partdiffs, bestpart, jumplimit, &drift, &last_delta, numparts);
530      partids[blobindex] = bestpart;
531      partsizes[bestpart]++; &bsol;*another in it */
532    }
533    bestpart = -1; &bsol;*first point */
534    drift = 0.0f;
535    last_delta = 0.0f;
536    partsizes[0]--; &bsol;*doing 1st pt again */
537    for (blobindex = startx; blobindex >= 0; blobindex--) {
538      diff = ydiffs[blobindex]; &bsol;*diff from line */
539      if (textord_oldbl_debug) {
540        tprintf("%d(%d,%d), ", blobindex, blobcoords[blobindex].left(),
541                blobcoords[blobindex].bottom());
542      }
543      bestpart =
544          choose_partition(diff, partdiffs, bestpart, jumplimit, &drift, &last_delta, numparts);
545      partids[blobindex] = bestpart;
546      partsizes[bestpart]++; &bsol;*another in it */
547    }
548    for (biggestpart = 0, bestpart = 1; bestpart < *numparts; bestpart++) {
549      if (partsizes[bestpart] >= partsizes[biggestpart]) {
550        biggestpart = bestpart; &bsol;*new biggest */
551      }
552    }
553    if (textord_oldbl_merge_parts) {
554      merge_oldbl_parts(blobcoords, blobcount, partids, partsizes, biggestpart, jumplimit);
555    }
556    return biggestpart; &bsol;*biggest partition */
557  }
558  void merge_oldbl_parts( 
559      TBOX blobcoords[],  
560      int blobcount,      &bsol;*no of blobs on row */
561      char partids[],     &bsol;*partition no of each blob */
562      int partsizes[],    &bsol;*no in each partition */
563      int biggestpart,    
564      float jumplimit     &bsol;*allowed delta change */
565  ) {
566    bool found_one; 
567    bool close_one; 
568    int blobindex;  &bsol;*no along text line */
569    int prevpart;   
570    int runlength;  
571    float diff;     &bsol;*difference from line */
572    int startx;     &bsol;*index of start blob */
573    int test_blob;  
574    FCOORD coord;   
575    float m, c;     
576    QLSQ stats;     
577    prevpart = biggestpart;
578    runlength = 0;
579    startx = 0;
580    for (blobindex = 0; blobindex < blobcount; blobindex++) {
581      if (partids[blobindex] != prevpart) {
582        if (prevpart != biggestpart && runlength > MAXBADRUN) {
583          stats.clear();
584          for (test_blob = startx; test_blob < blobindex; test_blob++) {
585            coord = FCOORD((blobcoords[test_blob].left() + blobcoords[test_blob].right()) / 2.0,
586                           blobcoords[test_blob].bottom());
587            stats.add(coord.x(), coord.y());
588          }
589          stats.fit(1);
590          m = stats.get_b();
591          c = stats.get_c();
592          if (textord_oldbl_debug) {
593            tprintf("Fitted line y=%g x + %g\n", m, c);
594          }
595          found_one = false;
596          close_one = false;
597          for (test_blob = 1;
598               !found_one && (startx - test_blob >= 0 || blobindex + test_blob <= blobcount);
599               test_blob++) {
600            if (startx - test_blob >= 0 && partids[startx - test_blob] == biggestpart) {
601              found_one = true;
602              coord = FCOORD(
603                  (blobcoords[startx - test_blob].left() + blobcoords[startx - test_blob].right()) /
604                      2.0,
605                  blobcoords[startx - test_blob].bottom());
606              diff = m * coord.x() + c - coord.y();
607              if (textord_oldbl_debug) {
608                tprintf("Diff of common blob to suspect part=%g at (%g,%g)\n", diff, coord.x(),
609                        coord.y());
610              }
611              if (diff < jumplimit && -diff < jumplimit) {
612                close_one = true;
613              }
614            }
615            if (blobindex + test_blob <= blobcount &&
616                partids[blobindex + test_blob - 1] == biggestpart) {
617              found_one = true;
618              coord = FCOORD((blobcoords[blobindex + test_blob - 1].left() +
619                              blobcoords[blobindex + test_blob - 1].right()) /
620                                 2.0,
621                             blobcoords[blobindex + test_blob - 1].bottom());
622              diff = m * coord.x() + c - coord.y();
623              if (textord_oldbl_debug) {
624                tprintf("Diff of common blob to suspect part=%g at (%g,%g)\n", diff, coord.x(),
625                        coord.y());
626              }
627              if (diff < jumplimit && -diff < jumplimit) {
628                close_one = true;
629              }
630            }
631          }
632          if (close_one) {
633            if (textord_oldbl_debug) {
634              tprintf(
635                  "Merged %d blobs back into part %d from %d starting at "
636                  "(%d,%d)\n",
637                  runlength, biggestpart, prevpart, blobcoords[startx].left(),
638                  blobcoords[startx].bottom());
639            }
640            partsizes[prevpart] -= runlength;
641            for (test_blob = startx; test_blob < blobindex; test_blob++) {
642              partids[test_blob] = biggestpart;
643            }
644          }
645        }
646        prevpart = partids[blobindex];
647        runlength = 1;
648        startx = blobindex;
649      } else {
650        runlength++;
651      }
652    }
653  }
654  int get_ydiffs(        
655      TBOX blobcoords[], 
656      int blobcount,     &bsol;*no of blobs */
657      QSPLINE *spline,   &bsol;*approximating spline */
658      float ydiffs[]     &bsol;*output */
659  ) {
660    int blobindex; &bsol;*current blob */
661    int xcentre;   &bsol;*xcoord */
662    int lastx;     &bsol;*last xcentre */
663    float diffsum; &bsol;*sum of diffs */
664    float diff;    &bsol;*current difference */
665    float drift;   &bsol;*sum of spline steps */
666    float bestsum; &bsol;*smallest diffsum */
667    int bestindex; &bsol;*index of bestsum */
668    diffsum = 0.0f;
669    bestindex = 0;
670    bestsum = static_cast<float>(INT32_MAX);
671    drift = 0.0f;
672    lastx = blobcoords[0].left();
673    for (blobindex = 0; blobindex < blobcount; blobindex++) {
674      xcentre = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) >> 1;
675      drift += spline->step(lastx, xcentre);
676      lastx = xcentre;
677      diff = blobcoords[blobindex].bottom();
678      diff -= spline->y(xcentre);
679      diff += drift;
680      ydiffs[blobindex] = diff; &bsol;*store difference */
681      if (blobindex > 2) {
682        diffsum -= ABS(ydiffs[blobindex - 3]);
683      }
684      diffsum += ABS(diff); &bsol;*add new one */
685      if (blobindex >= 2 && diffsum < bestsum) {
686        bestsum = diffsum;         &bsol;*find min sum */
687        bestindex = blobindex - 1; &bsol;*middle of set */
688      }
689    }
690    return bestindex;
691  }
692  int choose_partition(                              
693      float diff,                                    &bsol;*diff from spline */
694      float partdiffs[],                             &bsol;*diff on all parts */
695      int lastpart,                                  &bsol;*last assigned partition */
696      float jumplimit,                               &bsol;*new part threshold */
697      float *drift, float *lastdelta, int *partcount &bsol;*no of partitions */
698  ) {
699    int partition;   &bsol;*partition no */
700    int bestpart;    &bsol;*best new partition */
701    float bestdelta; &bsol;*best gap from a part */
702    float delta;     &bsol;*diff from part */
703    if (lastpart < 0) {
704      partdiffs[0] = diff;
705      lastpart = 0; &bsol;*first point */
706      *drift = 0.0f;
707      *lastdelta = 0.0f;
708    }
709    delta = diff - partdiffs[lastpart] - *drift;
710    if (textord_oldbl_debug) {
711      tprintf("Diff=%.2f, Delta=%.3f, Drift=%.3f, ", diff, delta, *drift);
712    }
713    if (ABS(delta) > jumplimit / 2) {
714      bestdelta = diff - partdiffs[0] - *drift;
715      bestpart = 0; &bsol;*0 best so far */
716      for (partition = 1; partition < *partcount; partition++) {
717        delta = diff - partdiffs[partition] - *drift;
718        if (ABS(delta) < ABS(bestdelta)) {
719          bestdelta = delta;
720          bestpart = partition; &bsol;*part with nearest jump */
721        }
722      }
723      delta = bestdelta;
724      if (ABS(bestdelta) > jumplimit && *partcount < MAXPARTS) { &bsol;*and spare part left */
725        bestpart = (*partcount)++;                               &bsol;*best was new one */
726        partdiffs[bestpart] = diff - *drift;
727        delta = 0.0f;
728      }
729    } else {
730      bestpart = lastpart; &bsol;*best was last one */
731    }
732    if (bestpart == lastpart &&
733        (ABS(delta - *lastdelta) < jumplimit / 2 || ABS(delta) < jumplimit / 2)) {
734      *drift = (3 * *drift + delta) / 3;
735    }
736    *lastdelta = delta;
737    if (textord_oldbl_debug) {
738      tprintf("P=%d\n", bestpart);
739    }
740    return bestpart;
741  }
742  int partition_coords(  
743      TBOX blobcoords[], 
744      int blobcount,     &bsol;*no of blobs in row */
745      char partids[],    &bsol;*partition no of each blob */
746      int bestpart,      &bsol;*best new partition */
747      int xcoords[],     &bsol;*points to work on */
748      int ycoords[]      &bsol;*points to work on */
749  ) {
750    int blobindex;  &bsol;*no along text line */
751    int pointcount; &bsol;*no of points */
752    pointcount = 0;
753    for (blobindex = 0; blobindex < blobcount; blobindex++) {
754      if (partids[blobindex] == bestpart) {
755        xcoords[pointcount] = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) >> 1;
756        ycoords[pointcount++] = blobcoords[blobindex].bottom();
757      }
758    }
759    return pointcount; &bsol;*no of points found */
760  }
761  int segment_spline(             
762      TBOX blobcoords[],          
763      int blobcount,              &bsol;*no of blobs in row */
764      int xcoords[],              &bsol;*points to work on */
765      int ycoords[],              &bsol;*points to work on */
766      int degree, int pointcount, &bsol;*no of points */
767      int xstarts[]               
768  ) {
769    int ptindex;                &bsol;*no along text line */
770    int segment;                &bsol;*partition no */
771    int lastmin, lastmax;       &bsol;*possible turn points */
772    int turnpoints[SPLINESIZE]; &bsol;*good turning points */
773    int turncount;              &bsol;*no of turning points */
774    int max_x;                  
775    xstarts[0] = xcoords[0] - 1; 
776    max_x = xcoords[pointcount - 1] + 1;
777    if (degree < 2) {
778      pointcount = 0;
779    }
780    turncount = 0; &bsol;*no turning points yet */
781    if (pointcount > 3) {
782      ptindex = 1;
783      lastmax = lastmin = 0; &bsol;*start with first one */
784      while (ptindex < pointcount - 1 && turncount < SPLINESIZE - 1) {
785        if (ycoords[ptindex - 1] > ycoords[ptindex] && ycoords[ptindex] <= ycoords[ptindex + 1]) {
786          if (ycoords[ptindex] < ycoords[lastmax] - TURNLIMIT) {
787            if (turncount == 0 || turnpoints[turncount - 1] != lastmax) {
788              turnpoints[turncount++] = lastmax;
789            }
790            lastmin = ptindex; &bsol;*latest minimum */
791          } else if (ycoords[ptindex] < ycoords[lastmin]) {
792            lastmin = ptindex; &bsol;*lower minimum */
793          }
794        }
795        if (ycoords[ptindex - 1] < ycoords[ptindex] && ycoords[ptindex] >= ycoords[ptindex + 1]) {
796          if (ycoords[ptindex] > ycoords[lastmin] + TURNLIMIT) {
797            if (turncount == 0 || turnpoints[turncount - 1] != lastmin) {
798              turnpoints[turncount++] = lastmin;
799            }
800            lastmax = ptindex; &bsol;*latest maximum */
801          } else if (ycoords[ptindex] > ycoords[lastmax]) {
802            lastmax = ptindex; &bsol;*higher maximum */
803          }
804        }
805        ptindex++;
806      }
807      if (ycoords[ptindex] < ycoords[lastmax] - TURNLIMIT &&
808          (turncount == 0 || turnpoints[turncount - 1] != lastmax)) {
809        if (turncount < SPLINESIZE - 1) {
810          turnpoints[turncount++] = lastmax;
811        }
812        if (turncount < SPLINESIZE - 1) {
813          turnpoints[turncount++] = ptindex;
814        }
815      } else if (ycoords[ptindex] > ycoords[lastmin] + TURNLIMIT
816                 && (turncount == 0 || turnpoints[turncount - 1] != lastmin)) {
817        if (turncount < SPLINESIZE - 1) {
818          turnpoints[turncount++] = lastmin;
819        }
820        if (turncount < SPLINESIZE - 1) {
821          turnpoints[turncount++] = ptindex;
822        }
823      } else if (turncount > 0 && turnpoints[turncount - 1] == lastmin &&
824                 turncount < SPLINESIZE - 1) {
825        if (ycoords[ptindex] > ycoords[lastmax]) {
826          turnpoints[turncount++] = ptindex;
827        } else {
828          turnpoints[turncount++] = lastmax;
829        }
830      } else if (turncount > 0 && turnpoints[turncount - 1] == lastmax &&
831                 turncount < SPLINESIZE - 1) {
832        if (ycoords[ptindex] < ycoords[lastmin]) {
833          turnpoints[turncount++] = ptindex;
834        } else {
835          turnpoints[turncount++] = lastmin;
836        }
837      }
838    }
839    if (textord_oldbl_debug && turncount > 0) {
840      tprintf("First turn is %d at (%d,%d)\n", turnpoints[0], xcoords[turnpoints[0]],
841              ycoords[turnpoints[0]]);
842    }
843    for (segment = 1; segment < turncount; segment++) {
844      lastmax = (ycoords[turnpoints[segment - 1]] + ycoords[turnpoints[segment]]) / 2;
845      if (ycoords[turnpoints[segment - 1]] < ycoords[turnpoints[segment]]) {
846        for (ptindex = turnpoints[segment - 1] + 1;
847             ptindex < turnpoints[segment] && ycoords[ptindex + 1] <= lastmax; ptindex++) {
848        }
849      } else {
850        for (ptindex = turnpoints[segment - 1] + 1;
851             ptindex < turnpoints[segment] && ycoords[ptindex + 1] >= lastmax; ptindex++) {
852        }
853      }
854      xstarts[segment] = (xcoords[ptindex - 1] + xcoords[ptindex] + xcoords[turnpoints[segment - 1]] +
855                          xcoords[turnpoints[segment]] + 2) /
856                         4;
857      if (textord_oldbl_debug) {
858        tprintf("Turn %d is %d at (%d,%d), mid pt is %d@%d, final @%d\n", segment,
859                turnpoints[segment], xcoords[turnpoints[segment]], ycoords[turnpoints[segment]],
860                ptindex - 1, xcoords[ptindex - 1], xstarts[segment]);
861      }
862    }
863    xstarts[segment] = max_x;
864    return segment; &bsol;*no of splines */
865  }
866  bool split_stepped_spline( 
867      QSPLINE *baseline,     
868      float jumplimit,       
869      int *xcoords,          &bsol;*points to work on */
870      int *xstarts,          
871      int &segments          
872  ) {
873    bool doneany; 
874    int segment;  &bsol;*partition no */
875    int startindex, centreindex, endindex;
876    float leftcoord, rightcoord;
877    int leftindex, rightindex;
878    float step; 
879    doneany = false;
880    startindex = 0;
881    for (segment = 1; segment < segments - 1; segment++) {
882      step = baseline->step((xstarts[segment - 1] + xstarts[segment]) / 2.0,
883                            (xstarts[segment] + xstarts[segment + 1]) / 2.0);
884      if (step < 0) {
885        step = -step;
886      }
887      if (step > jumplimit) {
888        while (xcoords[startindex] < xstarts[segment - 1]) {
889          startindex++;
890        }
891        centreindex = startindex;
892        while (xcoords[centreindex] < xstarts[segment]) {
893          centreindex++;
894        }
895        endindex = centreindex;
896        while (xcoords[endindex] < xstarts[segment + 1]) {
897          endindex++;
898        }
899        if (segments >= SPLINESIZE) {
900          if (textord_debug_baselines) {
901            tprintf("Too many segments to resegment spline!!\n");
902          }
903        } else if (endindex - startindex >= textord_spline_medianwin * 3) {
904          while (centreindex - startindex < textord_spline_medianwin * 3 / 2) {
905            centreindex++;
906          }
907          while (endindex - centreindex < textord_spline_medianwin * 3 / 2) {
908            centreindex--;
909          }
910          leftindex = (startindex + startindex + centreindex) / 3;
911          rightindex = (centreindex + endindex + endindex) / 3;
912          leftcoord = (xcoords[startindex] * 2 + xcoords[centreindex]) / 3.0;
913          rightcoord = (xcoords[centreindex] + xcoords[endindex] * 2) / 3.0;
914          while (xcoords[leftindex] > leftcoord &&
915                 leftindex - startindex > textord_spline_medianwin) {
916            leftindex--;
917          }
918          while (xcoords[leftindex] < leftcoord &&
919                 centreindex - leftindex > textord_spline_medianwin / 2) {
920            leftindex++;
921          }
922          if (xcoords[leftindex] - leftcoord > leftcoord - xcoords[leftindex - 1]) {
923            leftindex--;
924          }
925          while (xcoords[rightindex] > rightcoord &&
926                 rightindex - centreindex > textord_spline_medianwin / 2) {
927            rightindex--;
928          }
929          while (xcoords[rightindex] < rightcoord &&
930                 endindex - rightindex > textord_spline_medianwin) {
931            rightindex++;
932          }
933          if (xcoords[rightindex] - rightcoord > rightcoord - xcoords[rightindex - 1]) {
934            rightindex--;
935          }
936          if (textord_debug_baselines) {
937            tprintf("Splitting spline at %d with step %g at (%d,%d)\n", xstarts[segment],
938                    baseline->step((xstarts[segment - 1] + xstarts[segment]) / 2.0,
939                                   (xstarts[segment] + xstarts[segment + 1]) / 2.0),
940                    (xcoords[leftindex - 1] + xcoords[leftindex]) / 2,
941                    (xcoords[rightindex - 1] + xcoords[rightindex]) / 2);
942          }
943          insert_spline_point(xstarts, segment, (xcoords[leftindex - 1] + xcoords[leftindex]) / 2,
944                              (xcoords[rightindex - 1] + xcoords[rightindex]) / 2, segments);
945          doneany = true;
946        } else if (textord_debug_baselines) {
947          tprintf("Resegmenting spline failed - insufficient pts (%d,%d,%d,%d)\n", startindex,
948                  centreindex, endindex, (int32_t)textord_spline_medianwin);
949        }
950      }
951    }
952    return doneany;
953  }
954  void insert_spline_point(     
955      int xstarts[],            
956      int segment,              
957      int coord1,               
958      int coord2, int &segments 
959  ) {
960    int index; 
961    for (index = segments; index > segment; index--) {
962      xstarts[index + 1] = xstarts[index];
963    }
964    segments++;
965    xstarts[segment] = coord1;
966    xstarts[segment + 1] = coord2;
967  }
968  void find_lesser_parts( 
969      TO_ROW *row,        
970      TBOX blobcoords[],  
971      int blobcount,      &bsol;*no of blobs */
972      char partids[],     &bsol;*partition of each blob */
973      int partsizes[],    &bsol;*size of each part */
974      int partcount,      &bsol;*no of partitions */
975      int bestpart        &bsol;*biggest partition */
976  ) {
977    int blobindex;             &bsol;*index of blob */
978    int partition;             &bsol;*current partition */
979    int xcentre;               &bsol;*centre of blob */
980    int poscount;              &bsol;*count of best up step */
981    int negcount;              &bsol;*count of best down step */
982    float partsteps[MAXPARTS]; &bsol;*average step to part */
983    float bestneg;             &bsol;*best down step */
984    int runlength;             &bsol;*length of bad run */
985    int biggestrun;            &bsol;*biggest bad run */
986    biggestrun = 0;
987    for (partition = 0; partition < partcount; partition++) {
988      partsteps[partition] = 0.0; &bsol;*zero accumulators */
989    }
990    for (runlength = 0, blobindex = 0; blobindex < blobcount; blobindex++) {
991      xcentre = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) >> 1;
992      int part_id = static_cast<int>(static_cast<unsigned char>(partids[blobindex]));
993      if (part_id != bestpart) {
994        runlength++; &bsol;*run of non bests */
995        if (runlength > biggestrun) {
996          biggestrun = runlength;
997        }
998        partsteps[part_id] += blobcoords[blobindex].bottom() - row->baseline.y(xcentre);
999      } else {
1000        runlength = 0;
1001      }
1002    }
1003    if (biggestrun > MAXBADRUN) {
1004      row->xheight = -1.0f; &bsol;*failed */
1005    } else {
1006      row->xheight = 1.0f; &bsol;*success */
1007    }
1008    poscount = negcount = 0;
1009    bestneg = 0.0; &bsol;*no step yet */
1010    for (partition = 0; partition < partcount; partition++) {
1011      if (partition != bestpart) {
1012        if (partsizes[partition] == 0) {
1013          partsteps[partition] = 0;
1014        } else {
1015          partsteps[partition] /= partsizes[partition];
1016        }
1017        if (partsteps[partition] >= MINASCRISE && partsizes[partition] > poscount) {
1018          poscount = partsizes[partition];
1019        }
1020        if (partsteps[partition] <= -MINASCRISE && partsizes[partition] > negcount) {
1021          bestneg = partsteps[partition];
1022          negcount = partsizes[partition];
1023        }
1024      }
1025    }
1026    partsteps[bestpart] /= blobcount;
1027    row->descdrop = bestneg;
1028  }
1029  void old_first_xheight( 
1030      TO_ROW *row,        &bsol;*current row */
1031      TBOX blobcoords[],  &bsol;*blob bounding boxes */
1032      int initialheight,  
1033      int blobcount,      &bsol;*blobs in blobcoords */
1034      QSPLINE *baseline,  &bsol;*established */
1035      float jumplimit     &bsol;*min ascender height */
1036  ) {
1037    int blobindex; &bsol;*current blob */
1038    STATS heightstat(0, MAXHEIGHT - 1);
1039    int height;      &bsol;*height of blob */
1040    int xcentre;     &bsol;*centre of blob */
1041    int lineheight;  &bsol;*approx xheight */
1042    float ascenders; &bsol;*ascender sum */
1043    int asccount;    &bsol;*no of ascenders */
1044    float xsum;      &bsol;*xheight sum */
1045    int xcount;      &bsol;*xheight count */
1046    float diff;      &bsol;*height difference */
1047    if (blobcount > 1) {
1048      for (blobindex = 0; blobindex < blobcount; blobindex++) {
1049        xcentre = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) / 2;
1050        height = static_cast<int>(blobcoords[blobindex].top() - baseline->y(xcentre) + 0.5);
1051        if (height > initialheight * oldbl_xhfract && height > textord_min_xheight) {
1052          heightstat.add(height, 1);
1053        }
1054      }
1055      if (heightstat.get_total() > 3) {
1056        lineheight = static_cast<int>(heightstat.ile(0.25));
1057        if (lineheight <= 0) {
1058          lineheight = static_cast<int>(heightstat.ile(0.5));
1059        }
1060      } else {
1061        lineheight = initialheight;
1062      }
1063    } else {
1064      lineheight =
1065          static_cast<int>(blobcoords[0].top() -
1066                           baseline->y((blobcoords[0].left() + blobcoords[0].right()) / 2) + 0.5);
1067    }
1068    xsum = 0.0f;
1069    xcount = 0;
1070    for (ascenders = 0.0f, asccount = 0, blobindex = 0; blobindex < blobcount; blobindex++) {
1071      xcentre = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) / 2;
1072      diff = blobcoords[blobindex].top() - baseline->y(xcentre);
1073      if (diff > lineheight + jumplimit) {
1074        ascenders += diff;
1075        asccount++; &bsol;*count ascenders */
1076      } else if (diff > lineheight - jumplimit) {
1077        xsum += diff; &bsol;*mean xheight */
1078        xcount++;
1079      }
1080    }
1081    if (xcount > 0) {
1082      xsum /= xcount; &bsol;*average xheight */
1083    } else {
1084      xsum = static_cast<float>(lineheight); &bsol;*guess it */
1085    }
1086    row->xheight *= xsum;
1087    if (asccount > 0) {
1088      row->ascrise = ascenders / asccount - xsum;
1089    } else {
1090      row->ascrise = 0.0f; &bsol;*had none */
1091    }
1092    if (row->xheight == 0) {
1093      row->xheight = -1.0f;
1094    }
1095  }
1096  void make_first_xheight( 
1097      TO_ROW *row,         &bsol;*current row */
1098      TBOX blobcoords[],   &bsol;*blob bounding boxes */
1099      int lineheight,      
1100      int init_lineheight, 
1101      int blobcount,       &bsol;*blobs in blobcoords */
1102      QSPLINE *baseline,   &bsol;*established */
1103      float jumplimit      &bsol;*min ascender height */
1104  ) {
1105    STATS heightstat(0, HEIGHTBUCKETS - 1);
1106    int lefts[HEIGHTBUCKETS];
1107    int rights[HEIGHTBUCKETS];
1108    int modelist[MODENUM];
1109    int blobindex;
1110    int mode_count; 
1111    int sign_bit;
1112    int mode_threshold;
1113    const int kBaselineTouch = 2;  
1114    const int kGoodStrength = 8;   
1115    const float kMinHeight = 0.25; 
1116    sign_bit = row->xheight > 0 ? 1 : -1;
1117    memset(lefts, 0, HEIGHTBUCKETS * sizeof(lefts[0]));
1118    memset(rights, 0, HEIGHTBUCKETS * sizeof(rights[0]));
1119    mode_count = 0;
1120    for (blobindex = 0; blobindex < blobcount; blobindex++) {
1121      int xcenter = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) / 2;
1122      float base = baseline->y(xcenter);
1123      float bottomdiff = std::fabs(base - blobcoords[blobindex].bottom());
1124      int strength = textord_ocropus_mode && bottomdiff <= kBaselineTouch ? kGoodStrength : 1;
1125      int height = static_cast<int>(blobcoords[blobindex].top() - base + 0.5);
1126      if (blobcoords[blobindex].height() > init_lineheight * kMinHeight) {
1127        if (height > lineheight * oldbl_xhfract && height > textord_min_xheight) {
1128          heightstat.add(height, strength);
1129          if (height < HEIGHTBUCKETS) {
1130            if (xcenter > rights[height]) {
1131              rights[height] = xcenter;
1132            }
1133            if (xcenter > 0 && (lefts[height] == 0 || xcenter < lefts[height])) {
1134              lefts[height] = xcenter;
1135            }
1136          }
1137        }
1138        mode_count += strength;
1139      }
1140    }
1141    mode_threshold = static_cast<int>(blobcount * 0.1);
1142    if (oldbl_dot_error_size > 1 || oldbl_xhfix) {
1143      mode_threshold = static_cast<int>(mode_count * 0.1);
1144    }
1145    if (textord_oldbl_debug) {
1146      tprintf("blobcount=%d, mode_count=%d, mode_t=%d\n", blobcount, mode_count, mode_threshold);
1147    }
1148    find_top_modes(&heightstat, HEIGHTBUCKETS, modelist, MODENUM);
1149    if (textord_oldbl_debug) {
1150      for (blobindex = 0; blobindex < MODENUM; blobindex++) {
1151        tprintf("mode[%d]=%d ", blobindex, modelist[blobindex]);
1152      }
1153      tprintf("\n");
1154    }
1155    pick_x_height(row, modelist, lefts, rights, &heightstat, mode_threshold);
1156    if (textord_oldbl_debug) {
1157      tprintf("Output xheight=%g\n", row->xheight);
1158    }
1159    if (row->xheight < 0 && textord_oldbl_debug) {
1160      tprintf("warning: Row Line height < 0; %4.2f\n", row->xheight);
1161    }
1162    if (sign_bit < 0) {
1163      row->xheight = -row->xheight;
1164    }
1165  }
1166  const int kMinModeFactorOcropus = 32;
1167  const int kMinModeFactor = 12;
1168  void find_top_modes(            
1169      STATS *stats,               
1170      int statnum,                
1171      int modelist[], int modenum 
1172  ) {
1173    int mode_count;
1174    int last_i = 0;
1175    int last_max = INT32_MAX;
1176    int i;
1177    int mode;
1178    int total_max = 0;
1179    int mode_factor = textord_ocropus_mode ? kMinModeFactorOcropus : kMinModeFactor;
1180    for (mode_count = 0; mode_count < modenum; mode_count++) {
1181      mode = 0;
1182      for (i = 0; i < statnum; i++) {
1183        if (stats->pile_count(i) > stats->pile_count(mode)) {
1184          if ((stats->pile_count(i) < last_max) ||
1185              ((stats->pile_count(i) == last_max) && (i > last_i))) {
1186            mode = i;
1187          }
1188        }
1189      }
1190      last_i = mode;
1191      last_max = stats->pile_count(last_i);
1192      total_max += last_max;
1193      if (last_max <= total_max / mode_factor) {
1194        mode = 0;
1195      }
1196      modelist[mode_count] = mode;
1197    }
1198  }
1199  void pick_x_height(TO_ROW *row, 
1200                     int modelist[], int lefts[], int rights[], STATS *heightstat,
1201                     int mode_threshold) {
1202    int x;
1203    int y;
1204    int z;
1205    float ratio;
1206    int found_one_bigger = false;
1207    int best_x_height = 0;
1208    int best_asc = 0;
1209    int num_in_best;
1210    for (x = 0; x < MODENUM; x++) {
1211      for (y = 0; y < MODENUM; y++) {
1212        if (modelist[x] && modelist[y] && heightstat->pile_count(modelist[x]) > mode_threshold &&
1213            (!textord_ocropus_mode || std::min(rights[modelist[x]], rights[modelist[y]]) >
1214                                          std::max(lefts[modelist[x]], lefts[modelist[y]]))) {
1215          ratio = static_cast<float>(modelist[y]) / static_cast<float>(modelist[x]);
1216          if (1.2 < ratio && ratio < 1.8) {
1217            best_x_height = modelist[x];
1218            num_in_best = heightstat->pile_count(modelist[x]);
1219            do {
1220              found_one_bigger = false;
1221              for (z = 0; z < MODENUM; z++) {
1222                if (modelist[z] == best_x_height + 1 &&
1223                    (!textord_ocropus_mode || std::min(rights[modelist[x]], rights[modelist[y]]) >
1224                                                  std::max(lefts[modelist[x]], lefts[modelist[y]]))) {
1225                  ratio = static_cast<float>(modelist[y]) / static_cast<float>(modelist[z]);
1226                  if ((1.2 < ratio && ratio < 1.8) &&
1227                      heightstat->pile_count(modelist[z]) > num_in_best * 0.5) {
1228                    best_x_height++;
1229                    found_one_bigger = true;
1230                    break;
1231                  }
1232                }
1233              }
1234            } while (found_one_bigger);
1235            best_asc = modelist[y];
1236            num_in_best = heightstat->pile_count(modelist[y]);
1237            do {
1238              found_one_bigger = false;
1239              for (z = 0; z < MODENUM; z++) {
1240                if (modelist[z] > best_asc &&
1241                    (!textord_ocropus_mode || std::min(rights[modelist[x]], rights[modelist[y]]) >
1242                                                  std::max(lefts[modelist[x]], lefts[modelist[y]]))) {
1243                  ratio = static_cast<float>(modelist[z]) / static_cast<float>(best_x_height);
1244                  if ((1.2 < ratio && ratio < 1.8) &&
1245                      heightstat->pile_count(modelist[z]) > num_in_best * 0.5) {
1246                    best_asc = modelist[z];
1247                    found_one_bigger = true;
1248                    break;
1249                  }
1250                }
1251              }
1252            } while (found_one_bigger);
1253            row->xheight = static_cast<float>(best_x_height);
1254            row->ascrise = static_cast<float>(best_asc) - best_x_height;
1255            return;
1256          }
1257        }
1258      }
1259    }
1260    best_x_height = modelist[0]; &bsol;* Single Mode found */
1261    num_in_best = heightstat->pile_count(best_x_height);
1262    do {
1263      found_one_bigger = false;
1264      for (z = 1; z < MODENUM; z++) {
1265        if ((modelist[z] == best_x_height + 1) &&
1266            (heightstat->pile_count(modelist[z]) > num_in_best * 0.5)) {
1267          best_x_height++;
1268          found_one_bigger = true;
1269          break;
1270        }
1271      }
1272    } while (found_one_bigger);
1273    row->ascrise = 0.0f;
1274    row->xheight = static_cast<float>(best_x_height);
1275    if (row->xheight == 0) {
1276      row->xheight = -1.0f;
1277    }
1278  }
1279  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btaServer.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-oldbasel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>50      void MakeIpNumEventsPage(const int& IpNumId, const TIntV& EventV,
51          const int& PageNum, TChA& HtmlChA);
52      void MakeProjEventsPage(const int& ProjId, const TIntV& EventV,
53          const int& PageNum, TChA& HtmlChA);
</pre></code></div>
                <div class="column column_space"><pre><code>352      TBOX blobcoords[],    &bsol;*blob bounding boxes */
353      int blobcount,        &bsol;*no of blobcoords */
354      int xcoords[],        &bsol;*coords for spline */
355      int ycoords[],        &bsol;*approximator */
356      QSPLINE *spline,      &bsol;*initial spline */
357      QSPLINE *baseline,    &bsol;*output spline */
358      float jumplimit       &bsol;*guess half descenders */
359  ) {
360    int leftedge;              &bsol;*left edge of line */
361    int rightedge;             &bsol;*right edge of line */
362    int blobindex;             &bsol;*current blob */
363    int segment;               &bsol;*current segment */
364    float prevy, thisy, nexty; &bsol;*3 y coords */
365    float y1, y2, y3;          &bsol;*3 smooth blobs */
366    float maxmax, minmin;      &bsol;*absolute limits */
367    int x2 = 0;                &bsol;*right edge of old y3 */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    