
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.099935107073328%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashgenericmp.h</h3>
            <pre><code>1  #include "bd.h"
2  #ifdef GLib_GLIBC
3  inline unsigned int __sync_fetch_and_add_2(volatile unsigned int* p, unsigned int incr)
4  {
5      unsigned int result;
6      asm volatile("lock; xadd %0, %1" :
7              "=r"(result), "=m"(*p):
8              "0"(incr), "m"(*p) :
9              "memory");
10      return result + 1;
11  }
12  #endif
13  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
14  class THashGenericMP{
15  public:
16    enum {HashPrimes=32};
<span onclick='openModal()' class='match'>17    static const unsigned int HashPrimeT[HashPrimes];
18  public:
19    typedef THashKeyDatI<TKey, TDat> TIter;
20  private:
21    typedef THashKeyDat<TKey, TDat> THKeyDat;
22    typedef TPair<TKey, TDat> TKeyDatP;
23    TIntV PortV;
24    TIntV PortLockV;
25    TVec<THKeyDat> KeyDatV;
26    TBool AutoSizeP;
</span>27    TInt FFreeKeyId, FreeKeys;
28  private:
29    class THashKeyDatCmp {
30    public:
31      const THash<TKey, TDat, THashFunc>& Hash;
32      bool CmpKey, Asc;
33      THashKeyDatCmp(THash<TKey, TDat, THashFunc>& _Hash, const bool& _CmpKey, const bool& _Asc) :
34        Hash(_Hash), CmpKey(_CmpKey), Asc(_Asc) { }
35      bool operator () (const int& KeyId1, const int& KeyId2) const {
36        if (CmpKey) {
37          if (Asc) { return Hash.GetKey(KeyId1) < Hash.GetKey(KeyId2); }
38          else { return Hash.GetKey(KeyId2) < Hash.GetKey(KeyId1); } }
39        else {
40          if (Asc) { return Hash[KeyId1] < Hash[KeyId2]; }
41          else { return Hash[KeyId2] < Hash[KeyId1]; } } }
42    };
43  private:
44    THKeyDat& GetHashKeyDat(const int& KeyId){
45      THKeyDat& KeyDat=KeyDatV[KeyId];
46      Assert(KeyDat.HashCd!=-1); return KeyDat;}
47    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
48      const THKeyDat& KeyDat=KeyDatV[KeyId];
49      Assert(KeyDat.HashCd!=-1); return KeyDat;}
50    uint GetNextPrime(const uint& Val) const;
51    void Resize();
52  public:
53    THashGenericMP():
54      PortV(), KeyDatV(),
55      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0){
56      }
57    THashGenericMP(const THashGenericMP& Hash):
58      PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
59      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys) {
60      }
61    explicit THashGenericMP(const int& ExpectVals, const bool& _AutoSizeP=false);
62    explicit THashGenericMP(TSIn& SIn):
63      PortV(SIn), KeyDatV(SIn),
64      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){
65      SIn.LoadCs();
66    }
67    void Load(TSIn& SIn){
68      PortV.Load(SIn); KeyDatV.Load(SIn);
69      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
70      SIn.LoadCs();
71    }
72    void Save(TSOut& SOut) const {
73      PortV.Save(SOut); KeyDatV.Save(SOut);
74      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
75      SOut.SaveCs();
76    }
77    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
78    void SaveXml(TSOut& SOut, const TStr& Nm);
79    void ResizePar(int);
80    THashGenericMP& operator=(const THashGenericMP& Hash){
81      if (this!=&Hash){
82        PortV=Hash.PortV; KeyDatV=Hash.KeyDatV; AutoSizeP=Hash.AutoSizeP;
83        FFreeKeyId=Hash.FFreeKeyId; FreeKeys=Hash.FreeKeys;}
84      return *this;}
85    bool operator==(const THashGenericMP& Hash) const; 
86    bool operator < (const THashGenericMP& Hash) const { Fail; return true; }
87    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
88    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
89    TDat& operator()(const TKey& Key){return AddDat(Key);}
90    ::TSize GetMemUsed() const {
91        int64 MemUsed = sizeof(bool)+2*sizeof(int);
92        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
93        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
94            MemUsed += int64(2 * sizeof(TInt));
95            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
96            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
97        }
98        return ::TSize(MemUsed);
99    }
100    TIter BegI() const {
101      if (Len() == 0){return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
102      if (IsKeyIdEqKeyN()) { return TIter(KeyDatV.BegI(), KeyDatV.EndI());}
103      int FKeyId=-1;  FNextKeyId(FKeyId);
104      return TIter(KeyDatV.BegI()+FKeyId, KeyDatV.EndI()); }
105    TIter EndI() const {return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
106    TIter GetI(const TKey& Key) const {return TIter(&KeyDatV[GetKeyId(Key)], KeyDatV.EndI());}
107    void Gen(const int& ExpectVals){
108      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyDatV.Gen(ExpectVals, 0);
109      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1));}
110    void Clr(const bool& DoDel=true, const int& NoDelLim=-1, const bool& ResetDat=true);
111    bool Empty() const {return Len()==0;}
112    int Len() const {return KeyDatV.Len()-FreeKeys;}
113    int GetPorts() const {return PortV.Len();}
114    bool IsAutoSize() const {return AutoSizeP;}
115    int GetMxKeyIds() const {return KeyDatV.Len();}
116    int GetReservedKeyIds() const {return KeyDatV.Reserved();}
117    bool IsKeyIdEqKeyN() const {return FreeKeys==0;}
118    int AddKey(const TKey& Key);
119    int AddKeyPar(const TKey& Key);
120    TDat& AddDatId(const TKey& Key){
121      int KeyId=AddKey(Key); return KeyDatV[KeyId].Dat=KeyId;}
122    TDat& AddDat(const TKey& Key){return KeyDatV[AddKey(Key)].Dat;}
123    TDat& AddDat(const TKey& Key, const TDat& Dat){
124      return KeyDatV[AddKey(Key)].Dat=Dat;}
125    bool AddDatIfNotExist(const TKey& Key, const TDat& Dat);
126    int AddDatPar(const TKey& Key, const TInt& Dat) {
127      const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
128      const int HashCd=abs(THashFunc::GetSecHashCd(Key));
129      int PrevKeyId=-1;
130      int KeyId;
131      int Ret;
132      bool done = false;
133      while(!done) {
134        bool port_lock = false;
135        int old;
136        int *ptr = &PortLockV[PortN].Val;
137        old = PortLockV[PortN];
138        if (old == -2) {
139          port_lock = false;
140        }
141        else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
142          port_lock = true;
143        }
144        KeyId = PortV[PortN];
145        while ((KeyId!=-1) &&
146            !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
147          PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
148        if (KeyId==-1) {
149          if (port_lock == false) continue;
150          volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
151          KeyId = __sync_fetch_and_add(p, 1);
152          KeyDatV[KeyId].Next=-1;
153          KeyDatV[KeyId].HashCd=HashCd;
154          KeyDatV[KeyId].Key=Key;
155          int temp;
156          int* pt = &KeyDatV[KeyId].Next.Val;
157          while(true) {
158            temp = KeyDatV[KeyId].Next;
159            if (temp == -2) continue;
160            if (__sync_bool_compare_and_swap(pt, temp, -2)) {
161              KeyDatV[KeyId].Dat.Val1 = 0;
162              KeyDatV[KeyId].Dat.Val2.Add(Dat);
163              *pt = temp;
164              done = true;
165  	          Ret = 0;
166              break;
167            }
168          }
169          if (PrevKeyId==-1){
170            PortV[PortN] = KeyId;
171          } else {
172            KeyDatV[PrevKeyId].Next=KeyId;
173          }
174          *ptr = old;
175        }
176        else {
177          int temp, temp1;
178          int* pt = &KeyDatV[KeyId].Next.Val;
179          while(true) {
180            temp = KeyDatV[KeyId].Next;
181            temp1 = __sync_val_compare_and_swap(pt, temp, -2);
182            if (temp1 == temp && temp1 != -2) {
183              KeyDatV[KeyId].Dat.Val2.Add(Dat);
184              *pt = temp;
185              if (port_lock) *ptr = old;
186              done = true;
187  	          Ret = KeyDatV[KeyId].Dat.Val1;
188              break;
189            }
190            else {
191              usleep(20);
192            }
193          }
194        }
195      }
196      return Ret;
197    }
198    void DelKey(const TKey& Key);
199    bool DelIfKey(const TKey& Key){
200      int KeyId; if (IsKey(Key, KeyId)){DelKeyId(KeyId); return true;} return false;}
201    void DelKeyId(const int& KeyId){DelKey(GetKey(KeyId));}
202    void DelKeyIdV(const TIntV& KeyIdV){
203      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++){DelKeyId(KeyIdV[KeyIdN]);}}
204    void MarkDelKey(const TKey& Key); 
205    void MarkDelKeyId(const int& KeyId){MarkDelKey(GetKey(KeyId));}
206    const TKey& GetKey(const int& KeyId) const { return GetHashKeyDat(KeyId).Key;}
207    int GetKeyId(const TKey& Key) const;
208    int GetRndKeyId(TRnd& Rnd) const;
209    int GetRndKeyId(TRnd& Rnd, const double& EmptyFrac);
210    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1;}
211    bool IsKey(const TKey& Key, int& KeyId) const { KeyId=GetKeyId(Key); return KeyId!=-1;}
212    bool IsKeyId(const int& KeyId) const {
213      return (0<=KeyId)&&(KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd!=-1);}
214    const TDat& GetDat(const TKey& Key) const {return KeyDatV[GetKeyId(Key)].Dat;}
215    TDat& GetDat(const TKey& Key){return KeyDatV[GetKeyId(Key)].Dat;}
216    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
217      const THKeyDat& KeyDat=GetHashKeyDat(KeyId);
218      Key=KeyDat.Key; Dat=KeyDat.Dat;}
219    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const {int KeyId;
220      if (IsKey(Key, KeyId)){Dat=GetHashKeyDat(KeyId).Dat; return true;}
221      else {return false;}}
222    int FFirstKeyId() const {return 0-1;}
223    bool FNextKeyId(int& KeyId) const;
224    void GetKeyV(TVec<TKey>& KeyV) const;
225    void GetDatV(TVec<TDat>& DatV) const;
226    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
227    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
228    void GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const;
229    void GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const;
230    void Swap(THashGenericMP& Hash);
231    void Defrag();
232    void Pack(){KeyDatV.Pack();}
233    void Sort(const bool& CmpKey, const bool& Asc);
234    void SortByKey(const bool& Asc=true) { Sort(true, Asc); }
235    void SortByDat(const bool& Asc=true) { Sort(false, Asc); }
236  };
237  template<class TKey, class TDat, class THashFunc>
238  const unsigned int THashGenericMP<TKey, TDat, THashFunc>::HashPrimeT[HashPrimes]={
239    3ul, 5ul, 11ul, 23ul,
240    53ul,         97ul,         193ul,       389ul,       769ul,
241    1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
242    49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
243    1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
244    50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
245    1610612741ul, 3221225473ul, 4294967291ul
246  };
247  template<class TKey, class TDat, class THashFunc>
248  uint THashGenericMP<TKey, TDat, THashFunc>::GetNextPrime(const uint& Val) const {
249    const uint* f=(const uint*)HashPrimeT, *m, *l=(const uint*)HashPrimeT + (int)HashPrimes;
250    int h, len = (int)HashPrimes;
251    while (len > 0) {
252      h = len >> 1;  m = f + h;
253      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
254      else len = h;
255    }
256    return f == l ? *(l - 1) : *f;
257  }
258  template<class TKey, class TDat, class THashFunc>
259  void THashGenericMP<TKey, TDat, THashFunc>::ResizePar(int sz){
260    if (PortV.Len()==0){
261      PortV.Gen(sz);
262      KeyDatV.Gen(sz);
263      PortLockV.Gen(sz);
264    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
265      PortV.Gen(GetNextPrime(PortV.Len()+1));
266    } else {
267      return;
268    }
269    PortV.PutAll(TInt(-1));
270    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
271      THKeyDat& KeyDat=KeyDatV[KeyId];
272      if (KeyDat.HashCd!=-1){
273        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
274        KeyDat.Next=PortV[PortN];
275        PortV[PortN]=KeyId;
276      }
277    }
278  }
279  template<class TKey, class TDat, class THashFunc>
280  void THashGenericMP<TKey, TDat, THashFunc>::Resize(){
281    if (PortV.Len()==0){
282      PortV.Gen(17);
283    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
284      PortV.Gen(GetNextPrime(PortV.Len()+1));
285    } else {
286      return;
287    }
288    PortV.PutAll(TInt(-1));
289    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
290      THKeyDat& KeyDat=KeyDatV[KeyId];
291      if (KeyDat.HashCd!=-1){
292        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
293        KeyDat.Next=PortV[PortN];
294        PortV[PortN]=KeyId;
295      }
296    }
297  }
298  template<class TKey, class TDat, class THashFunc>
299  THashGenericMP<TKey, TDat, THashFunc>::THashGenericMP(const int& ExpectVals, const bool& _AutoSizeP):
300    PortV(GetNextPrime(ExpectVals/2)), KeyDatV(ExpectVals, 0),
301    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0){
302    PortV.PutAll(TInt(-1));
303  }
304  template<class TKey, class TDat, class THashFunc>
305  bool THashGenericMP<TKey, TDat, THashFunc>::operator==(const THashGenericMP& Hash) const {
306    if (Len() != Hash.Len()) { return false; }
307    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
308      const TKey& Key = GetKey(i);
309      if (! Hash.IsKey(Key)) { return false; }
310      if (GetDat(Key) != Hash.GetDat(Key)) { return false; }
311    }
312    return true;
313  }
314  template<class TKey, class TDat, class THashFunc>
315  void THashGenericMP<TKey, TDat, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim, const bool& ResetDat){
316    if (DoDel){
317      PortV.Clr(); KeyDatV.Clr();
318    } else {
319      PortV.PutAll(TInt(-1));
320      KeyDatV.Clr(DoDel, NoDelLim);
321      if (ResetDat){KeyDatV.PutAll(THKeyDat());}
322    }
323    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
324  }
325  template<class TKey, class TDat, class THashFunc>
326  int THashGenericMP<TKey, TDat, THashFunc>::AddKey(const TKey& Key){
327    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
328    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
329    int PrevKeyId=-1;
330    int KeyId=PortV[PortN];
331    while ((KeyId!=-1) &&
332     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
333      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
334    if (KeyId==-1){
335      if (FFreeKeyId==-1){
336        KeyId=KeyDatV.Add(THKeyDat(-1, HashCd, Key));
337      } else {
338        KeyId=FFreeKeyId; FFreeKeyId=KeyDatV[FFreeKeyId].Next; FreeKeys--;
339        KeyDatV[KeyId].Next=-1;
340        KeyDatV[KeyId].HashCd=HashCd;
341        KeyDatV[KeyId].Key=Key;
342      }
343      if (PrevKeyId==-1){
344        PortV[PortN]=KeyId;
345      } else {
346        KeyDatV[PrevKeyId].Next=KeyId;
347      }
348    }
349    return KeyId;
350  }
351  template<class TKey, class TDat, class THashFunc>
352  int THashGenericMP<TKey, TDat, THashFunc>::AddKeyPar(const TKey& Key){
353      const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
354      const int HashCd=abs(THashFunc::GetSecHashCd(Key));
355      int PrevKeyId=-1;
356      int KeyId;
357      bool done = false;
358      while(!done) {
359        bool port_lock = false;
360        int old;
361        int *ptr = &PortLockV[PortN].Val;
362        old = PortLockV[PortN];
363        if (old == -2) {
364          port_lock = false;
365        }
366        else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
367          port_lock = true;
368        }
369        KeyId = PortV[PortN];
370        while ((KeyId!=-1) &&
371            !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
372          PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
373        if (KeyId==-1) {
374          if (port_lock == false) continue;
375          volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
376          KeyId = __sync_fetch_and_add(p, 1);
377          KeyDatV[KeyId].Next=-1;
378          KeyDatV[KeyId].HashCd=HashCd;
379          KeyDatV[KeyId].Key=Key;
380          if (PrevKeyId==-1){
381            PortV[PortN] = KeyId;
382          } else {
383            KeyDatV[PrevKeyId].Next=KeyId;
384          }
385          *ptr = old;
386          done = true;
387        }
388        else {
389          done = true;
390        }
391      }
392      return KeyId;
393  }
394  template<class TKey, class TDat, class THashFunc>
395  void THashGenericMP<TKey, TDat, THashFunc>::DelKey(const TKey& Key){
396    IAssert(!PortV.Empty());
397    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
398    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
399    int PrevKeyId=-1;
400    int KeyId=PortV[PortN];
401    while ((KeyId!=-1) &&
402     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
403      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
404    IAssert(KeyId!=-1); 
405    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
406    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
407    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
408    KeyDatV[KeyId].HashCd=TInt(-1);
409    KeyDatV[KeyId].Key=TKey();
410    KeyDatV[KeyId].Dat=TDat();
411  }
412  template<class TKey, class TDat, class THashFunc>
413  void THashGenericMP<TKey, TDat, THashFunc>::MarkDelKey(const TKey& Key){
414    IAssert(!PortV.Empty());
415    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
416    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
417    int PrevKeyId=-1;
418    int KeyId=PortV[PortN];
419    while ((KeyId!=-1) &&
420     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
421      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
422    IAssertR(KeyId!=-1, Key.GetStr());
423    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
424    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
425    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
426    KeyDatV[KeyId].HashCd=TInt(-1);
427  }
428  template<class TKey, class TDat, class THashFunc>
429  int THashGenericMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd) const  {
430    IAssert(! Empty());
431    int KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len()));
432    while (KeyDatV[KeyId].HashCd == -1) { 
433      KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len())); }
434    return KeyId; 
435  }
436  template<class TKey, class TDat, class THashFunc>
437  int THashGenericMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd, const double& EmptyFrac) {
438    IAssert(! Empty());
439    if (FreeKeys/double(Len()+FreeKeys) > EmptyFrac) { Defrag(); }
440    int KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
441    while (KeyDatV[KeyId].HashCd == -1) { 
442      KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
443    }
444    return KeyId;
445  }
446  template<class TKey, class TDat, class THashFunc>
447  int THashGenericMP<TKey, TDat, THashFunc>::GetKeyId(const TKey& Key) const {
448    if (PortV.Empty()){return -1;}
449    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
450    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
451    int KeyId=PortV[PortN];
452    while ((KeyId!=-1) &&
453     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
454      KeyId=KeyDatV[KeyId].Next;}
455    return KeyId;
456  }
457  template<class TKey, class TDat, class THashFunc>
458  bool THashGenericMP<TKey, TDat, THashFunc>::FNextKeyId(int& KeyId) const {
459    do {KeyId++;} while ((KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd==-1));
460    return KeyId<KeyDatV.Len();
461  }
462  template<class TKey, class TDat, class THashFunc>
463  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
464    KeyV.Gen(Len(), 0);
465    int KeyId=FFirstKeyId();
466    while (FNextKeyId(KeyId)){
467      KeyV.Add(GetKey(KeyId));}
468  }
469  template<class TKey, class TDat, class THashFunc>
470  void THashGenericMP<TKey, TDat, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
471    DatV.Gen(Len(), 0);
472    int KeyId=FFirstKeyId();
473    while (FNextKeyId(KeyId)){
474      DatV.Add(GetHashKeyDat(KeyId).Dat);}
475  }
476  template<class TKey, class TDat, class THashFunc>
477  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
478    KeyDatPrV.Gen(Len(), 0);
479    TKey Key; TDat Dat;
480    int KeyId=FFirstKeyId();
481    while (FNextKeyId(KeyId)){
482      GetKeyDat(KeyId, Key, Dat);
483      KeyDatPrV.Add(TPair<TKey, TDat>(Key, Dat));
484    }
485  }
486  template<class TKey, class TDat, class THashFunc>
487  void THashGenericMP<TKey, TDat, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
488    DatKeyPrV.Gen(Len(), 0);
489    TKey Key; TDat Dat;
490    int KeyId=FFirstKeyId();
491    while (FNextKeyId(KeyId)){
492      GetKeyDat(KeyId, Key, Dat);
493      DatKeyPrV.Add(TPair<TDat, TKey>(Dat, Key));
494    }
495  }
496  template<class TKey, class TDat, class THashFunc>
497  void THashGenericMP<TKey, TDat, THashFunc>::GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const {
498    KeyDatKdV.Gen(Len(), 0);
499    TKey Key; TDat Dat;
500    int KeyId=FFirstKeyId();
501    while (FNextKeyId(KeyId)){
502      GetKeyDat(KeyId, Key, Dat);
503      KeyDatKdV.Add(TKeyDat<TKey, TDat>(Key, Dat));
504    }
505  }
506  template<class TKey, class TDat, class THashFunc>
507  void THashGenericMP<TKey, TDat, THashFunc>::GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const {
508    DatKeyKdV.Gen(Len(), 0);
509    TKey Key; TDat Dat;
510    int KeyId=FFirstKeyId();
511    while (FNextKeyId(KeyId)){
512      GetKeyDat(KeyId, Key, Dat);
513      DatKeyKdV.Add(TKeyDat<TDat, TKey>(Dat, Key));
514    }
515  }
516  template<class TKey, class TDat, class THashFunc>
517  void THashGenericMP<TKey, TDat, THashFunc>::Swap(THashGenericMP& Hash) {
518    if (this!=&Hash){
519      PortV.Swap(Hash.PortV);
520      KeyDatV.Swap(Hash.KeyDatV);
521      ::Swap(AutoSizeP, Hash.AutoSizeP);
522      ::Swap(FFreeKeyId, Hash.FFreeKeyId);
523      ::Swap(FreeKeys, Hash.FreeKeys);
524    }
525  }
526  template<class TKey, class TDat, class THashFunc>
527  void THashGenericMP<TKey, TDat, THashFunc>::Defrag(){
528    if (!IsKeyIdEqKeyN()){
529      THashGenericMP<TKey, TDat, THashFunc> Hash(PortV.Len());
530      int KeyId=FFirstKeyId(); TKey Key; TDat Dat;
531      while (FNextKeyId(KeyId)){
532        GetKeyDat(KeyId, Key, Dat);
533        Hash.AddDat(Key, Dat);
534      }
535      Pack();
536      operator=(Hash);
537      IAssert(IsKeyIdEqKeyN());
538    }
539  }
540  template<class TKey, class TDat, class THashFunc>
541  void THashGenericMP<TKey, TDat, THashFunc>::Sort(const bool& CmpKey, const bool& Asc) {
542    IAssertR(IsKeyIdEqKeyN(), "THash::Sort only works when table has no deleted keys.");
543    TIntV TargV(Len()), MapV(Len()), StateV(Len());
544    for (int i = 0; i < TargV.Len(); i++) {
545      TargV[i] = i; MapV[i] = i; StateV[i] = i;
546    }
547    THashKeyDatCmp HashCmp(*this, CmpKey, Asc);
548    TargV.SortCmp(HashCmp);
549    THashKeyDat<TKey, TDat> Tmp;
550    for (int i = 0; i < TargV.Len()-1; i++) {
551      const int SrcPos = MapV[TargV[i]];
552      const int Loc = i;
553      Tmp = KeyDatV[SrcPos];
554      KeyDatV[SrcPos] = KeyDatV[Loc];
555      KeyDatV[Loc] = Tmp;
556      MapV[StateV[i]] = SrcPos;
557      StateV.Swap(Loc, SrcPos);
558    }
559    for (int i = 0; i < TargV.Len(); i++) {
560      MapV[TargV[i]] = i; }
561    for (int p = 0; p < PortV.Len(); p++) {
562      if (PortV[p] != -1) {
563        PortV[p] = MapV[PortV[p]]; } }
564    for (int i = 0; i < KeyDatV.Len(); i++) {
565      if (KeyDatV[i].Next != -1) {
566        KeyDatV[i].Next = MapV[KeyDatV[i].Next]; }
567    }
568  }
569  template<class TKey, class TDat, class THashFunc>
570  bool THashGenericMP<TKey, TDat, THashFunc>::AddDatIfNotExist(const TKey& Key, const TDat& Dat) {
571    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
572    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
573    int PrevKeyId=-1;
574    int KeyId;
575    bool done = false;
576    while(!done) {
577      bool port_lock = false;
578      int old;
579      int *ptr = &PortLockV[PortN].Val;
580      old = PortLockV[PortN];
581      if (old == -2) {
582        port_lock = false;
583      }
584      else if (__sync_bool_compare_and_swap(ptr, old, -2)) {
585        port_lock = true;
586      }
587      KeyId = PortV[PortN];
588      while ((KeyId!=-1) &&
589          !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
590        PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
591      if (KeyId==-1) {
592        if (port_lock == false) continue;
593        volatile unsigned int *p = (volatile unsigned int *)&FFreeKeyId.Val;
594        KeyId = __sync_fetch_and_add(p, 1);
595        KeyDatV[KeyId].Next=-1;
596        KeyDatV[KeyId].HashCd=HashCd;
597        KeyDatV[KeyId].Key=Key;
598        int temp;
599        int* pt = &KeyDatV[KeyId].Next.Val;
600        while(true) {
601          temp = KeyDatV[KeyId].Next;
602          if (temp == -2) continue;
603          if (__sync_bool_compare_and_swap(pt, temp, -2)) {
604            KeyDatV[KeyId].Dat = Dat;
605            *pt = temp;
606            done = true;
607            break;
608          }
609        }
610        if (PrevKeyId==-1){
611          PortV[PortN] = KeyId;
612        } else {
613          KeyDatV[PrevKeyId].Next=KeyId;
614        }
615        *ptr = old;
616      }
617      else {
618        if (port_lock) *ptr = old;
619        break;
620      }
621    }
622    return done;
623  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tospace.cpp</h3>
            <pre><code>1  #include "drawtord.h"
2  #include "statistc.h"
3  #include "textord.h"
4  #include "tovars.h"
5  #ifdef HAVE_CONFIG_H
6  #  include "config_auto.h"
7  #endif
8  #include <algorithm>
9  #include <cmath>
10  #include <memory>
11  #define MAXSPACING 128 &bsol;*max expected spacing in pix */
12  namespace tesseract {
13  void Textord::to_spacing(ICOORD page_tr,       
14                           TO_BLOCK_LIST *blocks 
15  ) {
16    TO_BLOCK_IT block_it; 
17    TO_BLOCK *block;      
18    TO_ROW *row;          
19    int block_index;      
20    int row_index;        
21    int16_t block_space_gap_width;
22    int16_t block_non_space_gap_width;
23    bool old_text_ord_proportional; 
24    block_it.set_to_list(blocks);
25    block_index = 1;
26    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
27      block = block_it.data();
28      std::unique_ptr<GAPMAP> gapmap(new GAPMAP(block)); 
29      block_spacing_stats(block, gapmap.get(), old_text_ord_proportional, block_space_gap_width,
30                          block_non_space_gap_width);
31      if (tosp_old_to_method && tosp_old_to_constrain_sp_kn &&
32          block_non_space_gap_width > block_space_gap_width / 3) {
33        block_non_space_gap_width = block_space_gap_width / 3;
34      }
35      TO_ROW_IT row_it(block->get_rows());
36      row_index = 1;
37      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
38        row = row_it.data();
39        if ((row->pitch_decision == PITCH_DEF_PROP) || (row->pitch_decision == PITCH_CORR_PROP)) {
40          if ((tosp_debug_level > 0) && !old_text_ord_proportional) {
41            tprintf("Block %d Row %d: Now Proportional\n", block_index, row_index);
42          }
43          row_spacing_stats(row, gapmap.get(), block_index, row_index, block_space_gap_width,
44                            block_non_space_gap_width);
45        } else {
46          if ((tosp_debug_level > 0) && old_text_ord_proportional) {
47            tprintf("Block %d Row %d: Now Fixed Pitch Decision:%d fp flag:%f\n", block_index,
48                    row_index, row->pitch_decision, row->fixed_pitch);
49          }
50        }
51  #ifndef GRAPHICS_DISABLED
52        if (textord_show_initial_words) {
53          plot_word_decisions(to_win, static_cast<int16_t>(row->fixed_pitch), row);
54        }
55  #endif
56        row_index++;
57      }
58      block_index++;
59    }
60  }
61  void Textord::block_spacing_stats(TO_BLOCK *block, GAPMAP *gapmap, bool &old_text_ord_proportional,
62                                    int16_t &block_space_gap_width,    
63                                    int16_t &block_non_space_gap_width 
64  ) {
65    TO_ROW *row;         
66    BLOBNBOX_IT blob_it; 
67    STATS centre_to_centre_stats(0, MAXSPACING - 1);
68    STATS all_gap_stats(0, MAXSPACING - 1);
69    STATS space_gap_stats(0, MAXSPACING - 1);
70    int16_t minwidth = MAXSPACING; 
71    TBOX blob_box;
72    TBOX prev_blob_box;
73    int16_t centre_to_centre;
74    int16_t gap_width;
75    float real_space_threshold;
76    float iqr_centre_to_centre; 
77    float iqr_all_gap_stats;    
78    int32_t end_of_row;
79    int32_t row_length;
80    TO_ROW_IT row_it(block->get_rows());
81    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
82      row = row_it.data();
83      if (!row->blob_list()->empty() &&
84          (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) ||
85           (row->pitch_decision == PITCH_CORR_PROP))) {
86        blob_it.set_to_list(row->blob_list());
87        blob_it.mark_cycle_pt();
88        end_of_row = blob_it.data_relative(-1)->bounding_box().right();
89        if (tosp_use_pre_chopping) {
90          blob_box = box_next_pre_chopped(&blob_it);
91        } else if (tosp_stats_use_xht_gaps) {
92          blob_box = reduced_box_next(row, &blob_it);
93        } else {
94          blob_box = box_next(&blob_it);
95        }
96        row_length = end_of_row - blob_box.left();
97        if (blob_box.width() < minwidth) {
98          minwidth = blob_box.width();
99        }
100        prev_blob_box = blob_box;
101        while (!blob_it.cycled_list()) {
102          if (tosp_use_pre_chopping) {
103            blob_box = box_next_pre_chopped(&blob_it);
104          } else if (tosp_stats_use_xht_gaps) {
105            blob_box = reduced_box_next(row, &blob_it);
106          } else {
107            blob_box = box_next(&blob_it);
108          }
109          if (blob_box.width() < minwidth) {
110            minwidth = blob_box.width();
111          }
112          int16_t left = prev_blob_box.right();
113          int16_t right = blob_box.left();
114          gap_width = right - left;
115          if (!ignore_big_gap(row, row_length, gapmap, left, right)) {
116            all_gap_stats.add(gap_width, 1);
117            centre_to_centre = (right + blob_box.right() - (prev_blob_box.left() + left)) / 2;
118            centre_to_centre_stats.add(centre_to_centre, 1);
119          }
120          prev_blob_box = blob_box;
121        }
122      }
123    }
124    if (all_gap_stats.get_total() <= 1) {
125      block_non_space_gap_width = minwidth;
126      block_space_gap_width = -1; 
127      old_text_ord_proportional = true;
128    } else {
129      iqr_centre_to_centre = centre_to_centre_stats.ile(0.75) - centre_to_centre_stats.ile(0.25);
130      iqr_all_gap_stats = all_gap_stats.ile(0.75) - all_gap_stats.ile(0.25);
131      old_text_ord_proportional = iqr_centre_to_centre * 2 > iqr_all_gap_stats;
132      block_non_space_gap_width = static_cast<int16_t>(floor(all_gap_stats.median()));
133      row_it.set_to_list(block->get_rows());
134      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
135        row = row_it.data();
136        if (!row->blob_list()->empty() &&
137            (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) ||
138             (row->pitch_decision == PITCH_CORR_PROP))) {
139          real_space_threshold = std::max(tosp_init_guess_kn_mult * block_non_space_gap_width,
140                                          tosp_init_guess_xht_mult * row->xheight);
141          blob_it.set_to_list(row->blob_list());
142          blob_it.mark_cycle_pt();
143          end_of_row = blob_it.data_relative(-1)->bounding_box().right();
144          if (tosp_use_pre_chopping) {
145            blob_box = box_next_pre_chopped(&blob_it);
146          } else if (tosp_stats_use_xht_gaps) {
147            blob_box = reduced_box_next(row, &blob_it);
148          } else {
149            blob_box = box_next(&blob_it);
150          }
151          row_length = blob_box.left() - end_of_row;
152          prev_blob_box = blob_box;
153          while (!blob_it.cycled_list()) {
154            if (tosp_use_pre_chopping) {
155              blob_box = box_next_pre_chopped(&blob_it);
156            } else if (tosp_stats_use_xht_gaps) {
157              blob_box = reduced_box_next(row, &blob_it);
158            } else {
159              blob_box = box_next(&blob_it);
160            }
161            int16_t left = prev_blob_box.right();
162            int16_t right = blob_box.left();
163            gap_width = right - left;
164            if ((gap_width > real_space_threshold) &&
165                !ignore_big_gap(row, row_length, gapmap, left, right)) {
166              if (!tosp_block_use_cert_spaces ||
167                  (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
168                  ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
169                   (!tosp_narrow_blobs_not_cert ||
170                    (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
171                  (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
172                space_gap_stats.add(gap_width, 1);
173              }
174            }
175            prev_blob_box = blob_box;
176          }
177        }
178      }
179      if (space_gap_stats.get_total() <= 2) {
180        block_space_gap_width = -1; 
181      } else {
182        block_space_gap_width = std::max(static_cast<int16_t>(floor(space_gap_stats.median())),
183                                         static_cast<int16_t>(3 * block_non_space_gap_width));
184      }
185    }
186  }
187  void Textord::row_spacing_stats(TO_ROW *row, GAPMAP *gapmap, int16_t block_idx, int16_t row_idx,
188                                  int16_t block_space_gap_width,    
189                                  int16_t block_non_space_gap_width 
190  ) {
191    BLOBNBOX_IT blob_it = row->blob_list();
192    STATS all_gap_stats(0, MAXSPACING - 1);
193    STATS cert_space_gap_stats(0, MAXSPACING - 1);
194    STATS all_space_gap_stats(0, MAXSPACING - 1);
195    STATS small_gap_stats(0, MAXSPACING - 1);
196    TBOX blob_box;
197    TBOX prev_blob_box;
198    int16_t gap_width;
199    int16_t real_space_threshold = 0;
200    int16_t max = 0;
201    int16_t index;
202    int16_t large_gap_count = 0;
203    bool suspected_table;
204    int32_t max_max_nonspace; 
205    bool good_block_space_estimate = block_space_gap_width > 0;
206    int32_t end_of_row;
207    int32_t row_length = 0;
208    float sane_space;
209    int32_t sane_threshold;
210    if (!good_block_space_estimate) {
211      block_space_gap_width = int16_t(std::floor(row->xheight / 2));
212    }
213    if (!row->blob_list()->empty()) {
214      if (tosp_threshold_bias1 > 0) {
215        real_space_threshold =
216            block_non_space_gap_width +
217            int16_t(floor(0.5 + tosp_threshold_bias1 *
218                                    (block_space_gap_width - block_non_space_gap_width)));
219      } else {
220        real_space_threshold = 
221            (block_space_gap_width + block_non_space_gap_width) / 2;
222      }
223      blob_it.set_to_list(row->blob_list());
224      blob_it.mark_cycle_pt();
225      end_of_row = blob_it.data_relative(-1)->bounding_box().right();
226      if (tosp_use_pre_chopping) {
227        blob_box = box_next_pre_chopped(&blob_it);
228      } else if (tosp_stats_use_xht_gaps) {
229        blob_box = reduced_box_next(row, &blob_it);
230      } else {
231        blob_box = box_next(&blob_it);
232      }
233      row_length = end_of_row - blob_box.left();
234      prev_blob_box = blob_box;
235      while (!blob_it.cycled_list()) {
236        if (tosp_use_pre_chopping) {
237          blob_box = box_next_pre_chopped(&blob_it);
238        } else if (tosp_stats_use_xht_gaps) {
239          blob_box = reduced_box_next(row, &blob_it);
240        } else {
241          blob_box = box_next(&blob_it);
242        }
243        int16_t left = prev_blob_box.right();
244        int16_t right = blob_box.left();
245        gap_width = right - left;
246        if (ignore_big_gap(row, row_length, gapmap, left, right)) {
247          large_gap_count++;
248        } else {
249          if (gap_width >= real_space_threshold) {
250            if (!tosp_row_use_cert_spaces || (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
251                ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
252                 (!tosp_narrow_blobs_not_cert ||
253                  (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
254                (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
255              cert_space_gap_stats.add(gap_width, 1);
256            }
257            all_space_gap_stats.add(gap_width, 1);
258          } else {
259            small_gap_stats.add(gap_width, 1);
260          }
261          all_gap_stats.add(gap_width, 1);
262        }
263        prev_blob_box = blob_box;
264      }
265    }
266    suspected_table = (large_gap_count > 1) ||
267                      ((large_gap_count > 0) && (all_gap_stats.get_total() <= tosp_few_samples));
268    if ((cert_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) ||
269        ((suspected_table || all_gap_stats.get_total() <= tosp_short_row) &&
270         cert_space_gap_stats.get_total() > 0)) {
271      old_to_method(row, &all_gap_stats, &cert_space_gap_stats, &small_gap_stats,
272                    block_space_gap_width, block_non_space_gap_width);
273    } else {
274      if (!tosp_recovery_isolated_row_stats ||
275          !isolated_row_stats(row, gapmap, &all_gap_stats, suspected_table, block_idx, row_idx)) {
276        if (tosp_row_use_cert_spaces && (tosp_debug_level > 5)) {
277          tprintf("B:%d R:%d -- Inadequate certain spaces.\n", block_idx, row_idx);
278        }
279        if (tosp_row_use_cert_spaces1 && good_block_space_estimate) {
280          row->space_size = block_space_gap_width;
281          if (all_gap_stats.get_total() > tosp_redo_kern_limit) {
282            row->kern_size = all_gap_stats.median();
283          } else {
284            row->kern_size = block_non_space_gap_width;
285          }
286          row->space_threshold =
287              int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
288        } else {
289          old_to_method(row, &all_gap_stats, &all_space_gap_stats, &small_gap_stats,
290                        block_space_gap_width, block_non_space_gap_width);
291        }
292      }
293    }
294    if (tosp_improve_thresh && !suspected_table) {
295      improve_row_threshold(row, &all_gap_stats);
296    }
297    if (tosp_sanity_method == 0) {
298      if (suspected_table && (row->space_size < tosp_table_kn_sp_ratio * row->kern_size)) {
299        if (tosp_debug_level > 5) {
300          tprintf("B:%d R:%d -- DON'T BELIEVE SPACE %3.2f %d %3.2f.\n", block_idx, row_idx,
301                  row->kern_size, row->space_threshold, row->space_size);
302        }
303        row->space_threshold = static_cast<int32_t>(tosp_table_kn_sp_ratio * row->kern_size);
304        row->space_size = std::max(row->space_threshold + 1.0f, row->xheight);
305      }
306    } else if (tosp_sanity_method == 1) {
307      sane_space = row->space_size;
308      if ((row->space_size < tosp_min_sane_kn_sp * std::max(row->kern_size, 2.5f)) ||
309          ((row->space_size - row->kern_size) < (tosp_silly_kn_sp_gap * row->xheight))) {
310        if (good_block_space_estimate &&
311            (block_space_gap_width >= tosp_min_sane_kn_sp * row->kern_size)) {
312          sane_space = block_space_gap_width;
313        } else {
314          sane_space =
315              std::max(static_cast<float>(tosp_min_sane_kn_sp) * std::max(row->kern_size, 2.5f),
316                       row->xheight / 2.0f);
317        }
318        if (tosp_debug_level > 5) {
319          tprintf("B:%d R:%d -- DON'T BELIEVE SPACE %3.2f %d %3.2f -> %3.2f.\n", block_idx, row_idx,
320                  row->kern_size, row->space_threshold, row->space_size, sane_space);
321        }
322        row->space_size = sane_space;
323        row->space_threshold =
324            int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
325      }
326      sane_threshold = int32_t(floor(tosp_max_sane_kn_thresh * std::max(row->kern_size, 2.5f)));
327      if (row->space_threshold > sane_threshold) {
328        if (tosp_debug_level > 5) {
329          tprintf("B:%d R:%d -- DON'T BELIEVE THRESH %3.2f %d %3.2f->%d.\n", block_idx, row_idx,
330                  row->kern_size, row->space_threshold, row->space_size, sane_threshold);
331        }
332        row->space_threshold = sane_threshold;
333        if (row->space_size <= sane_threshold) {
334          row->space_size = row->space_threshold + 1.0f;
335        }
336      }
337      if (suspected_table) {
338        sane_space =
339            std::max(tosp_table_kn_sp_ratio * row->kern_size, tosp_table_xht_sp_ratio * row->xheight);
340        sane_threshold = int32_t(std::floor((sane_space + row->kern_size) / 2));
341        if ((row->space_size < sane_space) || (row->space_threshold < sane_threshold)) {
342          if (tosp_debug_level > 5) {
343            tprintf("B:%d R:%d -- SUSPECT NO SPACES %3.2f %d %3.2f.\n", block_idx, row_idx,
344                    row->kern_size, row->space_threshold, row->space_size);
345          }
346          row->space_threshold = static_cast<int32_t>(sane_space);
347          row->space_size = std::max(row->space_threshold + 1.0f, row->xheight);
348        }
349      }
350    }
351    if (tosp_old_to_method) {
352      row->max_nonspace = row->space_threshold;
353      row->min_space = row->space_threshold + 1;
354    } else {
355      row->min_space =
356          std::min(int32_t(ceil(tosp_fuzzy_space_factor * row->xheight)), int32_t(row->space_size));
357      if (row->min_space <= row->space_threshold) {
358        row->min_space = row->space_threshold + 1;
359      }
360      max_max_nonspace = int32_t((row->space_threshold + row->kern_size) / 2);
361      row->max_nonspace = max_max_nonspace;
362      for (index = 0; index <= max_max_nonspace; index++) {
363        if (all_gap_stats.pile_count(index) > max) {
364          max = all_gap_stats.pile_count(index);
365        }
366        if ((index > row->kern_size) && (all_gap_stats.pile_count(index) < 0.1 * max)) {
367          row->max_nonspace = index;
368          break;
369        }
370      }
371    }
372    if ((tosp_fuzzy_sp_fraction > 0) && (row->space_size > row->space_threshold)) {
373      row->min_space = std::max(
374          row->min_space, static_cast<int32_t>(ceil(row->space_threshold +
375                                                    tosp_fuzzy_sp_fraction *
376                                                        (row->space_size - row->space_threshold))));
377    }
378    if ((tosp_table_fuzzy_kn_sp_ratio > 0) && (suspected_table || tosp_fuzzy_limit_all)) {
379      row->min_space = std::max(
380          row->min_space, static_cast<int32_t>(ceil(tosp_table_fuzzy_kn_sp_ratio * row->kern_size)));
381    }
382    if ((tosp_fuzzy_kn_fraction > 0) && (row->kern_size < row->space_threshold)) {
383      row->max_nonspace = static_cast<int32_t>(floor(
384          0.5 + row->kern_size + tosp_fuzzy_kn_fraction * (row->space_threshold - row->kern_size)));
385    }
386    if (row->max_nonspace > row->space_threshold) {
387      row->max_nonspace = row->space_threshold;
388    }
389    if (tosp_debug_level > 5) {
390      tprintf(
391          "B:%d R:%d L:%d-- Kn:%d Sp:%d Thr:%d -- Kn:%3.2f (%d) Thr:%d (%d) "
392          "Sp:%3.2f\n",
393          block_idx, row_idx, row_length, block_non_space_gap_width, block_space_gap_width,
394          real_space_threshold, row->kern_size, row->max_nonspace, row->space_threshold,
395          row->min_space, row->space_size);
396    }
397    if (tosp_debug_level > 10) {
398      tprintf(
399          "row->kern_size = %3.2f, row->space_size = %3.2f, "
400          "row->space_threshold = %d\n",
401          row->kern_size, row->space_size, row->space_threshold);
402    }
403  }
404  void Textord::old_to_method(TO_ROW *row, STATS *all_gap_stats, STATS *space_gap_stats,
405                              STATS *small_gap_stats,
406                              int16_t block_space_gap_width,    
407                              int16_t block_non_space_gap_width 
408  ) {
409    if (space_gap_stats->get_total() >= tosp_enough_space_samples_for_median) {
410      row->space_size = space_gap_stats->median();
411      if (row->space_size > block_space_gap_width * 1.5) {
412        if (tosp_old_to_bug_fix) {
413          row->space_size = block_space_gap_width * 1.5;
414        } else {
415          row->space_size = block_space_gap_width;
416        }
417      }
418      if (row->space_size < (block_non_space_gap_width * 2) + 1) {
419        row->space_size = (block_non_space_gap_width * 2) + 1;
420      }
421    }
422    else if (space_gap_stats->get_total() >= 1) {
423      row->space_size = space_gap_stats->mean();
424      if (row->space_size > block_space_gap_width * 1.5) {
425        if (tosp_old_to_bug_fix) {
426          row->space_size = block_space_gap_width * 1.5;
427        } else {
428          row->space_size = block_space_gap_width;
429        }
430      }
431      if (row->space_size < (block_non_space_gap_width * 3) + 1) {
432        row->space_size = (block_non_space_gap_width * 3) + 1;
433      }
434    } else {
435      row->space_size = block_space_gap_width;
436    }
437    if ((tosp_only_small_gaps_for_kern) && (small_gap_stats->get_total() > tosp_redo_kern_limit)) {
438      row->kern_size = small_gap_stats->median();
439    } else if (all_gap_stats->get_total() > tosp_redo_kern_limit) {
440      row->kern_size = all_gap_stats->median();
441    } else { 
442      row->kern_size = block_non_space_gap_width;
443    }
444    if (tosp_threshold_bias2 > 0) {
445      row->space_threshold = int32_t(
446          floor(0.5 + row->kern_size + tosp_threshold_bias2 * (row->space_size - row->kern_size)));
447    } else {
448      row->space_threshold = int32_t(std::floor((row->space_size + row->kern_size) / 2));
449    }
450    if (tosp_old_to_constrain_sp_kn && tosp_sanity_method == 1 &&
451        ((row->space_size < tosp_min_sane_kn_sp * std::max(row->kern_size, 2.5f)) ||
452         ((row->space_size - row->kern_size) < tosp_silly_kn_sp_gap * row->xheight))) {
453      if (row->kern_size > 2.5) {
454        row->kern_size = row->space_size / tosp_min_sane_kn_sp;
455      }
456      row->space_threshold =
457          int32_t(floor((row->space_size + row->kern_size) / tosp_old_sp_kn_th_factor));
458    }
459  }
460  bool Textord::isolated_row_stats(TO_ROW *row, GAPMAP *gapmap, STATS *all_gap_stats,
461                                   bool suspected_table, int16_t block_idx, int16_t row_idx) {
462    float kern_estimate;
463    float crude_threshold_estimate;
464    int16_t small_gaps_count;
465    int16_t total;
466    BLOBNBOX_IT blob_it = row->blob_list();
467    STATS cert_space_gap_stats(0, MAXSPACING - 1);
468    STATS all_space_gap_stats(0, MAXSPACING - 1);
469    STATS small_gap_stats(0, MAXSPACING - 1);
470    TBOX blob_box;
471    TBOX prev_blob_box;
472    int16_t gap_width;
473    int32_t end_of_row;
474    int32_t row_length;
475    kern_estimate = all_gap_stats->median();
476    crude_threshold_estimate =
477        std::max(tosp_init_guess_kn_mult * kern_estimate, tosp_init_guess_xht_mult * row->xheight);
478    small_gaps_count =
479        stats_count_under(all_gap_stats, static_cast<int16_t>(std::ceil(crude_threshold_estimate)));
480    total = all_gap_stats->get_total();
481    if ((total <= tosp_redo_kern_limit) ||
482        ((small_gaps_count / static_cast<float>(total)) < tosp_enough_small_gaps) ||
483        (total - small_gaps_count < 1)) {
484      if (tosp_debug_level > 5) {
485        tprintf("B:%d R:%d -- Can't do isolated row stats.\n", block_idx, row_idx);
486      }
487      return false;
488    }
489    blob_it.set_to_list(row->blob_list());
490    blob_it.mark_cycle_pt();
491    end_of_row = blob_it.data_relative(-1)->bounding_box().right();
492    if (tosp_use_pre_chopping) {
493      blob_box = box_next_pre_chopped(&blob_it);
494    } else if (tosp_stats_use_xht_gaps) {
495      blob_box = reduced_box_next(row, &blob_it);
496    } else {
497      blob_box = box_next(&blob_it);
498    }
499    row_length = end_of_row - blob_box.left();
500    prev_blob_box = blob_box;
501    while (!blob_it.cycled_list()) {
502      if (tosp_use_pre_chopping) {
503        blob_box = box_next_pre_chopped(&blob_it);
504      } else if (tosp_stats_use_xht_gaps) {
505        blob_box = reduced_box_next(row, &blob_it);
506      } else {
507        blob_box = box_next(&blob_it);
508      }
509      int16_t left = prev_blob_box.right();
510      int16_t right = blob_box.left();
511      gap_width = right - left;
512      if (!ignore_big_gap(row, row_length, gapmap, left, right) &&
513          (gap_width > crude_threshold_estimate)) {
514        if ((gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
515            ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
516             (!tosp_narrow_blobs_not_cert ||
517              (!narrow_blob(row, prev_blob_box) && !narrow_blob(row, blob_box)))) ||
518            (wide_blob(row, prev_blob_box) && wide_blob(row, blob_box))) {
519          cert_space_gap_stats.add(gap_width, 1);
520        }
521        all_space_gap_stats.add(gap_width, 1);
522      }
523      if (gap_width < crude_threshold_estimate) {
524        small_gap_stats.add(gap_width, 1);
525      }
526      prev_blob_box = blob_box;
527    }
528    if (cert_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) {
529      row->space_size = cert_space_gap_stats.median();
530    } else if (suspected_table && (cert_space_gap_stats.get_total() > 0)) {
531      row->space_size = cert_space_gap_stats.mean();
532    } else if (all_space_gap_stats.get_total() >= tosp_enough_space_samples_for_median) {
533      row->space_size = all_space_gap_stats.median();
534    } else {
535      row->space_size = all_space_gap_stats.mean();
536    }
537    if (tosp_only_small_gaps_for_kern) {
538      row->kern_size = small_gap_stats.median();
539    } else {
540      row->kern_size = all_gap_stats->median();
541    }
542    row->space_threshold = int32_t(std::floor((row->space_size + row->kern_size) / 2));
543    if ((row->kern_size >= row->space_threshold) || (row->space_threshold >= row->space_size) ||
544        (row->space_threshold <= 0)) {
545      if (tosp_debug_level > 5) {
546        tprintf("B:%d R:%d -- Isolated row stats SANITY FAILURE: %f %d %f\n", block_idx, row_idx,
547                row->kern_size, row->space_threshold, row->space_size);
548      }
549      row->kern_size = 0.0f;
550      row->space_threshold = 0;
551      row->space_size = 0.0f;
552      return false;
553    }
554    if (tosp_debug_level > 5) {
555      tprintf("B:%d R:%d -- Isolated row stats: %f %d %f\n", block_idx, row_idx, row->kern_size,
556              row->space_threshold, row->space_size);
557    }
558    return true;
559  }
560  int16_t Textord::stats_count_under(STATS *stats, int16_t threshold) {
561    int16_t index;
562    int16_t total = 0;
563    for (index = 0; index < threshold; index++) {
564      total += stats->pile_count(index);
565    }
566    return total;
567  }
568  void Textord::improve_row_threshold(TO_ROW *row, STATS *all_gap_stats) {
569    float sp = row->space_size;
570    float kn = row->kern_size;
571    int16_t reqd_zero_width = 0;
572    int16_t zero_width = 0;
573    int16_t zero_start = 0;
574    int16_t index = 0;
575    if (tosp_debug_level > 10) {
576      tprintf("Improve row threshold 0");
577    }
578    if ((all_gap_stats->get_total() <= 25) || (sp <= 10) || (sp <= 3 * kn) ||
579        (stats_count_under(all_gap_stats, static_cast<int16_t>(ceil(kn + (sp - kn) / 3 + 0.5))) <
580         (0.75 * all_gap_stats->get_total()))) {
581      return;
582    }
583    if (tosp_debug_level > 10) {
584      tprintf(" 1");
585    }
586    reqd_zero_width = static_cast<int16_t>(floor((sp - kn) / 3 + 0.5));
587    if (reqd_zero_width < 3) {
588      reqd_zero_width = 3;
589    }
590    for (index = int16_t(std::ceil(kn)); index < int16_t(std::floor(sp)); index++) {
591      if (all_gap_stats->pile_count(index) == 0) {
592        if (zero_width == 0) {
593          zero_start = index;
594        }
595        zero_width++;
596      } else {
597        if (zero_width >= reqd_zero_width) {
598          break;
599        } else {
600          zero_width = 0;
601        }
602      }
603    }
604    index--;
605    if (tosp_debug_level > 10) {
606      tprintf(" reqd_z_width: %d found %d 0's, starting %d; thresh: %d/n", reqd_zero_width,
607              zero_width, zero_start, row->space_threshold);
608    }
609    if ((zero_width < reqd_zero_width) ||
610        ((row->space_threshold >= zero_start) && (row->space_threshold <= index))) {
611      return;
612    }
613    if (tosp_debug_level > 10) {
614      tprintf(" 2");
615    }
616    if (row->space_threshold < zero_start) {
617      if (tosp_debug_level > 5) {
618        tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start,
619                index, row->space_threshold, zero_start);
620      }
621      row->space_threshold = zero_start;
622    }
623    if (row->space_threshold > index) {
624      if (tosp_debug_level > 5) {
625        tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start,
626                index, row->space_threshold, index);
627      }
628      row->space_threshold = index;
629    }
630  }
631  ROW *Textord::make_prop_words(TO_ROW *row,    
632                                FCOORD rotation 
633  ) {
634    bool bol; 
635    bool prev_fuzzy_sp;     
636    bool prev_fuzzy_non;    
637    uint8_t prev_blanks;    
638    bool fuzzy_sp = false;  
639    bool fuzzy_non = false; 
640    uint8_t blanks = 0;     
641    bool prev_gap_was_a_space = false;
642    bool break_at_next_gap = false;
643    ROW *real_row; 
644    C_OUTLINE_IT cout_it;
645    C_BLOB_LIST cblobs;
646    C_BLOB_IT cblob_it = &cblobs;
647    WERD_LIST words;
648    WERD *word; 
649    int32_t next_rep_char_word_right = INT32_MAX;
650    float repetition_spacing; 
651    int32_t xstarts[2];       
652    int32_t prev_x;           
653    BLOBNBOX_IT box_it;       
654    TBOX prev_blob_box;
655    TBOX next_blob_box;
656    int16_t prev_gap = INT16_MAX;
657    int16_t current_gap = INT16_MAX;
658    int16_t next_gap = INT16_MAX;
659    int16_t prev_within_xht_gap = INT16_MAX;
660    int16_t current_within_xht_gap = INT16_MAX;
661    int16_t next_within_xht_gap = INT16_MAX;
662    int16_t word_count = 0;
663    WERD_IT rep_char_it(&(row->rep_words));
664    if (!rep_char_it.empty()) {
665      next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
666    }
667    prev_x = -INT16_MAX;
668    cblob_it.set_to_list(&cblobs);
669    box_it.set_to_list(row->blob_list());
670    WERD_IT word_it(&words);
671    bol = true;
672    prev_blanks = 0;
673    prev_fuzzy_sp = false;
674    prev_fuzzy_non = false;
675    if (!box_it.empty()) {
676      xstarts[0] = box_it.data()->bounding_box().left();
677      if (xstarts[0] > next_rep_char_word_right) {
678        word = rep_char_it.extract();
679        word_it.add_after_then_move(word);
680        word->set_flag(W_BOL, true);
681        bol = false;
682        word->set_blanks(0);
683        word->set_flag(W_FUZZY_SP, false);
684        word->set_flag(W_FUZZY_NON, false);
685        xstarts[0] = word->bounding_box().left();
686        repetition_spacing = find_mean_blob_spacing(word);
687        current_gap = box_it.data()->bounding_box().left() - next_rep_char_word_right;
688        current_within_xht_gap = current_gap;
689        if (current_gap > tosp_rep_space * repetition_spacing) {
690          prev_blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
691          if (prev_blanks < 1) {
692            prev_blanks = 1;
693          }
694        } else {
695          prev_blanks = 0;
696        }
697        if (tosp_debug_level > 5) {
698          tprintf("Repch wd at BOL(%d, %d). rep spacing %5.2f;  Rgap:%d  ",
699                  box_it.data()->bounding_box().left(), box_it.data()->bounding_box().bottom(),
700                  repetition_spacing, current_gap);
701        }
702        prev_fuzzy_sp = false;
703        prev_fuzzy_non = false;
704        if (rep_char_it.empty()) {
705          next_rep_char_word_right = INT32_MAX;
706        } else {
707          rep_char_it.forward();
708          next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
709        }
710      }
711      peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);
712      do {
713        auto bblob = box_it.data();
714        auto blob_box = bblob->bounding_box();
715        if (bblob->joined_to_prev()) {
716          auto cblob = bblob->remove_cblob();
717          if (cblob != nullptr) {
718            cout_it.set_to_list(cblob_it.data()->out_list());
719            cout_it.move_to_last();
720            cout_it.add_list_after(cblob->out_list());
721            delete cblob;
722          }
723        } else {
724          auto cblob = bblob->cblob();
725          if (cblob != nullptr) {
726            bblob->set_owns_cblob(false);
727            cblob_it.add_after_then_move(cblob);
728          }
729          prev_x = blob_box.right();
730        }
731        box_it.forward(); 
732        bblob = box_it.data();
733        blob_box = bblob->bounding_box();
734        if (!bblob->joined_to_prev() && bblob->cblob() != nullptr) {
735          prev_gap = current_gap;
736          prev_within_xht_gap = current_within_xht_gap;
737          prev_blob_box = next_blob_box;
738          current_gap = next_gap;
739          current_within_xht_gap = next_within_xht_gap;
740          peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);
741          int16_t prev_gap_arg = prev_gap;
742          int16_t next_gap_arg = next_gap;
743          if (tosp_only_use_xht_gaps) {
744            prev_gap_arg = prev_within_xht_gap;
745            next_gap_arg = next_within_xht_gap;
746          }
747          if (blob_box.left() > next_rep_char_word_right ||
748              make_a_word_break(row, blob_box, prev_gap_arg, prev_blob_box, current_gap,
749                                current_within_xht_gap, next_blob_box, next_gap_arg, blanks, fuzzy_sp,
750                                fuzzy_non, prev_gap_was_a_space, break_at_next_gap) ||
751              box_it.at_first()) {
752            word = new WERD(&cblobs, prev_blanks, nullptr);
753            word_count++;
754            word_it.add_after_then_move(word);
755            if (bol) {
756              word->set_flag(W_BOL, true);
757              bol = false;
758            }
759            if (prev_fuzzy_sp) {
760              word->set_flag(W_FUZZY_SP, true);
761            } else if (prev_fuzzy_non) {
762              word->set_flag(W_FUZZY_NON, true);
763            }
764            if (blob_box.left() > next_rep_char_word_right) {
765              word = rep_char_it.extract();
766              word_it.add_after_then_move(word);
767              repetition_spacing = find_mean_blob_spacing(word);
768              current_gap = word->bounding_box().left() - prev_x;
769              current_within_xht_gap = current_gap;
770              if (current_gap > tosp_rep_space * repetition_spacing) {
771                blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
772                if (blanks < 1) {
773                  blanks = 1;
774                }
775              } else {
776                blanks = 0;
777              }
778              if (tosp_debug_level > 5) {
779                tprintf("Repch wd (%d,%d) rep gap %5.2f;  Lgap:%d (%d blanks);",
780                        word->bounding_box().left(), word->bounding_box().bottom(),
781                        repetition_spacing, current_gap, blanks);
782              }
783              word->set_blanks(blanks);
784              word->set_flag(W_FUZZY_SP, false);
785              word->set_flag(W_FUZZY_NON, false);
786              current_gap = blob_box.left() - next_rep_char_word_right;
787              if (current_gap > tosp_rep_space * repetition_spacing) {
788                blanks = static_cast<uint8_t>(current_gap / row->space_size);
789                if (blanks < 1) {
790                  blanks = 1;
791                }
792              } else {
793                blanks = 0;
794              }
795              if (tosp_debug_level > 5) {
796                tprintf(" Rgap:%d (%d blanks)\n", current_gap, blanks);
797              }
798              fuzzy_sp = false;
799              fuzzy_non = false;
800              if (rep_char_it.empty()) {
801                next_rep_char_word_right = INT32_MAX;
802              } else {
803                rep_char_it.forward();
804                next_rep_char_word_right = rep_char_it.data()->bounding_box().right();
805              }
806            }
807            if (box_it.at_first() && rep_char_it.empty()) {
808              word->set_flag(W_EOL, true);
809              xstarts[1] = prev_x;
810            } else {
811              prev_blanks = blanks;
812              prev_fuzzy_sp = fuzzy_sp;
813              prev_fuzzy_non = fuzzy_non;
814            }
815          }
816        }
817      } while (!box_it.at_first()); 
818      while (!rep_char_it.empty()) {
819        word = rep_char_it.extract();
820        word_it.add_after_then_move(word);
821        repetition_spacing = find_mean_blob_spacing(word);
822        current_gap = word->bounding_box().left() - prev_x;
823        if (current_gap > tosp_rep_space * repetition_spacing) {
824          blanks = static_cast<uint8_t>(std::floor(current_gap / row->space_size));
825          if (blanks < 1) {
826            blanks = 1;
827          }
828        } else {
829          blanks = 0;
830        }
831        if (tosp_debug_level > 5) {
832          tprintf("Repch wd at EOL (%d,%d). rep spacing %5.2f; Lgap:%d (%d blanks)\n",
833                  word->bounding_box().left(), word->bounding_box().bottom(), repetition_spacing,
834                  current_gap, blanks);
835        }
836        word->set_blanks(blanks);
837        word->set_flag(W_FUZZY_SP, false);
838        word->set_flag(W_FUZZY_NON, false);
839        prev_x = word->bounding_box().right();
840        if (rep_char_it.empty()) {
841          word->set_flag(W_EOL, true);
842          xstarts[1] = prev_x;
843        } else {
844          rep_char_it.forward();
845        }
846      }
847      real_row =
848          new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
849      word_it.set_to_list(real_row->word_list());
850      word_it.add_list_after(&words);
851      real_row->recalc_bounding_box();
852      if (tosp_debug_level > 4) {
853        tprintf("Row: Made %d words in row ((%d,%d)(%d,%d))\n", word_count,
854                real_row->bounding_box().left(), real_row->bounding_box().bottom(),
855                real_row->bounding_box().right(), real_row->bounding_box().top());
856      }
857      return real_row;
858    }
859    return nullptr;
860  }
861  ROW *Textord::make_blob_words(TO_ROW *row,    
862                                FCOORD rotation 
863  ) {
864    bool bol;      
865    ROW *real_row; 
866    C_OUTLINE_IT cout_it;
867    C_BLOB_LIST cblobs;
868    C_BLOB_IT cblob_it = &cblobs;
869    WERD_LIST words;
870    WERD *word;         
871    BLOBNBOX_IT box_it; 
872    int16_t word_count = 0;
873    cblob_it.set_to_list(&cblobs);
874    box_it.set_to_list(row->blob_list());
875    WERD_IT word_it(&words);
876    bol = true;
877    if (!box_it.empty()) {
878      do {
879        auto bblob = box_it.data();
880        auto blob_box = bblob->bounding_box();
881        if (bblob->joined_to_prev()) {
882          auto cblob = bblob->remove_cblob();
883          if (cblob != nullptr) {
884            cout_it.set_to_list(cblob_it.data()->out_list());
885            cout_it.move_to_last();
886            cout_it.add_list_after(cblob->out_list());
887            delete cblob;
888          }
889        } else {
890          auto cblob = bblob->cblob();
891          if (cblob != nullptr) {
892            bblob->set_owns_cblob(false);
893            cblob_it.add_after_then_move(cblob);
894          }
895        }
896        box_it.forward(); 
897        bblob = box_it.data();
898        blob_box = bblob->bounding_box();
899        if (!bblob->joined_to_prev() && !cblobs.empty()) {
900          word = new WERD(&cblobs, 1, nullptr);
901          word_count++;
902          word_it.add_after_then_move(word);
903          if (bol) {
904            word->set_flag(W_BOL, true);
905            bol = false;
906          }
907          if (box_it.at_first()) { 
908            word->set_flag(W_EOL, true);
909          }
910        }
911      } while (!box_it.at_first()); 
912      real_row =
913          new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
914      word_it.set_to_list(real_row->word_list());
915      word_it.add_list_after(&words);
916      real_row->recalc_bounding_box();
917      if (tosp_debug_level > 4) {
918        tprintf("Row:Made %d words in row ((%d,%d)(%d,%d))\n", word_count,
919                real_row->bounding_box().left(), real_row->bounding_box().bottom(),
920                real_row->bounding_box().right(), real_row->bounding_box().top());
921      }
922      return real_row;
923    }
924    return nullptr;
925  }
<span onclick='openModal()' class='match'>926  bool Textord::make_a_word_break(TO_ROW *row,   
927                                  TBOX blob_box, 
928                                  int16_t prev_gap, TBOX prev_blob_box, int16_t real_current_gap,
929                                  int16_t within_xht_current_gap, TBOX next_blob_box,
930                                  int16_t next_gap, uint8_t &blanks, bool &fuzzy_sp, bool &fuzzy_non,
931                                  bool &prev_gap_was_a_space, bool &break_at_next_gap) {
932    bool space;
933    int16_t current_gap;
934    float fuzzy_sp_to_kn_limit;
</span>935    if (break_at_next_gap) {
936      break_at_next_gap = false;
937      return true;
938    }
939    if ((row->kern_size > tosp_large_kerning * row->xheight) ||
940        ((tosp_dont_fool_with_small_kerns >= 0) &&
941         (real_current_gap < tosp_dont_fool_with_small_kerns * row->kern_size))) {
942      within_xht_current_gap = real_current_gap;
943    }
944    if (tosp_use_xht_gaps && tosp_only_use_xht_gaps) {
945      current_gap = within_xht_current_gap;
946    } else {
947      current_gap = real_current_gap;
948    }
949    if (tosp_old_to_method) {
950      space = current_gap > row->max_nonspace;
951      if (space && (current_gap < INT16_MAX)) {
952        if (current_gap < row->min_space) {
953          if (current_gap > row->space_threshold) {
954            blanks = 1;
955            fuzzy_sp = true;
956            fuzzy_non = false;
957          } else {
958            blanks = 0;
959            fuzzy_sp = false;
960            fuzzy_non = true;
961          }
962        } else {
963          if (row->space_size == 0.0f) {
964            blanks = 1;
965          } else {
966            blanks = static_cast<uint8_t>(current_gap / row->space_size);
967            if (blanks < 1) {
968              blanks = 1;
969            }
970          }
971          fuzzy_sp = false;
972          fuzzy_non = false;
973        }
974      }
975      return space;
976    } else {
977      if (prev_blob_box.null_box()) { 
978        prev_gap_was_a_space = true;
979      }
980      space = current_gap > row->space_threshold;
981      int num_blanks = current_gap;
982      if (row->space_size > 1.0f) {
983        num_blanks = IntCastRounded(current_gap / row->space_size);
984      }
985      blanks = static_cast<uint8_t>(ClipToRange<int>(num_blanks, 1, UINT8_MAX));
986      fuzzy_sp = false;
987      fuzzy_non = false;
988      if (tosp_use_xht_gaps && (real_current_gap <= row->max_nonspace) &&
989          (within_xht_current_gap > row->max_nonspace)) {
990        space = true;
991        fuzzy_non = true;
992  #ifndef GRAPHICS_DISABLED
993        mark_gap(blob_box, 20, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
994                 next_gap);
995  #endif
996      } else if (tosp_use_xht_gaps && (real_current_gap <= row->space_threshold) &&
997                 (within_xht_current_gap > row->space_threshold)) {
998        space = true;
999        if (tosp_flip_fuzz_kn_to_sp) {
1000          fuzzy_sp = true;
1001        } else {
1002          fuzzy_non = true;
1003        }
1004  #ifndef GRAPHICS_DISABLED
1005        mark_gap(blob_box, 21, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1006                 next_gap);
1007  #endif
1008      } else if (tosp_use_xht_gaps && (real_current_gap < row->min_space) &&
1009                 (within_xht_current_gap >= row->min_space)) {
1010        space = true;
1011  #ifndef GRAPHICS_DISABLED
1012        mark_gap(blob_box, 22, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1013                 next_gap);
1014  #endif
1015      } else if (tosp_force_wordbreak_on_punct && !suspected_punct_blob(row, prev_blob_box) &&
1016                 suspected_punct_blob(row, blob_box)) {
1017        break_at_next_gap = true;
1018      }
1019      else if ((current_gap < row->min_space) && (current_gap > row->space_threshold)) {
1020        if (tosp_pass_wide_fuzz_sp_to_context > 0) {
1021          fuzzy_sp_to_kn_limit =
1022              row->kern_size + tosp_pass_wide_fuzz_sp_to_context * (row->space_size - row->kern_size);
1023        } else {
1024          fuzzy_sp_to_kn_limit = 99999.0f;
1025        }
1026        if ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box) && prev_gap_was_a_space &&
1027            (current_gap <= tosp_gap_factor * prev_gap)) {
1028          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1029            if (tosp_flip_fuzz_sp_to_kn) {
1030              fuzzy_non = true;
1031            } else {
1032              fuzzy_sp = true;
1033            }
1034          } else {
1035            space = false;
1036          }
1037  #ifndef GRAPHICS_DISABLED
1038          mark_gap(blob_box, 1, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1039                   next_gap);
1040  #endif
1041        }
1042        else if ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box) &&
1043                 !prev_gap_was_a_space && (current_gap * tosp_gap_factor <= prev_gap)) {
1044          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1045            if (tosp_flip_fuzz_sp_to_kn) {
1046              fuzzy_non = true;
1047            } else {
1048              fuzzy_sp = true;
1049            }
1050          } else {
1051            space = false;
1052          }
1053  #ifndef GRAPHICS_DISABLED
1054          mark_gap(blob_box, 2, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1055                   next_gap);
1056  #endif
1057        } else if ((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box) &&
1058                   (next_gap > row->space_threshold) && (current_gap <= tosp_gap_factor * next_gap)) {
1059          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1060            if (tosp_flip_fuzz_sp_to_kn) {
1061              fuzzy_non = true;
1062            } else {
1063              fuzzy_sp = true;
1064            }
1065          } else {
1066            space = false;
1067          }
1068  #ifndef GRAPHICS_DISABLED
1069          mark_gap(blob_box, 3, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1070                   next_gap);
1071  #endif
1072        } else if ((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box) &&
1073                   (next_gap <= row->space_threshold) &&
1074                   (current_gap * tosp_gap_factor <= next_gap)) {
1075          if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit)) {
1076            if (tosp_flip_fuzz_sp_to_kn) {
1077              fuzzy_non = true;
1078            } else {
1079              fuzzy_sp = true;
1080            }
1081          } else {
1082            space = false;
1083          }
1084  #ifndef GRAPHICS_DISABLED
1085          mark_gap(blob_box, 4, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1086                   next_gap);
1087  #endif
1088        } else if ((((next_blob_box.width() > 0) && narrow_blob(row, next_blob_box)) ||
1089                    ((prev_blob_box.width() > 0) && narrow_blob(row, prev_blob_box)))) {
1090          fuzzy_sp = true;
1091  #ifndef GRAPHICS_DISABLED
1092          mark_gap(blob_box, 6, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1093                   next_gap);
1094  #endif
1095        }
1096      } else if ((current_gap > row->max_nonspace) && (current_gap <= row->space_threshold)) {
1097        if ((prev_blob_box.width() > 0) && (next_blob_box.width() > 0) &&
1098            (current_gap >= tosp_kern_gap_factor1 * std::max(prev_gap, next_gap)) &&
1099            wide_blob(row, prev_blob_box) && wide_blob(row, next_blob_box)) {
1100          space = true;
1101          if ((tosp_flip_fuzz_kn_to_sp) &&
1102              ((tosp_flip_caution <= 0) || (tosp_flip_caution * row->kern_size > row->space_size))) {
1103            fuzzy_sp = true;
1104          } else {
1105            fuzzy_non = true;
1106          }
1107  #ifndef GRAPHICS_DISABLED
1108          mark_gap(blob_box, 7, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1109                   next_gap);
1110  #endif
1111        } else if (prev_blob_box.width() > 0 && next_blob_box.width() > 0 &&
1112                   current_gap > 5 && 
1113                   current_gap >= tosp_kern_gap_factor2 * std::max(prev_gap, next_gap) &&
1114                   !(narrow_blob(row, prev_blob_box) || suspected_punct_blob(row, prev_blob_box)) &&
1115                   !(narrow_blob(row, next_blob_box) || suspected_punct_blob(row, next_blob_box))) {
1116          space = true;
1117          fuzzy_non = true;
1118  #ifndef GRAPHICS_DISABLED
1119          mark_gap(blob_box, 8, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1120                   next_gap);
1121  #endif
1122        } else if ((tosp_kern_gap_factor3 > 0) && (prev_blob_box.width() > 0) &&
1123                   (next_blob_box.width() > 0) &&
1124                   (current_gap >= tosp_kern_gap_factor3 * std::max(prev_gap, next_gap)) &&
1125                   (!tosp_rule_9_test_punct || (!suspected_punct_blob(row, prev_blob_box) &&
1126                                                !suspected_punct_blob(row, next_blob_box)))) {
1127          space = true;
1128          fuzzy_non = true;
1129  #ifndef GRAPHICS_DISABLED
1130          mark_gap(blob_box, 9, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(),
1131                   next_gap);
1132  #endif
1133        }
1134      }
1135      if (tosp_debug_level > 10) {
1136        tprintf(
1137            "word break = %d current_gap = %d, prev_gap = %d, "
1138            "next_gap = %d\n",
1139            space ? 1 : 0, current_gap, prev_gap, next_gap);
1140      }
1141      prev_gap_was_a_space = space && !(fuzzy_non);
1142      return space;
1143    }
1144  }
1145  bool Textord::narrow_blob(TO_ROW *row, TBOX blob_box) {
1146    bool result;
1147    result =
1148        ((blob_box.width() <= tosp_narrow_fraction * row->xheight) ||
1149         ((static_cast<float>(blob_box.width()) / blob_box.height()) <= tosp_narrow_aspect_ratio));
1150    return result;
1151  }
1152  bool Textord::wide_blob(TO_ROW *row, TBOX blob_box) {
1153    bool result;
1154    if (tosp_wide_fraction > 0) {
1155      if (tosp_wide_aspect_ratio > 0) {
1156        result =
1157            ((blob_box.width() >= tosp_wide_fraction * row->xheight) &&
1158             ((static_cast<float>(blob_box.width()) / blob_box.height()) > tosp_wide_aspect_ratio));
1159      } else {
1160        result = (blob_box.width() >= tosp_wide_fraction * row->xheight);
1161      }
1162    } else {
1163      result = !narrow_blob(row, blob_box);
1164    }
1165    return result;
1166  }
1167  bool Textord::suspected_punct_blob(TO_ROW *row, TBOX box) {
1168    bool result;
1169    float baseline;
1170    float blob_x_centre;
1171    blob_x_centre = (box.right() + box.left()) / 2.0;
1172    baseline = row->baseline.y(blob_x_centre);
1173    result = (box.height() <= 0.66 * row->xheight) || (box.top() < baseline + row->xheight / 2.0) ||
1174             (box.bottom() > baseline + row->xheight / 2.0);
1175    return result;
1176  }
1177  void Textord::peek_at_next_gap(TO_ROW *row, BLOBNBOX_IT box_it, TBOX &next_blob_box,
1178                                 int16_t &next_gap, int16_t &next_within_xht_gap) {
1179    TBOX next_reduced_blob_box;
1180    TBOX bit_beyond;
1181    BLOBNBOX_IT reduced_box_it = box_it;
1182    next_blob_box = box_next(&box_it);
1183    next_reduced_blob_box = reduced_box_next(row, &reduced_box_it);
1184    if (box_it.at_first()) {
1185      next_gap = INT16_MAX;
1186      next_within_xht_gap = INT16_MAX;
1187    } else {
1188      bit_beyond = box_it.data()->bounding_box();
1189      next_gap = bit_beyond.left() - next_blob_box.right();
1190      bit_beyond = reduced_box_next(row, &reduced_box_it);
1191      next_within_xht_gap = bit_beyond.left() - next_reduced_blob_box.right();
1192    }
1193  }
1194  #ifndef GRAPHICS_DISABLED
1195  void Textord::mark_gap(TBOX blob,    
1196                         int16_t rule, 
1197                         int16_t prev_gap, int16_t prev_blob_width, int16_t current_gap,
1198                         int16_t next_blob_width, int16_t next_gap) {
1199    ScrollView::Color col; 
1200    switch (rule) {
1201      case 1:
1202        col = ScrollView::RED;
1203        break;
1204      case 2:
1205        col = ScrollView::CYAN;
1206        break;
1207      case 3:
1208        col = ScrollView::GREEN;
1209        break;
1210      case 4:
1211        col = ScrollView::BLACK;
1212        break;
1213      case 5:
1214        col = ScrollView::MAGENTA;
1215        break;
1216      case 6:
1217        col = ScrollView::BLUE;
1218        break;
1219      case 7:
1220        col = ScrollView::WHITE;
1221        break;
1222      case 8:
1223        col = ScrollView::YELLOW;
1224        break;
1225      case 9:
1226        col = ScrollView::BLACK;
1227        break;
1228      case 20:
1229        col = ScrollView::CYAN;
1230        break;
1231      case 21:
1232        col = ScrollView::GREEN;
1233        break;
1234      case 22:
1235        col = ScrollView::MAGENTA;
1236        break;
1237      default:
1238        col = ScrollView::BLACK;
1239    }
1240    if (textord_show_initial_words) {
1241      to_win->Pen(col);
1242      to_win->Ellipse(current_gap / 2.0f,
1243                      blob.height() / 2.0f, 
1244                      blob.left() - current_gap / 2.0f,
1245                      blob.bottom() + blob.height() / 2.0f);
1246    }
1247    if (tosp_debug_level > 5) {
1248      tprintf("  (%d,%d) Sp<->Kn Rule %d %d %d %d %d %d\n", blob.left() - current_gap / 2,
1249              blob.bottom(), rule, prev_gap, prev_blob_width, current_gap, next_blob_width, next_gap);
1250    }
1251  }
1252  #endif
1253  float Textord::find_mean_blob_spacing(WERD *word) {
1254    C_BLOB_IT cblob_it;
1255    TBOX blob_box;
1256    int32_t gap_sum = 0;
1257    int16_t gap_count = 0;
1258    int16_t prev_right;
1259    cblob_it.set_to_list(word->cblob_list());
1260    if (!cblob_it.empty()) {
1261      cblob_it.mark_cycle_pt();
1262      prev_right = cblob_it.data()->bounding_box().right();
1263      cblob_it.forward();
1264      for (; !cblob_it.cycled_list(); cblob_it.forward()) {
1265        blob_box = cblob_it.data()->bounding_box();
1266        gap_sum += blob_box.left() - prev_right;
1267        gap_count++;
1268        prev_right = blob_box.right();
1269      }
1270    }
1271    if (gap_count > 0) {
1272      return (gap_sum / static_cast<float>(gap_count));
1273    } else {
1274      return 0.0f;
1275    }
1276  }
1277  bool Textord::ignore_big_gap(TO_ROW *row, int32_t row_length, GAPMAP *gapmap, int16_t left,
1278                               int16_t right) {
1279    int16_t gap = right - left + 1;
1280    if (tosp_ignore_big_gaps > 999) {
1281      return false; 
1282    }
1283    if (tosp_ignore_big_gaps > 0) {
1284      return (gap > tosp_ignore_big_gaps * row->xheight);
1285    }
1286    if (gap > tosp_ignore_very_big_gaps * row->xheight) {
1287      return true;
1288    }
1289    if (tosp_ignore_big_gaps == 0) {
1290      if ((gap > 2.1 * row->xheight) && (row_length > 20 * row->xheight)) {
1291        return true;
1292      }
1293      if ((gap > 1.75 * row->xheight) &&
1294          ((row_length > 35 * row->xheight) || gapmap->table_gap(left, right))) {
1295        return true;
1296      }
1297    } else {
1298      if ((gap > gapmap_big_gaps * row->xheight) && gapmap->table_gap(left, right)) {
1299        return true;
1300      }
1301    }
1302    return false;
1303  }
1304  TBOX Textord::reduced_box_next(TO_ROW *row,    
1305                                 BLOBNBOX_IT *it 
1306  ) {
1307    BLOBNBOX *blob;             
1308    BLOBNBOX *head_blob;        
1309    TBOX full_box;              
1310    TBOX reduced_box;           
1311    int16_t left_above_xht;     
1312    int16_t new_left_above_xht; 
1313    blob = it->data();
1314    if (blob->red_box_set()) {
1315      reduced_box = blob->reduced_box();
1316      do {
1317        it->forward();
1318        blob = it->data();
1319      } while (blob->cblob() == nullptr || blob->joined_to_prev());
1320      return reduced_box;
1321    }
1322    head_blob = blob;
1323    full_box = blob->bounding_box();
1324    reduced_box = reduced_box_for_blob(blob, row, &left_above_xht);
1325    do {
1326      it->forward();
1327      blob = it->data();
1328      if (blob->cblob() == nullptr) {
1329        full_box += blob->bounding_box();
1330      } else if (blob->joined_to_prev()) {
1331        reduced_box += reduced_box_for_blob(blob, row, &new_left_above_xht);
1332        left_above_xht = std::min(left_above_xht, new_left_above_xht);
1333      }
1334    }
1335    while (blob->cblob() == nullptr || blob->joined_to_prev());
1336    if ((reduced_box.width() > 0) &&
1337        ((reduced_box.left() + tosp_near_lh_edge * reduced_box.width()) < left_above_xht) &&
1338        (reduced_box.height() > 0.7 * row->xheight)) {
1339  #ifndef GRAPHICS_DISABLED
1340      if (textord_show_initial_words) {
1341        reduced_box.plot(to_win, ScrollView::YELLOW, ScrollView::YELLOW);
1342      }
1343  #endif
1344    } else {
1345      reduced_box = full_box;
1346    }
1347    head_blob->set_reduced_box(reduced_box);
1348    return reduced_box;
1349  }
1350  TBOX Textord::reduced_box_for_blob(BLOBNBOX *blob, TO_ROW *row, int16_t *left_above_xht) {
1351    float baseline;
1352    float blob_x_centre;
1353    float left_limit;
1354    float right_limit;
1355    float junk;
1356    TBOX blob_box;
1357    blob_box = blob->bounding_box();
1358    blob_x_centre = (blob_box.left() + blob_box.right()) / 2.0;
1359    baseline = row->baseline.y(blob_x_centre);
1360    left_limit = static_cast<float>(INT32_MAX);
1361    junk = static_cast<float>(-INT32_MAX);
1362    find_cblob_hlimits(blob->cblob(), (baseline + 1.1 * row->xheight), static_cast<float>(INT16_MAX),
1363                       left_limit, junk);
1364    if (left_limit > junk) {
1365      *left_above_xht = INT16_MAX; 
1366    } else {
1367      *left_above_xht = static_cast<int16_t>(std::floor(left_limit));
1368    }
1369    left_limit = static_cast<float>(INT32_MAX);
1370    junk = static_cast<float>(-INT32_MAX);
1371    find_cblob_hlimits(blob->cblob(), baseline, static_cast<float>(INT16_MAX), left_limit, junk);
1372    if (left_limit > junk) {
1373      return TBOX(); 
1374    }
1375    junk = static_cast<float>(INT32_MAX);
1376    right_limit = static_cast<float>(-INT32_MAX);
1377    find_cblob_hlimits(blob->cblob(), static_cast<float>(-INT16_MAX), (baseline + row->xheight), junk,
1378                       right_limit);
1379    if (junk > right_limit) {
1380      return TBOX(); 
1381    }
1382    return TBOX(ICOORD(static_cast<int16_t>(std::floor(left_limit)), blob_box.bottom()),
1383                ICOORD(static_cast<int16_t>(std::ceil(right_limit)), blob_box.top()));
1384  }
1385  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashgenericmp.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tospace.cpp</div>
                </div>
                <div class="column column_space"><pre><code>17    static const unsigned int HashPrimeT[HashPrimes];
18  public:
19    typedef THashKeyDatI<TKey, TDat> TIter;
20  private:
21    typedef THashKeyDat<TKey, TDat> THKeyDat;
22    typedef TPair<TKey, TDat> TKeyDatP;
23    TIntV PortV;
24    TIntV PortLockV;
25    TVec<THKeyDat> KeyDatV;
26    TBool AutoSizeP;
</pre></code></div>
                <div class="column column_space"><pre><code>926  bool Textord::make_a_word_break(TO_ROW *row,   
927                                  TBOX blob_box, 
928                                  int16_t prev_gap, TBOX prev_blob_box, int16_t real_current_gap,
929                                  int16_t within_xht_current_gap, TBOX next_blob_box,
930                                  int16_t next_gap, uint8_t &blanks, bool &fuzzy_sp, bool &fuzzy_non,
931                                  bool &prev_gap_was_a_space, bool &break_at_next_gap) {
932    bool space;
933    int16_t current_gap;
934    float fuzzy_sp_to_kn_limit;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    