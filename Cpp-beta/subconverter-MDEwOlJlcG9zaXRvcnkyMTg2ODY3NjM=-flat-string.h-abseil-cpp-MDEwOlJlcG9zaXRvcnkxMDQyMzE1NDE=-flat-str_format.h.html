
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.456264775413711%, Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.h</h3>
            <pre><code>1  #ifndef STRING_H_INCLUDED
2  #define STRING_H_INCLUDED
3  #include <numeric>
4  #include <string>
5  #include <sstream>
6  #include <vector>
7  #include <map>
8  using string_size = std::string::size_type;
9  using string_array = std::vector<std::string>;
10  using string_map = std::map<std::string, std::string>;
11  using string_pair_array = std::vector<std::pair<std::string, std::string>>;
12  std::vector<std::string> split(const std::string &s, const std::string &seperator);
13  std::string join(const string_array &arr, const std::string &delimiter);
14  template <typename InputIt>
15  std::string join(InputIt first, InputIt last, const std::string &delimiter)
16  {
17      if(first == last)
18          return "";
19      if(std::next(first) == last)
20          return *first;
21      return std::accumulate(std::next(first), last, *first, [&](const std::string &a, const std::string &b) {return a + delimiter + b; });
22  }
<span onclick='openModal()' class='match'>23  std::string getUrlArg(const std::string &url, const std::string &request);
24  std::string replaceAllDistinct(std::string str, const std::string &old_value, const std::string &new_value);
25  std::string trimOf(const std::string& str, char target, bool before = true, bool after = true);
26  std::string trim(const std::string& str, bool before = true, bool after = true);
27  std::string trimQuote(const std::string &str, bool before = true, bool after = true);
28  void trimSelfOf(std::string &str, char target, bool before = true, bool after = true);
29  std::string trimWhitespace(const std::string &str, bool before = false, bool after = true);
</span>30  std::string randomStr(const int len);
31  bool isStrUTF8(const std::string &data);
32  void removeUTF8BOM(std::string &data);
33  std::string UTF8ToCodePoint(const std::string &data);
34  std::string toLower(const std::string &str);
35  std::string toUpper(const std::string &str);
36  void processEscapeChar(std::string &str);
37  void processEscapeCharReverse(std::string &str);
38  int parseCommaKeyValue(const std::string &input, const std::string &separator, string_pair_array &result);
39  inline bool strFind(const std::string &str, const std::string &target)
40  {
41      return str.find(target) != str.npos;
42  }
43  inline bool startsWith(const std::string &hay, const std::string &needle)
44  {
45      return hay.substr(0, needle.length()) == needle;
46  }
47  inline bool endsWith(const std::string &hay, const std::string &needle)
48  {
49      std::string::size_type hl = hay.length(), nl = needle.length();
50      return hl >= nl && hay.substr(hl - nl, nl) == needle;
51  }
52  inline bool count_least(const std::string &hay, const char needle, size_t cnt)
53  {
54      string_size pos = hay.find(needle);
55      while(pos != hay.npos)
56      {
57          cnt--;
58          if(!cnt)
59              return true;
60          pos = hay.find(needle, pos + 1);
61      }
62      return false;
63  }
64  inline char getLineBreak(const std::string &str)
65  {
66      return count_least(str, '\n', 1) ? '\n' : '\r';
67  }
68  template <typename T, typename U> static inline T to_number(const U &value, T def_value = T())
69  {
70      T retval = 0.0;
71      char c;
72      std::stringstream ss;
73      ss << value;
74      if(!(ss >> retval))
75          return def_value;
76      else if(ss >> c)
77          return def_value;
78      else
79          return retval;
80  }
81  int to_int(const std::string &str, int def_value = 0);
82  #ifndef HAVE_TO_STRING
83  namespace std
84  {
85  template <typename T> std::string to_string(const T& n)
86  {
87      std::ostringstream ss;
88      ss << n;
89      return ss.str();
90  }
91  }
92  #endif 
93  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_STR_FORMAT_H_
2  #define ABSL_STRINGS_STR_FORMAT_H_
3  #include <cstdio>
4  #include <string>
5  #include "absl/strings/internal/str_format/arg.h"  
6  #include "absl/strings/internal/str_format/bind.h"  
7  #include "absl/strings/internal/str_format/checker.h"  
8  #include "absl/strings/internal/str_format/extension.h"  
9  #include "absl/strings/internal/str_format/parser.h"  
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  class UntypedFormatSpec {
13   public:
14    UntypedFormatSpec() = delete;
15    UntypedFormatSpec(const UntypedFormatSpec&) = delete;
16    UntypedFormatSpec& operator=(const UntypedFormatSpec&) = delete;
17    explicit UntypedFormatSpec(string_view s) : spec_(s) {}
18   protected:
19    explicit UntypedFormatSpec(const str_format_internal::ParsedFormatBase* pc)
20        : spec_(pc) {}
21   private:
22    friend str_format_internal::UntypedFormatSpecImpl;
23    str_format_internal::UntypedFormatSpecImpl spec_;
24  };
25  template <typename T>
26  str_format_internal::StreamedWrapper<T> FormatStreamed(const T& v) {
27    return str_format_internal::StreamedWrapper<T>(v);
28  }
29  class FormatCountCapture {
30   public:
31    explicit FormatCountCapture(int* p) : p_(p) {}
32   private:
33    friend struct str_format_internal::FormatCountCaptureHelper;
34    int* Unused() { return p_; }
35    int* p_;
36  };
37  template <typename... Args>
38  using FormatSpec = str_format_internal::FormatSpecTemplate<
39      str_format_internal::ArgumentToConv<Args>()...>;
40  #if defined(__cpp_nontype_template_parameter_auto)
41  template <auto... Conv>
42  using ParsedFormat = absl::str_format_internal::ExtendedParsedFormat<
43      absl::str_format_internal::ToFormatConversionCharSet(Conv)...>;
44  #else
45  template <char... Conv>
46  using ParsedFormat = str_format_internal::ExtendedParsedFormat<
47      absl::str_format_internal::ToFormatConversionCharSet(Conv)...>;
48  #endif  
49  template <typename... Args>
50  ABSL_MUST_USE_RESULT std::string StrFormat(const FormatSpec<Args...>& format,
51                                             const Args&... args) {
52    return str_format_internal::FormatPack(
53        str_format_internal::UntypedFormatSpecImpl::Extract(format),
54        {str_format_internal::FormatArgImpl(args)...});
55  }
56  template <typename... Args>
57  std::string& StrAppendFormat(std::string* dst,
58                               const FormatSpec<Args...>& format,
59                               const Args&... args) {
60    return str_format_internal::AppendPack(
61        dst, str_format_internal::UntypedFormatSpecImpl::Extract(format),
62        {str_format_internal::FormatArgImpl(args)...});
63  }
64  template <typename... Args>
65  ABSL_MUST_USE_RESULT str_format_internal::Streamable StreamFormat(
66      const FormatSpec<Args...>& format, const Args&... args) {
67    return str_format_internal::Streamable(
68        str_format_internal::UntypedFormatSpecImpl::Extract(format),
69        {str_format_internal::FormatArgImpl(args)...});
70  }
71  template <typename... Args>
72  int PrintF(const FormatSpec<Args...>& format, const Args&... args) {
73    return str_format_internal::FprintF(
74        stdout, str_format_internal::UntypedFormatSpecImpl::Extract(format),
75        {str_format_internal::FormatArgImpl(args)...});
76  }
77  template <typename... Args>
78  int FPrintF(std::FILE* output, const FormatSpec<Args...>& format,
79              const Args&... args) {
80    return str_format_internal::FprintF(
81        output, str_format_internal::UntypedFormatSpecImpl::Extract(format),
82        {str_format_internal::FormatArgImpl(args)...});
83  }
84  template <typename... Args>
85  int SNPrintF(char* output, std::size_t size, const FormatSpec<Args...>& format,
86               const Args&... args) {
87    return str_format_internal::SnprintF(
88        output, size, str_format_internal::UntypedFormatSpecImpl::Extract(format),
89        {str_format_internal::FormatArgImpl(args)...});
90  }
91  class FormatRawSink {
92   public:
93    template <typename T,
94              typename = typename std::enable_if<std::is_constructible<
95                  str_format_internal::FormatRawSinkImpl, T*>::value>::type>
96    FormatRawSink(T* raw)  
97        : sink_(raw) {}
98   private:
99    friend str_format_internal::FormatRawSinkImpl;
100    str_format_internal::FormatRawSinkImpl sink_;
101  };
102  template <typename... Args>
103  bool Format(FormatRawSink raw_sink, const FormatSpec<Args...>& format,
104              const Args&... args) {
105    return str_format_internal::FormatUntyped(
106        str_format_internal::FormatRawSinkImpl::Extract(raw_sink),
107        str_format_internal::UntypedFormatSpecImpl::Extract(format),
108        {str_format_internal::FormatArgImpl(args)...});
109  }
110  using FormatArg = str_format_internal::FormatArgImpl;
111  ABSL_MUST_USE_RESULT inline bool FormatUntyped(
112      FormatRawSink raw_sink, const UntypedFormatSpec& format,
113      absl::Span<const FormatArg> args) {
114    return str_format_internal::FormatUntyped(
115        str_format_internal::FormatRawSinkImpl::Extract(raw_sink),
116        str_format_internal::UntypedFormatSpecImpl::Extract(format), args);
117  }
<span onclick='openModal()' class='match'>118  enum class FormatConversionChar : uint8_t {
119    c, s,                    
120    d, i, o, u, x, X,        
121    f, F, e, E, g, G, a, A,  
122    n, p, v                  
</span>123  };
124  class FormatConversionSpec {
125   public:
126    bool is_basic() const { return impl_.is_basic(); }
127    bool has_left_flag() const { return impl_.has_left_flag(); }
128    bool has_show_pos_flag() const { return impl_.has_show_pos_flag(); }
129    bool has_sign_col_flag() const { return impl_.has_sign_col_flag(); }
130    bool has_alt_flag() const { return impl_.has_alt_flag(); }
131    bool has_zero_flag() const { return impl_.has_zero_flag(); }
132    FormatConversionChar conversion_char() const {
133      return impl_.conversion_char();
134    }
135    int width() const { return impl_.width(); }
136    int precision() const { return impl_.precision(); }
137   private:
138    explicit FormatConversionSpec(
139        str_format_internal::FormatConversionSpecImpl impl)
140        : impl_(impl) {}
141    friend str_format_internal::FormatConversionSpecImpl;
142    absl::str_format_internal::FormatConversionSpecImpl impl_;
143  };
144  constexpr FormatConversionCharSet operator|(FormatConversionCharSet a,
145                                              FormatConversionCharSet b) {
146    return static_cast<FormatConversionCharSet>(static_cast<uint64_t>(a) |
147                                                static_cast<uint64_t>(b));
148  }
149  enum class FormatConversionCharSet : uint64_t {
150    c = str_format_internal::FormatConversionCharToConvInt('c'),
151    s = str_format_internal::FormatConversionCharToConvInt('s'),
152    d = str_format_internal::FormatConversionCharToConvInt('d'),
153    i = str_format_internal::FormatConversionCharToConvInt('i'),
154    o = str_format_internal::FormatConversionCharToConvInt('o'),
155    u = str_format_internal::FormatConversionCharToConvInt('u'),
156    x = str_format_internal::FormatConversionCharToConvInt('x'),
157    X = str_format_internal::FormatConversionCharToConvInt('X'),
158    f = str_format_internal::FormatConversionCharToConvInt('f'),
159    F = str_format_internal::FormatConversionCharToConvInt('F'),
160    e = str_format_internal::FormatConversionCharToConvInt('e'),
161    E = str_format_internal::FormatConversionCharToConvInt('E'),
162    g = str_format_internal::FormatConversionCharToConvInt('g'),
163    G = str_format_internal::FormatConversionCharToConvInt('G'),
164    a = str_format_internal::FormatConversionCharToConvInt('a'),
165    A = str_format_internal::FormatConversionCharToConvInt('A'),
166    n = str_format_internal::FormatConversionCharToConvInt('n'),
167    p = str_format_internal::FormatConversionCharToConvInt('p'),
168    v = str_format_internal::FormatConversionCharToConvInt('v'),
169    kStar = static_cast<uint64_t>(
170        absl::str_format_internal::FormatConversionCharSetInternal::kStar),
171    kIntegral = d | i | u | o | x | X,
172    kFloating = a | e | f | g | A | E | F | G,
173    kNumeric = kIntegral | kFloating,
174    kString = s,
175    kPointer = p,
176  };
177  class FormatSink {
178   public:
179    void Append(size_t count, char ch) { sink_->Append(count, ch); }
180    void Append(string_view v) { sink_->Append(v); }
181    bool PutPaddedString(string_view v, int width, int precision, bool left) {
182      return sink_->PutPaddedString(v, width, precision, left);
183    }
184    friend void AbslFormatFlush(FormatSink* sink, absl::string_view v) {
185      sink->Append(v);
186    }
187   private:
188    friend str_format_internal::FormatSinkImpl;
189    explicit FormatSink(str_format_internal::FormatSinkImpl* s) : sink_(s) {}
190    str_format_internal::FormatSinkImpl* sink_;
191  };
192  template <FormatConversionCharSet C>
193  struct FormatConvertResult {
194    bool value;
195  };
196  ABSL_NAMESPACE_END
197  }  
198  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format.h</div>
                </div>
                <div class="column column_space"><pre><code>23  std::string getUrlArg(const std::string &url, const std::string &request);
24  std::string replaceAllDistinct(std::string str, const std::string &old_value, const std::string &new_value);
25  std::string trimOf(const std::string& str, char target, bool before = true, bool after = true);
26  std::string trim(const std::string& str, bool before = true, bool after = true);
27  std::string trimQuote(const std::string &str, bool before = true, bool after = true);
28  void trimSelfOf(std::string &str, char target, bool before = true, bool after = true);
29  std::string trimWhitespace(const std::string &str, bool before = false, bool after = true);
</pre></code></div>
                <div class="column column_space"><pre><code>118  enum class FormatConversionChar : uint8_t {
119    c, s,                    
120    d, i, o, u, x, X,        
121    f, F, e, E, g, G, a, A,  
122    n, p, v                  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    