
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.95800933125972%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ff.cpp</h3>
            <pre><code>1  void TForestFire::InfectAll() {
2    InfectNIdV.Gen(Graph->GetNodes());
3    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
4      InfectNIdV.Add(NI.GetId()); }
5  }
6  void TForestFire::InfectRnd(const int& NInfect) {
7    IAssert(NInfect < Graph->GetNodes());
8    TIntV NIdV(Graph->GetNodes(), 0);
9    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
10      NIdV.Add(NI.GetId()); }
11    NIdV.Shuffle(Rnd);
12    InfectNIdV.Gen(NInfect, 0);
13    for (int i = 0; i < NInfect; i++) {
14      InfectNIdV.Add(NIdV[i]); }
15  }
16  void TForestFire::BurnExpFire() {
17    const double OldFwdBurnProb = FwdBurnProb;
18    const double OldBckBurnProb = BckBurnProb;
19    const int NInfect = InfectNIdV.Len();
20    const TNGraph& G = *Graph;
21    TIntH BurnedNIdH;               
22    TIntV BurningNIdV = InfectNIdV; 
23    TIntV NewBurnedNIdV;            
24    bool HasAliveNbrs;              
25    int NBurned = NInfect, NDiedFire=0;
26    for (int i = 0; i < InfectNIdV.Len(); i++) {
27      BurnedNIdH.AddDat(InfectNIdV[i]); }
28    NBurnedTmV.Clr(false);  NBurningTmV.Clr(false);  NewBurnedTmV.Clr(false);
29    for (int time = 0; ; time++) {
30      NewBurnedNIdV.Clr(false);
31      for (int node = 0; node < BurningNIdV.Len(); node++) {
32        const int& BurningNId = BurningNIdV[node];
33        const TNGraph::TNodeI Node = G.GetNI(BurningNId);
34        HasAliveNbrs = false;
35        NDiedFire = 0;
36        for (int e = 0; e < Node.GetOutDeg(); e++) {
37          const int OutNId = Node.GetOutNId(e);
38          if (! BurnedNIdH.IsKey(OutNId)) { 
39            HasAliveNbrs = true;
40            if (Rnd.GetUniDev() < FwdBurnProb) {
41              BurnedNIdH.AddDat(OutNId);  NewBurnedNIdV.Add(OutNId);  NBurned++; }
42          }
43        }
44        if (BckBurnProb > 0.0) {
45          for (int e = 0; e < Node.GetInDeg(); e++) {
46            const int InNId = Node.GetInNId(e);
47            if (! BurnedNIdH.IsKey(InNId)) { 
48              HasAliveNbrs = true;
49              if (Rnd.GetUniDev() < BckBurnProb) {
50                BurnedNIdH.AddDat(InNId);  NewBurnedNIdV.Add(InNId);  NBurned++; }
51            }
52          }
53        }
54        if (! HasAliveNbrs) { NDiedFire++; }
55      }
56      NBurnedTmV.Add(NBurned);
57      NBurningTmV.Add(BurningNIdV.Len() - NDiedFire);
58      NewBurnedTmV.Add(NewBurnedNIdV.Len());
59      BurningNIdV.Swap(NewBurnedNIdV);    
60      if (BurningNIdV.Empty()) break;
61      FwdBurnProb = FwdBurnProb * ProbDecay;
62      BckBurnProb = BckBurnProb * ProbDecay;
63    }
64    BurnedNIdV.Gen(BurnedNIdH.Len(), 0);
65    for (int i = 0; i < BurnedNIdH.Len(); i++) {
66      BurnedNIdV.Add(BurnedNIdH.GetKey(i)); }
67    FwdBurnProb = OldFwdBurnProb;
68    BckBurnProb = OldBckBurnProb;
69  }
70  void TForestFire::BurnGeoFire() {
71    const double OldFwdBurnProb=FwdBurnProb;
72    const double OldBckBurnProb=BckBurnProb;
73    const int& NInfect = InfectNIdV.Len();
74    const TNGraph& G = *Graph;
75    TIntH BurnedNIdH;               
76    TIntV BurningNIdV = InfectNIdV; 
77    TIntV NewBurnedNIdV;            
78    bool HasAliveInNbrs, HasAliveOutNbrs; 
79    TIntV AliveNIdV;                
80    int NBurned = NInfect, time;
81    for (int i = 0; i < InfectNIdV.Len(); i++) {
82      BurnedNIdH.AddDat(InfectNIdV[i]); }
83    NBurnedTmV.Clr(false);  NBurningTmV.Clr(false);  NewBurnedTmV.Clr(false);
84    for (time = 0; ; time++) {
85      NewBurnedNIdV.Clr(false);
86      for (int node = 0; node < BurningNIdV.Len(); node++) {
87        const int& BurningNId = BurningNIdV[node];
88        const TNGraph::TNodeI Node = G.GetNI(BurningNId);
89        HasAliveOutNbrs = false;
90        AliveNIdV.Clr(false); 
91        for (int e = 0; e < Node.GetOutDeg(); e++) {
92          const int OutNId = Node.GetOutNId(e);
93          if (! BurnedNIdH.IsKey(OutNId)) {
94            HasAliveOutNbrs = true;  AliveNIdV.Add(OutNId); }
95        }
96        const int BurnNFwdLinks = Rnd.GetGeoDev(1.0-FwdBurnProb) - 1;
97        if (HasAliveOutNbrs && BurnNFwdLinks > 0) {
<span onclick='openModal()' class='match'>98          AliveNIdV.Shuffle(Rnd);
99          for (int i = 0; i < TMath::Mn(BurnNFwdLinks, AliveNIdV.Len()); i++) {
100            BurnedNIdH.AddDat(AliveNIdV[i]);
101            NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
</span>102        }
103        if (BckBurnProb > 0.0) {
104          HasAliveInNbrs = false;
105          AliveNIdV.Clr(false);
106          for (int e = 0; e < Node.GetInDeg(); e++) {
107            const int InNId = Node.GetInNId(e);
108            if (! BurnedNIdH.IsKey(InNId)) {
109              HasAliveInNbrs = true;  AliveNIdV.Add(InNId); }
110          }
111          const int BurnNBckLinks = Rnd.GetGeoDev(1.0-BckBurnProb) - 1;
112          if (HasAliveInNbrs && BurnNBckLinks > 0) {
113            AliveNIdV.Shuffle(Rnd);
114            for (int i = 0; i < TMath::Mn(BurnNBckLinks, AliveNIdV.Len()); i++) {
115              BurnedNIdH.AddDat(AliveNIdV[i]);
116              NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
117          }
118        }
119      }
120      NBurnedTmV.Add(NBurned);  NBurningTmV.Add(BurningNIdV.Len());  NewBurnedTmV.Add(NewBurnedNIdV.Len());
121      BurningNIdV.Swap(NewBurnedNIdV);   
122      if (BurningNIdV.Empty()) break;
123      FwdBurnProb = FwdBurnProb * ProbDecay;
124      BckBurnProb = BckBurnProb * ProbDecay;
125    }
126    BurnedNIdV.Gen(BurnedNIdH.Len(), 0);
127    for (int i = 0; i < BurnedNIdH.Len(); i++) {
128      BurnedNIdV.Add(BurnedNIdH.GetKey(i)); }
129    FwdBurnProb = OldFwdBurnProb;
130    BckBurnProb = OldBckBurnProb;
131  }
132  void TForestFire::PlotFire(const TStr& FNmPref, const TStr& Desc, const bool& PlotAllBurned) {
133    TGnuPlot GnuPlot(FNmPref, TStr::Fmt("%s. ForestFire. G(%d, %d). Fwd:%g  Bck:%g  NInfect:%d",
134      Desc.CStr(), Graph->GetNodes(), Graph->GetEdges(), FwdBurnProb(), BckBurnProb(), InfectNIdV.Len()));
135    GnuPlot.SetXYLabel("TIME EPOCH", "Number of NODES");
136    if (PlotAllBurned) GnuPlot.AddPlot(NBurnedTmV, gpwLinesPoints, "All burned nodes till time");
137    GnuPlot.AddPlot(NBurningTmV, gpwLinesPoints, "Burning nodes at time");
138    GnuPlot.AddPlot(NewBurnedTmV, gpwLinesPoints, "Newly burned nodes at time");
139    GnuPlot.SavePng(TFile::GetUniqueFNm(TStr::Fmt("fireSz.%s_#.png", FNmPref.CStr())));
140  }
141  PNGraph TForestFire::GenGraph(const int& Nodes, const double& FwdProb, const double& BckProb) {
142    TFfGGen Ff(false, 1, FwdProb, BckProb, 1.0, 0.0, 0.0);
143    Ff.GenGraph(Nodes);
144    return Ff.GetGraph();
145  }
146  int TFfGGen::TimeLimitSec = 30*60; 
147  TFfGGen::TFfGGen(const bool& BurnExpFireP, const int& StartNNodes, const double& ForwBurnProb,
148                   const double& BackBurnProb, const double& DecayProb, const double& Take2AmbasPrb, const double& OrphanPrb) :
149   Graph(), BurnExpFire(BurnExpFireP), StartNodes(StartNNodes), FwdBurnProb(ForwBurnProb),
150   BckBurnProb(BackBurnProb), ProbDecay(DecayProb), Take2AmbProb(Take2AmbasPrb), OrphanProb(OrphanPrb) {
151  }
152  TStr TFfGGen::GetParamStr() const {
153    return TStr::Fmt("%s  FWD:%g  BCK:%g, StartNds:%d, Take2:%g, Orphan:%g, ProbDecay:%g",
154      BurnExpFire?"EXP":"GEO", FwdBurnProb(), BckBurnProb(), StartNodes(), Take2AmbProb(), OrphanProb(), ProbDecay());
155  }
156  TFfGGen::TStopReason TFfGGen::AddNodes(const int& GraphNodes, const bool& FloodStop) {
157    printf("\n***ForestFire:  %s  Nodes:%d  StartNodes:%d  Take2AmbProb:%g\n", BurnExpFire?"ExpFire":"GeoFire", GraphNodes, StartNodes(), Take2AmbProb());
158    printf("                FwdBurnP:%g  BckBurnP:%g  ProbDecay:%g  Orphan:%g\n", FwdBurnProb(), BckBurnProb(), ProbDecay(), OrphanProb());
159    TExeTm ExeTm;
160    int Burned1=0, Burned2=0, Burned3=0; 
161    if (Graph.Empty()) { Graph = PNGraph::New(); }
162    if (Graph->GetNodes() == 0) {
163      for (int n = 0; n < StartNodes; n++) { Graph->AddNode(); }
164    }
165    int NEdges = Graph->GetEdges();
166    TRnd Rnd(0);
167    TForestFire ForestFire(Graph, FwdBurnProb, BckBurnProb, ProbDecay, 0);
168    for (int NNodes = Graph->GetNodes()+1; NNodes <= GraphNodes; NNodes++) {
169      const int NewNId = Graph->AddNode(-1);
170      IAssert(NewNId == Graph->GetNodes()-1); 
171      if (OrphanProb == 0.0 || Rnd.GetUniDev() > OrphanProb) {
172        if (Take2AmbProb == 0.0 || Rnd.GetUniDev() > Take2AmbProb || NewNId < 2) {
173          ForestFire.Infect(Rnd.GetUniDevInt(NewNId)); 
174        } else {
175          const int AmbassadorNId1 = Rnd.GetUniDevInt(NewNId);
176          int AmbassadorNId2 = Rnd.GetUniDevInt(NewNId);
177          while (AmbassadorNId1 == AmbassadorNId2) {
178            AmbassadorNId2 = Rnd.GetUniDevInt(NewNId); }
179          ForestFire.Infect(TIntV::GetV(AmbassadorNId1, AmbassadorNId2)); 
180        }
181        if (BurnExpFire) { ForestFire.BurnExpFire(); }
182        else { ForestFire.BurnGeoFire(); }
183        for (int e = 0; e < ForestFire.GetBurned(); e++) {
184          Graph->AddEdge(NewNId, ForestFire.GetBurnedNId(e));
185          NEdges++;
186        }
187        Burned1=Burned2;  Burned2=Burned3;  Burned3=ForestFire.GetBurned();
188      } else {
189        Burned1=Burned2;  Burned2=Burned3;  Burned3=0;
190      }
191      if (NNodes % Kilo(1) == 0) {
192        printf("(%d, %d)  burned: [%d,%d,%d]  [%s]\n", NNodes, NEdges, Burned1, Burned2, Burned3, ExeTm.GetStr()); }
193      if (FloodStop && NEdges>GraphNodes && (NEdges/double(NNodes)>1000.0)) { 
194        printf(". FLOOD. G(%6d, %6d)\n", NNodes, NEdges);  return srFlood; }
195      if (NNodes % 1000 == 0 && TimeLimitSec > 0 && ExeTm.GetSecs() > TimeLimitSec) {
196        printf(". TIME LIMIT. G(%d, %d)\n", Graph->GetNodes(), Graph->GetEdges());
197        return srTimeLimit; }
198    }
199    IAssert(Graph->GetEdges() == NEdges);
200    return srOk;
201  }
202  TFfGGen::TStopReason TFfGGen::GenGraph(const int& GraphNodes, const bool& FloodStop) {
203    Graph = PNGraph::New();
204    return AddNodes(GraphNodes, FloodStop);
205  }
206  TFfGGen::TStopReason TFfGGen::GenGraph(const int& GraphNodes, PGStatVec& EvolStat, const bool& FloodStop) {
207    int GrowthStatNodes = 100;
208    Graph = PNGraph::New();
209    AddNodes(StartNodes);
210    TStopReason SR = srUndef;
211    while (Graph->GetNodes() < GraphNodes) {
212      SR = AddNodes(GrowthStatNodes, FloodStop);
213      if (SR != srOk) { return SR; }
214      EvolStat->Add(Graph, TSecTm(Graph->GetNodes()));
215      GrowthStatNodes = int(1.5*GrowthStatNodes);
216    }
217    return SR;
218  }
219  void TFfGGen::PlotFireSize(const TStr& FNmPref, const TStr& DescStr) {
220    TGnuPlot GnuPlot("fs."+FNmPref, TStr::Fmt("%s. Fire size. G(%d, %d)",
221      DescStr.CStr(), Graph->GetNodes(), Graph->GetEdges()));
222    GnuPlot.SetXYLabel("Vertex id (iterations)", "Fire size (node out-degree)");
223    TFltPrV IdToOutDegV;
224    for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
225      IdToOutDegV.Add(TFltPr(NI.GetId(), NI.GetOutDeg())); }
226    IdToOutDegV.Sort();
227    GnuPlot.AddPlot(IdToOutDegV, gpwImpulses, "Node out-degree");
228    GnuPlot.SavePng();
229  }
230  void TFfGGen::GenFFGraphs(const double& FProb, const double& BProb, const TStr& FNm) {
231    const int NRuns = 10;
232    const int NNodes = 10000;
233    TGStat::NDiamRuns = 10;
234    TVec<PGStatVec> GAtTmV;
235    TFfGGen FF(false, 1, FProb, BProb, 1.0, 0, 0);
236    for (int r = 0; r < NRuns; r++) {
237      PGStatVec GV = TGStatVec::New(tmuNodes, TGStat::AllStat());
238      FF.GenGraph(NNodes, GV, true);
239      for (int i = 0; i < GV->Len(); i++) {
240        if (i == GAtTmV.Len()) {
241          GAtTmV.Add(TGStatVec::New(tmuNodes, TGStat::AllStat()));
242        }
243        GAtTmV[i]->Add(GV->At(i));
244      }
245      IAssert(GAtTmV.Len() == GV->Len());
246    }
247    PGStatVec AvgStat = TGStatVec::New(tmuNodes, TGStat::AllStat());
248    for (int i = 0; i < GAtTmV.Len(); i++) {
249      AvgStat->Add(GAtTmV[i]->GetAvgGStat(false));
250    }
251    AvgStat->PlotAllVsX(gsvNodes, FNm, TStr::Fmt("Forest Fire: F:%g  B:%g (%d runs)", FProb, BProb, NRuns));
252    AvgStat->Last()->PlotAll(FNm, TStr::Fmt("Forest Fire: F:%g  B:%g (%d runs)", FProb, BProb, NRuns));
253  }
254  &bsol;* ForestFire.GenGraph(NNodes, true);
255      if (! ForestFire.GetGrowthStat()->Empty()) {
256        GrowthSet->Add(ForestFire.GetGrowthStat()); }
257    }
258    IAssert(! GrowthSet.Empty());
259    FBPrGSetH.AddDat(TFltPr(FwdProb, BckProb), GrowthSet);
260    PGrowthStat AvgStat = TGrowthStat::New();
261    AvgStat->AvgGrowthStat(*GrowthSet);
262    FBPrGStatH.AddDat(TFltPr(FwdProb, BckProb), AvgStat);
263    const double DiamCf = LastDecDiam().Val1;
264    const double GplCf = LastGplCf().Val1;
265    if (Plot && ! AvgStat.Empty()) {
266      const TStr FNm = TStr::Fmt("F%04d.B%04d", int(FwdProb*10000), int(BckProb*10000));
267      const TStr Title = GetTitleStr(Len()-1);
268      AvgStat->PlotDiam(FNm, Title);
269      AvgStat->PlotGpl(FNm, Title, true, false, false, false, false);
270    }
271    return TFltPr(GplCf, DiamCf);
272  }
273  void TFfPhaseTrans::FwdProbSteps(const double& MinFwdProb, const double& MaxFwdProb, const double& BckProb) {
274    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFwd.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
275    TFfGGen::TimeLimitSec = 10*60;
276    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
277      RunForestFire(FwdProb, BckProb, true);
278      { TFOut FOut(BinFNm);
279      Save(FOut); }
280    }
281  }
282  void TFfPhaseTrans::FwdProbStepsFact(const double& MinFwdProb, const double& MaxFwdProb, const double& BckFact) {
283    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFwd.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
284    TFfGGen::TimeLimitSec = 10*60;
285    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
286      RunForestFire(FwdProb, BckFact*FwdProb, true);
287      { TFOut FOut(BinFNm);
288      Save(FOut); }
289    }
290  }
291  void TFfPhaseTrans::FwdBckPhasePlot(const double& MinFwdProb, const double& MaxFwdProb, const double& MinBckFact,
292                                      const double& MaxBckFact, const int& TimeLimitSec) {
293    const TStr BinFNm = TFile::GetUniqueFNm(TStr::Fmt("phaseFF.n%dk.s%d_#.bin", int(NNodes/1000.0), StartNodes()));
294    TFfGGen::TimeLimitSec = TimeLimitSec;
295    for (double FwdProb = MinFwdProb; FwdProb <= MaxFwdProb; FwdProb += ProbInc) {
296      for (double BckFact = MinBckFact; BckFact < MaxBckFact+0.001; BckFact += ProbInc) {
297        const double BckProb = FwdProb * BckFact;
298        RunForestFire(FwdProb, BckProb, true);
299        { TFOut FOut(BinFNm);
300        Save(FOut); }
301      }
302    }
303  }
304  void TFfPhaseTrans::FindGplPhaseTr(const double& StartFProb, const double& FollowGplCf, const TStr& FNmPref, const TStr& Desc) {
305    const TStr FNm = TStr::Fmt("phGPL.%s", GetFNm(FNmPref).CStr());
306    const double Tolerance = 0.01;
307    const double MinDelta = 0.001;
308    const bool Plot = false;
309    TFfGGen::TimeLimitSec = 10*60;
310    TGrowthStat::MinNodesEdges = 2*(StartNodes-1)+100;
311    const int OldNDiamRuns = TGraphStat::NDiamRuns;
312    TGraphStat::NDiamRuns = 1;  
313    TakeStat(TFSet() | gsEffDiam);
314    FILE *F = fopen((FNm+".txt").CStr(), "wt");
315    fprintf(F, "FollowGplCf:  %g\n", FollowGplCf);
316    fprintf(F, "StartNodes:   %d\n", StartNodes());
317    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
318    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
319    fprintf(F, "Tolerance:    %g\n", Tolerance);
320    double FwdProb = StartFProb, LBckRat=0, RBckRat=1, BckRat, GplCf;
321    while (FwdProb < 1.0) {
322      while (true) {
323        BckRat = (RBckRat+LBckRat) / 2;
324        fprintf(F, "FWD: %g, (%f -- %f)", FwdProb, LBckRat, RBckRat);
325        GplCf = RunForestFire(FwdProb, FwdProb*BckRat, Plot).Val1;
326        IAssert(GplCf != -1);
327        fprintf(F, "  %f  gpl: %.4f (%.4f)", BckRat, GplCf, LastGplCf().Val2());
328        if (TMath::IsInEps(GplCf - FollowGplCf, Tolerance)) { fprintf(F, "  ***\n"); break; }
329        if (RBckRat-LBckRat < MinDelta) { fprintf(F, "  gap\n"); break; }
330        if (GplCf > FollowGplCf) { RBckRat = BckRat; } else { LBckRat = BckRat; }
331        fprintf(F, "\n");  fflush(F);
332      }
333      FwdProb += ProbInc;
334      RBckRat = BckRat+0.01;
335      if (RBckRat > 1.0) RBckRat = 1.0;
336      LBckRat = RBckRat - 0.2;
337      if (LBckRat < 0.0) LBckRat = 0.0;
338      { TFOut FOut(FNm+".bin");
339       Save(FOut); }
340      SaveGplPhaseTr(FollowGplCf, FNmPref, Desc);
341      fprintf(F, "\n");
342    }
343    fclose(F);
344    TGraphStat::NDiamRuns = OldNDiamRuns;
345  }
346  void TFfPhaseTrans::SaveGplPhaseTr(const double& FollowGplCf, const TStr& FNmPref, const TStr& Desc) {
347    const double Tolerance = 0.02;
348    THash<TFlt,  TIntFltPr> FProbH;
349    for (int i = 0; i < Len(); i ++) {
350      const double FProb = GetFProb(i);
351      const double GplCf = GetGplCf(i).Val1;
352      if (TMath::IsInEps(GplCf-FollowGplCf, Tolerance)) {
353        if (! FProbH.IsKey(FProb)) {
354          FProbH.AddDat(FProb, TIntFltPr(i, GplCf)); }
355        else {
356          const double bestCf = FProbH.GetDat(FProb).Val2;
357          if (fabs(bestCf - FollowGplCf) > fabs(GplCf - FollowGplCf)) {
358            FProbH.AddDat(FProb, TIntFltPr(i, GplCf)); }
359        }
360      }
361    }
362    TVec<TPair<TFlt, TIntFltPr> > FProbV;
363    FProbH.GetKeyDatPrV(FProbV);  FProbV.Sort();
364    const bool HasDiam = TakeStatSet.In(gsEffDiam);
365    FILE *F = fopen(TStr::Fmt("phGPL.%s.tab", GetFNm(FNmPref).CStr()).CStr(), "wt");
366    if (! Desc.Empty()) fprintf(F, "%s\n", Desc.CStr());
367    fprintf(F, "FollowGplCf:  %g\n", FollowGplCf);
368    fprintf(F, "StartNodes:   %d\n", StartNodes());
369    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
370    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
371    fprintf(F, "Tolerance:    %g\n", Tolerance);
372    fprintf(F, "id\tFProb\tBProb\tBRatio\tGlp\tGlpDev");
373    if (HasDiam) {  fprintf(F, "\tDiamCf\tDiamDev\tEffDiam"); }
374    fprintf(F, "\n");
375    for (int i = 0; i < FProbH.Len(); i++) {
376      const int Id = FProbV[i].Val2.Val1;
377      const TFltPr Gpl = GetGplCf(Id);
378      fprintf(F, "%d\t%f\t%f\t%f\t", Id, GetFProb(Id), GetBProb(Id), GetBProb(Id)/GetFProb(Id));
379      fprintf(F, "%f\t%f", Gpl.Val1(), Gpl.Val2());
380      if (HasDiam) {
381        const TFltPr DiamCf = GetDecDiam(Id);
382        fprintf(F, "\t%f\t%f\t%f", DiamCf.Val1(), DiamCf.Val2(), GetEffDiam(Id, -1).Val1());
383      }
384      fprintf(F, "\n");
385    }
386    fclose(F);
387  }
388  void TFfPhaseTrans::FindDiamPhaseTr(const double& StartFProb, const double& FollowDiamCf, const TStr& FNmPref, const TStr& Desc) {
389    const TStr FNm = TStr::Fmt("phDIAM.%s", GetFNm(FNmPref).CStr());
390    const double Tolerance = 0.01;
391    const double MinDelta = 0.001;
392    const bool Plot = false;
393    TFfGGen::TimeLimitSec = 10*60;
394    const int OldNDiamRuns = TGraphStat::NDiamRuns;
395    TGraphStat::NDiamRuns = 1;
396    TGrowthStat::MinNodesEdges = 2*(StartNodes-1)+100;
397    TakeStat(TFSet() | gsEffDiam);
398    FILE *F = fopen((FNm+".txt").CStr(), "wt");
399    fprintf(F, "FollowDiamCf: %g\n", FollowDiamCf);
400    fprintf(F, "StartNodes:   %d\n", StartNodes());
401    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
402    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
403    fprintf(F, "Tolerance:    %g\n", Tolerance);
404    double FwdProb = StartFProb, LBckRat=0, RBckRat=1, BckRat, DiamCf;
405    while (FwdProb < 1.0) {
406      while (true) {
407        BckRat = (RBckRat+LBckRat) / 2;
408        fprintf(F, "FWD: %g, (%f -- %f)", FwdProb, LBckRat, RBckRat);
409        DiamCf = RunForestFire(FwdProb, FwdProb*BckRat, Plot).Val2;
410        IAssert(DiamCf != -1);
411        fprintf(F, "  %f  diam: %.4f (%.4f)", BckRat, DiamCf, LastDecDiam().Val2());
412        if (TMath::IsInEps(DiamCf - FollowDiamCf, Tolerance)) { fprintf(F, "  ***\n"); break; }
413        if (RBckRat-LBckRat < MinDelta) { fprintf(F, "  gap\n"); break; }
414        if (DiamCf < FollowDiamCf) { RBckRat = BckRat; } else { LBckRat = BckRat; }
415        fprintf(F, "\n");  fflush(F);
416      }
417      FwdProb += ProbInc;
418      RBckRat = BckRat+0.05;
419      if (RBckRat > 1.0) RBckRat = 1.0;
420      LBckRat = RBckRat - 0.15;
421      if (LBckRat < 0.0) LBckRat = 0.0;
422      { TFOut FOut(FNm+".bin");
423      Save(FOut); }
424      SaveDiamPhaseTr(FollowDiamCf, FNmPref, Desc);
425      fprintf(F, "\n");
426    }
427    fclose(F);
428    TGraphStat::NDiamRuns = OldNDiamRuns;
429  }
430  void TFfPhaseTrans::SaveDiamPhaseTr(const double& FollowDiamCf, const TStr& FNmPref, const TStr& Desc) {
431    const double Tolerance = 0.03;
432    THash<TFlt,  TIntFltPr> FProbH;
433    for (int i = 0; i < Len(); i ++) {
434      const double FProb = GetFProb(i);
435      const double DiamCf = GetDecDiam(i).Val1;
436      if (TMath::IsInEps(DiamCf - FollowDiamCf, Tolerance)) {
437        if (! FProbH.IsKey(FProb)) {
438          FProbH.AddDat(FProb, TIntFltPr(i, DiamCf)); }
439        else {
440          const double bestCf = FProbH.GetDat(FProb).Val2;
441          if (fabs(bestCf - FollowDiamCf) > fabs(DiamCf - FollowDiamCf)) {
442            FProbH.AddDat(FProb, TIntFltPr(i, DiamCf)); }
443        }
444      }
445    }
446    TVec<TPair<TFlt, TIntFltPr> > FProbV;
447    FProbH.GetKeyDatPrV(FProbV);  FProbV.Sort();
448    FILE *F = fopen(TStr::Fmt("phDIAM.%s.tab", GetFNm(FNmPref).CStr()).CStr(), "wt");
449    if (! Desc.Empty()) fprintf(F, "%s\n", Desc.CStr());
450    fprintf(F, "FollowDiamCf: %g\n", FollowDiamCf);
451    fprintf(F, "StartNodes:   %d\n", StartNodes());
452    fprintf(F, "Take2AmbProb: %g\n", Take2AmbProb());
453    fprintf(F, "OrphanProb:   %g\n", OrphanProb());
454    fprintf(F, "Tolerance:    %g\n", Tolerance);
455    fprintf(F, "id\tFProb\tBProb\tBRatio\tDiamCf\tDiamDev\tGplCf\tGplDev\tEffDiam\n");
456    for (int i = 0; i < FProbV.Len(); i++) {
457      const int Id = FProbV[i].Val2.Val1;
458      const TFltPr DiamCf = GetDecDiam(Id);
459      const TFltPr GplCf = GetGplCf(Id);
460      const TFltPr EffDiam = GetEffDiam(Id, -1);
461      fprintf(F, "%d\t%f\t%f\t%f\t", Id, GetFProb(Id), GetBProb(Id), GetBProb(Id)/GetFProb(Id));
462      fprintf(F, "%f\t%f\t%f\t%f\t%f\n", DiamCf.Val1(), DiamCf.Val2(), GplCf.Val1(), GplCf.Val2(), EffDiam.Val1());
463    }
464    fclose(F);
465  }
466  void TFfPhaseTrans::Merge(const PFfPhaseTrans& FfPhaseTrans) {
467    Merge(*FfPhaseTrans);
468  }
469  void TFfPhaseTrans::Merge(const TFfPhaseTrans& FfPhaseTrans) {
470    printf("Merging:\n");
471    printf("  source      %6d  (Fwd,Bck) pairs\n", FfPhaseTrans.Len());
472    printf("  destination %6d  (Fwd,Bck) pairs\n", Len());
473    IAssert(BurExpFire == FfPhaseTrans.BurExpFire);
474    IAssert(NNodes == FfPhaseTrans.NNodes);
475    IAssert(StartNodes == FfPhaseTrans.StartNodes);
476    IAssert(Take2AmbProb == FfPhaseTrans.Take2AmbProb);
477    IAssert(FBPrGSetH.Len() == FBPrGStatH.Len());
478    IAssert(FfPhaseTrans.FBPrGSetH.Len() == FfPhaseTrans.FBPrGStatH.Len());
479    for (int i1 = 0; i1 < FfPhaseTrans.FBPrGSetH.Len(); i1++) {
480      IAssert(FfPhaseTrans.FBPrGSetH.GetKey(i1) == FfPhaseTrans.FBPrGStatH.GetKey(i1));
481      const TFltPr& Key = FfPhaseTrans.FBPrGSetH.GetKey(i1);
482      if (! FBPrGStatH.IsKey(Key)) {
483        const PGrowthStat Stat = FfPhaseTrans.FBPrGStatH[i1];
484        const PGrowthSet Set = FfPhaseTrans.FBPrGSetH[i1];
485        FBPrGStatH.AddDat(Key, Stat);
486        FBPrGSetH.AddDat(Key, Set);
487      }
488    }
489    printf("  ** merged   %6d  (Fwd,Bck) pairs\n", Len());
490  }
491  /&bsol;*/
492  int TUndirFFire::BurnGeoFire(const int& StartNId) {
493    BurnedSet.Clr(false);
494    BurningNIdV.Clr(false);  
495    NewBurnedNIdV.Clr(false);
496    AliveNIdV.Clr(false);
497    const TUNGraph& G = *Graph;
498    int NBurned = 1;
499    BurnedSet.AddKey(StartNId);
500    BurningNIdV.Add(StartNId);
501    while (! BurningNIdV.Empty()) {
502      for (int node = 0; node < BurningNIdV.Len(); node++) {
503        const int& BurningNId = BurningNIdV[node];
504        const TUNGraph::TNodeI& Node = G.GetNI(BurningNId);
505        AliveNIdV.Clr(false); 
506        for (int e = 0; e < Node.GetOutDeg(); e++) {
507          const int OutNId = Node.GetOutNId(e);
508          if (! BurnedSet.IsKey(OutNId)) {
509            AliveNIdV.Add(OutNId); }
510        }
511        const int BurnNLinks = Rnd.GetGeoDev(1.0-BurnProb) - 1;
512        if (! AliveNIdV.Empty() && BurnNLinks > 0) {
513          AliveNIdV.Shuffle(Rnd);
514          for (int i = 0; i < TMath::Mn(BurnNLinks, AliveNIdV.Len()); i++) {
515            BurnedSet.AddKey(AliveNIdV[i]);
516            NewBurnedNIdV.Add(AliveNIdV[i]);
517            NBurned++;
518          }
519        }
520      }
521      BurningNIdV.Swap(NewBurnedNIdV);   
522      NewBurnedNIdV.Clr(false);
523    }
524    IAssert(BurnedSet.Len() == NBurned);
525    return NBurned;
526  }
527  TFfGGen::TStopReason TUndirFFire::AddNodes(const int& GraphNodes, const bool& FloodStop) {
528    printf("\n***Undirected GEO ForestFire: graph(%d,%d) add %d nodes, burn prob %.3f\n", 
529      Graph->GetNodes(), Graph->GetEdges(), GraphNodes, BurnProb);
530    TExeTm ExeTm;
531    int Burned1=0, Burned2=0, Burned3=0; 
532    TIntPrV NodesEdgesV;
533    if (Graph.Empty()) { Graph = PUNGraph::New(); }
534    if (Graph->GetNodes() == 0) { Graph->AddNode(); }
535    int NEdges = Graph->GetEdges();
536    for (int NNodes = Graph->GetNodes()+1; NNodes <= GraphNodes; NNodes++) {
537      const int NewNId = Graph->AddNode(-1);
538      IAssert(NewNId == Graph->GetNodes()-1); 
539      const int StartNId = Rnd.GetUniDevInt(NewNId);
540      const int NBurned = BurnGeoFire(StartNId);
541      for (int e = 0; e < NBurned; e++) {
542        Graph->AddEdge(NewNId, GetBurnedNId(e)); }
543      NEdges += NBurned;
544      Burned1=Burned2;  Burned2=Burned3;  Burned3=NBurned;
545      if (NNodes % Kilo(1) == 0) {
546        printf("(%d, %d)    burned: [%d,%d,%d]  [%s]\n", NNodes, NEdges, Burned1, Burned2, Burned3, ExeTm.GetStr()); 
547        NodesEdgesV.Add(TIntPr(NNodes, NEdges));
548      }
549      if (FloodStop && NEdges>1000 && NEdges/double(NNodes)>100.0) { 
550        printf("!!! FLOOD. G(%6d, %6d)\n", NNodes, NEdges);  return TFfGGen::srFlood; }
551    }
552    printf("\n");
553    IAssert(Graph->GetEdges() == NEdges);
554    return TFfGGen::srOk;
555  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmgraph-exp.h</h3>
            <pre><code>1  #ifndef MGRAPH_H
2  #define MGRAPH_H
3  #include "network.h"
4  #include "networkmp.h"
5  template<class TNode>
6  class TMNet;
7  class TSVNode {
8  private:
9    TInt TypeId;
10    TInt Id;
11    TVec<TIntV > InEIdVV, OutEIdVV;
12    TInt InDeg, OutDeg;
13  public:
14    TSVNode() : TypeId(-1), Id(-1), InEIdVV(), OutEIdVV(), InDeg(0), OutDeg(0) { }
15    TSVNode(const int& NTypeId, const int& NId) : TypeId(NTypeId), Id(NId), InEIdVV(), OutEIdVV(), InDeg(0), OutDeg(0) { }
16    TSVNode(const TSVNode& Node) : TypeId(Node.TypeId), Id(Node.Id), InEIdVV(Node.InEIdVV), OutEIdVV(Node.OutEIdVV), InDeg(Node.InDeg), OutDeg(Node.OutDeg) { }
17    TSVNode(const TSVNode& Node, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
18                  TypeId(Node.TypeId), Id(Node.Id), InEIdVV(Node.InEIdVV.Len()), OutEIdVV(Node.OutEIdVV.Len()),
19                  InDeg(0), OutDeg(0) {
20      for (int i = 0; i < InETypeIdV.Len(); i++) {
21        int ETypeId = InETypeIdV[i];
22        InEIdVV[ETypeId] = Node.InEIdVV[ETypeId];
23        InDeg += Node.InEIdVV[ETypeId].Len();
24      }
25      for (int i = 0; i < OutETypeIdV.Len(); i++) {
26        int ETypeId = OutETypeIdV[i];
27        OutEIdVV[ETypeId] = Node.OutEIdVV[ETypeId];
28        OutDeg += Node.OutEIdVV[ETypeId].Len();
29      }
30    }
31    TSVNode(TSIn& SIn) : TypeId(SIn), Id(SIn), InEIdVV(SIn), OutEIdVV(SIn), InDeg(0), OutDeg(0) { }
32    void Save(TSOut& SOut) const { TypeId.Save(SOut); Id.Save(SOut); InEIdVV.Save(SOut); OutEIdVV.Save(SOut); InDeg.Save(SOut); OutDeg.Save(SOut); }
33    int GetTypeId() const { return TypeId; }
34    int GetId() const { return Id; }
35    int GetDeg() const { return GetInDeg() + GetOutDeg(); }
36    int GetInDeg(const int& ETypeId) const {return InEIdVV[ETypeId].Len();}
37    int GetInDeg() const { return InDeg; }
38    int GetOutDeg(int ETypeId) const {return OutEIdVV[ETypeId].Len();}
39    int GetOutDeg() const { return OutDeg; }
40    void AddInETypeIds(const TIntV& ETypeIds) {
41      int MxETypeId = -1;
42      for (int i = 0; i < ETypeIds.Len(); i++) {
43        if (MxETypeId < ETypeIds[i]) { MxETypeId = ETypeIds[i]; }
44      }
45      InEIdVV.Reserve(MxETypeId+1, MxETypeId+1);
46      for (int i = 0; i < ETypeIds.Len(); i++) {
47        InEIdVV[ETypeIds[i]] = TIntV();
48      }
49    }
50    void AddOutETypeIds(const TIntV& ETypeIds) {
51      int MxETypeId = -1;
52      for (int i = 0; i < ETypeIds.Len(); i++) {
53        if (MxETypeId < ETypeIds[i]) { MxETypeId = ETypeIds[i]; }
54      }
55      OutEIdVV.Reserve(MxETypeId+1, MxETypeId+1);
56      for (int i = 0; i < ETypeIds.Len(); i++) {
57        OutEIdVV[ETypeIds[i]] = TIntV();
58      }
59    }
60    void AddInNbr(const int& ETypeId, const int& EId) { InEIdVV[ETypeId].Add(EId); InDeg++; }
61    void AddOutNbr(const int& ETypeId, const int& EId) { OutEIdVV[ETypeId].Add(EId); OutDeg++; }
62    void DelInNbr(const int& ETypeId, const int& EId) { InEIdVV[ETypeId].DelIfIn(EId); InDeg--; }
63    void DelOutNbr(const int& ETypeId, const int& EId) { OutEIdVV[ETypeId].DelIfIn(EId); OutDeg--; }
64    int GetInEId(const int& EdgeN) const {
65      int CumSum = 0;
66      int ETypeId = 0;
67      for (; ETypeId < InEIdVV.Len(); ETypeId++) {
68        CumSum += InEIdVV[ETypeId].Len();
69        if (CumSum > EdgeN) { CumSum -= InEIdVV[ETypeId].Len(); break; }
70      }
71      return InEIdVV[ETypeId][EdgeN-CumSum];
72    }
73    int GetOutEId(const int& EdgeN) const {
74      int CumSum = 0;
75      int ETypeId = 0;
76      for (; ETypeId < OutEIdVV.Len(); ETypeId++) {
77        CumSum += OutEIdVV[ETypeId].Len();
78        if (CumSum > EdgeN) { CumSum -= OutEIdVV[ETypeId].Len(); break; }
79      }
80      return OutEIdVV[ETypeId][EdgeN-CumSum];
81    }
82    void GetInEIdV(TIntV& EIdV) const {
83      EIdV.Gen(InDeg, 0);
84      for (int i = 0; i < InEIdVV.Len(); i++) {
85        EIdV.AddV(InEIdVV[i]);
86      }
87    }
88    void GetOutEIdV(TIntV& EIdV) const {
89      EIdV.Gen(OutDeg, 0);
90      for (int i = 0; i < OutEIdVV.Len(); i++) {
91        EIdV.AddV(OutEIdVV[i]);
92      }
93    }
94    void GetInEIdV(const TInt ETypeId, TIntV& EIdV) const {
95      EIdV = InEIdVV[ETypeId.Val];
96    }
97    void GetOutEIdV(const TInt ETypeId, TIntV& EIdV) const {
98      EIdV = OutEIdVV[ETypeId.Val];
99    }
100    void GetInEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
101      EIdV.Reserve(InDeg, 0);
102      for (int k = 0; k < ETypeIdV.Len(); k++) {
103        EIdV.AddV(InEIdVV[ETypeIdV[k].Val]);
104      }
105    }
106    void GetOutEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
107      EIdV.Reserve(OutDeg, 0);
108      for (int k = 0; k < ETypeIdV.Len(); k++) {
109        EIdV.AddV(OutEIdVV[ETypeIdV[k].Val]);
110      }
111    }
112    friend class TMNet<TSVNode>;
113  };
114  class TMVNode {
115  private:
116    TInt TypeId; 
117    TInt Id; 
118    TIntV InEIdV, OutEIdV; 
119    TIntV InETypeIdV, OutETypeIdV; 
120  public:
121    TMVNode() : TypeId(-1), Id(-1), InEIdV(), OutEIdV(), InETypeIdV(), OutETypeIdV() { }
122    TMVNode(const int& NTypeId, const int& NId) : TypeId(NTypeId), Id(NId), InEIdV(), OutEIdV(), InETypeIdV(), OutETypeIdV() { }
123    TMVNode(const TMVNode& Node) : TypeId(Node.TypeId), Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV),
124                                          InETypeIdV(Node.InETypeIdV), OutETypeIdV(Node.OutETypeIdV) { }
125    TMVNode(const TMVNode& Node, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
126              TypeId(Node.TypeId), Id(Node.Id), InEIdV(Node.InEIdV.Len()), OutEIdV(Node.OutEIdV.Len()),
127              InETypeIdV(Node.InETypeIdV.Len()), OutETypeIdV(Node.OutETypeIdV.Len()) {
128      TIntSet InETypeIdSet(InETypeIdV);
129      for (int i = 0; i < Node.InEIdV.Len(); i++) {
130        if (InETypeIdSet.IsKey(Node.InETypeIdV[i])) {
131          InEIdV.Add(Node.InEIdV[i]);
132        }
133      }
134      TIntSet OutETypeIdSet(OutETypeIdV);
135      for (int i = 0; i < Node.OutEIdV.Len(); i++) {
136        if (OutETypeIdSet.IsKey(Node.OutETypeIdV[i])) {
137          OutEIdV.Add(Node.OutEIdV[i]);
138        }
139      }
140    }
141    TMVNode(TSIn& SIn) : TypeId(SIn), Id(SIn), InEIdV(SIn), OutEIdV(SIn), InETypeIdV(SIn), OutETypeIdV(SIn) { }
142    void Save(TSOut& SOut) const { TypeId.Save(SOut); Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut);
143                                    InETypeIdV.Save(SOut); OutETypeIdV.Save(SOut); }
144    int GetTypeId() const { return TypeId; }
145    int GetId() const { return Id; }
146    int GetDeg() const { return GetInDeg() + GetOutDeg(); }
147    int GetInDeg() const { return InEIdV.Len(); }
148    int GetOutDeg() const { return OutEIdV.Len(); }
149    int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
150    int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
151    int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
152    void GetInEIdV(TIntV& EIdV) const { EIdV = InEIdV; }
153    void GetOutEIdV(TIntV& EIdV) const { EIdV = OutEIdV; }
154    bool IsInEId(const int& EId) const { return InEIdV.SearchForw(EId) != -1; }
155    bool IsOutEId(const int& EId) const { return OutEIdV.SearchForw(EId) != -1; }
156    void AddInETypeIds(const TIntV& ETypeIds) { } 
157    void AddOutETypeIds(const TIntV& ETypeIds) { } 
158    void AddInNbr(const int& ETypeId, const int& EId) {
159      InETypeIdV.Add(ETypeId);
160      InEIdV.Add(EId);
161    }
162    void AddOutNbr(const int& ETypeId, const int& EId) {
163      OutETypeIdV.Add(ETypeId);
164      OutEIdV.Add(EId);
165    }
166    void DelInNbr(const int& ETypeId, const int& EId) {
167      int EIdN = InEIdV.SearchBack(EId);
168      InETypeIdV.Del(EIdN);
169      InEIdV.Del(EIdN);
170    }
171    void DelOutNbr(const int& ETypeId, const int& EId) {
172      int EIdN = OutEIdV.SearchBack(EId);
173      OutETypeIdV.Del(EIdN);
174      OutEIdV.Del(EIdN);
175    }
176    void GetInEIdV(const TInt& ETypeId, TIntV& EIdV) const {
177      EIdV.Reduce(0); 
178      for (int i = 0; i < InEIdV.Len(); i++) {
179        if (InETypeIdV[i] == ETypeId) { EIdV.Add(InEIdV[i]); }
180      }
181    }
182    void GetOutEIdV(const TInt& ETypeId, TIntV& EIdV) const {
183      EIdV.Reduce(0); 
184      for (int i = 0; i < OutEIdV.Len(); i++) {
185        if (OutETypeIdV[i] == ETypeId) { EIdV.Add(OutEIdV[i]); }
186      }
187    }
188    void GetInEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
189      EIdV.Reserve(InEIdV.Len(), 0);
190      for (int k = 0; k < ETypeIdV.Len(); k++) {
191        TInt ETypeId = ETypeIdV[k];
192        for (int i = 0; i < InETypeIdV.Len(); i++) {
193          if (InETypeIdV[i] == ETypeId) { EIdV.Add(InEIdV[i]); }
194        }
195      }
196    }
197    void GetOutEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
198      EIdV.Reserve(OutEIdV.Len(), 0);
199      for (int k = 0; k < ETypeIdV.Len(); k++) {
200        TInt ETypeId = ETypeIdV[k];
201        for (int i = 0; i < OutETypeIdV.Len(); i++) {
202          if (OutETypeIdV[i] == ETypeId) { EIdV.Add(OutEIdV[i]); }
203        }
204      }
205    }
206    friend class TMNet<TMVNode>;
207  };
208  class TCVNode {
209  public:
210    static const int DEF_WEIGHT;
211    static const int DEF_WEIGHT_COEFF;
212    static const int DEF_EXPAND_RATIO;
213  private:
214    static void RedistributeEIds(const TIntV& Weights, TIntV& EIdV, TIntV& TypeIndexV, TIntV& TypeDegV) {
215      IAssertR(TypeIndexV.Len() == TypeDegV.Len(), TStr::Fmt("The node is in inconsistent state."));
216      int NTypes = Weights.Len();
217      TIntV NewTypeIndexV(NTypes); 
218      int CumSum = 0; 
219      for (int ETypeId = 0; ETypeId < NTypes; ETypeId++) {
220        NewTypeIndexV[ETypeId] = CumSum;
221        CumSum += Weights[ETypeId] * DEF_WEIGHT_COEFF;
222      }
223      TIntV NewEIdV(CumSum);
224      for (int ETypeId = TypeIndexV.Len() - 1; ETypeId >= 0; ETypeId--) {
225        IAssertR(CumSum >= NewTypeIndexV[ETypeId] + TypeDegV[ETypeId], TStr::Fmt("The node is in inconsistent state."));
226        for (int i = 0; i < TypeDegV[ETypeId]; i++) {
227          NewEIdV[NewTypeIndexV[ETypeId] + i] = EIdV[TypeIndexV[ETypeId] + i];
228        }
229      }
230      TypeDegV.Reserve(NTypes, NTypes);
231      TypeIndexV = NewTypeIndexV;
232      EIdV = NewEIdV;
233    }
234  private:
235    TInt TypeId; 
236    TInt Id; 
237    TIntV InEIdV, OutEIdV;
238    TInt InDeg, OutDeg;
239    TIntV InTypeIndexV, OutTypeIndexV;
240    TIntV InTypeDegV, OutTypeDegV;
241  public:
242    TCVNode() : TypeId(-1), Id(-1), InEIdV(), OutEIdV(), InDeg(0), OutDeg(0),
243                                      InTypeIndexV(), OutTypeIndexV(), InTypeDegV(), OutTypeDegV() { }
244    TCVNode(const int& NTypeId, const int& NId) : TypeId(NTypeId), Id(NId), InEIdV(), OutEIdV(), InDeg(0), OutDeg(0),
245                                      InTypeIndexV(), OutTypeIndexV(), InTypeDegV(), OutTypeDegV() { }
246    TCVNode(const TCVNode& Node) : TypeId(Node.TypeId), Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV),
247                                      InDeg(Node.InDeg), OutDeg(Node.OutDeg), InTypeIndexV(Node.InTypeIndexV), OutTypeIndexV(Node.OutTypeIndexV),
248                                      InTypeDegV(Node.InTypeDegV), OutTypeDegV(Node.OutTypeDegV) { }
249    TCVNode(const TCVNode& Node, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
250                                      TypeId(Node.TypeId), Id(Node.Id), InDeg(0), OutDeg(0),
251                                      InTypeIndexV(Node.InTypeIndexV.Len()), OutTypeIndexV(Node.OutTypeIndexV.Len()),
252                                      InTypeDegV(Node.InTypeDegV.Len()), OutTypeDegV(Node.OutTypeDegV.Len()) {
253      for (TIntV::TIter iter = InETypeIdV.BegI(); iter < InETypeIdV.EndI(); iter++) {
254        InDeg += Node.InTypeDegV[*iter];
255        InTypeDegV[*iter] = Node.InTypeDegV[*iter];
256      }
257      int index = 0;
258      InEIdV.Gen(InDeg);
259      TIntSet InETypeIdSet(InETypeIdV);
260      for (int ETypeId = 0; ETypeId < InTypeIndexV.Len(); ETypeId++) {
261        InTypeIndexV[ETypeId] = index;
262        if (InETypeIdSet.IsKey(ETypeId)) {
263          for (int i = Node.InTypeIndexV[ETypeId]; i < Node.InTypeIndexV[ETypeId] + Node.InTypeDegV[ETypeId]; i++) {
264            InEIdV[index++] = Node.InEIdV[i];
265          }
266        }
267      }
268      IAssert(index == InDeg);
269      for (TIntV::TIter iter = OutETypeIdV.BegI(); iter < OutETypeIdV.EndI(); iter++) {
270        OutDeg += Node.OutTypeDegV[*iter];
271        OutTypeDegV[*iter] = Node.OutTypeDegV[*iter];
272      }
273      index = 0;
274      OutEIdV.Gen(OutDeg);
275      TIntSet OutETypeIdSet(OutETypeIdV);
276      for (int ETypeId = 0; ETypeId < OutTypeIndexV.Len(); ETypeId++) {
277        OutTypeIndexV[ETypeId] = index;
278        if (OutETypeIdSet.IsKey(ETypeId)) {
279          for (int i = Node.OutTypeIndexV[ETypeId]; i < Node.OutTypeIndexV[ETypeId] + Node.OutTypeDegV[ETypeId]; i++) {
280            OutEIdV[index++] = Node.OutEIdV[i];
281          }
282        }
283      }
284      IAssert(index == OutDeg);
285    }
286    TCVNode(TSIn& SIn) : TypeId(SIn), Id(SIn), InEIdV(SIn), OutEIdV(SIn), InDeg(SIn), OutDeg(SIn),
287                                      InTypeIndexV(SIn), OutTypeIndexV(SIn), InTypeDegV(SIn), OutTypeDegV(SIn) { }
288    void Save(TSOut& SOut) const { TypeId.Save(SOut); Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut);
289                                      InDeg.Save(SOut); OutDeg.Save(SOut); InTypeIndexV.Save(SOut); OutTypeIndexV.Save(SOut);
290                                      InTypeDegV.Save(SOut); OutTypeDegV.Save(SOut); }
291    int GetTypeId() const { return TypeId; }
292    int GetId() const { return Id; }
293    int GetDeg() const { return InDeg + OutDeg; }
294    int GetInDeg() const { return InDeg; }
295    int GetOutDeg() const { return OutDeg; }
296    int GetInDeg(const int& ETypeId) const { return InTypeDegV[ETypeId]; }
297    int GetOutDeg(const int& ETypeId) const { return OutTypeDegV[ETypeId]; }
298    int GetInEId(const int& EdgeN) const {
299      int CumSum = 0;
300      int ETypeId = 0;
301      for (; ETypeId < InTypeDegV.Len(); ETypeId++) {
302        CumSum += InTypeDegV[ETypeId];
303        if (CumSum > EdgeN) { CumSum -= InTypeDegV[ETypeId]; break; }
304      }
305      return InEIdV[InTypeIndexV[ETypeId] + EdgeN - CumSum];
306    }
307    int GetOutEId(const int& EdgeN) const {
308      int CumSum = 0;
309      int ETypeId = 0;
310      for (; ETypeId < OutTypeDegV.Len(); ETypeId++) {
311        CumSum += OutTypeDegV[ETypeId];
312        if (CumSum > EdgeN) { CumSum -= OutTypeDegV[ETypeId]; break; }
313      }
314      return OutEIdV[OutTypeIndexV[ETypeId] + EdgeN - CumSum];
315    }
316    int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
317    void GetInEIdV(TIntV& EIdV) const {
318      EIdV.Gen(InDeg, 0);
319      for (int ETypeId = 0; ETypeId < InTypeDegV.Len(); ETypeId++) {
320        for (int i = InTypeIndexV[ETypeId]; i < InTypeIndexV[ETypeId] + InTypeDegV[ETypeId]; i++) {
321          EIdV.Add(InEIdV[i]);
322        }
323      }
324    }
325    void GetOutEIdV(TIntV& EIdV) const {
326      EIdV.Gen(OutDeg, 0);
327      for (int ETypeId = 0; ETypeId < OutTypeDegV.Len(); ETypeId++) {
328        for (int i = OutTypeIndexV[ETypeId]; i < OutTypeIndexV[ETypeId] + OutTypeDegV[ETypeId]; i++) {
329          EIdV.Add(OutEIdV[i]);
330        }
331      }
332    }
333    void AddInETypeIds(const TIntV& ETypeIds) {
334      if (ETypeIds.Len() == 0) { return; }
335      int MxETypeId = InTypeIndexV.Len() - 1;
336      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
337        if (MxETypeId < *iter) { MxETypeId = *iter; }
338      }
339      TIntV InWeights(MxETypeId + 1);
340      for (int ETypeId = 0; ETypeId < InTypeDegV.Len(); ETypeId++) {
341        InWeights[ETypeId] = InTypeDegV[ETypeId];
342      }
343      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
344        InWeights[*iter] = DEF_WEIGHT;
345      }
346      RedistributeEIds(InWeights, InEIdV, InTypeIndexV, InTypeDegV);
347    }
348    void AddOutETypeIds(const TIntV& ETypeIds) {
349      if (ETypeIds.Len() == 0) { return; }
350      int MxETypeId = OutTypeIndexV.Len() - 1;
351      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
352        if (MxETypeId < *iter) { MxETypeId = *iter; }
353      }
354      TIntV OutWeights(MxETypeId + 1);
355      for (int ETypeId = 0; ETypeId < OutTypeDegV.Len(); ETypeId++) {
356        OutWeights[ETypeId] = OutTypeDegV[ETypeId];
357      }
358      for (TIntV::TIter iter = ETypeIds.BegI(); iter < ETypeIds.EndI(); iter++) {
359        OutWeights[*iter] = DEF_WEIGHT;
360      }
361      RedistributeEIds(OutWeights, OutEIdV, OutTypeIndexV, OutTypeDegV);
362    }
363    void AddInNbr(const int& ETypeId, const int& EId) {
364      int Deg = InTypeDegV[ETypeId];
365      int Capacity = (ETypeId == (InTypeIndexV.Len()-1)) ? InEIdV.Len() : InTypeIndexV[ETypeId+1].Val;
366      Capacity -= InTypeIndexV[ETypeId];
367      if (Deg >= Capacity) {
368        IAssertR(Deg == Capacity, TStr::Fmt("The node is in inconsistent state."));
369        TIntV Weights(InTypeDegV);
370        Weights[ETypeId] = (Weights[ETypeId] + 4) * DEF_EXPAND_RATIO;
371        RedistributeEIds(Weights, InEIdV, InTypeIndexV, InTypeDegV);
372      }
373      InEIdV[InTypeIndexV[ETypeId] + Deg] = EId;
374      InTypeDegV[ETypeId]++;
375      InDeg++;
376    }
377    void AddOutNbr(const int& ETypeId, const int& EId) {
378      int Deg = OutTypeDegV[ETypeId];
379      int Capacity = (ETypeId == (OutTypeIndexV.Len()-1)) ? OutEIdV.Len() : OutTypeIndexV[ETypeId+1].Val;
380      Capacity -= OutTypeIndexV[ETypeId];
381      if (Deg >= Capacity) {
382        IAssertR(Deg == Capacity, TStr::Fmt("The node is in inconsistent state."));
383        TIntV Weights(OutTypeDegV);
384        Weights[ETypeId] = (Weights[ETypeId] + 4) * DEF_EXPAND_RATIO; 
385        RedistributeEIds(Weights, OutEIdV, OutTypeIndexV, OutTypeDegV);
386      }
387      OutEIdV[OutTypeIndexV[ETypeId] + Deg] = EId;
388      OutTypeDegV[ETypeId]++;
389      OutDeg++;
390    }
391    void DelInNbr(const int& ETypeId, const int& EId) {
392      int ValN = InEIdV.SearchForw(EId, InTypeIndexV[ETypeId]);
393      for (int MValN=ValN+1; MValN<InTypeIndexV[ETypeId]+InTypeDegV[ETypeId]; MValN++){
394        InEIdV[MValN-1]=InEIdV[MValN];
395      }
396      InDeg--;
397      InTypeDegV[ETypeId]--;
398    }
399    void DelOutNbr(const int& ETypeId, const int& EId) {
400      int ValN = OutEIdV.SearchForw(EId, OutTypeIndexV[ETypeId]);
401      for (int MValN=ValN+1; MValN<OutTypeIndexV[ETypeId]+OutTypeDegV[ETypeId]; MValN++){
402        OutEIdV[MValN-1]=OutEIdV[MValN];
403      }
404      OutDeg--;
405      OutTypeDegV[ETypeId]--;
406    }
407    void GetInEIdV(const TInt& ETypeId, TIntV& EIdV) const {
408      int Sz = InTypeDegV[ETypeId].Val;
409      EIdV.Reserve(Sz, Sz);
410      int Ind = InTypeIndexV[ETypeId].Val;
411      for (int i = 0; i < Sz; i++) {
412        EIdV[i] = InEIdV[Ind+i];
413      }
414    }
415    void GetOutEIdV(const TInt& ETypeId, TIntV& EIdV) const {
416      int Sz = OutTypeDegV[ETypeId].Val;
417      EIdV.Reserve(Sz, Sz);
418      int Ind = OutTypeIndexV[ETypeId].Val;
419      for (int i = 0; i < Sz; i++) {
420        EIdV[i] = OutEIdV[Ind+i];
421      }
422    }
423    void GetInEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
424      int Sz = 0;
425      for (int k = 0; k < ETypeIdV.Len(); k++) {
426        Sz += InTypeDegV[ETypeIdV[k]].Val;
427      }
428      EIdV.Reserve(Sz, 0);
429      int Ind;
430      for (int k = 0; k < ETypeIdV.Len(); k++) {
431        Ind = InTypeIndexV[ETypeIdV[k]].Val;
432        for (int i = 0; i < InTypeDegV[ETypeIdV[k]]; i++) {
433          EIdV.Add(InEIdV[Ind]);
434        }
435      }
436    }
437    void GetOutEIdV(const TIntV& ETypeIdV, TIntV& EIdV) const {
438      int Sz = 0;
439      for (int k = 0; k < ETypeIdV.Len(); k++) {
440        Sz += OutTypeDegV[ETypeIdV[k]].Val;
441      }
442      EIdV.Reserve(Sz, 0);
443      int Ind;
444      for (int k = 0; k < ETypeIdV.Len(); k++) {
445        Ind = OutTypeIndexV[ETypeIdV[k]].Val;
446        for (int i = 0; i < OutTypeDegV[ETypeIdV[k]]; i++) {
447          EIdV.Add(OutEIdV[Ind]);
448        }
449      }
450    }
451    friend class TMNet<TCVNode>;
452  };
453  template<class TNode>
454  class TMNet {
455  public:
456    typedef TMNet TNet;
457    typedef TPt<TMNet> PNet;
458  public:
459    class TEdge {
460    private:
461      TInt TypeId, Id, SrcNId, DstNId;
462    public:
463      TEdge() : TypeId(-1), Id(-1), SrcNId(-1), DstNId(-1) { }
464      TEdge(const int& ETypeId, const int& EId, const int& SourceNId, const int& DestNId) : TypeId(ETypeId), Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
465      TEdge(const TEdge& Edge) : TypeId(Edge.TypeId), Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
466      TEdge(TSIn& SIn) : TypeId(SIn), Id(SIn), SrcNId(SIn), DstNId(SIn) { }
467      void Save(TSOut& SOut) const { TypeId.Save(SOut), Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
468      int GetTypeId() const { return TypeId; }
469      int GetId() const { return Id; }
470      int GetSrcNId() const { return SrcNId; }
471      int GetDstNId() const { return DstNId; }
472      friend class TMNet;
473    };
474    class TNodeType {
475    private:
476      TInt Id;
477      TStr Name;
478      TInt MxNId;
479      THash<TInt, TNode> NodeH;
480    public:
481      TNodeType() : Id(-1), Name(), MxNId(0), NodeH(){ }
482      TNodeType(const int& NTypeId, const TStr& NTypeName) : Id(NTypeId), Name(NTypeName), MxNId(0), NodeH(){ }
483      TNodeType(const TNodeType& NodeType) : Id(NodeType.Id), Name(NodeType.Name), MxNId(NodeType.MxNId), NodeH(NodeType.NodeH) { }
484      TNodeType(const TNodeType& NodeType, const TIntV& InETypeIdV, const TIntV& OutETypeIdV) :
485                Id(NodeType.Id), Name(NodeType.Name), MxNId(NodeType.MxNId), NodeH(NodeType.NodeH.Len()) {
486        for (typename THash<TInt,TNode>::TIter iter = NodeType.NodeH.BegI(); iter < NodeType.NodeH.EndI(); iter++) {
487          TNode NewNode(iter.GetDat(), InETypeIdV, OutETypeIdV);
488          NodeH.AddDat(iter.GetKey(), NewNode);
489        }
490      }
491      TNodeType(TSIn& SIn) : Id(SIn), Name(SIn), MxNId(SIn), NodeH(SIn) { }
492      void Save(TSOut& SOut) const { Id.Save(SOut); Name.Save(SOut); MxNId.Save(SOut); NodeH.Save(SOut); }
493      int GetId() const { return Id; }
494      TStr GetName() const { return Name; }
495      int GetMxNId() const { return MxNId; }
496      friend class TMNet;
497    };
498    template<class TEdge>
499    class TMNodeI {
500    private:
501      typedef typename THash<TInt, TNode>::TIter THashIter;
502      typedef typename TVec<TNodeType>::TIter TTypeIter;
503      TTypeIter VecI;
504      TTypeIter VecEndI;
505      THashIter HashI;
506      const TMNet *Graph;
507    private:
508      THashIter VecElemBegI() {
509        return (*VecI).NodeH.BegI();
510      }
511      void FindNextNonEmptyHashI() {
512        while (HashI.IsEnd() && VecI < VecEndI) {
513          VecI++;
514          HashI = VecElemBegI();
515        }
516      }
517    public:
518      TMNodeI() : VecI(), VecEndI(), HashI(), Graph(NULL) { }
519      TMNodeI(const TTypeIter& TypeIter, const THashIter& NodeIter, const TMNet* GraphPt)
520                : VecI(TypeIter), VecEndI(GraphPt->TypeNodeV.EndI()), HashI(NodeIter), Graph(GraphPt) { }
521      TMNodeI(const TTypeIter& TypeIter, const TMNet* GraphPt) : VecI(TypeIter), VecEndI(GraphPt->TypeNodeV.EndI()), Graph(GraphPt) {
522        if (VecI < VecEndI) {
523          HashI = VecElemBegI();
524          FindNextNonEmptyHashI();
525        } else {
526          HashI = THashIter();
527        }
528      }
529      TMNodeI(const TMNodeI& NodeI) : VecI(NodeI.VecI), VecEndI(NodeI.VecEndI), HashI(NodeI.HashI), Graph(NodeI.Graph) { }
530      TMNodeI& operator = (const TMNodeI& NodeI) { VecI=NodeI.VecI; VecEndI=NodeI.VecEndI; HashI=NodeI.HashI; Graph=NodeI.Graph; return *this; }
531      TMNodeI& operator++ (int) {
532        HashI++;
533        FindNextNonEmptyHashI();
534        return *this;
535      }
536      bool operator < (const TMNodeI& NodeI) const { return VecI < NodeI.VecI || HashI < NodeI.HashI; }
537      bool operator == (const TMNodeI& NodeI) const { return VecI == NodeI.VecI && HashI == NodeI.HashI; }
538      int GetId() const { return HashI.GetDat().GetId(); }
539      int GetLocalId() const { return TMNet::GetLocalNId(GetId()); }
540      int GetTypeId() const { return HashI.GetDat().GetTypeId(); }
541      int GetDeg() const { return HashI.GetDat().GetDeg(); }
542      int GetInDeg() const { return HashI.GetDat().GetInDeg(); }
543      int GetOutDeg() const { return HashI.GetDat().GetOutDeg(); }
544      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(HashI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
545      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(HashI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
546      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(HashI.GetDat().GetNbrEId(EdgeN)); return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
547      bool IsInNId(const int& NId) const {
548        const TNode& Node = HashI.GetDat();
549        for (int edge = 0; edge < Node.GetInDeg(); edge++) {
550          if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId()) { return true; }
551        }
552        return false;
553      }
554      bool IsOutNId(const int& NId) const {
555        const TNode& Node = HashI.GetDat();
556        for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
557          if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId()) { return true; }
558        }
559        return false;
560      }
561      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
562      int GetInEId(const int& EdgeN) const { return HashI.GetDat().GetInEId(EdgeN); }
563      int GetOutEId(const int& EdgeN) const { return HashI.GetDat().GetOutEId(EdgeN); }
564      int GetNbrEId(const int& EdgeN) const { return HashI.GetDat().GetNbrEId(EdgeN); }
565      bool IsInEId(const int& EId) const { return HashI.GetDat().IsInEId(EId); }
566      bool IsOutEId(const int& EId) const { return HashI.GetDat().IsOutEId(EId); }
567      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
568    };
569    typedef TMNodeI<TEdge> TNodeI;
570    class TEdgeI {
571    private:
572      typedef typename THash<TInt, TEdge>::TIter THashIter;
573      THashIter EdgeHI;
574      const TMNet *Graph;
575    public:
576      TEdgeI() : EdgeHI(), Graph(NULL) { }
577      TEdgeI(const THashIter& EdgeHIter, const TMNet *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
578      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
579      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
580      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
581      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
582      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
583      int GetId() const { return EdgeHI.GetDat().GetId(); }
584      int GetTypeId() const { return EdgeHI.GetDat().GetTypeId(); }
585      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
586      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
587      friend class TMNet;
588    };
589  private:
590    static const int NTYPEID_NBITS = 3; 
591    static const int NTYPEID_FLAG = (1 << NTYPEID_NBITS) - 1;
592    static int GetGlobalNId(const int& NTypeId, const int& NId) { return (NId << NTYPEID_NBITS) + NTypeId;}
593  private:
594    TCRef CRef;
595    TInt MxNId;
596    TInt MxEId;
597    THash<TStr, int> NTypeH;
598    THash<TStr, int> ETypeH;
599    TVec<TNodeType> TypeNodeV;
600    TIntV EdgeSzV; 
601    THash<TInt, TEdge> EdgeH;
602    int Sz;
603    TVec<TIntV> InETypes;
604    TVec<TIntV> OutETypes;
605    TStrIntPrH KeyToIndexTypeN, KeyToIndexTypeE;
606    enum { IntType, StrType, FltType };
607  private:
608    TNode& GetNode(const int&NId) {
609      int NTypeId = GetNTypeId(NId);
610      int LocalNId = GetLocalNId(NId);
611      return GetNode(NTypeId, LocalNId);
612    }
613    const TNode& GetNode(const int&NId) const {
614      int NTypeId = GetNTypeId(NId);
615      int LocalNId = GetLocalNId(NId);
616      return GetNode(NTypeId, LocalNId);
617    }
618    TNode& GetNode(const int& NTypeId, const int& NId) { return TypeNodeV[NTypeId].NodeH.GetDat(NId); }
619    const TNode& GetNode(const int& NTypeId, const int& NId) const { return TypeNodeV[NTypeId].NodeH.GetDat(NId); }
620    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
621    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
622    void AssertNTypeId(const int NTypeId) const {
623      IAssertR(IsNTypeId(NTypeId), TStr::Fmt("NodeTypeId %d does not exist", NTypeId));
624    }
625  public:
626    TMNet() : CRef(), MxEId(0), NTypeH(), ETypeH(), TypeNodeV(), EdgeH(), Sz(0), InETypes(), OutETypes(),
627      KeyToIndexTypeN(), KeyToIndexTypeE() { }
628    TMNet(const TMNet& Graph) : MxEId(Graph.MxEId),
629      NTypeH(Graph.NTypeH), ETypeH(Graph.ETypeH), TypeNodeV(Graph.TypeNodeV), EdgeH(Graph.EdgeH), Sz(Graph.Sz),
630      InETypes(Graph.InETypes), OutETypes(Graph.OutETypes), KeyToIndexTypeN(), KeyToIndexTypeE() { }
631    static TPt<TMNet<TNode> > New() {
632      return TPt<TMNet<TNode> >(new TMNet());
633    }
634    TMNet& operator = (const TMNet& Graph) { if (this!=&Graph) {
635      MxEId=Graph.MxEId; NTypeH=Graph.NTypeH; ETypeH=Graph.ETypeH; TypeNodeV=Graph.TypeNodeV; EdgeH=Graph.EdgeH;
636      Sz=Graph.Sz; InETypes=Graph.InETypes; OutETypes=Graph.OutETypes;
637      KeyToIndexTypeN=Graph.KeyToIndexTypeN; KeyToIndexTypeE=Graph.KeyToIndexTypeE;}
638      return *this; }
639    bool HasFlag(const TGraphFlag& Flag) const {
640      if (Flag == gfDirected) { return true; }
641      else if (Flag == gfMultiGraph) { return true; }
642      else return false;
643    }
644    static int GetNTypeId(const int& NId) { return NId & NTYPEID_FLAG; } 
645    static int GetLocalNId(const int& GlobalNId) { return GlobalNId >> NTYPEID_NBITS; }
646    int GetMxNTypeId() const { return TypeNodeV.Len(); }
647    int AddNType(const TStr& NTypeName) {
648      int KeyId = NTypeH.GetKeyId(NTypeName);
649      if (KeyId == -1) {
650        int NTypeId = GetMxNTypeId();
651        NTypeH.AddDat(NTypeName, NTypeId);
652        TypeNodeV.Add(TNodeType(NTypeId, NTypeName));
653        IAssertR(NTypeId == InETypes.Len(), TStr::Fmt("InETypes has inconsistent length."));
654        IAssertR(NTypeId == OutETypes.Len(), TStr::Fmt("OutETypes has inconsistent length."));
655        InETypes.Add(TIntV());
656        OutETypes.Add(TIntV());
657        return NTypeId;
658      } else {
659        TStr TempKey;
660        int NTypeId;
661        NTypeH.GetKeyDat(KeyId, TempKey, NTypeId);
662        return NTypeId;
663      }
664    }
665    int GetNTypeId(const TStr& NTypeStr) { return NTypeH.GetDat(NTypeStr); }
666    TStr GetNTypeName(const int NTypeId) {
667      AssertNTypeId(NTypeId);
668      return TypeNodeV[NTypeId].Name;
669    }
670    bool IsNTypeId(const int NTypeId) const { return NTypeId >= 0 && NTypeId < TypeNodeV.Len(); }
671    int GetNodes() const { return Sz; }
672    int GetNodes(const int& NTypeId) const { return TypeNodeV[NTypeId].NodeH.Len(); }
673    int GetMxNId() const { return MxNId; }
674    int GetMxNId(const int& NTypeId) const {
675      AssertNTypeId(NTypeId);
676      return TypeNodeV[NTypeId].MxNId;
677    }
678    int AddNode(const int& NTypeId, int NId = -1) {
679      AssertNTypeId(NTypeId);
680      TNodeType* NodeType = &TypeNodeV[NTypeId];
681      if (NId == -1) {
682        NId = NodeType->MxNId; NodeType->MxNId++;
683      } else {
684        IAssertR(!IsNode(NTypeId, NId), TStr::Fmt("NodeId %d with type %d already exists", NId, NTypeId));
685        NodeType->MxNId = TMath::Mx(NId+1, NodeType->GetMxNId());
686      }
687      TNode NewNode(NTypeId, GetGlobalNId(NTypeId, NId));
688      NewNode.AddInETypeIds(InETypes[NTypeId]);
689      NewNode.AddOutETypeIds(OutETypes[NTypeId]);
690      NodeType->NodeH.AddDat(NId, NewNode);
691      int GlobalNId = GetGlobalNId(NTypeId, NId);
692      MxNId = TMath::Mx(GlobalNId+1, MxNId());
693      Sz++;
694      return GlobalNId;
695    }
696    int AddNode(const TStr& NTypeStr) { return AddNode(GetNTypeId(NTypeStr)); }
697    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetTypeId(), NodeId.GetId()); }
698    bool IsNode(const int& NId) const { return IsNode(GetNTypeId(NId), GetLocalNId(NId)); }
699    bool IsNode(const int& NTypeId, const int& NId) const {
700      if (!IsNTypeId(NTypeId)) { return false; }
701      return TypeNodeV[NTypeId].NodeH.IsKey(NId);
702    }
703    void DelNode(const int& NTypeId, const int& NId) {
704      const TNode& Node = GetNode(NTypeId, NId);
705      TIntV EIdV;
706      Node.GetOutEIdV(EIdV);
707      for (int out = 0; out < EIdV.Len(); out++) {
708        DelEdge(EIdV[out]);
709      }
710      Node.GetInEIdV(EIdV);
711      for (int in = 0; in < EIdV.Len(); in++) {
712        DelEdge(EIdV[in]);
713      }
714      TypeNodeV[NTypeId].NodeH.DelKey(NId);
715      Sz--;
716    }
717    void DelNode(const int& NId) { DelNode(GetNTypeId(NId), GetLocalNId(NId)); }
718    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetTypeId(), NodeI.GetId()); }
719    TNodeI BegNI() const {
720      return TNodeI(TypeNodeV.BegI(), this);
721    }
722    TNodeI EndNI() const { return TNodeI(TypeNodeV.EndI(), this); }
723    TNodeI GetNI(const int& NId) const {
724      int NTypeId = GetNTypeId(NId);
725      int LocalNId = GetLocalNId(NId);
726      return GetNI(NTypeId, LocalNId);
727    }
728    TNodeI BegNI(const int& NTypeId) const { return TNodeI(TypeNodeV.GetI(NTypeId), this); }
729    TNodeI EndNI(const int& NTypeId) const { return TNodeI(TypeNodeV.GetI(NTypeId), TypeNodeV[NTypeId].NodeH.EndI(), this); }
730    TNodeI GetNI(const int& NTypeId, const int& NId) const {
731      return TNodeI(TypeNodeV.GetI(NTypeId), TypeNodeV[NTypeId].NodeH.GetI(NId), this);
732    }
733    void GetNIdV(TIntV& NIdV) const {
734      NIdV.Gen(GetNodes(), 0);
735      for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
736        NIdV.Add(NI.GetId());
737      }
738    }
739    int AddEType(const TStr& ETypeName, const TStr& SrcNTypeName, const TStr& DstNTypeName) {
740      int KeyId = ETypeH.GetKeyId(ETypeName);
741      if (KeyId == -1) {
742        int ETypeId = ETypeH.Len();
743        ETypeH.AddDat(ETypeName, ETypeId);
744        InETypes[GetNTypeId(DstNTypeName)].Add(ETypeId);
745        OutETypes[GetNTypeId(SrcNTypeName)].Add(ETypeId);
746        EdgeSzV.Reserve(ETypeId+1, ETypeId+1);
747        EdgeSzV[ETypeId] = 0;
748        return ETypeId;
749      } else {
750        TStr TempKey;
751        int ETypeId;
752        ETypeH.GetKeyDat(KeyId, TempKey, ETypeId);
753        return ETypeId;
754      }
755    }
756    int GetETypeId(const TStr& ETypeStr) { return ETypeH.GetDat(ETypeStr); }
757    int GetMxEId() const { return MxEId; }
758    int GetEdges() const { return EdgeH.Len(); }
759    int GetEdges(const int& ETypeId) const { return EdgeSzV[ETypeId].Val; }
760    int AddEdge(const int& SrcNId, const int& DstNId, const int& ETypeId, int EId  = -1) {
761      if (EId == -1) { EId = MxEId;  MxEId++; }
762      else { MxEId = TMath::Mx(EId+1, MxEId()); }
763      IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
764      IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
765      EdgeH.AddDat(EId, TEdge(ETypeId, EId, SrcNId, DstNId));
766      GetNode(SrcNId).AddOutNbr(ETypeId, EId);
767      GetNode(DstNId).AddInNbr(ETypeId, EId);
768      EdgeSzV[ETypeId] += 1;
769      return EId;
770    }
771    int AddEdge(const int& SrcNId, const int& DstNId, const TStr& ETypeStr) { return AddEdge(SrcNId, DstNId, GetETypeId(ETypeStr)); }
772    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetTypeId(), EdgeI.GetId()); }
773    void DelEdge(const int& EId) {
774      IAssert(IsEdge(EId));
775      TEdge Edge = GetEdge(EId);
776      int ETypeId = Edge.GetTypeId();
777      const int SrcNId = Edge.GetSrcNId();
778      const int DstNId = Edge.GetDstNId();
779      GetNode(SrcNId).DelOutNbr(ETypeId, EId);
780      GetNode(DstNId).DelInNbr(ETypeId, EId);
781      EdgeH.DelKey(EId);
782      EdgeSzV[ETypeId] -= 1;
783    }
784    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) {
785      int EId;
786      IAssert(IsEdge(SrcNId, DstNId, EId, IsDir)); 
787      while (IsEdge(SrcNId, DstNId, EId, IsDir)) {
788        DelEdge(EId);
789      }
790    }
791    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
792    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
793    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const {
794      const TNode& SrcNode = GetNode(SrcNId);
795      for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
796        const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
797        if (DstNId == Edge.GetDstNId()) {
798          EId = Edge.GetId();
799          return true;
800        }
801      }
802      if (! IsDir) {
803        for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
804          const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
805          if (DstNId == Edge.GetSrcNId()) {
806            EId = Edge.GetId();
807            return true;
808          }
809        }
810      }
811      return false;
812    }
813    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
814    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
815    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
816    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
817    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
818    int GetRndNId(TRnd& Rnd=TInt::Rnd) {
819      int RandN = Rnd.GetUniDevInt(Sz);
820      int Ct = 0;
821      int NTypeId = 0;
822      for (; NTypeId < TypeNodeV.Len(); NTypeId++) {
823        Ct += TypeNodeV[NTypeId].NodeH.Len();
824        if (Ct > RandN) { break; }
825      }
826      return GetRndNId(NTypeId, Rnd);
827    }
828    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
829    int GetRndNId(const int& NTypeId, TRnd& Rnd=TInt::Rnd) {
830      return TypeNodeV[NTypeId].NodeH.GetKey(TypeNodeV[NTypeId].NodeH.GetRndKeyId(Rnd, 0.8));
831    }
832    TNodeI GetRndNI(const int& NTypeId, TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(NTypeId, Rnd)); }
833    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
834    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
835    TPt<TMNet<TNode> > GetSubGraph(const TIntV& NTypeIdV) {
836      TPt<TMNet<TNode> > PNewGraph = New();
837      TMNet<TNode>& NewGraph = *PNewGraph;
838      TIntSet NTypeIdSet(NTypeIdV);
839      for (typename THash<TStr,int>::TIter iter = NTypeH.BegI(); iter < NTypeH.EndI(); iter++) {
840        if (NTypeIdSet.IsKey(TInt(iter.GetDat()))) { NewGraph.NTypeH.AddDat(iter.GetKey(), iter.GetDat()); }
841      }
842      TIntIntH EdgeCounter;
843      for (int i = 0; i < InETypes.Len(); i++) {
844        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
845        for (int j = 0; j < InETypes[i].Len(); j++) {
846          EdgeCounter.AddDat(InETypes[i][j], TInt(1));
847        }
848      }
849      for (int i = 0; i < OutETypes.Len(); i++) {
850        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
851        for (int j = 0; j < OutETypes[i].Len(); j++) {
852          if (EdgeCounter.IsKey(OutETypes[i][j])) { EdgeCounter.AddDat(OutETypes[i][j], TInt(2)); }
853        }
854      }
855      TIntSet ETypeIdSet;
856      for (typename TIntIntH::TIter iter = EdgeCounter.BegI(); iter < EdgeCounter.EndI(); iter++) {
857        if (iter.GetDat().Val == 2) { ETypeIdSet.AddKey(iter.GetKey()); }
858      }
859      for (typename THash<TStr,int>::TIter iter = ETypeH.BegI(); iter < ETypeH.EndI(); iter++) {
860        if (ETypeIdSet.IsKey(TInt(iter.GetDat()))) { NewGraph.ETypeH.AddDat(iter.GetKey(), iter.GetDat()); }
861      }
862      NewGraph.InETypes.Gen(InETypes.Len());
863      for (int i = 0; i < InETypes.Len(); i++) {
864        for (int j = 0; j < InETypes[i].Len(); j++) {
865          int ETypeId = InETypes[i][j];
866          if (ETypeIdSet.IsKey(ETypeId)) { NewGraph.InETypes[i].Add(ETypeId); }
867        }
868      }
869      NewGraph.OutETypes.Gen(OutETypes.Len());
870      for (int i = 0; i < OutETypes.Len(); i++) {
871        for (int j = 0; j < OutETypes[i].Len(); j++) {
872          int ETypeId = OutETypes[i][j];
873          if (ETypeIdSet.IsKey(ETypeId)) { NewGraph.OutETypes[i].Add(ETypeId); }
874        }
875      }
876      NewGraph.Sz = 0;
877      NewGraph.TypeNodeV.Gen(TypeNodeV.Len());
878      for (int NTypeId = 0; NTypeId < TypeNodeV.Len(); NTypeId++) {
879        if (NTypeIdSet.IsKey(NTypeId)) {
880          NewGraph.TypeNodeV[NTypeId] = TNodeType(TypeNodeV[NTypeId], NewGraph.InETypes[NTypeId], NewGraph.OutETypes[NTypeId]);
881          NewGraph.Sz += NewGraph.TypeNodeV[NTypeId].NodeH.Len();
882        } else {
883          NewGraph.TypeNodeV[NTypeId] = TNodeType(TypeNodeV[NTypeId].GetId(), TypeNodeV[NTypeId].GetName());
884        }
885      }
886      NewGraph.MxNId = MxNId;
887      int MaxEId = 0;
888      for (TEdgeI iter = BegEI(); iter < EndEI(); iter++) {
889        if (!ETypeIdSet.IsKey(iter.GetTypeId())) { continue; }
890        int EId = iter.GetId();
891        NewGraph.EdgeH.AddDat(EId, TEdge(iter.GetTypeId(), EId, iter.GetSrcNId(), iter.GetDstNId()));
892        if (MaxEId < EId) { MaxEId = EId; }
893      }
894      NewGraph.MxEId = MaxEId + 1;
895      return PNewGraph;
896    }
897    TPt<TMNet<TNode> > GetSubGraph(const TStrV& NTypeNameV) {
898      TIntV NTypeIdV;
899      for (int i = 0; i < NTypeNameV.Len(); i++) {
900        NTypeIdV.Add(NTypeH.GetDat(NTypeNameV[i]));
901      }
902      return GetSubGraph(NTypeIdV);
903    }
904    PNEANet GetSubGraphTNEANet(const TIntV& NTypeIdV) {
905      TIntSet NTypeIdSet(NTypeIdV);
906      TIntIntH EdgeCounter;
907      for (int i = 0; i < InETypes.Len(); i++) {
908        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
909        for (int j = 0; j < InETypes[i].Len(); j++) {
910          EdgeCounter.AddDat(InETypes[i][j], TInt(1));
911        }
912      }
913      for (int i = 0; i < OutETypes.Len(); i++) {
914        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
915        for (int j = 0; j < OutETypes[i].Len(); j++) {
916          if (EdgeCounter.IsKey(OutETypes[i][j])) { EdgeCounter.AddDat(OutETypes[i][j], TInt(2)); }
917        }
918      }
919      TIntV ETypeIdV;
920      for (typename TIntIntH::TIter iter = EdgeCounter.BegI(); iter < EdgeCounter.EndI(); iter++) {
921        if (iter.GetDat().Val == 2) {
922          ETypeIdV.Add(iter.GetKey());
923        }
924      }
925      return GetSubGraphTNEANet2(NTypeIdV, ETypeIdV);
926    }
927    PNEANet GetSubGraphTNEANet(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
928      PNEANet PNewGraph = PNEANet::New();
929      for (int i = 0; i < NTypeIdV.Len(); i++) {
930        TInt NTypeId = NTypeIdV[i];
931        for (typename THash<TInt,TNode>::TIter iter = TypeNodeV[NTypeId].NodeH.BegI(); iter < TypeNodeV[NTypeId].NodeH.EndI(); iter++) {
932          PNewGraph->AddNode(GetGlobalNId(NTypeId, iter.GetKey().Val));
933        }
934      }
935      TIntSet ETypeIdSet(ETypeIdV);
936      for (TEdgeI iter = BegEI(); iter < EndEI(); iter++) {
937        if (ETypeIdSet.IsKey(iter.GetTypeId())) {
938          PNewGraph->AddEdge(iter.GetSrcNId(), iter.GetDstNId(), iter.GetId());
939        }
940      }
941      return PNewGraph;
942    }
943    PNEANet GetSubGraphTNEANet2(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
944      PNEANet PNewGraph = PNEANet::New();
945      for (int i = 0; i < NTypeIdV.Len(); i++) {
946        TInt NTypeId = NTypeIdV[i];
947        for (typename THash<TInt,TNode>::TIter iter = TypeNodeV[NTypeId].NodeH.BegI(); iter < TypeNodeV[NTypeId].NodeH.EndI(); iter++) {
948          PNewGraph->AddNode(GetGlobalNId(NTypeId, iter.GetKey().Val));
949        }
950      }
951      TIntSet ETypeIdSet(ETypeIdV);
952      TIntV EIdV; 
953      for (int i = 0; i < NTypeIdV.Len(); i++) {
954        TInt NTypeId = NTypeIdV[i];
955        TIntV* POutETypes = &(OutETypes[NTypeId]);
956        TIntV OutETypeIdV;
957        for (TIntV::TIter iter = POutETypes->BegI(); iter < POutETypes->EndI(); iter++) {
958          if (ETypeIdSet.IsKey(*iter)) { OutETypeIdV.Add(*iter); }
959        }
960        for (typename THash<TInt,TNode>::TIter iter = TypeNodeV[NTypeId].NodeH.BegI(); iter < TypeNodeV[NTypeId].NodeH.EndI(); iter++) {
961          TNode* PNode = &(iter.GetDat());
962          for (int j = 0; j < OutETypeIdV.Len(); j++) {
963            PNode->GetOutEIdV(OutETypeIdV.GetVal(j).Val, EIdV);
964            for (int k = 0; k < EIdV.Len(); k++) {
965              TInt EId = EIdV[k];
966              PNewGraph->AddEdge(PNode->GetId(), GetEdge(EId).GetDstNId(), EId);
967            }
968          }
969        }
970      }
971      return PNewGraph;
972    }
973  #ifdef GCC_ATOMIC
974    PNEANetMP GetSubGraphTNEANetMP2(const TIntV& NTypeIdV) {
975      TStopwatch* Sw = TStopwatch::GetInstance();
976      Sw->Start(TStopwatch::ComputeETypes);
977      TIntSet NTypeIdSet(NTypeIdV);
978      TIntIntH EdgeCounter;
979      for (int i = 0; i < InETypes.Len(); i++) {
980        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
981        for (int j = 0; j < InETypes[i].Len(); j++) {
982          EdgeCounter.AddDat(InETypes[i][j], TInt(1));
983        }
984      }
985      for (int i = 0; i < OutETypes.Len(); i++) {
986        if (!NTypeIdSet.IsKey(TInt(i))) { continue; }
987        for (int j = 0; j < OutETypes[i].Len(); j++) {
988          if (EdgeCounter.IsKey(OutETypes[i][j])) { EdgeCounter.AddDat(OutETypes[i][j], TInt(2)); }
989        }
990      }
991      TIntV ETypeIdV;
992      for (typename TIntIntH::TIter iter = EdgeCounter.BegI(); iter < EdgeCounter.EndI(); iter++) {
993        if (iter.GetDat().Val == 2) {
994          ETypeIdV.Add(iter.GetKey());
995        }
996      }
997      Sw->Stop(TStopwatch::ComputeETypes);
998      return GetSubGraphTNEANetMP2(NTypeIdV, ETypeIdV);
999    }
1000    PNEANetMP GetSubGraphTNEANetMP(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
1001      TStopwatch* Sw = TStopwatch::GetInstance();
1002      Sw->Start(TStopwatch::EstimateSizes);
1003      int SubgraphSz = 0;
1004      for (TIntV::TIter iter = NTypeIdV.BegI(); iter < NTypeIdV.EndI(); iter++) {
1005        SubgraphSz += GetNodes((*iter).Val);
1006      }
1007      int SubgraphEdgeSz = 0;
1008      for (TIntV::TIter iter = ETypeIdV.BegI(); iter < ETypeIdV.EndI(); iter++) {
1009        SubgraphEdgeSz += GetEdges((*iter).Val);
1010      }
1011      Sw->Stop(TStopwatch::EstimateSizes);
1012      Sw->Start(TStopwatch::InitGraph);
1013      PNEANetMP PNewGraph = TNEANetMP::New(SubgraphSz, SubgraphEdgeSz);
1014      TIntSet ETypeIdSet(ETypeIdV);
1015      Sw->Stop(TStopwatch::InitGraph);
1016      TIntV OutETypeIdVV[NTypeIdV.Len()];
1017      TIntV InETypeIdVV[NTypeIdV.Len()];
1018      Sw->Start(TStopwatch::ExtractNbrETypes);
1019      #pragma omp parallel for schedule(static)
1020      for (int i = 0; i < NTypeIdV.Len(); i++) {
1021        TInt NTypeId = NTypeIdV[i];
1022        TIntV* POutETypes = &(OutETypes[NTypeId]);
1023        for (TIntV::TIter iter = POutETypes->BegI(); iter < POutETypes->EndI(); iter++) {
1024          if (ETypeIdSet.IsKey(*iter)) { OutETypeIdVV[i].Add(*iter); }
1025        }
1026        TIntV* PInETypes = &(InETypes[NTypeId]);
1027        for (TIntV::TIter iter = PInETypes->BegI(); iter < PInETypes->EndI(); iter++) {
1028          if (ETypeIdSet.IsKey(*iter)) { InETypeIdVV[i].Add(*iter); }
1029        }
1030      }
1031      Sw->Stop(TStopwatch::ExtractNbrETypes);
1032      TIntV Offsets(NTypeIdV.Len()+1);
1033      Offsets[0] = 0;
1034      for (int i = 0; i < NTypeIdV.Len(); i++) {
1035        Offsets[i+1] = Offsets[i] + TypeNodeV[NTypeIdV[i]].NodeH.GetMxKeyIds();
1036      }
1037      Sw->Start(TStopwatch::PopulateGraph);
1038      #pragma omp parallel for schedule(static)
1039      for (int j = 0; j < Offsets[NTypeIdV.Len()]; j++) {
1040        int i;
1041        Offsets.SearchBinLeft(j, i);
1042        THash<TInt,TNode> *NodeHPtr = &(TypeNodeV[NTypeIdV[i]].NodeH);
1043        int KeyId = j - Offsets[i];
1044        if (!NodeHPtr->IsKeyId(KeyId)) { continue; }
1045        TNode* PNode = &((*NodeHPtr)[KeyId]);
1046        int NId = PNode->GetId();
1047        TIntV EIdV;
1048        TIntV OutEIdV;
1049        for (TIntV::TIter iter = OutETypeIdVV[i].BegI(); iter < OutETypeIdVV[i].EndI(); iter++) {
1050          PNode->GetOutEIdV((*iter).Val, EIdV);
1051          OutEIdV.AddV(EIdV);
1052        }
1053        TIntV InEIdV;
1054        for (TIntV::TIter iter = InETypeIdVV[i].BegI(); iter < InETypeIdVV[i].EndI(); iter++) {
1055          PNode->GetInEIdV((*iter).Val, EIdV);
1056          InEIdV.AddV(EIdV);
1057        }
1058        PNewGraph->AddNodeWithEdges(NId, InEIdV, OutEIdV);
1059        for (TIntV::TIter iter = OutEIdV.BegI(); iter < OutEIdV.EndI(); iter++) {
1060          PNewGraph->AddEdgeUnchecked((*iter), NId, GetEdge(*iter).GetDstNId());
1061        }
1062      }
1063      Sw->Stop(TStopwatch::PopulateGraph);
1064      PNewGraph->SetNodes(SubgraphSz);
1065      PNewGraph->SetEdges(SubgraphEdgeSz);
1066      return PNewGraph;
1067    }
1068    PNEANetMP GetSubGraphTNEANetMP2(const TIntV& NTypeIdV, const TIntV& ETypeIdV) {
1069      TStopwatch* Sw = TStopwatch::GetInstance();
1070      Sw->Start(TStopwatch::EstimateSizes);
1071      int SubgraphSz = 0;
1072      for (TIntV::TIter iter = NTypeIdV.BegI(); iter < NTypeIdV.EndI(); iter++) {
1073        SubgraphSz += GetNodes((*iter).Val);
1074      }
1075      int SubgraphEdgeSz = 0;
1076      for (TIntV::TIter iter = ETypeIdV.BegI(); iter < ETypeIdV.EndI(); iter++) {
1077        SubgraphEdgeSz += GetEdges((*iter).Val);
1078      }
1079      Sw->Stop(TStopwatch::EstimateSizes);
1080      Sw->Start(TStopwatch::InitGraph);
1081      PNEANetMP PNewGraph = TNEANetMP::New(SubgraphSz, SubgraphEdgeSz);
1082      TIntSet ETypeIdSet(ETypeIdV);
1083      Sw->Stop(TStopwatch::InitGraph);
1084      for (int i = 0; i < NTypeIdV.Len(); i++) {
1085        Sw->Start(TStopwatch::ExtractNbrETypes);
1086        TInt NTypeId = NTypeIdV[i];
1087        TIntV* POutETypes = &(OutETypes[NTypeId]);
1088        TIntV OutETypeIdV;
1089        for (TIntV::TIter iter = POutETypes->BegI(); iter < POutETypes->EndI(); iter++) {
1090          if (ETypeIdSet.IsKey(*iter)) { OutETypeIdV.Add(*iter); }
1091        }
1092        TIntV* PInETypes = &(InETypes[NTypeId]);
1093        TIntV InETypeIdV;
1094        for (TIntV::TIter iter = PInETypes->BegI(); iter < PInETypes->EndI(); iter++) {
1095          if (ETypeIdSet.IsKey(*iter)) { InETypeIdV.Add(*iter); }
1096        }
1097        Sw->Stop(TStopwatch::ExtractNbrETypes);
1098        Sw->Start(TStopwatch::PopulateGraph);
1099        THash<TInt,TNode> *NodeHPtr = &(TypeNodeV[NTypeId].NodeH);
1100        #pragma omp parallel for schedule(static)
1101        for (int KeyId = 0; KeyId < NodeHPtr->GetMxKeyIds(); KeyId++) {
1102          if (!NodeHPtr->IsKeyId(KeyId)) { continue; }
1103          TIntV OutEIdV;
1104          TIntV InEIdV;
1105          TNode* PNode = &((*NodeHPtr)[KeyId]);
1106          int NId = PNode->GetId();
1107          PNode->GetOutEIdV(OutETypeIdV, OutEIdV);
1108          PNode->GetInEIdV(InETypeIdV, InEIdV);
<span onclick='openModal()' class='match'>1109          PNewGraph->AddNodeWithEdges(NId, InEIdV, OutEIdV);
1110          for (TIntV::TIter iter = OutEIdV.BegI(); iter < OutEIdV.EndI(); iter++) {
1111            PNewGraph->AddEdgeUnchecked((*iter), NId, GetEdge(*iter).GetDstNId());
</span>1112          }
1113        }
1114        Sw->Stop(TStopwatch::PopulateGraph);
1115      }
1116      PNewGraph->SetNodes(SubgraphSz);
1117      PNewGraph->SetEdges(SubgraphEdgeSz);
1118      return PNewGraph;
1119    }
1120  #endif 
1121    friend class TPt<TMNet>;
1122  };
1123  typedef TMNet<TSVNode> TSVNet;
1124  typedef TPt<TSVNet> PSVNet;
1125  typedef TMNet<TMVNode> TMVNet;
1126  typedef TPt<TMVNet> PMVNet;
1127  typedef TMNet<TCVNode> TCVNet;
1128  typedef TPt<TCVNet> PCVNet;
1129  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ff.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmgraph-exp.h</div>
                </div>
                <div class="column column_space"><pre><code>98          AliveNIdV.Shuffle(Rnd);
99          for (int i = 0; i < TMath::Mn(BurnNFwdLinks, AliveNIdV.Len()); i++) {
100            BurnedNIdH.AddDat(AliveNIdV[i]);
101            NewBurnedNIdV.Add(AliveNIdV[i]);  NBurned++; }
</pre></code></div>
                <div class="column column_space"><pre><code>1109          PNewGraph->AddNodeWithEdges(NId, InEIdV, OutEIdV);
1110          for (TIntV::TIter iter = OutEIdV.BegI(); iter < OutEIdV.EndI(); iter++) {
1111            PNewGraph->AddEdgeUnchecked((*iter), NId, GetEdge(*iter).GetDstNId());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    