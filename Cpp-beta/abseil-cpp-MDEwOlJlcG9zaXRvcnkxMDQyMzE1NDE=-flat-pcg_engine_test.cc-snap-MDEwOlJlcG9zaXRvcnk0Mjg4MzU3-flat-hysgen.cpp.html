
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1537450722733245%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-pcg_engine_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/pcg_engine.h"
2  #include <algorithm>
3  #include <bitset>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/random/internal/explicit_seed_seq.h"
9  #include "absl/time/clock.h"
10  #define UPDATE_GOLDEN 0
11  namespace {
12  using absl::random_internal::ExplicitSeedSeq;
13  using absl::random_internal::pcg32_2018_engine;
14  using absl::random_internal::pcg64_2018_engine;
15  template <typename EngineType>
16  class PCGEngineTest : public ::testing::Test {};
17  using EngineTypes = ::testing::Types<pcg64_2018_engine, pcg32_2018_engine>;
18  TYPED_TEST_SUITE(PCGEngineTest, EngineTypes);
19  TYPED_TEST(PCGEngineTest, VerifyReseedChangesAllValues) {
20    using engine_type = TypeParam;
21    using result_type = typename engine_type::result_type;
22    const size_t kNumOutputs = 16;
23    engine_type engine;
24    {
25      std::seed_seq seq1{1, 2, 3, 4, 5, 6, 7};
26      engine.seed(seq1);
27    }
28    result_type a[kNumOutputs];
29    std::generate(std::begin(a), std::end(a), std::ref(engine));
30    {
31      std::random_device rd;
32      std::seed_seq seq2{rd(), rd(), rd()};
33      engine.seed(seq2);
34    }
35    result_type b[kNumOutputs];
36    std::generate(std::begin(b), std::end(b), std::ref(engine));
37    size_t changed_bits = 0;
38    size_t unchanged_bits = 0;
39    size_t total_set = 0;
40    size_t total_bits = 0;
41    size_t equal_count = 0;
42    for (size_t i = 0; i < kNumOutputs; ++i) {
43      equal_count += (a[i] == b[i]) ? 1 : 0;
44      std::bitset<sizeof(result_type) * 8> bitset(a[i] ^ b[i]);
45      changed_bits += bitset.count();
46      unchanged_bits += bitset.size() - bitset.count();
47      std::bitset<sizeof(result_type) * 8> a_set(a[i]);
48      std::bitset<sizeof(result_type) * 8> b_set(b[i]);
49      total_set += a_set.count() + b_set.count();
50      total_bits += 2 * 8 * sizeof(result_type);
51    }
52    EXPECT_LE(changed_bits, 0.60 * (changed_bits + unchanged_bits));
53    EXPECT_GE(changed_bits, 0.40 * (changed_bits + unchanged_bits));
54    EXPECT_NEAR(total_set, total_bits * 0.5, 4 * std::sqrt(total_bits))
55        << "@" << total_set / static_cast<double>(total_bits);
56    const double kExpected = kNumOutputs / (1.0 * sizeof(result_type) * 8);
57    EXPECT_LE(equal_count, 1.0 + kExpected);
58  }
59  constexpr size_t kTwoBufferValues = 16;
60  TYPED_TEST(PCGEngineTest, VerifyDiscard) {
61    using engine_type = TypeParam;
62    for (size_t num_used = 0; num_used < kTwoBufferValues; ++num_used) {
63      engine_type engine_used;
64      for (size_t i = 0; i < num_used; ++i) {
65        engine_used();
66      }
67      for (size_t num_discard = 0; num_discard < kTwoBufferValues;
68           ++num_discard) {
69        engine_type engine1 = engine_used;
70        engine_type engine2 = engine_used;
71        for (size_t i = 0; i < num_discard; ++i) {
72          engine1();
73        }
74        engine2.discard(num_discard);
75        for (size_t i = 0; i < kTwoBufferValues; ++i) {
76          const auto r1 = engine1();
77          const auto r2 = engine2();
78          ASSERT_EQ(r1, r2) << "used=" << num_used << " discard=" << num_discard;
79        }
80      }
81    }
82  }
<span onclick='openModal()' class='match'>83  TYPED_TEST(PCGEngineTest, StreamOperatorsResult) {
84    using engine_type = TypeParam;
85    std::wostringstream os;
86    std::wistringstream is;
87    engine_type engine;
88    EXPECT_EQ(&(os << engine), &os);
89    EXPECT_EQ(&(is >> engine), &is);
90  }
91  TYPED_TEST(PCGEngineTest, StreamSerialization) {
</span>92    using engine_type = TypeParam;
93    for (size_t discard = 0; discard < kTwoBufferValues; ++discard) {
94      ExplicitSeedSeq seed_sequence{12, 34, 56};
95      engine_type engine(seed_sequence);
96      engine.discard(discard);
97      std::stringstream stream;
98      stream << engine;
99      engine_type new_engine;
100      stream >> new_engine;
101      for (size_t i = 0; i < 64; ++i) {
102        EXPECT_EQ(engine(), new_engine()) << " " << i;
103      }
104    }
105  }
106  constexpr size_t kNumGoldenOutputs = 127;
107  TYPED_TEST(PCGEngineTest, RandomNumberEngineInterface) {
108    using engine_type = TypeParam;
109    using E = engine_type;
110    using T = typename E::result_type;
111    static_assert(std::is_copy_constructible<E>::value,
112                  "engine_type must be copy constructible");
113    static_assert(absl::is_copy_assignable<E>::value,
114                  "engine_type must be copy assignable");
115    static_assert(std::is_move_constructible<E>::value,
116                  "engine_type must be move constructible");
117    static_assert(absl::is_move_assignable<E>::value,
118                  "engine_type must be move assignable");
119    static_assert(std::is_same<decltype(std::declval<E>()()), T>::value,
120                  "return type of operator() must be result_type");
121    E e, v;
122    const E x, y;
123    T s = 1;
124    std::seed_seq q{1, 2, 3};
125    unsigned long long z = 1;  
126    std::wostringstream os;
127    std::wistringstream is;
128    E{};
129    E{x};
130    E{s};
131    E{q};
132    e.seed();
133    EXPECT_TRUE(e == x);
134    e.seed(q);
135    {
136      E tmp(q);
137      EXPECT_TRUE(e == tmp);
138    }
139    e();
140    {
141      E tmp(q);
142      EXPECT_TRUE(e != tmp);
143    }
144    e.discard(z);
145    static_assert(std::is_same<decltype(x == y), bool>::value,
146                  "return type of operator== must be bool");
147    static_assert(std::is_same<decltype(x != y), bool>::value,
148                  "return type of operator== must be bool");
149  }
150  TYPED_TEST(PCGEngineTest, RandenEngineSFINAETest) {
151    using engine_type = TypeParam;
152    using result_type = typename engine_type::result_type;
153    {
154      engine_type engine(result_type(1));
155      engine.seed(result_type(1));
156    }
157    {
158      result_type n = 1;
159      engine_type engine(n);
160      engine.seed(n);
161    }
162    {
163      engine_type engine(1);
164      engine.seed(1);
165    }
166    {
167      int n = 1;
168      engine_type engine(n);
169      engine.seed(n);
170    }
171    {
172      std::seed_seq seed_seq;
173      engine_type engine(seed_seq);
174      engine.seed(seed_seq);
175    }
176    {
177      engine_type engine{std::seed_seq()};
178      engine.seed(std::seed_seq());
179    }
180  }
181  TEST(PCG642018EngineTest, VerifyGolden) {
182    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
183        0x01070196e695f8f1, 0x703ec840c59f4493, 0xe54954914b3a44fa,
184        0x96130ff204b9285e, 0x7d9fdef535ceb21a, 0x666feed42e1219a0,
185        0x981f685721c8326f, 0xad80710d6eab4dda, 0xe202c480b037a029,
186        0x5d3390eaedd907e2, 0x0756befb39c6b8aa, 0x1fb44ba6634d62a3,
187        0x8d20423662426642, 0x34ea910167a39fb4, 0x93010b43a80d0ab6,
188        0x663db08a98fc568a, 0x720b0a1335956fae, 0x2c35483e31e1d3ba,
189        0x429f39776337409d, 0xb46d99e638687344, 0x105370b96aedcaee,
190        0x3999e92f811cff71, 0xd230f8bcb591cfc9, 0x0dce3db2ba7bdea5,
191        0xcf2f52c91eec99af, 0x2bc7c24a8b998a39, 0xbd8af1b0d599a19c,
192        0x56bc45abc66059f5, 0x170a46dc170f7f1e, 0xc25daf5277b85fad,
193        0xe629c2e0c948eadb, 0x1720a796915542ed, 0x22fb0caa4f909951,
194        0x7e0c0f4175acd83d, 0xd9fcab37ff2a860c, 0xab2280fb2054bad1,
195        0x58e8a06f37fa9e99, 0xc3a52a30b06528c7, 0x0175f773a13fc1bd,
196        0x731cfc584b00e840, 0x404cc7b2648069cb, 0x5bc29153b0b7f783,
197        0x771310a38cc999d1, 0x766a572f0a71a916, 0x90f450fb4fc48348,
198        0xf080ea3e1c7b1a0d, 0x15471a4507d66a44, 0x7d58e55a78f3df69,
199        0x0130a094576ac99c, 0x46669cb2d04b1d87, 0x17ab5bed20191840,
200        0x95b177d260adff3e, 0x025fb624b6ee4c07, 0xb35de4330154a95f,
201        0xe8510fff67e24c79, 0x132c3cbcd76ed2d3, 0x35e7cc145a093904,
202        0x9f5b5b5f81583b79, 0x3ee749a533966233, 0x4af85886cdeda8cd,
203        0x0ca5380ecb3ef3aa, 0x4f674eb7661d3192, 0x88a29aad00cd7733,
204        0x70b627ca045ffac6, 0x5912b43ea887623d, 0x95dc9fc6f62cf221,
205        0x926081a12a5c905b, 0x9c57d4cd7dfce651, 0x85ab2cbf23e3bb5d,
206        0xc5cd669f63023152, 0x3067be0fad5d898e, 0x12b56f444cb53d05,
207        0xbc2e5a640c3434fc, 0x9280bff0e4613fe1, 0x98819094c528743e,
208        0x999d1c98d829df33, 0x9ff82a012dc89242, 0xf99183ed39c8be94,
209        0xf0f59161cd421c55, 0x3c705730c2f6c48d, 0x66ad85c6e9278a61,
210        0x2a3428e4a428d5d0, 0x79207d68fd04940d, 0xea7f2b402edc8430,
211        0xa06b419ac857f63b, 0xcb1dd0e6fbc47e1c, 0x4f55229200ada6a4,
212        0x9647b5e6359c927f, 0x30bf8f9197c7efe5, 0xa79519529cc384d0,
213        0xbb22c4f339ad6497, 0xd7b9782f59d14175, 0x0dff12fff2ec0118,
214        0xa331ad8305343a7c, 0x48dad7e3f17e0862, 0x324c6fb3fd3c9665,
215        0xf0e4350e7933dfc4, 0x7ccda2f30b8b03b6, 0xa0afc6179005de40,
216        0xee65da6d063b3a30, 0xb9506f42f2bfe87a, 0xc9a2e26b0ef5baa0,
217        0x39fa9d4f495011d6, 0xbecc21a45d023948, 0x6bf484c6593f737f,
218        0x8065e0070cadc3b7, 0x9ef617ed8d419799, 0xac692cf8c233dd15,
219        0xd2ed87583c4ebb98, 0xad95ba1bebfedc62, 0x9b60b160a8264e43,
220        0x0bc8c45f71fcf25b, 0x4a78035cdf1c9931, 0x4602dc106667e029,
221        0xb335a3c250498ac8, 0x0256ebc4df20cab8, 0x0c61efd153f0c8d9,
222        0xe5d0150a4f806f88, 0x99d6521d351e7d87, 0x8d4888c9f80f4325,
223        0x106c5735c1ba868d, 0x73414881b880a878, 0x808a9a58a3064751,
224        0x339a29f3746de3d5, 0x5410d7fa4f873896, 0xd84623c81d7b8a03,
225        0x1f7c7e7a7f47f462,
226    };
227    pcg64_2018_engine engine(0);
228  #if UPDATE_GOLDEN
229    (void)kGolden;  
230    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
231      printf("0x%016lx, ", engine());
232      if (i % 3 == 2) {
233        printf("\n");
234      }
235    }
236    printf("\n\n\n");
237  #else
238    for (const auto& elem : kGolden) {
239      EXPECT_EQ(elem, engine());
240    }
241    engine.seed();
242    for (const auto& elem : kGolden) {
243      EXPECT_EQ(elem, engine());
244    }
245  #endif
246  }
247  TEST(PCG642018EngineTest, VerifyGoldenSeeded) {
248    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
249        0xb03988f1e39691ee, 0xbd2a1eb5ac31e97a, 0x8f00d6d433634d02,
250        0x1823c28d483d5776, 0x000c3ee3e1aeb74a, 0xfa82ef27a4f3df9c,
251        0xc6f382308654e454, 0x414afb1a238996c2, 0x4703a4bc252eb411,
252        0x99d64f62c8f7f654, 0xbb07ebe11a34fa44, 0x79eb06a363c06131,
253        0xf66ad3756f1c6b21, 0x130c01d5e869f457, 0x5ca2b9963aecbc81,
254        0xfef7bebc1de27e6c, 0x1d174faa5ed2cdbf, 0xd75b7a773f2bb889,
255        0xc35c872327a170a5, 0x46da6d88646a42fe, 0x4622985e0442dae2,
256        0xbe3cbd67297f1f9b, 0xe7c37b4a4798bfd1, 0x173d5dfad15a25c3,
257        0x0eb6849ba2961522, 0xb0ff7246e6700d73, 0x88cb9c42d3afa577,
258        0xb609731dbd94d917, 0xd3941cda04b40081, 0x28d140f7409bea3a,
259        0x3c96699a920a124a, 0xdb28be521958b2fd, 0x0a3f44db3d4c5124,
260        0x7ac8e60ba13b70d2, 0x75f03a41ded5195a, 0xaed10ac7c4e4825d,
261        0xb92a3b18aadb7adc, 0xda45e0081f2bca46, 0x74d39ab3753143fc,
262        0xb686038018fac9ca, 0x4cc309fe99542dbb, 0xf3e1a4fcb311097c,
263        0x58763d6fa698d69d, 0xd11c365dbecd8d60, 0x2c15d55725b1dee7,
264        0x89805f254d85658c, 0x2374c44dfc62158b, 0x9a8350fa7995328d,
265        0x198f838970cf91da, 0x96aff569562c0e53, 0xd76c8c52b7ec6e3f,
266        0x23a01cd9ae4baa81, 0x3adb366b6d02a893, 0xb3313e2a4c5b333f,
267        0x04c11230b96a5425, 0x1f7f7af04787d571, 0xaddb019365275ec7,
268        0x5c960468ccb09f42, 0x8438db698c69a44a, 0x492be1e46111637e,
269        0x9c6c01e18100c610, 0xbfe48e75b7d0aceb, 0xb5e0b89ec1ce6a00,
270        0x9d280ecbc2fe8997, 0x290d9e991ba5fcab, 0xeec5bec7d9d2a4f0,
271        0x726e81488f19150e, 0x1a6df7955a7e462c, 0x37a12d174ba46bb5,
272        0x3cdcdffd96b1b5c5, 0x2c5d5ac10661a26e, 0xa742ed18f22e50c4,
273        0x00e0ed88ff0d8a35, 0x3d3c1718cb1efc0b, 0x1d70c51ffbccbf11,
274        0xfbbb895132a4092f, 0x619d27f2fb095f24, 0x69af68200985e5c4,
275        0xbee4885f57373f8d, 0x10b7a6bfe0587e40, 0xa885e6cf2f7e5f0a,
276        0x59f879464f767550, 0x24e805d69056990d, 0x860970b911095891,
277        0xca3189954f84170d, 0x6652a5edd4590134, 0x5e1008cef76174bf,
278        0xcbd417881f2bcfe5, 0xfd49fc9d706ecd17, 0xeebf540221ebd066,
279        0x46af7679464504cb, 0xd4028486946956f1, 0xd4f41864b86c2103,
280        0x7af090e751583372, 0x98cdaa09278cb642, 0xffd42b921215602f,
281        0x1d05bec8466b1740, 0xf036fa78a0132044, 0x787880589d1ecc78,
282        0x5644552cfef33230, 0x0a97e275fe06884b, 0x96d1b13333d470b5,
283        0xc8b3cdad52d3b034, 0x091357b9db7376fd, 0xa5fe4232555edf8c,
284        0x3371bc3b6ada76b5, 0x7deeb2300477c995, 0x6fc6d4244f2849c1,
285        0x750e8cc797ca340a, 0x81728613cd79899f, 0x3467f4ee6f9aeb93,
286        0x5ef0a905f58c640f, 0x432db85e5101c98a, 0x6488e96f46ac80c2,
287        0x22fddb282625048c, 0x15b287a0bc2d4c5d, 0xa7e2343ef1f28bce,
288        0xc87ee1aa89bed09e, 0x220610107812c5e9, 0xcbdab6fcd640f586,
289        0x8d41047970928784, 0x1aa431509ec1ade0, 0xac3f0be53f518ddc,
290        0x16f4428ad81d0cbb, 0x675b13c2736fc4bb, 0x6db073afdd87e32d,
291        0x572f3ca2f1a078c6,
292    };
293    ExplicitSeedSeq seed_sequence{12, 34, 56};
294    pcg64_2018_engine engine(seed_sequence);
295  #if UPDATE_GOLDEN
296    (void)kGolden;  
297    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
298      printf("0x%016lx, ", engine());
299      if (i % 3 == 2) {
300        printf("\n");
301      }
302    }
303    printf("\n\n\n");
304  #else
305    for (const auto& elem : kGolden) {
306      EXPECT_EQ(elem, engine());
307    }
308    engine.seed(seed_sequence);
309    for (const auto& elem : kGolden) {
310      EXPECT_EQ(elem, engine());
311    }
312  #endif
313  }
314  TEST(PCG642018EngineTest, VerifyGoldenFromDeserializedEngine) {
315    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
316        0xdd425b47b4113dea, 0x1b07176479d444b0, 0x6b391027586f2e42,
317        0xa166f2b15f4a2143, 0xffb6dbd7a179ee97, 0xb2c00035365bf0b1,
318        0x8fbb518b45855521, 0xfc789a55ddf87c3b, 0x429531f0f17ff355,
319        0xbe708560d603d283, 0x5bff415175c5cb6b, 0xe813491f4ad45394,
320        0xa853f4506d55880d, 0x7e538453e568172e, 0xe101f1e098ddd0ec,
321        0x6ee31266ee4c766d, 0xa8786d92d66b39d7, 0xfee622a2acf5e5b0,
322        0x5fe8e82c102fa7b3, 0x01f10be4cdb53c9d, 0xbe0545366f857022,
323        0x12e74f010a339bca, 0xb10d85ca40d5ce34, 0xe80d6feba5054875,
324        0x2b7c1ee6d567d4ee, 0x2a9cd043bfd03b66, 0x5cfc531bd239f3f1,
325        0x1c4734e4647d70f5, 0x85a8f60f006b5760, 0x6a4239ce76dca387,
326        0x8da0f86d7339335c, 0xf055b0468551374d, 0x486e8567e9bea9a0,
327        0x4cb531b8405192dd, 0xf813b1ee3157110b, 0x214c2a664a875d8e,
328        0x74531237b29b35f7, 0xa6f0267bb77a771e, 0x64b552bff54184a4,
329        0xa2d6f7af2d75b6fc, 0x460a10018e03b5ab, 0x76fd1fdcb81d0800,
330        0x76f5f81805070d9d, 0x1fb75cb1a70b289a, 0x9dfd25a022c4b27f,
331        0x9a31a14a80528e9e, 0x910dc565ddc25820, 0xd6aef8e2b0936c10,
332        0xe1773c507fe70225, 0xe027fd7aadd632bc, 0xc1fecb427089c8b8,
333        0xb5c74c69fa9dbf26, 0x71bf9b0e4670227d, 0x25f48fad205dcfdd,
334        0x905248ec4d689c56, 0x5c2b7631b0de5c9d, 0x9f2ee0f8f485036c,
335        0xfd6ce4ebb90bf7ea, 0xd435d20046085574, 0x6b7eadcb0625f986,
336        0x679d7d44b48be89e, 0x49683b8e1cdc49de, 0x4366cf76e9a2f4ca,
337        0x54026ec1cdad7bed, 0xa9a04385207f28d3, 0xc8e66de4eba074b2,
338        0x40b08c42de0f4cc0, 0x1d4c5e0e93c5bbc0, 0x19b80792e470ae2d,
339        0x6fcaaeaa4c2a5bd9, 0xa92cb07c4238438e, 0x8bb5c918a007e298,
340        0x7cd671e944874cf4, 0x88166470b1ba3cac, 0xd013d476eaeeade6,
341        0xcee416947189b3c3, 0x5d7c16ab0dce6088, 0xd3578a5c32b13d27,
342        0x3875db5adc9cc973, 0xfbdaba01c5b5dc56, 0xffc4fdd391b231c3,
343        0x2334520ecb164fec, 0x361c115e7b6de1fa, 0xeee58106cc3563d7,
344        0x8b7f35a8db25ebb8, 0xb29d00211e2cafa6, 0x22a39fe4614b646b,
345        0x92ca6de8b998506d, 0x40922fe3d388d1db, 0x9da47f1e540f802a,
346        0x811dceebf16a25db, 0xf6524ae22e0e53a9, 0x52d9e780a16eb99d,
347        0x4f504286bb830207, 0xf6654d4786bd5cc3, 0x00bd98316003a7e1,
348        0xefda054a6ab8f5f3, 0x46cfb0f4c1872827, 0xc22b316965c0f3b2,
349        0xd1a28087c7e7562a, 0xaa4f6a094b7f5cff, 0xfe2bc853a041f7da,
350        0xe9d531402a83c3ba, 0xe545d8663d3ce4dd, 0xfa2dcd7d91a13fa8,
351        0xda1a080e52a127b8, 0x19c98f1f809c3d84, 0x2cef109af4678c88,
352        0x53462accab3b9132, 0x176b13a80415394e, 0xea70047ef6bc178b,
353        0x57bca80506d6dcdf, 0xd853ba09ff09f5c4, 0x75f4df3a7ddd4775,
354        0x209c367ade62f4fe, 0xa9a0bbc74d5f4682, 0x5dfe34bada86c21a,
355        0xc2c05bbcd38566d1, 0x6de8088e348c916a, 0x6a7001c6000c2196,
356        0xd9fb51865fc4a367, 0x12f320e444ece8ff, 0x6d56f7f793d65035,
357        0x138f31b7a865f8aa, 0x58fc68b4026b9adf, 0xcd48954b79fb6436,
358        0x27dfce4a0232af87,
359    };
360  #if UPDATE_GOLDEN
361    (void)kGolden;  
362    std::seed_seq seed_sequence{1, 2, 3};
363    pcg64_2018_engine engine(seed_sequence);
364    std::ostringstream stream;
365    stream << engine;
366    auto str = stream.str();
367    printf("%s\n\n", str.c_str());
368    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
369      printf("0x%016lx, ", engine());
370      if (i % 3 == 2) {
371        printf("\n");
372      }
373    }
374    printf("\n\n\n");
375  #else
376    pcg64_2018_engine engine;
377    std::istringstream stream(
378        "2549297995355413924 4865540595714422341 6364136223846793005 "
379        "1442695040888963407 18088519957565336995 4845369368158826708");
380    stream >> engine;
381    for (const auto& elem : kGolden) {
382      EXPECT_EQ(elem, engine());
383    }
384  #endif
385  }
386  TEST(PCG322018EngineTest, VerifyGolden) {
387    constexpr uint32_t kGolden[kNumGoldenOutputs] = {
388        0x7a7ecbd9, 0x89fd6c06, 0xae646aa8, 0xcd3cf945, 0x6204b303, 0x198c8585,
389        0x49fce611, 0xd1e9297a, 0x142d9440, 0xee75f56b, 0x473a9117, 0xe3a45903,
390        0xbce807a1, 0xe54e5f4d, 0x497d6c51, 0x61829166, 0xa740474b, 0x031912a8,
391        0x9de3defa, 0xd266dbf1, 0x0f38bebb, 0xec3c4f65, 0x07c5057d, 0xbbce03c8,
392        0xfd2ac7a8, 0xffcf4773, 0x5b10affb, 0xede1c842, 0xe22b01b7, 0xda133c8c,
393        0xaf89b0f4, 0x25d1b8bc, 0x9f625482, 0x7bfd6882, 0x2e2210c0, 0x2c8fb9a6,
394        0x42cb3b83, 0x40ce0dab, 0x644a3510, 0x36230ef2, 0xe2cb6d43, 0x1012b343,
395        0x746c6c9f, 0x36714cf8, 0xed1f5026, 0x8bbbf83e, 0xe98710f4, 0x8a2afa36,
396        0x09035349, 0x6dc1a487, 0x682b634b, 0xc106794f, 0x7dd78beb, 0x628c262b,
397        0x852fb232, 0xb153ac4c, 0x4f169d1b, 0xa69ab774, 0x4bd4b6f2, 0xdc351dd3,
398        0x93ff3c8c, 0xa30819ab, 0xff07758c, 0x5ab13c62, 0xd16d7fb5, 0xc4950ffa,
399        0xd309ae49, 0xb9677a87, 0x4464e317, 0x90dc44f1, 0xc694c1d4, 0x1d5e1168,
400        0xadf37a2d, 0xda38990d, 0x1ec4bd33, 0x36ca25ce, 0xfa0dc76a, 0x968a9d43,
401        0x6950ac39, 0xdd3276bc, 0x06d5a71e, 0x1f6f282d, 0x5c626c62, 0xdde3fc31,
402        0x152194ce, 0xc35ed14c, 0xb1f7224e, 0x47f76bb8, 0xb34fdd08, 0x7011395e,
403        0x162d2a49, 0x0d1bf09f, 0x9428a952, 0x03c5c344, 0xd3525616, 0x7816fff3,
404        0x6bceb8a8, 0x8345a081, 0x366420fd, 0x182abeda, 0x70f82745, 0xaf15ded8,
405        0xc7f52ca2, 0xa98db9c5, 0x919d99ba, 0x9c376c1c, 0xed8d34c2, 0x716ae9f5,
406        0xef062fa5, 0xee3b6c56, 0x52325658, 0x61afa9c3, 0xfdaf02f0, 0x961cf3ab,
407        0x9f291565, 0x4fbf3045, 0x0590c899, 0xde901385, 0x45005ffb, 0x509db162,
408        0x262fa941, 0x4c421653, 0x4b17c21e, 0xea0d1530, 0xde803845, 0x61bfd515,
409        0x438523ef,
410    };
411    pcg32_2018_engine engine(0);
412  #if UPDATE_GOLDEN
413    (void)kGolden;  
414    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
415      printf("0x%08x, ", engine());
416      if (i % 6 == 5) {
417        printf("\n");
418      }
419    }
420    printf("\n\n\n");
421  #else
422    for (const auto& elem : kGolden) {
423      EXPECT_EQ(elem, engine());
424    }
425    engine.seed();
426    for (const auto& elem : kGolden) {
427      EXPECT_EQ(elem, engine());
428    }
429  #endif
430  }
431  TEST(PCG322018EngineTest, VerifyGoldenSeeded) {
432    constexpr uint32_t kGolden[kNumGoldenOutputs] = {
433        0x60b5a64c, 0x978502f9, 0x80a75f60, 0x241f1158, 0xa4cd1dbb, 0xe7284017,
434        0x3b678da5, 0x5223ec99, 0xe4bdd5d9, 0x72190e6d, 0xe6e702c9, 0xff80c768,
435        0xcf126ed3, 0x1fbd20ab, 0x60980489, 0xbc72bf89, 0x407ac6c0, 0x00bf3c51,
436        0xf9087897, 0x172e4eb6, 0xe9e4f443, 0x1a6098bf, 0xbf44f8c2, 0xdd84a0e5,
437        0xd9a52364, 0xc0e2e786, 0x061ae2ba, 0x9facb8e3, 0x6109432d, 0xd4e0a013,
438        0xbd8eb9a6, 0x7e86c3b6, 0x629c0e68, 0x05337430, 0xb495b9f4, 0x11ccd65d,
439        0xb578db25, 0x66f1246d, 0x6ef20a7f, 0x5e429812, 0x11772130, 0xb944b5c2,
440        0x01624128, 0xa2385ab7, 0xd3e10d35, 0xbe570ec3, 0xc951656f, 0xbe8944a0,
441        0x7be41062, 0x5709f919, 0xd745feda, 0x9870b9ae, 0xb44b8168, 0x19e7683b,
442        0xded8017f, 0xc6e4d544, 0x91ae4225, 0xd6745fba, 0xb992f284, 0x65b12b33,
443        0xa9d5fdb4, 0xf105ce1a, 0x35ca1a6e, 0x2ff70dd0, 0xd8335e49, 0xfb71ddf2,
444        0xcaeabb89, 0x5c6f5f84, 0x9a811a7d, 0xbcecbbd1, 0x0f661ba0, 0x9ad93b9d,
445        0xedd23e0b, 0x42062f48, 0xd38dd7e4, 0x6cd63c9c, 0x640b98ae, 0x4bff5653,
446        0x12626371, 0x13266017, 0xe7a698d8, 0x39c74667, 0xe8fdf2e3, 0x52803bf8,
447        0x2af6895b, 0x91335b7b, 0x699e4961, 0x00a40fff, 0x253ff2b6, 0x4a6cf672,
448        0x9584e85f, 0xf2a5000c, 0x4d58aba8, 0xb8513e6a, 0x767fad65, 0x8e326f9e,
449        0x182f15a1, 0x163dab52, 0xdf99c780, 0x047282a1, 0xee4f90dd, 0xd50394ae,
450        0x6c9fd5f0, 0xb06a9194, 0x387e3840, 0x04a9487b, 0xf678a4c2, 0xd0a78810,
451        0xd502c97e, 0xd6a9b12a, 0x4accc5dc, 0x416ed53e, 0x50411536, 0xeeb89c24,
452        0x813a7902, 0x034ebca6, 0xffa52e7c, 0x7ecd3d0e, 0xfa37a0d2, 0xb1fbe2c1,
453        0xb7efc6d1, 0xefa4ccee, 0xf6f80424, 0x2283f3d9, 0x68732284, 0x94f3b5c8,
454        0xbbdeceb9,
455    };
456    ExplicitSeedSeq seed_sequence{12, 34, 56};
457    pcg32_2018_engine engine(seed_sequence);
458  #if UPDATE_GOLDEN
459    (void)kGolden;  
460    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
461      printf("0x%08x, ", engine());
462      if (i % 6 == 5) {
463        printf("\n");
464      }
465    }
466    printf("\n\n\n");
467  #else
468    for (const auto& elem : kGolden) {
469      EXPECT_EQ(elem, engine());
470    }
471    engine.seed(seed_sequence);
472    for (const auto& elem : kGolden) {
473      EXPECT_EQ(elem, engine());
474    }
475  #endif
476  }
477  TEST(PCG322018EngineTest, VerifyGoldenFromDeserializedEngine) {
478    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
479        0x780f7042, 0xba137215, 0x43ab6f22, 0x0cb55f46, 0x44b2627d, 0x835597af,
480        0xea973ea1, 0x0d2abd35, 0x4fdd601c, 0xac4342fe, 0x7db7e93c, 0xe56ebcaf,
481        0x3596470a, 0x7770a9ad, 0x9b893320, 0x57db3415, 0xb432de54, 0xa02baf71,
482        0xa256aadb, 0x88921fc7, 0xa35fa6b3, 0xde3eca46, 0x605739a7, 0xa890b82b,
483        0xe457b7ad, 0x335fb903, 0xeb06790c, 0xb3c54bf6, 0x6141e442, 0xa599a482,
484        0xb78987cc, 0xc61dfe9d, 0x0f1d6ace, 0x17460594, 0x8f6a5061, 0x083dc354,
485        0xe9c337fb, 0xcfd105f7, 0x926764b6, 0x638d24dc, 0xeaac650a, 0x67d2cb9c,
486        0xd807733c, 0x205fc52e, 0xf5399e2e, 0x6c46ddcc, 0xb603e875, 0xce113a25,
487        0x3c8d4813, 0xfb584db8, 0xf6d255ff, 0xea80954f, 0x42e8be85, 0xb2feee72,
488        0x62bd8d16, 0x1be4a142, 0x97dca1a4, 0xdd6e7333, 0xb2caa20e, 0xa12b1588,
489        0xeb3a5a1a, 0x6fa5ba89, 0x077ea931, 0x8ddb1713, 0x0dd03079, 0x2c2ba965,
490        0xa77fac17, 0xc8325742, 0x8bb893bf, 0xc2315741, 0xeaceee92, 0x81dd2ee2,
491        0xe5214216, 0x1b9b8fb2, 0x01646d03, 0x24facc25, 0xd8c0e0bb, 0xa33fe106,
492        0xf34fe976, 0xb3b4b44e, 0x65618fed, 0x032c6192, 0xa9dd72ce, 0xf391887b,
493        0xf41c6a6e, 0x05c4bd6d, 0x37fa260e, 0x46b05659, 0xb5f6348a, 0x62d26d89,
494        0x39f6452d, 0xb17b30a2, 0xbdd82743, 0x38ecae3b, 0xfe90f0a2, 0xcb2d226d,
495        0xcf8a0b1c, 0x0eed3d4d, 0xa1f69cfc, 0xd7ac3ba5, 0xce9d9a6b, 0x121deb4c,
496        0x4a0d03f3, 0xc1821ed1, 0x59c249ac, 0xc0abb474, 0x28149985, 0xfd9a82ba,
497        0x5960c3b2, 0xeff00cba, 0x6073aa17, 0x25dc0919, 0x9976626e, 0xdd2ccc33,
498        0x39ecb6ec, 0xc6e15d13, 0xfac94cfd, 0x28cfd34f, 0xf2d2c32d, 0x51c23d08,
499        0x4fdb2f48, 0x97baa807, 0xf2c1004c, 0xc4ae8136, 0x71f31c94, 0x8c92d601,
500        0x36caf5cd,
501    };
502  #if UPDATE_GOLDEN
503    (void)kGolden;  
504    std::seed_seq seed_sequence{1, 2, 3};
505    pcg32_2018_engine engine(seed_sequence);
506    std::ostringstream stream;
507    stream << engine;
508    auto str = stream.str();
509    printf("%s\n\n", str.c_str());
510    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
511      printf("0x%08x, ", engine());
512      if (i % 6 == 5) {
513        printf("\n");
514      }
515    }
516    printf("\n\n\n");
517    EXPECT_FALSE(true);
518  #else
519    pcg32_2018_engine engine;
520    std::istringstream stream(
521        "6364136223846793005 1442695040888963407 6537028157270659894");
522    stream >> engine;
523    for (const auto& elem : kGolden) {
524      EXPECT_EQ(elem, engine());
525    }
526  #endif
527  }
528  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "hysgen.h"
3  void THysgenUtil::DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH) {
4    FILE* F = fopen(OutFNm.CStr(), "wt");
5    for (int c = 0; c < CmtyVV.Len(); c++) {
6      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVV[c].Len());
7      for (int u = 0; u < CmtyVV[c].Len(); u++) {
8        if (NIDNmH.IsKey(CmtyVV[c][u])){
9          fprintf(F, "%s\t", NIDNmH.GetDat(CmtyVV[c][u]).CStr());
10        }
11        else {
12          fprintf(F, "%d\t", (int) CmtyVV[c][u]);
13        }
14      }
15      fprintf(F, "\n");
16    }
17    fclose(F);
18  }
19  void THysgenUtil::DumpCmtyVH(const TStr OutFNm, TVec<TIntFltH>& CmtyVH, TIntStrH& NIDNmH, Criteria Crit) {
20    FILE* F = fopen(OutFNm.CStr(), "wt");
21    int UId;
22    for (int c = 0; c < CmtyVH.Len(); c++) {
23      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVH[c].Len());
24      TIntV SortedV;
25      if (Crit == Alphabetical) {
26        TIntStrH SortedCNames;
27        for (TIntFltH::TIter NI = CmtyVH[c].BegI(); NI < CmtyVH[c].EndI(); NI++) {
28          SortedCNames.AddDat(NI.GetKey(), NIDNmH.GetDat(NI.GetKey()));
29        }
30        SortedCNames.SortByDat();
31        for (TIntStrH::TIter NI = SortedCNames.BegI();
32             NI < SortedCNames.EndI(); NI++) {
33          SortedV.Add(NI.GetKey());
34        }
35      } else {
36        CmtyVH[c].SortByDat(false);
37        CmtyVH[c].GetKeyV(SortedV);
38      }
39      for (TIntV ::TIter NI = SortedV.BegI(); NI < SortedV.EndI(); NI++) {
40        UId = NI->Val;
41        if (NIDNmH.IsKey(UId)){
42          fprintf(F, "%s: ", NIDNmH.GetDat(UId).CStr());
43        }
44        else {
45          fprintf(F, "%d: ", UId);
46        }
47        fprintf(F, "%f,\t", (double) CmtyVH[c].GetDat(UId));
48      }
49      fprintf(F, "\n");
50    }
51    fclose(F);
52  }
53  PHGraph THysgenUtil::LoadEdgeList(const TStr& InFNm, TStrHash<TInt>& NodeNameH,
54                                    TSsFmt SsFmt) {
55    TSsParser Ss(InFNm, SsFmt);
56    PHGraph PG = THGraph::New();
57    THGraph& G = *PG;
58    TStrHash<TInt> StrSet(Mega(1), true);
59    int EIdCtr = 0;
60    int RedunEdgesCnt = 0; 
61    std::string Curr;
62    while (Ss.Next()) {
63      TIntSet NIdH;
64      NIdH.Gen(Ss.Len());
65      if (Ss.Len() == 0) { continue; }
66      Curr = Ss[0];
67      if (Curr.compare(0,1, "#") == 0) { continue; } 
68      for (int i = 0; i < Ss.Len(); i++){
69        int ENId = StrSet.AddKey(Ss[i]);
70        if (! G.IsNode(ENId)) { G.AddNode(ENId, Ss[i]); }
71        NIdH.AddKey(ENId);
72      }
73      if (G.AddEdge(NIdH,EIdCtr) >= 0) {
74        EIdCtr++;
75      } else {RedunEdgesCnt++; }
76    }
77    printf("\nNumber of redundant edges: %d:\n", RedunEdgesCnt);
78    NodeNameH = StrSet;
79    NodeNameH.Pack();
80    G.Defrag();
81    return PG;
82  }
83  template<class PHGraph>
84  double THysgenUtil::GetConductance(const PHGraph& Graph, const TIntSet& CmtyS,
85                                     const int N2Edges) {
86    TIntV NeiNV;
87    int Vol = 0,  Cut = 0;
88    double Phi = 0.0;
89    for (int i = 0; i < CmtyS.Len(); i++) {
90      if (! Graph->IsNode(CmtyS[i])) { continue; }
91      THGraph::TNodeI  NI = Graph->GetNI(CmtyS[i]);
92      NI.GetNbrNodes(NeiNV);
93      for (int nei = 0; nei < NeiNV.Len(); nei++) {
94        if (! CmtyS.IsKey(NeiNV[nei])) { Cut += 1; }
95      }
96      Vol += NI.Get2Edges();
97    }
98    int N2Edges2 = N2Edges * 2;
99    if (Vol != N2Edges2) {
100      if (N2Edges2 - Vol < Vol) { Phi = Cut / double (N2Edges2 - Vol); }
101      else if (Vol == 0) { Phi = 0.0; }
102      else { Phi = Cut / double(Vol); }
103    } else {
104      if (Vol == N2Edges2) { Phi = 1.0; }
105    }
106    return Phi;
107  }
108  template<class PHGraph>
109  void THysgenUtil::GetNbhCom(const PHGraph& Graph, const int NID, TIntSet& NBCmtyS) {
110    THGraph::TNodeI NI = Graph->GetNI(NID);
111    NBCmtyS.Gen(NI.GetNbrNodes() + 1);
112    NBCmtyS.AddKey(NID);
113    for (int e = 0; e < NI.GetNbrNodes(); e++) {
114      NBCmtyS.AddKey(NI.GetNbrNId(e));
115    }
116  }
117  template<class PHGraph>
118  void THysgenUtil::GetPhiNIdPrV(const PHGraph &G, TFltIntPrV &PhiNIdPrV, const int MinComSiz) {
119    PhiNIdPrV.Gen(G->GetNodes(), 0);
120    const int N2Edges = G->Get2Edges();
121    TExeTm RunTm;
122    for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
123      TIntSet NBCmty(NI.GetNbrNodes() + 1);
124      double Phi;
125      if (NI.GetNbrNodes() < MinComSiz) { 
126        Phi = 1.0;
127      } else {
128        THysgenUtil::GetNbhCom<PHGraph>(G, NI.GetId(), NBCmty);
129        Phi = THysgenUtil::GetConductance(G, NBCmty, N2Edges);
130      }
131      PhiNIdPrV.Add(TFltIntPr(Phi, NI.GetId()));
132    }
133    PhiNIdPrV.Sort(true);
134    fflush(stdout);
135  }
136  void THysgenUtil::GetBinLocs(const int& DecNum, TIntV& LocsV, const TIntV& NodMapV) {
137    int MaxShift = ceil(TMath::Log2((double) DecNum+1));
138    int NumCopy = DecNum;
139    for (int j = 0; j < MaxShift; j++) {
140      if ( NumCopy / 2.0 != floor(NumCopy / 2.0) ) {
141        LocsV.Add(NodMapV[j]);
142      }
143      NumCopy = int(NumCopy / 2.0);
144    }
145  }
146  void THysgen::SetGraph(const PHGraph& GraphPt) {
147    HONEIdsV.Gen(GraphPt->GetNodes());
148    HONNIdsV.Gen(GraphPt->GetNodes());
149    HOKIDSV.Gen(GraphPt->GetNodes());
150    TIntV NIDV;
151    GraphPt->GetNIdV(NIDV);
152    NIdToIdx.Gen(NIDV.Len());
153    NIdToIdx.AddKeyV(NIDV);
154    G = TSnap::GetSubGraph(GraphPt, NIDV);
155    for (int nid = 0; nid < G->GetNodes(); nid++) {
156      IAssert(G->IsNode(nid));
157    }
158    PrNoCom = 1.0 / (double) G->GetNodes();
159    if (1.0 / PrNoCom > sqrt(TFlt::Mx)) { PrNoCom = 0.99 / sqrt(TFlt::Mx); } 
160    NegWgt = 1.0;
161  }
162  void THysgen::LoadComInit(const TStr& InFNm, TSsFmt SsFmt) {
163    TSsParser Ss(InFNm, SsFmt);
164    TVec<TStrFltH> ComsVH;
165    TStrSet NodsInFile(G->GetNodes());
166    std::string Curr;
167    printf("Loading community initializations from file ...\n");
168    while (Ss.Next()) {
169      if (Ss.Len() == 0) { continue; }
170      Curr = Ss[0];
171      if (Curr.compare(0,1, "#") == 0 || Curr.compare(0,1, "*") == 0) { continue; } 
172      TStrFltH CurComH;
173      for (int i = 0; i < Ss.Len(); i++){
174        Curr = Ss[i];
175        TStr NName; double SN;
176        int SepLoc = Curr.find_first_of(":");
177        if (SepLoc == -1) {
178          NName = Curr.c_str();
179          SN = InitVal;
180        } else {
181          NName = Curr.substr(0, SepLoc).c_str();
182          SN = strtod(Curr.substr(SepLoc + 2, 8).c_str(), NULL);
183        }
184        CurComH.AddDat(NName, SN);
185        NodsInFile.AddKey(NName);
186      }
187      ComsVH.Add(CurComH);
188    }
189    for (int c = 0; c < ComsVH.Len(); c++) {
190      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
191        AddNCom(NI.GetId(), c, InitNullS);
192        if (ComsVH[c].IsKey(NI.GetName())) {
193          AddNCom(NI.GetId(), c, ComsVH[c].GetDat(NI.GetName()));
194        }
195      }
196    }
197    printf("\n");
198    for (int c = 0; c < GetNumComs(); c++) {
199      printf("comm %d:\t\t", c);
200      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
201        if (GetNCom(NI.GetId(),c) > InitNullS) {
202          printf("%s,%0.2f\t",NI.GetName().CStr(), GetNCom(NI.GetId(),c));
203        }
204      }
205      printf("\n");
206    }
207    printf("\n Likelihood of the initial community memberships from the file is: %f\n", Likelihood());
208  }
209  void THysgen::ComInit(const int InitComs, const int MinComSiz, const double PerturbDens) {
210    IAssertR(InitVal>0.0 || InitNullS>0.0, "Error: At least one of -ic or -in "
211             "parameters should be set > 0. Cannot start without any initalization.");
212    S.Gen(G->GetNodes()); 
213    time_t InitTime = time(NULL);
214    printf("\n** Initializing the communities and the parameters is started...\n");
215    NumCIdNV.Gen(InitComs);
216    NumComs = InitComs;
217    if (InitNullS > 0.0) {
218      UniformComInit(InitComs);
219      InitTime = time(NULL);
220      InitEdgeProb();
221    }
222    if (InitNullS != InitVal) {
223      InitTime = time(NULL);
224      NeighborComInit(MinComSiz, InitNullS==0.0);
225      if (InitNullS==0.0) {
226        InitTime = time(NULL);
227        InitEdgeProb();
228      }
229    }
230    if (InitNullS != InitVal) {
231      RandomComPerturb(PerturbDens);
232    } else { RandomComPerturb(); }
233    printf("\n** Initializations finsihed [%lu sec]\n", time(NULL) - InitTime);
234  }
235  void THysgen::UniformComInit(const int InitComs) {
236    for (int c=0; c < NumComs; c++) {
237      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
238        AddNCom(NI.GetId(), c, InitNullS, true);
239      }
240    }
241  }
242  void THysgen::RandomComPerturb(double Density) {
243    if (Density <= 0.0) { return; }
244    for (int c=0; c < NumComs; c++) {
245      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
246        if (GetNCom(NI.GetId(), c) == 0) { continue; } 
247        if (Rnd.GetUniDev() < Density) { AddNCom(NI.GetId(), c, InitVal*Rnd.GetUniDev()); }
248      }
249    }
250  }
251  void THysgen::NeighborComInit(const int MinComSiz, const bool& IsInit) {
252    TFltIntPrV PhiNIdPrV;
253    THysgenUtil::GetPhiNIdPrV<PHGraph>(G, PhiNIdPrV, MinComSiz);
254    NeighborComInit(PhiNIdPrV, IsInit);
255  }
256  void THysgen::NeighborComInit(TFltIntPrV& PhiNIdPrV, const bool& IsInit) {
257    PhiNIdPrV.Sort(true);
258    TIntV NIdV;
259    TIntV EIdV;
260    THGraph::TNodeI NI;
261    THGraph::TEdgeI EI;
262    TIntSet InvalidNIDS(S.Len());
263    TIntV NumCIdNDefV(NumComs, 0);
264    int CurCID = 0;
265    for (int ui = 0; ui < PhiNIdPrV.Len(); ui++) {
266      if (PhiNIdPrV[ui].Val1 == 0.0) { 
267        continue;
268      }
269      int UID = PhiNIdPrV[ui].Val2;
270      fflush(stdout);
271      if (InvalidNIDS.IsKey(UID)) { continue; }
272      AddNCom(UID, CurCID, InitVal, IsInit);
273      InvalidNIDS.AddKey(UID);
274      NI = G->GetNI(UID);
275      fflush(stdout);
276      NI.GetNbrNodes(NIdV);
277      AddNCom(NIdV, CurCID, InitVal, IsInit);
278      NumCIdNDefV[CurCID] = NIdV.Len()+1;
279      InvalidNIDS.AddKeyV(NIdV);
280      CurCID++;
281      if (CurCID >= NumComs) { break; }
282      fflush(stdout);
283    }
284    if (NumComs > CurCID) {
285      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
286    }
287    for (int c = 0; c < NumCIdNV.Len(); c++) {
288      if (NumCIdNDefV[c] == 0) {
289        printf("Empty communities remained after initialization. "
290               "Members are getting assigned randomly!!\n\n");
291        int ComSz = 10;
292        for (int u = 0; u < ComSz; u++) {
293          int UID = Rnd.GetUniDevInt(G->GetNodes());
294          AddNCom(UID, c, InitVal, IsInit);
295        }
296      }
297    }
298  }
299  void THysgen::InitEdgeProb(){
300    TInt NId;
301    TInt CIterKey;
302    ProbEdgCommHH.Gen(G->GetEdges());
303    ProbNotEdgH.Gen(G->GetEdges());
304    ProbEdgH.Gen(G->GetEdges());
305    ProbENoiseV.Gen(G->GetNodes(),1);
306    ProbENoiseV[0] = 1;
307    int DPMatSize = NumComs + (SNoise>0); 
308    AuxDPEdgVV.Gen(DPMatSize);
309    for (int i = 0; i < DPMatSize; i++) {
310      AuxDPEdgVV[i].Gen(DPMatSize);
311      for (int j = 0; j < DPMatSize; j++) {
312        AuxDPEdgVV[i][j] = 0.0;
313      }
314    }
315    for (THGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
316      TIntV NumMmbrsInEdgV(NumComs);
317      TIntFltH ProdH(NumComs);
318      TIntV NeiNV;
319      EI.GetNodesV(NeiNV);
320      for (int n = 0; n < NeiNV.Len(); n++) {
321        NId = NeiNV[n];
322        for (TIntFltH::TIter SNI = S[NId].BegI(); SNI < S[NId].EndI(); SNI++) {
323          CIterKey = SNI.GetKey();
324          if (!ProdH.IsKey(CIterKey)) { ProdH.AddDat(CIterKey, 1.0); }
325          ProdH.AddDat(CIterKey, ProdH.GetDat(CIterKey)*SNI.GetDat());
326          NumMmbrsInEdgV[CIterKey] ++;
327        }
328      }
329      for (int CId = 0; CId < NumComs; CId++){
330        if (NumMmbrsInEdgV[CId] > 0 && NumMmbrsInEdgV[CId] < NeiNV.Len()) {
331          ProdH.DelKey(CId);
332        }
333      }
334      AddECom(EI.GetId(), ProdH);
335    }
336    if (InitNullS > 0.0) { InitPrAllEdgesS(InitNullS, true);
337    } else { InitPrAllEdgesS(InitVal, false); }
338  }
339  void THysgen::UpdateUEdgesProb(const int& UId, const int& CId, const double& SUNew){
340    double SUOld = GetNCom(UId,CId);
341    TIntV EIdV;
342    TIntFltH ProbEH;
343    double PrECOld;
344    double PrECNew;
345    int EId;
346    G->GetNI(UId).GetEIDs(EIdV);
347    for (int e = 0; e < EIdV.Len(); e++) {
348      EId = EIdV[e];
349      if (SUOld < DBL_EPSILON) {
350        TIntV ENodesV;
351        G->GetEI(EId).GetNbrNodes(ENodesV);
352        PrECNew = SUNew;
353        for (int n = 0; n < ENodesV.Len(); n++) {
354          if (ENodesV[n] == UId) { continue; }
355          PrECNew *= GetNCom(ENodesV[n], CId);
356        }
357      } else {
358        PrECOld = GetECom(EId, CId);
359        PrECNew = PrECOld*SUNew/SUOld;
360      }
361      if (PrECNew > 0.0) {
362        AddECom(EId, CId, PrECNew);
363      } else {
364        DelECom(EId, CId);
365      }
366    }
367  }
368  void THysgen::InitPrAllEdgesS(const double& DefVal, const bool& IsEqualComms){
369    if (SumPrPsblEdgesPow_nVV.Len()==0) {
370      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
371    } else {
372      SumPrPsblEdgesPow_nVV.Clr();
373      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
374    }
375    TFlt SToN = 1.0;
376    for (int c=0; c<NumCIdNV.Len(); c++){
377      TFltV PsiV;
378      PsiV.Add(1.0);
379      SToN = 1.0;
380      for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) || (n<=TayN && PsiV[n-1]>TayThresh) ; n++){ 
381        SToN *= DefVal;
382        PsiV.Add(pow(SToN+1.0, NumCIdNV[c]) - 1);
383      }
384      SumPrPsblEdgesPow_nVV.Add(PsiV);
385      if (IsEqualComms && NumCIdNV.Len()>1) {
386        for (int c=1; c<NumCIdNV.Len(); c++) {
387          TFltV PsiVCopy(SumPrPsblEdgesPow_nVV[0]);
388          SumPrPsblEdgesPow_nVV.Add(PsiVCopy);
389        }
390        printf("\n Done the same initialization for the rest of %d communities...\n",NumComs()-1);
391        break;
392      }
393    }
394  }
395  void THysgen::UpdatePrAllEdgesS(const int &UID, const int &CID, const double& SNNew){
396    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
397    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, true);
398  }
399  void THysgen::UpdatePrAllEdgesS(TFltV& PsiV, const int& UID, const int& CID, const double& SNNew, const bool IsApplyChange){
400    PsiV[0] = 1.0; 
401    double SNOld = GetNCom(UID,CID);
402    double SToNOld = 1.0, SToNNew = 1.0;
403    int nLast = 0;
404    for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) ||
405                  (n <= TayN    && PsiV[n-1]>TayThresh); n++){
406      if (n >= PsiV.Len()) {
407        PsiV.Add(0.0);
408      }
409      SToNOld *= SNOld; SToNNew *= SNNew;
410      PsiV[n] = ((SToNNew+1.0)/(SToNOld+1.0)) *
411                                      (SumPrPsblEdgesPow_nVV[CID][n]-SToNOld) + SToNNew; 
412      nLast = n;
413    }
414    if (IsApplyChange) {
415      for (int n = 1; n <= nLast; n++) {
416        if (n >= SumPrPsblEdgesPow_nVV[CID].Len()) {
417          SumPrPsblEdgesPow_nVV[CID].Add(-1.0);
418        }
419        SumPrPsblEdgesPow_nVV[CID][n] = PsiV[n];
420      }
421      nLast++;
422      while (nLast < SumPrPsblEdgesPow_nVV[CID].Len()) {
423        SumPrPsblEdgesPow_nVV[CID][nLast] = 0.0;
424        nLast++;
425      }
426    }
427  }
428  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID,
429                                    const bool IsLikelihood, const bool Verbose){
430    double SCoef = 1.0;
431    double LikCoef = 1.0;
432    double S_uc = GetNCom(UID,CID);
433    double SPowN = 1.0;
434    if (!IsLikelihood){
435      if (S_uc <= 0.0) { return SumPrPsblEdgesPow_nVV[CID][1]; }
436      else { SCoef = 1.0/S_uc; }
437    }
438    if (S_uc<=0.0 && IsLikelihood) { return 0.0; }
439    double Val = 0.0;
440    double Val_n;
441    if (Verbose) {
442      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
443    }
444    for (int n=1; n<SumPrPsblEdgesPow_nVV[CID].Len() &&
445                  SumPrPsblEdgesPow_nVV[CID][n]>TayThresh; n++){
446      if (IsLikelihood) { LikCoef = -n; }
447      SPowN *= S_uc;
448      Val_n = SCoef * (SPowN/(1+SPowN)) * (SumPrPsblEdgesPow_nVV[CID][n] - SPowN) / LikCoef;
449      Val += Val_n;
450      if(Verbose){
451        printf("\t --- (n=%d): %f\n", n , Val_n);
452      }
453    }
454    return Val;
455  }
456  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID, const double& SNNew,
457                                    const bool IsLikelihood, const bool Verbose){
458    IAssertR(IsLikelihood,"This Overload of function is only designed for computing the likelihood, not gradient!\n");
459    double SCoef = 1.0;
460    double LikCoef;
461    double SPowN = 1.0;
462    if (SNNew <= 0.0) { return 0.0; } 
463    double Val = 0.0;
464    double Val_n;
465    if (Verbose) {
466      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
467    }
468    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
469    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, false);
470    for (int n=1; n<PsiV.Len() && PsiV[n]>TayThresh; n++){ 
471      LikCoef = -n;
472      SPowN *= SNNew;
473      Val_n = SCoef * (SPowN/(1.0+SPowN)) * (PsiV[n] - SPowN) / LikCoef;
474      Val += Val_n;
475      if(Verbose){
476        printf("\t --- (n=%d): %f\n", n , Val_n);
477      }
478    }
479    return Val;
480  }
481  double THysgen::PredictAllCEdgesS_direct(const int &UID, const int &CID,
482                                           const bool IsLikelihood, const bool Verbose) {
483    double Psi_c = 0.0;
484    double S_uc = GetNCom(UID,CID);
485    if (S_uc <= 0.0 && IsLikelihood) { return 0.0; }
486    TIntV CNodesV(S.Len(),0);
487    for (int nod=0; nod < S.Len(); nod++) {
488      if (GetNCom(nod, CID) > 0.0 || nod==UID) {CNodesV.Add(nod);}
489    }
490    TInt NPsbEdges = pow(2, CNodesV.Len());
491    for (int e=0; e<NPsbEdges; e++) {
492      TIntV ENodesV;
493      THysgenUtil::GetBinLocs(e, ENodesV, CNodesV);
494      if (!ENodesV.IsIn(UID) || ENodesV.Len() < 2) { continue; }
495      double ECProb = 1.0;
496      for (int i = 0; i < ENodesV.Len(); i++) {
497        if (Verbose) {
498          printf("%d, ", ENodesV[i]()); }
499        if (ENodesV[i] != UID) { ECProb *= GetNCom(ENodesV[i], CID); }
500      }
501      if (Verbose) {
502        printf(" --\t ECProb=%f, ", ECProb);
503      }
504      if (ECProb == 1.0 && S_uc == 1.0) { continue; }
505      if (!IsLikelihood) {
506        Psi_c += (ECProb / (1.0 - ECProb*S_uc));
507      } else {
508        Psi_c += log(1.0 - ECProb*S_uc);
509      }
510      if (Verbose) {
511        printf(" *Islikelihood=%d*, Psi_c=%f\n", IsLikelihood, Psi_c); }
512    }
513    return Psi_c;
514  }
515  void THysgen::UpdateProbNotEdgH(const int &EId, const double &PrECNew,
516                                const double &PrECOld) {
517    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
518    if (PrECNew>=0.0 && ProbNotEdgH.IsKey(EId) && ProbNotEdgH.GetDat(EId)()==-1.0)  {
519      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId); 
520      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
521      if (1.0 - ProbEdgH.GetDat(EId) < 1.0) { 
522        ProbNotEdgH.AddDat(EId, 1.0 - ProbEdgH.GetDat(EId));
523      }
524      return;
525    }
526    double PrNotE;
527    if (PrECOld < 1.0){
528      PrNotE = ProbNotEdgH.GetDat(EId) * (1.0 - PrECNew) / (1.0 - PrECOld);
529    } else {
530      PrNotE = 1.0 - PrENoise;
531      for (TIntFltH::TIter HI = ProbEdgCommHH.GetDat(EId).BegI();
532           HI < ProbEdgCommHH.GetDat(EId).EndI(); HI++) {
533        PrNotE *= 1.0 - HI.GetDat();
534      }
535    }
536    ProbNotEdgH.AddDat(EId, PrNotE);
537    ProbEdgH.AddDat(EId, 1-PrNotE);
538    if (PrNotE >= 1.0) {
539      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId);
540      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
541      ProbNotEdgH.AddDat(EId,-1.0);
542    }
543  }
544  double THysgen::DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
545    double DP = 0.0;
546    for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
547      if (UV.IsKey(HI.GetKey())) {
548        DP += UV.GetDat(HI.GetKey()) * HI.GetDat();
549      }
550    }
551    return DP;
552  }
553  void THysgen::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
554    S.Gen(G->GetNodes());
555    NumCIdNV.Gen(CmtyVV.Len());
556    NumComs = CmtyVV.Len();
557    for (int c = 0; c < CmtyVV.Len(); c++) {
558      for (int u = 0; u < CmtyVV[c].Len(); u++) {
559        int UID = CmtyVV[c][u];
560        if (! NIdToIdx.IsKey(UID)) { continue; }
561        AddNCom(NIdToIdx.GetKeyId(UID), c, 1.0);
562      }
563    }
564  }
565  double THysgen::Likelihood() {
566    TExeTm ExeTm;
567    double L = 0.0;
568    for (int u = 0; u < S.Len(); u++) {
569      double LU = LikelihoodForRow(u);
570      L += LU;
571    }
572    return L ;
573  }
574  double THysgen::LikelihoodForRow(const int UID) {
575    return LikelihoodForRow(UID, S[UID]);
576  }
577  double THysgen::LikelihoodForRow(const int UID, const TIntFltH &SU) {
578    bool IsSUpdated = false;
579    if (S[UID].Len() != SU.Len()) {
580      IsSUpdated = true;
581    } else {
582      for (int CID = 0; CID < NumComs; CID++){
583        if (!S[UID].IsKey(CID) && !SU.IsKey(CID)) {continue;}
584        if ( (S[UID].IsKey(CID) && !SU.IsKey(CID)) ||
585            (!S[UID].IsKey(CID) && SU.IsKey(CID)) ||
586            abs(S[UID].GetDat(CID) - SU.GetDat(CID)) > DBL_MIN ) {
587          IsSUpdated = true;
588          break;
589        }
590      }
591    }
592    double L = 0.0;
593    const bool IsLikelihood = true;
594    THGraph::TNodeI NI = G->GetNI(UID);
595    TIntV EIdV; 
596    NI.GetEIDs(EIdV);
597    TFlt SumLgPrNotUEdges = 0.0; 
598    for (int e = 0; e < NI.GetDeg(); e++) {
599      int EId = EIdV[e];
600      TIntFltH PrENewCH;
601      if (HONNIdsV[UID].IsKey(EId)) { continue; }
602        L += log(GetPrE(EId, UID, SU, PrENewCH));
603        for (TIntFltH::TIter PrECI = PrENewCH.BegI(); PrECI < PrENewCH.EndI(); PrECI++){
604          SumLgPrNotUEdges += log(1.0 - PrECI.GetDat());
605        }
606    }
607    TFlt SumAllPsbl = 0.0;
608    for (TIntFltH::TIter UCI = SU.BegI(); UCI < SU.EndI(); UCI++) {
609      if (IsSUpdated) {
610        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), UCI.GetDat(), IsLikelihood);
611      } else {
612        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), IsLikelihood);
613      }
614    }
615    L += NegWgt * (SumAllPsbl - SumLgPrNotUEdges);
616    if (RegCoef > 0.0) {
617      L -= RegCoef * Sum(SU);
618    }
619    return L;
620  }
621  void THysgen::GradientForRow(const int UId, TIntFltH &GradNod) {
622    GradNod.Gen(GetNumComs());
623    THGraph::TNodeI NI = G->GetNI(UId);
624    int NDeg = NI.GetDeg();
625    TIntV EIdV; 
626    NI.GetEIDs(EIdV);
627    TIntFltH PredEH(NDeg);
628    TFltV PredECMinusUV(GetNumComs());
629    TFltV GradV(GetNumComs());
630    TIntV CIDV(GetNumComs());
631    TIntV NIdV;
632    TInt NId;
633    TInt EId;
634    for (int e = 0; e < NDeg; e++) {
635      EId = EIdV[e];
636      if (HONEIdsV[UId].IsKey(EId)) { continue; }
637      PredEH.AddDat(EId, GetPrE(EId)); 
638    }
639    for (int CId = 0; CId < NumComs; CId++) { 
640      double Val = 0.0;
641      for (int e = 0; e < NDeg; e++) {
642        EId = EIdV[e];
643        if (HONEIdsV[UId].IsKey(EId)) { continue; }
644        if (GetNCom(UId, CId) > 0.0) {
645          PredECMinusUV[CId] =
646            GetECom(EId, CId) / GetNCom(UId, CId); 
647        } else {
648          PredECMinusUV[CId] = 1.0;
649          G->GetEI(EId).GetNodesV(NIdV);
650          for (int m = 0; m < NIdV.Len(); m++) {
651            NId = NIdV[m];
652            if (NId != UId) { PredECMinusUV[CId] *= GetNCom(NId, CId); }
653          }
654        }
655        double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
656        if (GetECom(EId, CId) >= 1.0 || (1.0 - GetECom(EId, CId) <= 0.0)) {
657          double PredENotCId = 1.0 - PrENoise;
658          for (int c2 = 0; c2 < NumComs; c2++) {
659            if (c2 == CId) { continue; }
660            PredENotCId *= 1.0 - GetECom(EId, c2);
661          }
662          Val += PredECMinusUV[CId] * PredENotCId / PredEH.GetDat(EId); 
663        }
664        else {
665          double PrNotENotC = (1.0 - PredEH.GetDat(EId)) / (1.0 - GetECom(EId, CId));
666          Val +=
667            PredECMinusUV[CId] * PrNotENotC / PredEH.GetDat(EId);
668        }
669        Val += NegWgt * (PredECMinusUV[CId] /
670          (1.0 - GetECom(EId, CId)));
671      }
672      Val -= NegWgt * PredictAllCEdgesS(UId, CId, false);
673      CIDV[CId] = CId;
674      GradV[CId] = Val;
675    }
676    for (int c = 0; c < GradV.Len(); c++) {
677      GradNod.AddDat(CIDV[c], GradV[CIDV[c]]);
678    }
679  }
680  void THysgen::GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV, TVec<TFltV>& WckVV,
681                          const double Thres, const int MinSz) {
682    CmtyVH.Gen(NumComs, 0.0);
683    CmtyVV.Gen(NumComs, 0.0);
684    for (int CId = 0; CId < NumComs; CId++) {
685      TIntFltH NIDSucH(S.Len());
686      TIntV CmtyV;
687      for (int u = 0; u < S.Len(); u++) {
688        int NID = NIdToIdx[u];
689        if (GetNCom(u, CId) > Thres) {
690          NIDSucH.AddDat(NID, GetNCom(u, CId));
691        }
692      }
693      NIDSucH.SortByDat(false);
694      NIDSucH.GetKeyV(CmtyV);
695      if (CmtyV.Len() < MinSz) { continue; }
696      CmtyVH.Add(NIDSucH);
697      CmtyVV.Add(CmtyV);
698    }
699    if ( NumComs != CmtyVV.Len()) {
700      printf("Unsorted Community vector generated. %d communities are ommitted\n",
701             NumComs.Val - CmtyVV.Len());
702    }
703  }
704  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
705    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
706  }
707  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
708    CmtyVV.Gen(NumComs, 0.0);
709    for (int c = 0; c < NumComs; c++) {
710      TIntV CmtyV;
711      for (int u = 0; u < G->GetNodes(); u++) {
712        if (GetNCom(u, c) > Thres) { CmtyV.Add(NIdToIdx[u]); }
713      }
714      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
715    }
716    if ( NumComs != CmtyVV.Len()) {
717      printf("*Sorted* Community vector generated. %d communities are ommitted\n",
718             NumComs.Val - CmtyVV.Len());
719    }
720  }
721  double THysgen::GetStepSizeByLineSearch(const int UID, const TIntFltH &DeltaH,
722                                          const double &stepSize,
723                                          const double &CtrlParam,
724                                          const double &ReductionRatio,
725                                          const int MaxIter) {
726    double StepSize = stepSize;
727    double NewVal;
728    bool ShouldReduce = true;
729    while (ShouldReduce) {
730      ShouldReduce = false;
731      for (TIntFltH::TIter CI = DeltaH.BegI(); CI < DeltaH.EndI(); CI++) {
732        int CID = CI.GetKey();
733        NewVal = GetNCom(UID, CID) + StepSize * CI.GetDat();
734        if ((NewVal < MinVal || NewVal > MaxVal)) {
735          StepSize *= ReductionRatio;
736          ShouldReduce = true;
737          break;
738        }
739      }
740    }
741    double InitLikelihood = LikelihoodForRow(UID);
742    double FinalLikelihood = 0.0;
743    TIntFltH SearchVecH;
744    for(int iter = 0; iter < MaxIter; iter++) {
745      TIntFltH NewVarH;
746      GetUpdatedNodP(NewVarH, SearchVecH, UID, DeltaH, StepSize);
747      FinalLikelihood = LikelihoodForRow(UID, NewVarH);
748      double DotProd = DotProduct(SearchVecH, SearchVecH);
749      if (FinalLikelihood < InitLikelihood + CtrlParam * StepSize * DotProd ||
750                                                      isinf(FinalLikelihood)) {
751        StepSize *= ReductionRatio;
752      } else {
753        break;
754      }
755      if (iter == MaxIter - 1 || DotProd < 0.00001) {
756        StepSize = 0.0;
757        break;
758      }
759    }
760    return StepSize;
761  }
762  int THysgen::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm,
763                             const double StepSize, const double StepCtrlParam, const double StepReductionRatio) {
764    int NegLikPermits = MaxIter/3;
765    int MaxIterLineSearch = 100;
766    time_t InitTime = time(NULL);
767    time_t InitIterTime;
768    TExeTm ExeTm, CheckTm;
769    int iter = 0; 
770    TIntFltPrV IterLV; 
771    THGraph::TNodeI UI; 
772    double PrevL = Likelihood(), CurL = 0.0, DiffL;
773    printf("\n0 iterations (iter/#nodes = 0) {[INITIAL] Likelihood: %.4e}\n",PrevL);
774    TIntV NIdxV(S.Len(), 0);  
775    for (int i = 0; i < S.Len(); i++) { NIdxV.Add(i); }
776    TIntFltH GradUH;
777    TFltV Last5;
778    double SumLast5 = 0;
779    while(iter < MaxIter) {
780      InitIterTime = time(NULL);
781      NIdxV.Shuffle(Rnd);
782      for (int ui = 0; ui < S.Len(); ui++, iter++) {
783        int u = NIdxV[ui];
784        GradientForRow(u, GradUH);
785        if (Norm2(GradUH) < 1e-4) { continue; }
786        TIntFltH GradAdjustedH;
787        TIntFltH SearchVecH;
788        NormalizeIfLarge(GradUH, GradAdjustedH);
789        bool IsAnyValidChange = RmvWeakDirections(u, GradAdjustedH);
790        if (! IsAnyValidChange) { continue; }
791        double LearnRate = GetStepSizeByLineSearch(u, GradAdjustedH, StepSize,
792                                                   StepCtrlParam,
793                                                   StepReductionRatio,
794                                                   MaxIterLineSearch);
795        if (LearnRate <= DBL_MIN) { continue; }
796        TIntFltH SNew;
797        GetUpdatedNodP(SNew, u, GradAdjustedH, LearnRate);
798        double NewSuc;
799        for (int CID = 0; CID < NumComs; CID++) {
800          if (! SNew.IsKey(CID)) {
801            NewSuc = 0.0;
802          } else {
803            NewSuc = SNew.GetDat(CID);
804          }
805          if (NewSuc < DBL_EPSILON) {
806            DelNCom(u, CID);
807          } else {
808            AddNCom(u, CID, NewSuc);
809          }
810        }
811        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
812          IterLV.Add(TIntFltPr(iter, Likelihood()));
813        }
814      }
815      CurL = Likelihood();
816      DiffL = CurL - PrevL;
817      PrevL = CurL;
818      double AdjDiffL = (abs(DiffL) < 1000.0) ? abs(DiffL) : 1000.0;
819      Last5.Add(AdjDiffL);
820      SumLast5 += AdjDiffL;
821      if (Last5.Len() > 5) {
822        SumLast5 -= Last5[0];
823        Last5.Del(0);
824      }
825      if (fabs(CurL) < 1e9) {
826        if (fabs(DiffL) < 1e9) {
827          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4f} [%lu/%lu sec]\n",
828                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
829        } else {
830          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4e} [%lu/%lu sec]\n",
831                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
832        }
833      } else {
834        if (fabs(DiffL) < 1e9) {
835          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4f} [%lu/%lu sec]\n",
836                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
837        } else {
838          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4e} [%lu/%lu sec]\n",
839                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
840        }
841      }
842      printf("\n");
843      fflush(stdout);
844      if (DiffL < 0.0) { 
845        if (NegLikPermits <= 0) { break; }
846        NegLikPermits --;
847      }
848      if (SumLast5/Last5.Len() <= Thres) {
849        printf("The average of last five differences < threshold. Iterations end...\n");
850        break;
851      }
852    }
853    printf("\n");
854    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
855    if (! PlotNm.Empty()) {
856      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
857    }
858    return iter;
859  }
860  double THysgen::GetPrE(const int &EId, const int &UId, const TIntFltH &SUNewH,
861                         TIntFltH &PrEOutCH) {
862    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
863    double SUOld;
864    double SUNew;
865    double PrECOld;
866    double PrENew = 1.0 - PrENoise;
867    int SCId;
868    for (TIntFltH::TIter SCI = SUNewH.BegI(); SCI < SUNewH.EndI(); SCI++) {
869      SCId = SCI.GetKey();
870      SUNew = SCI.GetDat();
871      SUOld = GetNCom(UId, SCId);
872      if (SUOld < DBL_EPSILON) {
873        TIntV ENodesV;
874        G->GetEI(EId).GetNbrNodes(ENodesV);
875        double PrEC = SUNew;
876        for (int n = 0; n < ENodesV.Len(); n++) {
877          if (ENodesV[n] == UId) { continue; }
878          PrEC *= GetNCom(ENodesV[n], SCId);
879        }
880        PrEOutCH.AddDat(SCId, PrEC);
881      } else {
882        PrECOld = GetECom(EId, SCId);
883        PrEOutCH.AddDat(SCId, PrECOld * SUNew / SUOld);
884      }
885      PrENew *= 1.0 - PrEOutCH.GetDat(SCId);
886    }
887    if (PrENew < 1.0) { PrENew = 1.0 - PrENew; }
888    else {
889      PrENew = GetPrEPrecision(PrEOutCH, AuxDPEdgVV, PrENoise);
890    }
891    return PrENew;
892  }
893  double THysgen::GetPrEPrecision(const TIntFltH &ECH, TVec<TFltV> &DPMatVV,
894                                  const double PrENoise) {
895    int NumEC = ECH.Len();
896    TFltV ECV(NumEC);
897    ECH.GetDatV(ECV);
898    if (PrENoise > 0.0) { ECV.Add(PrENoise); NumEC++; }
899    for (int i=1; i<NumEC; i++) {
900      DPMatVV[i][NumEC-1] = 0;
901    }
902    DPMatVV[0][NumEC-1] = ECV[NumEC-1];
903    for (int j= NumEC - 2; j >= 0; j--) {
904      DPMatVV[0][j] = DPMatVV[0][j + 1] + ECV[j];
905    }
906    for (int i=1; i<NumEC; i++) {
907      for (int j=NumEC-1-i; j>=0; j--) {
908        DPMatVV[i][j] = ECV[j] * DPMatVV[i-1][j+1] + DPMatVV[i][j+1];
909      }
910    }
911    double prob = 0.0;
912    double SignCoef = 1.0;
913    for (int i=0; i<NumEC; i++) {
914      prob += SignCoef * DPMatVV[i][0];
915      SignCoef *= -1.0;
916    }
917    if (prob < DBL_MIN || prob >1) {
918      prob = DBL_MIN;
919    }
920    return prob;
921  }
922  void THysgen::GetUpdatedNodP(TIntFltH &SNew, const int &UID, const TIntFltH& GradUH,
923                          double &StepSize) {
924    TIntFltH SearchVecOut;
<span onclick='openModal()' class='match'>925    GetUpdatedNodP(SNew, SearchVecOut, UID, GradUH, StepSize);
926  }
927  void THysgen::GetUpdatedNodP(TIntFltH &SNew, TIntFltH& SearchVecOut, const int& UID,
</span>928                               const TIntFltH& GradUH, double& StepSize) {
929    for (int CID = 0; CID < NumComs; CID++) {
930      if (GradUH.IsKey(CID)) {
931        double Change = StepSize * GradUH.GetDat(CID);
932        if (RegCoef>0.0 && GetNCom(UID, CID)>0.0) {
933          Change -= - RegCoef;
934        }
935        double NewSuc = GetNCom(UID, CID) + Change;
936        if (NewSuc < DBL_EPSILON) {
937          NewSuc = MinVal;
938        } else if (NewSuc >= MaxVal - TayThresh) {
939          NewSuc = MaxVal - TayThresh;
940        }
941        Change = NewSuc - GetNCom(UID, CID);
942        if (NewSuc >= DBL_EPSILON) {
943          SNew.AddDat(CID, NewSuc);
944        }
945        SearchVecOut.AddDat(CID, Change);
946      } else {
947        if (GetNCom(UID, CID) > 0.0) {
948          double NewSuc;
949          if (GetNCom(UID, CID) >= MaxVal - TayThresh) {
950            NewSuc = MaxVal - TayThresh;
951          } else {
952            NewSuc = GetNCom(UID, CID);
953          }
954          SNew.AddDat(CID, NewSuc);
955        }
956      }
957    }
958  }
959  bool THysgen::AcceptStepSA(const int &UID, const TIntFltH &SNew, const int &Iter,
960                        const int &MaxIter, const double &SAParamK) {
961    double T0 = 100.0;
962    double T = T0/((double)Iter+1.0);
963    double OldLikelihood = LikelihoodForRow(UID);
964    double NewLikelihood = LikelihoodForRow(UID, SNew);
965    double DeltaE = - (NewLikelihood-OldLikelihood);
966    double PrAccept = exp(-DeltaE/(SAParamK*T));
967    if (Rnd.GetUniDev() < PrAccept) { return true; }
968    return false;
969  }
970  bool THysgen::RmvWeakDirections(const int &UId, TIntFltH &GradH) {
971    bool IsEligible = false;
972    THashSet<TInt> BadDirH;
973    for (TIntFltH::TIter CI = GradH.BegI(); CI < GradH.EndI(); CI++) {
974      if ((GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() < DBL_EPSILON) ||
975            (1.0 - GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() > DBL_EPSILON)) {
976        BadDirH.AddKey(CI.GetKey());
977      } else {
978        IsEligible = true;
979      }
980    }
981    if (BadDirH.Len() > 0) {
982      for (THashSet<TInt>::TIter CId = BadDirH.BegI();
983           CId < BadDirH.EndI(); CId++) {
984        GradH.DelKey(CId.GetKey());
985      }
986    }
987    return IsEligible;
988  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-pcg_engine_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</div>
                </div>
                <div class="column column_space"><pre><code>83  TYPED_TEST(PCGEngineTest, StreamOperatorsResult) {
84    using engine_type = TypeParam;
85    std::wostringstream os;
86    std::wistringstream is;
87    engine_type engine;
88    EXPECT_EQ(&(os << engine), &os);
89    EXPECT_EQ(&(is >> engine), &is);
90  }
91  TYPED_TEST(PCGEngineTest, StreamSerialization) {
</pre></code></div>
                <div class="column column_space"><pre><code>925    GetUpdatedNodP(SNew, SearchVecOut, UID, GradUH, StepSize);
926  }
927  void THysgen::GetUpdatedNodP(TIntFltH &SNew, TIntFltH& SearchVecOut, const int& UID,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    