
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.139500734214391%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-TNodeNet.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  TEST(TNodeNet, DefaultConstructor) {
4    TPt <TNodeNet<TInt> > Net;
5    Net = TNodeNet<TInt>::New();
6    EXPECT_EQ(0,Net->GetNodes());
7    EXPECT_EQ(0,Net->GetEdges());
8    EXPECT_EQ(1,Net->IsOk());
9    EXPECT_EQ(1,Net->Empty());
10    EXPECT_EQ(1,Net->HasFlag(gfDirected));
11    EXPECT_EQ(1,Net->HasFlag(gfNodeDat));
12  }
13  TEST(TNodeNet, ManipulateNodesEdges) {
14    int NNodes = 10000;
15    int NEdges = 100000;
16    const char *FName = "test.net.dat";
17    TPt <TNodeNet<TInt> > Net;
18    TPt <TNodeNet<TInt> > Net1;
19    TPt <TNodeNet<TInt> > Net2;
20    int i;
21    int n;
22    int NCount;
23    int x,y;
24    int Deg, InDeg, OutDeg;
25    Net = TNodeNet<TInt>::New();
26    EXPECT_EQ(1,Net->Empty());
27    for (i = 0; i < NNodes; i++) {
28      Net->AddNode(i);
29    }
30    EXPECT_EQ(0,Net->Empty());
31    EXPECT_EQ(NNodes,Net->GetNodes());
32    NCount = NEdges;
33    while (NCount > 0) {
34      x = (long) (drand48() * NNodes);
35      y = (long) (drand48() * NNodes);
36      if (x != y  &&  !Net->IsEdge(x,y)) {
37        n = Net->AddEdge(x, y);
38        NCount--;
39      }
40    }
41    EXPECT_EQ(NEdges,Net->GetEdges());
42    EXPECT_EQ(0,Net->Empty());
43    EXPECT_EQ(1,Net->IsOk());
44    for (i = 0; i < NNodes; i++) {
45      EXPECT_EQ(1,Net->IsNode(i));
46    }
47    EXPECT_EQ(0,Net->IsNode(NNodes));
48    EXPECT_EQ(0,Net->IsNode(NNodes+1));
49    EXPECT_EQ(0,Net->IsNode(2*NNodes));
50    NCount = 0;
51    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
52      NCount++;
53    }
54    EXPECT_EQ(NNodes,NCount);
55    NCount = 0;
56    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
57      for (int e = 0; e < NI.GetOutDeg(); e++) {
58        NCount++;
59      }
60    }
61    EXPECT_EQ(NEdges,NCount);
62    NCount = 0;
63    for (TNodeNet<TInt>::TEdgeI EI = Net->BegEI(); EI < Net->EndEI(); EI++) {
64      NCount++;
65    }
66    EXPECT_EQ(NEdges,NCount);
67    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
68      Deg = NI.GetDeg();
69      InDeg = NI.GetInDeg();
70      OutDeg = NI.GetOutDeg();
71      EXPECT_EQ(Deg,InDeg+OutDeg);
72    }
73    Net1 = TNodeNet<TInt>::New();
74    *Net1 = *Net;
75    EXPECT_EQ(NNodes,Net1->GetNodes());
76    EXPECT_EQ(NEdges,Net1->GetEdges());
77    EXPECT_EQ(0,Net1->Empty());
78    EXPECT_EQ(1,Net1->IsOk());
79    {
80      TFOut FOut(FName);
81      Net->Save(FOut);
82      FOut.Flush();
83    }
84    {
85      TFIn FIn(FName);
86      Net2 = TNodeNet<TInt>::Load(FIn);
87    }
88    EXPECT_EQ(NNodes,Net2->GetNodes());
89    EXPECT_EQ(NEdges,Net2->GetEdges());
90    EXPECT_EQ(0,Net2->Empty());
91    EXPECT_EQ(1,Net2->IsOk());
92    for (i = 0; i < NNodes; i++) {
93      n = Net->GetRndNId();
94      Net->DelNode(n);
95    }
96    EXPECT_EQ(0,Net->GetNodes());
97    EXPECT_EQ(0,Net->GetEdges());
98    EXPECT_EQ(1,Net->IsOk());
99    EXPECT_EQ(1,Net->Empty());
100    Net1->Clr();
101    EXPECT_EQ(0,Net1->GetNodes());
102    EXPECT_EQ(0,Net1->GetEdges());
103    EXPECT_EQ(1,Net1->IsOk());
104    EXPECT_EQ(1,Net1->Empty());
105  }
106  TEST(TNodeNet, SetNodeData) {
107    int NNodes = 10000;
108    int NEdges = 100000;
109    TPt <TNodeNet<TInt> > Net;
110    TPt <TNodeNet<TInt> > Net1;
111    TPt <TNodeNet<TInt> > Net2;
112    int i;
113    int n;
114    int NCount;
115    int x,y;
116    Net = TNodeNet<TInt>::New();
117    EXPECT_EQ(1,Net->Empty());
118    for (i = 0; i < NNodes; i++) {
119      Net->AddNode(i);
120    }
121    EXPECT_EQ(0,Net->Empty());
122    EXPECT_EQ(NNodes,Net->GetNodes());
123    NCount = NEdges;
124    while (NCount > 0) {
125      x = (long) (drand48() * NNodes);
126      y = (long) (drand48() * NNodes);
127      if (x != y  &&  !Net->IsEdge(x,y)) {
128        n = Net->AddEdge(x, y);
129        NCount--;
130      }
131    }
132    EXPECT_EQ(NEdges,Net->GetEdges());
133    EXPECT_EQ(0,Net->Empty());
134    EXPECT_EQ(1,Net->IsOk());
135    for (i = 0; i < NNodes; i++) {
136      EXPECT_EQ(1,Net->IsNode(i));
137    }
138    EXPECT_EQ(0,Net->IsNode(NNodes));
139    EXPECT_EQ(0,Net->IsNode(NNodes+1));
140    EXPECT_EQ(0,Net->IsNode(2*NNodes));
141    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
142      Net->SetNDat(NI.GetId(), NI.GetId()+10);
143    }
144    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
145      EXPECT_EQ(NI.GetId()+10, Net->GetNDat(NI.GetId()));
146    }
147  }
148  TEST(TNodeNet, UpdateNodeData) {
149    int NNodes = 10000;
150    int NEdges = 100000;
151    TPt <TNodeNet<TInt> > Net;
152    TPt <TNodeNet<TInt> > Net1;
153    TPt <TNodeNet<TInt> > Net2;
154    int i;
155    int n;
156    int NCount;
157    int x,y;
158    Net = TNodeNet<TInt>::New();
159    EXPECT_EQ(1,Net->Empty());
160    for (i = 0; i < NNodes; i++) {
161      Net->AddNode(i,i+5);
162    }
163    EXPECT_EQ(0,Net->Empty());
164    EXPECT_EQ(NNodes,Net->GetNodes());
165    NCount = NEdges;
166    while (NCount > 0) {
167      x = (long) (drand48() * NNodes);
168      y = (long) (drand48() * NNodes);
169      if (x != y  &&  !Net->IsEdge(x,y)) {
170        n = Net->AddEdge(x, y);
171        NCount--;
172      }
173    }
174    EXPECT_EQ(NEdges,Net->GetEdges());
175    EXPECT_EQ(0,Net->Empty());
176    EXPECT_EQ(1,Net->IsOk());
177    for (i = 0; i < NNodes; i++) {
178      EXPECT_EQ(1,Net->IsNode(i));
179    }
180    EXPECT_EQ(0,Net->IsNode(NNodes));
181    EXPECT_EQ(0,Net->IsNode(NNodes+1));
182    EXPECT_EQ(0,Net->IsNode(2*NNodes));
183    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
184      EXPECT_EQ(NI.GetId()+5, Net->GetNDat(NI.GetId()));
185    }
186    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
187      Net->SetNDat(NI.GetId(), NI.GetId()+10);
188    }
189    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
190      EXPECT_EQ(NI.GetId()+10, Net->GetNDat(NI.GetId()));
191    }
192  }
193  TEST(TNodeNet, SortNodeData) {
194    int NNodes = 10000;
195    int NEdges = 100000;
<span onclick='openModal()' class='match'>196    TPt <TNodeNet<TInt> > Net;
197    TPt <TNodeNet<TInt> > Net1;
198    TPt <TNodeNet<TInt> > Net2;
199    int i;
200    int n;
201    int NCount;
202    int x,y;
203    bool Sorted;
204    int Min;
</span>205    int Value;
206    Net = TNodeNet<TInt>::New();
207    EXPECT_EQ(1,Net->Empty());
208    for (i = 0; i < NNodes; i++) {
209      Net->AddNode((i*13) % NNodes);
210    }
211    EXPECT_EQ(0,Net->Empty());
212    EXPECT_EQ(NNodes,Net->GetNodes());
213    NCount = NEdges;
214    while (NCount > 0) {
215      x = (long) (drand48() * NNodes);
216      y = (long) (drand48() * NNodes);
217      if (x != y  &&  !Net->IsEdge(x,y)) {
218        n = Net->AddEdge(x, y);
219        NCount--;
220      }
221    }
222    EXPECT_EQ(NEdges,Net->GetEdges());
223    EXPECT_EQ(0,Net->Empty());
224    EXPECT_EQ(1,Net->IsOk());
225    for (i = 0; i < NNodes; i++) {
226      EXPECT_EQ(1,Net->IsNode(i));
227    }
228    EXPECT_EQ(0,Net->IsNode(NNodes));
229    EXPECT_EQ(0,Net->IsNode(NNodes+1));
230    EXPECT_EQ(0,Net->IsNode(2*NNodes));
231    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
232      Net->SetNDat(NI.GetId(), (NI.GetId()*NI.GetId()) % NNodes);
233    }
234    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
235      EXPECT_EQ((NI.GetId()*NI.GetId()) % NNodes, Net->GetNDat(NI.GetId()));
236    }
237    Min = -1;
238    Sorted = true;
239    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
240      Value = NI.GetId();
241      if (Min > Value) {
242        Sorted = false;
243      }
244      Min = Value;
245    }
246    EXPECT_EQ(false,Sorted);
247    Net->SortNIdById();
248    Min = -1;
249    Sorted = true;
250    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
251      Value = NI.GetId();
252      if (Min > Value) {
253        Sorted = false;
254      }
255      Min = Value;
256    }
257    EXPECT_EQ(true,Sorted);
258    Min = -1;
259    Sorted = true;
260    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
261      Value = Net->GetNDat(NI.GetId());
262      if (Min > Value) {
263        Sorted = false;
264      }
265      Min = Value;
266    }
267    EXPECT_EQ(false,Sorted);
268    Net->SortNIdByDat();
269    Min = -1;
270    Sorted = true;
271    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
272      Value = Net->GetNDat(NI.GetId());
273      if (Min > Value) {
274        Sorted = false;
275      }
276      Min = Value;
277    }
278    EXPECT_EQ(true,Sorted);
279    Min = -1;
280    Sorted = true;
281    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
282      Value = NI.GetId();
283      if (Min > Value) {
284        Sorted = false;
285      }
286      Min = Value;
287    }
288    EXPECT_EQ(false,Sorted);
289    for (TNodeNet<TInt>::TNodeI NI = Net->BegNI(); NI < Net->EndNI(); NI++) {
290      EXPECT_EQ((NI.GetId()*NI.GetId()) % NNodes, Net->GetNDat(NI.GetId()));
291    }
292  }
293  TEST(TNodeNet, GetSmallGraph) {
294  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallet_55.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <nano/node/election.hpp>
5  #include <nano/node/lmdb/lmdb_iterator.hpp>
6  #include <nano/node/node.hpp>
7  #include <nano/node/wallet.hpp>
8  #include <boost/filesystem.hpp>
9  #include <boost/format.hpp>
10  #include <boost/polymorphic_cast.hpp>
11  #include <boost/property_tree/json_parser.hpp>
12  #include <future>
13  #include <argon2.h>
14  nano::uint256_union nano::wallet_store::check (nano::transaction const & transaction_a)
15  {
16  	nano::wallet_value value (entry_get_raw (transaction_a, nano::wallet_store::check_special));
17  	return value.key;
18  }
19  nano::uint256_union nano::wallet_store::salt (nano::transaction const & transaction_a)
20  {
21  	nano::wallet_value value (entry_get_raw (transaction_a, nano::wallet_store::salt_special));
22  	return value.key;
23  }
24  void nano::wallet_store::wallet_key (nano::raw_key & prv_a, nano::transaction const & transaction_a)
25  {
26  	nano::lock_guard<std::recursive_mutex> lock{ mutex };
27  	nano::raw_key wallet_l;
28  	wallet_key_mem.value (wallet_l);
29  	nano::raw_key password_l;
30  	password.value (password_l);
31  	prv_a.decrypt (wallet_l, password_l, salt (transaction_a).owords[0]);
32  }
33  void nano::wallet_store::seed (nano::raw_key & prv_a, nano::transaction const & transaction_a)
34  {
35  	nano::wallet_value value (entry_get_raw (transaction_a, nano::wallet_store::seed_special));
36  	nano::raw_key password_l;
37  	wallet_key (password_l, transaction_a);
38  	prv_a.decrypt (value.key, password_l, salt (transaction_a).owords[seed_iv_index]);
39  }
40  void nano::wallet_store::seed_set (nano::transaction const & transaction_a, nano::raw_key const & prv_a)
41  {
42  	nano::raw_key password_l;
43  	wallet_key (password_l, transaction_a);
44  	nano::raw_key ciphertext;
45  	ciphertext.encrypt (prv_a, password_l, salt (transaction_a).owords[seed_iv_index]);
46  	entry_put_raw (transaction_a, nano::wallet_store::seed_special, nano::wallet_value (ciphertext, 0));
47  	deterministic_clear (transaction_a);
48  }
49  nano::public_key nano::wallet_store::deterministic_insert (nano::transaction const & transaction_a)
50  {
51  	auto index (deterministic_index_get (transaction_a));
52  	auto prv = deterministic_key (transaction_a, index);
53  	nano::public_key result (nano::pub_key (prv));
54  	while (exists (transaction_a, result))
55  	{
56  		++index;
57  		prv = deterministic_key (transaction_a, index);
58  		result = nano::pub_key (prv);
59  	}
60  	uint64_t marker (1);
61  	marker <<= 32;
62  	marker |= index;
63  	entry_put_raw (transaction_a, result, nano::wallet_value (marker, 0));
64  	++index;
65  	deterministic_index_set (transaction_a, index);
66  	return result;
67  }
68  nano::public_key nano::wallet_store::deterministic_insert (nano::transaction const & transaction_a, uint32_t const index)
69  {
70  	auto prv = deterministic_key (transaction_a, index);
71  	nano::public_key result (nano::pub_key (prv));
72  	uint64_t marker (1);
73  	marker <<= 32;
74  	marker |= index;
75  	entry_put_raw (transaction_a, result, nano::wallet_value (marker, 0));
76  	return result;
77  }
78  nano::raw_key nano::wallet_store::deterministic_key (nano::transaction const & transaction_a, uint32_t index_a)
79  {
80  	debug_assert (valid_password (transaction_a));
81  	nano::raw_key seed_l;
82  	seed (seed_l, transaction_a);
83  	return nano::deterministic_key (seed_l, index_a);
84  }
85  uint32_t nano::wallet_store::deterministic_index_get (nano::transaction const & transaction_a)
86  {
87  	nano::wallet_value value (entry_get_raw (transaction_a, nano::wallet_store::deterministic_index_special));
88  	return static_cast<uint32_t> (value.key.number () & static_cast<uint32_t> (-1));
89  }
90  void nano::wallet_store::deterministic_index_set (nano::transaction const & transaction_a, uint32_t index_a)
91  {
92  	nano::raw_key index_l (index_a);
93  	nano::wallet_value value (index_l, 0);
94  	entry_put_raw (transaction_a, nano::wallet_store::deterministic_index_special, value);
95  }
96  void nano::wallet_store::deterministic_clear (nano::transaction const & transaction_a)
97  {
98  	nano::uint256_union key (0);
99  	for (auto i (begin (transaction_a)), n (end ()); i != n;)
100  	{
101  		switch (key_type (nano::wallet_value (i->second)))
102  		{
103  			case nano::key_type::deterministic:
104  			{
105  				auto const & key (i->first);
106  				erase (transaction_a, key);
107  				i = begin (transaction_a, key);
108  				break;
109  			}
110  			default:
111  			{
112  				++i;
113  				break;
114  			}
115  		}
116  	}
117  	deterministic_index_set (transaction_a, 0);
118  }
119  bool nano::wallet_store::valid_password (nano::transaction const & transaction_a)
120  {
121  	nano::raw_key zero;
122  	zero.clear ();
123  	nano::raw_key wallet_key_l;
124  	wallet_key (wallet_key_l, transaction_a);
125  	nano::uint256_union check_l;
126  	check_l.encrypt (zero, wallet_key_l, salt (transaction_a).owords[check_iv_index]);
127  	bool ok = check (transaction_a) == check_l;
128  	return ok;
129  }
130  bool nano::wallet_store::attempt_password (nano::transaction const & transaction_a, std::string const & password_a)
131  {
132  	bool result = false;
133  	{
134  		nano::lock_guard<std::recursive_mutex> lock{ mutex };
135  		nano::raw_key password_l;
136  		derive_key (password_l, transaction_a, password_a);
137  		password.value_set (password_l);
138  		result = !valid_password (transaction_a);
139  	}
140  	if (!result)
141  	{
142  		switch (version (transaction_a))
143  		{
144  			case version_4:
145  				break;
146  			default:
147  				debug_assert (false);
148  		}
149  	}
150  	return result;
151  }
152  bool nano::wallet_store::rekey (nano::transaction const & transaction_a, std::string const & password_a)
153  {
154  	nano::lock_guard<std::recursive_mutex> lock{ mutex };
155  	bool result (false);
156  	if (valid_password (transaction_a))
157  	{
158  		nano::raw_key password_new;
159  		derive_key (password_new, transaction_a, password_a);
160  		nano::raw_key wallet_key_l;
161  		wallet_key (wallet_key_l, transaction_a);
162  		nano::raw_key password_l;
163  		password.value (password_l);
164  		password.value_set (password_new);
165  		nano::raw_key encrypted;
166  		encrypted.encrypt (wallet_key_l, password_new, salt (transaction_a).owords[0]);
167  		nano::raw_key wallet_enc;
168  		wallet_enc = encrypted;
169  		wallet_key_mem.value_set (wallet_enc);
170  		entry_put_raw (transaction_a, nano::wallet_store::wallet_key_special, nano::wallet_value (encrypted, 0));
171  	}
172  	else
173  	{
174  		result = true;
175  	}
176  	return result;
177  }
178  void nano::wallet_store::derive_key (nano::raw_key & prv_a, nano::transaction const & transaction_a, std::string const & password_a)
179  {
180  	auto salt_l (salt (transaction_a));
181  	kdf.phs (prv_a, password_a, salt_l);
182  }
183  nano::fan::fan (nano::raw_key const & key, std::size_t count_a)
184  {
185  	auto first (std::make_unique<nano::raw_key> (key));
186  	for (auto i (1); i < count_a; ++i)
187  	{
188  		auto entry (std::make_unique<nano::raw_key> ());
189  		nano::random_pool::generate_block (entry->bytes.data (), entry->bytes.size ());
190  		*first ^= *entry;
191  		values.push_back (std::move (entry));
192  	}
193  	values.push_back (std::move (first));
194  }
195  void nano::fan::value (nano::raw_key & prv_a)
196  {
197  	nano::lock_guard<nano::mutex> lock{ mutex };
198  	value_get (prv_a);
199  }
200  void nano::fan::value_get (nano::raw_key & prv_a)
201  {
202  	debug_assert (!mutex.try_lock ());
203  	prv_a.clear ();
204  	for (auto & i : values)
205  	{
206  		prv_a ^= *i;
207  	}
208  }
209  void nano::fan::value_set (nano::raw_key const & value_a)
210  {
211  	nano::lock_guard<nano::mutex> lock{ mutex };
212  	nano::raw_key value_l;
213  	value_get (value_l);
214  	*(values[0]) ^= value_l;
215  	*(values[0]) ^= value_a;
216  }
217  nano::account const nano::wallet_store::version_special{};
<span onclick='openModal()' class='match'>218  nano::account const nano::wallet_store::salt_special (1);
219  nano::account const nano::wallet_store::wallet_key_special (2);
220  nano::account const nano::wallet_store::check_special (3);
221  nano::account const nano::wallet_store::representative_special (4);
222  nano::account const nano::wallet_store::seed_special (5);
223  nano::account const nano::wallet_store::deterministic_index_special (6);
224  int const nano::wallet_store::special_count (7);
225  std::size_t const nano::wallet_store::check_iv_index (0);
226  std::size_t const nano::wallet_store::seed_iv_index (1);
</span>227  nano::wallet_store::wallet_store (bool & init_a, nano::kdf & kdf_a, nano::transaction & transaction_a, nano::account representative_a, unsigned fanout_a, std::string const & wallet_a, std::string const & json_a) :
228  	password (0, fanout_a),
229  	wallet_key_mem (0, fanout_a),
230  	kdf (kdf_a)
231  {
232  	init_a = false;
233  	initialize (transaction_a, init_a, wallet_a);
234  	if (!init_a)
235  	{
236  		MDB_val junk;
237  		debug_assert (mdb_get (tx (transaction_a), handle, nano::mdb_val (version_special), &junk) == MDB_NOTFOUND);
238  		boost::property_tree::ptree wallet_l;
239  		std::stringstream istream (json_a);
240  		try
241  		{
242  			boost::property_tree::read_json (istream, wallet_l);
243  		}
244  		catch (...)
245  		{
246  			init_a = true;
247  		}
248  		for (auto i (wallet_l.begin ()), n (wallet_l.end ()); i != n; ++i)
249  		{
250  			nano::account key;
251  			init_a = key.decode_hex (i->first);
252  			if (!init_a)
253  			{
254  				nano::raw_key value;
255  				init_a = value.decode_hex (wallet_l.get<std::string> (i->first));
256  				if (!init_a)
257  				{
258  					entry_put_raw (transaction_a, key, nano::wallet_value (value, 0));
259  				}
260  				else
261  				{
262  					init_a = true;
263  				}
264  			}
265  			else
266  			{
267  				init_a = true;
268  			}
269  		}
270  		init_a |= mdb_get (tx (transaction_a), handle, nano::mdb_val (version_special), &junk) != 0;
271  		init_a |= mdb_get (tx (transaction_a), handle, nano::mdb_val (wallet_key_special), &junk) != 0;
272  		init_a |= mdb_get (tx (transaction_a), handle, nano::mdb_val (salt_special), &junk) != 0;
273  		init_a |= mdb_get (tx (transaction_a), handle, nano::mdb_val (check_special), &junk) != 0;
274  		init_a |= mdb_get (tx (transaction_a), handle, nano::mdb_val (representative_special), &junk) != 0;
275  		nano::raw_key key;
276  		key.clear ();
277  		password.value_set (key);
278  		key = entry_get_raw (transaction_a, nano::wallet_store::wallet_key_special).key;
279  		wallet_key_mem.value_set (key);
280  	}
281  }
282  nano::wallet_store::wallet_store (bool & init_a, nano::kdf & kdf_a, nano::transaction & transaction_a, nano::account representative_a, unsigned fanout_a, std::string const & wallet_a) :
283  	password (0, fanout_a),
284  	wallet_key_mem (0, fanout_a),
285  	kdf (kdf_a)
286  {
287  	init_a = false;
288  	initialize (transaction_a, init_a, wallet_a);
289  	if (!init_a)
290  	{
291  		int version_status;
292  		MDB_val version_value;
293  		version_status = mdb_get (tx (transaction_a), handle, nano::mdb_val (version_special), &version_value);
294  		if (version_status == MDB_NOTFOUND)
295  		{
296  			version_put (transaction_a, version_current);
297  			nano::raw_key salt_l;
298  			random_pool::generate_block (salt_l.bytes.data (), salt_l.bytes.size ());
299  			entry_put_raw (transaction_a, nano::wallet_store::salt_special, nano::wallet_value (salt_l, 0));
300  			nano::raw_key wallet_key;
301  			random_pool::generate_block (wallet_key.bytes.data (), sizeof (wallet_key.bytes));
302  			nano::raw_key password_l;
303  			password_l.clear ();
304  			password.value_set (password_l);
305  			nano::raw_key zero;
306  			zero.clear ();
307  			nano::raw_key encrypted;
308  			encrypted.encrypt (wallet_key, zero, salt_l.owords[0]);
309  			entry_put_raw (transaction_a, nano::wallet_store::wallet_key_special, nano::wallet_value (encrypted, 0));
310  			nano::raw_key wallet_key_enc;
311  			wallet_key_enc = encrypted;
312  			wallet_key_mem.value_set (wallet_key_enc);
313  			nano::raw_key check;
314  			check.encrypt (zero, wallet_key, salt_l.owords[check_iv_index]);
315  			entry_put_raw (transaction_a, nano::wallet_store::check_special, nano::wallet_value (check, 0));
316  			nano::raw_key rep;
317  			rep.bytes = representative_a.bytes;
318  			entry_put_raw (transaction_a, nano::wallet_store::representative_special, nano::wallet_value (rep, 0));
319  			nano::raw_key seed;
320  			random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
321  			seed_set (transaction_a, seed);
322  			entry_put_raw (transaction_a, nano::wallet_store::deterministic_index_special, nano::wallet_value (0, 0));
323  		}
324  	}
325  	nano::raw_key key;
326  	key = entry_get_raw (transaction_a, nano::wallet_store::wallet_key_special).key;
327  	wallet_key_mem.value_set (key);
328  }
329  std::vector<nano::account> nano::wallet_store::accounts (nano::transaction const & transaction_a)
330  {
331  	std::vector<nano::account> result;
332  	for (auto i (begin (transaction_a)), n (end ()); i != n; ++i)
333  	{
334  		nano::account const & account (i->first);
335  		result.push_back (account);
336  	}
337  	return result;
338  }
339  void nano::wallet_store::initialize (nano::transaction const & transaction_a, bool & init_a, std::string const & path_a)
340  {
341  	debug_assert (strlen (path_a.c_str ()) == path_a.size ());
342  	auto error (0);
343  	MDB_dbi handle_l;
344  	error |= mdb_dbi_open (tx (transaction_a), path_a.c_str (), MDB_CREATE, &handle_l);
345  	handle = handle_l;
346  	init_a = error != 0;
347  }
348  bool nano::wallet_store::is_representative (nano::transaction const & transaction_a)
349  {
350  	return exists (transaction_a, representative (transaction_a));
351  }
352  void nano::wallet_store::representative_set (nano::transaction const & transaction_a, nano::account const & representative_a)
353  {
354  	nano::raw_key rep;
355  	rep.bytes = representative_a.bytes;
356  	entry_put_raw (transaction_a, nano::wallet_store::representative_special, nano::wallet_value (rep, 0));
357  }
358  nano::account nano::wallet_store::representative (nano::transaction const & transaction_a)
359  {
360  	nano::wallet_value value (entry_get_raw (transaction_a, nano::wallet_store::representative_special));
361  	return reinterpret_cast<nano::account const &> (value.key);
362  }
363  nano::public_key nano::wallet_store::insert_adhoc (nano::transaction const & transaction_a, nano::raw_key const & prv)
364  {
365  	debug_assert (valid_password (transaction_a));
366  	nano::public_key pub (nano::pub_key (prv));
367  	nano::raw_key password_l;
368  	wallet_key (password_l, transaction_a);
369  	nano::raw_key ciphertext;
370  	ciphertext.encrypt (prv, password_l, pub.owords[0].number ());
371  	entry_put_raw (transaction_a, pub, nano::wallet_value (ciphertext, 0));
372  	return pub;
373  }
374  bool nano::wallet_store::insert_watch (nano::transaction const & transaction_a, nano::account const & pub_a)
375  {
376  	bool error (!valid_public_key (pub_a));
377  	if (!error)
378  	{
379  		entry_put_raw (transaction_a, pub_a, nano::wallet_value (nano::raw_key (0), 0));
380  	}
381  	return error;
382  }
383  void nano::wallet_store::erase (nano::transaction const & transaction_a, nano::account const & pub)
384  {
385  	auto status (mdb_del (tx (transaction_a), handle, nano::mdb_val (pub), nullptr));
386  	(void)status;
387  	debug_assert (status == 0);
388  }
389  nano::wallet_value nano::wallet_store::entry_get_raw (nano::transaction const & transaction_a, nano::account const & pub_a)
390  {
391  	nano::wallet_value result;
392  	nano::mdb_val value;
393  	auto status (mdb_get (tx (transaction_a), handle, nano::mdb_val (pub_a), value));
394  	if (status == 0)
395  	{
396  		result = nano::wallet_value (value);
397  	}
398  	else
399  	{
400  		result.key.clear ();
401  		result.work = 0;
402  	}
403  	return result;
404  }
405  void nano::wallet_store::entry_put_raw (nano::transaction const & transaction_a, nano::account const & pub_a, nano::wallet_value const & entry_a)
406  {
407  	auto status (mdb_put (tx (transaction_a), handle, nano::mdb_val (pub_a), nano::mdb_val (sizeof (entry_a), const_cast<nano::wallet_value *> (&entry_a)), 0));
408  	(void)status;
409  	debug_assert (status == 0);
410  }
411  nano::key_type nano::wallet_store::key_type (nano::wallet_value const & value_a)
412  {
413  	auto number (value_a.key.number ());
414  	nano::key_type result;
415  	auto text (number.convert_to<std::string> ());
416  	if (number > std::numeric_limits<uint64_t>::max ())
417  	{
418  		result = nano::key_type::adhoc;
419  	}
420  	else
421  	{
422  		if ((number >> 32).convert_to<uint32_t> () == 1)
423  		{
424  			result = nano::key_type::deterministic;
425  		}
426  		else
427  		{
428  			result = nano::key_type::unknown;
429  		}
430  	}
431  	return result;
432  }
433  bool nano::wallet_store::fetch (nano::transaction const & transaction_a, nano::account const & pub, nano::raw_key & prv)
434  {
435  	auto result (false);
436  	if (valid_password (transaction_a))
437  	{
438  		nano::wallet_value value (entry_get_raw (transaction_a, pub));
439  		if (!value.key.is_zero ())
440  		{
441  			switch (key_type (value))
442  			{
443  				case nano::key_type::deterministic:
444  				{
445  					nano::raw_key seed_l;
446  					seed (seed_l, transaction_a);
447  					uint32_t index (static_cast<uint32_t> (value.key.number () & static_cast<uint32_t> (-1)));
448  					prv = deterministic_key (transaction_a, index);
449  					break;
450  				}
451  				case nano::key_type::adhoc:
452  				{
453  					nano::raw_key password_l;
454  					wallet_key (password_l, transaction_a);
455  					prv.decrypt (value.key, password_l, pub.owords[0].number ());
456  					break;
457  				}
458  				default:
459  				{
460  					result = true;
461  					break;
462  				}
463  			}
464  		}
465  		else
466  		{
467  			result = true;
468  		}
469  	}
470  	else
471  	{
472  		result = true;
473  	}
474  	if (!result)
475  	{
476  		nano::public_key compare (nano::pub_key (prv));
477  		if (!(pub == compare))
478  		{
479  			result = true;
480  		}
481  	}
482  	return result;
483  }
484  bool nano::wallet_store::valid_public_key (nano::public_key const & pub)
485  {
486  	return pub.number () >= special_count;
487  }
488  bool nano::wallet_store::exists (nano::transaction const & transaction_a, nano::public_key const & pub)
489  {
490  	return valid_public_key (pub) && find (transaction_a, pub) != end ();
491  }
492  void nano::wallet_store::serialize_json (nano::transaction const & transaction_a, std::string & string_a)
493  {
494  	boost::property_tree::ptree tree;
495  	for (nano::store_iterator<nano::uint256_union, nano::wallet_value> i (std::make_unique<nano::mdb_iterator<nano::uint256_union, nano::wallet_value>> (transaction_a, handle)), n (nullptr); i != n; ++i)
496  	{
497  		tree.put (i->first.to_string (), i->second.key.to_string ());
498  	}
499  	std::stringstream ostream;
500  	boost::property_tree::write_json (ostream, tree);
501  	string_a = ostream.str ();
502  }
503  void nano::wallet_store::write_backup (nano::transaction const & transaction_a, boost::filesystem::path const & path_a)
504  {
505  	std::ofstream backup_file;
506  	backup_file.open (path_a.string ());
507  	if (!backup_file.fail ())
508  	{
509  		boost::system::error_code ec;
510  		nano::set_secure_perm_file (path_a, ec);
511  		std::string json;
512  		serialize_json (transaction_a, json);
513  		backup_file << json;
514  	}
515  }
516  bool nano::wallet_store::move (nano::transaction const & transaction_a, nano::wallet_store & other_a, std::vector<nano::public_key> const & keys)
517  {
518  	debug_assert (valid_password (transaction_a));
519  	debug_assert (other_a.valid_password (transaction_a));
520  	auto result (false);
521  	for (auto i (keys.begin ()), n (keys.end ()); i != n; ++i)
522  	{
523  		nano::raw_key prv;
524  		auto error (other_a.fetch (transaction_a, *i, prv));
525  		result = result | error;
526  		if (!result)
527  		{
528  			insert_adhoc (transaction_a, prv);
529  			other_a.erase (transaction_a, *i);
530  		}
531  	}
532  	return result;
533  }
534  bool nano::wallet_store::import (nano::transaction const & transaction_a, nano::wallet_store & other_a)
535  {
536  	debug_assert (valid_password (transaction_a));
537  	debug_assert (other_a.valid_password (transaction_a));
538  	auto result (false);
539  	for (auto i (other_a.begin (transaction_a)), n (end ()); i != n; ++i)
540  	{
541  		nano::raw_key prv;
542  		auto error (other_a.fetch (transaction_a, i->first, prv));
543  		result = result | error;
544  		if (!result)
545  		{
546  			if (!prv.is_zero ())
547  			{
548  				insert_adhoc (transaction_a, prv);
549  			}
550  			else
551  			{
552  				insert_watch (transaction_a, i->first);
553  			}
554  			other_a.erase (transaction_a, i->first);
555  		}
556  	}
557  	return result;
558  }
559  bool nano::wallet_store::work_get (nano::transaction const & transaction_a, nano::public_key const & pub_a, uint64_t & work_a)
560  {
561  	auto result (false);
562  	auto entry (entry_get_raw (transaction_a, pub_a));
563  	if (!entry.key.is_zero ())
564  	{
565  		work_a = entry.work;
566  	}
567  	else
568  	{
569  		result = true;
570  	}
571  	return result;
572  }
573  void nano::wallet_store::work_put (nano::transaction const & transaction_a, nano::public_key const & pub_a, uint64_t work_a)
574  {
575  	auto entry (entry_get_raw (transaction_a, pub_a));
576  	debug_assert (!entry.key.is_zero ());
577  	entry.work = work_a;
578  	entry_put_raw (transaction_a, pub_a, entry);
579  }
580  unsigned nano::wallet_store::version (nano::transaction const & transaction_a)
581  {
582  	nano::wallet_value value (entry_get_raw (transaction_a, nano::wallet_store::version_special));
583  	auto entry (value.key);
584  	auto result (static_cast<unsigned> (entry.bytes[31]));
585  	return result;
586  }
587  void nano::wallet_store::version_put (nano::transaction const & transaction_a, unsigned version_a)
588  {
589  	nano::raw_key entry (version_a);
590  	entry_put_raw (transaction_a, nano::wallet_store::version_special, nano::wallet_value (entry, 0));
591  }
592  void nano::kdf::phs (nano::raw_key & result_a, std::string const & password_a, nano::uint256_union const & salt_a)
593  {
594  	nano::lock_guard<nano::mutex> lock{ mutex };
595  	auto success (argon2_hash (1, kdf_work, 1, password_a.data (), password_a.size (), salt_a.bytes.data (), salt_a.bytes.size (), result_a.bytes.data (), result_a.bytes.size (), NULL, 0, Argon2_d, 0x10));
596  	debug_assert (success == 0);
597  	(void)success;
598  }
599  nano::wallet::wallet (bool & init_a, nano::transaction & transaction_a, nano::wallets & wallets_a, std::string const & wallet_a) :
600  	lock_observer ([] (bool, bool) {}),
601  	store (init_a, wallets_a.kdf, transaction_a, wallets_a.node.config.random_representative (), wallets_a.node.config.password_fanout, wallet_a),
602  	wallets (wallets_a)
603  {
604  }
605  nano::wallet::wallet (bool & init_a, nano::transaction & transaction_a, nano::wallets & wallets_a, std::string const & wallet_a, std::string const & json) :
606  	lock_observer ([] (bool, bool) {}),
607  	store (init_a, wallets_a.kdf, transaction_a, wallets_a.node.config.random_representative (), wallets_a.node.config.password_fanout, wallet_a, json),
608  	wallets (wallets_a)
609  {
610  }
611  void nano::wallet::enter_initial_password ()
612  {
613  	nano::raw_key password_l;
614  	{
615  		nano::lock_guard<std::recursive_mutex> lock{ store.mutex };
616  		store.password.value (password_l);
617  	}
618  	if (password_l.is_zero ())
619  	{
620  		auto transaction (wallets.tx_begin_write ());
621  		if (store.valid_password (transaction))
622  		{
623  			store.rekey (transaction, "");
624  		}
625  		else
626  		{
627  			enter_password (transaction, "");
628  		}
629  	}
630  }
631  bool nano::wallet::enter_password (nano::transaction const & transaction_a, std::string const & password_a)
632  {
633  	auto result (store.attempt_password (transaction_a, password_a));
634  	if (!result)
635  	{
636  		auto this_l (shared_from_this ());
637  		wallets.node.background ([this_l] () {
638  			this_l->search_receivable (this_l->wallets.tx_begin_read ());
639  		});
640  		wallets.node.logger.try_log ("Wallet unlocked");
641  	}
642  	else
643  	{
644  		wallets.node.logger.try_log ("Invalid password, wallet locked");
645  	}
646  	lock_observer (result, password_a.empty ());
647  	return result;
648  }
649  nano::public_key nano::wallet::deterministic_insert (nano::transaction const & transaction_a, bool generate_work_a)
650  {
651  	nano::public_key key{};
652  	if (store.valid_password (transaction_a))
653  	{
654  		key = store.deterministic_insert (transaction_a);
655  		if (generate_work_a)
656  		{
657  			work_ensure (key, key);
658  		}
659  		auto half_principal_weight (wallets.node.minimum_principal_weight () / 2);
660  		if (wallets.check_rep (key, half_principal_weight))
661  		{
662  			nano::lock_guard<nano::mutex> lock{ representatives_mutex };
663  			representatives.insert (key);
664  		}
665  	}
666  	return key;
667  }
668  nano::public_key nano::wallet::deterministic_insert (uint32_t const index, bool generate_work_a)
669  {
670  	auto transaction (wallets.tx_begin_write ());
671  	nano::public_key key{};
672  	if (store.valid_password (transaction))
673  	{
674  		key = store.deterministic_insert (transaction, index);
675  		if (generate_work_a)
676  		{
677  			work_ensure (key, key);
678  		}
679  	}
680  	return key;
681  }
682  nano::public_key nano::wallet::deterministic_insert (bool generate_work_a)
683  {
684  	auto transaction (wallets.tx_begin_write ());
685  	auto result (deterministic_insert (transaction, generate_work_a));
686  	return result;
687  }
688  nano::public_key nano::wallet::insert_adhoc (nano::raw_key const & key_a, bool generate_work_a)
689  {
690  	nano::public_key key{};
691  	auto transaction (wallets.tx_begin_write ());
692  	if (store.valid_password (transaction))
693  	{
694  		key = store.insert_adhoc (transaction, key_a);
695  		auto block_transaction (wallets.node.store.tx_begin_read ());
696  		if (generate_work_a)
697  		{
698  			work_ensure (key, wallets.node.ledger.latest_root (block_transaction, key));
699  		}
700  		auto half_principal_weight (wallets.node.minimum_principal_weight () / 2);
701  		transaction.commit ();
702  		if (wallets.check_rep (key, half_principal_weight))
703  		{
704  			nano::lock_guard<nano::mutex> lock{ representatives_mutex };
705  			representatives.insert (key);
706  		}
707  	}
708  	return key;
709  }
710  bool nano::wallet::insert_watch (nano::transaction const & transaction_a, nano::public_key const & pub_a)
711  {
712  	return store.insert_watch (transaction_a, pub_a);
713  }
714  bool nano::wallet::exists (nano::public_key const & account_a)
715  {
716  	auto transaction (wallets.tx_begin_read ());
717  	return store.exists (transaction, account_a);
718  }
719  bool nano::wallet::import (std::string const & json_a, std::string const & password_a)
720  {
721  	auto error (false);
722  	std::unique_ptr<nano::wallet_store> temp;
723  	{
724  		auto transaction (wallets.tx_begin_write ());
725  		nano::uint256_union id;
726  		random_pool::generate_block (id.bytes.data (), id.bytes.size ());
727  		temp = std::make_unique<nano::wallet_store> (error, wallets.node.wallets.kdf, transaction, 0, 1, id.to_string (), json_a);
728  	}
729  	if (!error)
730  	{
731  		auto transaction (wallets.tx_begin_write ());
732  		error = temp->attempt_password (transaction, password_a);
733  	}
734  	auto transaction (wallets.tx_begin_write ());
735  	if (!error)
736  	{
737  		error = store.import (transaction, *temp);
738  	}
739  	temp->destroy (transaction);
740  	return error;
741  }
742  void nano::wallet::serialize (std::string & json_a)
743  {
744  	auto transaction (wallets.tx_begin_read ());
745  	store.serialize_json (transaction, json_a);
746  }
747  void nano::wallet_store::destroy (nano::transaction const & transaction_a)
748  {
749  	auto status (mdb_drop (tx (transaction_a), handle, 1));
750  	(void)status;
751  	debug_assert (status == 0);
752  	handle = 0;
753  }
754  std::shared_ptr<nano::block> nano::wallet::receive_action (nano::block_hash const & send_hash_a, nano::account const & representative_a, nano::uint128_union const & amount_a, nano::account const & account_a, uint64_t work_a, bool generate_work_a)
755  {
756  	std::shared_ptr<nano::block> block;
757  	nano::block_details details;
758  	details.is_receive = true;
759  	if (wallets.node.config.receive_minimum.number () <= amount_a.number ())
760  	{
761  		auto block_transaction (wallets.node.ledger.store.tx_begin_read ());
762  		auto transaction (wallets.tx_begin_read ());
763  		if (wallets.node.ledger.block_or_pruned_exists (block_transaction, send_hash_a))
764  		{
765  			auto pending_info = wallets.node.ledger.pending_info (block_transaction, nano::pending_key (account_a, send_hash_a));
766  			if (pending_info)
767  			{
768  				nano::raw_key prv;
769  				if (!store.fetch (transaction, account_a, prv))
770  				{
771  					if (work_a == 0)
772  					{
773  						store.work_get (transaction, account_a, work_a);
774  					}
775  					auto info = wallets.node.ledger.account_info (block_transaction, account_a);
776  					if (info)
777  					{
778  						block = std::make_shared<nano::state_block> (account_a, info->head, info->representative, info->balance.number () + pending_info->amount.number (), send_hash_a, prv, account_a, work_a);
779  						details.epoch = std::max (info->epoch (), pending_info->epoch);
780  					}
781  					else
782  					{
783  						block = std::make_shared<nano::state_block> (account_a, 0, representative_a, pending_info->amount, reinterpret_cast<nano::link const &> (send_hash_a), prv, account_a, work_a);
784  						details.epoch = pending_info->epoch;
785  					}
786  				}
787  				else
788  				{
789  					wallets.node.logger.try_log ("Unable to receive, wallet locked");
790  				}
791  			}
792  			else
793  			{
794  			}
795  		}
796  		else
797  		{
798  		}
799  	}
800  	else
801  	{
802  		wallets.node.logger.try_log (boost::str (boost::format ("Not receiving block %1% due to minimum receive threshold") % send_hash_a.to_string ()));
803  	}
804  	if (block != nullptr)
805  	{
806  		if (action_complete (block, account_a, generate_work_a, details))
807  		{
808  			block = nullptr;
809  		}
810  	}
811  	return block;
812  }
813  std::shared_ptr<nano::block> nano::wallet::change_action (nano::account const & source_a, nano::account const & representative_a, uint64_t work_a, bool generate_work_a)
814  {
815  	std::shared_ptr<nano::block> block;
816  	nano::block_details details;
817  	{
818  		auto transaction (wallets.tx_begin_read ());
819  		auto block_transaction (wallets.node.store.tx_begin_read ());
820  		if (store.valid_password (transaction))
821  		{
822  			auto existing (store.find (transaction, source_a));
823  			if (existing != store.end () && !wallets.node.ledger.latest (block_transaction, source_a).is_zero ())
824  			{
825  				auto info = wallets.node.ledger.account_info (block_transaction, source_a);
826  				debug_assert (info);
827  				nano::raw_key prv;
828  				auto error2 (store.fetch (transaction, source_a, prv));
829  				(void)error2;
830  				debug_assert (!error2);
831  				if (work_a == 0)
832  				{
833  					store.work_get (transaction, source_a, work_a);
834  				}
835  				block = std::make_shared<nano::state_block> (source_a, info->head, representative_a, info->balance, 0, prv, source_a, work_a);
836  				details.epoch = info->epoch ();
837  			}
838  		}
839  	}
840  	if (block != nullptr)
841  	{
842  		if (action_complete (block, source_a, generate_work_a, details))
843  		{
844  			block = nullptr;
845  		}
846  	}
847  	return block;
848  }
849  std::shared_ptr<nano::block> nano::wallet::send_action (nano::account const & source_a, nano::account const & account_a, nano::uint128_t const & amount_a, uint64_t work_a, bool generate_work_a, boost::optional<std::string> id_a)
850  {
851  	boost::optional<nano::mdb_val> id_mdb_val;
852  	if (id_a)
853  	{
854  		id_mdb_val = nano::mdb_val (id_a->size (), const_cast<char *> (id_a->data ()));
855  	}
856  	auto prepare_send = [&id_mdb_val, &wallets = this->wallets, &store = this->store, &source_a, &amount_a, &work_a, &account_a] (auto const & transaction) {
857  		auto block_transaction (wallets.node.store.tx_begin_read ());
858  		auto error (false);
859  		auto cached_block (false);
860  		std::shared_ptr<nano::block> block;
861  		nano::block_details details;
862  		details.is_send = true;
863  		if (id_mdb_val)
864  		{
865  			nano::mdb_val result;
866  			auto status (mdb_get (wallets.env.tx (transaction), wallets.node.wallets.send_action_ids, *id_mdb_val, result));
867  			if (status == 0)
868  			{
869  				nano::block_hash hash (result);
870  				block = wallets.node.store.block.get (block_transaction, hash);
871  				if (block != nullptr)
872  				{
873  					cached_block = true;
874  					wallets.node.network.flood_block (block, nano::transport::buffer_drop_policy::no_limiter_drop);
875  				}
876  			}
877  			else if (status != MDB_NOTFOUND)
878  			{
879  				error = true;
880  			}
881  		}
882  		if (!error && block == nullptr)
883  		{
884  			if (store.valid_password (transaction))
885  			{
886  				auto existing (store.find (transaction, source_a));
887  				if (existing != store.end ())
888  				{
889  					auto balance (wallets.node.ledger.account_balance (block_transaction, source_a));
890  					if (!balance.is_zero () && balance >= amount_a)
891  					{
892  						auto info = wallets.node.ledger.account_info (block_transaction, source_a);
893  						debug_assert (info);
894  						nano::raw_key prv;
895  						auto error2 (store.fetch (transaction, source_a, prv));
896  						(void)error2;
897  						debug_assert (!error2);
898  						if (work_a == 0)
899  						{
900  							store.work_get (transaction, source_a, work_a);
901  						}
902  						block = std::make_shared<nano::state_block> (source_a, info->head, info->representative, balance - amount_a, account_a, prv, source_a, work_a);
903  						details.epoch = info->epoch ();
904  						if (id_mdb_val && block != nullptr)
905  						{
906  							auto status (mdb_put (wallets.env.tx (transaction), wallets.node.wallets.send_action_ids, *id_mdb_val, nano::mdb_val (block->hash ()), 0));
907  							if (status != 0)
908  							{
909  								block = nullptr;
910  								error = true;
911  							}
912  						}
913  					}
914  				}
915  			}
916  		}
917  		return std::make_tuple (block, error, cached_block, details);
918  	};
919  	std::tuple<std::shared_ptr<nano::block>, bool, bool, nano::block_details> result;
920  	{
921  		if (id_mdb_val)
922  		{
923  			result = prepare_send (wallets.tx_begin_write ());
924  		}
925  		else
926  		{
927  			result = prepare_send (wallets.tx_begin_read ());
928  		}
929  	}
930  	std::shared_ptr<nano::block> block;
931  	bool error;
932  	bool cached_block;
933  	nano::block_details details;
934  	std::tie (block, error, cached_block, details) = result;
935  	if (!error && block != nullptr && !cached_block)
936  	{
937  		if (action_complete (block, source_a, generate_work_a, details))
938  		{
939  			block = nullptr;
940  		}
941  	}
942  	return block;
943  }
944  bool nano::wallet::action_complete (std::shared_ptr<nano::block> const & block_a, nano::account const & account_a, bool const generate_work_a, nano::block_details const & details_a)
945  {
946  	bool error{ false };
947  	wallets.delayed_work->erase (account_a);
948  	if (block_a != nullptr)
949  	{
950  		auto required_difficulty{ wallets.node.network_params.work.threshold (block_a->work_version (), details_a) };
951  		if (wallets.node.network_params.work.difficulty (*block_a) < required_difficulty)
952  		{
953  			wallets.node.logger.try_log (boost::str (boost::format ("Cached or provided work for block %1% account %2% is invalid, regenerating") % block_a->hash ().to_string () % account_a.to_account ()));
954  			debug_assert (required_difficulty <= wallets.node.max_work_generate_difficulty (block_a->work_version ()));
955  			error = !wallets.node.work_generate_blocking (*block_a, required_difficulty).is_initialized ();
956  		}
957  		if (!error)
958  		{
959  			auto result = wallets.node.process_local (block_a);
960  			error = !result || result.value ().code != nano::process_result::progress;
961  			debug_assert (error || block_a->sideband ().details == details_a);
962  		}
963  		if (!error && generate_work_a)
964  		{
965  			work_ensure (account_a, block_a->hash ());
966  		}
967  	}
968  	return error;
969  }
970  bool nano::wallet::change_sync (nano::account const & source_a, nano::account const & representative_a)
971  {
972  	std::promise<bool> result;
973  	std::future<bool> future = result.get_future ();
974  	change_async (
975  	source_a, representative_a, [&result] (std::shared_ptr<nano::block> const & block_a) {
976  		result.set_value (block_a == nullptr);
977  	},
978  	true);
979  	return future.get ();
980  }
981  void nano::wallet::change_async (nano::account const & source_a, nano::account const & representative_a, std::function<void (std::shared_ptr<nano::block> const &)> const & action_a, uint64_t work_a, bool generate_work_a)
982  {
983  	auto this_l (shared_from_this ());
984  	wallets.node.wallets.queue_wallet_action (nano::wallets::high_priority, this_l, [this_l, source_a, representative_a, action_a, work_a, generate_work_a] (nano::wallet & wallet_a) {
985  		auto block (wallet_a.change_action (source_a, representative_a, work_a, generate_work_a));
986  		action_a (block);
987  	});
988  }
989  bool nano::wallet::receive_sync (std::shared_ptr<nano::block> const & block_a, nano::account const & representative_a, nano::uint128_t const & amount_a)
990  {
991  	std::promise<bool> result;
992  	std::future<bool> future = result.get_future ();
993  	auto destination (block_a->link ().is_zero () ? block_a->destination () : block_a->link ().as_account ());
994  	receive_async (
995  	block_a->hash (), representative_a, amount_a, destination, [&result] (std::shared_ptr<nano::block> const & block_a) {
996  		result.set_value (block_a == nullptr);
997  	},
998  	true);
999  	return future.get ();
1000  }
1001  void nano::wallet::receive_async (nano::block_hash const & hash_a, nano::account const & representative_a, nano::uint128_t const & amount_a, nano::account const & account_a, std::function<void (std::shared_ptr<nano::block> const &)> const & action_a, uint64_t work_a, bool generate_work_a)
1002  {
1003  	auto this_l (shared_from_this ());
1004  	wallets.node.wallets.queue_wallet_action (amount_a, this_l, [this_l, hash_a, representative_a, amount_a, account_a, action_a, work_a, generate_work_a] (nano::wallet & wallet_a) {
1005  		auto block (wallet_a.receive_action (hash_a, representative_a, amount_a, account_a, work_a, generate_work_a));
1006  		action_a (block);
1007  	});
1008  }
1009  nano::block_hash nano::wallet::send_sync (nano::account const & source_a, nano::account const & account_a, nano::uint128_t const & amount_a)
1010  {
1011  	std::promise<nano::block_hash> result;
1012  	std::future<nano::block_hash> future = result.get_future ();
1013  	send_async (
1014  	source_a, account_a, amount_a, [&result] (std::shared_ptr<nano::block> const & block_a) {
1015  		result.set_value (block_a->hash ());
1016  	},
1017  	true);
1018  	return future.get ();
1019  }
1020  void nano::wallet::send_async (nano::account const & source_a, nano::account const & account_a, nano::uint128_t const & amount_a, std::function<void (std::shared_ptr<nano::block> const &)> const & action_a, uint64_t work_a, bool generate_work_a, boost::optional<std::string> id_a)
1021  {
1022  	auto this_l (shared_from_this ());
1023  	wallets.node.wallets.queue_wallet_action (nano::wallets::high_priority, this_l, [this_l, source_a, account_a, amount_a, action_a, work_a, generate_work_a, id_a] (nano::wallet & wallet_a) {
1024  		auto block (wallet_a.send_action (source_a, account_a, amount_a, work_a, generate_work_a, id_a));
1025  		action_a (block);
1026  	});
1027  }
1028  void nano::wallet::work_update (nano::transaction const & transaction_a, nano::account const & account_a, nano::root const & root_a, uint64_t work_a)
1029  {
1030  	debug_assert (!wallets.node.network_params.work.validate_entry (nano::work_version::work_1, root_a, work_a));
1031  	debug_assert (store.exists (transaction_a, account_a));
1032  	auto block_transaction (wallets.node.store.tx_begin_read ());
1033  	auto latest (wallets.node.ledger.latest_root (block_transaction, account_a));
1034  	if (latest == root_a)
1035  	{
1036  		store.work_put (transaction_a, account_a, work_a);
1037  	}
1038  	else
1039  	{
1040  		wallets.node.logger.try_log ("Cached work no longer valid, discarding");
1041  	}
1042  }
1043  void nano::wallet::work_ensure (nano::account const & account_a, nano::root const & root_a)
1044  {
1045  	using namespace std::chrono_literals;
1046  	std::chrono::seconds const precache_delay = wallets.node.network_params.network.is_dev_network () ? 1s : 10s;
1047  	wallets.delayed_work->operator[] (account_a) = root_a;
1048  	wallets.node.workers.add_timed_task (std::chrono::steady_clock::now () + precache_delay, [this_l = shared_from_this (), account_a, root_a] {
1049  		auto delayed_work = this_l->wallets.delayed_work.lock ();
1050  		auto existing (delayed_work->find (account_a));
1051  		if (existing != delayed_work->end () && existing->second == root_a)
1052  		{
1053  			delayed_work->erase (existing);
1054  			this_l->wallets.queue_wallet_action (nano::wallets::generate_priority, this_l, [account_a, root_a] (nano::wallet & wallet_a) {
1055  				wallet_a.work_cache_blocking (account_a, root_a);
1056  			});
1057  		}
1058  	});
1059  }
1060  bool nano::wallet::search_receivable (nano::transaction const & wallet_transaction_a)
1061  {
1062  	auto result (!store.valid_password (wallet_transaction_a));
1063  	if (!result)
1064  	{
1065  		wallets.node.logger.try_log ("Beginning receivable block search");
1066  		for (auto i (store.begin (wallet_transaction_a)), n (store.end ()); i != n; ++i)
1067  		{
1068  			auto block_transaction (wallets.node.store.tx_begin_read ());
1069  			nano::account const & account (i->first);
1070  			if (!nano::wallet_value (i->second).key.is_zero ())
1071  			{
1072  				for (auto j (wallets.node.store.pending.begin (block_transaction, nano::pending_key (account, 0))), k (wallets.node.store.pending.end ()); j != k && nano::pending_key (j->first).account == account; ++j)
1073  				{
1074  					nano::pending_key key (j->first);
1075  					auto hash (key.hash);
1076  					nano::pending_info pending (j->second);
1077  					auto amount (pending.amount.number ());
1078  					if (wallets.node.config.receive_minimum.number () <= amount)
1079  					{
1080  						wallets.node.logger.try_log (boost::str (boost::format ("Found a receivable block %1% for account %2%") % hash.to_string () % pending.source.to_account ()));
1081  						if (wallets.node.ledger.block_confirmed (block_transaction, hash))
1082  						{
1083  							auto representative = store.representative (wallet_transaction_a);
1084  							receive_async (hash, representative, amount, account, [] (std::shared_ptr<nano::block> const &) {});
1085  						}
1086  						else if (!wallets.node.confirmation_height_processor.is_processing_block (hash))
1087  						{
1088  							auto block (wallets.node.store.block.get (block_transaction, hash));
1089  							if (block)
1090  							{
1091  								wallets.node.block_confirm (block);
1092  							}
1093  						}
1094  					}
1095  				}
1096  			}
1097  		}
1098  		wallets.node.logger.try_log ("Receivable block search phase completed");
1099  	}
1100  	else
1101  	{
1102  		wallets.node.logger.try_log ("Stopping search, wallet is locked");
1103  	}
1104  	return result;
1105  }
1106  void nano::wallet::init_free_accounts (nano::transaction const & transaction_a)
1107  {
1108  	free_accounts.clear ();
1109  	for (auto i (store.begin (transaction_a)), n (store.end ()); i != n; ++i)
1110  	{
1111  		free_accounts.insert (i->first);
1112  	}
1113  }
1114  uint32_t nano::wallet::deterministic_check (nano::transaction const & transaction_a, uint32_t index)
1115  {
1116  	auto block_transaction (wallets.node.store.tx_begin_read ());
1117  	for (uint32_t i (index + 1), n (index + 64); i < n; ++i)
1118  	{
1119  		auto prv = store.deterministic_key (transaction_a, i);
1120  		nano::keypair pair (prv.to_string ());
1121  		auto latest (wallets.node.ledger.latest (block_transaction, pair.pub));
1122  		if (!latest.is_zero ())
1123  		{
1124  			index = i;
1125  			n = i + 64 + (i / 64);
1126  		}
1127  		else
1128  		{
1129  			for (auto ii (wallets.node.store.pending.begin (block_transaction, nano::pending_key (pair.pub, 0))), nn (wallets.node.store.pending.end ()); ii != nn && nano::pending_key (ii->first).account == pair.pub; ++ii)
1130  			{
1131  				index = i;
1132  				n = i + 64 + (i / 64);
1133  				break;
1134  			}
1135  		}
1136  	}
1137  	return index;
1138  }
1139  nano::public_key nano::wallet::change_seed (nano::transaction const & transaction_a, nano::raw_key const & prv_a, uint32_t count)
1140  {
1141  	store.seed_set (transaction_a, prv_a);
1142  	auto account = deterministic_insert (transaction_a);
1143  	if (count == 0)
1144  	{
1145  		count = deterministic_check (transaction_a, 0);
1146  	}
1147  	for (uint32_t i (0); i < count; ++i)
1148  	{
1149  		account = deterministic_insert (transaction_a, false);
1150  	}
1151  	return account;
1152  }
1153  void nano::wallet::deterministic_restore (nano::transaction const & transaction_a)
1154  {
1155  	auto index (store.deterministic_index_get (transaction_a));
1156  	auto new_index (deterministic_check (transaction_a, index));
1157  	for (uint32_t i (index); i <= new_index && index != new_index; ++i)
1158  	{
1159  		deterministic_insert (transaction_a, false);
1160  	}
1161  }
1162  bool nano::wallet::live ()
1163  {
1164  	return store.handle != 0;
1165  }
1166  void nano::wallet::work_cache_blocking (nano::account const & account_a, nano::root const & root_a)
1167  {
1168  	if (wallets.node.work_generation_enabled ())
1169  	{
1170  		auto difficulty (wallets.node.default_difficulty (nano::work_version::work_1));
1171  		auto opt_work_l (wallets.node.work_generate_blocking (nano::work_version::work_1, root_a, difficulty, account_a));
1172  		if (opt_work_l.is_initialized ())
1173  		{
1174  			auto transaction_l (wallets.tx_begin_write ());
1175  			if (live () && store.exists (transaction_l, account_a))
1176  			{
1177  				work_update (transaction_l, account_a, root_a, *opt_work_l);
1178  			}
1179  		}
1180  		else if (!wallets.node.stopped)
1181  		{
1182  			wallets.node.logger.try_log (boost::str (boost::format ("Could not precache work for root %1% due to work generation failure") % root_a.to_string ()));
1183  		}
1184  	}
1185  }
1186  void nano::wallets::do_wallet_actions ()
1187  {
1188  	nano::unique_lock<nano::mutex> action_lock{ action_mutex };
1189  	while (!stopped)
1190  	{
1191  		if (!actions.empty ())
1192  		{
1193  			auto first (actions.begin ());
1194  			auto wallet (first->second.first);
1195  			auto current (std::move (first->second.second));
1196  			actions.erase (first);
1197  			if (wallet->live ())
1198  			{
1199  				action_lock.unlock ();
1200  				observer (true);
1201  				current (*wallet);
1202  				observer (false);
1203  				action_lock.lock ();
1204  			}
1205  		}
1206  		else
1207  		{
1208  			condition.wait (action_lock);
1209  		}
1210  	}
1211  }
1212  nano::wallets::wallets (bool error_a, nano::node & node_a) :
1213  	network_params{ node_a.config.network_params },
1214  	observer ([] (bool) {}),
1215  	kdf{ node_a.config.network_params.kdf_work },
1216  	node (node_a),
1217  	env (boost::polymorphic_downcast<nano::mdb_wallets_store *> (node_a.wallets_store_impl.get ())->environment),
1218  	stopped (false)
1219  {
1220  	nano::unique_lock<nano::mutex> lock{ mutex };
1221  	if (!error_a)
1222  	{
1223  		auto transaction (tx_begin_write ());
1224  		auto status (mdb_dbi_open (env.tx (transaction), nullptr, MDB_CREATE, &handle));
1225  		split_if_needed (transaction, node.store);
1226  		status |= mdb_dbi_open (env.tx (transaction), "send_action_ids", MDB_CREATE, &send_action_ids);
1227  		release_assert (status == 0);
1228  		std::string beginning (nano::uint256_union (0).to_string ());
1229  		std::string end ((nano::uint256_union (nano::uint256_t (0) - nano::uint256_t (1))).to_string ());
1230  		nano::store_iterator<std::array<char, 64>, nano::no_value> i (std::make_unique<nano::mdb_iterator<std::array<char, 64>, nano::no_value>> (transaction, handle, nano::mdb_val (beginning.size (), const_cast<char *> (beginning.c_str ()))));
1231  		nano::store_iterator<std::array<char, 64>, nano::no_value> n (std::make_unique<nano::mdb_iterator<std::array<char, 64>, nano::no_value>> (transaction, handle, nano::mdb_val (end.size (), const_cast<char *> (end.c_str ()))));
1232  		for (; i != n; ++i)
1233  		{
1234  			nano::wallet_id id;
1235  			std::string text (i->first.data (), i->first.size ());
1236  			auto error (id.decode_hex (text));
1237  			release_assert (!error);
1238  			release_assert (items.find (id) == items.end ());
1239  			auto wallet (std::make_shared<nano::wallet> (error, transaction, *this, text));
1240  			if (!error)
1241  			{
1242  				items[id] = wallet;
1243  			}
1244  			else
1245  			{
1246  			}
1247  		}
1248  	}
1249  	bool backup_required (false);
1250  	if (node.config.backup_before_upgrade)
1251  	{
1252  		auto transaction (tx_begin_read ());
1253  		for (auto & item : items)
1254  		{
1255  			if (item.second->store.version (transaction) != nano::wallet_store::version_current)
1256  			{
1257  				backup_required = true;
1258  				break;
1259  			}
1260  		}
1261  	}
1262  	if (backup_required)
1263  	{
1264  		char const * store_path;
1265  		mdb_env_get_path (env, &store_path);
1266  		boost::filesystem::path const path (store_path);
1267  		nano::lmdb::store::create_backup_file (env, path, node_a.logger);
1268  	}
1269  	for (auto & item : items)
1270  	{
1271  		item.second->enter_initial_password ();
1272  	}
1273  	if (node_a.config.enable_voting)
1274  	{
1275  		lock.unlock ();
1276  		ongoing_compute_reps ();
1277  	}
1278  }
1279  nano::wallets::~wallets ()
1280  {
1281  	stop ();
1282  }
1283  std::shared_ptr<nano::wallet> nano::wallets::open (nano::wallet_id const & id_a)
1284  {
1285  	nano::lock_guard<nano::mutex> lock{ mutex };
1286  	std::shared_ptr<nano::wallet> result;
1287  	auto existing (items.find (id_a));
1288  	if (existing != items.end ())
1289  	{
1290  		result = existing->second;
1291  	}
1292  	return result;
1293  }
1294  std::shared_ptr<nano::wallet> nano::wallets::create (nano::wallet_id const & id_a)
1295  {
1296  	nano::lock_guard<nano::mutex> lock{ mutex };
1297  	debug_assert (items.find (id_a) == items.end ());
1298  	std::shared_ptr<nano::wallet> result;
1299  	bool error;
1300  	{
1301  		auto transaction (tx_begin_write ());
1302  		result = std::make_shared<nano::wallet> (error, transaction, *this, id_a.to_string ());
1303  	}
1304  	if (!error)
1305  	{
1306  		items[id_a] = result;
1307  		result->enter_initial_password ();
1308  	}
1309  	return result;
1310  }
1311  bool nano::wallets::search_receivable (nano::wallet_id const & wallet_a)
1312  {
1313  	auto result (false);
1314  	if (auto wallet = open (wallet_a); wallet != nullptr)
1315  	{
1316  		result = wallet->search_receivable (tx_begin_read ());
1317  	}
1318  	return result;
1319  }
1320  void nano::wallets::search_receivable_all ()
1321  {
1322  	nano::unique_lock<nano::mutex> lk{ mutex };
1323  	auto wallets_l = get_wallets ();
1324  	auto wallet_transaction (tx_begin_read ());
1325  	lk.unlock ();
1326  	for (auto const & [id, wallet] : wallets_l)
1327  	{
1328  		wallet->search_receivable (wallet_transaction);
1329  	}
1330  }
1331  void nano::wallets::destroy (nano::wallet_id const & id_a)
1332  {
1333  	nano::lock_guard<nano::mutex> lock{ mutex };
1334  	auto transaction (tx_begin_write ());
1335  	nano::lock_guard<nano::mutex> action_lock{ action_mutex };
1336  	auto existing (items.find (id_a));
1337  	debug_assert (existing != items.end ());
1338  	auto wallet (existing->second);
1339  	items.erase (existing);
1340  	wallet->store.destroy (transaction);
1341  }
1342  void nano::wallets::reload ()
1343  {
1344  	nano::lock_guard<nano::mutex> lock{ mutex };
1345  	auto transaction (tx_begin_write ());
1346  	std::unordered_set<nano::uint256_union> stored_items;
1347  	std::string beginning (nano::uint256_union (0).to_string ());
1348  	std::string end ((nano::uint256_union (nano::uint256_t (0) - nano::uint256_t (1))).to_string ());
1349  	nano::store_iterator<std::array<char, 64>, nano::no_value> i (std::make_unique<nano::mdb_iterator<std::array<char, 64>, nano::no_value>> (transaction, handle, nano::mdb_val (beginning.size (), const_cast<char *> (beginning.c_str ()))));
1350  	nano::store_iterator<std::array<char, 64>, nano::no_value> n (std::make_unique<nano::mdb_iterator<std::array<char, 64>, nano::no_value>> (transaction, handle, nano::mdb_val (end.size (), const_cast<char *> (end.c_str ()))));
1351  	for (; i != n; ++i)
1352  	{
1353  		nano::wallet_id id;
1354  		std::string text (i->first.data (), i->first.size ());
1355  		auto error (id.decode_hex (text));
1356  		debug_assert (!error);
1357  		if (items.find (id) == items.end ())
1358  		{
1359  			auto wallet (std::make_shared<nano::wallet> (error, transaction, *this, text));
1360  			if (!error)
1361  			{
1362  				items[id] = wallet;
1363  			}
1364  		}
1365  		stored_items.insert (id);
1366  	}
1367  	std::vector<nano::wallet_id> deleted_items;
1368  	for (auto i : items)
1369  	{
1370  		if (stored_items.find (i.first) == stored_items.end ())
1371  		{
1372  			deleted_items.push_back (i.first);
1373  		}
1374  	}
1375  	for (auto & i : deleted_items)
1376  	{
1377  		debug_assert (items.find (i) == items.end ());
1378  		items.erase (i);
1379  	}
1380  }
1381  void nano::wallets::queue_wallet_action (nano::uint128_t const & amount_a, std::shared_ptr<nano::wallet> const & wallet_a, std::function<void (nano::wallet &)> action_a)
1382  {
1383  	{
1384  		nano::lock_guard<nano::mutex> action_lock{ action_mutex };
1385  		actions.emplace (amount_a, std::make_pair (wallet_a, action_a));
1386  	}
1387  	condition.notify_all ();
1388  }
1389  void nano::wallets::foreach_representative (std::function<void (nano::public_key const & pub_a, nano::raw_key const & prv_a)> const & action_a)
1390  {
1391  	if (node.config.enable_voting)
1392  	{
1393  		std::vector<std::pair<nano::public_key const, nano::raw_key const>> action_accounts_l;
1394  		{
1395  			auto transaction_l (tx_begin_read ());
1396  			nano::lock_guard<nano::mutex> lock{ mutex };
1397  			for (auto i (items.begin ()), n (items.end ()); i != n; ++i)
1398  			{
1399  				auto & wallet (*i->second);
1400  				nano::lock_guard<std::recursive_mutex> store_lock{ wallet.store.mutex };
1401  				decltype (wallet.representatives) representatives_l;
1402  				{
1403  					nano::lock_guard<nano::mutex> representatives_lock{ wallet.representatives_mutex };
1404  					representatives_l = wallet.representatives;
1405  				}
1406  				for (auto const & account : representatives_l)
1407  				{
1408  					if (wallet.store.exists (transaction_l, account))
1409  					{
1410  						if (!node.ledger.weight (account).is_zero ())
1411  						{
1412  							if (wallet.store.valid_password (transaction_l))
1413  							{
1414  								nano::raw_key prv;
1415  								auto error (wallet.store.fetch (transaction_l, account, prv));
1416  								(void)error;
1417  								debug_assert (!error);
1418  								action_accounts_l.emplace_back (account, prv);
1419  							}
1420  							else
1421  							{
1422  								static auto last_log = std::chrono::steady_clock::time_point ();
1423  								if (last_log < std::chrono::steady_clock::now () - std::chrono::seconds (60))
1424  								{
1425  									last_log = std::chrono::steady_clock::now ();
1426  									node.logger.always_log (boost::str (boost::format ("Representative locked inside wallet %1%") % i->first.to_string ()));
1427  								}
1428  							}
1429  						}
1430  					}
1431  				}
1432  			}
1433  		}
1434  		for (auto const & representative : action_accounts_l)
1435  		{
1436  			action_a (representative.first, representative.second);
1437  		}
1438  	}
1439  }
1440  bool nano::wallets::exists (nano::transaction const & transaction_a, nano::account const & account_a)
1441  {
1442  	nano::lock_guard<nano::mutex> lock{ mutex };
1443  	auto result (false);
1444  	for (auto i (items.begin ()), n (items.end ()); !result && i != n; ++i)
1445  	{
1446  		result = i->second->store.exists (transaction_a, account_a);
1447  	}
1448  	return result;
1449  }
1450  void nano::wallets::stop ()
1451  {
1452  	{
1453  		nano::lock_guard<nano::mutex> action_lock{ action_mutex };
1454  		stopped = true;
1455  		actions.clear ();
1456  	}
1457  	condition.notify_all ();
1458  	if (thread.joinable ())
1459  	{
1460  		thread.join ();
1461  	}
1462  }
1463  void nano::wallets::start ()
1464  {
1465  	thread = std::thread{ [this] () {
1466  		nano::thread_role::set (nano::thread_role::name::wallet_actions);
1467  		do_wallet_actions ();
1468  	} };
1469  }
1470  nano::write_transaction nano::wallets::tx_begin_write ()
1471  {
1472  	return env.tx_begin_write ();
1473  }
1474  nano::read_transaction nano::wallets::tx_begin_read ()
1475  {
1476  	return env.tx_begin_read ();
1477  }
1478  void nano::wallets::clear_send_ids (nano::transaction const & transaction_a)
1479  {
1480  	auto status (mdb_drop (env.tx (transaction_a), send_action_ids, 0));
1481  	(void)status;
1482  	debug_assert (status == 0);
1483  }
1484  nano::wallet_representatives nano::wallets::reps () const
1485  {
1486  	nano::lock_guard<nano::mutex> counts_guard{ reps_cache_mutex };
1487  	return representatives;
1488  }
1489  bool nano::wallets::check_rep (nano::account const & account_a, nano::uint128_t const & half_principal_weight_a, bool const acquire_lock_a)
1490  {
1491  	auto weight = node.ledger.weight (account_a);
1492  	if (weight < node.config.vote_minimum.number ())
1493  	{
1494  		return false; 
1495  	}
1496  	nano::unique_lock<nano::mutex> lock;
1497  	if (acquire_lock_a)
1498  	{
1499  		lock = nano::unique_lock<nano::mutex>{ reps_cache_mutex };
1500  	}
1501  	if (weight >= half_principal_weight_a)
1502  	{
1503  		representatives.half_principal = true;
1504  	}
1505  	auto insert_result = representatives.accounts.insert (account_a);
1506  	if (!insert_result.second)
1507  	{
1508  		return false; 
1509  	}
1510  	++representatives.voting;
1511  	return true;
1512  }
1513  void nano::wallets::compute_reps ()
1514  {
1515  	nano::lock_guard<nano::mutex> guard{ mutex };
1516  	nano::lock_guard<nano::mutex> counts_guard{ reps_cache_mutex };
1517  	representatives.clear ();
1518  	auto half_principal_weight (node.minimum_principal_weight () / 2);
1519  	auto transaction (tx_begin_read ());
1520  	for (auto i (items.begin ()), n (items.end ()); i != n; ++i)
1521  	{
1522  		auto & wallet (*i->second);
1523  		decltype (wallet.representatives) representatives_l;
1524  		for (auto ii (wallet.store.begin (transaction)), nn (wallet.store.end ()); ii != nn; ++ii)
1525  		{
1526  			auto account (ii->first);
1527  			if (check_rep (account, half_principal_weight, false))
1528  			{
1529  				representatives_l.insert (account);
1530  			}
1531  		}
1532  		nano::lock_guard<nano::mutex> representatives_guard{ wallet.representatives_mutex };
1533  		wallet.representatives.swap (representatives_l);
1534  	}
1535  }
1536  void nano::wallets::ongoing_compute_reps ()
1537  {
1538  	compute_reps ();
1539  	auto & node_l (node);
1540  	auto compute_delay = network_params.network.is_dev_network () ? std::chrono::milliseconds (10) : (network_params.network.is_test_network () ? std::chrono::milliseconds (nano::test_scan_wallet_reps_delay ()) : std::chrono::minutes (15));
1541  	node.workers.add_timed_task (std::chrono::steady_clock::now () + compute_delay, [&node_l] () {
1542  		node_l.wallets.ongoing_compute_reps ();
1543  	});
1544  }
1545  void nano::wallets::split_if_needed (nano::transaction & transaction_destination, nano::store & store_a)
1546  {
1547  	auto store_l = dynamic_cast<nano::lmdb::store *> (&store_a);
1548  	if (store_l != nullptr)
1549  	{
1550  		if (items.empty ())
1551  		{
1552  			std::string beginning (nano::uint256_union (0).to_string ());
1553  			std::string end ((nano::uint256_union (nano::uint256_t (0) - nano::uint256_t (1))).to_string ());
1554  			auto get_store_it = [&handle = handle] (nano::transaction const & transaction_source, std::string const & hash) {
1555  				return nano::store_iterator<std::array<char, 64>, nano::no_value> (std::make_unique<nano::mdb_iterator<std::array<char, 64>, nano::no_value>> (transaction_source, handle, nano::mdb_val (hash.size (), const_cast<char *> (hash.c_str ()))));
1556  			};
1557  			auto wallets_need_splitting (false);
1558  			{
1559  				auto transaction_source (store_l->tx_begin_read ());
1560  				auto i = get_store_it (transaction_source, beginning);
1561  				auto n = get_store_it (transaction_source, end);
1562  				wallets_need_splitting = (i != n);
1563  			}
1564  			if (wallets_need_splitting)
1565  			{
1566  				auto transaction_source (store_l->tx_begin_write ());
1567  				auto i = get_store_it (transaction_source, beginning);
1568  				auto n = get_store_it (transaction_source, end);
1569  				auto tx_source = static_cast<MDB_txn *> (transaction_source.get_handle ());
1570  				auto tx_destination = static_cast<MDB_txn *> (transaction_destination.get_handle ());
1571  				for (; i != n; ++i)
1572  				{
1573  					nano::uint256_union id;
1574  					std::string text (i->first.data (), i->first.size ());
1575  					auto error1 (id.decode_hex (text));
1576  					(void)error1;
1577  					debug_assert (!error1);
1578  					debug_assert (strlen (text.c_str ()) == text.size ());
1579  					move_table (text, tx_source, tx_destination);
1580  				}
1581  			}
1582  		}
1583  	}
1584  }
1585  void nano::wallets::move_table (std::string const & name_a, MDB_txn * tx_source, MDB_txn * tx_destination)
1586  {
1587  	MDB_dbi handle_source;
1588  	auto error2 (mdb_dbi_open (tx_source, name_a.c_str (), MDB_CREATE, &handle_source));
1589  	(void)error2;
1590  	debug_assert (!error2);
1591  	MDB_dbi handle_destination;
1592  	auto error3 (mdb_dbi_open (tx_destination, name_a.c_str (), MDB_CREATE, &handle_destination));
1593  	(void)error3;
1594  	debug_assert (!error3);
1595  	MDB_cursor * cursor;
1596  	auto error4 (mdb_cursor_open (tx_source, handle_source, &cursor));
1597  	(void)error4;
1598  	debug_assert (!error4);
1599  	MDB_val val_key;
1600  	MDB_val val_value;
1601  	auto cursor_status (mdb_cursor_get (cursor, &val_key, &val_value, MDB_FIRST));
1602  	while (cursor_status == MDB_SUCCESS)
1603  	{
1604  		auto error5 (mdb_put (tx_destination, handle_destination, &val_key, &val_value, 0));
1605  		(void)error5;
1606  		debug_assert (!error5);
1607  		cursor_status = mdb_cursor_get (cursor, &val_key, &val_value, MDB_NEXT);
1608  	}
1609  	auto error6 (mdb_drop (tx_source, handle_source, 1));
1610  	(void)error6;
1611  	debug_assert (!error6);
1612  }
1613  std::unordered_map<nano::wallet_id, std::shared_ptr<nano::wallet>> nano::wallets::get_wallets ()
1614  {
1615  	debug_assert (!mutex.try_lock ());
1616  	return items;
1617  }
1618  nano::uint128_t const nano::wallets::generate_priority = std::numeric_limits<nano::uint128_t>::max ();
1619  nano::uint128_t const nano::wallets::high_priority = std::numeric_limits<nano::uint128_t>::max () - 1;
1620  nano::store_iterator<nano::account, nano::wallet_value> nano::wallet_store::begin (nano::transaction const & transaction_a)
1621  {
1622  	nano::store_iterator<nano::account, nano::wallet_value> result (std::make_unique<nano::mdb_iterator<nano::account, nano::wallet_value>> (transaction_a, handle, nano::mdb_val (nano::account (special_count))));
1623  	return result;
1624  }
1625  nano::store_iterator<nano::account, nano::wallet_value> nano::wallet_store::begin (nano::transaction const & transaction_a, nano::account const & key)
1626  {
1627  	nano::store_iterator<nano::account, nano::wallet_value> result (std::make_unique<nano::mdb_iterator<nano::account, nano::wallet_value>> (transaction_a, handle, nano::mdb_val (key)));
1628  	return result;
1629  }
1630  nano::store_iterator<nano::account, nano::wallet_value> nano::wallet_store::find (nano::transaction const & transaction_a, nano::account const & key)
1631  {
1632  	auto result (begin (transaction_a, key));
1633  	nano::store_iterator<nano::account, nano::wallet_value> end (nullptr);
1634  	if (result != end)
1635  	{
1636  		if (result->first == key)
1637  		{
1638  			return result;
1639  		}
1640  		else
1641  		{
1642  			return end;
1643  		}
1644  	}
1645  	else
1646  	{
1647  		return end;
1648  	}
1649  	return result;
1650  }
1651  nano::store_iterator<nano::account, nano::wallet_value> nano::wallet_store::end ()
1652  {
1653  	return nano::store_iterator<nano::account, nano::wallet_value> (nullptr);
1654  }
1655  nano::mdb_wallets_store::mdb_wallets_store (boost::filesystem::path const & path_a, nano::lmdb_config const & lmdb_config_a) :
1656  	environment (error, path_a, nano::mdb_env::options::make ().set_config (lmdb_config_a).override_config_sync (nano::lmdb_config::sync_strategy::always).override_config_map_size (1ULL * 1024 * 1024 * 1024))
1657  {
1658  }
1659  bool nano::mdb_wallets_store::init_error () const
1660  {
1661  	return error;
1662  }
1663  MDB_txn * nano::wallet_store::tx (nano::transaction const & transaction_a) const
1664  {
1665  	return static_cast<MDB_txn *> (transaction_a.get_handle ());
1666  }
1667  std::unique_ptr<nano::container_info_component> nano::collect_container_info (wallets & wallets, std::string const & name)
1668  {
1669  	std::size_t items_count;
1670  	std::size_t actions_count;
1671  	{
1672  		nano::lock_guard<nano::mutex> guard{ wallets.mutex };
1673  		items_count = wallets.items.size ();
1674  		actions_count = wallets.actions.size ();
1675  	}
1676  	auto sizeof_item_element = sizeof (decltype (wallets.items)::value_type);
1677  	auto sizeof_actions_element = sizeof (decltype (wallets.actions)::value_type);
1678  	auto composite = std::make_unique<container_info_composite> (name);
1679  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "items", items_count, sizeof_item_element }));
1680  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "actions", actions_count, sizeof_actions_element }));
1681  	return composite;
1682  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-TNodeNet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallet_55.cpp</div>
                </div>
                <div class="column column_space"><pre><code>196    TPt <TNodeNet<TInt> > Net;
197    TPt <TNodeNet<TInt> > Net1;
198    TPt <TNodeNet<TInt> > Net2;
199    int i;
200    int n;
201    int NCount;
202    int x,y;
203    bool Sorted;
204    int Min;
</pre></code></div>
                <div class="column column_space"><pre><code>218  nano::account const nano::wallet_store::salt_special (1);
219  nano::account const nano::wallet_store::wallet_key_special (2);
220  nano::account const nano::wallet_store::check_special (3);
221  nano::account const nano::wallet_store::representative_special (4);
222  nano::account const nano::wallet_store::seed_special (5);
223  nano::account const nano::wallet_store::deterministic_index_special (6);
224  int const nano::wallet_store::special_count (7);
225  std::size_t const nano::wallet_store::check_iv_index (0);
226  std::size_t const nano::wallet_store::seed_iv_index (1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    