
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.523101433882103%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-randen_hwaes.cc</h3>
            <pre><code>1  #include "absl/random/internal/randen_hwaes.h"
2  #include <cstdint>
3  #include <cstring>
4  #include "absl/base/attributes.h"
5  #include "absl/numeric/int128.h"
6  #include "absl/random/internal/platform.h"
7  #include "absl/random/internal/randen_traits.h"
8  #if ABSL_HAVE_ACCELERATED_AES
9  #if defined(ABSL_ARCH_X86_64) || defined(ABSL_ARCH_X86_32) || \
10      defined(ABSL_ARCH_PPC) || defined(ABSL_ARCH_ARM) ||       \
11      defined(ABSL_ARCH_AARCH64)
12  #define ABSL_RANDEN_HWAES_IMPL 1
13  #endif
14  #endif
15  #if !defined(ABSL_RANDEN_HWAES_IMPL)
16  #include <cstdio>
17  #include <cstdlib>
18  namespace absl {
19  ABSL_NAMESPACE_BEGIN
20  namespace random_internal {
21  bool HasRandenHwAesImplementation() { return false; }
22  const void* RandenHwAes::GetKeys() {
23    const int d = ABSL_RANDOM_INTERNAL_AES_DISPATCH;
24    fprintf(stderr, "AES Hardware detection failed (%d).\n", d);
25    exit(1);
26    return nullptr;
27  }
28  void RandenHwAes::Absorb(const void*, void*) {
29    const int d = ABSL_RANDOM_INTERNAL_AES_DISPATCH;
30    fprintf(stderr, "AES Hardware detection failed (%d).\n", d);
31    exit(1);
32  }
33  void RandenHwAes::Generate(const void*, void*) {
34    const int d = ABSL_RANDOM_INTERNAL_AES_DISPATCH;
35    fprintf(stderr, "AES Hardware detection failed (%d).\n", d);
36    exit(1);
37  }
38  }  
39  ABSL_NAMESPACE_END
40  }  
41  #else  
42  namespace {
43  using absl::random_internal::RandenTraits;
44  }  
45  #if (defined(__clang__) || defined(__GNUC__))
46  #if defined(ABSL_ARCH_X86_64) || defined(ABSL_ARCH_X86_32)
47  #define ABSL_TARGET_CRYPTO __attribute__((target("aes")))
48  #elif defined(ABSL_ARCH_PPC)
49  #define ABSL_TARGET_CRYPTO __attribute__((target("crypto")))
50  #else
51  #define ABSL_TARGET_CRYPTO
52  #endif
53  #else
54  #define ABSL_TARGET_CRYPTO
55  #endif
56  #if defined(ABSL_ARCH_PPC)
57  #include <altivec.h>
58  #undef vector
59  #undef bool
60  using Vector128 = __vector unsigned long long;  
61  namespace {
62  inline ABSL_TARGET_CRYPTO Vector128 ReverseBytes(const Vector128& v) {
63    const __vector unsigned char perm = {15, 14, 13, 12, 11, 10, 9, 8,
64                                         7,  6,  5,  4,  3,  2,  1, 0};
65    return vec_perm(v, v, perm);
66  }
67  inline ABSL_TARGET_CRYPTO Vector128 Vector128Load(const void* from) {
68    return vec_vsx_ld(0, reinterpret_cast<const Vector128*>(from));
69  }
70  inline ABSL_TARGET_CRYPTO void Vector128Store(const Vector128& v, void* to) {
71    vec_vsx_st(v, 0, reinterpret_cast<Vector128*>(to));
72  }
73  inline ABSL_TARGET_CRYPTO Vector128 AesRound(const Vector128& state,
74                                               const Vector128& round_key) {
75    return Vector128(__builtin_crypto_vcipher(state, round_key));
76  }
77  inline ABSL_TARGET_CRYPTO void SwapEndian(absl::uint128* state) {
78    for (uint32_t block = 0; block < RandenTraits::kFeistelBlocks; ++block) {
79      Vector128Store(ReverseBytes(Vector128Load(state + block)), state + block);
80    }
81  }
82  }  
83  #elif defined(ABSL_ARCH_ARM) || defined(ABSL_ARCH_AARCH64)
84  #include <arm_neon.h>
85  using Vector128 = uint8x16_t;
86  namespace {
87  inline ABSL_TARGET_CRYPTO Vector128 Vector128Load(const void* from) {
88    return vld1q_u8(reinterpret_cast<const uint8_t*>(from));
89  }
90  inline ABSL_TARGET_CRYPTO void Vector128Store(const Vector128& v, void* to) {
91    vst1q_u8(reinterpret_cast<uint8_t*>(to), v);
92  }
93  inline ABSL_TARGET_CRYPTO Vector128 AesRound(const Vector128& state,
94                                               const Vector128& round_key) {
95    return vaesmcq_u8(vaeseq_u8(state, uint8x16_t{})) ^ round_key;
96  }
97  inline ABSL_TARGET_CRYPTO void SwapEndian(void*) {}
98  }  
99  #elif defined(ABSL_ARCH_X86_64) || defined(ABSL_ARCH_X86_32)
100  #include <immintrin.h>
101  namespace {
102  class Vector128 {
103   public:
104    inline explicit Vector128(const __m128i& v) : data_(v) {}
105    inline __m128i data() const { return data_; }
106    inline Vector128& operator^=(const Vector128& other) {
107      data_ = _mm_xor_si128(data_, other.data());
108      return *this;
109    }
110   private:
111    __m128i data_;
112  };
<span onclick='openModal()' class='match'>113  inline ABSL_TARGET_CRYPTO Vector128 Vector128Load(const void* from) {
114    return Vector128(_mm_load_si128(reinterpret_cast<const __m128i*>(from)));
115  }
116  inline ABSL_TARGET_CRYPTO void Vector128Store(const Vector128& v, void* to) {
</span>117    _mm_store_si128(reinterpret_cast<__m128i*>(to), v.data());
118  }
119  inline ABSL_TARGET_CRYPTO Vector128 AesRound(const Vector128& state,
120                                               const Vector128& round_key) {
121    return Vector128(_mm_aesenc_si128(state.data(), round_key.data()));
122  }
123  inline ABSL_TARGET_CRYPTO void SwapEndian(void*) {}
124  }  
125  #endif
126  #ifdef __clang__
127  #pragma clang diagnostic push
128  #pragma clang diagnostic ignored "-Wunknown-pragmas"
129  #endif
130  namespace {
131  inline ABSL_TARGET_CRYPTO void BlockShuffle(absl::uint128* state) {
132    static_assert(RandenTraits::kFeistelBlocks == 16,
133                  "Expecting 16 FeistelBlocks.");
134    constexpr size_t shuffle[RandenTraits::kFeistelBlocks] = {
135        7, 2, 13, 4, 11, 8, 3, 6, 15, 0, 9, 10, 1, 14, 5, 12};
136    const Vector128 v0 = Vector128Load(state + shuffle[0]);
137    const Vector128 v1 = Vector128Load(state + shuffle[1]);
138    const Vector128 v2 = Vector128Load(state + shuffle[2]);
139    const Vector128 v3 = Vector128Load(state + shuffle[3]);
140    const Vector128 v4 = Vector128Load(state + shuffle[4]);
141    const Vector128 v5 = Vector128Load(state + shuffle[5]);
142    const Vector128 v6 = Vector128Load(state + shuffle[6]);
143    const Vector128 v7 = Vector128Load(state + shuffle[7]);
144    const Vector128 w0 = Vector128Load(state + shuffle[8]);
145    const Vector128 w1 = Vector128Load(state + shuffle[9]);
146    const Vector128 w2 = Vector128Load(state + shuffle[10]);
147    const Vector128 w3 = Vector128Load(state + shuffle[11]);
148    const Vector128 w4 = Vector128Load(state + shuffle[12]);
149    const Vector128 w5 = Vector128Load(state + shuffle[13]);
150    const Vector128 w6 = Vector128Load(state + shuffle[14]);
151    const Vector128 w7 = Vector128Load(state + shuffle[15]);
152    Vector128Store(v0, state + 0);
153    Vector128Store(v1, state + 1);
154    Vector128Store(v2, state + 2);
155    Vector128Store(v3, state + 3);
156    Vector128Store(v4, state + 4);
157    Vector128Store(v5, state + 5);
158    Vector128Store(v6, state + 6);
159    Vector128Store(v7, state + 7);
160    Vector128Store(w0, state + 8);
161    Vector128Store(w1, state + 9);
162    Vector128Store(w2, state + 10);
163    Vector128Store(w3, state + 11);
164    Vector128Store(w4, state + 12);
165    Vector128Store(w5, state + 13);
166    Vector128Store(w6, state + 14);
167    Vector128Store(w7, state + 15);
168  }
169  inline ABSL_TARGET_CRYPTO const absl::uint128* FeistelRound(
170      absl::uint128* state,
171      const absl::uint128* ABSL_RANDOM_INTERNAL_RESTRICT keys) {
172    static_assert(RandenTraits::kFeistelBlocks == 16,
173                  "Expecting 16 FeistelBlocks.");
174    const Vector128 s0 = Vector128Load(state + 0);
175    const Vector128 s1 = Vector128Load(state + 1);
176    const Vector128 s2 = Vector128Load(state + 2);
177    const Vector128 s3 = Vector128Load(state + 3);
178    const Vector128 s4 = Vector128Load(state + 4);
179    const Vector128 s5 = Vector128Load(state + 5);
180    const Vector128 s6 = Vector128Load(state + 6);
181    const Vector128 s7 = Vector128Load(state + 7);
182    const Vector128 s8 = Vector128Load(state + 8);
183    const Vector128 s9 = Vector128Load(state + 9);
184    const Vector128 s10 = Vector128Load(state + 10);
185    const Vector128 s11 = Vector128Load(state + 11);
186    const Vector128 s12 = Vector128Load(state + 12);
187    const Vector128 s13 = Vector128Load(state + 13);
188    const Vector128 s14 = Vector128Load(state + 14);
189    const Vector128 s15 = Vector128Load(state + 15);
190    const Vector128 e0 = AesRound(s0, Vector128Load(keys + 0));
191    const Vector128 e2 = AesRound(s2, Vector128Load(keys + 1));
192    const Vector128 e4 = AesRound(s4, Vector128Load(keys + 2));
193    const Vector128 e6 = AesRound(s6, Vector128Load(keys + 3));
194    const Vector128 e8 = AesRound(s8, Vector128Load(keys + 4));
195    const Vector128 e10 = AesRound(s10, Vector128Load(keys + 5));
196    const Vector128 e12 = AesRound(s12, Vector128Load(keys + 6));
197    const Vector128 e14 = AesRound(s14, Vector128Load(keys + 7));
198    const Vector128 o1 = AesRound(e0, s1);
199    const Vector128 o3 = AesRound(e2, s3);
200    const Vector128 o5 = AesRound(e4, s5);
201    const Vector128 o7 = AesRound(e6, s7);
202    const Vector128 o9 = AesRound(e8, s9);
203    const Vector128 o11 = AesRound(e10, s11);
204    const Vector128 o13 = AesRound(e12, s13);
205    const Vector128 o15 = AesRound(e14, s15);
206    Vector128Store(o1, state + 1);
207    Vector128Store(o3, state + 3);
208    Vector128Store(o5, state + 5);
209    Vector128Store(o7, state + 7);
210    Vector128Store(o9, state + 9);
211    Vector128Store(o11, state + 11);
212    Vector128Store(o13, state + 13);
213    Vector128Store(o15, state + 15);
214    return keys + 8;
215  }
216  inline ABSL_TARGET_CRYPTO void Permute(
217      absl::uint128* state,
218      const absl::uint128* ABSL_RANDOM_INTERNAL_RESTRICT keys) {
219  #ifdef __clang__
220  #pragma clang loop unroll_count(2)
221  #endif
222    for (size_t round = 0; round < RandenTraits::kFeistelRounds; ++round) {
223      keys = FeistelRound(state, keys);
224      BlockShuffle(state);
225    }
226  }
227  }  
228  namespace absl {
229  ABSL_NAMESPACE_BEGIN
230  namespace random_internal {
231  bool HasRandenHwAesImplementation() { return true; }
232  const void* ABSL_TARGET_CRYPTO RandenHwAes::GetKeys() {
233  #if defined(ABSL_ARCH_PPC)
234    return kRandenRoundKeysBE;
235  #else
236    return kRandenRoundKeys;
237  #endif
238  }
239  void ABSL_TARGET_CRYPTO RandenHwAes::Absorb(const void* seed_void,
240                                              void* state_void) {
241    static_assert(RandenTraits::kCapacityBytes / sizeof(Vector128) == 1,
242                  "Unexpected Randen kCapacityBlocks");
243    static_assert(RandenTraits::kStateBytes / sizeof(Vector128) == 16,
244                  "Unexpected Randen kStateBlocks");
245    auto* state = reinterpret_cast<absl::uint128 * ABSL_RANDOM_INTERNAL_RESTRICT>(
246        state_void);
247    const auto* seed =
248        reinterpret_cast<const absl::uint128 * ABSL_RANDOM_INTERNAL_RESTRICT>(
249            seed_void);
250    Vector128 b1 = Vector128Load(state + 1);
251    b1 ^= Vector128Load(seed + 0);
252    Vector128Store(b1, state + 1);
253    Vector128 b2 = Vector128Load(state + 2);
254    b2 ^= Vector128Load(seed + 1);
255    Vector128Store(b2, state + 2);
256    Vector128 b3 = Vector128Load(state + 3);
257    b3 ^= Vector128Load(seed + 2);
258    Vector128Store(b3, state + 3);
259    Vector128 b4 = Vector128Load(state + 4);
260    b4 ^= Vector128Load(seed + 3);
261    Vector128Store(b4, state + 4);
262    Vector128 b5 = Vector128Load(state + 5);
263    b5 ^= Vector128Load(seed + 4);
264    Vector128Store(b5, state + 5);
265    Vector128 b6 = Vector128Load(state + 6);
266    b6 ^= Vector128Load(seed + 5);
267    Vector128Store(b6, state + 6);
268    Vector128 b7 = Vector128Load(state + 7);
269    b7 ^= Vector128Load(seed + 6);
270    Vector128Store(b7, state + 7);
271    Vector128 b8 = Vector128Load(state + 8);
272    b8 ^= Vector128Load(seed + 7);
273    Vector128Store(b8, state + 8);
274    Vector128 b9 = Vector128Load(state + 9);
275    b9 ^= Vector128Load(seed + 8);
276    Vector128Store(b9, state + 9);
277    Vector128 b10 = Vector128Load(state + 10);
278    b10 ^= Vector128Load(seed + 9);
279    Vector128Store(b10, state + 10);
280    Vector128 b11 = Vector128Load(state + 11);
281    b11 ^= Vector128Load(seed + 10);
282    Vector128Store(b11, state + 11);
283    Vector128 b12 = Vector128Load(state + 12);
284    b12 ^= Vector128Load(seed + 11);
285    Vector128Store(b12, state + 12);
286    Vector128 b13 = Vector128Load(state + 13);
287    b13 ^= Vector128Load(seed + 12);
288    Vector128Store(b13, state + 13);
289    Vector128 b14 = Vector128Load(state + 14);
290    b14 ^= Vector128Load(seed + 13);
291    Vector128Store(b14, state + 14);
292    Vector128 b15 = Vector128Load(state + 15);
293    b15 ^= Vector128Load(seed + 14);
294    Vector128Store(b15, state + 15);
295  }
296  void ABSL_TARGET_CRYPTO RandenHwAes::Generate(const void* keys_void,
297                                                void* state_void) {
298    static_assert(RandenTraits::kCapacityBytes == sizeof(Vector128),
299                  "Capacity mismatch");
300    auto* state = reinterpret_cast<absl::uint128*>(state_void);
301    const auto* keys = reinterpret_cast<const absl::uint128*>(keys_void);
302    const Vector128 prev_inner = Vector128Load(state);
303    SwapEndian(state);
304    Permute(state, keys);
305    SwapEndian(state);
306    Vector128 inner = Vector128Load(state);
307    inner ^= prev_inner;
308    Vector128Store(inner, state);
309  }
310  #ifdef __clang__
311  #pragma clang diagnostic pop
312  #endif
313  }  
314  ABSL_NAMESPACE_END
315  }  
316  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.h</h3>
            <pre><code>1  #ifndef NETWORKMP_H
2  #define NETWORKMP_H
3  #ifdef GCC_ATOMIC
4  class TNEANetMP;
5  typedef TPt<TNEANetMP> PNEANetMP;
6  class TNEANetMP {
7  public:
8    typedef TNEANetMP TNet;
9    typedef TPt<TNEANetMP> PNet;
10  public:
11    class TNode {
12    private:
13      TInt Id;
14      TIntV InEIdV, OutEIdV;
15    public:
16      TNode() : Id(-1), InEIdV(), OutEIdV() { }
17      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV() { }
18      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV) { }
19      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn) { }
20      void Save(TSOut& SOut) const { Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut); }
21      int GetId() const { return Id; }
22      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
23      int GetInDeg() const { return InEIdV.Len(); }
24      int GetOutDeg() const { return OutEIdV.Len(); }
25      int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
26      int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
27      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
28      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
29      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
30      friend class TNEANetMP;
31    };
32    class TEdge {
33    private:
34      TInt Id, SrcNId, DstNId;
35    public:
36      TEdge() : Id(-1), SrcNId(-1), DstNId(-1) { }
37      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
38      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
39      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn) { }
40      void Save(TSOut& SOut) const { Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
41      int GetId() const { return Id; }
42      int GetSrcNId() const { return SrcNId; }
43      int GetDstNId() const { return DstNId; }
44      friend class TNEANetMP;
45    };
46    class TNodeI {
47    private:
48      typedef THashMP<TInt, TNode>::TIter THashIter;
49      THashIter NodeHI;
50      const TNEANetMP *Graph;
51    public:
52      TNodeI() : NodeHI(), Graph(NULL) { }
53      TNodeI(const THashIter& NodeHIter, const TNEANetMP* GraphPt) : NodeHI(NodeHIter), Graph(GraphPt) { }
54      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Graph(NodeI.Graph) { }
55      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
56      TNodeI& operator++ (int) { NodeHI++; return *this; }
57      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
58      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
59      int GetId() const { return NodeHI.GetDat().GetId(); }
60      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
61      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
62      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
63      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
64      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
65      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN)); return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
66      bool IsInNId(const int& NId) const;
67      bool IsOutNId(const int& NId) const;
68      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
69      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
70      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
71      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
72      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
73      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
74      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
75      void GetAttrNames(TStrV& Names) const { Graph->AttrNameNI(GetId(), Names); }
76      void GetAttrVal(TStrV& Val) const { Graph->AttrValueNI(GetId(), Val); }
77      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameNI(GetId(), Names); }
78      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueNI(GetId(), Val); }
79      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameNI(GetId(), Names); }
80      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueNI(GetId(), Val); }
81      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameNI(GetId(), Names); }
82      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueNI(GetId(), Val); }
83      friend class TNEANetMP;
84    };
85    class TEdgeI {
86    private:
87      typedef THashMP<TInt, TEdge>::TIter THashIter;
88      THashIter EdgeHI;
89      const TNEANetMP *Graph;
90    public:
91      TEdgeI() : EdgeHI(), Graph(NULL) { }
92      TEdgeI(const THashIter& EdgeHIter, const TNEANetMP *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
93      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
94      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
95      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
96      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
97      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
98      int GetId() const { return EdgeHI.GetDat().GetId(); }
99      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
100      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
101      void GetAttrNames(TStrV& Names) const { Graph->AttrNameEI(GetId(), Names); }
102      void GetAttrVal(TStrV& Val) const { Graph->AttrValueEI(GetId(), Val); }
103      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameEI(GetId(), Names); }
104      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueEI(GetId(), Val); }
105      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameEI(GetId(), Names); }
106      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueEI(GetId(), Val); }
107      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameEI(GetId(), Names); }
108      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueEI(GetId(), Val); }
109      friend class TNEANetMP;
110    };
111    class TAIntI {
112    private:
113      typedef TIntV::TIter TIntVecIter;
114      TIntVecIter HI;
115      bool isNode;
116      TStr attr;
117      const TNEANetMP *Graph;
118    public:
119      TAIntI() : HI(), attr(), Graph(NULL) { }
120      TAIntI(const TIntVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANetMP* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
121      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
122      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
123      bool operator < (const TAIntI& I) const { return HI < I.HI; }
124      bool operator == (const TAIntI& I) const { return HI == I.HI; }
125      TInt GetDat() const { return HI[0]; }
126      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetIntAttrDefaultN(attr) : GetDat() == Graph->GetIntAttrDefaultE(attr); };
127      TAIntI& operator++(int) { HI++; return *this; }
128      friend class TNEANetMP;
129    };
130    class TAStrI {
131    private:
132      typedef TStrV::TIter TStrVecIter;
133      TStrVecIter HI;
134      bool isNode;
135      TStr attr;
136      const TNEANetMP *Graph;
137    public:
138      TAStrI() : HI(), attr(), Graph(NULL) { }
139      TAStrI(const TStrVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANetMP* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
140      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
141      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
142      bool operator < (const TAStrI& I) const { return HI < I.HI; }
143      bool operator == (const TAStrI& I) const { return HI == I.HI; }
144      TStr GetDat() const { return HI[0]; }
145      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetStrAttrDefaultN(attr) : GetDat() == Graph->GetStrAttrDefaultE(attr); };
146      TAStrI& operator++(int) { HI++; return *this; }
147      friend class TNEANetMP;
148    };
149    class TAFltI {
150    private:
151      typedef TFltV::TIter TFltVecIter;
152      TFltVecIter HI;
153      bool isNode;
154      TStr attr;
155      const TNEANetMP *Graph;
156    public:
157      TAFltI() : HI(), attr(), Graph(NULL) { }
158      TAFltI(const TFltVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANetMP* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
159      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
160      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
161      bool operator < (const TAFltI& I) const { return HI < I.HI; }
162      bool operator == (const TAFltI& I) const { return HI == I.HI; }
163      TFlt GetDat() const { return HI[0]; }
164      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetFltAttrDefaultN(attr) : GetDat() == Graph->GetFltAttrDefaultE(attr); };
165      TAFltI& operator++(int) { HI++; return *this; }
166      friend class TNEANetMP;
167    };
168  private:
169    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
170    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
171    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
172    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
173    TInt GetIntAttrDefaultN(const TStr& attribute) const { return IntDefaultsN.IsKey(attribute) ? IntDefaultsN.GetDat(attribute) : (TInt) TInt::Mn; }
174    TStr GetStrAttrDefaultN(const TStr& attribute) const { return StrDefaultsN.IsKey(attribute) ? StrDefaultsN.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
175    TFlt GetFltAttrDefaultN(const TStr& attribute) const { return FltDefaultsN.IsKey(attribute) ? FltDefaultsN.GetDat(attribute) : (TFlt) TFlt::Mn; }
176    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
177    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
178    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
179  private:
180    TCRef CRef;
181    TInt MxNId, MxEId;
182    THashMP<TInt, TNode> NodeH;
183    THashMP<TInt, TEdge> EdgeH;
184    TStrIntPrH KeyToIndexTypeN, KeyToIndexTypeE;
185    THashMP<TStr, TInt> IntDefaultsN, IntDefaultsE;
186    THashMP<TStr, TStr> StrDefaultsN, StrDefaultsE;
187    THashMP<TStr, TFlt> FltDefaultsN, FltDefaultsE;
188    TVec<TIntV> VecOfIntVecsN, VecOfIntVecsE;
189    TVec<TStrV> VecOfStrVecsN, VecOfStrVecsE;
190    TVec<TFltV> VecOfFltVecsN, VecOfFltVecsE;
191    enum { IntType, StrType, FltType };
192  public:
193    TNEANetMP() : CRef(), MxNId(0), MxEId(0), NodeH(), EdgeH(),
194      KeyToIndexTypeN(), KeyToIndexTypeE(), IntDefaultsN(), IntDefaultsE(),
195      StrDefaultsN(), StrDefaultsE(), FltDefaultsN(), FltDefaultsE(),
196      VecOfIntVecsN(), VecOfIntVecsE(), VecOfStrVecsN(), VecOfStrVecsE(),
197      VecOfFltVecsN(), VecOfFltVecsE() { }
198    explicit TNEANetMP(const int& Nodes, const int& Edges) : CRef(),
199      MxNId(0), MxEId(0), NodeH(), EdgeH(), KeyToIndexTypeN(), KeyToIndexTypeE(),
200      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
201      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
202      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE()
203      { Reserve(Nodes, Edges); }
204    TNEANetMP(const TNEANetMP& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
205      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(), KeyToIndexTypeE(),
206      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
207      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
208      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE() { }
209    TNEANetMP(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn),
210      KeyToIndexTypeN(SIn), KeyToIndexTypeE(SIn), IntDefaultsN(SIn), IntDefaultsE(SIn),
211      StrDefaultsN(SIn), StrDefaultsE(SIn), FltDefaultsN(SIn), FltDefaultsE(SIn),
212      VecOfIntVecsN(SIn), VecOfIntVecsE(SIn), VecOfStrVecsN(SIn),VecOfStrVecsE(SIn),
213      VecOfFltVecsN(SIn), VecOfFltVecsE(SIn) { }
214    void Save(TSOut& SOut) const {
215      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
216      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
217      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
218      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
219      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
220      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
221      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
222      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut); }
223    static PNEANetMP New() { return PNEANetMP(new TNEANetMP()); }
224    static PNEANetMP New(const int& Nodes, const int& Edges) { return PNEANetMP(new TNEANetMP(Nodes, Edges)); }
225    static PNEANetMP Load(TSIn& SIn) { return PNEANetMP(new TNEANetMP(SIn)); }
226    bool HasFlag(const TGraphFlag& Flag) const;
227    TNEANetMP& operator = (const TNEANetMP& Graph) { if (this!=&Graph) {
228      MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH; }
229      return *this; }
230    int GetNodes() const { return NodeH.Len(); }
231    void SetNodes(const int& Length) { NodeH.SetLen(Length); }
232    int AddNode(int NId = -1);
233    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
234    void AddNodeWithEdges(const TInt& NId, TIntV& InEIdV, TIntV& OutEIdV);
235    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
236    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
237    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
238    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
239    TAIntI BegNAIntI(const TStr& attr) const {
240      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
241    TAIntI EndNAIntI(const TStr& attr) const {
242      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
243    TAIntI GetNAIntI(const TStr& attr, const int& NId) const {
244      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
245    TAStrI BegNAStrI(const TStr& attr) const {
246      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
<span onclick='openModal()' class='match'>247    TAStrI EndNAStrI(const TStr& attr) const {
248      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
249    TAStrI GetNAStrI(const TStr& attr, const int& NId) const {
</span>250      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
251    TAFltI BegNAFltI(const TStr& attr) const {
252      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
253    TAFltI EndNAFltI(const TStr& attr) const {
254      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
255    TAFltI GetNAFltI(const TStr& attr, const int& NId) const {
256      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
257    void AttrNameNI(const TInt& NId, TStrV& Names) const {
258      AttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
259    void AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
260    void AttrValueNI(const TInt& NId, TStrV& Values) const {
261      AttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
262    void AttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
263    void IntAttrNameNI(const TInt& NId, TStrV& Names) const {
264      IntAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
265    void IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
266    void IntAttrValueNI(const TInt& NId, TIntV& Values) const {
267      IntAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
268    void IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const;
269    void StrAttrNameNI(const TInt& NId, TStrV& Names) const {
270      StrAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
271    void StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
272    void StrAttrValueNI(const TInt& NId, TStrV& Values) const {
273      StrAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
274    void StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
275    void FltAttrNameNI(const TInt& NId, TStrV& Names) const {
276      FltAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
277    void FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
278    void FltAttrValueNI(const TInt& NId, TFltV& Values) const {
279      FltAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
280    void FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const;
281    void AttrNameEI(const TInt& EId, TStrV& Names) const {
282      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
283    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
284    void AttrValueEI(const TInt& EId, TStrV& Values) const {
285      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
286    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
287    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
288      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
289    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
290    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
291      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
292    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const;
293    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
294      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
295    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
296    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
297      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
298    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
299    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
300      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
301    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
302    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
303      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
304    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const;
305    TAIntI BegEAIntI(const TStr& attr) const {
306      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
307    }
308    TAIntI EndEAIntI(const TStr& attr) const {
309      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
310    }
311    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
312      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
313    }
314    TAStrI BegEAStrI(const TStr& attr) const {
315      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);   }
316    TAStrI EndEAStrI(const TStr& attr) const {
317      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
318    }
319    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
320      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
321    }
322    TAFltI BegEAFltI(const TStr& attr) const {
323      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
324    }
325    TAFltI EndEAFltI(const TStr& attr) const {
326      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
327    }
328    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
329      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
330    }
331    int GetMxNId() const { return MxNId; }
332    int GetMxEId() const { return MxEId; }
333    int Reserved() const {return NodeH.GetReservedKeyIds();}
334    int ReservedE() const {return EdgeH.GetReservedKeyIds();}
335    int GetEdges() const { return EdgeH.Len(); }
336    void SetEdges(const int& Length) { EdgeH.SetLen(Length); }
337    void SetMxEId(const TInt& Id) { MxEId = Id; }
338    int AddEdge(const int& SrcNId, const int& DstNId, int EId  = -1);
339    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId()); }
340    void AddEdgeUnchecked(const TInt& EId, const int SrcNId, const int DstNId);
341    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
342    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
343    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
344    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
345    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
346    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
347    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
348    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
349    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
350    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
351    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
352    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
353    void GetNIdV(TIntV& NIdV) const;
354    void GetEIdV(TIntV& EIdV) const;
355    bool Empty() const { return GetNodes()==0; }
356    void Clr() { MxNId=0; MxEId=0; NodeH.Clr(); EdgeH.Clr(),
357      KeyToIndexTypeN.Clr(), KeyToIndexTypeE.Clr(), IntDefaultsN.Clr(), IntDefaultsE.Clr(),
358      StrDefaultsN.Clr(), StrDefaultsE.Clr(), FltDefaultsN.Clr(), FltDefaultsE.Clr(),
359      VecOfIntVecsN.Clr(), VecOfIntVecsE.Clr(), VecOfStrVecsN.Clr(), VecOfStrVecsE.Clr(),
360      VecOfFltVecsN.Clr(), VecOfFltVecsE.Clr();}
361    void Reserve(const int& Nodes, const int& Edges) {
362      if (Nodes>0) { NodeH.Gen(Nodes); } if (Edges>0) { EdgeH.Gen(Edges); } }
363    void ReserveAttr(const int& NIntAttr, const int& NFltAttr, const int& NStrAttr, const int& EIntAttr,
364         const int& EFltAttr, const int& EStrAttr) {
365      if (NIntAttr > 0) { IntDefaultsN.Gen(NIntAttr); }
366      if (NFltAttr > 0) { FltDefaultsN.Gen(NFltAttr); }
367      if (NStrAttr > 0) { StrDefaultsN.Gen(NStrAttr); }
368      if (EIntAttr > 0) { IntDefaultsE.Gen(EIntAttr); }
369      if (EFltAttr > 0) { FltDefaultsE.Gen(EFltAttr); }
370      if (EStrAttr > 0) { StrDefaultsE.Gen(EStrAttr); }
371    }
372    void Defrag(const bool& OnlyNodeLinks=false);
373    bool IsOk(const bool& ThrowExcept=true) const;
374    void Dump(FILE *OutF=stdout) const;
375    int AddIntAttrDatN(const TNodeI& NodeId, const TInt& value, const TStr& attr) { return AddIntAttrDatN(NodeId.GetId(), value, attr); }
376    int AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr);
377    int AddStrAttrDatN(const TNodeI& NodeId, const TStr& value, const TStr& attr) { return AddStrAttrDatN(NodeId.GetId(), value, attr); }
378    int AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr);
379    int AddFltAttrDatN(const TNodeI& NodeId, const TFlt& value, const TStr& attr) { return AddFltAttrDatN(NodeId.GetId(), value, attr); }
380    int AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr);
381    int AddIntAttrDatE(const TEdgeI& EdgeId, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeId.GetId(), value, attr); }
382    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
383    int AddStrAttrDatE(const TEdgeI& EdgeId, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeId.GetId(), value, attr); }
384    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
385    int AddFltAttrDatE(const TEdgeI& EdgeId, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeId.GetId(), value, attr); }
386    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
387    TInt GetIntAttrDatN(const TNodeI& NodeId, const TStr& attr) { return GetIntAttrDatN(NodeId.GetId(), attr); }
388    TInt GetIntAttrDatN(const int& NId, const TStr& attr);
389    TStr GetStrAttrDatN(const TNodeI& NodeId, const TStr& attr) { return GetStrAttrDatN(NodeId.GetId(), attr); }
390    TStr GetStrAttrDatN(const int& NId, const TStr& attr);
391    TFlt GetFltAttrDatN(const TNodeI& NodeId, const TStr& attr) { return GetFltAttrDatN(NodeId.GetId(), attr); }
392    TFlt GetFltAttrDatN(const int& NId, const TStr& attr);
393    int GetIntAttrIndN(const TStr& attr);
394    TInt GetIntAttrIndDatN(const TNodeI& NodeId, const int& index) { return GetIntAttrIndDatN(NodeId.GetId(), index); }
395    TInt GetIntAttrIndDatN(const int& NId, const int& index);
396    TInt GetIntAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return GetIntAttrDatE(EdgeId.GetId(), attr); }
397    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
398    TStr GetStrAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return GetStrAttrDatE(EdgeId.GetId(), attr); }
399    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
400    TFlt GetFltAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return GetFltAttrDatE(EdgeId.GetId(), attr); }
401    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
402    int GetIntAttrIndE(const TStr& attr);
403    TInt GetIntAttrIndDatE(const TEdgeI& EdgeId, const int &index) { return GetIntAttrIndDatE(EdgeId.GetId(), index); }
404    TInt GetIntAttrIndDatE(const int& EId, const int& index);
405    int DelAttrDatN(const TNodeI& NodeId, const TStr& attr) { return DelAttrDatN(NodeId.GetId(), attr); }
406    int DelAttrDatN(const int& NId, const TStr& attr);
407    int DelAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return DelAttrDatE(EdgeId.GetId(), attr); }
408    int DelAttrDatE(const int& EId, const TStr& attr);
409    int AddIntAttrN(const TStr& attr, TInt defaultValue=TInt::Mn);
410    int AddStrAttrN(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
411    int AddFltAttrN(const TStr& attr, TFlt defaultValue=TFlt::Mn);
412    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
413    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
414    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
415    bool NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
416    bool NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
417    bool NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
418    bool NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
419    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
420    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
421    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
422    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
423    TStr GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
424    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
425    TFlt GetWeightOutEdges(const TNodeI& NI, const TStr& attr);
426    bool IsFltAttrE(const TStr& attr);
427    bool IsIntAttrE(const TStr& attr);
428    bool IsStrAttrE(const TStr& attr);
429    TVec<TFlt>& GetFltAttrVecE(const TStr& attr);
430    int GetFltKeyIdE(const int& EId);
431    void GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) ;
432    friend class TPt<TNEANetMP>;
433  };
434  namespace TSnap {
435  template <> struct IsMultiGraph<TNEANetMP> { enum { Val = 1 }; };
436  template <> struct IsDirected<TNEANetMP> { enum { Val = 1 }; };
437  }
438  #else
439  #endif 
440  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-randen_hwaes.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.h</div>
                </div>
                <div class="column column_space"><pre><code>113  inline ABSL_TARGET_CRYPTO Vector128 Vector128Load(const void* from) {
114    return Vector128(_mm_load_si128(reinterpret_cast<const __m128i*>(from)));
115  }
116  inline ABSL_TARGET_CRYPTO void Vector128Store(const Vector128& v, void* to) {
</pre></code></div>
                <div class="column column_space"><pre><code>247    TAStrI EndNAStrI(const TStr& attr) const {
248      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
249    TAStrI GetNAStrI(const TStr& attr, const int& NId) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    