
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.6433853738701727%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-webget.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <unistd.h>
3  #include <sys/stat.h>
4  #include <thread>
5  #include <atomic>
6  #include <curl/curl.h>
7  #include "../handler/settings.h"
8  #include "../utils/base64/base64.h"
9  #include "../utils/defer.h"
10  #include "../utils/file_extra.h"
11  #include "../utils/logger.h"
12  #include "../utils/urlencode.h"
13  #include "../version.h"
14  #include "webget.h"
15  #ifdef _WIN32
16  #ifndef _stat
17  #define _stat stat
18  #endif 
19  #endif 
20  class RWLock
21  {
22  #define WRITE_LOCK_STATUS -1
23  #define FREE_STATUS 0
24  private:
<span onclick='openModal()' class='match'>25      const std::thread::id NULL_THREAD;
26      const bool WRITE_FIRST;
27      std::thread::id m_write_thread_id;
28      std::atomic_int m_lockCount;
29      std::atomic_uint m_writeWaitCount;
30  public:
31      RWLock(const RWLock&) = delete;
32      RWLock& operator=(const RWLock&) = delete;
</span>33      RWLock(bool writeFirst = true): WRITE_FIRST(writeFirst), m_write_thread_id(), m_lockCount(0), m_writeWaitCount(0) {}
34      virtual ~RWLock() = default;
35      int readLock()
36      {
37          if (std::this_thread::get_id() != m_write_thread_id)
38          {
39              int count;
40              if (WRITE_FIRST)
41                  do {
42                      while ((count = m_lockCount) == WRITE_LOCK_STATUS || m_writeWaitCount > 0);
43                  } while (!m_lockCount.compare_exchange_weak(count, count + 1));
44              else
45                  do {
46                      while ((count = m_lockCount) == WRITE_LOCK_STATUS);
47                  } while (!m_lockCount.compare_exchange_weak(count, count + 1));
48          }
49          return m_lockCount;
50      }
51      int readUnlock()
52      {
53          if (std::this_thread::get_id() != m_write_thread_id)
54              --m_lockCount;
55          return m_lockCount;
56      }
57      int writeLock()
58      {
59          if (std::this_thread::get_id() != m_write_thread_id)
60          {
61              ++m_writeWaitCount;
62              for (int zero = FREE_STATUS; !m_lockCount.compare_exchange_weak(zero, WRITE_LOCK_STATUS); zero = FREE_STATUS);
63              --m_writeWaitCount;
64              m_write_thread_id = std::this_thread::get_id();
65          }
66          return m_lockCount;
67      }
68      int writeUnlock()
69      {
70          if (std::this_thread::get_id() != m_write_thread_id)
71          {
72              throw std::runtime_error("writeLock/Unlock mismatch");
73          }
74          if (WRITE_LOCK_STATUS != m_lockCount)
75          {
76              throw std::runtime_error("RWLock internal error");
77          }
78          m_write_thread_id = NULL_THREAD;
79          m_lockCount.store(FREE_STATUS);
80          return m_lockCount;
81      }
82  };
83  RWLock cache_rw_lock;
84  static std::string user_agent_str = "subconverter/" VERSION " cURL/" LIBCURL_VERSION;
85  struct curl_progress_data
86  {
87      long size_limit = 0L;
88  };
89  static inline void curl_init()
90  {
91      static bool init = false;
92      if(!init)
93      {
94          curl_global_init(CURL_GLOBAL_ALL);
95          init = true;
96      }
97  }
98  static int writer(char *data, size_t size, size_t nmemb, std::string *writerData)
99  {
100      if(writerData == NULL)
101          return 0;
102      writerData->append(data, size*nmemb);
103      return size * nmemb;
104  }
105  static int dummy_writer(char *data, size_t size, size_t nmemb, void *writerData)
106  {
107      (void)data;
108      (void)writerData;
109      return size * nmemb;
110  }
111  static int size_checker(void *clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow)
112  {
113      if(clientp)
114      {
115          curl_progress_data *data = reinterpret_cast<curl_progress_data*>(clientp);
116          if(data->size_limit)
117          {
118              if(dlnow > data->size_limit)
119                  return 1;
120          }
121      }
122      return 0;
123  }
124  static inline void curl_set_common_options(CURL *curl_handle, const char *url, curl_progress_data *data)
125  {
126      curl_easy_setopt(curl_handle, CURLOPT_URL, url);
127      curl_easy_setopt(curl_handle, CURLOPT_VERBOSE, global.logLevel == LOG_LEVEL_VERBOSE ? 1L : 0L);
128      curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 0L);
129      curl_easy_setopt(curl_handle, CURLOPT_NOSIGNAL, 1L);
130      curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
131      curl_easy_setopt(curl_handle, CURLOPT_MAXREDIRS, 20L);
132      curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);
133      curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYHOST, 0L);
134      curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 15L);
135      curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, user_agent_str.data());
136      curl_easy_setopt(curl_handle, CURLOPT_COOKIEFILE, "");
137      if(data)
138      {
139          if(data->size_limit)
140              curl_easy_setopt(curl_handle, CURLOPT_MAXFILESIZE, data->size_limit);
141          curl_easy_setopt(curl_handle, CURLOPT_XFERINFOFUNCTION, size_checker);
142          curl_easy_setopt(curl_handle, CURLOPT_XFERINFODATA, data);
143      }
144  }
145  static int curlGet(const FetchArgument &argument, FetchResult &result)
146  {
147      CURL *curl_handle;
148      std::string *data = result.content, new_url = argument.url;
149      struct curl_slist *list = NULL;
150      defer(curl_slist_free_all(list);)
151      long retVal = 0;
152      curl_init();
153      curl_handle = curl_easy_init();
154      if(argument.proxy.size())
155      {
156          if(startsWith(argument.proxy, "cors:"))
157          {
158              list = curl_slist_append(list, "X-Requested-With: subconverter " VERSION);
159              new_url = argument.proxy.substr(5) + argument.url;
160          }
161          else
162              curl_easy_setopt(curl_handle, CURLOPT_PROXY, argument.proxy.data());
163      }
164      curl_progress_data limit;
165      limit.size_limit = global.maxAllowedDownloadSize;
166      curl_set_common_options(curl_handle, new_url.data(), &limit);
167      list = curl_slist_append(list, "Content-Type: application/json;charset=utf-8");
168      if(argument.request_headers)
169      {
170          for(auto &x : *argument.request_headers)
171              list = curl_slist_append(list, (x.first + ": " + x.second).data());
172      }
173      list = curl_slist_append(list, "SubConverter-Request: 1");
174      list = curl_slist_append(list, "SubConverter-Version: " VERSION);
175      if(list)
176          curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list);
177      if(result.content)
178      {
179          curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, writer);
180          curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, result.content);
181      }
182      else
183          curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, dummy_writer);
184      if(result.response_headers)
185      {
186          curl_easy_setopt(curl_handle, CURLOPT_HEADERFUNCTION, writer);
187          curl_easy_setopt(curl_handle, CURLOPT_HEADERDATA, result.response_headers);
188      }
189      else
190          curl_easy_setopt(curl_handle, CURLOPT_HEADERFUNCTION, dummy_writer);
191      if(argument.cookies)
192      {
193          string_array cookies = split(*argument.cookies, "\r\n");
194          for(auto &x : cookies)
195              curl_easy_setopt(curl_handle, CURLOPT_COOKIELIST, x.c_str());
196      }
197      switch(argument.method)
198      {
199      case HTTP_POST:
200          curl_easy_setopt(curl_handle, CURLOPT_POST, 1L);
201          if(argument.post_data)
202          {
203              curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, argument.post_data->data());
204              curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDSIZE, argument.post_data->size());
205          }
206          break;
207      case HTTP_PATCH:
208          curl_easy_setopt(curl_handle, CURLOPT_CUSTOMREQUEST, "PATCH");
209          if(argument.post_data)
210          {
211              curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, argument.post_data->data());
212              curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDSIZE, argument.post_data->size());
213          }
214          break;
215      case HTTP_HEAD:
216          curl_easy_setopt(curl_handle, CURLOPT_NOBODY, 1L);
217          break;
218      case HTTP_GET:
219          break;
220      }
221      unsigned int fail_count = 0, max_fails = 1;
222      while(true)
223      {
224          retVal = curl_easy_perform(curl_handle);
225          if(retVal == CURLE_OK || max_fails >= fail_count)
226              break;
227          else
228              fail_count++;
229      }
230      long code = 0;
231      curl_easy_getinfo(curl_handle, CURLINFO_HTTP_CODE, &code);
232      *result.status_code = code;
233      if(result.cookies)
234      {
235          curl_slist *cookies = nullptr;
236          curl_easy_getinfo(curl_handle, CURLINFO_COOKIELIST, &cookies);
237          if(cookies)
238          {
239              auto each = cookies;
240              while(each)
241              {
242                  result.cookies->append(each->data);
243                  *result.cookies += "\r\n";
244                  each = each->next;
245              }
246          }
247          curl_slist_free_all(cookies);
248      }
249      curl_easy_cleanup(curl_handle);
250      if(data && !argument.keep_resp_on_fail)
251      {
252          if(retVal != CURLE_OK || *result.status_code != 200)
253              data->clear();
254          data->shrink_to_fit();
255      }
256      return *result.status_code;
257  }
258  static std::string dataGet(const std::string &url)
259  {
260      if (!startsWith(url, "data:"))
261          return std::string();
262      std::string::size_type comma = url.find(',');
263      if (comma == std::string::npos || comma == url.size() - 1)
264          return std::string();
265      std::string data = urlDecode(url.substr(comma + 1));
266      if (endsWith(url.substr(0, comma), ";base64")) {
267          return urlSafeBase64Decode(data);
268      } else {
269          return data;
270      }
271  }
272  std::string buildSocks5ProxyString(const std::string &addr, int port, const std::string &username, const std::string &password)
273  {
274      std::string authstr = username.size() && password.size() ? username + ":" + password + "@" : "";
275      std::string proxystr = "socks5:&bsol;&bsol;" + authstr + addr + ":" + std::to_string(port);
276      return proxystr;
277  }
278  std::string webGet(const std::string &url, const std::string &proxy, unsigned int cache_ttl, std::string *response_headers, string_icase_map *request_headers)
279  {
280      int return_code = 0;
281      std::string content;
282      FetchArgument argument {HTTP_GET, url, proxy, nullptr, request_headers, nullptr, cache_ttl};
283      FetchResult fetch_res {&return_code, &content, response_headers, nullptr};
284      if (startsWith(url, "data:"))
285          return dataGet(url);
286      if(cache_ttl > 0)
287      {
288          md("cache");
289          const std::string url_md5 = getMD5(url);
290          const std::string path = "cache/" + url_md5, path_header = path + "_header";
291          struct stat result;
292          if(stat(path.data(), &result) == 0) 
293          {
294              time_t mtime = result.st_mtime, now = time(NULL); 
295              if(difftime(now, mtime) <= cache_ttl) 
296              {
297                  writeLog(0, "CACHE HIT: '" + url + "', using local cache.");
298                  cache_rw_lock.readLock();
299                  defer(cache_rw_lock.readUnlock();)
300                  if(response_headers)
301                      *response_headers = fileGet(path_header, true);
302                  return fileGet(path, true);
303              }
304              writeLog(0, "CACHE MISS: '" + url + "', TTL timeout, creating new cache."); 
305          }
306          else
307              writeLog(0, "CACHE NOT EXIST: '" + url + "', creating new cache.");
308          curlGet(argument, fetch_res);
309          if(return_code == 200) 
310          {
311              cache_rw_lock.writeLock();
312              defer(cache_rw_lock.writeUnlock();)
313              fileWrite(path, content, true);
314              if(response_headers)
315                  fileWrite(path_header, *response_headers, true);
316          }
317          else
318          {
319              if(fileExist(path) && global.serveCacheOnFetchFail) 
320              {
321                  writeLog(0, "Fetch failed. Serving cached content."); 
322                  cache_rw_lock.readLock();
323                  defer(cache_rw_lock.readUnlock();)
324                  content = fileGet(path, true);
325                  if(response_headers)
326                      *response_headers = fileGet(path_header, true);
327              }
328              else
329                  writeLog(0, "Fetch failed. No local cache available."); 
330          }
331          return content;
332      }
333      curlGet(argument, fetch_res);
334      return content;
335  }
336  void flushCache()
337  {
338      cache_rw_lock.writeLock();
339      defer(cache_rw_lock.writeUnlock();)
340      operateFiles("cache", [](const std::string &file){ remove(("cache/" + file).data()); return 0; });
341  }
342  int webPost(const std::string &url, const std::string &data, const std::string &proxy, const string_icase_map &request_headers, std::string *retData)
343  {
344      int return_code = 0;
345      FetchArgument argument {HTTP_POST, url, proxy, &data, &request_headers, nullptr, 0, true};
346      FetchResult fetch_res {&return_code, retData, nullptr, nullptr};
347      return webGet(argument, fetch_res);
348  }
349  int webPatch(const std::string &url, const std::string &data, const std::string &proxy, const string_icase_map &request_headers, std::string *retData)
350  {
351      int return_code = 0;
352      FetchArgument argument {HTTP_PATCH, url, proxy, &data, &request_headers, nullptr, 0, true};
353      FetchResult fetch_res {&return_code, retData, nullptr, nullptr};
354      return webGet(argument, fetch_res);
355  }
356  int webHead(const std::string &url, const std::string &proxy, const string_icase_map &request_headers, std::string &response_headers)
357  {
358      int return_code = 0;
359      FetchArgument argument {HTTP_HEAD, url, proxy, nullptr, &request_headers, nullptr, 0};
360      FetchResult fetch_res {&return_code, nullptr, &response_headers, nullptr};
361      return webGet(argument, fetch_res);
362  }
363  string_array headers_map_to_array(const string_map &headers)
364  {
365      string_array result;
366      for(auto &kv : headers)
367          result.push_back(kv.first + ": " + kv.second);
368      return result;
369  }
370  int webGet(const FetchArgument& argument, FetchResult &result)
371  {
372      return curlGet(argument, result);
373  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-FindReplaceDlg.h</h3>
            <pre><code>1  #pragma once
2  #include <map>
3  #include "FindReplaceDlg_rc.h"
4  #include "ScintillaEditView.h"
5  #include "DockingDlgInterface.h"
6  #include "BoostRegexSearch.h"
7  #include "StatusBar.h"
8  #define FIND_RECURSIVE 1
9  #define FIND_INHIDDENDIR 2
10  #define FINDREPLACE_MAXLENGTH 2048
11  #define FINDREPLACE_INSEL_TEXTSIZE_THRESHOLD 1024
12  #define FINDTEMPSTRING_MAXSIZE 1024*1024
13  enum DIALOG_TYPE {FIND_DLG, REPLACE_DLG, FINDINFILES_DLG, FINDINPROJECTS_DLG, MARK_DLG};
14  #define DIR_DOWN true
15  #define DIR_UP false
16  enum InWhat{ALL_OPEN_DOCS, FILES_IN_DIR, CURRENT_DOC, CURR_DOC_SELECTION, FILES_IN_PROJECTS};
17  struct FoundInfo {
18  	FoundInfo(intptr_t start, intptr_t end, size_t lineNumber, const TCHAR *fullPath)
19  		: _lineNumber(lineNumber), _fullPath(fullPath) {
20  		_ranges.push_back(std::pair<intptr_t, intptr_t>(start, end));
21  	};
22  	std::vector<std::pair<intptr_t, intptr_t>> _ranges;
23  	size_t _lineNumber = 0;
24  	generic_string _fullPath;
25  };
26  struct TargetRange {
27  	int targetStart;
28  	int targetEnd;
29  };
30  enum SearchIncrementalType { NotIncremental, FirstIncremental, NextIncremental };
31  enum SearchType { FindNormal, FindExtended, FindRegex };
32  enum ProcessOperation { ProcessFindAll, ProcessReplaceAll, ProcessCountAll, ProcessMarkAll, ProcessMarkAll_2, ProcessMarkAll_IncSearch, ProcessMarkAllExt, ProcessFindInFinder };
33  struct FindOption
34  {
35  	bool _isWholeWord = true;
36  	bool _isMatchCase = true;
37  	bool _isWrapAround = true;
38  	bool _whichDirection = DIR_DOWN;
39  	SearchIncrementalType _incrementalType = NotIncremental;
40  	SearchType _searchType = FindNormal;
41  	bool _doPurge = false;
42  	bool _doMarkLine = false;
43  	bool _isInSelection = false;
44  	generic_string _str2Search;
45  	generic_string _str4Replace;
46  	generic_string _filters;
47  	generic_string _directory;
48  	bool _isRecursive = true;
49  	bool _isInHiddenDir = false;
50  	bool _isProjectPanel_1 = false;
51  	bool _isProjectPanel_2 = false;
52  	bool _isProjectPanel_3 = false;
53  	bool _dotMatchesNewline = false;
54  	bool _isMatchLineNumber = true; 
55  };
56  class Searching {
57  public:
58  	static int convertExtendedToString(const TCHAR * query, TCHAR * result, int length);
59  	static TargetRange t;
60  	static int buildSearchFlags(const FindOption * option) {
61  		return	(option->_isWholeWord ? SCFIND_WHOLEWORD : 0) |
62  				(option->_isMatchCase ? SCFIND_MATCHCASE : 0) |
63  				(option->_searchType == FindRegex ? SCFIND_REGEXP|SCFIND_POSIX : 0) |
64  				((option->_searchType == FindRegex && option->_dotMatchesNewline) ? SCFIND_REGEXP_DOTMATCHESNL : 0);
65  	};
66  	static void displaySectionCentered(size_t posStart, size_t posEnd, ScintillaEditView * pEditView, bool isDownwards = true);
67  private:
68  	static bool readBase(const TCHAR * str, int * value, int base, int size);
69  };
70  class Finder : public DockingDlgInterface {
71  friend class FindReplaceDlg;
72  public:
73  	Finder() : DockingDlgInterface(IDD_FINDRESULT) {
74  		_markingsStruct._length = 0;
75  		_markingsStruct._markings = NULL;
76  	};
77  	~Finder() {
78  		_scintView.destroy();
79  	}
80  	void init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView) {
81  		DockingDlgInterface::init(hInst, hPere);
82  		_ppEditView = ppEditView;
83  	};
84  	void addSearchLine(const TCHAR *searchName);
85  	void addFileNameTitle(const TCHAR * fileName);
86  	void addFileHitCount(int count);
87  	void addSearchHitCount(int count, int countSearched, bool isMatchLines, bool searchedEntireNotSelection);
88  	const char* foundLine(FoundInfo fi, SearchResultMarkingLine mi, const TCHAR* foundline, size_t totalLineNumber);
89  	void setFinderStyle();
90  	void setFinderStyleForNpc(bool onlyColor = false);
91  	void removeAll();
92  	void openAll();
93  	void wrapLongLinesToggle();
94  	void purgeToggle();
95  	void copy();
96  	void copyPathnames();
97  	void beginNewFilesSearch();
98  	void finishFilesSearch(int count, int searchedCount, bool isMatchLines, bool searchedEntireNotSelection);
99  	void gotoNextFoundResult(int direction);
100  	std::pair<intptr_t, intptr_t> gotoFoundLine(size_t nOccurrence = 0); 
101  	void deleteResult();
102  	std::vector<generic_string> getResultFilePaths() const;
103  	bool canFind(const TCHAR *fileName, size_t lineNumber, size_t* indexToStartFrom) const;
104  	void setVolatiled(bool val) { _canBeVolatiled = val; };
105  	generic_string getHitsString(int count) const;
106  protected :
107  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
108  	bool notify(SCNotification *notification);
109  private:
110  	enum { searchHeaderLevel = SC_FOLDLEVELBASE, fileHeaderLevel, resultLevel };
111  	enum CurrentPosInLineStatus { pos_infront, pos_between, pos_inside, pos_behind };
112  	struct CurrentPosInLineInfo {
113  		CurrentPosInLineStatus _status = pos_infront;
114  		intptr_t auxiliaryInfo = -1; 
115  	};
116  	ScintillaEditView **_ppEditView = nullptr;
117  	std::vector<FoundInfo> _foundInfos1;
118  	std::vector<FoundInfo> _foundInfos2;
119  	std::vector<FoundInfo>* _pMainFoundInfos = &_foundInfos1;
120  	std::vector<SearchResultMarkingLine> _markings1;
121  	std::vector<SearchResultMarkingLine> _markings2;
122  	std::vector<SearchResultMarkingLine>* _pMainMarkings = &_markings1;
123  	SearchResultMarkings _markingsStruct;
124  	intptr_t _previousLineNumber = -1;
125  	ScintillaEditView _scintView;
126  	unsigned int _nbFoundFiles = 0;
127  	intptr_t _lastFileHeaderPos = 0;
128  	intptr_t _lastSearchHeaderPos = 0;
129  	bool _canBeVolatiled = true;
130  	bool _longLinesAreWrapped = false;
131  	bool _purgeBeforeEverySearch = false;
132  	generic_string _prefixLineStr;
133  	void setFinderReadOnly(bool isReadOnly) {
134  		_scintView.execute(SCI_SETREADONLY, isReadOnly);
135  	};
136  	bool isLineActualSearchResult(const generic_string & s) const;
137  	generic_string & prepareStringForClipboard(generic_string & s) const;
138  	static FoundInfo EmptyFoundInfo;
139  	static SearchResultMarkingLine EmptySearchResultMarking;
140  	CurrentPosInLineInfo getCurrentPosInLineInfo(intptr_t currentPosInLine, const SearchResultMarkingLine& markingLine) const;
141  	void anchorWithNoHeaderLines(intptr_t& currentL, intptr_t initL, intptr_t minL, intptr_t maxL, int direction);
142  };
143  enum FindStatus { FSFound, FSNotFound, FSTopReached, FSEndReached, FSMessage, FSNoMessage};
144  enum FindNextType {
145  	FINDNEXTTYPE_FINDNEXT,
146  	FINDNEXTTYPE_REPLACENEXT,
147  	FINDNEXTTYPE_FINDNEXTFORREPLACE
148  };
149  struct FindReplaceInfo
150  {
151  	const TCHAR *_txt2find = nullptr;
152  	const TCHAR *_txt2replace = nullptr;
153  	intptr_t _startRange = -1;
154  	intptr_t _endRange = -1;
155  };
156  struct FindersInfo
157  {
158  	Finder *_pSourceFinder = nullptr;
159  	Finder *_pDestFinder = nullptr;
160  	const TCHAR *_pFileName = nullptr;
161  	FindOption _findOption;
162  };
163  class FindInFinderDlg : public StaticDialog
164  {
165  public:
166  	void doDialog(Finder *launcher, bool isRTL = false);
167  	FindOption & getOption() { return _options; }
168  	FindInFinderDlg() {
169  		_options._isMatchCase = false;
170  		_options._isWholeWord = false;
171  	};
172  private:
173  	Finder  *_pFinder2Search = nullptr;
174  	FindOption _options;
175  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
176  	void initFromOptions();
177  	void writeOptions();
178  };
179  LRESULT run_swapButtonProc(WNDPROC oldEditProc, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
180  class FindReplaceDlg : public StaticDialog
181  {
182  friend class FindIncrementDlg;
183  public :
184  	static FindOption _options;
185  	static FindOption* _env;
186  	FindReplaceDlg() {
187  		_uniFileName = new char[(_fileNameLenMax + 3) * 2];
188  		_winVer = (NppParameters::getInstance()).getWinVersion();
189  		_env = &_options;
190  	};
191  	~FindReplaceDlg();
192  	void init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView) {
193  		Window::init(hInst, hPere);
194  		if (!ppEditView)
195  			throw std::runtime_error("FindIncrementDlg::init : ppEditView is null.");
196  		_ppEditView = ppEditView;
197  	};
198  	void create(int dialogID, bool isRTL = false, bool msgDestParent = true, bool toShow = true);
199  	void initOptionsFromDlg();
200  	void doDialog(DIALOG_TYPE whichType, bool isRTL = false, bool toShow = true);
201  	bool processFindNext(const TCHAR *txt2find, const FindOption *options = NULL, FindStatus *oFindStatus = NULL, FindNextType findNextType = FINDNEXTTYPE_FINDNEXT);
202  	bool processReplace(const TCHAR *txt2find, const TCHAR *txt2replace, const FindOption *options = NULL);
203  	int markAll(const TCHAR *txt2find, int styleID);
204  	int markAllInc(const FindOption *opt);
205  	int processAll(ProcessOperation op, const FindOption *opt, bool isEntire = false, const FindersInfo *pFindersInfo = nullptr, int colourStyleID = -1);
206  	int processRange(ProcessOperation op, FindReplaceInfo & findReplaceInfo, const FindersInfo *pFindersInfo, const FindOption *opt = nullptr, int colourStyleID = -1, ScintillaEditView *view2Process = nullptr);
207  	void replaceAllInOpenedDocs();
208  	void findAllIn(InWhat op);
209  	void setSearchText(TCHAR * txt2find);
210  	void gotoNextFoundResult(int direction = 0) {if (_pFinder) _pFinder->gotoNextFoundResult(direction);};
211  	void putFindResult(int result) {
212  		_findAllResult = result;
213  	};
214  	const TCHAR * getDir2Search() const {return _env->_directory.c_str();};
215  	void getPatterns(std::vector<generic_string> & patternVect);
216  	void getAndValidatePatterns(std::vector<generic_string> & patternVect);
217  	void launchFindInFilesDlg() {
218  		doDialog(FINDINFILES_DLG);
219  	};
220  	void launchFindInProjectsDlg() {
221  		doDialog(FINDINPROJECTS_DLG);
222  	};
223  	void setFindInFilesDirFilter(const TCHAR *dir, const TCHAR *filters);
224  	void setProjectCheckmarks(FindHistory *findHistory, int Msk);
225  	void enableProjectCheckmarks();
226  	generic_string getText2search() const {
227  		return _env->_str2Search;
228  	};
229  	const generic_string & getFilters() const {return _env->_filters;};
230  	const generic_string & getDirectory() const {return _env->_directory;};
231  	const FindOption & getCurrentOptions() const {return *_env;};
232  	bool isRecursive() const { return _env->_isRecursive; };
233  	bool isInHiddenDir() const { return _env->_isInHiddenDir; };
234  	bool isProjectPanel_1() const { return _env->_isProjectPanel_1; };
235  	bool isProjectPanel_2() const { return _env->_isProjectPanel_2; };
236  	bool isProjectPanel_3() const { return _env->_isProjectPanel_3; };
237  	void saveFindHistory();
238  	void changeTabName(DIALOG_TYPE index, const TCHAR *name2change) {
239  		TCITEM tie{};
240  		tie.mask = TCIF_TEXT;
241  		tie.pszText = (TCHAR *)name2change;
242  		TabCtrl_SetItem(_tab.getHSelf(), index, &tie);
243  		TCHAR label[MAX_PATH]{};
244  		_tab.getCurrentTitle(label, MAX_PATH);
245  		::SetWindowText(_hSelf, label);
246  	}
247  	void beginNewFilesSearch()
248  	{
249  		_pFinder->beginNewFilesSearch();
250  		_pFinder->addSearchLine(getText2search().c_str());
251  	}
252  	void finishFilesSearch(int count, int searchedCount, bool searchedEntireNotSelection)
253  	{
254  		const bool isMatchLines = false;
255  		_pFinder->finishFilesSearch(count, searchedCount, isMatchLines, searchedEntireNotSelection);
256  	}
257  	void focusOnFinder() {
258  		if (_pFinder) 
259  		{
260  			_pFinder->display();
261  			_pFinder->_scintView.getFocus();
262  		}
263  	};
264  	HWND getHFindResults() {
265  		if (_pFinder)
266  			return _pFinder->_scintView.getHSelf();
267  		return NULL;
268  	}
269  	void updateFinderScintilla() {
270  		if (_pFinder && _pFinder->isCreated())
271  		{
272  			_pFinder->setFinderStyle();
273  			if (!_findersOfFinder.empty())
274  			{
275  				for (const auto& finder : _findersOfFinder)
276  				{
277  					finder->setFinderStyle();
278  				}
279  			}
280  		}
281  	};
282  	void updateFinderScintillaForNpc(bool onlyColor = false) {
283  		if (_pFinder && _pFinder->isCreated())
284  		{
285  			_pFinder->setFinderStyleForNpc(onlyColor);
286  			if (!_findersOfFinder.empty())
287  			{
288  				for (const auto& finder : _findersOfFinder)
289  				{
290  					finder->setFinderStyleForNpc();
291  				}
292  			}
293  		}
294  	};
295  	void execSavedCommand(int cmd, uptr_t intValue, const generic_string& stringValue);
296  	void clearMarks(const FindOption& opt);
297  	void setStatusbarMessage(const generic_string & msg, FindStatus staus, char const *pTooltipMsg = NULL);
298  	generic_string getScopeInfoForStatusBar(FindOption const *pFindOpt) const;
299  	Finder * createFinder();
300  	bool removeFinder(Finder *finder2remove);
301  	DIALOG_TYPE getCurrentStatus() {return _currentStatus;};
302  protected :
303  	void resizeDialogElements(LONG newWidth);
304  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
305  	static WNDPROC originalFinderProc;
306  	static WNDPROC originalComboEditProc;
307  	static LRESULT FAR PASCAL comboEditProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
308  	static LRESULT FAR PASCAL finderProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
309      void combo2ExtendedMode(int comboID);
310  private :
311  	RECT _initialWindowRect = {};
312  	LONG _deltaWidth = 0;
313  	LONG _initialClientWidth = 0;
314  	LONG _lesssModeHeight = 0;
315  	DIALOG_TYPE _currentStatus = DIALOG_TYPE::FIND_DLG;
316  	RECT _findClosePos = {};
317  	RECT _replaceClosePos = {};
318  	RECT _findInFilesClosePos = {};
319  	RECT _markClosePos = {};
320  	RECT _countInSelFramePos = {};
321  	RECT _replaceInSelFramePos = {};
322  	RECT _countInSelCheckPos = {};
323  	RECT _replaceInSelCheckPos = {};
324  	RECT _collapseButtonPos = {};
325  	RECT _uncollapseButtonPos = {};
326  	ScintillaEditView **_ppEditView = nullptr;
327  	Finder  *_pFinder = nullptr;
328  	generic_string _findResTitle;
329  	std::vector<Finder*> _findersOfFinder{};
330  	HWND _shiftTrickUpTip = nullptr;
331  	HWND _2ButtonsTip = nullptr;
332  	HWND _filterTip = nullptr;
333  	bool _isRTL = false;
334  	int _findAllResult = 0;
335  	TCHAR _findAllResultStr[1024] = {'\0'};
336  	int _fileNameLenMax = 1024;
337  	char *_uniFileName = nullptr;
338  	TabBar _tab;
339  	winVer _winVer = winVer::WV_UNKNOWN;
340  	StatusBar _statusBar;
341  	FindStatus _statusbarFindStatus;
342  	generic_string _statusbarTooltipMsg;
343  	HWND _statusbarTooltipWnd = nullptr;
344  	HICON _statusbarTooltipIcon = nullptr;
345  	int _statusbarTooltipIconSize = 0;
346  	HFONT _hMonospaceFont = nullptr;
347  	HFONT _hLargerBolderFont = nullptr;
348  	HFONT _hCourrierNewFont = nullptr;
349  	std::map<int, bool> _controlEnableMap;
350  	std::vector<int> _reduce2hide_find = { IDC_IN_SELECTION_CHECK, IDC_REPLACEINSELECTION, IDC_FINDALL_CURRENTFILE };
351  	std::vector<int> _reduce2hide_findReplace = { IDC_IN_SELECTION_CHECK, IDC_REPLACEINSELECTION, IDREPLACEALL };
352  	std::vector<int> _reduce2hide_fif = { IDD_FINDINFILES_FILTERS_STATIC, IDD_FINDINFILES_FILTERS_COMBO, IDCANCEL };
353  	std::vector<int> _reduce2hide_fip = { IDD_FINDINFILES_FILTERS_STATIC, IDD_FINDINFILES_FILTERS_COMBO, IDCANCEL };
354  	std::vector<int> _reduce2hide_mark = { IDC_MARKLINE_CHECK, IDC_PURGE_CHECK, IDC_IN_SELECTION_CHECK, IDC_COPY_MARKED_TEXT };
355  	void enableFindDlgItem(int dlgItemID, bool isEnable = true);
356  	void showFindDlgItem(int dlgItemID, bool isShow = true);
357  	void enableReplaceFunc(bool isEnable);
358  	void enableFindInFilesControls(bool isEnable, bool projectPanels);
359  	void enableFindInFilesFunc();
360  	void enableFindInProjectsFunc();
<span onclick='openModal()' class='match'>361  	void enableMarkAllControls(bool isEnable);
362  	void enableMarkFunc();
363  	void hideOrShowCtrl4reduceOrNormalMode(DIALOG_TYPE dlgT);
364  	void setDefaultButton(int nID) {
365  		SendMessage(_hSelf, DM_SETDEFID, nID, 0L);
366  	};
367  	void gotoCorrectTab() {
368  		auto currentIndex = _tab.getCurrentTabIndex();
</span>369  		if (currentIndex != _currentStatus)
370  			_tab.activateAt(_currentStatus);
371  	};
372  	FindStatus getFindStatus() {
373  		return _statusbarFindStatus;
374  	}
375  	void updateCombos();
376  	void updateCombo(int comboID);
377  	void fillFindHistory();
378      void fillComboHistory(int id, const std::vector<generic_string> & strings);
379  	int saveComboHistory(int id, int maxcount, std::vector<generic_string> & strings, bool saveEmpty);
380  	static const int FR_OP_FIND = 1;
381  	static const int FR_OP_REPLACE = 2;
382  	static const int FR_OP_FIF = 4;
383  	static const int FR_OP_GLOBAL = 8;
384  	static const int FR_OP_FIP = 16;
385  	void saveInMacro(size_t cmd, int cmdType);
386  	void drawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
387  	bool replaceInFilesConfirmCheck(generic_string directory, generic_string fileTypes);
388  	bool replaceInProjectsConfirmCheck();
389  	bool replaceInOpenDocsConfirmCheck(void);
390  	ContextMenu _swapPopupMenu;
391  	enum SwapButtonStatus {swap, down, up} _swapButtonStatus = swap;
392  	HWND _hSwapButton = nullptr;
393  	static LRESULT CALLBACK swapButtonProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
394  		const auto dlg = (FindReplaceDlg*)(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
395  		return (run_swapButtonProc(dlg->_oldSwapButtonProc, hwnd, message, wParam, lParam));
396  	};
397  	WNDPROC _oldSwapButtonProc = nullptr;
398  };
399  class FindIncrementDlg : public StaticDialog
400  {
401  public :
402  	FindIncrementDlg() = default;
403  	void init(HINSTANCE hInst, HWND hPere, FindReplaceDlg *pFRDlg, bool isRTL = false);
404  	void destroy() override;
405  	void display(bool toShow = true) const override;
406  	void setSearchText(const TCHAR* txt2find, bool) {
407  		::SendDlgItemMessage(_hSelf, IDC_INCFINDTEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(txt2find));
408  	};
409  	void setFindStatus(FindStatus iStatus, int nbCounted);
410  	FindStatus getFindStatus() {
411  		return _findStatus;
412  	}
413  	void addToRebar(ReBar* rebar);
414  private :
415  	bool _isRTL = false;
416  	FindReplaceDlg *_pFRDlg = nullptr;
417  	FindStatus _findStatus = FSFound;
418  	ReBar* _pRebar = nullptr;
419  	REBARBANDINFO _rbBand{};
420  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
421  	void markSelectedTextInc(bool enable, FindOption *opt = NULL);
422  };
423  class Progress
424  {
425  public:
426  	explicit Progress(HINSTANCE hInst);
427  	~Progress();
428  	Progress(const Progress&) = delete;
429  	const Progress& operator=(const Progress&) = delete;
430  	HWND open(HWND hCallerWnd, const TCHAR* header = NULL);
431  	void close();
432  	bool isCancelled() const
433  	{
434  		if (_hwnd)
435  			return (::WaitForSingleObject(_hActiveState, 0) != WAIT_OBJECT_0);
436  		return false;
437  	}
438  	void setPercent(unsigned percent, const TCHAR* fileName, int nbHitsSoFar) const;
439  	void setInfo(const TCHAR* info, int nbHitsSoFar = -1) const;
440  private:
441  	static const TCHAR cClassName[];
442  	static const TCHAR cDefaultHeader[];
443  	static const int cBackgroundColor;
444  	static const int cPBwidth;
445  	static const int cPBheight;
446  	static const int cBTNwidth;
447  	static const int cBTNheight;
448  	static volatile LONG refCount;
449  	static DWORD WINAPI threadFunc(LPVOID data);
450  	static LRESULT APIENTRY wndProc(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam);
451  	int thread();
452  	int createProgressWindow();
453  	HINSTANCE _hInst = nullptr;
454  	volatile HWND _hwnd = nullptr;
455  	HWND _hCallerWnd = nullptr;
456  	TCHAR _header[128] = {'\0'};
457  	HANDLE _hThread = nullptr;
458  	HANDLE _hActiveState = nullptr;
459  	HWND _hPathText = nullptr;
460  	HWND _hRunningHitsStaticText = nullptr;
461  	HWND _hRunningHitsText = nullptr;
462  	HWND _hPBar = nullptr;
463  	HWND _hBtn = nullptr;
464  	HFONT _hFont = nullptr;
465  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-webget.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-FindReplaceDlg.h</div>
                </div>
                <div class="column column_space"><pre><code>25      const std::thread::id NULL_THREAD;
26      const bool WRITE_FIRST;
27      std::thread::id m_write_thread_id;
28      std::atomic_int m_lockCount;
29      std::atomic_uint m_writeWaitCount;
30  public:
31      RWLock(const RWLock&) = delete;
32      RWLock& operator=(const RWLock&) = delete;
</pre></code></div>
                <div class="column column_space"><pre><code>361  	void enableMarkAllControls(bool isEnable);
362  	void enableMarkFunc();
363  	void hideOrShowCtrl4reduceOrNormalMode(DIALOG_TYPE dlgT);
364  	void setDefaultButton(int nID) {
365  		SendMessage(_hSelf, DM_SETDEFID, nID, 0L);
366  	};
367  	void gotoCorrectTab() {
368  		auto currentIndex = _tab.getCurrentTabIndex();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    