
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.217948717948719%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-utility_21.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/locks.hpp>
3  #include <boost/current_function.hpp>
4  #include <boost/preprocessor/facilities/empty.hpp>
5  #include <boost/preprocessor/facilities/overload.hpp>
6  #include <cassert>
7  #include <functional>
8  #include <mutex>
9  #include <vector>
10  #include <magic_enum_containers.hpp>
11  namespace boost
12  {
13  namespace filesystem
14  {
15  	class path;
16  }
17  namespace system
18  {
19  	class error_code;
20  }
21  namespace program_options
22  {
23  	class options_description;
24  }
25  }
26  void assert_internal (char const * check_expr, char const * func, char const * file, unsigned int line, bool is_release_assert, std::string_view error = "");
27  #define release_assert_1(check) check ? (void)0 : assert_internal (#check, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__, true)
28  #define release_assert_2(check, error_msg) check ? (void)0 : assert_internal (#check, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__, true, error_msg)
29  #if !BOOST_PP_VARIADICS_MSVC
30  #define release_assert(...)                          \
31  	BOOST_PP_OVERLOAD (release_assert_, __VA_ARGS__) \
32  	(__VA_ARGS__)
33  #else
34  #define release_assert(...) BOOST_PP_CAT (BOOST_PP_OVERLOAD (release_assert_, __VA_ARGS__) (__VA_ARGS__), BOOST_PP_EMPTY ())
35  #endif
36  #ifdef NDEBUG
37  #define debug_assert(...) (void)0
38  #else
39  #define debug_assert_1(check) check ? (void)0 : assert_internal (#check, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__, false)
40  #define debug_assert_2(check, error_msg) check ? (void)0 : assert_internal (#check, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__, false, error_msg)
41  #if !BOOST_PP_VARIADICS_MSVC
42  #define debug_assert(...)                          \
43  	BOOST_PP_OVERLOAD (debug_assert_, __VA_ARGS__) \
44  	(__VA_ARGS__)
45  #else
46  #define debug_assert(...) BOOST_PP_CAT (BOOST_PP_OVERLOAD (debug_assert_, __VA_ARGS__) (__VA_ARGS__), BOOST_PP_EMPTY ())
47  #endif
48  #endif
49  namespace nano
50  {
51  template <typename Index, typename Value>
52  using enum_array = magic_enum::containers::array<Index, Value>;
53  struct container_info
54  {
55  	std::string name;
56  	size_t count;
57  	size_t sizeof_element;
58  };
59  class container_info_component
60  {
61  public:
62  	virtual ~container_info_component () = default;
63  	virtual bool is_composite () const = 0;
64  };
65  class container_info_composite : public container_info_component
66  {
67  public:
68  	container_info_composite (std::string const & name);
69  	bool is_composite () const override;
70  	void add_component (std::unique_ptr<container_info_component> child);
71  	std::vector<std::unique_ptr<container_info_component>> const & get_children () const;
72  	std::string const & get_name () const;
73  private:
74  	std::string name;
75  	std::vector<std::unique_ptr<container_info_component>> children;
76  };
77  class container_info_leaf : public container_info_component
78  {
79  public:
80  	container_info_leaf (container_info const & info);
81  	bool is_composite () const override;
82  	container_info const & get_info () const;
83  private:
84  	container_info info;
85  };
86  void work_thread_reprioritize ();
87  void set_umask ();
<span onclick='openModal()' class='match'>88  void set_secure_perm_directory (boost::filesystem::path const & path);
89  void set_secure_perm_directory (boost::filesystem::path const & path, boost::system::error_code & ec);
90  void set_secure_perm_file (boost::filesystem::path const & path);
91  void set_secure_perm_file (boost::filesystem::path const & path, boost::system::error_code & ec);
92  bool is_windows_elevated ();
93  bool event_log_reg_entry_exists ();
94  void create_load_memory_address_files ();
95  std::size_t get_file_descriptor_limit ();
96  void set_file_descriptor_limit (std::size_t limit);
97  void remove_all_files_in_dir (boost::filesystem::path const & dir);
98  void move_all_files_to_dir (boost::filesystem::path const & from, boost::filesystem::path const & to);
</span>99  template <class InputIt, class OutputIt, class Pred, class Func>
100  void transform_if (InputIt first, InputIt last, OutputIt dest, Pred pred, Func transform)
101  {
102  	while (first != last)
103  	{
104  		if (pred (*first))
105  		{
106  			*dest++ = transform (*first);
107  		}
108  		++first;
109  	}
110  }
111  template <class Container, class Pred>
112  void erase_if (Container & container, Pred pred)
113  {
114  	for (auto it = container.begin (), end = container.end (); it != end;)
115  	{
116  		if (pred (*it))
117  		{
118  			it = container.erase (it);
119  		}
120  		else
121  		{
122  			++it;
123  		}
124  	}
125  }
126  template <typename TARGET_TYPE, typename SOURCE_TYPE>
127  constexpr TARGET_TYPE narrow_cast (SOURCE_TYPE const & val)
128  {
129  	auto res (static_cast<TARGET_TYPE> (val));
130  	debug_assert (val == static_cast<SOURCE_TYPE> (res));
131  	return res;
132  }
133  void sort_options_description (const boost::program_options::options_description & source, boost::program_options::options_description & target);
134  using clock = std::chrono::steady_clock;
135  template <typename Duration>
136  bool elapsed (nano::clock::time_point const & last, Duration duration, nano::clock::time_point const & now)
137  {
138  	return last + duration < now;
139  }
140  template <typename Duration>
141  bool elapsed (nano::clock::time_point const & last, Duration duration)
142  {
143  	return elapsed (last, duration, nano::clock::now ());
144  }
145  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</h3>
            <pre><code>1  #include <caffe/caffe.hpp>
2  #ifdef USE_OPENCV
3  #include <opencv2/core/core.hpp>
4  #include <opencv2/highgui/highgui.hpp>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #endif  
7  #include <algorithm>
8  #include <iosfwd>
9  #include <memory>
10  #include <string>
11  #include <utility>
12  #include <vector>
13  #include <gflags/gflags.h>
14  #ifdef USE_OPENCV
15  using namespace caffe;  
16  using std::string;
17  using std::cout;
18  using std::cerr;
19  using std::endl;
20  using std::vector;
21  DEFINE_string(model, "",
22      "Required; The model definition protocol buffer text file.");
23  DEFINE_string(weights, "",
24      "Required; The pretrained weights.");
25  DEFINE_string(input, "",
26      "Required; File that contain the path of input images line by line");
27  DEFINE_string(label_file, "",
28      "Required; The label file.");
29  DEFINE_string(engine, "",
30      "Optional; Engine can only be CAFFE | MKL2017 | MKLDNN");
31  DEFINE_string(mean_file, "",
32      "Optional; The mean file used to subtract from the input image.");
33  DEFINE_string(mean_value, "104,117,123",
34      "Optional; If specified, can be one value or can be same as image channels"
35      " - would subtract from the corresponding channel). Separated by ','.");
36  DEFINE_int32(batch_size, 1,
37      "Optional; batch size, default 1");
38  typedef std::pair<string, float> Prediction;
39  class Classifier {
40      public:
41          Classifier(const string& model_file,
42                  const string& trained_file,
43                  const string& mean_file,
44                  const string& mean_value,
45                  const string& label_file,
46                  const string& engine,
47                  const size_t batch_size,
<span onclick='openModal()' class='match'>48                  const size_t topN = 5
49                  );
50          vector<vector<Prediction> > ClassifyBatch(vector<cv::Mat>& imgs);
51      private:
52          void SetMean(const string& mean_file, const string& mean_value);
</span>53          vector<float> PredictBatch(vector<cv::Mat>& imgs);
54          void WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch);
55          void WriteImgToInput(const vector<cv::Mat>& imgs, vector<vector<cv::Mat> >* input_channels_batch);
56          void Preprocess(cv::Mat& img);
57          void PreprocessBatch(vector<cv::Mat>& imgs);
58      private:
59          shared_ptr<Net<float> > net_;
60          cv::Size input_geometry_;
61          int num_channels_;
62          cv::Mat mean_;
63          size_t batch_size_;
64          size_t topN_;
65          std::vector<string> labels_;
66  };
67  Classifier::Classifier(const string& model_file,
68          const string& trained_file,
69          const string& mean_file,
70          const string& mean_value,
71          const string& label_file,
72          const string& engine,
73          const size_t batch_size,
74          const size_t topN
75          ) {
76  #ifdef CPU_ONLY
77      Caffe::set_mode(Caffe::CPU);
78  #else
79      Caffe::set_mode(Caffe::GPU);
80  #endif
81      net_.reset(new Net<float>(model_file, TEST, 0, NULL, NULL, engine));
82      net_->CopyTrainedLayersFrom(trained_file);
83      CHECK_EQ(net_->num_inputs(), 1) << "Network should have exactly one input.";
84      CHECK_EQ(net_->num_outputs(), 1) << "Network should have exactly one output.";
85      Blob<float>* input_layer = net_->input_blobs()[0];
86      num_channels_ = input_layer->channels();
87      CHECK(num_channels_ == 3 || num_channels_ == 1)
88          << "Input layer should have 1 or 3 channels.";
89      input_geometry_ = cv::Size(input_layer->width(), input_layer->height());
90      SetMean(mean_file, mean_value);
91      batch_size_ = batch_size;
92      topN_ = topN;
93      if(!label_file.empty()) {
94      std::ifstream labels(label_file.c_str());
95      CHECK(labels) << "Unable to open labels file " << label_file;
96      string line;
97      while (std::getline(labels, line))
98          labels_.push_back(string(line));
99      Blob<float>* output_layer = net_->output_blobs()[0];
100      CHECK_EQ(labels_.size(), output_layer->channels())
101          << "Number of labels is different from the output layer dimension.";
102      }
103  }
104  static bool PairCompare(const std::pair<float, int>& lhs,
105          const std::pair<float, int>& rhs) {
106      return lhs.first > rhs.first;
107  }
108  static vector<int> Argmax(const vector<float>& v, int N) {
109      vector<std::pair<float, int> > pairs;
110      for (size_t i = 0; i < v.size(); ++i)
111          pairs.push_back(std::make_pair(v[i], i));
112      std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);
113      vector<int> result;
114      for (int i = 0; i < N; ++i)
115          result.push_back(pairs[i].second);
116      return result;
117  }
118  vector<vector<Prediction> > Classifier::ClassifyBatch(vector<cv::Mat>& imgs) {
119      vector<float> output_batch = PredictBatch(imgs);
120      vector<vector<Prediction> > predictionsBatch;
121      int output_channels = net_->output_blobs()[0]->channels();
122      for (size_t i = 0; i < batch_size_; ++i) {
123          vector<float> output(output_batch.begin() + i*output_channels, output_batch.begin()+(i+1)*output_channels);
124          vector<int> maxN = Argmax(output, topN_);
125          vector<Prediction>  predictions;
126          for (int i = 0; i < topN_; ++i) {
127              int idx = maxN[i];
128              if(labels_.empty()) {
129                  predictions.push_back(std::make_pair(std::to_string(idx), output[idx]));
130              } else{
131                  predictions.push_back(std::make_pair(labels_[idx], output[idx]));
132              }
133          }
134          predictionsBatch.push_back(predictions);
135      }
136      return predictionsBatch;
137  }
138  void Classifier::SetMean(const string& mean_file, const string& mean_value) {
139      cv::Scalar channel_mean;
140      if(!mean_file.empty()) {
141          BlobProto blob_proto;
142          ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);
143          Blob<float> mean_blob;
144          mean_blob.FromProto(blob_proto);
145          CHECK_EQ(mean_blob.channels(), num_channels_)
146              << "Number of channels of mean file doesn't match input layer.";
147          vector<cv::Mat> channels;
148          float* data = mean_blob.mutable_cpu_data();
149          for (int i = 0; i < num_channels_; ++i) {
150              cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
151              channels.push_back(channel);
152              data += mean_blob.height() * mean_blob.width();
153          }
154          cv::Mat mean;
155          cv::merge(channels, mean);
156          channel_mean = cv::mean(mean);
157          mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
158      }
159      if (!mean_value.empty()) {
160          stringstream ss(mean_value);
161          vector<float> values;
162          string item;
163          while (getline(ss, item, ',')) {
164              float value = std::atof(item.c_str());
165              values.push_back(value);
166          }
167          CHECK(values.size() == 1 || values.size() == num_channels_) <<
168              "Specify either 1 mean_value or as many as channels: " << num_channels_;
169          std::vector<cv::Mat> channels;
170          for (int i = 0; i < num_channels_; ++i) {
171              cv::Mat channel(input_geometry_.height, input_geometry_.width, CV_32FC1,
172                      cv::Scalar(values[i]));
173              channels.push_back(channel);
174          }
175          cv::merge(channels, mean_);
176      }
177  }
178  vector<float> Classifier::PredictBatch(vector<cv::Mat>& imgs) {
179      Blob<float>* input_layer = net_->input_blobs()[0];
180      input_layer->Reshape(batch_size_, num_channels_,
181              input_geometry_.height, input_geometry_.width);
182      net_->Reshape();
183      vector<vector<cv::Mat> > input_channels_batch;
184      WrapInputLayerBatch(&input_channels_batch);
185      PreprocessBatch(imgs);
186      WriteImgToInput(imgs, &input_channels_batch);
187      net_->Forward();
188      Blob<float>* output_layer = net_->output_blobs()[0];
189      const float* begin = output_layer->cpu_data();
190      const float* end = begin + output_layer->channels() * batch_size_;
191      printf("output_layer->channels: %d\n", output_layer->channels());
192      return vector<float>(begin, end);
193  }
194  void Classifier::WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch) {
195      Blob<float>* input_layer = net_->input_blobs()[0];
196      int width = input_layer->width();
197      int height = input_layer->height();
198      float* input_data = input_layer->mutable_cpu_data();
199      int num = input_layer->num();
200      for( int j = 0; j < num; ++j) {
201          vector<cv::Mat> input_channels;
202          for (int i = 0; i < input_layer->channels(); ++i) {
203              cv::Mat channel(height, width, CV_32FC1, input_data);
204              input_channels.push_back(channel);
205              input_data += width * height;
206          }
207          input_channels_batch->push_back(input_channels);
208      }
209  }
210  void Classifier::WriteImgToInput(const vector<cv::Mat>& imgs,
211          vector<vector<cv::Mat> >* input_channels_batch)
212  {
213      for(size_t i=0; i<batch_size_; ++i) {
214          cv::split(imgs[i], input_channels_batch->at(i));
215      }
216  }
217  void Classifier::PreprocessBatch(vector<cv::Mat>& imgs) {
218      for(size_t i=0; i<imgs.size(); ++i) {
219          Preprocess(imgs[i]);
220      }
221  }
222  void Classifier::Preprocess(cv::Mat& img) {
223      cv::Mat sample;
224      if (img.channels() == 3 && num_channels_ == 1)
225          cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
226      else if (img.channels() == 4 && num_channels_ == 1)
227          cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
228      else if (img.channels() == 4 && num_channels_ == 3)
229          cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
230      else if (img.channels() == 1 && num_channels_ == 3)
231          cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
232      else
233          sample = img;
234      cv::Mat sample_resized;
235      if (sample.size() != input_geometry_)
236          cv::resize(sample, sample_resized, input_geometry_);
237      else
238          sample_resized = sample;
239      cv::Mat sample_float;
240      if (num_channels_ == 3)
241          sample_resized.convertTo(sample_float, CV_32FC3);
242      else
243          sample_resized.convertTo(sample_float, CV_32FC1);
244      cv::subtract(sample_float, mean_, img);
245  }
246  vector<cv::Mat> loadImgBatch(vector<string> imgNames) {
247      vector<cv::Mat> imgs;
248      for(size_t i=0; i<imgNames.size(); ++i) {
249          cv::Mat img = cv::imread(imgNames[i], -1);
250          CHECK(!img.empty()) << "Unable to decode image " << imgNames[i];
251          imgs.push_back(img);
252      }
253      return imgs;
254  }
255  void printPrediction(vector<Prediction> predictions) {
256      for (size_t i = 0; i < predictions.size(); ++i) {
257          Prediction p = predictions[i];
258          cout << std::fixed << std::setprecision(4) << p.second << " - \""
259              << p.first << "\"" << endl;
260      }
261  }
262  void printPredictionsBatch(vector<string> imgNames,
263          vector<vector<Prediction> > predictionsBatch) {
264      for( size_t i = 0; i < predictionsBatch.size(); ++i) {
265          cout << "---------- "<< i + 1 <<": Prediction for "
266              << imgNames[i] << " ----------" << endl;
267          printPrediction(predictionsBatch[i]);
268      }
269  }
270  vector<string> readImgListFromPath(string file) {
271      vector<string> rawImgNames;
272      std::ifstream input_lines(file.c_str());
273      CHECK(input_lines) << "Unable to open file " << file;
274      string line;
275      while (std::getline(input_lines, line))
276          rawImgNames.push_back(string(line));
277      return rawImgNames;
278  }
279  int main(int argc, char** argv) {
280      ::google::InitGoogleLogging(argv[0]);
281  #ifndef GFLAGS_GFLAGS_H_
282      namespace gflags = google;
283  #endif
284      gflags::SetUsageMessage("Image classification.\n"
285          "Usage:\n"
286          "batch_classification <args>\n"
287          "Example: ./batch_classification --model <model path> --weights <weights path> --input <input.txt> --batch_size <num>"
288          );
289      gflags::ParseCommandLineFlags(&argc, &argv, true);
290      CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to score.";
291      CHECK_GT(FLAGS_weights.size(), 0) << "Need model weights to score.";
292      CHECK_GT(FLAGS_input.size(), 0) << "Need model weights to score.";
293      cout<<"Use batch size: "<< FLAGS_batch_size << endl;
294      if (FLAGS_mean_file.empty()) {
295          cout<<"Use mean value: "<< FLAGS_mean_value<<endl;
296      }else{
297          cout<<"Use mean file: "<<FLAGS_mean_file<<endl;
298      }
299  #ifdef USE_MLSL
300      caffe::mn::init(&argc,&argv);
301  #endif
302      Classifier classifier(FLAGS_model, FLAGS_weights, FLAGS_mean_file,
303              FLAGS_mean_value, FLAGS_label_file, FLAGS_engine, FLAGS_batch_size);
304      vector<string> rawImgNames = readImgListFromPath(FLAGS_input);
305      if(rawImgNames.size() > 0 && rawImgNames.size() < FLAGS_batch_size) {
306          while(rawImgNames.size() < FLAGS_batch_size) {
307              rawImgNames.insert(rawImgNames.end(), rawImgNames.begin(), rawImgNames.end());
308          }
309      }
310      vector<string> imgNames(rawImgNames.begin(), rawImgNames.begin() + FLAGS_batch_size);
311      vector<cv::Mat> imgs = loadImgBatch(rawImgNames);
312      vector<vector<Prediction> > predictionsBatch = classifier.ClassifyBatch(imgs);
313      printPredictionsBatch(imgNames, predictionsBatch);
314      return 0;
315  }
316  #else
317  int main(int argc, char** argv) {
318      LOG(FATAL) << "This example requires OpenCV; compile with USE_OPENCV.";
319  }
320  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-utility_21.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</div>
                </div>
                <div class="column column_space"><pre><code>88  void set_secure_perm_directory (boost::filesystem::path const & path);
89  void set_secure_perm_directory (boost::filesystem::path const & path, boost::system::error_code & ec);
90  void set_secure_perm_file (boost::filesystem::path const & path);
91  void set_secure_perm_file (boost::filesystem::path const & path, boost::system::error_code & ec);
92  bool is_windows_elevated ();
93  bool event_log_reg_entry_exists ();
94  void create_load_memory_address_files ();
95  std::size_t get_file_descriptor_limit ();
96  void set_file_descriptor_limit (std::size_t limit);
97  void remove_all_files_in_dir (boost::filesystem::path const & dir);
98  void move_all_files_to_dir (boost::filesystem::path const & from, boost::filesystem::path const & to);
</pre></code></div>
                <div class="column column_space"><pre><code>48                  const size_t topN = 5
49                  );
50          vector<vector<Prediction> > ClassifyBatch(vector<cv::Mat>& imgs);
51      private:
52          void SetMean(const string& mean_file, const string& mean_value);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    