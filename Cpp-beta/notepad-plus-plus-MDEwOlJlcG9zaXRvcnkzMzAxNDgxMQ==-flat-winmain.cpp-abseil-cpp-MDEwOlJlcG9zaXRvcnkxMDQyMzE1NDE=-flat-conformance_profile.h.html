
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.200578592092572%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-winmain.cpp</h3>
            <pre><code>1  #include "Notepad_plus_Window.h"
2  #include "Processus.h"
3  #include "Win32Exception.h"	
4  #include "MiniDumper.h"			
5  #include "verifySignedfile.h"
6  #include "NppDarkMode.h"
7  #include <memory>
8  typedef std::vector<generic_string> ParamVector;
9  namespace
10  {
11  void allowPrivilegeMessages(const Notepad_plus_Window& notepad_plus_plus, winVer winVer)
12  {
13  	#ifndef MSGFLT_ADD
14  	const DWORD MSGFLT_ADD = 1;
15  	#endif
16  	#ifndef MSGFLT_ALLOW
17  	const DWORD MSGFLT_ALLOW = 1;
18  	#endif
19  	if (winVer >= WV_VISTA || winVer == WV_UNKNOWN)
20  	{
21  		HMODULE hDll = GetModuleHandle(TEXT("user32.dll"));
22  		if (hDll)
23  		{
24  			if (winVer == WV_VISTA)
25  			{
26  				typedef BOOL (WINAPI *MESSAGEFILTERFUNC)(UINT message,DWORD dwFlag);
27  				MESSAGEFILTERFUNC func = (MESSAGEFILTERFUNC)::GetProcAddress( hDll, "ChangeWindowMessageFilter" );
28  				if (func)
29  				{
30  					func(WM_COPYDATA, MSGFLT_ADD);
31  					func(NPPM_INTERNAL_RESTOREFROMTRAY, MSGFLT_ADD);
32  				}
33  			}
34  			else
35  			{
36  				typedef BOOL (WINAPI *MESSAGEFILTERFUNCEX)(HWND hWnd,UINT message,DWORD action,VOID* pChangeFilterStruct);
37  				MESSAGEFILTERFUNCEX funcEx = (MESSAGEFILTERFUNCEX)::GetProcAddress( hDll, "ChangeWindowMessageFilterEx" );
38  				if (funcEx)
39  				{
40  					funcEx(notepad_plus_plus.getHSelf(), WM_COPYDATA, MSGFLT_ALLOW, NULL);
41  					funcEx(notepad_plus_plus.getHSelf(), NPPM_INTERNAL_RESTOREFROMTRAY, MSGFLT_ALLOW, NULL);
42  				}
43  			}
44  		}
45  	}
46  }
47  void parseCommandLine(const TCHAR* commandLine, ParamVector& paramVector)
48  {
49  	if (!commandLine)
50  		return;
51  	TCHAR* cmdLine = new TCHAR[lstrlen(commandLine) + 1];
52  	lstrcpy(cmdLine, commandLine);
53  	TCHAR* cmdLinePtr = cmdLine;
54  	bool isInFile = false;
55  	bool isStringInArg = false;
56  	bool isInWhiteSpace = true;
57  	int zArg = 0; 
58  	bool shouldBeTerminated = false; 
59  	size_t commandLength = lstrlen(cmdLinePtr);
60  	std::vector<TCHAR *> args;
61  	for (size_t i = 0; i < commandLength && !shouldBeTerminated; ++i)
62  	{
63  		switch (cmdLinePtr[i])
64  		{
65  			case '\"': 
66  			{
67  				if (!isStringInArg && i > 0 && cmdLinePtr[i-1] == '=')
68  				{
69  					isStringInArg = true;
70  				}
71  				else if (isStringInArg)
72  				{
73  					isStringInArg = false;
74  				}
75  				else if (!isInFile)	
76  				{
77  					args.push_back(cmdLinePtr + i + 1);	
78  					isInFile = true;
79  					cmdLinePtr[i] = 0;
80  					if (zArg == 1)
81  					{
82  						++zArg; 
83  					}
84  				}
85  				else if (isInFile)
86  				{
87  					isInFile = false;
88  					cmdLinePtr[i] = 0;
89  				}
90  				isInWhiteSpace = false;
91  			}
92  			break;
93  			case '\t': 
94  			case ' ':
95  			{
96  				isInWhiteSpace = true;
97  				if (!isInFile && !isStringInArg)
98  				{
99  					cmdLinePtr[i] = 0;		
100  					size_t argsLen = args.size();
101  					if (argsLen > 0 && lstrcmp(args[argsLen-1], L"-z") == 0)
102  						++zArg; 
103  				}
104  			}
105  			break;
106  			default: 
107  			{
108  				if (!isInFile && !isStringInArg && isInWhiteSpace)
109  				{
110  					args.push_back(cmdLinePtr + i);	
111  					if (zArg == 2)
112  					{
113  						shouldBeTerminated = true; 
114  					}
115  					isInWhiteSpace = false;
116  				}
117  			}
118  		}
119  	}
120  	paramVector.assign(args.begin(), args.end());
121  	delete[] cmdLine;
122  }
123  void convertParamsToNotepadStyle(ParamVector& params)
124  {
125  	for (auto it = params.begin(); it != params.end(); ++it)
126  	{
127  		if (lstrcmp(it->c_str(), TEXT("/p")) == 0 || lstrcmp(it->c_str(), TEXT("/P")) == 0)
128  		{
129  			it->assign(TEXT("-quickPrint"));
130  		}
131  	}
132  }
133  bool isInList(const TCHAR *token2Find, ParamVector& params, bool eraseArg = true)
134  {
135  	for (auto it = params.begin(); it != params.end(); ++it)
136  	{
137  		if (lstrcmp(token2Find, it->c_str()) == 0)
138  		{
139  			if (eraseArg) params.erase(it);
140  			return true;
141  		}
142  	}
143  	return false;
144  }
145  bool getParamVal(TCHAR c, ParamVector & params, generic_string & value)
146  {
147  	value = TEXT("");
148  	size_t nbItems = params.size();
149  	for (size_t i = 0; i < nbItems; ++i)
150  	{
151  		const TCHAR * token = params.at(i).c_str();
152  		if (token[0] == '-' && lstrlen(token) >= 2 && token[1] == c) 
153  		{
154  			value = (token+2);
155  			params.erase(params.begin() + i);
156  			return true;
157  		}
158  	}
159  	return false;
160  }
161  bool getParamValFromString(const TCHAR *str, ParamVector & params, generic_string & value)
162  {
163  	value = TEXT("");
164  	size_t nbItems = params.size();
165  	for (size_t i = 0; i < nbItems; ++i)
166  	{
167  		const TCHAR * token = params.at(i).c_str();
168  		generic_string tokenStr = token;
169  		size_t pos = tokenStr.find(str);
170  		if (pos != generic_string::npos && pos == 0)
171  		{
172  			value = (token + lstrlen(str));
173  			params.erase(params.begin() + i);
174  			return true;
175  		}
176  	}
177  	return false;
178  }
179  LangType getLangTypeFromParam(ParamVector & params)
180  {
181  	generic_string langStr;
182  	if (!getParamVal('l', params, langStr))
183  		return L_EXTERNAL;
184  	return NppParameters::getLangIDFromStr(langStr.c_str());
185  }
186  generic_string getLocalizationPathFromParam(ParamVector & params)
187  {
188  	generic_string locStr;
189  	if (!getParamVal('L', params, locStr))
190  		return TEXT("");
191  	locStr = stringToLower(stringReplace(locStr, TEXT("_"), TEXT("-"))); 
192  	return NppParameters::getLocPathFromStr(locStr.c_str());
193  }
194  intptr_t getNumberFromParam(char paramName, ParamVector & params, bool & isParamePresent)
195  {
196  	generic_string numStr;
197  	if (!getParamVal(paramName, params, numStr))
198  	{
199  		isParamePresent = false;
200  		return -1;
201  	}
202  	isParamePresent = true;
203  	return static_cast<intptr_t>(_ttoi64(numStr.c_str()));
204  }
205  generic_string getEasterEggNameFromParam(ParamVector & params, unsigned char & type)
206  {
207  	generic_string EasterEggName;
208  	if (!getParamValFromString(TEXT("-qn="), params, EasterEggName))  
209  	{
210  		if (!getParamValFromString(TEXT("-qt="), params, EasterEggName)) 
211  		{
212  			if (!getParamValFromString(TEXT("-qf="), params, EasterEggName)) 
213  				return TEXT("");
214  			else
215  			{
216  				type = 2; 
217  			}
218  		}
219  		else
220  			type = 1; 
221  	}
222  	else
223  		type = 0; 
224  	if (EasterEggName.c_str()[0] == '"' && EasterEggName.c_str()[EasterEggName.length() - 1] == '"')
225  	{
226  		EasterEggName = EasterEggName.substr(1, EasterEggName.length() - 2);
227  	}
228  	if (type == 2)
229  		EasterEggName = relativeFilePathToFullFilePath(EasterEggName.c_str());
230  	return EasterEggName;
231  }
232  int getGhostTypingSpeedFromParam(ParamVector & params)
233  {
234  	generic_string speedStr;
235  	if (!getParamValFromString(TEXT("-qSpeed"), params, speedStr))
236  		return -1;
237  	int speed = std::stoi(speedStr, 0);
238  	if (speed <= 0 || speed > 3)
239  		return -1;
240  	return speed;
241  }
242  const TCHAR FLAG_MULTI_INSTANCE[] = TEXT("-multiInst");
243  const TCHAR FLAG_NO_PLUGIN[] = TEXT("-noPlugin");
244  const TCHAR FLAG_READONLY[] = TEXT("-ro");
245  const TCHAR FLAG_NOSESSION[] = TEXT("-nosession");
246  const TCHAR FLAG_NOTABBAR[] = TEXT("-notabbar");
247  const TCHAR FLAG_SYSTRAY[] = TEXT("-systemtray");
248  const TCHAR FLAG_LOADINGTIME[] = TEXT("-loadingTime");
249  const TCHAR FLAG_HELP[] = TEXT("--help");
250  const TCHAR FLAG_ALWAYS_ON_TOP[] = TEXT("-alwaysOnTop");
251  const TCHAR FLAG_OPENSESSIONFILE[] = TEXT("-openSession");
252  const TCHAR FLAG_RECURSIVE[] = TEXT("-r");
253  const TCHAR FLAG_FUNCLSTEXPORT[] = TEXT("-export=functionList");
254  const TCHAR FLAG_PRINTANDQUIT[] = TEXT("-quickPrint");
255  const TCHAR FLAG_NOTEPAD_COMPATIBILITY[] = TEXT("-notepadStyleCmdline");
256  const TCHAR FLAG_OPEN_FOLDERS_AS_WORKSPACE[] = TEXT("-openFoldersAsWorkspace");
257  const TCHAR FLAG_SETTINGS_DIR[] = TEXT("-settingsDir=");
258  const TCHAR FLAG_TITLEBAR_ADD[] = TEXT("-titleAdd=");
259  const TCHAR FLAG_APPLY_UDL[] = TEXT("-udl=");
260  const TCHAR FLAG_PLUGIN_MESSAGE[] = TEXT("-pluginMessage=");
261  const TCHAR FLAG_MONITOR_FILES[] = TEXT("-monitor");
262  void doException(Notepad_plus_Window & notepad_plus_plus)
263  {
264  	Win32Exception::removeHandler();	
265  	::MessageBox(Notepad_plus_Window::gNppHWND, TEXT("Notepad++ will attempt to save any unsaved data. However, dataloss is very likely."), TEXT("Recovery initiating"), MB_OK | MB_ICONINFORMATION);
266  	TCHAR tmpDir[1024];
267  	GetTempPath(1024, tmpDir);
268  	generic_string emergencySavedDir = tmpDir;
269  	emergencySavedDir += TEXT("\\Notepad++ RECOV");
270  	bool res = notepad_plus_plus.emergency(emergencySavedDir);
271  	if (res)
272  	{
273  		generic_string displayText = TEXT("Notepad++ was able to successfully recover some unsaved documents, or nothing to be saved could be found.\r\nYou can find the results at :\r\n");
274  		displayText += emergencySavedDir;
275  		::MessageBox(Notepad_plus_Window::gNppHWND, displayText.c_str(), TEXT("Recovery success"), MB_OK | MB_ICONINFORMATION);
276  	}
277  	else
278  		::MessageBox(Notepad_plus_Window::gNppHWND, TEXT("Unfortunatly, Notepad++ was not able to save your work. We are sorry for any lost data."), TEXT("Recovery failure"), MB_OK | MB_ICONERROR);
279  }
280  void stripIgnoredParams(ParamVector & params)
281  {
282  	for (auto it = params.begin(); it != params.end(); )
283  	{
284  		if (lstrcmp(it->c_str(), TEXT("-z")) == 0)
285  		{
286  			auto nextIt = std::next(it);
287  			if ( nextIt != params.end() )
288  			{
289  				params.erase(nextIt);
290  			}
291  			it = params.erase(it);
292  		}
293  		else
294  		{
295  			++it;
296  		}
297  	}
<span onclick='openModal()' class='match'>298  }
299  } 
300  int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE &bsol;*hPrevInstance*/, _In_ PWSTR pCmdLine, _In_ int &bsol;*nShowCmd*/)
301  {
302  	bool TheFirstOne = true;
</span>303  	::SetLastError(NO_ERROR);
304  	::CreateMutex(NULL, false, TEXT("nppInstance"));
305  	if (::GetLastError() == ERROR_ALREADY_EXISTS)
306  		TheFirstOne = false;
307  	generic_string cmdLineString = pCmdLine ? pCmdLine : _T("");
308  	ParamVector params;
309  	parseCommandLine(pCmdLine, params);
310  	stripIgnoredParams(params);
311  	if ( isInList(FLAG_NOTEPAD_COMPATIBILITY, params) )
312  	{
313  		convertParamsToNotepadStyle(params);
314  	}
315  	bool isParamePresent;
316  	bool showHelp = isInList(FLAG_HELP, params);
317  	bool isMultiInst = isInList(FLAG_MULTI_INSTANCE, params);
318  	bool doFunctionListExport = isInList(FLAG_FUNCLSTEXPORT, params);
319  	bool doPrintAndQuit = isInList(FLAG_PRINTANDQUIT, params);
320  	CmdLineParams cmdLineParams;
321  	cmdLineParams._isNoTab = isInList(FLAG_NOTABBAR, params);
322  	cmdLineParams._isNoPlugin = isInList(FLAG_NO_PLUGIN, params);
323  	cmdLineParams._isReadOnly = isInList(FLAG_READONLY, params);
324  	cmdLineParams._isNoSession = isInList(FLAG_NOSESSION, params);
325  	cmdLineParams._isPreLaunch = isInList(FLAG_SYSTRAY, params);
326  	cmdLineParams._alwaysOnTop = isInList(FLAG_ALWAYS_ON_TOP, params);
327  	cmdLineParams._showLoadingTime = isInList(FLAG_LOADINGTIME, params);
328  	cmdLineParams._isSessionFile = isInList(FLAG_OPENSESSIONFILE, params);
329  	cmdLineParams._isRecursive = isInList(FLAG_RECURSIVE, params);
330  	cmdLineParams._openFoldersAsWorkspace = isInList(FLAG_OPEN_FOLDERS_AS_WORKSPACE, params);
331  	cmdLineParams._monitorFiles = isInList(FLAG_MONITOR_FILES, params);
332  	cmdLineParams._langType = getLangTypeFromParam(params);
333  	cmdLineParams._localizationPath = getLocalizationPathFromParam(params);
334  	cmdLineParams._easterEggName = getEasterEggNameFromParam(params, cmdLineParams._quoteType);
335  	cmdLineParams._ghostTypingSpeed = getGhostTypingSpeedFromParam(params);
336  	generic_string pluginMessage;
337  	if (getParamValFromString(FLAG_PLUGIN_MESSAGE, params, pluginMessage))
338  	{
339  		if (pluginMessage.length() >= 2)
340  		{
341  			if (pluginMessage.front() == '"' && pluginMessage.back() == '"')
342  			{
343  				pluginMessage = pluginMessage.substr(1, pluginMessage.length() - 2);
344  			}
345  		}
346  		cmdLineParams._pluginMessage = pluginMessage;
347  	}
348  	cmdLineParams._line2go = getNumberFromParam('n', params, isParamePresent);
349      cmdLineParams._column2go = getNumberFromParam('c', params, isParamePresent);
350      cmdLineParams._pos2go = getNumberFromParam('p', params, isParamePresent);
351  	cmdLineParams._point.x = static_cast<LONG>(getNumberFromParam('x', params, cmdLineParams._isPointXValid));
352  	cmdLineParams._point.y = static_cast<LONG>(getNumberFromParam('y', params, cmdLineParams._isPointYValid));
353  	NppParameters& nppParameters = NppParameters::getInstance();
354  	nppParameters.setCmdLineString(cmdLineString);
355  	generic_string path;
356  	if (getParamValFromString(FLAG_SETTINGS_DIR, params, path))
357  	{
358  		if (path.c_str()[0] == '"' && path.c_str()[path.length() - 1] == '"')
359  		{
360  			path = path.substr(1, path.length() - 2);
361  		}
362  		nppParameters.setCmdSettingsDir(path);
363  	}
364  	generic_string titleBarAdditional;
365  	if (getParamValFromString(FLAG_TITLEBAR_ADD, params, titleBarAdditional))
366  	{
367  		if (titleBarAdditional.length() >= 2)
368  		{
369  			if (titleBarAdditional.front() == '"' && titleBarAdditional.back() == '"')
370  			{
371  				titleBarAdditional = titleBarAdditional.substr(1, titleBarAdditional.length() - 2);
372  			}
373  		}
374  		nppParameters.setTitleBarAdd(titleBarAdditional);
375  	}
376  	generic_string udlName;
377  	if (getParamValFromString(FLAG_APPLY_UDL, params, udlName))
378  	{
379  		if (udlName.length() >= 2)
380  		{
381  			if (udlName.front() == '"' && udlName.back() == '"')
382  			{
383  				udlName = udlName.substr(1, udlName.length() - 2);
384  			}
385  		}
386  		cmdLineParams._udlName = udlName;
387  	}
388  	if (showHelp)
389  		::MessageBox(NULL, COMMAND_ARG_HELP, TEXT("Notepad++ Command Argument Help"), MB_OK);
390  	if (cmdLineParams._localizationPath != TEXT(""))
391  	{
392  		nppParameters.setStartWithLocFileName(cmdLineParams._localizationPath);
393  	}
394  	nppParameters.load();
395  	NppGUI & nppGui = nppParameters.getNppGUI();
396  	NppDarkMode::initDarkMode();
397  	bool doUpdateNpp = nppGui._autoUpdateOpt._doAutoUpdate;
398  	bool doUpdatePluginList = nppGui._autoUpdateOpt._doAutoUpdate;
399  	if (doFunctionListExport || doPrintAndQuit) 
400  	{
401  		isMultiInst = true;
402  		doUpdateNpp = doUpdatePluginList = false;
403  		cmdLineParams._isNoSession = true;
404  	}
405  	nppParameters.setFunctionListExportBoolean(doFunctionListExport);
406  	nppParameters.setPrintAndExitBoolean(doPrintAndQuit);
407  	if (nppParameters.asNotepadStyle())
408  	{
409  		isMultiInst = true;
410  		cmdLineParams._isNoTab = true;
411  		cmdLineParams._isNoSession = true;
412  	}
413  	const NppGUI & nppGUI = nppParameters.getNppGUI();
414  	if (nppGUI._multiInstSetting == multiInst)
415  	{
416  		isMultiInst = true;
417  		if (!TheFirstOne)
418  			cmdLineParams._isNoSession = true;
419  	}
420  	generic_string quotFileName = TEXT("");
421  	size_t nbFilesToOpen = params.size();
422  	for (size_t i = 0; i < nbFilesToOpen; ++i)
423  	{
424  		const TCHAR * currentFile = params.at(i).c_str();
425  		if (currentFile[0])
426  		{
427  			quotFileName += TEXT("\"");
428  			quotFileName += relativeFilePathToFullFilePath(currentFile);
429  			quotFileName += TEXT("\" ");
430  		}
431  	}
432  	::SetCurrentDirectory(NppParameters::getInstance().getNppPath().c_str());	
433  	if ((!isMultiInst) && (!TheFirstOne))
434  	{
435  		HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
436  		for (int i = 0 ;!hNotepad_plus && i < 5 ; ++i)
437  		{
438  			Sleep(100);
439  			hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
440  		}
441          if (hNotepad_plus)
442          {
443  			nppParameters.destroyInstance();
444  			bool isInSystemTray = ::SendMessage(hNotepad_plus, NPPM_INTERNAL_RESTOREFROMTRAY, 0, 0);
445  			if (!isInSystemTray)
446  			{
447  				int sw = 0;
448  				if (::IsZoomed(hNotepad_plus))
449  					sw = SW_MAXIMIZE;
450  				else if (::IsIconic(hNotepad_plus))
451  					sw = SW_RESTORE;
452  				if (sw != 0)
453  					::ShowWindow(hNotepad_plus, sw);
454  			}
455  			::SetForegroundWindow(hNotepad_plus);
456  			if (params.size() > 0)	
457  			{
458  				CmdLineParamsDTO dto = CmdLineParamsDTO::FromCmdLineParams(cmdLineParams);
459  				COPYDATASTRUCT paramData{};
460  				paramData.dwData = COPYDATA_PARAMS;
461  				paramData.lpData = &dto;
462  				paramData.cbData = sizeof(dto);
463  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&paramData));
464  				COPYDATASTRUCT cmdLineData{};
465  				cmdLineData.dwData = COPYDATA_FULL_CMDLINE;
466  				cmdLineData.lpData = (void*)cmdLineString.c_str();
467  				cmdLineData.cbData = static_cast<DWORD>((cmdLineString.length() + 1) * sizeof(TCHAR));
468  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&cmdLineData));
469  				COPYDATASTRUCT fileNamesData{};
470  				fileNamesData.dwData = COPYDATA_FILENAMESW;
471  				fileNamesData.lpData = (void *)quotFileName.c_str();
472  				fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
473  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&fileNamesData));
474  			}
475  			return 0;
476          }
477  	}
478  	auto upNotepadWindow = std::make_unique<Notepad_plus_Window>();
479  	Notepad_plus_Window & notepad_plus_plus = *upNotepadWindow.get();
480  	generic_string updaterDir = nppParameters.getNppPath();
481  	updaterDir += TEXT("\\updater\\");
482  	generic_string updaterFullPath = updaterDir + TEXT("gup.exe");
483  	generic_string updaterParams = TEXT("-v");
484  	updaterParams += VERSION_VALUE;
485  	bool isUpExist = nppGui._doesExistUpdater = (::PathFileExists(updaterFullPath.c_str()) == TRUE);
486      if (doUpdateNpp) 
487      {
488          Date today(0);
489          if (today < nppGui._autoUpdateOpt._nextUpdateDate)
490              doUpdateNpp = false;
491      }
492  	if (doUpdatePluginList)
493  	{
494  	}
495  	winVer ver = nppParameters.getWinVersion();
496  	bool isGtXP = ver > WV_XP;
497  	SecurityGuard securityGuard;
498  	bool isSignatureOK = securityGuard.checkModule(updaterFullPath, nm_gup);
499  	if (TheFirstOne && isUpExist && isGtXP && isSignatureOK)
500  	{
501  		if (nppParameters.archType() == IMAGE_FILE_MACHINE_AMD64)
502  		{
503  			updaterParams += TEXT(" -px64");
504  		}
505  		else if (nppParameters.archType() == IMAGE_FILE_MACHINE_ARM64)
506  		{
507  			updaterParams += TEXT(" -parm64");
508  		}
509  		if (doUpdateNpp)
510  		{
511  			Process updater(updaterFullPath.c_str(), updaterParams.c_str(), updaterDir.c_str());
512  			updater.run();
513  			if (nppGui._autoUpdateOpt._intervalDays < 0) 
514  				nppGui._autoUpdateOpt._intervalDays = 0 - nppGui._autoUpdateOpt._intervalDays;
515  			nppGui._autoUpdateOpt._nextUpdateDate = Date(nppGui._autoUpdateOpt._intervalDays);
516  		}
517  		doUpdatePluginList = false;
518  		if (doUpdatePluginList)
519  		{
520  			generic_string upPlParams = TEXT("-v"); 
521  			upPlParams += notepad_plus_plus.getPluginListVerStr();
522  			if (nppParameters.archType() == IMAGE_FILE_MACHINE_AMD64)
523  			{
524  				upPlParams += TEXT(" -px64");
525  			}
526  			else if (nppParameters.archType() == IMAGE_FILE_MACHINE_ARM64)
527  			{
528  				upPlParams += TEXT(" -parm64");
529  			}
530  			upPlParams += TEXT(" -upZip");
531  			upPlParams += TEXT(" https:&bsol;&bsol;notepad-plus-plus.org/update/pluginListDownloadUrl.php");
532  			upPlParams += nppParameters.getPluginConfDir();
533  			Process updater(updaterFullPath.c_str(), upPlParams.c_str(), updaterDir.c_str());
534  			updater.run();
535  		}
536  	}
537  	MSG msg{};
538  	msg.wParam = 0;
539  	Win32Exception::installHandler();
540  	MiniDumper mdump;	
541  	try
542  	{
543  		notepad_plus_plus.init(hInstance, NULL, quotFileName.c_str(), &cmdLineParams);
544  		allowPrivilegeMessages(notepad_plus_plus, ver);
545  		bool going = true;
546  		while (going)
547  		{
548  			going = ::GetMessageW(&msg, NULL, 0, 0) != 0;
549  			if (going)
550  			{
551  				if (!notepad_plus_plus.isDlgsMsg(&msg))
552  				{
553  					if (::TranslateAccelerator(notepad_plus_plus.getHSelf(), notepad_plus_plus.getAccTable(), &msg) == 0)
554  					{
555  						::TranslateMessage(&msg);
556  						::DispatchMessageW(&msg);
557  					}
558  				}
559  			}
560  		}
561  	}
562  	catch (int i)
563  	{
564  		TCHAR str[50] = TEXT("God Damned Exception : ");
565  		TCHAR code[10];
566  		wsprintf(code, TEXT("%d"), i);
567  		wcscat_s(str, code);
568  		::MessageBox(Notepad_plus_Window::gNppHWND, str, TEXT("Int Exception"), MB_OK);
569  		doException(notepad_plus_plus);
570  	}
571  	catch (std::runtime_error & ex)
572  	{
573  		::MessageBoxA(Notepad_plus_Window::gNppHWND, ex.what(), "Runtime Exception", MB_OK);
574  		doException(notepad_plus_plus);
575  	}
576  	catch (const Win32Exception & ex)
577  	{
578  		TCHAR message[1024];	
579  		wsprintf(message, TEXT("An exception occured. Notepad++ cannot recover and must be shut down.\r\nThe exception details are as follows:\r\n")
580  			TEXT("Code:\t0x%08X\r\nType:\t%S\r\nException address: 0x%p"), ex.code(), ex.what(), ex.where());
581  		::MessageBox(Notepad_plus_Window::gNppHWND, message, TEXT("Win32Exception"), MB_OK | MB_ICONERROR);
582  		mdump.writeDump(ex.info());
583  		doException(notepad_plus_plus);
584  	}
585  	catch (std::exception & ex)
586  	{
587  		::MessageBoxA(Notepad_plus_Window::gNppHWND, ex.what(), "General Exception", MB_OK);
588  		doException(notepad_plus_plus);
589  	}
590  	catch (...) 
591  	{
592  		::MessageBoxA(Notepad_plus_Window::gNppHWND, "An exception that we did not yet found its name is just caught", "Unknown Exception", MB_OK);
593  		doException(notepad_plus_plus);
594  	}
595  	return static_cast<int>(msg.wParam);
596  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_profile.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_PROFILE_H_
2  #define ABSL_TYPES_INTERNAL_CONFORMANCE_PROFILE_H_
3  #include <set>
4  #include <type_traits>
5  #include <utility>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/algorithm/container.h"
9  #include "absl/meta/type_traits.h"
10  #include "absl/strings/ascii.h"
11  #include "absl/strings/str_cat.h"
12  #include "absl/strings/string_view.h"
13  #include "absl/types/internal/conformance_testing_helpers.h"
14  #include "absl/utility/utility.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace types_internal {
18  template <typename Enum>
19  constexpr absl::underlying_type_t<Enum> UnderlyingValue(Enum value) {
20    return static_cast<absl::underlying_type_t<Enum>>(value);
21  }
22  struct NoError {};
23  class ConformanceErrors {
24   public:
25    explicit ConformanceErrors(std::string type_name)
26        : assertion_result_(false), type_name_(std::move(type_name)) {
27      assertion_result_ << "\n\n"
28                           "Assuming the following type alias:\n"
29                           "\n"
30                           "  using _T = "
31                        << type_name_ << ";\n\n";
32      outputDivider();
33    }
34    void addTestSuccess(absl::string_view test_name) {
35      auto normalized_test_name = absl::AsciiStrToLower(test_name);
36      if (test_failures_.find(normalized_test_name) == test_failures_.end()) {
37        test_successes_.insert(std::move(normalized_test_name));
38      }
39    }
40    template <class... P>
41    void addTestFailure(absl::string_view test_name, const P&... args) {
42      assertion_result_ << "\n\n"
43                           "Failed test: "
44                        << test_name << "\n\n";
45      addTestFailureImpl(args...);
46      assertion_result_ << "\n\n";
47      outputDivider();
48      auto normalized_test_name = absl::AsciiStrToLower(test_name);
49      test_successes_.erase(normalized_test_name);
50      test_failures_.insert(std::move(normalized_test_name));
51      has_error_ = true;
52    }
53    ::testing::AssertionResult assertionResult() const {
54      return has_error_ ? assertion_result_ : ::testing::AssertionSuccess();
55    }
56    ::testing::AssertionResult expectFailedTests(
57        const std::set<std::string>& test_names) const {
58      if (!has_error_) {
59        return ::testing::AssertionFailure()
60               << "Unexpected conformance of type:\n"
61                  "    "
62               << type_name_ << "\n\n";
63      }
64      std::vector<std::string> nonfailing_tests;
65      absl::c_set_difference(test_names, test_failures_,
66                             std::back_inserter(nonfailing_tests));
67      std::vector<std::string> unrun_tests;
68      absl::c_set_difference(nonfailing_tests, test_successes_,
69                             std::back_inserter(unrun_tests));
70      if (!unrun_tests.empty()) {
71        const bool tests_were_run =
72            !(test_failures_.empty() && test_successes_.empty());
73        ::testing::AssertionResult result = ::testing::AssertionFailure();
74        result << "When testing type:\n    " << type_name_
75               << "\n\nThe following tests were expected to fail but were not "
76                  "run";
77        if (tests_were_run) result << " (was the test name spelled correctly?)";
78        result << ":\n\n";
79        for (const auto& test_name : unrun_tests) {
80          result << "    " << test_name << "\n";
81        }
82        if (!tests_were_run) result << "\nNo tests were run.";
83        if (!test_failures_.empty()) {
84          result << "\nThe tests that were run and failed are:\n\n";
85          for (const auto& test_name : test_failures_) {
86            result << "    " << test_name << "\n";
87          }
88        }
89        if (!test_successes_.empty()) {
90          result << "\nThe tests that were run and succeeded are:\n\n";
91          for (const auto& test_name : test_successes_) {
92            result << "    " << test_name << "\n";
93          }
94        }
95        return result;
96      }
97      if (nonfailing_tests.empty()) return ::testing::AssertionSuccess();
98      ::testing::AssertionResult unexpected_successes =
99          ::testing::AssertionFailure();
100      unexpected_successes << "When testing type:\n    " << type_name_
101                           << "\n\nThe following tests passed when they were "
102                              "expected to fail:\n\n";
103      for (const auto& test_name : nonfailing_tests) {
104        unexpected_successes << "    " << test_name << "\n";
105      }
106      return unexpected_successes;
107    }
108   private:
109    void outputDivider() {
110      assertion_result_ << "========================================";
111    }
112    void addTestFailureImpl() {}
113    template <class H, class... T>
114    void addTestFailureImpl(const H& head, const T&... tail) {
115      assertion_result_ << head;
116      addTestFailureImpl(tail...);
<span onclick='openModal()' class='match'>117    }
118    ::testing::AssertionResult assertion_result_;
119    std::set<std::string> test_failures_;
120    std::set<std::string> test_successes_;
121    std::string type_name_;
122    bool has_error_ = false;
</span>123  };
124  template <class T, class &bsol;*Enabler*/ = void>
125  struct PropertiesOfImpl {};
126  template <class T>
127  struct PropertiesOfImpl<T, absl::void_t<typename T::properties>> {
128    using type = typename T::properties;
129  };
130  template <class T>
131  struct PropertiesOfImpl<T, absl::void_t<typename T::profile_alias_of>> {
132    using type = typename PropertiesOfImpl<typename T::profile_alias_of>::type;
133  };
134  template <class T>
135  struct PropertiesOf : PropertiesOfImpl<T> {};
136  template <class T>
137  using PropertiesOfT = typename PropertiesOf<T>::type;
138  enum class function_support { maybe, yes, nothrow, trivial };
139  constexpr const char* PessimisticPropertyDescription(function_support v) {
140    return v == function_support::maybe
141               ? "no"
142               : v == function_support::yes
143                     ? "yes, potentially throwing"
144                     : v == function_support::nothrow ? "yes, nothrow"
145                                                      : "yes, trivial";
146  }
147  inline std::string ExpectedFunctionKindList(function_support min,
148                                              function_support max) {
149    if (min == max) {
150      std::string result =
151          absl::StrCat("Expected:\n  ",
152                       PessimisticPropertyDescription(
153                           static_cast<function_support>(UnderlyingValue(min))),
154                       "\n");
155      return result;
156    }
157    std::string result = "Expected one of:\n";
158    for (auto curr_support = UnderlyingValue(min);
159         curr_support <= UnderlyingValue(max); ++curr_support) {
160      absl::StrAppend(&result, "  ",
161                      PessimisticPropertyDescription(
162                          static_cast<function_support>(curr_support)),
163                      "\n");
164    }
165    return result;
166  }
167  template <class Enum>
168  void ExpectModelOfImpl(ConformanceErrors* errors, Enum min_support,
169                         Enum max_support, Enum kind) {
170    const auto kind_value = UnderlyingValue(kind);
171    const auto min_support_value = UnderlyingValue(min_support);
172    const auto max_support_value = UnderlyingValue(max_support);
173    if (!(kind_value >= min_support_value && kind_value <= max_support_value)) {
174      errors->addTestFailure(
175          PropertyName(kind), "**Failed property expectation**\n\n",
176          ExpectedFunctionKindList(
177              static_cast<function_support>(min_support_value),
178              static_cast<function_support>(max_support_value)),
179          '\n', "Actual:\n  ",
180          PessimisticPropertyDescription(
181              static_cast<function_support>(kind_value)));
182    } else {
183      errors->addTestSuccess(PropertyName(kind));
184    }
185  }
186  #define ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(description, name) \
187    enum class name { maybe, yes, nothrow, trivial };                   \
188                                                                        \
189    constexpr const char* PropertyName(name v) { return description; }  \
190    static_assert(true, "")  
191  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for default construction",
192                                             default_constructible);
193  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for move construction",
194                                             move_constructible);
195  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for copy construction",
196                                             copy_constructible);
197  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for move assignment",
198                                             move_assignable);
199  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for copy assignment",
200                                             copy_assignable);
201  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for destruction",
202                                             destructible);
203  #undef ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM
204  #define ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(description, name)     \
205    enum class name { maybe, yes, nothrow };                           \
206                                                                       \
207    constexpr const char* PropertyName(name v) { return description; } \
208    static_assert(true, "")  
209  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for ==", equality_comparable);
210  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for !=", inequality_comparable);
211  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for <", less_than_comparable);
212  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for <=", less_equal_comparable);
213  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for >=",
214                                        greater_equal_comparable);
215  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for >", greater_than_comparable);
216  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for swap", swappable);
217  #undef ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM
218  enum class hashable { maybe, yes };
219  constexpr const char* PropertyName(hashable v) {
220    return "support for std::hash";
221  }
222  template <class T>
223  using AlwaysFalse = std::false_type;
224  #define ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(name, property)   \
225    template <class T>                                                        \
226    constexpr property property##_support_of() {                              \
227      return std::is_##property<T>::value                                     \
228                 ? std::is_nothrow_##property<T>::value                       \
229                       ? absl::is_trivially_##property<T>::value              \
230                             ? property::trivial                              \
231                             : property::nothrow                              \
232                       : property::yes                                        \
233                 : property::maybe;                                           \
234    }                                                                         \
235                                                                              \
236    template <class T, class MinProf, class MaxProf>                          \
237    void ExpectModelOf##name(ConformanceErrors* errors) {                     \
238      (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::property##_support, \
239                          PropertiesOfT<MaxProf>::property##_support,         \
240                          property##_support_of<T>());                        \
241    }
242  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(DefaultConstructible,
243                                                    default_constructible);
244  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(MoveConstructible,
245                                                    move_constructible);
246  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(CopyConstructible,
247                                                    copy_constructible);
248  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(MoveAssignable,
249                                                    move_assignable);
250  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(CopyAssignable,
251                                                    copy_assignable);
252  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(Destructible, destructible);
253  #undef ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER
254  void BoolFunction(bool) noexcept;
255  template <class T, template <class...> class Op, class = void>
256  struct IsOpableImpl : std::false_type {};
257  template <class T, template <class...> class Op>
258  struct IsOpableImpl<T, Op, absl::void_t<Op<T>>> : std::true_type {};
259  template <template <class...> class Op>
260  struct IsOpable {
261    template <class T>
262    using apply = typename IsOpableImpl<T, Op>::type;
263  };
264  template <class T, template <class...> class Op, class = void>
265  struct IsNothrowOpableImpl : std::false_type {};
266  template <class T, template <class...> class Op>
267  struct IsNothrowOpableImpl<T, Op, absl::enable_if_t<Op<T>::value>>
268      : std::true_type {};
269  template <template <class...> class Op>
270  struct IsNothrowOpable {
271    template <class T>
272    using apply = typename IsNothrowOpableImpl<T, Op>::type;
273  };
274  #define ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(name, property, op)      \
275    template <class T,                                                           \
276              class Result = std::integral_constant<                             \
277                  bool, noexcept((BoolFunction)(std::declval<const T&>() op      \
278                                                    std::declval<const T&>()))>> \
279    using name = Result;                                                         \
280                                                                                 \
281    template <class T>                                                           \
282    constexpr property property##_support_of() {                                 \
283      return IsOpable<name>::apply<T>::value                                     \
284                 ? IsNothrowOpable<name>::apply<T>::value ? property::nothrow    \
285                                                          : property::yes        \
286                 : property::maybe;                                              \
287    }                                                                            \
288                                                                                 \
289    template <class T, class MinProf, class MaxProf>                             \
290    void ExpectModelOf##name(ConformanceErrors* errors) {                        \
291      (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::property##_support,    \
292                          PropertiesOfT<MaxProf>::property##_support,            \
293                          property##_support_of<T>());                           \
294    }
295  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(EqualityComparable,
296                                                equality_comparable, ==);
297  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(InequalityComparable,
298                                                inequality_comparable, !=);
299  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(LessThanComparable,
300                                                less_than_comparable, <);
301  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(LessEqualComparable,
302                                                less_equal_comparable, <=);
303  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(GreaterEqualComparable,
304                                                greater_equal_comparable, >=);
305  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(GreaterThanComparable,
306                                                greater_than_comparable, >);
307  #undef ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON
308  template <class T>
309  constexpr swappable swappable_support_of() {
310    return type_traits_internal::IsSwappable<T>::value
311               ? type_traits_internal::IsNothrowSwappable<T>::value
312                     ? swappable::nothrow
313                     : swappable::yes
314               : swappable::maybe;
315  }
316  template <class T, class MinProf, class MaxProf>
317  void ExpectModelOfSwappable(ConformanceErrors* errors) {
318    (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::swappable_support,
319                        PropertiesOfT<MaxProf>::swappable_support,
320                        swappable_support_of<T>());
321  }
322  template <class T>
323  constexpr hashable hashable_support_of() {
324    return type_traits_internal::IsHashable<T>::value ? hashable::yes
325                                                      : hashable::maybe;
326  }
327  template <class T, class MinProf, class MaxProf>
328  void ExpectModelOfHashable(ConformanceErrors* errors) {
329    (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::hashable_support,
330                        PropertiesOfT<MaxProf>::hashable_support,
331                        hashable_support_of<T>());
332  }
333  template <
334      default_constructible DefaultConstructibleValue =
335          default_constructible::maybe,
336      move_constructible MoveConstructibleValue = move_constructible::maybe,
337      copy_constructible CopyConstructibleValue = copy_constructible::maybe,
338      move_assignable MoveAssignableValue = move_assignable::maybe,
339      copy_assignable CopyAssignableValue = copy_assignable::maybe,
340      destructible DestructibleValue = destructible::maybe,
341      equality_comparable EqualityComparableValue = equality_comparable::maybe,
342      inequality_comparable InequalityComparableValue =
343          inequality_comparable::maybe,
344      less_than_comparable LessThanComparableValue = less_than_comparable::maybe,
345      less_equal_comparable LessEqualComparableValue =
346          less_equal_comparable::maybe,
347      greater_equal_comparable GreaterEqualComparableValue =
348          greater_equal_comparable::maybe,
349      greater_than_comparable GreaterThanComparableValue =
350          greater_than_comparable::maybe,
351      swappable SwappableValue = swappable::maybe,
352      hashable HashableValue = hashable::maybe>
353  struct ConformanceProfile {
354    using properties = ConformanceProfile;
355    static constexpr default_constructible
356        default_constructible_support =  
357        DefaultConstructibleValue;
358    static constexpr move_constructible move_constructible_support =  
359        MoveConstructibleValue;
360    static constexpr copy_constructible copy_constructible_support =  
361        CopyConstructibleValue;
362    static constexpr move_assignable move_assignable_support =  
363        MoveAssignableValue;
364    static constexpr copy_assignable copy_assignable_support =  
365        CopyAssignableValue;
366    static constexpr destructible destructible_support =  
367        DestructibleValue;
368    static constexpr equality_comparable equality_comparable_support =  
369        EqualityComparableValue;
370    static constexpr inequality_comparable
371        inequality_comparable_support =  
372        InequalityComparableValue;
373    static constexpr less_than_comparable
374        less_than_comparable_support =  
375        LessThanComparableValue;
376    static constexpr less_equal_comparable
377        less_equal_comparable_support =  
378        LessEqualComparableValue;
379    static constexpr greater_equal_comparable
380        greater_equal_comparable_support =  
381        GreaterEqualComparableValue;
382    static constexpr greater_than_comparable
383        greater_than_comparable_support =  
384        GreaterThanComparableValue;
385    static constexpr swappable swappable_support = SwappableValue;  
386    static constexpr hashable hashable_support = HashableValue;  
387    static constexpr bool is_default_constructible =  
388        DefaultConstructibleValue != default_constructible::maybe;
389    static constexpr bool is_move_constructible =  
390        MoveConstructibleValue != move_constructible::maybe;
391    static constexpr bool is_copy_constructible =  
392        CopyConstructibleValue != copy_constructible::maybe;
393    static constexpr bool is_move_assignable =  
394        MoveAssignableValue != move_assignable::maybe;
395    static constexpr bool is_copy_assignable =  
396        CopyAssignableValue != copy_assignable::maybe;
397    static constexpr bool is_destructible =  
398        DestructibleValue != destructible::maybe;
399    static constexpr bool is_equality_comparable =  
400        EqualityComparableValue != equality_comparable::maybe;
401    static constexpr bool is_inequality_comparable =  
402        InequalityComparableValue != inequality_comparable::maybe;
403    static constexpr bool is_less_than_comparable =  
404        LessThanComparableValue != less_than_comparable::maybe;
405    static constexpr bool is_less_equal_comparable =  
406        LessEqualComparableValue != less_equal_comparable::maybe;
407    static constexpr bool is_greater_equal_comparable =  
408        GreaterEqualComparableValue != greater_equal_comparable::maybe;
409    static constexpr bool is_greater_than_comparable =  
410        GreaterThanComparableValue != greater_than_comparable::maybe;
411    static constexpr bool is_swappable =  
412        SwappableValue != swappable::maybe;
413    static constexpr bool is_hashable =  
414        HashableValue != hashable::maybe;
415  };
416  enum class CheckHashability { no, yes };
417  template <class T, CheckHashability ShouldCheckHashability>
418  struct conservative_hashable_support_of;
419  template <class T>
420  struct conservative_hashable_support_of<T, CheckHashability::no> {
421    static constexpr hashable Invoke() { return hashable::maybe; }
422  };
423  template <class T>
424  struct conservative_hashable_support_of<T, CheckHashability::yes> {
425    static constexpr hashable Invoke() { return hashable_support_of<T>(); }
426  };
427  template <class T, CheckHashability ShouldCheckHashability>
428  struct SyntacticConformanceProfileOf {
429    using properties = ConformanceProfile<
430        default_constructible_support_of<T>(), move_constructible_support_of<T>(),
431        copy_constructible_support_of<T>(), move_assignable_support_of<T>(),
432        copy_assignable_support_of<T>(), destructible_support_of<T>(),
433        equality_comparable_support_of<T>(),
434        inequality_comparable_support_of<T>(),
435        less_than_comparable_support_of<T>(),
436        less_equal_comparable_support_of<T>(),
437        greater_equal_comparable_support_of<T>(),
438        greater_than_comparable_support_of<T>(), swappable_support_of<T>(),
439        conservative_hashable_support_of<T, ShouldCheckHashability>::Invoke()>;
440  };
441  #define ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(type, name)     \
442    template <default_constructible DefaultConstructibleValue,                   \
443              move_constructible MoveConstructibleValue,                         \
444              copy_constructible CopyConstructibleValue,                         \
445              move_assignable MoveAssignableValue,                               \
446              copy_assignable CopyAssignableValue,                               \
447              destructible DestructibleValue,                                    \
448              equality_comparable EqualityComparableValue,                       \
449              inequality_comparable InequalityComparableValue,                   \
450              less_than_comparable LessThanComparableValue,                      \
451              less_equal_comparable LessEqualComparableValue,                    \
452              greater_equal_comparable GreaterEqualComparableValue,              \
453              greater_than_comparable GreaterThanComparableValue,                \
454              swappable SwappableValue, hashable HashableValue>                  \
455    constexpr type ConformanceProfile<                                           \
456        DefaultConstructibleValue, MoveConstructibleValue,                       \
457        CopyConstructibleValue, MoveAssignableValue, CopyAssignableValue,        \
458        DestructibleValue, EqualityComparableValue, InequalityComparableValue,   \
459        LessThanComparableValue, LessEqualComparableValue,                       \
460        GreaterEqualComparableValue, GreaterThanComparableValue, SwappableValue, \
461        HashableValue>::name
462  #define ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(type)           \
463    ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(type,            \
464                                                           type##_support); \
465    ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(bool, is_##type)
466  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
467  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(default_constructible);
468  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(move_constructible);
469  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(copy_constructible);
470  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(move_assignable);
471  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(copy_assignable);
472  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(destructible);
473  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(equality_comparable);
474  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(inequality_comparable);
475  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(less_than_comparable);
476  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(less_equal_comparable);
477  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(greater_equal_comparable);
478  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(greater_than_comparable);
479  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(swappable);
480  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(hashable);
481  #endif
482  #undef ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF
483  #undef ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL
484  template <class H>
485  constexpr H MinEnum(H head) {
486    return head;
487  }
488  template <class H, class N, class... T>
489  constexpr H MinEnum(H head, N next, T... tail) {
490    return (UnderlyingValue)(head) < (UnderlyingValue)(next)
491               ? (MinEnum)(head, tail...)
492               : (MinEnum)(next, tail...);
493  }
494  template <class... Profs>
495  struct MinimalProfiles {
496    static constexpr default_constructible
497        default_constructible_support =  
498        (MinEnum)(PropertiesOfT<Profs>::default_constructible_support...);
499    static constexpr move_constructible move_constructible_support =  
500        (MinEnum)(PropertiesOfT<Profs>::move_constructible_support...);
501    static constexpr copy_constructible copy_constructible_support =  
502        (MinEnum)(PropertiesOfT<Profs>::copy_constructible_support...);
503    static constexpr move_assignable move_assignable_support =  
504        (MinEnum)(PropertiesOfT<Profs>::move_assignable_support...);
505    static constexpr copy_assignable copy_assignable_support =  
506        (MinEnum)(PropertiesOfT<Profs>::copy_assignable_support...);
507    static constexpr destructible destructible_support =  
508        (MinEnum)(PropertiesOfT<Profs>::destructible_support...);
509    static constexpr equality_comparable equality_comparable_support =  
510        (MinEnum)(PropertiesOfT<Profs>::equality_comparable_support...);
511    static constexpr inequality_comparable
512        inequality_comparable_support =  
513        (MinEnum)(PropertiesOfT<Profs>::inequality_comparable_support...);
514    static constexpr less_than_comparable
515        less_than_comparable_support =  
516        (MinEnum)(PropertiesOfT<Profs>::less_than_comparable_support...);
517    static constexpr less_equal_comparable
518        less_equal_comparable_support =  
519        (MinEnum)(PropertiesOfT<Profs>::less_equal_comparable_support...);
520    static constexpr greater_equal_comparable
521        greater_equal_comparable_support =  
522        (MinEnum)(PropertiesOfT<Profs>::greater_equal_comparable_support...);
523    static constexpr greater_than_comparable
524        greater_than_comparable_support =  
525        (MinEnum)(PropertiesOfT<Profs>::greater_than_comparable_support...);
526    static constexpr swappable swappable_support =  
527        (MinEnum)(PropertiesOfT<Profs>::swappable_support...);
528    static constexpr hashable hashable_support =  
529        (MinEnum)(PropertiesOfT<Profs>::hashable_support...);
530    using properties = ConformanceProfile<
531        default_constructible_support, move_constructible_support,
532        copy_constructible_support, move_assignable_support,
533        copy_assignable_support, destructible_support,
534        equality_comparable_support, inequality_comparable_support,
535        less_than_comparable_support, less_equal_comparable_support,
536        greater_equal_comparable_support, greater_than_comparable_support,
537        swappable_support, hashable_support>;
538  };
539  template <class H>
540  constexpr H MaxEnum(H head) {
541    return head;
542  }
543  template <class H, class N, class... T>
544  constexpr H MaxEnum(H head, N next, T... tail) {
545    return (UnderlyingValue)(next) < (UnderlyingValue)(head)
546               ? (MaxEnum)(head, tail...)
547               : (MaxEnum)(next, tail...);
548  }
549  template <class... Profs>
550  struct CombineProfilesImpl {
551    static constexpr default_constructible
552        default_constructible_support =  
553        (MaxEnum)(PropertiesOfT<Profs>::default_constructible_support...);
554    static constexpr move_constructible move_constructible_support =  
555        (MaxEnum)(PropertiesOfT<Profs>::move_constructible_support...);
556    static constexpr copy_constructible copy_constructible_support =  
557        (MaxEnum)(PropertiesOfT<Profs>::copy_constructible_support...);
558    static constexpr move_assignable move_assignable_support =  
559        (MaxEnum)(PropertiesOfT<Profs>::move_assignable_support...);
560    static constexpr copy_assignable copy_assignable_support =  
561        (MaxEnum)(PropertiesOfT<Profs>::copy_assignable_support...);
562    static constexpr destructible destructible_support =  
563        (MaxEnum)(PropertiesOfT<Profs>::destructible_support...);
564    static constexpr equality_comparable equality_comparable_support =  
565        (MaxEnum)(PropertiesOfT<Profs>::equality_comparable_support...);
566    static constexpr inequality_comparable
567        inequality_comparable_support =  
568        (MaxEnum)(PropertiesOfT<Profs>::inequality_comparable_support...);
569    static constexpr less_than_comparable
570        less_than_comparable_support =  
571        (MaxEnum)(PropertiesOfT<Profs>::less_than_comparable_support...);
572    static constexpr less_equal_comparable
573        less_equal_comparable_support =  
574        (MaxEnum)(PropertiesOfT<Profs>::less_equal_comparable_support...);
575    static constexpr greater_equal_comparable
576        greater_equal_comparable_support =  
577        (MaxEnum)(PropertiesOfT<Profs>::greater_equal_comparable_support...);
578    static constexpr greater_than_comparable
579        greater_than_comparable_support =  
580        (MaxEnum)(PropertiesOfT<Profs>::greater_than_comparable_support...);
581    static constexpr swappable swappable_support =  
582        (MaxEnum)(PropertiesOfT<Profs>::swappable_support...);
583    static constexpr hashable hashable_support =  
584        (MaxEnum)(PropertiesOfT<Profs>::hashable_support...);
585    using properties = ConformanceProfile<
586        default_constructible_support, move_constructible_support,
587        copy_constructible_support, move_assignable_support,
588        copy_assignable_support, destructible_support,
589        equality_comparable_support, inequality_comparable_support,
590        less_than_comparable_support, less_equal_comparable_support,
591        greater_equal_comparable_support, greater_than_comparable_support,
592        swappable_support, hashable_support>;
593  };
594  template <class... Profs>
595  struct CombineProfiles {
596    using profile_alias_of = CombineProfilesImpl<Profs...>;
597  };
598  template <>
599  struct CombineProfiles<> {
600    using properties = ConformanceProfile<>;
601  };
602  template <class Profile, class Tag>
603  struct StrongProfileTypedef {
604    using properties = PropertiesOfT<Profile>;
605  };
606  template <class T, class &bsol;*Enabler*/ = void>
607  struct IsProfileImpl : std::false_type {};
608  template <class T>
609  struct IsProfileImpl<T, absl::void_t<PropertiesOfT<T>>> : std::true_type {};
610  template <class T>
611  struct IsProfile : IsProfileImpl<T>::type {};
612  struct RegularityDomain {};
613  }  
614  ABSL_NAMESPACE_END
615  }  
616  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-winmain.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_profile.h</div>
                </div>
                <div class="column column_space"><pre><code>298  }
299  } 
300  int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE &bsol;*hPrevInstance*/, _In_ PWSTR pCmdLine, _In_ int &bsol;*nShowCmd*/)
301  {
302  	bool TheFirstOne = true;
</pre></code></div>
                <div class="column column_space"><pre><code>117    }
118    ::testing::AssertionResult assertion_result_;
119    std::set<std::string> test_failures_;
120    std::set<std::string> test_successes_;
121    std::string type_name_;
122    bool has_error_ = false;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    