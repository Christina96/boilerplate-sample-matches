
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 41.30434782608695%, Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-xbyak_util.h</h3>
            <pre><code>1  #ifndef XBYAK_XBYAK_UTIL_H_
2  #define XBYAK_XBYAK_UTIL_H_
3  #include "xbyak.h"
4  #ifdef _MSC_VER
5  	#if (_MSC_VER < 1400) && defined(XBYAK32)
6  		static inline __declspec(naked) void __cpuid(int[4], int)
7  		{
8  			__asm {
<span onclick='openModal()' class='match'>9  				push	ebx
10  				push	esi
11  				mov		eax, dword ptr [esp + 4 * 2 + 8] 
12  				cpuid
13  				mov		esi, dword ptr [esp + 4 * 2 + 4] 
14  				mov		dword ptr [esi], eax
15  				mov		dword ptr [esi + 4], ebx
16  				mov		dword ptr [esi + 8], ecx
17  				mov		dword ptr [esi + 12], edx
18  				pop		esi
19  				pop		ebx
</span>20  				ret
21  			}
22  		}
23  	#else
24  		#include <intrin.h> 
25  	#endif
26  #else
27  	#ifndef __GNUC_PREREQ
28      	#define __GNUC_PREREQ(major, minor) ((((__GNUC__) << 16) + (__GNUC_MINOR__)) >= (((major) << 16) + (minor)))
29  	#endif
30  	#if __GNUC_PREREQ(4, 3) && !defined(__APPLE__)
31  		#include <cpuid.h>
32  	#else
33  		#if defined(__APPLE__) && defined(XBYAK32) 
34  			#define __cpuid(eaxIn, a, b, c, d) __asm__ __volatile__("pushl %%ebx\ncpuid\nmovl %%ebp, %%esi\npopl %%ebx" : "=a"(a), "=S"(b), "=c"(c), "=d"(d) : "0"(eaxIn))
35  			#define __cpuid_count(eaxIn, ecxIn, a, b, c, d) __asm__ __volatile__("pushl %%ebx\ncpuid\nmovl %%ebp, %%esi\npopl %%ebx" : "=a"(a), "=S"(b), "=c"(c), "=d"(d) : "0"(eaxIn), "2"(ecxIn))
36  		#else
37  			#define __cpuid(eaxIn, a, b, c, d) __asm__ __volatile__("cpuid\n" : "=a"(a), "=b"(b), "=c"(c), "=d"(d) : "0"(eaxIn))
38  			#define __cpuid_count(eaxIn, ecxIn, a, b, c, d) __asm__ __volatile__("cpuid\n" : "=a"(a), "=b"(b), "=c"(c), "=d"(d) : "0"(eaxIn), "2"(ecxIn))
39  		#endif
40  	#endif
41  #endif
42  #ifdef _MSC_VER
43  extern "C" unsigned __int64 __xgetbv(int);
44  #endif
45  namespace Xbyak { namespace util {
46  class Cpu {
47  	uint64 type_;
48  	unsigned int get32bitAsBE(const char *x) const
49  	{
50  		return x[0] | (x[1] << 8) | (x[2] << 16) | (x[3] << 24);
51  	}
52  	unsigned int mask(int n) const
53  	{
54  		return (1U << n) - 1;
55  	}
56  	void setFamily()
57  	{
58  		unsigned int data[4];
59  		getCpuid(1, data);
60  		stepping = data[0] & mask(4);
61  		model = (data[0] >> 4) & mask(4);
62  		family = (data[0] >> 8) & mask(4);
63  		extModel = (data[0] >> 16) & mask(4);
64  		extFamily = (data[0] >> 20) & mask(8);
65  		if (family == 0x0f) {
66  			displayFamily = family + extFamily;
67  		} else {
68  			displayFamily = family;
69  		}
70  		if (family == 6 || family == 0x0f) {
71  			displayModel = (extModel << 4) + model;
72  		} else {
73  			displayModel = model;
74  		}
75  	}
76  public:
77  	int model;
78  	int family;
79  	int stepping;
80  	int extModel;
81  	int extFamily;
82  	int displayFamily; 
83  	int displayModel; 
84  	static inline void getCpuid(unsigned int eaxIn, unsigned int data[4])
85  	{
86  #ifdef _MSC_VER
87  		__cpuid(reinterpret_cast<int*>(data), eaxIn);
88  #else
89  		__cpuid(eaxIn, data[0], data[1], data[2], data[3]);
90  #endif
91  	}
92  	static inline void getCpuidEx(unsigned int eaxIn, unsigned int ecxIn, unsigned int data[4])
93  	{
94  #ifdef _MSC_VER
95  		__cpuidex(reinterpret_cast<int*>(data), eaxIn, ecxIn);
96  #else
97  		__cpuid_count(eaxIn, ecxIn, data[0], data[1], data[2], data[3]);
98  #endif
99  	}
100  	static inline uint64 getXfeature()
101  	{
102  #ifdef _MSC_VER
103  		return __xgetbv(0);
104  #else
105  		unsigned int eax, edx;
106  		__asm__ volatile(".byte 0x0f, 0x01, 0xd0" : "=a"(eax), "=d"(edx) : "c"(0));
107  		return ((uint64)edx << 32) | eax;
108  #endif
109  	}
110  	typedef uint64 Type;
111  	static const Type NONE = 0;
112  	static const Type tMMX = 1 << 0;
113  	static const Type tMMX2 = 1 << 1;
114  	static const Type tCMOV = 1 << 2;
115  	static const Type tSSE = 1 << 3;
116  	static const Type tSSE2 = 1 << 4;
117  	static const Type tSSE3 = 1 << 5;
118  	static const Type tSSSE3 = 1 << 6;
119  	static const Type tSSE41 = 1 << 7;
120  	static const Type tSSE42 = 1 << 8;
121  	static const Type tPOPCNT = 1 << 9;
122  	static const Type tAESNI = 1 << 10;
123  	static const Type tSSE5 = 1 << 11;
124  	static const Type tOSXSAVE = 1 << 12;
125  	static const Type tPCLMULQDQ = 1 << 13;
126  	static const Type tAVX = 1 << 14;
127  	static const Type tFMA = 1 << 15;
128  	static const Type t3DN = 1 << 16;
129  	static const Type tE3DN = 1 << 17;
130  	static const Type tSSE4a = 1 << 18;
131  	static const Type tRDTSCP = 1 << 19;
132  	static const Type tAVX2 = 1 << 20;
133  	static const Type tBMI1 = 1 << 21; 
134  	static const Type tBMI2 = 1 << 22; 
135  	static const Type tLZCNT = 1 << 23;
136  	static const Type tINTEL = 1 << 24;
137  	static const Type tAMD = 1 << 25;
138  	static const Type tENHANCED_REP = 1 << 26; 
139  	static const Type tRDRAND = 1 << 27;
140  	static const Type tADX = 1 << 28; 
141  	static const Type tRDSEED = 1 << 29; 
142  	static const Type tSMAP = 1 << 30; 
143  	static const Type tHLE = uint64(1) << 31; 
144  	static const Type tRTM = uint64(1) << 32; 
145  	static const Type tF16C = uint64(1) << 33; 
146  	static const Type tMOVBE = uint64(1) << 34; 
147  	Cpu()
148  		: type_(NONE)
149  	{
150  		unsigned int data[4];
151  		getCpuid(0, data);
152  		const unsigned int maxNum = data[0];
153  		static const char intel[] = "ntel";
154  		static const char amd[] = "cAMD";
155  		if (data[2] == get32bitAsBE(amd)) {
156  			type_ |= tAMD;
157  			getCpuid(0x80000001, data);
158  			if (data[3] & (1U << 31)) type_ |= t3DN;
159  			if (data[3] & (1U << 15)) type_ |= tCMOV;
160  			if (data[3] & (1U << 30)) type_ |= tE3DN;
161  			if (data[3] & (1U << 22)) type_ |= tMMX2;
162  			if (data[3] & (1U << 27)) type_ |= tRDTSCP;
163  		}
164  		if (data[2] == get32bitAsBE(intel)) {
165  			type_ |= tINTEL;
166  			getCpuid(0x80000001, data);
167  			if (data[3] & (1U << 27)) type_ |= tRDTSCP;
168  			if (data[2] & (1U << 5)) type_ |= tLZCNT;
169  		}
170  		getCpuid(1, data);
171  		if (data[2] & (1U << 0)) type_ |= tSSE3;
172  		if (data[2] & (1U << 9)) type_ |= tSSSE3;
173  		if (data[2] & (1U << 19)) type_ |= tSSE41;
174  		if (data[2] & (1U << 20)) type_ |= tSSE42;
175  		if (data[2] & (1U << 22)) type_ |= tMOVBE;
176  		if (data[2] & (1U << 23)) type_ |= tPOPCNT;
177  		if (data[2] & (1U << 25)) type_ |= tAESNI;
178  		if (data[2] & (1U << 1)) type_ |= tPCLMULQDQ;
179  		if (data[2] & (1U << 27)) type_ |= tOSXSAVE;
180  		if (data[2] & (1U << 30)) type_ |= tRDRAND;
181  		if (data[2] & (1U << 29)) type_ |= tF16C;
182  		if (data[3] & (1U << 15)) type_ |= tCMOV;
183  		if (data[3] & (1U << 23)) type_ |= tMMX;
184  		if (data[3] & (1U << 25)) type_ |= tMMX2 | tSSE;
185  		if (data[3] & (1U << 26)) type_ |= tSSE2;
186  		if (type_ & tOSXSAVE) {
187  			uint64 bv = getXfeature();
188  			if ((bv & 6) == 6) {
189  				if (data[2] & (1U << 28)) type_ |= tAVX;
190  				if (data[2] & (1U << 12)) type_ |= tFMA;
191  			}
192  		}
193  		if (maxNum >= 7) {
194  			getCpuidEx(7, 0, data);
195  			if (type_ & tAVX && data[1] & 0x20) type_ |= tAVX2;
196  			if (data[1] & (1U << 3)) type_ |= tBMI1;
197  			if (data[1] & (1U << 8)) type_ |= tBMI2;
198  			if (data[1] & (1U << 9)) type_ |= tENHANCED_REP;
199  			if (data[1] & (1U << 18)) type_ |= tRDSEED;
200  			if (data[1] & (1U << 19)) type_ |= tADX;
201  			if (data[1] & (1U << 20)) type_ |= tSMAP;
202  			if (data[1] & (1U << 4)) type_ |= tHLE;
203  			if (data[1] & (1U << 11)) type_ |= tRTM;
204  		}
205  		setFamily();
206  	}
207  	void putFamily()
208  	{
209  		printf("family=%d, model=%X, stepping=%d, extFamily=%d, extModel=%X\n",
210  			family, model, stepping, extFamily, extModel);
211  		printf("display:family=%X, model=%X\n", displayFamily, displayModel);
212  	}
213  	bool has(Type type) const
214  	{
215  		return (type & type_) != 0;
216  	}
217  };
218  class Clock {
219  public:
220  	static inline uint64 getRdtsc()
221  	{
222  #ifdef _MSC_VER
223  		return __rdtsc();
224  #else
225  		unsigned int eax, edx;
226  		__asm__ volatile("rdtsc" : "=a"(eax), "=d"(edx));
227  		return ((uint64)edx << 32) | eax;
228  #endif
229  	}
230  	Clock()
231  		: clock_(0)
232  		, count_(0)
233  	{
234  	}
235  	void begin()
236  	{
237  		clock_ -= getRdtsc();
238  	}
239  	void end()
240  	{
241  		clock_ += getRdtsc();
242  		count_++;
243  	}
244  	int getCount() const { return count_; }
245  	uint64 getClock() const { return clock_; }
246  	void clear() { count_ = 0; clock_ = 0; }
247  private:
248  	uint64 clock_;
249  	int count_;
250  };
251  #ifdef XBYAK64
252  const int UseRCX = 1 << 6;
253  const int UseRDX = 1 << 7;
254  class Pack {
255  	static const size_t maxTblNum = 10;
256  	const Xbyak::Reg64 *tbl_[maxTblNum];
257  	size_t n_;
258  public:
259  	Pack() : n_(0) {}
260  	Pack(const Xbyak::Reg64 *tbl, size_t n) { init(tbl, n); }
261  	Pack(const Pack& rhs)
262  		: n_(rhs.n_)
263  	{
264  		if (n_ > maxTblNum) throw Error(ERR_INTERNAL);
265  		for (size_t i = 0; i < n_; i++) tbl_[i] = rhs.tbl_[i];
266  	}
267  	Pack(const Xbyak::Reg64& t0)
268  	{ n_ = 1; tbl_[0] = &t0; }
269  	Pack(const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
270  	{ n_ = 2; tbl_[0] = &t0; tbl_[1] = &t1; }
271  	Pack(const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
272  	{ n_ = 3; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; }
273  	Pack(const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
274  	{ n_ = 4; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; }
275  	Pack(const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
276  	{ n_ = 5; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; }
277  	Pack(const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
278  	{ n_ = 6; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; }
279  	Pack(const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
280  	{ n_ = 7; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; }
281  	Pack(const Xbyak::Reg64& t7, const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
282  	{ n_ = 8; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; tbl_[7] = &t7; }
283  	Pack(const Xbyak::Reg64& t8, const Xbyak::Reg64& t7, const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
284  	{ n_ = 9; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; tbl_[7] = &t7; tbl_[8] = &t8; }
285  	Pack(const Xbyak::Reg64& t9, const Xbyak::Reg64& t8, const Xbyak::Reg64& t7, const Xbyak::Reg64& t6, const Xbyak::Reg64& t5, const Xbyak::Reg64& t4, const Xbyak::Reg64& t3, const Xbyak::Reg64& t2, const Xbyak::Reg64& t1, const Xbyak::Reg64& t0)
286  	{ n_ = 10; tbl_[0] = &t0; tbl_[1] = &t1; tbl_[2] = &t2; tbl_[3] = &t3; tbl_[4] = &t4; tbl_[5] = &t5; tbl_[6] = &t6; tbl_[7] = &t7; tbl_[8] = &t8; tbl_[9] = &t9; }
287  	Pack& append(const Xbyak::Reg64& t)
288  	{
289  		if (n_ == 10) {
290  			fprintf(stderr, "ERR Pack::can't append\n");
291  			throw Error(ERR_BAD_PARAMETER);
292  		}
293  		tbl_[n_++] = &t;
294  		return *this;
295  	}
296  	void init(const Xbyak::Reg64 *tbl, size_t n)
297  	{
298  		if (n > maxTblNum) {
299  			fprintf(stderr, "ERR Pack::init bad n=%d\n", (int)n);
300  			throw Error(ERR_BAD_PARAMETER);
301  		}
302  		n_ = n;
303  		for (size_t i = 0; i < n; i++) {
304  			tbl_[i] = &tbl[i];
305  		}
306  	}
307  	const Xbyak::Reg64& operator[](size_t n) const
308  	{
309  		if (n >= n_) {
310  			fprintf(stderr, "ERR Pack bad n=%d\n", (int)n);
311  			throw Error(ERR_BAD_PARAMETER);
312  		}
313  		return *tbl_[n];
314  	}
315  	size_t size() const { return n_; }
316  	Pack sub(size_t pos, size_t num = size_t(-1)) const
317  	{
318  		if (num == size_t(-1)) num = n_ - pos;
319  		if (pos + num > n_) {
320  			fprintf(stderr, "ERR Pack::sub bad pos=%d, num=%d\n", (int)pos, (int)num);
321  			throw Error(ERR_BAD_PARAMETER);
322  		}
323  		Pack pack;
324  		pack.n_ = num;
325  		for (size_t i = 0; i < num; i++) {
326  			pack.tbl_[i] = tbl_[pos + i];
327  		}
328  		return pack;
329  	}
330  	void put() const
331  	{
332  		for (size_t i = 0; i < n_; i++) {
333  			printf("%s ", tbl_[i]->toString());
334  		}
335  		printf("\n");
336  	}
337  };
338  class StackFrame {
339  #ifdef XBYAK64_WIN
340  	static const int noSaveNum = 6;
341  	static const int rcxPos = 0;
342  	static const int rdxPos = 1;
343  #else
344  	static const int noSaveNum = 8;
345  	static const int rcxPos = 3;
346  	static const int rdxPos = 2;
347  #endif
348  	Xbyak::CodeGenerator *code_;
349  	int pNum_;
350  	int tNum_;
351  	bool useRcx_;
352  	bool useRdx_;
353  	int saveNum_;
354  	int P_;
355  	bool makeEpilog_;
356  	Xbyak::Reg64 pTbl_[4];
357  	Xbyak::Reg64 tTbl_[10];
358  	Pack p_;
359  	Pack t_;
360  	StackFrame(const StackFrame&);
361  	void operator=(const StackFrame&);
362  public:
363  	const Pack& p;
364  	const Pack& t;
365  	StackFrame(Xbyak::CodeGenerator *code, int pNum, int tNum = 0, int stackSizeByte = 0, bool makeEpilog = true)
366  		: code_(code)
367  		, pNum_(pNum)
368  		, tNum_(tNum & ~(UseRCX | UseRDX))
369  		, useRcx_((tNum & UseRCX) != 0)
370  		, useRdx_((tNum & UseRDX) != 0)
371  		, saveNum_(0)
372  		, P_(0)
373  		, makeEpilog_(makeEpilog)
374  		, p(p_)
375  		, t(t_)
376  	{
377  		using namespace Xbyak;
378  		if (pNum < 0 || pNum > 4) throw Error(ERR_BAD_PNUM);
379  		const int allRegNum = pNum + tNum_ + (useRcx_ ? 1 : 0) + (useRdx_ ? 1 : 0);
380  		if (allRegNum < pNum || allRegNum > 14) throw Error(ERR_BAD_TNUM);
381  		const Reg64& _rsp = code->rsp;
382  		const AddressFrame& _ptr = code->ptr;
383  		saveNum_ = (std::max)(0, allRegNum - noSaveNum);
384  		const int *tbl = getOrderTbl() + noSaveNum;
385  		P_ = saveNum_ + (stackSizeByte + 7) / 8;
386  		if (P_ > 0 && (P_ & 1) == 0) P_++; 
387  		P_ *= 8;
388  		if (P_ > 0) code->sub(_rsp, P_);
389  #ifdef XBYAK64_WIN
390  		for (int i = 0; i < (std::min)(saveNum_, 4); i++) {
391  			code->mov(_ptr [_rsp + P_ + (i + 1) * 8], Reg64(tbl[i]));
392  		}
393  		for (int i = 4; i < saveNum_; i++) {
394  			code->mov(_ptr [_rsp + P_ - 8 * (saveNum_ - i)], Reg64(tbl[i]));
395  		}
396  #else
397  		for (int i = 0; i < saveNum_; i++) {
398  			code->mov(_ptr [_rsp + P_ - 8 * (saveNum_ - i)], Reg64(tbl[i]));
399  		}
400  #endif
401  		int pos = 0;
402  		for (int i = 0; i < pNum; i++) {
403  			pTbl_[i] = Xbyak::Reg64(getRegIdx(pos));
404  		}
405  		for (int i = 0; i < tNum_; i++) {
406  			tTbl_[i] = Xbyak::Reg64(getRegIdx(pos));
407  		}
408  		if (useRcx_ && rcxPos < pNum) code_->mov(code_->r10, code_->rcx);
409  		if (useRdx_ && rdxPos < pNum) code_->mov(code_->r11, code_->rdx);
410  		p_.init(pTbl_, pNum);
411  		t_.init(tTbl_, tNum_);
412  	}
413  	void close(bool callRet = true)
414  	{
415  		using namespace Xbyak;
416  		const Reg64& _rsp = code_->rsp;
417  		const AddressFrame& _ptr = code_->ptr;
418  		const int *tbl = getOrderTbl() + noSaveNum;
419  #ifdef XBYAK64_WIN
420  		for (int i = 0; i < (std::min)(saveNum_, 4); i++) {
421  			code_->mov(Reg64(tbl[i]), _ptr [_rsp + P_ + (i + 1) * 8]);
422  		}
423  		for (int i = 4; i < saveNum_; i++) {
424  			code_->mov(Reg64(tbl[i]), _ptr [_rsp + P_ - 8 * (saveNum_ - i)]);
425  		}
426  #else
427  		for (int i = 0; i < saveNum_; i++) {
428  			code_->mov(Reg64(tbl[i]), _ptr [_rsp + P_ - 8 * (saveNum_ - i)]);
429  		}
430  #endif
431  		if (P_ > 0) code_->add(_rsp, P_);
432  		if (callRet) code_->ret();
433  	}
434  	~StackFrame()
435  	{
436  		if (!makeEpilog_) return;
437  		try {
438  			close();
439  		} catch (std::exception& e) {
440  			printf("ERR:StackFrame %s\n", e.what());
441  			exit(1);
442  		} catch (...) {
443  			printf("ERR:StackFrame otherwise\n");
444  			exit(1);
445  		}
446  	}
447  private:
448  	const int *getOrderTbl() const
449  	{
450  		using namespace Xbyak;
451  		static const int tbl[] = {
452  #ifdef XBYAK64_WIN
453  			Operand::RCX, Operand::RDX, Operand::R8, Operand::R9, Operand::R10, Operand::R11, Operand::RDI, Operand::RSI,
454  #else
455  			Operand::RDI, Operand::RSI, Operand::RDX, Operand::RCX, Operand::R8, Operand::R9, Operand::R10, Operand::R11,
456  #endif
457  			Operand::RBX, Operand::RBP, Operand::R12, Operand::R13, Operand::R14, Operand::R15
458  		};
459  		return &tbl[0];
460  	}
461  	int getRegIdx(int& pos) const
462  	{
463  		assert(pos < 14);
464  		using namespace Xbyak;
465  		const int *tbl = getOrderTbl();
466  		int r = tbl[pos++];
467  		if (useRcx_) {
468  			if (r == Operand::RCX) { return Operand::R10; }
469  			if (r == Operand::R10) { r = tbl[pos++]; }
470  		}
471  		if (useRdx_) {
472  			if (r == Operand::RDX) { return Operand::R11; }
473  			if (r == Operand::R11) { return tbl[pos++]; }
474  		}
475  		return r;
476  	}
477  };
478  #endif
479  } } 
480  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl_gl.h</h3>
            <pre><code>1  #ifndef __OPENCL_CL_GL_H
2  #define __OPENCL_CL_GL_H
3  #ifdef __APPLE__
4  #include <OpenCL/cl.h>
5  #else
6  #include <CL/cl.h>
7  #endif	
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
<span onclick='openModal()' class='match'>11  typedef cl_uint     cl_gl_object_type;
12  typedef cl_uint     cl_gl_texture_info;
13  typedef cl_uint     cl_gl_platform_info;
14  typedef struct __GLsync *cl_GLsync;
15  #define CL_GL_OBJECT_BUFFER                     0x2000
16  #define CL_GL_OBJECT_TEXTURE2D                  0x2001
17  #define CL_GL_OBJECT_TEXTURE3D                  0x2002
18  #define CL_GL_OBJECT_RENDERBUFFER               0x2003
19  #define CL_GL_OBJECT_TEXTURE2D_ARRAY            0x200E
20  #define CL_GL_OBJECT_TEXTURE1D                  0x200F
21  #define CL_GL_OBJECT_TEXTURE1D_ARRAY            0x2010
22  #define CL_GL_OBJECT_TEXTURE_BUFFER             0x2011
23  #define CL_GL_TEXTURE_TARGET                    0x2004
24  #define CL_GL_MIPMAP_LEVEL                      0x2005
25  #define CL_GL_NUM_SAMPLES                       0x2012
26  extern CL_API_ENTRY cl_mem CL_API_CALL
27  clCreateFromGLBuffer(cl_context     &bsol;* context */,
28                       cl_mem_flags   &bsol;* flags */,
29                       cl_GLuint      &bsol;* bufobj */,
30                       int *          &bsol;* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;
31  extern CL_API_ENTRY cl_mem CL_API_CALL
32  clCreateFromGLTexture(cl_context      &bsol;* context */,
33                        cl_mem_flags    &bsol;* flags */,
34                        cl_GLenum       &bsol;* target */,
35                        cl_GLint        &bsol;* miplevel */,
36                        cl_GLuint       &bsol;* texture */,
37                        cl_int *        &bsol;* errcode_ret */) CL_API_SUFFIX__VERSION_1_2;
38  extern CL_API_ENTRY cl_mem CL_API_CALL
39  clCreateFromGLRenderbuffer(cl_context   &bsol;* context */,
40                             cl_mem_flags &bsol;* flags */,
41                             cl_GLuint    &bsol;* renderbuffer */,
42                             cl_int *     &bsol;* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;
</span>43  extern CL_API_ENTRY cl_int CL_API_CALL
44  clGetGLObjectInfo(cl_mem                &bsol;* memobj */,
45                    cl_gl_object_type *   &bsol;* gl_object_type */,
46                    cl_GLuint *           &bsol;* gl_object_name */) CL_API_SUFFIX__VERSION_1_0;
47  extern CL_API_ENTRY cl_int CL_API_CALL
48  clGetGLTextureInfo(cl_mem               &bsol;* memobj */,
49                     cl_gl_texture_info   &bsol;* param_name */,
50                     size_t               &bsol;* param_value_size */,
51                     void *               &bsol;* param_value */,
52                     size_t *             &bsol;* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;
53  extern CL_API_ENTRY cl_int CL_API_CALL
54  clEnqueueAcquireGLObjects(cl_command_queue      &bsol;* command_queue */,
55                            cl_uint               &bsol;* num_objects */,
56                            const cl_mem *        &bsol;* mem_objects */,
57                            cl_uint               &bsol;* num_events_in_wait_list */,
58                            const cl_event *      &bsol;* event_wait_list */,
59                            cl_event *            &bsol;* event */) CL_API_SUFFIX__VERSION_1_0;
60  extern CL_API_ENTRY cl_int CL_API_CALL
61  clEnqueueReleaseGLObjects(cl_command_queue      &bsol;* command_queue */,
62                            cl_uint               &bsol;* num_objects */,
63                            const cl_mem *        &bsol;* mem_objects */,
64                            cl_uint               &bsol;* num_events_in_wait_list */,
65                            const cl_event *      &bsol;* event_wait_list */,
66                            cl_event *            &bsol;* event */) CL_API_SUFFIX__VERSION_1_0;
67  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_mem CL_API_CALL
68  clCreateFromGLTexture2D(cl_context      &bsol;* context */,
69                          cl_mem_flags    &bsol;* flags */,
70                          cl_GLenum       &bsol;* target */,
71                          cl_GLint        &bsol;* miplevel */,
72                          cl_GLuint       &bsol;* texture */,
73                          cl_int *        &bsol;* errcode_ret */) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
74  extern CL_API_ENTRY CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_mem CL_API_CALL
75  clCreateFromGLTexture3D(cl_context      &bsol;* context */,
76                          cl_mem_flags    &bsol;* flags */,
77                          cl_GLenum       &bsol;* target */,
78                          cl_GLint        &bsol;* miplevel */,
79                          cl_GLuint       &bsol;* texture */,
80                          cl_int *        &bsol;* errcode_ret */) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
81  #define cl_khr_gl_sharing 1
82  typedef cl_uint     cl_gl_context_info;
83  #define CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR  -1000
84  #define CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR    0x2006
85  #define CL_DEVICES_FOR_GL_CONTEXT_KHR           0x2007
86  #define CL_GL_CONTEXT_KHR                       0x2008
87  #define CL_EGL_DISPLAY_KHR                      0x2009
88  #define CL_GLX_DISPLAY_KHR                      0x200A
89  #define CL_WGL_HDC_KHR                          0x200B
90  #define CL_CGL_SHAREGROUP_KHR                   0x200C
91  extern CL_API_ENTRY cl_int CL_API_CALL
92  clGetGLContextInfoKHR(const cl_context_properties * &bsol;* properties */,
93                        cl_gl_context_info            &bsol;* param_name */,
94                        size_t                        &bsol;* param_value_size */,
95                        void *                        &bsol;* param_value */,
96                        size_t *                      &bsol;* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;
97  typedef CL_API_ENTRY cl_int (CL_API_CALL *clGetGLContextInfoKHR_fn)(
98      const cl_context_properties * properties,
99      cl_gl_context_info            param_name,
100      size_t                        param_value_size,
101      void *                        param_value,
102      size_t *                      param_value_size_ret);
103  #ifdef __cplusplus
104  }
105  #endif
106  #endif  &bsol;* __OPENCL_CL_GL_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-xbyak_util.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl_gl.h</div>
                </div>
                <div class="column column_space"><pre><code>9  				push	ebx
10  				push	esi
11  				mov		eax, dword ptr [esp + 4 * 2 + 8] 
12  				cpuid
13  				mov		esi, dword ptr [esp + 4 * 2 + 4] 
14  				mov		dword ptr [esi], eax
15  				mov		dword ptr [esi + 4], ebx
16  				mov		dword ptr [esi + 8], ecx
17  				mov		dword ptr [esi + 12], edx
18  				pop		esi
19  				pop		ebx
</pre></code></div>
                <div class="column column_space"><pre><code>11  typedef cl_uint     cl_gl_object_type;
12  typedef cl_uint     cl_gl_texture_info;
13  typedef cl_uint     cl_gl_platform_info;
14  typedef struct __GLsync *cl_GLsync;
15  #define CL_GL_OBJECT_BUFFER                     0x2000
16  #define CL_GL_OBJECT_TEXTURE2D                  0x2001
17  #define CL_GL_OBJECT_TEXTURE3D                  0x2002
18  #define CL_GL_OBJECT_RENDERBUFFER               0x2003
19  #define CL_GL_OBJECT_TEXTURE2D_ARRAY            0x200E
20  #define CL_GL_OBJECT_TEXTURE1D                  0x200F
21  #define CL_GL_OBJECT_TEXTURE1D_ARRAY            0x2010
22  #define CL_GL_OBJECT_TEXTURE_BUFFER             0x2011
23  #define CL_GL_TEXTURE_TARGET                    0x2004
24  #define CL_GL_MIPMAP_LEVEL                      0x2005
25  #define CL_GL_NUM_SAMPLES                       0x2012
26  extern CL_API_ENTRY cl_mem CL_API_CALL
27  clCreateFromGLBuffer(cl_context     &bsol;* context */,
28                       cl_mem_flags   &bsol;* flags */,
29                       cl_GLuint      &bsol;* bufobj */,
30                       int *          &bsol;* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;
31  extern CL_API_ENTRY cl_mem CL_API_CALL
32  clCreateFromGLTexture(cl_context      &bsol;* context */,
33                        cl_mem_flags    &bsol;* flags */,
34                        cl_GLenum       &bsol;* target */,
35                        cl_GLint        &bsol;* miplevel */,
36                        cl_GLuint       &bsol;* texture */,
37                        cl_int *        &bsol;* errcode_ret */) CL_API_SUFFIX__VERSION_1_2;
38  extern CL_API_ENTRY cl_mem CL_API_CALL
39  clCreateFromGLRenderbuffer(cl_context   &bsol;* context */,
40                             cl_mem_flags &bsol;* flags */,
41                             cl_GLuint    &bsol;* renderbuffer */,
42                             cl_int *     &bsol;* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    