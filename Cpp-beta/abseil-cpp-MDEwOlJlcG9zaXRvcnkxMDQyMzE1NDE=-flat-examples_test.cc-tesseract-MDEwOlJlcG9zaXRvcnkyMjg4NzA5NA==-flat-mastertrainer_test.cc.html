
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.04494382022472%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-examples_test.cc</h3>
            <pre><code>1  #include <cinttypes>
2  #include <random>
3  #include <sstream>
4  #include <vector>
5  #include "gtest/gtest.h"
6  #include "absl/random/random.h"
7  template <typename T>
8  void Use(T) {}
9  TEST(Examples, Basic) {
10    absl::BitGen gen;
11    std::vector<int> objs = {10, 20, 30, 40, 50};
12    auto elem = objs[absl::Uniform(gen, 0u, objs.size())];
13    Use(elem);
14    auto dice_roll = absl::Uniform<int>(absl::IntervalClosedClosed, gen, 1, 6);
15    Use(dice_roll);
16    auto byte = absl::Uniform<uint8_t>(gen);
17    Use(byte);
18    auto fraction = absl::Uniform<float>(gen, 0, 1);
19    Use(fraction);
20    bool coin_toss = absl::Bernoulli(gen, 0.5);
21    Use(coin_toss);
22    auto file_size = absl::LogUniform<size_t>(gen, 1000, 10 * 1000 * 1000);
23    Use(file_size);
24    std::shuffle(std::begin(objs), std::end(objs), gen);
25  }
26  TEST(Examples, CreateingCorrelatedVariateSequences) {
27    {
28      auto my_seed = absl::MakeSeedSeq();
29      absl::BitGen gen_1(my_seed);
30      absl::BitGen gen_2(my_seed);  
<span onclick='openModal()' class='match'>31      EXPECT_EQ(absl::Bernoulli(gen_1, 0.5), absl::Bernoulli(gen_2, 0.5));
32      EXPECT_EQ(absl::Uniform<uint32_t>(gen_1), absl::Uniform<uint32_t>(gen_2));
33    }
34    {
35      absl::BitGen gen;
36      auto my_seed = absl::CreateSeedSeqFrom(&gen);
37      absl::BitGen gen_1(my_seed);
</span>38      absl::BitGen gen_2(my_seed);
39      EXPECT_EQ(absl::Bernoulli(gen_1, 0.5), absl::Bernoulli(gen_2, 0.5));
40      EXPECT_EQ(absl::Uniform<uint32_t>(gen_1), absl::Uniform<uint32_t>(gen_2));
41    }
42    {
43      const char kData[] = "A simple seed string";
44      std::seed_seq my_seed(std::begin(kData), std::end(kData));
45      absl::BitGen gen_1(my_seed);
46      absl::BitGen gen_2(my_seed);
47      EXPECT_EQ(absl::Bernoulli(gen_1, 0.5), absl::Bernoulli(gen_2, 0.5));
48      EXPECT_EQ(absl::Uniform<uint32_t>(gen_1), absl::Uniform<uint32_t>(gen_2));
49    }
50  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-mastertrainer_test.cc</h3>
            <pre><code>1  #include "include_gunit.h"
2  #include "commontraining.h"
3  #include "errorcounter.h"
4  #include "log.h" 
5  #include "mastertrainer.h"
6  #include "shapeclassifier.h"
7  #include "shapetable.h"
8  #include "trainingsample.h"
9  #include "unicharset.h"
10  #include <string>
11  #include <utility>
12  #include <vector>
13  using namespace tesseract;
14  static const int kNumTopNErrs = 10;
15  static const int kNumTop2Errs = kNumTopNErrs + 20;
16  static const int kNumTop1Errs = kNumTop2Errs + 30;
17  static const int kNumTopTopErrs = kNumTop1Errs + 25;
18  static const int kNumNonReject = 1000;
19  static const int kNumCorrect = kNumNonReject - kNumTop1Errs;
20  static const int kNumAnswers = kNumNonReject + 2 * (kNumTop2Errs - kNumTopNErrs) +
21                                 (kNumTop1Errs - kNumTop2Errs) + (kNumTopTopErrs - kNumTop1Errs);
22  #ifndef DISABLED_LEGACY_ENGINE
23  static bool safe_strto32(const std::string &str, int *pResult) {
24    long n = strtol(str.c_str(), nullptr, 0);
25    *pResult = n;
26    return true;
27  }
28  #endif
29  class MockClassifier : public ShapeClassifier {
30  public:
31    explicit MockClassifier(ShapeTable *shape_table)
32        : shape_table_(shape_table), num_done_(0), done_bad_font_(false) {
33      false_unichar_id_ = 67;
34      false_shape_ = shape_table_->AddShape(false_unichar_id_, 25);
35    }
36    ~MockClassifier() override = default;
37    int ClassifySample(const TrainingSample &sample, Image page_pix, int debug, UNICHAR_ID keep_this,
38                       std::vector<ShapeRating> *results) override {
39      results->clear();
40      if (++num_done_ > kNumNonReject) {
41        return 0;
42      }
43      int class_id = sample.class_id();
44      int font_id = sample.font_id();
45      int shape_id = shape_table_->FindShape(class_id, font_id);
46      int wrong_id1 = shape_id > 10 ? shape_id - 1 : shape_id + 1;
47      int wrong_id2 = shape_id > 10 ? shape_id - 2 : shape_id + 2;
48      if (num_done_ <= kNumTopNErrs) {
49        results->push_back(ShapeRating(wrong_id1, 1.0f));
50      } else if (num_done_ <= kNumTop2Errs) {
51        results->push_back(ShapeRating(wrong_id1, 1.0f));
52        results->push_back(ShapeRating(wrong_id2, 0.875f));
53        results->push_back(ShapeRating(shape_id, 0.75f));
54      } else if (num_done_ <= kNumTop1Errs) {
55        results->push_back(ShapeRating(wrong_id1, 1.0f));
56        results->push_back(ShapeRating(shape_id, 0.8f));
57      } else if (num_done_ <= kNumTopTopErrs) {
58        results->push_back(ShapeRating(wrong_id1, 1.0f));
59        results->push_back(ShapeRating(shape_id, 0.99f));
60      } else if (!done_bad_font_ && class_id == false_unichar_id_) {
61        results->push_back(ShapeRating(false_shape_, 1.0f));
62        done_bad_font_ = true;
63      } else {
64        results->push_back(ShapeRating(shape_id, 1.0f));
65      }
66      return results->size();
67    }
68    const ShapeTable *GetShapeTable() const override {
69      return shape_table_;
70    }
71  private:
72    ShapeTable *shape_table_;
73    int false_unichar_id_;
74    int false_shape_;
75    int num_done_;
76    bool done_bad_font_;
77  };
78  const double kMin1lDistance = 0.25;
79  class MasterTrainerTest : public testing::Test {
80  #ifndef DISABLED_LEGACY_ENGINE
81  protected:
82    void SetUp() override {
83      std::locale::global(std::locale(""));
84      file::MakeTmpdir();
85    }
86    std::string TestDataNameToPath(const std::string &name) {
87      return file::JoinPath(TESTING_DIR, name);
88    }
89    std::string TmpNameToPath(const std::string &name) {
90      return file::JoinPath(FLAGS_test_tmpdir, name);
91    }
92    MasterTrainerTest() {
93      shape_table_ = nullptr;
94      master_trainer_ = nullptr;
95    }
96    ~MasterTrainerTest() override {
97      delete shape_table_;
98    }
99    void LoadMasterTrainer() {
100      FLAGS_output_trainer = TmpNameToPath("tmp_trainer").c_str();
101      FLAGS_F = file::JoinPath(LANGDATA_DIR, "font_properties").c_str();
102      FLAGS_X = TestDataNameToPath("eng.xheights").c_str();
103      FLAGS_U = TestDataNameToPath("eng.unicharset").c_str();
104      std::string tr_file_name(TestDataNameToPath("eng.Arial.exp0.tr"));
105      const char *filelist[] = {tr_file_name.c_str(), nullptr};
106      std::string file_prefix;
107      delete shape_table_;
108      shape_table_ = nullptr;
109      master_trainer_ = LoadTrainingData(filelist, false, &shape_table_, file_prefix);
110      EXPECT_TRUE(master_trainer_ != nullptr);
111      EXPECT_TRUE(shape_table_ != nullptr);
112    }
113    void VerifyIl1() {
114      int font_id = master_trainer_->GetFontInfoId("Arial");
115      EXPECT_GE(font_id, 0);
116      int unichar_I = master_trainer_->unicharset().unichar_to_id("I");
117      EXPECT_GT(unichar_I, 0);
118      int unichar_l = master_trainer_->unicharset().unichar_to_id("l");
119      EXPECT_GT(unichar_l, 0);
120      int unichar_1 = master_trainer_->unicharset().unichar_to_id("1");
121      EXPECT_GT(unichar_1, 0);
122      int shape_I = shape_table_->FindShape(unichar_I, font_id);
123      EXPECT_GE(shape_I, 0);
124      int shape_l = shape_table_->FindShape(unichar_l, font_id);
125      EXPECT_GE(shape_l, 0);
126      int shape_1 = shape_table_->FindShape(unichar_1, font_id);
127      EXPECT_GE(shape_1, 0);
128      float dist_I_l = master_trainer_->ShapeDistance(*shape_table_, shape_I, shape_l);
129      EXPECT_EQ(0.0f, dist_I_l);
130      float dist_l_I = master_trainer_->ShapeDistance(*shape_table_, shape_l, shape_I);
131      EXPECT_EQ(0.0f, dist_l_I);
<span onclick='openModal()' class='match'>132      float dist_l_1 = master_trainer_->ShapeDistance(*shape_table_, shape_l, shape_1);
133      EXPECT_GT(dist_l_1, kMin1lDistance);
134      float dist_1_l = master_trainer_->ShapeDistance(*shape_table_, shape_1, shape_l);
135      EXPECT_GT(dist_1_l, kMin1lDistance);
</span>136      float dist_I_1 = master_trainer_->ShapeDistance(*shape_table_, shape_I, shape_1);
137      EXPECT_GT(dist_I_1, kMin1lDistance);
138      float dist_1_I = master_trainer_->ShapeDistance(*shape_table_, shape_1, shape_I);
139      EXPECT_GT(dist_1_I, kMin1lDistance);
140    }
141    ShapeTable *shape_table_;
142    std::unique_ptr<MasterTrainer> master_trainer_;
143  #endif
144  };
145  TEST_F(MasterTrainerTest, Il1Test) {
146  #ifdef DISABLED_LEGACY_ENGINE
147    GTEST_SKIP();
148  #else
149    LoadMasterTrainer();
150    VerifyIl1();
151  #endif
152  }
153  TEST_F(MasterTrainerTest, ErrorCounterTest) {
154  #ifdef DISABLED_LEGACY_ENGINE
155    GTEST_SKIP();
156  #else
157    LoadMasterTrainer();
158    if (shape_table_->FindShape(0, -1) < 0) {
159      shape_table_->AddShape(0, 0);
160    }
161    auto shape_classifier = std::make_unique<MockClassifier>(shape_table_);
162    std::string accuracy_report;
163    master_trainer_->TestClassifierOnSamples(tesseract::CT_UNICHAR_TOP1_ERR, 0, false,
164                                             shape_classifier.get(), &accuracy_report);
165    LOG(INFO) << accuracy_report.c_str();
166    std::string result_string = accuracy_report.c_str();
167    std::vector<std::string> results = split(result_string, '\t');
168    EXPECT_EQ(tesseract::CT_SIZE + 1, results.size());
169    int result_values[tesseract::CT_SIZE];
170    for (int i = 0; i < tesseract::CT_SIZE; ++i) {
171      EXPECT_TRUE(safe_strto32(results[i + 1], &result_values[i]));
172    }
173    int num_samples = master_trainer_->GetSamples()->num_raw_samples();
174    EXPECT_EQ(kNumCorrect, result_values[tesseract::CT_UNICHAR_TOP_OK]);
175    EXPECT_EQ(1, result_values[tesseract::CT_FONT_ATTR_ERR]);
176    EXPECT_EQ(kNumTopTopErrs, result_values[tesseract::CT_UNICHAR_TOPTOP_ERR]);
177    EXPECT_EQ(kNumTop1Errs, result_values[tesseract::CT_UNICHAR_TOP1_ERR]);
178    EXPECT_EQ(kNumTop2Errs, result_values[tesseract::CT_UNICHAR_TOP2_ERR]);
179    EXPECT_EQ(kNumTopNErrs, result_values[tesseract::CT_UNICHAR_TOPN_ERR]);
180    EXPECT_EQ(kNumTopTopErrs - kNumTop1Errs, result_values[tesseract::CT_OK_MULTI_UNICHAR]);
181    EXPECT_EQ(num_samples - kNumNonReject, result_values[tesseract::CT_REJECT]);
182    EXPECT_EQ(kNumAnswers, result_values[tesseract::CT_NUM_RESULTS]);
183  #endif
184  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-examples_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-mastertrainer_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>31      EXPECT_EQ(absl::Bernoulli(gen_1, 0.5), absl::Bernoulli(gen_2, 0.5));
32      EXPECT_EQ(absl::Uniform<uint32_t>(gen_1), absl::Uniform<uint32_t>(gen_2));
33    }
34    {
35      absl::BitGen gen;
36      auto my_seed = absl::CreateSeedSeqFrom(&gen);
37      absl::BitGen gen_1(my_seed);
</pre></code></div>
                <div class="column column_space"><pre><code>132      float dist_l_1 = master_trainer_->ShapeDistance(*shape_table_, shape_l, shape_1);
133      EXPECT_GT(dist_l_1, kMin1lDistance);
134      float dist_1_l = master_trainer_->ShapeDistance(*shape_table_, shape_1, shape_l);
135      EXPECT_GT(dist_1_l, kMin1lDistance);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    