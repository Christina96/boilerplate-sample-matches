
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.275407292474787%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.cpp</h3>
            <pre><code>1  #include "hldoc.h"
2  #include "yahooex.h"
3  void THldWordDs::AddWordIdFq(const TIntFltKd& WordIdFqKd){
4    double WordFq=WordIdFqKd.Dat;
5    if (WordFq>0){
6      int WordIdN=WordIdFqKdV.SearchBin(WordIdFqKd);
7      SumWordFq+=WordFq;
8      if (WordIdN==-1){
9        WordIdFqKdV.AddSorted(WordIdFqKd);
10      } else {
11        WordIdFqKdV[WordIdN].Dat+=WordFq;
12      }
13    }
14  }
15  bool THldWordDs::FNextWordId(
16   int& WordIdN, int& WordId, double& WordFq, double& WordPrb) const {
17    WordIdN++;
18    if (WordIdN<WordIdFqKdV.Len()){
19      WordId=WordIdFqKdV[WordIdN].Key;
20      WordFq=WordIdFqKdV[WordIdN].Dat;
21      WordPrb=WordFq/SumWordFq;
22      return true;
23    } else {
24      return false;
25    }
26  }
27  void THldWordDs::NrToSumWordFq(const double& NrSumWordFq){
28    if (SumWordFq!=NrSumWordFq){
29      double NrRatio=(double(SumWordFq)==0) ? 0 : NrSumWordFq/SumWordFq;
30      SumWordFq=NrSumWordFq;
31      if (SumWordFq>0){
32        for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
33          WordIdFqKdV[WordIdN].Dat=WordIdFqKdV[WordIdN].Dat*NrRatio;}
34      }
35    }
36  }
37  void THldWordDs::PowWordFq(const double& Exp){
38    if (SumWordFq>0){
39      SumWordFq=0;
40      for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
41        SumWordFq+=WordIdFqKdV[WordIdN].Dat=pow(WordIdFqKdV[WordIdN].Dat, Exp);
42      }
43    }
44  }
45  void THldWordDs::SaveTxt(const PSOut& SOut, const PHldBs& HldBs){
46    TFltIntKdV WordFqIdKdV(WordIdFqKdV.Len(), 0);
<span onclick='openModal()' class='match'>47    for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
48      int WordId=WordIdFqKdV[WordIdN].Key;
49      double WordFq=WordIdFqKdV[WordIdN].Dat/SumWordFq;
50      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
</span>51    }
52    WordFqIdKdV.Sort(false);
53    IAssert(WordFqIdKdV.IsSorted(false));
54    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
55    Lx.PutVarFlt("SumWordFq", SumWordFq);
56    Lx.PutVar("WordIdFqKdV", true, true);
57    {for (int WordIdN=0; WordIdN<WordFqIdKdV.Len(); WordIdN++){
58      int WordId=WordFqIdKdV[WordIdN].Dat;
59      double WordFq=WordFqIdKdV[WordIdN].Key;
60      if (HldBs.Empty()){Lx.PutInt(WordId);}
61      else {Lx.PutQStr(HldBs->GetWordStr(WordId));}
62      Lx.PutFlt(WordFq); Lx.PutLn();
63    }}
64    Lx.PutSym(syRBracket); Lx.PutLn();
65  }
66  PHldWordDs THldWordDs::GetMerged(
67   const PHldWordDs& LWordDs, const PHldWordDs& RWordDs){
68    TIntFltKdV& LWordIdFqKdV=LWordDs->WordIdFqKdV;
69    TIntFltKdV& RWordIdFqKdV=RWordDs->WordIdFqKdV;
70    int LWordIds=LWordDs->GetWordIds();
71    int RWordIds=RWordDs->GetWordIds();
72    double LSumWordFq=LWordDs->GetSumWordFq();
73    double RSumWordFq=RWordDs->GetSumWordFq();
74    PHldWordDs WordDs=new THldWordDs(LWordIds+RWordIds);
75    int LWordIdN=0; int RWordIdN=0;
76    if ((LSumWordFq>0)&&(RSumWordFq>0)){
77      while ((LWordIdN<LWordIds)&&(RWordIdN<RWordIds)){
78        TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
79        TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
80        if (LWordIdFqKd==RWordIdFqKd){
81          double LFq=LWordIdFqKd.Dat;
82          double RFq=RWordIdFqKd.Dat;
83          WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq+RFq); LWordIdN++; RWordIdN++;
84        } else
85        if (LWordIdFqKd<RWordIdFqKd){
86          double LFq=LWordIdFqKd.Dat;
87          WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq); LWordIdN++;
88        } else {
89          double RFq=RWordIdFqKd.Dat;
90          WordDs->AddWordIdFq(RWordIdFqKd.Key, RFq); RWordIdN++;
91        }
92      }
93    }
94    if (LSumWordFq>0){
95      while (LWordIdN<LWordIds){
96        TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
97        double LFq=LWordIdFqKd.Dat;
98        WordDs->AddWordIdFq(LWordIdFqKd.Key, LFq);
99        LWordIdN++;
100      }
101    }
102    if (RSumWordFq>0){
103      while (RWordIdN<RWordIds){
104        TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
105        double RFq=RWordIdFqKd.Dat;
106        WordDs->AddWordIdFq(RWordIdFqKd.Key, RFq);
107        RWordIdN++;
108      }
109    }
110    return WordDs;
111  }
112  PHldWordDs THldWordDs::GetTruncByMxWords(
113   const PHldWordDs& WordDs, const int& MxWords){
114    TFltIntKdV WordFqIdKdV(WordDs->WordIdFqKdV.Len(), 0);
115    for (int WordIdN=0; WordIdN<WordDs->WordIdFqKdV.Len(); WordIdN++){
116      int WordId=WordDs->WordIdFqKdV[WordIdN].Key;
117      double WordFq=WordDs->WordIdFqKdV[WordIdN].Dat;
118      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
119    }
120    WordFqIdKdV.Sort(false);
121    int TruncWordIds=TInt::GetMn(MxWords, WordDs->GetWordIds());
122    PHldWordDs TruncWordDs=PHldWordDs(new THldWordDs(TruncWordIds));
123    for (int WordIdN=0; WordIdN<TruncWordIds; WordIdN++){
124      double WordFq=WordFqIdKdV[WordIdN].Key;
125      int WordId=WordFqIdKdV[WordIdN].Dat;
126      TruncWordDs->AddWordIdFq(WordId, WordFq);
127    }
128    return TruncWordDs;
129  }
130  double THldWordDs::GetDist(
131   const PHldWordDs& LWordDs, const PHldWordDs& RWordDs,
132   const PHldBs& &bsol;*HldBs*/){
133    TIntFltKdV& LWordIdFqKdV=LWordDs->WordIdFqKdV;
134    TIntFltKdV& RWordIdFqKdV=RWordDs->WordIdFqKdV;
135    int LWordIds=LWordIdFqKdV.Len();
136    int RWordIds=RWordIdFqKdV.Len();
137    double Dist=0;
138    int LWordIdN=0; int RWordIdN=0;
139    while ((LWordIdN<LWordIds)&&(RWordIdN<RWordIds)){
140      TIntFltKd& LWordIdFqKd=LWordIdFqKdV[LWordIdN];
141      TIntFltKd& RWordIdFqKd=RWordIdFqKdV[RWordIdN];
142      if (LWordIdFqKd==RWordIdFqKd){
143        Dist++;
144        LWordIdN++; RWordIdN++;
145      } else
146      if (LWordIdFqKd<RWordIdFqKd){
147        LWordIdN++;
148      } else {
149        RWordIdN++;
150      }
151    }
152    Dist=1-Dist/(sqrt(LWordIdFqKdV.Len())*sqrt(RWordIdFqKdV.Len()));
153    return Dist;
154  }
155  void THldWordDs::GetHypTsEst(
156   const PHldWordDs& RefWordDs, const PHldWordDs& HypWordDs,
157   double& Precis, double& Recall, double& Dist, double& F2){
158    int RefWordIds=0; int IntsWordIds=0;
159    int WordIdN=RefWordDs->FFirstWordId(); int WordId; double WordFq; double WordPrb;
160    while (RefWordDs->FNextWordId(WordIdN, WordId, WordFq, WordPrb)){
161      if (HypWordDs->IsWordId(WordId)){IntsWordIds++;}
162      RefWordIds++;
163    }
164    int HypWordIds=HypWordDs->GetWordIds();
165    PHldWordDs RefHypWordDs=THldWordDs::GetMerged(RefWordDs, HypWordDs);
166    if ((RefWordIds==0)||(HypWordIds==0)){
167      Precis=1; Recall=1; Dist=1;
168    } else {
169      Precis=IntsWordIds/double(HypWordIds);
170      Recall=IntsWordIds/double(RefWordIds);
171      Dist=1-IntsWordIds/(sqrt(HypWordIds)*sqrt(RefWordIds));
172    }
173    if (Precis+Recall>0){F2=(5*Precis*Recall)/(4*Precis+Recall);}
174  }
175  THldWord::THldWord(THldBs* _HldBs, const TStr& Str):
176    HldBs(_HldBs), FirstChN(HldBs->WordChAHeap.Len()){
177    HldBs->WordChAHeap+=Str; HldBs->WordChAHeap+=CrCh;
178  }
179  TStr THldWord::GetStr() const {
180    TChA ChA; int ChN=FirstChN;
181    while (HldBs->WordChAHeap[ChN]!=CrCh){
182      ChA+=HldBs->WordChAHeap[ChN++];}
183    return ChA;
184  }
185  void THldBs::PutThisToWord(){
186    int WordToFqP=WordToFqH.FFirstKeyId();
187    while (WordToFqH.FNextKeyId(WordToFqP)){
188      WordToFqH.GetKey(WordToFqP).HldBs=this;
189    }
190  }
191  TStr THldBs::GetStrQStr(const TStrQ& StrQ, const int& Strs){
192    TChA ChA;
193    int FirstStrN=(Strs==-1) ? 0 : StrQ.Len()-Strs;
194    for (int StrN=FirstStrN; StrN<StrQ.Len(); StrN++){
195      if (!ChA.Empty()){ChA+=' ';} ChA+=StrQ[StrN];
196    }
197    return ChA;
198  }
199  THldBs::THldBs(
200   const TStrV& HlCtxStrV, const PXWebBs& WebBs,
201   const int& _MxNGram, const int& _MnWordFq,
202   const TSwSetTy& SwSetTy, const PNotify& _Notify):
203    MxNGram(_MxNGram), MnWordFq(_MnWordFq),
204    SwSet(new TSwSet(SwSetTy)),
205    WordToFqH(100000), WordChAHeap(1000000),
206    WordIdVHeap(100000, 0), DocIdToUrlStrH(50000),
207    HlDocV(), Notify(_Notify){
208    TIntPrV HlCtxWebPgPrV(HlCtxStrV.Len(), 0);
209    for (int HlCtxStrN=0; HlCtxStrN<HlCtxStrV.Len(); HlCtxStrN++){
210      TStr UrlStr=GetUrlStrFromHlCtxStr(HlCtxStrV[HlCtxStrN]);
211      IAssert(WebBs->IsUrlStr(UrlStr));
212      int WebPgId=WebBs->GetWebPgId(UrlStr);
213      HlCtxWebPgPrV.Add(TIntPr(HlCtxStrN, WebPgId));
214    }
215    TNotify::OnNotify(Notify, ntInfo, "Start Generation N-Grams");
216    for (int NGram=1; NGram<=MxNGram; NGram++){
217      int Hlds=0;
218      for (int HlCtxWebPgN=0; HlCtxWebPgN<HlCtxWebPgPrV.Len(); HlCtxWebPgN++){
219        int HlCtxStrN=HlCtxWebPgPrV[HlCtxWebPgN].Val1;
220        int WebPgId=HlCtxWebPgPrV[HlCtxWebPgN].Val2;
221        TStr HlCtxStr=HlCtxStrV[HlCtxStrN];
222        TStr WebPgStr=WebBs->GetBodyStr(WebPgId);
223        AddTxt(HlCtxStr, false, NGram);
224        AddTxt(WebPgStr, false, NGram);
225        if (++Hlds%100==0){
226          TStr DocProcStr=TStr("...")+TInt::GetStr(Hlds)+" Documents; "+
227           TInt::GetStr(GetWords())+" N-Grams";
228          TNotify::OnNotify(Notify, ntInfo, DocProcStr);
229        }
230      }
231      TStr NGramGenStr=TInt::GetStr(NGram)+"-Grams Generated ("+
232       TInt::GetStr(GetWords())+")";
233      TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
234      TStrIntPrV WordStrFqPrV(WordToFqH.Len(), 0);
235      int WordId=WordToFqH.FFirstKeyId();
236      while (WordToFqH.FNextKeyId(WordId)){
237        if (WordToFqH[WordId]>=MnWordFq){
238          WordStrFqPrV.Add(TStrIntPr(GetWordStr(WordId), TInt(GetWordFq(WordId))));}
239      }
240      WordToFqH.Clr(); WordChAHeap.Clr();
241      for (int WordN=0; WordN<WordStrFqPrV.Len(); WordN++){
242        AddWord(WordStrFqPrV[WordN].Val1)=WordStrFqPrV[WordN].Val2;}
243      TStr NGramReduceStr=TInt::GetStr(NGram)+"-Grams Reduced ("+
244       TInt::GetStr(GetWords())+")";
245      TNotify::OnNotify(Notify, ntInfo, NGramReduceStr);
246    }
247    TStr NGramGenStr=TInt::GetStr(MxNGram)+"-Grams Generation Finished ("+
248     TInt::GetStr(GetWords())+")";
249    TNotify::OnNotify(Notify, ntInfo, NGramGenStr);
250    TNotify::OnNotify(Notify, ntInfo, "Start Processing Documents");
251    HlDocV.Gen(HlCtxWebPgPrV.Len(), 0);
252    int Hlds=0;
253    THash<TStr, TInt> UrlStrToDocIdH(HlCtxWebPgPrV.Len());
254    for (int HlCtxWebPgN=0; HlCtxWebPgN<HlCtxWebPgPrV.Len(); HlCtxWebPgN++){
255      int HlCtxStrN=HlCtxWebPgPrV[HlCtxWebPgN].Val1;
256      int WebPgId=HlCtxWebPgPrV[HlCtxWebPgN].Val2;
257      TStr HlCtxStr=HlCtxStrV[HlCtxStrN];
258      TStr WebPgStr=WebBs->GetBodyStr(WebPgId);
259      TStr UrlStr=WebBs->GetUrlStr(WebPgId);
260      int HlId=AddTxt(HlCtxStr, true, -1);
261      int DocId;
262      if (UrlStrToDocIdH.IsKey(UrlStr)){
263        DocId=UrlStrToDocIdH.GetDat(UrlStr);
264      } else {
265        DocId=AddTxt(WebPgStr, true, -1);
266        UrlStrToDocIdH.AddDat(UrlStr, DocId);
267        DocIdToUrlStrH.AddDat(DocId, UrlStr);
268      }
269      PHldWordDs HlWordDs=GetTxtWordDs(HlId);
270      HlDocV.Add(THlDoc(HlId, DocId, HlWordDs));
271      if (++Hlds%100==0){
272        TStr DocProcStr=TInt::GetStr(Hlds)+" Documents Processed";
273        TNotify::OnNotify(Notify, ntInfo, DocProcStr);
274      }
275    }
276    TStr DocProcStr=TStr("HyperLinkDocument Processing Finished (")+
277     TInt::GetStr(HlDocV.Len())+")";
278    TNotify::OnNotify(Notify, ntInfo, DocProcStr);
279  }
280  TInt& THldBs::AddWord(const TStr& WordStr){
281    int PrevLen=WordChAHeap.Len();
282    THldWord Word(this, WordStr);
283    int WordId=WordToFqH.GetKeyId(Word);
284    if (WordId==-1){
285      return WordToFqH.AddDat(Word);
286    } else {
287      WordChAHeap.Trunc(PrevLen);
288      return WordToFqH[WordId];
289    }
290  }
291  int THldBs::GetWordId(const TStr& WordStr){
292    int PrevLen=WordChAHeap.Len();
293    THldWord Word(this, WordStr);
294    int WordId=WordToFqH.GetKeyId(Word);
295    WordChAHeap.Trunc(PrevLen);
296    return WordId;
297  }
298  int THldBs::AddTxt(const TStr& TxtStr, const bool& DoGenDoc, const int& NGram){
299    int TxtId=-1;
300    TIntV TxtWordIdV;
301    if (DoGenDoc){
302      IAssert(NGram==-1);
303      TxtWordIdV.Gen(1000, 0);
304    }
305    PSIn SIn=TStrIn::New(TxtStr);
306    PHtmlDoc HtmlDoc=PHtmlDoc(new THtmlDoc(SIn, hdtAll));
307    PHtmlTok Tok; THtmlLxSym Sym=hlsyUndef; TStr Str; TStrQ PrevStrQ;
308    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
309      Tok=HtmlDoc->GetTok(TokN, Sym, Str);
310      switch (Sym){
311        case hlsyStr:
312          if (DoGenDoc){
313            if (!SwSet->IsIn(Str)){
314              int WordId=GetWordId(Str);
315              if (WordId!=-1){
316                TxtWordIdV.Add(WordId);
317                PrevStrQ.Push(Str);
318                int NGram=2;
319                while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
320                  int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
321                  if (WordId==-1){
322                    while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
323                  } else {
324                    TxtWordIdV.Add(WordId);
325                  }
326                  NGram++;
327                }
328              } else {
329                PrevStrQ.Clr();
330              }
331            }
332          } else {
333            if (NGram==1){
334              if (!SwSet->IsIn(Str)){AddWord(Str)++;}
335            } else {
336              if (!SwSet->IsIn(Str)){
337                int WordId=GetWordId(Str);
338                if (WordId!=-1){
339                  TStr WordStr=GetWordStr(WordId);
340                  if (PrevStrQ.Len()+1==NGram){
341                    if (GetWordId(GetStrQStr(PrevStrQ))!=-1){
342                      PrevStrQ.Push(WordStr);
343                      AddWord(GetStrQStr(PrevStrQ))++;
344                      PrevStrQ.Pop();
345                    } else {
346                      PrevStrQ.Push(WordStr); PrevStrQ.Pop();
347                    }
348                  } else {
349                    PrevStrQ.Push(WordStr);
350                  }
351                } else {
352                  PrevStrQ.Clr();
353                }
354              }
355            }
356          }
357          break;
358        case hlsyNum:
359        case hlsySSym:
360          PrevStrQ.Clr(); break;
361        case hlsyBTag:
362        case hlsyETag:
363          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
364        default:;
365      }
366    }
367    if (DoGenDoc){
368      TxtId=WordIdVHeap.Len();
369      WordIdVHeap.AddV(TxtWordIdV); WordIdVHeap.Add(TInt(-1));
370    }
371    return TxtId;
372  }
373  int THldBs::GetTxtLen(const int& TxtId){
374    int WordIdN=TxtId; int TxtLen=0;
375    while (WordIdVHeap[WordIdN]!=-1){WordIdN++; TxtLen++;}
376    return TxtLen;
377  }
378  PHldWordDs THldBs::GetTxtWordDs(const int& TxtId){
379    PHldWordDs WordDs=PHldWordDs(new THldWordDs(GetTxtLen(TxtId)));
380    int WordIdN=TxtId;
381    while (WordIdVHeap[WordIdN]!=-1){
382      int WordId=WordIdVHeap[WordIdN++];
383      WordDs->AddWordIdFq(WordId, 1);
384    }
385    return WordDs;
386  }
387  PHldWordDs THldBs::GetWordDs(const PSIn& SIn){
388    PHldWordDs WordDs=PHldWordDs(new THldWordDs());
389    PHtmlDoc HtmlDoc=new THtmlDoc(SIn, hdtAll);
390    PHtmlTok Tok; THtmlLxSym Sym; TStr Str; TStrQ PrevStrQ;
391    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
392      Tok=HtmlDoc->GetTok(TokN, Sym, Str);
393      switch (Sym){
394        case hlsyStr:
395          if (!SwSet->IsIn(Str)){
396            int WordId=GetWordId(Str);
397            if (WordId!=-1){
398              WordDs->AddWordIdFq(WordId, 1);
399              PrevStrQ.Push(Str);
400              int NGram=2;
401              while ((NGram<=MxNGram)&&(NGram<=PrevStrQ.Len())){
402                int WordId=GetWordId(GetStrQStr(PrevStrQ, NGram));
403                if (WordId==-1){
404                  while (PrevStrQ.Len()>=NGram){PrevStrQ.Pop();} break;
405                } else {
406                  WordDs->AddWordIdFq(WordId, 1);
407                }
408                NGram++;
409              }
410            } else {
411              PrevStrQ.Clr();
412            }
413          }
414          break;
415        case hlsyNum:
416        case hlsySSym:
417          PrevStrQ.Clr(); break;
418        case hlsyBTag:
419        case hlsyETag:
420          if (THtmlTok::IsBreakTag(Str)){PrevStrQ.Clr();} break;
421        default:;
422      }
423    }
424    return WordDs;
425  }
426  void THldBs::GetDistHlDocNV(
427   const int& KNNbrs, const bool& RndSel,
428   const PHldWordDs& RefHlWordDs, const TStrV& SelUrlStrV,
429   TFltIntKdV& DistHlDocNKdV){
430    DistHlDocNKdV.Clr();
431    for (int HlDocN=0; HlDocN<GetHlDocs(); HlDocN++){
432      if (SelUrlStrV.Len()>0){
433        if (SelUrlStrV.SearchBin(GetDocUrlStr(HlDocN))==-1){continue;}}
434      PHldWordDs HlWordDs=GetHlWordDs(HlDocN);
435      double Dist=THldWordDs::GetDist(RefHlWordDs, HlWordDs, this);
436      if (RndSel){
437        DistHlDocNKdV.Add(TFltIntKd(Dist, HlDocN));
438      } else {
439        DistHlDocNKdV.AddSorted(TFltIntKd(Dist, HlDocN), true, KNNbrs);
440      }
441    }
442    if (RndSel){
443      TRnd Rnd(TRnd::RndSeed);
444      DistHlDocNKdV.Shuffle(Rnd);
445      int Docs=TInt::GetMn(DistHlDocNKdV.Len(), KNNbrs);
446      DistHlDocNKdV.Reserve(Docs, Docs);
447    }
448  }
449  PHldWordDs THldBs::GetHypDocWordDs(const TFltIntKdV& DistHlDocNKdV){
450    PHldWordDs HypWordDs=PHldWordDs(new THldWordDs());
451    PMom HypDocLenMom=PMom(new TMom());
452    for (int DistHlDocNKdN=0; DistHlDocNKdN<DistHlDocNKdV.Len(); DistHlDocNKdN++){
453      int HlDocN=DistHlDocNKdV[DistHlDocNKdN].Dat;
454      PHldWordDs DocWordDs=GetDocWordDs(HlDocN);
455      HypWordDs=THldWordDs::GetMerged(HypWordDs, DocWordDs);
456      HypDocLenMom->Add(GetTxtLen(GetDocId(HlDocN)));
457    }
458    HypDocLenMom->Def();
459    int HypDocLen=int(HypDocLenMom->GetMean());
460    HypWordDs=THldWordDs::GetTruncByMxWords(HypWordDs, HypDocLen);
461    return HypWordDs;
462  }
463  void THldBs::SaveTxt(const PSOut& SOut){
464    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
465    for (int HlDocN=0; HlDocN<HlDocV.Len(); HlDocN++){
466      int HlId=HlDocV[HlDocN].GetHlId();
467      int DocId=HlDocV[HlDocN].GetDocId();
468      PHldWordDs HlWordDs=HlDocV[HlDocN].GetHlWordDs();
469      TStr UrlStr=DocIdToUrlStrH.GetDat(DocId);
470      Lx.PutVarStr("UrlStr", UrlStr);
471      Lx.PutVar("Hl", true, true);
472      int HlWordIdN=HlId; TChA HlWordLn;
473      while (WordIdVHeap[HlWordIdN]!=-1){
474        TStr WordStr=GetWordStr(WordIdVHeap[HlWordIdN++]);
475        if (WordStr.SearchCh(' ')==-1){HlWordLn+=WordStr;}
476        else {HlWordLn+='('; HlWordLn+=WordStr; HlWordLn+=')';}
477        HlWordLn+=' ';
478        if (HlWordLn.Len()>50){
479          Lx.PutQStr(HlWordLn); Lx.PutLn(); HlWordLn.Clr();}
480      }
481      if (!HlWordLn.Empty()){Lx.PutQStr(HlWordLn); Lx.PutLn();}
482      Lx.PutSym(syRBracket); Lx.PutLn();
483      Lx.PutVar("Doc", true, true);
484      int DocWordIdN=DocId; TChA DocWordLn;
485      while (WordIdVHeap[DocWordIdN]!=-1){
486        TStr WordStr=GetWordStr(WordIdVHeap[DocWordIdN++]);
487        if (WordStr.SearchCh(' ')==-1){DocWordLn+=WordStr;}
488        else {DocWordLn+='('; DocWordLn+=WordStr; DocWordLn+=')';}
489        DocWordLn+=' ';
490        if (DocWordLn.Len()>50){
491          Lx.PutQStr(DocWordLn); Lx.PutLn(); DocWordLn.Clr();}
492      }
493      if (!DocWordLn.Empty()){Lx.PutQStr(DocWordLn); Lx.PutLn();}
494      Lx.PutSym(syRBracket); Lx.PutLn();
495      HlWordDs->SaveTxt(SOut, this);
496    }
497    Lx.PutVar("WordFqIdKdV", true, true);
498    TIntKdV WordFqIdKdV;
499    int WordToFqP=WordToFqH.FFirstKeyId();
500    while (WordToFqH.FNextKeyId(WordToFqP)){
501      int WordId=WordToFqP;
502      int WordFq=WordToFqH[WordToFqP];
503      WordFqIdKdV.Add(TIntKd(WordFq, WordId));
504    }
505    WordFqIdKdV.Sort(false);
506    for (int WordFqIdKdN=0; WordFqIdKdN<WordFqIdKdV.Len(); WordFqIdKdN++){
507      int WordFq=WordFqIdKdV[WordFqIdKdN].Key;
508      TStr WordStr=GetWordStr(WordFqIdKdV[WordFqIdKdN].Dat);
509      Lx.PutStr(WordStr); Lx.PutSym(syColon); Lx.PutInt(WordFq); Lx.PutLn();
510    }
511    Lx.PutSym(syRBracket); Lx.PutLn();
512  }
513  TStr THldBs::GetUrlStrFromHlCtxStr(const TStr& HlCtxStr){
514    PSIn SIn=TStrIn::New(HlCtxStr);
515    PHtmlDoc HtmlDoc=THtmlDoc::New(SIn, hdtA);
516    PHtmlTok Tok=HtmlDoc->GetTok(0);
517    IAssert((Tok->GetSym()==hlsyBTag)&&(Tok->GetStr()==THtmlTok::ATagNm));
518    TStr HRefStr=Tok->GetArg(THtmlTok::HRefArgNm);
519    PUrl Url=TUrl::New(HRefStr);
520    return Url->GetUrlStr();
521  }
522  void THldExpr::PutMomHd(TOLx& Lx, const TStr& VarNm){
523    Lx.PutUQStr(VarNm+"Mean"); Lx.PutUQStr(VarNm+"SDev");
524    Lx.PutUQStr(VarNm+"SErr"); Lx.PutUQStr(VarNm+"Med");
525    Lx.PutUQStr(VarNm+"Q1"); Lx.PutUQStr(VarNm+"Q3");
526  }
527  void THldExpr::PutMomVal(TOLx& Lx, const PMom& Mom){
528    if (Mom->IsUsable()){
529      Lx.PutFlt(Mom->GetMean()); Lx.PutFlt(Mom->GetSDev());
530      Lx.PutFlt(Mom->GetSErr()); Lx.PutFlt(Mom->GetMedian());
531      Lx.PutFlt(Mom->GetQuart1()); Lx.PutFlt(Mom->GetQuart3());
532    } else {
533      for (int MomN=0; MomN<6; MomN++){Lx.PutFlt(-1);}
534    }
535  }
536  void THldExpr::Go(
537   const PSOut& SOut, const bool& PutHd, const bool& SaveTmp,
538   const TStr& HldDmNm, const int& TsRuns,
539   const TStrV& AllHlCtxStrV, const PXWebBs& DocWebBs,
540   const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
541   const int& KNNbrs, const bool& RndSel,
542   const PNotify& Notify){
543    PSOut LogSOut=new TFOut("log.t");
544    TOLx LogLx(LogSOut, TFSet()|oloFrcEoln|oloSigNum);
545    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
546    if (PutHd){
547      Lx.PutUQStr("DmNm"); Lx.PutUQStr("TsRunN");
548      Lx.PutUQStr("KNNbrs");
549      Lx.PutUQStr("RndSel");
550      PutMomHd(Lx, "HldPrecis");
551      PutMomHd(Lx, "HldRecall");
552      PutMomHd(Lx, "HldDist");
553      PutMomHd(Lx, "HldF2");
554      PutMomHd(Lx, "HlLen");
555      PutMomHd(Lx, "DocLen");
556      PutMomHd(Lx, "HypDocLen");
557      PutMomHd(Lx, "YHldPrecis");
558      PutMomHd(Lx, "YHldRecall");
559      Lx.PutLn();
560    }
561    TRnd Rnd;
562    TStrV ShHlCtxStrV=AllHlCtxStrV; ShHlCtxStrV.Shuffle(Rnd);
563    for (int TsRunN=0; TsRunN<TsRuns; TsRunN++){
564      TStrV TrHlCtxStrV; TStrV TsHlCtxStrV;
565      for (int ShHlCtxStrN=0; ShHlCtxStrN<ShHlCtxStrV.Len(); ShHlCtxStrN++){
566        if (ShHlCtxStrN%TsRuns==TsRunN){
567          TsHlCtxStrV.Add(ShHlCtxStrV[ShHlCtxStrN]);
568        } else {
569          TrHlCtxStrV.Add(ShHlCtxStrV[ShHlCtxStrN]);
570        }
571      }
572      PHldBs HldBs=PHldBs(new THldBs(
573       TrHlCtxStrV, DocWebBs, MxNGram, MnWordFq, SwSetTy, Notify));
574      if (SaveTmp){
575        TFOut FOut("HldBsRef.Dat");
576        HldBs->Save(FOut);
577        HldBs->SaveTxt(PSOut(new TFOut("hldRef.t")));
578      }
579      PMom HldPrecisMom=PMom(new TMom());
580      PMom HldRecallMom=PMom(new TMom());
581      PMom HldDistMom=PMom(new TMom());
582      PMom HldF2Mom=PMom(new TMom());
583      PMom HlLenMom=PMom(new TMom());
584      PMom DocLenMom=PMom(new TMom());
585      PMom HypDocLenMom=PMom(new TMom());
586      PMom YHldPrecisMom=PMom(new TMom());
587      PMom YHldRecallMom=PMom(new TMom());
588      for (int TsHlCtxStrN=0; TsHlCtxStrN<TsHlCtxStrV.Len(); TsHlCtxStrN++){
589        TStr TsHlCtxStr=TsHlCtxStrV[TsHlCtxStrN];
590        LogLx.PutVarStr("TsHlCtxStr", TsHlCtxStr);
591        {TStr UrlStr=THldBs::GetUrlStrFromHlCtxStr(TsHlCtxStr);
592        TStr WebPgStr=DocWebBs->GetBodyStr(UrlStr);
593        PHldWordDs TsHlWordDs=HldBs->GetWordDs(TsHlCtxStr);
594        PHldWordDs TsDocWordDs=HldBs->GetWordDs(WebPgStr);
595        TFltIntKdV DistHlDocNKdV;
596        HldBs->GetDistHlDocNV(KNNbrs, RndSel, TsHlWordDs, TStrV(), DistHlDocNKdV);
597        if (SaveTmp){
598          for (int DistHlDocNKdN=0; DistHlDocNKdN<DistHlDocNKdV.Len(); DistHlDocNKdN++){
599            double Dist=DistHlDocNKdV[DistHlDocNKdN].Key;
600            TStr UrlStr=HldBs->GetDocUrlStr(DistHlDocNKdV[DistHlDocNKdN].Dat);
601            LogLx.PutVarStr("UrlStr", TFlt::GetStr(Dist)+" "+UrlStr);
602          }
603        }
604        PHldWordDs HypDocWordDs=HldBs->GetHypDocWordDs(DistHlDocNKdV);
605        double Precis; double Recall; double Dist; double F2;
606        THldWordDs::GetHypTsEst(TsDocWordDs, HypDocWordDs, Precis, Recall, Dist, F2);
607        HldPrecisMom->Add(Precis); HldRecallMom->Add(Recall);
608        HldDistMom->Add(Dist); HldF2Mom->Add(F2);
609        double HlLen=TsHlWordDs->GetWordIds(); HlLenMom->Add(HlLen);
610        double DocLen=TsDocWordDs->GetWordIds(); DocLenMom->Add(DocLen);
611        double HypDocLen=HypDocWordDs->GetWordIds(); HypDocLenMom->Add(HypDocLen);
612        if (SaveTmp){
613          LogLx.PutVarFlt("Precis", Precis);
614          LogLx.PutVarFlt("Recall", Recall);
615          LogLx.PutVarFlt("Dist", Dist);
616          LogLx.PutVarFlt("F2", F2);
617          LogLx.PutVarFlt("HlLen", HlLen);
618          LogLx.PutVarFlt("DocLen", DocLen);
619          LogLx.PutVarFlt("HypDocLen", HypDocLen);
620        }}
621        if (SaveTmp){LogLx.PutLn();}
622      }
623      HldPrecisMom->Def();
624      HldRecallMom->Def();
625      HldDistMom->Def();
626      HldF2Mom->Def();
627      HlLenMom->Def();
628      DocLenMom->Def();
629      HypDocLenMom->Def();
630      YHldPrecisMom->Def();
631      YHldRecallMom->Def();
632      Lx.PutStr(HldDmNm); Lx.PutInt(TsRunN);
633      Lx.PutInt(KNNbrs);
634      Lx.PutBool(RndSel);
635      PutMomVal(Lx, HldPrecisMom);
636      PutMomVal(Lx, HldRecallMom);
637      PutMomVal(Lx, HldDistMom);
638      PutMomVal(Lx, HldF2Mom);
639      PutMomVal(Lx, HlLenMom);
640      PutMomVal(Lx, DocLenMom);
641      PutMomVal(Lx, HypDocLenMom);
642      PutMomVal(Lx, YHldPrecisMom);
643      PutMomVal(Lx, YHldRecallMom);
644      Lx.PutLn();
645      SOut->Flush();
646      LogSOut->Flush();
647    }
648  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-postag.cpp</h3>
            <pre><code>1  #include <postag.h>
2  TPosTagType TPosElt::GetTypeFromAna(const TStr& AnaType) {
3      if (AnaType.Empty()) {  return pttUndef; }
4      switch (AnaType[0]) {
5          case 'N': return pttNoun;
6          case 'V': return pttVerb;
7          case 'A': return pttAdjective;
8          case 'R': return pttAdverb;
9          case 'P': return pttPronoun;
10          case 'S': return pttAdposition;
11          case 'C': return pttConjunction;
12          case 'Q': return pttParticle;
13          case 'I': return pttInterjection;
14          case 'M': return pttNumeral;
15          case 'Y': return pttAbbreviation;
16          case 'X': return pttResidual;
17          default: return pttUndef;
18      }
19  }
20  void TPosSentBs::MakeSplit(const int& Train, const int& Test) {
21      if (Train == -1) {
22          TestSents = TInt::GetMn(Test, GetSents());
23          TrainSents = GetSents() - TestSents;
24      } else if (Test == -1) { 
25          TrainSents = TInt::GetMn(Train, GetSents());
26          TestSents = GetSents() - TrainSents;
27      } else {
28          TrainSents = TInt::GetMn(Train, GetSents());
29          TestSents = TInt::GetMn(Test, GetSents()-TrainSents);
30      }
31  }
32  int TPosSentBs::CompareSent(const TPosSent& OrgSent, const TPosSent& PredSent) const {
33      IAssert(OrgSent.GetElts() == PredSent.GetElts());
34      int MatchCount = 0;
35      for (int EltN = 2; EltN < (OrgSent.GetElts()-1); EltN++) {
36          const TPosTagType OrgTagType = OrgSent.GetElt(EltN).GetPosTagType();
37          const TPosTagType PredTagType = PredSent.GetElt(EltN).GetPosTagType();
38          if (OrgTagType == PredTagType) { MatchCount++; }
39      }
40      return MatchCount;
41  }
42  int TPosSentBs::CompareSentKnown(const TPosSent& OrgSent, 
43          const TPosSent& PredSent, const PPosHmm& Hmm) const {
44      IAssert(OrgSent.GetElts() == PredSent.GetElts());
45      int MatchCount = 0;
46      for (int EltN = 2; EltN < (OrgSent.GetElts()-1); EltN++) {
47          if (!Hmm->IsKnown(OrgSent.GetElt(EltN).GetLemmaStr())) { continue; }
48          const TPosTagType OrgTagType = OrgSent.GetElt(EltN).GetPosTagType();
49          const TPosTagType PredTagType = PredSent.GetElt(EltN).GetPosTagType();
50          if (OrgTagType == PredTagType) { MatchCount++; }
51      }
52      return MatchCount;
53  }
54  int TPosSentBs::CompareSentUnknown(const TPosSent& OrgSent, 
55          const TPosSent& PredSent, const PPosHmm& Hmm) const {
56      IAssert(OrgSent.GetElts() == PredSent.GetElts());
57      int MatchCount = 0;
58      for (int EltN = 2; EltN < (OrgSent.GetElts()-1); EltN++) {
59          if (Hmm->IsKnown(OrgSent.GetElt(EltN).GetLemmaStr())) { continue; }
60          const TPosTagType OrgTagType = OrgSent.GetElt(EltN).GetPosTagType();
61          const TPosTagType PredTagType = PredSent.GetElt(EltN).GetPosTagType();
62          if (OrgTagType == PredTagType) { MatchCount++; }
63      }
64      return MatchCount;
65  }
66  PPosSentBs TPosSentBs::LoadMte(const TStr& XmlFNm) {
67      PPosSentBs PosSentBs = TPosSentBs::New();
68      printf("Loading XML ... ");
69      PSIn XmlSIn = TFIn::New(XmlFNm);
70      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
71      PXmlTok TopTok = XmlDoc->GetTok();
72      printf("done\n");
73      TXmlTokV PartTokV; TopTok->GetTagTokV("text|body|div", PartTokV);
74      printf("Loading %d parts ... ", PartTokV.Len());
75      int AllSubParts = 0, AllParas = 0, AllSents = 0, AllWords = 0;
<span onclick='openModal()' class='match'>76      for (int PartN = 0; PartN < PartTokV.Len(); PartN++) {
77          PXmlTok PartTok = PartTokV[PartN];
78          const int SubParts = PartTok->GetSubToks(); AllSubParts += SubParts;
</span>79          for (int SubPartN = 0; SubPartN < SubParts; SubPartN++) {
80              PXmlTok SubPartTok = PartTok->GetSubTok(SubPartN);
81              if (SubPartTok->GetStrArgVal("type", "") == "appendix") { continue; }
82              const int Paras = SubPartTok->GetSubToks();
83              for (int ParaN = 0; ParaN < Paras; ParaN++) {
84                  PXmlTok ParaTok = SubPartTok->GetSubTok(ParaN);
85                  if (!ParaTok->IsTag()) { continue; } AllParas++;
86                  const int Sents = ParaTok->GetSubToks();
87                  for (int SentN = 0; SentN < Sents; SentN++) {
88                      PXmlTok SentTok = ParaTok->GetSubTok(SentN);
89                      if (!SentTok->IsTag()) { continue; } AllSents++;
90                      const int Words = SentTok->GetSubToks();
91                      TPosSent PosSent;
92                      PosSent.AddElt(TPosElt(pttBegining)); 
93                      PosSent.AddElt(TPosElt(pttBegining)); 
94                      for (int WordN = 0; WordN < Words; WordN++) {
95                          PXmlTok WordTok = SentTok->GetSubTok(WordN);
96                          if (!WordTok->IsTag()) { continue; } AllWords++;
97                          if (WordTok->GetTagNm() == "w") {
98                              TStr WordStr = WordTok->GetTokStr(false);
99                              TStr LemmaStr = WordTok->GetStrArgVal("lemma", "");
100                              TStr AnaType = WordTok->GetStrArgVal("ana", "");
101                              const TPosTagType PosTagType = TPosElt::GetTypeFromAna(AnaType);
102                              PosSent.AddElt(TPosElt(WordStr, LemmaStr, PosTagType));
103                          }
104                      }
105                      PosSent.AddElt(TPosElt(pttEnd)); 
106                      if (PosSent.GetElts() > 3) { PosSentBs->AddSent(PosSent); }
107                  }
108              }
109          }
110      }
111      printf("Done (Chapters:%d, Paragraphs:%d, Sentences:%d, Words:%d)\n",
112          AllSubParts, AllParas, AllSents, AllWords);
113      return PosSentBs;
114  }
115  void TPosHmm::LearnProb(const PPosSentBs& PosSentBs, int& Tokens, 
116          TIntPrIntH& BigramCountH, TIntTrIntH& TrigramCountH,
117          TIntPrIntH& LexicalCountH) {
118      LemmaH.Clr(); StateH.Clr();
119      Tokens = 0; BigramCountH.Clr();
120      TrigramCountH.Clr(); LexicalCountH.Clr(); 
121      const int Sents = PosSentBs->GetTrainSents();
122      printf("Counting %d sentences ... ", Sents);
123      for (int SentN = 0; SentN < Sents; SentN++) {
124          const TPosSent& Sent = PosSentBs->GetTrainSent(SentN);
125          const int Elts = Sent.GetElts();
126          int OldState = -1, OldOldState = -1;
127          for (int EltN = 0; EltN < Elts; EltN++) {
128              const TPosElt& Elt = Sent.GetElt(EltN);           
129              const int LemmaId = LemmaH.AddKey(Elt.GetLemmaStr());
130              LemmaH[LemmaId]++; 
131              const int State = int(Elt.GetPosTagType());
132              StateH.AddDat(State)++;
133              Tokens++;
134              if (EltN > 0) { 
135                  IAssert(OldState != -1);
136                  BigramCountH.AddDat(TIntPr(OldState, State))++;
137              }
138              if (EltN > 1) {
139                  IAssert(OldState != -1 && OldOldState != -1);
140                  TrigramCountH.AddDat(TIntTr(OldOldState, OldState, State))++;
141              }
142              LexicalCountH.AddDat(TIntPr(LemmaId, State))++;
143              OldOldState = OldState;
144              OldState = State;
145          }
146      }
147      printf("Done (Lemmas:%d States:%d, Bigrams:%d, Trigrams:%d, Lexical:%d)\n", LemmaH.Len(), 
148          StateH.Len(), BigramCountH.Len(), TrigramCountH.Len(), LexicalCountH.Len());
149      StateProbH.Clr(); BigramProbH.Clr();
150      TrigramProbH.Clr(); LexicalProbH.Clr();
151      printf("Calculating probabilities ... ");
152      {printf("States ");
153      IAssert(Tokens > 0);
154      int KeyId = StateH.FFirstKeyId(); double ProbSum = 0.0; 
155      while (StateH.FNextKeyId(KeyId)) {
156          const int State = StateH.GetKey(KeyId);
157          const int StateCount = StateH[KeyId];        
158          const double Prob = double(StateCount) / double(Tokens);
159          StateProbH.AddDat(State, Prob);
160          ProbSum += Prob;
161      }printf("(%g) ... ", ProbSum);}
162      {printf("Bigrams ");
163      int KeyId = BigramCountH.FFirstKeyId(); double ProbSum = 0.0;
164      while (BigramCountH.FNextKeyId(KeyId)) {
165          const TIntPr& Bigram = BigramCountH.GetKey(KeyId);
166          const int BigramCount = BigramCountH[KeyId];
167          const int OldStateCount = StateH.GetDat(Bigram.Val1); 
168          IAssert(OldStateCount > 0);        
169          const double Prob = double(BigramCount) / double (OldStateCount);
170          BigramProbH.AddDat(Bigram, Prob);
171          ProbSum += Prob;
172      }printf("(%g) ... ", ProbSum);}
173      {printf("Trigrams ");
174      int KeyId = TrigramCountH.FFirstKeyId(); double ProbSum = 0.0;
175      while (TrigramCountH.FNextKeyId(KeyId)) {
176          const TIntTr& Trigram = TrigramCountH.GetKey(KeyId);
177          const int TrigramCount = TrigramCountH[KeyId];
178          TIntPr OldBigram(Trigram.Val1, Trigram.Val2);
179          const int OldBigramCount = BigramCountH.GetDat(OldBigram);
180          IAssert(OldBigramCount > 0);
181          const double Prob = double(TrigramCount) / double(OldBigramCount);
182          TrigramProbH.AddDat(Trigram, Prob);
183          ProbSum += Prob;
184      }printf("(%g) ... ", ProbSum);}
185      {printf("Lexical ");
186      int KeyId = LexicalCountH.FFirstKeyId(); double ProbSum = 0.0;
187      while (LexicalCountH.FNextKeyId(KeyId)) {
188          const TIntPr& Lexical = LexicalCountH.GetKey(KeyId);
189          const int LexicalCount = LexicalCountH[KeyId];
190          const int StateCount = StateH.GetDat(Lexical.Val2); 
191          IAssert(StateCount > 0);
192          const double Prob = double(LexicalCount) / double(StateCount);
193          LexicalProbH.AddDat(Lexical, Prob);
194          ProbSum += Prob;
195      } printf("(%g) ", ProbSum);}
196      printf("Done\n");
197  }
198  void TPosHmm::LearnLambdas(const int& Tokens, const TIntPrIntH& BigramCountH, 
199          const TIntTrIntH& TrigramCountH, const TIntPrIntH& LexicalCountH) {
200      printf("Learning lambdas ... ");
201      double Lambda1 = 0.0, Lambda2 = 0.0, Lambda3 = 0.0;
202      int KeyId = TrigramProbH.FFirstKeyId(); IAssert(Tokens > 1);
203      while (TrigramProbH.FNextKeyId(KeyId)) {
204          const TIntTr& Trigram = TrigramProbH.GetKey(KeyId);
205          const int TrigramCount = TrigramCountH[KeyId];
206          TIntPr OldBigram(Trigram.Val1, Trigram.Val2);
207          const int OldBigramCount = BigramCountH.GetDat(OldBigram);
208          TIntPr Bigram(Trigram.Val2, Trigram.Val3);
209          const int BigramCount = BigramCountH.GetDat(Bigram);
210          const int OldStateCount = StateH.GetDat(Trigram.Val2); 
211          const int StateCount = StateH.GetDat(Trigram.Val3); 
212          const double Val3 = OldBigramCount > 1 ? 
213              double(TrigramCount - 1) / double(OldBigramCount - 1) : 0.0;
214          const double Val2 = OldStateCount > 1 ?
215              double(BigramCount - 1) / double (OldStateCount - 1) : 0.0;
216          const double Val1 = double(StateCount - 1) / double(Tokens - 1);
217          if (Val3 > Val1 && Val3 > Val2) { Lambda3 += TrigramCount; }
218          else if (Val2 > Val1 && Val2 > Val3) { Lambda2 += TrigramCount; }
219          else if (Val1 > Val2 && Val1 > Val3) { Lambda1 += TrigramCount; }
220      } 
221      LambdaV = TFltV::GetV(Lambda1, Lambda2, Lambda3);
222      TLinAlg::NormalizeL1(LambdaV);
223      printf("Done (L1:%.6f, L2:%.6f, L3:%.6f)\n", 
224          LambdaV[0].Val, LambdaV[1].Val, LambdaV[2].Val);
225  }
226  void TPosHmm::LearnUnknown(const PPosSentBs& PosSentBs, 
227          const int& MxLemmaFq, const int& MxSuffixLen) {
228      SuffixH.Clr(); TIntPrIntH StateSuffixCountH;
229      const int Sents = PosSentBs->GetTrainSents();
230      int AllSuffixFq = 0; TIntH StateCountH;
231      printf("Counting %d sentences ... ", Sents);
232      for (int SentN = 0; SentN < Sents; SentN++) {
233          const TPosSent& Sent = PosSentBs->GetTrainSent(SentN);
234          const int Elts = Sent.GetElts();
235          for (int EltN = 0; EltN < Elts; EltN++) {
236              const TPosElt& Elt = Sent.GetElt(EltN);           
237              TStr Lemma = Elt.GetLemmaStr();
238              if (LemmaH.GetDat(Lemma) > MxLemmaFq) { continue; }
239              const int MxChs = TInt::GetMn(Lemma.Len(), MxSuffixLen);
240              for (int Chs = 1; Chs <= MxChs; Chs++) {
241                  AllSuffixFq++;
242                  const int State = int(Elt.GetPosTagType());
243                  StateCountH.AddDat(State)++;
244                  TStr Suffix = Lemma.Right(Chs);
245                  const int SuffixId = SuffixH.AddKey(Suffix);
246                  SuffixH[SuffixId]++; 
247                  TIntPr StateSuffix(State, SuffixId);
248                  StateSuffixCountH.AddDat(StateSuffix)++;
249              }
250          }
251      }
252      SuffixStateProbH.Clr();
253      printf("Probabilities (Suffix:%d) ... ", SuffixH.Len());
254      int KeyId = StateSuffixCountH.FFirstKeyId(); 
255      double ProbSum = 0.0, InvProbSum = 0.0;
256      while (StateSuffixCountH.FNextKeyId(KeyId)) {
257          const TIntPr& StateSuffix = StateSuffixCountH.GetKey(KeyId);
258          const int StateSuffixCount = StateSuffixCountH[KeyId];
259          const int SuffixCount = SuffixH[StateSuffix.Val2];
260          const double Prob = double(StateSuffixCount) / double(SuffixCount);
261          const double SuffixProb = double(SuffixCount) / double(AllSuffixFq);
262          const int StateCount = StateCountH.GetDat(StateSuffix.Val1);
263          const double StateProb = double(StateCount) / double(AllSuffixFq);
264          const double InvProb = Prob * SuffixProb / StateProb;
265          TIntPr SuffixState(StateSuffix.Val2, StateSuffix.Val1);
266          SuffixStateProbH.AddDat(SuffixState, InvProb);
267          ProbSum += Prob; InvProbSum += InvProb;
268      }
269      printf("Done (Prob:%g, Inv:%g)\n", ProbSum, InvProbSum);
270      printf("Learning smoothing weights ... ");
271      int MxProbState = -1; double MxProbStateWgt = 0.0;
272      {double MxProbStateProb = 0.0, MxProbStateSumProb = 0.0;
273      int StateKeyId = StateH.FFirstKeyId();
274      while (StateH.FNextKeyId(StateKeyId)) { 
275          const int CurrState = StateH.GetKey(StateKeyId);
276          const double Prob = StateProbH.GetDat(CurrState);
277          MxProbStateSumProb += Prob;
278          if (Prob > MxProbStateProb) { 
279              MxProbState = CurrState; MxProbStateProb = Prob; 
280          }
281      } MxProbStateWgt = MxProbStateProb / MxProbStateSumProb; }
282      ThetaV.Gen(MxSuffixLen+1); ThetaV.PutAll(0.0);
283      for (int SentN = 0; SentN < Sents; SentN++) {
284          const TPosSent& Sent = PosSentBs->GetTrainSent(SentN);
285          const int Elts = Sent.GetElts();
286          for (int EltN = 0; EltN < Elts; EltN++) {
287              const TPosElt& Elt = Sent.GetElt(EltN);           
288              const int EltState = int(Elt.GetPosTagType());
289              TStr Lemma = Elt.GetLemmaStr();
290              if (LemmaH.GetDat(Lemma) > MxLemmaFq) { continue; }
291              if (EltState == MxProbState) { ThetaV[0] += MxProbStateWgt; }
292              const int MxChs = TInt::GetMn(Lemma.Len(), MxSuffixLen);
293              for (int Chs = 1; Chs <= MxChs; Chs++) {
294                  const int State = int(Elt.GetPosTagType());
295                  const int SuffixId = SuffixH.GetKeyId(Lemma.Right(Chs));
296                  int MxState = -1; double MxProb = 0.0, SumProb = 0.0;
297                  {int StateKeyId = StateH.FFirstKeyId();
298                  while (StateH.FNextKeyId(StateKeyId)) { 
299                      const int CurrState = StateH.GetKey(StateKeyId);
300                      TIntPr SuffixState(SuffixId, CurrState);
301                      if (!SuffixStateProbH.IsKey(SuffixState)) { continue; }
302                      const double Prob = SuffixStateProbH.GetDat(SuffixState);
303                      SumProb += Prob;
304                      if (Prob > MxProb) { MxState = CurrState; MxProb = Prob; }
305                  }}
306                  if (MxState == State) { ThetaV[Chs] += double(Chs) * MxProb / SumProb; }
307              }
308          }
309      }
310      TLinAlg::NormalizeL1(ThetaV);
311      printf("Done\n");
312      TLAMisc::PrintTFltV(ThetaV, "Theta");
313  }
314  double TPosHmm::GetTrigramProb(const int& OldOldState, 
315          const int& OldState, const int& State) const {
316      TIntPr Bigram(OldState, State);
317      TIntTr Trigram(OldOldState, OldState, State);
318      const double UnigramProb = StateProbH.IsKey(State) ? 
319          StateProbH.GetDat(State) : 0.0;
320      const double BigramProb = BigramProbH.IsKey(Bigram) ? 
321          BigramProbH.GetDat(Bigram) : 0.0;
322      const double TrigramProb = TrigramProbH.IsKey(Trigram) ? 
323          TrigramProbH.GetDat(Trigram) : 0.0; 
324      return LambdaV[0] * UnigramProb + LambdaV[1] * BigramProb + LambdaV[2] * TrigramProb;
325  }
326  double TPosHmm::GetLexicalProb(const TStr& Lemma, const int& State) const {
327      if (LemmaH.IsKey(Lemma)) {
328          const int LemmaId = LemmaH.GetKeyId(Lemma);
329          TIntPr Lexical(LemmaId, State);
330          return LexicalProbH.IsKey(Lexical) ? LexicalProbH.GetDat(Lexical) : 0.0;
331      } else {
332          double Prob = ThetaV[0] * StateProbH.GetDat(State);
333          const int MxChs = Lemma.Len(); int Chs;
334          for (Chs = 1; Chs <= MxChs; Chs++) {
335              TStr Suffix = Lemma.Right(Chs);
336              if (!SuffixH.IsKey(Suffix)) { break; }
337              const int SuffixId = SuffixH.GetKeyId(Suffix);
338              TIntPr SuffixState(SuffixId, State);
339              if (!SuffixStateProbH.IsKey(SuffixState)) { break; }
340              const double SuffixProb = SuffixStateProbH.GetDat(SuffixState);
341              Prob += ThetaV[Chs] * SuffixProb;
342          }
343          return Prob;
344      }
345      return 0.0;
346  }
347  TPosHmm::TPosHmm(const PPosSentBs& PosSentBs) {
348      int Tokens; TIntPrIntH BigramCountH; 
349      TIntTrIntH TrigramCountH; TIntPrIntH LexicalCountH;
350      LearnProb(PosSentBs, Tokens, BigramCountH, TrigramCountH, LexicalCountH);
351      LearnLambdas(Tokens, BigramCountH, TrigramCountH, LexicalCountH);
352      LearnUnknown(PosSentBs, 10, 10);
353  }
354  void TPosHmm::Tag(TPosSent& Sent) {
355      if (Sent.GetElts() < 4) { return; }
356      const int States = StateH.Len();
357      const int BeginState = int(pttBegining), EndState = int(pttEnd);
358      const int BeginStateId = StateH.GetKeyId(BeginState);
359      const int EndStateId = StateH.GetKeyId(EndState);
360      const int Elts = Sent.GetElts();
361      TFltVV MxProbVV(Elts, States); MxProbVV.PutAll(0.0);
362      TIntVV BackVV(Elts, States); BackVV.PutAll(-1);
363      { 
364          const int FirstEltN = 2;
365          TStr Lemma = Sent.GetElt(FirstEltN).GetLemmaStr();
366          for (int StateId = 0; StateId < States; StateId++) {
367              const int State = StateH.GetKey(StateId);
368              const double TrigramProb = GetTrigramProb(BeginState, BeginState, State);
369              const double LexicalProb = GetLexicalProb(Lemma, State);
370              const double Prob = TrigramProb * LexicalProb;
371              MxProbVV(FirstEltN, StateId) = Prob;
372              BackVV(FirstEltN, StateId) = BeginStateId;
373              BackVV(0, StateId) = BackVV(1, StateId) = -1;
374          }
375          BackVV(1, BeginStateId) = BeginStateId;
376      }
377      for (int EltN = 3; EltN < (Elts-1); EltN++) {
378          TStr Lemma = Sent.GetElt(EltN).GetLemmaStr();
379          bool PositiveMoveP = false;
380          for (int StateId = 0; StateId < States; StateId++) {
381              const int State = StateH.GetKey(StateId);
382              int MxOldStateId = -1; double MxProb = 0.0;
383              for (int OldStateId = 0; OldStateId < States; OldStateId++) {
384                  const int OldState = StateH.GetKey(OldStateId);
385                  const int OldOldStateId = BackVV(EltN-1, OldStateId);
386                  if (OldOldStateId == -1) { continue; }
387                  const int OldOldState = StateH.GetKey(OldOldStateId);
388                  const double OldProb = MxProbVV(EltN-1, OldStateId);
389                  const double TrigramProb = GetTrigramProb(OldOldState, OldState, State);
390                  const double LexicalProb = GetLexicalProb(Lemma, State);
391                  const double Prob = OldProb * TrigramProb * LexicalProb;
392                  if (Prob > MxProb) { MxProb = Prob; MxOldStateId = OldStateId; }
393              }
394              MxProbVV(EltN, StateId) = MxProb;
395              BackVV(EltN, StateId) = MxOldStateId;
396              PositiveMoveP = PositiveMoveP || (MxOldStateId != -1);
397          }
398          IAssert(PositiveMoveP);
399      }
400      const int LastEltN = Elts-1;
401      int MxOldStateId = -1; double MxProb = 0.0;
402      for (int OldStateId = 0; OldStateId < States; OldStateId++) {
403          const int OldState = StateH.GetKey(OldStateId);
404          const int OldOldStateId = BackVV(LastEltN-1, OldStateId);
405          if (OldOldStateId == -1) { continue; }
406          const int OldOldState = StateH.GetKey(OldOldStateId);
407          const double OldProb = MxProbVV(LastEltN-1, OldStateId);
408          const double TrigramProb = GetTrigramProb(OldOldState, OldState, EndState);
409          const double Prob = OldProb * TrigramProb;
410          if (Prob > MxProb) { MxProb = Prob; MxOldStateId = OldStateId; }
411      } IAssert(MxOldStateId != -1);
412      Sent.GetElt(LastEltN).PutPosTagType(pttEnd); 
413      for (int EltN = Elts-2; EltN >= 0; EltN--) {
414          const int MxOldState = StateH.GetKey(MxOldStateId);
415          const TPosTagType MxTagType = TPosTagType(MxOldState);
416          Sent.GetElt(EltN).PutPosTagType(MxTagType);
417          MxOldStateId = BackVV(EltN, MxOldStateId);
418          IAssert((MxOldStateId != -1) || (EltN == 0));
419      }
420  }
421  int TPosHmm::GetKnowns(const TPosSent& Sent) const {
422      int Knowns = 0;
423      for (int EltN = 2; EltN < (Sent.GetElts()-1); EltN++) {
424          if (IsKnown(Sent.GetElt(EltN).GetLemmaStr())) { Knowns++; }
425      }
426      return Knowns;
427  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hldoc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-postag.cpp</div>
                </div>
                <div class="column column_space"><pre><code>47    for (int WordIdN=0; WordIdN<WordIdFqKdV.Len(); WordIdN++){
48      int WordId=WordIdFqKdV[WordIdN].Key;
49      double WordFq=WordIdFqKdV[WordIdN].Dat/SumWordFq;
50      WordFqIdKdV.Add(TFltIntKd(WordFq, WordId));
</pre></code></div>
                <div class="column column_space"><pre><code>76      for (int PartN = 0; PartN < PartTokV.Len(); PartN++) {
77          PXmlTok PartTok = PartTokV[PartN];
78          const int SubParts = PartTok->GetSubToks(); AllSubParts += SubParts;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    