
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.867494824016563%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronfit.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "kronecker.h"
3  int main(int argc, char* argv[]) {
4    Env = TEnv(argc, argv, TNotify::StdNotify);
5    Env.PrepArgs(TStr::Fmt("Kronecker graphs. build: %s, %s. Time: %s", __TIME__, __DATE__, TExeTm::GetCurTm()));
6    TExeTm ExeTm;
7    Try
8    Env = TEnv(argc, argv, TNotify::StdNotify);
9    const TStr InFNm = Env.GetIfArgPrefixStr("-i:", "../as20graph.txt", "Input graph file (single directed edge per line)");
10    TStr OutFNm = Env.GetIfArgPrefixStr("-o:", "", "Output file prefix");
11    const TInt NZero = Env.GetIfArgPrefixInt("-n0:", 2, "Innitiator matrix size");
12    const TStr InitMtx = Env.GetIfArgPrefixStr("-m:", "0.9 0.7; 0.5 0.2", "Init Gradient Descent Matrix (R=random)").GetLc();
13    const TStr Perm = Env.GetIfArgPrefixStr("-p:", "d", "Initial node permutation: d:Degree, r:Random, o:Order").GetLc();
14    const TInt GradIter = Env.GetIfArgPrefixInt("-gi:", 50, "Gradient descent iterations");
15    const TFlt LrnRate = Env.GetIfArgPrefixFlt("-l:", 1e-5, "Learning rate");
16    const TFlt MnStep = Env.GetIfArgPrefixFlt("-mns:", 0.005, "Minimum gradient step");
17    const TFlt MxStep = Env.GetIfArgPrefixFlt("-mxs:", 0.05, "Maximum gradient step");
18    const TInt WarmUp =  Env.GetIfArgPrefixInt("-w:", 10000, "Samples to warm up");
19    const TInt NSamples = Env.GetIfArgPrefixInt("-s:", 100000, "Samples per gradient estimation");
20    const bool ScaleInitMtx = Env.GetIfArgPrefixBool("-sim:", true, "Scale the initiator to match the number of edges");
21    const TFlt PermSwapNodeProb = Env.GetIfArgPrefixFlt("-nsp:", 1.0, "Probability of using NodeSwap (vs. EdgeSwap) MCMC proposal distribution");
22    if (OutFNm.Empty()) { OutFNm = TStr::Fmt("%s-fit%d", InFNm.GetFMid().CStr(), NZero()); }
23    PNGraph G;
24    if (InFNm.GetFExt().GetLc()==".ungraph") {
25      TFIn FIn(InFNm);  G=TSnap::ConvertGraph<PNGraph>(TUNGraph::Load(FIn), true); }
26    else if (InFNm.GetFExt().GetLc()==".ngraph") {
27      TFIn FIn(InFNm);  G=TNGraph::Load(FIn); }
28    else {
29      G = TSnap::LoadEdgeList<PNGraph>(InFNm, 0, 1);
30    }
31    TKronMtx InitKronMtx = InitMtx=="r" ? TKronMtx::GetRndMtx(NZero, 0.1) : TKronMtx::GetMtx(InitMtx);
32    InitKronMtx.Dump("INIT PARAM", true);
33    TKroneckerLL KronLL(G, InitKronMtx, PermSwapNodeProb);
34    if (ScaleInitMtx) {
35      InitKronMtx.SetForEdges(G->GetNodes(), G->GetEdges()); }
36    KronLL.InitLL(G, InitKronMtx);
37    InitKronMtx.Dump("SCALED PARAM", true);
38    KronLL.SetPerm(Perm.GetCh(0));
39    double LogLike = 0;
40    LogLike = KronLL.GradDescent(GradIter, LrnRate, MnStep, MxStep, WarmUp, NSamples);
41    const TKronMtx& FitMtx = KronLL.GetProbMtx();
42    FILE *F = fopen(OutFNm.CStr(), "w");
43    fprintf(F, "Input\t%s\n", InFNm.CStr());
44    TStrV ParamV; Env.GetCmLn().SplitOnAllCh(' ', ParamV);
45    fprintf(F, "Command line options\n");
46    for (int i = 0; i < ParamV.Len(); i++) {
47      fprintf(F, "\t%s\n", ParamV[i].CStr()+(ParamV[i][0]=='-'?1:0)); }
48    fprintf(F, "Loglikelihood\t%10.2f\n", LogLike);
<span onclick='openModal()' class='match'>49    fprintf(F, "Absolute error (based on expected number of edges)\t%f\n", KronLL.GetAbsErr());
50    fprintf(F, "RunTime\t%g\n", ExeTm.GetSecs());
51    fprintf(F, "Estimated initiator\t%s\n", FitMtx.GetMtxStr().CStr());
52    fclose(F);
53    Catch
54    printf("\nrun time: %s (%s)\n", ExeTm.GetTmStr(), TSecTm::GetCurTm().GetTmStr().CStr());
</span>55    return 0;
56  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-voting.cpp</h3>
            <pre><code>1  #include <nano/node/common.hpp>
2  #include <nano/node/voting.hpp>
3  #include <nano/test_common/system.hpp>
4  #include <nano/test_common/testutil.hpp>
5  #include <gtest/gtest.h>
6  using namespace std::chrono_literals;
7  namespace nano
8  {
9  TEST (local_vote_history, basic)
10  {
11  	nano::local_vote_history history{ nano::dev::network_params.voting };
12  	ASSERT_FALSE (history.exists (1));
13  	ASSERT_FALSE (history.exists (2));
<span onclick='openModal()' class='match'>14  	ASSERT_TRUE (history.votes (1).empty ());
15  	ASSERT_TRUE (history.votes (2).empty ());
16  	auto vote1a (std::make_shared<nano::vote> ());
17  	ASSERT_EQ (0, history.size ());
18  	history.add (1, 2, vote1a);
19  	ASSERT_EQ (1, history.size ());
20  	ASSERT_TRUE (history.exists (1));
</span>21  	ASSERT_FALSE (history.exists (2));
22  	auto votes1a (history.votes (1));
23  	ASSERT_FALSE (votes1a.empty ());
24  	ASSERT_EQ (1, history.votes (1, 2).size ());
25  	ASSERT_TRUE (history.votes (1, 1).empty ());
26  	ASSERT_TRUE (history.votes (1, 3).empty ());
27  	ASSERT_TRUE (history.votes (2).empty ());
28  	ASSERT_EQ (1, votes1a.size ());
29  	ASSERT_EQ (vote1a, votes1a[0]);
30  	auto vote1b (std::make_shared<nano::vote> ());
31  	history.add (1, 2, vote1b);
32  	auto votes1b (history.votes (1));
33  	ASSERT_EQ (1, votes1b.size ());
34  	ASSERT_EQ (vote1b, votes1b[0]);
35  	ASSERT_NE (vote1a, votes1b[0]);
36  	auto vote2 (std::make_shared<nano::vote> ());
37  	vote2->account.dwords[0]++;
38  	ASSERT_EQ (1, history.size ());
39  	history.add (1, 2, vote2);
40  	ASSERT_EQ (2, history.size ());
41  	auto votes2 (history.votes (1));
42  	ASSERT_EQ (2, votes2.size ());
43  	ASSERT_TRUE (vote1b == votes2[0] || vote1b == votes2[1]);
44  	ASSERT_TRUE (vote2 == votes2[0] || vote2 == votes2[1]);
45  	auto vote3 (std::make_shared<nano::vote> ());
46  	vote3->account.dwords[1]++;
47  	history.add (1, 3, vote3);
48  	ASSERT_EQ (1, history.size ());
49  	auto votes3 (history.votes (1));
50  	ASSERT_EQ (1, votes3.size ());
51  	ASSERT_TRUE (vote3 == votes3[0]);
52  }
53  }
54  TEST (vote_generator, cache)
55  {
56  	nano::test::system system (1);
57  	auto & node (*system.nodes[0]);
58  	auto epoch1 = system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
59  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
60  	node.generator.add (epoch1->root (), epoch1->hash ());
61  	ASSERT_TIMELY (1s, !node.history.votes (epoch1->root (), epoch1->hash ()).empty ());
62  	auto votes (node.history.votes (epoch1->root (), epoch1->hash ()));
63  	ASSERT_FALSE (votes.empty ());
64  	ASSERT_TRUE (std::any_of (votes[0]->hashes.begin (), votes[0]->hashes.end (), [hash = epoch1->hash ()] (nano::block_hash const & hash_a) { return hash_a == hash; }));
65  }
66  TEST (vote_generator, multiple_representatives)
67  {
68  	nano::test::system system (1);
69  	auto & node (*system.nodes[0]);
70  	nano::keypair key1, key2, key3;
71  	auto & wallet (*system.wallet (0));
72  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
73  	wallet.insert_adhoc (key1.prv);
74  	wallet.insert_adhoc (key2.prv);
75  	wallet.insert_adhoc (key3.prv);
76  	auto const amount = 100 * nano::Gxrb_ratio;
77  	wallet.send_sync (nano::dev::genesis_key.pub, key1.pub, amount);
78  	wallet.send_sync (nano::dev::genesis_key.pub, key2.pub, amount);
79  	wallet.send_sync (nano::dev::genesis_key.pub, key3.pub, amount);
80  	ASSERT_TIMELY (3s, node.balance (key1.pub) == amount && node.balance (key2.pub) == amount && node.balance (key3.pub) == amount);
81  	wallet.change_sync (key1.pub, key1.pub);
82  	wallet.change_sync (key2.pub, key2.pub);
83  	wallet.change_sync (key3.pub, key3.pub);
84  	ASSERT_TRUE (node.weight (key1.pub) == amount && node.weight (key2.pub) == amount && node.weight (key3.pub) == amount);
85  	node.wallets.compute_reps ();
86  	ASSERT_EQ (4, node.wallets.reps ().voting);
87  	auto hash = wallet.send_sync (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 1);
88  	auto send = node.block (hash);
89  	ASSERT_NE (nullptr, send);
90  	ASSERT_TIMELY (5s, node.history.votes (send->root (), send->hash ()).size () == 4);
91  	auto votes (node.history.votes (send->root (), send->hash ()));
92  	for (auto const & account : { key1.pub, key2.pub, key3.pub, nano::dev::genesis_key.pub })
93  	{
94  		auto existing (std::find_if (votes.begin (), votes.end (), [&account] (std::shared_ptr<nano::vote> const & vote_a) -> bool {
95  			return vote_a->account == account;
96  		}));
97  		ASSERT_NE (votes.end (), existing);
98  	}
99  }
100  TEST (vote_spacing, basic)
101  {
102  	nano::vote_spacing spacing{ std::chrono::milliseconds{ 100 } };
103  	nano::root root1{ 1 };
104  	nano::root root2{ 2 };
105  	nano::block_hash hash3{ 3 };
106  	nano::block_hash hash4{ 4 };
107  	nano::block_hash hash5{ 5 };
108  	ASSERT_EQ (0, spacing.size ());
109  	ASSERT_TRUE (spacing.votable (root1, hash3));
110  	spacing.flag (root1, hash3);
111  	ASSERT_EQ (1, spacing.size ());
112  	ASSERT_TRUE (spacing.votable (root1, hash3));
113  	ASSERT_FALSE (spacing.votable (root1, hash4));
114  	spacing.flag (root2, hash5);
115  	ASSERT_EQ (2, spacing.size ());
116  }
117  TEST (vote_spacing, prune)
118  {
119  	auto length = std::chrono::milliseconds{ 100 };
120  	nano::vote_spacing spacing{ length };
121  	nano::root root1{ 1 };
122  	nano::root root2{ 2 };
123  	nano::block_hash hash3{ 3 };
124  	nano::block_hash hash4{ 4 };
125  	spacing.flag (root1, hash3);
126  	ASSERT_EQ (1, spacing.size ());
127  	std::this_thread::sleep_for (length);
128  	spacing.flag (root2, hash4);
129  	ASSERT_EQ (1, spacing.size ());
130  }
131  TEST (vote_spacing, vote_generator)
132  {
133  	nano::node_config config;
134  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
135  	config.active_elections_hinted_limit_percentage = 0; 
136  	nano::test::system system;
137  	nano::node_flags node_flags;
138  	node_flags.disable_search_pending = true;
139  	auto & node = *system.add_node (config, node_flags);
140  	auto & wallet = *system.wallet (0);
141  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
142  	nano::state_block_builder builder;
143  	auto send1 = builder.make_block ()
144  				 .account (nano::dev::genesis_key.pub)
145  				 .previous (nano::dev::genesis->hash ())
146  				 .representative (nano::dev::genesis_key.pub)
147  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
148  				 .link (nano::dev::genesis_key.pub)
149  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
150  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
151  				 .build_shared ();
152  	auto send2 = builder.make_block ()
153  				 .account (nano::dev::genesis_key.pub)
154  				 .previous (nano::dev::genesis->hash ())
155  				 .representative (nano::dev::genesis_key.pub)
156  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
157  				 .link (nano::dev::genesis_key.pub)
158  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
159  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
160  				 .build_shared ();
161  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send1).code);
162  	ASSERT_EQ (0, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts));
163  	node.generator.add (nano::dev::genesis->hash (), send1->hash ());
164  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts) == 1);
165  	ASSERT_FALSE (node.ledger.rollback (node.store.tx_begin_write (), send1->hash ()));
166  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send2).code);
167  	node.generator.add (nano::dev::genesis->hash (), send2->hash ());
168  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_spacing) == 1);
169  	ASSERT_EQ (1, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts));
170  	std::this_thread::sleep_for (config.network_params.voting.delay);
171  	node.generator.add (nano::dev::genesis->hash (), send2->hash ());
172  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts) == 2);
173  }
174  TEST (vote_spacing, rapid)
175  {
176  	nano::node_config config;
177  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
178  	config.active_elections_hinted_limit_percentage = 0; 
179  	nano::test::system system;
180  	nano::node_flags node_flags;
181  	node_flags.disable_search_pending = true;
182  	auto & node = *system.add_node (config, node_flags);
183  	auto & wallet = *system.wallet (0);
184  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
185  	nano::state_block_builder builder;
186  	auto send1 = builder.make_block ()
187  				 .account (nano::dev::genesis_key.pub)
188  				 .previous (nano::dev::genesis->hash ())
189  				 .representative (nano::dev::genesis_key.pub)
190  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
191  				 .link (nano::dev::genesis_key.pub)
192  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
193  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
194  				 .build_shared ();
195  	auto send2 = builder.make_block ()
196  				 .account (nano::dev::genesis_key.pub)
197  				 .previous (nano::dev::genesis->hash ())
198  				 .representative (nano::dev::genesis_key.pub)
199  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
200  				 .link (nano::dev::genesis_key.pub)
201  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
202  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
203  				 .build_shared ();
204  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send1).code);
205  	node.generator.add (nano::dev::genesis->hash (), send1->hash ());
206  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts) == 1);
207  	ASSERT_FALSE (node.ledger.rollback (node.store.tx_begin_write (), send1->hash ()));
208  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send2).code);
209  	node.generator.add (nano::dev::genesis->hash (), send2->hash ());
210  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_spacing) == 1);
211  	ASSERT_TIMELY (3s, 1 == node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts));
212  	std::this_thread::sleep_for (config.network_params.voting.delay);
213  	node.generator.add (nano::dev::genesis->hash (), send2->hash ());
214  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::vote_generator, nano::stat::detail::generator_broadcasts) == 2);
215  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronfit.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-voting.cpp</div>
                </div>
                <div class="column column_space"><pre><code>49    fprintf(F, "Absolute error (based on expected number of edges)\t%f\n", KronLL.GetAbsErr());
50    fprintf(F, "RunTime\t%g\n", ExeTm.GetSecs());
51    fprintf(F, "Estimated initiator\t%s\n", FitMtx.GetMtxStr().CStr());
52    fclose(F);
53    Catch
54    printf("\nrun time: %s (%s)\n", ExeTm.GetTmStr(), TSecTm::GetCurTm().GetTmStr().CStr());
</pre></code></div>
                <div class="column column_space"><pre><code>14  	ASSERT_TRUE (history.votes (1).empty ());
15  	ASSERT_TRUE (history.votes (2).empty ());
16  	auto vote1a (std::make_shared<nano::vote> ());
17  	ASSERT_EQ (0, history.size ());
18  	history.add (1, 2, vote1a);
19  	ASSERT_EQ (1, history.size ());
20  	ASSERT_TRUE (history.exists (1));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    