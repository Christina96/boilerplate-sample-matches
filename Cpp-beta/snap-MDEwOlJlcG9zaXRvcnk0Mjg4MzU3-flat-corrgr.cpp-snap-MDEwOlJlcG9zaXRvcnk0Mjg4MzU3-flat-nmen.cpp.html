
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.435155412647376%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</h3>
            <pre><code>1  #include "corrgr.h"
2  void TCorrGroups::GetCorrSimVV(TFltVV& SimVV) const {
3    int Vars=GetVars();
4    SimVV.Gen(Vars, Vars);
5    for (int VarN1=0; VarN1<Vars; VarN1++){
6      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
7      TNotify::OnStatus(Notify, MsgStr);
8      SimVV.At(VarN1, VarN1)=1;
9      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
10        PCorr Corr=TCorr::New(VarValVV[VarN1], VarValVV[VarN2]);
11        SimVV.At(VarN1, VarN2)=fabs(Corr->GetCorrCf());
12        SimVV.At(VarN2, VarN1)=fabs(Corr->GetCorrCf());
13      }
14    }
15    TNotify::OnStatus(Notify, "\n");
16  }
17  void TCorrGroups::GetEuclSimVV(TFltVV& SimVV) const {
18    int Vars=GetVars();
19    SimVV.Gen(Vars, Vars);
20    for (int VarN1=0; VarN1<Vars; VarN1++){
21      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
22      TNotify::OnStatus(Notify, MsgStr);
23      SimVV.At(VarN1, VarN1)=1;
24      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
25        double Sim=0;
26        for (int ValN=0; ValN<VarValVV[VarN1].Len(); ValN++){
27          double ValSim=VarValVV[VarN1][ValN]-VarValVV[VarN2][ValN];
28          Sim+=TMath::Sqr(ValSim);
29        }
30        Sim=-sqrt(Sim);
31        SimVV.At(VarN1, VarN2)=Sim;
32        SimVV.At(VarN2, VarN1)=Sim;
33      }
34    }
35    TNotify::OnStatus(Notify, "\n");
36  }
37  void TCorrGroups::GetSimVVFromData(TFltVV& SimVV) const {
38    IAssert(VarValVV[0].Len()==VarValVV.Len());
39    SimVV.Gen(VarValVV.Len(), VarValVV.Len());
40    for (int Y=0; Y<VarValVV.Len(); Y++){
41      for (int X=0; X<VarValVV.Len(); X++){
42        SimVV.At(Y, X)=VarValVV[Y][X];
43      }
44    }
45  }
46  void TCorrGroups::SetGroups(const double& _CorrCfTsh){
47    TNotify::OnNotify(Notify, ntInfo,
48     "Calculating Correlation Groups for Threshold "+TFlt::GetStr(CorrCfTsh));
49    CorrCfTsh=_CorrCfTsh;
50    int Vars=GetVars();
51    TFltVV CorrCfVV; GetCorrSimVV(CorrCfVV);
52    PGraph Graph=TGGraph::New();
53    for (int VarN=0; VarN<Vars; VarN++){
54      TStr VarNm=TInt::GetStr(VarN);
55      PVrtx Vrtx=PVrtx(new TGVrtx(VarNm));
56      Graph->AddVrtx(Vrtx);
57    }
58    int GoodCorrs=0;
59    for (int VarN1=0; VarN1<Vars; VarN1++){
60      for (int VarN2=VarN1; VarN2<Vars; VarN2++){
61        if ((VarN1!=VarN2)&&(fabs(CorrCfVV.At(VarN1, VarN2))>CorrCfTsh)){
62          GoodCorrs++;
63          TStr MsgStr=TStr("Good Correlations:")+TInt::GetStr(GoodCorrs)+"\r";
64          TNotify::OnStatus(Notify, MsgStr);
65          TStr VrtxNm1=TInt::GetStr(VarN1);
66          TStr VrtxNm2=TInt::GetStr(VarN2);
67          TStr ENm=TFlt::GetStr(CorrCfVV.At(VarN1, VarN2), "%0.2f");
68          PVrtx Vrtx1=Graph->GetVrtx(VrtxNm1);
69          PVrtx Vrtx2=Graph->GetVrtx(VrtxNm2);
70          PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, ENm, false));
71          Graph->AddEdge(Edge);
72        }
73      }
74    }
75    TNotify::OnStatus(Notify, "\n");
76    VarNVV.Clr();
77    TBoolV VarUsedV(Vars);
78    {for (int VarN=0; VarN<Vars; VarN++){
79      if (!VarUsedV[VarN]){
80        VarUsedV[VarN]=true;
81        VarNVV.Add();
82        TStr VrtxNm=TInt::GetStr(VarN);
83        PVrtx Vrtx=Graph->GetVrtx(VrtxNm);
84        TVrtxV ConnVrtxV;
85        Graph->GetConnVrtxV(Vrtx, ConnVrtxV);
86        for (int ConnVrtxN=0; ConnVrtxN<ConnVrtxV.Len(); ConnVrtxN++){
87          PVrtx ConnVrtx=ConnVrtxV[ConnVrtxN];
88          TStr ConnVrtxVNm=ConnVrtx->GetVNm();
89          int ConnVarN=ConnVrtxVNm.GetInt();
90          VarNVV.Last().Add(ConnVarN);
91          VarUsedV[ConnVrtx->GetVId()]=true;
92        }
93      }
94    }}
95    TNotify::OnNotify(Notify, ntInfo, "... Done.");
96  }
97  void TCorrGroups::GetGroupCentroid(const TIntV& VarNV, TMomV& VarValMomV) const {
98    int Recs=GetRecs();
99    TMom::NewV(VarValMomV, Recs);
100    for (int VarNN=0; VarNN<VarNV.Len(); VarNN++){
101      int VarN=VarNV[VarNN];
102      for (int RecN=0; RecN<Recs; RecN++){
103        double Val=VarValVV[VarN][RecN];
104        VarValMomV[RecN]->Add(Val);
105      }
106    }
107    TMom::DefV(VarValMomV);
108  }
109  PGraph TCorrGroups::GetHClustGraph(const TFltVV& SimVV) const {
110    PGraph HClustGraph=TGGraph::New();
111    TVrtxV VrtxV(GetVars()); TVec<TIntV> VarNVV(GetVars());
112    for (int VarN=0; VarN<GetVars(); VarN++){
113      PVrtx Vrtx=PVrtx(new TGVrtx(VarN, GetVarNm(VarN)));
114      HClustGraph->AddVrtx(Vrtx);
115      VrtxV[VarN]=Vrtx; VarNVV[VarN].Add(VarN);
116    }
117    for (int HClustJoinN=0; HClustJoinN<GetVars()-1; HClustJoinN++){
118      printf("Join %d\r", HClustJoinN);
119      bool FirstMx=true; double MxMeanSim=0; int MxVrtxN1=-1; int MxVrtxN2=-1;
120      for (int VrtxN1=0; VrtxN1<VrtxV.Len(); VrtxN1++){
121        PVrtx Vrtx1=VrtxV[VrtxN1];
122        if (!Vrtx1.Empty()){
123          for (int VrtxN2=VrtxN1+1; VrtxN2<VrtxV.Len(); VrtxN2++){
124            PVrtx Vrtx2=VrtxV[VrtxN2];
125            if (!Vrtx2.Empty()){
126              TIntV& VarNV1=VarNVV[VrtxN1];
127              TIntV& VarNV2=VarNVV[VrtxN2];
128              double SumSim=0;
129              for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
130                for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
131                  SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
132                }
133              }
134              double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
135              if ((FirstMx)||(MeanSim>MxMeanSim)){
136                FirstMx=false;
137                MxMeanSim=MeanSim; MxVrtxN1=VrtxN1; MxVrtxN2=VrtxN2;
138              }
139            }
140          }
141        }
142      }
143      PVrtx JoinVrtx=PVrtx(new TGVrtx()); HClustGraph->AddVrtx(JoinVrtx);
144      PEdge JoinEdge1=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN1]));
145      PEdge JoinEdge2=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN2]));
146      HClustGraph->AddEdge(JoinEdge1); HClustGraph->AddEdge(JoinEdge2);
147      JoinVrtx->PutWgt(MxMeanSim);
148      VrtxV[MxVrtxN1]=JoinVrtx; VrtxV[MxVrtxN2]=NULL;
149      VarNVV[MxVrtxN1].AddV(VarNVV[MxVrtxN2]); VarNVV[MxVrtxN2].Clr();
150    }
151    return HClustGraph;
152  }
153  PGraph TCorrGroups::GetHClustGraph() const {
154    TFltVV SimVV; GetCorrSimVV(SimVV);
155    return GetHClustGraph(SimVV);
156  }
157  void TCorrGroups::SetHClustGroups(const TFltVV& SimVV, const int& Groups){
158    int Vars=GetVars();
159    IAssert((0<Groups)&&(Groups<=Vars));
160    VarNVV.Gen(Vars);
161    for (int VarN=0; VarN<Vars; VarN++){VarNVV[VarN].Add(VarN);}
162    for (int HClustJoinN=0; HClustJoinN<Vars-Groups; HClustJoinN++){
163      printf("Join %d\r", HClustJoinN);
164      bool FirstMx=true; double MxMeanSim=0; int MxVarNVN1=-1; int MxVarNVN2=-1;
165      for (int VarNVN1=0; VarNVN1<VarNVV.Len(); VarNVN1++){
166        for (int VarNVN2=VarNVN1+1; VarNVN2<VarNVV.Len(); VarNVN2++){
167          TIntV& VarNV1=VarNVV[VarNVN1];
168          TIntV& VarNV2=VarNVV[VarNVN2];
169          double SumSim=0;
170          for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
171            for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
172              SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
173            }
174          }
175          double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
176          if ((FirstMx)||(MeanSim>MxMeanSim)){
177            FirstMx=false;
178            MxMeanSim=MeanSim; MxVarNVN1=VarNVN1; MxVarNVN2=VarNVN2;
179          }
180        }
181      }
182      VarNVV[MxVarNVN1].AddV(VarNVV[MxVarNVN2]);
183      VarNVV.Del(MxVarNVN2);
184    }
185  }
186  void TCorrGroups::SetKMeansGroups(const int& Groups, const int& Trials){
187    TRnd Rnd(1); int Vars=GetVars(); int Recs=GetRecs();
188    IAssert((0<Groups)&&(Groups<=Vars));
189    double BestQual=0; TVec<TIntV> BestVarNVV;
190    for (int TrialN=0; TrialN<Trials; TrialN++){
191      printf("Trial: %d\n", TrialN);
192      TVec<TFltV> CentrVarNV(Groups);
193      for (int CentrN=0; CentrN<Groups; CentrN++){
194        int CentrVarN=Rnd.GetUniDevInt(Vars);
195        CentrVarNV[CentrN]=VarValVV[CentrVarN];
196      }
197      double PrevQual=0; double Qual=0;
198      do {
199        PrevQual=Qual;
200        VarNVV.Gen(Groups);
201        for (int VarN=0; VarN<Vars; VarN++){
202          TFltV SimV(Groups);
203          for (int CentrN=0; CentrN<Groups; CentrN++){
204            PCorr Corr=TCorr::New(CentrVarNV[CentrN], VarValVV[VarN]);
205            SimV[CentrN]=fabs(Corr->GetCorrCf());
206          }
207          int BestGroupN=SimV.GetMxValN();
208          VarNVV[BestGroupN].Add(VarN);
209        }
210        for (int CentrN=0; CentrN<Groups; CentrN++){
211          TMomV VarValMomV; GetGroupCentroid(VarNVV[CentrN], VarValMomV);
212          for (int RecN=0; RecN<Recs; RecN++){
213            if (VarValMomV[RecN]->IsUsable()){
214              CentrVarNV[CentrN][RecN]=VarValMomV[RecN]->GetMedian();
215            } else {
216              CentrVarNV[CentrN][RecN]=0;
217            }
218          }
219        }
220        Qual=0;
221        for (int GroupN=0; GroupN<Groups; GroupN++){
222          int GroupVars=VarNVV[GroupN].Len();
223          for (int VarNN=0; VarNN<GroupVars; VarNN++){
224            int VarN=VarNVV[GroupN][VarNN];
225            PCorr Corr=TCorr::New(CentrVarNV[GroupN], VarValVV[VarN]);
226            double Sim=fabs(Corr->GetCorrCf());
227            Qual+=TMath::Sqr(Sim);
228          }
229        }
230        if ((PrevQual==0)||(Qual<BestQual)){
231          BestQual=Qual; BestVarNVV=VarNVV;
232        }
233        if (PrevQual!=0){
234          printf("   %g (%g)\n", Qual, PrevQual/Qual);}
235      } while ((PrevQual==0)||(PrevQual/Qual<0.9999));
236    }
237    VarNVV=BestVarNVV;
238  }
239  PCorrGroups TCorrGroups::LoadTxtVarCVal(const TStr& FNm){
240    TStrV VarNmV; 
241    TStrV RecNmV; 
242    TVec<TFltV> VarValVV; 
243    TILx Lx(TFIn::New(FNm), TFSet(iloRetEoln, iloSigNum));
244    Lx.GetSym(syInt, syEof); int RecN=0;
245    while (Lx.Sym!=syEof){
246      RecN++; TStr RecNm=TInt::GetStr(RecN);
247      RecNmV.Add(RecNm);
248      int PrevVarN=-1; TStrV CurVarNmV; TFltV VarValV(VarNmV.Len(), 0);
249      while (Lx.Sym!=syEoln){
250        IAssert((PrevVarN==-1)||(PrevVarN+1==Lx.Int));
251        PrevVarN=Lx.Int;
252        TStr VarNm=TInt::GetStr(Lx.Int);
253        CurVarNmV.Add(VarNm);
254        Lx.GetSym(syColon);
255        double VarVal=Lx.GetFlt();
256        VarValV.Add(VarVal);
257        Lx.GetSym(syInt, syEoln);
258      }
259      if (VarNmV.Empty()){VarNmV=CurVarNmV;}
260      else {IAssert(VarNmV==CurVarNmV);}
261      VarValVV.Add(VarValV);
262      Lx.GetSym(syInt, syEof);
263    }
264    PCorrGroups CorrGroups=New(VarNmV, RecNmV, VarValVV, TNotify::StdNotify);
265    return CorrGroups;
266  }
267  void TCorrGroups::SaveTxt(
268   const PSOut& SOut, const bool& CentrP, const bool& SqrtValP) const {
<span onclick='openModal()' class='match'>269    SOut->PutStr("==============================="); SOut->PutLn();
270    for (int GroupN=0; GroupN<VarNVV.Len(); GroupN++){
271      SOut->PutStr("Group"); SOut->PutInt(GroupN);
272      SOut->PutInt(VarNVV[GroupN].Len(), "(%d)");
</span>273      SOut->PutStr(":"); SOut->PutLn();
274      for (int VarNN=0; VarNN<VarNVV[GroupN].Len(); VarNN++){
275        int VarN=VarNVV[GroupN][VarNN];
276        SOut->PutStr("   ");
277        SOut->PutStr(GetVarNm(VarN));
278        SOut->PutLn();
279      }
280      VarNVV[GroupN].Sort();
281      if (CentrP){
282        TIntV VarNV; GetGroup(GroupN, VarNV);
283        TMomV VarValMomV; GetGroupCentroid(VarNV, VarValMomV);
284        SOut->PutStr("Centroid:\n");
285        for (int RecN=0; RecN<GetRecs(); RecN++){
286          SOut->PutStr("  ");
287          SOut->PutStr(GetRecNm(RecN));
288          SOut->PutStr(":");
289          if (!VarValMomV[RecN]->IsUsable()){
290            SOut->PutStr("X");
291          } else {
292            if (SqrtValP){
293              SOut->PutFlt(sqrt(VarValMomV[RecN]->GetMean()), "%0.0f");
294            } else {
295              SOut->PutFlt(VarValMomV[RecN]->GetMean());
296            }
297          }
298          if ((RecN+1)%8==0){SOut->PutLn();}
299        }
300        SOut->PutLn();
301      }
302      SOut->PutLn();
303    }
304  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmen.cpp</h3>
            <pre><code>1  TNmEnCtxBs::TNmEnCtxBs(TSIn& SIn) {
2      CtxPtV.Load(SIn);
3      CtxPool = TStrPool::Load(SIn);
4      CtxDateH.Load(SIn);
5  }
6  void TNmEnCtxBs::Save(TSOut& SOut) const {
7      CtxPtV.Save(SOut);
8      CtxPool->Save(SOut);
9      CtxDateH.Save(SOut);
10  }
11  int TNmEnCtxBs::AddCtx(const TStr& CtxStr, const TTm& CtxDate) {
12      const uint CtxPt = CtxPool->AddStr(CtxStr);
13      const int CtxId = CtxPtV.Add(CtxPt);
14      CtxDateH.AddDat(CtxId) = CtxDate;
15      return CtxId;
16  }
17  void TNmEnBs::GetMxNmEnV(const int& MxNmEns,
18          TIntV& NmEnIdV, const TIntH& TypeH) const {
19      TIntPrV CountNmV;
20      int NmEnKeyId = NmEnCtxIdVH.FFirstKeyId();
21      while (NmEnCtxIdVH.FNextKeyId(NmEnKeyId)) {
22          const int NmEnId = NmEnCtxIdVH.GetKey(NmEnKeyId);
23          const int TypeInt = int(GetNmEnType(NmEnId));
24          if (!TypeH.Empty() && !TypeH.IsKey(TypeInt)) { continue; }
25          const int Count = GetNmEnCount(NmEnId);
26          CountNmV.Add(TIntPr(Count, NmEnId));
27      }
28      CountNmV.Sort(false); NmEnIdV.Gen(MxNmEns, 0);
29      for (int CountNmN = 0; CountNmN < CountNmV.Len(); CountNmN++) {
30          if (CountNmN >= MxNmEns) { break; }
31          NmEnIdV.Add(CountNmV[CountNmN].Val2);
32      }
33  }
34  void TNmEnBs::GetMxNmEnH(const int& MxNmEns, TIntH& NmEnIdH) const {
35      TIntV NmEnIdV; GetMxNmEnV(MxNmEns, NmEnIdV, TIntH()); NmEnIdH.Clr();
36      for (int NmEnIdN = 0; NmEnIdN < NmEnIdV.Len(); NmEnIdN++) {
37          printf("%d/%d\r", NmEnIdN, NmEnIdV.Len());
38          const int NmEnId = NmEnIdV[NmEnIdN];
39          NmEnIdH.AddKey(NmEnId);
40      }
41  }
42  TStr TNmEnBs::GetClustNm(PBowDocPartClust Clust, PBowDocBs BowDocBs,
43          PBowDocWgtBs BowDocWgtBs, const int& TopNmEns) const {
44      Fail; return "";
45  }
46  TStr TNmEnBs::GenNmEnCtx(const TStr& NmEnStr, const TStr& ParStr) const {
47      int NmEnPos = ParStr.SearchStr(NmEnStr);
48      TStr LeftStr = ParStr.Left(NmEnPos);
49      TStr RightStr = ParStr.Right(ParStr.Len() - NmEnPos - NmEnStr.Len());
50      const int WndWords = 3;
51      TStrV LeftWndV(WndWords); LeftWndV.PutAll("");
52      TMem LeftMem(LeftStr); THtmlLx LeftLx(LeftMem.GetSIn(), false);
53      LeftLx.GetSym(); int WordCount = 0;
54      while (LeftLx.Sym != hsyEof) {
55          if (LeftLx.Sym == hsyStr) {
56              LeftWndV[WordCount % WndWords] = LeftLx.ChA();
57              WordCount++;
58          }
59          LeftLx.GetSym();
60      }
61      TStrV RightWndV(WndWords, 0); TMem RightMem(RightStr);
62      THtmlLx RightLx(RightMem.GetSIn(), false); RightLx.GetSym();
63      while ((RightLx.Sym != hsyEof) && (RightWndV.Len() < WndWords)) {
64          if (RightLx.Sym == hsyStr) { RightWndV.Add(RightLx.ChA()); }
65          RightLx.GetSym();
66      }
67      TChA CtxChA;
68      for (int LeftWndN = 0; LeftWndN < LeftWndV.Len(); LeftWndN++) {
69          CtxChA += LeftWndV[LeftWndN]; CtxChA += " "; }
70      CtxChA += "NM_EN"; CtxChA += " ";
71      for (int RightWndN = 0; RightWndN < RightWndV.Len(); RightWndN++) {
72          CtxChA += RightWndV[RightWndN]; CtxChA += " "; }
73      return CtxChA;
74  }
75  TStr TNmEnBs::GenNmEnPrCtx(const TStr& NmEn1Str,
76          const TStr& NmEn2Str, const TStr& ParStr) const {
77      int NmEn1Pos = ParStr.SearchStr(NmEn1Str);
78      int NmEn2Pos = ParStr.SearchStr(NmEn2Str);
79      TStr MiddleStr;
80      if (NmEn1Pos < NmEn2Pos) {
81          MiddleStr = ParStr.GetSubStr(NmEn1Pos + NmEn1Str.Len(), NmEn2Pos-1);
82      } else {
83          MiddleStr = ParStr.GetSubStr(NmEn2Pos + NmEn2Str.Len(), NmEn1Pos-1);
84      }
85      return "NM_EN " + MiddleStr + " NM_EN";
86  }
87  TNmEnBs::TNmEnBs() {
88      NmEnCtxBs = TNmEnCtxBs::New();
89      NmEnCtxBow = TBowDocBs::New();
90      NmEnCtxBoww = TBowDocWgtBs::New(NmEnCtxBow->GetSig());
91      NmEnCooCtxBow = TBowDocBs::New();
92      NmEnCooCtxBoww = TBowDocWgtBs::New(NmEnCooCtxBow->GetSig());
93  }
94  TNmEnBs::TNmEnBs(TSIn& SIn, const bool& LoadCtxP) {
95      TypeStrToIntH.Load(SIn); NmEnStrH.Load(SIn);
96      NmEnTypeHH.Load(SIn); NmEnRelNmEnHH.Load(SIn);
97      if (LoadCtxP) {
98          NmEnCtxBs = TNmEnCtxBs::Load(SIn);
99          NmEnCtxIdVH.Load(SIn); NmEnPrCtxIdVH.Load(SIn);
100          NmEnToDIdH.Load(SIn); NmEnCtxBow = TBowDocBs::Load(SIn);
101          NmEnCtxBoww = TBowDocWgtBs::Load(SIn);
102          NmEnToDIdVH.Load(SIn); NmEnCooCtxBow = TBowDocBs::Load(SIn);
103          NmEnCooCtxBoww = TBowDocWgtBs::Load(SIn);
104      }
105  }
106  TNmEnBs::TNmEnBs(TSIn& SIn, PBowDocBs _NmEnCtxBow) {
107      TypeStrToIntH.Load(SIn); NmEnStrH.Load(SIn);
108      NmEnTypeHH.Load(SIn); NmEnRelNmEnHH.Load(SIn);
109      NmEnCtxBs = TNmEnCtxBs::Load(SIn);
110      NmEnCtxIdVH.Load(SIn); NmEnPrCtxIdVH.Load(SIn);
111      NmEnToDIdH.Load(SIn);
112      {PBowDocBs LoadNmEnCtxBow = TBowDocBs::Load(SIn);
113      EAssert(_NmEnCtxBow->GetSig() == LoadNmEnCtxBow->GetSig());
114      NmEnCtxBow = _NmEnCtxBow;}
115      NmEnCtxBoww = TBowDocWgtBs::Load(SIn);
116      NmEnToDIdVH.Load(SIn); NmEnCooCtxBow = TBowDocBs::Load(SIn);
117      NmEnCooCtxBoww = TBowDocWgtBs::Load(SIn);
118  }
119  void TNmEnBs::Save(TSOut& SOut) const {
120      TypeStrToIntH.Save(SOut); NmEnStrH.Save(SOut);
121      NmEnTypeHH.Save(SOut); NmEnRelNmEnHH.Save(SOut);
122      NmEnCtxBs->Save(SOut); NmEnCtxIdVH.Save(SOut); NmEnPrCtxIdVH.Save(SOut);
123      NmEnToDIdH.Save(SOut); NmEnCtxBow->Save(SOut); NmEnCtxBoww->Save(SOut);
124      NmEnToDIdVH.Save(SOut); NmEnCooCtxBow->Save(SOut); NmEnCooCtxBoww->Save(SOut);
125  }
126  TNmEnType TNmEnBs::GetType(const TStr& TypeStr) {
127      if (TypeStrToIntH.Empty()) {
128          TypeStrToIntH.AddDat("organization", int(netOrg));
129          TypeStrToIntH.AddDat("location", int(netLocation));
130          TypeStrToIntH.AddDat("person", int(netPerson));
131      }
132      if (TypeStrToIntH.IsKey(TypeStr)) {
133          return TNmEnType(TypeStrToIntH.GetDat(TypeStr).Val);
134      } else {
135          return netUndef;
136      }
137  }
138  TStr TNmEnBs::GetTypeStr(const TNmEnType& TypeInt) {
139      if (TypeIntToStrH.Empty()) {
140          TypeIntToStrH.AddDat(int(netOrg), "organization");
141          TypeIntToStrH.AddDat(int(netLocation), "location");
142          TypeIntToStrH.AddDat(int(netPerson), "person");
143      }
144      if (TypeIntToStrH.IsKey(TypeInt)) {
145          return TypeIntToStrH.GetDat(TypeInt);
146      } else {
147          return "";
148      }
149  }
150  TNmEnType TNmEnBs::GetNmEnType(const int& NmEnId) const {
151      const TIntH& TypeH = NmEnTypeHH.GetDat(NmEnId);
152      int MxType = -1, MxVal = -1, KeyId = TypeH.FFirstKeyId();
153      while (TypeH.FNextKeyId(KeyId)) {
154          if (TypeH[KeyId] > MxVal) {
155              MxType = TypeH.GetKey(KeyId);
156              MxVal = TypeH[KeyId];
157          }
158      }
159      return (MxType != -1) ? TNmEnType(MxType) : netUndef;
160  }
161  int TNmEnBs::AddNmEn(const TStr& NmEnStr, const TNmEnType& NmEnType) {
162      const int NmEnId = NmEnStrH.AddKey(NmEnStr);
163      NmEnTypeHH.AddDat(NmEnId).AddDat(NmEnType, 1);
164      return NmEnId;
165  }
166  void TNmEnBs::GetRelated(const int& NmEnId, TIntPrV& RelNmEnIdWgtV,
167          const int& MxNmEns, const bool& SortP) {
168      const TIntH& RelNmEnIdWgtH = NmEnRelNmEnHH.GetDat(NmEnId);
169      RelNmEnIdWgtH.GetKeyDatPrV(RelNmEnIdWgtV);
170      if (SortP) {
171          TIntPrV RelNmEnWgtIdV;
172          GetSwitchedPrV<TInt, TInt>(RelNmEnIdWgtV, RelNmEnWgtIdV);
173          RelNmEnWgtIdV.Sort(false);
174          GetSwitchedPrV<TInt, TInt>(RelNmEnWgtIdV, RelNmEnIdWgtV);
175      }
176      if (MxNmEns != -1 && RelNmEnIdWgtV.Len() > MxNmEns) {
177          RelNmEnIdWgtV.Trunc(MxNmEns);
178      }
179  }
180  void TNmEnBs::PrintRelated(const TStr& NmEnStr, const int& MxNmEns) {
181      const int NmEnId = GetNmEnId(NmEnStr);
182      TIntPrV RelNmEnIdWgtV;
183      GetRelated(NmEnId, RelNmEnIdWgtV, MxNmEns, true);
184      printf("[%s]\n", NmEnStr.CStr());
185      for (int RelNmEnN = 0; RelNmEnN < RelNmEnIdWgtV.Len(); RelNmEnN++) {
186          const int RelNmEnId = RelNmEnIdWgtV[RelNmEnN].Val1;
187          TStr RelNmEnStr = GetNmEnStr(RelNmEnId);
188          const int RelNmEnWgt = RelNmEnIdWgtV[RelNmEnN].Val2;
189          TStr DocNm = GetNmEnPrStr(NmEnId, RelNmEnId);
190          if (NmEnCooCtxBow->IsDocNm(DocNm)) {
191              const int DId = NmEnCooCtxBow->GetDId(DocNm);
192              PBowSpV DocSpV = NmEnCooCtxBoww->GetSpV(DId);
193              PBowKWordSet KWordSet = DocSpV->GetKWordSet(NmEnCooCtxBow)->GetTopKWords(5, 1.0);
194              printf(" => %s [%d] (%s)\n", RelNmEnStr.CStr(),
195                  RelNmEnWgt, KWordSet->GetKWordsStr().ToLc().CStr());
196          } else {
197              printf(" => %s [%d] (missing ...)\n", RelNmEnStr.CStr(), RelNmEnWgt);
198          }
199      }
200  }
201  void TNmEnBs::GetRelated(const TIntV& ClustDIdV1, const TIntV& ClustDIdV2,
202          TIntV& CooCtxDIdV, TIntPrV& NmEnWgtV) {
203      TIntH Clust1DIdH, Clust2DIdH;
204      for (int ClustDIdN = 0; ClustDIdN < ClustDIdV1.Len(); ClustDIdN++) {
205          Clust1DIdH.AddKey(ClustDIdV1[ClustDIdN]); }
206      for (int ClustDIdN = 0; ClustDIdN < ClustDIdV2.Len(); ClustDIdN++) {
207          Clust2DIdH.AddKey(ClustDIdV2[ClustDIdN]); }
208      CooCtxDIdV.Clr(); TIntH NmEnWgtH;
209      int NmEnPrKeyId = NmEnPrCtxIdVH.FFirstKeyId();
210      while (NmEnPrCtxIdVH.FNextKeyId(NmEnPrKeyId)) {
211          const int NmEnId1 = NmEnPrCtxIdVH.GetKey(NmEnPrKeyId).Val1;
212          const int NmEnId2 = NmEnPrCtxIdVH.GetKey(NmEnPrKeyId).Val2;
213          if (!IsNmEnDId(NmEnId1) || !IsNmEnDId(NmEnId2)) { continue; }
214          const int NmEnDId1 = GetNmEnDId(NmEnId1);
215          const int NmEnDId2 = GetNmEnDId(NmEnId2);
216          if ((Clust1DIdH.IsKey(NmEnDId1) && Clust2DIdH.IsKey(NmEnDId2)) ||
217              (Clust2DIdH.IsKey(NmEnDId2) && Clust1DIdH.IsKey(NmEnDId1))) {
218              TStr DocNm = GetNmEnPrStr(NmEnId1, NmEnId2);
219              if (NmEnCooCtxBow->IsDocNm(DocNm)) {
220                  const int CooCtxDId = NmEnCooCtxBow->GetDId(DocNm);
221                  CooCtxDIdV.AddMerged(CooCtxDId);
222                  NmEnWgtH.AddDat(NmEnId1)++;
223                  NmEnWgtH.AddDat(NmEnId2)++;
224              }
225          }
226      }
227      TIntPrV WgtNmEnV; NmEnWgtH.GetDatKeyPrV(WgtNmEnV);
228      WgtNmEnV.Sort(false); GetSwitchedPrV<TInt, TInt>(WgtNmEnV, NmEnWgtV);
229  }
230  void TNmEnBs::GetRelated(const TIntV& ClustDIdV1, const TIntV& ClustDIdV2,
231          TStr& RelNm, int& RelPrs, PBowSpV& RelSpV) {
232      TIntV CooCtxDIdV; TIntPrV NmEnWgtV;
233      GetRelated(ClustDIdV1, ClustDIdV2, CooCtxDIdV, NmEnWgtV);
234      RelPrs = CooCtxDIdV.Len();
235      PBowSim BowSim = TBowSim::New(bstCos);
236      RelSpV = TBowClust::GetConceptSpV(
237          NmEnCooCtxBoww, BowSim, CooCtxDIdV, 1.0);
238      const int MxNmEns = TInt::GetMn(10, NmEnWgtV.Len());
239      for (int NmEnN = 0; NmEnN < MxNmEns; NmEnN++) {
240          if (NmEnN > 0) { RelNm += ", "; }
241          RelNm += GetNmEnStr(NmEnWgtV[NmEnN].Val1);
242      }
243  }
244  void TNmEnBs::GetRelated(const TIntV& ClustDIdV1, const TIntV& ClustDIdV2,
245          const int& MxKeyWds, TStr& RelNm, int& RelPrs, TStr& RelKeyWdStr) {
246      PBowSpV RelSpV; GetRelated(ClustDIdV1, ClustDIdV2, RelNm, RelPrs, RelSpV);
247      PBowKWordSet KWordSet = RelSpV->GetKWordSet(NmEnCooCtxBow)->GetTopKWords(MxKeyWds, 1.0);
248      RelKeyWdStr = KWordSet->GetKWordsStr().ToLc();
249  }
250  void TNmEnBs::AddNmEnCtx(const int& NmEnId, const int& CtxId) {
251      NmEnCtxIdVH.AddDat(NmEnId).AddMerged(CtxId);
252  }
253  void TNmEnBs::AddNmEnPrCtx(const int& NmEnId1, const int& NmEnId2, const int& CtxId) {
254      NmEnPrCtxIdVH.AddDat(GetNmEnPr(NmEnId1, NmEnId2)).AddMerged(CtxId);
255  }
256  void TNmEnBs::GenNmEnCtxBow(const int& MxNmEns, const TIntH& TypeH) {
257      PSwSet SwSet = TSwSet::New(swstEn523); SwSet->AddWord("NM_EN");
258      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
259      NmEnCtxBow = TBowDocBs::New(SwSet, Stemmer, NULL);
260      printf("Loading profiles ...\n");
261      TIntV NmEnIdV; GetMxNmEnV(MxNmEns, NmEnIdV, TypeH); NmEnToDIdH.Clr();
262      for (int NmEnIdN = 0; NmEnIdN < NmEnIdV.Len(); NmEnIdN++) {
263          if (NmEnIdN % 100 == 0) { printf("%d/%d\r", NmEnIdN, NmEnIdV.Len()); }
264          const int NmEnId = NmEnIdV[NmEnIdN];
265          TStr NmEnStr = NmEnStrH.GetKey(NmEnId);
266          const TIntV& CtxIdV = GetCtxIdV(NmEnId);
267          TChA NmEnFullCtx;
268          for (int CtxIdN = 0; CtxIdN < CtxIdV.Len(); CtxIdN++) {
269              TStr CtxStr = GetCtxStr(CtxIdV[CtxIdN]);
270              NmEnFullCtx += CtxStr; NmEnFullCtx += '\n';
271          }
272          TStr CatNm = GetTypeStr(GetNmEnType(NmEnId));
273          const int DId = NmEnCtxBow->AddHtmlDoc(NmEnStr,
274              TStrV::GetV(CatNm), TStr(NmEnFullCtx), true);
275          NmEnToDIdH.AddDat(NmEnId, DId);
276      } printf("\n");
277      NmEnCtxBoww = TBowDocWgtBs::New(NmEnCtxBow, bwwtLogDFNrmTFIDF);
278  }
279  void TNmEnBs::GenNmEnCooCtxBow(const int& MxNmEns) {
280      PSwSet SwSet = TSwSet::New(swstEn523);
281      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
282      NmEnCooCtxBow = TBowDocBs::New(SwSet, Stemmer, NULL);
283      int NmEnPrKeyId = NmEnPrCtxIdVH.FFirstKeyId();
284      printf("Loading co-profiles ...\n");
285      TIntH NmEnIdH; GetMxNmEnH(MxNmEns, NmEnIdH); NmEnToDIdVH.Clr();
286      while (NmEnPrCtxIdVH.FNextKeyId(NmEnPrKeyId)) {
287          if (NmEnPrKeyId % 1000 == 0) {
288              printf("%d/%d\r ", NmEnPrKeyId, NmEnPrCtxIdVH.Len());
289          }
290          const int NmEnId1 = NmEnPrCtxIdVH.GetKey(NmEnPrKeyId).Val1;
291          if (!NmEnIdH.IsKey(NmEnId1)) { continue; }
292          const int NmEnId2 = NmEnPrCtxIdVH.GetKey(NmEnPrKeyId).Val2;
293          if (!NmEnIdH.IsKey(NmEnId2)) { continue; }
294          const TIntV& CtxIdV = GetPrCtxIdV(NmEnId1, NmEnId2);
295          TChA NmEnFullCtx;
296          for (int CtxIdN = 0; CtxIdN < CtxIdV.Len(); CtxIdN++) {
297              TStr CtxStr = GetCtxStr(CtxIdV[CtxIdN]);
298              NmEnFullCtx += CtxStr; NmEnFullCtx += '\n';
299          }
300          const int DId = NmEnCooCtxBow->AddHtmlDoc(
301              GetNmEnPrStr(NmEnId1, NmEnId2),
302              TStrV(), TStr(NmEnFullCtx), false);
303          NmEnToDIdVH.AddDat(NmEnId1).Add(DId);
304          NmEnToDIdVH.AddDat(NmEnId2).Add(DId);
305      } printf("\n");
306      NmEnCooCtxBoww = TBowDocWgtBs::New(NmEnCooCtxBow, bwwtLogDFNrmTFIDF);
307  }
308  PBowDocPart TNmEnBs::GenBowDocPart(const int& Clusts) {
309      PBowSim BowSim = TBowSim::New(bstCos);
310      TRnd Rnd(1);
311      PBowDocPart BowDocPart = TBowClust::GetKMeansPartForDocWgtBs(
312          TNotify::StdNotify, NmEnCtxBoww, NmEnCtxBow,
313          BowSim, Rnd, Clusts, 1, 10, 1);
314      return BowDocPart;
315  }
316  void TNmEnBs::PrintClustSim(const TStr& FNm, const int& Clusts) {
317      TFOut FOut(FNm);
318      printf("clustering...\n");
319      PBowDocPart BowDocPart = GenBowDocPart(Clusts);
320      FOut.PutStrLn("Clusters:"); printf("outputing clusters...\n");
321      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
322          printf("%d\r", ClustN+1);
323          TStr ClustNm = GetClustNm(BowDocPart->GetClust(ClustN), NmEnCtxBow, NmEnCtxBoww, 10);
324          PBowSpV ClustSpV = BowDocPart->GetClust(ClustN)->GetConceptSpV();
325          TStr ClustStr = ClustSpV->GetKWordSet(NmEnCtxBow)->GetTopKWords(10, 1.0)->GetKWordsStr();
326          FOut.PutStrLn(TStr::Fmt(" [%2d] ClustNm: %s", ClustN+1, ClustNm.CStr()));
327          FOut.PutStrLn("      Keywords: " + ClustStr.ToLc());
328      } printf("\n");
329      FOut.PutLn(); FOut.PutStrLn("Relations:"); printf("outputing relations...\n");
330      TIntIntPrPrV RelWgtPrV; THash<TIntPr, PBowSpV> RelToBowSpVH; TIntPrStrH RelToNmH;
331      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
332          for (int RelClustN = ClustN+1; RelClustN < BowDocPart->GetClusts(); RelClustN++) {
333              TStr RelNm; int RelPrs = 0; PBowSpV RelSpV;
334              GetRelated(BowDocPart->GetClust(ClustN)->GetDIdVRef(),
335                  BowDocPart->GetClust(RelClustN)->GetDIdVRef(),
336                  RelNm, RelPrs, RelSpV);
337              RelWgtPrV.Add(TIntIntPrPr(RelPrs, TIntPr(ClustN, RelClustN)));
338              RelToBowSpVH.AddDat(TIntPr(ClustN, RelClustN), RelSpV);
339              RelToNmH.AddDat(TIntPr(ClustN, RelClustN), RelNm);
340          }
341      }
342      RelWgtPrV.Sort(false);
343      for (int RelWgtPrN = 0; RelWgtPrN < RelWgtPrV.Len(); RelWgtPrN++) {
344          const int RelPrs = RelWgtPrV[RelWgtPrN].Val1;
345          const TIntPr ClustPr = RelWgtPrV[RelWgtPrN].Val2;
346          PBowSpV RelSpV = RelToBowSpVH.GetDat(ClustPr);
347          TStr RelNm = RelToNmH.GetDat(ClustPr);
348          const int ClustN = ClustPr.Val1;
349          const int RelClustN = ClustPr.Val2;
350          printf("%2d-%2d\r", ClustN+1, RelClustN+1);
351          TStr RelStr = RelSpV->GetKWordSet(
352              NmEnCooCtxBow)->GetTopKWords(10, 1.0)->GetKWordsStr();
353          FOut.PutStrLn(TStr::Fmt(" [%4d: %2d-%2d] %s", RelPrs,
354              ClustN+1, RelClustN+1, RelNm.CStr()));
355          FOut.PutStrLn("       Keywords: " + RelStr.ToLc());
356      } printf("\n");
357      printf("done\n");
358  }
359  void TNmEnBs::AddReutersXml(const TStr& XmlFNm, const bool& GenCooCtxP) {
360      PXmlDoc Doc=TXmlDoc::LoadTxt(XmlFNm);
361      TStr DateStr=Doc->GetTagTok("newsitem")->GetArgVal("date");
362      TStr TitleStr=Doc->GetTagTok("newsitem|title")->GetTokStr(false);
363      TStr HeadlineStr=Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
364      TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
365      TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
366      for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
367          TStr ParStr = ParTokV[ParTokN]->GetTokStr(false);
368          TXmlTokV NmEnTokV; ParTokV[ParTokN]->GetTagTokV("enamex", NmEnTokV);
369          TIntV NmEnIdV;
370          for (int NmEnTokN = 0; NmEnTokN < NmEnTokV.Len(); NmEnTokN++) {
371              TStr NmEnTypeStr = NmEnTokV[NmEnTokN]->GetArgVal("type", "");
372              TStr NmEnStr = NmEnTokV[NmEnTokN]->GetTokStr(false);
373              TNmEnType NmEnType = GetType(NmEnTypeStr);
374              if (NmEnType == netUndef) { printf("Unknown: %s", NmEnTypeStr.CStr()); continue; }
375              if (IsNmEn(NmEnStr)) { 
376                  const int NmEnId = GetNmEnId(NmEnStr);
377                  IAssert(GetNmEnStr(NmEnId) == NmEnStr);
378                  NmEnTypeHH.AddDat(NmEnId).AddDat(NmEnType)++;
379                  NmEnIdV.AddMerged(NmEnId);
380              } else {
381                  const int NmEnId = AddNmEn(NmEnStr, NmEnType);
382                  NmEnIdV.AddMerged(NmEnId);
383              }
384          }
385          if (NmEnIdV.Empty()) { continue; }
386          for (int NmEn1IdN = 0; NmEn1IdN < NmEnIdV.Len(); NmEn1IdN++) {
387              const int NmEn1Id = NmEnIdV[NmEn1IdN];
388              TStr NmEn1Str = GetNmEnStr(NmEn1Id);
389              TStr NmEn1CtxStr = GenNmEnCtx(NmEn1Str, ParStr);
390              const int NmEn1CtxId = NmEnCtxBs->AddCtx(NmEn1CtxStr, DateTm);
391              AddNmEnCtx(NmEn1Id, NmEn1CtxId);
392              for (int NmEn2IdN = 0; NmEn2IdN < NmEnIdV.Len(); NmEn2IdN++) {
393                  const int NmEn2Id = NmEnIdV[NmEn2IdN];
394                  if (NmEn1Id == NmEn2Id) { continue; }
395                  AddRelNmEn(NmEn1Id, NmEn2Id);
396                  if (GenCooCtxP) {
397                      TStr NmEn2Str = GetNmEnStr(NmEn2Id);
398                      TStr NmEnPrCtxStr = GenNmEnPrCtx(NmEn1Str, NmEn2Str, ParStr);
399                      const int NmEnPrCtxId = NmEnCtxBs->AddCtx(NmEnPrCtxStr, DateTm);
400                      AddNmEnPrCtx(NmEn1Id, NmEn2Id, NmEnPrCtxId);
401                  }
402              }
403          }
404      }
405  }
406  PNmEnBs TNmEnBs::LoadReuters(const TStr& FPath, const TTm& StartDate,
407          const TTm& EndDate, const bool& GenCooCtxP) {
408      PNotify Notify = TStdNotify::New();
409      Notify->OnStatus("Loading Reuters documents from file-path " + FPath + " ...");
410      PNmEnBs NmEnBs = TNmEnBs::New();
411      TFFile FFile(FPath, ".xml", true);
412      TStr FNm; int Docs = 0, Files = 0;
413      while (FFile.Next(FNm)) {
414          if (Files > 100000) { break; }
415          if (TFile::Exists(FNm)) {
416              TStr DateStr, RestStr;
417              FNm.GetFBase().SplitOnCh(DateStr, '_', RestStr);
418              TTm DateTm(DateStr.GetSubStr(0, 3).GetInt(),
419                  DateStr.GetSubStr(4, 5).GetInt(),
420                  DateStr.GetSubStr(6, 7).GetInt());
421              if (StartDate <= DateTm && DateTm <= EndDate) {
422                  NmEnBs->AddReutersXml(FNm, GenCooCtxP); Docs++;
423              }
424              Files++;
425          }
426          if (Files % 1000 == 0) {
427              const int NmEns = NmEnBs->GetNmEns();
428              const int Ctxs = NmEnBs->GetCtxs();
429              Notify->OnStatus(TStr::Fmt("F:%d / D:%d / NE:%d/ C:%d\r", Files, Docs, NmEns, Ctxs));
430          }
431      }
432      const int NmEns = NmEnBs->GetNmEns(), Ctxs = NmEnBs->GetCtxs();
433      Notify->OnStatus(TStr::Fmt("F:%d / D:%d / NE:%d/ C:%d", Files, Docs, NmEns, Ctxs));
434      return NmEnBs;
435  }
436  PNmEnBs TNmEnBs::LoadMsrSent(const TStr& InFNm) {
437      PNmEnBs NmEnBs = TNmEnBs::New();
438      TLnRet LnRet(TFIn::New(InFNm));
439      TStr LnStr; TStrV PartV;
440      while (LnRet.NextLn(LnStr)) {
441          LnStr.ToLc(); LnStr.SplitOnAllCh(' ', PartV);
442          TIntV NmEnIdV;
443          for (int PartN = 0; PartN < PartV.Len(); PartN++) {
444              if (PartV[PartN].IsChIn('_')) {
445                  TStr NmEnStr = PartV[PartN];
446                  if (NmEnBs->IsNmEn(NmEnStr)) { 
447                      const int NmEnId = NmEnBs->GetNmEnId(NmEnStr);
448                      NmEnIdV.AddMerged(NmEnId);
449                  } else {
450                      const int NmEnId = NmEnBs->AddNmEn(NmEnStr, netUndef);
451                      NmEnIdV.AddMerged(NmEnId);
452                  }
453                  while (LnStr.DelStr(NmEnStr)) { }
454              }
455          }
456          if (NmEnIdV.Empty()) { continue; }
457          const int CtxId = NmEnBs->NmEnCtxBs->AddCtx(LnStr, TTm());
458          for (int NmEnIdN1 = 0; NmEnIdN1 < NmEnIdV.Len(); NmEnIdN1++) {
459              const int NmEnId1 = NmEnIdV[NmEnIdN1];
460              NmEnBs->AddNmEnCtx(NmEnId1, CtxId);
461              for (int NmEnIdN2 = 0; NmEnIdN2 < NmEnIdV.Len(); NmEnIdN2++) {
462                  const int NmEnId2 = NmEnIdV[NmEnIdN2];
463                  if (NmEnId1 == NmEnId2) { continue; }
464                  NmEnBs->AddRelNmEn(NmEnId1, NmEnId2);
465                  NmEnBs->AddNmEnPrCtx(NmEnId1, NmEnId2, CtxId);
466              }
467          }
468      }
469      return NmEnBs;
470  }
471  void TNmEnBs::SaveNmEnStat(const TStr& FNm) const {
472      TFOut FOut(FNm);
473      TIntStrPrV CountNmV;
474      int NmEnKeyId = NmEnCtxIdVH.FFirstKeyId();
475      while (NmEnCtxIdVH.FNextKeyId(NmEnKeyId)) {
476          const int NmEnId = NmEnCtxIdVH.GetKey(NmEnKeyId);
477          TStr NmEnStr = GetNmEnStr(NmEnId);
478          const int Count = GetNmEnCount(NmEnId);
479          CountNmV.Add(TIntStrPr(Count, NmEnStr));
480      }
<span onclick='openModal()' class='match'>481      CountNmV.Sort(false);
482      FOut.PutStrLn("Name entities:");
483      for (int CountNmN = 0; CountNmN < CountNmV.Len(); CountNmN++) {
484          FOut.PutStrLn(TStr::Fmt("%d : %s",
485              CountNmV[CountNmN].Val1.Val,
486              CountNmV[CountNmN].Val2.CStr()));
</span>487      }
488      FOut.Flush();
489  }
490  void TNmEnBs::SaveNmEnCtxStat(const TStr& FNm) const {
491      TIntV NmEnIdV; GetMxNmEnV(50000, NmEnIdV, TIntH());
492      TFOut FOut(FNm); TRnd Rnd(1); 
493      if (NmEnIdV.Len() > 100) { NmEnIdV.Trunc(100); }
494      for (int NmEnIdN = 0; NmEnIdN < NmEnIdV.Len(); NmEnIdN++) {
495          const int NmEnId = NmEnIdV[NmEnIdN];
496          TStr NmEnStr = GetNmEnStr(NmEnId);
497          FOut.PutStrLn(NmEnStr);
498          TIntV CtxIdV = GetCtxIdV(NmEnId); CtxIdV.Shuffle(Rnd);
499          if (CtxIdV.Len() > 10) { CtxIdV.Trunc(10); }
500          for (int CtxIdN = 0; CtxIdN < CtxIdV.Len(); CtxIdN++) {
501              const int CtxId = CtxIdV[CtxIdN];
502              TStr CtxStr = GetCtxStr(CtxId);
503              FOut.PutStrLn("  " + CtxStr);
504          }
505          FOut.Flush();
506      }
507  }
508  void TNmEnBs::SaveNmEnPrStat(const TStr& FNm) const {
509      TFOut FOut(FNm);
510      printf("NmEnPrCtxIdVH.Len() == %d\n", NmEnPrCtxIdVH.Len());
511      TIntStrPrV CountNmV;
512      int NmEnPrKeyId = NmEnPrCtxIdVH.FFirstKeyId();
513      while (NmEnPrCtxIdVH.FNextKeyId(NmEnPrKeyId)) {
514          const int NmEnId1 = NmEnPrCtxIdVH.GetKey(NmEnPrKeyId).Val1;
515          const int NmEnId2 = NmEnPrCtxIdVH.GetKey(NmEnPrKeyId).Val2;
516          const int Count = GetPrCtxIdV(NmEnId1, NmEnId2).Len();
517          CountNmV.Add(TIntStrPr(Count, GetNmEnPrStr(NmEnId1, NmEnId2)));
518      }
519      printf("CountNmV.Len() == %d\n", CountNmV.Len());
520      CountNmV.Sort(false);
521      FOut.PutLn();
522      FOut.PutStrLn("Co-occurance:");
523      for (int CountNmN = 0; CountNmN < CountNmV.Len(); CountNmN++) {
524          TStr NmEnIdStr1, NmEnIdStr2;
525          TStr DocNm = CountNmV[CountNmN].Val2;
526          DocNm.SplitOnCh(NmEnIdStr1, '-', NmEnIdStr2);
527          const int NmEnId1 = NmEnIdStr1.GetInt();
528          const int NmEnId2 = NmEnIdStr2.GetInt();
529          TStr NmEnStr1 = NmEnStrH.GetKey(NmEnId1);
530          TStr NmEnStr2 = NmEnStrH.GetKey(NmEnId2);
531          if (NmEnCooCtxBow->IsDocNm(DocNm)) {
532              const int DId = NmEnCooCtxBow->GetDId(DocNm);
533              PBowSpV DocSpV = NmEnCooCtxBoww->GetSpV(DId);
534              PBowKWordSet KWordSet = DocSpV->GetKWordSet(NmEnCooCtxBow)->GetTopKWords(5, 1.0);
535              FOut.PutStrLn(TStr::Fmt("%d : %s - %s [%s]",  CountNmV[CountNmN].Val1.Val,
536                  NmEnStr1.CStr(), NmEnStr2.CStr(), KWordSet->GetKWordsStr().ToLc().CStr()));
537          } else {
538              FOut.PutStrLn(TStr::Fmt("%d : %s - %s",
539                  CountNmV[CountNmN].Val1.Val, NmEnStr1.CStr(), NmEnStr2.CStr()));
540          }
541      }
542      FOut.Flush();
543  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmen.cpp</div>
                </div>
                <div class="column column_space"><pre><code>269    SOut->PutStr("==============================="); SOut->PutLn();
270    for (int GroupN=0; GroupN<VarNVV.Len(); GroupN++){
271      SOut->PutStr("Group"); SOut->PutInt(GroupN);
272      SOut->PutInt(VarNVV[GroupN].Len(), "(%d)");
</pre></code></div>
                <div class="column column_space"><pre><code>481      CountNmV.Sort(false);
482      FOut.PutStrLn("Name entities:");
483      for (int CountNmN = 0; CountNmN < CountNmV.Len(); CountNmN++) {
484          FOut.PutStrLn(TStr::Fmt("%d : %s",
485              CountNmV[CountNmN].Val1.Val,
486              CountNmV[CountNmN].Val2.CStr()));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    