
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.371721778791334%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobs.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "blobs.h"
5  #include "ccstruct.h"
6  #include "clst.h"
7  #include "linlsq.h"
8  #include "normalis.h"
9  #include "ocrblock.h"
10  #include "ocrrow.h"
11  #include "points.h"
12  #include "polyaprx.h"
13  #include "werd.h"
14  #include "helpers.h"
15  #include <algorithm>
16  namespace tesseract {
17  const TPOINT kDivisibleVerticalUpright(0, 1);
18  const TPOINT kDivisibleVerticalItalic(1, 5);
19  bool TPOINT::IsCrossed(const TPOINT &a0, const TPOINT &a1, const TPOINT &b0, const TPOINT &b1) {
20    TPOINT b0a1, b0a0, a1b1, b0b1, a1a0;
21    b0a1.x = a1.x - b0.x;
22    b0a0.x = a0.x - b0.x;
23    a1b1.x = b1.x - a1.x;
24    b0b1.x = b1.x - b0.x;
25    a1a0.x = a0.x - a1.x;
26    b0a1.y = a1.y - b0.y;
27    b0a0.y = a0.y - b0.y;
28    a1b1.y = b1.y - a1.y;
29    b0b1.y = b1.y - b0.y;
30    a1a0.y = a0.y - a1.y;
31    int b0a1xb0b1 = b0a1.cross(b0b1);
32    int b0b1xb0a0 = b0b1.cross(b0a0);
33    int a1b1xa1a0 = a1b1.cross(a1a0);
34    int a1a0xa1b0 = -a1a0.cross(b0a1);
35    return ((b0a1xb0b1 > 0 && b0b1xb0a0 > 0) || (b0a1xb0b1 < 0 && b0b1xb0a0 < 0)) &&
36           ((a1b1xa1a0 > 0 && a1a0xa1b0 > 0) || (a1b1xa1a0 < 0 && a1a0xa1b0 < 0));
37  }
38  TESSLINE *TESSLINE::BuildFromOutlineList(EDGEPT *outline) {
39    auto *result = new TESSLINE;
40    result->loop = outline;
41    if (outline->src_outline != nullptr) {
42      EDGEPT *pt = outline;
43      do {
44        pt->step_count = pt->next->start_step - pt->start_step;
45        if (pt->step_count < 0) {
46          pt->step_count += pt->src_outline->pathlength();
47        }
48        pt = pt->next;
49      } while (pt != outline);
50    }
51    result->SetupFromPos();
52    return result;
53  }
54  void TESSLINE::CopyFrom(const TESSLINE &src) {
55    Clear();
56    topleft = src.topleft;
57    botright = src.botright;
58    start = src.start;
59    is_hole = src.is_hole;
60    if (src.loop != nullptr) {
61      EDGEPT *prevpt = nullptr;
62      EDGEPT *newpt = nullptr;
63      EDGEPT *srcpt = src.loop;
64      do {
65        newpt = new EDGEPT(*srcpt);
66        if (prevpt == nullptr) {
67          loop = newpt;
68        } else {
69          newpt->prev = prevpt;
70          prevpt->next = newpt;
71        }
72        prevpt = newpt;
73        srcpt = srcpt->next;
74      } while (srcpt != src.loop);
75      loop->prev = newpt;
76      newpt->next = loop;
77    }
78  }
79  void TESSLINE::Clear() {
80    if (loop == nullptr) {
81      return;
82    }
83    EDGEPT *this_edge = loop;
84    do {
85      EDGEPT *next_edge = this_edge->next;
86      delete this_edge;
87      this_edge = next_edge;
88    } while (this_edge != loop);
89    loop = nullptr;
90  }
91  void TESSLINE::Normalize(const DENORM &denorm) {
92    EDGEPT *pt = loop;
93    do {
94      denorm.LocalNormTransform(pt->pos, &pt->pos);
95      pt = pt->next;
96    } while (pt != loop);
97    SetupFromPos();
98  }
99  void TESSLINE::Rotate(const FCOORD rot) {
100    EDGEPT *pt = loop;
101    do {
102      int tmp = static_cast<int>(floor(pt->pos.x * rot.x() - pt->pos.y * rot.y() + 0.5));
103      pt->pos.y = static_cast<int>(floor(pt->pos.y * rot.x() + pt->pos.x * rot.y() + 0.5));
104      pt->pos.x = tmp;
105      pt = pt->next;
106    } while (pt != loop);
107    SetupFromPos();
108  }
109  void TESSLINE::Move(const ICOORD vec) {
110    EDGEPT *pt = loop;
111    do {
112      pt->pos.x += vec.x();
113      pt->pos.y += vec.y();
114      pt = pt->next;
115    } while (pt != loop);
116    SetupFromPos();
117  }
118  void TESSLINE::Scale(float factor) {
119    EDGEPT *pt = loop;
120    do {
121      pt->pos.x = static_cast<int>(floor(pt->pos.x * factor + 0.5));
122      pt->pos.y = static_cast<int>(floor(pt->pos.y * factor + 0.5));
123      pt = pt->next;
124    } while (pt != loop);
125    SetupFromPos();
126  }
127  void TESSLINE::SetupFromPos() {
128    EDGEPT *pt = loop;
129    do {
130      pt->vec.x = pt->next->pos.x - pt->pos.x;
131      pt->vec.y = pt->next->pos.y - pt->pos.y;
132      pt = pt->next;
133    } while (pt != loop);
134    start = pt->pos;
135    ComputeBoundingBox();
136  }
137  void TESSLINE::ComputeBoundingBox() {
138    int minx = INT32_MAX;
139    int miny = INT32_MAX;
140    int maxx = -INT32_MAX;
141    int maxy = -INT32_MAX;
142    start = loop->pos;
143    EDGEPT *this_edge = loop;
144    do {
145      if (!this_edge->IsHidden() || !this_edge->prev->IsHidden()) {
146        if (this_edge->pos.x < minx) {
147          minx = this_edge->pos.x;
148        }
149        if (this_edge->pos.y < miny) {
150          miny = this_edge->pos.y;
151        }
152        if (this_edge->pos.x > maxx) {
153          maxx = this_edge->pos.x;
154        }
155        if (this_edge->pos.y > maxy) {
156          maxy = this_edge->pos.y;
157        }
158      }
159      this_edge = this_edge->next;
160    } while (this_edge != loop);
161    topleft.x = minx;
162    topleft.y = maxy;
163    botright.x = maxx;
164    botright.y = miny;
165  }
166  void TESSLINE::MinMaxCrossProduct(const TPOINT vec, int *min_xp, int *max_xp) const {
167    *min_xp = INT32_MAX;
168    *max_xp = INT32_MIN;
169    EDGEPT *this_edge = loop;
170    do {
171      if (!this_edge->IsHidden() || !this_edge->prev->IsHidden()) {
172        int product = this_edge->pos.cross(vec);
173        UpdateRange(product, min_xp, max_xp);
174      }
175      this_edge = this_edge->next;
176    } while (this_edge != loop);
177  }
178  TBOX TESSLINE::bounding_box() const {
179    return TBOX(topleft.x, botright.y, botright.x, topleft.y);
180  }
181  #ifndef GRAPHICS_DISABLED
182  void TESSLINE::plot(ScrollView *window, ScrollView::Color color, ScrollView::Color child_color) {
183    if (is_hole) {
184      window->Pen(child_color);
185    } else {
186      window->Pen(color);
187    }
188    window->SetCursor(start.x, start.y);
189    EDGEPT *pt = loop;
190    do {
191      bool prev_hidden = pt->IsHidden();
192      pt = pt->next;
193      if (prev_hidden) {
194        window->SetCursor(pt->pos.x, pt->pos.y);
195      } else {
196        window->DrawTo(pt->pos.x, pt->pos.y);
197      }
198    } while (pt != loop);
199  }
200  #endif 
201  EDGEPT *TESSLINE::FindBestStartPt() const {
202    EDGEPT *best_start = loop;
203    int best_step = loop->start_step;
204    EDGEPT *pt = loop;
205    do {
206      if (pt->IsHidden()) {
207        continue;
208      }
209      if (pt->prev->IsHidden() || pt->prev->src_outline != pt->src_outline) {
210        return pt; 
211      }
212      if (pt->start_step < best_step) {
213        best_step = pt->start_step;
214        best_start = pt;
215      }
216    } while ((pt = pt->next) != loop);
217    return best_start;
218  }
219  static TESSLINE **ApproximateOutlineList(bool allow_detailed_fx, C_OUTLINE_LIST *outlines,
220                                           bool children, TESSLINE **tail) {
221    C_OUTLINE_IT ol_it(outlines);
222    for (ol_it.mark_cycle_pt(); !ol_it.cycled_list(); ol_it.forward()) {
223      C_OUTLINE *outline = ol_it.data();
224      if (outline->pathlength() > 0) {
225        TESSLINE *tessline = ApproximateOutline(allow_detailed_fx, outline);
226        tessline->is_hole = children;
227        *tail = tessline;
228        tail = &tessline->next;
229      }
230      if (!outline->child()->empty()) {
231        tail = ApproximateOutlineList(allow_detailed_fx, outline->child(), true, tail);
232      }
233    }
234    return tail;
235  }
236  TBLOB *TBLOB::PolygonalCopy(bool allow_detailed_fx, C_BLOB *src) {
237    auto *tblob = new TBLOB;
238    ApproximateOutlineList(allow_detailed_fx, src->out_list(), false, &tblob->outlines);
239    return tblob;
240  }
241  TBLOB *TBLOB::ShallowCopy(const TBLOB &src) {
242    auto *blob = new TBLOB;
243    blob->denorm_ = src.denorm_;
244    return blob;
245  }
246  TBLOB *TBLOB::ClassifyNormalizeIfNeeded() const {
247    TBLOB *rotated_blob = nullptr;
248    if (denorm_.block() != nullptr && denorm_.block()->classify_rotation().y() != 0.0) {
249      TBOX box = bounding_box();
250      int x_middle = (box.left() + box.right()) / 2;
251      int y_middle = (box.top() + box.bottom()) / 2;
252      rotated_blob = new TBLOB(*this);
253      const FCOORD &rotation = denorm_.block()->classify_rotation();
254      float target_y =
255          kBlnBaselineOffset + (rotation.y() > 0 ? x_middle - box.left() : box.right() - x_middle);
256      rotated_blob->Normalize(nullptr, &rotation, &denorm_, x_middle, y_middle, 1.0f, 1.0f, 0.0f,
257                              target_y, denorm_.inverse(), denorm_.pix());
258    }
259    return rotated_blob;
260  }
261  void TBLOB::CopyFrom(const TBLOB &src) {
262    Clear();
263    TESSLINE *prev_outline = nullptr;
264    for (TESSLINE *srcline = src.outlines; srcline != nullptr; srcline = srcline->next) {
265      auto *new_outline = new TESSLINE(*srcline);
266      if (outlines == nullptr) {
267        outlines = new_outline;
268      } else {
269        prev_outline->next = new_outline;
270      }
271      prev_outline = new_outline;
272    }
273    denorm_ = src.denorm_;
274  }
275  void TBLOB::Clear() {
276    for (TESSLINE *next_outline = nullptr; outlines != nullptr; outlines = next_outline) {
277      next_outline = outlines->next;
278      delete outlines;
279    }
280  }
281  void TBLOB::Normalize(const BLOCK *block, const FCOORD *rotation, const DENORM *predecessor,
282                        float x_origin, float y_origin, float x_scale, float y_scale,
283                        float final_xshift, float final_yshift, bool inverse, Image pix) {
284    denorm_.SetupNormalization(block, rotation, predecessor, x_origin, y_origin, x_scale, y_scale,
285                               final_xshift, final_yshift);
286    denorm_.set_inverse(inverse);
287    denorm_.set_pix(pix);
288  #if 0
289    for (TESSLINE* outline = outlines; outline != nullptr; outline = outline->next) {
290      outline->Normalize(denorm_);
291    }
292  #else
293    denorm_.LocalNormBlob(this);
294  #endif
295  }
296  void TBLOB::Rotate(const FCOORD rotation) {
297    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
298      outline->Rotate(rotation);
299    }
300  }
301  void TBLOB::Move(const ICOORD vec) {
302    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
303      outline->Move(vec);
304    }
305  }
306  void TBLOB::Scale(float factor) {
307    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
308      outline->Scale(factor);
309    }
310  }
311  void TBLOB::ComputeBoundingBoxes() {
312    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
313      outline->ComputeBoundingBox();
314    }
315  }
316  int TBLOB::NumOutlines() const {
317    int result = 0;
318    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
319      ++result;
320    }
321    return result;
322  }
323  TBOX TBLOB::bounding_box() const {
324    if (outlines == nullptr) {
325      return TBOX(0, 0, 0, 0);
326    }
327    TESSLINE *outline = outlines;
328    TBOX box = outline->bounding_box();
329    for (outline = outline->next; outline != nullptr; outline = outline->next) {
330      box += outline->bounding_box();
331    }
332    return box;
333  }
334  void TBLOB::EliminateDuplicateOutlines() {
335    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
336      TESSLINE *last_outline = outline;
337      for (TESSLINE *other_outline = outline->next; other_outline != nullptr;
338           last_outline = other_outline, other_outline = other_outline->next) {
339        if (outline->SameBox(*other_outline)) {
340          last_outline->next = other_outline->next;
341          other_outline->loop = nullptr;
342          delete other_outline;
343          other_outline = last_outline;
344          outline->is_hole = false;
345        }
346      }
347    }
348  }
349  void TBLOB::CorrectBlobOrder(TBLOB *next) {
350    TBOX box = bounding_box();
351    TBOX next_box = next->bounding_box();
352    if (box.x_middle() > next_box.x_middle()) {
353      std::swap(outlines, next->outlines);
354    }
355  }
356  #ifndef GRAPHICS_DISABLED
357  void TBLOB::plot(ScrollView *window, ScrollView::Color color, ScrollView::Color child_color) {
358    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
359      outline->plot(window, color, child_color);
360    }
361  }
362  #endif 
363  int TBLOB::ComputeMoments(FCOORD *center, FCOORD *second_moments) const {
364    LLSQ accumulator;
365    TBOX box = bounding_box();
366    CollectEdges(box, nullptr, &accumulator, nullptr, nullptr);
367    *center = accumulator.mean_point() + box.botleft();
368    double x2nd = sqrt(accumulator.x_variance());
369    double y2nd = sqrt(accumulator.y_variance());
370    if (x2nd < 1.0) {
371      x2nd = 1.0;
372    }
373    if (y2nd < 1.0) {
374      y2nd = 1.0;
375    }
376    second_moments->set_x(x2nd);
377    second_moments->set_y(y2nd);
378    return accumulator.count();
379  }
380  void TBLOB::GetPreciseBoundingBox(TBOX *precise_box) const {
381    TBOX box = bounding_box();
382    *precise_box = TBOX();
383    CollectEdges(box, precise_box, nullptr, nullptr, nullptr);
384    precise_box->move(box.botleft());
385  }
386  void TBLOB::GetEdgeCoords(const TBOX &box, std::vector<std::vector<int>> &x_coords,
387                            std::vector<std::vector<int>> &y_coords) const {
388    x_coords.clear();
389    x_coords.resize(box.height());
390    y_coords.clear();
391    y_coords.resize(box.width());
392    CollectEdges(box, nullptr, nullptr, &x_coords, &y_coords);
393    for (auto &coord : x_coords) {
394      std::sort(coord.begin(), coord.end());
395    }
396    for (auto &coord : y_coords) {
397      std::sort(coord.begin(), coord.end());
398    }
399  }
400  static void SegmentLLSQ(const FCOORD &pt1, const FCOORD &pt2, LLSQ *accumulator) {
401    FCOORD step(pt2);
402    step -= pt1;
403    int xstart = IntCastRounded(std::min(pt1.x(), pt2.x()));
404    int xend = IntCastRounded(std::max(pt1.x(), pt2.x()));
405    int ystart = IntCastRounded(std::min(pt1.y(), pt2.y()));
406    int yend = IntCastRounded(std::max(pt1.y(), pt2.y()));
407    if (xstart == xend && ystart == yend) {
408      return; 
409    }
410    double weight = step.length() / (xend - xstart + yend - ystart);
411    for (int x = xstart; x < xend; ++x) {
412      double y = pt1.y() + step.y() * (x + 0.5 - pt1.x()) / step.x();
413      accumulator->add(x + 0.5, y, weight);
414    }
415    for (int y = ystart; y < yend; ++y) {
416      double x = pt1.x() + step.x() * (y + 0.5 - pt1.y()) / step.y();
417      accumulator->add(x, y + 0.5, weight);
418    }
419  }
420  static void SegmentCoords(const FCOORD &pt1, const FCOORD &pt2, int x_limit, int y_limit,
421                            std::vector<std::vector<int>> *x_coords,
422                            std::vector<std::vector<int>> *y_coords) {
423    FCOORD step(pt2);
424    step -= pt1;
425    int start = ClipToRange(IntCastRounded(std::min(pt1.x(), pt2.x())), 0, x_limit);
426    int end = ClipToRange(IntCastRounded(std::max(pt1.x(), pt2.x())), 0, x_limit);
427    for (int x = start; x < end; ++x) {
428      int y = IntCastRounded(pt1.y() + step.y() * (x + 0.5 - pt1.x()) / step.x());
429      (*y_coords)[x].push_back(y);
430    }
431    start = ClipToRange(IntCastRounded(std::min(pt1.y(), pt2.y())), 0, y_limit);
432    end = ClipToRange(IntCastRounded(std::max(pt1.y(), pt2.y())), 0, y_limit);
433    for (int y = start; y < end; ++y) {
434      int x = IntCastRounded(pt1.x() + step.x() * (y + 0.5 - pt1.y()) / step.y());
435      (*x_coords)[y].push_back(x);
436    }
437  }
438  static void SegmentBBox(const FCOORD &pt1, const FCOORD &pt2, TBOX *bbox) {
439    FCOORD step(pt2);
440    step -= pt1;
441    int x1 = IntCastRounded(std::min(pt1.x(), pt2.x()));
442    int x2 = IntCastRounded(std::max(pt1.x(), pt2.x()));
443    if (x2 > x1) {
444      int y1 = IntCastRounded(pt1.y() + step.y() * (x1 + 0.5 - pt1.x()) / step.x());
445      int y2 = IntCastRounded(pt1.y() + step.y() * (x2 - 0.5 - pt1.x()) / step.x());
446      TBOX point(x1, std::min(y1, y2), x2, std::max(y1, y2));
447      *bbox += point;
448    }
449    int y1 = IntCastRounded(std::min(pt1.y(), pt2.y()));
450    int y2 = IntCastRounded(std::max(pt1.y(), pt2.y()));
451    if (y2 > y1) {
452      int x1 = IntCastRounded(pt1.x() + step.x() * (y1 + 0.5 - pt1.y()) / step.y());
453      int x2 = IntCastRounded(pt1.x() + step.x() * (y2 - 0.5 - pt1.y()) / step.y());
454      TBOX point(std::min(x1, x2), y1, std::max(x1, x2), y2);
455      *bbox += point;
456    }
457  }
<span onclick='openModal()' class='match'>458  static void CollectEdgesOfRun(const EDGEPT *startpt, const EDGEPT *lastpt, const DENORM &denorm,
459                                const TBOX &box, TBOX *bounding_box, LLSQ *accumulator,
460                                std::vector<std::vector<int>> *x_coords,
461                                std::vector<std::vector<int>> *y_coords) {
462    const C_OUTLINE *outline = startpt->src_outline;
</span>463    int x_limit = box.width() - 1;
464    int y_limit = box.height() - 1;
465    if (outline != nullptr) {
466      const DENORM *root_denorm = denorm.RootDenorm();
467      int step_length = outline->pathlength();
468      int start_index = startpt->start_step;
469      int end_index = lastpt->start_step + lastpt->step_count;
470      if (end_index <= start_index) {
471        end_index += step_length;
472      }
473      ICOORD pos = outline->position_at_index(start_index);
474      FCOORD origin(box.left(), box.bottom());
475      FCOORD f_pos = outline->sub_pixel_pos_at_index(pos, start_index);
476      FCOORD prev_normed;
477      denorm.NormTransform(root_denorm, f_pos, &prev_normed);
478      prev_normed -= origin;
479      for (int index = start_index; index < end_index; ++index) {
480        ICOORD step = outline->step(index % step_length);
481        if (outline->edge_strength_at_index(index % step_length) > 0) {
482          FCOORD f_pos = outline->sub_pixel_pos_at_index(pos, index % step_length);
483          FCOORD pos_normed;
484          denorm.NormTransform(root_denorm, f_pos, &pos_normed);
485          pos_normed -= origin;
486          if (bounding_box != nullptr) {
487            SegmentBBox(pos_normed, prev_normed, bounding_box);
488          }
489          if (accumulator != nullptr) {
490            SegmentLLSQ(pos_normed, prev_normed, accumulator);
491          }
492          if (x_coords != nullptr && y_coords != nullptr) {
493            SegmentCoords(pos_normed, prev_normed, x_limit, y_limit, x_coords, y_coords);
494          }
495          prev_normed = pos_normed;
496        }
497        pos += step;
498      }
499    } else {
500      const EDGEPT *endpt = lastpt->next;
501      const EDGEPT *pt = startpt;
502      do {
503        FCOORD next_pos(pt->next->pos.x - box.left(), pt->next->pos.y - box.bottom());
504        FCOORD pos(pt->pos.x - box.left(), pt->pos.y - box.bottom());
505        if (bounding_box != nullptr) {
506          SegmentBBox(next_pos, pos, bounding_box);
507        }
508        if (accumulator != nullptr) {
509          SegmentLLSQ(next_pos, pos, accumulator);
510        }
511        if (x_coords != nullptr && y_coords != nullptr) {
512          SegmentCoords(next_pos, pos, x_limit, y_limit, x_coords, y_coords);
513        }
514      } while ((pt = pt->next) != endpt);
515    }
516  }
517  void TBLOB::CollectEdges(const TBOX &box, TBOX *bounding_box, LLSQ *llsq,
518                           std::vector<std::vector<int>> *x_coords,
519                           std::vector<std::vector<int>> *y_coords) const {
520    for (const TESSLINE *ol = outlines; ol != nullptr; ol = ol->next) {
521      EDGEPT *loop_pt = ol->FindBestStartPt();
522      EDGEPT *pt = loop_pt;
523      if (pt == nullptr) {
524        continue;
525      }
526      do {
527        if (pt->IsHidden()) {
528          continue;
529        }
530        EDGEPT *last_pt = pt;
531        do {
532          last_pt = last_pt->next;
533        } while (last_pt != loop_pt && !last_pt->IsHidden() &&
534                 last_pt->src_outline == pt->src_outline);
535        last_pt = last_pt->prev;
536        CollectEdgesOfRun(pt, last_pt, denorm_, box, bounding_box, llsq, x_coords, y_coords);
537        pt = last_pt;
538      } while ((pt = pt->next) != loop_pt);
539    }
540  }
541  TWERD *TWERD::PolygonalCopy(bool allow_detailed_fx, WERD *src) {
542    auto *tessword = new TWERD;
543    tessword->latin_script = src->flag(W_SCRIPT_IS_LATIN);
544    C_BLOB_IT b_it(src->cblob_list());
545    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
546      C_BLOB *blob = b_it.data();
547      TBLOB *tblob = TBLOB::PolygonalCopy(allow_detailed_fx, blob);
548      tessword->blobs.push_back(tblob);
549    }
550    return tessword;
551  }
552  void TWERD::BLNormalize(const BLOCK *block, const ROW *row, Image pix, bool inverse, float x_height,
553                          float baseline_shift, bool numeric_mode, tesseract::OcrEngineMode hint,
554                          const TBOX *norm_box, DENORM *word_denorm) {
555    TBOX word_box = bounding_box();
556    if (norm_box != nullptr) {
557      word_box = *norm_box;
558    }
559    float word_middle = (word_box.left() + word_box.right()) / 2.0f;
560    float input_y_offset = 0.0f;
561    auto final_y_offset = static_cast<float>(kBlnBaselineOffset);
562    float scale = kBlnXHeight / x_height;
563    if (row == nullptr) {
564      word_middle = word_box.left();
565      input_y_offset = word_box.bottom();
566      final_y_offset = 0.0f;
567    } else {
568      input_y_offset = row->base_line(word_middle) + baseline_shift;
569    }
570    for (auto blob : blobs) {
571      TBOX blob_box = blob->bounding_box();
572      float mid_x = (blob_box.left() + blob_box.right()) / 2.0f;
573      float baseline = input_y_offset;
574      float blob_scale = scale;
575      if (numeric_mode) {
576        baseline = blob_box.bottom();
577        blob_scale = ClipToRange(kBlnXHeight * 4.0f / (3 * blob_box.height()), scale, scale * 1.5f);
578      } else if (row != nullptr) {
579        baseline = row->base_line(mid_x) + baseline_shift;
580      }
581      blob->Normalize(block, nullptr, nullptr, word_middle, baseline, blob_scale, blob_scale, 0.0f,
582                      final_y_offset, inverse, pix);
583    }
584    if (word_denorm != nullptr) {
585      word_denorm->SetupNormalization(block, nullptr, nullptr, word_middle, input_y_offset, scale,
586                                      scale, 0.0f, final_y_offset);
587      word_denorm->set_inverse(inverse);
588      word_denorm->set_pix(pix);
589    }
590  }
591  void TWERD::CopyFrom(const TWERD &src) {
592    Clear();
593    latin_script = src.latin_script;
594    for (auto blob : src.blobs) {
595      auto *new_blob = new TBLOB(*blob);
596      blobs.push_back(new_blob);
597    }
598  }
599  void TWERD::Clear() {
600    for (auto blob : blobs) {
601      delete blob;
602    }
603    blobs.clear();
604  }
605  void TWERD::ComputeBoundingBoxes() {
606    for (auto &blob : blobs) {
607      blob->ComputeBoundingBoxes();
608    }
609  }
610  TBOX TWERD::bounding_box() const {
611    TBOX result;
612    for (auto blob : blobs) {
613      TBOX box = blob->bounding_box();
614      result += box;
615    }
616    return result;
617  }
618  void TWERD::MergeBlobs(unsigned start, unsigned end) {
619    if (end > blobs.size()) {
620      end = blobs.size();
621    }
622    if (start >= end) {
623      return; 
624    }
625    TESSLINE *outline = blobs[start]->outlines;
626    for (auto i = start + 1; i < end; ++i) {
627      TBLOB *next_blob = blobs[i];
628      if (outline == nullptr) {
629        blobs[start]->outlines = next_blob->outlines;
630        outline = blobs[start]->outlines;
631      } else {
632        while (outline->next != nullptr) {
633          outline = outline->next;
634        }
635        outline->next = next_blob->outlines;
636        next_blob->outlines = nullptr;
637      }
638      delete next_blob;
639      blobs[i] = nullptr;
640    }
641    for (auto i = start + 1; i < end && start + 1 < blobs.size(); ++i) {
642      blobs.erase(blobs.begin() + start + 1);
643    }
644  }
645  #ifndef GRAPHICS_DISABLED
646  void TWERD::plot(ScrollView *window) {
647    ScrollView::Color color = WERD::NextColor(ScrollView::BLACK);
648    for (auto &blob : blobs) {
649      blob->plot(window, color, ScrollView::BROWN);
650      color = WERD::NextColor(color);
651    }
652  }
653  #endif 
654  bool divisible_blob(TBLOB *blob, bool italic_blob, TPOINT *location) {
655    if (blob->outlines == nullptr || blob->outlines->next == nullptr) {
656      return false; 
657    }
658    int max_gap = 0;
659    TPOINT vertical = italic_blob ? kDivisibleVerticalItalic : kDivisibleVerticalUpright;
660    for (TESSLINE *outline1 = blob->outlines; outline1 != nullptr; outline1 = outline1->next) {
661      if (outline1->is_hole) {
662        continue; 
663      }
664      TPOINT mid_pt1((outline1->topleft.x + outline1->botright.x) / 2,
665                     (outline1->topleft.y + outline1->botright.y) / 2);
666      int mid_prod1 = mid_pt1.cross(vertical);
667      int min_prod1, max_prod1;
668      outline1->MinMaxCrossProduct(vertical, &min_prod1, &max_prod1);
669      for (TESSLINE *outline2 = outline1->next; outline2 != nullptr; outline2 = outline2->next) {
670        if (outline2->is_hole) {
671          continue; 
672        }
673        TPOINT mid_pt2((outline2->topleft.x + outline2->botright.x) / 2,
674                       (outline2->topleft.y + outline2->botright.y) / 2);
675        int mid_prod2 = mid_pt2.cross(vertical);
676        int min_prod2, max_prod2;
677        outline2->MinMaxCrossProduct(vertical, &min_prod2, &max_prod2);
678        int mid_gap = abs(mid_prod2 - mid_prod1);
679        int overlap = std::min(max_prod1, max_prod2) - std::max(min_prod1, min_prod2);
680        if (mid_gap - overlap / 4 > max_gap) {
681          max_gap = mid_gap - overlap / 4;
682          *location = mid_pt1;
683          *location += mid_pt2;
684          *location /= 2;
685        }
686      }
687    }
688    return max_gap > vertical.y;
689  }
690  void divide_blobs(TBLOB *blob, TBLOB *other_blob, bool italic_blob, const TPOINT &location) {
691    TPOINT vertical = italic_blob ? kDivisibleVerticalItalic : kDivisibleVerticalUpright;
692    TESSLINE *outline1 = nullptr;
693    TESSLINE *outline2 = nullptr;
694    TESSLINE *outline = blob->outlines;
695    blob->outlines = nullptr;
696    int location_prod = location.cross(vertical);
697    while (outline != nullptr) {
698      TPOINT mid_pt((outline->topleft.x + outline->botright.x) / 2,
699                    (outline->topleft.y + outline->botright.y) / 2);
700      int mid_prod = mid_pt.cross(vertical);
701      if (mid_prod < location_prod) {
702        if (outline1) {
703          outline1->next = outline;
704        } else {
705          blob->outlines = outline;
706        }
707        outline1 = outline;
708      } else {
709        if (outline2) {
710          outline2->next = outline;
711        } else {
712          other_blob->outlines = outline;
713        }
714        outline2 = outline;
715      }
716      outline = outline->next;
717    }
718    if (outline1) {
719      outline1->next = nullptr;
720    }
721    if (outline2) {
722      outline2->next = nullptr;
723    }
724  }
725  } 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_parser.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_PARSER_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_PARSER_HPP
3  namespace boost{
4  namespace BOOST_REGEX_DETAIL_NS{
5  #ifdef BOOST_REGEX_MSVC
6  #pragma warning(push)
7  #pragma warning(disable:4244 4459)
8  #if BOOST_REGEX_MSVC < 1910
9  #pragma warning(disable:4800)
10  #endif
11  #endif
12  inline std::intmax_t umax(std::integral_constant<bool, false> const&)
13  {
14     return std::numeric_limits<std::intmax_t>::is_specialized ? (std::numeric_limits<std::intmax_t>::max)() : INT_MAX;
15  }
16  inline std::intmax_t umax(std::integral_constant<bool, true> const&)
17  {
18     return (std::numeric_limits<std::size_t>::max)();
19  }
20  inline std::intmax_t umax()
21  {
22     return umax(std::integral_constant<bool, std::numeric_limits<std::intmax_t>::digits >= std::numeric_limits<std::size_t>::digits>());
23  }
24  template <class charT, class traits>
25  class basic_regex_parser : public basic_regex_creator<charT, traits>
26  {
27  public:
28     basic_regex_parser(regex_data<charT, traits>* data);
29     void parse(const charT* p1, const charT* p2, unsigned flags);
<span onclick='openModal()' class='match'>30     void fail(regex_constants::error_type error_code, std::ptrdiff_t position);
31     void fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos);
</span>32     void fail(regex_constants::error_type error_code, std::ptrdiff_t position, const std::string& message)
33     {
34        fail(error_code, position, message, position);
35     }
36     bool parse_all();
37     bool parse_basic();
38     bool parse_extended();
39     bool parse_literal();
40     bool parse_open_paren();
41     bool parse_basic_escape();
42     bool parse_extended_escape();
43     bool parse_match_any();
44     bool parse_repeat(std::size_t low = 0, std::size_t high = (std::numeric_limits<std::size_t>::max)());
45     bool parse_repeat_range(bool isbasic);
46     bool parse_alt();
47     bool parse_set();
48     bool parse_backref();
49     void parse_set_literal(basic_char_set<charT, traits>& char_set);
50     bool parse_inner_set(basic_char_set<charT, traits>& char_set);
51     bool parse_QE();
52     bool parse_perl_extension();
53     bool parse_perl_verb();
54     bool match_verb(const char*);
55     bool add_emacs_code(bool negate);
56     bool unwind_alts(std::ptrdiff_t last_paren_start);
57     digraph<charT> get_next_set_literal(basic_char_set<charT, traits>& char_set);
58     charT unescape_character();
59     regex_constants::syntax_option_type parse_options();
60  private:
61     typedef bool (basic_regex_parser::*parser_proc_type)();
62     typedef typename traits::string_type string_type;
63     typedef typename traits::char_class_type char_class_type;
64     parser_proc_type           m_parser_proc;    
65     const charT*               m_base;           
66     const charT*               m_end;            
67     const charT*               m_position;       
68     unsigned                   m_mark_count;     
69     int                        m_mark_reset;     
70     unsigned                   m_max_mark;       
71     std::ptrdiff_t             m_paren_start;    
72     std::ptrdiff_t             m_alt_insert_point; 
73     bool                       m_has_case_change; 
74     unsigned                   m_recursion_count; 
75     unsigned                   m_max_backref;     
76  #if defined(BOOST_REGEX_MSVC) && defined(_M_IX86)
77     static_assert(sizeof(long) >= sizeof(void*), "Long isn't long enough!");
78     std::vector<long>           m_alt_jumps;      
79  #else
80     std::vector<std::ptrdiff_t> m_alt_jumps;      
81  #endif
82     basic_regex_parser& operator=(const basic_regex_parser&);
83     basic_regex_parser(const basic_regex_parser&);
84  };
85  template <class charT, class traits>
86  basic_regex_parser<charT, traits>::basic_regex_parser(regex_data<charT, traits>* data)
87     : basic_regex_creator<charT, traits>(data), m_parser_proc(), m_base(0), m_end(0), m_position(0), 
88     m_mark_count(0), m_mark_reset(-1), m_max_mark(0), m_paren_start(0), m_alt_insert_point(0), m_has_case_change(false), m_recursion_count(0), m_max_backref(0)
89  {
90  }
91  template <class charT, class traits>
92  void basic_regex_parser<charT, traits>::parse(const charT* p1, const charT* p2, unsigned l_flags)
93  {
94     this->init(l_flags);
95     m_position = m_base = p1;
96     m_end = p2;
97     if((p1 == p2) && 
98        (
99           ((l_flags & regbase::main_option_type) != regbase::perl_syntax_group)
100           || (l_flags & regbase::no_empty_expressions)
101        )
102       )
103     {
104        fail(regex_constants::error_empty, 0);
105        return;
106     }
107     switch(l_flags & regbase::main_option_type)
108     {
109     case regbase::perl_syntax_group:
110        {
111           m_parser_proc = &basic_regex_parser<charT, traits>::parse_extended;
112           re_brace* br = static_cast<re_brace*>(this->append_state(syntax_element_startmark, sizeof(re_brace)));
113           br->index = 0;
114           br->icase = this->flags() & regbase::icase;
115           break;
116        }
117     case regbase::basic_syntax_group:
118        m_parser_proc = &basic_regex_parser<charT, traits>::parse_basic;
119        break;
120     case regbase::literal:
121        m_parser_proc = &basic_regex_parser<charT, traits>::parse_literal;
122        break;
123     default:
124        fail(regex_constants::error_unknown, 0, "An invalid combination of regular expression syntax flags was used.");
125        return;
126     }
127     bool result = parse_all();
128     unwind_alts(-1);
129     this->flags(l_flags);
130     if(!result)
131     {
132        fail(regex_constants::error_paren, std::distance(m_base, m_position), "Found a closing ) with no corresponding opening parenthesis.");
133        return;
134     }
135     if(this->m_pdata->m_status)
136        return;
137     this->m_pdata->m_mark_count = 1u + (std::size_t)m_mark_count;
138     if (m_max_backref > m_mark_count)
139     {
140        fail(regex_constants::error_backref, std::distance(m_base, m_position), "Found a backreference to a non-existant sub-expression.");
141     }
142     this->finalize(p1, p2);
143  }
144  template <class charT, class traits>
145  void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position)
146  {
147     std::string message = this->m_pdata->m_ptraits->error_string(error_code);
148     fail(error_code, position, message);
149  }
150  template <class charT, class traits>
151  void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos)
152  {
153     if(0 == this->m_pdata->m_status) 
154        this->m_pdata->m_status = error_code;
155     m_position = m_end; 
156     if(start_pos == position)
157        start_pos = (std::max)(static_cast<std::ptrdiff_t>(0), position - static_cast<std::ptrdiff_t>(10));
158     std::ptrdiff_t end_pos = (std::min)(position + static_cast<std::ptrdiff_t>(10), static_cast<std::ptrdiff_t>(m_end - m_base));
159     if(error_code != regex_constants::error_empty)
160     {
161        if((start_pos != 0) || (end_pos != (m_end - m_base)))
162           message += "  The error occurred while parsing the regular expression fragment: '";
163        else
164           message += "  The error occurred while parsing the regular expression: '";
165        if(start_pos != end_pos)
166        {
167           message += std::string(m_base + start_pos, m_base + position);
168           message += ">>>HERE>>>";
169           message += std::string(m_base + position, m_base + end_pos);
170        }
171        message += "'.";
172     }
173  #ifndef BOOST_NO_EXCEPTIONS
174     if(0 == (this->flags() & regex_constants::no_except))
175     {
176        boost::regex_error e(message, error_code, position);
177        e.raise();
178     }
179  #else
180     (void)position; 
181  #endif
182  }
183  template <class charT, class traits>
184  bool basic_regex_parser<charT, traits>::parse_all()
185  {
186     if (++m_recursion_count > 400)
187     {
188        fail(boost::regex_constants::error_complexity, m_position - m_base, "Exceeded nested brace limit.");
189     }
190     bool result = true;
191     while(result && (m_position != m_end))
192     {
193        result = (this->*m_parser_proc)();
194     }
195     --m_recursion_count;
196     return result;
197  }
198  #ifdef BOOST_REGEX_MSVC
199  #pragma warning(push)
200  #pragma warning(disable:4702)
201  #endif
202  template <class charT, class traits>
203  bool basic_regex_parser<charT, traits>::parse_basic()
204  {
205     switch(this->m_traits.syntax_type(*m_position))
206     {
207     case regex_constants::syntax_escape:
208        return parse_basic_escape();
209     case regex_constants::syntax_dot:
210        return parse_match_any();
211     case regex_constants::syntax_caret:
212        ++m_position;
213        this->append_state(syntax_element_start_line);
214        break;
215     case regex_constants::syntax_dollar:
216        ++m_position;
217        this->append_state(syntax_element_end_line);
218        break;
219     case regex_constants::syntax_star:
220        if(!(this->m_last_state) || (this->m_last_state->type == syntax_element_start_line))
221           return parse_literal();
222        else
223        {
224           ++m_position;
225           return parse_repeat();
226        }
227     case regex_constants::syntax_plus:
228        if(!(this->m_last_state) || (this->m_last_state->type == syntax_element_start_line) || !(this->flags() & regbase::emacs_ex))
229           return parse_literal();
230        else
231        {
232           ++m_position;
233           return parse_repeat(1);
234        }
235     case regex_constants::syntax_question:
236        if(!(this->m_last_state) || (this->m_last_state->type == syntax_element_start_line) || !(this->flags() & regbase::emacs_ex))
237           return parse_literal();
238        else
239        {
240           ++m_position;
241           return parse_repeat(0, 1);
242        }
243     case regex_constants::syntax_open_set:
244        return parse_set();
245     case regex_constants::syntax_newline:
246        if(this->flags() & regbase::newline_alt)
247           return parse_alt();
248        else
249           return parse_literal();
250     default:
251        return parse_literal();
252     }
253     return true;
254  }
255  #ifdef BOOST_REGEX_MSVC
256  #  pragma warning(push)
257  #if BOOST_REGEX_MSVC >= 1800
258  #pragma warning(disable:26812)
259  #endif
260  #endif
261  template <class charT, class traits>
262  bool basic_regex_parser<charT, traits>::parse_extended()
263  {
264     bool result = true;
265     switch(this->m_traits.syntax_type(*m_position))
266     {
267     case regex_constants::syntax_open_mark:
268        return parse_open_paren();
269     case regex_constants::syntax_close_mark:
270        return false;
271     case regex_constants::syntax_escape:
272        return parse_extended_escape();
273     case regex_constants::syntax_dot:
274        return parse_match_any();
275     case regex_constants::syntax_caret:
276        ++m_position;
277        this->append_state(
278           (this->flags() & regex_constants::no_mod_m ? syntax_element_buffer_start : syntax_element_start_line));
279        break;
280     case regex_constants::syntax_dollar:
281        ++m_position;
282        this->append_state(
283           (this->flags() & regex_constants::no_mod_m ? syntax_element_buffer_end : syntax_element_end_line));
284        break;
285     case regex_constants::syntax_star:
286        if(m_position == this->m_base)
287        {
288           fail(regex_constants::error_badrepeat, 0, "The repeat operator \"*\" cannot start a regular expression.");
289           return false;
290        }
291        ++m_position;
292        return parse_repeat();
293     case regex_constants::syntax_question:
294        if(m_position == this->m_base)
295        {
296           fail(regex_constants::error_badrepeat, 0, "The repeat operator \"?\" cannot start a regular expression.");
297           return false;
298        }
299        ++m_position;
300        return parse_repeat(0,1);
301     case regex_constants::syntax_plus:
302        if(m_position == this->m_base)
303        {
304           fail(regex_constants::error_badrepeat, 0, "The repeat operator \"+\" cannot start a regular expression.");
305           return false;
306        }
307        ++m_position;
308        return parse_repeat(1);
309     case regex_constants::syntax_open_brace:
310        ++m_position;
311        return parse_repeat_range(false);
312     case regex_constants::syntax_close_brace:
313        if((this->flags() & regbase::no_perl_ex) == regbase::no_perl_ex)
314        {
315           fail(regex_constants::error_brace, this->m_position - this->m_base, "Found a closing repetition operator } with no corresponding {.");
316           return false;
317        }
318        result = parse_literal();
319        break;
320     case regex_constants::syntax_or:
321        return parse_alt();
322     case regex_constants::syntax_open_set:
323        return parse_set();
324     case regex_constants::syntax_newline:
325        if(this->flags() & regbase::newline_alt)
326           return parse_alt();
327        else
328           return parse_literal();
329     case regex_constants::syntax_hash:
330        if((this->flags() 
331           & (regbase::no_perl_ex|regbase::mod_x))
332           == regbase::mod_x)
333        {
334           while((m_position != m_end) && !is_separator(*m_position++)){}
335           return true;
336        }
337        BOOST_REGEX_FALLTHROUGH;
338     default:
339        result = parse_literal();
340        break;
341     }
342     return result;
343  }
344  #ifdef BOOST_REGEX_MSVC
345  #  pragma warning(pop)
346  #endif
347  #ifdef BOOST_REGEX_MSVC
348  #pragma warning(pop)
349  #endif
350  template <class charT, class traits>
351  bool basic_regex_parser<charT, traits>::parse_literal()
352  {
353     if(
354        ((this->flags() 
355           & (regbase::main_option_type|regbase::mod_x|regbase::no_perl_ex)) 
356              != regbase::mod_x)
357        || !this->m_traits.isctype(*m_position, this->m_mask_space))
358           this->append_literal(*m_position);
359     ++m_position;
360     return true;
361  }
362  template <class charT, class traits>
363  bool basic_regex_parser<charT, traits>::parse_open_paren()
364  {
365     if(++m_position == m_end)
366     {
367        fail(regex_constants::error_paren, m_position - m_base);
368        return false;
369     }
370     if(
371           ((this->flags() & (regbase::main_option_type | regbase::no_perl_ex)) == 0)
372           || ((this->flags() & (regbase::main_option_type | regbase::emacs_ex)) == (regbase::basic_syntax_group|regbase::emacs_ex))
373       )
374     {
375        if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_question)
376           return parse_perl_extension();
377        if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_star)
378           return parse_perl_verb();
379     }
380     unsigned markid = 0;
381     if(0 == (this->flags() & regbase::nosubs))
382     {
383        markid = ++m_mark_count;
384        if(this->flags() & regbase::save_subexpression_location)
385           this->m_pdata->m_subs.push_back(std::pair<std::size_t, std::size_t>(std::distance(m_base, m_position) - 1, 0));
386     }
387     re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_startmark, sizeof(re_brace)));
388     pb->index = markid;
389     pb->icase = this->flags() & regbase::icase;
390     std::ptrdiff_t last_paren_start = this->getoffset(pb);
391     std::ptrdiff_t last_alt_point = m_alt_insert_point;
392     this->m_pdata->m_data.align();
393     m_alt_insert_point = this->m_pdata->m_data.size();
394     regex_constants::syntax_option_type opts = this->flags();
395     bool old_case_change = m_has_case_change;
396     m_has_case_change = false; 
397     int mark_reset = m_mark_reset;
398     m_mark_reset = -1;
399     parse_all();
400     if(0 == unwind_alts(last_paren_start))
401        return false;
402     if(m_has_case_change)
403     {
404        static_cast<re_case*>(
405           this->append_state(syntax_element_toggle_case, sizeof(re_case))
406           )->icase = opts & regbase::icase;
407     }
408     this->flags(opts);
409     m_has_case_change = old_case_change;
410     m_mark_reset = mark_reset;
411     if(m_position == m_end)
412     {
413        this->fail(regex_constants::error_paren, std::distance(m_base, m_end));
414        return false;
415     }
416     if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
417        return false;
418     if(markid && (this->flags() & regbase::save_subexpression_location))
419        this->m_pdata->m_subs.at(markid - 1).second = std::distance(m_base, m_position);
420     ++m_position;
421     pb = static_cast<re_brace*>(this->append_state(syntax_element_endmark, sizeof(re_brace)));
422     pb->index = markid;
423     pb->icase = this->flags() & regbase::icase;
424     this->m_paren_start = last_paren_start;
425     this->m_alt_insert_point = last_alt_point;
426     return true;
427  }
428  template <class charT, class traits>
429  bool basic_regex_parser<charT, traits>::parse_basic_escape()
430  {
431     if(++m_position == m_end)
432     {
433        fail(regex_constants::error_paren, m_position - m_base);
434        return false;
435     }
436     bool result = true;
437     switch(this->m_traits.escape_syntax_type(*m_position))
438     {
439     case regex_constants::syntax_open_mark:
440        return parse_open_paren();
441     case regex_constants::syntax_close_mark:
442        return false;
443     case regex_constants::syntax_plus:
444        if(this->flags() & regex_constants::bk_plus_qm)
445        {
446           ++m_position;
447           return parse_repeat(1);
448        }
449        else
450           return parse_literal();
451     case regex_constants::syntax_question:
452        if(this->flags() & regex_constants::bk_plus_qm)
453        {
454           ++m_position;
455           return parse_repeat(0, 1);
456        }
457        else
458           return parse_literal();
459     case regex_constants::syntax_open_brace:
460        if(this->flags() & regbase::no_intervals)
461           return parse_literal();
462        ++m_position;
463        return parse_repeat_range(true);
464     case regex_constants::syntax_close_brace:
465        if(this->flags() & regbase::no_intervals)
466           return parse_literal();
467        fail(regex_constants::error_brace, this->m_position - this->m_base, "Found a closing repetition operator } with no corresponding {.");
468        return false;
469     case regex_constants::syntax_or:
470        if(this->flags() & regbase::bk_vbar)
471           return parse_alt();
472        else
473           result = parse_literal();
474        break;
475     case regex_constants::syntax_digit:
476        return parse_backref();
477     case regex_constants::escape_type_start_buffer:
478        if(this->flags() & regbase::emacs_ex)
479        {
480           ++m_position;
481           this->append_state(syntax_element_buffer_start);
482        }
483        else
484           result = parse_literal();
485        break;
486     case regex_constants::escape_type_end_buffer:
487        if(this->flags() & regbase::emacs_ex)
488        {
489           ++m_position;
490           this->append_state(syntax_element_buffer_end);
491        }
492        else
493           result = parse_literal();
494        break;
495     case regex_constants::escape_type_word_assert:
496        if(this->flags() & regbase::emacs_ex)
497        {
498           ++m_position;
499           this->append_state(syntax_element_word_boundary);
500        }
501        else
502           result = parse_literal();
503        break;
504     case regex_constants::escape_type_not_word_assert:
505        if(this->flags() & regbase::emacs_ex)
506        {
507           ++m_position;
508           this->append_state(syntax_element_within_word);
509        }
510        else
511           result = parse_literal();
512        break;
513     case regex_constants::escape_type_left_word:
514        if(this->flags() & regbase::emacs_ex)
515        {
516           ++m_position;
517           this->append_state(syntax_element_word_start);
518        }
519        else
520           result = parse_literal();
521        break;
522     case regex_constants::escape_type_right_word:
523        if(this->flags() & regbase::emacs_ex)
524        {
525           ++m_position;
526           this->append_state(syntax_element_word_end);
527        }
528        else
529           result = parse_literal();
530        break;
531     default:
532        if(this->flags() & regbase::emacs_ex)
533        {
534           bool negate = true;
535           switch(*m_position)
536           {
537           case 'w':
538              negate = false;
539              BOOST_REGEX_FALLTHROUGH;
540           case 'W':
541              {
542              basic_char_set<charT, traits> char_set;
543              if(negate)
544                 char_set.negate();
545              char_set.add_class(this->m_word_mask);
546              if(0 == this->append_set(char_set))
547              {
548                 fail(regex_constants::error_ctype, m_position - m_base);
549                 return false;
550              }
551              ++m_position;
552              return true;
553              }
554           case 's':
555              negate = false;
556              BOOST_REGEX_FALLTHROUGH;
557           case 'S':
558              return add_emacs_code(negate);
559           case 'c':
560           case 'C':
561              fail(regex_constants::error_escape, m_position - m_base, "The \\c and \\C escape sequences are not supported by POSIX basic regular expressions: try the Perl syntax instead.");
562              return false;
563           default:
564              break;
565           }
566        }
567        result = parse_literal();
568        break;
569     }
570     return result;
571  }
572  template <class charT, class traits>
573  bool basic_regex_parser<charT, traits>::parse_extended_escape()
574  {
575     ++m_position;
576     if(m_position == m_end)
577     {
578        fail(regex_constants::error_escape, m_position - m_base, "Incomplete escape sequence found.");
579        return false;
580     }
581     bool negate = false; 
582     switch(this->m_traits.escape_syntax_type(*m_position))
583     {
584     case regex_constants::escape_type_not_class:
585        negate = true;
586        BOOST_REGEX_FALLTHROUGH;
587     case regex_constants::escape_type_class:
588        {
589  escape_type_class_jump:
590           typedef typename traits::char_class_type m_type;
591           m_type m = this->m_traits.lookup_classname(m_position, m_position+1);
592           if(m != 0)
593           {
594              basic_char_set<charT, traits> char_set;
595              if(negate)
596                 char_set.negate();
597              char_set.add_class(m);
598              if(0 == this->append_set(char_set))
599              {
600                 fail(regex_constants::error_ctype, m_position - m_base);
601                 return false;
602              }
603              ++m_position;
604              return true;
605           }
606           this->append_literal(unescape_character());
607           break;
608        }
609     case regex_constants::syntax_digit:
610        return parse_backref();
611     case regex_constants::escape_type_left_word:
612        ++m_position;
613        this->append_state(syntax_element_word_start);
614        break;
615     case regex_constants::escape_type_right_word:
616        ++m_position;
617        this->append_state(syntax_element_word_end);
618        break;
619     case regex_constants::escape_type_start_buffer:
620        ++m_position;
621        this->append_state(syntax_element_buffer_start);
622        break;
623     case regex_constants::escape_type_end_buffer:
624        ++m_position;
625        this->append_state(syntax_element_buffer_end);
626        break;
627     case regex_constants::escape_type_word_assert:
628        ++m_position;
629        this->append_state(syntax_element_word_boundary);
630        break;
631     case regex_constants::escape_type_not_word_assert:
632        ++m_position;
633        this->append_state(syntax_element_within_word);
634        break;
635     case regex_constants::escape_type_Z:
636        ++m_position;
637        this->append_state(syntax_element_soft_buffer_end);
638        break;
639     case regex_constants::escape_type_Q:
640        return parse_QE();
641     case regex_constants::escape_type_C:
642        return parse_match_any();
643     case regex_constants::escape_type_X:
644        ++m_position;
645        this->append_state(syntax_element_combining);
646        break;
647     case regex_constants::escape_type_G:
648        ++m_position;
649        this->append_state(syntax_element_restart_continue);
650        break;
651     case regex_constants::escape_type_not_property:
652        negate = true;
653        BOOST_REGEX_FALLTHROUGH;
654     case regex_constants::escape_type_property:
655        {
656           ++m_position;
657           char_class_type m;
658           if(m_position == m_end)
659           {
660              fail(regex_constants::error_escape, m_position - m_base, "Incomplete property escape found.");
661              return false;
662           }
663           if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_open_brace)
664           {
665              const charT* base = m_position;
666              while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_brace))
667                 ++m_position;
668              if(m_position == m_end)
669              {
670                 fail(regex_constants::error_escape, m_position - m_base, "Closing } missing from property escape sequence.");
671                 return false;
672              }
673              m = this->m_traits.lookup_classname(++base, m_position++);
674           }
675           else
676           {
677              m = this->m_traits.lookup_classname(m_position, m_position+1);
678              ++m_position;
679           }
680           if(m != 0)
681           {
682              basic_char_set<charT, traits> char_set;
683              if(negate)
684                 char_set.negate();
685              char_set.add_class(m);
686              if(0 == this->append_set(char_set))
687              {
688                 fail(regex_constants::error_ctype, m_position - m_base);
689                 return false;
690              }
691              return true;
692           }
693           fail(regex_constants::error_ctype, m_position - m_base, "Escape sequence was neither a valid property nor a valid character class name.");
694           return false;
695        }
696     case regex_constants::escape_type_reset_start_mark:
697        if(0 == (this->flags() & (regbase::main_option_type | regbase::no_perl_ex)))
698        {
699           re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_startmark, sizeof(re_brace)));
700           pb->index = -5;
701           pb->icase = this->flags() & regbase::icase;
702           this->m_pdata->m_data.align();
703           ++m_position;
704           return true;
705        }
706        goto escape_type_class_jump;
707     case regex_constants::escape_type_line_ending:
708        if(0 == (this->flags() & (regbase::main_option_type | regbase::no_perl_ex)))
709        {
710           const charT* e = get_escape_R_string<charT>();
711           const charT* old_position = m_position;
712           const charT* old_end = m_end;
713           const charT* old_base = m_base;
714           m_position = e;
715           m_base = e;
716           m_end = e + traits::length(e);
717           bool r = parse_all();
718           m_position = ++old_position;
719           m_end = old_end;
720           m_base = old_base;
721           return r;
722        }
723        goto escape_type_class_jump;
724     case regex_constants::escape_type_extended_backref:
725        if(0 == (this->flags() & (regbase::main_option_type | regbase::no_perl_ex)))
726        {
727           bool have_brace = false;
728           bool negative = false;
729           static const char incomplete_message[] = "Incomplete \\g escape found.";
730           if(++m_position == m_end)
731           {
732              fail(regex_constants::error_escape, m_position - m_base, incomplete_message);
733              return false;
734           }
735           regex_constants::syntax_type syn = this->m_traits.syntax_type(*m_position);
736           regex_constants::syntax_type syn_end = 0;
737           if((syn == regex_constants::syntax_open_brace) 
738              || (syn == regex_constants::escape_type_left_word)
739              || (syn == regex_constants::escape_type_end_buffer))
740           {
741              if(++m_position == m_end)
742              {
743                 fail(regex_constants::error_escape, m_position - m_base, incomplete_message);
744                 return false;
745              }
746              have_brace = true;
747              switch(syn)
748              {
749              case regex_constants::syntax_open_brace:
750                 syn_end = regex_constants::syntax_close_brace;
751                 break;
752              case regex_constants::escape_type_left_word:
753                 syn_end = regex_constants::escape_type_right_word;
754                 break;
755              default:
756                 syn_end = regex_constants::escape_type_end_buffer;
757                 break;
758              }
759           }
760           negative = (*m_position == static_cast<charT>('-'));
761           if((negative) && (++m_position == m_end))
762           {
763              fail(regex_constants::error_escape, m_position - m_base, incomplete_message);
764              return false;
765           }
766           const charT* pc = m_position;
767           std::intmax_t i = this->m_traits.toi(pc, m_end, 10);
768           if((i < 0) && syn_end)
769           {
770              const charT* base = m_position;
771              while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != syn_end))
772              {
773                 ++m_position;
774              }
775              i = hash_value_from_capture_name(base, m_position);
776              pc = m_position;
777           }
778           if(negative)
779              i = 1 + (static_cast<std::intmax_t>(m_mark_count) - i);
780           if(((i < hash_value_mask) && (i > 0)) || ((i >= hash_value_mask) && (this->m_pdata->get_id((int)i) > 0)))
781           {
782              m_position = pc;
783              re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_backref, sizeof(re_brace)));
784              pb->index = (int)i;
785              pb->icase = this->flags() & regbase::icase;
786              if ((i > m_max_backref) && (i < hash_value_mask))
787                 m_max_backref = i;
788           }
789           else
790           {
791              fail(regex_constants::error_backref, m_position - m_base);
792              return false;
793           }
794           m_position = pc;
795           if(have_brace)
796           {
797              if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != syn_end))
798              {
799                 fail(regex_constants::error_escape, m_position - m_base, incomplete_message);
800                 return false;
801              }
802              ++m_position;
803           }
804           return true;
805        }
806        goto escape_type_class_jump;
807     case regex_constants::escape_type_control_v:
808        if(0 == (this->flags() & (regbase::main_option_type | regbase::no_perl_ex)))
809           goto escape_type_class_jump;
810        BOOST_REGEX_FALLTHROUGH;
811     default:
812        this->append_literal(unescape_character());
813        break;
814     }
815     return true;
816  }
817  template <class charT, class traits>
818  bool basic_regex_parser<charT, traits>::parse_match_any()
819  {
820     ++m_position;
821     static_cast<re_dot*>(
822        this->append_state(syntax_element_wild, sizeof(re_dot))
823        )->mask = static_cast<unsigned char>(this->flags() & regbase::no_mod_s 
824        ? BOOST_REGEX_DETAIL_NS::force_not_newline 
825           : this->flags() & regbase::mod_s ?
826              BOOST_REGEX_DETAIL_NS::force_newline : BOOST_REGEX_DETAIL_NS::dont_care);
827     return true;
828  }
829  template <class charT, class traits>
830  bool basic_regex_parser<charT, traits>::parse_repeat(std::size_t low, std::size_t high)
831  {
832     bool greedy = true;
833     bool possessive = false;
834     std::size_t insert_point;
835     if((m_position != m_end) 
836        && (
837              (0 == (this->flags() & (regbase::main_option_type | regbase::no_perl_ex)))
838              || ((regbase::basic_syntax_group|regbase::emacs_ex) == (this->flags() & (regbase::main_option_type | regbase::emacs_ex)))
839           )
840        )
841     {
842        if ((this->flags() & (regbase::main_option_type | regbase::mod_x | regbase::no_perl_ex)) == regbase::mod_x)
843        {
844           while ((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
845              ++m_position;
846        }
847        if((m_position != m_end) && (this->m_traits.syntax_type(*m_position) == regex_constants::syntax_question))
848        {
849           greedy = false;
850           ++m_position;
851        }
852        if((m_position != m_end)
853           && (0 == (this->flags() & regbase::main_option_type)) 
854           && (this->m_traits.syntax_type(*m_position) == regex_constants::syntax_plus))
855        {
856           possessive = true;
857           ++m_position;
858        }
859     }
860     if(0 == this->m_last_state)
861     {
862        fail(regex_constants::error_badrepeat, std::distance(m_base, m_position), "Nothing to repeat.");
863        return false;
864     }
865     if(this->m_last_state->type == syntax_element_endmark)
866     {
867        insert_point = this->m_paren_start;
868     }
869     else if((this->m_last_state->type == syntax_element_literal) && (static_cast<re_literal*>(this->m_last_state)->length > 1))
870     {
871        re_literal* lit = static_cast<re_literal*>(this->m_last_state);
872        charT c = (static_cast<charT*>(static_cast<void*>(lit+1)))[lit->length - 1];
873        lit->length -= 1;
874        lit = static_cast<re_literal*>(this->append_state(syntax_element_literal, sizeof(re_literal) + sizeof(charT)));
875        lit->length = 1;
876        (static_cast<charT*>(static_cast<void*>(lit+1)))[0] = c;
877        insert_point = this->getoffset(this->m_last_state);
878     }
879     else
880     {
881        switch(this->m_last_state->type)
882        {
883        case syntax_element_start_line:
884        case syntax_element_end_line:
885        case syntax_element_word_boundary:
886        case syntax_element_within_word:
887        case syntax_element_word_start:
888        case syntax_element_word_end:
889        case syntax_element_buffer_start:
890        case syntax_element_buffer_end:
891        case syntax_element_alt:
892        case syntax_element_soft_buffer_end:
893        case syntax_element_restart_continue:
894        case syntax_element_jump:
895        case syntax_element_startmark:
896        case syntax_element_backstep:
897        case syntax_element_toggle_case:
898           fail(regex_constants::error_badrepeat, m_position - m_base);
899           return false;
900        default:
901           break;
902        }
903        insert_point = this->getoffset(this->m_last_state);
904     }
905     re_repeat* rep = static_cast<re_repeat*>(this->insert_state(insert_point, syntax_element_rep, re_repeater_size));
906     rep->min = low;
907     rep->max = high;
908     rep->greedy = greedy;
909     rep->leading = false;
910     std::ptrdiff_t rep_off = this->getoffset(rep);
911     re_jump* jmp = static_cast<re_jump*>(this->append_state(syntax_element_jump, sizeof(re_jump)));
912     jmp->alt.i = rep_off - this->getoffset(jmp);
913     this->m_pdata->m_data.align();
914     rep = static_cast<re_repeat*>(this->getaddress(rep_off));
915     rep->alt.i = this->m_pdata->m_data.size() - rep_off;
916     if(possessive)
917     {
918        if(m_position != m_end)
919        {
920           bool contin = false;
921           do
922           {
923              if ((this->flags() & (regbase::main_option_type | regbase::mod_x | regbase::no_perl_ex)) == regbase::mod_x)
924              {
925                 while ((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
926                    ++m_position;
927              }
928              if (m_position != m_end)
929              {
930                 switch (this->m_traits.syntax_type(*m_position))
931                 {
932                 case regex_constants::syntax_star:
933                 case regex_constants::syntax_plus:
934                 case regex_constants::syntax_question:
935                 case regex_constants::syntax_open_brace:
936                    fail(regex_constants::error_badrepeat, m_position - m_base);
937                    return false;
938                 case regex_constants::syntax_open_mark:
939                    if ((m_position + 2 < m_end) && this->m_traits.syntax_type(*(m_position + 1)) == regex_constants::syntax_question
940                       && this->m_traits.syntax_type(*(m_position + 2)) == regex_constants::syntax_hash)
941                    {
942                       while ((m_position != m_end)
943                          && (this->m_traits.syntax_type(*m_position++) != regex_constants::syntax_close_mark)) {
944                       }
945                       contin = true;
946                    }
947                    else
948                       contin = false;
949                    break;
950                 default:
951                    contin = false;
952                 }
953              }
954              else
955                 contin = false;
956           } while (contin);
957        }
958        re_brace* pb = static_cast<re_brace*>(this->insert_state(insert_point, syntax_element_startmark, sizeof(re_brace)));
959        pb->index = -3;
960        pb->icase = this->flags() & regbase::icase;
961        jmp = static_cast<re_jump*>(this->insert_state(insert_point + sizeof(re_brace), syntax_element_jump, sizeof(re_jump)));
962        this->m_pdata->m_data.align();
963        jmp->alt.i = this->m_pdata->m_data.size() - this->getoffset(jmp);
964        pb = static_cast<re_brace*>(this->append_state(syntax_element_endmark, sizeof(re_brace)));
965        pb->index = -3;
966        pb->icase = this->flags() & regbase::icase;
967     }
968     return true;
969  }
970  template <class charT, class traits>
971  bool basic_regex_parser<charT, traits>::parse_repeat_range(bool isbasic)
972  {
973     static const char incomplete_message[] = "Missing } in quantified repetition.";
974     std::size_t min, max;
975     std::intmax_t v;
976     while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
977        ++m_position;
978     if(this->m_position == this->m_end)
979     {
980        if(this->flags() & (regbase::main_option_type | regbase::no_perl_ex))
981        {
982           fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
983           return false;
984        }
985        --m_position;
986        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_brace) --m_position;
987        return parse_literal();
988     }
989     v = this->m_traits.toi(m_position, m_end, 10);
990     if((v < 0) || (v > umax()))
991     {
992        if(this->flags() & (regbase::main_option_type | regbase::no_perl_ex))
993        {
994           fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
995           return false;
996        }
997        --m_position;
998        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_brace) --m_position;
999        return parse_literal();
1000     }
1001     while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
1002        ++m_position;
1003     if(this->m_position == this->m_end)
1004     {
1005        if(this->flags() & (regbase::main_option_type | regbase::no_perl_ex))
1006        {
1007           fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
1008           return false;
1009        }
1010        --m_position;
1011        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_brace) --m_position;
1012        return parse_literal();
1013     }
1014     min = static_cast<std::size_t>(v);
1015     if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_comma)
1016     {
1017        ++m_position;
1018        while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
1019           ++m_position;
1020        if(this->m_position == this->m_end)
1021        {
1022           if(this->flags() & (regbase::main_option_type | regbase::no_perl_ex))
1023           {
1024              fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
1025              return false;
1026           }
1027           --m_position;
1028           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_brace) --m_position;
1029           return parse_literal();
1030        }
1031        v = this->m_traits.toi(m_position, m_end, 10);
1032        max = ((v >= 0) && (v < umax())) ? (std::size_t)v : (std::numeric_limits<std::size_t>::max)();
1033     }
1034     else
1035     {
1036        max = min;
1037     }
1038     while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
1039        ++m_position;
1040     if(this->m_position == this->m_end)
1041     {
1042        if(this->flags() & (regbase::main_option_type | regbase::no_perl_ex))
1043        {
1044           fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
1045           return false;
1046        }
1047        --m_position;
1048        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_brace) --m_position;
1049        return parse_literal();
1050     }
1051     if(isbasic)
1052     {
1053        if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_escape)
1054        {
1055           ++m_position;
1056           if(this->m_position == this->m_end)
1057           {
1058              fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
1059              return false;
1060           }
1061        }
1062        else
1063        {
1064           fail(regex_constants::error_brace, this->m_position - this->m_base, incomplete_message);
1065           return false;
1066        }
1067     }
1068     if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_brace)
1069        ++m_position;
1070     else
1071     {
1072        --m_position;
1073        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_brace) --m_position;
1074        return parse_literal();
1075     }
1076     if(min > max)
1077     {
1078        m_position -= 2;
1079        while(this->m_traits.isctype(*m_position, this->m_word_mask)) --m_position;
1080           ++m_position;
1081        fail(regex_constants::error_badbrace, m_position - m_base);
1082        return false;
1083     }
1084     return parse_repeat(min, max);
1085  }
1086  template <class charT, class traits>
1087  bool basic_regex_parser<charT, traits>::parse_alt()
1088  {
1089     if(
1090        ((this->m_last_state == 0) || (this->m_last_state->type == syntax_element_startmark))
1091        &&
1092        !(
1093           ((this->flags() & regbase::main_option_type) == regbase::perl_syntax_group)
1094             &&
1095           ((this->flags() & regbase::no_empty_expressions) == 0)
1096          )
1097        )
1098     {
1099        fail(regex_constants::error_empty, this->m_position - this->m_base, "A regular expression cannot start with the alternation operator |.");
1100        return false;
1101     }
1102     if(m_max_mark < m_mark_count)
1103        m_max_mark = m_mark_count;
1104     if(m_mark_reset >= 0)
1105        m_mark_count = m_mark_reset;
1106     ++m_position;
1107     re_syntax_base* pj = this->append_state(BOOST_REGEX_DETAIL_NS::syntax_element_jump, sizeof(re_jump));
1108     std::ptrdiff_t jump_offset = this->getoffset(pj);
1109     re_alt* palt = static_cast<re_alt*>(this->insert_state(this->m_alt_insert_point, syntax_element_alt, re_alt_size));
1110     jump_offset += re_alt_size;
1111     this->m_pdata->m_data.align();
1112     palt->alt.i = this->m_pdata->m_data.size() - this->getoffset(palt);
1113     this->m_alt_insert_point = this->m_pdata->m_data.size();
1114     if(m_has_case_change)
1115     {
1116        static_cast<re_case*>(
1117           this->append_state(syntax_element_toggle_case, sizeof(re_case))
1118           )->icase = this->m_icase;
1119     }
1120     m_alt_jumps.push_back(jump_offset);
1121     return true;
1122  }
1123  template <class charT, class traits>
1124  bool basic_regex_parser<charT, traits>::parse_set()
1125  {
1126     static const char incomplete_message[] = "Character set declaration starting with [ terminated prematurely - either no ] was found or the set had no content.";
1127     ++m_position;
1128     if(m_position == m_end)
1129     {
1130        fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1131        return false;
1132     }
1133     basic_char_set<charT, traits> char_set;
1134     const charT* base = m_position;  
1135     const charT* item_base = m_position;  
1136     while(m_position != m_end)
1137     {
1138        switch(this->m_traits.syntax_type(*m_position))
1139        {
1140        case regex_constants::syntax_caret:
1141           if(m_position == base)
1142           {
1143              char_set.negate();
1144              ++m_position;
1145              item_base = m_position;
1146           }
1147           else
1148              parse_set_literal(char_set);
1149           break;
1150        case regex_constants::syntax_close_set:
1151           if(m_position == item_base)
1152           {
1153              parse_set_literal(char_set);
1154              break;
1155           }
1156           else
1157           {
1158              ++m_position;
1159              if(0 == this->append_set(char_set))
1160              {
1161                 fail(regex_constants::error_ctype, m_position - m_base);
1162                 return false;
1163              }
1164           }
1165           return true;
1166        case regex_constants::syntax_open_set:
1167           if(parse_inner_set(char_set))
1168              break;
1169           return true;
1170        case regex_constants::syntax_escape:
1171           {
1172              ++m_position;
1173              if(this->m_traits.escape_syntax_type(*m_position)
1174                 == regex_constants::escape_type_class)
1175              {
1176                 char_class_type m = this->m_traits.lookup_classname(m_position, m_position+1);
1177                 if(m != 0)
1178                 {
1179                    char_set.add_class(m);
1180                    ++m_position;
1181                    break;
1182                 }
1183              }
1184              else if(this->m_traits.escape_syntax_type(*m_position)
1185                 == regex_constants::escape_type_not_class)
1186              {
1187                 char_class_type m = this->m_traits.lookup_classname(m_position, m_position+1);
1188                 if(m != 0)
1189                 {
1190                    char_set.add_negated_class(m);
1191                    ++m_position;
1192                    break;
1193                 }
1194              }
1195              --m_position;
1196              parse_set_literal(char_set);
1197              break;
1198           }
1199        default:
1200           parse_set_literal(char_set);
1201           break;
1202        }
1203     }
1204     return m_position != m_end;
1205  }
1206  template <class charT, class traits>
1207  bool basic_regex_parser<charT, traits>::parse_inner_set(basic_char_set<charT, traits>& char_set)
1208  {
1209     static const char incomplete_message[] = "Character class declaration starting with [ terminated prematurely - either no ] was found or the set had no content.";
1210     if(m_end == ++m_position)
1211     {
1212        fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1213        return false;
1214     }
1215     switch(this->m_traits.syntax_type(*m_position))
1216     {
1217     case regex_constants::syntax_dot:
1218        --m_position;
1219        parse_set_literal(char_set);
1220        return true;
1221     case regex_constants::syntax_colon:
1222        {
1223        if((this->flags() & (regbase::main_option_type | regbase::no_char_classes)) 
1224           == (regbase::basic_syntax_group  | regbase::no_char_classes))
1225        {
1226           --m_position;
1227           parse_set_literal(char_set);
1228           return true;
1229        }
1230        if(m_end == ++m_position)
1231        {
1232           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1233           return false;
1234        }
1235        const charT* name_first = m_position;
1236        if(m_end == ++m_position)
1237        {
1238           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1239           return false;
1240        }
1241        while((m_position != m_end) 
1242           && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_colon)) 
1243           ++m_position;
1244        const charT* name_last = m_position;
1245        if(m_end == m_position)
1246        {
1247           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1248           return false;
1249        }
1250        if((m_end == ++m_position) 
1251           || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
1252        {
1253           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1254           return false;
1255        }
1256        bool negated = false;
1257        if(this->m_traits.syntax_type(*name_first) == regex_constants::syntax_caret)
1258        {
1259           ++name_first;
1260           negated = true;
1261        }
1262        typedef typename traits::char_class_type m_type;
1263        m_type m = this->m_traits.lookup_classname(name_first, name_last);
1264        if(m == 0)
1265        {
1266           if(char_set.empty() && (name_last - name_first == 1))
1267           {
1268              ++m_position;
1269              if( (m_position != m_end) 
1270                 && (this->m_traits.syntax_type(*m_position) 
1271                    == regex_constants::syntax_close_set))
1272              {
1273                 if(this->m_traits.escape_syntax_type(*name_first) 
1274                    == regex_constants::escape_type_left_word)
1275                 {
1276                    ++m_position;
1277                    this->append_state(syntax_element_word_start);
1278                    return false;
1279                 }
1280                 if(this->m_traits.escape_syntax_type(*name_first) 
1281                    == regex_constants::escape_type_right_word)
1282                 {
1283                    ++m_position;
1284                    this->append_state(syntax_element_word_end);
1285                    return false;
1286                 }
1287              }
1288           }
1289           fail(regex_constants::error_ctype, name_first - m_base);
1290           return false;
1291        }
1292        if(!negated)
1293           char_set.add_class(m);
1294        else
1295           char_set.add_negated_class(m);
1296        ++m_position;
1297        break;
1298     }
1299     case regex_constants::syntax_equal:
1300        {
1301        if(m_end == ++m_position)
1302        {
1303           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1304           return false;
1305        }
1306        const charT* name_first = m_position;
1307        if(m_end == ++m_position)
1308        {
1309           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1310           return false;
1311        }
1312        while((m_position != m_end) 
1313           && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_equal)) 
1314           ++m_position;
1315        const charT* name_last = m_position;
1316        if(m_end == m_position)
1317        {
1318           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1319           return false;
1320        }
1321        if((m_end == ++m_position) 
1322           || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
1323        {
1324           fail(regex_constants::error_brack, m_position - m_base, incomplete_message);
1325           return false;
1326        }
1327        string_type m = this->m_traits.lookup_collatename(name_first, name_last);
1328        if(m.empty() || (m.size() > 2))
1329        {
1330           fail(regex_constants::error_collate, name_first - m_base);
1331           return false;
1332        }
1333        digraph<charT> d;
1334        d.first = m[0];
1335        if(m.size() > 1)
1336           d.second = m[1];
1337        else
1338           d.second = 0;
1339        char_set.add_equivalent(d);
1340        ++m_position;
1341        break;
1342     }
1343     default:
1344        --m_position;
1345        parse_set_literal(char_set);
1346        break;
1347     }
1348     return true;
1349  }
1350  template <class charT, class traits>
1351  void basic_regex_parser<charT, traits>::parse_set_literal(basic_char_set<charT, traits>& char_set)
1352  {
1353     digraph<charT> start_range(get_next_set_literal(char_set));
1354     if(m_end == m_position)
1355     {
1356        fail(regex_constants::error_brack, m_position - m_base);
1357        return;
1358     }
1359     if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_dash)
1360     {
1361        if(m_end == ++m_position)
1362        {
1363           fail(regex_constants::error_brack, m_position - m_base);
1364           return;
1365        }
1366        if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set)
1367        {
1368           digraph<charT> end_range = get_next_set_literal(char_set);
1369           char_set.add_range(start_range, end_range);
1370           if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_dash)
1371           {
1372              if(m_end == ++m_position)
1373              {
1374                 fail(regex_constants::error_brack, m_position - m_base);
1375                 return;
1376              }
1377              if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_set)
1378              {
1379                 --m_position;
1380                 return;
1381              }
1382              fail(regex_constants::error_range, m_position - m_base);
1383              return;
1384           }
1385           return;
1386        }
1387        --m_position;
1388     }
1389     char_set.add_single(start_range);
1390  }
1391  template <class charT, class traits>
1392  digraph<charT> basic_regex_parser<charT, traits>::get_next_set_literal(basic_char_set<charT, traits>& char_set)
1393  {
1394     digraph<charT> result;
1395     switch(this->m_traits.syntax_type(*m_position))
1396     {
1397     case regex_constants::syntax_dash:
1398        if(!char_set.empty())
1399        {
1400           if((++m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
1401           {
1402              fail(regex_constants::error_range, m_position - m_base);
1403              return result;
1404           }
1405           --m_position;
1406        }
1407        result.first = *m_position++;
1408        return result;
1409     case regex_constants::syntax_escape:
1410        if(this->flags() & regex_constants::no_escape_in_lists)
1411        {
1412           result = *m_position++;
1413           break;
1414        }
1415        ++m_position;
1416        result = unescape_character();
1417        break;
1418     case regex_constants::syntax_open_set:
1419     {
1420        if(m_end == ++m_position)
1421        {
1422           fail(regex_constants::error_collate, m_position - m_base);
1423           return result;
1424        }
1425        if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_dot)
1426        {
1427           --m_position;
1428           result.first = *m_position;
1429           ++m_position;
1430           return result;
1431        }
1432        if(m_end == ++m_position)
1433        {
1434           fail(regex_constants::error_collate, m_position - m_base);
1435           return result;
1436        }
1437        const charT* name_first = m_position;
1438        if(m_end == ++m_position)
1439        {
1440           fail(regex_constants::error_collate, name_first - m_base);
1441           return result;
1442        }
1443        while((m_position != m_end) 
1444           && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_dot)) 
1445           ++m_position;
1446        const charT* name_last = m_position;
1447        if(m_end == m_position)
1448        {
1449           fail(regex_constants::error_collate, name_first - m_base);
1450           return result;
1451        }
1452        if((m_end == ++m_position) 
1453           || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
1454        {
1455           fail(regex_constants::error_collate, name_first - m_base);
1456           return result;
1457        }
1458        ++m_position;
1459        string_type s = this->m_traits.lookup_collatename(name_first, name_last);
1460        if(s.empty() || (s.size() > 2))
1461        {
1462           fail(regex_constants::error_collate, name_first - m_base);
1463           return result;
1464        }
1465        result.first = s[0];
1466        if(s.size() > 1)
1467           result.second = s[1];
1468        else
1469           result.second = 0;
1470        return result;
1471     }
1472     default:
1473        result = *m_position++;
1474     }
1475     return result;
1476  }
1477  template <class charT>
1478  bool valid_value(charT, std::intmax_t v, const std::integral_constant<bool, true>&)
1479  {
1480     return (v >> (sizeof(charT) * CHAR_BIT)) == 0;
1481  }
1482  template <class charT>
1483  bool valid_value(charT, std::intmax_t, const std::integral_constant<bool, false>&)
1484  {
1485     return true; 
1486  }
1487  template <class charT>
1488  bool valid_value(charT c, std::intmax_t v)
1489  {
1490     return valid_value(c, v, std::integral_constant<bool, (sizeof(charT) < sizeof(std::intmax_t))>());
1491  }
1492  template <class charT, class traits>
1493  charT basic_regex_parser<charT, traits>::unescape_character()
1494  {
1495  #ifdef BOOST_REGEX_MSVC
1496  #pragma warning(push)
1497  #pragma warning(disable:4127)
1498  #endif
1499     charT result(0);
1500     if(m_position == m_end)
1501     {
1502        fail(regex_constants::error_escape, m_position - m_base, "Escape sequence terminated prematurely.");
1503        return false;
1504     }
1505     switch(this->m_traits.escape_syntax_type(*m_position))
1506     {
1507     case regex_constants::escape_type_control_a:
1508        result = charT('\a');
1509        break;
1510     case regex_constants::escape_type_e:
1511        result = charT(27);
1512        break;
1513     case regex_constants::escape_type_control_f:
1514        result = charT('\f');
1515        break;
1516     case regex_constants::escape_type_control_n:
1517        result = charT('\n');
1518        break;
1519     case regex_constants::escape_type_control_r:
1520        result = charT('\r');
1521        break;
1522     case regex_constants::escape_type_control_t:
1523        result = charT('\t');
1524        break;
1525     case regex_constants::escape_type_control_v:
1526        result = charT('\v');
1527        break;
1528     case regex_constants::escape_type_word_assert:
1529        result = charT('\b');
1530        break;
1531     case regex_constants::escape_type_ascii_control:
1532        ++m_position;
1533        if(m_position == m_end)
1534        {
1535           --m_position;
1536           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1537           fail(regex_constants::error_escape, m_position - m_base, "ASCII escape sequence terminated prematurely.");
1538           return result;
1539        }
1540        result = static_cast<charT>(*m_position % 32);
1541        break;
1542     case regex_constants::escape_type_hex:
1543        ++m_position;
1544        if(m_position == m_end)
1545        {
1546           --m_position;
1547           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1548           fail(regex_constants::error_escape, m_position - m_base, "Hexadecimal escape sequence terminated prematurely.");
1549           return result;
1550        }
1551        if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_open_brace)
1552        {
1553           ++m_position;
1554           if(m_position == m_end)
1555           {
1556              --m_position;
1557              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1558              fail(regex_constants::error_escape, m_position - m_base, "Missing } in hexadecimal escape sequence.");
1559              return result;
1560           }
1561           std::intmax_t i = this->m_traits.toi(m_position, m_end, 16);
1562           if((m_position == m_end)
1563              || (i < 0)
1564              || ((std::numeric_limits<charT>::is_specialized) && (i > (std::intmax_t)(std::numeric_limits<charT>::max)()))
1565              || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_brace))
1566           {
1567              --m_position;
1568              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1569              fail(regex_constants::error_badbrace, m_position - m_base, "Hexadecimal escape sequence was invalid.");
1570              return result;
1571           }
1572           ++m_position;
1573           result = charT(i);
1574        }
1575        else
1576        {
1577           std::ptrdiff_t len = (std::min)(static_cast<std::ptrdiff_t>(2), static_cast<std::ptrdiff_t>(m_end - m_position));
1578           std::intmax_t i = this->m_traits.toi(m_position, m_position + len, 16);
1579           if((i < 0)
1580              || !valid_value(charT(0), i))
1581           {
1582              --m_position;
1583              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1584              fail(regex_constants::error_escape, m_position - m_base, "Escape sequence did not encode a valid character.");
1585              return result;
1586           }
1587           result = charT(i);
1588        }
1589        return result;
1590     case regex_constants::syntax_digit:
1591        {
1592        std::ptrdiff_t len = (std::min)(std::distance(m_position, m_end), static_cast<std::ptrdiff_t>(4));
1593        const charT* bp = m_position;
1594        std::intmax_t val = this->m_traits.toi(bp, bp + 1, 8);
1595        if(val != 0)
1596        {
1597           --m_position;
1598           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1599           fail(regex_constants::error_escape, m_position - m_base, "Invalid octal escape sequence.");
1600           return result;
1601        }
1602        val = this->m_traits.toi(m_position, m_position + len, 8);
1603        if((val < 0) || (val > (std::intmax_t)(std::numeric_limits<charT>::max)()))
1604        {
1605           --m_position;
1606           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1607           fail(regex_constants::error_escape, m_position - m_base, "Octal escape sequence is invalid.");
1608           return result;
1609        }
1610        return static_cast<charT>(val);
1611        }
1612     case regex_constants::escape_type_named_char:
1613        {
1614           ++m_position;
1615           if(m_position == m_end)
1616           {
1617              --m_position;
1618              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1619              fail(regex_constants::error_escape, m_position - m_base);
1620              return false;
1621           }
1622           if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_open_brace)
1623           {
1624              const charT* base = m_position;
1625              while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_brace))
1626                 ++m_position;
1627              if(m_position == m_end)
1628              {
1629                 --m_position;
1630                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1631                 fail(regex_constants::error_escape, m_position - m_base);
1632                 return false;
1633              }
1634              string_type s = this->m_traits.lookup_collatename(++base, m_position++);
1635              if(s.empty())
1636              {
1637                 --m_position;
1638                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1639                 fail(regex_constants::error_collate, m_position - m_base);
1640                 return false;
1641              }
1642              if(s.size() == 1)
1643              {
1644                 return s[0];
1645              }
1646           }
1647           --m_position;
1648           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1649           fail(regex_constants::error_escape, m_position - m_base);
1650           return false;
1651        }
1652     default:
1653        result = *m_position;
1654        break;
1655     }
1656     ++m_position;
1657     return result;
1658  #ifdef BOOST_REGEX_MSVC
1659  #pragma warning(pop)
1660  #endif
1661  }
1662  template <class charT, class traits>
1663  bool basic_regex_parser<charT, traits>::parse_backref()
1664  {
1665     BOOST_REGEX_ASSERT(m_position != m_end);
1666     const charT* pc = m_position;
1667     std::intmax_t i = this->m_traits.toi(pc, pc + 1, 10);
1668     if((i == 0) || (((this->flags() & regbase::main_option_type) == regbase::perl_syntax_group) && (this->flags() & regbase::no_bk_refs)))
1669     {
1670        charT c = unescape_character();
1671        this->append_literal(c);
1672     }
1673     else if((i > 0))
1674     {
1675        m_position = pc;
1676        re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_backref, sizeof(re_brace)));
1677        pb->index = (int)i;
1678        pb->icase = this->flags() & regbase::icase;
1679        if(i > m_max_backref)
1680           m_max_backref = i;
1681     }
1682     else
1683     {
1684        --m_position;
1685        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
1686        fail(regex_constants::error_backref, m_position - m_base);
1687        return false;
1688     }
1689     return true;
1690  }
1691  template <class charT, class traits>
1692  bool basic_regex_parser<charT, traits>::parse_QE()
1693  {
1694  #ifdef BOOST_REGEX_MSVC
1695  #pragma warning(push)
1696  #pragma warning(disable:4127)
1697  #endif
1698     ++m_position; 
1699     const charT* start = m_position;
1700     const charT* end;
1701     do
1702     {
1703        while((m_position != m_end) 
1704           && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape))
1705           ++m_position;
1706        if(m_position == m_end)
1707        {
1708           end = m_position;
1709           break;  
1710        }
1711        if(++m_position == m_end) 
1712        {
1713           fail(regex_constants::error_escape, m_position - m_base, "Unterminated \\Q...\\E sequence.");
1714           return false;
1715        }
1716        if(this->m_traits.escape_syntax_type(*m_position) == regex_constants::escape_type_E)
1717        {
1718           ++m_position;
1719           end = m_position - 2;
1720           break;
1721        }
1722     }while(true);
1723     while(start != end)
1724     {
1725        this->append_literal(*start);
1726        ++start;
1727     }
1728     return true;
1729  #ifdef BOOST_REGEX_MSVC
1730  #pragma warning(pop)
1731  #endif
1732  }
1733  template <class charT, class traits>
1734  bool basic_regex_parser<charT, traits>::parse_perl_extension()
1735  {
1736     if(++m_position == m_end)
1737     {
1738        --m_position;
1739        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1740        fail(regex_constants::error_perl_extension, m_position - m_base);
1741        return false;
1742     }
1743     if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_hash)
1744     {
1745        while((m_position != m_end) 
1746           && (this->m_traits.syntax_type(*m_position++) != regex_constants::syntax_close_mark))
1747        {}
1748        return true;
1749     }
1750     int markid = 0;
1751     std::ptrdiff_t jump_offset = 0;
1752     re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_startmark, sizeof(re_brace)));
1753     pb->icase = this->flags() & regbase::icase;
1754     std::ptrdiff_t last_paren_start = this->getoffset(pb);
1755     std::ptrdiff_t last_alt_point = m_alt_insert_point;
1756     this->m_pdata->m_data.align();
1757     m_alt_insert_point = this->m_pdata->m_data.size();
1758     std::ptrdiff_t expected_alt_point = m_alt_insert_point;
1759     bool restore_flags = true;
1760     regex_constants::syntax_option_type old_flags = this->flags();
1761     bool old_case_change = m_has_case_change;
1762     m_has_case_change = false;
1763     charT name_delim;
1764     int mark_reset = m_mark_reset;
1765     int max_mark = m_max_mark;
1766     m_mark_reset = -1;
1767     m_max_mark = m_mark_count;
1768     std::intmax_t v;
1769     switch(this->m_traits.syntax_type(*m_position))
1770     {
1771     case regex_constants::syntax_or:
1772        m_mark_reset = m_mark_count;
1773        BOOST_REGEX_FALLTHROUGH;
1774     case regex_constants::syntax_colon:
1775        pb->index = markid = 0;
1776        ++m_position;
1777        break;
1778     case regex_constants::syntax_digit:
1779        {
1780        v = this->m_traits.toi(m_position, m_end, 10);
1781        if((v < 0) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
1782        {
1783           --m_position;
1784           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1785           fail(regex_constants::error_perl_extension, m_position - m_base, "The recursive sub-expression refers to an invalid marking group, or is unterminated.");
1786           return false;
1787        }
1788  insert_recursion:
1789        pb->index = markid = 0;
1790        re_recurse* pr = static_cast<re_recurse*>(this->append_state(syntax_element_recurse, sizeof(re_recurse)));
1791        pr->alt.i = (std::ptrdiff_t)v;
1792        pr->state_id = 0;
1793        static_cast<re_case*>(
1794              this->append_state(syntax_element_toggle_case, sizeof(re_case))
1795              )->icase = this->flags() & regbase::icase;
1796        break;
1797        }
1798     case regex_constants::syntax_plus:
1799        ++m_position;
1800        v = this->m_traits.toi(m_position, m_end, 10);
1801        if((v <= 0) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
1802        {
1803           --m_position;
1804           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1805           fail(regex_constants::error_perl_extension, m_position - m_base, "An invalid or unterminated recursive sub-expression.");
1806           return false;
1807        }
1808        if ((std::numeric_limits<std::intmax_t>::max)() - m_mark_count < v)
1809        {
1810           fail(regex_constants::error_perl_extension, m_position - m_base, "An invalid or unterminated recursive sub-expression.");
1811           return false;
1812        }
1813        v += m_mark_count;
1814        goto insert_recursion;
1815     case regex_constants::syntax_dash:
1816        ++m_position;
1817        v = this->m_traits.toi(m_position, m_end, 10);
1818        if(v <= 0)
1819        {
1820           --m_position;
1821           goto option_group_jump;
1822        }
1823        v = static_cast<std::intmax_t>(m_mark_count) + 1 - v;
1824        if(v <= 0)
1825        {
1826           --m_position;
1827           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1828           fail(regex_constants::error_perl_extension, m_position - m_base, "An invalid or unterminated recursive sub-expression.");
1829           return false;
1830        }
1831        goto insert_recursion;
1832     case regex_constants::syntax_equal:
1833        pb->index = markid = -1;
1834        ++m_position;
1835        jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
1836        this->m_pdata->m_data.align();
1837        m_alt_insert_point = this->m_pdata->m_data.size();
1838        break;
1839     case regex_constants::syntax_not:
1840        pb->index = markid = -2;
1841        ++m_position;
1842        jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
1843        this->m_pdata->m_data.align();
1844        m_alt_insert_point = this->m_pdata->m_data.size();
1845        break;
1846     case regex_constants::escape_type_left_word:
1847        {
1848           if(++m_position == m_end)
1849           {
1850              --m_position;
1851              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1852              fail(regex_constants::error_perl_extension, m_position - m_base);
1853              return false;
1854           }
1855           regex_constants::syntax_type t = this->m_traits.syntax_type(*m_position);
1856           if(t == regex_constants::syntax_not)
1857              pb->index = markid = -2;
1858           else if(t == regex_constants::syntax_equal)
1859              pb->index = markid = -1;
1860           else
1861           {
1862              name_delim = '>';
1863              --m_position;
1864              goto named_capture_jump;
1865           }
1866           ++m_position;
1867           jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
1868           this->append_state(syntax_element_backstep, sizeof(re_brace));
1869           this->m_pdata->m_data.align();
1870           m_alt_insert_point = this->m_pdata->m_data.size();
1871           break;
1872        }
1873     case regex_constants::escape_type_right_word:
1874        pb->index = markid = -3;
1875        ++m_position;
1876        jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
1877        this->m_pdata->m_data.align();
1878        m_alt_insert_point = this->m_pdata->m_data.size();
1879        break;
1880     case regex_constants::syntax_open_mark:
1881        {
1882        pb->index = markid = -4;
1883        if(++m_position == m_end)
1884        {
1885           --m_position;
1886           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1887           fail(regex_constants::error_perl_extension, m_position - m_base);
1888           return false;
1889        }
1890        v = this->m_traits.toi(m_position, m_end, 10);
1891        if(m_position == m_end)
1892        {
1893           --m_position;
1894           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1895           fail(regex_constants::error_perl_extension, m_position - m_base);
1896           return false;
1897        }
1898        if(*m_position == charT('R'))
1899        {
1900           if(++m_position == m_end)
1901           {
1902              --m_position;
1903              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1904              fail(regex_constants::error_perl_extension, m_position - m_base);
1905              return false;
1906           }
1907           if(*m_position == charT('&'))
1908           {
1909              const charT* base = ++m_position;
1910              while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
1911                 ++m_position;
1912              if(m_position == m_end)
1913              {
1914                 --m_position;
1915                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1916                 fail(regex_constants::error_perl_extension, m_position - m_base);
1917                 return false;
1918              }
1919              v = -static_cast<int>(hash_value_from_capture_name(base, m_position));
1920           }
1921           else
1922           {
1923              v = -this->m_traits.toi(m_position, m_end, 10);
1924           }
1925           re_brace* br = static_cast<re_brace*>(this->append_state(syntax_element_assert_backref, sizeof(re_brace)));
1926           br->index = v < 0 ? (int)(v - 1) : 0;
1927           if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
1928           {
1929              --m_position;
1930              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1931              fail(regex_constants::error_perl_extension, m_position - m_base);
1932              return false;
1933           }
1934           if(++m_position == m_end)
1935           {
1936              --m_position;
1937              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1938              fail(regex_constants::error_perl_extension, m_position - m_base);
1939              return false;
1940           }
1941        }
1942        else if((*m_position == charT('\'')) || (*m_position == charT('<')))
1943        {
1944           const charT* base = ++m_position;
1945           while((m_position != m_end) && (*m_position != charT('>')) && (*m_position != charT('\'')))
1946              ++m_position;
1947           if(m_position == m_end)
1948           {
1949              --m_position;
1950              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1951              fail(regex_constants::error_perl_extension, m_position - m_base);
1952              return false;
1953           }
1954           v = static_cast<int>(hash_value_from_capture_name(base, m_position));
1955           re_brace* br = static_cast<re_brace*>(this->append_state(syntax_element_assert_backref, sizeof(re_brace)));
1956           br->index = (int)v;
1957           if(((*m_position != charT('>')) && (*m_position != charT('\''))) || (++m_position == m_end))
1958           {
1959              --m_position;
1960              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1961              fail(regex_constants::error_perl_extension, m_position - m_base, "Unterminated named capture.");
1962              return false;
1963           }
1964           if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
1965           {
1966              --m_position;
1967              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1968              fail(regex_constants::error_perl_extension, m_position - m_base);
1969              return false;
1970           }
1971           if(++m_position == m_end)
1972           {
1973              --m_position;
1974              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1975              fail(regex_constants::error_perl_extension, m_position - m_base);
1976              return false;
1977           }
1978        }
1979        else if(*m_position == charT('D'))
1980        {
1981           const char* def = "DEFINE";
1982           while(*def && (m_position != m_end) && (*m_position == charT(*def)))
1983              ++m_position, ++def;
1984           if((m_position == m_end) || *def)
1985           {
1986              --m_position;
1987              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1988              fail(regex_constants::error_perl_extension, m_position - m_base);
1989              return false;
1990           }
1991           re_brace* br = static_cast<re_brace*>(this->append_state(syntax_element_assert_backref, sizeof(re_brace)));
1992           br->index = 9999; 
1993           if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
1994           {
1995              --m_position;
1996              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
1997              fail(regex_constants::error_perl_extension, m_position - m_base);
1998              return false;
1999           }
2000           if(++m_position == m_end)
2001           {
2002              --m_position;
2003              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2004              fail(regex_constants::error_perl_extension, m_position - m_base);
2005              return false;
2006           }
2007        }
2008        else if(v > 0)
2009        {
2010           re_brace* br = static_cast<re_brace*>(this->append_state(syntax_element_assert_backref, sizeof(re_brace)));
2011           br->index = (int)v;
2012           if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
2013           {
2014              --m_position;
2015              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2016              fail(regex_constants::error_perl_extension, m_position - m_base);
2017              return false;
2018           }
2019           if(++m_position == m_end)
2020           {
2021              --m_position;
2022              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2023              fail(regex_constants::error_perl_extension, m_position - m_base);
2024              return false;
2025           }
2026        }
2027        else
2028        {
2029           if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_question)
2030           {
2031              --m_position;
2032              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2033              fail(regex_constants::error_perl_extension, m_position - m_base);
2034              return false;
2035           }
2036           if(++m_position == m_end)
2037           {
2038              --m_position;
2039              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2040              fail(regex_constants::error_perl_extension, m_position - m_base);
2041              return false;
2042           }
2043           if(this->m_traits.syntax_type(*m_position) == regex_constants::escape_type_left_word)
2044           {
2045              if(++m_position == m_end)
2046              {
2047                 --m_position;
2048                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2049                 fail(regex_constants::error_perl_extension, m_position - m_base);
2050                 return false;
2051              }
2052              if((this->m_traits.syntax_type(*m_position) != regex_constants::syntax_equal)
2053                 && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_not))
2054              {
2055                 --m_position;
2056                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2057                 fail(regex_constants::error_perl_extension, m_position - m_base);
2058                 return false;
2059              }
2060              m_position -= 3;
2061           }
2062           else
2063           {
2064              if((this->m_traits.syntax_type(*m_position) != regex_constants::syntax_equal)
2065                 && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_not))
2066              {
2067                 --m_position;
2068                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2069                 fail(regex_constants::error_perl_extension, m_position - m_base);
2070                 return false;
2071              }
2072              m_position -= 2;
2073           }
2074        }
2075        break;
2076        }
2077     case regex_constants::syntax_close_mark:
2078        --m_position;
2079        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2080        fail(regex_constants::error_perl_extension, m_position - m_base);
2081        return false;
2082     case regex_constants::escape_type_end_buffer:
2083        {
2084        name_delim = *m_position;
2085  named_capture_jump:
2086        markid = 0;
2087        if(0 == (this->flags() & regbase::nosubs))
2088        {
2089           markid = ++m_mark_count;
2090           if(this->flags() & regbase::save_subexpression_location)
2091              this->m_pdata->m_subs.push_back(std::pair<std::size_t, std::size_t>(std::distance(m_base, m_position) - 2, 0));
2092        }
2093        pb->index = markid;
2094        const charT* base = ++m_position;
2095        if(m_position == m_end)
2096        {
2097           --m_position;
2098           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2099           fail(regex_constants::error_perl_extension, m_position - m_base);
2100           return false;
2101        }
2102        while((m_position != m_end) && (*m_position != name_delim))
2103           ++m_position;
2104        if(m_position == m_end)
2105        {
2106           --m_position;
2107           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2108           fail(regex_constants::error_perl_extension, m_position - m_base);
2109           return false;
2110        }
2111        this->m_pdata->set_name(base, m_position, markid);
2112        ++m_position;
2113        break;
2114        }
2115     default:
2116        if(*m_position == charT('R'))
2117        {
2118           ++m_position;
2119           v = 0;
2120           if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
2121           {
2122              --m_position;
2123              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2124              fail(regex_constants::error_perl_extension, m_position - m_base);
2125              return false;
2126           }
2127           goto insert_recursion;
2128        }
2129        if(*m_position == charT('&'))
2130        {
2131           ++m_position;
2132           const charT* base = m_position;
2133           while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2134              ++m_position;
2135           if(m_position == m_end)
2136           {
2137              --m_position;
2138              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2139              fail(regex_constants::error_perl_extension, m_position - m_base);
2140              return false;
2141           }
2142           v = static_cast<int>(hash_value_from_capture_name(base, m_position));
2143           goto insert_recursion;
2144        }
2145        if(*m_position == charT('P'))
2146        {
2147           ++m_position;
2148           if(m_position == m_end)
2149           {
2150              --m_position;
2151              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2152              fail(regex_constants::error_perl_extension, m_position - m_base);
2153              return false;
2154           }
2155           if(*m_position == charT('>'))
2156           {
2157              ++m_position;
2158              const charT* base = m_position;
2159              while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2160                 ++m_position;
2161              if(m_position == m_end)
2162              {
2163                 --m_position;
2164                 while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2165                 fail(regex_constants::error_perl_extension, m_position - m_base);
2166                 return false;
2167              }
2168              v = static_cast<int>(hash_value_from_capture_name(base, m_position));
2169              goto insert_recursion;
2170           }
2171        }
2172  option_group_jump:
2173        regex_constants::syntax_option_type opts = parse_options();
2174        if(m_position == m_end)
2175        {
2176           --m_position;
2177           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2178           fail(regex_constants::error_perl_extension, m_position - m_base);
2179           return false;
2180        }
2181        m_has_case_change = ((opts & regbase::icase) != (this->flags() & regbase::icase));
2182        pb->index = markid = 0;
2183        if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark)
2184        {
2185           this->flags(opts);
2186           restore_flags = false;
2187           old_case_change |= m_has_case_change; 
2188        }
2189        else if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_colon)
2190        {
2191           this->flags(opts);
2192           ++m_position;
2193        }
2194        else
2195        {
2196           --m_position;
2197           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2198           fail(regex_constants::error_perl_extension, m_position - m_base);
2199           return false;
2200        }
2201        if(m_has_case_change)
2202        {
2203           static_cast<re_case*>(
2204              this->append_state(syntax_element_toggle_case, sizeof(re_case))
2205              )->icase = opts & regbase::icase;
2206        }
2207     }
2208     parse_all();
2209     if(0 == unwind_alts(last_paren_start))
2210     {
2211        --m_position;
2212        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2213        fail(regex_constants::error_perl_extension, m_position - m_base, "Invalid alternation operators within (?...) block.");
2214        return false;
2215     }
2216     if(m_position == m_end)
2217     {
2218        --m_position;
2219        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2220        this->fail(regex_constants::error_paren, std::distance(m_base, m_end));
2221        return false;
2222     }
2223     BOOST_REGEX_ASSERT(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark);
2224     ++m_position;
2225     if(restore_flags)
2226     {
2227        if(m_has_case_change)
2228        {
2229           static_cast<re_case*>(
2230              this->append_state(syntax_element_toggle_case, sizeof(re_case))
2231              )->icase = old_flags & regbase::icase;
2232        }
2233        this->flags(old_flags);
2234     }
2235     if(jump_offset)
2236     {
2237        this->m_pdata->m_data.align();
2238        re_jump* jmp = static_cast<re_jump*>(this->getaddress(jump_offset));
2239        jmp->alt.i = this->m_pdata->m_data.size() - this->getoffset(jmp);
2240        if((this->m_last_state == jmp) && (markid != -2))
2241        {
2242           --m_position;
2243           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2244           fail(regex_constants::error_perl_extension, m_position - m_base, "Invalid or empty zero width assertion.");
2245           return false;
2246        }
2247     }
2248     if(markid == -4)
2249     {
2250        re_syntax_base* b = this->getaddress(expected_alt_point);
2251        if(b->type != syntax_element_alt)
2252        {
2253           re_alt* alt = static_cast<re_alt*>(this->insert_state(expected_alt_point, syntax_element_alt, sizeof(re_alt)));
2254           alt->alt.i = this->m_pdata->m_data.size() - this->getoffset(alt);
2255        }
2256        else if(((std::ptrdiff_t)this->m_pdata->m_data.size() > (static_cast<re_alt*>(b)->alt.i + this->getoffset(b))) && (static_cast<re_alt*>(b)->alt.i > 0) && this->getaddress(static_cast<re_alt*>(b)->alt.i, b)->type == syntax_element_alt)
2257        {
2258           --m_position;
2259           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2260           fail(regex_constants::error_bad_pattern, m_position - m_base, "More than one alternation operator | was encountered inside a conditional expression.");
2261           return false;
2262        }
2263        else
2264        {
2265           b = this->getaddress(b->next.i, b);
2266           if((b->type == syntax_element_assert_backref) && (static_cast<re_brace*>(b)->index == 9999))
2267           {
2268              --m_position;
2269              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2270              fail(regex_constants::error_bad_pattern, m_position - m_base, "Alternation operators are not allowed inside a DEFINE block.");
2271              return false;
2272           }
2273        }
2274        b = this->getaddress(expected_alt_point);
2275        b = this->getaddress(static_cast<re_alt*>(b)->next.i, b);
2276        if((b->type != syntax_element_assert_backref)
2277           && (b->type != syntax_element_startmark))
2278        {
2279           --m_position;
2280           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2281           fail(regex_constants::error_badrepeat, m_position - m_base, "A repetition operator cannot be applied to a zero-width assertion.");
2282           return false;
2283        }
2284     }
2285     pb = static_cast<re_brace*>(this->append_state(syntax_element_endmark, sizeof(re_brace)));
2286     pb->index = markid;
2287     pb->icase = this->flags() & regbase::icase;
2288     this->m_paren_start = last_paren_start;
2289     this->m_alt_insert_point = last_alt_point;
2290     m_has_case_change = old_case_change;
2291     if(m_max_mark > m_mark_count)
2292     {
2293        m_mark_count = m_max_mark;
2294     }
2295     m_mark_reset = mark_reset;
2296     m_max_mark = max_mark;
2297     if(markid > 0)
2298     {
2299        if(this->flags() & regbase::save_subexpression_location)
2300           this->m_pdata->m_subs.at((std::size_t)markid - 1).second = std::distance(m_base, m_position) - 1;
2301     }
2302     return true;
2303  }
2304  template <class charT, class traits>
2305  bool basic_regex_parser<charT, traits>::match_verb(const char* verb)
2306  {
2307     while(*verb)
2308     {
2309        if(static_cast<charT>(*verb) != *m_position)
2310        {
2311           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2312           fail(regex_constants::error_perl_extension, m_position - m_base);
2313           return false;
2314        }
2315        if(++m_position == m_end)
2316        {
2317           --m_position;
2318           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2319           fail(regex_constants::error_perl_extension, m_position - m_base);
2320           return false;
2321        }
2322        ++verb;
2323     }
2324     return true;
2325  }
2326  #ifdef BOOST_REGEX_MSVC
2327  #  pragma warning(push)
2328  #if BOOST_REGEX_MSVC >= 1800
2329  #pragma warning(disable:26812)
2330  #endif
2331  #endif
2332  template <class charT, class traits>
2333  bool basic_regex_parser<charT, traits>::parse_perl_verb()
2334  {
2335     if(++m_position == m_end)
2336     {
2337        --m_position;
2338        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2339        fail(regex_constants::error_perl_extension, m_position - m_base);
2340        return false;
2341     }
2342     switch(*m_position)
2343     {
2344     case 'F':
2345        if(++m_position == m_end)
2346        {
2347           --m_position;
2348           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2349           fail(regex_constants::error_perl_extension, m_position - m_base);
2350           return false;
2351        }
2352        if((this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark) || match_verb("AIL"))
2353        {
2354           if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2355           {
2356              --m_position;
2357              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2358              fail(regex_constants::error_perl_extension, m_position - m_base);
2359              return false;
2360           }
2361           ++m_position;
2362           this->append_state(syntax_element_fail);
2363           return true;
2364        }
2365        break;
2366     case 'A':
2367        if(++m_position == m_end)
2368        {
2369           --m_position;
2370           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2371           fail(regex_constants::error_perl_extension, m_position - m_base);
2372           return false;
2373        }
2374        if(match_verb("CCEPT"))
2375        {
2376           if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2377           {
2378              --m_position;
2379              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2380              fail(regex_constants::error_perl_extension, m_position - m_base);
2381              return false;
2382           }
2383           ++m_position;
2384           this->append_state(syntax_element_accept);
2385           return true;
2386        }
2387        break;
2388     case 'C':
2389        if(++m_position == m_end)
2390        {
2391           --m_position;
2392           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2393           fail(regex_constants::error_perl_extension, m_position - m_base);
2394           return false;
2395        }
2396        if(match_verb("OMMIT"))
2397        {
2398           if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2399           {
2400              --m_position;
2401              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2402              fail(regex_constants::error_perl_extension, m_position - m_base);
2403              return false;
2404           }
2405           ++m_position;
2406           static_cast<re_commit*>(this->append_state(syntax_element_commit, sizeof(re_commit)))->action = commit_commit;
2407           this->m_pdata->m_disable_match_any = true;
2408           return true;
2409        }
2410        break;
2411     case 'P':
2412        if(++m_position == m_end)
2413        {
2414           --m_position;
2415           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2416           fail(regex_constants::error_perl_extension, m_position - m_base);
2417           return false;
2418        }
2419        if(match_verb("RUNE"))
2420        {
2421           if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2422           {
2423              --m_position;
2424              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2425              fail(regex_constants::error_perl_extension, m_position - m_base);
2426              return false;
2427           }
2428           ++m_position;
2429           static_cast<re_commit*>(this->append_state(syntax_element_commit, sizeof(re_commit)))->action = commit_prune;
2430           this->m_pdata->m_disable_match_any = true;
2431           return true;
2432        }
2433        break;
2434     case 'S':
2435        if(++m_position == m_end)
2436        {
2437           --m_position;
2438           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2439           fail(regex_constants::error_perl_extension, m_position - m_base);
2440           return false;
2441        }
2442        if(match_verb("KIP"))
2443        {
2444           if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2445           {
2446              --m_position;
2447              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2448              fail(regex_constants::error_perl_extension, m_position - m_base);
2449              return false;
2450           }
2451           ++m_position;
2452           static_cast<re_commit*>(this->append_state(syntax_element_commit, sizeof(re_commit)))->action = commit_skip;
2453           this->m_pdata->m_disable_match_any = true;
2454           return true;
2455        }
2456        break;
2457     case 'T':
2458        if(++m_position == m_end)
2459        {
2460           --m_position;
2461           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2462           fail(regex_constants::error_perl_extension, m_position - m_base);
2463           return false;
2464        }
2465        if(match_verb("HEN"))
2466        {
2467           if((m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark))
2468           {
2469              --m_position;
2470              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2471              fail(regex_constants::error_perl_extension, m_position - m_base);
2472              return false;
2473           }
2474           ++m_position;
2475           this->append_state(syntax_element_then);
2476           this->m_pdata->m_disable_match_any = true;
2477           return true;
2478        }
2479        break;
2480     }
2481     --m_position;
2482     while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2483     fail(regex_constants::error_perl_extension, m_position - m_base);
2484     return false;
2485  }
2486  #ifdef BOOST_REGEX_MSVC
2487  #  pragma warning(pop)
2488  #endif
2489  template <class charT, class traits>
2490  bool basic_regex_parser<charT, traits>::add_emacs_code(bool negate)
2491  {
2492     if(++m_position == m_end)
2493     {
2494        --m_position;
2495        while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape) --m_position;
2496        fail(regex_constants::error_escape, m_position - m_base);
2497        return false;
2498     }
2499     basic_char_set<charT, traits> char_set;
2500     if(negate)
2501        char_set.negate();
2502     static const charT s_punct[5] = { 'p', 'u', 'n', 'c', 't', };
2503     switch(*m_position)
2504     {
2505     case 's':
2506     case ' ':
2507        char_set.add_class(this->m_mask_space);
2508        break;
2509     case 'w':
2510        char_set.add_class(this->m_word_mask);
2511        break;
2512     case '_':
2513        char_set.add_single(digraph<charT>(charT('$'))); 
2514        char_set.add_single(digraph<charT>(charT('&'))); 
2515        char_set.add_single(digraph<charT>(charT('*'))); 
2516        char_set.add_single(digraph<charT>(charT('+'))); 
2517        char_set.add_single(digraph<charT>(charT('-'))); 
2518        char_set.add_single(digraph<charT>(charT('_'))); 
2519        char_set.add_single(digraph<charT>(charT('<'))); 
2520        char_set.add_single(digraph<charT>(charT('>'))); 
2521        break;
2522     case '.':
2523        char_set.add_class(this->m_traits.lookup_classname(s_punct, s_punct+5));
2524        break;
2525     case '(':
2526        char_set.add_single(digraph<charT>(charT('('))); 
2527        char_set.add_single(digraph<charT>(charT('['))); 
2528        char_set.add_single(digraph<charT>(charT('{'))); 
2529        break;
2530     case ')':
2531        char_set.add_single(digraph<charT>(charT(')'))); 
2532        char_set.add_single(digraph<charT>(charT(']'))); 
2533        char_set.add_single(digraph<charT>(charT('}'))); 
2534        break;
2535     case '"':
2536        char_set.add_single(digraph<charT>(charT('"'))); 
2537        char_set.add_single(digraph<charT>(charT('\''))); 
2538        char_set.add_single(digraph<charT>(charT('`'))); 
2539        break;
2540     case '\'':
2541        char_set.add_single(digraph<charT>(charT('\''))); 
2542        char_set.add_single(digraph<charT>(charT(','))); 
2543        char_set.add_single(digraph<charT>(charT('#'))); 
2544        break;
2545     case '<':
2546        char_set.add_single(digraph<charT>(charT(';'))); 
2547        break;
2548     case '>':
2549        char_set.add_single(digraph<charT>(charT('\n'))); 
2550        char_set.add_single(digraph<charT>(charT('\f'))); 
2551        break;
2552     default:
2553        fail(regex_constants::error_ctype, m_position - m_base);
2554        return false;
2555     }
2556     if(0 == this->append_set(char_set))
2557     {
2558        fail(regex_constants::error_ctype, m_position - m_base);
2559        return false;
2560     }
2561     ++m_position;
2562     return true;
2563  }
2564  template <class charT, class traits>
2565  regex_constants::syntax_option_type basic_regex_parser<charT, traits>::parse_options()
2566  {
2567     regex_constants::syntax_option_type f = this->flags();
2568     bool breakout = false;
2569     do
2570     {
2571        switch(*m_position)
2572        {
2573        case 's':
2574           f |= regex_constants::mod_s;
2575           f &= ~regex_constants::no_mod_s;
2576           break;
2577        case 'm':
2578           f &= ~regex_constants::no_mod_m;
2579           break;
2580        case 'i':
2581           f |= regex_constants::icase;
2582           break;
2583        case 'x':
2584           f |= regex_constants::mod_x;
2585           break;
2586        default:
2587           breakout = true;
2588           continue;
2589        }
2590        if(++m_position == m_end)
2591        {
2592           --m_position;
2593           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2594           fail(regex_constants::error_paren, m_position - m_base);
2595           return false;
2596        }
2597     }
2598     while(!breakout);
2599     breakout = false;
2600     if(*m_position == static_cast<charT>('-'))
2601     {
2602        if(++m_position == m_end)
2603        {
2604           --m_position;
2605           while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2606           fail(regex_constants::error_paren, m_position - m_base);
2607           return false;
2608        }
2609        do
2610        {
2611           switch(*m_position)
2612           {
2613           case 's':
2614              f &= ~regex_constants::mod_s;
2615              f |= regex_constants::no_mod_s;
2616              break;
2617           case 'm':
2618              f |= regex_constants::no_mod_m;
2619              break;
2620           case 'i':
2621              f &= ~regex_constants::icase;
2622              break;
2623           case 'x':
2624              f &= ~regex_constants::mod_x;
2625              break;
2626           default:
2627              breakout = true;
2628              continue;
2629           }
2630           if(++m_position == m_end)
2631           {
2632              --m_position;
2633              while(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_open_mark) --m_position;
2634              fail(regex_constants::error_paren, m_position - m_base);
2635              return false;
2636           }
2637        }
2638        while(!breakout);
2639     }
2640     return f;
2641  }
2642  template <class charT, class traits>
2643  bool basic_regex_parser<charT, traits>::unwind_alts(std::ptrdiff_t last_paren_start)
2644  {
2645     if((this->m_alt_insert_point == static_cast<std::ptrdiff_t>(this->m_pdata->m_data.size()))
2646        && (!m_alt_jumps.empty()) && (m_alt_jumps.back() > last_paren_start)
2647        &&
2648        !(
2649           ((this->flags() & regbase::main_option_type) == regbase::perl_syntax_group)
2650             &&
2651           ((this->flags() & regbase::no_empty_expressions) == 0)
2652          )
2653        )
2654     {
2655        fail(regex_constants::error_empty, this->m_position - this->m_base, "Can't terminate a sub-expression with an alternation operator |.");
2656        return false;
2657     }
2658     while((!m_alt_jumps.empty()) && (m_alt_jumps.back() > last_paren_start))
2659     {
2660        std::ptrdiff_t jump_offset = m_alt_jumps.back();
2661        m_alt_jumps.pop_back();
2662        this->m_pdata->m_data.align();
2663        re_jump* jmp = static_cast<re_jump*>(this->getaddress(jump_offset));
2664        if (jmp->type != syntax_element_jump)
2665        {
2666           fail(regex_constants::error_unknown, this->m_position - this->m_base, "Internal logic failed while compiling the expression, probably you added a repeat to something non-repeatable!");
2667           return false;
2668        }
2669        jmp->alt.i = this->m_pdata->m_data.size() - jump_offset;
2670     }
2671     return true;
2672  }
2673  #ifdef BOOST_REGEX_MSVC
2674  #pragma warning(pop)
2675  #endif
2676  } 
2677  } 
2678  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobs.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_parser.hpp</div>
                </div>
                <div class="column column_space"><pre><code>458  static void CollectEdgesOfRun(const EDGEPT *startpt, const EDGEPT *lastpt, const DENORM &denorm,
459                                const TBOX &box, TBOX *bounding_box, LLSQ *accumulator,
460                                std::vector<std::vector<int>> *x_coords,
461                                std::vector<std::vector<int>> *y_coords) {
462    const C_OUTLINE *outline = startpt->src_outline;
</pre></code></div>
                <div class="column column_space"><pre><code>30     void fail(regex_constants::error_type error_code, std::ptrdiff_t position);
31     void fail(regex_constants::error_type error_code, std::ptrdiff_t position, std::string message, std::ptrdiff_t start_pos);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    