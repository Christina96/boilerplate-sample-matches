
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.46417445482866%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hc.h</h3>
            <pre><code>1  #ifndef Hc_h
2  #define Hc_h
3  #include "base.h"
4  class THcWord{
5  private:
6    TB32Set FSet;
7    TInt WordId;
8  public:
9    THcWord(): FSet(), WordId(-1){}
10    THcWord(const THcWord& HcWord): FSet(HcWord.FSet), WordId(HcWord.WordId){}
11    THcWord(const TB32Set& _FSet, const int& _WordId):
12      FSet(_FSet), WordId(_WordId){}
13    THcWord(const THcWord& HcWord, int _WordId):
14      FSet(HcWord.FSet), WordId(_WordId){}
15    THcWord(TSIn& SIn): FSet(SIn), WordId(SIn){}
16    void Save(TSOut& SOut){FSet.Save(SOut); WordId.Save(SOut);}
17    THcWord& operator=(const THcWord& HcWord){
18      if (this!=&HcWord){FSet=HcWord.FSet; WordId=HcWord.WordId;} return *this;}
19    bool operator==(const THcWord& HcWord) const {
20      return (FSet==HcWord.FSet)&&(WordId==HcWord.WordId);}
21    bool IsFlag(const int& FN){return FSet.GetBit(FN)==1;}
22    void SetFlag(const int& FN, const bool& Val){FSet.SetBit(FN, Val);}
23    bool GetFlag(const int& FN){return FSet.GetBit(FN);}
24    TInt GetWordId(){return WordId;}
25  };
26  class THcDoc{
27  private:
28    TCRef CRef;
29  private:
30    TVec<THcWord> WordV;
31  public:
32    THcDoc(): WordV(100, 0){}
33    THcDoc(const THcDoc& HcDoc): WordV(HcDoc.WordV){Fail;}
34    static TPt<THcDoc> Load(TSIn& SIn){return new THcDoc(SIn);}
35    THcDoc(TSIn& SIn): WordV(SIn){}
36    void Save(TSOut& SOut){WordV.Save(SOut);}
37    THcDoc& operator=(const THcDoc& HcDoc){
38      if (this!=&HcDoc){WordV=HcDoc.WordV;} return *this;}
39    bool operator==(const THcDoc& HcDoc) const {return this==&HcDoc;}
40    void Add(const THcWord& HcWord){WordV.Add(HcWord);}
41    void Add(const TVec<THcWord>& HcWordV){WordV.AddV(HcWordV);}
42    THcWord& Get(const int& WordN){return WordV[WordN];}
43    int Len(){return WordV.Len();}
44    friend TPt<THcDoc>;
45  };
46  typedef TPt<THcDoc> PHcDoc;
47  class THcBase{
48  private:
49    TCRef CRef;
50  private:
51    THash<TStr, TIntPr> WordH;
52    THash<TStr, PHcDoc> DocH;
53    THash<TInt, TVoid> StopStrH, FlagTagH, ContTagH, SkipTagH, BreakTagH;
54    TInt StrFN, DStrFN, BTagFN, ETagFN, UrlFN, AnchFN;
55    TInt TitleTagId, AnchTagId;
56    TInt H1TagId, H2TagId, H3TagId, H4TagId, H5TagId, H6TagId;
57    TInt FxWordIds;
<span onclick='openModal()' class='match'>58    void GenStopStr(const TStr& Str){StopStrH.AddKey(TInt(WordH.AddKey(Str)));}
59    void GenFlagTag(const TStr& Str){FlagTagH.AddKey(TInt(WordH.AddKey(Str)));}
60    void GenContTag(const TStr& Str){ContTagH.AddKey(TInt(WordH.AddKey(Str)));}
</span>61    void GenSkipTag(const TStr& Str){SkipTagH.AddKey(TInt(WordH.AddKey(Str)));}
62    void GenBreakTag(const TStr& Str){BreakTagH.AddKey(TInt(WordH.AddKey(Str)));}
63    int AddDStrKey(const int& WordId1, const int& WordId2){
64      return WordH.AddKey(WordH.GetKey(WordId1)+" "+WordH.GetKey(WordId2));}
65    void ClrAnchFlag(const TVec<THcWord>& HcWordV);
66  public:
67    THcBase();
68    THcBase(TSIn& SIn);
69    static TPt<THcBase> Load(TSIn& SIn){return new THcBase(SIn);}
70    void Save(TSOut& SOut);
71    int GetWords(){return WordH.Len();}
72    int GetMxWordIds(){return WordH.GetMxKeyIds();}
73    TStr GetWordStr(const int& WordId){return WordH.GetKey(WordId);}
74    int GetWordId(const TStr& WordStr){return WordH.GetKeyId(WordStr);}
75    int FFirstWordId(){return WordH.FFirstKeyId();}
76    bool FNextWordId(int& WordId){return WordH.FNextKeyId(WordId);}
77    void AddDoc(const TStr& FNm, const TStr& _Nm=TStr());
78    PHcDoc GetDoc(const TStr& Nm){return DocH.GetDat(Nm);}
79    PHcDoc GetDoc(const int& DocId){return DocH[DocId];}
80    void DelDoc(const TStr& Nm);
81    void DelDocs();
82    int GetDocs(){return DocH.Len();}
83    int GetMxDocIds(){return DocH.GetMxKeyIds();}
84    TStr GetDocNm(const int& DocId){return DocH.GetKey(DocId);}
85    int GetDocId(const TStr& Nm){return DocH.GetKeyId(Nm);}
86    int FFirstDocId(){return DocH.FFirstKeyId();}
87    bool FNextDocId(int& DocId){return DocH.FNextKeyId(DocId);}
88    TVec<PHcDoc> GetHLDocV(const int& DocId);
89    void Wr();
90    void WrDoc(const TStr& UrlStr, const PHcDoc& Doc);
91    friend TPt<THcBase>;
92  };
93  typedef TPt<THcBase> PHcBase;
94  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</h3>
            <pre><code>1  class TSockSys{
2  public:
3    static bool Active;
4    static HWND SockWndHnd;
5    static HWND DnsWndHnd;
6    static HWND ReportWndHnd;
7    static HWND TimerWndHnd;
8    static UINT SockMsgHnd;
9    static UINT SockErrMsgHnd;
10    static UINT DnsMsgHnd;
11    static UINT ReportMsgHnd;
12    static uint64 SockBytesRead;
13    static uint64 SockBytesWritten;
14    static THash<TInt, TUInt64> SockIdToHndH;
15    static THash<TUInt64, TInt> SockHndToIdH;
16    static THash<TUInt64, TInt> SockHndToEventIdH;
17    static TIntH SockTimerIdH;
18    static TUInt64H ActiveSockHndH;
19    static THash<TUInt64, PSockHost> HndToSockHostH;
20    static THash<TInt, PSockEvent> IdToSockEventH;
21    static TIntH ActiveSockEventIdH;
22    static THash<TInt, PReportEvent> IdToReportEventH;
23    static THash<TInt, ATimer> IdToTimerH;
24  public:
25    static TStr GetErrStr(const int ErrCd);
26    static LRESULT CALLBACK MainWndProc(
27     HWND WndHnd, UINT Msg, WPARAM wParam, LPARAM lParam);
28  public:
29    TSockSys();
30    ~TSockSys();
31    TSockSys& operator=(const TSockSys&){Fail; return *this;}
32    static HWND GetSockWndHnd(){IAssert(Active); return SockWndHnd;}
33    static HWND GetDnsWndHnd(){IAssert(Active); return DnsWndHnd;}
34    static HWND GetReportWndHnd(){IAssert(Active); return ReportWndHnd;}
35    static HWND GetTimerWndHnd(){IAssert(Active); return TimerWndHnd;}
36    static UINT GetSockMsgHnd(){IAssert(Active); return SockMsgHnd;}
37    static UINT GetSockErrMsgHnd(){IAssert(Active); return SockErrMsgHnd;}
38    static UINT GetDnsMsgHnd(){IAssert(Active); return DnsMsgHnd;}
39    static UINT GetReportMsgHnd(){IAssert(Active); return ReportMsgHnd;}
40    static int GetAllSockEventCdSet(){
41      return (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE);}
42    static uint64 GetSockBytesRead(){return SockBytesRead;}
43    static uint64 GetSockBytesWritten(){return SockBytesWritten;}
44    static void AddSock(
45     const int& SockId, const TSockHnd& SockHnd, const int& SockEventId);
46    static void DelSock(const int& SockId);
47    static bool IsSockId(const int& SockId){
48      IAssert(Active); return SockIdToHndH.IsKey(SockId);}
49    static bool IsSockHnd(const TSockHnd& SockHnd){
50      IAssert(Active); return SockHndToIdH.IsKey(SockHnd);}
51    static TSockHnd GetSockHnd(const int& SockId){
52      IAssert(Active); return TSockHnd(SockIdToHndH.GetDat(SockId));}
53    static TSockHnd GetSockId(const TSockHnd& SockHnd){
54      IAssert(Active); return SockHndToIdH.GetDat(SockHnd);}
55    static int GetSockEventId(const TSockHnd& SockHnd){
56      IAssert(Active); return SockHndToEventIdH.GetDat(SockHnd);}
57    static void AddSockTimer(const int& SockId, const int& MSecs){
58      UINT ErrCd=(UINT)SetTimer(GetSockWndHnd(), SockId, uint(MSecs), NULL);
59      ESAssert(ErrCd!=0);
60      SockTimerIdH.AddKey(SockId);}
61    static void DelIfSockTimer(const int& SockId){
62      KillTimer(GetSockWndHnd(), SockId);
63      SockTimerIdH.DelIfKey(SockId);}
64    static bool IsSockActive(const TSockHnd& SockHnd){
65      return ActiveSockHndH.IsKey(SockHnd);}
66    static void SetSockActive(const TSockHnd& SockHnd, const bool& Active){
67      IAssert(
68       (Active&&!IsSockActive(SockHnd))||
69       (!Active&&IsSockActive(SockHnd)));
70      if (Active){ActiveSockHndH.AddKey(SockHnd);}
71      else {ActiveSockHndH.DelKey(SockHnd);}}
72    static const int MxSockBfL;
73    static void AddSockHost(const TUInt64& SockHostHnd, const PSockHost& SockHost){
74      HndToSockHostH.AddDat(SockHostHnd, SockHost);}
75    static void DelSockHost(const TUInt64& SockHostHnd){
76      HndToSockHostH.DelKey(SockHostHnd);}
77    static bool IsSockHost(const TUInt64& SockHostHnd){
78      return HndToSockHostH.IsKey(SockHostHnd);}
79    static PSockHost GetSockHost(const TUInt64& SockHostHnd){
80      return HndToSockHostH.GetDat(SockHostHnd);}
81    static void AddSockEvent(const PSockEvent& SockEvent){
82      IAssert(!IsSockEvent(SockEvent));
83      IdToSockEventH.AddDat(SockEvent->GetSockEventId(), SockEvent);}
84    static void DelSockEvent(const PSockEvent& SockEvent){
85      IdToSockEventH.DelKey(SockEvent->GetSockEventId());}
86    static bool IsSockEvent(const int& SockEventId){
87      return IdToSockEventH.IsKey(TInt(SockEventId));}
88    static bool IsSockEvent(const PSockEvent& SockEvent){
89      return IdToSockEventH.IsKey(TInt(SockEvent->GetSockEventId()));}
90    static PSockEvent GetSockEvent(const int& SockEventId){
91      return IdToSockEventH.GetDat(SockEventId);}
92    static bool IsSockEventActive(const int& SockEventId){
93      return ActiveSockEventIdH.IsKey(SockEventId);}
94    static void SetSockEventActive(const int& SockEventId, const bool& Active){
95      IAssert(
96       (Active&&!IsSockEventActive(SockEventId))||
97       (!Active&&IsSockEventActive(SockEventId)));
98      if (Active){ActiveSockEventIdH.AddKey(SockEventId);}
99      else {ActiveSockEventIdH.DelKey(SockEventId);}}
100    static void AddReportEvent(const PReportEvent& ReportEvent){
101      IAssert(!IsReportEvent(ReportEvent));
<span onclick='openModal()' class='match'>102      IdToReportEventH.AddDat(TInt(ReportEvent->GetReportEventId()), ReportEvent);}
103    static void DelReportEvent(const PReportEvent& ReportEvent){
104      IdToReportEventH.DelKey(TInt(ReportEvent->GetReportEventId()));}
105    static bool IsReportEvent(const PReportEvent& ReportEvent){
</span>106      return IdToReportEventH.IsKey(TInt(ReportEvent->GetReportEventId()));}
107    static PReportEvent GetReportEvent(const int& ReportEventId){
108      return IdToReportEventH.GetDat(ReportEventId);}
109    static void AddTimer(const ATimer& Timer){
110      IAssert(!IsTimer(Timer->GetTimerId()));
111      IdToTimerH.AddDat(TInt(Timer->GetTimerId()), Timer);}
112    static void DelTimer(const int& TimerId){
113      IdToTimerH.DelKey(TimerId);}
114    static bool IsTimer(const int& TimerId){
115      return IdToTimerH.IsKey(TimerId);}
116    static ATimer GetTimer(const int& TimerId){
117      return IdToTimerH.GetDat(TimerId);}
118    static void OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
119    static void OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
120    static void OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
121    static void OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
122    static void OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
123    static void OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
124    static void OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
125    static void OnError(
126     const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd);
127    static void OnGetHost(const PSockHost& SockHost);
128    static TStr GetStatusStr();
129  };
130  bool TSockSys::Active=false;
131  HWND TSockSys::SockWndHnd=0;
132  HWND TSockSys::DnsWndHnd=0;
133  HWND TSockSys::ReportWndHnd=0;
134  HWND TSockSys::TimerWndHnd=0;
135  UINT TSockSys::SockMsgHnd=0;
136  UINT TSockSys::SockErrMsgHnd=0;
137  UINT TSockSys::DnsMsgHnd=0;
138  UINT TSockSys::ReportMsgHnd=0;
139  uint64 TSockSys::SockBytesRead=0;
140  uint64 TSockSys::SockBytesWritten=0;
141  THash<TInt, TUInt64> TSockSys::SockIdToHndH;
142  THash<TUInt64, TInt> TSockSys::SockHndToIdH;
143  THash<TUInt64, TInt> TSockSys::SockHndToEventIdH;
144  TIntH TSockSys::SockTimerIdH;
145  TUInt64H TSockSys::ActiveSockHndH;
146  const int TSockSys::MxSockBfL=100*1024;
147  THash<TUInt64, PSockHost> TSockSys::HndToSockHostH;
148  THash<TInt, PSockEvent> TSockSys::IdToSockEventH;
149  TIntH TSockSys::ActiveSockEventIdH;
150  THash<TInt, PReportEvent> TSockSys::IdToReportEventH;
151  THash<TInt, ATimer> TSockSys::IdToTimerH;
152  TSockSys SockSys; 
153  TStr TSockSys::GetErrStr(const int ErrCd){
154    switch (ErrCd){
155      case WSASYSNOTREADY: return "Underlying network subsystem is not ready for network communication.";
156      case WSAVERNOTSUPPORTED: return "The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.";
157      case WSAEPROCLIM: return "Limit on the number of tasks supported by the Windows Sockets implementation has been reached.";
158      case WSANOTINITIALISED: return "Windows Sockets not initialized.";
159      case WSAENETDOWN: return "The network subsystem has failed.";
160      case WSAEWOULDBLOCK: return "Resource temporarily unavailable (op. would block).";
161      case WSAEINPROGRESS: return "A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.";
162      case WSAEADDRINUSE: return "The specified address is already in use.";
163      case WSAEADDRNOTAVAIL: return "The specified address is not available from the local machine.";
164      case WSAEAFNOSUPPORT: return "Addresses in the specified family cannot be used with this socket.";
165      case WSAECONNREFUSED: return "The attempt to connect was forcefully rejected.";
166      case WSAENETUNREACH: return "The network cannot be reached from this host at this time.";
167      case WSAEFAULT: return "Bad parameter.";
168      case WSAEINVAL: return "The socket is already bound to an address.";
169      case WSAEISCONN: return "The socket is already connected.";
170      case WSAEMFILE: return "No more file descriptors are available.";
171      case WSAENOBUFS: return "No buffer space is available. The socket cannot be connected.";
172      case WSAENOTCONN: return "The socket is not connected.";
173      case WSAETIMEDOUT: return "Attempt to connect timed out without establishing a connection.";
174      case WSAECONNRESET: return "The connection was reset by the remote side.";
175      case WSAECONNABORTED: return "The connection was terminated due to a time-out or other failure.";
176      default: return TStr("Unknown socket error (code ")+TInt::GetStr(ErrCd)+TStr(").");
177    }
178  }
179  LRESULT CALLBACK TSockSys::MainWndProc(
180   HWND WndHnd, UINT MsgHnd, WPARAM wParam, LPARAM lParam){
181    if (MsgHnd==TSockSys::SockMsgHnd){
182      IAssert(WndHnd==GetSockWndHnd());
183      TSockHnd SockHnd=wParam;
184      if (IsSockHnd(SockHnd)){
185        int SockEventId=GetSockEventId(SockHnd);
186        PSockEvent SockEvent=GetSockEvent(SockEventId);
187        SetSockEventActive(SockEventId, true);
188        try {
189          int ErrCd=WSAGETSELECTERROR(lParam);
190          if (ErrCd==0){
191            int EventCd=WSAGETSELECTEVENT(lParam);
192            switch (EventCd){
193              case FD_READ: OnRead(SockHnd, SockEvent); break;
194              case FD_WRITE: OnWrite(SockHnd, SockEvent); break;
195              case FD_OOB: OnOob(SockHnd, SockEvent); break;
196              case FD_ACCEPT: OnAccept(SockHnd, SockEvent); break;
197              case FD_CONNECT: OnConnect(SockHnd, SockEvent); break;
198              case FD_CLOSE: OnClose(SockHnd, SockEvent); break;
199              default: Fail;
200            }
201          } else {
202            OnError(SockHnd, SockEvent, ErrCd);
203          }
204        } catch (...){
205          SaveToErrLog("Exception from 'switch (EventCd)'");
206        }
207        SetSockEventActive(SockEventId, false);
208      }
209    } else
210    if (MsgHnd==TSockSys::SockErrMsgHnd){
211      IAssert(WndHnd==GetSockWndHnd());
212      TSockHnd SockHnd=wParam;
213      if (IsSockHnd(SockHnd)){
214        int SockEventId=GetSockEventId(SockHnd);
215        PSockEvent SockEvent=GetSockEvent(SockEventId);
216        SetSockEventActive(SockEventId, true);
217        try {
218          int ErrCd=int(lParam);
219          OnError(SockHnd, SockEvent, ErrCd);
220        } catch (...){
221          SaveToErrLog("Exception from 'OnError(SockHnd, SockEvent, ErrCd)'");
222        }
223        SetSockEventActive(SockEventId, false);
224      }
225    } else
226    if (MsgHnd==WM_TIMER){
227      if (WndHnd==GetSockWndHnd()){
228        int SockId=int(wParam);
229        DelIfSockTimer(SockId);
230        if (IsSockId(SockId)){
231          TSockHnd SockHnd=GetSockHnd(SockId);
232          int SockEventId=GetSockEventId(SockHnd);
233          PSockEvent SockEvent=GetSockEvent(SockEventId);
234          SetSockEventActive(SockEventId, true);
235          try {
236            OnTimeOut(SockHnd, SockEvent);
237          } catch (...){
238            SaveToErrLog("Exception from OnTimeOut(SockHnd, SockEvent);");
239          }
240          SetSockEventActive(SockEventId, false);
241        }
242      } else
243      if (WndHnd==GetTimerWndHnd()){
244        int TimerId=int(wParam);
245        if (TSockSys::IsTimer(TimerId)){
246          PTimer Timer=TSockSys::GetTimer(TimerId)();
247          Timer->IncTicks();
248          try {
249            Timer->OnTimeOut();
250          } catch (...){
251            SaveToErrLog("Exception from Timer->OnTimeOut();");
252          }
253        }
254      } else {
255        Fail;
256      }
257    } else
258    if (MsgHnd==TSockSys::DnsMsgHnd){
259      IAssert(WndHnd==GetDnsWndHnd());
260      uint SockHostHnd=int(wParam);
261      if (TSockSys::IsSockHost(SockHostHnd)){
262        TSockHostStatus Status=TSockHost::GetStatus(WSAGETASYNCERROR(lParam));
263        PSockHost SockHost=TSockSys::GetSockHost(SockHostHnd);
264        SockHost->GetFromHostEnt(Status, (hostent*)SockHost->HostEntBf);
265        DelSockHost(SockHostHnd);
266        try {
267          OnGetHost(SockHost);
268        } catch (...){
269          SaveToErrLog("Exception from OnGetHost(SockHost);");
270        }
271      }
272    } else
273    if (MsgHnd==TSockSys::ReportMsgHnd){
274      IAssert(WndHnd==GetReportWndHnd());
275      int ReportEventId=int(lParam);
276      PReportEvent ReportEvent=TSockSys::GetReportEvent(ReportEventId);
277      try {
278        ReportEvent->OnReport();
279      } catch (...){
280        SaveToErrLog("Exception from ReportEvent->OnReport()");
281      }
282      TSockSys::DelReportEvent(ReportEvent);
283    } else {
284      return DefWindowProc(WndHnd, MsgHnd, wParam, lParam);
285    }
286    return 0;
287  }
288  TSockSys::TSockSys(){
289    IAssert(Active==false);
290    WNDCLASS WndClass;
291    WndClass.style=0;
292    WndClass.lpfnWndProc=MainWndProc;
293    WndClass.cbClsExtra=0;
294    WndClass.cbWndExtra=0;
295    FSAssert((WndClass.hInstance=GetModuleHandle(NULL))!=NULL);
296    WndClass.hIcon=NULL;
297    WndClass.hCursor=NULL;
298    WndClass.hbrBackground=NULL;
299    WndClass.lpszMenuName=NULL;
300    WndClass.lpszClassName="SockWndClass";
301    FSAssert(RegisterClass(&WndClass)!=0);
302    TSockSys::SockWndHnd=CreateWindow(
303     "SockWndClass", "Socket Window",
304     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
305     GetModuleHandle(NULL), NULL);
306    FSAssert(TSockSys::SockWndHnd!=NULL);
307    TSockSys::DnsWndHnd=CreateWindow(
308     "SockWndClass", "Dns Window",
309     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
310     GetModuleHandle(NULL), NULL);
311    FSAssert(TSockSys::DnsWndHnd!=NULL);
312    TSockSys::ReportWndHnd=CreateWindow(
313     "SockWndClass", "RepMsg Window",
314     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
315     GetModuleHandle(NULL), NULL);
316    FSAssert(TSockSys::ReportWndHnd!=NULL);
317    TSockSys::TimerWndHnd=CreateWindow(
318     "SockWndClass", "Net Timer",
319     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
320     GetModuleHandle(NULL), NULL);
321    FSAssert(TSockSys::TimerWndHnd!=NULL);
322    SockMsgHnd=RegisterWindowMessage("SockSys.SockMsg"); FSAssert(SockMsgHnd!=0);
323    SockErrMsgHnd=RegisterWindowMessage("SockSys.SockErrorMsg"); FSAssert(SockErrMsgHnd!=0);
324    DnsMsgHnd=RegisterWindowMessage("SockSys.DnsMsg"); FSAssert(DnsMsgHnd!=0);
325    ReportMsgHnd=RegisterWindowMessage("SockSys.RepMsg"); FSAssert(ReportMsgHnd!=0);
326    WORD Version=((WORD) (((BYTE) (2)) | (((WORD) ((BYTE) (0))) << 8)));
327    WSADATA WsaData;
328    int WsaErrCd=WSAStartup(Version, &WsaData);
329    FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
330    FAssert(
331     WsaData.wVersion==Version,
332     "Can not find appropriate version of WinSock DLL.");
333    Active=true;
334  }
335  TSockSys::~TSockSys(){
336    if (Active){
337      IAssert(ActiveSockHndH.Len()==0);
338      IAssert(ActiveSockEventIdH.Len()==0);
339      int WsaErrCd=WSACleanup();
340      FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
341      Active=false;
342    }
343  }
344  void TSockSys::AddSock(
345   const int& SockId, const TSockHnd& SockHnd, const int& SockEventId){
346    IAssert(Active);
347    SockIdToHndH.AddDat(SockId, SockHnd);
348    SockHndToIdH.AddDat(SockHnd, SockId);
349    SockHndToEventIdH.AddDat(SockHnd, SockEventId);
350  }
351  void TSockSys::DelSock(const int& SockId){
352    IAssert(Active);
353    TSockHnd SockHnd=TSockHnd(SockIdToHndH.GetDat(SockId));
354    IAssert(!IsSockActive(SockHnd));
355    SockIdToHndH.DelKey(SockId);
356    SockHndToIdH.DelKey(SockHnd);
357    SockHndToEventIdH.DelKey(SockHnd);
358    DelIfSockTimer(SockId);
359  }
360  void TSockSys::OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
361    TMem Mem(MxSockBfL);
362    char* Bf=new char[MxSockBfL]; int BfL;
363    do {
364      BfL=recv(SockHnd, Bf, MxSockBfL, 0);
365      if (BfL!=SOCKET_ERROR){
366        Mem.AddBf(Bf, BfL); SockBytesRead+=BfL;}
367    } while ((BfL>0)&&(BfL!=SOCKET_ERROR));
368    delete[] Bf;
369    if (!SockEvent.Empty()){
370      PSIn SIn=Mem.GetSIn();
371      SockEvent->OnRead(int(GetSockId(SockHnd)), SIn);
372    }
373  }
374  void TSockSys::OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
375    if (!SockEvent.Empty()){
376      SockEvent->OnWrite(int(GetSockId(SockHnd)));}
377  }
378  void TSockSys::OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
379    if (!SockEvent.Empty()){
380      SockEvent->OnOob(int(GetSockId(SockHnd)));}
381  }
382  void TSockSys::OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
383    PSock AccSock=TSock::Accept(SockHnd, SockEvent);
384    if (!SockEvent.Empty()){
385      SockEvent->OnAccept(AccSock->GetSockId(), AccSock);}
386  }
387  void TSockSys::OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
388    if (!SockEvent.Empty()){
389      SockEvent->OnConnect(int(GetSockId(SockHnd)));}
390  }
391  void TSockSys::OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
392    if (!SockEvent.Empty()){
393      SockEvent->OnClose(int(GetSockId(SockHnd)));}
394  }
395  void TSockSys::OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
396    if (!SockEvent.Empty()){
397      SockEvent->OnTimeOut(int(GetSockId(SockHnd)));}
398  }
399  void TSockSys::OnError(
400   const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd){
401    if (!SockEvent.Empty()){
402      SockEvent->OnError(int(GetSockId(SockHnd)), ErrCd, GetErrStr(ErrCd));}
403  }
404  void TSockSys::OnGetHost(const PSockHost& SockHost){
405    if (IsSockEvent(SockHost->GetSockEventId())){
406      PSockEvent SockEvent=SockHost->GetSockEvent();
407      if (!SockEvent.Empty()){
408        SockEvent->OnGetHost(SockHost);}
409    }
410  }
411  TStr TSockSys::GetStatusStr(){
412    TChA ChA;
413    ChA+="Sockets: "; ChA+=TInt::GetStr(SockIdToHndH.Len()); ChA+="\r\n";
414    ChA+="Host-Resolutions: "; ChA+=TInt::GetStr(HndToSockHostH.Len()); ChA+="\r\n";
415    ChA+="Socket-Events: "; ChA+=TInt::GetStr(IdToSockEventH.Len()); ChA+="\r\n";
416    ChA+="Report-Events: "; ChA+=TInt::GetStr(IdToReportEventH.Len()); ChA+="\r\n";
417    ChA+="Timers: "; ChA+=TInt::GetStr(IdToTimerH.Len()); ChA+="\r\n";
418    return ChA;
419  }
420  int TSockEvent::LastSockEventId=0;
421  TSockEvent::~TSockEvent(){
422    IAssert(!TSockSys::IsSockEventActive(SockEventId));
423  }
424  bool TSockEvent::IsReg(const PSockEvent& SockEvent){
425    return TSockSys::IsSockEvent(SockEvent);
426  }
427  void TSockEvent::Reg(const PSockEvent& SockEvent){
428    IAssert(!TSockSys::IsSockEvent(SockEvent));
429    TSockSys::AddSockEvent(SockEvent);
430  }
431  void TSockEvent::UnReg(const PSockEvent& SockEvent){
432    IAssert(TSockSys::IsSockEvent(SockEvent));
433    TSockSys::DelSockEvent(SockEvent);
434  }
435  void TSockHost::GetFromHostEnt(
436   const TSockHostStatus& _Status, const hostent* HostEnt){
437    if ((Status=_Status)==shsOk){
438      IAssert(HostEnt!=NULL);
439      IAssert(HostEnt->h_addrtype==AF_INET);
440      IAssert(HostEnt->h_length==4);
441      HostNmV.Add(TStr(HostEnt->h_name).GetLc());
442      int HostNmN=0;
443      while (HostEnt->h_aliases[HostNmN]!=NULL){
444        HostNmV.Add(TStr(HostEnt->h_aliases[HostNmN]).GetLc()); HostNmN++;}
445      int IpNumN=0;
446      while (HostEnt->h_addr_list[IpNumN]!=NULL){
447        TStr IpNum=
448         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][0]))+"."+
449         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][1]))+"."+
450         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][2]))+"."+
451         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][3]));
452        IpNumV.Add(IpNum); IpNumN++;
453      }
454    }
455  }
456  PSockEvent TSockHost::GetSockEvent() const {
457    return TSockSys::GetSockEvent(SockEventId);
458  }
459  bool TSockHost::IsIpNum(const TStr& HostNm){
460    int HostNmLen=HostNm.Len();
461    for (int ChN=0; ChN<HostNmLen; ChN++){
462      if (TCh::IsAlpha(HostNm[ChN])){return false;}}
463    return true;
464  }
465  TStr TSockHost::GetIpNum(const uint& IpNum){
466    TChA IpNumChA;
467    IpNumChA+=TUInt::GetStr(IpNum/0x1000000);
468    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x10000)%0x100);
469    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x100)%0x100);
470    IpNumChA+='.'; IpNumChA+=TUInt::GetStr(IpNum%0x100);
471    return IpNumChA;
472  }
473  PSockHost TSockHost::GetSyncSockHost(const TStr& HostNm){
474    hostent* HostEnt; TSockHostStatus Status(shsUndef);
475    if ((HostNm.Len()>0)&&(!IsIpNum(HostNm))){
476      HostEnt=gethostbyname(HostNm.CStr());
477      if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
478      else {Status=shsOk;}
479    } else {
480      uint HostIpNum=inet_addr(HostNm.CStr());
481      if (HostIpNum==INADDR_NONE){
482        Status=shsError; HostEnt=NULL;
483      } else {
484        HostEnt=gethostbyaddr((char*)&HostIpNum, 4, AF_INET);
485        if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
486        else {Status=shsOk;}
487      }
488    }
489    PSockHost SockHost=PSockHost(new TSockHost());
490    SockHost->GetFromHostEnt(Status, HostEnt);
491    return SockHost;
492  }
493  void TSockHost::GetAsyncSockHost(
494   const TStr& HostNm, const PSockEvent& SockEvent){
495    PSockHost SockHost=PSockHost(new TSockHost(SockEvent));
496    HANDLE SockHostHnd=0;
497    if ((HostNm.Len()>0)){
498      SockHostHnd=WSAAsyncGetHostByName(TSockSys::GetDnsWndHnd(),
499       TSockSys::GetDnsMsgHnd(), HostNm.CStr(),
500       SockHost->HostEntBf, MAXGETHOSTSTRUCT);
501    } else {
502      uint HostIpNum=inet_addr(HostNm.CStr());
503      if (HostIpNum==INADDR_NONE){
504        SockHostHnd=0;
505      } else {
506        SockHostHnd=WSAAsyncGetHostByAddr(TSockSys::GetDnsWndHnd(),
507         TSockSys::GetDnsMsgHnd(), (char*)&HostIpNum, 4, AF_INET,
508         SockHost->HostEntBf, MAXGETHOSTSTRUCT);
509      }
510    }
511    EAssertR(SockHostHnd!=0, TSockSys::GetErrStr(WSAGetLastError()));
512    if (SockHostHnd!=0){
513      TSockSys::AddSockHost(TUInt64(SockHostHnd), SockHost);
514    }
515  }
516  TSockHostStatus TSockHost::GetStatus(const int& ErrCd){
517    switch (ErrCd){
518      case 0: return shsOk;
519      case WSAHOST_NOT_FOUND: return shsHostNotFound;
520      case WSATRY_AGAIN: return shsTryAgain;
521      default: return shsError;
522    }
523  }
524  PSockHost TSockHost::GetLocalSockHost(){
525    PSockHost SockHost=TSockHost::GetSyncSockHost(LocalHostNm);
526    if (SockHost->IsOk()){
527      SockHost=TSockHost::GetSyncSockHost(SockHost->GetHostNm());}
528    return SockHost;
529  }
530  const TStr TSockHost::LocalHostNm("localhost");
531  int TSock::LastSockId=0;
532  TSock::TSock(const PSockEvent& SockEvent):
533    SockId(++LastSockId), SockHnd(0),
534    SockEventId(SockEvent->GetSockEventId()){
535    SockHnd=socket(AF_INET, SOCK_STREAM, 0);
536    EAssertR(SockHnd!=INVALID_SOCKET, TSockSys::GetErrStr(WSAGetLastError()));
537    TSockSys::AddSock(SockId, SockHnd, SockEventId);
538    IAssert(TSockEvent::IsReg(SockEvent));
539  }
540  TSock::TSock(const TSockHnd& _SockHnd, const PSockEvent& SockEvent):
541    SockId(++LastSockId), SockHnd(_SockHnd),
542    SockEventId(SockEvent->GetSockEventId()){
543    TSockSys::AddSock(SockId, SockHnd, SockEventId);
544    IAssert(TSockEvent::IsReg(SockEvent));
545  }
546  TSock::~TSock(){
547    IAssert(!TSockSys::IsSockActive(SockHnd));
548    TSockSys::DelSock(SockId);
549    closesocket(SockHnd);
550  }
551  PSockEvent TSock::GetSockEvent() const {
552    return TSockSys::GetSockEvent(SockEventId);
553  }
554  void TSock::Listen(const int& PortN){
555    sockaddr_in SockAddr;
556    memset(&SockAddr, 0, sizeof(SockAddr));
557    SockAddr.sin_family=AF_INET;
558    SockAddr.sin_addr.s_addr=INADDR_ANY;
559    SockAddr.sin_port=htons(u_short(PortN));
560    EAssertR(
561     bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr))==0,
562     TSockSys::GetErrStr(WSAGetLastError()));
563    EAssertR(
564     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
565      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
566     TSockSys::GetErrStr(WSAGetLastError()));
567    EAssertR(
568     listen(SockHnd, SOMAXCONN)==0,
569     TSockSys::GetErrStr(WSAGetLastError()));
570  }
571  int TSock::GetPortAndListen(const int& MnPortN){
572    int PortN=MnPortN-1;
573    int ErrCd=0;
574    forever {
575      PortN++;
576      sockaddr_in SockAddr;
577      memset(&SockAddr, 0, sizeof(SockAddr));
578      SockAddr.sin_family=AF_INET;
579      SockAddr.sin_addr.s_addr=INADDR_ANY;
580      SockAddr.sin_port=htons(u_short(PortN));
581      int OkCd=bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
582      if (OkCd==SOCKET_ERROR){
583        ErrCd=WSAGetLastError();
584        if (ErrCd!=WSAEADDRINUSE){break;}
585      } else {
586        ErrCd=0; break;
587      }
588    }
589    EAssertR(ErrCd==0, TSockSys::GetErrStr(ErrCd));
590    EAssertR(
591     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
592     TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
593     TSockSys::GetErrStr(WSAGetLastError()));
594    EAssertR(
595     listen(SockHnd, SOMAXCONN)==0,
596     TSockSys::GetErrStr(WSAGetLastError()));
597    return PortN;
598  }
599  void TSock::Connect(const PSockHost& SockHost, const int& PortN){
600    IAssert(SockHost->IsOk());
601    uint HostIpNum=inet_addr(SockHost->GetIpNum().CStr());
602    IAssert(HostIpNum!=INADDR_NONE);
603    sockaddr_in SockAddr;
604    memset(&SockAddr, 0, sizeof(SockAddr));
605    memcpy(&(SockAddr.sin_addr), &HostIpNum, sizeof(HostIpNum));
606    SockAddr.sin_family=AF_INET;
607    SockAddr.sin_port=htons(u_short(PortN));
608    EAssertR(
609     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
610      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
611     TSockSys::GetErrStr(WSAGetLastError()));
612    int ErrCd=connect(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
613    EAssertR(
614     (ErrCd==SOCKET_ERROR)&&(WSAGetLastError()==WSAEWOULDBLOCK),
615     "Unsuccessful socket-connect.");
616  }
617  void TSock::Send(const PSIn& SIn, bool& Ok, int& ErrCd){
618    if (!SIn.Empty()){UnsentBf+=SIn;}
619    Ok=true; ErrCd=0;
620    int SentChs=0;
621    while (SentChs<UnsentBf.Len()){
622      int SendBfL=UnsentBf.Len()-SentChs;
623      if (SendBfL>TSockSys::MxSockBfL){SendBfL=TSockSys::MxSockBfL;}
624      int LSentChs=send(SockHnd, &UnsentBf[SentChs], SendBfL, 0);
625      if (LSentChs==SOCKET_ERROR){
626        ErrCd=WSAGetLastError();
627        Ok=(ErrCd==WSAEWOULDBLOCK);
628        break;
629      } else {
630        SentChs+=LSentChs;
631        TSockSys::SockBytesWritten+=LSentChs;
632      }
633    }
634    UnsentBf.Del(0, SentChs-1);
635  }
636  void TSock::Send(const PSIn& SIn){
637    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
638    if (!Ok){
639     ESAssert(PostMessage(
640      TSockSys::GetSockWndHnd(), TSockSys::SockErrMsgHnd, SockHnd, ErrCd));
641    }
642  }
643  void TSock::SendSafe(const PSIn& SIn){
644    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
645  }
646  TStr TSock::GetPeerIpNum() const {
647    sockaddr_in SockAddr;
648    memset(&SockAddr, 0, sizeof(SockAddr));
649    int NmLen=sizeof(sockaddr_in);
650    EAssertR(
651     getpeername(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
652     TSockSys::GetErrStr(WSAGetLastError()));
653    TStr IpNum=
654     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
655     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
656     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
657     TInt::GetStr(SockAddr.sin_addr.s_impno);
658    return IpNum;
659  }
660  TStr TSock::GetLocalIpNum() const {
661    sockaddr_in SockAddr;
662    memset(&SockAddr, 0, sizeof(SockAddr));
663    int NmLen=sizeof(sockaddr_in);
664    EAssertR(
665     getsockname(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
666     TSockSys::GetErrStr(WSAGetLastError()));
667    TStr IpNum=
668     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
669     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
670     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
671     TInt::GetStr(SockAddr.sin_addr.s_impno);
672    return IpNum;
673  }
674  void TSock::PutTimeOut(const int& MSecs){
675    TSockSys::AddSockTimer(SockId, MSecs);
676  }
677  void TSock::DelTimeOut(){
678    TSockSys::DelIfSockTimer(SockId);
679  }
680  PSock TSock::Accept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
681    sockaddr_in SockAddr;
682    int SockAddrLen=sizeof(SockAddr);
683    memset(&SockAddr, 0, sizeof(SockAddr));
684    TSockHnd AccSockHnd=accept(SockHnd, (sockaddr*)&SockAddr, &SockAddrLen);
685    EAssertR(
686     AccSockHnd!=INVALID_SOCKET,
687     TSockSys::GetErrStr(WSAGetLastError()));
688    PSock AccSock=PSock(new TSock(AccSockHnd, SockEvent));
689    EAssertR(
690     WSAAsyncSelect(AccSock->GetSockHnd(), TSockSys::GetSockWndHnd(),
691      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
692     TSockSys::GetErrStr(WSAGetLastError()));
693    return AccSock;
694  }
695  TStr TSock::GetSockSysStatusStr(){
696    return TSockSys::GetStatusStr();
697  }
698  uint64 TSock::GetSockSysBytesRead(){
699    return TSockSys::SockBytesRead;
700  }
701  uint64 TSock::GetSockSysBytesWritten(){
702    return TSockSys::SockBytesWritten;
703  }
704  bool TSock::IsSockId(const int& SockId){
705    return TSockSys::IsSockId(SockId);
706  }
707  int TReportEvent::LastReportEventId=0;
708  void TReportEvent::SendReport(){
709    TSockSys::AddReportEvent(this);
710    ESAssert(PostMessage(
711     TSockSys::GetReportWndHnd(), TSockSys::GetReportMsgHnd(), 0, ReportEventId));
712  }
713  int TTTimer::LastTimerId=0;
714  TTTimer::TTTimer(const int& _TimeOut):
715    TimerId(++LastTimerId), TimerHnd(0), TimeOut(_TimeOut),
716    Ticks(0), StartTm(TSecTm::GetCurTm()){
717    IAssert(TimeOut>=0);
718    StartTimer(TimeOut);
719  }
720  TTTimer::~TTTimer(){
721    StopTimer();
722  }
723  void TTTimer::StartTimer(const int& _TimeOut){
724    IAssert((_TimeOut==-1)||(_TimeOut>=0));
725    if (_TimeOut!=-1){
726      TimeOut=_TimeOut;}
727    StopTimer();
728    if (TimeOut>0){
729      TimerHnd=uint(SetTimer(
730       TSockSys::GetTimerWndHnd(), UINT(TimerId), UINT(TimeOut), NULL));
731      ESAssert(TimerHnd!=0);
732      TSockSys::AddTimer(this);
733    }
734  }
735  void TTTimer::StopTimer(){
736    if (TimerHnd!=0){
737      ESAssert(KillTimer(TSockSys::GetTimerWndHnd(), TimerId));
738      TSockSys::DelTimer(TimerId);
739      TimerHnd=0;
740    }
741  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</div>
                </div>
                <div class="column column_space"><pre><code>58    void GenStopStr(const TStr& Str){StopStrH.AddKey(TInt(WordH.AddKey(Str)));}
59    void GenFlagTag(const TStr& Str){FlagTagH.AddKey(TInt(WordH.AddKey(Str)));}
60    void GenContTag(const TStr& Str){ContTagH.AddKey(TInt(WordH.AddKey(Str)));}
</pre></code></div>
                <div class="column column_space"><pre><code>102      IdToReportEventH.AddDat(TInt(ReportEvent->GetReportEventId()), ReportEvent);}
103    static void DelReportEvent(const PReportEvent& ReportEvent){
104      IdToReportEventH.DelKey(TInt(ReportEvent->GetReportEventId()));}
105    static bool IsReportEvent(const PReportEvent& ReportEvent){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    