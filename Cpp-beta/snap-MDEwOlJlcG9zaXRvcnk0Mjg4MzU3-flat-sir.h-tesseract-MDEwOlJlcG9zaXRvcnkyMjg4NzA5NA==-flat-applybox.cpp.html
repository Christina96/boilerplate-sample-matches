
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.041274438812455%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.h</h3>
            <pre><code>1  #ifndef snap_sir_h
2  #define snap_sir_h
3  #include "Snap.h"
4  class TEpidemModel {
5  public:
6    TEpidemModel() { } 
7    virtual void GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) = 0;
8    virtual TStr GetStr() const { return TStr(); }
9    virtual double RunCalcErr(const TFltV& ParamV, const int& StepsPerTm) { Fail; return -1; }
10    virtual void GetParam(TFltV& ParamV) const = 0;
11    virtual void SetParam(const TFltV& ParamV) = 0;
12    void RunModel(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV);
13    void RunModel10(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV);
14    void RunEuler(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV);
15    void RungeKutta(const TFltV& y, const TFltV& dydx, double x, double h, TFltV& SirOutV);
16    static double GetErr(const TFltV& TrueV, const TFltV& SimV, const int& SimT0);
17    static void Plot(const TFltV& TrueV, const TStr& Label1, const TFltV& SimV, const TStr& Label2, 
18      const TStr& OutFNm, const TStr& Desc, const TStr& XLabel, const TStr& YLabel);
19    static void LoadTxt(const TStr& InFNm, const int& ColId, TFltV& ValV);
20  };
21  template <class TEpiModel>
22  class TEstEpidemParams {
23  public:
24    TRnd Rnd;
25    TEpiModel Model;
26    TFltTrV ParamMnMxStepV;
27    TFltV ParamV, NewParamV, BestParamV;
28    double CurErr, BestErr;
29    TVec<THash<TFlt,TInt> > ParamH; 
30  public:
31    TEstEpidemParams(const TEpiModel& EpiModel) : Rnd(0), Model(EpiModel) { }
32    bool GetNextSample();
33    void EstParams(const int& NIter);
34    double PlotBest(const TStr& OutFNm, TStr Desc="");
35    void PlotParamHist(const TStr& OutFNm, TStr Desc="");
36  };
37  template <class TEpiModel>
38  bool TEstEpidemParams<TEpiModel>::GetNextSample() {
39    for (int p = 0; p < NewParamV.Len(); p++) {
40      if (ParamMnMxStepV[p].Val3 <= 0) { continue; } 
41      NewParamV[p] = ParamV[p] + ParamMnMxStepV[p].Val3*Rnd.GetNrmDev();
42      if (NewParamV[p] < ParamMnMxStepV[p].Val1) { NewParamV[p]=ParamMnMxStepV[p].Val1; }  
43      if (NewParamV[p] > ParamMnMxStepV[p].Val2) { NewParamV[p]=ParamMnMxStepV[p].Val2; }  
44    }
45    const double NewErr = Model.RunCalcErr(NewParamV);
46    if (NewErr < BestErr || BestErr<1) {
47      BestErr = NewErr;
48      BestParamV = NewParamV;
49    }
50    const double E = exp((CurErr-NewErr)/(4*BestErr)); 
51    if (Rnd.GetUniDev() < E || CurErr<1) { 
52      CurErr = NewErr;
53      ParamV = NewParamV;
54      return true;
55    } else { 
56      return false;
57    }
58  }
59  template <class TEpiModel>
60  void TEstEpidemParams<TEpiModel>::EstParams(const int& NIter) {
61    Model.GetParam(ParamV);
62    NewParamV = ParamV;
63    BestParamV = ParamV;
64    CurErr = -1;
65    BestErr = -1;
66    Model.GetParamRange(ParamMnMxStepV);
67    ParamH.Gen(ParamV.Len());
68    TExeTm ExeTm;
<span onclick='openModal()' class='match'>69    int nAcc=0, plot=0;
70    for (int iter = 0; iter < NIter; iter++) {
71      const bool Accept = GetNextSample();
72      if (Accept) { nAcc++; }
</span>73      for (int p=0; p<ParamV.Len(); p++) { 
74        const double Res = (ParamMnMxStepV[p].Val2-ParamMnMxStepV[p].Val1)/50.0;
75        ParamH[p].AddDat(TMath::Round(ParamV[p]/Res, 1)*Res) += 1;
76      }
77      if (iter % (NIter/100) == 0) {
78        printf("%dk]", iter/1000); 
79        for (int p=0; p<ParamV.Len(); p++) { printf(" %g", ParamV[p]); }
80        printf("\tE:%g B:%g  A:%.3f [%s]\n", CurErr, BestErr, nAcc/double(iter+1), ExeTm.GetStr());
81        if (iter % (NIter/10) == 0) {
82        }
83      }
84    }
85    printf("\ndone. Accept %f\n\n", nAcc/double(NIter));
86  }
87  template <class TEpiModel>
88  double TEstEpidemParams<TEpiModel>::PlotBest(const TStr& OutFNm, TStr Desc) {
89    const double E = Model.RunCalcErr(BestParamV);
90    Model.Plot(OutFNm, Desc);
91    return E;
92  }
93  template <class TEpiModel>
94  void TEstEpidemParams<TEpiModel>::PlotParamHist(const TStr& OutFNm, TStr Desc) {
95    TStrV ParamNmV; Model.GetParamNmV(ParamNmV);
96    for (int p = 0; p < ParamH.Len(); p++) {
97      TGnuPlot::PlotValCntH(ParamH[p], "param-"+ParamNmV[p]+"-"+OutFNm, Desc+" "+Model.GetStr(), ParamNmV[p], "Count");
98    }
99  }
100  class TSirModel : public TEpidemModel {
101  public:
102    double N0, I0;
103    TFltTrV ParamMnMnRngV;
104    double Beta, Gamma;
105    int T0;
106    TFltV TrueInfectV;
107    TVec<TFltV> OutValV; 
108  public:
109    TSirModel(double NZero, TFltTr NZeroP, double IZero, TFltTr IZeroP, double _Beta, TFltTr BetaP, double _Gamma, TFltTr GammaP, 
110      int TZero, TFltTr TZeroP, TStr InFNm, int ColId);
111    TStr GetStr() const { return TStr::Fmt("N0:%g  I0:%g  T0:%d  Beta:%g  Gamma:%g. Err: %f", N0, I0, T0, Beta, Gamma, GetErr()); }
112    void SetPeakT0();
113    void GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV);
114    double GetErr() const;
115    double RunCalcErr(const TFltV& ParamV);
116    void GetParam(TFltV& ParamV) const;
117    void SetParam(const TFltV& ParamV);  
118    void GetParamRange(TFltTrV& ParamMnMxStepV) const;
119    void GetParamNmV(TStrV& ParamNmV) const;
120    void Plot(const TStr& OutFNm, TStr Desc="") const;
121    static void TestEurlerVsRk();
122  };
123  class TSir2Model : public TEpidemModel {
124  public:
125    double N0M, I0M, N0B, I0B;
126    int T0;
127    double BetaM, GammaM, BetaB, GammaB, BetaMB, BetaBM;
128    TFltTrV ParamMnMnRngV;
129    TFltV MediaV, BlogV;
130    TVec<TFltV> OutValV;
131  public:
132    TSir2Model() { }
133    TSir2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
134      int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
135      double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, TStr InFNm, int ColId1, int ColId2);
136    TStr GetStr() const;
137    void SetPeakT0();
138    void SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV);
139    void GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV);
140    double GetErr() const;
141    double RunCalcErr(const TFltV& ParamV);
142    void GetParam(TFltV& ParamV) const;
143    void SetParam(const TFltV& ParamV);
144    void GetParamRange(TFltTrV& ParamMnMxStepV) const;
145    void GetParamNmV(TStrV& ParamNmV) const;
146    void Plot(const TStr& OutFNm, TStr Desc="") const;
147  };
148  class TSirSR2Model : public TEpidemModel {
149  public:
150    double N0M, I0M, N0B, I0B;
151    int T0;
152    double BetaM, GammaM, BetaB, GammaB, BetaMB, BetaBM;
153    double DeltaM, DeltaB;
154    TFltTrV ParamMnMnRngV;
155    TFltV MediaV, BlogV;
156    TVec<TFltV> OutValV;
157  public:
158    TSirSR2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
159      int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
160      double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, 
161      double _DeltaM, TFltTr DeltaMP, double _DeltaB, TFltTr DeltaBP, TStr InFNm, int ColId1, int ColId2);
162    TStr GetStr() const;
163    void SetPeakT0();
164    void SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV);
165    void GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV);
166    double GetErr() const;
167    double RunCalcErr(const TFltV& ParamV);
168    void GetParam(TFltV& ParamV) const;
169    void SetParam(const TFltV& ParamV);
170    void GetParamRange(TFltTrV& ParamMnMxStepV) const;
171    void GetParamNmV(TStrV& ParamNmV) const;
172    void Plot(const TStr& OutFNm, TStr Desc="") const;
173  };
174  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-applybox.cpp</h3>
            <pre><code>1  #ifndef DISABLED_LEGACY_ENGINE
2  #  include <allheaders.h>
3  #  include <cctype>
4  #  include <cerrno>
5  #  include <cstring>
6  #  include "boxread.h"
7  #endif 
8  #include <tesseract/unichar.h>
9  #include "pageres.h"
10  #include "tesseractclass.h"
11  #include "unicharset.h"
12  #ifndef DISABLED_LEGACY_ENGINE
13  const int kMaxGroupSize = 4;
14  const double kMaxXHeightDeviationFraction = 0.125;
15  #endif 
16  namespace tesseract {
17  #ifndef DISABLED_LEGACY_ENGINE
18  static void clear_any_old_text(BLOCK_LIST *block_list) {
19    BLOCK_IT block_it(block_list);
20    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
21      ROW_IT row_it(block_it.data()->row_list());
22      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
23        WERD_IT word_it(row_it.data()->word_list());
24        for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
25          word_it.data()->set_text("");
26        }
27      }
28    }
29  }
30  PAGE_RES *Tesseract::ApplyBoxes(const char *filename, bool find_segmentation,
31                                  BLOCK_LIST *block_list) {
32    std::vector<TBOX> boxes;
33    std::vector<std::string> texts, full_texts;
34    if (!ReadAllBoxes(applybox_page, true, filename, &boxes, &texts, &full_texts, nullptr)) {
35      return nullptr; 
36    }
37    const int box_count = boxes.size();
38    int box_failures = 0;
39    PAGE_RES *page_res = find_segmentation ? nullptr : SetupApplyBoxes(boxes, block_list);
40    clear_any_old_text(block_list);
41    for (int i = 0; i < box_count; i++) {
42      bool foundit = false;
43      if (page_res != nullptr) {
44        foundit =
45            ResegmentCharBox(page_res, (i == 0) ? nullptr : &boxes[i - 1], boxes[i],
46                             (i == box_count - 1) ? nullptr : &boxes[i + 1], full_texts[i].c_str());
47      } else {
48        foundit = ResegmentWordBox(block_list, boxes[i],
49                                   (i == box_count - 1) ? nullptr : &boxes[i + 1], texts[i].c_str());
50      }
51      if (!foundit) {
52        box_failures++;
53        ReportFailedBox(i, boxes[i], texts[i].c_str(), "FAILURE! Couldn't find a matching blob");
54      }
55    }
56    if (page_res == nullptr) {
57      page_res = SetupApplyBoxes(boxes, block_list);
58      ReSegmentByClassification(page_res);
59    }
60    if (applybox_debug > 0) {
61      tprintf("APPLY_BOXES:\n");
62      tprintf("   Boxes read from boxfile:  %6d\n", box_count);
63      if (box_failures > 0) {
64        tprintf("   Boxes failed resegmentation:  %6d\n", box_failures);
65      }
66    }
67    TidyUp(page_res);
68    return page_res;
69  }
70  static double MedianXHeight(BLOCK_LIST *block_list) {
71    BLOCK_IT block_it(block_list);
72    STATS xheights(0, block_it.data()->pdblk.bounding_box().height() - 1);
73    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
74      ROW_IT row_it(block_it.data()->row_list());
75      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
76        xheights.add(IntCastRounded(row_it.data()->x_height()), 1);
77      }
78    }
79    return xheights.median();
80  }
81  void Tesseract::PreenXHeights(BLOCK_LIST *block_list) {
82    const double median_xheight = MedianXHeight(block_list);
83    const double max_deviation = kMaxXHeightDeviationFraction * median_xheight;
84    BLOCK_IT b_it(block_list);
85    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
86      BLOCK *block = b_it.data();
87      ROW_IT r_it(block->row_list());
88      for (r_it.mark_cycle_pt(); !r_it.cycled_list(); r_it.forward()) {
89        ROW *row = r_it.data();
90        const double diff = fabs(row->x_height() - median_xheight);
91        if (diff > max_deviation) {
92          if (applybox_debug) {
93            tprintf("row xheight=%g, but median xheight = %g\n", row->x_height(), median_xheight);
94          }
95          row->set_x_height(static_cast<float>(median_xheight));
96        }
97      }
98    }
99  }
100  PAGE_RES *Tesseract::SetupApplyBoxes(const std::vector<TBOX> &boxes, BLOCK_LIST *block_list) {
101    PreenXHeights(block_list);
102    BLOCK_IT b_it(block_list);
103    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
104      BLOCK *block = b_it.data();
105      ROW_IT r_it(block->row_list());
106      for (r_it.mark_cycle_pt(); !r_it.cycled_list(); r_it.forward()) {
107        ROW *row = r_it.data();
108        WERD_IT w_it(row->word_list());
109        for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
110          WERD *word = w_it.data();
111          if (word->cblob_list()->empty()) {
112            delete w_it.extract();
113          } else {
114            word->set_flag(W_FUZZY_SP, false);
115            word->set_flag(W_FUZZY_NON, false);
116          }
117        }
118      }
119    }
120    auto *page_res = new PAGE_RES(false, block_list, nullptr);
121    PAGE_RES_IT pr_it(page_res);
122    WERD_RES *word_res;
123    while ((word_res = pr_it.word()) != nullptr) {
124      MaximallyChopWord(boxes, pr_it.block()->block, pr_it.row()->row, word_res);
125      pr_it.forward();
126    }
127    return page_res;
128  }
129  void Tesseract::MaximallyChopWord(const std::vector<TBOX> &boxes, BLOCK *block, ROW *row,
130                                    WERD_RES *word_res) {
131    if (!word_res->SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode, nullptr,
132                                       classify_bln_numeric_mode, textord_use_cjk_fp_model,
133                                       poly_allow_detailed_fx, row, block)) {
134      word_res->CloneChoppedToRebuild();
135      return;
136    }
137    if (chop_debug) {
138      tprintf("Maximally chopping word at:");
139      word_res->word->bounding_box().print();
140    }
141    std::vector<BLOB_CHOICE *> blob_choices;
142    ASSERT_HOST(!word_res->chopped_word->blobs.empty());
143    auto rating = static_cast<float>(INT8_MAX);
144    for (unsigned i = 0; i < word_res->chopped_word->NumBlobs(); ++i) {
145      auto *choice = new BLOB_CHOICE(0, rating, -rating, -1, 0.0f, 0.0f, 0.0f, BCC_FAKE);
146      blob_choices.push_back(choice);
147      rating -= 0.125f;
148    }
149    const double e = exp(1.0); 
150    unsigned blob_number;
151    int right_chop_index = 0;
152    if (!assume_fixed_pitch_char_segment) {
153      SEAM *seam = nullptr;
154      while ((seam = chop_one_blob(boxes, blob_choices, word_res, &blob_number)) != nullptr) {
155        word_res->InsertSeam(blob_number, seam);
156        BLOB_CHOICE *left_choice = blob_choices[blob_number];
157        rating = left_choice->rating() / e;
158        left_choice->set_rating(rating);
159        left_choice->set_certainty(-rating);
160        auto *right_choice = new BLOB_CHOICE(++right_chop_index, rating - 0.125f, -rating, -1, 0.0f,
161                                             0.0f, 0.0f, BCC_FAKE);
162        blob_choices.insert(blob_choices.begin() + blob_number + 1, right_choice);
163      }
164    }
165    word_res->CloneChoppedToRebuild();
166    word_res->FakeClassifyWord(blob_choices.size(), &blob_choices[0]);
167  }
168  static double BoxMissMetric(const TBOX &box1, const TBOX &box2) {
169    const int overlap_area = box1.intersection(box2).area();
170    const int a = box1.area();
171    const int b = box2.area();
172    ASSERT_HOST(a != 0 && b != 0);
173    return 1.0 * (a - overlap_area) * (b - overlap_area) / a / b;
174  }
175  bool Tesseract::ResegmentCharBox(PAGE_RES *page_res, const TBOX *prev_box, const TBOX &box,
176                                   const TBOX *next_box, const char *correct_text) {
177    if (applybox_debug > 1) {
178      tprintf("\nAPPLY_BOX: in ResegmentCharBox() for %s\n", correct_text);
179    }
180    PAGE_RES_IT page_res_it(page_res);
181    WERD_RES *word_res;
182    for (word_res = page_res_it.word(); word_res != nullptr; word_res = page_res_it.forward()) {
183      if (!word_res->box_word->bounding_box().major_overlap(box)) {
184        continue;
185      }
186      if (applybox_debug > 1) {
187        tprintf("Checking word box:");
188        word_res->box_word->bounding_box().print();
189      }
190      int word_len = word_res->box_word->length();
191      for (int i = 0; i < word_len; ++i) {
192        TBOX char_box = TBOX();
193        int blob_count = 0;
194        for (blob_count = 0; i + blob_count < word_len; ++blob_count) {
195          TBOX blob_box = word_res->box_word->BlobBox(i + blob_count);
196          if (!blob_box.major_overlap(box)) {
197            break;
198          }
199          if (word_res->correct_text[i + blob_count].length() > 0) {
200            break; 
201          }
202          if (next_box != nullptr) {
203            const double current_box_miss_metric = BoxMissMetric(blob_box, box);
204            const double next_box_miss_metric = BoxMissMetric(blob_box, *next_box);
205            if (applybox_debug > 2) {
206              tprintf("Checking blob:");
207              blob_box.print();
208              tprintf("Current miss metric = %g, next = %g\n", current_box_miss_metric,
209                      next_box_miss_metric);
210            }
211            if (current_box_miss_metric > next_box_miss_metric) {
212              break; 
213            }
214          }
215          char_box += blob_box;
216        }
217        if (blob_count > 0) {
218          if (applybox_debug > 1) {
219            tprintf("Index [%d, %d) seem good.\n", i, i + blob_count);
220          }
221          if (!char_box.almost_equal(box, 3) &&
222              ((next_box != nullptr && box.x_gap(*next_box) < -3) ||
223               (prev_box != nullptr && prev_box->x_gap(box) < -3))) {
224            return false;
225          }
226          word_res->box_word->MergeBoxes(i, i + blob_count);
227          word_res->best_state[i] = blob_count;
228          word_res->correct_text[i] = correct_text;
229          if (applybox_debug > 2) {
230            tprintf("%d Blobs match: blob box:", blob_count);
231            word_res->box_word->BlobBox(i).print();
232            tprintf("Matches box:");
233            box.print();
234            if (next_box != nullptr) {
235              tprintf("With next box:");
236              next_box->print();
237            }
238          }
239          for (int j = 1; j < blob_count; ++j) {
240            word_res->best_state.erase(word_res->best_state.begin() + i + 1);
241            word_res->correct_text.erase(word_res->correct_text.begin() + i + 1);
242          }
243          if (applybox_debug > 1) {
244            tprintf("Best state = ");
245            for (auto best_state : word_res->best_state) {
246              tprintf("%d ", best_state);
247            }
248            tprintf("\n");
249            tprintf("Correct text = [[ ");
250            for (auto &it : word_res->correct_text) {
251              tprintf("%s ", it.c_str());
252            }
253            tprintf("]]\n");
254          }
255          return true;
256        }
257      }
258    }
259    if (applybox_debug > 0) {
260      tprintf("FAIL!\n");
261    }
262    return false; 
263  }
264  bool Tesseract::ResegmentWordBox(BLOCK_LIST *block_list, const TBOX &box, const TBOX *next_box,
265                                   const char *correct_text) {
266    if (applybox_debug > 1) {
267      tprintf("\nAPPLY_BOX: in ResegmentWordBox() for %s\n", correct_text);
268    }
269    WERD *new_word = nullptr;
270    BLOCK_IT b_it(block_list);
271    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
272      BLOCK *block = b_it.data();
273      if (!box.major_overlap(block->pdblk.bounding_box())) {
274        continue;
275      }
276      ROW_IT r_it(block->row_list());
277      for (r_it.mark_cycle_pt(); !r_it.cycled_list(); r_it.forward()) {
278        ROW *row = r_it.data();
279        if (!box.major_overlap(row->bounding_box())) {
280          continue;
281        }
282        WERD_IT w_it(row->word_list());
283        for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
284          WERD *word = w_it.data();
285          if (applybox_debug > 2) {
286            tprintf("Checking word:");
287            word->bounding_box().print();
288          }
289          if (word->text() != nullptr && word->text()[0] != '\0') {
290            continue; 
291          }
292          if (!box.major_overlap(word->bounding_box())) {
293            continue;
294          }
295          C_BLOB_IT blob_it(word->cblob_list());
296          for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
297            C_BLOB *blob = blob_it.data();
298            TBOX blob_box = blob->bounding_box();
299            if (!blob_box.major_overlap(box)) {
300              continue;
301            }
302            if (next_box != nullptr) {
303              const double current_box_miss_metric = BoxMissMetric(blob_box, box);
304              const double next_box_miss_metric = BoxMissMetric(blob_box, *next_box);
305              if (applybox_debug > 2) {
306                tprintf("Checking blob:");
307                blob_box.print();
308                tprintf("Current miss metric = %g, next = %g\n", current_box_miss_metric,
309                        next_box_miss_metric);
310              }
311              if (current_box_miss_metric > next_box_miss_metric) {
312                continue; 
313              }
314            }
315            if (applybox_debug > 2) {
316              tprintf("Blob match: blob:");
317              blob_box.print();
318              tprintf("Matches box:");
319              box.print();
320              if (next_box != nullptr) {
321                tprintf("With next box:");
322                next_box->print();
323              }
324            }
325            if (new_word == nullptr) {
326              new_word = word->shallow_copy();
327              new_word->set_text(correct_text);
328              w_it.add_to_end(new_word);
329            }
330            C_BLOB_IT new_blob_it(new_word->cblob_list());
331            new_blob_it.add_to_end(blob_it.extract());
332          }
333        }
334      }
335    }
336    if (new_word == nullptr && applybox_debug > 0) {
337      tprintf("FAIL!\n");
338    }
339    return new_word != nullptr;
340  }
341  void Tesseract::ReSegmentByClassification(PAGE_RES *page_res) {
342    PAGE_RES_IT pr_it(page_res);
343    WERD_RES *word_res;
344    for (; (word_res = pr_it.word()) != nullptr; pr_it.forward()) {
345      const WERD *word = word_res->word;
346      if (word->text() == nullptr || word->text()[0] == '\0') {
347        continue; 
348      }
349      std::vector<UNICHAR_ID> target_text;
350      if (!ConvertStringToUnichars(word->text(), &target_text)) {
351        tprintf("APPLY_BOX: FAILURE: can't find class_id for '%s'\n", word->text());
352        pr_it.DeleteCurrentWord();
353        continue;
354      }
355      if (!FindSegmentation(target_text, word_res)) {
356        tprintf("APPLY_BOX: FAILURE: can't find segmentation for '%s'\n", word->text());
357        pr_it.DeleteCurrentWord();
358        continue;
359      }
360    }
361  }
362  bool Tesseract::ConvertStringToUnichars(const char *utf8, std::vector<UNICHAR_ID> *class_ids) {
363    for (int step = 0; *utf8 != '\0'; utf8 += step) {
364      const char *next_space = strchr(utf8, ' ');
365      if (next_space == nullptr) {
366        next_space = utf8 + strlen(utf8);
367      }
368      step = next_space - utf8;
369      UNICHAR_ID class_id = unicharset.unichar_to_id(utf8, step);
370      if (class_id == INVALID_UNICHAR_ID) {
371        return false;
372      }
373      while (utf8[step] == ' ') {
374        ++step;
375      }
376      class_ids->push_back(class_id);
377    }
378    return true;
379  }
380  bool Tesseract::FindSegmentation(const std::vector<UNICHAR_ID> &target_text, WERD_RES *word_res) {
381    const int word_length = word_res->box_word->length();
382    auto *choices = new std::vector<BLOB_CHOICE_LIST *>[word_length];
<span onclick='openModal()' class='match'>383    for (int i = 0; i < word_length; ++i) {
384      for (int j = 1; j <= kMaxGroupSize && i + j <= word_length; ++j) {
385        BLOB_CHOICE_LIST *match_result =
386            classify_piece(word_res->seam_array, i, i + j - 1, "Applybox", word_res->chopped_word,
387                           word_res->blamer_bundle);
388        if (applybox_debug > 2) {
</span>389          tprintf("%d+%d:", i, j);
390          print_ratings_list("Segment:", match_result, unicharset);
391        }
392        choices[i].push_back(match_result);
393      }
394    }
395    word_res->best_state.clear();
396    std::vector<int> search_segmentation;
397    float best_rating = 0.0f;
398    SearchForText(choices, 0, word_length, target_text, 0, 0.0f, &search_segmentation, &best_rating,
399                  &word_res->best_state);
400    for (int i = 0; i < word_length; ++i) {
401      for (auto choice : choices[i]) {
402        delete choice;
403      }
404    }
405    delete[] choices;
406    if (word_res->best_state.empty()) {
407      int blob_count = 1;
408      for (auto s : word_res->seam_array) {
409        SEAM *seam = s;
410        if (!seam->HasAnySplits()) {
411          word_res->best_state.push_back(blob_count);
412          blob_count = 1;
413        } else {
414          ++blob_count;
415        }
416      }
417      word_res->best_state.push_back(blob_count);
418      if (word_res->best_state.size() != target_text.size()) {
419        word_res->best_state.clear(); 
420        return false;
421      }
422    }
423    word_res->correct_text.clear();
424    for (auto &text : target_text) {
425      word_res->correct_text.emplace_back(unicharset.id_to_unichar(text));
426    }
427    return true;
428  }
429  void Tesseract::SearchForText(const std::vector<BLOB_CHOICE_LIST *> *choices, int choices_pos,
430                                unsigned choices_length, const std::vector<UNICHAR_ID> &target_text,
431                                unsigned text_index, float rating, std::vector<int> *segmentation,
432                                float *best_rating, std::vector<int> *best_segmentation) {
433    const UnicharAmbigsVector &table = getDict().getUnicharAmbigs().dang_ambigs();
434    for (unsigned length = 1; length <= choices[choices_pos].size(); ++length) {
435      float choice_rating = 0.0f;
436      BLOB_CHOICE_IT choice_it(choices[choices_pos][length - 1]);
437      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
438        const BLOB_CHOICE *choice = choice_it.data();
439        choice_rating = choice->rating();
440        auto class_id = choice->unichar_id();
441        if (class_id == target_text[text_index]) {
442          break;
443        }
444        if (static_cast<size_t>(class_id) < table.size() && table[class_id] != nullptr) {
445          AmbigSpec_IT spec_it(table[class_id]);
446          for (spec_it.mark_cycle_pt(); !spec_it.cycled_list(); spec_it.forward()) {
447            const AmbigSpec *ambig_spec = spec_it.data();
448            if (ambig_spec->wrong_ngram[1] == INVALID_UNICHAR_ID &&
449                ambig_spec->correct_ngram_id == target_text[text_index]) {
450              break;
451            }
452          }
453          if (!spec_it.cycled_list()) {
454            break; 
455          }
456        }
457      }
458      if (choice_it.cycled_list()) {
459        continue; 
460      }
461      segmentation->push_back(length);
462      if (choices_pos + length == choices_length && text_index + 1 == target_text.size()) {
463        if (applybox_debug > 2) {
464          tprintf("Complete match, rating = %g, best=%g, seglength=%zu, best=%zu\n",
465                  rating + choice_rating, *best_rating, segmentation->size(),
466                  best_segmentation->size());
467        }
468        if (best_segmentation->empty() || rating + choice_rating < *best_rating) {
469          *best_segmentation = *segmentation;
470          *best_rating = rating + choice_rating;
471        }
472      } else if (choices_pos + length < choices_length && text_index + 1 < target_text.size()) {
473        if (applybox_debug > 3) {
474          tprintf("Match found for %d=%s:%s, at %d+%d, recursing...\n", target_text[text_index],
475                  unicharset.id_to_unichar(target_text[text_index]),
476                  choice_it.data()->unichar_id() == target_text[text_index] ? "Match" : "Ambig",
477                  choices_pos, length);
478        }
479        SearchForText(choices, choices_pos + length, choices_length, target_text, text_index + 1,
480                      rating + choice_rating, segmentation, best_rating, best_segmentation);
481        if (applybox_debug > 3) {
482          tprintf("End recursion for %d=%s\n", target_text[text_index],
483                  unicharset.id_to_unichar(target_text[text_index]));
484        }
485      }
486      segmentation->resize(segmentation->size() - 1);
487    }
488  }
489  void Tesseract::TidyUp(PAGE_RES *page_res) {
490    int ok_blob_count = 0;
491    int bad_blob_count = 0;
492    int ok_word_count = 0;
493    int unlabelled_words = 0;
494    PAGE_RES_IT pr_it(page_res);
495    WERD_RES *word_res;
496    for (; (word_res = pr_it.word()) != nullptr; pr_it.forward()) {
497      int ok_in_word = 0;
498      int blob_count = word_res->correct_text.size();
499      auto *word_choice = new WERD_CHOICE(word_res->uch_set, blob_count);
500      word_choice->set_permuter(TOP_CHOICE_PERM);
501      for (int c = 0; c < blob_count; ++c) {
502        if (word_res->correct_text[c].length() > 0) {
503          ++ok_in_word;
504        }
505        word_choice->append_unichar_id_space_allocated(INVALID_UNICHAR_ID, word_res->best_state[c],
506                                                       1.0f, -1.0f);
507      }
508      if (ok_in_word > 0) {
509        ok_blob_count += ok_in_word;
510        bad_blob_count += word_res->correct_text.size() - ok_in_word;
511        word_res->LogNewRawChoice(word_choice);
512        word_res->LogNewCookedChoice(1, false, word_choice);
513      } else {
514        ++unlabelled_words;
515        if (applybox_debug > 0) {
516          tprintf("APPLY_BOXES: Unlabelled word at :");
517          word_res->word->bounding_box().print();
518        }
519        pr_it.DeleteCurrentWord();
520        delete word_choice;
521      }
522    }
523    pr_it.restart_page();
524    for (; (word_res = pr_it.word()) != nullptr; pr_it.forward()) {
525      word_res->RebuildBestState();
526      word_res->SetupBoxWord();
527      word_res->word->set_flag(W_BOL, pr_it.prev_row() != pr_it.row());
528      word_res->word->set_flag(W_EOL, pr_it.next_row() != pr_it.row());
529    }
530    if (applybox_debug > 0) {
531      tprintf("   Found %d good blobs.\n", ok_blob_count);
532      if (bad_blob_count > 0) {
533        tprintf("   Leaving %d unlabelled blobs in %d words.\n", bad_blob_count, ok_word_count);
534      }
535      if (unlabelled_words > 0) {
536        tprintf("   %d remaining unlabelled words deleted.\n", unlabelled_words);
537      }
538    }
539  }
540  void Tesseract::ReportFailedBox(int boxfile_lineno, TBOX box, const char *box_ch,
541                                  const char *err_msg) {
542    tprintf("APPLY_BOXES: boxfile line %d/%s ((%d,%d),(%d,%d)): %s\n", boxfile_lineno + 1, box_ch,
543            box.left(), box.bottom(), box.right(), box.top(), err_msg);
544  }
545  void Tesseract::ApplyBoxTraining(const std::string &fontname, PAGE_RES *page_res) {
546    PAGE_RES_IT pr_it(page_res);
547    int word_count = 0;
548    for (WERD_RES *word_res = pr_it.word(); word_res != nullptr; word_res = pr_it.forward()) {
549      LearnWord(fontname.c_str(), word_res);
550      ++word_count;
551    }
552    tprintf("Generated training data for %d words\n", word_count);
553  }
554  #endif 
555  void Tesseract::CorrectClassifyWords(PAGE_RES *page_res) {
556    PAGE_RES_IT pr_it(page_res);
557    for (WERD_RES *word_res = pr_it.word(); word_res != nullptr; word_res = pr_it.forward()) {
558      auto *choice = new WERD_CHOICE(word_res->uch_set, word_res->correct_text.size());
559      for (auto &correct_text : word_res->correct_text) {
560        std::vector<std::string> tokens = split(correct_text, ' ');
561        UNICHAR_ID char_id = unicharset.unichar_to_id(tokens[0].c_str());
562        choice->append_unichar_id_space_allocated(char_id, word_res->best_state[&correct_text - &word_res->correct_text[0]], 0.0f, 0.0f);
563      }
564      word_res->ClearWordChoices();
565      word_res->LogNewRawChoice(choice);
566      word_res->LogNewCookedChoice(1, false, choice);
567    }
568  }
569  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-applybox.cpp</div>
                </div>
                <div class="column column_space"><pre><code>69    int nAcc=0, plot=0;
70    for (int iter = 0; iter < NIter; iter++) {
71      const bool Accept = GetNextSample();
72      if (Accept) { nAcc++; }
</pre></code></div>
                <div class="column column_space"><pre><code>383    for (int i = 0; i < word_length; ++i) {
384      for (int j = 1; j <= kMaxGroupSize && i + j <= word_length; ++j) {
385        BLOB_CHOICE_LIST *match_result =
386            classify_piece(word_res->seam_array, i, i + j - 1, "Applybox", word_res->chopped_word,
387                           word_res->blamer_bundle);
388        if (applybox_debug > 2) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    