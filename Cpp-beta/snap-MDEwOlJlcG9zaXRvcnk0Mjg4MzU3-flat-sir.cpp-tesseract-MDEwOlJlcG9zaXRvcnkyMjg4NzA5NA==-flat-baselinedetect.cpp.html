
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.691629955947137%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "sir.h"
3  void TEpidemModel::RunModel(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
4    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
5    OutValV.Clr(false);
6    for (int v = 0; v < StartValV.Len(); v++) {
7      OutValV.Add();
8      OutValV[v].Clr(false);
9      OutValV[v].Add(StartValV[v]);
10    }
11    const double h = (StopT-StartT) / NSteps;
12    double x = StartT;
13    for (int k = 0; k < NSteps; k++) {
14      GetDerivs(x, ValV, dydx);
15      RungeKutta(ValV, dydx, x, h, ValV2);
16      for (int v = 0; v < ValV2.Len(); v++) {
17        double X = ValV2[v];
18        if (X < 0 || _isnan(X) || !_finite(X)) { X = 0; }
19        OutValV[v].Add(X);
20      }
21      ValV = ValV2;
22      x += h;
23    }
24  }
25  void TEpidemModel::RunModel10(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
26    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
27    OutValV.Clr(false);
28    for (int v = 0; v < StartValV.Len(); v++) {
29      OutValV.Add();
30      OutValV[v].Clr(false);
31      OutValV[v].Add(StartValV[v]);
32    }
33    const double h = (StopT-StartT) / (10*NSteps);
34    double x = StartT;
35    for (int k = 0; k < 10*NSteps; k++) {
36      GetDerivs(x, ValV, dydx);
37      RungeKutta(ValV, dydx, x, h, ValV2);
38      if (k % 10 == 0) {
39        for (int v = 0; v < ValV2.Len(); v++) {
40          OutValV[v].Add(ValV2[v]); }
41      }
42      ValV = ValV2;
43      x += h;
44    }
45  }
46  void TEpidemModel::RunEuler(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
47    const double h = (StopT-StartT) / NSteps;
48    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
49    for (int v = 0; v < StartValV.Len(); v++) {
50      OutValV.Add();
51      OutValV[v].Clr(false);
52      OutValV[v].Add(StartValV[v]);
53    }
54    OutValV.Add(); 
55    OutValV.Last().Add(StartT);
56    for (double x = StartT; x <= StopT; x += h) {
57      GetDerivs(x, ValV, dydx);
58      for (int v = 0; v < ValV.Len(); v++) {
59        ValV[v] += h*dydx[v];
60        OutValV[v].Add(ValV[v]);
61      }
62      OutValV.Last().Add(x+h);
63    }
64    for (int v = 1; v < OutValV.Len(); v++) {
65      IAssert(OutValV[v].Len()==OutValV[v-1].Len());
66    }
67  }
68  void TEpidemModel::RungeKutta(const TFltV& y, const TFltV& dydx, double x, double h, TFltV& SirOutV) {
69    const int n = y.Len();
70    IAssert(y.Len() == n && dydx.Len() == n);
71    TFltV dym(n), dyt(n), yt(n);
72    int i;
73    double hh=h*0.5;
74    double h6=h/6.0;
75    double xh=x+hh;
76    for (i=0; i < n; i++) {
77      yt[i]=y[i]+hh*dydx[i];
78    }
79    GetDerivs(xh, yt, dyt);
80    for (i=0; i<n; i++) {
81      yt[i]=y[i]+hh*dyt[i];
82    }
83    GetDerivs(xh,yt,dym);
84    for (i=0; i<n; i++) {
85  	  yt[i]=y[i]+h*dym[i];
86  	  dym[i] += dyt[i];
87    }
88    GetDerivs(x+h,yt,dyt);
89    SirOutV.Clr(false);  
90    for (i=0; i<n; i++) {
91      SirOutV.Add(y[i]+h6 * (dydx[i]+dyt[i]+2.0*dym[i]));
92    }
93  }
94  double TEpidemModel::GetErr(const TFltV& TrueV, const TFltV& SimV, const int& SimT0) { 
95    if (SimV.Empty() || TrueV.Empty()) { return -1.0; }
96    double Err = 0.0;
97    double S=0;
98    for (int t=0; t < TrueV.Len(); t++) {
99      if (t-SimT0 >= 0) { S = SimV[t-SimT0]; } else { S = 0; }
100      Err += TMath::Sqr(TrueV[t]-S);
101    }
102    if (Err <= 0) { Err = TFlt::Mx; }
103    return Err;
104  }
105  void TEpidemModel::Plot(const TFltV& TrueV, const TStr& Label1, const TFltV& SimV, const TStr& Label2, const TStr& OutFNm, const TStr& Desc, const TStr& XLabel, const TStr& YLabel) {
106    TGnuPlot GP(OutFNm, Desc);
107    GP.AddPlot(TrueV, gpwLinesPoints, Label1);
108    GP.AddPlot(SimV, gpwLinesPoints, Label2);
109    GP.SetXYLabel(XLabel, YLabel);
110    GP.SavePng();
111  }
112  void TEpidemModel::LoadTxt(const TStr& InFNm, const int& ColId, TFltV& ValV) {
113    ValV.Clr();
114    if (! TFile::Exists(InFNm)) { 
115      printf("*** %s not found!\n", InFNm.CStr());
116      return; 
117    }
118    TSsParser Ss(InFNm, ssfTabSep);
119    while (Ss.Next()) {
120      ValV.Add(Ss.GetFlt(ColId));
121    }
122  }
123  TSirModel::TSirModel(double NZero, TFltTr NZeroP, double IZero, TFltTr IZeroP, double _Beta, TFltTr BetaP, double _Gamma, TFltTr GammaP, int TZero, TFltTr TZeroP, TStr InFNm, int ColId) :
124   N0(NZero), I0(IZero), Beta(_Beta), Gamma(_Gamma), T0(TZero) { 
125    ParamMnMnRngV.Add(NZeroP);
126    ParamMnMnRngV.Add(IZeroP);
127    ParamMnMnRngV.Add(BetaP);
128    ParamMnMnRngV.Add(GammaP);
129    ParamMnMnRngV.Add(TZeroP);
130    TEpidemModel::LoadTxt(InFNm, ColId, TrueInfectV); 
131  }
132  void TSirModel::GetParam(TFltV& ParamV) const { 
133    ParamV.Clr(false); 
134    ParamV.Add(N0);
135    ParamV.Add(I0);
136    ParamV.Add(Beta); 
137    ParamV.Add(Gamma); 
138    ParamV.Add(T0);
139  }
140  void TSirModel::SetParam(const TFltV& ParamV) { 
141    N0 = ParamV[0];
142    I0 = ParamV[1];
143    Beta = ParamV[2]; 
144    Gamma = ParamV[3]; 
145    T0 = int(ParamV[4]); 
146  }
147  void TSirModel::SetPeakT0() {
<span onclick='openModal()' class='match'>148    double Max =0;
149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
</span>151      if (TrueInfectV[i] > Max) { 
152        Max=TrueInfectV[i]; 
153        Peak=i;
154      }
155    }
156    T0 = int(0.9*Peak);
157    ParamMnMnRngV[4].Val1 = Peak - 0.5*abs(Peak); 
158    ParamMnMnRngV[4].Val2 = Peak + 0.5*abs(Peak); 
159    printf("Set peak T0 = %d (%g -- %g)\n", Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2);
160  }
161  void TSirModel::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
162    dxdyV[0] = -Beta*SirValV[0]*SirValV[1];
163    dxdyV[1] = Beta*SirValV[0]*SirValV[1] - Gamma*SirValV[1];
164  }
165  double TSirModel::GetErr() const { 
166    return TEpidemModel::GetErr(TrueInfectV, OutValV[1], T0);
167  }
168  double TSirModel::RunCalcErr(const TFltV& ParamV) {
169    SetParam(ParamV);
170    const int EndT = TrueInfectV.Len() - T0 + 2;
171    RunModel(TFltV::GetV(N0-I0, I0), 0, EndT, EndT, OutValV);
172    return GetErr();
173  }
174  void TSirModel::GetParamRange(TFltTrV& ParamMnMxStepV) const {
175    ParamMnMxStepV = ParamMnMnRngV; 
176  }
177  void TSirModel::GetParamNmV(TStrV& ParamNmV) const {
178    ParamNmV = TStrV::GetV("Beta", "Gamma");
179  }
180  void TSirModel::Plot(const TStr& OutFNm, TStr Desc) const {
181    if (OutValV.Empty()) { printf("EMPTY()");  return; }
182    TFltV V2;
183    for (int t=0; t < TrueInfectV.Len(); t++) {
184      if (t-T0 >= 0) { V2.Add(OutValV[1][t-T0]); } else { V2.Add(0); }
185    }
186    TEpidemModel::Plot(TrueInfectV, "TRUE", V2, "SIR model", OutFNm, Desc+" "+GetStr(), "Time", "Number of infected nodes");
187  }
188  void TSirModel::TestEurlerVsRk() {
189  }
190  TSir2Model::TSir2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
191    int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, double _GammaB, TFltTr GammaBP, 
192    double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, TStr InFNm, int ColId1, int ColId2) : N0M(_N0M), I0M(_I0M), N0B(_N0B), I0B(_I0B), T0(_T0), BetaM(_BetaM), 
193    GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM) { 
194    ParamMnMnRngV.Add(N0MP);
195    ParamMnMnRngV.Add(I0MP);
196    ParamMnMnRngV.Add(N0BP);
197    ParamMnMnRngV.Add(I0BP);
198    ParamMnMnRngV.Add(T0P);
199    ParamMnMnRngV.Add(BetaMP);
200    ParamMnMnRngV.Add(GammaMP);
201    ParamMnMnRngV.Add(BetaBP);
202    ParamMnMnRngV.Add(GammaBP);
203    ParamMnMnRngV.Add(BetaMBP);
204    ParamMnMnRngV.Add(BetaBMP);
205    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
206      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
207      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
208    }
209  }
210  void TSir2Model::GetParam(TFltV& ParamV) const { 
211    ParamV.Clr(false); 
212    ParamV.Add(N0M);
213    ParamV.Add(I0M);
214    ParamV.Add(N0B);
215    ParamV.Add(I0B);
216    ParamV.Add(T0);
217    ParamV.Add(BetaM);
218    ParamV.Add(GammaM);
219    ParamV.Add(BetaB);
220    ParamV.Add(GammaB);
221    ParamV.Add(BetaMB);
222    ParamV.Add(BetaBM);
223  }
224  void TSir2Model::SetParam(const TFltV& ParamV) { 
225    N0M = ParamV[0];
226    I0M = ParamV[1];
227    N0B = ParamV[2];
228    I0B = ParamV[3];
229    T0 = (int) ParamV[4];
230    BetaM = ParamV[5];
231    GammaM = ParamV[6];
232    BetaB = ParamV[7];
233    GammaB = ParamV[8];
234    BetaMB = ParamV[9];
235    BetaBM = ParamV[10];
236  }
237  TStr TSir2Model::GetStr() const { 
238    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g Err: %.2f", 
239      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, GetErr()); 
240  }
241  void TSir2Model::SetPeakT0() {
242    double Max1=0, Max2=0;
243    int Peak1=0, Peak2=0;
244    for (int i = 0; i < MediaV.Len(); i++) {
245      if (MediaV[i] > Max1) { 
246        Max1 = MediaV[i]; Peak1 = i; }
247    }
248    for (int i = 0; i < BlogV.Len(); i++) {
249      if (BlogV[i] > Max2) { 
250        Max2 = BlogV[i]; Peak2 = i; }
251    }
252    int Peak = TMath::Mn(Peak1, Peak2);
253    T0 = int(0.9*Peak);
254    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
255    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
256    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
257      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
258  }
259  void TSir2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
260    IAssert(_MediaV.Len() == _BlogV.Len());
261    MediaV.Clr(false);  BlogV.Clr(false);
262    for (int i = 0; i < _MediaV.Len(); i++) {
263      MediaV.Add(_MediaV[i].Val2);
264      BlogV.Add(_BlogV[i].Val2);
265    }
266  }
267  void TSir2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
268    const TFlt& SM = SirValV[0];
269    const TFlt& SB = SirValV[1];
270    const TFlt& IM = SirValV[2];
271    const TFlt& IB = SirValV[3];
272    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM;
273    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB;
274    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
275    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
276  }
277  double TSir2Model::GetErr() const { 
278    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
279  }
280  double TSir2Model::RunCalcErr(const TFltV& ParamV) {
281    SetParam(ParamV);
282    const int EndT = BlogV.Len() - T0 + 2;
283    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
284    return GetErr();
285  }
286  void TSir2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
287    ParamMnMxStepV = ParamMnMnRngV; 
288  }
289  void TSir2Model::GetParamNmV(TStrV& ParamNmV) const {
290    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM").SplitOnAllCh(',', ParamNmV);
291  }
292  void TSir2Model::Plot(const TStr& OutFNm, TStr Desc) const {
293    if (OutValV.Empty()) { printf("EMPTY()");  return; }
294    TFltV MV, BV;
295    const TFltV& SMediaV = OutValV[2];
296    for (int t=0; t < MediaV.Len(); t++) {
297      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
298    }
299    const TFltV& SBlogV = OutValV[3];
300    for (int t=0; t < BlogV.Len(); t++) {
301      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
302    }
303    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
304    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
305    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
306    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
307    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
308    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
309    GP.SavePng();
310  }
311  TSirSR2Model::TSirSR2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
312   int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
313   double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, 
314   double _DeltaM, TFltTr DeltaMP, double _DeltaB, TFltTr DeltaBP, TStr InFNm, int ColId1, int ColId2) :  N0M(_N0M), I0M(_I0M), N0B(_N0B), 
315   I0B(_I0B), T0(_T0), BetaM(_BetaM), GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM),
316   DeltaM(_DeltaM), DeltaB(DeltaB) { 
317    ParamMnMnRngV.Add(N0MP);
318    ParamMnMnRngV.Add(I0MP);
319    ParamMnMnRngV.Add(N0BP);
320    ParamMnMnRngV.Add(I0BP);
321    ParamMnMnRngV.Add(T0P);
322    ParamMnMnRngV.Add(BetaMP);
323    ParamMnMnRngV.Add(GammaMP);
324    ParamMnMnRngV.Add(BetaBP);
325    ParamMnMnRngV.Add(GammaBP);
326    ParamMnMnRngV.Add(BetaMBP);
327    ParamMnMnRngV.Add(BetaBMP);
328    ParamMnMnRngV.Add(DeltaMP);
329    ParamMnMnRngV.Add(DeltaBP);
330    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
331      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
332      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
333    }
334  }
335  void TSirSR2Model::GetParam(TFltV& ParamV) const { 
336    ParamV.Clr(false); 
337    ParamV.Add(N0M);
338    ParamV.Add(I0M);
339    ParamV.Add(N0B);
340    ParamV.Add(I0B);
341    ParamV.Add(T0);
342    ParamV.Add(BetaM);
343    ParamV.Add(GammaM);
344    ParamV.Add(BetaB);
345    ParamV.Add(GammaB);
346    ParamV.Add(BetaMB);
347    ParamV.Add(BetaBM);
348    ParamV.Add(DeltaM);
349    ParamV.Add(DeltaB);
350  }
351  void TSirSR2Model::SetParam(const TFltV& ParamV) { 
352    N0M = ParamV[0];
353    I0M = ParamV[1];
354    N0B = ParamV[2];
355    I0B = ParamV[3];
356    T0 = (int) ParamV[4];
357    BetaM = ParamV[5];
358    GammaM = ParamV[6];
359    BetaB = ParamV[7];
360    GammaB = ParamV[8];
361    BetaMB = ParamV[9];
362    BetaBM = ParamV[10];
363    DeltaM = ParamV[11];
364    DeltaB = ParamV[12];
365  }
366  TStr TSirSR2Model::GetStr() const { 
367    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g  Delta:%g %g    ERR: %.2f", 
368      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, DeltaM, DeltaB, GetErr()); 
369  }
370  void TSirSR2Model::SetPeakT0() {
371    double Max1=0, Max2=0;
372    int Peak1=0, Peak2=0;
373    for (int i = 0; i < MediaV.Len(); i++) {
374      if (MediaV[i] > Max1) { 
375        Max1 = MediaV[i]; Peak1 = i; }
376    }
377    for (int i = 0; i < BlogV.Len(); i++) {
378      if (BlogV[i] > Max2) { 
379        Max2 = BlogV[i]; Peak2 = i; }
380    }
381    int Peak = TMath::Mn(Peak1, Peak2);
382    T0 = int(0.9*Peak);
383    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
384    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
385    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
386      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
387  }
388  void TSirSR2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
389    IAssert(_MediaV.Len() == _BlogV.Len());
390    MediaV.Clr(false);  BlogV.Clr(false);
391    for (int i = 0; i < _MediaV.Len(); i++) {
392      MediaV.Add(_MediaV[i].Val2);
393      BlogV.Add(_BlogV[i].Val2);
394    }
395  }
396  void TSirSR2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
397    const TFlt& SM = SirValV[0];
398    const TFlt& SB = SirValV[1];
399    const TFlt& IM = SirValV[2];
400    const TFlt& IB = SirValV[3];
401    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM - DeltaM*SM;
402    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB - DeltaB*SB;
403    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
404    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
405  }
406  double TSirSR2Model::GetErr() const { 
407    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
408  }
409  double TSirSR2Model::RunCalcErr(const TFltV& ParamV) {
410    SetParam(ParamV);
411    const int EndT = BlogV.Len() - T0 + 2;
412    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
413    return GetErr();
414  }
415  void TSirSR2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
416    ParamMnMxStepV = ParamMnMnRngV; 
417  }
418  void TSirSR2Model::GetParamNmV(TStrV& ParamNmV) const {
419    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM,DeltaM,DeltaB").SplitOnAllCh(',', ParamNmV);
420  }
421  void TSirSR2Model::Plot(const TStr& OutFNm, TStr Desc) const {
422    if (OutValV.Empty()) { printf("EMPTY()");  return; }
423    TFltV MV, BV;
424    const TFltV& SMediaV = OutValV[2];
425    for (int t=0; t < MediaV.Len(); t++) {
426      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
427    }
428    const TFltV& SBlogV = OutValV[3];
429    for (int t=0; t < BlogV.Len(); t++) {
430      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
431    }
432    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
433    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
434    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
435    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
436    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
437    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
438    GP.SavePng();
439  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baselinedetect.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "baselinedetect.h"
6  #include <allheaders.h>
7  #include <algorithm>
8  #include <cfloat> 
9  #include <cmath>  
10  #include "blobbox.h"
11  #include "detlinefit.h"
12  #include "drawtord.h"
13  #include "helpers.h"
14  #include "linlsq.h"
15  #include "makerow.h"
16  #include "textord.h"
17  #include "tprintf.h"
18  #include "underlin.h"
19  const int kMaxDisplacementsModes = 3;
20  const int kNumSkipPoints = 3;
21  const double kMaxSkewDeviation = 1.0 / 64;
22  const double kOffsetQuantizationFactor = 3.0 / 64;
23  const double kFitHalfrangeFactor = 6.0 / 64;
24  const double kMaxBaselineError = 3.0 / 64;
25  const double kMaxBlobSizeMultiple = 1.3;
26  const double kMinFittingLinespacings = 0.25;
27  namespace tesseract {
28  BaselineRow::BaselineRow(double line_spacing, TO_ROW *to_row)
29      : blobs_(to_row->blob_list()),
30        baseline_pt1_(0.0f, 0.0f),
31        baseline_pt2_(0.0f, 0.0f),
32        baseline_error_(0.0),
33        good_baseline_(false) {
34    ComputeBoundingBox();
35    disp_quant_factor_ = kOffsetQuantizationFactor * line_spacing;
36    fit_halfrange_ = kFitHalfrangeFactor * line_spacing;
37    max_baseline_error_ = kMaxBaselineError * line_spacing;
38  }
39  void BaselineRow::SetupOldLineParameters(TO_ROW *row) const {
40    double gradient = tan(BaselineAngle());
41    float para_c = StraightYAtX(0.0);
42    row->set_line(gradient, para_c, baseline_error_);
43    row->set_parallel_line(gradient, para_c, baseline_error_);
44  }
45  void BaselineRow::Print() const {
46    tprintf("Baseline (%g,%g)->(%g,%g), angle=%g, intercept=%g\n",
47            baseline_pt1_.x(), baseline_pt1_.y(), baseline_pt2_.x(),
48            baseline_pt2_.y(), BaselineAngle(), StraightYAtX(0.0));
49    tprintf("Quant factor=%g, error=%g, good=%d, box:", disp_quant_factor_,
50            baseline_error_, good_baseline_);
51    bounding_box_.print();
52  }
53  double BaselineRow::BaselineAngle() const {
54    FCOORD baseline_dir(baseline_pt2_ - baseline_pt1_);
55    double angle = baseline_dir.angle();
56    return fmod(angle + M_PI * 1.5, M_PI) - M_PI * 0.5;
57  }
58  double BaselineRow::SpaceBetween(const BaselineRow &other) const {
59    float x = (std::max(bounding_box_.left(), other.bounding_box_.left()) +
60               std::min(bounding_box_.right(), other.bounding_box_.right())) /
61              2.0f;
62    float y = (StraightYAtX(x) + other.StraightYAtX(x)) / 2.0f;
63    FCOORD pt(x, y);
64    return PerpDistanceFromBaseline(pt) + other.PerpDistanceFromBaseline(pt);
65  }
66  double BaselineRow::PerpDisp(const FCOORD &direction) const {
67    float middle_x = (bounding_box_.left() + bounding_box_.right()) / 2.0f;
68    FCOORD middle_pos(middle_x, StraightYAtX(middle_x));
69    return direction * middle_pos / direction.length();
70  }
71  double BaselineRow::StraightYAtX(double x) const {
72    double denominator = baseline_pt2_.x() - baseline_pt1_.x();
73    if (denominator == 0.0) {
74      return (baseline_pt1_.y() + baseline_pt2_.y()) / 2.0;
75    }
76    return baseline_pt1_.y() + (x - baseline_pt1_.x()) *
77                                   (baseline_pt2_.y() - baseline_pt1_.y()) /
78                                   denominator;
79  }
80  bool BaselineRow::FitBaseline(bool use_box_bottoms) {
81    fitter_.Clear();
82    LLSQ llsq;
83    BLOBNBOX_IT blob_it(blobs_);
84    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
85      BLOBNBOX *blob = blob_it.data();
86      if (!use_box_bottoms) {
87        blob->EstimateBaselinePosition();
88      }
89      const TBOX &box = blob->bounding_box();
90      int x_middle = (box.left() + box.right()) / 2;
91  #ifdef kDebugYCoord
92      if (box.bottom() < kDebugYCoord && box.top() > kDebugYCoord) {
93        tprintf("Box bottom = %d, baseline pos=%d for box at:", box.bottom(),
94                blob->baseline_position());
95        box.print();
96      }
97  #endif
98      fitter_.Add(ICOORD(x_middle, blob->baseline_position()), box.width() / 2);
99      llsq.add(x_middle, blob->baseline_position());
100    }
101    ICOORD pt1, pt2;
102    baseline_error_ = fitter_.Fit(&pt1, &pt2);
103    baseline_pt1_ = pt1;
104    baseline_pt2_ = pt2;
105    if (baseline_error_ > max_baseline_error_ &&
106        fitter_.SufficientPointsForIndependentFit()) {
107      double error = fitter_.Fit(kNumSkipPoints, kNumSkipPoints, &pt1, &pt2);
108      if (error < baseline_error_ / 2.0) {
109        baseline_error_ = error;
110        baseline_pt1_ = pt1;
111        baseline_pt2_ = pt2;
112      }
113    }
114    int debug = 0;
115  #ifdef kDebugYCoord
116    Print();
117    debug = bounding_box_.bottom() < kDebugYCoord &&
118                    bounding_box_.top() > kDebugYCoord
119                ? 3
120                : 2;
121  #endif
122    FCOORD direction(pt2 - pt1);
123    double target_offset = direction * pt1;
124    good_baseline_ = false;
125    FitConstrainedIfBetter(debug, direction, 0.0, target_offset);
126    double angle = BaselineAngle();
127    if (fabs(angle) > M_PI * 0.25) {
128      baseline_pt1_ = llsq.mean_point();
129      baseline_pt2_ = baseline_pt1_ + FCOORD(1.0f, llsq.m());
130      double m = llsq.m();
131      double c = llsq.c(m);
132      baseline_error_ = llsq.rms(m, c);
133      good_baseline_ = false;
134    }
135    return good_baseline_;
136  }
137  void BaselineRow::AdjustBaselineToParallel(int debug, const FCOORD &direction) {
138    SetupBlobDisplacements(direction);
139    if (displacement_modes_.empty()) {
140      return;
141    }
142  #ifdef kDebugYCoord
143    if (bounding_box_.bottom() < kDebugYCoord &&
144        bounding_box_.top() > kDebugYCoord && debug < 3)
145      debug = 3;
146  #endif
147    FitConstrainedIfBetter(debug, direction, 0.0, displacement_modes_[0]);
148  }
149  double BaselineRow::AdjustBaselineToGrid(int debug, const FCOORD &direction,
150                                           double line_spacing,
151                                           double line_offset) {
152    if (blobs_->empty()) {
153      if (debug > 1) {
154        tprintf("Row empty at:");
155        bounding_box_.print();
156      }
157      return line_offset;
158    }
159    double best_error = 0.0;
160    int best_index = -1;
161    for (unsigned i = 0; i < displacement_modes_.size(); ++i) {
162      double blob_y = displacement_modes_[i];
163      double error =
164          BaselineBlock::SpacingModelError(blob_y, line_spacing, line_offset);
165      if (debug > 1) {
166        tprintf("Mode at %g has error %g from model \n", blob_y, error);
167      }
168      if (best_index < 0 || error < best_error) {
169        best_error = error;
170        best_index = i;
171      }
172    }
173    double model_margin = max_baseline_error_ - best_error;
174    if (best_index >= 0 && model_margin > 0.0) {
175      double perp_disp = PerpDisp(direction);
176      double shift = displacement_modes_[best_index] - perp_disp;
177      if (fabs(shift) > max_baseline_error_) {
178        if (debug > 1) {
179          tprintf("Attempting linespacing model fit with mode %g to row at:",
180                  displacement_modes_[best_index]);
181          bounding_box_.print();
182        }
183        FitConstrainedIfBetter(debug, direction, model_margin,
184                               displacement_modes_[best_index]);
185      } else if (debug > 1) {
186        tprintf("Linespacing model only moves current line by %g for row at:",
187                shift);
188        bounding_box_.print();
189      }
190    } else if (debug > 1) {
191      tprintf("Linespacing model not close enough to any mode for row at:");
192      bounding_box_.print();
193    }
194    return fmod(PerpDisp(direction), line_spacing);
195  }
196  void BaselineRow::SetupBlobDisplacements(const FCOORD &direction) {
197    std::vector<double> perp_blob_dists;
198    displacement_modes_.clear();
199    double min_dist = FLT_MAX;
200    double max_dist = -FLT_MAX;
201    BLOBNBOX_IT blob_it(blobs_);
202  #ifdef kDebugYCoord
203    bool debug = false;
204  #endif
205    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
206      BLOBNBOX *blob = blob_it.data();
207      const TBOX &box = blob->bounding_box();
208  #ifdef kDebugYCoord
209      if (box.bottom() < kDebugYCoord && box.top() > kDebugYCoord)
210        debug = true;
211  #endif
212      FCOORD blob_pos((box.left() + box.right()) / 2.0f,
213                      blob->baseline_position());
214      double offset = direction * blob_pos;
215      perp_blob_dists.push_back(offset);
216  #ifdef kDebugYCoord
217      if (debug) {
218        tprintf("Displacement %g for blob at:", offset);
219        box.print();
220      }
221  #endif
222      UpdateRange(offset, &min_dist, &max_dist);
223    }
224    STATS dist_stats(IntCastRounded(min_dist / disp_quant_factor_),
225                     IntCastRounded(max_dist / disp_quant_factor_));
226    for (double perp_blob_dist : perp_blob_dists) {
227      dist_stats.add(IntCastRounded(perp_blob_dist / disp_quant_factor_), 1);
228    }
229    std::vector<KDPairInc<float, int>> scaled_modes;
230    dist_stats.top_n_modes(kMaxDisplacementsModes, scaled_modes);
231  #ifdef kDebugYCoord
232    if (debug) {
233      for (int i = 0; i < scaled_modes.size(); ++i) {
234        tprintf("Top mode = %g * %d\n", scaled_modes[i].key * disp_quant_factor_,
235                scaled_modes[i].data());
236      }
237    }
238  #endif
239    for (auto &scaled_mode : scaled_modes) {
240      displacement_modes_.push_back(disp_quant_factor_ * scaled_mode.key());
241    }
242  }
243  void BaselineRow::FitConstrainedIfBetter(int debug, const FCOORD &direction,
244                                           double cheat_allowance,
245                                           double target_offset) {
246    double halfrange = fit_halfrange_ * direction.length();
247    double min_dist = target_offset - halfrange;
248    double max_dist = target_offset + halfrange;
249    ICOORD line_pt;
250    double new_error = fitter_.ConstrainedFit(direction, min_dist, max_dist,
251                                              debug > 2, &line_pt);
252    new_error -= cheat_allowance;
253    double old_angle = BaselineAngle();
254    double new_angle = direction.angle();
255    if (debug > 1) {
256      tprintf("Constrained error = %g, original = %g", new_error,
257              baseline_error_);
258      tprintf(" angles = %g, %g, delta=%g vs threshold %g\n", old_angle,
259              new_angle, new_angle - old_angle, kMaxSkewDeviation);
260    }
261    bool new_good_baseline =
262        new_error <= max_baseline_error_ &&
263        (cheat_allowance > 0.0 || fitter_.SufficientPointsForIndependentFit());
264    if (new_error <= baseline_error_ || (!good_baseline_ && new_good_baseline) ||
265        fabs(new_angle - old_angle) > kMaxSkewDeviation) {
266      baseline_error_ = new_error;
267      baseline_pt1_ = line_pt;
268      baseline_pt2_ = baseline_pt1_ + direction;
269      good_baseline_ = new_good_baseline;
270      if (debug > 1) {
271        tprintf("Replacing with constrained baseline, good = %d\n",
272                good_baseline_);
273      }
274    } else if (debug > 1) {
275      tprintf("Keeping old baseline\n");
276    }
277  }
278  float BaselineRow::PerpDistanceFromBaseline(const FCOORD &pt) const {
279    FCOORD baseline_vector(baseline_pt2_ - baseline_pt1_);
280    FCOORD offset_vector(pt - baseline_pt1_);
281    float distance = baseline_vector * offset_vector;
282    float sqlength = baseline_vector.sqlength();
283    if (sqlength == 0.0f) {
284      tprintf("unexpected baseline vector (0,0)\n");
285      return 0.0f;
286    }
287    return std::sqrt(distance * distance / sqlength);
288  }
289  void BaselineRow::ComputeBoundingBox() {
290    BLOBNBOX_IT it(blobs_);
291    TBOX box;
292    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
293      box += it.data()->bounding_box();
294    }
295    bounding_box_ = box;
296  }
297  BaselineBlock::BaselineBlock(int debug_level, bool non_text, TO_BLOCK *block)
298      : block_(block),
299        debug_level_(debug_level),
300        non_text_block_(non_text),
301        good_skew_angle_(false),
302        skew_angle_(0.0),
303        line_spacing_(block->line_spacing),
304        line_offset_(0.0),
305        model_error_(0.0) {
306    TO_ROW_IT row_it(block_->get_rows());
307    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
308      row_it.data()->blob_list()->sort(blob_x_order);
309      rows_.push_back(new BaselineRow(block->line_spacing, row_it.data()));
310    }
311  }
312  double BaselineBlock::SpacingModelError(double perp_disp, double line_spacing,
313                                          double line_offset) {
314    int multiple = IntCastRounded((perp_disp - line_offset) / line_spacing);
315    double model_y = line_spacing * multiple + line_offset;
316    return fabs(perp_disp - model_y);
317  }
318  bool BaselineBlock::FitBaselinesAndFindSkew(bool use_box_bottoms) {
319    if (non_text_block_) {
320      return false;
321    }
322    std::vector<double> angles;
323    for (auto row : rows_) {
324      if (row->FitBaseline(use_box_bottoms)) {
325        double angle = row->BaselineAngle();
326        angles.push_back(angle);
327      }
328      if (debug_level_ > 1) {
329        row->Print();
330      }
331    }
332    if (!angles.empty()) {
333      skew_angle_ = MedianOfCircularValues(M_PI, angles);
334      good_skew_angle_ = true;
335    } else {
336      skew_angle_ = 0.0f;
337      good_skew_angle_ = false;
338    }
339    if (debug_level_ > 0) {
340      tprintf("Initial block skew angle = %g, good = %d\n", skew_angle_,
341              good_skew_angle_);
342    }
343    return good_skew_angle_;
344  }
345  void BaselineBlock::ParallelizeBaselines(double default_block_skew) {
346    if (non_text_block_) {
347      return;
348    }
349    if (!good_skew_angle_) {
350      skew_angle_ = default_block_skew;
351    }
352    if (debug_level_ > 0) {
353      tprintf("Adjusting block to skew angle %g\n", skew_angle_);
354    }
355    FCOORD direction(cos(skew_angle_), sin(skew_angle_));
356    for (auto row : rows_) {
357      row->AdjustBaselineToParallel(debug_level_, direction);
358      if (debug_level_ > 1) {
359        row->Print();
360      }
361    }
362    if (rows_.size() < 3 || !ComputeLineSpacing()) {
363      return;
364    }
365    unsigned best_row = 0;
366    double best_error = SpacingModelError(rows_[0]->PerpDisp(direction),
367                                          line_spacing_, line_offset_);
368    for (unsigned r = 1; r < rows_.size(); ++r) {
369      double error = SpacingModelError(rows_[r]->PerpDisp(direction),
370                                       line_spacing_, line_offset_);
371      if (error < best_error) {
372        best_error = error;
373        best_row = r;
374      }
375    }
376    double offset = line_offset_;
377    for (auto r = best_row + 1; r < rows_.size(); ++r) {
378      offset = rows_[r]->AdjustBaselineToGrid(debug_level_, direction,
379                                              line_spacing_, offset);
380    }
381    offset = line_offset_;
382    for (int r = best_row - 1; r >= 0; --r) {
383      offset = rows_[r]->AdjustBaselineToGrid(debug_level_, direction,
384                                              line_spacing_, offset);
385    }
386  }
387  void BaselineBlock::SetupBlockParameters() const {
388    if (line_spacing_ > 0.0) {
389      float min_spacing =
390          std::min(block_->line_spacing, static_cast<float>(line_spacing_));
391      if (min_spacing < block_->line_size) {
392        block_->line_size = min_spacing;
393      }
394      block_->line_spacing = line_spacing_;
395      block_->baseline_offset = line_offset_;
396      block_->max_blob_size = line_spacing_ * kMaxBlobSizeMultiple;
397    }
398    TO_ROW_IT row_it(block_->get_rows());
399    for (unsigned r = 0; r < rows_.size(); ++r, row_it.forward()) {
400      BaselineRow *row = rows_[r];
401      TO_ROW *to_row = row_it.data();
402      row->SetupOldLineParameters(to_row);
403    }
404  }
405  void BaselineBlock::PrepareForSplineFitting(ICOORD page_tr, bool remove_noise) {
406    if (non_text_block_) {
407      return;
408    }
409    if (remove_noise) {
410      vigorous_noise_removal(block_);
411    }
412    FCOORD rotation(1.0f, 0.0f);
413    double gradient = tan(skew_angle_);
414    separate_underlines(block_, gradient, rotation, true);
415    pre_associate_blobs(page_tr, block_, rotation, true);
416  }
417  void BaselineBlock::FitBaselineSplines(bool enable_splines,
418                                         bool show_final_rows, Textord *textord) {
419    double gradient = tan(skew_angle_);
420    FCOORD rotation(1.0f, 0.0f);
421    if (enable_splines) {
422      textord->make_spline_rows(block_, gradient, show_final_rows);
423    } else {
424      TBOX block_box = block_->block->pdblk.bounding_box();
425      TO_ROW_IT row_it = block_->get_rows();
426      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
427        TO_ROW *row = row_it.data();
428        int32_t xstarts[2] = {block_box.left(), block_box.right()};
429        double coeffs[3] = {0.0, row->line_m(), row->line_c()};
430        row->baseline = QSPLINE(1, xstarts, coeffs);
431        textord->compute_row_xheight(row, block_->block->classify_rotation(),
432                                     row->line_m(), block_->line_size);
433      }
434    }
435    textord->compute_block_xheight(block_, gradient);
436    block_->block->set_xheight(block_->xheight);
437    if (textord_restore_underlines) { 
438      restore_underlined_blobs(block_);
439    }
440  }
441  #ifndef GRAPHICS_DISABLED
442  void BaselineBlock::DrawFinalRows(const ICOORD &page_tr) {
443    if (non_text_block_) {
444      return;
445    }
446    double gradient = tan(skew_angle_);
447    FCOORD rotation(1.0f, 0.0f);
448    int left_edge = block_->block->pdblk.bounding_box().left();
449    ScrollView *win = create_to_win(page_tr);
450    ScrollView::Color colour = ScrollView::RED;
451    TO_ROW_IT row_it = block_->get_rows();
452    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
453      plot_parallel_row(row_it.data(), gradient, left_edge, colour, rotation);
454      colour = static_cast<ScrollView::Color>(colour + 1);
455      if (colour > ScrollView::MAGENTA) {
456        colour = ScrollView::RED;
457      }
458    }
459    plot_blob_list(win, &block_->blobs, ScrollView::MAGENTA, ScrollView::WHITE);
460    plot_blob_list(win, &block_->underlines, ScrollView::YELLOW,
461                   ScrollView::CORAL);
462    if (block_->blobs.length() > 0) {
463      tprintf("%d blobs discarded as noise\n", block_->blobs.length());
464    }
465    draw_meanlines(block_, gradient, left_edge, ScrollView::WHITE, rotation);
466  }
467  #endif 
468  void BaselineBlock::DrawPixSpline(Image pix_in) {
469    if (non_text_block_) {
470      return;
471    }
472    TO_ROW_IT row_it = block_->get_rows();
473    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
474      row_it.data()->baseline.plot(pix_in);
475    }
476  }
477  bool BaselineBlock::ComputeLineSpacing() {
478    FCOORD direction(cos(skew_angle_), sin(skew_angle_));
479    std::vector<double> row_positions;
480    ComputeBaselinePositions(direction, &row_positions);
481    if (row_positions.size() < 2) {
482      return false;
483    }
484    EstimateLineSpacing();
485    RefineLineSpacing(row_positions);
486    double max_baseline_error = kMaxBaselineError * line_spacing_;
<span onclick='openModal()' class='match'>487    int non_trivial_gaps = 0;
488    int fitting_gaps = 0;
489    for (unsigned i = 1; i < row_positions.size(); ++i) {
</span>490      double row_gap = fabs(row_positions[i - 1] - row_positions[i]);
491      if (row_gap > max_baseline_error) {
492        ++non_trivial_gaps;
493        if (fabs(row_gap - line_spacing_) <= max_baseline_error) {
494          ++fitting_gaps;
495        }
496      }
497    }
498    if (debug_level_ > 0) {
499      tprintf("Spacing %g, in %zu rows, %d gaps fitted out of %d non-trivial\n",
500              line_spacing_, row_positions.size(), fitting_gaps,
501              non_trivial_gaps);
502    }
503    return fitting_gaps > non_trivial_gaps * kMinFittingLinespacings;
504  }
505  void BaselineBlock::ComputeBaselinePositions(const FCOORD &direction,
506                                               std::vector<double> *positions) {
507    positions->clear();
508    for (auto row : rows_) {
509      const TBOX &row_box = row->bounding_box();
510      float x_middle = (row_box.left() + row_box.right()) / 2.0f;
511      FCOORD row_pos(x_middle, static_cast<float>(row->StraightYAtX(x_middle)));
512      float offset = direction * row_pos;
513      positions->push_back(offset);
514    }
515  }
516  void BaselineBlock::EstimateLineSpacing() {
517    std::vector<float> spacings;
518    for (unsigned r = 0; r < rows_.size(); ++r) {
519      BaselineRow *row = rows_[r];
520      if (fabs(row->BaselineAngle()) > M_PI * 0.25) {
521        continue;
522      }
523      const TBOX &row_box = row->bounding_box();
524      unsigned r2;
525      for (r2 = r + 1; r2 < rows_.size() &&
526                       !row_box.major_x_overlap(rows_[r2]->bounding_box());
527           ++r2) {
528        ;
529      }
530      if (r2 < rows_.size()) {
531        BaselineRow *row2 = rows_[r2];
532        if (fabs(row2->BaselineAngle()) > M_PI * 0.25) {
533          continue;
534        }
535        float spacing = row->SpaceBetween(*row2);
536        spacings.push_back(spacing);
537      }
538    }
539    if (!spacings.empty()) {
540      std::nth_element(spacings.begin(), spacings.begin() + spacings.size() / 2,
541                       spacings.end());
542      line_spacing_ = spacings[spacings.size() / 2];
543      if (debug_level_ > 1) {
544        tprintf("Estimate of linespacing = %g\n", line_spacing_);
545      }
546    }
547  }
548  void BaselineBlock::RefineLineSpacing(const std::vector<double> &positions) {
549    double spacings[3], offsets[3], errors[3];
550    int index_range;
551    errors[0] = FitLineSpacingModel(positions, line_spacing_, &spacings[0],
552                                    &offsets[0], &index_range);
553    if (index_range > 1) {
554      double spacing_plus = line_spacing_ / (1.0 + 1.0 / index_range);
555      errors[1] = FitLineSpacingModel(positions, spacing_plus, &spacings[1],
556                                      &offsets[1], nullptr);
557      double spacing_minus = line_spacing_ / (1.0 - 1.0 / index_range);
558      errors[2] = FitLineSpacingModel(positions, spacing_minus, &spacings[2],
559                                      &offsets[2], nullptr);
560      for (int i = 1; i <= 2; ++i) {
561        if (errors[i] < errors[0]) {
562          spacings[0] = spacings[i];
563          offsets[0] = offsets[i];
564          errors[0] = errors[i];
565        }
566      }
567    }
568    if (spacings[0] > 0.0) {
569      line_spacing_ = spacings[0];
570      line_offset_ = offsets[0];
571      model_error_ = errors[0];
572      if (debug_level_ > 0) {
573        tprintf("Final linespacing model = %g + offset %g, error %g\n",
574                line_spacing_, line_offset_, model_error_);
575      }
576    }
577  }
578  double BaselineBlock::FitLineSpacingModel(const std::vector<double> &positions,
579                                            double m_in, double *m_out,
580                                            double *c_out, int *index_delta) {
581    if (m_in == 0.0f || positions.size() < 2) {
582      *m_out = m_in;
583      *c_out = 0.0;
584      if (index_delta != nullptr) {
585        *index_delta = 0;
586      }
587      return 0.0;
588    }
589    std::vector<double> offsets;
590    offsets.reserve(positions.size());
591    for (double position : positions) {
592      offsets.push_back(fmod(position, m_in));
593    }
594    double median_offset = MedianOfCircularValues(m_in, offsets);
595    LLSQ llsq;
596    int min_index = INT32_MAX;
597    int max_index = -INT32_MAX;
598    for (double y_pos : positions) {
599      int row_index = IntCastRounded((y_pos - median_offset) / m_in);
600      UpdateRange(row_index, &min_index, &max_index);
601      llsq.add(row_index, y_pos);
602    }
603    *m_out = llsq.m();
604    offsets.clear();
605    if (*m_out != 0.0) {
606      for (double position : positions) {
607        offsets.push_back(fmod(position, *m_out));
608      }
609      if (debug_level_ > 2) {
610        for (unsigned i = 0; i < offsets.size(); ++i) {
611          tprintf("%u: %g\n", i, offsets[i]);
612        }
613      }
614      *c_out = MedianOfCircularValues(*m_out, offsets);
615    } else {
616      *c_out = 0.0;
617    }
618    if (debug_level_ > 1) {
619      tprintf("Median offset = %g, compared to mean of %g.\n", *c_out,
620              llsq.c(*m_out));
621    }
622    if (index_delta != nullptr) {
623      *index_delta = max_index - min_index;
624    }
625    double rms_error = llsq.rms(*m_out, llsq.c(*m_out));
626    if (debug_level_ > 1) {
627      tprintf("Linespacing of y=%g x + %g improved to %g x + %g, rms=%g\n", m_in,
628              median_offset, *m_out, *c_out, rms_error);
629    }
630    return rms_error;
631  }
632  BaselineDetect::BaselineDetect(int debug_level, const FCOORD &page_skew,
633                                 TO_BLOCK_LIST *blocks)
634      : page_skew_(page_skew), debug_level_(debug_level) {
635    TO_BLOCK_IT it(blocks);
636    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
637      TO_BLOCK *to_block = it.data();
638      BLOCK *block = to_block->block;
639      POLY_BLOCK *pb = block->pdblk.poly_block();
640      bool non_text = pb != nullptr && !pb->IsText();
641      blocks_.push_back(new BaselineBlock(debug_level_, non_text, to_block));
642    }
643  }
644  void BaselineDetect::ComputeStraightBaselines(bool use_box_bottoms) {
645    std::vector<double> block_skew_angles;
646    for (auto bl_block : blocks_) {
647      if (debug_level_ > 0) {
648        tprintf("Fitting initial baselines...\n");
649      }
650      if (bl_block->FitBaselinesAndFindSkew(use_box_bottoms)) {
651        block_skew_angles.push_back(bl_block->skew_angle());
652      }
653    }
654    double default_block_skew = page_skew_.angle();
655    if (!block_skew_angles.empty()) {
656      default_block_skew = MedianOfCircularValues(M_PI, block_skew_angles);
657    }
658    if (debug_level_ > 0) {
659      tprintf("Page skew angle = %g\n", default_block_skew);
660    }
661    for (auto bl_block : blocks_) {
662      bl_block->ParallelizeBaselines(default_block_skew);
663      bl_block->SetupBlockParameters(); 
664    }
665  }
666  void BaselineDetect::ComputeBaselineSplinesAndXheights(const ICOORD &page_tr,
667                                                         bool enable_splines,
668                                                         bool remove_noise,
669                                                         bool show_final_rows,
670                                                         Textord *textord) {
671    for (auto bl_block : blocks_) {
672      if (enable_splines) {
673        bl_block->PrepareForSplineFitting(page_tr, remove_noise);
674      }
675      bl_block->FitBaselineSplines(enable_splines, show_final_rows, textord);
676  #ifndef GRAPHICS_DISABLED
677      if (show_final_rows) {
678        bl_block->DrawFinalRows(page_tr);
679      }
680  #endif
681    }
682  }
683  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baselinedetect.cpp</div>
                </div>
                <div class="column column_space"><pre><code>148    double Max =0;
149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>487    int non_trivial_gaps = 0;
488    int fitting_gaps = 0;
489    for (unsigned i = 1; i < row_positions.size(); ++i) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    