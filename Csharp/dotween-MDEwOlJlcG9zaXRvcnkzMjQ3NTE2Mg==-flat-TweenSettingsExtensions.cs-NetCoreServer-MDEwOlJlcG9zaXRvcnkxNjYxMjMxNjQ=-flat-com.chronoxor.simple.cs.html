
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.578342904019689%, Tokens: 11</h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-TweenSettingsExtensions.cs</h3>
            <pre><code>1  #if COMPATIBLE
2  using DOVector2 = DG.Tweening.Core.Surrogates.Vector2Wrapper;
3  using DOVector3 = DG.Tweening.Core.Surrogates.Vector3Wrapper;
4  using DOVector4 = DG.Tweening.Core.Surrogates.Vector4Wrapper;
5  using DOQuaternion = DG.Tweening.Core.Surrogates.QuaternionWrapper;
6  using DOColor = DG.Tweening.Core.Surrogates.ColorWrapper;
7  #else
8  using DOVector2 = UnityEngine.Vector2;
9  using DOVector3 = UnityEngine.Vector3;
10  using DOVector4 = UnityEngine.Vector4;
11  using DOQuaternion = UnityEngine.Quaternion;
12  using DOColor = UnityEngine.Color;
13  #endif
14  using DG.Tweening.Core;
15  using DG.Tweening.Core.Easing;
16  using DG.Tweening.Plugins;
17  using DG.Tweening.Plugins.Core.PathCore;
18  using DG.Tweening.Plugins.Options;
19  using UnityEngine;
20  #pragma warning disable 1573
21  namespace DG.Tweening
22  {
23      public static class TweenSettingsExtensions
24      {
25          #region Tweeners + Sequences
26          public static T SetAutoKill<T>(this T t) where T : Tween
27          {
28              if (t == null || !t.active || t.creationLocked) return t;
29              t.autoKill = true;
30              return t;
31          }
32          public static T SetAutoKill<T>(this T t, bool autoKillOnCompletion) where T : Tween
33          {
34              if (t == null || !t.active || t.creationLocked) return t;
35              t.autoKill = autoKillOnCompletion;
36              return t;
37          }
38          public static T SetId<T>(this T t, object objectId) where T : Tween
39          {
40              if (t == null || !t.active) return t;
41              t.id = objectId;
42              return t;
43          }
44          public static T SetId<T>(this T t, string stringId) where T : Tween
45          {
46              if (t == null || !t.active) return t;
47              t.stringId = stringId;
48              return t;
49          }
50          public static T SetId<T>(this T t, int intId) where T : Tween
51          {
<span onclick='openModal()' class='match'>52              if (t == null || !t.active) return t;
53              t.intId = intId;
54              return t;
55          }
56          public static T SetLink<T>(this T t, GameObject gameObject) where T : Tween
57          {
58              if (t == null || !t.active || t.isSequenced || gameObject == null) return t;
</span>59              TweenManager.AddTweenLink(t, new TweenLink(gameObject, LinkBehaviour.KillOnDestroy));
60              return t;
61          }
62          public static T SetLink<T>(this T t, GameObject gameObject, LinkBehaviour behaviour) where T : Tween
63          {
64              if (t == null || !t.active || t.isSequenced || gameObject == null) return t;
65              TweenManager.AddTweenLink(t, new TweenLink(gameObject, behaviour));
66              return t;
67          }
68          public static T SetTarget<T>(this T t, object target) where T : Tween
69          {
70              if (t == null || !t.active) return t;
71              if (DOTween.debugStoreTargetId) {
72                  Component comp = target as Component;
73                  t.debugTargetId = comp != null ? comp.name : target.ToString();
74              }
75              t.target = target;
76              return t;
77          }
78          public static T SetLoops<T>(this T t, int loops) where T : Tween
79          {
80              if (t == null || !t.active || t.creationLocked) return t;
81              if (loops < -1) loops = -1;
82              else if (loops == 0) loops = 1;
83              t.loops = loops;
84              if (t.tweenType == TweenType.Tweener) {
85                  if (loops > -1) t.fullDuration = t.duration * loops;
86                  else t.fullDuration = Mathf.Infinity;
87              }
88              return t;
89          }
90          public static T SetLoops<T>(this T t, int loops, LoopType loopType) where T : Tween
91          {
92              if (t == null || !t.active || t.creationLocked) return t;
93              if (loops < -1) loops = -1;
94              else if (loops == 0) loops = 1;
95              t.loops = loops;
96              t.loopType = loopType;
97              if (t.tweenType == TweenType.Tweener) {
98                  if (loops > -1) t.fullDuration = t.duration * loops;
99                  else t.fullDuration = Mathf.Infinity;
100              }
101              return t;
102          }
103          public static T SetEase<T>(this T t, Ease ease) where T : Tween
104          {
105              if (t == null || !t.active) return t;
106              t.easeType = ease;
107              if (EaseManager.IsFlashEase(ease)) t.easeOvershootOrAmplitude = (int)t.easeOvershootOrAmplitude;
108              t.customEase = null;
109              return t;
110          }
111          public static T SetEase<T>(this T t, Ease ease, float overshoot) where T : Tween
112          {
113              if (t == null || !t.active) return t;
114              t.easeType = ease;
115              if (EaseManager.IsFlashEase(ease)) overshoot = (int)overshoot;
116              t.easeOvershootOrAmplitude = overshoot;
117              t.customEase = null;
118              return t;
119          }
120          public static T SetEase<T>(this T t, Ease ease, float amplitude, float period) where T : Tween
121          {
122              if (t == null || !t.active) return t;
123              t.easeType = ease;
124              if (EaseManager.IsFlashEase(ease)) amplitude = (int)amplitude;
125              t.easeOvershootOrAmplitude = amplitude;
126              t.easePeriod = period;
127              t.customEase = null;
128              return t;
129          }
130          public static T SetEase<T>(this T t, AnimationCurve animCurve) where T : Tween
131          {
132              if (t == null || !t.active) return t;
133              t.easeType = Ease.INTERNAL_Custom;
134              t.customEase = new EaseCurve(animCurve).Evaluate;
135              return t;
136          }
137          public static T SetEase<T>(this T t, EaseFunction customEase) where T : Tween
138          {
139              if (t == null || !t.active) return t;
140              t.easeType = Ease.INTERNAL_Custom;
141              t.customEase = customEase;
142              return t;
143          }
144          public static T SetRecyclable<T>(this T t) where T : Tween
145          {
146              if (t == null || !t.active) return t;
147              t.isRecyclable = true;
148              return t;
149          }
150          public static T SetRecyclable<T>(this T t, bool recyclable) where T : Tween
151          {
152              if (t == null || !t.active) return t;
153              t.isRecyclable = recyclable;
154              return t;
155          }
156          public static T SetUpdate<T>(this T t, bool isIndependentUpdate) where T : Tween
157          {
158              if (t == null || !t.active) return t;
159              TweenManager.SetUpdateType(t, DOTween.defaultUpdateType, isIndependentUpdate);
160              return t;
161          }
162          public static T SetUpdate<T>(this T t, UpdateType updateType) where T : Tween
163          {
164              if (t == null || !t.active) return t;
165              TweenManager.SetUpdateType(t, updateType, DOTween.defaultTimeScaleIndependent);
166              return t;
167          }
168          public static T SetUpdate<T>(this T t, UpdateType updateType, bool isIndependentUpdate) where T : Tween
169          {
170              if (t == null || !t.active) return t;
171              TweenManager.SetUpdateType(t, updateType, isIndependentUpdate);
172              return t;
173          }
174          public static T SetInverted<T>(this T t) where T : Tween
175          {
176              if (t == null || !t.active || t.creationLocked) return t;
177              t.isInverted = true;
178              return t;
179          }
180          public static T SetInverted<T>(this T t, bool inverted) where T : Tween
181          {
182              if (t == null || !t.active || t.creationLocked) return t;
183              t.isInverted = inverted;
184              return t;
185          }
186          public static T OnStart<T>(this T t, TweenCallback action) where T : Tween
187          {
188              if (t == null || !t.active) return t;
189              t.onStart = action;
190              return t;
191          }
192          public static T OnPlay<T>(this T t, TweenCallback action) where T : Tween
193          {
194              if (t == null || !t.active) return t;
195              t.onPlay = action;
196              return t;
197          }
198          public static T OnPause<T>(this T t, TweenCallback action) where T : Tween
199          {
200              if (t == null || !t.active) return t;
201              t.onPause = action;
202              return t;
203          }
204          public static T OnRewind<T>(this T t, TweenCallback action) where T : Tween
205          {
206              if (t == null || !t.active) return t;
207              t.onRewind = action;
208              return t;
209          }
210          public static T OnUpdate<T>(this T t, TweenCallback action) where T : Tween
211          {
212              if (t == null || !t.active) return t;
213              t.onUpdate = action;
214              return t;
215          }
216          public static T OnStepComplete<T>(this T t, TweenCallback action) where T : Tween
217          {
218              if (t == null || !t.active) return t;
219              t.onStepComplete = action;
220              return t;
221          }
222          public static T OnComplete<T>(this T t, TweenCallback action) where T : Tween
223          {
224              if (t == null || !t.active) return t;
225              t.onComplete = action;
226              return t;
227          }
228          public static T OnKill<T>(this T t, TweenCallback action) where T : Tween
229          {
230              if (t == null || !t.active) return t;
231              t.onKill = action;
232              return t;
233          }
234          public static T OnWaypointChange<T>(this T t, TweenCallback<int> action) where T : Tween
235          {
236              if (t == null || !t.active) return t;
237              t.onWaypointChange = action;
238              return t;
239          }
240          public static T SetAs<T>(this T t, Tween asTween) where T : Tween
241          {
242              if (t == null || !t.active || t.creationLocked) return t;
243              t.timeScale = asTween.timeScale;
244              t.isBackwards = asTween.isBackwards;
245              TweenManager.SetUpdateType(t, asTween.updateType, asTween.isIndependentUpdate);
246              t.id = asTween.id;
247              t.stringId = asTween.stringId;
248              t.intId = asTween.intId;
249              t.onStart = asTween.onStart;
250              t.onPlay = asTween.onPlay;
251              t.onRewind = asTween.onRewind;
252              t.onUpdate = asTween.onUpdate;
253              t.onStepComplete = asTween.onStepComplete;
254              t.onComplete = asTween.onComplete;
255              t.onKill = asTween.onKill;
256              t.onWaypointChange = asTween.onWaypointChange;
257              t.isRecyclable = asTween.isRecyclable;
258              t.isSpeedBased = asTween.isSpeedBased;
259              t.autoKill = asTween.autoKill;
260              t.loops = asTween.loops;
261              t.loopType = asTween.loopType;
262              if (t.tweenType == TweenType.Tweener) {
263                  if (t.loops > -1) t.fullDuration = t.duration * t.loops;
264                  else t.fullDuration = Mathf.Infinity;
265              }
266              t.delay = asTween.delay;
267              t.delayComplete = t.delay <= 0;
268              t.isRelative = asTween.isRelative;
269              t.easeType = asTween.easeType;
270              t.customEase = asTween.customEase;
271              t.easeOvershootOrAmplitude = asTween.easeOvershootOrAmplitude;
272              t.easePeriod = asTween.easePeriod;
273              return t;
274          }
275          public static T SetAs<T>(this T t, TweenParams tweenParams) where T : Tween
276          {
277              if (t == null || !t.active || t.creationLocked) return t;
278              TweenManager.SetUpdateType(t, tweenParams.updateType, tweenParams.isIndependentUpdate);
279              t.id = tweenParams.id;
280              t.stringId = tweenParams.stringId;
281              t.intId = tweenParams.intId;
282              t.onStart = tweenParams.onStart;
283              t.onPlay = tweenParams.onPlay;
284              t.onRewind = tweenParams.onRewind;
285              t.onUpdate = tweenParams.onUpdate;
286              t.onStepComplete = tweenParams.onStepComplete;
287              t.onComplete = tweenParams.onComplete;
288              t.onKill = tweenParams.onKill;
289              t.onWaypointChange = tweenParams.onWaypointChange;
290              t.isRecyclable = tweenParams.isRecyclable;
291              t.isSpeedBased = tweenParams.isSpeedBased;
292              t.autoKill = tweenParams.autoKill;
293              t.loops = tweenParams.loops;
294              t.loopType = tweenParams.loopType;
295              if (t.tweenType == TweenType.Tweener) {
296                  if (t.loops > -1) t.fullDuration = t.duration * t.loops;
297                  else t.fullDuration = Mathf.Infinity;
298              }
299              t.delay = tweenParams.delay;
300              t.delayComplete = t.delay <= 0;
301              t.isRelative = tweenParams.isRelative;
302              if (tweenParams.easeType == Ease.Unset) {
303                  if (t.tweenType == TweenType.Sequence) t.easeType = Ease.Linear;
304                  else t.easeType = DOTween.defaultEaseType;
305              } else t.easeType = tweenParams.easeType;
306              t.customEase = tweenParams.customEase;
307              t.easeOvershootOrAmplitude = tweenParams.easeOvershootOrAmplitude;
308              t.easePeriod = tweenParams.easePeriod;
309              return t;
310          }
311          #endregion
312          #region Sequences-only
313          public static Sequence Append(this Sequence s, Tween t)
314          {
315              if (!ValidateAddToSequence(s, t)) return s;
316              Sequence.DoInsert(s, t, s.duration);
317              return s;
318          }
319          public static Sequence Prepend(this Sequence s, Tween t)
320          {
321              if (!ValidateAddToSequence(s, t)) return s;
322              Sequence.DoPrepend(s, t);
323              return s;
324          }
325          public static Sequence Join(this Sequence s, Tween t)
326          {
327              if (!ValidateAddToSequence(s, t)) return s;
328              Sequence.DoInsert(s, t, s.lastTweenInsertTime);
329              return s;
330          }
331          public static Sequence Insert(this Sequence s, float atPosition, Tween t)
332          {
333              if (!ValidateAddToSequence(s, t)) return s;
334              Sequence.DoInsert(s, t, atPosition);
335              return s;
336          }
337          public static Sequence AppendInterval(this Sequence s, float interval)
338          {
339              if (!ValidateAddToSequence(s, null, true)) return s;
340              Sequence.DoAppendInterval(s, interval);
341              return s;
342          }
343          public static Sequence PrependInterval(this Sequence s, float interval)
344          {
345              if (!ValidateAddToSequence(s, null, true)) return s;
346              Sequence.DoPrependInterval(s, interval);
347              return s;
348          }
349          public static Sequence AppendCallback(this Sequence s, TweenCallback callback)
350          {
351              if (!ValidateAddToSequence(s, null, true)) return s;
352              if (callback == null) return s;
353              Sequence.DoInsertCallback(s, callback, s.duration);
354              return s;
355          }
356          public static Sequence PrependCallback(this Sequence s, TweenCallback callback)
357          {
358              if (!ValidateAddToSequence(s, null, true)) return s;
359              if (callback == null) return s;
360              Sequence.DoInsertCallback(s, callback, 0);
361              return s;
362          }
363          public static Sequence InsertCallback(this Sequence s, float atPosition, TweenCallback callback)
364          {
365              if (!ValidateAddToSequence(s, null, true)) return s;
366              if (callback == null) return s;
367              Sequence.DoInsertCallback(s, callback, atPosition);
368              return s;
369          }
370          static bool ValidateAddToSequence(Sequence s, Tween t, bool ignoreTween = false)
371          {
372              if (s == null) {
373                  Debugger.Sequence.LogAddToNullSequence();
374                  return false;
375              }
376              if (!s.active) {
377                  Debugger.Sequence.LogAddToInactiveSequence();
378                  return false;
379              }
380              if (s.creationLocked) {
381                  Debugger.Sequence.LogAddToLockedSequence();
382                  return false;
383              }
384              if (!ignoreTween) {
385                  if (t == null) {
386                      Debugger.Sequence.LogAddNullTween();
387                      return false;
388                  }
389                  if (!t.active) {
390                      Debugger.Sequence.LogAddInactiveTween(t);
391                      return false;
392                  }
393                  if (t.isSequenced) {
394                      Debugger.Sequence.LogAddAlreadySequencedTween(t);
395                      return false;
396                  }
397              }
398              return true;
399          }
400          #endregion
401          #region Tweeners-only
402          #region FROM
403          public static T From<T>(this T t) where T : Tweener
404          { return From(t, true, false); }
405          public static T From<T>(this T t, bool isRelative) where T : Tweener
406          { { return From(t, true, isRelative); } }
407          public static T From<T>(this T t, bool setImmediately, bool isRelative) where T : Tweener
408          {
409              if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) return t;
410              t.isFrom = true;
411              if (setImmediately) t.SetFrom(isRelative && !t.isBlendable);
412              else {
413                  t.isRelative = isRelative;
414              }
415              return t;
416          }
417          public static TweenerCore<T1,T2,TPlugOptions> From<T1,T2,TPlugOptions>(
418              this TweenerCore<T1,T2,TPlugOptions> t, T2 fromValue, bool setImmediately = true, bool isRelative = false
419          ) where TPlugOptions : struct, IPlugOptions
420          {
421              if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) return t;
422              t.isFrom = true;
423              t.SetFrom(fromValue, setImmediately, isRelative);
424              return t;
425          }
426          #region FROM Extra Overloads
427          public static TweenerCore<DOColor, DOColor, ColorOptions> From(
428              this TweenerCore<DOColor, DOColor, ColorOptions> t, float fromAlphaValue, bool setImmediately = true, bool isRelative = false
429          ){
430              if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) return t;
431              t.isFrom = true;
432              t.SetFrom(new Color(0,0,0,fromAlphaValue), setImmediately, isRelative);
433              return t;
434          }
435          public static TweenerCore<DOVector3, DOVector3, VectorOptions> From(
436              this TweenerCore<DOVector3, DOVector3, VectorOptions> t, float fromValue, bool setImmediately = true, bool isRelative = false
437          ){
438              if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) return t;
439              t.isFrom = true;
440              t.SetFrom(new Vector3(fromValue, fromValue, fromValue), setImmediately, isRelative);
441              return t;
442          }
443          public static TweenerCore<DOVector2, DOVector2, CircleOptions> From(
444              this TweenerCore<DOVector2, DOVector2, CircleOptions> t, float fromValueDegrees, bool setImmediately = true, bool isRelative = false
445          ){
446              if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) return t;
447              t.isFrom = true;
448              t.SetFrom(new Vector2(fromValueDegrees, 0), setImmediately, isRelative);
449              return t;
450          }
451          #endregion
452          #endregion
453          public static T SetDelay<T>(this T t, float delay) where T : Tween
454          {
455              if (t == null || !t.active || t.creationLocked) return t;
456              if (t.tweenType == TweenType.Sequence) {
457                  (t as Sequence).PrependInterval(delay);
458              } else {
459                  t.delay = delay;
460                  t.delayComplete = delay <= 0;
461              }
462              return t;
463          }
464          public static T SetDelay<T>(this T t, float delay, bool asPrependedIntervalIfSequence) where T : Tween
465          {
466              if (t == null || !t.active || t.creationLocked) return t;
467              bool isSequence = t.tweenType == TweenType.Sequence;
468              if (!isSequence || !asPrependedIntervalIfSequence) {
469                  t.delay = delay;
470                  t.delayComplete = delay <= 0;
471              } else {
472                  (t as Sequence).PrependInterval(delay);
473              }
474              return t;
475          }
476          public static T SetRelative<T>(this T t) where T : Tween
477          {
478              if (t == null || !t.active || t.creationLocked || t.isFrom || t.isBlendable) return t;
479              t.isRelative = true;
480              return t;
481          }
482          public static T SetRelative<T>(this T t, bool isRelative) where T : Tween
483          {
484              if (t == null || !t.active || t.creationLocked || t.isFrom || t.isBlendable) return t;
485              t.isRelative = isRelative;
486              return t;
487          }
488          public static T SetSpeedBased<T>(this T t) where T : Tween
489          {
490              if (t == null || !t.active || t.creationLocked) return t;
491              t.isSpeedBased = true;
492              return t;
493          }
494          public static T SetSpeedBased<T>(this T t, bool isSpeedBased) where T : Tween
495          {
496              if (t == null || !t.active || t.creationLocked) return t;
497              t.isSpeedBased = isSpeedBased;
498              return t;
499          }
500          #endregion
501          #region Tweeners Extra Options
502          public static Tweener SetOptions(this TweenerCore<float, float, FloatOptions> t, bool snapping)
503          {
504              if (t == null || !t.active) return t;
505              t.plugOptions.snapping = snapping;
506              return t;
507          }
508          public static Tweener SetOptions(this TweenerCore<DOVector2, DOVector2, VectorOptions> t, bool snapping)
509          {
510              if (t == null || !t.active) return t;
511              t.plugOptions.snapping = snapping;
512              return t;
513          }
514          public static Tweener SetOptions(this TweenerCore<DOVector2, DOVector2, VectorOptions> t, AxisConstraint axisConstraint, bool snapping = false)
515          {
516              if (t == null || !t.active) return t;
517              t.plugOptions.axisConstraint = axisConstraint;
518              t.plugOptions.snapping = snapping;
519              return t;
520          }
521          public static Tweener SetOptions(this TweenerCore<DOVector3, DOVector3, VectorOptions> t, bool snapping)
522          {
523              if (t == null || !t.active) return t;
524              t.plugOptions.snapping = snapping;
525              return t;
526          }
527          public static Tweener SetOptions(this TweenerCore<DOVector3, DOVector3, VectorOptions> t, AxisConstraint axisConstraint, bool snapping = false)
528          {
529              if (t == null || !t.active) return t;
530              t.plugOptions.axisConstraint = axisConstraint;
531              t.plugOptions.snapping = snapping;
532              return t;
533          }
534          public static Tweener SetOptions(this TweenerCore<DOVector4, DOVector4, VectorOptions> t, bool snapping)
535          {
536              if (t == null || !t.active) return t;
537              t.plugOptions.snapping = snapping;
538              return t;
539          }
540          public static Tweener SetOptions(this TweenerCore<DOVector4, DOVector4, VectorOptions> t, AxisConstraint axisConstraint, bool snapping = false)
541          {
542              if (t == null || !t.active) return t;
543              t.plugOptions.axisConstraint = axisConstraint;
544              t.plugOptions.snapping = snapping;
545              return t;
546          }
547          public static Tweener SetOptions(this TweenerCore<DOQuaternion, DOVector3, QuaternionOptions> t, bool useShortest360Route = true)
548          {
549              if (t == null || !t.active) return t;
550              t.plugOptions.rotateMode = useShortest360Route ? RotateMode.Fast : RotateMode.FastBeyond360;
551              return t;
552          }
553          public static Tweener SetOptions(this TweenerCore<DOColor, DOColor, ColorOptions> t, bool alphaOnly)
554          {
555              if (t == null || !t.active) return t;
556              t.plugOptions.alphaOnly = alphaOnly;
557              return t;
558          }
559          public static Tweener SetOptions(this TweenerCore<Rect, Rect, RectOptions> t, bool snapping)
560          {
561              if (t == null || !t.active) return t;
562              t.plugOptions.snapping = snapping;
563              return t;
564          }
565          public static Tweener SetOptions(this TweenerCore<string, string, StringOptions> t, bool richTextEnabled, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
566          {
567              if (t == null || !t.active) return t;
568              t.plugOptions.richTextEnabled = richTextEnabled;
569              t.plugOptions.scrambleMode = scrambleMode;
570              if (!string.IsNullOrEmpty(scrambleChars)) {
571                  if (scrambleChars.Length <= 1) scrambleChars += scrambleChars;
572                  t.plugOptions.scrambledChars = scrambleChars.ToCharArray();
573                  t.plugOptions.scrambledChars.ScrambleChars();
574              }
575              return t;
576          }
577          public static Tweener SetOptions(this TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t, bool snapping)
578          {
579              if (t == null || !t.active) return t;
580              t.plugOptions.snapping = snapping;
581              return t;
582          }
583          public static Tweener SetOptions(this TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t, AxisConstraint axisConstraint, bool snapping = false)
584          {
585              if (t == null || !t.active) return t;
586              t.plugOptions.axisConstraint = axisConstraint;
587              t.plugOptions.snapping = snapping;
588              return t;
589          }
590          public static Tweener SetOptions(this TweenerCore<DOVector2, DOVector2, CircleOptions> t, float endValueDegrees, bool relativeCenter = true, bool snapping = false)
591          {
592              if (t == null || !t.active) return t;
593              t.plugOptions.endValueDegrees = endValueDegrees;
594              t.plugOptions.relativeCenter = relativeCenter;
595              t.plugOptions.snapping = snapping;
596              return t;
597          }
598          #region Path Options
599          public static TweenerCore<Vector3, Path, PathOptions> SetOptions(
600              this TweenerCore<Vector3, Path, PathOptions> t,
601              AxisConstraint lockPosition, AxisConstraint lockRotation = AxisConstraint.None
602          )
603          {
604              return SetOptions(t, false, lockPosition, lockRotation);
605          }
606          public static TweenerCore<Vector3, Path, PathOptions> SetOptions(
607              this TweenerCore<Vector3, Path, PathOptions> t,
608              bool closePath, AxisConstraint lockPosition = AxisConstraint.None, AxisConstraint lockRotation = AxisConstraint.None
609          )
610          {
611              if (t == null || !t.active) return t;
612              t.plugOptions.isClosedPath = closePath;
613              t.plugOptions.lockPositionAxis = lockPosition;
614              t.plugOptions.lockRotationAxis = lockRotation;
615              return t;
616          }
617          public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
618              this TweenerCore<Vector3, Path, PathOptions> t, Vector3 lookAtPosition, Vector3? forwardDirection = null, Vector3? up = null
619          )
620          { return SetLookAt(t, OrientType.LookAtPosition, lookAtPosition, null, -1, forwardDirection, up); }
621          public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
622              this TweenerCore<Vector3, Path, PathOptions> t, Vector3 lookAtPosition, bool stableZRotation
623          )
624          { return SetLookAt(t, OrientType.LookAtPosition, lookAtPosition, null, -1, null, null, stableZRotation); }
625          public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
626              this TweenerCore<Vector3, Path, PathOptions> t, Transform lookAtTransform, Vector3? forwardDirection = null, Vector3? up = null
627          )
628          { return SetLookAt(t, OrientType.LookAtTransform, Vector3.zero, lookAtTransform, -1, forwardDirection, up); }
629          public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
630              this TweenerCore<Vector3, Path, PathOptions> t, Transform lookAtTransform, bool stableZRotation
631          )
632          { return SetLookAt(t, OrientType.LookAtTransform, Vector3.zero, lookAtTransform, -1, null, null, stableZRotation); }
633          public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
634              this TweenerCore<Vector3, Path, PathOptions> t, float lookAhead, Vector3? forwardDirection = null, Vector3? up = null
635          )
636          { return SetLookAt(t, OrientType.ToPath, Vector3.zero, null, lookAhead, forwardDirection, up); }
637          public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
638              this TweenerCore<Vector3, Path, PathOptions> t, float lookAhead, bool stableZRotation
639          )
640          { return SetLookAt(t, OrientType.ToPath, Vector3.zero, null, lookAhead, null, null, stableZRotation); }
641          static TweenerCore<Vector3, Path, PathOptions> SetLookAt(
642              this TweenerCore<Vector3, Path, PathOptions> t,
643              OrientType orientType, Vector3 lookAtPosition, Transform lookAtTransform, float lookAhead,
644              Vector3? forwardDirection = null, Vector3? up = null, bool stableZRotation = false
645          )
646          {
647              if (t == null || !t.active) return t;
648              t.plugOptions.orientType = orientType;
649              switch (orientType) {
650              case OrientType.LookAtPosition:
651                  t.plugOptions.lookAtPosition = lookAtPosition;
652                  break;
653              case OrientType.LookAtTransform:
654                  t.plugOptions.lookAtTransform = lookAtTransform;
655                  break;
656              case OrientType.ToPath:
657                  if (lookAhead < PathPlugin.MinLookAhead) lookAhead = PathPlugin.MinLookAhead;
658                  t.plugOptions.lookAhead = lookAhead;
659                  break;
660              }
661              t.plugOptions.lookAtPosition = lookAtPosition;
662              t.plugOptions.stableZRotation = stableZRotation;
663              SetPathForwardDirection(t, forwardDirection, up);
664              return t;
665          }
666          static void SetPathForwardDirection(this TweenerCore<Vector3, Path, PathOptions> t, Vector3? forwardDirection = null, Vector3? up = null)
667          {
668              if (t == null || !t.active) return;
669              t.plugOptions.hasCustomForwardDirection = forwardDirection != null && forwardDirection != Vector3.zero || up != null && up != Vector3.zero;
670              if (t.plugOptions.hasCustomForwardDirection) {
671                  if (forwardDirection == Vector3.zero) forwardDirection = Vector3.forward;
672                  t.plugOptions.forward = Quaternion.LookRotation(
673                      forwardDirection == null ? Vector3.forward : (Vector3)forwardDirection,
674                      up == null ? Vector3.up : (Vector3)up
675                  );
676              }
677          }
678          #endregion
679          #endregion
680      }
681  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-com.chronoxor.simple.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Linq;
7  using System.Numerics;
8  using System.Runtime.Serialization;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  namespace com.chronoxor.simple {
13      public struct SimpleRequest : IComparable, IComparable<SimpleRequest>, IEquatable<SimpleRequest>
14      {
15          public Guid id;
16          public string Message;
17          public const long FBETypeConst = 1;
18          public long FBEType => FBETypeConst;
19          public static SimpleRequest Default => new SimpleRequest
20          {
21              id = com.chronoxor.FBE.UuidGenerator.Sequential()
22              , Message = ""
23          };
24          public SimpleRequest(Guid id, string Message)
25          {
26              this.id = id;
27              this.Message = Message;
28          }
29          public SimpleRequest Clone()
30          {
31              var writer = new com.chronoxor.simple.FBE.SimpleRequestModel();
32              writer.Serialize(this);
33              var reader = new com.chronoxor.simple.FBE.SimpleRequestModel();
34              reader.Attach(writer.Buffer);
35              reader.Deserialize(out var result);
36              return result;
37          }
38          public int CompareTo(object other)
39          {
40              int result = 0;
41              result = id.CompareTo(((SimpleRequest)other).id);
42              if (result != 0)
43                  return result;
44              return result;
45          }
46          public int CompareTo(SimpleRequest other)
47          {
48              int result = 0;
49              result = id.CompareTo(other.id);
50              if (result != 0)
51                  return result;
52              return result;
53          }
54          public override bool Equals(object other)
55          {
56              if (!(other is SimpleRequest))
57                  return false;
58              if (!id.Equals(((SimpleRequest)other).id))
59                  return false;
60              return true;
61          }
62          public bool Equals(SimpleRequest other)
63          {
64              if (!id.Equals(other.id))
65                  return false;
66              return true;
67          }
68          public override int GetHashCode()
69          {
70              int hash = 17;
71              hash = hash * 31 + id.GetHashCode();
72              return hash;
73          }
74          public static bool operator==(SimpleRequest lhs, SimpleRequest rhs) => lhs.Equals(rhs);
75          public static bool operator!=(SimpleRequest lhs, SimpleRequest rhs) => !(lhs == rhs);
76          public override string ToString()
77          {
78              var sb = new StringBuilder();
79              sb.Append("SimpleRequest(");
80              sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
81              sb.Append(",Message="); if (Message != null) sb.Append("\"").Append(Message).Append("\""); else sb.Append("null");
82              sb.Append(")");
83              return sb.ToString();
84          }
85          public static com.chronoxor.FBE.FieldModelValueType<SimpleRequest> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new simple.FBE.FieldModelSimpleRequest(buffer, offset); }
86      }
87  } 
88  namespace com.chronoxor.simple.FBE {
89      using global::com.chronoxor.simple;
90      public class FieldModelSimpleRequest : com.chronoxor.FBE.FieldModelValueType<SimpleRequest>
91      {
92          public readonly com.chronoxor.FBE.FieldModelValueType<Guid> id;
93          public readonly com.chronoxor.FBE.FieldModelReferenceType<string> Message;
94          public FieldModelSimpleRequest(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
95          {
96              id = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 4 + 4);
97              Message = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, id.FBEOffset + id.FBESize);
98          }
99          public override long FBESize => 4;
100          public long FBEBody
101          {
102              get
103              {
104                  long fbeResult = 4 + 4
105                      + id.FBESize
106                      + Message.FBESize
107                      ;
108                  return fbeResult;
109              }
110          }
111          public override long FBEExtra
112          {
113              get
114              {
115                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
116                      return 0;
117                  uint fbeStructOffset = ReadUInt32(FBEOffset);
118                  if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
119                      return 0;
120                  _buffer.Shift(fbeStructOffset);
121                  long fbeResult = FBEBody
122                      + id.FBEExtra
123                      + Message.FBEExtra
124                      ;
125                  _buffer.Unshift(fbeStructOffset);
126                  return fbeResult;
127              }
128          }
129          public const long FBETypeConst = 1;
130          public long FBEType => FBETypeConst;
131          public override com.chronoxor.FBE.FieldModelValueType<SimpleRequest> Clone() { return new FieldModelSimpleRequest(_buffer, _offset); }
132          public override bool Verify() { return Verify(true); }
133          public bool Verify(bool fbeVerifyType)
134          {
135              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
136                  return true;
137              uint fbeStructOffset = ReadUInt32(FBEOffset);
138              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
139                  return false;
140              uint fbeStructSize = ReadUInt32(fbeStructOffset);
141              if (fbeStructSize < (4 + 4))
142                  return false;
143              uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
144              if (fbeVerifyType && (fbeStructType != FBEType))
145                  return false;
146              _buffer.Shift(fbeStructOffset);
147              bool fbeResult = VerifyFields(fbeStructSize);
148              _buffer.Unshift(fbeStructOffset);
149              return fbeResult;
150          }
151          public bool VerifyFields(long fbeStructSize)
152          {
153              long fbeCurrentSize = 4 + 4;
154              if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
155                  return true;
156              if (!id.Verify())
157                  return false;
158              fbeCurrentSize += id.FBESize;
159              if ((fbeCurrentSize + Message.FBESize) > fbeStructSize)
160                  return true;
161              if (!Message.Verify())
162                  return false;
163              fbeCurrentSize += Message.FBESize;
164              return true;
165          }
166          public long GetBegin()
167          {
168              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
169                  return 0;
170              uint fbeStructOffset = ReadUInt32(FBEOffset);
171              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
172              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
173                  return 0;
174              uint fbeStructSize = ReadUInt32(fbeStructOffset);
175              Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
176              if (fbeStructSize < (4 + 4))
177                  return 0;
178              _buffer.Shift(fbeStructOffset);
179              return fbeStructOffset;
180          }
181          public void GetEnd(long fbeBegin)
182          {
183              _buffer.Unshift(fbeBegin);
184          }
185          public override void Get(out SimpleRequest fbeValue) { Get(out fbeValue, SimpleRequest.Default); }
186          public override void Get(out SimpleRequest fbeValue, SimpleRequest defaults)
187          {
188              long fbeBegin = GetBegin();
189              if (fbeBegin == 0)
190              {
191                  fbeValue = defaults;
192                  return;
193              }
194              uint fbeStructSize = ReadUInt32(0);
195              GetFields(out fbeValue, fbeStructSize);
196              GetEnd(fbeBegin);
197          }
198          public void GetFields(out SimpleRequest fbeValue, long fbeStructSize)
199          {
200              long fbeCurrentSize = 4 + 4;
201              fbeValue = SimpleRequest.Default;
202              if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
203                  id.Get(out fbeValue.id, com.chronoxor.FBE.UuidGenerator.Sequential());
204              else
205                  fbeValue.id = com.chronoxor.FBE.UuidGenerator.Sequential();
206              fbeCurrentSize += id.FBESize;
207              if ((fbeCurrentSize + Message.FBESize) <= fbeStructSize)
208                  Message.Get(out fbeValue.Message);
209              else
210                  fbeValue.Message = "";
211              fbeCurrentSize += Message.FBESize;
212          }
213          public long SetBegin()
214          {
215              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
216              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
217                  return 0;
218              uint fbeStructSize = (uint)FBEBody;
219              uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
220              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
221              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
222                  return 0;
223              Write(FBEOffset, fbeStructOffset);
224              Write(fbeStructOffset, fbeStructSize);
225              Write(fbeStructOffset + 4, (uint)FBEType);
226              _buffer.Shift(fbeStructOffset);
227              return fbeStructOffset;
228          }
229          public void SetEnd(long fbeBegin)
230          {
231              _buffer.Unshift(fbeBegin);
232          }
233          public override void Set(SimpleRequest fbeValue)
234          {
235              long fbeBegin = SetBegin();
236              if (fbeBegin == 0)
237                  return;
238              SetFields(fbeValue);
239              SetEnd(fbeBegin);
240          }
241          public void SetFields(SimpleRequest fbeValue)
242          {
243              id.Set(fbeValue.id);
244              Message.Set(fbeValue.Message);
245          }
246      }
247  } 
248  namespace com.chronoxor.simple.FBE {
249      using global::com.chronoxor.simple;
250      public class SimpleRequestModel : com.chronoxor.FBE.Model
251      {
252          public readonly FieldModelSimpleRequest model;
253          public SimpleRequestModel() { model = new FieldModelSimpleRequest(Buffer, 4); }
254          public SimpleRequestModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleRequest(Buffer, 4); }
255          public long FBESize => model.FBESize + model.FBEExtra;
256          public const long FBETypeConst = FieldModelSimpleRequest.FBETypeConst;
257          public long FBEType => FBETypeConst;
258          public bool Verify()
259          {
260              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
261                  return false;
262              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
263              if (fbeFullSize < model.FBESize)
264                  return false;
265              return model.Verify();
266          }
267          public long CreateBegin()
268          {
269              long fbeBegin = Buffer.Allocate(4 + model.FBESize);
270              return fbeBegin;
271          }
272          public long CreateEnd(long fbeBegin)
273          {
274              long fbeEnd = Buffer.Size;
275              uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
276              Write(model.FBEOffset - 4, fbeFullSize);
277              return fbeFullSize;
278          }
279          public long Serialize(SimpleRequest value)
280          {
281              long fbeBegin = CreateBegin();
282              model.Set(value);
283              long fbeFullSize = CreateEnd(fbeBegin);
284              return fbeFullSize;
285          }
286          public long Deserialize(out SimpleRequest value)
287          {
288              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
289              {
290                  value = SimpleRequest.Default;
291                  return 0;
292              }
293              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
294              Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
295              if (fbeFullSize < model.FBESize)
296              {
297                  value = SimpleRequest.Default;
298                  return 0;
299              }
300              model.Get(out value);
301              return fbeFullSize;
302          }
303          public void Next(long prev)
304          {
305              model.FBEShift(prev);
306          }
307      }
308  } 
309  namespace com.chronoxor.simple {
310      public struct SimpleResponse : IComparable, IComparable<SimpleResponse>, IEquatable<SimpleResponse>
311      {
312          public Guid id;
313          public uint Length;
314          public uint Hash;
315          public const long FBETypeConst = 2;
316          public long FBEType => FBETypeConst;
317          public static SimpleResponse Default => new SimpleResponse
318          {
319              id = com.chronoxor.FBE.UuidGenerator.Sequential()
320              , Length = (uint)0U
321              , Hash = (uint)0U
322          };
323          public SimpleResponse(Guid id, uint Length, uint Hash)
324          {
325              this.id = id;
326              this.Length = Length;
327              this.Hash = Hash;
328          }
329          public SimpleResponse Clone()
330          {
331              var writer = new com.chronoxor.simple.FBE.SimpleResponseModel();
332              writer.Serialize(this);
333              var reader = new com.chronoxor.simple.FBE.SimpleResponseModel();
334              reader.Attach(writer.Buffer);
335              reader.Deserialize(out var result);
336              return result;
337          }
338          public int CompareTo(object other)
339          {
340              int result = 0;
341              result = id.CompareTo(((SimpleResponse)other).id);
342              if (result != 0)
343                  return result;
344              return result;
345          }
346          public int CompareTo(SimpleResponse other)
347          {
348              int result = 0;
349              result = id.CompareTo(other.id);
350              if (result != 0)
351                  return result;
352              return result;
353          }
354          public override bool Equals(object other)
355          {
356              if (!(other is SimpleResponse))
357                  return false;
358              if (!id.Equals(((SimpleResponse)other).id))
359                  return false;
360              return true;
361          }
362          public bool Equals(SimpleResponse other)
363          {
364              if (!id.Equals(other.id))
365                  return false;
366              return true;
367          }
368          public override int GetHashCode()
369          {
370              int hash = 17;
371              hash = hash * 31 + id.GetHashCode();
372              return hash;
373          }
374          public static bool operator==(SimpleResponse lhs, SimpleResponse rhs) => lhs.Equals(rhs);
375          public static bool operator!=(SimpleResponse lhs, SimpleResponse rhs) => !(lhs == rhs);
376          public override string ToString()
377          {
378              var sb = new StringBuilder();
379              sb.Append("SimpleResponse(");
380              sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
381              sb.Append(",Length="); sb.Append(Length);
382              sb.Append(",Hash="); sb.Append(Hash);
383              sb.Append(")");
384              return sb.ToString();
385          }
386          public static com.chronoxor.FBE.FieldModelValueType<SimpleResponse> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new simple.FBE.FieldModelSimpleResponse(buffer, offset); }
387      }
388  } 
389  namespace com.chronoxor.simple.FBE {
390      using global::com.chronoxor.simple;
391      public class FieldModelSimpleResponse : com.chronoxor.FBE.FieldModelValueType<SimpleResponse>
392      {
393          public readonly com.chronoxor.FBE.FieldModelValueType<Guid> id;
394          public readonly com.chronoxor.FBE.FieldModelValueType<uint> Length;
395          public readonly com.chronoxor.FBE.FieldModelValueType<uint> Hash;
396          public FieldModelSimpleResponse(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
397          {
398              id = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 4 + 4);
399              Length = com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, id.FBEOffset + id.FBESize);
400              Hash = com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, Length.FBEOffset + Length.FBESize);
401          }
402          public override long FBESize => 4;
403          public long FBEBody
404          {
405              get
406              {
407                  long fbeResult = 4 + 4
408                      + id.FBESize
409                      + Length.FBESize
410                      + Hash.FBESize
411                      ;
412                  return fbeResult;
413              }
414          }
415          public override long FBEExtra
416          {
417              get
418              {
419                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
420                      return 0;
421                  uint fbeStructOffset = ReadUInt32(FBEOffset);
422                  if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
423                      return 0;
424                  _buffer.Shift(fbeStructOffset);
425                  long fbeResult = FBEBody
426                      + id.FBEExtra
427                      + Length.FBEExtra
428                      + Hash.FBEExtra
429                      ;
430                  _buffer.Unshift(fbeStructOffset);
431                  return fbeResult;
432              }
433          }
434          public const long FBETypeConst = 2;
435          public long FBEType => FBETypeConst;
436          public override com.chronoxor.FBE.FieldModelValueType<SimpleResponse> Clone() { return new FieldModelSimpleResponse(_buffer, _offset); }
437          public override bool Verify() { return Verify(true); }
438          public bool Verify(bool fbeVerifyType)
439          {
440              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
441                  return true;
442              uint fbeStructOffset = ReadUInt32(FBEOffset);
443              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
444                  return false;
445              uint fbeStructSize = ReadUInt32(fbeStructOffset);
446              if (fbeStructSize < (4 + 4))
447                  return false;
448              uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
449              if (fbeVerifyType && (fbeStructType != FBEType))
450                  return false;
451              _buffer.Shift(fbeStructOffset);
452              bool fbeResult = VerifyFields(fbeStructSize);
453              _buffer.Unshift(fbeStructOffset);
454              return fbeResult;
455          }
456          public bool VerifyFields(long fbeStructSize)
457          {
458              long fbeCurrentSize = 4 + 4;
459              if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
460                  return true;
461              if (!id.Verify())
462                  return false;
463              fbeCurrentSize += id.FBESize;
464              if ((fbeCurrentSize + Length.FBESize) > fbeStructSize)
465                  return true;
466              if (!Length.Verify())
467                  return false;
468              fbeCurrentSize += Length.FBESize;
469              if ((fbeCurrentSize + Hash.FBESize) > fbeStructSize)
470                  return true;
471              if (!Hash.Verify())
472                  return false;
473              fbeCurrentSize += Hash.FBESize;
474              return true;
475          }
476          public long GetBegin()
477          {
478              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
479                  return 0;
480              uint fbeStructOffset = ReadUInt32(FBEOffset);
481              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
482              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
483                  return 0;
484              uint fbeStructSize = ReadUInt32(fbeStructOffset);
485              Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
486              if (fbeStructSize < (4 + 4))
487                  return 0;
488              _buffer.Shift(fbeStructOffset);
489              return fbeStructOffset;
490          }
491          public void GetEnd(long fbeBegin)
492          {
493              _buffer.Unshift(fbeBegin);
494          }
495          public override void Get(out SimpleResponse fbeValue) { Get(out fbeValue, SimpleResponse.Default); }
496          public override void Get(out SimpleResponse fbeValue, SimpleResponse defaults)
497          {
498              long fbeBegin = GetBegin();
499              if (fbeBegin == 0)
500              {
501                  fbeValue = defaults;
502                  return;
503              }
504              uint fbeStructSize = ReadUInt32(0);
505              GetFields(out fbeValue, fbeStructSize);
506              GetEnd(fbeBegin);
507          }
508          public void GetFields(out SimpleResponse fbeValue, long fbeStructSize)
509          {
510              long fbeCurrentSize = 4 + 4;
511              fbeValue = SimpleResponse.Default;
512              if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
513                  id.Get(out fbeValue.id, com.chronoxor.FBE.UuidGenerator.Sequential());
514              else
515                  fbeValue.id = com.chronoxor.FBE.UuidGenerator.Sequential();
516              fbeCurrentSize += id.FBESize;
517              if ((fbeCurrentSize + Length.FBESize) <= fbeStructSize)
518                  Length.Get(out fbeValue.Length);
519              else
520                  fbeValue.Length = (uint)0U;
521              fbeCurrentSize += Length.FBESize;
522              if ((fbeCurrentSize + Hash.FBESize) <= fbeStructSize)
523                  Hash.Get(out fbeValue.Hash);
524              else
525                  fbeValue.Hash = (uint)0U;
526              fbeCurrentSize += Hash.FBESize;
527          }
528          public long SetBegin()
529          {
530              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
531              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
532                  return 0;
533              uint fbeStructSize = (uint)FBEBody;
534              uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
535              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
536              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
537                  return 0;
538              Write(FBEOffset, fbeStructOffset);
539              Write(fbeStructOffset, fbeStructSize);
540              Write(fbeStructOffset + 4, (uint)FBEType);
541              _buffer.Shift(fbeStructOffset);
542              return fbeStructOffset;
543          }
544          public void SetEnd(long fbeBegin)
545          {
546              _buffer.Unshift(fbeBegin);
547          }
548          public override void Set(SimpleResponse fbeValue)
549          {
550              long fbeBegin = SetBegin();
551              if (fbeBegin == 0)
552                  return;
553              SetFields(fbeValue);
554              SetEnd(fbeBegin);
555          }
556          public void SetFields(SimpleResponse fbeValue)
557          {
558              id.Set(fbeValue.id);
559              Length.Set(fbeValue.Length);
560              Hash.Set(fbeValue.Hash);
561          }
562      }
563  } 
564  namespace com.chronoxor.simple.FBE {
565      using global::com.chronoxor.simple;
566      public class SimpleResponseModel : com.chronoxor.FBE.Model
567      {
568          public readonly FieldModelSimpleResponse model;
569          public SimpleResponseModel() { model = new FieldModelSimpleResponse(Buffer, 4); }
570          public SimpleResponseModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleResponse(Buffer, 4); }
571          public long FBESize => model.FBESize + model.FBEExtra;
572          public const long FBETypeConst = FieldModelSimpleResponse.FBETypeConst;
573          public long FBEType => FBETypeConst;
574          public bool Verify()
575          {
576              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
577                  return false;
578              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
579              if (fbeFullSize < model.FBESize)
580                  return false;
581              return model.Verify();
582          }
583          public long CreateBegin()
584          {
585              long fbeBegin = Buffer.Allocate(4 + model.FBESize);
586              return fbeBegin;
587          }
588          public long CreateEnd(long fbeBegin)
589          {
590              long fbeEnd = Buffer.Size;
591              uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
592              Write(model.FBEOffset - 4, fbeFullSize);
593              return fbeFullSize;
594          }
595          public long Serialize(SimpleResponse value)
596          {
597              long fbeBegin = CreateBegin();
598              model.Set(value);
599              long fbeFullSize = CreateEnd(fbeBegin);
600              return fbeFullSize;
601          }
602          public long Deserialize(out SimpleResponse value)
603          {
604              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
605              {
606                  value = SimpleResponse.Default;
607                  return 0;
608              }
609              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
610              Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
611              if (fbeFullSize < model.FBESize)
612              {
613                  value = SimpleResponse.Default;
614                  return 0;
615              }
616              model.Get(out value);
617              return fbeFullSize;
618          }
619          public void Next(long prev)
620          {
621              model.FBEShift(prev);
622          }
623      }
624  } 
625  namespace com.chronoxor.simple {
626      public struct SimpleReject : IComparable, IComparable<SimpleReject>, IEquatable<SimpleReject>
627      {
628          public Guid id;
629          public string Error;
630          public const long FBETypeConst = 3;
631          public long FBEType => FBETypeConst;
632          public static SimpleReject Default => new SimpleReject
633          {
634              id = com.chronoxor.FBE.UuidGenerator.Sequential()
635              , Error = ""
636          };
637          public SimpleReject(Guid id, string Error)
638          {
639              this.id = id;
640              this.Error = Error;
641          }
642          public SimpleReject Clone()
643          {
644              var writer = new com.chronoxor.simple.FBE.SimpleRejectModel();
645              writer.Serialize(this);
646              var reader = new com.chronoxor.simple.FBE.SimpleRejectModel();
647              reader.Attach(writer.Buffer);
648              reader.Deserialize(out var result);
649              return result;
650          }
651          public int CompareTo(object other)
652          {
653              int result = 0;
654              result = id.CompareTo(((SimpleReject)other).id);
655              if (result != 0)
656                  return result;
657              return result;
658          }
659          public int CompareTo(SimpleReject other)
660          {
661              int result = 0;
662              result = id.CompareTo(other.id);
663              if (result != 0)
664                  return result;
665              return result;
666          }
667          public override bool Equals(object other)
668          {
669              if (!(other is SimpleReject))
670                  return false;
671              if (!id.Equals(((SimpleReject)other).id))
672                  return false;
673              return true;
674          }
675          public bool Equals(SimpleReject other)
676          {
677              if (!id.Equals(other.id))
678                  return false;
679              return true;
680          }
681          public override int GetHashCode()
682          {
683              int hash = 17;
684              hash = hash * 31 + id.GetHashCode();
685              return hash;
686          }
687          public static bool operator==(SimpleReject lhs, SimpleReject rhs) => lhs.Equals(rhs);
688          public static bool operator!=(SimpleReject lhs, SimpleReject rhs) => !(lhs == rhs);
689          public override string ToString()
690          {
691              var sb = new StringBuilder();
692              sb.Append("SimpleReject(");
693              sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
694              sb.Append(",Error="); if (Error != null) sb.Append("\"").Append(Error).Append("\""); else sb.Append("null");
695              sb.Append(")");
696              return sb.ToString();
697          }
698          public static com.chronoxor.FBE.FieldModelValueType<SimpleReject> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new simple.FBE.FieldModelSimpleReject(buffer, offset); }
699      }
700  } 
701  namespace com.chronoxor.simple.FBE {
702      using global::com.chronoxor.simple;
703      public class FieldModelSimpleReject : com.chronoxor.FBE.FieldModelValueType<SimpleReject>
704      {
705          public readonly com.chronoxor.FBE.FieldModelValueType<Guid> id;
706          public readonly com.chronoxor.FBE.FieldModelReferenceType<string> Error;
707          public FieldModelSimpleReject(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
708          {
709              id = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 4 + 4);
710              Error = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, id.FBEOffset + id.FBESize);
711          }
712          public override long FBESize => 4;
713          public long FBEBody
714          {
715              get
716              {
717                  long fbeResult = 4 + 4
718                      + id.FBESize
719                      + Error.FBESize
720                      ;
721                  return fbeResult;
722              }
723          }
724          public override long FBEExtra
725          {
726              get
727              {
728                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
729                      return 0;
730                  uint fbeStructOffset = ReadUInt32(FBEOffset);
731                  if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
732                      return 0;
733                  _buffer.Shift(fbeStructOffset);
734                  long fbeResult = FBEBody
735                      + id.FBEExtra
736                      + Error.FBEExtra
737                      ;
738                  _buffer.Unshift(fbeStructOffset);
739                  return fbeResult;
740              }
741          }
742          public const long FBETypeConst = 3;
743          public long FBEType => FBETypeConst;
744          public override com.chronoxor.FBE.FieldModelValueType<SimpleReject> Clone() { return new FieldModelSimpleReject(_buffer, _offset); }
745          public override bool Verify() { return Verify(true); }
746          public bool Verify(bool fbeVerifyType)
747          {
748              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
749                  return true;
750              uint fbeStructOffset = ReadUInt32(FBEOffset);
751              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
752                  return false;
753              uint fbeStructSize = ReadUInt32(fbeStructOffset);
754              if (fbeStructSize < (4 + 4))
755                  return false;
756              uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
757              if (fbeVerifyType && (fbeStructType != FBEType))
758                  return false;
759              _buffer.Shift(fbeStructOffset);
760              bool fbeResult = VerifyFields(fbeStructSize);
761              _buffer.Unshift(fbeStructOffset);
762              return fbeResult;
763          }
764          public bool VerifyFields(long fbeStructSize)
765          {
766              long fbeCurrentSize = 4 + 4;
767              if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
768                  return true;
769              if (!id.Verify())
770                  return false;
771              fbeCurrentSize += id.FBESize;
772              if ((fbeCurrentSize + Error.FBESize) > fbeStructSize)
773                  return true;
774              if (!Error.Verify())
<span onclick='openModal()' class='match'>775                  return false;
776              fbeCurrentSize += Error.FBESize;
777              return true;
778          }
779          public long GetBegin()
780          {
781              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
782                  return 0;
</span>783              uint fbeStructOffset = ReadUInt32(FBEOffset);
784              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
785              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
786                  return 0;
787              uint fbeStructSize = ReadUInt32(fbeStructOffset);
788              Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
789              if (fbeStructSize < (4 + 4))
790                  return 0;
791              _buffer.Shift(fbeStructOffset);
792              return fbeStructOffset;
793          }
794          public void GetEnd(long fbeBegin)
795          {
796              _buffer.Unshift(fbeBegin);
797          }
798          public override void Get(out SimpleReject fbeValue) { Get(out fbeValue, SimpleReject.Default); }
799          public override void Get(out SimpleReject fbeValue, SimpleReject defaults)
800          {
801              long fbeBegin = GetBegin();
802              if (fbeBegin == 0)
803              {
804                  fbeValue = defaults;
805                  return;
806              }
807              uint fbeStructSize = ReadUInt32(0);
808              GetFields(out fbeValue, fbeStructSize);
809              GetEnd(fbeBegin);
810          }
811          public void GetFields(out SimpleReject fbeValue, long fbeStructSize)
812          {
813              long fbeCurrentSize = 4 + 4;
814              fbeValue = SimpleReject.Default;
815              if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
816                  id.Get(out fbeValue.id, com.chronoxor.FBE.UuidGenerator.Sequential());
817              else
818                  fbeValue.id = com.chronoxor.FBE.UuidGenerator.Sequential();
819              fbeCurrentSize += id.FBESize;
820              if ((fbeCurrentSize + Error.FBESize) <= fbeStructSize)
821                  Error.Get(out fbeValue.Error);
822              else
823                  fbeValue.Error = "";
824              fbeCurrentSize += Error.FBESize;
825          }
826          public long SetBegin()
827          {
828              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
829              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
830                  return 0;
831              uint fbeStructSize = (uint)FBEBody;
832              uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
833              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
834              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
835                  return 0;
836              Write(FBEOffset, fbeStructOffset);
837              Write(fbeStructOffset, fbeStructSize);
838              Write(fbeStructOffset + 4, (uint)FBEType);
839              _buffer.Shift(fbeStructOffset);
840              return fbeStructOffset;
841          }
842          public void SetEnd(long fbeBegin)
843          {
844              _buffer.Unshift(fbeBegin);
845          }
846          public override void Set(SimpleReject fbeValue)
847          {
848              long fbeBegin = SetBegin();
849              if (fbeBegin == 0)
850                  return;
851              SetFields(fbeValue);
852              SetEnd(fbeBegin);
853          }
854          public void SetFields(SimpleReject fbeValue)
855          {
856              id.Set(fbeValue.id);
857              Error.Set(fbeValue.Error);
858          }
859      }
860  } 
861  namespace com.chronoxor.simple.FBE {
862      using global::com.chronoxor.simple;
863      public class SimpleRejectModel : com.chronoxor.FBE.Model
864      {
865          public readonly FieldModelSimpleReject model;
866          public SimpleRejectModel() { model = new FieldModelSimpleReject(Buffer, 4); }
867          public SimpleRejectModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleReject(Buffer, 4); }
868          public long FBESize => model.FBESize + model.FBEExtra;
869          public const long FBETypeConst = FieldModelSimpleReject.FBETypeConst;
870          public long FBEType => FBETypeConst;
871          public bool Verify()
872          {
873              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
874                  return false;
875              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
876              if (fbeFullSize < model.FBESize)
877                  return false;
878              return model.Verify();
879          }
880          public long CreateBegin()
881          {
882              long fbeBegin = Buffer.Allocate(4 + model.FBESize);
883              return fbeBegin;
884          }
885          public long CreateEnd(long fbeBegin)
886          {
887              long fbeEnd = Buffer.Size;
888              uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
889              Write(model.FBEOffset - 4, fbeFullSize);
890              return fbeFullSize;
891          }
892          public long Serialize(SimpleReject value)
893          {
894              long fbeBegin = CreateBegin();
895              model.Set(value);
896              long fbeFullSize = CreateEnd(fbeBegin);
897              return fbeFullSize;
898          }
899          public long Deserialize(out SimpleReject value)
900          {
901              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
902              {
903                  value = SimpleReject.Default;
904                  return 0;
905              }
906              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
907              Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
908              if (fbeFullSize < model.FBESize)
909              {
910                  value = SimpleReject.Default;
911                  return 0;
912              }
913              model.Get(out value);
914              return fbeFullSize;
915          }
916          public void Next(long prev)
917          {
918              model.FBEShift(prev);
919          }
920      }
921  } 
922  namespace com.chronoxor.simple {
923      public struct SimpleNotify : IComparable, IComparable<SimpleNotify>, IEquatable<SimpleNotify>
924      {
925          public string Notification;
926          public Guid id => Guid.Empty;
927          public const long FBETypeConst = 4;
928          public long FBEType => FBETypeConst;
929          public static SimpleNotify Default => new SimpleNotify
930          {
931              Notification = ""
932          };
933          public SimpleNotify(string Notification)
934          {
935              this.Notification = Notification;
936          }
937          public SimpleNotify Clone()
938          {
939              var writer = new com.chronoxor.simple.FBE.SimpleNotifyModel();
940              writer.Serialize(this);
941              var reader = new com.chronoxor.simple.FBE.SimpleNotifyModel();
942              reader.Attach(writer.Buffer);
943              reader.Deserialize(out var result);
944              return result;
945          }
946          public int CompareTo(object other)
947          {
948              int result = 0;
949              return result;
950          }
951          public int CompareTo(SimpleNotify other)
952          {
953              int result = 0;
954              return result;
955          }
956          public override bool Equals(object other)
957          {
958              if (!(other is SimpleNotify))
959                  return false;
960              return true;
961          }
962          public bool Equals(SimpleNotify other)
963          {
964              return true;
965          }
966          public override int GetHashCode()
967          {
968              int hash = 17;
969              return hash;
970          }
971          public static bool operator==(SimpleNotify lhs, SimpleNotify rhs) => lhs.Equals(rhs);
972          public static bool operator!=(SimpleNotify lhs, SimpleNotify rhs) => !(lhs == rhs);
973          public override string ToString()
974          {
975              var sb = new StringBuilder();
976              sb.Append("SimpleNotify(");
977              sb.Append("Notification="); if (Notification != null) sb.Append("\"").Append(Notification).Append("\""); else sb.Append("null");
978              sb.Append(")");
979              return sb.ToString();
980          }
981          public static com.chronoxor.FBE.FieldModelValueType<SimpleNotify> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new simple.FBE.FieldModelSimpleNotify(buffer, offset); }
982      }
983  } 
984  namespace com.chronoxor.simple.FBE {
985      using global::com.chronoxor.simple;
986      public class FieldModelSimpleNotify : com.chronoxor.FBE.FieldModelValueType<SimpleNotify>
987      {
988          public readonly com.chronoxor.FBE.FieldModelReferenceType<string> Notification;
989          public FieldModelSimpleNotify(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
990          {
991              Notification = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 4 + 4);
992          }
993          public override long FBESize => 4;
994          public long FBEBody
995          {
996              get
997              {
998                  long fbeResult = 4 + 4
999                      + Notification.FBESize
1000                      ;
1001                  return fbeResult;
1002              }
1003          }
1004          public override long FBEExtra
1005          {
1006              get
1007              {
1008                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1009                      return 0;
1010                  uint fbeStructOffset = ReadUInt32(FBEOffset);
1011                  if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
1012                      return 0;
1013                  _buffer.Shift(fbeStructOffset);
1014                  long fbeResult = FBEBody
1015                      + Notification.FBEExtra
1016                      ;
1017                  _buffer.Unshift(fbeStructOffset);
1018                  return fbeResult;
1019              }
1020          }
1021          public const long FBETypeConst = 4;
1022          public long FBEType => FBETypeConst;
1023          public override com.chronoxor.FBE.FieldModelValueType<SimpleNotify> Clone() { return new FieldModelSimpleNotify(_buffer, _offset); }
1024          public override bool Verify() { return Verify(true); }
1025          public bool Verify(bool fbeVerifyType)
1026          {
1027              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1028                  return true;
1029              uint fbeStructOffset = ReadUInt32(FBEOffset);
1030              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
1031                  return false;
1032              uint fbeStructSize = ReadUInt32(fbeStructOffset);
1033              if (fbeStructSize < (4 + 4))
1034                  return false;
1035              uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
1036              if (fbeVerifyType && (fbeStructType != FBEType))
1037                  return false;
1038              _buffer.Shift(fbeStructOffset);
1039              bool fbeResult = VerifyFields(fbeStructSize);
1040              _buffer.Unshift(fbeStructOffset);
1041              return fbeResult;
1042          }
1043          public bool VerifyFields(long fbeStructSize)
1044          {
1045              long fbeCurrentSize = 4 + 4;
1046              if ((fbeCurrentSize + Notification.FBESize) > fbeStructSize)
1047                  return true;
1048              if (!Notification.Verify())
1049                  return false;
1050              fbeCurrentSize += Notification.FBESize;
1051              return true;
1052          }
1053          public long GetBegin()
1054          {
1055              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1056                  return 0;
1057              uint fbeStructOffset = ReadUInt32(FBEOffset);
1058              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
1059              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
1060                  return 0;
1061              uint fbeStructSize = ReadUInt32(fbeStructOffset);
1062              Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
1063              if (fbeStructSize < (4 + 4))
1064                  return 0;
1065              _buffer.Shift(fbeStructOffset);
1066              return fbeStructOffset;
1067          }
1068          public void GetEnd(long fbeBegin)
1069          {
1070              _buffer.Unshift(fbeBegin);
1071          }
1072          public override void Get(out SimpleNotify fbeValue) { Get(out fbeValue, SimpleNotify.Default); }
1073          public override void Get(out SimpleNotify fbeValue, SimpleNotify defaults)
1074          {
1075              long fbeBegin = GetBegin();
1076              if (fbeBegin == 0)
1077              {
1078                  fbeValue = defaults;
1079                  return;
1080              }
1081              uint fbeStructSize = ReadUInt32(0);
1082              GetFields(out fbeValue, fbeStructSize);
1083              GetEnd(fbeBegin);
1084          }
1085          public void GetFields(out SimpleNotify fbeValue, long fbeStructSize)
1086          {
1087              long fbeCurrentSize = 4 + 4;
1088              fbeValue = SimpleNotify.Default;
1089              if ((fbeCurrentSize + Notification.FBESize) <= fbeStructSize)
1090                  Notification.Get(out fbeValue.Notification);
1091              else
1092                  fbeValue.Notification = "";
1093              fbeCurrentSize += Notification.FBESize;
1094          }
1095          public long SetBegin()
1096          {
1097              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1098              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1099                  return 0;
1100              uint fbeStructSize = (uint)FBEBody;
1101              uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
1102              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
1103              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
1104                  return 0;
1105              Write(FBEOffset, fbeStructOffset);
1106              Write(fbeStructOffset, fbeStructSize);
1107              Write(fbeStructOffset + 4, (uint)FBEType);
1108              _buffer.Shift(fbeStructOffset);
1109              return fbeStructOffset;
1110          }
1111          public void SetEnd(long fbeBegin)
1112          {
1113              _buffer.Unshift(fbeBegin);
1114          }
1115          public override void Set(SimpleNotify fbeValue)
1116          {
1117              long fbeBegin = SetBegin();
1118              if (fbeBegin == 0)
1119                  return;
1120              SetFields(fbeValue);
1121              SetEnd(fbeBegin);
1122          }
1123          public void SetFields(SimpleNotify fbeValue)
1124          {
1125              Notification.Set(fbeValue.Notification);
1126          }
1127      }
1128  } 
1129  namespace com.chronoxor.simple.FBE {
1130      using global::com.chronoxor.simple;
1131      public class SimpleNotifyModel : com.chronoxor.FBE.Model
1132      {
1133          public readonly FieldModelSimpleNotify model;
1134          public SimpleNotifyModel() { model = new FieldModelSimpleNotify(Buffer, 4); }
1135          public SimpleNotifyModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleNotify(Buffer, 4); }
1136          public long FBESize => model.FBESize + model.FBEExtra;
1137          public const long FBETypeConst = FieldModelSimpleNotify.FBETypeConst;
1138          public long FBEType => FBETypeConst;
1139          public bool Verify()
1140          {
1141              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
1142                  return false;
1143              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
1144              if (fbeFullSize < model.FBESize)
1145                  return false;
1146              return model.Verify();
1147          }
1148          public long CreateBegin()
1149          {
1150              long fbeBegin = Buffer.Allocate(4 + model.FBESize);
1151              return fbeBegin;
1152          }
1153          public long CreateEnd(long fbeBegin)
1154          {
1155              long fbeEnd = Buffer.Size;
1156              uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
1157              Write(model.FBEOffset - 4, fbeFullSize);
1158              return fbeFullSize;
1159          }
1160          public long Serialize(SimpleNotify value)
1161          {
1162              long fbeBegin = CreateBegin();
1163              model.Set(value);
1164              long fbeFullSize = CreateEnd(fbeBegin);
1165              return fbeFullSize;
1166          }
1167          public long Deserialize(out SimpleNotify value)
1168          {
1169              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
1170              {
1171                  value = SimpleNotify.Default;
1172                  return 0;
1173              }
1174              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
1175              Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
1176              if (fbeFullSize < model.FBESize)
1177              {
1178                  value = SimpleNotify.Default;
1179                  return 0;
1180              }
1181              model.Get(out value);
1182              return fbeFullSize;
1183          }
1184          public void Next(long prev)
1185          {
1186              model.FBEShift(prev);
1187          }
1188      }
1189  } 
1190  namespace com.chronoxor.simple {
1191      public struct DisconnectRequest : IComparable, IComparable<DisconnectRequest>, IEquatable<DisconnectRequest>
1192      {
1193          public Guid id;
1194          public const long FBETypeConst = 5;
1195          public long FBEType => FBETypeConst;
1196          public static DisconnectRequest Default => new DisconnectRequest
1197          {
1198              id = com.chronoxor.FBE.UuidGenerator.Sequential()
1199          };
1200          public DisconnectRequest(Guid id)
1201          {
1202              this.id = id;
1203          }
1204          public DisconnectRequest Clone()
1205          {
1206              var writer = new com.chronoxor.simple.FBE.DisconnectRequestModel();
1207              writer.Serialize(this);
1208              var reader = new com.chronoxor.simple.FBE.DisconnectRequestModel();
1209              reader.Attach(writer.Buffer);
1210              reader.Deserialize(out var result);
1211              return result;
1212          }
1213          public int CompareTo(object other)
1214          {
1215              int result = 0;
1216              result = id.CompareTo(((DisconnectRequest)other).id);
1217              if (result != 0)
1218                  return result;
1219              return result;
1220          }
1221          public int CompareTo(DisconnectRequest other)
1222          {
1223              int result = 0;
1224              result = id.CompareTo(other.id);
1225              if (result != 0)
1226                  return result;
1227              return result;
1228          }
1229          public override bool Equals(object other)
1230          {
1231              if (!(other is DisconnectRequest))
1232                  return false;
1233              if (!id.Equals(((DisconnectRequest)other).id))
1234                  return false;
1235              return true;
1236          }
1237          public bool Equals(DisconnectRequest other)
1238          {
1239              if (!id.Equals(other.id))
1240                  return false;
1241              return true;
1242          }
1243          public override int GetHashCode()
1244          {
1245              int hash = 17;
1246              hash = hash * 31 + id.GetHashCode();
1247              return hash;
1248          }
1249          public static bool operator==(DisconnectRequest lhs, DisconnectRequest rhs) => lhs.Equals(rhs);
1250          public static bool operator!=(DisconnectRequest lhs, DisconnectRequest rhs) => !(lhs == rhs);
1251          public override string ToString()
1252          {
1253              var sb = new StringBuilder();
1254              sb.Append("DisconnectRequest(");
1255              sb.Append("id="); sb.Append("\"").Append(id).Append("\"");
1256              sb.Append(")");
1257              return sb.ToString();
1258          }
1259          public static com.chronoxor.FBE.FieldModelValueType<DisconnectRequest> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new simple.FBE.FieldModelDisconnectRequest(buffer, offset); }
1260      }
1261  } 
1262  namespace com.chronoxor.simple.FBE {
1263      using global::com.chronoxor.simple;
1264      public class FieldModelDisconnectRequest : com.chronoxor.FBE.FieldModelValueType<DisconnectRequest>
1265      {
1266          public readonly com.chronoxor.FBE.FieldModelValueType<Guid> id;
1267          public FieldModelDisconnectRequest(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
1268          {
1269              id = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 4 + 4);
1270          }
1271          public override long FBESize => 4;
1272          public long FBEBody
1273          {
1274              get
1275              {
1276                  long fbeResult = 4 + 4
1277                      + id.FBESize
1278                      ;
1279                  return fbeResult;
1280              }
1281          }
1282          public override long FBEExtra
1283          {
1284              get
1285              {
1286                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1287                      return 0;
1288                  uint fbeStructOffset = ReadUInt32(FBEOffset);
1289                  if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
1290                      return 0;
1291                  _buffer.Shift(fbeStructOffset);
1292                  long fbeResult = FBEBody
1293                      + id.FBEExtra
1294                      ;
1295                  _buffer.Unshift(fbeStructOffset);
1296                  return fbeResult;
1297              }
1298          }
1299          public const long FBETypeConst = 5;
1300          public long FBEType => FBETypeConst;
1301          public override com.chronoxor.FBE.FieldModelValueType<DisconnectRequest> Clone() { return new FieldModelDisconnectRequest(_buffer, _offset); }
1302          public override bool Verify() { return Verify(true); }
1303          public bool Verify(bool fbeVerifyType)
1304          {
1305              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1306                  return true;
1307              uint fbeStructOffset = ReadUInt32(FBEOffset);
1308              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
1309                  return false;
1310              uint fbeStructSize = ReadUInt32(fbeStructOffset);
1311              if (fbeStructSize < (4 + 4))
1312                  return false;
1313              uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
1314              if (fbeVerifyType && (fbeStructType != FBEType))
1315                  return false;
1316              _buffer.Shift(fbeStructOffset);
1317              bool fbeResult = VerifyFields(fbeStructSize);
1318              _buffer.Unshift(fbeStructOffset);
1319              return fbeResult;
1320          }
1321          public bool VerifyFields(long fbeStructSize)
1322          {
1323              long fbeCurrentSize = 4 + 4;
1324              if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
1325                  return true;
1326              if (!id.Verify())
1327                  return false;
1328              fbeCurrentSize += id.FBESize;
1329              return true;
1330          }
1331          public long GetBegin()
1332          {
1333              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1334                  return 0;
1335              uint fbeStructOffset = ReadUInt32(FBEOffset);
1336              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
1337              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
1338                  return 0;
1339              uint fbeStructSize = ReadUInt32(fbeStructOffset);
1340              Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
1341              if (fbeStructSize < (4 + 4))
1342                  return 0;
1343              _buffer.Shift(fbeStructOffset);
1344              return fbeStructOffset;
1345          }
1346          public void GetEnd(long fbeBegin)
1347          {
1348              _buffer.Unshift(fbeBegin);
1349          }
1350          public override void Get(out DisconnectRequest fbeValue) { Get(out fbeValue, DisconnectRequest.Default); }
1351          public override void Get(out DisconnectRequest fbeValue, DisconnectRequest defaults)
1352          {
1353              long fbeBegin = GetBegin();
1354              if (fbeBegin == 0)
1355              {
1356                  fbeValue = defaults;
1357                  return;
1358              }
1359              uint fbeStructSize = ReadUInt32(0);
1360              GetFields(out fbeValue, fbeStructSize);
1361              GetEnd(fbeBegin);
1362          }
1363          public void GetFields(out DisconnectRequest fbeValue, long fbeStructSize)
1364          {
1365              long fbeCurrentSize = 4 + 4;
1366              fbeValue = DisconnectRequest.Default;
1367              if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
1368                  id.Get(out fbeValue.id, com.chronoxor.FBE.UuidGenerator.Sequential());
1369              else
1370                  fbeValue.id = com.chronoxor.FBE.UuidGenerator.Sequential();
1371              fbeCurrentSize += id.FBESize;
1372          }
1373          public long SetBegin()
1374          {
1375              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1376              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1377                  return 0;
1378              uint fbeStructSize = (uint)FBEBody;
1379              uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
1380              Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
1381              if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
1382                  return 0;
1383              Write(FBEOffset, fbeStructOffset);
1384              Write(fbeStructOffset, fbeStructSize);
1385              Write(fbeStructOffset + 4, (uint)FBEType);
1386              _buffer.Shift(fbeStructOffset);
1387              return fbeStructOffset;
1388          }
1389          public void SetEnd(long fbeBegin)
1390          {
1391              _buffer.Unshift(fbeBegin);
1392          }
1393          public override void Set(DisconnectRequest fbeValue)
1394          {
1395              long fbeBegin = SetBegin();
1396              if (fbeBegin == 0)
1397                  return;
1398              SetFields(fbeValue);
1399              SetEnd(fbeBegin);
1400          }
1401          public void SetFields(DisconnectRequest fbeValue)
1402          {
1403              id.Set(fbeValue.id);
1404          }
1405      }
1406  } 
1407  namespace com.chronoxor.simple.FBE {
1408      using global::com.chronoxor.simple;
1409      public class DisconnectRequestModel : com.chronoxor.FBE.Model
1410      {
1411          public readonly FieldModelDisconnectRequest model;
1412          public DisconnectRequestModel() { model = new FieldModelDisconnectRequest(Buffer, 4); }
1413          public DisconnectRequestModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelDisconnectRequest(Buffer, 4); }
1414          public long FBESize => model.FBESize + model.FBEExtra;
1415          public const long FBETypeConst = FieldModelDisconnectRequest.FBETypeConst;
1416          public long FBEType => FBETypeConst;
1417          public bool Verify()
1418          {
1419              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
1420                  return false;
1421              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
1422              if (fbeFullSize < model.FBESize)
1423                  return false;
1424              return model.Verify();
1425          }
1426          public long CreateBegin()
1427          {
1428              long fbeBegin = Buffer.Allocate(4 + model.FBESize);
1429              return fbeBegin;
1430          }
1431          public long CreateEnd(long fbeBegin)
1432          {
1433              long fbeEnd = Buffer.Size;
1434              uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
1435              Write(model.FBEOffset - 4, fbeFullSize);
1436              return fbeFullSize;
1437          }
1438          public long Serialize(DisconnectRequest value)
1439          {
1440              long fbeBegin = CreateBegin();
1441              model.Set(value);
1442              long fbeFullSize = CreateEnd(fbeBegin);
1443              return fbeFullSize;
1444          }
1445          public long Deserialize(out DisconnectRequest value)
1446          {
1447              if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
1448              {
1449                  value = DisconnectRequest.Default;
1450                  return 0;
1451              }
1452              uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
1453              Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
1454              if (fbeFullSize < model.FBESize)
1455              {
1456                  value = DisconnectRequest.Default;
1457                  return 0;
1458              }
1459              model.Get(out value);
1460              return fbeFullSize;
1461          }
1462          public void Next(long prev)
1463          {
1464              model.FBEShift(prev);
1465          }
1466      }
1467  } 
1468  namespace com.chronoxor.simple.FBE {
1469      public static class ProtocolVersion
1470      {
1471          public const int Major = 1;
1472          public const int Minor = 0;
1473      }
1474  } 
1475  namespace com.chronoxor.simple.FBE {
1476      public interface ISenderListener : com.chronoxor.FBE.ISenderListener
1477      {
1478      }
1479      public class Sender : com.chronoxor.FBE.Sender, ISenderListener
1480      {
1481          public readonly SimpleRequestModel SimpleRequestModel;
1482          public readonly SimpleResponseModel SimpleResponseModel;
1483          public readonly SimpleRejectModel SimpleRejectModel;
1484          public readonly SimpleNotifyModel SimpleNotifyModel;
1485          public readonly DisconnectRequestModel DisconnectRequestModel;
1486          public Sender() : base(false)
1487          {
1488              SimpleRequestModel = new SimpleRequestModel(Buffer);
1489              SimpleResponseModel = new SimpleResponseModel(Buffer);
1490              SimpleRejectModel = new SimpleRejectModel(Buffer);
1491              SimpleNotifyModel = new SimpleNotifyModel(Buffer);
1492              DisconnectRequestModel = new DisconnectRequestModel(Buffer);
1493          }
1494          public Sender(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
1495          {
1496              SimpleRequestModel = new SimpleRequestModel(Buffer);
1497              SimpleResponseModel = new SimpleResponseModel(Buffer);
1498              SimpleRejectModel = new SimpleRejectModel(Buffer);
1499              SimpleNotifyModel = new SimpleNotifyModel(Buffer);
1500              DisconnectRequestModel = new DisconnectRequestModel(Buffer);
1501          }
1502          public long Send(object obj) { return SendListener(this, obj); }
1503          public long SendListener(ISenderListener listener, object obj)
1504          {
1505              switch (obj)
1506              {
1507                  case global::com.chronoxor.simple.SimpleRequest value when value.FBEType == global::com.chronoxor.simple.SimpleRequest.FBETypeConst: return SendListener(listener, value);
1508                  case global::com.chronoxor.simple.SimpleResponse value when value.FBEType == global::com.chronoxor.simple.SimpleResponse.FBETypeConst: return SendListener(listener, value);
1509                  case global::com.chronoxor.simple.SimpleReject value when value.FBEType == global::com.chronoxor.simple.SimpleReject.FBETypeConst: return SendListener(listener, value);
1510                  case global::com.chronoxor.simple.SimpleNotify value when value.FBEType == global::com.chronoxor.simple.SimpleNotify.FBETypeConst: return SendListener(listener, value);
1511                  case global::com.chronoxor.simple.DisconnectRequest value when value.FBEType == global::com.chronoxor.simple.DisconnectRequest.FBETypeConst: return SendListener(listener, value);
1512                  default: break;
1513              }
1514              return 0;
1515          }
1516          public long Send(global::com.chronoxor.simple.SimpleRequest value) { return SendListener(this, value); }
1517          public long SendListener(ISenderListener listener, global::com.chronoxor.simple.SimpleRequest value)
1518          {
1519              long serialized = SimpleRequestModel.Serialize(value);
1520              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleRequest serialization failed!");
1521              Debug.Assert(SimpleRequestModel.Verify(), "com.chronoxor.simple.SimpleRequest validation failed!");
1522              if (Logging)
1523              {
1524                  string message = value.ToString();
1525                  listener.OnSendLog(message);
1526              }
1527              return SendSerialized(listener, serialized);
1528          }
1529          public long Send(global::com.chronoxor.simple.SimpleResponse value) { return SendListener(this, value); }
1530          public long SendListener(ISenderListener listener, global::com.chronoxor.simple.SimpleResponse value)
1531          {
1532              long serialized = SimpleResponseModel.Serialize(value);
1533              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleResponse serialization failed!");
1534              Debug.Assert(SimpleResponseModel.Verify(), "com.chronoxor.simple.SimpleResponse validation failed!");
1535              if (Logging)
1536              {
1537                  string message = value.ToString();
1538                  listener.OnSendLog(message);
1539              }
1540              return SendSerialized(listener, serialized);
1541          }
1542          public long Send(global::com.chronoxor.simple.SimpleReject value) { return SendListener(this, value); }
1543          public long SendListener(ISenderListener listener, global::com.chronoxor.simple.SimpleReject value)
1544          {
1545              long serialized = SimpleRejectModel.Serialize(value);
1546              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleReject serialization failed!");
1547              Debug.Assert(SimpleRejectModel.Verify(), "com.chronoxor.simple.SimpleReject validation failed!");
1548              if (Logging)
1549              {
1550                  string message = value.ToString();
1551                  listener.OnSendLog(message);
1552              }
1553              return SendSerialized(listener, serialized);
1554          }
1555          public long Send(global::com.chronoxor.simple.SimpleNotify value) { return SendListener(this, value); }
1556          public long SendListener(ISenderListener listener, global::com.chronoxor.simple.SimpleNotify value)
1557          {
1558              long serialized = SimpleNotifyModel.Serialize(value);
1559              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleNotify serialization failed!");
1560              Debug.Assert(SimpleNotifyModel.Verify(), "com.chronoxor.simple.SimpleNotify validation failed!");
1561              if (Logging)
1562              {
1563                  string message = value.ToString();
1564                  listener.OnSendLog(message);
1565              }
1566              return SendSerialized(listener, serialized);
1567          }
1568          public long Send(global::com.chronoxor.simple.DisconnectRequest value) { return SendListener(this, value); }
1569          public long SendListener(ISenderListener listener, global::com.chronoxor.simple.DisconnectRequest value)
1570          {
1571              long serialized = DisconnectRequestModel.Serialize(value);
1572              Debug.Assert((serialized > 0), "com.chronoxor.simple.DisconnectRequest serialization failed!");
1573              Debug.Assert(DisconnectRequestModel.Verify(), "com.chronoxor.simple.DisconnectRequest validation failed!");
1574              if (Logging)
1575              {
1576                  string message = value.ToString();
1577                  listener.OnSendLog(message);
1578              }
1579              return SendSerialized(listener, serialized);
1580          }
1581      }
1582  } 
1583  namespace com.chronoxor.simple.FBE {
1584      public interface IReceiverListener : com.chronoxor.FBE.IReceiverListener
1585      {
1586          void OnReceive(global::com.chronoxor.simple.SimpleRequest value) {}
1587          void OnReceive(global::com.chronoxor.simple.SimpleResponse value) {}
1588          void OnReceive(global::com.chronoxor.simple.SimpleReject value) {}
1589          void OnReceive(global::com.chronoxor.simple.SimpleNotify value) {}
1590          void OnReceive(global::com.chronoxor.simple.DisconnectRequest value) {}
1591      }
1592      public class Receiver : com.chronoxor.FBE.Receiver, IReceiverListener
1593      {
1594          private global::com.chronoxor.simple.SimpleRequest SimpleRequestValue;
1595          private global::com.chronoxor.simple.SimpleResponse SimpleResponseValue;
1596          private global::com.chronoxor.simple.SimpleReject SimpleRejectValue;
1597          private global::com.chronoxor.simple.SimpleNotify SimpleNotifyValue;
1598          private global::com.chronoxor.simple.DisconnectRequest DisconnectRequestValue;
1599          private readonly SimpleRequestModel SimpleRequestModel;
1600          private readonly SimpleResponseModel SimpleResponseModel;
1601          private readonly SimpleRejectModel SimpleRejectModel;
1602          private readonly SimpleNotifyModel SimpleNotifyModel;
1603          private readonly DisconnectRequestModel DisconnectRequestModel;
1604          public Receiver() : base(false)
1605          {
1606              SimpleRequestValue = global::com.chronoxor.simple.SimpleRequest.Default;
1607              SimpleRequestModel = new SimpleRequestModel();
1608              SimpleResponseValue = global::com.chronoxor.simple.SimpleResponse.Default;
1609              SimpleResponseModel = new SimpleResponseModel();
1610              SimpleRejectValue = global::com.chronoxor.simple.SimpleReject.Default;
1611              SimpleRejectModel = new SimpleRejectModel();
1612              SimpleNotifyValue = global::com.chronoxor.simple.SimpleNotify.Default;
1613              SimpleNotifyModel = new SimpleNotifyModel();
1614              DisconnectRequestValue = global::com.chronoxor.simple.DisconnectRequest.Default;
1615              DisconnectRequestModel = new DisconnectRequestModel();
1616          }
1617          public Receiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
1618          {
1619              SimpleRequestValue = global::com.chronoxor.simple.SimpleRequest.Default;
1620              SimpleRequestModel = new SimpleRequestModel();
1621              SimpleResponseValue = global::com.chronoxor.simple.SimpleResponse.Default;
1622              SimpleResponseModel = new SimpleResponseModel();
1623              SimpleRejectValue = global::com.chronoxor.simple.SimpleReject.Default;
1624              SimpleRejectModel = new SimpleRejectModel();
1625              SimpleNotifyValue = global::com.chronoxor.simple.SimpleNotify.Default;
1626              SimpleNotifyModel = new SimpleNotifyModel();
1627              DisconnectRequestValue = global::com.chronoxor.simple.DisconnectRequest.Default;
1628              DisconnectRequestModel = new DisconnectRequestModel();
1629          }
1630          internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
1631          internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
1632          {
1633              switch (type)
1634              {
1635                  case SimpleRequestModel.FBETypeConst:
1636                  {
1637                      SimpleRequestModel.Attach(buffer, offset);
1638                      Debug.Assert(SimpleRequestModel.Verify(), "com.chronoxor.simple.SimpleRequest validation failed!");
1639                      long deserialized = SimpleRequestModel.Deserialize(out SimpleRequestValue);
1640                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleRequest deserialization failed!");
1641                      if (Logging)
1642                      {
1643                          string message = SimpleRequestValue.ToString();
1644                          listener.OnReceiveLog(message);
1645                      }
1646                      listener.OnReceive(SimpleRequestValue);
1647                      return true;
1648                  }
1649                  case SimpleResponseModel.FBETypeConst:
1650                  {
1651                      SimpleResponseModel.Attach(buffer, offset);
1652                      Debug.Assert(SimpleResponseModel.Verify(), "com.chronoxor.simple.SimpleResponse validation failed!");
1653                      long deserialized = SimpleResponseModel.Deserialize(out SimpleResponseValue);
1654                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleResponse deserialization failed!");
1655                      if (Logging)
1656                      {
1657                          string message = SimpleResponseValue.ToString();
1658                          listener.OnReceiveLog(message);
1659                      }
1660                      listener.OnReceive(SimpleResponseValue);
1661                      return true;
1662                  }
1663                  case SimpleRejectModel.FBETypeConst:
1664                  {
1665                      SimpleRejectModel.Attach(buffer, offset);
1666                      Debug.Assert(SimpleRejectModel.Verify(), "com.chronoxor.simple.SimpleReject validation failed!");
1667                      long deserialized = SimpleRejectModel.Deserialize(out SimpleRejectValue);
1668                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleReject deserialization failed!");
1669                      if (Logging)
1670                      {
1671                          string message = SimpleRejectValue.ToString();
1672                          listener.OnReceiveLog(message);
1673                      }
1674                      listener.OnReceive(SimpleRejectValue);
1675                      return true;
1676                  }
1677                  case SimpleNotifyModel.FBETypeConst:
1678                  {
1679                      SimpleNotifyModel.Attach(buffer, offset);
1680                      Debug.Assert(SimpleNotifyModel.Verify(), "com.chronoxor.simple.SimpleNotify validation failed!");
1681                      long deserialized = SimpleNotifyModel.Deserialize(out SimpleNotifyValue);
1682                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleNotify deserialization failed!");
1683                      if (Logging)
1684                      {
1685                          string message = SimpleNotifyValue.ToString();
1686                          listener.OnReceiveLog(message);
1687                      }
1688                      listener.OnReceive(SimpleNotifyValue);
1689                      return true;
1690                  }
1691                  case DisconnectRequestModel.FBETypeConst:
1692                  {
1693                      DisconnectRequestModel.Attach(buffer, offset);
1694                      Debug.Assert(DisconnectRequestModel.Verify(), "com.chronoxor.simple.DisconnectRequest validation failed!");
1695                      long deserialized = DisconnectRequestModel.Deserialize(out DisconnectRequestValue);
1696                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.DisconnectRequest deserialization failed!");
1697                      if (Logging)
1698                      {
1699                          string message = DisconnectRequestValue.ToString();
1700                          listener.OnReceiveLog(message);
1701                      }
1702                      listener.OnReceive(DisconnectRequestValue);
1703                      return true;
1704                  }
1705                  default: break;
1706              }
1707              return false;
1708          }
1709      }
1710  } 
1711  namespace com.chronoxor.simple.FBE {
1712      public interface IProxyListener : com.chronoxor.FBE.IReceiverListener
1713      {
1714          void OnProxy(SimpleRequestModel model, long type, byte[] buffer, long offset, long size) {}
1715          void OnProxy(SimpleResponseModel model, long type, byte[] buffer, long offset, long size) {}
1716          void OnProxy(SimpleRejectModel model, long type, byte[] buffer, long offset, long size) {}
1717          void OnProxy(SimpleNotifyModel model, long type, byte[] buffer, long offset, long size) {}
1718          void OnProxy(DisconnectRequestModel model, long type, byte[] buffer, long offset, long size) {}
1719      }
1720      public class Proxy : com.chronoxor.FBE.Receiver, IProxyListener
1721      {
1722          private readonly SimpleRequestModel SimpleRequestModel;
1723          private readonly SimpleResponseModel SimpleResponseModel;
1724          private readonly SimpleRejectModel SimpleRejectModel;
1725          private readonly SimpleNotifyModel SimpleNotifyModel;
1726          private readonly DisconnectRequestModel DisconnectRequestModel;
1727          public Proxy() : base(false)
1728          {
1729              SimpleRequestModel = new SimpleRequestModel();
1730              SimpleResponseModel = new SimpleResponseModel();
1731              SimpleRejectModel = new SimpleRejectModel();
1732              SimpleNotifyModel = new SimpleNotifyModel();
1733              DisconnectRequestModel = new DisconnectRequestModel();
1734          }
1735          public Proxy(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
1736          {
1737              SimpleRequestModel = new SimpleRequestModel();
1738              SimpleResponseModel = new SimpleResponseModel();
1739              SimpleRejectModel = new SimpleRejectModel();
1740              SimpleNotifyModel = new SimpleNotifyModel();
1741              DisconnectRequestModel = new DisconnectRequestModel();
1742          }
1743          internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
1744          internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
1745          {
1746              switch (type)
1747              {
1748                  case SimpleRequestModel.FBETypeConst:
1749                  {
1750                      SimpleRequestModel.Attach(buffer, offset);
1751                      Debug.Assert(SimpleRequestModel.Verify(), "com.chronoxor.simple.SimpleRequest validation failed!");
1752                      long fbeBegin = SimpleRequestModel.model.GetBegin();
1753                      if (fbeBegin == 0)
1754                          return false;
1755                      listener.OnProxy(SimpleRequestModel, type, buffer, offset, size);
1756                      SimpleRequestModel.model.GetEnd(fbeBegin);
1757                      return true;
1758                  }
1759                  case SimpleResponseModel.FBETypeConst:
1760                  {
1761                      SimpleResponseModel.Attach(buffer, offset);
1762                      Debug.Assert(SimpleResponseModel.Verify(), "com.chronoxor.simple.SimpleResponse validation failed!");
1763                      long fbeBegin = SimpleResponseModel.model.GetBegin();
1764                      if (fbeBegin == 0)
1765                          return false;
1766                      listener.OnProxy(SimpleResponseModel, type, buffer, offset, size);
1767                      SimpleResponseModel.model.GetEnd(fbeBegin);
1768                      return true;
1769                  }
1770                  case SimpleRejectModel.FBETypeConst:
1771                  {
1772                      SimpleRejectModel.Attach(buffer, offset);
1773                      Debug.Assert(SimpleRejectModel.Verify(), "com.chronoxor.simple.SimpleReject validation failed!");
1774                      long fbeBegin = SimpleRejectModel.model.GetBegin();
1775                      if (fbeBegin == 0)
1776                          return false;
1777                      listener.OnProxy(SimpleRejectModel, type, buffer, offset, size);
1778                      SimpleRejectModel.model.GetEnd(fbeBegin);
1779                      return true;
1780                  }
1781                  case SimpleNotifyModel.FBETypeConst:
1782                  {
1783                      SimpleNotifyModel.Attach(buffer, offset);
1784                      Debug.Assert(SimpleNotifyModel.Verify(), "com.chronoxor.simple.SimpleNotify validation failed!");
1785                      long fbeBegin = SimpleNotifyModel.model.GetBegin();
1786                      if (fbeBegin == 0)
1787                          return false;
1788                      listener.OnProxy(SimpleNotifyModel, type, buffer, offset, size);
1789                      SimpleNotifyModel.model.GetEnd(fbeBegin);
1790                      return true;
1791                  }
1792                  case DisconnectRequestModel.FBETypeConst:
1793                  {
1794                      DisconnectRequestModel.Attach(buffer, offset);
1795                      Debug.Assert(DisconnectRequestModel.Verify(), "com.chronoxor.simple.DisconnectRequest validation failed!");
1796                      long fbeBegin = DisconnectRequestModel.model.GetBegin();
1797                      if (fbeBegin == 0)
1798                          return false;
1799                      listener.OnProxy(DisconnectRequestModel, type, buffer, offset, size);
1800                      DisconnectRequestModel.model.GetEnd(fbeBegin);
1801                      return true;
1802                  }
1803                  default: break;
1804              }
1805              return false;
1806          }
1807      }
1808  } 
1809  namespace com.chronoxor.simple.FBE {
1810      public interface IClientListener : com.chronoxor.FBE.IClientListener, ISenderListener, IReceiverListener
1811      {
1812      }
1813      public class Client : com.chronoxor.FBE.Client, IClientListener
1814      {
1815          public readonly SimpleRequestModel SimpleRequestSenderModel;
1816          public readonly SimpleResponseModel SimpleResponseSenderModel;
1817          public readonly SimpleRejectModel SimpleRejectSenderModel;
1818          public readonly SimpleNotifyModel SimpleNotifySenderModel;
1819          public readonly DisconnectRequestModel DisconnectRequestSenderModel;
1820          private global::com.chronoxor.simple.SimpleRequest SimpleRequestReceiverValue;
1821          private global::com.chronoxor.simple.SimpleResponse SimpleResponseReceiverValue;
1822          private global::com.chronoxor.simple.SimpleReject SimpleRejectReceiverValue;
1823          private global::com.chronoxor.simple.SimpleNotify SimpleNotifyReceiverValue;
1824          private global::com.chronoxor.simple.DisconnectRequest DisconnectRequestReceiverValue;
1825          private readonly SimpleRequestModel SimpleRequestReceiverModel;
1826          private readonly SimpleResponseModel SimpleResponseReceiverModel;
1827          private readonly SimpleRejectModel SimpleRejectReceiverModel;
1828          private readonly SimpleNotifyModel SimpleNotifyReceiverModel;
1829          private readonly DisconnectRequestModel DisconnectRequestReceiverModel;
1830          private Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>>> _requestsByIdSimpleResponse;
1831          private SortedDictionary<DateTime, Guid> _requestsByTimestampSimpleResponse;
1832          public Client() : base(false)
1833          {
1834              SimpleRequestSenderModel = new SimpleRequestModel(SendBuffer);
1835              SimpleRequestReceiverValue = global::com.chronoxor.simple.SimpleRequest.Default;
1836              SimpleRequestReceiverModel = new SimpleRequestModel();
1837              SimpleResponseSenderModel = new SimpleResponseModel(SendBuffer);
1838              SimpleResponseReceiverValue = global::com.chronoxor.simple.SimpleResponse.Default;
1839              SimpleResponseReceiverModel = new SimpleResponseModel();
1840              SimpleRejectSenderModel = new SimpleRejectModel(SendBuffer);
1841              SimpleRejectReceiverValue = global::com.chronoxor.simple.SimpleReject.Default;
1842              SimpleRejectReceiverModel = new SimpleRejectModel();
1843              SimpleNotifySenderModel = new SimpleNotifyModel(SendBuffer);
1844              SimpleNotifyReceiverValue = global::com.chronoxor.simple.SimpleNotify.Default;
1845              SimpleNotifyReceiverModel = new SimpleNotifyModel();
1846              DisconnectRequestSenderModel = new DisconnectRequestModel(SendBuffer);
1847              DisconnectRequestReceiverValue = global::com.chronoxor.simple.DisconnectRequest.Default;
1848              DisconnectRequestReceiverModel = new DisconnectRequestModel();
1849              _requestsByIdSimpleResponse = new Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>>>();
1850              _requestsByTimestampSimpleResponse = new SortedDictionary<DateTime, Guid>();
1851          }
1852          public Client(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
1853          {
1854              SimpleRequestSenderModel = new SimpleRequestModel(SendBuffer);
1855              SimpleRequestReceiverValue = global::com.chronoxor.simple.SimpleRequest.Default;
1856              SimpleRequestReceiverModel = new SimpleRequestModel();
1857              SimpleResponseSenderModel = new SimpleResponseModel(SendBuffer);
1858              SimpleResponseReceiverValue = global::com.chronoxor.simple.SimpleResponse.Default;
1859              SimpleResponseReceiverModel = new SimpleResponseModel();
1860              SimpleRejectSenderModel = new SimpleRejectModel(SendBuffer);
1861              SimpleRejectReceiverValue = global::com.chronoxor.simple.SimpleReject.Default;
1862              SimpleRejectReceiverModel = new SimpleRejectModel();
1863              SimpleNotifySenderModel = new SimpleNotifyModel(SendBuffer);
1864              SimpleNotifyReceiverValue = global::com.chronoxor.simple.SimpleNotify.Default;
1865              SimpleNotifyReceiverModel = new SimpleNotifyModel();
1866              DisconnectRequestSenderModel = new DisconnectRequestModel(SendBuffer);
1867              DisconnectRequestReceiverValue = global::com.chronoxor.simple.DisconnectRequest.Default;
1868              DisconnectRequestReceiverModel = new DisconnectRequestModel();
1869              _requestsByIdSimpleResponse = new Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>>>();
1870              _requestsByTimestampSimpleResponse = new SortedDictionary<DateTime, Guid>();
1871          }
1872          public Task<global::com.chronoxor.simple.SimpleResponse> Request(global::com.chronoxor.simple.SimpleRequest value) { return RequestListener(this, value, TimeSpan.Zero); }
1873          public Task<global::com.chronoxor.simple.SimpleResponse> Request(global::com.chronoxor.simple.SimpleRequest value, TimeSpan timeout) { return RequestListener(this, value, timeout); }
1874          public Task<global::com.chronoxor.simple.SimpleResponse> RequestListener(IClientListener listener, global::com.chronoxor.simple.SimpleRequest value) { return RequestListener(listener, value, TimeSpan.Zero); }
1875          public Task<global::com.chronoxor.simple.SimpleResponse> RequestListener(IClientListener listener, global::com.chronoxor.simple.SimpleRequest value, TimeSpan timeout)
1876          {
1877              lock (Lock)
1878              {
1879                  TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse> source = new TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>();
1880                  Task<global::com.chronoxor.simple.SimpleResponse> task = source.Task;
1881                  DateTime current = DateTime.UtcNow;
1882                  long serialized = SendListener(listener, value);
1883                  if (serialized > 0)
1884                  {
1885                      Timestamp = (current <= Timestamp) ? new DateTime(Timestamp.Ticks + 1) : current;
1886                      _requestsByIdSimpleResponse.Add(value.id, new Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>>(Timestamp, timeout, source));
1887                      if (timeout.Ticks > 0)
1888                          _requestsByTimestampSimpleResponse.Add(Timestamp, value.id);
1889                  }
1890                  else
1891                      source.SetException(new Exception("Send request failed!"));
1892                  return task;
1893              }
1894          }
1895          public Task Request(global::com.chronoxor.simple.DisconnectRequest value) { return RequestListener(this, value, TimeSpan.Zero); }
1896          public Task Request(global::com.chronoxor.simple.DisconnectRequest value, TimeSpan timeout) { return RequestListener(this, value, timeout); }
1897          public Task RequestListener(IClientListener listener, global::com.chronoxor.simple.DisconnectRequest value) { return RequestListener(listener, value, TimeSpan.Zero); }
1898          public Task RequestListener(IClientListener listener, global::com.chronoxor.simple.DisconnectRequest value, TimeSpan timeout)
1899          {
1900              TaskCompletionSource source = new TaskCompletionSource();
1901              Task task = source.Task;
1902              long serialized = SendListener(listener, value);
1903              if (serialized > 0)
1904                  source.SetResult();
1905              else
1906                  source.SetException(new Exception("Send request failed!"));
1907              return task;
1908          }
1909          public long Send(object obj) { return SendListener(this, obj); }
1910          public long SendListener(IClientListener listener, object obj)
1911          {
1912              switch (obj)
1913              {
1914                  case global::com.chronoxor.simple.SimpleRequest value when value.FBEType == global::com.chronoxor.simple.SimpleRequest.FBETypeConst: return SendListener(listener, value);
1915                  case global::com.chronoxor.simple.SimpleResponse value when value.FBEType == global::com.chronoxor.simple.SimpleResponse.FBETypeConst: return SendListener(listener, value);
1916                  case global::com.chronoxor.simple.SimpleReject value when value.FBEType == global::com.chronoxor.simple.SimpleReject.FBETypeConst: return SendListener(listener, value);
1917                  case global::com.chronoxor.simple.SimpleNotify value when value.FBEType == global::com.chronoxor.simple.SimpleNotify.FBETypeConst: return SendListener(listener, value);
1918                  case global::com.chronoxor.simple.DisconnectRequest value when value.FBEType == global::com.chronoxor.simple.DisconnectRequest.FBETypeConst: return SendListener(listener, value);
1919                  default: break;
1920              }
1921              return 0;
1922          }
1923          public long Send(global::com.chronoxor.simple.SimpleRequest value) { return SendListener(this, value); }
1924          public long SendListener(IClientListener listener, global::com.chronoxor.simple.SimpleRequest value)
1925          {
1926              long serialized = SimpleRequestSenderModel.Serialize(value);
1927              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleRequest serialization failed!");
1928              Debug.Assert(SimpleRequestSenderModel.Verify(), "com.chronoxor.simple.SimpleRequest validation failed!");
1929              if (Logging)
1930              {
1931                  string message = value.ToString();
1932                  listener.OnSendLog(message);
1933              }
1934              return SendSerialized(listener, serialized);
1935          }
1936          public long Send(global::com.chronoxor.simple.SimpleResponse value) { return SendListener(this, value); }
1937          public long SendListener(IClientListener listener, global::com.chronoxor.simple.SimpleResponse value)
1938          {
1939              long serialized = SimpleResponseSenderModel.Serialize(value);
1940              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleResponse serialization failed!");
1941              Debug.Assert(SimpleResponseSenderModel.Verify(), "com.chronoxor.simple.SimpleResponse validation failed!");
1942              if (Logging)
1943              {
1944                  string message = value.ToString();
1945                  listener.OnSendLog(message);
1946              }
1947              return SendSerialized(listener, serialized);
1948          }
1949          public long Send(global::com.chronoxor.simple.SimpleReject value) { return SendListener(this, value); }
1950          public long SendListener(IClientListener listener, global::com.chronoxor.simple.SimpleReject value)
1951          {
1952              long serialized = SimpleRejectSenderModel.Serialize(value);
1953              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleReject serialization failed!");
1954              Debug.Assert(SimpleRejectSenderModel.Verify(), "com.chronoxor.simple.SimpleReject validation failed!");
1955              if (Logging)
1956              {
1957                  string message = value.ToString();
1958                  listener.OnSendLog(message);
1959              }
1960              return SendSerialized(listener, serialized);
1961          }
1962          public long Send(global::com.chronoxor.simple.SimpleNotify value) { return SendListener(this, value); }
1963          public long SendListener(IClientListener listener, global::com.chronoxor.simple.SimpleNotify value)
1964          {
1965              long serialized = SimpleNotifySenderModel.Serialize(value);
1966              Debug.Assert((serialized > 0), "com.chronoxor.simple.SimpleNotify serialization failed!");
1967              Debug.Assert(SimpleNotifySenderModel.Verify(), "com.chronoxor.simple.SimpleNotify validation failed!");
1968              if (Logging)
1969              {
1970                  string message = value.ToString();
1971                  listener.OnSendLog(message);
1972              }
1973              return SendSerialized(listener, serialized);
1974          }
1975          public long Send(global::com.chronoxor.simple.DisconnectRequest value) { return SendListener(this, value); }
1976          public long SendListener(IClientListener listener, global::com.chronoxor.simple.DisconnectRequest value)
1977          {
1978              long serialized = DisconnectRequestSenderModel.Serialize(value);
1979              Debug.Assert((serialized > 0), "com.chronoxor.simple.DisconnectRequest serialization failed!");
1980              Debug.Assert(DisconnectRequestSenderModel.Verify(), "com.chronoxor.simple.DisconnectRequest validation failed!");
1981              if (Logging)
1982              {
1983                  string message = value.ToString();
1984                  listener.OnSendLog(message);
1985              }
1986              return SendSerialized(listener, serialized);
1987          }
1988          public bool OnReceiveResponse(global::com.chronoxor.simple.SimpleResponse response)
1989          {
1990              ReceivedResponse_SimpleResponse?.Invoke(response);
1991              lock (Lock)
1992              {
1993                  if (_requestsByIdSimpleResponse.TryGetValue(response.id, out Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>> tuple))
1994                  {
1995                      var timestamp = tuple.Item1;
1996                      var timespan = tuple.Item2;
1997                      var source = tuple.Item3;
1998                      source.SetResult(response);
1999                      _requestsByIdSimpleResponse.Remove(response.id);
2000                      _requestsByTimestampSimpleResponse.Remove(timestamp);
2001                      return true;
2002                  }
2003                  return false;
2004              }
2005          }
2006          public bool OnReceiveResponse(global::com.chronoxor.simple.SimpleRequest response) { ReceivedResponse_SimpleRequest?.Invoke(response); return false; }
2007          public bool OnReceiveResponse(global::com.chronoxor.simple.SimpleReject response) { ReceivedResponse_SimpleReject?.Invoke(response); return false; }
2008          public bool OnReceiveResponse(global::com.chronoxor.simple.SimpleNotify response) { ReceivedResponse_SimpleNotify?.Invoke(response); return false; }
2009          public bool OnReceiveResponse(global::com.chronoxor.simple.DisconnectRequest response) { ReceivedResponse_DisconnectRequest?.Invoke(response); return false; }
2010          public bool OnReceiveReject(global::com.chronoxor.simple.SimpleReject reject)
2011          {
2012              ReceivedReject_SimpleReject?.Invoke(reject);
2013              lock (Lock)
2014              {
2015                  if (_requestsByIdSimpleResponse.TryGetValue(reject.id, out Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>> tupleSimpleResponse))
2016                  {
2017                      var timestamp = tupleSimpleResponse.Item1;
2018                      var timespan = tupleSimpleResponse.Item2;
2019                      var source = tupleSimpleResponse.Item3;
2020                      source.SetException(new Exception(reject.ToString()));
2021                      _requestsByIdSimpleResponse.Remove(reject.id);
2022                      _requestsByTimestampSimpleResponse.Remove(timestamp);
2023                      return true;
2024                  }
2025                  return false;
2026              }
2027          }
2028          public bool OnReceiveReject(global::com.chronoxor.simple.SimpleRequest reject) { ReceivedReject_SimpleRequest?.Invoke(reject); return false; }
2029          public bool OnReceiveReject(global::com.chronoxor.simple.SimpleResponse reject) { ReceivedReject_SimpleResponse?.Invoke(reject); return false; }
2030          public bool OnReceiveReject(global::com.chronoxor.simple.SimpleNotify reject) { ReceivedReject_SimpleNotify?.Invoke(reject); return false; }
2031          public bool OnReceiveReject(global::com.chronoxor.simple.DisconnectRequest reject) { ReceivedReject_DisconnectRequest?.Invoke(reject); return false; }
2032          public void OnReceiveNotify(global::com.chronoxor.simple.SimpleRequest notify) { ReceivedNotify_SimpleRequest?.Invoke(notify); }
2033          public void OnReceiveNotify(global::com.chronoxor.simple.SimpleResponse notify) { ReceivedNotify_SimpleResponse?.Invoke(notify); }
2034          public void OnReceiveNotify(global::com.chronoxor.simple.SimpleReject notify) { ReceivedNotify_SimpleReject?.Invoke(notify); }
2035          public void OnReceiveNotify(global::com.chronoxor.simple.SimpleNotify notify) { ReceivedNotify_SimpleNotify?.Invoke(notify); }
2036          public void OnReceiveNotify(global::com.chronoxor.simple.DisconnectRequest notify) { ReceivedNotify_DisconnectRequest?.Invoke(notify); }
2037          public void OnReceive(global::com.chronoxor.simple.SimpleRequest value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
2038          public void OnReceive(global::com.chronoxor.simple.SimpleResponse value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
2039          public void OnReceive(global::com.chronoxor.simple.SimpleReject value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
2040          public void OnReceive(global::com.chronoxor.simple.SimpleNotify value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
2041          public void OnReceive(global::com.chronoxor.simple.DisconnectRequest value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
2042          internal override void ResetRequests()
2043          {
2044              base.ResetRequests();
2045              foreach(var request in _requestsByIdSimpleResponse)
2046                  request.Value.Item3.SetException(new Exception("Reset client!"));
2047              _requestsByIdSimpleResponse.Clear();
2048              _requestsByTimestampSimpleResponse.Clear();
2049          }
2050          internal override void WatchdogRequests(DateTime utc)
2051          {
2052              base.WatchdogRequests(utc);
2053              while (_requestsByTimestampSimpleResponse.Count > 0)
2054              {
2055                  var request = _requestsByTimestampSimpleResponse.First();
2056                  Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.chronoxor.simple.SimpleResponse>> tuple;
2057                  _requestsByIdSimpleResponse.TryGetValue(request.Value, out tuple);
2058                  var timestamp = tuple.Item1;
2059                  var timespan = tuple.Item2;
2060                  if ((timestamp + timespan) <= utc)
2061                  {
2062                      var source = tuple.Item3;
2063                      source.SetException(new Exception("Timeout!"));
2064                      _requestsByIdSimpleResponse.Remove(request.Value);
2065                      _requestsByTimestampSimpleResponse.Remove(timestamp);
2066                      continue;
2067                  }
2068                  else
2069                      break;
2070              }
2071          }
2072          internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
2073          internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
2074          {
2075              switch (type)
2076              {
2077                  case SimpleRequestModel.FBETypeConst:
2078                  {
2079                      SimpleRequestReceiverModel.Attach(buffer, offset);
2080                      Debug.Assert(SimpleRequestReceiverModel.Verify(), "com.chronoxor.simple.SimpleRequest validation failed!");
2081                      long deserialized = SimpleRequestReceiverModel.Deserialize(out SimpleRequestReceiverValue);
2082                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleRequest deserialization failed!");
2083                      if (Logging)
2084                      {
2085                          string message = SimpleRequestReceiverValue.ToString();
2086                          listener.OnReceiveLog(message);
2087                      }
2088                      listener.OnReceive(SimpleRequestReceiverValue);
2089                      return true;
2090                  }
2091                  case SimpleResponseModel.FBETypeConst:
2092                  {
2093                      SimpleResponseReceiverModel.Attach(buffer, offset);
2094                      Debug.Assert(SimpleResponseReceiverModel.Verify(), "com.chronoxor.simple.SimpleResponse validation failed!");
2095                      long deserialized = SimpleResponseReceiverModel.Deserialize(out SimpleResponseReceiverValue);
2096                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleResponse deserialization failed!");
2097                      if (Logging)
2098                      {
2099                          string message = SimpleResponseReceiverValue.ToString();
2100                          listener.OnReceiveLog(message);
2101                      }
2102                      listener.OnReceive(SimpleResponseReceiverValue);
2103                      return true;
2104                  }
2105                  case SimpleRejectModel.FBETypeConst:
2106                  {
2107                      SimpleRejectReceiverModel.Attach(buffer, offset);
2108                      Debug.Assert(SimpleRejectReceiverModel.Verify(), "com.chronoxor.simple.SimpleReject validation failed!");
2109                      long deserialized = SimpleRejectReceiverModel.Deserialize(out SimpleRejectReceiverValue);
2110                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleReject deserialization failed!");
2111                      if (Logging)
2112                      {
2113                          string message = SimpleRejectReceiverValue.ToString();
2114                          listener.OnReceiveLog(message);
2115                      }
2116                      listener.OnReceive(SimpleRejectReceiverValue);
2117                      return true;
2118                  }
2119                  case SimpleNotifyModel.FBETypeConst:
2120                  {
2121                      SimpleNotifyReceiverModel.Attach(buffer, offset);
2122                      Debug.Assert(SimpleNotifyReceiverModel.Verify(), "com.chronoxor.simple.SimpleNotify validation failed!");
2123                      long deserialized = SimpleNotifyReceiverModel.Deserialize(out SimpleNotifyReceiverValue);
2124                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.SimpleNotify deserialization failed!");
2125                      if (Logging)
2126                      {
2127                          string message = SimpleNotifyReceiverValue.ToString();
2128                          listener.OnReceiveLog(message);
2129                      }
2130                      listener.OnReceive(SimpleNotifyReceiverValue);
2131                      return true;
2132                  }
2133                  case DisconnectRequestModel.FBETypeConst:
2134                  {
2135                      DisconnectRequestReceiverModel.Attach(buffer, offset);
2136                      Debug.Assert(DisconnectRequestReceiverModel.Verify(), "com.chronoxor.simple.DisconnectRequest validation failed!");
2137                      long deserialized = DisconnectRequestReceiverModel.Deserialize(out DisconnectRequestReceiverValue);
2138                      Debug.Assert((deserialized > 0), "com.chronoxor.simple.DisconnectRequest deserialization failed!");
2139                      if (Logging)
2140                      {
2141                          string message = DisconnectRequestReceiverValue.ToString();
2142                          listener.OnReceiveLog(message);
2143                      }
2144                      listener.OnReceive(DisconnectRequestReceiverValue);
2145                      return true;
2146                  }
2147                  default: break;
2148              }
2149              return false;
2150          }
2151          public delegate void ReceiveResponseHandler_SimpleResponse(global::com.chronoxor.simple.SimpleResponse response);
2152          public event ReceiveResponseHandler_SimpleResponse ReceivedResponse_SimpleResponse = (response) => {};
2153          public delegate void ReceiveResponseHandler_SimpleRequest(global::com.chronoxor.simple.SimpleRequest response);
2154          public event ReceiveResponseHandler_SimpleRequest ReceivedResponse_SimpleRequest = (response) => {};
2155          public delegate void ReceiveResponseHandler_SimpleReject(global::com.chronoxor.simple.SimpleReject response);
2156          public event ReceiveResponseHandler_SimpleReject ReceivedResponse_SimpleReject = (response) => {};
2157          public delegate void ReceiveResponseHandler_SimpleNotify(global::com.chronoxor.simple.SimpleNotify response);
2158          public event ReceiveResponseHandler_SimpleNotify ReceivedResponse_SimpleNotify = (response) => {};
2159          public delegate void ReceiveResponseHandler_DisconnectRequest(global::com.chronoxor.simple.DisconnectRequest response);
2160          public event ReceiveResponseHandler_DisconnectRequest ReceivedResponse_DisconnectRequest = (response) => {};
2161          public delegate void ReceiveRejectHandler_SimpleReject(global::com.chronoxor.simple.SimpleReject reject);
2162          public event ReceiveRejectHandler_SimpleReject ReceivedReject_SimpleReject = (reject) => {};
2163          public delegate void ReceiveRejectHandler_SimpleRequest(global::com.chronoxor.simple.SimpleRequest reject);
2164          public event ReceiveRejectHandler_SimpleRequest ReceivedReject_SimpleRequest = (reject) => {};
2165          public delegate void ReceiveRejectHandler_SimpleResponse(global::com.chronoxor.simple.SimpleResponse reject);
2166          public event ReceiveRejectHandler_SimpleResponse ReceivedReject_SimpleResponse = (reject) => {};
2167          public delegate void ReceiveRejectHandler_SimpleNotify(global::com.chronoxor.simple.SimpleNotify reject);
2168          public event ReceiveRejectHandler_SimpleNotify ReceivedReject_SimpleNotify = (reject) => {};
2169          public delegate void ReceiveRejectHandler_DisconnectRequest(global::com.chronoxor.simple.DisconnectRequest reject);
2170          public event ReceiveRejectHandler_DisconnectRequest ReceivedReject_DisconnectRequest = (reject) => {};
2171          public delegate void ReceiveNotifyHandler_SimpleRequest(global::com.chronoxor.simple.SimpleRequest notify);
2172          public event ReceiveNotifyHandler_SimpleRequest ReceivedNotify_SimpleRequest = (notify) => {};
2173          public delegate void ReceiveNotifyHandler_SimpleResponse(global::com.chronoxor.simple.SimpleResponse notify);
2174          public event ReceiveNotifyHandler_SimpleResponse ReceivedNotify_SimpleResponse = (notify) => {};
2175          public delegate void ReceiveNotifyHandler_SimpleReject(global::com.chronoxor.simple.SimpleReject notify);
2176          public event ReceiveNotifyHandler_SimpleReject ReceivedNotify_SimpleReject = (notify) => {};
2177          public delegate void ReceiveNotifyHandler_SimpleNotify(global::com.chronoxor.simple.SimpleNotify notify);
2178          public event ReceiveNotifyHandler_SimpleNotify ReceivedNotify_SimpleNotify = (notify) => {};
2179          public delegate void ReceiveNotifyHandler_DisconnectRequest(global::com.chronoxor.simple.DisconnectRequest notify);
2180          public event ReceiveNotifyHandler_DisconnectRequest ReceivedNotify_DisconnectRequest = (notify) => {};
2181      }
2182  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-TweenSettingsExtensions.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-com.chronoxor.simple.cs</div>
                </div>
                <div class="column column_space"><pre><code>52              if (t == null || !t.active) return t;
53              t.intId = intId;
54              return t;
55          }
56          public static T SetLink<T>(this T t, GameObject gameObject) where T : Tween
57          {
58              if (t == null || !t.active || t.isSequenced || gameObject == null) return t;
</pre></code></div>
                <div class="column column_space"><pre><code>775                  return false;
776              fbeCurrentSize += Error.FBESize;
777              return true;
778          }
779          public long GetBegin()
780          {
781              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
782                  return 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    