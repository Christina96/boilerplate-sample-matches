
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GeoJSONHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.ObjectModel;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GeoJSON.Net;
7  using GeoJSON.Net.CoordinateReferenceSystem;
8  using GeoJSON.Net.Geometry;
9  using Npgsql.BackendMessages;
10  using Npgsql.Internal;
11  using Npgsql.Internal.TypeHandling;
12  using Npgsql.PostgresTypes;
13  namespace Npgsql.GeoJSON.Internal;
14  sealed partial class GeoJsonHandler : NpgsqlTypeHandler&lt;GeoJSONObject&gt;,
15      INpgsqlTypeHandler&lt;Point&gt;, INpgsqlTypeHandler&lt;MultiPoint&gt;,
16      INpgsqlTypeHandler&lt;Polygon&gt;, INpgsqlTypeHandler&lt;MultiPolygon&gt;,
17      INpgsqlTypeHandler&lt;LineString&gt;, INpgsqlTypeHandler&lt;MultiLineString&gt;,
18      INpgsqlTypeHandler&lt;GeometryCollection&gt;,
19      INpgsqlTypeHandler&lt;IGeoJSONObject&gt;,
20      INpgsqlTypeHandler&lt;IGeometryObject&gt;
21  {
22      readonly GeoJSONOptions _options;
23      readonly CrsMap _crsMap;
24      readonly ConcurrentDictionary&lt;int, NamedCRS&gt; _cachedCrs = new();
25      internal GeoJsonHandler(PostgresType postgresType, GeoJSONOptions options, CrsMap crsMap)
26          : base(postgresType)
27      {
28          _options = options;
29          _crsMap = crsMap;
30      }
31      GeoJSONOptions CrsType =&gt; _options &amp; (GeoJSONOptions.ShortCRS | GeoJSONOptions.LongCRS);
32      bool BoundingBox =&gt; (_options &amp; GeoJSONOptions.BoundingBox) != 0;
33      static bool HasSrid(EwkbGeometryType type)
34          =&gt; (type &amp; EwkbGeometryType.HasSrid) != 0;
35      static bool HasZ(EwkbGeometryType type)
36          =&gt; (type &amp; EwkbGeometryType.HasZ) != 0;
37      static bool HasM(EwkbGeometryType type)
38          =&gt; (type &amp; EwkbGeometryType.HasM) != 0;
39      static bool HasZ(IPosition coordinates)
40          =&gt; coordinates.Altitude.HasValue;
41      const int SizeOfLength = sizeof(int);
42      const int SizeOfHeader = sizeof(byte) + sizeof(EwkbGeometryType);
43      const int SizeOfHeaderWithLength = SizeOfHeader + SizeOfLength;
44      const int SizeOfPoint2D = 2 * sizeof(double);
45      const int SizeOfPoint3D = 3 * sizeof(double);
46      static int SizeOfPoint(bool hasZ)
47          =&gt; hasZ ? SizeOfPoint3D : SizeOfPoint2D;
48      static int SizeOfPoint(EwkbGeometryType type)
49      {
50          var size = SizeOfPoint2D;
51          if (HasZ(type))
52              size += sizeof(double);
53          if (HasM(type))
54              size += sizeof(double);
55          return size;
56      }
57      #region Throw
58      static Exception UnknownPostGisType()
59          =&gt; throw new InvalidOperationException(&quot;Invalid PostGIS type&quot;);
60      static Exception AllOrNoneCoordiantesMustHaveZ(NpgsqlParameter? parameter, string typeName)
61          =&gt; parameter is null
62              ? new ArgumentException($&quot;The Z coordinate must be specified for all or none elements of {typeName}&quot;)
63              : new ArgumentException($&quot;The Z coordinate must be specified for all or none elements of {typeName} in the {parameter.ParameterName} parameter&quot;, parameter.ParameterName);
64      #endregion
65      #region Read
66      public override ValueTask&lt;GeoJSONObject&gt; Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription = null)
67          =&gt; ReadGeometry(buf, async);
68      async ValueTask&lt;Point&gt; INpgsqlTypeHandler&lt;Point&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
69          =&gt; (Point)await ReadGeometry(buf, async);
70      async ValueTask&lt;LineString&gt; INpgsqlTypeHandler&lt;LineString&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
71          =&gt; (LineString)await ReadGeometry(buf, async);
72      async ValueTask&lt;Polygon&gt; INpgsqlTypeHandler&lt;Polygon&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
73          =&gt; (Polygon)await ReadGeometry(buf, async);
74      async ValueTask&lt;MultiPoint&gt; INpgsqlTypeHandler&lt;MultiPoint&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
75          =&gt; (MultiPoint)await ReadGeometry(buf, async);
76      async ValueTask&lt;MultiLineString&gt; INpgsqlTypeHandler&lt;MultiLineString&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
77          =&gt; (MultiLineString)await ReadGeometry(buf, async);
78      async ValueTask&lt;MultiPolygon&gt; INpgsqlTypeHandler&lt;MultiPolygon&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
79          =&gt; (MultiPolygon)await ReadGeometry(buf, async);
80      async ValueTask&lt;GeometryCollection&gt; INpgsqlTypeHandler&lt;GeometryCollection&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
81          =&gt; (GeometryCollection)await ReadGeometry(buf, async);
82      async ValueTask&lt;IGeoJSONObject&gt; INpgsqlTypeHandler&lt;IGeoJSONObject&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
83          =&gt; await ReadGeometry(buf, async);
84      async ValueTask&lt;IGeometryObject&gt; INpgsqlTypeHandler&lt;IGeometryObject&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
85          =&gt; (IGeometryObject)await ReadGeometry(buf, async);
86      async ValueTask&lt;GeoJSONObject&gt; ReadGeometry(NpgsqlReadBuffer buf, bool async)
87      {
88          var boundingBox = BoundingBox ? new BoundingBoxBuilder() : null;
89          var geometry = await ReadGeometryCore(buf, async, boundingBox);
90          geometry.BoundingBoxes = boundingBox?.Build();
91          return geometry;
92      }
93      async ValueTask&lt;GeoJSONObject&gt; ReadGeometryCore(NpgsqlReadBuffer buf, bool async, BoundingBoxBuilder? boundingBox)
94      {
95          await buf.Ensure(SizeOfHeader, async);
96          var littleEndian = buf.ReadByte() &gt; 0;
97          var type = (EwkbGeometryType)buf.ReadUInt32(littleEndian);
98          GeoJSONObject geometry;
99          NamedCRS? crs = null;
100          if (HasSrid(type))
101          {
102              await buf.Ensure(4, async);
103              crs = GetCrs(buf.ReadInt32(littleEndian));
104          }
105          switch (type &amp; EwkbGeometryType.BaseType)
106          {
107          case EwkbGeometryType.Point:
108          {
109              await buf.Ensure(SizeOfPoint(type), async);
110              var position = ReadPosition(buf, type, littleEndian);
111              boundingBox?.Accumulate(position);
112              geometry = new Point(position);
113              break;
114          }
115          case EwkbGeometryType.LineString:
116          {
117              await buf.Ensure(SizeOfLength, async);
118              var coordinates = new Position[buf.ReadInt32(littleEndian)];
119              for (var i = 0; i &lt; coordinates.Length; ++i)
120              {
121                  await buf.Ensure(SizeOfPoint(type), async);
122                  var position = ReadPosition(buf, type, littleEndian);
123                  boundingBox?.Accumulate(position);
124                  coordinates[i] = position;
125              }
126              geometry = new LineString(coordinates);
127              break;
128          }
129          case EwkbGeometryType.Polygon:
130          {
131              await buf.Ensure(SizeOfLength, async);
132              var lines = new LineString[buf.ReadInt32(littleEndian)];
133              for (var i = 0; i &lt; lines.Length; ++i)
134              {
135                  await buf.Ensure(SizeOfLength, async);
136                  var coordinates = new Position[buf.ReadInt32(littleEndian)];
137                  for (var j = 0; j &lt; coordinates.Length; ++j)
138                  {
139                      await buf.Ensure(SizeOfPoint(type), async);
140                      var position = ReadPosition(buf, type, littleEndian);
141                      boundingBox?.Accumulate(position);
142                      coordinates[j] = position;
143                  }
144                  lines[i] = new LineString(coordinates);
145              }
146              geometry = new Polygon(lines);
147              break;
148          }
149          case EwkbGeometryType.MultiPoint:
150          {
151              await buf.Ensure(SizeOfLength, async);
152              var points = new Point[buf.ReadInt32(littleEndian)];
153              for (var i = 0; i &lt; points.Length; ++i)
154              {
155                  await buf.Ensure(SizeOfHeader + SizeOfPoint(type), async);
156                  await buf.Skip(SizeOfHeader, async);
157                  var position = ReadPosition(buf, type, littleEndian);
158                  boundingBox?.Accumulate(position);
159                  points[i] = new Point(position);
160              }
161              geometry = new MultiPoint(points);
162              break;
163          }
164          case EwkbGeometryType.MultiLineString:
165          {
166              await buf.Ensure(SizeOfLength, async);
167              var lines = new LineString[buf.ReadInt32(littleEndian)];
168              for (var i = 0; i &lt; lines.Length; ++i)
169              {
170                  await buf.Ensure(SizeOfHeaderWithLength, async);
171                  await buf.Skip(SizeOfHeader, async);
172                  var coordinates = new Position[buf.ReadInt32(littleEndian)];
173                  for (var j = 0; j &lt; coordinates.Length; ++j)
174                  {
175                      await buf.Ensure(SizeOfPoint(type), async);
176                      var position = ReadPosition(buf, type, littleEndian);
177                      boundingBox?.Accumulate(position);
178                      coordinates[j] = position;
179                  }
180                  lines[i] = new LineString(coordinates);
181              }
182              geometry = new MultiLineString(lines);
183              break;
184          }
185          case EwkbGeometryType.MultiPolygon:
186          {
187              await buf.Ensure(SizeOfLength, async);
188              var polygons = new Polygon[buf.ReadInt32(littleEndian)];
189              for (var i = 0; i &lt; polygons.Length; ++i)
190              {
191                  await buf.Ensure(SizeOfHeaderWithLength, async);
192                  await buf.Skip(SizeOfHeader, async);
193                  var lines = new LineString[buf.ReadInt32(littleEndian)];
194                  for (var j = 0; j &lt; lines.Length; ++j)
195                  {
196                      await buf.Ensure(SizeOfLength, async);
197                      var coordinates = new Position[buf.ReadInt32(littleEndian)];
198                      for (var k = 0; k &lt; coordinates.Length; ++k)
199                      {
200                          await buf.Ensure(SizeOfPoint(type), async);
201                          var position = ReadPosition(buf, type, littleEndian);
202                          boundingBox?.Accumulate(position);
203                          coordinates[k] = position;
204                      }
205                      lines[j] = new LineString(coordinates);
206                  }
207                  polygons[i] = new Polygon(lines);
208              }
209              geometry = new MultiPolygon(polygons);
210              break;
211          }
212          case EwkbGeometryType.GeometryCollection:
213          {
214              await buf.Ensure(SizeOfLength, async);
215              var elements = new IGeometryObject[buf.ReadInt32(littleEndian)];
216              for (var i = 0; i &lt; elements.Length; ++i)
217                  elements[i] = (IGeometryObject)await ReadGeometryCore(buf, async, boundingBox);
218              geometry = new GeometryCollection(elements);
219              break;
220          }
221          default:
222              throw UnknownPostGisType();
223          }
224          geometry.CRS = crs;
225          return geometry;
226      }
227      static Position ReadPosition(NpgsqlReadBuffer buf, EwkbGeometryType type, bool littleEndian)
228      {
229          var position = new Position(
230              longitude: buf.ReadDouble(littleEndian),
231              latitude: buf.ReadDouble(littleEndian),
232              altitude: HasZ(type) ? buf.ReadDouble() : (double?)null);
233          if (HasM(type)) buf.ReadDouble(littleEndian);
234          return position;
235      }
236      #endregion
237      #region Write
238      public override int ValidateAndGetLength(GeoJSONObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
239          =&gt; value.Type switch
240          {
241              GeoJSONObjectType.Point              =&gt; ValidateAndGetLength((Point)value, ref lengthCache, parameter),
242              GeoJSONObjectType.LineString         =&gt; ValidateAndGetLength((LineString)value, ref lengthCache, parameter),
243              GeoJSONObjectType.Polygon            =&gt; ValidateAndGetLength((Polygon)value, ref lengthCache, parameter),
244              GeoJSONObjectType.MultiPoint         =&gt; ValidateAndGetLength((MultiPoint)value, ref lengthCache, parameter),
245              GeoJSONObjectType.MultiLineString    =&gt; ValidateAndGetLength((MultiLineString)value, ref lengthCache, parameter),
246              GeoJSONObjectType.MultiPolygon       =&gt; ValidateAndGetLength((MultiPolygon)value, ref lengthCache, parameter),
247              GeoJSONObjectType.GeometryCollection =&gt; ValidateAndGetLength((GeometryCollection)value, ref lengthCache, parameter),
248              _                                    =&gt; throw UnknownPostGisType()
249          };
250      public int ValidateAndGetLength(Point value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
251      {
252          var length = SizeOfHeader + SizeOfPoint(HasZ(value.Coordinates));
253          if (GetSrid(value.CRS) != 0)
254              length += sizeof(int);
255          return length;
256      }
257      public int ValidateAndGetLength(LineString value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
258      {
259          var coordinates = value.Coordinates;
260          if (NotValid(coordinates, out var hasZ))
261              throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(LineString));
262          var length = SizeOfHeaderWithLength + coordinates.Count * SizeOfPoint(hasZ);
263          if (GetSrid(value.CRS) != 0)
264              length += sizeof(int);
265          return length;
266      }
267      public int ValidateAndGetLength(Polygon value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
268      {
269          var lines = value.Coordinates;
270          var length = SizeOfHeaderWithLength + SizeOfLength * lines.Count;
271          if (GetSrid(value.CRS) != 0)
272              length += sizeof(int);
273          var hasZ = false;
274          for (var i = 0; i &lt; lines.Count; ++i)
275          {
276              var coordinates = lines[i].Coordinates;
277              if (NotValid(coordinates, out var lineHasZ))
278                  throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(Polygon));
279              if (hasZ != lineHasZ)
280              {
281                  if (i == 0) hasZ = lineHasZ;
282                  else throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(LineString));
283              }
284              length += coordinates.Count * SizeOfPoint(hasZ);
285          }
286          return length;
287      }
288      static bool NotValid(ReadOnlyCollection&lt;IPosition&gt; coordinates, out bool hasZ)
289      {
290          if (coordinates.Count == 0)
291              hasZ = false;
292          else
293          {
294              hasZ = HasZ(coordinates[0]);
295              for (var i = 1; i &lt; coordinates.Count; ++i)
296                  if (HasZ(coordinates[i]) != hasZ) return true;
297          }
298          return false;
299      }
300      public int ValidateAndGetLength(MultiPoint value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
301      {
302          var length = SizeOfHeaderWithLength;
303          if (GetSrid(value.CRS) != 0)
304              length += sizeof(int);
305          var coordinates = value.Coordinates;
306          for (var i = 0; i &lt; coordinates.Count; ++i)
307              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
308          return length;
309      }
310      public int ValidateAndGetLength(MultiLineString value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
311      {
312          var length = SizeOfHeaderWithLength;
313          if (GetSrid(value.CRS) != 0)
314              length += sizeof(int);
315          var coordinates = value.Coordinates;
316          for (var i = 0; i &lt; coordinates.Count; ++i)
317              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
318          return length;
319      }
320      public int ValidateAndGetLength(MultiPolygon value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
321      {
322          var length = SizeOfHeaderWithLength;
323          if (GetSrid(value.CRS) != 0)
324              length += sizeof(int);
325          var coordinates = value.Coordinates;
326          for (var i = 0; i &lt; coordinates.Count; ++i)
327              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
328          return length;
329      }
330      public int ValidateAndGetLength(GeometryCollection value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
331      {
332          var length = SizeOfHeaderWithLength;
333          if (GetSrid(value.CRS) != 0)
334              length += sizeof(int);
335          var geometries = value.Geometries;
336          for (var i = 0; i &lt; geometries.Count; ++i)
337              length += ValidateAndGetLength((GeoJSONObject)geometries[i], ref lengthCache, parameter);
338          return length;
339      }
340      int INpgsqlTypeHandler&lt;IGeoJSONObject&gt;.ValidateAndGetLength(IGeoJSONObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
341          =&gt; ValidateAndGetLength((GeoJSONObject)value, ref lengthCache, parameter);
342      int INpgsqlTypeHandler&lt;IGeometryObject&gt;.ValidateAndGetLength(IGeometryObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
343          =&gt; ValidateAndGetLength((GeoJSONObject)value, ref lengthCache, parameter);
344      public override Task Write(GeoJSONObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
345          =&gt; value.Type switch
346          {
347              GeoJSONObjectType.Point              =&gt; Write((Point)value, buf, lengthCache, parameter, async, cancellationToken),
348              GeoJSONObjectType.LineString         =&gt; Write((LineString)value, buf, lengthCache, parameter, async, cancellationToken),
349              GeoJSONObjectType.Polygon            =&gt; Write((Polygon)value, buf, lengthCache, parameter, async, cancellationToken),
350              GeoJSONObjectType.MultiPoint         =&gt; Write((MultiPoint)value, buf, lengthCache, parameter, async, cancellationToken),
351              GeoJSONObjectType.MultiLineString    =&gt; Write((MultiLineString)value, buf, lengthCache, parameter, async, cancellationToken),
352              GeoJSONObjectType.MultiPolygon       =&gt; Write((MultiPolygon)value, buf, lengthCache, parameter, async, cancellationToken),
353              GeoJSONObjectType.GeometryCollection =&gt; Write((GeometryCollection)value, buf, lengthCache, parameter, async, cancellationToken),
354              _                                    =&gt; throw UnknownPostGisType()
355          };
356      public async Task Write(Point value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
357      {
358          var type = EwkbGeometryType.Point;
359          var size = SizeOfHeader;
360          var srid = GetSrid(value.CRS);
361          if (srid != 0)
362          {
363              size += sizeof(int);
<span onclick='openModal()' class='match'>364              type |= EwkbGeometryType.HasSrid;
365          }
366          if (buf.WriteSpaceLeft &lt; size)
367              await buf.Flush(async, cancellationToken);
368          buf.WriteByte(0); 
</span>369          buf.WriteInt32((int)type);
370          if (srid != 0)
371              buf.WriteInt32(srid);
372          await WritePosition(value.Coordinates, buf, async, cancellationToken);
373      }
374      public async Task Write(LineString value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
375      {
376          var type = EwkbGeometryType.LineString;
377          var size = SizeOfHeaderWithLength;
378          var srid = GetSrid(value.CRS);
379          if (srid != 0)
380          {
381              size += sizeof(int);
382              type |= EwkbGeometryType.HasSrid;
383          }
384          if (buf.WriteSpaceLeft &lt; size)
385              await buf.Flush(async, cancellationToken);
386          var coordinates = value.Coordinates;
387          buf.WriteByte(0); 
388          buf.WriteInt32((int)type);
389          buf.WriteInt32(coordinates.Count);
390          if (srid != 0)
391              buf.WriteInt32(srid);
392          for (var i = 0; i &lt; coordinates.Count; ++i)
393              await WritePosition(coordinates[i], buf, async, cancellationToken);
394      }
395      public async Task Write(Polygon value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
396      {
397          var type = EwkbGeometryType.Polygon;
398          var size = SizeOfHeaderWithLength;
399          var srid = GetSrid(value.CRS);
400          if (srid != 0)
401          {
402              size += sizeof(int);
403              type |= EwkbGeometryType.HasSrid;
404          }
405          if (buf.WriteSpaceLeft &lt; size)
406              await buf.Flush(async, cancellationToken);
407          var lines = value.Coordinates;
408          buf.WriteByte(0); 
409          buf.WriteInt32((int)type);
410          buf.WriteInt32(lines.Count);
411          if (srid != 0)
412              buf.WriteInt32(srid);
413          for (var i = 0; i &lt; lines.Count; ++i)
414          {
415              if (buf.WriteSpaceLeft &lt; SizeOfLength)
416                  await buf.Flush(async, cancellationToken);
417              var coordinates = lines[i].Coordinates;
418              buf.WriteInt32(coordinates.Count);
419              for (var j = 0; j &lt; coordinates.Count; ++j)
420                  await WritePosition(coordinates[j], buf, async, cancellationToken);
421          }
422      }
423      public async Task Write(MultiPoint value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
424      {
425          var type = EwkbGeometryType.MultiPoint;
426          var size = SizeOfHeaderWithLength;
427          var srid = GetSrid(value.CRS);
428          if (srid != 0)
429          {
430              size += sizeof(int);
431              type |= EwkbGeometryType.HasSrid;
432          }
433          if (buf.WriteSpaceLeft &lt; size)
434              await buf.Flush(async, cancellationToken);
435          var coordinates = value.Coordinates;
436          buf.WriteByte(0); 
437          buf.WriteInt32((int)type);
438          buf.WriteInt32(coordinates.Count);
439          if (srid != 0)
440              buf.WriteInt32(srid);
441          for (var i = 0; i &lt; coordinates.Count; ++i)
442              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
443      }
444      public async Task Write(MultiLineString value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
445      {
446          var type = EwkbGeometryType.MultiLineString;
447          var size = SizeOfHeaderWithLength;
448          var srid = GetSrid(value.CRS);
449          if (srid != 0)
450          {
451              size += sizeof(int);
452              type |= EwkbGeometryType.HasSrid;
453          }
454          if (buf.WriteSpaceLeft &lt; size)
455              await buf.Flush(async, cancellationToken);
456          var coordinates = value.Coordinates;
457          buf.WriteByte(0); 
458          buf.WriteInt32((int)type);
459          buf.WriteInt32(coordinates.Count);
460          if (srid != 0)
461              buf.WriteInt32(srid);
462          for (var i = 0; i &lt; coordinates.Count; ++i)
463              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
464      }
465      public async Task Write(MultiPolygon value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
466      {
467          var type = EwkbGeometryType.MultiPolygon;
468          var size = SizeOfHeaderWithLength;
469          var srid = GetSrid(value.CRS);
470          if (srid != 0)
471          {
472              size += sizeof(int);
473              type |= EwkbGeometryType.HasSrid;
474          }
475          if (buf.WriteSpaceLeft &lt; size)
476              await buf.Flush(async, cancellationToken);
477          var coordinates = value.Coordinates;
478          buf.WriteByte(0); 
479          buf.WriteInt32((int)type);
480          buf.WriteInt32(coordinates.Count);
481          if (srid != 0)
482              buf.WriteInt32(srid);
483          for (var i = 0; i &lt; coordinates.Count; ++i)
484              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
485      }
486      public async Task Write(GeometryCollection value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
487      {
488          var type = EwkbGeometryType.GeometryCollection;
489          var size = SizeOfHeaderWithLength;
490          var srid = GetSrid(value.CRS);
491          if (srid != 0)
492          {
493              size += sizeof(int);
494              type |= EwkbGeometryType.HasSrid;
495          }
496          if (buf.WriteSpaceLeft &lt; size)
497              await buf.Flush(async, cancellationToken);
498          var geometries = value.Geometries;
499          buf.WriteByte(0); 
500          buf.WriteInt32((int)type);
501          buf.WriteInt32(geometries.Count);
502          if (srid != 0)
503              buf.WriteInt32(srid);
504          for (var i = 0; i &lt; geometries.Count; ++i)
505              await Write((GeoJSONObject) geometries[i], buf, lengthCache, parameter, async, cancellationToken);
506      }
507      Task INpgsqlTypeHandler&lt;IGeoJSONObject&gt;.Write(IGeoJSONObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
508          =&gt; Write((GeoJSONObject)value, buf, lengthCache, parameter, async, cancellationToken);
509      Task INpgsqlTypeHandler&lt;IGeometryObject&gt;.Write(IGeometryObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
510          =&gt; Write((GeoJSONObject)value, buf, lengthCache, parameter, async, cancellationToken);
511      static async Task WritePosition(IPosition coordinate, NpgsqlWriteBuffer buf, bool async, CancellationToken cancellationToken = default)
512      {
513          var altitude = coordinate.Altitude;
514          if (buf.WriteSpaceLeft &lt; SizeOfPoint(altitude.HasValue))
515              await buf.Flush(async, cancellationToken);
516          buf.WriteDouble(coordinate.Longitude);
517          buf.WriteDouble(coordinate.Latitude);
518          if (altitude.HasValue)
519              buf.WriteDouble(altitude.Value);
520      }
521      #endregion
522      #region Crs
523      NamedCRS? GetCrs(int srid)
524      {
525          var crsType = CrsType;
526          if (crsType == GeoJSONOptions.None)
527              return null;
528  #if NETSTANDARD2_0
529          return _cachedCrs.GetOrAdd(srid, srid =&gt;
530          {
531              var authority = _crsMap.GetAuthority(srid);
532              return authority is null
533                  ? throw new InvalidOperationException($&quot;SRID {srid} unknown in spatial_ref_sys table&quot;)
534                  : new NamedCRS(crsType == GeoJSONOptions.LongCRS
535                      ? &quot;urn:ogc:def:crs:&quot; + authority + &quot;::&quot; + srid
536                      : authority + &quot;:&quot; + srid);
537          });
538  #else
539          return _cachedCrs.GetOrAdd(srid, static (srid, me) =&gt;
540          {
541              var authority = me._crsMap.GetAuthority(srid);
542              return authority is null
543                  ? throw new InvalidOperationException($&quot;SRID {srid} unknown in spatial_ref_sys table&quot;)
544                  : new NamedCRS(me.CrsType == GeoJSONOptions.LongCRS
545                      ? &quot;urn:ogc:def:crs:&quot; + authority + &quot;::&quot; + srid
546                      : authority + &quot;:&quot; + srid);
547          }, this);
548  #endif
549      }
550      static int GetSrid(ICRSObject crs)
551      {
552          if (crs == null || crs is UnspecifiedCRS)
553              return 0;
554          var namedCrs = crs as NamedCRS;
555          if (namedCrs == null)
556              throw new NotSupportedException(&quot;The LinkedCRS class isn&#x27;t supported&quot;);
557          if (namedCrs.Properties.TryGetValue(&quot;name&quot;, out var value) &amp;&amp; value != null)
558          {
559              var name = value.ToString()!;
560              if (string.Equals(name, &quot;urn:ogc:def:crs:OGC::CRS84&quot;, StringComparison.Ordinal))
561                  return 4326;
562              var index = name.LastIndexOf(&#x27;:&#x27;);
563              if (index != -1 &amp;&amp; int.TryParse(name.Substring(index + 1), out var srid))
564                  return srid;
565              throw new FormatException(&quot;The specified CRS isn&#x27;t properly named&quot;);
566          }
567          return 0;
568      }
569      #endregion
570  }
571  [Flags]
572  enum EwkbGeometryType : uint
573  {
574      Point = 1,
575      LineString = 2,
576      Polygon = 3,
577      MultiPoint = 4,
578      MultiLineString = 5,
579      MultiPolygon = 6,
580      GeometryCollection = 7,
581      BaseType = Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection,
582      HasSrid = 0x20000000,
583      HasM = 0x40000000,
584      HasZ = 0x80000000
585  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GeoJSONHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.ObjectModel;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GeoJSON.Net;
7  using GeoJSON.Net.CoordinateReferenceSystem;
8  using GeoJSON.Net.Geometry;
9  using Npgsql.BackendMessages;
10  using Npgsql.Internal;
11  using Npgsql.Internal.TypeHandling;
12  using Npgsql.PostgresTypes;
13  namespace Npgsql.GeoJSON.Internal;
14  sealed partial class GeoJsonHandler : NpgsqlTypeHandler&lt;GeoJSONObject&gt;,
15      INpgsqlTypeHandler&lt;Point&gt;, INpgsqlTypeHandler&lt;MultiPoint&gt;,
16      INpgsqlTypeHandler&lt;Polygon&gt;, INpgsqlTypeHandler&lt;MultiPolygon&gt;,
17      INpgsqlTypeHandler&lt;LineString&gt;, INpgsqlTypeHandler&lt;MultiLineString&gt;,
18      INpgsqlTypeHandler&lt;GeometryCollection&gt;,
19      INpgsqlTypeHandler&lt;IGeoJSONObject&gt;,
20      INpgsqlTypeHandler&lt;IGeometryObject&gt;
21  {
22      readonly GeoJSONOptions _options;
23      readonly CrsMap _crsMap;
24      readonly ConcurrentDictionary&lt;int, NamedCRS&gt; _cachedCrs = new();
25      internal GeoJsonHandler(PostgresType postgresType, GeoJSONOptions options, CrsMap crsMap)
26          : base(postgresType)
27      {
28          _options = options;
29          _crsMap = crsMap;
30      }
31      GeoJSONOptions CrsType =&gt; _options &amp; (GeoJSONOptions.ShortCRS | GeoJSONOptions.LongCRS);
32      bool BoundingBox =&gt; (_options &amp; GeoJSONOptions.BoundingBox) != 0;
33      static bool HasSrid(EwkbGeometryType type)
34          =&gt; (type &amp; EwkbGeometryType.HasSrid) != 0;
35      static bool HasZ(EwkbGeometryType type)
36          =&gt; (type &amp; EwkbGeometryType.HasZ) != 0;
37      static bool HasM(EwkbGeometryType type)
38          =&gt; (type &amp; EwkbGeometryType.HasM) != 0;
39      static bool HasZ(IPosition coordinates)
40          =&gt; coordinates.Altitude.HasValue;
41      const int SizeOfLength = sizeof(int);
42      const int SizeOfHeader = sizeof(byte) + sizeof(EwkbGeometryType);
43      const int SizeOfHeaderWithLength = SizeOfHeader + SizeOfLength;
44      const int SizeOfPoint2D = 2 * sizeof(double);
45      const int SizeOfPoint3D = 3 * sizeof(double);
46      static int SizeOfPoint(bool hasZ)
47          =&gt; hasZ ? SizeOfPoint3D : SizeOfPoint2D;
48      static int SizeOfPoint(EwkbGeometryType type)
49      {
50          var size = SizeOfPoint2D;
51          if (HasZ(type))
52              size += sizeof(double);
53          if (HasM(type))
54              size += sizeof(double);
55          return size;
56      }
57      #region Throw
58      static Exception UnknownPostGisType()
59          =&gt; throw new InvalidOperationException(&quot;Invalid PostGIS type&quot;);
60      static Exception AllOrNoneCoordiantesMustHaveZ(NpgsqlParameter? parameter, string typeName)
61          =&gt; parameter is null
62              ? new ArgumentException($&quot;The Z coordinate must be specified for all or none elements of {typeName}&quot;)
63              : new ArgumentException($&quot;The Z coordinate must be specified for all or none elements of {typeName} in the {parameter.ParameterName} parameter&quot;, parameter.ParameterName);
64      #endregion
65      #region Read
66      public override ValueTask&lt;GeoJSONObject&gt; Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription = null)
67          =&gt; ReadGeometry(buf, async);
68      async ValueTask&lt;Point&gt; INpgsqlTypeHandler&lt;Point&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
69          =&gt; (Point)await ReadGeometry(buf, async);
70      async ValueTask&lt;LineString&gt; INpgsqlTypeHandler&lt;LineString&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
71          =&gt; (LineString)await ReadGeometry(buf, async);
72      async ValueTask&lt;Polygon&gt; INpgsqlTypeHandler&lt;Polygon&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
73          =&gt; (Polygon)await ReadGeometry(buf, async);
74      async ValueTask&lt;MultiPoint&gt; INpgsqlTypeHandler&lt;MultiPoint&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
75          =&gt; (MultiPoint)await ReadGeometry(buf, async);
76      async ValueTask&lt;MultiLineString&gt; INpgsqlTypeHandler&lt;MultiLineString&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
77          =&gt; (MultiLineString)await ReadGeometry(buf, async);
78      async ValueTask&lt;MultiPolygon&gt; INpgsqlTypeHandler&lt;MultiPolygon&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
79          =&gt; (MultiPolygon)await ReadGeometry(buf, async);
80      async ValueTask&lt;GeometryCollection&gt; INpgsqlTypeHandler&lt;GeometryCollection&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
81          =&gt; (GeometryCollection)await ReadGeometry(buf, async);
82      async ValueTask&lt;IGeoJSONObject&gt; INpgsqlTypeHandler&lt;IGeoJSONObject&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
83          =&gt; await ReadGeometry(buf, async);
84      async ValueTask&lt;IGeometryObject&gt; INpgsqlTypeHandler&lt;IGeometryObject&gt;.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
85          =&gt; (IGeometryObject)await ReadGeometry(buf, async);
86      async ValueTask&lt;GeoJSONObject&gt; ReadGeometry(NpgsqlReadBuffer buf, bool async)
87      {
88          var boundingBox = BoundingBox ? new BoundingBoxBuilder() : null;
89          var geometry = await ReadGeometryCore(buf, async, boundingBox);
90          geometry.BoundingBoxes = boundingBox?.Build();
91          return geometry;
92      }
93      async ValueTask&lt;GeoJSONObject&gt; ReadGeometryCore(NpgsqlReadBuffer buf, bool async, BoundingBoxBuilder? boundingBox)
94      {
95          await buf.Ensure(SizeOfHeader, async);
96          var littleEndian = buf.ReadByte() &gt; 0;
97          var type = (EwkbGeometryType)buf.ReadUInt32(littleEndian);
98          GeoJSONObject geometry;
99          NamedCRS? crs = null;
100          if (HasSrid(type))
101          {
102              await buf.Ensure(4, async);
103              crs = GetCrs(buf.ReadInt32(littleEndian));
104          }
105          switch (type &amp; EwkbGeometryType.BaseType)
106          {
107          case EwkbGeometryType.Point:
108          {
109              await buf.Ensure(SizeOfPoint(type), async);
110              var position = ReadPosition(buf, type, littleEndian);
111              boundingBox?.Accumulate(position);
112              geometry = new Point(position);
113              break;
114          }
115          case EwkbGeometryType.LineString:
116          {
117              await buf.Ensure(SizeOfLength, async);
118              var coordinates = new Position[buf.ReadInt32(littleEndian)];
119              for (var i = 0; i &lt; coordinates.Length; ++i)
120              {
121                  await buf.Ensure(SizeOfPoint(type), async);
122                  var position = ReadPosition(buf, type, littleEndian);
123                  boundingBox?.Accumulate(position);
124                  coordinates[i] = position;
125              }
126              geometry = new LineString(coordinates);
127              break;
128          }
129          case EwkbGeometryType.Polygon:
130          {
131              await buf.Ensure(SizeOfLength, async);
132              var lines = new LineString[buf.ReadInt32(littleEndian)];
133              for (var i = 0; i &lt; lines.Length; ++i)
134              {
135                  await buf.Ensure(SizeOfLength, async);
136                  var coordinates = new Position[buf.ReadInt32(littleEndian)];
137                  for (var j = 0; j &lt; coordinates.Length; ++j)
138                  {
139                      await buf.Ensure(SizeOfPoint(type), async);
140                      var position = ReadPosition(buf, type, littleEndian);
141                      boundingBox?.Accumulate(position);
142                      coordinates[j] = position;
143                  }
144                  lines[i] = new LineString(coordinates);
145              }
146              geometry = new Polygon(lines);
147              break;
148          }
149          case EwkbGeometryType.MultiPoint:
150          {
151              await buf.Ensure(SizeOfLength, async);
152              var points = new Point[buf.ReadInt32(littleEndian)];
153              for (var i = 0; i &lt; points.Length; ++i)
154              {
155                  await buf.Ensure(SizeOfHeader + SizeOfPoint(type), async);
156                  await buf.Skip(SizeOfHeader, async);
157                  var position = ReadPosition(buf, type, littleEndian);
158                  boundingBox?.Accumulate(position);
159                  points[i] = new Point(position);
160              }
161              geometry = new MultiPoint(points);
162              break;
163          }
164          case EwkbGeometryType.MultiLineString:
165          {
166              await buf.Ensure(SizeOfLength, async);
167              var lines = new LineString[buf.ReadInt32(littleEndian)];
168              for (var i = 0; i &lt; lines.Length; ++i)
169              {
170                  await buf.Ensure(SizeOfHeaderWithLength, async);
171                  await buf.Skip(SizeOfHeader, async);
172                  var coordinates = new Position[buf.ReadInt32(littleEndian)];
173                  for (var j = 0; j &lt; coordinates.Length; ++j)
174                  {
175                      await buf.Ensure(SizeOfPoint(type), async);
176                      var position = ReadPosition(buf, type, littleEndian);
177                      boundingBox?.Accumulate(position);
178                      coordinates[j] = position;
179                  }
180                  lines[i] = new LineString(coordinates);
181              }
182              geometry = new MultiLineString(lines);
183              break;
184          }
185          case EwkbGeometryType.MultiPolygon:
186          {
187              await buf.Ensure(SizeOfLength, async);
188              var polygons = new Polygon[buf.ReadInt32(littleEndian)];
189              for (var i = 0; i &lt; polygons.Length; ++i)
190              {
191                  await buf.Ensure(SizeOfHeaderWithLength, async);
192                  await buf.Skip(SizeOfHeader, async);
193                  var lines = new LineString[buf.ReadInt32(littleEndian)];
194                  for (var j = 0; j &lt; lines.Length; ++j)
195                  {
196                      await buf.Ensure(SizeOfLength, async);
197                      var coordinates = new Position[buf.ReadInt32(littleEndian)];
198                      for (var k = 0; k &lt; coordinates.Length; ++k)
199                      {
200                          await buf.Ensure(SizeOfPoint(type), async);
201                          var position = ReadPosition(buf, type, littleEndian);
202                          boundingBox?.Accumulate(position);
203                          coordinates[k] = position;
204                      }
205                      lines[j] = new LineString(coordinates);
206                  }
207                  polygons[i] = new Polygon(lines);
208              }
209              geometry = new MultiPolygon(polygons);
210              break;
211          }
212          case EwkbGeometryType.GeometryCollection:
213          {
214              await buf.Ensure(SizeOfLength, async);
215              var elements = new IGeometryObject[buf.ReadInt32(littleEndian)];
216              for (var i = 0; i &lt; elements.Length; ++i)
217                  elements[i] = (IGeometryObject)await ReadGeometryCore(buf, async, boundingBox);
218              geometry = new GeometryCollection(elements);
219              break;
220          }
221          default:
222              throw UnknownPostGisType();
223          }
224          geometry.CRS = crs;
225          return geometry;
226      }
227      static Position ReadPosition(NpgsqlReadBuffer buf, EwkbGeometryType type, bool littleEndian)
228      {
229          var position = new Position(
230              longitude: buf.ReadDouble(littleEndian),
231              latitude: buf.ReadDouble(littleEndian),
232              altitude: HasZ(type) ? buf.ReadDouble() : (double?)null);
233          if (HasM(type)) buf.ReadDouble(littleEndian);
234          return position;
235      }
236      #endregion
237      #region Write
238      public override int ValidateAndGetLength(GeoJSONObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
239          =&gt; value.Type switch
240          {
241              GeoJSONObjectType.Point              =&gt; ValidateAndGetLength((Point)value, ref lengthCache, parameter),
242              GeoJSONObjectType.LineString         =&gt; ValidateAndGetLength((LineString)value, ref lengthCache, parameter),
243              GeoJSONObjectType.Polygon            =&gt; ValidateAndGetLength((Polygon)value, ref lengthCache, parameter),
244              GeoJSONObjectType.MultiPoint         =&gt; ValidateAndGetLength((MultiPoint)value, ref lengthCache, parameter),
245              GeoJSONObjectType.MultiLineString    =&gt; ValidateAndGetLength((MultiLineString)value, ref lengthCache, parameter),
246              GeoJSONObjectType.MultiPolygon       =&gt; ValidateAndGetLength((MultiPolygon)value, ref lengthCache, parameter),
247              GeoJSONObjectType.GeometryCollection =&gt; ValidateAndGetLength((GeometryCollection)value, ref lengthCache, parameter),
248              _                                    =&gt; throw UnknownPostGisType()
249          };
250      public int ValidateAndGetLength(Point value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
251      {
252          var length = SizeOfHeader + SizeOfPoint(HasZ(value.Coordinates));
253          if (GetSrid(value.CRS) != 0)
254              length += sizeof(int);
255          return length;
256      }
257      public int ValidateAndGetLength(LineString value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
258      {
259          var coordinates = value.Coordinates;
260          if (NotValid(coordinates, out var hasZ))
261              throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(LineString));
262          var length = SizeOfHeaderWithLength + coordinates.Count * SizeOfPoint(hasZ);
263          if (GetSrid(value.CRS) != 0)
264              length += sizeof(int);
265          return length;
266      }
267      public int ValidateAndGetLength(Polygon value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
268      {
269          var lines = value.Coordinates;
270          var length = SizeOfHeaderWithLength + SizeOfLength * lines.Count;
271          if (GetSrid(value.CRS) != 0)
272              length += sizeof(int);
273          var hasZ = false;
274          for (var i = 0; i &lt; lines.Count; ++i)
275          {
276              var coordinates = lines[i].Coordinates;
277              if (NotValid(coordinates, out var lineHasZ))
278                  throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(Polygon));
279              if (hasZ != lineHasZ)
280              {
281                  if (i == 0) hasZ = lineHasZ;
282                  else throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(LineString));
283              }
284              length += coordinates.Count * SizeOfPoint(hasZ);
285          }
286          return length;
287      }
288      static bool NotValid(ReadOnlyCollection&lt;IPosition&gt; coordinates, out bool hasZ)
289      {
290          if (coordinates.Count == 0)
291              hasZ = false;
292          else
293          {
294              hasZ = HasZ(coordinates[0]);
295              for (var i = 1; i &lt; coordinates.Count; ++i)
296                  if (HasZ(coordinates[i]) != hasZ) return true;
297          }
298          return false;
299      }
300      public int ValidateAndGetLength(MultiPoint value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
301      {
302          var length = SizeOfHeaderWithLength;
303          if (GetSrid(value.CRS) != 0)
304              length += sizeof(int);
305          var coordinates = value.Coordinates;
306          for (var i = 0; i &lt; coordinates.Count; ++i)
307              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
308          return length;
309      }
310      public int ValidateAndGetLength(MultiLineString value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
311      {
312          var length = SizeOfHeaderWithLength;
313          if (GetSrid(value.CRS) != 0)
314              length += sizeof(int);
315          var coordinates = value.Coordinates;
316          for (var i = 0; i &lt; coordinates.Count; ++i)
317              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
318          return length;
319      }
320      public int ValidateAndGetLength(MultiPolygon value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
321      {
322          var length = SizeOfHeaderWithLength;
323          if (GetSrid(value.CRS) != 0)
324              length += sizeof(int);
325          var coordinates = value.Coordinates;
326          for (var i = 0; i &lt; coordinates.Count; ++i)
327              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
328          return length;
329      }
330      public int ValidateAndGetLength(GeometryCollection value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
331      {
332          var length = SizeOfHeaderWithLength;
333          if (GetSrid(value.CRS) != 0)
334              length += sizeof(int);
335          var geometries = value.Geometries;
336          for (var i = 0; i &lt; geometries.Count; ++i)
337              length += ValidateAndGetLength((GeoJSONObject)geometries[i], ref lengthCache, parameter);
338          return length;
339      }
340      int INpgsqlTypeHandler&lt;IGeoJSONObject&gt;.ValidateAndGetLength(IGeoJSONObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
341          =&gt; ValidateAndGetLength((GeoJSONObject)value, ref lengthCache, parameter);
342      int INpgsqlTypeHandler&lt;IGeometryObject&gt;.ValidateAndGetLength(IGeometryObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
343          =&gt; ValidateAndGetLength((GeoJSONObject)value, ref lengthCache, parameter);
344      public override Task Write(GeoJSONObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
345          =&gt; value.Type switch
346          {
347              GeoJSONObjectType.Point              =&gt; Write((Point)value, buf, lengthCache, parameter, async, cancellationToken),
348              GeoJSONObjectType.LineString         =&gt; Write((LineString)value, buf, lengthCache, parameter, async, cancellationToken),
349              GeoJSONObjectType.Polygon            =&gt; Write((Polygon)value, buf, lengthCache, parameter, async, cancellationToken),
350              GeoJSONObjectType.MultiPoint         =&gt; Write((MultiPoint)value, buf, lengthCache, parameter, async, cancellationToken),
351              GeoJSONObjectType.MultiLineString    =&gt; Write((MultiLineString)value, buf, lengthCache, parameter, async, cancellationToken),
352              GeoJSONObjectType.MultiPolygon       =&gt; Write((MultiPolygon)value, buf, lengthCache, parameter, async, cancellationToken),
353              GeoJSONObjectType.GeometryCollection =&gt; Write((GeometryCollection)value, buf, lengthCache, parameter, async, cancellationToken),
354              _                                    =&gt; throw UnknownPostGisType()
355          };
356      public async Task Write(Point value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
357      {
358          var type = EwkbGeometryType.Point;
359          var size = SizeOfHeader;
360          var srid = GetSrid(value.CRS);
361          if (srid != 0)
362          {
363              size += sizeof(int);
364              type |= EwkbGeometryType.HasSrid;
365          }
366          if (buf.WriteSpaceLeft &lt; size)
367              await buf.Flush(async, cancellationToken);
368          buf.WriteByte(0); 
369          buf.WriteInt32((int)type);
370          if (srid != 0)
371              buf.WriteInt32(srid);
372          await WritePosition(value.Coordinates, buf, async, cancellationToken);
373      }
374      public async Task Write(LineString value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
375      {
376          var type = EwkbGeometryType.LineString;
377          var size = SizeOfHeaderWithLength;
378          var srid = GetSrid(value.CRS);
379          if (srid != 0)
380          {
381              size += sizeof(int);
382              type |= EwkbGeometryType.HasSrid;
383          }
384          if (buf.WriteSpaceLeft &lt; size)
385              await buf.Flush(async, cancellationToken);
386          var coordinates = value.Coordinates;
387          buf.WriteByte(0); 
388          buf.WriteInt32((int)type);
389          buf.WriteInt32(coordinates.Count);
390          if (srid != 0)
391              buf.WriteInt32(srid);
392          for (var i = 0; i &lt; coordinates.Count; ++i)
393              await WritePosition(coordinates[i], buf, async, cancellationToken);
394      }
395      public async Task Write(Polygon value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
396      {
397          var type = EwkbGeometryType.Polygon;
398          var size = SizeOfHeaderWithLength;
399          var srid = GetSrid(value.CRS);
400          if (srid != 0)
401          {
402              size += sizeof(int);
<span onclick='openModal()' class='match'>403              type |= EwkbGeometryType.HasSrid;
404          }
405          if (buf.WriteSpaceLeft &lt; size)
406              await buf.Flush(async, cancellationToken);
407          var lines = value.Coordinates;
</span>408          buf.WriteByte(0); 
409          buf.WriteInt32((int)type);
410          buf.WriteInt32(lines.Count);
411          if (srid != 0)
412              buf.WriteInt32(srid);
413          for (var i = 0; i &lt; lines.Count; ++i)
414          {
415              if (buf.WriteSpaceLeft &lt; SizeOfLength)
416                  await buf.Flush(async, cancellationToken);
417              var coordinates = lines[i].Coordinates;
418              buf.WriteInt32(coordinates.Count);
419              for (var j = 0; j &lt; coordinates.Count; ++j)
420                  await WritePosition(coordinates[j], buf, async, cancellationToken);
421          }
422      }
423      public async Task Write(MultiPoint value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
424      {
425          var type = EwkbGeometryType.MultiPoint;
426          var size = SizeOfHeaderWithLength;
427          var srid = GetSrid(value.CRS);
428          if (srid != 0)
429          {
430              size += sizeof(int);
431              type |= EwkbGeometryType.HasSrid;
432          }
433          if (buf.WriteSpaceLeft &lt; size)
434              await buf.Flush(async, cancellationToken);
435          var coordinates = value.Coordinates;
436          buf.WriteByte(0); 
437          buf.WriteInt32((int)type);
438          buf.WriteInt32(coordinates.Count);
439          if (srid != 0)
440              buf.WriteInt32(srid);
441          for (var i = 0; i &lt; coordinates.Count; ++i)
442              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
443      }
444      public async Task Write(MultiLineString value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
445      {
446          var type = EwkbGeometryType.MultiLineString;
447          var size = SizeOfHeaderWithLength;
448          var srid = GetSrid(value.CRS);
449          if (srid != 0)
450          {
451              size += sizeof(int);
452              type |= EwkbGeometryType.HasSrid;
453          }
454          if (buf.WriteSpaceLeft &lt; size)
455              await buf.Flush(async, cancellationToken);
456          var coordinates = value.Coordinates;
457          buf.WriteByte(0); 
458          buf.WriteInt32((int)type);
459          buf.WriteInt32(coordinates.Count);
460          if (srid != 0)
461              buf.WriteInt32(srid);
462          for (var i = 0; i &lt; coordinates.Count; ++i)
463              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
464      }
465      public async Task Write(MultiPolygon value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
466      {
467          var type = EwkbGeometryType.MultiPolygon;
468          var size = SizeOfHeaderWithLength;
469          var srid = GetSrid(value.CRS);
470          if (srid != 0)
471          {
472              size += sizeof(int);
473              type |= EwkbGeometryType.HasSrid;
474          }
475          if (buf.WriteSpaceLeft &lt; size)
476              await buf.Flush(async, cancellationToken);
477          var coordinates = value.Coordinates;
478          buf.WriteByte(0); 
479          buf.WriteInt32((int)type);
480          buf.WriteInt32(coordinates.Count);
481          if (srid != 0)
482              buf.WriteInt32(srid);
483          for (var i = 0; i &lt; coordinates.Count; ++i)
484              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
485      }
486      public async Task Write(GeometryCollection value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
487      {
488          var type = EwkbGeometryType.GeometryCollection;
489          var size = SizeOfHeaderWithLength;
490          var srid = GetSrid(value.CRS);
491          if (srid != 0)
492          {
493              size += sizeof(int);
494              type |= EwkbGeometryType.HasSrid;
495          }
496          if (buf.WriteSpaceLeft &lt; size)
497              await buf.Flush(async, cancellationToken);
498          var geometries = value.Geometries;
499          buf.WriteByte(0); 
500          buf.WriteInt32((int)type);
501          buf.WriteInt32(geometries.Count);
502          if (srid != 0)
503              buf.WriteInt32(srid);
504          for (var i = 0; i &lt; geometries.Count; ++i)
505              await Write((GeoJSONObject) geometries[i], buf, lengthCache, parameter, async, cancellationToken);
506      }
507      Task INpgsqlTypeHandler&lt;IGeoJSONObject&gt;.Write(IGeoJSONObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
508          =&gt; Write((GeoJSONObject)value, buf, lengthCache, parameter, async, cancellationToken);
509      Task INpgsqlTypeHandler&lt;IGeometryObject&gt;.Write(IGeometryObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
510          =&gt; Write((GeoJSONObject)value, buf, lengthCache, parameter, async, cancellationToken);
511      static async Task WritePosition(IPosition coordinate, NpgsqlWriteBuffer buf, bool async, CancellationToken cancellationToken = default)
512      {
513          var altitude = coordinate.Altitude;
514          if (buf.WriteSpaceLeft &lt; SizeOfPoint(altitude.HasValue))
515              await buf.Flush(async, cancellationToken);
516          buf.WriteDouble(coordinate.Longitude);
517          buf.WriteDouble(coordinate.Latitude);
518          if (altitude.HasValue)
519              buf.WriteDouble(altitude.Value);
520      }
521      #endregion
522      #region Crs
523      NamedCRS? GetCrs(int srid)
524      {
525          var crsType = CrsType;
526          if (crsType == GeoJSONOptions.None)
527              return null;
528  #if NETSTANDARD2_0
529          return _cachedCrs.GetOrAdd(srid, srid =&gt;
530          {
531              var authority = _crsMap.GetAuthority(srid);
532              return authority is null
533                  ? throw new InvalidOperationException($&quot;SRID {srid} unknown in spatial_ref_sys table&quot;)
534                  : new NamedCRS(crsType == GeoJSONOptions.LongCRS
535                      ? &quot;urn:ogc:def:crs:&quot; + authority + &quot;::&quot; + srid
536                      : authority + &quot;:&quot; + srid);
537          });
538  #else
539          return _cachedCrs.GetOrAdd(srid, static (srid, me) =&gt;
540          {
541              var authority = me._crsMap.GetAuthority(srid);
542              return authority is null
543                  ? throw new InvalidOperationException($&quot;SRID {srid} unknown in spatial_ref_sys table&quot;)
544                  : new NamedCRS(me.CrsType == GeoJSONOptions.LongCRS
545                      ? &quot;urn:ogc:def:crs:&quot; + authority + &quot;::&quot; + srid
546                      : authority + &quot;:&quot; + srid);
547          }, this);
548  #endif
549      }
550      static int GetSrid(ICRSObject crs)
551      {
552          if (crs == null || crs is UnspecifiedCRS)
553              return 0;
554          var namedCrs = crs as NamedCRS;
555          if (namedCrs == null)
556              throw new NotSupportedException(&quot;The LinkedCRS class isn&#x27;t supported&quot;);
557          if (namedCrs.Properties.TryGetValue(&quot;name&quot;, out var value) &amp;&amp; value != null)
558          {
559              var name = value.ToString()!;
560              if (string.Equals(name, &quot;urn:ogc:def:crs:OGC::CRS84&quot;, StringComparison.Ordinal))
561                  return 4326;
562              var index = name.LastIndexOf(&#x27;:&#x27;);
563              if (index != -1 &amp;&amp; int.TryParse(name.Substring(index + 1), out var srid))
564                  return srid;
565              throw new FormatException(&quot;The specified CRS isn&#x27;t properly named&quot;);
566          }
567          return 0;
568      }
569      #endregion
570  }
571  [Flags]
572  enum EwkbGeometryType : uint
573  {
574      Point = 1,
575      LineString = 2,
576      Polygon = 3,
577      MultiPoint = 4,
578      MultiLineString = 5,
579      MultiPolygon = 6,
580      GeometryCollection = 7,
581      BaseType = Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection,
582      HasSrid = 0x20000000,
583      HasM = 0x40000000,
584      HasZ = 0x80000000
585  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GeoJSONHandler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GeoJSONHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>364              type |= EwkbGeometryType.HasSrid;
365          }
366          if (buf.WriteSpaceLeft &lt; size)
367              await buf.Flush(async, cancellationToken);
368          buf.WriteByte(0); 
</pre></code></div>
                <div class="column column_space"><pre><code>403              type |= EwkbGeometryType.HasSrid;
404          }
405          if (buf.WriteSpaceLeft &lt; size)
406              await buf.Flush(async, cancellationToken);
407          var lines = value.Coordinates;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    