
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Net;
6  using System.Net.Http;
7  using System.Security.Claims;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using Microsoft.AspNetCore.Authentication.Cookies;
12  using Microsoft.AspNetCore.Builder;
13  using Microsoft.AspNetCore.Hosting;
14  using Microsoft.AspNetCore.Http;
15  using Microsoft.AspNetCore.Http.Extensions;
16  using Microsoft.AspNetCore.TestHost;
17  using Microsoft.AspNetCore.WebUtilities;
18  using Microsoft.Extensions.DependencyInjection;
19  using Microsoft.IdentityModel.Tokens;
20  using Microsoft.Net.Http.Headers;
21  using Xunit;
22  namespace Microsoft.AspNetCore.Authentication.WsFederation
23  {
24      public class WsFederationTest
25      {
26          [Fact]
27          public async Task VerifySchemeDefaults()
28          {
29              var services = new ServiceCollection();
30              services.AddAuthentication().AddWsFederation();
31              var sp = services.BuildServiceProvider();
32              var schemeProvider = sp.GetRequiredService<IAuthenticationSchemeProvider>();
33              var scheme = await schemeProvider.GetSchemeAsync(WsFederationDefaults.AuthenticationScheme);
34              Assert.NotNull(scheme);
35              Assert.Equal("WsFederationHandler", scheme.HandlerType.Name);
36              Assert.Equal(WsFederationDefaults.AuthenticationScheme, scheme.DisplayName);
37          }
38          [Fact]
39          public async Task MissingConfigurationThrows()
40          {
41              var builder = new WebHostBuilder()
42                  .Configure(ConfigureApp)
43                  .ConfigureServices(services =>
44                  {
45                      services.AddAuthentication(sharedOptions =>
46                      {
47                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
48                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
49                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
50                      })
51                      .AddCookie()
52                      .AddWsFederation();
53                  });
54              var server = new TestServer(builder);
55              var httpClient = server.CreateClient();
56              var exception = await Assert.ThrowsAsync<InvalidOperationException>(() => httpClient.GetAsync("/"));
57              Assert.Equal("Provide MetadataAddress, Configuration, or ConfigurationManager to WsFederationOptions", exception.Message);
58          }
59          [Fact]
60          public async Task ChallengeRedirects()
61          {
62              var httpClient = CreateClient();
63              var response = await httpClient.GetAsync("/");
64              Assert.Equal("https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed", response.Headers.Location.GetLeftPart(System.UriPartial.Path));
65              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
66              Assert.Equal("http:&bsol;&bsol;Automation1", queryItems["wtrealm"]);
67              Assert.True(queryItems["wctx"].ToString().Equals(CustomStateDataFormat.ValidStateData), "wctx does not equal ValidStateData");
68              Assert.Equal(httpClient.BaseAddress + "signin-wsfed", queryItems["wreply"]);
69              Assert.Equal("wsignin1.0", queryItems["wa"]);
70          }
71          [Fact]
72          public async Task MapWillNotAffectRedirect()
73          {
74              var httpClient = CreateClient();
75              var response = await httpClient.GetAsync("/mapped-challenge");
76              Assert.Equal("https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed", response.Headers.Location.GetLeftPart(System.UriPartial.Path));
77              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
78              Assert.Equal("http:&bsol;&bsol;Automation1", queryItems["wtrealm"]);
79              Assert.True(queryItems["wctx"].ToString().Equals(CustomStateDataFormat.ValidStateData), "wctx does not equal ValidStateData");
80              Assert.Equal(httpClient.BaseAddress + "signin-wsfed", queryItems["wreply"]);
81              Assert.Equal("wsignin1.0", queryItems["wa"]);
82          }
83          [Fact]
84          public async Task PreMappedWillAffectRedirect()
85          {
86              var httpClient = CreateClient();
87              var response = await httpClient.GetAsync("/premapped-challenge");
88              Assert.Equal("https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed", response.Headers.Location.GetLeftPart(System.UriPartial.Path));
89              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
90              Assert.Equal("http:&bsol;&bsol;Automation1", queryItems["wtrealm"]);
91              Assert.True(queryItems["wctx"].ToString().Equals(CustomStateDataFormat.ValidStateData), "wctx does not equal ValidStateData");
92              Assert.Equal(httpClient.BaseAddress + "premapped-challenge/signin-wsfed", queryItems["wreply"]);
93              Assert.Equal("wsignin1.0", queryItems["wa"]);
94          }
95          [Fact]
96          public async Task ValidTokenIsAccepted()
97          {
98              var httpClient = CreateClient();
99              var response = await httpClient.GetAsync("/");
100              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
101              var request = new HttpRequestMessage(HttpMethod.Post, queryItems["wreply"]);
102              CopyCookies(response, request);
103              request.Content = CreateSignInContent("WsFederation/ValidToken.xml", queryItems["wctx"]);
104              response = await httpClient.SendAsync(request);
105              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
106              request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
107              CopyCookies(response, request);
108              response = await httpClient.SendAsync(request);
109              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
110          }
111          [Fact]
112          public async Task ValidUnsolicitedTokenIsRefused()
113          {
114              var httpClient = CreateClient();
115              var form = CreateSignInContent("WsFederation/ValidToken.xml", suppressWctx: true);
116              var exception = await Assert.ThrowsAsync<Exception>(() => httpClient.PostAsync(httpClient.BaseAddress + "signin-wsfed", form));
117              Assert.Contains("Unsolicited logins are not allowed.", exception.InnerException.Message);
118          }
119          [Fact]
120          public async Task ValidUnsolicitedTokenIsAcceptedWhenAllowed()
121          {
122              var httpClient = CreateClient(allowUnsolicited: true);
123              var form = CreateSignInContent("WsFederation/ValidToken.xml", suppressWctx: true);
124              var response = await httpClient.PostAsync(httpClient.BaseAddress + "signin-wsfed", form);
125              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
126              var request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
127              CopyCookies(response, request);
128              response = await httpClient.SendAsync(request);
129              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
130          }
131          [Fact]
132          public async Task InvalidTokenIsRejected()
133          {
134              var httpClient = CreateClient();
135              var response = await httpClient.GetAsync("/");
136              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
137              var request = new HttpRequestMessage(HttpMethod.Post, queryItems["wreply"]);
138              CopyCookies(response, request);
139              request.Content = CreateSignInContent("WsFederation/InvalidToken.xml", queryItems["wctx"]);
140              response = await httpClient.SendAsync(request);
141              Assert.Equal("AuthenticationFailed", await response.Content.ReadAsStringAsync());
142          }
143          [Fact]
144          public async Task RemoteSignoutRequestTriggersSignout()
145          {
146              var httpClient = CreateClient();
147              var response = await httpClient.GetAsync("/signin-wsfed?wa=wsignoutcleanup1.0");
148              response.EnsureSuccessStatusCode();
149              var cookie = response.Headers.GetValues(HeaderNames.SetCookie).Single();
150              Assert.Equal(".AspNetCore.Cookies=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; samesite=lax", cookie);
151              Assert.Equal("OnRemoteSignOut", response.Headers.GetValues("EventHeader").Single());
152              Assert.Equal("", await response.Content.ReadAsStringAsync());
153          }
154          [Fact]
155          public async Task EventsResolvedFromDI()
156          {
157              var builder = new WebHostBuilder()
158                  .ConfigureServices(services =>
159                  {
160                      services.AddSingleton<MyWsFedEvents>();
161                      services.AddAuthentication(sharedOptions =>
162                      {
163                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
164                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
165                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
166                      })
167                      .AddCookie()
168                      .AddWsFederation(options =>
169                      {
170                          options.Wtrealm = "http:&bsol;&bsol;Automation1";
171                          options.MetadataAddress = "https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml";
172                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
<span onclick='openModal()' class='match'>173                          options.EventsType = typeof(MyWsFedEvents);
174                      });
175                  })
</span>176                  .Configure(app =>
177                  {
178                      app.Run(context => context.ChallengeAsync());
179                  });
180              var server = new TestServer(builder);
181              var result = await server.CreateClient().GetAsync("");
182              Assert.Contains("CustomKey=CustomValue", result.Headers.Location.Query);
183          }
184          private class MyWsFedEvents : WsFederationEvents
185          {
186              public override Task RedirectToIdentityProvider(RedirectContext context)
187              {
188                  context.ProtocolMessage.SetParameter("CustomKey", "CustomValue");
189                  return base.RedirectToIdentityProvider(context);
190              }
191          }
192          private FormUrlEncodedContent CreateSignInContent(string tokenFile, string wctx = null, bool suppressWctx = false)
193          {
194              var kvps = new List<KeyValuePair<string, string>>();
195              kvps.Add(new KeyValuePair<string, string>("wa", "wsignin1.0"));
196              kvps.Add(new KeyValuePair<string, string>("wresult", File.ReadAllText(tokenFile)));
197              if (!string.IsNullOrEmpty(wctx))
198              {
199                  kvps.Add(new KeyValuePair<string, string>("wctx", wctx));
200              }
201              if (suppressWctx)
202              {
203                  kvps.Add(new KeyValuePair<string, string>("suppressWctx", "true"));
204              }
205              return new FormUrlEncodedContent(kvps);
206          }
207          private void CopyCookies(HttpResponseMessage response, HttpRequestMessage request)
208          {
209              var cookies = SetCookieHeaderValue.ParseList(response.Headers.GetValues(HeaderNames.SetCookie).ToList());
210              foreach (var cookie in cookies)
211              {
212                  if (cookie.Value.HasValue)
213                  {
214                      request.Headers.Add(HeaderNames.Cookie, new CookieHeaderValue(cookie.Name, cookie.Value).ToString());
215                  }
216              }
217          }
218          private HttpClient CreateClient(bool allowUnsolicited = false)
219          {
220              var builder = new WebHostBuilder()
221                  .Configure(ConfigureApp)
222                  .ConfigureServices(services =>
223                  {
224                      services.AddAuthentication(sharedOptions =>
225                      {
226                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
227                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
228                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
229                      })
230                      .AddCookie()
231                      .AddWsFederation(options =>
232                      {
233                          options.Wtrealm = "http:&bsol;&bsol;Automation1";
234                          options.MetadataAddress = "https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml";
235                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
236                          options.StateDataFormat = new CustomStateDataFormat();
237                          options.SecurityTokenHandlers = new List<ISecurityTokenValidator>() { new TestSecurityTokenValidator() };
238                          options.UseTokenLifetime = false;
239                          options.AllowUnsolicitedLogins = allowUnsolicited;
240                          options.Events = new WsFederationEvents()
241                          {
242                              OnMessageReceived = context =>
243                              {
244                                  if (!context.ProtocolMessage.Parameters.TryGetValue("suppressWctx", out var suppress))
245                                  {
246                                      Assert.True(context.ProtocolMessage.Wctx.Equals("customValue"), "wctx is not my custom value");
247                                  }
248                                  context.HttpContext.Items["MessageReceived"] = true;
249                                  return Task.FromResult(0);
250                              },
251                              OnRedirectToIdentityProvider = context =>
252                              {
253                                  if (context.ProtocolMessage.IsSignInMessage)
254                                  {
255                                      context.ProtocolMessage.Wctx = "customValue";
256                                  }
257                                  return Task.FromResult(0);
258                              },
259                              OnSecurityTokenReceived = context =>
260                              {
261                                  context.HttpContext.Items["SecurityTokenReceived"] = true;
262                                  return Task.FromResult(0);
263                              },
264                              OnSecurityTokenValidated = context =>
265                              {
266                                  Assert.True((bool)context.HttpContext.Items["MessageReceived"], "MessageReceived notification not invoked");
267                                  Assert.True((bool)context.HttpContext.Items["SecurityTokenReceived"], "SecurityTokenReceived notification not invoked");
268                                  if (context.Principal != null)
269                                  {
270                                      var identity = context.Principal.Identities.Single();
271                                      identity.AddClaim(new Claim("ReturnEndpoint", "true"));
272                                      identity.AddClaim(new Claim("Authenticated", "true"));
273                                      identity.AddClaim(new Claim(identity.RoleClaimType, "Guest", ClaimValueTypes.String));
274                                  }
275                                  return Task.FromResult(0);
276                              },
277                              OnAuthenticationFailed = context =>
278                              {
279                                  context.HttpContext.Items["AuthenticationFailed"] = true;
280                                  context.HttpContext.Request.Path = new PathString("/AuthenticationFailed");
281                                  context.SkipHandler();
282                                  return Task.FromResult(0);
283                              },
284                              OnRemoteSignOut = context =>
285                              {
286                                  context.Response.Headers["EventHeader"] = "OnRemoteSignOut";
287                                  return Task.FromResult(0);
288                              }
289                          };
290                      });
291                  });
292              var server = new TestServer(builder);
293              return server.CreateClient();
294          }
295          private void ConfigureApp(IApplicationBuilder app)
296          {
297              app.Map("/PreMapped-Challenge", mapped =>
298              {
299                  mapped.UseAuthentication();
300                  mapped.Run(async context =>
301                  {
302                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
303                  });
304              });
305              app.UseAuthentication();
306              app.Map("/Logout", subApp =>
307                  {
308                      subApp.Run(async context =>
309                          {
310                              if (context.User.Identity.IsAuthenticated)
311                              {
312                                  var authProperties = new AuthenticationProperties() { RedirectUri = context.Request.GetEncodedUrl() };
313                                  await context.SignOutAsync(WsFederationDefaults.AuthenticationScheme, authProperties);
314                                  await context.Response.WriteAsync("Signing out...");
315                              }
316                              else
317                              {
318                                  await context.Response.WriteAsync("SignedOut");
319                              }
320                          });
321                  });
322              app.Map("/AuthenticationFailed", subApp =>
323              {
324                  subApp.Run(async context =>
325                  {
326                      await context.Response.WriteAsync("AuthenticationFailed");
327                  });
328              });
329              app.Map("/signout-wsfed", subApp =>
330              {
331                  subApp.Run(async context =>
332                  {
333                      await context.Response.WriteAsync("signout-wsfed");
334                  });
335              });
336              app.Map("/mapped-challenge", subApp =>
337              {
338                  subApp.Run(async context =>
339                  {
340                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
341                  });
342              });
343              app.Run(async context =>
344              {
345                  var result = context.AuthenticateAsync();
346                  if (context.User == null || !context.User.Identity.IsAuthenticated)
347                  {
348                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
349                      await context.Response.WriteAsync("Unauthorized");
350                  }
351                  else
352                  {
353                      var identity = context.User.Identities.Single();
354                      if (identity.NameClaimType == "Name_Failed" && identity.RoleClaimType == "Role_Failed")
355                      {
356                          context.Response.StatusCode = 500;
357                          await context.Response.WriteAsync("SignIn_Failed");
358                      }
359                      else if (!identity.HasClaim("Authenticated", "true") || !identity.HasClaim("ReturnEndpoint", "true") || !identity.HasClaim(identity.RoleClaimType, "Guest"))
360                      {
361                          await context.Response.WriteAsync("Provider not invoked");
362                          return;
363                      }
364                      else
365                      {
366                          await context.Response.WriteAsync(WsFederationDefaults.AuthenticationScheme);
367                      }
368                  }
369              });
370          }
371          private class WaadMetadataDocumentHandler : HttpMessageHandler
372          {
373              protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
374              {
375                  var metadata = File.ReadAllText(@"WsFederation/federationmetadata.xml");
376                  var newResponse = new HttpResponseMessage() { Content = new StringContent(metadata, Encoding.UTF8, "text/xml") };
377                  return Task.FromResult<HttpResponseMessage>(newResponse);
378              }
379          }
380      }
381  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-AuthenticationMiddlewareTests.cs</h3>
            <pre><code>1  using System;
2  using System.Security.Claims;
3  using System.Threading.Tasks;
4  using Microsoft.AspNetCore.Builder;
5  using Microsoft.AspNetCore.Hosting;
6  using Microsoft.AspNetCore.Http;
7  using Microsoft.AspNetCore.TestHost;
8  using Microsoft.Extensions.DependencyInjection;
9  using Xunit;
10  namespace Microsoft.AspNetCore.Authentication
11  {
12      public class AuthenticationMiddlewareTests
13      {
14          [Fact]
15          public async Task OnlyInvokesCanHandleRequestHandlers()
16          {
17              var builder = new WebHostBuilder()
18                  .Configure(app =>
19                  {
20                      app.UseAuthentication();
21                  })
22                  .ConfigureServices(services => services.AddAuthentication(o =>
23                  {
24                      o.AddScheme("Skip", s =>
25                      {
<span onclick='openModal()' class='match'>26                          s.HandlerType = typeof(SkipHandler);
27                      });
28                      o.AddScheme("throws", s =>
</span>29                      {
30                          s.HandlerType = typeof(ThrowsHandler);
31                      });
32                      o.AddScheme("607", s =>
33                      {
34                          s.HandlerType = typeof(SixOhSevenHandler);
35                      });
36                      o.AddScheme("305", s =>
37                      {
38                          s.HandlerType = typeof(ThreeOhFiveHandler);
39                      });
40                  }));
41              var server = new TestServer(builder);
42              var response = await server.CreateClient().GetAsync("http:&bsol;&bsol;example.com/");
43              Assert.Equal(607, (int)response.StatusCode);
44          }
45          private class ThreeOhFiveHandler : StatusCodeHandler {
46              public ThreeOhFiveHandler() : base(305) { }
47          }
48          private class SixOhSevenHandler : StatusCodeHandler
49          {
50              public SixOhSevenHandler() : base(607) { }
51          }
52          private class SevenOhSevenHandler : StatusCodeHandler
53          {
54              public SevenOhSevenHandler() : base(707) { }
55          }
56          private class StatusCodeHandler : IAuthenticationRequestHandler
57          {
58              private HttpContext _context;
59              private int _code;
60              public StatusCodeHandler(int code)
61              {
62                  _code = code;
63              }
64              public Task<AuthenticateResult> AuthenticateAsync()
65              {
66                  throw new NotImplementedException();
67              }
68              public Task ChallengeAsync(AuthenticationProperties properties)
69              {
70                  throw new NotImplementedException();
71              }
72              public Task ForbidAsync(AuthenticationProperties properties)
73              {
74                  throw new NotImplementedException();
75              }
76              public Task<bool> HandleRequestAsync()
77              {
78                  _context.Response.StatusCode = _code;
79                  return Task.FromResult(true);
80              }
81              public Task InitializeAsync(AuthenticationScheme scheme, HttpContext context)
82              {
83                  _context = context;
84                  return Task.FromResult(0);
85              }
86              public Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties)
87              {
88                  throw new NotImplementedException();
89              }
90              public Task SignOutAsync(AuthenticationProperties properties)
91              {
92                  throw new NotImplementedException();
93              }
94          }
95          private class ThrowsHandler : IAuthenticationHandler
96          {
97              private HttpContext _context;
98              public Task<AuthenticateResult> AuthenticateAsync()
99              {
100                  throw new NotImplementedException();
101              }
102              public Task ChallengeAsync(AuthenticationProperties properties)
103              {
104                  throw new NotImplementedException();
105              }
106              public Task ForbidAsync(AuthenticationProperties properties)
107              {
108                  throw new NotImplementedException();
109              }
110              public Task<bool> HandleRequestAsync()
111              {
112                  throw new NotImplementedException();
113              }
114              public Task InitializeAsync(AuthenticationScheme scheme, HttpContext context)
115              {
116                  _context = context;
117                  return Task.FromResult(0);
118              }
119              public Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties)
120              {
121                  throw new NotImplementedException();
122              }
123              public Task SignOutAsync(AuthenticationProperties properties)
124              {
125                  throw new NotImplementedException();
126              }
127          }
128          private class SkipHandler : IAuthenticationRequestHandler
129          {
130              private HttpContext _context;
131              public Task<AuthenticateResult> AuthenticateAsync()
132              {
133                  throw new NotImplementedException();
134              }
135              public Task ChallengeAsync(AuthenticationProperties properties)
136              {
137                  throw new NotImplementedException();
138              }
139              public Task ForbidAsync(AuthenticationProperties properties)
140              {
141                  throw new NotImplementedException();
142              }
143              public Task<bool> HandleRequestAsync()
144              {
145                  return Task.FromResult(false);
146              }
147              public Task InitializeAsync(AuthenticationScheme scheme, HttpContext context)
148              {
149                  _context = context;
150                  return Task.FromResult(0);
151              }
152              public Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties)
153              {
154                  throw new NotImplementedException();
155              }
156              public Task SignOutAsync(AuthenticationProperties properties)
157              {
158                  throw new NotImplementedException();
159              }
160          }
161      }
162  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-AuthenticationMiddlewareTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>173                          options.EventsType = typeof(MyWsFedEvents);
174                      });
175                  })
</pre></code></div>
                <div class="column column_space"><pre><code>26                          s.HandlerType = typeof(SkipHandler);
27                      });
28                      o.AddScheme("throws", s =>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    