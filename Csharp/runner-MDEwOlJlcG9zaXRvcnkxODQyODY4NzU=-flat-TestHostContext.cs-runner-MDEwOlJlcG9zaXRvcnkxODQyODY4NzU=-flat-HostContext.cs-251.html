
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TestHostContext.cs</h3>
            <pre><code>1  using GitHub.Runner.Common.Util;
2  using System;
3  using System.Collections.Concurrent;
4  using System.Globalization;
5  using System.IO;
6  using System.Runtime.CompilerServices;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using System.Runtime.Loader;
10  using System.Reflection;
11  using System.Collections.Generic;
12  using GitHub.DistributedTask.Logging;
13  using System.Net.Http.Headers;
14  using GitHub.Runner.Sdk;
15  namespace GitHub.Runner.Common.Tests
16  {
17      public sealed class TestHostContext : IHostContext, IDisposable
18      {
19          private readonly ConcurrentDictionary&lt;Type, ConcurrentQueue&lt;object&gt;&gt; _serviceInstances = new();
20          private readonly ConcurrentDictionary&lt;Type, object&gt; _serviceSingletons = new();
21          private readonly ITraceManager _traceManager;
22          private readonly Terminal _term;
23          private readonly SecretMasker _secretMasker;
24          private CancellationTokenSource _runnerShutdownTokenSource = new();
25          private string _suiteName;
26          private string _testName;
27          private Tracing _trace;
28          private AssemblyLoadContext _loadContext;
29          private string _tempDirectoryRoot = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString(&quot;D&quot;));
30          private StartupType _startupType;
31          public event EventHandler Unloading;
32          public CancellationToken RunnerShutdownToken =&gt; _runnerShutdownTokenSource.Token;
33          public ShutdownReason RunnerShutdownReason { get; private set; }
34          public ISecretMasker SecretMasker =&gt; _secretMasker;
35          public TestHostContext(object testClass, [CallerMemberName] string testName = &quot;&quot;)
36          {
37              ArgUtil.NotNull(testClass, nameof(testClass));
38              ArgUtil.NotNullOrEmpty(testName, nameof(testName));
39              _loadContext = AssemblyLoadContext.GetLoadContext(typeof(TestHostContext).GetTypeInfo().Assembly);
40              _loadContext.Unloading += LoadContext_Unloading;
41              _testName = testName;
42              _suiteName = testClass.GetType().FullName.Substring(
43                  startIndex: typeof(Tests.TestHostContext).FullName.LastIndexOf(nameof(TestHostContext)));
44              _suiteName = _suiteName.Replace(&quot;.&quot;, &quot;_&quot;);
45              TraceFileName = Path.Combine(
46                  Path.Combine(TestUtil.GetSrcPath(), &quot;Test&quot;, &quot;TestLogs&quot;),
47                  $&quot;trace_{_suiteName}_{_testName}.log&quot;);
48              if (File.Exists(TraceFileName))
49              {
50                  File.Delete(TraceFileName);
51              }
52              var traceListener = new HostTraceListener(TraceFileName);
53              _secretMasker = new SecretMasker();
54              _secretMasker.AddValueEncoder(ValueEncoders.JsonStringEscape);
55              _secretMasker.AddValueEncoder(ValueEncoders.UriDataEscape);
56              _traceManager = new TraceManager(traceListener, null, _secretMasker);
57              _trace = GetTrace(nameof(TestHostContext));
58              _term = new Terminal();
59              _term.Silent = true;
60              SetSingleton&lt;ITerminal&gt;(_term);
61              EnqueueInstance&lt;ITerminal&gt;(_term);
62          }
63          public CultureInfo DefaultCulture { get; private set; }
64          public string TraceFileName { get; private set; }
65          public StartupType StartupType
66          {
67              get
68              {
69                  return _startupType;
70              }
71              set
72              {
73                  _startupType = value;
74              }
75          }
76          public List&lt;ProductInfoHeaderValue&gt; UserAgents =&gt; new() { new ProductInfoHeaderValue(&quot;L0Test&quot;, &quot;0.0&quot;) };
77          public RunnerWebProxy WebProxy =&gt; new();
78          public async Task Delay(TimeSpan delay, CancellationToken token)
79          {
80              await Task.Delay(TimeSpan.Zero);
81          }
82          public T CreateService&lt;T&gt;() where T : class, IRunnerService
83          {
84              _trace.Verbose($&quot;Create service: &#x27;{typeof(T).Name}&#x27;&quot;);
85              object service;
86              ConcurrentQueue&lt;object&gt; queue;
87              if (!_serviceInstances.TryGetValue(typeof(T), out queue) ||
88                  !queue.TryDequeue(out service))
89              {
90                  throw new Exception($&quot;Unable to dequeue a registered instance for type &#x27;{typeof(T).FullName}&#x27;.&quot;);
91              }
92              var s = service as T;
93              s.Initialize(this);
94              return s;
95          }
96          public T GetService&lt;T&gt;() where T : class, IRunnerService
97          {
98              _trace.Verbose($&quot;Get service: &#x27;{typeof(T).Name}&#x27;&quot;);
99              object service;
100              if (!_serviceSingletons.TryGetValue(typeof(T), out service))
101              {
102                  throw new Exception($&quot;Singleton instance not registered for type &#x27;{typeof(T).FullName}&#x27;.&quot;);
103              }
104              T s = service as T;
105              s.Initialize(this);
106              return s;
107          }
108          public void EnqueueInstance&lt;T&gt;(T instance) where T : class, IRunnerService
109          {
110              if (object.ReferenceEquals(instance, null))
111              {
112                  throw new ArgumentNullException(nameof(instance));
113              }
114              ConcurrentQueue&lt;object&gt; queue = _serviceInstances.GetOrAdd(
115                  key: typeof(T),
116                  valueFactory: x =&gt; new ConcurrentQueue&lt;object&gt;());
117              queue.Enqueue(instance);
118          }
119          public void SetDefaultCulture(string name)
120          {
121              DefaultCulture = new CultureInfo(name);
122          }
123          public void SetSingleton&lt;T&gt;(T singleton) where T : class, IRunnerService
124          {
125              if (object.ReferenceEquals(singleton, null))
126              {
127                  throw new ArgumentNullException(nameof(singleton));
128              }
129              _serviceSingletons[typeof(T)] = singleton;
130          }
131          public string GetDirectory(WellKnownDirectory directory)
132          {
133              string path;
134              switch (directory)
135              {
136                  case WellKnownDirectory.Bin:
137                      var overwriteBinDir = Environment.GetEnvironmentVariable(&quot;RUNNER_L0_OVERRIDEBINDIR&quot;);
138                      if (Directory.Exists(overwriteBinDir))
139                      {
140                          path = overwriteBinDir;
141                      }
142                      else
143                      {
144                          path = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
145                      }
146                      break;
147                  case WellKnownDirectory.Diag:
148                      path = Path.Combine(
149                          GetDirectory(WellKnownDirectory.Root),
150                          Constants.Path.DiagDirectory);
151                      break;
152                  case WellKnownDirectory.Externals:
153                      path = Path.Combine(
154                          GetDirectory(WellKnownDirectory.Root),
155                          Constants.Path.ExternalsDirectory);
156                      break;
157                  case WellKnownDirectory.Root:
158                      path = new DirectoryInfo(GetDirectory(WellKnownDirectory.Bin)).Parent.FullName;
159                      break;
160                  case WellKnownDirectory.Temp:
161                      path = Path.Combine(
162                          GetDirectory(WellKnownDirectory.Work),
163                          Constants.Path.TempDirectory);
164                      break;
165                  case WellKnownDirectory.Actions:
166                      path = Path.Combine(
167                          GetDirectory(WellKnownDirectory.Work),
168                          Constants.Path.ActionsDirectory);
169                      break;
170                  case WellKnownDirectory.Tools:
171                      path = Environment.GetEnvironmentVariable(&quot;RUNNER_TOOL_CACHE&quot;);
172                      if (string.IsNullOrEmpty(path))
173                      {
174                          path = Path.Combine(
175                              GetDirectory(WellKnownDirectory.Work),
176                              Constants.Path.ToolDirectory);
177                      }
178                      break;
179                  case WellKnownDirectory.Update:
180                      path = Path.Combine(
181                          GetDirectory(WellKnownDirectory.Work),
182                          Constants.Path.UpdateDirectory);
183                      break;
184                  case WellKnownDirectory.Work:
185                      path = Path.Combine(
186                          _tempDirectoryRoot,
187                          WellKnownDirectory.Work.ToString());
188                      break;
189                  default:
190                      throw new NotSupportedException($&quot;Unexpected well known directory: &#x27;{directory}&#x27;&quot;);
191              }
192              _trace.Info($&quot;Well known directory &#x27;{directory}&#x27;: &#x27;{path}&#x27;&quot;);
193              return path;
194          }
195          public string GetConfigFile(WellKnownConfigFile configFile)
196          {
197              string path;
198              switch (configFile)
199              {
200                  case WellKnownConfigFile.Runner:
201                      path = Path.Combine(
202                          GetDirectory(WellKnownDirectory.Root),
203                          &quot;.agent&quot;);
204                      break;
205                  case WellKnownConfigFile.Credentials:
206                      path = Path.Combine(
207                          GetDirectory(WellKnownDirectory.Root),
208                          &quot;.credentials&quot;);
209                      break;
210                  case WellKnownConfigFile.RSACredentials:
211                      path = Path.Combine(
212                          GetDirectory(WellKnownDirectory.Root),
213                          &quot;.credentials_rsaparams&quot;);
214                      break;
215                  case WellKnownConfigFile.Service:
216                      path = Path.Combine(
217                          GetDirectory(WellKnownDirectory.Root),
218                          &quot;.service&quot;);
219                      break;
220                  case WellKnownConfigFile.CredentialStore:
221  #if OS_OSX
222                      path = Path.Combine(
223                          GetDirectory(WellKnownDirectory.Root),
224                          &quot;.credential_store.keychain&quot;);
225  #else
226                      path = Path.Combine(
227                          GetDirectory(WellKnownDirectory.Root),
228                          &quot;.credential_store&quot;);
229  #endif
230                      break;
231                  case WellKnownConfigFile.Certificates:
232                      path = Path.Combine(
233                          GetDirectory(WellKnownDirectory.Root),
234                          &quot;.certificates&quot;);
235                      break;
236                  case WellKnownConfigFile.Options:
237                      path = Path.Combine(
238                          GetDirectory(WellKnownDirectory.Root),
239                          &quot;.options&quot;);
240                      break;
241                  case WellKnownConfigFile.SetupInfo:
242                      path = Path.Combine(
243                          GetDirectory(WellKnownDirectory.Root),
<span onclick='openModal()' class='match'>244                          &quot;.setup_info&quot;);
245                      break;
246                  default:
247                      throw new NotSupportedException($&quot;Unexpected well known config file: &#x27;{configFile}&#x27;&quot;);
248              }
249              _trace.Info($&quot;Well known config file &#x27;{configFile}&#x27;: &#x27;{path}&#x27;&quot;);
250              return path;
251          }
252          public Tracing GetTrace()
</span>253          {
254              Tracing trace = GetTrace($&quot;{_suiteName}_{_testName}&quot;);
255              trace.Info($&quot;Starting {_testName}&quot;);
256              return trace;
257          }
258          public Tracing GetTrace(string name)
259          {
260              return _traceManager[name];
261          }
262          public void ShutdownRunner(ShutdownReason reason)
263          {
264              ArgUtil.NotNull(reason, nameof(reason));
265              RunnerShutdownReason = reason;
266              _runnerShutdownTokenSource.Cancel();
267          }
268          public void WritePerfCounter(string counter)
269          {
270          }
271          public void Dispose()
272          {
273              Dispose(true);
274              GC.SuppressFinalize(this);
275          }
276          private void Dispose(bool disposing)
277          {
278              if (disposing)
279              {
280                  if (_loadContext != null)
281                  {
282                      _loadContext.Unloading -= LoadContext_Unloading;
283                      _loadContext = null;
284                  }
285                  _traceManager?.Dispose();
286                  try
287                  {
288                      Directory.Delete(_tempDirectoryRoot);
289                  }
290                  catch (Exception)
291                  {
292                  }
293              }
294          }
295          private void LoadContext_Unloading(AssemblyLoadContext obj)
296          {
297              if (Unloading != null)
298              {
299                  Unloading(this, null);
300              }
301          }
302      }
303  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-HostContext.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Diagnostics;
5  using System.Diagnostics.Tracing;
6  using System.Globalization;
7  using System.IO;
8  using System.Linq;
9  using System.Net.Http;
10  using System.Net.Http.Headers;
11  using System.Reflection;
12  using System.Runtime.Loader;
13  using System.Threading;
14  using System.Threading.Tasks;
15  using GitHub.DistributedTask.Logging;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  namespace GitHub.Runner.Common
19  {
20      public interface IHostContext : IDisposable
21      {
22          StartupType StartupType { get; set; }
23          CancellationToken RunnerShutdownToken { get; }
24          ShutdownReason RunnerShutdownReason { get; }
25          ISecretMasker SecretMasker { get; }
26          List&lt;ProductInfoHeaderValue&gt; UserAgents { get; }
27          RunnerWebProxy WebProxy { get; }
28          string GetDirectory(WellKnownDirectory directory);
29          string GetConfigFile(WellKnownConfigFile configFile);
30          Tracing GetTrace(string name);
31          Task Delay(TimeSpan delay, CancellationToken cancellationToken);
32          T CreateService&lt;T&gt;() where T : class, IRunnerService;
33          T GetService&lt;T&gt;() where T : class, IRunnerService;
34          void SetDefaultCulture(string name);
35          event EventHandler Unloading;
36          void ShutdownRunner(ShutdownReason reason);
37          void WritePerfCounter(string counter);
38      }
39      public enum StartupType
40      {
41          Manual,
42          Service,
43          AutoStartup
44      }
45      public sealed class HostContext : EventListener, IObserver&lt;DiagnosticListener&gt;, IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;, IHostContext, IDisposable
46      {
47          private const int _defaultLogPageSize = 8;  
48          private static int _defaultLogRetentionDays = 30;
49          private static int[] _vssHttpMethodEventIds = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 24 };
50          private static int[] _vssHttpCredentialEventIds = new int[] { 11, 13, 14, 15, 16, 17, 18, 20, 21, 22, 27, 29 };
51          private readonly ConcurrentDictionary&lt;Type, object&gt; _serviceInstances = new();
52          private readonly ConcurrentDictionary&lt;Type, Type&gt; _serviceTypes = new();
53          private readonly ISecretMasker _secretMasker = new SecretMasker();
54          private readonly List&lt;ProductInfoHeaderValue&gt; _userAgents = new() { new ProductInfoHeaderValue($&quot;GitHubActionsRunner-{BuildConstants.RunnerPackage.PackageName}&quot;, BuildConstants.RunnerPackage.Version) };
55          private CancellationTokenSource _runnerShutdownTokenSource = new();
56          private object _perfLock = new();
57          private Tracing _trace;
58          private Tracing _actionsHttpTrace;
59          private Tracing _netcoreHttpTrace;
60          private ITraceManager _traceManager;
61          private AssemblyLoadContext _loadContext;
62          private IDisposable _httpTraceSubscription;
63          private IDisposable _diagListenerSubscription;
64          private StartupType _startupType;
65          private string _perfFile;
66          private RunnerWebProxy _webProxy = new();
67          public event EventHandler Unloading;
68          public CancellationToken RunnerShutdownToken =&gt; _runnerShutdownTokenSource.Token;
69          public ShutdownReason RunnerShutdownReason { get; private set; }
70          public ISecretMasker SecretMasker =&gt; _secretMasker;
71          public List&lt;ProductInfoHeaderValue&gt; UserAgents =&gt; _userAgents;
72          public RunnerWebProxy WebProxy =&gt; _webProxy;
73          public HostContext(string hostType, string logFile = null)
74          {
75              ArgUtil.NotNullOrEmpty(hostType, nameof(hostType));
76              _loadContext = AssemblyLoadContext.GetLoadContext(typeof(HostContext).GetTypeInfo().Assembly);
77              _loadContext.Unloading += LoadContext_Unloading;
78              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscape);
79              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscapeShift1);
80              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscapeShift2);
81              this.SecretMasker.AddValueEncoder(ValueEncoders.CommandLineArgumentEscape);
82              this.SecretMasker.AddValueEncoder(ValueEncoders.ExpressionStringEscape);
83              this.SecretMasker.AddValueEncoder(ValueEncoders.JsonStringEscape);
84              this.SecretMasker.AddValueEncoder(ValueEncoders.UriDataEscape);
85              this.SecretMasker.AddValueEncoder(ValueEncoders.XmlDataEscape);
86              this.SecretMasker.AddValueEncoder(ValueEncoders.TrimDoubleQuotes);
87              this.SecretMasker.AddValueEncoder(ValueEncoders.PowerShellPreAmpersandEscape);
88              this.SecretMasker.AddValueEncoder(ValueEncoders.PowerShellPostAmpersandEscape);
89              StdoutTraceListener stdoutTraceListener = null;
90              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(Constants.Variables.Agent.PrintLogToStdout)))
91              {
92                  stdoutTraceListener = new StdoutTraceListener(hostType);
93              }
94              if (string.IsNullOrEmpty(logFile))
95              {
96                  int logPageSize;
97                  string logSizeEnv = Environment.GetEnvironmentVariable($&quot;{hostType.ToUpperInvariant()}_LOGSIZE&quot;);
98                  if (string.IsNullOrEmpty(logSizeEnv) || !int.TryParse(logSizeEnv, out logPageSize))
99                  {
100                      logPageSize = _defaultLogPageSize;
101                  }
102                  int logRetentionDays;
103                  string logRetentionDaysEnv = Environment.GetEnvironmentVariable($&quot;{hostType.ToUpperInvariant()}_LOGRETENTION&quot;);
104                  if (string.IsNullOrEmpty(logRetentionDaysEnv) || !int.TryParse(logRetentionDaysEnv, out logRetentionDays))
105                  {
106                      logRetentionDays = _defaultLogRetentionDays;
107                  }
108                  string diagLogDirectory = Path.Combine(new DirectoryInfo(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location)).Parent.FullName, Constants.Path.DiagDirectory);
109                  _traceManager = new TraceManager(new HostTraceListener(diagLogDirectory, hostType, logPageSize, logRetentionDays), stdoutTraceListener, this.SecretMasker);
110              }
111              else
112              {
113                  _traceManager = new TraceManager(new HostTraceListener(logFile), stdoutTraceListener, this.SecretMasker);
114              }
115              _trace = GetTrace(nameof(HostContext));
116              _actionsHttpTrace = GetTrace(&quot;GitHubActionsService&quot;);
117              bool enableHttpTrace;
118              if (bool.TryParse(Environment.GetEnvironmentVariable(&quot;GITHUB_ACTIONS_RUNNER_HTTPTRACE&quot;), out enableHttpTrace) &amp;&amp; enableHttpTrace)
119              {
120                  _trace.Warning(&quot;*****************************************************************************************&quot;);
121                  _trace.Warning(&quot;**                                                                                     **&quot;);
122                  _trace.Warning(&quot;** Http trace is enabled, all your http traffic will be dumped into runner diag log.   **&quot;);
123                  _trace.Warning(&quot;** DO NOT share the log in public place! The trace may contains secrets in plain text. **&quot;);
124                  _trace.Warning(&quot;**                                                                                     **&quot;);
125                  _trace.Warning(&quot;*****************************************************************************************&quot;);
126                  _netcoreHttpTrace = GetTrace(&quot;HttpTrace&quot;);
127                  _diagListenerSubscription = DiagnosticListener.AllListeners.Subscribe(this);
128              }
129              string perfCounterLocation = Environment.GetEnvironmentVariable(&quot;RUNNER_PERFLOG&quot;);
130              if (!string.IsNullOrEmpty(perfCounterLocation))
131              {
132                  try
133                  {
134                      Directory.CreateDirectory(perfCounterLocation);
135                      _perfFile = Path.Combine(perfCounterLocation, $&quot;{hostType}.perf&quot;);
136                  }
137                  catch (Exception ex)
138                  {
139                      _trace.Error(ex);
140                  }
141              }
142              if (!string.IsNullOrEmpty(WebProxy.HttpProxyAddress))
143              {
144                  if (string.IsNullOrEmpty(WebProxy.HttpProxyUsername) &amp;&amp; string.IsNullOrEmpty(WebProxy.HttpProxyPassword))
145                  {
146                      _trace.Info($&quot;Configuring anonymous proxy {WebProxy.HttpProxyAddress} for all HTTP requests.&quot;);
147                  }
148                  else
149                  {
150                      if (!string.IsNullOrEmpty(WebProxy.HttpProxyPassword))
151                      {
152                          this.SecretMasker.AddValue(WebProxy.HttpProxyPassword);
153                      }
154                      _trace.Info($&quot;Configuring authenticated proxy {WebProxy.HttpProxyAddress} for all HTTP requests.&quot;);
155                  }
156              }
157              if (!string.IsNullOrEmpty(WebProxy.HttpsProxyAddress))
158              {
159                  if (string.IsNullOrEmpty(WebProxy.HttpsProxyUsername) &amp;&amp; string.IsNullOrEmpty(WebProxy.HttpsProxyPassword))
160                  {
161                      _trace.Info($&quot;Configuring anonymous proxy {WebProxy.HttpsProxyAddress} for all HTTPS requests.&quot;);
162                  }
163                  else
164                  {
165                      if (!string.IsNullOrEmpty(WebProxy.HttpsProxyPassword))
166                      {
167                          this.SecretMasker.AddValue(WebProxy.HttpsProxyPassword);
168                      }
169                      _trace.Info($&quot;Configuring authenticated proxy {WebProxy.HttpsProxyAddress} for all HTTPS requests.&quot;);
170                  }
171              }
172              if (string.IsNullOrEmpty(WebProxy.HttpProxyAddress) &amp;&amp; string.IsNullOrEmpty(WebProxy.HttpsProxyAddress))
173              {
174                  _trace.Info($&quot;No proxy settings were found based on environmental variables (http_proxy/https_proxy/HTTP_PROXY/HTTPS_PROXY)&quot;);
175              }
176              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(&quot;GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY&quot;)))
177              {
178                  _trace.Warning($&quot;Runner is running under insecure mode: HTTPS server certifcate validation has been turned off by GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY environment variable.&quot;);
179              }
180              var credFile = GetConfigFile(WellKnownConfigFile.Credentials);
181              if (File.Exists(credFile))
182              {
183                  var credData = IOUtil.LoadObject&lt;CredentialData&gt;(credFile);
184                  if (credData != null &amp;&amp;
185                      credData.Data.TryGetValue(&quot;clientId&quot;, out var clientId))
186                  {
187                      _userAgents.Add(new ProductInfoHeaderValue(&quot;ClientId&quot;, clientId));
188                  }
189              }
190              var runnerFile = GetConfigFile(WellKnownConfigFile.Runner);
191              if (File.Exists(runnerFile))
192              {
193                  var runnerSettings = IOUtil.LoadObject&lt;RunnerSettings&gt;(runnerFile, true);
194                  _userAgents.Add(new ProductInfoHeaderValue(&quot;RunnerId&quot;, runnerSettings.AgentId.ToString(CultureInfo.InvariantCulture)));
195                  _userAgents.Add(new ProductInfoHeaderValue(&quot;GroupId&quot;, runnerSettings.PoolId.ToString(CultureInfo.InvariantCulture)));
196              }
197              _userAgents.Add(new ProductInfoHeaderValue(&quot;CommitSHA&quot;, BuildConstants.Source.CommitHash));
198              var extraUserAgent = Environment.GetEnvironmentVariable(&quot;GITHUB_ACTIONS_RUNNER_EXTRA_USER_AGENT&quot;);
199              if (!string.IsNullOrEmpty(extraUserAgent))
200              {
201                  var extraUserAgentSplit = extraUserAgent.Split(&#x27;/&#x27;, StringSplitOptions.RemoveEmptyEntries);
202                  if (extraUserAgentSplit.Length != 2)
203                  {
204                      _trace.Error($&quot;GITHUB_ACTIONS_RUNNER_EXTRA_USER_AGENT is not in the format of &#x27;name/version&#x27;.&quot;);
205                  }
206                  var extraUserAgentHeader = new ProductInfoHeaderValue(extraUserAgentSplit[0], extraUserAgentSplit[1]);
207                  _trace.Info($&quot;Adding extra user agent &#x27;{extraUserAgentHeader}&#x27; to all HTTP requests.&quot;);
208                  _userAgents.Add(extraUserAgentHeader);
209              }
210          }
211          public string GetDirectory(WellKnownDirectory directory)
212          {
213              string path;
214              switch (directory)
215              {
216                  case WellKnownDirectory.Bin:
217                      path = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
218                      break;
219                  case WellKnownDirectory.Diag:
220                      path = Path.Combine(
221                          GetDirectory(WellKnownDirectory.Root),
222                          Constants.Path.DiagDirectory);
223                      break;
224                  case WellKnownDirectory.Externals:
225                      path = Path.Combine(
226                          GetDirectory(WellKnownDirectory.Root),
227                          Constants.Path.ExternalsDirectory);
228                      break;
229                  case WellKnownDirectory.Root:
230                      path = new DirectoryInfo(GetDirectory(WellKnownDirectory.Bin)).Parent.FullName;
231                      break;
232                  case WellKnownDirectory.Temp:
233                      path = Path.Combine(
234                          GetDirectory(WellKnownDirectory.Work),
235                          Constants.Path.TempDirectory);
236                      break;
237                  case WellKnownDirectory.Actions:
238                      path = Path.Combine(
239                          GetDirectory(WellKnownDirectory.Work),
240                          Constants.Path.ActionsDirectory);
241                      break;
242                  case WellKnownDirectory.Tools:
243                      path = Environment.GetEnvironmentVariable(&quot;RUNNER_TOOL_CACHE&quot;) ?? Environment.GetEnvironmentVariable(&quot;RUNNER_TOOLSDIRECTORY&quot;) ?? Environment.GetEnvironmentVariable(&quot;AGENT_TOOLSDIRECTORY&quot;) ?? Environment.GetEnvironmentVariable(Constants.Variables.Agent.ToolsDirectory);
244                      if (string.IsNullOrEmpty(path))
245                      {
246                          path = Path.Combine(
247                              GetDirectory(WellKnownDirectory.Work),
248                              Constants.Path.ToolDirectory);
249                      }
250                      break;
251                  case WellKnownDirectory.Update:
252                      path = Path.Combine(
253                          GetDirectory(WellKnownDirectory.Work),
254                          Constants.Path.UpdateDirectory);
255                      break;
256                  case WellKnownDirectory.Work:
257                      var configurationStore = GetService&lt;IConfigurationStore&gt;();
258                      RunnerSettings settings = configurationStore.GetSettings();
259                      ArgUtil.NotNull(settings, nameof(settings));
260                      ArgUtil.NotNullOrEmpty(settings.WorkFolder, nameof(settings.WorkFolder));
261                      path = Path.GetFullPath(Path.Combine(
262                          GetDirectory(WellKnownDirectory.Root),
263                          settings.WorkFolder));
264                      break;
265                  default:
266                      throw new NotSupportedException($&quot;Unexpected well known directory: &#x27;{directory}&#x27;&quot;);
267              }
268              _trace.Info($&quot;Well known directory &#x27;{directory}&#x27;: &#x27;{path}&#x27;&quot;);
269              return path;
270          }
271          public string GetConfigFile(WellKnownConfigFile configFile)
272          {
273              string path;
274              switch (configFile)
275              {
276                  case WellKnownConfigFile.Runner:
277                      path = Path.Combine(
278                          GetDirectory(WellKnownDirectory.Root),
279                          &quot;.runner&quot;);
280                      break;
281                  case WellKnownConfigFile.Credentials:
282                      path = Path.Combine(
283                          GetDirectory(WellKnownDirectory.Root),
284                          &quot;.credentials&quot;);
285                      break;
286                  case WellKnownConfigFile.MigratedCredentials:
287                      path = Path.Combine(
288                          GetDirectory(WellKnownDirectory.Root),
289                          &quot;.credentials_migrated&quot;);
290                      break;
291                  case WellKnownConfigFile.RSACredentials:
292                      path = Path.Combine(
293                          GetDirectory(WellKnownDirectory.Root),
294                          &quot;.credentials_rsaparams&quot;);
295                      break;
296                  case WellKnownConfigFile.Service:
297                      path = Path.Combine(
298                          GetDirectory(WellKnownDirectory.Root),
299                          &quot;.service&quot;);
300                      break;
301                  case WellKnownConfigFile.CredentialStore:
302  #if OS_OSX
303                      path = Path.Combine(
304                          GetDirectory(WellKnownDirectory.Root),
305                          &quot;.credential_store.keychain&quot;);
306  #else
307                      path = Path.Combine(
308                          GetDirectory(WellKnownDirectory.Root),
309                          &quot;.credential_store&quot;);
310  #endif
311                      break;
312                  case WellKnownConfigFile.Certificates:
313                      path = Path.Combine(
314                          GetDirectory(WellKnownDirectory.Root),
315                          &quot;.certificates&quot;);
316                      break;
317                  case WellKnownConfigFile.Options:
318                      path = Path.Combine(
319                          GetDirectory(WellKnownDirectory.Root),
320                          &quot;.options&quot;);
321                      break;
322                  case WellKnownConfigFile.SetupInfo:
323                      path = Path.Combine(
324                          GetDirectory(WellKnownDirectory.Root),
325                          &quot;.setup_info&quot;);
326                      break;
327                  case WellKnownConfigFile.Telemetry:
328                      path = Path.Combine(
329                          GetDirectory(WellKnownDirectory.Diag),
<span onclick='openModal()' class='match'>330                          &quot;.telemetry&quot;);
331                      break;
332                  default:
333                      throw new NotSupportedException($&quot;Unexpected well known config file: &#x27;{configFile}&#x27;&quot;);
334              }
335              _trace.Info($&quot;Well known config file &#x27;{configFile}&#x27;: &#x27;{path}&#x27;&quot;);
336              return path;
337          }
338          public Tracing GetTrace(string name)
</span>339          {
340              return _traceManager[name];
341          }
342          public async Task Delay(TimeSpan delay, CancellationToken cancellationToken)
343          {
344              await Task.Delay(delay, cancellationToken);
345          }
346          public T CreateService&lt;T&gt;() where T : class, IRunnerService
347          {
348              Type target;
349              if (!_serviceTypes.TryGetValue(typeof(T), out target))
350              {
351                  CustomAttributeData attribute = typeof(T)
352                      .GetTypeInfo()
353                      .CustomAttributes
354                      .FirstOrDefault(x =&gt; x.AttributeType == typeof(ServiceLocatorAttribute));
355                  if (attribute != null)
356                  {
357                      foreach (CustomAttributeNamedArgument arg in attribute.NamedArguments)
358                      {
359                          if (string.Equals(arg.MemberName, ServiceLocatorAttribute.DefaultPropertyName, StringComparison.Ordinal))
360                          {
361                              target = arg.TypedValue.Value as Type;
362                          }
363                      }
364                  }
365                  if (target == null)
366                  {
367                      throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, &quot;Service mapping not found for key &#x27;{0}&#x27;.&quot;, typeof(T).FullName));
368                  }
369                  _serviceTypes.TryAdd(typeof(T), target);
370                  target = _serviceTypes[typeof(T)];
371              }
372              T svc = Activator.CreateInstance(target) as T;
373              svc.Initialize(this);
374              return svc;
375          }
376          public T GetService&lt;T&gt;() where T : class, IRunnerService
377          {
378              object instance;
379              if (_serviceInstances.TryGetValue(typeof(T), out instance))
380              {
381                  return instance as T;
382              }
383              _serviceInstances.TryAdd(typeof(T), CreateService&lt;T&gt;());
384              return _serviceInstances[typeof(T)] as T;
385          }
386          public void SetDefaultCulture(string name)
387          {
388              ArgUtil.NotNull(name, nameof(name));
389              _trace.Verbose($&quot;Setting default culture and UI culture to: &#x27;{name}&#x27;&quot;);
390              CultureInfo.DefaultThreadCurrentCulture = new CultureInfo(name);
391              CultureInfo.DefaultThreadCurrentUICulture = new CultureInfo(name);
392          }
393          public void ShutdownRunner(ShutdownReason reason)
394          {
395              ArgUtil.NotNull(reason, nameof(reason));
396              _trace.Info($&quot;Runner will be shutdown for {reason.ToString()}&quot;);
397              RunnerShutdownReason = reason;
398              _runnerShutdownTokenSource.Cancel();
399          }
400          public override void Dispose()
401          {
402              Dispose(true);
403              GC.SuppressFinalize(this);
404          }
405          public StartupType StartupType
406          {
407              get
408              {
409                  return _startupType;
410              }
411              set
412              {
413                  _startupType = value;
414              }
415          }
416          public void WritePerfCounter(string counter)
417          {
418              if (!string.IsNullOrEmpty(_perfFile))
419              {
420                  string normalizedCounter = counter.Replace(&#x27;:&#x27;, &#x27;_&#x27;);
421                  lock (_perfLock)
422                  {
423                      try
424                      {
425                          File.AppendAllLines(_perfFile, new[] { $&quot;{normalizedCounter}:{DateTime.UtcNow.ToString(&quot;O&quot;)}&quot; });
426                      }
427                      catch (Exception ex)
428                      {
429                          _trace.Error(ex);
430                      }
431                  }
432              }
433          }
434          private void Dispose(bool disposing)
435          {
436              if (disposing)
437              {
438                  if (_loadContext != null)
439                  {
440                      _loadContext.Unloading -= LoadContext_Unloading;
441                      _loadContext = null;
442                  }
443                  _httpTraceSubscription?.Dispose();
444                  _diagListenerSubscription?.Dispose();
445                  _traceManager?.Dispose();
446                  _traceManager = null;
447                  _runnerShutdownTokenSource?.Dispose();
448                  _runnerShutdownTokenSource = null;
449                  base.Dispose();
450              }
451          }
452          private void LoadContext_Unloading(AssemblyLoadContext obj)
453          {
454              if (Unloading != null)
455              {
456                  Unloading(this, null);
457              }
458          }
459          void IObserver&lt;DiagnosticListener&gt;.OnCompleted()
460          {
461              _netcoreHttpTrace.Info(&quot;DiagListeners finished transmitting data.&quot;);
462          }
463          void IObserver&lt;DiagnosticListener&gt;.OnError(Exception error)
464          {
465              _netcoreHttpTrace.Error(error);
466          }
467          void IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener listener)
468          {
469              if (listener.Name == &quot;HttpHandlerDiagnosticListener&quot; &amp;&amp; _httpTraceSubscription == null)
470              {
471                  _httpTraceSubscription = listener.Subscribe(this);
472              }
473          }
474          void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnCompleted()
475          {
476              _netcoreHttpTrace.Info(&quot;HttpHandlerDiagnosticListener finished transmitting data.&quot;);
477          }
478          void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnError(Exception error)
479          {
480              _netcoreHttpTrace.Error(error);
481          }
482          void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnNext(KeyValuePair&lt;string, object&gt; value)
483          {
484              _netcoreHttpTrace.Info($&quot;Trace {value.Key} event:{Environment.NewLine}{value.Value.ToString()}&quot;);
485          }
486          protected override void OnEventSourceCreated(EventSource source)
487          {
488              if (source.Name.Equals(&quot;GitHub-Actions-Http&quot;))
489              {
490                  EnableEvents(source, EventLevel.Verbose);
491              }
492          }
493          protected override void OnEventWritten(EventWrittenEventArgs eventData)
494          {
495              if (eventData == null)
496              {
497                  return;
498              }
499              string message = eventData.Message;
500              object[] payload = new object[0];
501              if (eventData.Payload != null &amp;&amp; eventData.Payload.Count &gt; 0)
502              {
503                  payload = eventData.Payload.ToArray();
504              }
505              try
506              {
507                  if (_vssHttpMethodEventIds.Contains(eventData.EventId))
508                  {
509                      payload[0] = Enum.Parse(typeof(VssHttpMethod), ((int)payload[0]).ToString());
510                  }
511                  else if (_vssHttpCredentialEventIds.Contains(eventData.EventId))
512                  {
513                      payload[0] = Enum.Parse(typeof(GitHub.Services.Common.VssCredentialsType), ((int)payload[0]).ToString());
514                  }
515                  if (payload.Length &gt; 0)
516                  {
517                      message = String.Format(eventData.Message.Replace(&quot;%n&quot;, Environment.NewLine), payload);
518                  }
519                  switch (eventData.Level)
520                  {
521                      case EventLevel.Critical:
522                      case EventLevel.Error:
523                          _actionsHttpTrace.Error(message);
524                          break;
525                      case EventLevel.Warning:
526                          _actionsHttpTrace.Warning(message);
527                          break;
528                      case EventLevel.Informational:
529                          _actionsHttpTrace.Info(message);
530                          break;
531                      default:
532                          _actionsHttpTrace.Verbose(message);
533                          break;
534                  }
535              }
536              catch (Exception ex)
537              {
538                  _actionsHttpTrace.Error(ex);
539                  _actionsHttpTrace.Info(eventData.Message);
540                  _actionsHttpTrace.Info(string.Join(&quot;, &quot;, eventData.Payload?.ToArray() ?? new string[0]));
541              }
542          }
543          internal enum VssHttpMethod
544          {
545              UNKNOWN,
546              DELETE,
547              HEAD,
548              GET,
549              OPTIONS,
550              PATCH,
551              POST,
552              PUT,
553          }
554      }
555      public static class HostContextExtension
556      {
557          public static HttpClientHandler CreateHttpClientHandler(this IHostContext context)
558          {
559              var handlerFactory = context.GetService&lt;IHttpClientHandlerFactory&gt;();
560              return handlerFactory.CreateClientHandler(context.WebProxy);
561          }
562          public static string GetDefaultShellForScript(this IHostContext hostContext, string path, string prependPath)
563          {
564              var trace = hostContext.GetTrace(nameof(GetDefaultShellForScript));
565              switch (Path.GetExtension(path))
566              {
567                  case &quot;.sh&quot;:
568                      if (WhichUtil.Which(&quot;bash&quot;, false, trace, prependPath) != null)
569                      {
570                          return &quot;bash&quot;;
571                      }
572                      return &quot;sh&quot;;
573                  case &quot;.ps1&quot;:
574                      if (WhichUtil.Which(&quot;pwsh&quot;, false, trace, prependPath) != null)
575                      {
576                          return &quot;pwsh&quot;;
577                      }
578                      return &quot;powershell&quot;;
579                  case &quot;.js&quot;:
580                      return Path.Combine(hostContext.GetDirectory(WellKnownDirectory.Externals), NodeUtil.GetInternalNodeVersion(), &quot;bin&quot;, $&quot;node{IOUtil.ExeExtension}&quot;) + &quot; {0}&quot;;
581                  default:
582                      throw new ArgumentException($&quot;{path} is not a valid path to a script. Make sure it ends in &#x27;.sh&#x27;, &#x27;.ps1&#x27; or &#x27;.js&#x27;.&quot;);
583              }
584          }
585      }
586      public enum ShutdownReason
587      {
588          UserCancelled = 0,
589          OperatingSystemShutdown = 1,
590      }
591  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TestHostContext.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-HostContext.cs</div>
                </div>
                <div class="column column_space"><pre><code>244                          &quot;.setup_info&quot;);
245                      break;
246                  default:
247                      throw new NotSupportedException($&quot;Unexpected well known config file: &#x27;{configFile}&#x27;&quot;);
248              }
249              _trace.Info($&quot;Well known config file &#x27;{configFile}&#x27;: &#x27;{path}&#x27;&quot;);
250              return path;
251          }
252          public Tracing GetTrace()
</pre></code></div>
                <div class="column column_space"><pre><code>330                          &quot;.telemetry&quot;);
331                      break;
332                  default:
333                      throw new NotSupportedException($&quot;Unexpected well known config file: &#x27;{configFile}&#x27;&quot;);
334              }
335              _trace.Info($&quot;Well known config file &#x27;{configFile}&#x27;: &#x27;{path}&#x27;&quot;);
336              return path;
337          }
338          public Tracing GetTrace(string name)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    