
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 210, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssConnection.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.ComponentModel;
5  using System.Diagnostics;
6  using System.Diagnostics.CodeAnalysis;
7  using System.Linq;
8  using System.Net.Http;
9  using System.Reflection;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using GitHub.Services.Common;
13  using GitHub.Services.Location;
14  using GitHub.Services.WebApi.Internal;
15  using GitHub.Services.WebApi.Location;
16  using GitHub.Services.WebApi.Utilities;
17  namespace GitHub.Services.WebApi
18  {
19      public class VssConnection : IDisposable
20      {
21          public VssConnection(
22              Uri baseUrl,
23              VssCredentials credentials)
24              : this(baseUrl, credentials, VssClientHttpRequestSettings.Default.Clone())
25          {
26          }
27          public VssConnection(
28              Uri baseUrl,
29              VssCredentials credentials,
30              VssHttpRequestSettings settings)
31              : this(baseUrl, new VssHttpMessageHandler(credentials, settings), null)
32          {
33          }
34          public VssConnection(
35              Uri baseUrl,
36              VssHttpMessageHandler innerHandler,
37              IEnumerable&lt;DelegatingHandler&gt; delegatingHandlers)
38              : this(baseUrl, innerHandler, delegatingHandlers, true)
39          {
40          }
41          private VssConnection(
42              Uri baseUrl,
43              VssHttpMessageHandler innerHandler,
44              IEnumerable&lt;DelegatingHandler&gt; delegatingHandlers,
45              Boolean allowUnattributedClients)
46          {
47              ArgumentUtility.CheckForNull(baseUrl, &quot;baseUrl&quot;);
48              ArgumentUtility.CheckForNull(innerHandler, &quot;innerHandler&quot;);
49              m_delegatingHandlers = delegatingHandlers = delegatingHandlers ?? Enumerable.Empty&lt;DelegatingHandler&gt;();
50              m_baseUrl = baseUrl;
51              m_innerHandler = innerHandler;
52              m_allowUnattributedClients = allowUnattributedClients;
53              if (this.Settings.MaxRetryRequest &gt; 0)
54              {
55                  delegatingHandlers = delegatingHandlers.Concat(new DelegatingHandler[] { new VssHttpRetryMessageHandler(this.Settings.MaxRetryRequest) });
56              }
57              if (delegatingHandlers.Any())
58              {
59                  m_pipeline = HttpClientFactory.CreatePipeline(m_innerHandler, delegatingHandlers);
60              }
61              else
62              {
63                  m_pipeline = m_innerHandler;
64              }
65              m_serverDataProvider = new VssServerDataProvider(this, m_pipeline, m_baseUrl.AbsoluteUri);
66              if (innerHandler.Credentials != null)
67              {
68                  if (innerHandler.Credentials.Federated != null)
69                  {
70                      innerHandler.Credentials.Federated.TokenStorageUrl = baseUrl;
71                  }
72              }
73          }
74          public Task ConnectAsync(
75              CancellationToken cancellationToken = default(CancellationToken))
76          {
77              return ConnectAsync(VssConnectMode.Automatic, null, cancellationToken);
78          }
79          public Task ConnectAsync(
80              VssConnectMode connectMode,
81              IDictionary&lt;String, String&gt; parameters,
82              CancellationToken cancellationToken = default(CancellationToken))
83          {
84              CheckForDisposed();
85              if (Credentials.Federated != null &amp;&amp; Credentials.Federated.Prompt != null)
86              {
87                  if (parameters != null)
88                  {
89                      parameters = new Dictionary&lt;String, String&gt;(parameters);
90                  }
91                  else
92                  {
93                      parameters = new Dictionary&lt;String, String&gt;();
94                  }
95                  IVssCredentialPrompt promptToSetParametersOn;
96                  IVssCredentialPrompts credentialPrompts = Credentials.Federated.Prompt as IVssCredentialPrompts;
97                  if (credentialPrompts != null &amp;&amp; credentialPrompts.FederatedPrompt != null)
98                  {
99                      promptToSetParametersOn = credentialPrompts.FederatedPrompt;
100                  }
101                  else
102                  {
103                      promptToSetParametersOn = Credentials.Federated.Prompt;
104                  }
105                  parameters[VssConnectionParameterKeys.VssConnectionMode] = connectMode.ToString();
106                  promptToSetParametersOn.Parameters = parameters;
107              }
108              return ServerDataProvider.ConnectAsync(ConnectOptions.None, cancellationToken);
109          }
110          public void Disconnect()
111          {
112              try
113              {
114                  if (HasAuthenticated)
115                  {
116                      m_innerHandler.Credentials.SignOut(Uri, null, null);
117                  }
118              }
119              finally
120              {
121                  ServerDataProvider.DisconnectAsync().SyncResult();
122              }
123          }
124          public T GetService&lt;T&gt;() where T : IVssClientService
125          {
126              return (T)GetClientServiceImplAsync(typeof(T), Guid.Empty, GetServiceInstanceAsync).SyncResult();
127          }
128          public async Task&lt;T&gt; GetServiceAsync&lt;T&gt;(CancellationToken cancellationToken = default(CancellationToken)) where T : IVssClientService
129          {
130              return (T)await GetClientServiceImplAsync(typeof(T), Guid.Empty, GetServiceInstanceAsync, cancellationToken).ConfigureAwait(false);
131          }
132          public T GetClient&lt;T&gt;() where T : VssHttpClientBase
133          {
134              return GetClientAsync&lt;T&gt;().SyncResult();
135          }
136          public async Task&lt;T&gt; GetClientAsync&lt;T&gt;(CancellationToken cancellationToken = default(CancellationToken)) where T : VssHttpClientBase
137          {
138              CheckForDisposed();
139              Type clientType = typeof(T);
140              Guid serviceIdentifier = GetServiceIdentifier(clientType);
141              if (serviceIdentifier == Guid.Empty &amp;&amp; !m_allowUnattributedClients)
142              {
143                  throw new CannotGetUnattributedClientException(clientType);
144              }
145              return (T)await GetClientServiceImplAsync(typeof(T), serviceIdentifier, GetClientInstanceAsync, cancellationToken).ConfigureAwait(false);
146          }
147          private async Task&lt;Object&gt; GetClientServiceImplAsync(
148              Type requestedType,
149              Guid serviceIdentifier,
150              Func&lt;Type, Guid, CancellationToken, Task&lt;Object&gt;&gt; getInstanceAsync,
151              CancellationToken cancellationToken = default(CancellationToken))
152          {
153              CheckForDisposed();
154              Object requestedObject = null;
155              Type managedType = GetExtensibleType(requestedType);
156              ClientCacheKey cacheKey = new ClientCacheKey(managedType, serviceIdentifier);
157              if (!m_cachedTypes.TryGetValue(cacheKey, out requestedObject))
158              {
159                  AsyncLock typeLock = m_loadingTypes.GetOrAdd(cacheKey, (t) =&gt; new AsyncLock());
160                  using (await typeLock.LockAsync(cancellationToken).ConfigureAwait(false))
161                  {
162                      if (!m_cachedTypes.TryGetValue(cacheKey, out requestedObject))
163                      {
164                          requestedObject = await getInstanceAsync(managedType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
165                          m_cachedTypes[cacheKey] = requestedObject;
166                          AsyncLock removed;
167                          m_loadingTypes.TryRemove(cacheKey, out removed);
168                      }
169                  }
170              }
171              return requestedObject;
172          }
173          private Task&lt;Object&gt; GetClientInstanceAsync(
174              Type managedType,
175              Guid serviceIdentifier,
176              CancellationToken cancellationToken)
177          {
178              return GetClientInstanceAsync(managedType, serviceIdentifier, cancellationToken, null, null);
179          }
180          private async Task&lt;Object&gt; GetClientInstanceAsync(
181              Type managedType,
182              Guid serviceIdentifier,
183              CancellationToken cancellationToken,
184              VssHttpRequestSettings settings,
185              DelegatingHandler[] handlers)
186          {
187              CheckForDisposed();
188              ILocationService locationService = await GetServiceAsync&lt;ILocationService&gt;(cancellationToken).ConfigureAwait(false);
189              ILocationDataProvider locationData = await locationService.GetLocationDataAsync(serviceIdentifier, cancellationToken).ConfigureAwait(false);
190              if (locationData == null)
191              {
192                  throw new VssServiceException(WebApiResources.ServerDataProviderNotFound(serviceIdentifier));
193              }
194              String serviceLocationString = await locationData.LocationForCurrentConnectionAsync(
195                  ServiceInterfaces.LocationService2,
196                  LocationServiceConstants.SelfReferenceIdentifier,
197                  cancellationToken).ConfigureAwait(false);
198              Uri clientBaseUri = new Uri(serviceLocationString);
199              VssHttpClientBase toReturn = null;
200              if (settings != null)
201              {
202                  toReturn = (VssHttpClientBase)Activator.CreateInstance(managedType, clientBaseUri, Credentials, settings, handlers);
203              }
204              else
205              {
206                  toReturn = (VssHttpClientBase)Activator.CreateInstance(managedType, clientBaseUri, m_pipeline, false &amp;bsol;* disposeHandler */);
207              }
208              ApiResourceLocationCollection resourceLocations = await locationData.GetResourceLocationsAsync(cancellationToken).ConfigureAwait(false);
209              toReturn.SetResourceLocations(resourceLocations);
210              return toReturn;
211          }
212          private Guid GetServiceIdentifier(
213              Type requestedType)
214          {
215              ResourceAreaAttribute[] attributes = (ResourceAreaAttribute[])requestedType.GetTypeInfo().GetCustomAttributes&lt;ResourceAreaAttribute&gt;(true);
216              if (attributes.Length &gt; 0)
217              {
218                  return attributes[0].AreaId;
219              }
220              else
221              {
222                  return Guid.Empty;
223              }
224          }
225          private Task&lt;Object&gt; GetServiceInstanceAsync(
226              Type managedType,
227              Guid serviceIdentifier,
228              CancellationToken cancellationToken)
229          {
230              CheckForDisposed();
231              IVssClientService clientService;
232              try
233              {
234                  clientService = (IVssClientService)Activator.CreateInstance(managedType);
235              }
236              catch (MissingMemberException ex)
237              {
238                  throw new ArgumentException(WebApiResources.GetServiceArgumentError(managedType), ex);
239              }
240              clientService.Initialize(this);
241              return Task.FromResult&lt;Object&gt;(clientService);
242          }
243          private Type GetExtensibleType(Type managedType)
244          {
245              if (managedType.GetTypeInfo().IsAbstract || managedType.GetTypeInfo().IsInterface)
246              {
<span onclick='openModal()' class='match'>247                  Type extensibleType = null;
248                  if (!m_extensibleServiceTypes.TryGetValue(managedType.Name, out extensibleType))
249                  {
250                      VssClientServiceImplementationAttribute[] attributes = (VssClientServiceImplementationAttribute[])managedType.GetTypeInfo().GetCustomAttributes&lt;VssClientServiceImplementationAttribute&gt;(true);
251                      if (attributes.Length &gt; 0)
252                      {
253                          if (attributes[0].Type != null)
254                          {
255                              extensibleType = attributes[0].Type;
256                              m_extensibleServiceTypes[managedType.Name] = extensibleType;
257                          }
258                          else if (!String.IsNullOrEmpty(attributes[0].TypeName))
259                          {
260                              extensibleType = Type.GetType(attributes[0].TypeName);
261                              if (extensibleType != null)
262                              {
263                                  m_extensibleServiceTypes[managedType.Name] = extensibleType;
264                              }
265                              else
266                              {
267                                  Debug.Assert(false, &quot;VssConnection: Could not load type from type name: &quot; + attributes[0].TypeName);
268                              }
269                          }
270                      }
271                  }
272                  if (extensibleType == null)
273                  {
274                      throw new ExtensibleServiceTypeNotRegisteredException(managedType);
275                  }
276                  if (!managedType.GetTypeInfo().IsAssignableFrom(extensibleType.GetTypeInfo()))
277                  {
278                      throw new ExtensibleServiceTypeNotValidException(managedType, extensibleType);
279                  }
280                  return extensibleType;
281              }
282              else
283              {
284                  return managedType;
285              }
286          }
287          internal void RegisterExtensibleType(
</span>288              String typeName,
289              Type type)
290          {
291              ArgumentUtility.CheckStringForNullOrEmpty(typeName, &quot;typeName&quot;);
292              ArgumentUtility.CheckForNull(type, &quot;type&quot;);
293              m_extensibleServiceTypes[typeName] = type;
294          }
295          private bool m_isDisposed = false;
296          private object m_disposeLock = new object();
297          public void Dispose()
298          {
299              if (!m_isDisposed)
300              {
301                  lock (m_disposeLock)
302                  {
303                      if (!m_isDisposed)
304                      {
305                          m_isDisposed = true;
306                          foreach (var cachedType in m_cachedTypes.Values.Where(v =&gt; v is IDisposable).Select(v =&gt; v as IDisposable))
307                          {
308                              cachedType.Dispose();
309                          }
310                          m_cachedTypes.Clear();
311                          Disconnect();
312                          if (m_parentConnection != null)
313                          {
314                              m_parentConnection.Dispose();
315                              m_parentConnection = null;
316                          }
317                      }
318                  }
319              }
320          }
321          private void CheckForDisposed()
322          {
323              if (m_isDisposed)
324              {
325                  throw new ObjectDisposedException(this.GetType().Name);
326              }
327          }
328          public Uri Uri
329          {
330              get
331              {
332                  return m_baseUrl;
333              }
334          }
335          public VssHttpMessageHandler InnerHandler
336          {
337              get
338              {
339                  return m_innerHandler;
340              }
341          }
342          public IEnumerable&lt;DelegatingHandler&gt; DelegatingHandlers
343          {
344              get
345              {
346                  return m_delegatingHandlers;
347              }
348          }
349          public VssCredentials Credentials
350          {
351              get
352              {
353                  return m_innerHandler.Credentials;
354              }
355          }
356          public VssClientHttpRequestSettings Settings
357          {
358              get
359              {
360                  return (VssClientHttpRequestSettings)m_innerHandler.Settings;
361              }
362          }
363          public Guid ServerId
364          {
365              get
366              {
367                  return ServerDataProvider.GetInstanceIdAsync().SyncResult();
368              }
369          }
370          public Guid ServerType
371          {
372              get
373              {
374                  return ServerDataProvider.GetInstanceTypeAsync().SyncResult();
375              }
376          }
377          public Identity.Identity AuthorizedIdentity
378          {
379              get
380              {
381                  return ServerDataProvider.GetAuthorizedIdentityAsync().SyncResult();
382              }
383          }
384          [EditorBrowsable(EditorBrowsableState.Never)]
385          public Identity.Identity AuthenticatedIdentity
386          {
387              get
388              {
389                  return ServerDataProvider.GetAuthenticatedIdentityAsync().SyncResult();
390              }
391          }
392          public Boolean HasAuthenticated
393          {
394              get
395              {
396                  return ServerDataProvider.HasConnected;
397              }
398          }
399          public VssConnection ParentConnection
400          {
401              get
402              {
403                  CheckForDisposed();
404                  if (m_parentConnection == null)
405                  {
406                      lock (m_parentConnectionLock)
407                      {
408                          ILocationService locationService = GetService&lt;ILocationService&gt;();
409                          ILocationDataProvider locationData = locationService.GetLocationData(Guid.Empty);
410                          String applicationLocation = locationData.LocationForCurrentConnection(
411                              ServiceInterfaces.LocationService2,
412                              LocationServiceConstants.ApplicationIdentifier);
413                          if (String.IsNullOrEmpty(applicationLocation))
414                          {
415                              throw new VssServiceException(WebApiResources.ServerDataProviderNotFound(LocationServiceConstants.ApplicationIdentifier));
416                          }
417                          m_parentConnection = new VssConnection(
418                              new Uri(applicationLocation),
419                              new VssHttpMessageHandler(Credentials, VssClientHttpRequestSettings.Default.Clone()),
420                              null,
421                              allowUnattributedClients: false);
422                      }
423                  }
424                  return m_parentConnection;
425              }
426          }
427          internal IVssServerDataProvider ServerDataProvider
428          {
429              get
430              {
431                  return m_serverDataProvider;
432              }
433              set
434              {
435                  m_serverDataProvider = value;
436              }
437          }
438          private IVssServerDataProvider m_serverDataProvider;
439          private VssConnection m_parentConnection;
440          private Object m_parentConnectionLock = new Object();
441          private readonly Uri m_baseUrl;
442          private readonly HttpMessageHandler m_pipeline;
443          private readonly VssHttpMessageHandler m_innerHandler;
444          private readonly IEnumerable&lt;DelegatingHandler&gt; m_delegatingHandlers;
445          private readonly Boolean m_allowUnattributedClients;
446          private readonly ConcurrentDictionary&lt;ClientCacheKey, AsyncLock&gt; m_loadingTypes = new ConcurrentDictionary&lt;ClientCacheKey, AsyncLock&gt;(ClientCacheKey.Comparer);
447          private readonly ConcurrentDictionary&lt;ClientCacheKey, Object&gt; m_cachedTypes = new ConcurrentDictionary&lt;ClientCacheKey, Object&gt;(ClientCacheKey.Comparer);
448          private readonly ConcurrentDictionary&lt;String, Type&gt; m_extensibleServiceTypes = new ConcurrentDictionary&lt;String, Type&gt;();
449          private struct ClientCacheKey
450          {
451              public ClientCacheKey(Type type, Guid serviceIdentifier)
452              {
453                  this.Type = type;
454                  this.ServiceIdentifier = serviceIdentifier;
455              }
456              public readonly Type Type;
457              public readonly Guid ServiceIdentifier;
458              public static readonly IEqualityComparer&lt;ClientCacheKey&gt; Comparer = new ClientCacheKeyComparer();
459              private class ClientCacheKeyComparer : IEqualityComparer&lt;ClientCacheKey&gt;
460              {
461                  public bool Equals(ClientCacheKey x, ClientCacheKey y)
462                  {
463                      return x.Type.Equals(y.Type) &amp;&amp;
464                             x.ServiceIdentifier.Equals(y.ServiceIdentifier);
465                  }
466                  public int GetHashCode(ClientCacheKey obj)
467                  {
468                      return obj.Type.GetHashCode() ^ obj.ServiceIdentifier.GetHashCode();
469                  }
470              }
471          }
472      }
473      public interface IVssClientService
474      {
475          void Initialize(VssConnection connection);
476      }
477      [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
478      [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1019:DefineAccessorsForAttributeArguments&quot;, Justification = &quot;FxCop can&#x27;t tell that we have an accessor.&quot;)]
479      public sealed class VssClientServiceImplementationAttribute : Attribute
480      {
481          public VssClientServiceImplementationAttribute(Type type)
482          {
483              this.Type = type;
484          }
485          public VssClientServiceImplementationAttribute(String typeName)
486          {
487              this.TypeName = typeName;
488          }
489          public Type Type
490          {
491              get;
492              set;
493          }
494          public String TypeName
495          {
496              get;
497              set;
498          }
499      }
500      [ExceptionMapping(&quot;0.0&quot;, &quot;3.0&quot;, &quot;ExtensibleServiceTypeNotRegisteredException&quot;, &quot;GitHub.Services.Client.ExtensibleServiceTypeNotRegisteredException, GitHub.Services.Client, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot;)]
501      public class ExtensibleServiceTypeNotRegisteredException : VssException
502      {
503          public ExtensibleServiceTypeNotRegisteredException(Type managedType)
504              : base(WebApiResources.ExtensibleServiceTypeNotRegistered(managedType.Name))
505          {
506          }
507          public ExtensibleServiceTypeNotRegisteredException(String message, Exception innerException)
508              : base(message, innerException)
509          {
510          }
511      }
512      [ExceptionMapping(&quot;0.0&quot;, &quot;3.0&quot;, &quot;ExtensibleServiceTypeNotValidException&quot;, &quot;GitHub.Services.Client.ExtensibleServiceTypeNotValidException, GitHub.Services.Client, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot;)]
513      public class ExtensibleServiceTypeNotValidException : VssException
514      {
515          public ExtensibleServiceTypeNotValidException(Type managedType, Type extensibleType)
516              : base(WebApiResources.ExtensibleServiceTypeNotValid(managedType.Name, extensibleType.Name))
517          {
518          }
519          public ExtensibleServiceTypeNotValidException(String message, Exception innerException)
520              : base(message, innerException)
521          {
522          }
523      }
524      public class CannotGetUnattributedClientException : VssException
525      {
526          public CannotGetUnattributedClientException(Type clientType)
527              : base(WebApiResources.CannotGetUnattributedClient(clientType.Name))
528          {
529          }
530          public CannotGetUnattributedClientException(String message, Exception innerException)
531              : base(message, innerException)
532          {
533          }
534      }
535  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-RawConnection.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Diagnostics;
5  using System.Linq;
6  using System.Net.Http;
7  using System.Reflection;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using GitHub.Services.Common;
11  using GitHub.Services.OAuth;
12  using GitHub.Services.WebApi;
13  using GitHub.Services.WebApi.Utilities;
14  namespace Sdk.WebApi.WebApi.RawClient
15  {
16      public class RawConnection : IDisposable
17      {
18          public RawConnection(
19              Uri baseUrl,
20              VssOAuthCredential credentials,
21              RawClientHttpRequestSettings settings)
22              : this(baseUrl, new RawHttpMessageHandler(credentials, settings), null)
23          {
24          }
25          public RawConnection(
26              Uri baseUrl,
27              RawHttpMessageHandler innerHandler,
28              IEnumerable&lt;DelegatingHandler&gt; delegatingHandlers)
29          {
30              ArgumentUtility.CheckForNull(baseUrl, &quot;baseUrl&quot;);
31              ArgumentUtility.CheckForNull(innerHandler, &quot;innerHandler&quot;);
32              m_delegatingHandlers = delegatingHandlers = delegatingHandlers ?? Enumerable.Empty&lt;DelegatingHandler&gt;();
33              m_baseUrl = baseUrl;
34              m_innerHandler = innerHandler;
35              if (this.Settings.MaxRetryRequest &gt; 0)
36              {
37                  delegatingHandlers = delegatingHandlers.Concat(new DelegatingHandler[] { new VssHttpRetryMessageHandler(this.Settings.MaxRetryRequest) });
38              }
39              if (delegatingHandlers.Any())
40              {
41                  m_pipeline = HttpClientFactory.CreatePipeline(m_innerHandler, delegatingHandlers);
42              }
43              else
44              {
45                  m_pipeline = m_innerHandler;
46              }
47          }
48          public RawClientHttpRequestSettings Settings
49          {
50              get
51              {
52                  return (RawClientHttpRequestSettings)m_innerHandler.Settings;
53              }
54          }
55          public async Task&lt;T&gt; GetClientAsync&lt;T&gt;(CancellationToken cancellationToken = default(CancellationToken)) where T : RawHttpClientBase
56          {
57              CheckForDisposed();
58              Type clientType = typeof(T);
59              return (T)await GetClientServiceImplAsync(typeof(T), cancellationToken).ConfigureAwait(false);
60          }
61          private async Task&lt;Object&gt; GetClientServiceImplAsync(
62              Type requestedType,
63              CancellationToken cancellationToken = default(CancellationToken))
64          {
65              CheckForDisposed();
66              Object requestedObject = null;
67              Type managedType = GetExtensibleType(requestedType);
68              if (!m_cachedTypes.TryGetValue(managedType, out requestedObject))
69              {
70                  AsyncLock typeLock = m_loadingTypes.GetOrAdd(managedType, (t) =&gt; new AsyncLock());
71                  using (await typeLock.LockAsync(cancellationToken).ConfigureAwait(false))
72                  {
73                      if (!m_cachedTypes.TryGetValue(managedType, out requestedObject))
74                      {
75                          requestedObject = (RawHttpClientBase)Activator.CreateInstance(managedType, m_baseUrl, m_pipeline, false &amp;bsol;* disposeHandler */);
76                          m_cachedTypes[managedType] = requestedObject;
77                          AsyncLock removed;
78                          m_loadingTypes.TryRemove(managedType, out removed);
79                      }
80                  }
81              }
82              return requestedObject;
83          }
84          private Type GetExtensibleType(Type managedType)
85          {
86              if (managedType.GetTypeInfo().IsAbstract || managedType.GetTypeInfo().IsInterface)
87              {
<span onclick='openModal()' class='match'>88                  Type extensibleType = null;
89                  if (!m_extensibleServiceTypes.TryGetValue(managedType.Name, out extensibleType))
90                  {
91                      VssClientServiceImplementationAttribute[] attributes = (VssClientServiceImplementationAttribute[])managedType.GetTypeInfo().GetCustomAttributes&lt;VssClientServiceImplementationAttribute&gt;(true);
92                      if (attributes.Length &gt; 0)
93                      {
94                          if (attributes[0].Type != null)
95                          {
96                              extensibleType = attributes[0].Type;
97                              m_extensibleServiceTypes[managedType.Name] = extensibleType;
98                          }
99                          else if (!String.IsNullOrEmpty(attributes[0].TypeName))
100                          {
101                              extensibleType = Type.GetType(attributes[0].TypeName);
102                              if (extensibleType != null)
103                              {
104                                  m_extensibleServiceTypes[managedType.Name] = extensibleType;
105                              }
106                              else
107                              {
108                                  Debug.Assert(false, &quot;VssConnection: Could not load type from type name: &quot; + attributes[0].TypeName);
109                              }
110                          }
111                      }
112                  }
113                  if (extensibleType == null)
114                  {
115                      throw new ExtensibleServiceTypeNotRegisteredException(managedType);
116                  }
117                  if (!managedType.GetTypeInfo().IsAssignableFrom(extensibleType.GetTypeInfo()))
118                  {
119                      throw new ExtensibleServiceTypeNotValidException(managedType, extensibleType);
120                  }
121                  return extensibleType;
122              }
123              else
124              {
125                  return managedType;
126              }
127          }
128          public void Dispose()
</span>129          {
130              if (!m_isDisposed)
131              {
132                  lock (m_disposeLock)
133                  {
134                      if (!m_isDisposed)
135                      {
136                          m_isDisposed = true;
137                          foreach (var cachedType in m_cachedTypes.Values.Where(v =&gt; v is IDisposable).Select(v =&gt; v as IDisposable))
138                          {
139                              cachedType.Dispose();
140                          }
141                          m_cachedTypes.Clear();
142                      }
143                  }
144              }
145          }
146          private void CheckForDisposed()
147          {
148              if (m_isDisposed)
149              {
150                  throw new ObjectDisposedException(this.GetType().Name);
151              }
152          }
153          private bool m_isDisposed = false;
154          private object m_disposeLock = new object();
155          private readonly ConcurrentDictionary&lt;String, Type&gt; m_extensibleServiceTypes = new ConcurrentDictionary&lt;String, Type&gt;();
156          private readonly Uri m_baseUrl;
157          private readonly HttpMessageHandler m_pipeline;
158          private readonly IEnumerable&lt;DelegatingHandler&gt; m_delegatingHandlers;
159          private readonly RawHttpMessageHandler m_innerHandler;
160          private readonly ConcurrentDictionary&lt;Type, AsyncLock&gt; m_loadingTypes = new ConcurrentDictionary&lt;Type, AsyncLock&gt;();
161          private readonly ConcurrentDictionary&lt;Type, Object&gt; m_cachedTypes = new ConcurrentDictionary&lt;Type, Object&gt;();
162      }
163  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssConnection.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-RawConnection.cs</div>
                </div>
                <div class="column column_space"><pre><code>247                  Type extensibleType = null;
248                  if (!m_extensibleServiceTypes.TryGetValue(managedType.Name, out extensibleType))
249                  {
250                      VssClientServiceImplementationAttribute[] attributes = (VssClientServiceImplementationAttribute[])managedType.GetTypeInfo().GetCustomAttributes&lt;VssClientServiceImplementationAttribute&gt;(true);
251                      if (attributes.Length &gt; 0)
252                      {
253                          if (attributes[0].Type != null)
254                          {
255                              extensibleType = attributes[0].Type;
256                              m_extensibleServiceTypes[managedType.Name] = extensibleType;
257                          }
258                          else if (!String.IsNullOrEmpty(attributes[0].TypeName))
259                          {
260                              extensibleType = Type.GetType(attributes[0].TypeName);
261                              if (extensibleType != null)
262                              {
263                                  m_extensibleServiceTypes[managedType.Name] = extensibleType;
264                              }
265                              else
266                              {
267                                  Debug.Assert(false, &quot;VssConnection: Could not load type from type name: &quot; + attributes[0].TypeName);
268                              }
269                          }
270                      }
271                  }
272                  if (extensibleType == null)
273                  {
274                      throw new ExtensibleServiceTypeNotRegisteredException(managedType);
275                  }
276                  if (!managedType.GetTypeInfo().IsAssignableFrom(extensibleType.GetTypeInfo()))
277                  {
278                      throw new ExtensibleServiceTypeNotValidException(managedType, extensibleType);
279                  }
280                  return extensibleType;
281              }
282              else
283              {
284                  return managedType;
285              }
286          }
287          internal void RegisterExtensibleType(
</pre></code></div>
                <div class="column column_space"><pre><code>88                  Type extensibleType = null;
89                  if (!m_extensibleServiceTypes.TryGetValue(managedType.Name, out extensibleType))
90                  {
91                      VssClientServiceImplementationAttribute[] attributes = (VssClientServiceImplementationAttribute[])managedType.GetTypeInfo().GetCustomAttributes&lt;VssClientServiceImplementationAttribute&gt;(true);
92                      if (attributes.Length &gt; 0)
93                      {
94                          if (attributes[0].Type != null)
95                          {
96                              extensibleType = attributes[0].Type;
97                              m_extensibleServiceTypes[managedType.Name] = extensibleType;
98                          }
99                          else if (!String.IsNullOrEmpty(attributes[0].TypeName))
100                          {
101                              extensibleType = Type.GetType(attributes[0].TypeName);
102                              if (extensibleType != null)
103                              {
104                                  m_extensibleServiceTypes[managedType.Name] = extensibleType;
105                              }
106                              else
107                              {
108                                  Debug.Assert(false, &quot;VssConnection: Could not load type from type name: &quot; + attributes[0].TypeName);
109                              }
110                          }
111                      }
112                  }
113                  if (extensibleType == null)
114                  {
115                      throw new ExtensibleServiceTypeNotRegisteredException(managedType);
116                  }
117                  if (!managedType.GetTypeInfo().IsAssignableFrom(extensibleType.GetTypeInfo()))
118                  {
119                      throw new ExtensibleServiceTypeNotValidException(managedType, extensibleType);
120                  }
121                  return extensibleType;
122              }
123              else
124              {
125                  return managedType;
126              }
127          }
128          public void Dispose()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    