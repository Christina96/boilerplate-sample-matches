
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.6225045372050815%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DORotateTests.cs</h3>
            <pre><code>1  using System.Collections;
2  using System.Collections.Generic;
3  using DG.Tweening;
4  using DG.Tweening.Core;
5  using DG.Tweening.Plugins.Options;
6  using UnityEngine;
7  public class DORotateTests : BrainBase
8  {
9      public enum TweenType
10      {
11          Normal,
12          FromCurrent,
13          FromDirect
14      }
15      [Header("Main")]
16      public TweenType tweenType = TweenType.Normal;
17      float tweenDuration = 2;
18      public bool isRelative = false;
19      public bool isFrom = false;
20      public Vector2 offsetBetweenDices = new Vector2(7, 4);
21      public int maxDicesPerRow = 4;
22      [Range(-1, 10)]
23      public int focusOnlyOnDice = -1;
24      [Header("Fast")]
25      public Vector3[] fastStartValues = new[] {
26          new Vector3(0, 0, 0),
27          new Vector3(85, 0, 0),
28          new Vector3(95, 0, 0),
29          new Vector3(180, 0, 0),
30          new Vector3(0, 85, 0),
31          new Vector3(0, 95, 0),
32          new Vector3(0, 0, 85),
33          new Vector3(0, 0, 95),
34          new Vector3(180, 0, 0),
35      };
36      public Vector3 fastEndValue = new Vector3(100, 0, 0);
37      [Header("Beyond360")]
38      public Vector3[] beyond360StartValues = new[] {
39          new Vector3(0, 0, 0),
40          new Vector3(85, 0, 0),
41          new Vector3(95, 0, 0),
42          new Vector3(180, 0, 0),
43          new Vector3(0, 85, 0),
44          new Vector3(0, 95, 0),
45          new Vector3(0, 0, 85),
46          new Vector3(0, 0, 95),
47          new Vector3(180, 0, 0),
48      };
49      public Vector3 beyond360EndValue = new Vector3(100, 0, 0);
50      [Header("WorldAxisAdd")]
51      public Vector3[] worldAxisAddStartValues = new[] {
52          new Vector3(0, 0, 0),
53          new Vector3(85, 0, 0),
54          new Vector3(95, 0, 0),
55          new Vector3(180, 0, 0),
56          new Vector3(0, 85, 0),
57          new Vector3(0, 95, 0),
58          new Vector3(0, 0, 85),
59          new Vector3(0, 0, 95),
60          new Vector3(180, 0, 0),
61      };
62      public Vector3 worldAxisAddEndValue = new Vector3(100, 0, 0);
63      [Header("LocalAxisAdd")]
64      public Vector3[] localAxisAddStartValues = new[] {
65          new Vector3(0, 0, 0),
66          new Vector3(85, 0, 0),
67          new Vector3(95, 0, 0),
68          new Vector3(180, 0, 0),
69          new Vector3(0, 85, 0),
70          new Vector3(0, 95, 0),
71          new Vector3(0, 0, 85),
72          new Vector3(0, 0, 95),
73          new Vector3(180, 0, 0),
74      };
75      public Vector3 localAxisAddEndValue = new Vector3(100, 0, 0);
76      GameObject[] _dices;
77      GameObject _diceGroupPrefab;
78      RotateMode _currRotateMode;
79      #region Main Methods
80      void Start()
81      {
82          _diceGroupPrefab = GameObject.Find("n:DiceGroupPrefab");
83          _diceGroupPrefab.SetActive(false);
84      }
85      void SetupFor(RotateMode mode)
86      {
87          DOTween.KillAll();
88          if (_dices != null) {
89              for (int i = 0; i < _dices.Length; ++i) Destroy(_dices[i]);
90              _dices = null;
91          }
92          _currRotateMode = mode;
93          Vector3[] startVals;
94          Vector3 endVal;
95          switch (mode) {
96          case RotateMode.FastBeyond360:
97              startVals = beyond360StartValues;
98              endVal = beyond360EndValue;
99              break;
100          case RotateMode.WorldAxisAdd:
101              startVals = worldAxisAddStartValues;
102              endVal = worldAxisAddEndValue;
103              break;
104          case RotateMode.LocalAxisAdd:
105              startVals = localAxisAddStartValues;
106              endVal = localAxisAddEndValue;
107              break;
108          default:
109              startVals = fastStartValues;
110              endVal = fastEndValue;
111              break;
112          }
113          int totDices = startVals.Length;
114          int totRows = Mathf.CeilToInt(totDices / (float)maxDicesPerRow);
115          Vector3 startP = new Vector3(
116              -(offsetBetweenDices.x * (Mathf.Min(totDices, maxDicesPerRow) - 1)) * 0.5f,
117              (offsetBetweenDices.y * (totRows + 1)) * 0.5f,
118              0
119          );
120          int xIndex = -1;
121          _dices = new GameObject[totDices];
122          for (int i = 0; i < totDices; ++i) {
123              if (focusOnlyOnDice > -1 && i != focusOnlyOnDice) {
124                  _dices[i] = null;
125                  continue;
126              }
127              if (i % maxDicesPerRow == 0) {
128                  xIndex = -1;
129                  startP.y -= offsetBetweenDices.y;
130              }
131              xIndex++;
132              _dices[i] = Instantiate(_diceGroupPrefab, _diceGroupPrefab.transform.parent);
133              _dices[i].name = "Dice " + i;
134              _dices[i].SetActive(true);
135              _dices[i].transform.localPosition = startP + new Vector3(offsetBetweenDices.x, 0, 0) * xIndex;
136              Transform dice = GetDiceFromGroup(_dices[i]);
137              dice.localEulerAngles = startVals[i];
138              TextMesh label = _dices[i].GetComponentInChildren<TextMesh>();
<span onclick='openModal()' class='match'>139              label.text = startVals[i] + "\n" + Quaternion.Euler(startVals[i]).eulerAngles + "\n" + endVal + "\n" + FlipEulerAngles(endVal);
140          }
141      }
142      void StartTweening()
143      {
144          if (_dices == null) {
145              Debug.Log("Nothing to tween, Setup something first");
146              return;
147          }
148          DOTween.KillAll();
</span>149          Vector3[] startVals;
150          Vector3 endVal;
151          switch (_currRotateMode) {
152          case RotateMode.FastBeyond360:
153              startVals = beyond360StartValues;
154              endVal = beyond360EndValue;
155              break;
156          case RotateMode.WorldAxisAdd:
157              startVals = worldAxisAddStartValues;
158              endVal = worldAxisAddEndValue;
159              break;
160          case RotateMode.LocalAxisAdd:
161              startVals = localAxisAddStartValues;
162              endVal = localAxisAddEndValue;
163              break;
164          default:
165              startVals = fastStartValues;
166              endVal = fastEndValue;
167              break;
168          }
169          for (int i = 0; i < _dices.Length; ++i) {
170              if (_dices[i] == null) continue;
171              Transform dice = GetDiceFromGroup(_dices[i]);
172              TextMesh label = _dices[i].GetComponentInChildren<TextMesh>();
173              Vector3 startVal = startVals[i];
174              Vector3 actualEndVal = endVal;
175              TweenerCore<Quaternion, Vector3, QuaternionOptions> t;
176              switch (tweenType) {
177              case TweenType.FromCurrent:
178                  actualEndVal = startVal;
179                  t = dice.DOLocalRotate(endVal, tweenDuration, _currRotateMode).From();
180                  break;
181              case TweenType.FromDirect:
182                  actualEndVal = startVal;
183                  t = dice.DOLocalRotate(startVal, tweenDuration, _currRotateMode).From(endVal);
184                  break;
185              default:
186                  t = dice.DOLocalRotate(endVal, tweenDuration, _currRotateMode);
187                  if (isFrom) t.From(isRelative);
188                  else if (isRelative) t.SetRelative();
189                  break;
190              }
191              t.OnUpdate(() => {
192                  label.text = dice.eulerAngles + "\n" + actualEndVal;
193              });
194          }
195      }
196      #endregion
197      #region Utils
198      Transform GetDiceFromGroup(GameObject diceGroup)
199      {
200          Transform[] ts = diceGroup.GetComponentsInChildren<Transform>();
201          for (int i = 0; i < ts.Length; ++i) {
202              if (ts[i].name == "Dice") return ts[i];
203          }
204          return null;
205      }
206      Vector3 FlipEulerAngles(Vector3 euler)
207      {
208          return new Vector3(180 - euler.x, euler.y + 180, euler.z + 180);
209      }
210      #endregion
211      #region UI Buttons
212      public void SetupForFast()
213      {
214          SetupFor(RotateMode.Fast);
215      }
216      public void SetupForBeyond360()
217      {
218          SetupFor(RotateMode.FastBeyond360);
219      }
220      public void SetupForWorldAxisAdd()
221      {
222          SetupFor(RotateMode.WorldAxisAdd);
223      }
224      public void SetupForLocalAxisAdd()
225      {
226          SetupFor(RotateMode.LocalAxisAdd);
227      }
228      public void Tween()
229      {
230          StartTweening();
231      }
232      #endregion
233  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WsSession.cs</h3>
            <pre><code>1  using System;
2  using System.Net.Sockets;
3  using System.Text;
4  namespace NetCoreServer
5  {
6      public class WsSession : HttpSession, IWebSocket
7      {
8          internal readonly WebSocket WebSocket;
9          public WsSession(WsServer server) : base(server) { WebSocket = new WebSocket(this); }
10          public virtual bool Close(int status) { SendCloseAsync(status, Span<byte>.Empty); base.Disconnect(); return true; }
11          #region WebSocket send text methods
12          public long SendText(string text) => SendText(Encoding.UTF8.GetBytes(text));
13          public long SendText(ReadOnlySpan<char> text) => SendText(Encoding.UTF8.GetBytes(text.ToArray()));
14          public long SendText(byte[] buffer) => SendText(buffer.AsSpan());
15          public long SendText(byte[] buffer, long offset, long size) => SendText(buffer.AsSpan((int)offset, (int)size));
16          public long SendText(ReadOnlySpan<byte> buffer)
17          {
18              lock (WebSocket.WsSendLock)
19              {
20                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, false, buffer);
21                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
22              }
23          }
24          public bool SendTextAsync(string text) => SendTextAsync(Encoding.UTF8.GetBytes(text));
25          public bool SendTextAsync(ReadOnlySpan<char> text) => SendTextAsync(Encoding.UTF8.GetBytes(text.ToArray()));
26          public bool SendTextAsync(byte[] buffer) => SendTextAsync(buffer.AsSpan());
27          public bool SendTextAsync(byte[] buffer, long offset, long size) => SendTextAsync(buffer.AsSpan((int)offset, (int)size));
28          public bool SendTextAsync(ReadOnlySpan<byte> buffer)
29          {
30              lock (WebSocket.WsSendLock)
31              {
32                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, false, buffer);
33                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
34              }
35          }
36          #endregion
37          #region WebSocket send binary methods
38          public long SendBinary(string text) => SendBinary(Encoding.UTF8.GetBytes(text));
39          public long SendBinary(ReadOnlySpan<char> text) => SendBinary(Encoding.UTF8.GetBytes(text.ToArray()));
40          public long SendBinary(byte[] buffer) => SendBinary(buffer.AsSpan());
41          public long SendBinary(byte[] buffer, long offset, long size) => SendBinary(buffer.AsSpan((int)offset, (int)size));
42          public long SendBinary(ReadOnlySpan<byte> buffer)
43          {
44              lock (WebSocket.WsSendLock)
45              {
46                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, false, buffer);
47                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
48              }
49          }
50          public bool SendBinaryAsync(string text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text));
51          public bool SendBinaryAsync(ReadOnlySpan<char> text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text.ToArray()));
52          public bool SendBinaryAsync(byte[] buffer) => SendBinaryAsync(buffer.AsSpan());
53          public bool SendBinaryAsync(byte[] buffer, long offset, long size) => SendBinaryAsync(buffer.AsSpan((int)offset, (int)size));
54          public bool SendBinaryAsync(ReadOnlySpan<byte> buffer)
55          {
56              lock (WebSocket.WsSendLock)
57              {
58                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, false, buffer);
59                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
60              }
61          }
62          #endregion
63          #region WebSocket send close methods
64          public long SendClose(int status, string text) => SendClose(status, Encoding.UTF8.GetBytes(text));
65          public long SendClose(int status, ReadOnlySpan<char> text) => SendClose(status, Encoding.UTF8.GetBytes(text.ToArray()));
66          public long SendClose(int status, byte[] buffer) => SendClose(status, buffer.AsSpan());
67          public long SendClose(int status, byte[] buffer, long offset, long size) => SendClose(status, buffer.AsSpan((int)offset, (int)size));
68          public long SendClose(int status, ReadOnlySpan<byte> buffer)
69          {
70              lock (WebSocket.WsSendLock)
71              {
72                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, false, buffer, status);
73                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
74              }
75          }
76          public bool SendCloseAsync(int status, string text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text));
77          public bool SendCloseAsync(int status, ReadOnlySpan<char> text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text.ToArray()));
78          public bool SendCloseAsync(int status, byte[] buffer) => SendCloseAsync(status, buffer.AsSpan());
79          public bool SendCloseAsync(int status, byte[] buffer, long offset, long size) => SendCloseAsync(status, buffer.AsSpan((int)offset, (int)size));
80          public bool SendCloseAsync(int status, ReadOnlySpan<byte> buffer)
81          {
82              lock (WebSocket.WsSendLock)
83              {
84                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, false, buffer, status);
85                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
86              }
87          }
88          #endregion
89          #region WebSocket send ping methods
90          public long SendPing(string text) => SendPing(Encoding.UTF8.GetBytes(text));
91          public long SendPing(ReadOnlySpan<char> text) => SendPing(Encoding.UTF8.GetBytes(text.ToArray()));
92          public long SendPing(byte[] buffer) => SendPing(buffer.AsSpan());
93          public long SendPing(byte[] buffer, long offset, long size) => SendPing(buffer.AsSpan((int)offset, (int)size));
94          public long SendPing(ReadOnlySpan<byte> buffer)
95          {
96              lock (WebSocket.WsSendLock)
97              {
98                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, false, buffer);
99                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
100              }
101          }
102          public bool SendPingAsync(string text) => SendPingAsync(Encoding.UTF8.GetBytes(text));
103          public bool SendPingAsync(ReadOnlySpan<char> text) => SendPingAsync(Encoding.UTF8.GetBytes(text.ToArray()));
104          public bool SendPingAsync(byte[] buffer) => SendPingAsync(buffer.AsSpan());
105          public bool SendPingAsync(byte[] buffer, long offset, long size) => SendPingAsync(buffer.AsSpan((int)offset, (int)size));
106          public bool SendPingAsync(ReadOnlySpan<byte> buffer)
107          {
108              lock (WebSocket.WsSendLock)
109              {
110                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, false, buffer);
111                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
112              }
113          }
114          #endregion
115          #region WebSocket send pong methods
116          public long SendPong(string text) => SendPong(Encoding.UTF8.GetBytes(text));
117          public long SendPong(ReadOnlySpan<char> text) => SendPong(Encoding.UTF8.GetBytes(text.ToArray()));
118          public long SendPong(byte[] buffer) => SendPong(buffer.AsSpan());
119          public long SendPong(byte[] buffer, long offset, long size) => SendPong(buffer.AsSpan((int)offset, (int)size));
120          public long SendPong(ReadOnlySpan<byte> buffer)
121          {
122              lock (WebSocket.WsSendLock)
123              {
124                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, false, buffer);
125                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
126              }
127          }
128          public bool SendPongAsync(string text) => SendPongAsync(Encoding.UTF8.GetBytes(text));
129          public bool SendPongAsync(ReadOnlySpan<char> text) => SendPongAsync(Encoding.UTF8.GetBytes(text.ToArray()));
130          public bool SendPongAsync(byte[] buffer) => SendPongAsync(buffer.AsSpan());
131          public bool SendPongAsync(byte[] buffer, long offset, long size) => SendPongAsync(buffer.AsSpan((int)offset, (int)size));
132          public bool SendPongAsync(ReadOnlySpan<byte> buffer)
133          {
134              lock (WebSocket.WsSendLock)
135              {
136                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, false, buffer);
137                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
138              }
139          }
140          #endregion
141          #region WebSocket receive methods
142          public string ReceiveText()
143          {
144              Buffer result = new Buffer();
145              if (!WebSocket.WsHandshaked)
146                  return result.ExtractString(0, result.Data.Length);
147              Buffer cache = new Buffer();
148              while (!WebSocket.WsFinalReceived)
149              {
150                  while (!WebSocket.WsFrameReceived)
151                  {
152                      long required = WebSocket.RequiredReceiveFrameSize();
153                      cache.Resize(required);
154                      long received = base.Receive(cache.Data, 0, required);
155                      if (received != required)
156                          return result.ExtractString(0, result.Data.Length);
157                      WebSocket.PrepareReceiveFrame(cache.Data, 0, received);
158                  }
159                  if (!WebSocket.WsFinalReceived)
160                      WebSocket.PrepareReceiveFrame(null, 0, 0);
161              }
162              result.Append(WebSocket.WsReceiveFinalBuffer);
163              WebSocket.PrepareReceiveFrame(null, 0, 0);
164              return result.ExtractString(0, result.Data.Length);
165          }
166          public Buffer ReceiveBinary()
167          {
168              Buffer result = new Buffer();
169              if (!WebSocket.WsHandshaked)
170                  return result;
171              Buffer cache = new Buffer();
172              while (!WebSocket.WsFinalReceived)
173              {
174                  while (!WebSocket.WsFrameReceived)
175                  {
176                      long required = WebSocket.RequiredReceiveFrameSize();
177                      cache.Resize(required);
178                      long received = base.Receive(cache.Data, 0, required);
179                      if (received != required)
180                          return result;
181                      WebSocket.PrepareReceiveFrame(cache.Data, 0, received);
182                  }
183                  if (!WebSocket.WsFinalReceived)
184                      WebSocket.PrepareReceiveFrame(null, 0, 0);
185              }
186              result.Append(WebSocket.WsReceiveFinalBuffer);
187              WebSocket.PrepareReceiveFrame(null, 0, 0);
188              return result;
189          }
190          #endregion
191          #region Session handlers
192          protected override void OnDisconnecting()
193          {
194              if (WebSocket.WsHandshaked)
195                  OnWsDisconnecting();
196          }
197          protected override void OnDisconnected()
198          {
199              if (WebSocket.WsHandshaked)
200              {
201                  WebSocket.WsHandshaked = false;
202                  OnWsDisconnected();
203              }
204              Request.Clear();
205              Response.Clear();
<span onclick='openModal()' class='match'>206              WebSocket.ClearWsBuffers();
207              WebSocket.InitWsNonce();
208          }
209          protected override void OnReceived(byte[] buffer, long offset, long size)
210          {
211              if (WebSocket.WsHandshaked)
212              {
213                  WebSocket.PrepareReceiveFrame(buffer, offset, size);
214                  return;
215              }
216              base.OnReceived(buffer, offset, size);
</span>217          }
218          protected override void OnReceivedRequestHeader(HttpRequest request)
219          {
220              if (WebSocket.WsHandshaked)
221                  return;
222              if (!WebSocket.PerformServerUpgrade(request, Response))
223              {
224                  base.OnReceivedRequestHeader(request);
225                  return;
226              }
227          }
228          protected override void OnReceivedRequest(HttpRequest request)
229          {
230              if (WebSocket.WsHandshaked)
231              {
232                  var body = Request.Body;
233                  var data = Encoding.UTF8.GetBytes(body);
234                  WebSocket.PrepareReceiveFrame(data, 0, data.Length);
235                  return;
236              }
237              base.OnReceivedRequest(request);
238          }
239          protected override void OnReceivedRequestError(HttpRequest request, string error)
240          {
241              if (WebSocket.WsHandshaked)
242              {
243                  OnError(new SocketError());
244                  return;
245              }
246              base.OnReceivedRequestError(request, error);
247          }
248          #endregion
249          #region Web socket handlers
250          public virtual void OnWsConnecting(HttpRequest request) {}
251          public virtual void OnWsConnected(HttpResponse response) {}
252          public virtual bool OnWsConnecting(HttpRequest request, HttpResponse response) { return true; }
253          public virtual void OnWsConnected(HttpRequest request) {}
254          public virtual void OnWsDisconnecting() {}
255          public virtual void OnWsDisconnected() {}
256          public virtual void OnWsReceived(byte[] buffer, long offset, long size) {}
257          public virtual void OnWsClose(byte[] buffer, long offset, long size, int status = 1000) { Close(status); }
258          public virtual void OnWsPing(byte[] buffer, long offset, long size) { SendPongAsync(buffer, offset, size); }
259          public virtual void OnWsPong(byte[] buffer, long offset, long size) {}
260          public virtual void OnWsError(string error) { OnError(SocketError.SocketError); }
261          public virtual void OnWsError(SocketError error) { OnError(error); }
262          public void SendUpgrade(HttpResponse response) { SendResponseAsync(response); }
263          #endregion
264      }
265  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DORotateTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WsSession.cs</div>
                </div>
                <div class="column column_space"><pre><code>139              label.text = startVals[i] + "\n" + Quaternion.Euler(startVals[i]).eulerAngles + "\n" + endVal + "\n" + FlipEulerAngles(endVal);
140          }
141      }
142      void StartTweening()
143      {
144          if (_dices == null) {
145              Debug.Log("Nothing to tween, Setup something first");
146              return;
147          }
148          DOTween.KillAll();
</pre></code></div>
                <div class="column column_space"><pre><code>206              WebSocket.ClearWsBuffers();
207              WebSocket.InitWsNonce();
208          }
209          protected override void OnReceived(byte[] buffer, long offset, long size)
210          {
211              if (WebSocket.WsHandshaked)
212              {
213                  WebSocket.PrepareReceiveFrame(buffer, offset, size);
214                  return;
215              }
216              base.OnReceived(buffer, offset, size);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    