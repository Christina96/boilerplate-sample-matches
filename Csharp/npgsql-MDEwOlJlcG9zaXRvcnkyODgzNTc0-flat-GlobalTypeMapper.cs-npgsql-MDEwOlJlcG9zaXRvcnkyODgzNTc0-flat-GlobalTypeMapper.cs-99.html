
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using System.Threading;
9  using Npgsql.Internal.TypeHandling;
10  using Npgsql.Internal.TypeMapping;
11  using Npgsql.NameTranslation;
12  using NpgsqlTypes;
13  using static Npgsql.Util.Statics;
14  namespace Npgsql.TypeMapping;
15  sealed class GlobalTypeMapper : INpgsqlTypeMapper
16  {
17      public static GlobalTypeMapper Instance { get; }
18      public INpgsqlNameTranslator DefaultNameTranslator { get; set; } = new NpgsqlSnakeCaseNameTranslator();
19      internal List&lt;TypeHandlerResolverFactory&gt; HandlerResolverFactories { get; } = new();
20      List&lt;TypeMappingResolver&gt; MappingResolvers { get; } = new();
21      public ConcurrentDictionary&lt;string, IUserTypeMapping&gt; UserTypeMappings { get; } = new();
22      readonly ConcurrentDictionary&lt;Type, TypeMappingInfo&gt; _mappingsByClrType = new();
23      internal ReaderWriterLockSlim Lock { get; }
24          = new(LockRecursionPolicy.SupportsRecursion);
25      static GlobalTypeMapper()
26          =&gt; Instance = new GlobalTypeMapper();
27      GlobalTypeMapper()
28          =&gt; Reset();
29      #region Mapping management
30      public INpgsqlTypeMapper MapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
31          where TEnum : struct, Enum
32      {
33          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
34              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
35          nameTranslator ??= DefaultNameTranslator;
36          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
37          Lock.EnterWriteLock();
<span onclick='openModal()' class='match'>38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping&lt;TEnum&gt;(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
</span>50          where TEnum : struct, Enum
51      {
52          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
53              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
54          nameTranslator ??= DefaultNameTranslator;
55          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
56          Lock.EnterWriteLock();
57          try
58          {
59              if (UserTypeMappings.TryRemove(pgName, out _))
60              {
61                  RecordChange();
62                  return true;
63              }
64              return false;
65          }
66          finally
67          {
68              Lock.ExitWriteLock();
69          }
70      }
71      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
72      public INpgsqlTypeMapper MapComposite&lt;T&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
73      {
74          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
75              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
76          nameTranslator ??= DefaultNameTranslator;
77          pgName ??= GetPgName(typeof(T), nameTranslator);
78          Lock.EnterWriteLock();
79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping&lt;T&gt;(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
91      public INpgsqlTypeMapper MapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
92      {
93          var openMethod = typeof(GlobalTypeMapper).GetMethod(nameof(MapComposite), new[] { typeof(string), typeof(INpgsqlNameTranslator) })!;
94          var method = openMethod.MakeGenericMethod(clrType);
95          method.Invoke(this, new object?[] { pgName, nameTranslator });
96          return this;
97      }
98      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
99      public bool UnmapComposite&lt;T&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
100          =&gt; UnmapComposite(typeof(T), pgName, nameTranslator);
101      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
102      public bool UnmapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
103      {
104          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
105              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
106          nameTranslator ??= DefaultNameTranslator;
107          pgName ??= GetPgName(clrType, nameTranslator);
108          Lock.EnterWriteLock();
109          try
110          {
111              if (UserTypeMappings.TryRemove(pgName, out _))
112              {
113                  RecordChange();
114                  return true;
115              }
116              return false;
117          }
118          finally
119          {
120              Lock.ExitWriteLock();
121          }
122      }
123      public void AddTypeResolverFactory(TypeHandlerResolverFactory resolverFactory)
124      {
125          Lock.EnterWriteLock();
126          try
127          {
128              var type = resolverFactory.GetType();
129              if (HandlerResolverFactories[0].GetType() == type)
130                  HandlerResolverFactories[0] = resolverFactory;
131              else
132              {
133                  for (var i = 0; i &lt; HandlerResolverFactories.Count; i++)
134                      if (HandlerResolverFactories[i].GetType() == type)
135                          HandlerResolverFactories.RemoveAt(i);
136                  HandlerResolverFactories.Insert(0, resolverFactory);
137              }
138              var mappingResolver = resolverFactory.CreateMappingResolver();
139              if (mappingResolver is not null)
140                  AddMappingResolver(mappingResolver, overwrite: true);
141              RecordChange();
142          }
143          finally
144          {
145              Lock.ExitWriteLock();
146          }
147      }
148      internal void TryAddMappingResolver(TypeMappingResolver resolver)
149      {
150          Lock.EnterWriteLock();
151          try
152          {
153              if (AddMappingResolver(resolver, overwrite: false))
154                  RecordChange();
155          }
156          finally
157          {
158              Lock.ExitWriteLock();
159          }
160      }
161      bool AddMappingResolver(TypeMappingResolver resolver, bool overwrite)
162      {
163          var type = resolver.GetType();
164          if (MappingResolvers[0].GetType() == type)
165          {
166              if (!overwrite)
167                  return false;
168              MappingResolvers[0] = resolver;
169          }
170          else
171          {
172              for (var i = 0; i &lt; MappingResolvers.Count; i++)
173              {
174                  if (MappingResolvers[i].GetType() == type)
175                  {
176                      if (!overwrite)
177                          return false;
178                      MappingResolvers.RemoveAt(i);
179                      break;
180                  }
181              }
182              MappingResolvers.Insert(0, resolver);
183          }
184          return true;
185      }
186      public void Reset()
187      {
188          Lock.EnterWriteLock();
189          try
190          {
191              HandlerResolverFactories.Clear();
192              HandlerResolverFactories.Add(new BuiltInTypeHandlerResolverFactory());
193              MappingResolvers.Clear();
194              MappingResolvers.Add(new BuiltInTypeMappingResolver());
195              UserTypeMappings.Clear();
196              RecordChange();
197          }
198          finally
199          {
200              Lock.ExitWriteLock();
201          }
202      }
203      internal void RecordChange()
204          =&gt; _mappingsByClrType.Clear();
205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          =&gt; clrType.GetCustomAttribute&lt;PgNameAttribute&gt;()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
209      #region NpgsqlDbType/DbType inference for NpgsqlParameter
210      [RequiresUnreferencedCode(&quot;ToNpgsqlDbType uses interface-based reflection and isn&#x27;t trimming-safe&quot;)]
211      internal bool TryResolveMappingByValue(object value, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
212      {
213          Lock.EnterReadLock();
214          try
215          {
216              var type = value.GetType();
217              if (_mappingsByClrType.TryGetValue(type, out typeMapping))
218                  return true;
219              foreach (var resolver in MappingResolvers)
220                  if ((typeMapping = resolver.GetMappingByValueDependentValue(value)) is not null)
221                      return true;
222              return TryResolveMappingByClrType(type, out typeMapping);
223          }
224          finally
225          {
226              Lock.ExitReadLock();
227          }
228          bool TryResolveMappingByClrType(Type clrType, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
229          {
230              if (_mappingsByClrType.TryGetValue(clrType, out typeMapping))
231                  return true;
232              foreach (var resolver in MappingResolvers)
233              {
234                  if ((typeMapping = resolver.GetMappingByClrType(clrType)) is not null)
235                  {
236                      _mappingsByClrType[clrType] = typeMapping;
237                      return true;
238                  }
239              }
240              if (clrType.IsArray)
241              {
242                  if (TryResolveMappingByClrType(clrType.GetElementType()!, out var elementMapping))
243                  {
244                      _mappingsByClrType[clrType] = typeMapping = new(
245                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
246                          elementMapping.DataTypeName + &quot;[]&quot;);
247                      return true;
248                  }
249                  typeMapping = null;
250                  return false;
251              }
252              var typeInfo = clrType.GetTypeInfo();
253              var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =&gt;
254                  x.GetTypeInfo().IsGenericType &amp;&amp; x.GetGenericTypeDefinition() == typeof(IList&lt;&gt;));
255              if (ilist != null)
256              {
257                  if (TryResolveMappingByClrType(ilist.GetGenericArguments()[0], out var elementMapping))
258                  {
259                      _mappingsByClrType[clrType] = typeMapping = new(
260                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
261                          elementMapping.DataTypeName + &quot;[]&quot;);
262                      return true;
263                  }
264                  typeMapping = null;
265                  return false;
266              }
267              if (typeInfo.IsGenericType &amp;&amp; clrType.GetGenericTypeDefinition() == typeof(NpgsqlRange&lt;&gt;))
268              {
269                  if (TryResolveMappingByClrType(clrType.GetGenericArguments()[0], out var elementMapping))
270                  {
271                      _mappingsByClrType[clrType] = typeMapping = new(
272                          NpgsqlDbType.Range | elementMapping.NpgsqlDbType,
273                          dataTypeName: null);
274                      return true;
275                  }
276                  typeMapping = null;
277                  return false;
278              }
279              typeMapping = null;
280              return false;
281          }
282      }
283      #endregion NpgsqlDbType/DbType inference for NpgsqlParameter
284      #region Static translation tables
285      public static string? NpgsqlDbTypeToDataTypeName(NpgsqlDbType npgsqlDbType)
286          =&gt; npgsqlDbType switch
287          {
288              NpgsqlDbType.Smallint =&gt; &quot;smallint&quot;,
289              NpgsqlDbType.Integer  =&gt; &quot;integer&quot;,
290              NpgsqlDbType.Bigint   =&gt; &quot;bigint&quot;,
291              NpgsqlDbType.Real     =&gt; &quot;real&quot;,
292              NpgsqlDbType.Double   =&gt; &quot;double precision&quot;,
293              NpgsqlDbType.Numeric  =&gt; &quot;numeric&quot;,
294              NpgsqlDbType.Money    =&gt; &quot;money&quot;,
295              NpgsqlDbType.Text      =&gt; &quot;text&quot;,
296              NpgsqlDbType.Xml       =&gt; &quot;xml&quot;,
297              NpgsqlDbType.Varchar   =&gt; &quot;character varying&quot;,
298              NpgsqlDbType.Char      =&gt; &quot;character&quot;,
299              NpgsqlDbType.Name      =&gt; &quot;name&quot;,
300              NpgsqlDbType.Refcursor =&gt; &quot;refcursor&quot;,
301              NpgsqlDbType.Citext    =&gt; &quot;citext&quot;,
302              NpgsqlDbType.Jsonb     =&gt; &quot;jsonb&quot;,
303              NpgsqlDbType.Json      =&gt; &quot;json&quot;,
304              NpgsqlDbType.JsonPath  =&gt; &quot;jsonpath&quot;,
305              NpgsqlDbType.Timestamp   =&gt; &quot;timestamp without time zone&quot;,
306              NpgsqlDbType.TimestampTz =&gt; &quot;timestamp with time zone&quot;,
307              NpgsqlDbType.Date        =&gt; &quot;date&quot;,
308              NpgsqlDbType.Time        =&gt; &quot;time without time zone&quot;,
309              NpgsqlDbType.TimeTz      =&gt; &quot;time with time zone&quot;,
310              NpgsqlDbType.Interval    =&gt; &quot;interval&quot;,
311              NpgsqlDbType.Cidr     =&gt; &quot;cidr&quot;,
312              NpgsqlDbType.Inet     =&gt; &quot;inet&quot;,
313              NpgsqlDbType.MacAddr  =&gt; &quot;macaddr&quot;,
314              NpgsqlDbType.MacAddr8 =&gt; &quot;macaddr8&quot;,
315              NpgsqlDbType.TsQuery   =&gt; &quot;tsquery&quot;,
316              NpgsqlDbType.TsVector  =&gt; &quot;tsvector&quot;,
317              NpgsqlDbType.Box     =&gt; &quot;box&quot;,
318              NpgsqlDbType.Circle  =&gt; &quot;circle&quot;,
319              NpgsqlDbType.Line    =&gt; &quot;line&quot;,
320              NpgsqlDbType.LSeg    =&gt; &quot;lseg&quot;,
321              NpgsqlDbType.Path    =&gt; &quot;path&quot;,
322              NpgsqlDbType.Point   =&gt; &quot;point&quot;,
323              NpgsqlDbType.Polygon =&gt; &quot;polygon&quot;,
324              NpgsqlDbType.LQuery    =&gt; &quot;lquery&quot;,
325              NpgsqlDbType.LTree     =&gt; &quot;ltree&quot;,
326              NpgsqlDbType.LTxtQuery =&gt; &quot;ltxtquery&quot;,
327              NpgsqlDbType.Oid       =&gt; &quot;oid&quot;,
328              NpgsqlDbType.Xid       =&gt; &quot;xid&quot;,
329              NpgsqlDbType.Xid8      =&gt; &quot;xid8&quot;,
330              NpgsqlDbType.Cid       =&gt; &quot;cid&quot;,
331              NpgsqlDbType.Regtype   =&gt; &quot;regtype&quot;,
332              NpgsqlDbType.Regconfig =&gt; &quot;regconfig&quot;,
333              NpgsqlDbType.Boolean =&gt; &quot;boolean&quot;,
334              NpgsqlDbType.Bytea   =&gt; &quot;bytea&quot;,
335              NpgsqlDbType.Uuid    =&gt; &quot;uuid&quot;,
336              NpgsqlDbType.Varbit  =&gt; &quot;bit varying&quot;,
337              NpgsqlDbType.Bit     =&gt; &quot;bit&quot;,
338              NpgsqlDbType.Hstore  =&gt; &quot;hstore&quot;,
339              NpgsqlDbType.Geometry  =&gt; &quot;geometry&quot;,
340              NpgsqlDbType.Geography =&gt; &quot;geography&quot;,
341              NpgsqlDbType.IntegerRange     =&gt; &quot;int4range&quot;,
342              NpgsqlDbType.BigIntRange      =&gt; &quot;int8range&quot;,
343              NpgsqlDbType.NumericRange     =&gt; &quot;numrange&quot;,
344              NpgsqlDbType.TimestampRange   =&gt; &quot;tsrange&quot;,
345              NpgsqlDbType.TimestampTzRange =&gt; &quot;tstzrange&quot;,
346              NpgsqlDbType.DateRange        =&gt; &quot;daterange&quot;,
347              NpgsqlDbType.IntegerMultirange     =&gt; &quot;int4multirange&quot;,
348              NpgsqlDbType.BigIntMultirange      =&gt; &quot;int8multirange&quot;,
349              NpgsqlDbType.NumericMultirange     =&gt; &quot;nummultirange&quot;,
350              NpgsqlDbType.TimestampMultirange   =&gt; &quot;tsmultirange&quot;,
351              NpgsqlDbType.TimestampTzMultirange =&gt; &quot;tstzmultirange&quot;,
352              NpgsqlDbType.DateMultirange        =&gt; &quot;datemultirange&quot;,
353              NpgsqlDbType.Int2Vector   =&gt; &quot;int2vector&quot;,
354              NpgsqlDbType.Oidvector    =&gt; &quot;oidvector&quot;,
355              NpgsqlDbType.PgLsn        =&gt; &quot;pg_lsn&quot;,
356              NpgsqlDbType.Tid          =&gt; &quot;tid&quot;,
357              NpgsqlDbType.InternalChar =&gt; &quot;char&quot;,
358              NpgsqlDbType.Unknown =&gt; &quot;unknown&quot;,
359              _ =&gt; npgsqlDbType.HasFlag(NpgsqlDbType.Array)
360                  ? NpgsqlDbTypeToDataTypeName(npgsqlDbType &amp; ~NpgsqlDbType.Array) + &quot;[]&quot;
361                  : null 
362          };
363      public static NpgsqlDbType DataTypeNameToNpgsqlDbType(string typeName)
364      {
365          var parenIndex = typeName.IndexOf(&#x27;(&#x27;);
366          if (parenIndex &gt; -1)
367              typeName = typeName.Substring(0, parenIndex);
368          return typeName switch
369          {
370              &quot;smallint&quot; =&gt; NpgsqlDbType.Smallint,
371              &quot;integer&quot; or &quot;int&quot; =&gt; NpgsqlDbType.Integer,
372              &quot;bigint&quot; =&gt; NpgsqlDbType.Bigint,
373              &quot;real&quot; =&gt; NpgsqlDbType.Real,
374              &quot;double precision&quot; =&gt; NpgsqlDbType.Double,
375              &quot;numeric&quot; =&gt; NpgsqlDbType.Numeric,
376              &quot;money&quot; =&gt; NpgsqlDbType.Money,
377              &quot;text&quot; =&gt; NpgsqlDbType.Text,
378              &quot;xml&quot; =&gt; NpgsqlDbType.Xml,
379              &quot;character varying&quot; or &quot;varchar&quot; =&gt; NpgsqlDbType.Varchar,
380              &quot;character&quot; =&gt; NpgsqlDbType.Char,
381              &quot;name&quot; =&gt; NpgsqlDbType.Name,
382              &quot;refcursor&quot; =&gt; NpgsqlDbType.Refcursor,
383              &quot;citext&quot; =&gt; NpgsqlDbType.Citext,
384              &quot;jsonb&quot; =&gt; NpgsqlDbType.Jsonb,
385              &quot;json&quot; =&gt; NpgsqlDbType.Json,
386              &quot;jsonpath&quot; =&gt; NpgsqlDbType.JsonPath,
387              &quot;timestamp without time zone&quot; or &quot;timestamp&quot; =&gt; NpgsqlDbType.Timestamp,
388              &quot;timestamp with time zone&quot; or &quot;timestamptz&quot; =&gt; NpgsqlDbType.TimestampTz,
389              &quot;date&quot; =&gt; NpgsqlDbType.Date,
390              &quot;time without time zone&quot; or &quot;timetz&quot; =&gt; NpgsqlDbType.Time,
391              &quot;time with time zone&quot; or &quot;time&quot; =&gt; NpgsqlDbType.TimeTz,
392              &quot;interval&quot; =&gt; NpgsqlDbType.Interval,
393              &quot;cidr&quot; =&gt; NpgsqlDbType.Cidr,
394              &quot;inet&quot; =&gt; NpgsqlDbType.Inet,
395              &quot;macaddr&quot; =&gt; NpgsqlDbType.MacAddr,
396              &quot;macaddr8&quot; =&gt; NpgsqlDbType.MacAddr8,
397              &quot;tsquery&quot; =&gt; NpgsqlDbType.TsQuery,
398              &quot;tsvector&quot; =&gt; NpgsqlDbType.TsVector,
399              &quot;box&quot; =&gt; NpgsqlDbType.Box,
400              &quot;circle&quot; =&gt; NpgsqlDbType.Circle,
401              &quot;line&quot; =&gt; NpgsqlDbType.Line,
402              &quot;lseg&quot; =&gt; NpgsqlDbType.LSeg,
403              &quot;path&quot; =&gt; NpgsqlDbType.Path,
404              &quot;point&quot; =&gt; NpgsqlDbType.Point,
405              &quot;polygon&quot; =&gt; NpgsqlDbType.Polygon,
406              &quot;lquery&quot; =&gt; NpgsqlDbType.LQuery,
407              &quot;ltree&quot; =&gt; NpgsqlDbType.LTree,
408              &quot;ltxtquery&quot; =&gt; NpgsqlDbType.LTxtQuery,
409              &quot;oid&quot; =&gt; NpgsqlDbType.Oid,
410              &quot;xid&quot; =&gt; NpgsqlDbType.Xid,
411              &quot;xid8&quot; =&gt; NpgsqlDbType.Xid8,
412              &quot;cid&quot; =&gt; NpgsqlDbType.Cid,
413              &quot;regtype&quot; =&gt; NpgsqlDbType.Regtype,
414              &quot;regconfig&quot; =&gt; NpgsqlDbType.Regconfig,
415              &quot;boolean&quot; or &quot;bool&quot; =&gt; NpgsqlDbType.Boolean,
416              &quot;bytea&quot; =&gt; NpgsqlDbType.Bytea,
417              &quot;uuid&quot; =&gt; NpgsqlDbType.Uuid,
418              &quot;bit varying&quot; or &quot;varbit&quot; =&gt; NpgsqlDbType.Varbit,
419              &quot;bit&quot; =&gt; NpgsqlDbType.Bit,
420              &quot;hstore&quot; =&gt; NpgsqlDbType.Hstore,
421              &quot;geometry&quot; =&gt; NpgsqlDbType.Geometry,
422              &quot;geography&quot; =&gt; NpgsqlDbType.Geography,
423              &quot;int4range&quot; =&gt; NpgsqlDbType.IntegerRange,
424              &quot;int8range&quot; =&gt; NpgsqlDbType.BigIntRange,
425              &quot;numrange&quot; =&gt; NpgsqlDbType.NumericRange,
426              &quot;tsrange&quot; =&gt; NpgsqlDbType.TimestampRange,
427              &quot;tstzrange&quot; =&gt; NpgsqlDbType.TimestampTzRange,
428              &quot;daterange&quot; =&gt; NpgsqlDbType.DateRange,
429              &quot;int4multirange&quot; =&gt; NpgsqlDbType.IntegerMultirange,
430              &quot;int8multirange&quot; =&gt; NpgsqlDbType.BigIntMultirange,
431              &quot;nummultirange&quot; =&gt; NpgsqlDbType.NumericMultirange,
432              &quot;tsmultirange&quot; =&gt; NpgsqlDbType.TimestampMultirange,
433              &quot;tstzmultirange&quot; =&gt; NpgsqlDbType.TimestampTzMultirange,
434              &quot;datemultirange&quot; =&gt; NpgsqlDbType.DateMultirange,
435              &quot;int2vector&quot; =&gt; NpgsqlDbType.Int2Vector,
436              &quot;oidvector&quot; =&gt; NpgsqlDbType.Oidvector,
437              &quot;pg_lsn&quot; =&gt; NpgsqlDbType.PgLsn,
438              &quot;tid&quot; =&gt; NpgsqlDbType.Tid,
439              &quot;char&quot; =&gt; NpgsqlDbType.InternalChar,
440              _ =&gt; typeName.EndsWith(&quot;[]&quot;, StringComparison.Ordinal) &amp;&amp;
441                   DataTypeNameToNpgsqlDbType(typeName.Substring(0, typeName.Length - 2)) is { } elementNpgsqlDbType &amp;&amp;
442                   elementNpgsqlDbType != NpgsqlDbType.Unknown
443                  ? elementNpgsqlDbType | NpgsqlDbType.Array
444                  : NpgsqlDbType.Unknown 
445          };
446      }
447      internal static NpgsqlDbType? DbTypeToNpgsqlDbType(DbType dbType)
448          =&gt; dbType switch
449          {
450              DbType.AnsiString            =&gt; NpgsqlDbType.Text,
451              DbType.Binary                =&gt; NpgsqlDbType.Bytea,
452              DbType.Byte                  =&gt; NpgsqlDbType.Smallint,
453              DbType.Boolean               =&gt; NpgsqlDbType.Boolean,
454              DbType.Currency              =&gt; NpgsqlDbType.Money,
455              DbType.Date                  =&gt; NpgsqlDbType.Date,
456              DbType.DateTime              =&gt; LegacyTimestampBehavior ? NpgsqlDbType.Timestamp : NpgsqlDbType.TimestampTz,
457              DbType.Decimal               =&gt; NpgsqlDbType.Numeric,
458              DbType.VarNumeric            =&gt; NpgsqlDbType.Numeric,
459              DbType.Double                =&gt; NpgsqlDbType.Double,
460              DbType.Guid                  =&gt; NpgsqlDbType.Uuid,
461              DbType.Int16                 =&gt; NpgsqlDbType.Smallint,
462              DbType.Int32                 =&gt; NpgsqlDbType.Integer,
463              DbType.Int64                 =&gt; NpgsqlDbType.Bigint,
464              DbType.Single                =&gt; NpgsqlDbType.Real,
465              DbType.String                =&gt; NpgsqlDbType.Text,
466              DbType.Time                  =&gt; NpgsqlDbType.Time,
467              DbType.AnsiStringFixedLength =&gt; NpgsqlDbType.Text,
468              DbType.StringFixedLength     =&gt; NpgsqlDbType.Text,
469              DbType.Xml                   =&gt; NpgsqlDbType.Xml,
470              DbType.DateTime2             =&gt; NpgsqlDbType.Timestamp,
471              DbType.DateTimeOffset        =&gt; NpgsqlDbType.TimestampTz,
472              DbType.Object                =&gt; null,
473              DbType.SByte                 =&gt; null,
474              DbType.UInt16                =&gt; null,
475              DbType.UInt32                =&gt; null,
476              DbType.UInt64                =&gt; null,
477              _ =&gt; throw new ArgumentOutOfRangeException(nameof(dbType), dbType, null)
478          };
479      internal static DbType NpgsqlDbTypeToDbType(NpgsqlDbType npgsqlDbType)
480          =&gt; npgsqlDbType switch
481          {
482              NpgsqlDbType.Smallint    =&gt; DbType.Int16,
483              NpgsqlDbType.Integer     =&gt; DbType.Int32,
484              NpgsqlDbType.Bigint      =&gt; DbType.Int64,
485              NpgsqlDbType.Real        =&gt; DbType.Single,
486              NpgsqlDbType.Double      =&gt; DbType.Double,
487              NpgsqlDbType.Numeric     =&gt; DbType.Decimal,
488              NpgsqlDbType.Money       =&gt; DbType.Currency,
489              NpgsqlDbType.Text        =&gt; DbType.String,
490              NpgsqlDbType.Xml         =&gt; DbType.Xml,
491              NpgsqlDbType.Varchar     =&gt; DbType.String,
492              NpgsqlDbType.Char        =&gt; DbType.String,
493              NpgsqlDbType.Name        =&gt; DbType.String,
494              NpgsqlDbType.Refcursor   =&gt; DbType.String,
495              NpgsqlDbType.Citext      =&gt; DbType.String,
496              NpgsqlDbType.Jsonb       =&gt; DbType.Object,
497              NpgsqlDbType.Json        =&gt; DbType.Object,
498              NpgsqlDbType.JsonPath    =&gt; DbType.String,
499              NpgsqlDbType.Timestamp   =&gt; LegacyTimestampBehavior ? DbType.DateTime : DbType.DateTime2,
500              NpgsqlDbType.TimestampTz =&gt; LegacyTimestampBehavior ? DbType.DateTimeOffset : DbType.DateTime,
501              NpgsqlDbType.Date        =&gt; DbType.Date,
502              NpgsqlDbType.Time        =&gt; DbType.Time,
503              NpgsqlDbType.Bytea       =&gt; DbType.Binary,
504              NpgsqlDbType.Boolean     =&gt; DbType.Boolean,
505              NpgsqlDbType.Uuid        =&gt; DbType.Guid,
506              NpgsqlDbType.Unknown     =&gt; DbType.Object,
507              _ =&gt; DbType.Object
508          };
509      #endregion Static translation tables
510  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using System.Threading;
9  using Npgsql.Internal.TypeHandling;
10  using Npgsql.Internal.TypeMapping;
11  using Npgsql.NameTranslation;
12  using NpgsqlTypes;
13  using static Npgsql.Util.Statics;
14  namespace Npgsql.TypeMapping;
15  sealed class GlobalTypeMapper : INpgsqlTypeMapper
16  {
17      public static GlobalTypeMapper Instance { get; }
18      public INpgsqlNameTranslator DefaultNameTranslator { get; set; } = new NpgsqlSnakeCaseNameTranslator();
19      internal List&lt;TypeHandlerResolverFactory&gt; HandlerResolverFactories { get; } = new();
20      List&lt;TypeMappingResolver&gt; MappingResolvers { get; } = new();
21      public ConcurrentDictionary&lt;string, IUserTypeMapping&gt; UserTypeMappings { get; } = new();
22      readonly ConcurrentDictionary&lt;Type, TypeMappingInfo&gt; _mappingsByClrType = new();
23      internal ReaderWriterLockSlim Lock { get; }
24          = new(LockRecursionPolicy.SupportsRecursion);
25      static GlobalTypeMapper()
26          =&gt; Instance = new GlobalTypeMapper();
27      GlobalTypeMapper()
28          =&gt; Reset();
29      #region Mapping management
30      public INpgsqlTypeMapper MapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
31          where TEnum : struct, Enum
32      {
33          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
34              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
35          nameTranslator ??= DefaultNameTranslator;
36          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
37          Lock.EnterWriteLock();
38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping&lt;TEnum&gt;(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
50          where TEnum : struct, Enum
51      {
52          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
53              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
54          nameTranslator ??= DefaultNameTranslator;
55          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
56          Lock.EnterWriteLock();
57          try
58          {
59              if (UserTypeMappings.TryRemove(pgName, out _))
60              {
61                  RecordChange();
62                  return true;
63              }
64              return false;
65          }
66          finally
67          {
68              Lock.ExitWriteLock();
69          }
70      }
71      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
72      public INpgsqlTypeMapper MapComposite&lt;T&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
73      {
74          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
75              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
76          nameTranslator ??= DefaultNameTranslator;
77          pgName ??= GetPgName(typeof(T), nameTranslator);
78          Lock.EnterWriteLock();
<span onclick='openModal()' class='match'>79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping&lt;T&gt;(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
</span>91      public INpgsqlTypeMapper MapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
92      {
93          var openMethod = typeof(GlobalTypeMapper).GetMethod(nameof(MapComposite), new[] { typeof(string), typeof(INpgsqlNameTranslator) })!;
94          var method = openMethod.MakeGenericMethod(clrType);
95          method.Invoke(this, new object?[] { pgName, nameTranslator });
96          return this;
97      }
98      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
99      public bool UnmapComposite&lt;T&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
100          =&gt; UnmapComposite(typeof(T), pgName, nameTranslator);
101      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
102      public bool UnmapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
103      {
104          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
105              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
106          nameTranslator ??= DefaultNameTranslator;
107          pgName ??= GetPgName(clrType, nameTranslator);
108          Lock.EnterWriteLock();
109          try
110          {
111              if (UserTypeMappings.TryRemove(pgName, out _))
112              {
113                  RecordChange();
114                  return true;
115              }
116              return false;
117          }
118          finally
119          {
120              Lock.ExitWriteLock();
121          }
122      }
123      public void AddTypeResolverFactory(TypeHandlerResolverFactory resolverFactory)
124      {
125          Lock.EnterWriteLock();
126          try
127          {
128              var type = resolverFactory.GetType();
129              if (HandlerResolverFactories[0].GetType() == type)
130                  HandlerResolverFactories[0] = resolverFactory;
131              else
132              {
133                  for (var i = 0; i &lt; HandlerResolverFactories.Count; i++)
134                      if (HandlerResolverFactories[i].GetType() == type)
135                          HandlerResolverFactories.RemoveAt(i);
136                  HandlerResolverFactories.Insert(0, resolverFactory);
137              }
138              var mappingResolver = resolverFactory.CreateMappingResolver();
139              if (mappingResolver is not null)
140                  AddMappingResolver(mappingResolver, overwrite: true);
141              RecordChange();
142          }
143          finally
144          {
145              Lock.ExitWriteLock();
146          }
147      }
148      internal void TryAddMappingResolver(TypeMappingResolver resolver)
149      {
150          Lock.EnterWriteLock();
151          try
152          {
153              if (AddMappingResolver(resolver, overwrite: false))
154                  RecordChange();
155          }
156          finally
157          {
158              Lock.ExitWriteLock();
159          }
160      }
161      bool AddMappingResolver(TypeMappingResolver resolver, bool overwrite)
162      {
163          var type = resolver.GetType();
164          if (MappingResolvers[0].GetType() == type)
165          {
166              if (!overwrite)
167                  return false;
168              MappingResolvers[0] = resolver;
169          }
170          else
171          {
172              for (var i = 0; i &lt; MappingResolvers.Count; i++)
173              {
174                  if (MappingResolvers[i].GetType() == type)
175                  {
176                      if (!overwrite)
177                          return false;
178                      MappingResolvers.RemoveAt(i);
179                      break;
180                  }
181              }
182              MappingResolvers.Insert(0, resolver);
183          }
184          return true;
185      }
186      public void Reset()
187      {
188          Lock.EnterWriteLock();
189          try
190          {
191              HandlerResolverFactories.Clear();
192              HandlerResolverFactories.Add(new BuiltInTypeHandlerResolverFactory());
193              MappingResolvers.Clear();
194              MappingResolvers.Add(new BuiltInTypeMappingResolver());
195              UserTypeMappings.Clear();
196              RecordChange();
197          }
198          finally
199          {
200              Lock.ExitWriteLock();
201          }
202      }
203      internal void RecordChange()
204          =&gt; _mappingsByClrType.Clear();
205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          =&gt; clrType.GetCustomAttribute&lt;PgNameAttribute&gt;()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
209      #region NpgsqlDbType/DbType inference for NpgsqlParameter
210      [RequiresUnreferencedCode(&quot;ToNpgsqlDbType uses interface-based reflection and isn&#x27;t trimming-safe&quot;)]
211      internal bool TryResolveMappingByValue(object value, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
212      {
213          Lock.EnterReadLock();
214          try
215          {
216              var type = value.GetType();
217              if (_mappingsByClrType.TryGetValue(type, out typeMapping))
218                  return true;
219              foreach (var resolver in MappingResolvers)
220                  if ((typeMapping = resolver.GetMappingByValueDependentValue(value)) is not null)
221                      return true;
222              return TryResolveMappingByClrType(type, out typeMapping);
223          }
224          finally
225          {
226              Lock.ExitReadLock();
227          }
228          bool TryResolveMappingByClrType(Type clrType, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
229          {
230              if (_mappingsByClrType.TryGetValue(clrType, out typeMapping))
231                  return true;
232              foreach (var resolver in MappingResolvers)
233              {
234                  if ((typeMapping = resolver.GetMappingByClrType(clrType)) is not null)
235                  {
236                      _mappingsByClrType[clrType] = typeMapping;
237                      return true;
238                  }
239              }
240              if (clrType.IsArray)
241              {
242                  if (TryResolveMappingByClrType(clrType.GetElementType()!, out var elementMapping))
243                  {
244                      _mappingsByClrType[clrType] = typeMapping = new(
245                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
246                          elementMapping.DataTypeName + &quot;[]&quot;);
247                      return true;
248                  }
249                  typeMapping = null;
250                  return false;
251              }
252              var typeInfo = clrType.GetTypeInfo();
253              var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =&gt;
254                  x.GetTypeInfo().IsGenericType &amp;&amp; x.GetGenericTypeDefinition() == typeof(IList&lt;&gt;));
255              if (ilist != null)
256              {
257                  if (TryResolveMappingByClrType(ilist.GetGenericArguments()[0], out var elementMapping))
258                  {
259                      _mappingsByClrType[clrType] = typeMapping = new(
260                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
261                          elementMapping.DataTypeName + &quot;[]&quot;);
262                      return true;
263                  }
264                  typeMapping = null;
265                  return false;
266              }
267              if (typeInfo.IsGenericType &amp;&amp; clrType.GetGenericTypeDefinition() == typeof(NpgsqlRange&lt;&gt;))
268              {
269                  if (TryResolveMappingByClrType(clrType.GetGenericArguments()[0], out var elementMapping))
270                  {
271                      _mappingsByClrType[clrType] = typeMapping = new(
272                          NpgsqlDbType.Range | elementMapping.NpgsqlDbType,
273                          dataTypeName: null);
274                      return true;
275                  }
276                  typeMapping = null;
277                  return false;
278              }
279              typeMapping = null;
280              return false;
281          }
282      }
283      #endregion NpgsqlDbType/DbType inference for NpgsqlParameter
284      #region Static translation tables
285      public static string? NpgsqlDbTypeToDataTypeName(NpgsqlDbType npgsqlDbType)
286          =&gt; npgsqlDbType switch
287          {
288              NpgsqlDbType.Smallint =&gt; &quot;smallint&quot;,
289              NpgsqlDbType.Integer  =&gt; &quot;integer&quot;,
290              NpgsqlDbType.Bigint   =&gt; &quot;bigint&quot;,
291              NpgsqlDbType.Real     =&gt; &quot;real&quot;,
292              NpgsqlDbType.Double   =&gt; &quot;double precision&quot;,
293              NpgsqlDbType.Numeric  =&gt; &quot;numeric&quot;,
294              NpgsqlDbType.Money    =&gt; &quot;money&quot;,
295              NpgsqlDbType.Text      =&gt; &quot;text&quot;,
296              NpgsqlDbType.Xml       =&gt; &quot;xml&quot;,
297              NpgsqlDbType.Varchar   =&gt; &quot;character varying&quot;,
298              NpgsqlDbType.Char      =&gt; &quot;character&quot;,
299              NpgsqlDbType.Name      =&gt; &quot;name&quot;,
300              NpgsqlDbType.Refcursor =&gt; &quot;refcursor&quot;,
301              NpgsqlDbType.Citext    =&gt; &quot;citext&quot;,
302              NpgsqlDbType.Jsonb     =&gt; &quot;jsonb&quot;,
303              NpgsqlDbType.Json      =&gt; &quot;json&quot;,
304              NpgsqlDbType.JsonPath  =&gt; &quot;jsonpath&quot;,
305              NpgsqlDbType.Timestamp   =&gt; &quot;timestamp without time zone&quot;,
306              NpgsqlDbType.TimestampTz =&gt; &quot;timestamp with time zone&quot;,
307              NpgsqlDbType.Date        =&gt; &quot;date&quot;,
308              NpgsqlDbType.Time        =&gt; &quot;time without time zone&quot;,
309              NpgsqlDbType.TimeTz      =&gt; &quot;time with time zone&quot;,
310              NpgsqlDbType.Interval    =&gt; &quot;interval&quot;,
311              NpgsqlDbType.Cidr     =&gt; &quot;cidr&quot;,
312              NpgsqlDbType.Inet     =&gt; &quot;inet&quot;,
313              NpgsqlDbType.MacAddr  =&gt; &quot;macaddr&quot;,
314              NpgsqlDbType.MacAddr8 =&gt; &quot;macaddr8&quot;,
315              NpgsqlDbType.TsQuery   =&gt; &quot;tsquery&quot;,
316              NpgsqlDbType.TsVector  =&gt; &quot;tsvector&quot;,
317              NpgsqlDbType.Box     =&gt; &quot;box&quot;,
318              NpgsqlDbType.Circle  =&gt; &quot;circle&quot;,
319              NpgsqlDbType.Line    =&gt; &quot;line&quot;,
320              NpgsqlDbType.LSeg    =&gt; &quot;lseg&quot;,
321              NpgsqlDbType.Path    =&gt; &quot;path&quot;,
322              NpgsqlDbType.Point   =&gt; &quot;point&quot;,
323              NpgsqlDbType.Polygon =&gt; &quot;polygon&quot;,
324              NpgsqlDbType.LQuery    =&gt; &quot;lquery&quot;,
325              NpgsqlDbType.LTree     =&gt; &quot;ltree&quot;,
326              NpgsqlDbType.LTxtQuery =&gt; &quot;ltxtquery&quot;,
327              NpgsqlDbType.Oid       =&gt; &quot;oid&quot;,
328              NpgsqlDbType.Xid       =&gt; &quot;xid&quot;,
329              NpgsqlDbType.Xid8      =&gt; &quot;xid8&quot;,
330              NpgsqlDbType.Cid       =&gt; &quot;cid&quot;,
331              NpgsqlDbType.Regtype   =&gt; &quot;regtype&quot;,
332              NpgsqlDbType.Regconfig =&gt; &quot;regconfig&quot;,
333              NpgsqlDbType.Boolean =&gt; &quot;boolean&quot;,
334              NpgsqlDbType.Bytea   =&gt; &quot;bytea&quot;,
335              NpgsqlDbType.Uuid    =&gt; &quot;uuid&quot;,
336              NpgsqlDbType.Varbit  =&gt; &quot;bit varying&quot;,
337              NpgsqlDbType.Bit     =&gt; &quot;bit&quot;,
338              NpgsqlDbType.Hstore  =&gt; &quot;hstore&quot;,
339              NpgsqlDbType.Geometry  =&gt; &quot;geometry&quot;,
340              NpgsqlDbType.Geography =&gt; &quot;geography&quot;,
341              NpgsqlDbType.IntegerRange     =&gt; &quot;int4range&quot;,
342              NpgsqlDbType.BigIntRange      =&gt; &quot;int8range&quot;,
343              NpgsqlDbType.NumericRange     =&gt; &quot;numrange&quot;,
344              NpgsqlDbType.TimestampRange   =&gt; &quot;tsrange&quot;,
345              NpgsqlDbType.TimestampTzRange =&gt; &quot;tstzrange&quot;,
346              NpgsqlDbType.DateRange        =&gt; &quot;daterange&quot;,
347              NpgsqlDbType.IntegerMultirange     =&gt; &quot;int4multirange&quot;,
348              NpgsqlDbType.BigIntMultirange      =&gt; &quot;int8multirange&quot;,
349              NpgsqlDbType.NumericMultirange     =&gt; &quot;nummultirange&quot;,
350              NpgsqlDbType.TimestampMultirange   =&gt; &quot;tsmultirange&quot;,
351              NpgsqlDbType.TimestampTzMultirange =&gt; &quot;tstzmultirange&quot;,
352              NpgsqlDbType.DateMultirange        =&gt; &quot;datemultirange&quot;,
353              NpgsqlDbType.Int2Vector   =&gt; &quot;int2vector&quot;,
354              NpgsqlDbType.Oidvector    =&gt; &quot;oidvector&quot;,
355              NpgsqlDbType.PgLsn        =&gt; &quot;pg_lsn&quot;,
356              NpgsqlDbType.Tid          =&gt; &quot;tid&quot;,
357              NpgsqlDbType.InternalChar =&gt; &quot;char&quot;,
358              NpgsqlDbType.Unknown =&gt; &quot;unknown&quot;,
359              _ =&gt; npgsqlDbType.HasFlag(NpgsqlDbType.Array)
360                  ? NpgsqlDbTypeToDataTypeName(npgsqlDbType &amp; ~NpgsqlDbType.Array) + &quot;[]&quot;
361                  : null 
362          };
363      public static NpgsqlDbType DataTypeNameToNpgsqlDbType(string typeName)
364      {
365          var parenIndex = typeName.IndexOf(&#x27;(&#x27;);
366          if (parenIndex &gt; -1)
367              typeName = typeName.Substring(0, parenIndex);
368          return typeName switch
369          {
370              &quot;smallint&quot; =&gt; NpgsqlDbType.Smallint,
371              &quot;integer&quot; or &quot;int&quot; =&gt; NpgsqlDbType.Integer,
372              &quot;bigint&quot; =&gt; NpgsqlDbType.Bigint,
373              &quot;real&quot; =&gt; NpgsqlDbType.Real,
374              &quot;double precision&quot; =&gt; NpgsqlDbType.Double,
375              &quot;numeric&quot; =&gt; NpgsqlDbType.Numeric,
376              &quot;money&quot; =&gt; NpgsqlDbType.Money,
377              &quot;text&quot; =&gt; NpgsqlDbType.Text,
378              &quot;xml&quot; =&gt; NpgsqlDbType.Xml,
379              &quot;character varying&quot; or &quot;varchar&quot; =&gt; NpgsqlDbType.Varchar,
380              &quot;character&quot; =&gt; NpgsqlDbType.Char,
381              &quot;name&quot; =&gt; NpgsqlDbType.Name,
382              &quot;refcursor&quot; =&gt; NpgsqlDbType.Refcursor,
383              &quot;citext&quot; =&gt; NpgsqlDbType.Citext,
384              &quot;jsonb&quot; =&gt; NpgsqlDbType.Jsonb,
385              &quot;json&quot; =&gt; NpgsqlDbType.Json,
386              &quot;jsonpath&quot; =&gt; NpgsqlDbType.JsonPath,
387              &quot;timestamp without time zone&quot; or &quot;timestamp&quot; =&gt; NpgsqlDbType.Timestamp,
388              &quot;timestamp with time zone&quot; or &quot;timestamptz&quot; =&gt; NpgsqlDbType.TimestampTz,
389              &quot;date&quot; =&gt; NpgsqlDbType.Date,
390              &quot;time without time zone&quot; or &quot;timetz&quot; =&gt; NpgsqlDbType.Time,
391              &quot;time with time zone&quot; or &quot;time&quot; =&gt; NpgsqlDbType.TimeTz,
392              &quot;interval&quot; =&gt; NpgsqlDbType.Interval,
393              &quot;cidr&quot; =&gt; NpgsqlDbType.Cidr,
394              &quot;inet&quot; =&gt; NpgsqlDbType.Inet,
395              &quot;macaddr&quot; =&gt; NpgsqlDbType.MacAddr,
396              &quot;macaddr8&quot; =&gt; NpgsqlDbType.MacAddr8,
397              &quot;tsquery&quot; =&gt; NpgsqlDbType.TsQuery,
398              &quot;tsvector&quot; =&gt; NpgsqlDbType.TsVector,
399              &quot;box&quot; =&gt; NpgsqlDbType.Box,
400              &quot;circle&quot; =&gt; NpgsqlDbType.Circle,
401              &quot;line&quot; =&gt; NpgsqlDbType.Line,
402              &quot;lseg&quot; =&gt; NpgsqlDbType.LSeg,
403              &quot;path&quot; =&gt; NpgsqlDbType.Path,
404              &quot;point&quot; =&gt; NpgsqlDbType.Point,
405              &quot;polygon&quot; =&gt; NpgsqlDbType.Polygon,
406              &quot;lquery&quot; =&gt; NpgsqlDbType.LQuery,
407              &quot;ltree&quot; =&gt; NpgsqlDbType.LTree,
408              &quot;ltxtquery&quot; =&gt; NpgsqlDbType.LTxtQuery,
409              &quot;oid&quot; =&gt; NpgsqlDbType.Oid,
410              &quot;xid&quot; =&gt; NpgsqlDbType.Xid,
411              &quot;xid8&quot; =&gt; NpgsqlDbType.Xid8,
412              &quot;cid&quot; =&gt; NpgsqlDbType.Cid,
413              &quot;regtype&quot; =&gt; NpgsqlDbType.Regtype,
414              &quot;regconfig&quot; =&gt; NpgsqlDbType.Regconfig,
415              &quot;boolean&quot; or &quot;bool&quot; =&gt; NpgsqlDbType.Boolean,
416              &quot;bytea&quot; =&gt; NpgsqlDbType.Bytea,
417              &quot;uuid&quot; =&gt; NpgsqlDbType.Uuid,
418              &quot;bit varying&quot; or &quot;varbit&quot; =&gt; NpgsqlDbType.Varbit,
419              &quot;bit&quot; =&gt; NpgsqlDbType.Bit,
420              &quot;hstore&quot; =&gt; NpgsqlDbType.Hstore,
421              &quot;geometry&quot; =&gt; NpgsqlDbType.Geometry,
422              &quot;geography&quot; =&gt; NpgsqlDbType.Geography,
423              &quot;int4range&quot; =&gt; NpgsqlDbType.IntegerRange,
424              &quot;int8range&quot; =&gt; NpgsqlDbType.BigIntRange,
425              &quot;numrange&quot; =&gt; NpgsqlDbType.NumericRange,
426              &quot;tsrange&quot; =&gt; NpgsqlDbType.TimestampRange,
427              &quot;tstzrange&quot; =&gt; NpgsqlDbType.TimestampTzRange,
428              &quot;daterange&quot; =&gt; NpgsqlDbType.DateRange,
429              &quot;int4multirange&quot; =&gt; NpgsqlDbType.IntegerMultirange,
430              &quot;int8multirange&quot; =&gt; NpgsqlDbType.BigIntMultirange,
431              &quot;nummultirange&quot; =&gt; NpgsqlDbType.NumericMultirange,
432              &quot;tsmultirange&quot; =&gt; NpgsqlDbType.TimestampMultirange,
433              &quot;tstzmultirange&quot; =&gt; NpgsqlDbType.TimestampTzMultirange,
434              &quot;datemultirange&quot; =&gt; NpgsqlDbType.DateMultirange,
435              &quot;int2vector&quot; =&gt; NpgsqlDbType.Int2Vector,
436              &quot;oidvector&quot; =&gt; NpgsqlDbType.Oidvector,
437              &quot;pg_lsn&quot; =&gt; NpgsqlDbType.PgLsn,
438              &quot;tid&quot; =&gt; NpgsqlDbType.Tid,
439              &quot;char&quot; =&gt; NpgsqlDbType.InternalChar,
440              _ =&gt; typeName.EndsWith(&quot;[]&quot;, StringComparison.Ordinal) &amp;&amp;
441                   DataTypeNameToNpgsqlDbType(typeName.Substring(0, typeName.Length - 2)) is { } elementNpgsqlDbType &amp;&amp;
442                   elementNpgsqlDbType != NpgsqlDbType.Unknown
443                  ? elementNpgsqlDbType | NpgsqlDbType.Array
444                  : NpgsqlDbType.Unknown 
445          };
446      }
447      internal static NpgsqlDbType? DbTypeToNpgsqlDbType(DbType dbType)
448          =&gt; dbType switch
449          {
450              DbType.AnsiString            =&gt; NpgsqlDbType.Text,
451              DbType.Binary                =&gt; NpgsqlDbType.Bytea,
452              DbType.Byte                  =&gt; NpgsqlDbType.Smallint,
453              DbType.Boolean               =&gt; NpgsqlDbType.Boolean,
454              DbType.Currency              =&gt; NpgsqlDbType.Money,
455              DbType.Date                  =&gt; NpgsqlDbType.Date,
456              DbType.DateTime              =&gt; LegacyTimestampBehavior ? NpgsqlDbType.Timestamp : NpgsqlDbType.TimestampTz,
457              DbType.Decimal               =&gt; NpgsqlDbType.Numeric,
458              DbType.VarNumeric            =&gt; NpgsqlDbType.Numeric,
459              DbType.Double                =&gt; NpgsqlDbType.Double,
460              DbType.Guid                  =&gt; NpgsqlDbType.Uuid,
461              DbType.Int16                 =&gt; NpgsqlDbType.Smallint,
462              DbType.Int32                 =&gt; NpgsqlDbType.Integer,
463              DbType.Int64                 =&gt; NpgsqlDbType.Bigint,
464              DbType.Single                =&gt; NpgsqlDbType.Real,
465              DbType.String                =&gt; NpgsqlDbType.Text,
466              DbType.Time                  =&gt; NpgsqlDbType.Time,
467              DbType.AnsiStringFixedLength =&gt; NpgsqlDbType.Text,
468              DbType.StringFixedLength     =&gt; NpgsqlDbType.Text,
469              DbType.Xml                   =&gt; NpgsqlDbType.Xml,
470              DbType.DateTime2             =&gt; NpgsqlDbType.Timestamp,
471              DbType.DateTimeOffset        =&gt; NpgsqlDbType.TimestampTz,
472              DbType.Object                =&gt; null,
473              DbType.SByte                 =&gt; null,
474              DbType.UInt16                =&gt; null,
475              DbType.UInt32                =&gt; null,
476              DbType.UInt64                =&gt; null,
477              _ =&gt; throw new ArgumentOutOfRangeException(nameof(dbType), dbType, null)
478          };
479      internal static DbType NpgsqlDbTypeToDbType(NpgsqlDbType npgsqlDbType)
480          =&gt; npgsqlDbType switch
481          {
482              NpgsqlDbType.Smallint    =&gt; DbType.Int16,
483              NpgsqlDbType.Integer     =&gt; DbType.Int32,
484              NpgsqlDbType.Bigint      =&gt; DbType.Int64,
485              NpgsqlDbType.Real        =&gt; DbType.Single,
486              NpgsqlDbType.Double      =&gt; DbType.Double,
487              NpgsqlDbType.Numeric     =&gt; DbType.Decimal,
488              NpgsqlDbType.Money       =&gt; DbType.Currency,
489              NpgsqlDbType.Text        =&gt; DbType.String,
490              NpgsqlDbType.Xml         =&gt; DbType.Xml,
491              NpgsqlDbType.Varchar     =&gt; DbType.String,
492              NpgsqlDbType.Char        =&gt; DbType.String,
493              NpgsqlDbType.Name        =&gt; DbType.String,
494              NpgsqlDbType.Refcursor   =&gt; DbType.String,
495              NpgsqlDbType.Citext      =&gt; DbType.String,
496              NpgsqlDbType.Jsonb       =&gt; DbType.Object,
497              NpgsqlDbType.Json        =&gt; DbType.Object,
498              NpgsqlDbType.JsonPath    =&gt; DbType.String,
499              NpgsqlDbType.Timestamp   =&gt; LegacyTimestampBehavior ? DbType.DateTime : DbType.DateTime2,
500              NpgsqlDbType.TimestampTz =&gt; LegacyTimestampBehavior ? DbType.DateTimeOffset : DbType.DateTime,
501              NpgsqlDbType.Date        =&gt; DbType.Date,
502              NpgsqlDbType.Time        =&gt; DbType.Time,
503              NpgsqlDbType.Bytea       =&gt; DbType.Binary,
504              NpgsqlDbType.Boolean     =&gt; DbType.Boolean,
505              NpgsqlDbType.Uuid        =&gt; DbType.Guid,
506              NpgsqlDbType.Unknown     =&gt; DbType.Object,
507              _ =&gt; DbType.Object
508          };
509      #endregion Static translation tables
510  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</div>
                </div>
                <div class="column column_space"><pre><code>38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping&lt;TEnum&gt;(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
</pre></code></div>
                <div class="column column_space"><pre><code>79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping&lt;T&gt;(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    