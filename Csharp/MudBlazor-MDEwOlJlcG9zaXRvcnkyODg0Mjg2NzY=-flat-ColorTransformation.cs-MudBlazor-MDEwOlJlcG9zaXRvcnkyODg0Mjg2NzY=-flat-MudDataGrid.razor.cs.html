
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.966057441253264%, Tokens: 21</h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ColorTransformation.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics.CodeAnalysis;
3  using SystemMath = System.Math;
4  namespace MudBlazor.Utilities
5  {
6      [ExcludeFromCodeCoverage] 
7      [Obsolete("Use MudColor instead.", true)]
8      public static class ColorTransformation
9      {
10          private static double EPSILON => 0.000000000000001;
11          public class HSLColor
12          {
<span onclick='openModal()' class='match'>13              public double H { get; set; }
14              public double S { get; set; }
15              public double L { get; set; }
</span>16          }
17          public static HSLColor RgBtoHsl(System.Drawing.Color color)
18          {
19              var h = 0D;
20              var s = 0D;
21              double l;
22              var r = color.R / 255D;
23              var g = color.G / 255D;
24              var b = color.B / 255D;
25              var max = SystemMath.Max(r, SystemMath.Max(g, b));
26              var min = SystemMath.Min(r, SystemMath.Min(g, b));
27              if (SystemMath.Abs(max - min) < EPSILON)
28                  h = 0D; 
29              else if ((SystemMath.Abs(max - r) < EPSILON)
30                      && (g >= b))
31                  h = (60D * (g - b)) / (max - min);
32              else if ((SystemMath.Abs(max - r) < EPSILON)
33                      && (g < b))
34                  h = ((60D * (g - b)) / (max - min)) + 360D;
35              else if (SystemMath.Abs(max - g) < EPSILON)
36                  h = ((60D * (b - r)) / (max - min)) + 120D;
37              else if (SystemMath.Abs(max - b) < EPSILON)
38                  h = ((60D * (r - g)) / (max - min)) + 240D;
39              l = (max + min) / 2D;
40              if ((SystemMath.Abs(l) < EPSILON)
41                      || (SystemMath.Abs(max - min) < EPSILON))
42                  s = 0D;
43              else if ((0D < l)
44                      && (l <= .5D))
45                  s = (max - min) / (max + min);
46              else if (l > .5D)
47                  s = (max - min) / (2D - (max + min)); 
48              return new HSLColor
49              {
50                  H = SystemMath.Max(0D, SystemMath.Min(360D, h)),
51                  S = SystemMath.Max(0D, SystemMath.Min(1D, s)),
52                  L = SystemMath.Max(0D, SystemMath.Min(1D, l))
53              };
54          }
55          public static System.Drawing.Color HsLtoRgb(HSLColor hsl, int a = 255)
56          {
57              var h = SystemMath.Max(0D, SystemMath.Min(360D, hsl.H));
58              var s = SystemMath.Max(0D, SystemMath.Min(1D, hsl.S));
59              var l = SystemMath.Max(0D, SystemMath.Min(1D, hsl.L));
60              a = SystemMath.Max(0, SystemMath.Min(255, a));
61              if (SystemMath.Abs(s) < EPSILON)
62              {
63                  return System.Drawing.Color.FromArgb(
64                          a,
65                          SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{l * 255D:0.00}")))),
66                          SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{l * 255D:0.00}")))),
67                          SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{l * 255D:0.00}")))));
68              }
69              var q = l < .5D
70                      ? l * (1D + s)
71                      : (l + s) - (l * s);
72              var p = (2D * l) - q;
73              var hk = h / 360D;
74              var T = new double[3];
75              T[0] = hk + (1D / 3D); 
76              T[1] = hk; 
77              T[2] = hk - (1D / 3D); 
78              for (var i = 0; i < 3; i++)
79              {
80                  if (T[i] < 0D)
81                      T[i] += 1D;
82                  if (T[i] > 1D)
83                      T[i] -= 1D;
84                  if ((T[i] * 6D) < 1D)
85                      T[i] = p + ((q - p) * 6D * T[i]);
86                  else if ((T[i] * 2D) < 1)
87                      T[i] = q;
88                  else if ((T[i] * 3D) < 2)
89                      T[i] = p + ((q - p) * ((2D / 3D) - T[i]) * 6D);
90                  else
91                      T[i] = p;
92              }
93              return System.Drawing.Color.FromArgb(
94                      a,
95                      SystemMath.Max(0, SystemMath.Min(255, (int)Math.Round(T[0] * 255D))),
96                      SystemMath.Max(0, SystemMath.Min(255, (int)Math.Round(T[1] * 255D))),
97                      SystemMath.Max(0, SystemMath.Min(255, (int)Math.Round(T[2] * 255D))));
98          }
99      }
100  }
</code></pre>
        </div>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudDataGrid.razor.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Collections.Specialized;
4  using System.Diagnostics.CodeAnalysis;
5  using System.Globalization;
6  using System.Linq;
7  using System.Reflection;
8  using System.Text.Json;
9  using System.Threading.Tasks;
10  using Microsoft.AspNetCore.Components;
11  using Microsoft.AspNetCore.Components.Web;
12  using MudBlazor.Utilities;
13  namespace MudBlazor
14  {
15      [CascadingTypeParameter(nameof(T))]
16      public partial class MudDataGrid<T> : MudComponentBase
17      {
18          private int _currentPage = 0;
19          internal int? _rowsPerPage;
20          private bool _isFirstRendered = false;
21          private bool _filtersMenuVisible = false;
22          private bool _columnsPanelVisible = false;
23          private IEnumerable<T> _items;
24          private T _selectedItem;
25          internal HashSet<object> _groupExpansions = new HashSet<object>();
26          private List<GroupDefinition<T>> _currentPageGroups = new List<GroupDefinition<T>>();
27          private List<GroupDefinition<T>> _allGroups = new List<GroupDefinition<T>>();
28          internal HashSet<T> _openHierarchies = new HashSet<T>();
29          private PropertyInfo[] _properties = typeof(T).GetProperties();
30          private MudDropContainer<Column<T>> _dropContainer;
31          protected string _classname =>
32              new CssBuilder("mud-table")
33                 .AddClass("mud-data-grid")
34                 .AddClass("mud-xs-table", Breakpoint == Breakpoint.Xs)
35                 .AddClass("mud-sm-table", Breakpoint == Breakpoint.Sm)
36                 .AddClass("mud-md-table", Breakpoint == Breakpoint.Md)
37                 .AddClass("mud-lg-table", Breakpoint == Breakpoint.Lg || Breakpoint == Breakpoint.Always)
38                 .AddClass("mud-xl-table", Breakpoint == Breakpoint.Xl || Breakpoint == Breakpoint.Always)
39                 .AddClass("mud-table-dense", Dense)
40                 .AddClass("mud-table-hover", Hover)
41                 .AddClass("mud-table-bordered", Bordered)
42                 .AddClass("mud-table-striped", Striped)
43                 .AddClass("mud-table-outlined", Outlined)
44                 .AddClass("mud-table-square", Square)
45                 .AddClass("mud-table-sticky-header", FixedHeader)
46                 .AddClass("mud-table-sticky-footer", FixedFooter)
47                 .AddClass($"mud-elevation-{Elevation}", !Outlined)
48                .AddClass(Class)
49              .Build();
50          protected string _style =>
51              new StyleBuilder()
52                  .AddStyle("overflow-x", "auto", when: HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container)
53                  .AddStyle("position", "relative", when: hasStickyColumns)
54                  .AddStyle(Style)
55              .Build();
56          protected string _tableStyle =>
57              new StyleBuilder()
58                  .AddStyle("height", Height, !string.IsNullOrWhiteSpace(Height))
59                  .AddStyle("width", "max-content", when: (HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container) && !hasStickyColumns)
60                  .AddStyle("display", "block", when: HorizontalScrollbar)
61              .Build();
62          protected string _tableClass =>
63              new CssBuilder("mud-table-container")
64                  .AddClass("cursor-col-resize", when: IsResizing)
65              .Build();
66          protected string _headClassname => new CssBuilder("mud-table-head")
67              .AddClass(HeaderClass).Build();
68          protected string _footClassname => new CssBuilder("mud-table-foot")
69              .AddClass(FooterClass).Build();
70          internal SortDirection GetColumnSortDirection(string columnName)
71          {
72              if (columnName == null)
73              {
74                  return SortDirection.None;
75              }
76              else
77              {
78                  SortDefinition<T> sortDefinition = null;
79                  var ok = SortDefinitions.TryGetValue(columnName, out sortDefinition);
80                  if (ok)
81                  {
82                      return sortDefinition.Descending ? SortDirection.Descending : SortDirection.Ascending;
83                  }
84                  else
85                  {
86                      return SortDirection.None;
87                  }
88              }
89          }
90          protected int numPages
91          {
92              get
93              {
94                  if (ServerData != null)
95                      return (int)Math.Ceiling(_server_data.TotalItems / (double)RowsPerPage);
96                  return (int)Math.Ceiling(FilteredItems.Count() / (double)RowsPerPage);
97              }
98          }
99          internal static bool RenderedColumnsItemsSelector(Column<T> item, string dropZone) => item?.PropertyName == dropZone;
100          private static void Swap<TItem>(List<TItem> list, int indexA, int indexB)
101          {
102              TItem tmp = list[indexA];
103              list[indexA] = list[indexB];
104              list[indexB] = tmp;
105          }
106          private Task ItemUpdatedAsync(MudItemDropInfo<Column<T>> dropItem)
107          {
108              dropItem.Item.Identifier = dropItem.DropzoneIdentifier;
109              var dragAndDropSource = RenderedColumns.Where(rc => rc.PropertyName == dropItem.Item.PropertyName).SingleOrDefault();
110              var dragAndDropDestination = RenderedColumns.Where(rc => rc.PropertyName == dropItem.DropzoneIdentifier).SingleOrDefault();
111              if (dragAndDropSource != null && dragAndDropDestination != null)
112              {
113                  var dragAndDropSourceIndex = RenderedColumns.IndexOf(dragAndDropSource);
114                  var dragAndDropDestinationIndex = RenderedColumns.IndexOf(dragAndDropDestination);
115                  Swap<Column<T>>(RenderedColumns, dragAndDropSourceIndex, dragAndDropDestinationIndex);
116                  var dest = dragAndDropDestination.HeaderCell.Width;
117                  var src = dragAndDropSource.HeaderCell.Width;
118                  dragAndDropSource.HeaderCell.Width = dest;
119                  dragAndDropDestination.HeaderCell.Width = src;
120                  StateHasChanged();
121              }
122              return Task.CompletedTask;
123          }
124          public readonly List<Column<T>> RenderedColumns = new List<Column<T>>();
125          internal T _editingItem;
126          internal T editingSourceItem;
127          internal T _previousEditingItem;
128          internal bool isEditFormOpen;
129          private Converter<bool, bool?> _oppositeBoolConverter = new Converter<bool, bool?>
130          {
131              SetFunc = value => value ? false : true,
132              GetFunc = value => value.HasValue ? !value.Value : true,
133          };
134          #region Notify Children Delegates
<span onclick='openModal()' class='match'>135          internal Action<Dictionary<string, SortDefinition<T>>, HashSet<string>> SortChangedEvent { get; set; }
136          internal Action<HashSet<T>> SelectedItemsChangedEvent { get; set; }
137          internal Action<bool> SelectedAllItemsChangedEvent { get; set; }
</span>138          internal Action StartedEditingItemEvent { get; set; }
139          internal Action EditingCanceledEvent { get; set; }
140          public Action PagerStateHasChangedEvent { get; set; }
141          #endregion
142          #region EventCallbacks
143          [Parameter] public EventCallback<T> SelectedItemChanged { get; set; }
144          [Parameter] public EventCallback<HashSet<T>> SelectedItemsChanged { get; set; }
145          [Parameter] public EventCallback<DataGridRowClickEventArgs<T>> RowClick { get; set; }
146          [Parameter] public EventCallback<T> StartedEditingItem { get; set; }
147          [Parameter] public EventCallback<T> CanceledEditingItem { get; set; }
148          [Obsolete("Use CanceledEditingItem instead", false)]
149          [Parameter] public EventCallback<T> CancelledEditingItem { get => CanceledEditingItem; set => CanceledEditingItem = value; }
150          [Parameter] public EventCallback<T> CommittedItemChanges { get; set; }
151          [Parameter] public EventCallback<FormFieldChangedEventArgs> FormFieldChanged { get; set; }
152          #endregion
153          #region Parameters
154          [Parameter] public bool DragDropColumnReordering { get; set; } = false;
155          [Parameter] public string DragIndicatorIcon { get; set; } = Icons.Material.Filled.DragIndicator;
156          [Parameter] public Size DragIndicatorSize { get; set; } = Size.Small;
157          [Parameter] public string DropAllowedClass { get; set; } = "drop-allowed";
158          [Parameter] public string DropNotAllowedClass { get; set; } = "drop-not-allowed";
159          [Parameter] public bool ApplyDropClassesOnDragStarted { get; set; } = false;
160          [Parameter] public SortMode SortMode { get; set; } = SortMode.Multiple;
161          [Parameter] public bool Filterable { get; set; } = false;
162          [Parameter] public bool Hideable { get; set; } = false;
163          [Parameter] public bool ShowColumnOptions { get; set; } = true;
164          [Parameter] public Breakpoint Breakpoint { get; set; } = Breakpoint.Xs;
165          [Parameter] public int Elevation { set; get; } = 1;
166          [Parameter] public bool Square { get; set; }
167          [Parameter] public bool Outlined { get; set; }
168          [Parameter] public bool Bordered { get; set; }
169          [Parameter] public RenderFragment ColGroup { get; set; }
170          [Parameter] public bool Dense { get; set; }
171          [Parameter] public bool Hover { get; set; }
172          [Parameter] public bool Striped { get; set; }
173          [Parameter] public bool FixedHeader { get; set; }
174          [Parameter] public bool FixedFooter { get; set; }
175          [Parameter] public bool ShowFilterIcons { get; set; } = true;
176          [Parameter] public DataGridFilterMode FilterMode { get; set; }
177          [Parameter] public DataGridFilterCaseSensitivity FilterCaseSensitivity { get; set; }
178          [Parameter] public RenderFragment<MudDataGrid<T>> FilterTemplate { get; set; }
179          [Parameter] public List<IFilterDefinition<T>> FilterDefinitions { get; set; } = new List<IFilterDefinition<T>>();
180          [Parameter] public Dictionary<string, SortDefinition<T>> SortDefinitions { get; set; } = new Dictionary<string, SortDefinition<T>>();
181          [Parameter] public bool Virtualize { get; set; }
182          [Parameter] public int OverscanCount { get; set; } = 3;
183          [Parameter] public string RowClass { get; set; }
184          [Parameter] public string RowStyle { get; set; }
185          [Parameter] public Func<T, int, string> RowClassFunc { get; set; }
186          [Parameter] public Func<T, int, string> RowStyleFunc { get; set; }
187          [Parameter] public bool MultiSelection { get; set; }
188          [Parameter] public DataGridEditMode? EditMode { get; set; }
189          [Parameter] public DataGridEditTrigger? EditTrigger { get; set; } = DataGridEditTrigger.Manual;
190          [Parameter] public DialogOptions EditDialogOptions { get; set; }
191          [Parameter]
192          public IEnumerable<T> Items
193          {
194              get => _items;
195              set
196              {
197                  if (_items == value)
198                      return;
199                  _items = value;
200                  if (PagerStateHasChangedEvent != null)
201                      InvokeAsync(PagerStateHasChangedEvent);
202                  if (Groupable)
203                  {
204                      GroupItems();
205                  }
206                  if (_items is INotifyCollectionChanged)
207                  {
208                      (_items as INotifyCollectionChanged).CollectionChanged += (s, e) =>
209                      {
210                          _currentRenderFilteredItemsCache = null;
211                          if (Groupable)
212                              GroupItems();
213                      };
214                  }
215              }
216          }
217          [Parameter] public bool Loading { get; set; }
218          [Parameter] public bool CanCancelEdit { get; set; } = true;
219          [Parameter] public Color LoadingProgressColor { get; set; } = Color.Info;
220          [Parameter] public RenderFragment ToolBarContent { get; set; }
221          [Parameter] public bool HorizontalScrollbar { get; set; }
222          [Parameter] public ResizeMode ColumnResizeMode { get; set; }
223          [Parameter] public string HeaderClass { get; set; }
224          [Parameter] public string Height { get; set; }
225          [Parameter] public string FooterClass { get; set; }
226          [Parameter] public Func<T, bool> QuickFilter { get; set; } = null;
227          [Parameter] public RenderFragment Header { get; set; }
228          [Parameter] public RenderFragment Columns { get; set; }
229          [Parameter]
230          public CultureInfo Culture { get; set; }
231          [Parameter] public RenderFragment<CellContext<T>> ChildRowContent { get; set; }
232          [Parameter] public RenderFragment NoRecordsContent { get; set; }
233          [Parameter] public RenderFragment LoadingContent { get; set; }
234          [Parameter] public RenderFragment PagerContent { get; set; }
235          [Parameter] public Func<GridState<T>, Task<GridData<T>>> ServerData { get; set; }
236          [Parameter]
237          public int RowsPerPage
238          {
239              get => _rowsPerPage ?? 10;
240              set
241              {
242                  if (_rowsPerPage == null)
243                      InvokeAsync(() => SetRowsPerPageAsync(value));
244              }
245          }
246          [Parameter]
247          public int CurrentPage
248          {
249              get => _currentPage;
250              set
251              {
252                  if (_currentPage == value)
253                      return;
254                  _currentPage = value;
255                  InvokeAsync(StateHasChanged);
256                  if (_isFirstRendered)
257                      InvokeAsync(InvokeServerLoadFunc);
258              }
259          }
260          [Parameter] public bool ReadOnly { get; set; } = true;
261          [Parameter]
262          public HashSet<T> SelectedItems
263          {
264              get
265              {
266                  if (!MultiSelection)
267                      if (_selectedItem is null)
268                          return new HashSet<T>(Array.Empty<T>());
269                      else
270                          return new HashSet<T>(new T[] { _selectedItem });
271                  else
272                      return Selection;
273              }
274              set
275              {
276                  if (value == Selection)
277                      return;
278                  if (value == null)
279                  {
280                      if (Selection.Count == 0)
281                          return;
282                      Selection = new HashSet<T>();
283                  }
284                  else
285                      Selection = value;
286                  SelectedItemsChangedEvent?.Invoke(Selection);
287                  SelectedItemsChanged.InvokeAsync(Selection);
288                  InvokeAsync(StateHasChanged);
289              }
290          }
291          [Parameter]
292          public T SelectedItem
293          {
294              get => _selectedItem;
295              set
296              {
297                  if (EqualityComparer<T>.Default.Equals(SelectedItem, value))
298                      return;
299                  _selectedItem = value;
300                  SelectedItemChanged.InvokeAsync(value);
301              }
302          }
303          [Parameter]
304          public bool Groupable
305          {
306              get { return _groupable; }
307              set
308              {
309                  if (_groupable != value)
310                  {
311                      _groupable = value;
312                      if (!_groupable)
313                      {
314                          _currentPageGroups.Clear();
315                          _allGroups.Clear();
316                          _groupExpansions.Clear();
317                          _groupExpansions.Add("__initial__");
318                          foreach (var column in RenderedColumns)
319                              column.RemoveGrouping();
320                      }
321                  }
322              }
323          }
324          private bool _groupable = false;
325          [Parameter] public bool GroupExpanded { get; set; }
326          [Parameter] public string GroupClass { get; set; }
327          [Parameter] public string GroupStyle { get; set; }
328          [Parameter] public Func<GroupDefinition<T>, string> GroupClassFunc { get; set; }
329          [Parameter] public Func<GroupDefinition<T>, string> GroupStyleFunc { get; set; }
330          [Parameter] public bool ShowMenuIcon { get; set; } = false;
331          #endregion
332          #region Properties
333          internal IEnumerable<T> CurrentPageItems
334          {
335              get
336              {
337                  if (@PagerContent == null)
338                  {
339                      return FilteredItems; 
340                  }
341                  if (ServerData == null)
342                  {
343                      var filteredItemCount = GetFilteredItemsCount();
344                      int lastPageNo;
345                      if (filteredItemCount == 0)
346                          lastPageNo = 0;
347                      else
348                          lastPageNo = (filteredItemCount / RowsPerPage) - (filteredItemCount % RowsPerPage == 0 ? 1 : 0);
349                      CurrentPage = lastPageNo < CurrentPage ? lastPageNo : CurrentPage;
350                  }
351                  return GetItemsOfPage(CurrentPage, RowsPerPage);
352              }
353          }
354          public HashSet<T> Selection { get; set; } = new HashSet<T>();
355          public bool HasPager { get; set; }
356          public IEnumerable<T> ServerItems => _server_data.Items;
357          private GridData<T> _server_data = new GridData<T>() { TotalItems = 0, Items = Array.Empty<T>() };
358          private IEnumerable<T> _currentRenderFilteredItemsCache = null;
359          internal uint FilteringRunCount { get; private set; }
360          public IEnumerable<T> FilteredItems
361          {
362              get
363              {
364                  if (_currentRenderFilteredItemsCache != null) return _currentRenderFilteredItemsCache;
365                  var items = ServerData != null
366                      ? _server_data.Items
367                      : Items;
368                  if (QuickFilter != null)
369                  {
370                      items = items.Where(QuickFilter);
371                  }
372                  if (ServerData is null)
373                  {
374                      foreach (var filterDefinition in FilterDefinitions)
375                      {
376                          var filterFunc = filterDefinition.GenerateFilterFunction(new FilterOptions
377                          {
378                              FilterCaseSensitivity = FilterCaseSensitivity
379                          });
380                          items = items.Where(filterFunc);
381                      }
382                  }
383                  _currentRenderFilteredItemsCache = Sort(items).ToList(); 
384                  unchecked { FilteringRunCount++; }
385                  GroupItems(noStateChange: true);
386                  return _currentRenderFilteredItemsCache;
387              }
388          }
389          public Interfaces.IForm Validator { get; set; } = new DataGridRowValidator();
390          internal Column<T> GroupedColumn
391          {
392              get
393              {
394                  return RenderedColumns.FirstOrDefault(x => x.grouping);
395              }
396          }
397          #endregion
398          #region Computed Properties
399          private bool hasFooter
400          {
401              get
402              {
403                  return RenderedColumns.Any(x => !x.Hidden && (x.FooterTemplate != null || x.AggregateDefinition != null));
404              }
405          }
406          private bool hasStickyColumns
407          {
408              get
409              {
410                  return RenderedColumns.Any(x => x.StickyLeft || x.StickyRight);
411              }
412          }
413          private bool hasHierarchyColumn
414          {
415              get
416              {
417                  return RenderedColumns.Any(x => x.Tag?.ToString() == "hierarchy-column");
418              }
419          }
420          #endregion
421          [UnconditionalSuppressMessage("Trimming", "IL2046: 'RequiresUnreferencedCodeAttribute' annotations must match across all interface implementations or overrides.", Justification = "Suppressing because we annotating the whole component with RequiresUnreferencedCodeAttribute for information that generic type must be preserved.")]
422          protected override async Task OnAfterRenderAsync(bool firstRender)
423          {
424              if (firstRender)
425              {
426                  await InvokeServerLoadFunc();
427                  if (ServerData == null)
428                      StateHasChanged();
429                  _isFirstRendered = true;
430              }
431              else
432              {
433                  PagerStateHasChangedEvent?.Invoke();
434              }
435              await base.OnAfterRenderAsync(firstRender);
436          }
437          [UnconditionalSuppressMessage("Trimming", "IL2046: 'RequiresUnreferencedCodeAttribute' annotations must match across all interface implementations or overrides.", Justification = "Suppressing because we annotating the whole component with RequiresUnreferencedCodeAttribute for information that generic type must be preserved.")]
438          public override async Task SetParametersAsync(ParameterView parameters)
439          {
440              var sortModeBefore = SortMode;
441              await base.SetParametersAsync(parameters);
442              if (parameters.TryGetValue(nameof(SortMode), out SortMode sortMode) && sortMode != sortModeBefore)
443                  await ClearCurrentSortings();
444          }
445          #region Methods
446          protected IEnumerable<T> GetItemsOfPage(int page, int pageSize)
447          {
448              if (page < 0 || pageSize <= 0)
449                  return Array.Empty<T>();
450              if (ServerData != null)
451              {
452                  return QuickFilter != null
453                      ? _server_data.Items.Where(QuickFilter)
454                      : _server_data.Items;
455              }
456              return FilteredItems.Skip(page * pageSize).Take(pageSize);
457          }
458          internal async Task InvokeServerLoadFunc()
459          {
460              if (ServerData == null)
461                  return;
462              Loading = true;
463              StateHasChanged();
464              var state = new GridState<T>
465              {
466                  Page = CurrentPage,
467                  PageSize = RowsPerPage,
468                  SortDefinitions = SortDefinitions.Values.OrderBy(sd => sd.Index).ToList(),
469                  FilterDefinitions = FilterDefinitions.ToList()
470              };
471              _server_data = await ServerData(state);
472              _currentRenderFilteredItemsCache = null;
473              if (CurrentPage * RowsPerPage > _server_data.TotalItems)
474                  CurrentPage = 0;
475              Loading = false;
476              StateHasChanged();
477              PagerStateHasChangedEvent?.Invoke();
478          }
479          internal void AddColumn(Column<T> column)
480          {
481              if (column.Tag?.ToString() == "hierarchy-column")
482              {
483                  RenderedColumns.Insert(0, column);
484              }
485              else if (column.Tag?.ToString() == "select-column")
486              {
487                  if (RenderedColumns.Select(x => x.Tag).Contains("hierarchy-column"))
488                  {
489                      RenderedColumns.Insert(1, column);
490                  }
491                  else
492                  {
493                      RenderedColumns.Insert(0, column);
494                  }
495              }
496              else
497              {
498                  RenderedColumns.Add(column);
499              }
500          }
501          public void AddFilter()
502          {
503              var column = RenderedColumns.FirstOrDefault(x => x.filterable);
504              FilterDefinitions.Add(new FilterDefinition<T>
505              {
506                  Id = Guid.NewGuid(),
507                  DataGrid = this,
508                  Title = column?.Title,
509                  Column = column,
510              });
511              _filtersMenuVisible = true;
512              StateHasChanged();
513          }
514          internal Task ApplyFiltersAsync()
515          {
516              _filtersMenuVisible = false;
517              return InvokeServerLoadFunc();
518          }
519          public Task ClearFiltersAsync()
520          {
521              FilterDefinitions.Clear();
522              return InvokeServerLoadFunc();
523          }
524          public async Task AddFilterAsync(IFilterDefinition<T> definition)
525          {
526              FilterDefinitions.Add(definition);
527              _filtersMenuVisible = true;
528              await InvokeServerLoadFunc();
529              if (ServerData is null) StateHasChanged();
530          }
531          internal async Task RemoveFilterAsync(Guid id)
532          {
533              FilterDefinitions.RemoveAll(x => x.Id == id);
534              await InvokeServerLoadFunc();
535              GroupItems();
536          }
537          internal async Task SetSelectedItemAsync(bool value, T item)
538          {
539              if (value)
540                  Selection.Add(item);
541              else
542                  Selection.Remove(item);
543              await InvokeAsync(() => SelectedItemsChangedEvent.Invoke(SelectedItems));
544              await SelectedItemsChanged.InvokeAsync(SelectedItems);
545              await InvokeAsync(StateHasChanged);
546          }
547          internal async Task SetSelectAllAsync(bool value)
548          {
549              var items = ServerData != null
550                      ? ServerItems
551                      : Items;
552              if (value)
553                  Selection = new HashSet<T>(items);
554              else
555                  Selection.Clear();
556              SelectedItemsChangedEvent?.Invoke(SelectedItems);
557              SelectedAllItemsChangedEvent?.Invoke(value);
558              await SelectedItemsChanged.InvokeAsync(SelectedItems);
559              StateHasChanged();
560          }
561          internal IEnumerable<T> Sort(IEnumerable<T> items)
562          {
563              if (null == items || !items.Any())
564                  return items;
565              if (null == SortDefinitions || 0 == SortDefinitions.Count)
566                  return items;
567              IOrderedEnumerable<T> orderedEnumerable = null;
568              foreach (var sortDefinition in SortDefinitions.Values.Where(sd => null != sd.SortFunc).OrderBy(sd => sd.Index))
569              {
570                  if (null == orderedEnumerable)
571                      orderedEnumerable = sortDefinition.Descending ? items.OrderByDescending(item => sortDefinition.SortFunc(item), sortDefinition.Comparer)
572                          : items.OrderBy(item => sortDefinition.SortFunc(item), sortDefinition.Comparer);
573                  else
574                      orderedEnumerable = sortDefinition.Descending ? orderedEnumerable.ThenByDescending(item => sortDefinition.SortFunc(item), sortDefinition.Comparer)
575                          : orderedEnumerable.ThenBy(item => sortDefinition.SortFunc(item), sortDefinition.Comparer);
576              }
577              return orderedEnumerable ?? items;
578          }
579          internal void ClearEditingItem()
580          {
581              _editingItem = default;
582              editingSourceItem = default;
583          }
584          internal async Task CommitItemChangesAsync(T item)
585          {
586              await CommittedItemChanges.InvokeAsync(item);
587          }
588          internal async Task CommitItemChangesAsync()
589          {
590              if (editingSourceItem != null)
591              {
592                  foreach (var property in _properties)
593                  {
594                      if (property.CanWrite)
595                          property.SetValue(editingSourceItem, property.GetValue(_editingItem));
596                  }
597                  await CommittedItemChanges.InvokeAsync(editingSourceItem);
598                  ClearEditingItem();
599                  isEditFormOpen = false;
600              }
601          }
602          internal async Task OnRowClickedAsync(MouseEventArgs args, T item, int rowIndex)
603          {
604              await RowClick.InvokeAsync(new DataGridRowClickEventArgs<T>(args, item, rowIndex));
605              if (EditMode != DataGridEditMode.Cell && EditTrigger == DataGridEditTrigger.OnRowClick)
606                  await SetEditingItemAsync(item);
607              await SetSelectedItemAsync(item);
608          }
609          public int GetFilteredItemsCount()
610          {
611              if (ServerData != null)
612                  return _server_data.TotalItems;
613              return FilteredItems.Count();
614          }
615          public void NavigateTo(Page page)
616          {
617              switch (page)
618              {
619                  case Page.First:
620                      CurrentPage = 0;
621                      break;
622                  case Page.Last:
623                      CurrentPage = Math.Max(0, numPages - 1);
624                      break;
625                  case Page.Next:
626                      CurrentPage = Math.Min(numPages - 1, CurrentPage + 1);
627                      break;
628                  case Page.Previous:
629                      CurrentPage = Math.Max(0, CurrentPage - 1);
630                      break;
631              }
632              GroupItems();
633          }
634          public async Task SetRowsPerPageAsync(int size)
635          {
636              if (_rowsPerPage == size)
637                  return;
638              _rowsPerPage = size;
639              CurrentPage = 0;
640              StateHasChanged();
641              if (_isFirstRendered)
642                  await InvokeAsync(InvokeServerLoadFunc);
643          }
644          public async Task SetSortAsync(string field, SortDirection direction, Func<T, object> sortFunc, IComparer<object> comparer = null)
645          {
646              var removedSortDefinitions = new HashSet<string>(SortDefinitions.Keys);
647              SortDefinitions.Clear();
648              var newDefinition = new SortDefinition<T>(field, direction == SortDirection.Descending, 0, sortFunc, comparer);
649              SortDefinitions[field] = newDefinition;
650              removedSortDefinitions.Remove(field);
651              await InvokeSortUpdates(SortDefinitions, removedSortDefinitions);
652          }
653          public async Task ExtendSortAsync(string field, SortDirection direction, Func<T, object> sortFunc, IComparer<object> comparer = null)
654          {
655              if (SortMode != SortMode.Multiple)
656              {
657                  await SetSortAsync(field, direction, sortFunc, comparer);
658                  return;
659              }
660              if (SortDefinitions.TryGetValue(field, out var sortDefinition))
661                  SortDefinitions[field] = sortDefinition with { Descending = direction == SortDirection.Descending, SortFunc = sortFunc, Comparer = comparer };
662              else
663              {
664                  var newDefinition = new SortDefinition<T>(field, direction == SortDirection.Descending, SortDefinitions.Count, sortFunc, comparer);
665                  SortDefinitions[field] = newDefinition;
666              }
667              await InvokeSortUpdates(SortDefinitions, null);
668          }
669          public async Task RemoveSortAsync(string field)
670          {
671              if (!string.IsNullOrWhiteSpace(field) && SortDefinitions.TryGetValue(field, out var definition))
672              {
673                  SortDefinitions.Remove(field);
674                  foreach (var defToUpdate in SortDefinitions.Where(kvp => kvp.Value.Index > definition.Index).ToList())
675                      SortDefinitions[defToUpdate.Key] = defToUpdate.Value with { Index = defToUpdate.Value.Index - 1 };
676                  await InvokeSortUpdates(SortDefinitions, new HashSet<string>() { field });
677              }
678          }
679          private async Task ClearCurrentSortings()
680          {
681              var removedSortDefinitions = new HashSet<string>(SortDefinitions.Keys);
682              SortDefinitions.Clear();
683              await InvokeSortUpdates(SortDefinitions, removedSortDefinitions);
684          }
685          private async Task InvokeSortUpdates(Dictionary<string, SortDefinition<T>> activeSortDefinitions, HashSet<string> removedSortDefinitions)
686          {
687              SortChangedEvent?.Invoke(activeSortDefinitions, removedSortDefinitions);
688              if (_isFirstRendered)
689              {
690                  await InvokeServerLoadFunc();
691                  if (ServerData == null)
692                      StateHasChanged();
693              }
694          }
695          public async Task SetSelectedItemAsync(T item)
696          {
697              if (MultiSelection)
698              {
699                  if (Selection.Contains(item))
700                  {
701                      Selection.Remove(item);
702                  }
703                  else
704                  {
705                      Selection.Add(item);
706                  }
707                  SelectedItemsChangedEvent?.Invoke(SelectedItems);
708                  await SelectedItemsChanged.InvokeAsync(SelectedItems);
709              }
710              SelectedItem = item;
711          }
712          [UnconditionalSuppressMessage("Trimming", "IL2026: Using member 'System.Text.Json.JsonSerializer.Deserialize<T>(string, System.Text.Json.JsonSerializerOptions?)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code. JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.", Justification = "Suppressing because T is a type supplied by the user and it is unlikely that it is not referenced by their code.")]
713          public async Task SetEditingItemAsync(T item)
714          {
715              if (ReadOnly) return;
716              editingSourceItem = item;
717              EditingCanceledEvent?.Invoke();
718              _previousEditingItem = _editingItem;
719              _editingItem = JsonSerializer.Deserialize<T>(JsonSerializer.Serialize(item));
720              StartedEditingItemEvent?.Invoke();
721              await StartedEditingItem.InvokeAsync(_editingItem);
722              isEditFormOpen = true;
723          }
724          public async Task CancelEditingItemAsync()
725          {
726              EditingCanceledEvent?.Invoke();
727              await CanceledEditingItem.InvokeAsync(_editingItem);
728              ClearEditingItem();
729              isEditFormOpen = false;
730          }
731          public void ToggleFiltersMenu()
732          {
733              _filtersMenuVisible = !_filtersMenuVisible;
734              StateHasChanged();
735          }
736          public Task ReloadServerData()
737          {
738              return InvokeServerLoadFunc();
739          }
740          public void OpenFilters()
741          {
742              _filtersMenuVisible = true;
743              StateHasChanged();
744          }
745          internal async Task HideAllColumnsAsync()
746          {
747              foreach (var column in RenderedColumns)
748              {
749                  if (column.Hideable ?? false)
750                      await column.HideAsync();
751              }
752              StateHasChanged();
753          }
754          internal async Task ShowAllColumnsAsync()
755          {
756              foreach (var column in RenderedColumns)
757              {
758                  if (column.Hideable ?? false)
759                      await column.ShowAsync();
760              }
761              StateHasChanged();
762          }
763          public void ShowColumnsPanel()
764          {
765              _columnsPanelVisible = true;
766              StateHasChanged();
767          }
768          public void HideColumnsPanel()
769          {
770              _columnsPanelVisible = false;
771              StateHasChanged();
772          }
773          internal void DropContainerHasChanged()
774          {
775              _dropContainer?.Refresh();
776          }
777          public void GroupItems(bool noStateChange = false)
778          {
779              if (GroupedColumn == null)
780              {
781                  _currentPageGroups = new List<GroupDefinition<T>>();
782                  _allGroups = new List<GroupDefinition<T>>();
783                  if (_isFirstRendered && !noStateChange)
784                      StateHasChanged();
785                  return;
786              }
787              var currentPageGroupings = CurrentPageItems.GroupBy(GroupedColumn.groupBy);
788              var allGroupings = FilteredItems.GroupBy(GroupedColumn.groupBy);
789              if (GetFilteredItemsCount() > 0 && _groupExpansions.Count == 0 && GroupExpanded)
790              {
791                  _groupExpansions.Add("__initial__");
792                  foreach (var group in allGroupings)
793                  {
794                      _groupExpansions.Add(group.Key);
795                  }
796              }
797              _currentPageGroups = currentPageGroupings.Select(x => new GroupDefinition<T>(x,
798                  _groupExpansions.Contains(x.Key))).ToList();
799              _allGroups = allGroupings.Select(x => new GroupDefinition<T>(x,
800                  _groupExpansions.Contains(x.Key))).ToList();                
801              if ((_isFirstRendered || ServerData != null) && !noStateChange)
802                  StateHasChanged();
803          }
804          internal void ChangedGrouping(Column<T> column)
805          {
806              foreach (var c in RenderedColumns)
807              {
808                  if (c.PropertyName != column.PropertyName)
809                      c.RemoveGrouping();
810              }
811              GroupItems();
812          }
813          internal void ToggleGroupExpansion(GroupDefinition<T> g)
814          {
815              if (_groupExpansions.Contains(g.Grouping.Key))
816              {
817                  _groupExpansions.Remove(g.Grouping.Key);
818              }
819              else
820              {
821                  _groupExpansions.Add(g.Grouping.Key);
822              }
823              GroupItems();
824          }
825          public void ExpandAllGroups()
826          {
827              foreach (var group in _allGroups)
828              {
829                  group.IsExpanded = true;
830                  _groupExpansions.Add(group.Grouping.Key);
831              }
832          }
833          public void CollapseAllGroups()
834          {
835              _groupExpansions.Clear();
836              _groupExpansions.Add("__initial__");
837              foreach (var group in _allGroups)
838                  group.IsExpanded = false;
839          }
840          #endregion
841          internal async Task ToggleHierarchyVisibilityAsync(T item)
842          {
843              if (_openHierarchies.Contains(item))
844              {
845                  _openHierarchies.Remove(item);
846              }
847              else
848              {
849                  _openHierarchies.Add(item);
850              }
851              await InvokeAsync(StateHasChanged);
852          }
853          #region Resize feature
854          [Inject] private IEventListener EventListener { get; set; }
855          internal bool IsResizing { get; set; }
856          private ElementReference _gridElement;
857          private DataGridColumnResizeService<T> _resizeService;
858          internal DataGridColumnResizeService<T> ResizeService
859          {
860              get
861              {
862                  return _resizeService ??= new DataGridColumnResizeService<T>(this, EventListener);
863              }
864          }
865          internal async Task<bool> StartResizeColumn(HeaderCell<T> headerCell, double clientX)
866              => await ResizeService.StartResizeColumn(headerCell, clientX, RenderedColumns, ColumnResizeMode);
867          internal async Task<double> GetActualHeight()
868          {
869              var gridRect = await _gridElement.MudGetBoundingClientRectAsync();
870              var gridHeight = gridRect.Height;
871              return gridHeight;
872          }
873          #endregion
874      }
875  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ColorTransformation.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudDataGrid.razor.cs</div>
                <div class="column column_space"><pre><code>13              public double H { get; set; }
14              public double S { get; set; }
15              public double L { get; set; }
</pre></code></div>
                <div class="column column_space"><pre><code>135          internal Action<Dictionary<string, SortDefinition<T>>, HashSet<string>> SortChangedEvent { get; set; }
136          internal Action<HashSet<T>> SelectedItemsChangedEvent { get; set; }
137          internal Action<bool> SelectedAllItemsChangedEvent { get; set; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    