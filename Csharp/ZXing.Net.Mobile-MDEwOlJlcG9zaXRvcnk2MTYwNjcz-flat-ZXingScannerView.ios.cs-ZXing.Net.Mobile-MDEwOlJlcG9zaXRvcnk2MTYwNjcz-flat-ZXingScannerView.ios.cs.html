
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>ZXing.Net.Mobile-MDEwOlJlcG9zaXRvcnk2MTYwNjcz-flat-ZXingScannerView.ios.cs</h3>
            <pre><code>1  using System;
2  using System.Linq;
3  using System.Collections.Generic;
4  using System.Drawing;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Foundation;
8  using CoreFoundation;
9  using AVFoundation;
10  using CoreGraphics;
11  using CoreMedia;
12  using CoreVideo;
13  using ObjCRuntime;
14  using UIKit;
15  using ZXing.Common;
16  using ZXing.Mobile;
17  namespace ZXing.Mobile
18  {
19  	public class ZXingScannerView : UIView, IZXingScanner<UIView>, IScannerSessionHost
20  	{
21  		public delegate void ScannerSetupCompleteDelegate();
22  		public event ScannerSetupCompleteDelegate OnScannerSetupComplete;
23  		public ZXingScannerView()
24  		{
25  		}
26  		public ZXingScannerView(IntPtr handle) : base(handle)
27  		{
28  		}
29  		public ZXingScannerView(CGRect frame) : base(frame)
30  		{
31  		}
32  		AVCaptureSession session;
33  		AVCaptureDevice captureDevice = null;
34  		AVCaptureVideoPreviewLayer previewLayer;
35  		AVCaptureVideoDataOutput output;
36  		OutputRecorder outputRecorder;
37  		DispatchQueue queue;
38  		Action<ZXing.Result> resultCallback;
39  		volatile bool stopped = true;
40  		UIView layerView;
41  		UIView overlayView = null;
42  		public MobileBarcodeScanningOptions ScanningOptions { get; set; }
43  		public event Action OnCancelButtonPressed;
44  		public string CancelButtonText { get; set; }
45  		public string FlashButtonText { get; set; }
46  		bool shouldRotatePreviewBuffer = false;
47  		AVConfigs captureDeviceOriginalConfig;
48  		void Setup()
49  		{
50  			var started = DateTime.UtcNow;
51  			if (overlayView != null)
52  				overlayView.RemoveFromSuperview();
53  			if (UseCustomOverlayView)
54  				overlayView = CustomOverlayView;
55  			else
56  			{
57  				overlayView = new ZXingDefaultOverlayView(new CGRect(0, 0, Frame.Width, Frame.Height),
58  					TopText, BottomText, CancelButtonText, FlashButtonText,
59  					() =>
60  					{
61  						var evt = OnCancelButtonPressed;
62  						if (evt != null)
63  							evt();
64  					}, ToggleTorch);
65  			}
66  			if (overlayView != null)
67  			{
68  				overlayView.Frame = new CGRect(0, 0, this.Frame.Width, this.Frame.Height);
69  				overlayView.AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight;
70  			}
71  			var total = DateTime.UtcNow - started;
72  			Console.WriteLine("ZXingScannerView.Setup() took {0} ms.", total.TotalMilliseconds);
73  		}
74  		bool torch = false;
75  		bool analyzing = true;
76  		bool SetupCaptureSession()
77  		{
78  			var started = DateTime.UtcNow;
79  			var availableResolutions = new List<CameraResolution>();
80  			var consideredResolutions = new Dictionary<NSString, CameraResolution> {
81  				{ AVCaptureSession.Preset352x288, new CameraResolution   { Width = 352,  Height = 288 } },
82  				{ AVCaptureSession.PresetMedium, new CameraResolution    { Width = 480,  Height = 360 } },	
83  				{ AVCaptureSession.Preset640x480, new CameraResolution   { Width = 640,  Height = 480 } },
84  				{ AVCaptureSession.Preset1280x720, new CameraResolution  { Width = 1280, Height = 720 } },
85  				{ AVCaptureSession.Preset1920x1080, new CameraResolution { Width = 1920, Height = 1080 } }
86  			};
87  			session = new AVCaptureSession()
88  			{
89  				SessionPreset = AVCaptureSession.Preset640x480
90  			};
91  			var devices = AVCaptureDevice.DevicesWithMediaType(AVMediaType.Video);
92  			foreach (var device in devices)
93  			{
94  				captureDevice = device;
95  				if (ScanningOptions.UseFrontCameraIfAvailable.HasValue &&
96  					ScanningOptions.UseFrontCameraIfAvailable.Value &&
97  					device.Position == AVCaptureDevicePosition.Front)
98  					break; 
99  				else if (device.Position == AVCaptureDevicePosition.Back && (!ScanningOptions.UseFrontCameraIfAvailable.HasValue || !ScanningOptions.UseFrontCameraIfAvailable.Value))
100  					break; 
101  			}
102  			if (captureDevice == null)
103  			{
104  				Console.WriteLine("No captureDevice - this won't work on the simulator, try a physical device");
105  				if (overlayView != null)
106  				{
107  					AddSubview(overlayView);
108  					BringSubviewToFront(overlayView);
109  				}
110  				return false;
111  			}
112  			CameraResolution resolution = null;
113  			foreach (var cr in consideredResolutions)
114  			{
115  				if (captureDevice.SupportsAVCaptureSessionPreset(cr.Key))
116  					availableResolutions.Add(cr.Value);
117  			}
118  			resolution = ScanningOptions.GetResolution(availableResolutions);
119  			if (resolution != null)
120  			{
121  				var preset = (from c in consideredResolutions
122  							  where c.Value.Width == resolution.Width
123  								&& c.Value.Height == resolution.Height
124  							  select c.Key).FirstOrDefault();
125  				if (!string.IsNullOrEmpty(preset))
126  					session.SessionPreset = preset;
127  			}
128  			var input = AVCaptureDeviceInput.FromDevice(captureDevice);
129  			if (input == null)
130  			{
131  				Console.WriteLine("No input - this won't work on the simulator, try a physical device");
132  				if (overlayView != null)
133  				{
134  					AddSubview(overlayView);
135  					BringSubviewToFront(overlayView);
136  				}
137  				return false;
138  			}
139  			else
140  				session.AddInput(input);
141  			var startedAVPreviewLayerAlloc = PerformanceCounter.Start();
142  			previewLayer = new AVCaptureVideoPreviewLayer(session);
143  			PerformanceCounter.Stop(startedAVPreviewLayerAlloc, "Alloc AVCaptureVideoPreviewLayer took {0} ms.");
144  			var perf2 = PerformanceCounter.Start();
145  			previewLayer.VideoGravity = AVLayerVideoGravity.ResizeAspectFill;
146  			previewLayer.Frame = new CGRect(0, 0, Frame.Width, Frame.Height);
147  			previewLayer.Position = new CGPoint(Layer.Bounds.Width / 2, (Layer.Bounds.Height / 2));
148  			layerView = new UIView(new CGRect(0, 0, Frame.Width, Frame.Height));
149  			layerView.AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight;
150  			layerView.Layer.AddSublayer(previewLayer);
151  			AddSubview(layerView);
152  			ResizePreview(UIApplication.SharedApplication.StatusBarOrientation);
153  			if (overlayView != null)
154  			{
155  				AddSubview(overlayView);
156  				BringSubviewToFront(overlayView);
157  			}
158  			PerformanceCounter.Stop(perf2, "PERF: Setting up layers took {0} ms");
159  			var perf3 = PerformanceCounter.Start();
160  			session.StartRunning();
161  			PerformanceCounter.Stop(perf3, "PERF: session.StartRunning() took {0} ms");
162  			var perf4 = PerformanceCounter.Start();
163  			var videoSettings = NSDictionary.FromObjectAndKey(new NSNumber((int)CVPixelFormatType.CV32BGRA),
164  				CVPixelBuffer.PixelFormatTypeKey);
165  			output = new AVCaptureVideoDataOutput
166  			{
167  				WeakVideoSettings = videoSettings
168  			};
169  			queue = new DispatchQueue("ZxingScannerView"); 
170  			var barcodeReader = ScanningOptions.BuildBarcodeReader();
171  			outputRecorder = new OutputRecorder(this, img =>
172  			{
173  				var ls = img;
174  				if (!IsAnalyzing)
175  					return false;
176  				try
177  				{
178  					var perfDecode = PerformanceCounter.Start();
179  					if (shouldRotatePreviewBuffer)
180  						ls = ls.rotateCounterClockwise();
181  					var result = barcodeReader.Decode(ls);
182  					PerformanceCounter.Stop(perfDecode, "Decode Time: {0} ms");
183  					if (result != null)
184  					{
185  						resultCallback(result);
186  						return true;
187  					}
188  				}
189  				catch (Exception ex)
190  				{
191  					Console.WriteLine("DECODE FAILED: " + ex);
192  				}
193  				return false;
194  			});
195  			output.AlwaysDiscardsLateVideoFrames = true;
196  			output.SetSampleBufferDelegate(outputRecorder, queue);
197  			PerformanceCounter.Stop(perf4, "PERF: SetupCamera Finished.  Took {0} ms.");
198  			session.AddOutput(output);
199  			var perf5 = PerformanceCounter.Start();
200  			if (captureDevice.LockForConfiguration(out var err))
201  			{
202  				captureDeviceOriginalConfig = new AVConfigs
203  				{
204  					FocusMode = captureDevice.FocusMode,
205  					ExposureMode = captureDevice.ExposureMode,
206  					WhiteBalanceMode = captureDevice.WhiteBalanceMode,
207  					AutoFocusRangeRestriction = captureDevice.AutoFocusRangeRestriction,
208  				};
209  				if (captureDevice.HasFlash)
210  					captureDeviceOriginalConfig.FlashMode = captureDevice.FlashMode;
211  				if (captureDevice.HasTorch)
212  					captureDeviceOriginalConfig.TorchMode = captureDevice.TorchMode;
213  				if (captureDevice.FocusPointOfInterestSupported)
214  					captureDeviceOriginalConfig.FocusPointOfInterest = captureDevice.FocusPointOfInterest;
215  				if (captureDevice.ExposurePointOfInterestSupported)
216  					captureDeviceOriginalConfig.ExposurePointOfInterest = captureDevice.ExposurePointOfInterest;
217  				if (ScanningOptions.DisableAutofocus)
218  				{
219  					captureDevice.FocusMode = AVCaptureFocusMode.Locked;
220  				}
221  				else
222  				{
223  					if (captureDevice.IsFocusModeSupported(AVCaptureFocusMode.ContinuousAutoFocus))
224  						captureDevice.FocusMode = AVCaptureFocusMode.ContinuousAutoFocus;
225  					else if (captureDevice.IsFocusModeSupported(AVCaptureFocusMode.AutoFocus))
226  						captureDevice.FocusMode = AVCaptureFocusMode.AutoFocus;
227  				}
228  				if (captureDevice.IsExposureModeSupported(AVCaptureExposureMode.ContinuousAutoExposure))
229  					captureDevice.ExposureMode = AVCaptureExposureMode.ContinuousAutoExposure;
230  				else if (captureDevice.IsExposureModeSupported(AVCaptureExposureMode.AutoExpose))
231  					captureDevice.ExposureMode = AVCaptureExposureMode.AutoExpose;
232  				if (captureDevice.IsWhiteBalanceModeSupported(AVCaptureWhiteBalanceMode.ContinuousAutoWhiteBalance))
233  					captureDevice.WhiteBalanceMode = AVCaptureWhiteBalanceMode.ContinuousAutoWhiteBalance;
234  				else if (captureDevice.IsWhiteBalanceModeSupported(AVCaptureWhiteBalanceMode.AutoWhiteBalance))
235  					captureDevice.WhiteBalanceMode = AVCaptureWhiteBalanceMode.AutoWhiteBalance;
236  				if (UIDevice.CurrentDevice.CheckSystemVersion(7, 0) && captureDevice.AutoFocusRangeRestrictionSupported)
237  				{
238  					captureDevice.AutoFocusRangeRestriction = AVCaptureAutoFocusRangeRestriction.Near;
239  				}
240  				if (captureDevice.FocusPointOfInterestSupported)
241  					captureDevice.FocusPointOfInterest = new PointF(0.5f, 0.5f);
242  				if (captureDevice.ExposurePointOfInterestSupported)
243  					captureDevice.ExposurePointOfInterest = new PointF(0.5f, 0.5f);
244  				captureDevice.UnlockForConfiguration();
245  			}
246  			else
247  				Console.WriteLine("Failed to Lock for Config: " + err.Description);
248  			PerformanceCounter.Stop(perf5, "PERF: Setup Focus in {0} ms.");
249  			return true;
250  		}
251  		public void DidRotate(UIInterfaceOrientation orientation)
252  		{
253  			ResizePreview(orientation);
254  			LayoutSubviews();
255  		}
256  		public void ResizePreview(UIInterfaceOrientation orientation)
257  		{
258  			shouldRotatePreviewBuffer = orientation == UIInterfaceOrientation.Portrait || orientation == UIInterfaceOrientation.PortraitUpsideDown;
259  			if (previewLayer == null)
260  				return;
261  			previewLayer.Frame = new CGRect(0, 0, Frame.Width, Frame.Height);
262  			if (previewLayer.RespondsToSelector(new Selector("connection")) && previewLayer.Connection != null)
263  			{
264  				switch (orientation)
265  				{
266  					case UIInterfaceOrientation.LandscapeLeft:
267  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.LandscapeLeft;
268  						break;
269  					case UIInterfaceOrientation.LandscapeRight:
270  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.LandscapeRight;
271  						break;
<span onclick='openModal()' class='match'>272  					case UIInterfaceOrientation.Portrait:
273  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.Portrait;
274  						break;
275  					case UIInterfaceOrientation.PortraitUpsideDown:
</span>276  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.PortraitUpsideDown;
277  						break;
278  				}
279  			}
280  		}
281  		public void Focus(PointF pointOfInterest)
282  		{
283  			if (AVMediaType.Video == null)
284  				return;
285  			var device = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
286  			if (device == null)
287  				return;
288  			if (device.FocusPointOfInterestSupported && !device.AdjustingFocus)
289  			{
290  				NSError err = null;
291  				if (device.LockForConfiguration(out err))
292  				{
293  					Console.WriteLine("Focusing at point: " + pointOfInterest.X + ", " + pointOfInterest.Y);
294  					device.FocusPointOfInterest = pointOfInterest;
295  					device.FocusMode = AVCaptureFocusMode.ContinuousAutoFocus;
296  					device.UnlockForConfiguration();
297  				}
298  			}
299  		}
300  		public class OutputRecorder : AVCaptureVideoDataOutputSampleBufferDelegate
301  		{
302  			public OutputRecorder(IScannerSessionHost scannerHost, Func<LuminanceSource, bool> handleImage) : base()
303  			{
304  				this.handleImage = handleImage;
305  				this.scannerHost = scannerHost;
306  			}
307  			IScannerSessionHost scannerHost;
308  			Func<LuminanceSource, bool> handleImage;
309  			DateTime lastAnalysis = DateTime.MinValue;
310  			volatile bool working = false;
311  			volatile bool wasScanned = false;
312  			[Export("captureOutput:didDropSampleBuffer:fromConnection:")]
313  			public override void DidDropSampleBuffer(AVCaptureOutput captureOutput, CMSampleBuffer sampleBuffer, AVCaptureConnection connection)
314  			{
315  			}
316  			public CancellationTokenSource CancelTokenSource = new CancellationTokenSource();
317  			public override void DidOutputSampleBuffer(AVCaptureOutput captureOutput, CMSampleBuffer sampleBuffer, AVCaptureConnection connection)
318  			{
319  				var msSinceLastPreview = (DateTime.UtcNow - lastAnalysis).TotalMilliseconds;
320  				if (msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenAnalyzingFrames
321  					|| (wasScanned && msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenContinuousScans)
322  					|| working
323  					|| CancelTokenSource.IsCancellationRequested)
324  				{
325  					if (msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenAnalyzingFrames)
326  						Console.WriteLine("Too soon between frames");
327  					if (wasScanned && msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenContinuousScans)
328  						Console.WriteLine("Too soon since last scan");
329  					if (sampleBuffer != null)
330  					{
331  						sampleBuffer.Dispose();
332  						sampleBuffer = null;
333  					}
334  					return;
335  				}
336  				wasScanned = false;
337  				working = true;
338  				lastAnalysis = DateTime.UtcNow;
339  				try
340  				{
341  					using (var pixelBuffer = sampleBuffer.GetImageBuffer() as CVPixelBuffer)
342  					{
343  						pixelBuffer.Lock(CVPixelBufferLock.ReadOnly); 
344  						LuminanceSource luminanceSource;
345  						unsafe
346  						{
347  							var rawData = (byte*)pixelBuffer.BaseAddress.ToPointer();
348  							var rawDatalen = (int)(pixelBuffer.Height * pixelBuffer.Width * 4); 
349  							luminanceSource = new CVPixelBufferBGRA32LuminanceSource(rawData, rawDatalen, (int)pixelBuffer.Width, (int)pixelBuffer.Height);
350  						}
351  						if (handleImage(luminanceSource))
352  							wasScanned = true;
353  						pixelBuffer.Unlock(CVPixelBufferLock.ReadOnly);
354  					}
355  					sampleBuffer.Dispose();
356  					sampleBuffer = null;
357  				}
358  				catch (Exception e)
359  				{
360  					Console.WriteLine(e);
361  				}
362  				finally
363  				{
364  					working = false;
365  				}
366  			}
367  		}
368  		#region IZXingScanner implementation
369  		public void StartScanning(Action<Result> scanResultHandler, MobileBarcodeScanningOptions options = null)
370  		{
371  			if (!stopped)
372  				return;
373  			stopped = false;
374  			var perf = PerformanceCounter.Start();
375  			Setup();
376  			ScanningOptions = options ?? MobileBarcodeScanningOptions.Default;
377  			resultCallback = scanResultHandler;
378  			Console.WriteLine("StartScanning");
379  			InvokeOnMainThread(() =>
380  			{
381  				if (!SetupCaptureSession())
382  				{
383  					Console.WriteLine("Capture Session FAILED");
384  				}
385  				if (Runtime.Arch == Arch.SIMULATOR)
386  				{
387  					InsertSubview(new UIView(new CGRect(0, 0, this.Frame.Width, this.Frame.Height))
388  					{
389  						BackgroundColor = UIColor.LightGray,
390  						AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight
391  					}, 0);
392  				}
393  			});
394  			if (!analyzing)
395  				analyzing = true;
396  			PerformanceCounter.Stop(perf, "PERF: StartScanning() Took {0} ms.");
397  			OnScannerSetupComplete?.Invoke();
398  		}
399  		public void StopScanning()
400  		{
401  			if (overlayView != null)
402  			{
403  				if (overlayView is ZXingDefaultOverlayView)
404  					(overlayView as ZXingDefaultOverlayView).Destroy();
405  				overlayView = null;
406  			}
407  			if (stopped)
408  				return;
409  			Console.WriteLine("Stopping...");
410  			if (outputRecorder != null)
411  				outputRecorder.CancelTokenSource.Cancel();
412  			if (captureDevice != null && captureDevice.LockForConfiguration(out var err))
413  			{
414  				captureDevice.FocusMode = captureDeviceOriginalConfig.FocusMode;
415  				captureDevice.ExposureMode = captureDeviceOriginalConfig.ExposureMode;
416  				captureDevice.WhiteBalanceMode = captureDeviceOriginalConfig.WhiteBalanceMode;
417  				if (UIDevice.CurrentDevice.CheckSystemVersion(7, 0) && captureDevice.AutoFocusRangeRestrictionSupported)
418  					captureDevice.AutoFocusRangeRestriction = captureDeviceOriginalConfig.AutoFocusRangeRestriction;
419  				if (captureDevice.FocusPointOfInterestSupported)
420  					captureDevice.FocusPointOfInterest = captureDeviceOriginalConfig.FocusPointOfInterest;
421  				if (captureDevice.ExposurePointOfInterestSupported)
422  					captureDevice.ExposurePointOfInterest = captureDeviceOriginalConfig.ExposurePointOfInterest;
423  				if (captureDevice.HasFlash)
424  					captureDevice.FlashMode = captureDeviceOriginalConfig.FlashMode;
425  				if (captureDevice.HasTorch)
426  					captureDevice.TorchMode = captureDeviceOriginalConfig.TorchMode;
427  				captureDevice.UnlockForConfiguration();
428  			}
429  			try
430  			{
431  				while (session.Outputs.Length > 0)
432  					session.RemoveOutput(session.Outputs[0]);
433  			}
434  			catch { }
435  			try
436  			{
437  				while (session.Inputs.Length > 0)
438  					session.RemoveInput(session.Inputs[0]);
439  			}
440  			catch { }
441  			if (session.Running)
442  				session.StopRunning();
443  			stopped = true;
444  		}
445  		public void PauseAnalysis()
446  			=> analyzing = false;
447  		public void ResumeAnalysis()
448  			=> analyzing = true;
449  		public void Torch(bool on)
450  		{
451  			try
452  			{
453  				var device = captureDevice ?? AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
454  				if (device != null && (device.HasTorch || device.HasFlash))
455  				{
456  					device.LockForConfiguration(out var err);
457  					if (err != null)
458  					{
459  						if (on)
460  						{
461  							if (device.HasTorch)
462  								device.TorchMode = AVCaptureTorchMode.On;
463  							if (device.HasFlash)
464  								device.FlashMode = AVCaptureFlashMode.On;
465  						}
466  						else
467  						{
468  							if (device.HasTorch)
469  								device.TorchMode = AVCaptureTorchMode.Off;
470  							if (device.HasFlash)
471  								device.FlashMode = AVCaptureFlashMode.Off;
472  						}
473  					}
474  					try
475  					{
476  						device.UnlockForConfiguration();
477  					}
478  					catch { }
479  				}
480  				torch = on;
481  			}
482  			catch { }
483  		}
484  		public void ToggleTorch()
485  			=> Torch(!IsTorchOn);
486  		public void AutoFocus()
487  		{
488  		}
489  		public void AutoFocus(int x, int y)
490  		{
491  		}
492  		public string TopText { get; set; }
493  		public string BottomText { get; set; }
494  		public UIView CustomOverlayView { get; set; }
495  		public bool UseCustomOverlayView { get; set; }
496  		public bool IsAnalyzing { get { return analyzing; } }
497  		public bool IsTorchOn { get { return torch; } }
498  		bool? hasTorch = null;
499  		public bool HasTorch
500  		{
501  			get
502  			{
503  				if (hasTorch.HasValue)
504  					return hasTorch.Value;
505  				var device = captureDevice ?? AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
506  				hasTorch = device.HasFlash || device.HasTorch;
507  				return hasTorch.Value;
508  			}
509  		}
510  		#endregion
511  	}
512  	struct AVConfigs
513  	{
514  		public AVCaptureFocusMode FocusMode;
515  		public AVCaptureExposureMode ExposureMode;
516  		public AVCaptureWhiteBalanceMode WhiteBalanceMode;
517  		public AVCaptureAutoFocusRangeRestriction AutoFocusRangeRestriction;
518  		public CGPoint FocusPointOfInterest;
519  		public CGPoint ExposurePointOfInterest;
520  		public AVCaptureFlashMode FlashMode;
521  		public AVCaptureTorchMode TorchMode;
522  	}
523  }
</code></pre>
        </div>
        <div class="column">
            <h3>ZXing.Net.Mobile-MDEwOlJlcG9zaXRvcnk2MTYwNjcz-flat-ZXingScannerView.ios.cs</h3>
            <pre><code>1  using System;
2  using System.Linq;
3  using System.Collections.Generic;
4  using System.Drawing;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Foundation;
8  using CoreFoundation;
9  using AVFoundation;
10  using CoreGraphics;
11  using CoreMedia;
12  using CoreVideo;
13  using ObjCRuntime;
14  using UIKit;
15  using ZXing.Common;
16  using ZXing.Mobile;
17  namespace ZXing.Mobile
18  {
19  	public class ZXingScannerView : UIView, IZXingScanner<UIView>, IScannerSessionHost
20  	{
21  		public delegate void ScannerSetupCompleteDelegate();
22  		public event ScannerSetupCompleteDelegate OnScannerSetupComplete;
23  		public ZXingScannerView()
24  		{
25  		}
26  		public ZXingScannerView(IntPtr handle) : base(handle)
27  		{
28  		}
29  		public ZXingScannerView(CGRect frame) : base(frame)
30  		{
31  		}
32  		AVCaptureSession session;
33  		AVCaptureDevice captureDevice = null;
34  		AVCaptureVideoPreviewLayer previewLayer;
35  		AVCaptureVideoDataOutput output;
36  		OutputRecorder outputRecorder;
37  		DispatchQueue queue;
38  		Action<ZXing.Result> resultCallback;
39  		volatile bool stopped = true;
40  		UIView layerView;
41  		UIView overlayView = null;
42  		public MobileBarcodeScanningOptions ScanningOptions { get; set; }
43  		public event Action OnCancelButtonPressed;
44  		public string CancelButtonText { get; set; }
45  		public string FlashButtonText { get; set; }
46  		bool shouldRotatePreviewBuffer = false;
47  		AVConfigs captureDeviceOriginalConfig;
48  		void Setup()
49  		{
50  			var started = DateTime.UtcNow;
51  			if (overlayView != null)
52  				overlayView.RemoveFromSuperview();
53  			if (UseCustomOverlayView)
54  				overlayView = CustomOverlayView;
55  			else
56  			{
57  				overlayView = new ZXingDefaultOverlayView(new CGRect(0, 0, Frame.Width, Frame.Height),
58  					TopText, BottomText, CancelButtonText, FlashButtonText,
59  					() =>
60  					{
61  						var evt = OnCancelButtonPressed;
62  						if (evt != null)
63  							evt();
64  					}, ToggleTorch);
65  			}
66  			if (overlayView != null)
67  			{
68  				overlayView.Frame = new CGRect(0, 0, this.Frame.Width, this.Frame.Height);
69  				overlayView.AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight;
70  			}
71  			var total = DateTime.UtcNow - started;
72  			Console.WriteLine("ZXingScannerView.Setup() took {0} ms.", total.TotalMilliseconds);
73  		}
74  		bool torch = false;
75  		bool analyzing = true;
76  		bool SetupCaptureSession()
77  		{
78  			var started = DateTime.UtcNow;
79  			var availableResolutions = new List<CameraResolution>();
80  			var consideredResolutions = new Dictionary<NSString, CameraResolution> {
81  				{ AVCaptureSession.Preset352x288, new CameraResolution   { Width = 352,  Height = 288 } },
82  				{ AVCaptureSession.PresetMedium, new CameraResolution    { Width = 480,  Height = 360 } },	
83  				{ AVCaptureSession.Preset640x480, new CameraResolution   { Width = 640,  Height = 480 } },
84  				{ AVCaptureSession.Preset1280x720, new CameraResolution  { Width = 1280, Height = 720 } },
85  				{ AVCaptureSession.Preset1920x1080, new CameraResolution { Width = 1920, Height = 1080 } }
86  			};
87  			session = new AVCaptureSession()
88  			{
89  				SessionPreset = AVCaptureSession.Preset640x480
90  			};
91  			var devices = AVCaptureDevice.DevicesWithMediaType(AVMediaType.Video);
92  			foreach (var device in devices)
93  			{
94  				captureDevice = device;
95  				if (ScanningOptions.UseFrontCameraIfAvailable.HasValue &&
96  					ScanningOptions.UseFrontCameraIfAvailable.Value &&
97  					device.Position == AVCaptureDevicePosition.Front)
98  					break; 
99  				else if (device.Position == AVCaptureDevicePosition.Back && (!ScanningOptions.UseFrontCameraIfAvailable.HasValue || !ScanningOptions.UseFrontCameraIfAvailable.Value))
100  					break; 
101  			}
102  			if (captureDevice == null)
103  			{
104  				Console.WriteLine("No captureDevice - this won't work on the simulator, try a physical device");
105  				if (overlayView != null)
106  				{
107  					AddSubview(overlayView);
108  					BringSubviewToFront(overlayView);
109  				}
110  				return false;
111  			}
112  			CameraResolution resolution = null;
113  			foreach (var cr in consideredResolutions)
114  			{
115  				if (captureDevice.SupportsAVCaptureSessionPreset(cr.Key))
116  					availableResolutions.Add(cr.Value);
117  			}
118  			resolution = ScanningOptions.GetResolution(availableResolutions);
119  			if (resolution != null)
120  			{
121  				var preset = (from c in consideredResolutions
122  							  where c.Value.Width == resolution.Width
123  								&& c.Value.Height == resolution.Height
124  							  select c.Key).FirstOrDefault();
125  				if (!string.IsNullOrEmpty(preset))
126  					session.SessionPreset = preset;
127  			}
128  			var input = AVCaptureDeviceInput.FromDevice(captureDevice);
129  			if (input == null)
130  			{
131  				Console.WriteLine("No input - this won't work on the simulator, try a physical device");
132  				if (overlayView != null)
133  				{
134  					AddSubview(overlayView);
135  					BringSubviewToFront(overlayView);
136  				}
137  				return false;
138  			}
139  			else
140  				session.AddInput(input);
141  			var startedAVPreviewLayerAlloc = PerformanceCounter.Start();
142  			previewLayer = new AVCaptureVideoPreviewLayer(session);
143  			PerformanceCounter.Stop(startedAVPreviewLayerAlloc, "Alloc AVCaptureVideoPreviewLayer took {0} ms.");
144  			var perf2 = PerformanceCounter.Start();
145  			previewLayer.VideoGravity = AVLayerVideoGravity.ResizeAspectFill;
146  			previewLayer.Frame = new CGRect(0, 0, Frame.Width, Frame.Height);
147  			previewLayer.Position = new CGPoint(Layer.Bounds.Width / 2, (Layer.Bounds.Height / 2));
148  			layerView = new UIView(new CGRect(0, 0, Frame.Width, Frame.Height));
149  			layerView.AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight;
150  			layerView.Layer.AddSublayer(previewLayer);
151  			AddSubview(layerView);
152  			ResizePreview(UIApplication.SharedApplication.StatusBarOrientation);
153  			if (overlayView != null)
154  			{
155  				AddSubview(overlayView);
156  				BringSubviewToFront(overlayView);
157  			}
158  			PerformanceCounter.Stop(perf2, "PERF: Setting up layers took {0} ms");
159  			var perf3 = PerformanceCounter.Start();
160  			session.StartRunning();
161  			PerformanceCounter.Stop(perf3, "PERF: session.StartRunning() took {0} ms");
162  			var perf4 = PerformanceCounter.Start();
163  			var videoSettings = NSDictionary.FromObjectAndKey(new NSNumber((int)CVPixelFormatType.CV32BGRA),
164  				CVPixelBuffer.PixelFormatTypeKey);
165  			output = new AVCaptureVideoDataOutput
166  			{
167  				WeakVideoSettings = videoSettings
168  			};
169  			queue = new DispatchQueue("ZxingScannerView"); 
170  			var barcodeReader = ScanningOptions.BuildBarcodeReader();
171  			outputRecorder = new OutputRecorder(this, img =>
172  			{
173  				var ls = img;
174  				if (!IsAnalyzing)
175  					return false;
176  				try
177  				{
178  					var perfDecode = PerformanceCounter.Start();
179  					if (shouldRotatePreviewBuffer)
180  						ls = ls.rotateCounterClockwise();
181  					var result = barcodeReader.Decode(ls);
182  					PerformanceCounter.Stop(perfDecode, "Decode Time: {0} ms");
183  					if (result != null)
184  					{
185  						resultCallback(result);
186  						return true;
187  					}
188  				}
189  				catch (Exception ex)
190  				{
191  					Console.WriteLine("DECODE FAILED: " + ex);
192  				}
193  				return false;
194  			});
195  			output.AlwaysDiscardsLateVideoFrames = true;
196  			output.SetSampleBufferDelegate(outputRecorder, queue);
197  			PerformanceCounter.Stop(perf4, "PERF: SetupCamera Finished.  Took {0} ms.");
198  			session.AddOutput(output);
199  			var perf5 = PerformanceCounter.Start();
200  			if (captureDevice.LockForConfiguration(out var err))
201  			{
202  				captureDeviceOriginalConfig = new AVConfigs
203  				{
204  					FocusMode = captureDevice.FocusMode,
205  					ExposureMode = captureDevice.ExposureMode,
206  					WhiteBalanceMode = captureDevice.WhiteBalanceMode,
207  					AutoFocusRangeRestriction = captureDevice.AutoFocusRangeRestriction,
208  				};
209  				if (captureDevice.HasFlash)
210  					captureDeviceOriginalConfig.FlashMode = captureDevice.FlashMode;
211  				if (captureDevice.HasTorch)
212  					captureDeviceOriginalConfig.TorchMode = captureDevice.TorchMode;
213  				if (captureDevice.FocusPointOfInterestSupported)
214  					captureDeviceOriginalConfig.FocusPointOfInterest = captureDevice.FocusPointOfInterest;
215  				if (captureDevice.ExposurePointOfInterestSupported)
216  					captureDeviceOriginalConfig.ExposurePointOfInterest = captureDevice.ExposurePointOfInterest;
217  				if (ScanningOptions.DisableAutofocus)
218  				{
219  					captureDevice.FocusMode = AVCaptureFocusMode.Locked;
220  				}
221  				else
222  				{
223  					if (captureDevice.IsFocusModeSupported(AVCaptureFocusMode.ContinuousAutoFocus))
224  						captureDevice.FocusMode = AVCaptureFocusMode.ContinuousAutoFocus;
225  					else if (captureDevice.IsFocusModeSupported(AVCaptureFocusMode.AutoFocus))
226  						captureDevice.FocusMode = AVCaptureFocusMode.AutoFocus;
227  				}
228  				if (captureDevice.IsExposureModeSupported(AVCaptureExposureMode.ContinuousAutoExposure))
229  					captureDevice.ExposureMode = AVCaptureExposureMode.ContinuousAutoExposure;
230  				else if (captureDevice.IsExposureModeSupported(AVCaptureExposureMode.AutoExpose))
231  					captureDevice.ExposureMode = AVCaptureExposureMode.AutoExpose;
232  				if (captureDevice.IsWhiteBalanceModeSupported(AVCaptureWhiteBalanceMode.ContinuousAutoWhiteBalance))
233  					captureDevice.WhiteBalanceMode = AVCaptureWhiteBalanceMode.ContinuousAutoWhiteBalance;
234  				else if (captureDevice.IsWhiteBalanceModeSupported(AVCaptureWhiteBalanceMode.AutoWhiteBalance))
235  					captureDevice.WhiteBalanceMode = AVCaptureWhiteBalanceMode.AutoWhiteBalance;
236  				if (UIDevice.CurrentDevice.CheckSystemVersion(7, 0) && captureDevice.AutoFocusRangeRestrictionSupported)
237  				{
238  					captureDevice.AutoFocusRangeRestriction = AVCaptureAutoFocusRangeRestriction.Near;
239  				}
240  				if (captureDevice.FocusPointOfInterestSupported)
241  					captureDevice.FocusPointOfInterest = new PointF(0.5f, 0.5f);
242  				if (captureDevice.ExposurePointOfInterestSupported)
243  					captureDevice.ExposurePointOfInterest = new PointF(0.5f, 0.5f);
244  				captureDevice.UnlockForConfiguration();
245  			}
246  			else
247  				Console.WriteLine("Failed to Lock for Config: " + err.Description);
248  			PerformanceCounter.Stop(perf5, "PERF: Setup Focus in {0} ms.");
249  			return true;
250  		}
251  		public void DidRotate(UIInterfaceOrientation orientation)
252  		{
253  			ResizePreview(orientation);
254  			LayoutSubviews();
255  		}
256  		public void ResizePreview(UIInterfaceOrientation orientation)
257  		{
258  			shouldRotatePreviewBuffer = orientation == UIInterfaceOrientation.Portrait || orientation == UIInterfaceOrientation.PortraitUpsideDown;
259  			if (previewLayer == null)
260  				return;
261  			previewLayer.Frame = new CGRect(0, 0, Frame.Width, Frame.Height);
262  			if (previewLayer.RespondsToSelector(new Selector("connection")) && previewLayer.Connection != null)
263  			{
264  				switch (orientation)
265  				{
<span onclick='openModal()' class='match'>266  					case UIInterfaceOrientation.LandscapeLeft:
267  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.LandscapeLeft;
268  						break;
269  					case UIInterfaceOrientation.LandscapeRight:
</span>270  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.LandscapeRight;
271  						break;
272  					case UIInterfaceOrientation.Portrait:
273  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.Portrait;
274  						break;
275  					case UIInterfaceOrientation.PortraitUpsideDown:
276  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.PortraitUpsideDown;
277  						break;
278  				}
279  			}
280  		}
281  		public void Focus(PointF pointOfInterest)
282  		{
283  			if (AVMediaType.Video == null)
284  				return;
285  			var device = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
286  			if (device == null)
287  				return;
288  			if (device.FocusPointOfInterestSupported && !device.AdjustingFocus)
289  			{
290  				NSError err = null;
291  				if (device.LockForConfiguration(out err))
292  				{
293  					Console.WriteLine("Focusing at point: " + pointOfInterest.X + ", " + pointOfInterest.Y);
294  					device.FocusPointOfInterest = pointOfInterest;
295  					device.FocusMode = AVCaptureFocusMode.ContinuousAutoFocus;
296  					device.UnlockForConfiguration();
297  				}
298  			}
299  		}
300  		public class OutputRecorder : AVCaptureVideoDataOutputSampleBufferDelegate
301  		{
302  			public OutputRecorder(IScannerSessionHost scannerHost, Func<LuminanceSource, bool> handleImage) : base()
303  			{
304  				this.handleImage = handleImage;
305  				this.scannerHost = scannerHost;
306  			}
307  			IScannerSessionHost scannerHost;
308  			Func<LuminanceSource, bool> handleImage;
309  			DateTime lastAnalysis = DateTime.MinValue;
310  			volatile bool working = false;
311  			volatile bool wasScanned = false;
312  			[Export("captureOutput:didDropSampleBuffer:fromConnection:")]
313  			public override void DidDropSampleBuffer(AVCaptureOutput captureOutput, CMSampleBuffer sampleBuffer, AVCaptureConnection connection)
314  			{
315  			}
316  			public CancellationTokenSource CancelTokenSource = new CancellationTokenSource();
317  			public override void DidOutputSampleBuffer(AVCaptureOutput captureOutput, CMSampleBuffer sampleBuffer, AVCaptureConnection connection)
318  			{
319  				var msSinceLastPreview = (DateTime.UtcNow - lastAnalysis).TotalMilliseconds;
320  				if (msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenAnalyzingFrames
321  					|| (wasScanned && msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenContinuousScans)
322  					|| working
323  					|| CancelTokenSource.IsCancellationRequested)
324  				{
325  					if (msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenAnalyzingFrames)
326  						Console.WriteLine("Too soon between frames");
327  					if (wasScanned && msSinceLastPreview < scannerHost.ScanningOptions.DelayBetweenContinuousScans)
328  						Console.WriteLine("Too soon since last scan");
329  					if (sampleBuffer != null)
330  					{
331  						sampleBuffer.Dispose();
332  						sampleBuffer = null;
333  					}
334  					return;
335  				}
336  				wasScanned = false;
337  				working = true;
338  				lastAnalysis = DateTime.UtcNow;
339  				try
340  				{
341  					using (var pixelBuffer = sampleBuffer.GetImageBuffer() as CVPixelBuffer)
342  					{
343  						pixelBuffer.Lock(CVPixelBufferLock.ReadOnly); 
344  						LuminanceSource luminanceSource;
345  						unsafe
346  						{
347  							var rawData = (byte*)pixelBuffer.BaseAddress.ToPointer();
348  							var rawDatalen = (int)(pixelBuffer.Height * pixelBuffer.Width * 4); 
349  							luminanceSource = new CVPixelBufferBGRA32LuminanceSource(rawData, rawDatalen, (int)pixelBuffer.Width, (int)pixelBuffer.Height);
350  						}
351  						if (handleImage(luminanceSource))
352  							wasScanned = true;
353  						pixelBuffer.Unlock(CVPixelBufferLock.ReadOnly);
354  					}
355  					sampleBuffer.Dispose();
356  					sampleBuffer = null;
357  				}
358  				catch (Exception e)
359  				{
360  					Console.WriteLine(e);
361  				}
362  				finally
363  				{
364  					working = false;
365  				}
366  			}
367  		}
368  		#region IZXingScanner implementation
369  		public void StartScanning(Action<Result> scanResultHandler, MobileBarcodeScanningOptions options = null)
370  		{
371  			if (!stopped)
372  				return;
373  			stopped = false;
374  			var perf = PerformanceCounter.Start();
375  			Setup();
376  			ScanningOptions = options ?? MobileBarcodeScanningOptions.Default;
377  			resultCallback = scanResultHandler;
378  			Console.WriteLine("StartScanning");
379  			InvokeOnMainThread(() =>
380  			{
381  				if (!SetupCaptureSession())
382  				{
383  					Console.WriteLine("Capture Session FAILED");
384  				}
385  				if (Runtime.Arch == Arch.SIMULATOR)
386  				{
387  					InsertSubview(new UIView(new CGRect(0, 0, this.Frame.Width, this.Frame.Height))
388  					{
389  						BackgroundColor = UIColor.LightGray,
390  						AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight
391  					}, 0);
392  				}
393  			});
394  			if (!analyzing)
395  				analyzing = true;
396  			PerformanceCounter.Stop(perf, "PERF: StartScanning() Took {0} ms.");
397  			OnScannerSetupComplete?.Invoke();
398  		}
399  		public void StopScanning()
400  		{
401  			if (overlayView != null)
402  			{
403  				if (overlayView is ZXingDefaultOverlayView)
404  					(overlayView as ZXingDefaultOverlayView).Destroy();
405  				overlayView = null;
406  			}
407  			if (stopped)
408  				return;
409  			Console.WriteLine("Stopping...");
410  			if (outputRecorder != null)
411  				outputRecorder.CancelTokenSource.Cancel();
412  			if (captureDevice != null && captureDevice.LockForConfiguration(out var err))
413  			{
414  				captureDevice.FocusMode = captureDeviceOriginalConfig.FocusMode;
415  				captureDevice.ExposureMode = captureDeviceOriginalConfig.ExposureMode;
416  				captureDevice.WhiteBalanceMode = captureDeviceOriginalConfig.WhiteBalanceMode;
417  				if (UIDevice.CurrentDevice.CheckSystemVersion(7, 0) && captureDevice.AutoFocusRangeRestrictionSupported)
418  					captureDevice.AutoFocusRangeRestriction = captureDeviceOriginalConfig.AutoFocusRangeRestriction;
419  				if (captureDevice.FocusPointOfInterestSupported)
420  					captureDevice.FocusPointOfInterest = captureDeviceOriginalConfig.FocusPointOfInterest;
421  				if (captureDevice.ExposurePointOfInterestSupported)
422  					captureDevice.ExposurePointOfInterest = captureDeviceOriginalConfig.ExposurePointOfInterest;
423  				if (captureDevice.HasFlash)
424  					captureDevice.FlashMode = captureDeviceOriginalConfig.FlashMode;
425  				if (captureDevice.HasTorch)
426  					captureDevice.TorchMode = captureDeviceOriginalConfig.TorchMode;
427  				captureDevice.UnlockForConfiguration();
428  			}
429  			try
430  			{
431  				while (session.Outputs.Length > 0)
432  					session.RemoveOutput(session.Outputs[0]);
433  			}
434  			catch { }
435  			try
436  			{
437  				while (session.Inputs.Length > 0)
438  					session.RemoveInput(session.Inputs[0]);
439  			}
440  			catch { }
441  			if (session.Running)
442  				session.StopRunning();
443  			stopped = true;
444  		}
445  		public void PauseAnalysis()
446  			=> analyzing = false;
447  		public void ResumeAnalysis()
448  			=> analyzing = true;
449  		public void Torch(bool on)
450  		{
451  			try
452  			{
453  				var device = captureDevice ?? AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
454  				if (device != null && (device.HasTorch || device.HasFlash))
455  				{
456  					device.LockForConfiguration(out var err);
457  					if (err != null)
458  					{
459  						if (on)
460  						{
461  							if (device.HasTorch)
462  								device.TorchMode = AVCaptureTorchMode.On;
463  							if (device.HasFlash)
464  								device.FlashMode = AVCaptureFlashMode.On;
465  						}
466  						else
467  						{
468  							if (device.HasTorch)
469  								device.TorchMode = AVCaptureTorchMode.Off;
470  							if (device.HasFlash)
471  								device.FlashMode = AVCaptureFlashMode.Off;
472  						}
473  					}
474  					try
475  					{
476  						device.UnlockForConfiguration();
477  					}
478  					catch { }
479  				}
480  				torch = on;
481  			}
482  			catch { }
483  		}
484  		public void ToggleTorch()
485  			=> Torch(!IsTorchOn);
486  		public void AutoFocus()
487  		{
488  		}
489  		public void AutoFocus(int x, int y)
490  		{
491  		}
492  		public string TopText { get; set; }
493  		public string BottomText { get; set; }
494  		public UIView CustomOverlayView { get; set; }
495  		public bool UseCustomOverlayView { get; set; }
496  		public bool IsAnalyzing { get { return analyzing; } }
497  		public bool IsTorchOn { get { return torch; } }
498  		bool? hasTorch = null;
499  		public bool HasTorch
500  		{
501  			get
502  			{
503  				if (hasTorch.HasValue)
504  					return hasTorch.Value;
505  				var device = captureDevice ?? AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
506  				hasTorch = device.HasFlash || device.HasTorch;
507  				return hasTorch.Value;
508  			}
509  		}
510  		#endregion
511  	}
512  	struct AVConfigs
513  	{
514  		public AVCaptureFocusMode FocusMode;
515  		public AVCaptureExposureMode ExposureMode;
516  		public AVCaptureWhiteBalanceMode WhiteBalanceMode;
517  		public AVCaptureAutoFocusRangeRestriction AutoFocusRangeRestriction;
518  		public CGPoint FocusPointOfInterest;
519  		public CGPoint ExposurePointOfInterest;
520  		public AVCaptureFlashMode FlashMode;
521  		public AVCaptureTorchMode TorchMode;
522  	}
523  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ZXing.Net.Mobile-MDEwOlJlcG9zaXRvcnk2MTYwNjcz-flat-ZXingScannerView.ios.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from ZXing.Net.Mobile-MDEwOlJlcG9zaXRvcnk2MTYwNjcz-flat-ZXingScannerView.ios.cs</div>
                </div>
                <div class="column column_space"><pre><code>272  					case UIInterfaceOrientation.Portrait:
273  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.Portrait;
274  						break;
275  					case UIInterfaceOrientation.PortraitUpsideDown:
</pre></code></div>
                <div class="column column_space"><pre><code>266  					case UIInterfaceOrientation.LandscapeLeft:
267  						previewLayer.Connection.VideoOrientation = AVCaptureVideoOrientation.LandscapeLeft;
268  						break;
269  					case UIInterfaceOrientation.LandscapeRight:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    