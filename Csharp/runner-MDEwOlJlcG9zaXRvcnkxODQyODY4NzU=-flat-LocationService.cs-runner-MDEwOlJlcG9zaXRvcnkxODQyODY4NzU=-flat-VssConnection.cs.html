
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationService.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Threading;
4  using System.Threading.Tasks;
5  using GitHub.Services.Common.Internal;
6  using GitHub.Services.Location;
7  namespace GitHub.Services.WebApi.Location
8  {
9      internal class LocationService : ILocationService
10      {
11          public virtual void Initialize(
12              VssConnection connection)
13          {
14              m_connection = connection;
15          }
16          public ILocationDataProvider GetLocationData(
17              Guid locationAreaIdentifier)
18          {
19              return GetLocationDataAsync(locationAreaIdentifier).SyncResult();
20          }
21          public async Task<ILocationDataProvider> GetLocationDataAsync(
22              Guid locationAreaIdentifier,
23              CancellationToken cancellationToken = default(CancellationToken))
24          {
25              if (locationAreaIdentifier == Guid.Empty ||
26                  locationAreaIdentifier == LocationServiceConstants.SelfReferenceIdentifier)
27              {
28                  return LocalDataProvider;
29              }
30              else
31              {
<span onclick='openModal()' class='match'>32                  Guid instanceId = await LocalDataProvider.GetInstanceIdAsync(cancellationToken).ConfigureAwait(false);
33                  Guid instanceType = await LocalDataProvider.GetInstanceTypeAsync(cancellationToken).ConfigureAwait(false);
</span>34                  if (locationAreaIdentifier == instanceId ||
35                      locationAreaIdentifier == instanceType ||
36                      instanceType == ServiceInstanceTypes.TFSOnPremises)
37                  {
38                      return LocalDataProvider;
39                  }
40                  else
41                  {
42                      return await ResolveLocationDataAsync(locationAreaIdentifier, cancellationToken).ConfigureAwait(false);
43                  }
44              }
45          }
46          private async Task<ILocationDataProvider> ResolveLocationDataAsync(
47              Guid locationAreaIdentifier,
48              CancellationToken cancellationToken = default(CancellationToken))
49          {
50              ILocationDataProvider locationData = null;
51              ProviderCache providerLookup = m_providerLookup;
52              if (providerLookup == null)
53              {
54                  providerLookup = new ProviderCache();
55                  String location = await LocalDataProvider.LocationForCurrentConnectionAsync(
56                      ServiceInterfaces.LocationService2,
57                      LocationServiceConstants.SelfReferenceIdentifier,
58                      cancellationToken).ConfigureAwait(false);
59                  if (location != null)
60                  {
61                      providerLookup.GetOrAdd(location, LocalDataProvider);
62                  }
63                  ProviderCache actualProvider = Interlocked.CompareExchange(ref m_providerLookup, providerLookup, null);
64                  if (actualProvider != null)
65                  {
66                      providerLookup = actualProvider;
67                  }
68              }
69              if (!providerLookup.TryGetValue(locationAreaIdentifier, out locationData))
70              {
71                  String location = await LocalDataProvider.LocationForCurrentConnectionAsync(
72                      ServiceInterfaces.LocationService2,
73                      locationAreaIdentifier,
74                      cancellationToken).ConfigureAwait(false);
75                  if (location == null &&
76                      locationAreaIdentifier != LocationServiceConstants.ApplicationIdentifier &&
77                      locationAreaIdentifier != LocationServiceConstants.RootIdentifier) 
78                  {
79                      ILocationDataProvider rootProvider = await ResolveLocationDataAsync(
80                          LocationServiceConstants.RootIdentifier,
81                          cancellationToken).ConfigureAwait(false);
82                      if (rootProvider != null &&
83                          !Object.ReferenceEquals(rootProvider, LocalDataProvider))
84                      {
85                          location = await rootProvider.LocationForCurrentConnectionAsync(
86                              ServiceInterfaces.LocationService2,
87                              locationAreaIdentifier,
88                              cancellationToken).ConfigureAwait(false);
89                      }
90                  }
91                  if (location != null)
92                  {
93                      if (!providerLookup.TryGetValue(location, out locationData))
94                      {
95                          locationData = await CreateDataProviderAsync(location, cancellationToken).ConfigureAwait(false);
96                          locationData = providerLookup.GetOrAdd(location, locationData);
97                      }
98                      providerLookup[locationAreaIdentifier] = locationData;
99                  }
100              }
101              return locationData;
102          }
103          public String GetLocationServiceUrl(
104              Guid locationAreaIdentifier)
105          {
106              return GetLocationServiceUrlAsync(locationAreaIdentifier, null).SyncResult();
107          }
108          public String GetLocationServiceUrl(
109              Guid locationAreaIdentifier,
110              String accessMappingMoniker = null)
111          {
112              return GetLocationServiceUrlAsync(locationAreaIdentifier, accessMappingMoniker).SyncResult();
113          }
114          public async Task<String> GetLocationServiceUrlAsync(
115              Guid locationAreaIdentifier,
116              String accessMappingMoniker = null,
117              CancellationToken cancellationToken = default(CancellationToken))
118          {
119              ILocationDataProvider locationData = await GetLocationDataAsync(locationAreaIdentifier, cancellationToken).ConfigureAwait(false);
120              if (locationData == null)
121              {
122                  return null;
123              }
124              AccessMapping accessMapping = await locationData.GetAccessMappingAsync(accessMappingMoniker ?? AccessMappingConstants.PublicAccessMappingMoniker).ConfigureAwait(false);
125              if (accessMapping == null)
126              {
127                  accessMapping = await locationData.GetClientAccessMappingAsync().ConfigureAwait(false);
128              }
129              return await locationData.LocationForAccessMappingAsync(
130                  ServiceInterfaces.LocationService2,
131                  LocationServiceConstants.SelfReferenceIdentifier,
132                  accessMapping,
133                  cancellationToken).ConfigureAwait(false);
134          }
135          protected virtual async Task<ILocationDataProvider> CreateDataProviderAsync(
136              String location,
137              CancellationToken cancellationToken = default(CancellationToken))
138          {
139              VssClientHttpRequestSettings locationServiceRequestSettings = VssClientHttpRequestSettings.Default.Clone();
140              locationServiceRequestSettings.SendTimeout = TimeSpan.FromSeconds(30); 
141              VssConnection connection = new VssConnection(new Uri(location), m_connection.Credentials, locationServiceRequestSettings);
142              IVssServerDataProvider dataProvider = connection.ServerDataProvider;
143              if (m_connection.ServerDataProvider.HasConnected)
144              {
145                  await dataProvider.ConnectAsync(ConnectOptions.None, cancellationToken).ConfigureAwait(false);
146              }
147              return dataProvider;
148          }
149          protected virtual ILocationDataProvider LocalDataProvider
150          {
151              get
152              {
153                  return m_connection.ServerDataProvider;
154              }
155          }
156          private VssConnection m_connection;
157          private ProviderCache m_providerLookup;
158          private class ProviderCache
159          {
160              public Boolean TryGetValue(Guid locationAreaIdentfier, out ILocationDataProvider provider)
161              {
162                  return m_guidCache.TryGetValue(locationAreaIdentfier, out provider);
163              }
164              public Boolean TryGetValue(String locationUrl, out ILocationDataProvider provider)
165              {
166                  return m_urlCache.TryGetValue(NormalizeUrl(locationUrl), out provider);
167              }
168              public ILocationDataProvider GetOrAdd(String locationUrl, ILocationDataProvider provider)
169              {
170                  return m_urlCache.GetOrAdd(NormalizeUrl(locationUrl), provider);
171              }
172              public ILocationDataProvider this[Guid locationAreaIdentifier]
173              {
174                  get { return m_guidCache[locationAreaIdentifier]; }
175                  set { m_guidCache[locationAreaIdentifier] = value; }
176              }
177              private static String NormalizeUrl(String locationUrl)
178              {
179                  return UriUtility.AppendSlashToPathIfNeeded(locationUrl);
180              }
181              private ConcurrentDictionary<Guid, ILocationDataProvider> m_guidCache = new ConcurrentDictionary<Guid, ILocationDataProvider>();
182              private ConcurrentDictionary<String, ILocationDataProvider> m_urlCache = new ConcurrentDictionary<String, ILocationDataProvider>(StringComparer.OrdinalIgnoreCase);
183          }
184      }
185  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssConnection.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.ComponentModel;
5  using System.Diagnostics;
6  using System.Diagnostics.CodeAnalysis;
7  using System.Linq;
8  using System.Net.Http;
9  using System.Reflection;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using GitHub.Services.Common;
13  using GitHub.Services.Location;
14  using GitHub.Services.WebApi.Internal;
15  using GitHub.Services.WebApi.Location;
16  using GitHub.Services.WebApi.Utilities;
17  namespace GitHub.Services.WebApi
18  {
19      public class VssConnection : IDisposable
20      {
21          public VssConnection(
22              Uri baseUrl,
23              VssCredentials credentials)
24              : this(baseUrl, credentials, VssClientHttpRequestSettings.Default.Clone())
25          {
26          }
27          public VssConnection(
28              Uri baseUrl,
29              VssCredentials credentials,
30              VssHttpRequestSettings settings)
31              : this(baseUrl, new VssHttpMessageHandler(credentials, settings), null)
32          {
33          }
34          public VssConnection(
35              Uri baseUrl,
36              VssHttpMessageHandler innerHandler,
37              IEnumerable<DelegatingHandler> delegatingHandlers)
38              : this(baseUrl, innerHandler, delegatingHandlers, true)
39          {
40          }
41          private VssConnection(
42              Uri baseUrl,
43              VssHttpMessageHandler innerHandler,
44              IEnumerable<DelegatingHandler> delegatingHandlers,
45              Boolean allowUnattributedClients)
46          {
47              ArgumentUtility.CheckForNull(baseUrl, "baseUrl");
48              ArgumentUtility.CheckForNull(innerHandler, "innerHandler");
49              m_delegatingHandlers = delegatingHandlers = delegatingHandlers ?? Enumerable.Empty<DelegatingHandler>();
50              m_baseUrl = baseUrl;
51              m_innerHandler = innerHandler;
52              m_allowUnattributedClients = allowUnattributedClients;
53              if (this.Settings.MaxRetryRequest > 0)
54              {
55                  delegatingHandlers = delegatingHandlers.Concat(new DelegatingHandler[] { new VssHttpRetryMessageHandler(this.Settings.MaxRetryRequest) });
56              }
57              if (delegatingHandlers.Any())
58              {
59                  m_pipeline = HttpClientFactory.CreatePipeline(m_innerHandler, delegatingHandlers);
60              }
61              else
62              {
63                  m_pipeline = m_innerHandler;
64              }
65              m_serverDataProvider = new VssServerDataProvider(this, m_pipeline, m_baseUrl.AbsoluteUri);
66              if (innerHandler.Credentials != null)
67              {
68                  if (innerHandler.Credentials.Federated != null)
69                  {
70                      innerHandler.Credentials.Federated.TokenStorageUrl = baseUrl;
71                  }
72              }
73          }
74          public Task ConnectAsync(
75              CancellationToken cancellationToken = default(CancellationToken))
76          {
77              return ConnectAsync(VssConnectMode.Automatic, null, cancellationToken);
78          }
79          public Task ConnectAsync(
80              VssConnectMode connectMode,
81              IDictionary<String, String> parameters,
82              CancellationToken cancellationToken = default(CancellationToken))
83          {
84              CheckForDisposed();
85              if (Credentials.Federated != null && Credentials.Federated.Prompt != null)
86              {
87                  if (parameters != null)
88                  {
89                      parameters = new Dictionary<String, String>(parameters);
90                  }
91                  else
92                  {
93                      parameters = new Dictionary<String, String>();
94                  }
95                  IVssCredentialPrompt promptToSetParametersOn;
96                  IVssCredentialPrompts credentialPrompts = Credentials.Federated.Prompt as IVssCredentialPrompts;
97                  if (credentialPrompts != null && credentialPrompts.FederatedPrompt != null)
98                  {
99                      promptToSetParametersOn = credentialPrompts.FederatedPrompt;
100                  }
101                  else
102                  {
103                      promptToSetParametersOn = Credentials.Federated.Prompt;
104                  }
105                  parameters[VssConnectionParameterKeys.VssConnectionMode] = connectMode.ToString();
106                  promptToSetParametersOn.Parameters = parameters;
107              }
108              return ServerDataProvider.ConnectAsync(ConnectOptions.None, cancellationToken);
109          }
110          public void Disconnect()
111          {
112              try
113              {
114                  if (HasAuthenticated)
115                  {
116                      m_innerHandler.Credentials.SignOut(Uri, null, null);
117                  }
118              }
119              finally
120              {
121                  ServerDataProvider.DisconnectAsync().SyncResult();
122              }
123          }
124          public T GetService<T>() where T : IVssClientService
125          {
126              return (T)GetClientServiceImplAsync(typeof(T), Guid.Empty, GetServiceInstanceAsync).SyncResult();
127          }
128          public async Task<T> GetServiceAsync<T>(CancellationToken cancellationToken = default(CancellationToken)) where T : IVssClientService
129          {
130              return (T)await GetClientServiceImplAsync(typeof(T), Guid.Empty, GetServiceInstanceAsync, cancellationToken).ConfigureAwait(false);
131          }
132          public T GetClient<T>() where T : VssHttpClientBase
133          {
134              return GetClientAsync<T>().SyncResult();
135          }
136          public async Task<T> GetClientAsync<T>(CancellationToken cancellationToken = default(CancellationToken)) where T : VssHttpClientBase
137          {
138              CheckForDisposed();
139              Type clientType = typeof(T);
140              Guid serviceIdentifier = GetServiceIdentifier(clientType);
141              if (serviceIdentifier == Guid.Empty && !m_allowUnattributedClients)
142              {
143                  throw new CannotGetUnattributedClientException(clientType);
144              }
145              return (T)await GetClientServiceImplAsync(typeof(T), serviceIdentifier, GetClientInstanceAsync, cancellationToken).ConfigureAwait(false);
146          }
147          private async Task<Object> GetClientServiceImplAsync(
148              Type requestedType,
149              Guid serviceIdentifier,
150              Func<Type, Guid, CancellationToken, Task<Object>> getInstanceAsync,
151              CancellationToken cancellationToken = default(CancellationToken))
152          {
153              CheckForDisposed();
154              Object requestedObject = null;
155              Type managedType = GetExtensibleType(requestedType);
156              ClientCacheKey cacheKey = new ClientCacheKey(managedType, serviceIdentifier);
157              if (!m_cachedTypes.TryGetValue(cacheKey, out requestedObject))
158              {
159                  AsyncLock typeLock = m_loadingTypes.GetOrAdd(cacheKey, (t) => new AsyncLock());
160                  using (await typeLock.LockAsync(cancellationToken).ConfigureAwait(false))
161                  {
162                      if (!m_cachedTypes.TryGetValue(cacheKey, out requestedObject))
163                      {
164                          requestedObject = await getInstanceAsync(managedType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
165                          m_cachedTypes[cacheKey] = requestedObject;
166                          AsyncLock removed;
167                          m_loadingTypes.TryRemove(cacheKey, out removed);
168                      }
169                  }
170              }
171              return requestedObject;
172          }
173          private Task<Object> GetClientInstanceAsync(
174              Type managedType,
175              Guid serviceIdentifier,
176              CancellationToken cancellationToken)
177          {
178              return GetClientInstanceAsync(managedType, serviceIdentifier, cancellationToken, null, null);
179          }
180          private async Task<Object> GetClientInstanceAsync(
181              Type managedType,
182              Guid serviceIdentifier,
183              CancellationToken cancellationToken,
184              VssHttpRequestSettings settings,
185              DelegatingHandler[] handlers)
186          {
187              CheckForDisposed();
188              ILocationService locationService = await GetServiceAsync<ILocationService>(cancellationToken).ConfigureAwait(false);
189              ILocationDataProvider locationData = await locationService.GetLocationDataAsync(serviceIdentifier, cancellationToken).ConfigureAwait(false);
190              if (locationData == null)
191              {
192                  throw new VssServiceException(WebApiResources.ServerDataProviderNotFound(serviceIdentifier));
193              }
194              String serviceLocationString = await locationData.LocationForCurrentConnectionAsync(
195                  ServiceInterfaces.LocationService2,
196                  LocationServiceConstants.SelfReferenceIdentifier,
197                  cancellationToken).ConfigureAwait(false);
198              Uri clientBaseUri = new Uri(serviceLocationString);
199              VssHttpClientBase toReturn = null;
200              if (settings != null)
201              {
202                  toReturn = (VssHttpClientBase)Activator.CreateInstance(managedType, clientBaseUri, Credentials, settings, handlers);
203              }
204              else
205              {
206                  toReturn = (VssHttpClientBase)Activator.CreateInstance(managedType, clientBaseUri, m_pipeline, false &bsol;* disposeHandler */);
207              }
<span onclick='openModal()' class='match'>208              ApiResourceLocationCollection resourceLocations = await locationData.GetResourceLocationsAsync(cancellationToken).ConfigureAwait(false);
209              toReturn.SetResourceLocations(resourceLocations);
</span>210              return toReturn;
211          }
212          private Guid GetServiceIdentifier(
213              Type requestedType)
214          {
215              ResourceAreaAttribute[] attributes = (ResourceAreaAttribute[])requestedType.GetTypeInfo().GetCustomAttributes<ResourceAreaAttribute>(true);
216              if (attributes.Length > 0)
217              {
218                  return attributes[0].AreaId;
219              }
220              else
221              {
222                  return Guid.Empty;
223              }
224          }
225          private Task<Object> GetServiceInstanceAsync(
226              Type managedType,
227              Guid serviceIdentifier,
228              CancellationToken cancellationToken)
229          {
230              CheckForDisposed();
231              IVssClientService clientService;
232              try
233              {
234                  clientService = (IVssClientService)Activator.CreateInstance(managedType);
235              }
236              catch (MissingMemberException ex)
237              {
238                  throw new ArgumentException(WebApiResources.GetServiceArgumentError(managedType), ex);
239              }
240              clientService.Initialize(this);
241              return Task.FromResult<Object>(clientService);
242          }
243          private Type GetExtensibleType(Type managedType)
244          {
245              if (managedType.GetTypeInfo().IsAbstract || managedType.GetTypeInfo().IsInterface)
246              {
247                  Type extensibleType = null;
248                  if (!m_extensibleServiceTypes.TryGetValue(managedType.Name, out extensibleType))
249                  {
250                      VssClientServiceImplementationAttribute[] attributes = (VssClientServiceImplementationAttribute[])managedType.GetTypeInfo().GetCustomAttributes<VssClientServiceImplementationAttribute>(true);
251                      if (attributes.Length > 0)
252                      {
253                          if (attributes[0].Type != null)
254                          {
255                              extensibleType = attributes[0].Type;
256                              m_extensibleServiceTypes[managedType.Name] = extensibleType;
257                          }
258                          else if (!String.IsNullOrEmpty(attributes[0].TypeName))
259                          {
260                              extensibleType = Type.GetType(attributes[0].TypeName);
261                              if (extensibleType != null)
262                              {
263                                  m_extensibleServiceTypes[managedType.Name] = extensibleType;
264                              }
265                              else
266                              {
267                                  Debug.Assert(false, "VssConnection: Could not load type from type name: " + attributes[0].TypeName);
268                              }
269                          }
270                      }
271                  }
272                  if (extensibleType == null)
273                  {
274                      throw new ExtensibleServiceTypeNotRegisteredException(managedType);
275                  }
276                  if (!managedType.GetTypeInfo().IsAssignableFrom(extensibleType.GetTypeInfo()))
277                  {
278                      throw new ExtensibleServiceTypeNotValidException(managedType, extensibleType);
279                  }
280                  return extensibleType;
281              }
282              else
283              {
284                  return managedType;
285              }
286          }
287          internal void RegisterExtensibleType(
288              String typeName,
289              Type type)
290          {
291              ArgumentUtility.CheckStringForNullOrEmpty(typeName, "typeName");
292              ArgumentUtility.CheckForNull(type, "type");
293              m_extensibleServiceTypes[typeName] = type;
294          }
295          private bool m_isDisposed = false;
296          private object m_disposeLock = new object();
297          public void Dispose()
298          {
299              if (!m_isDisposed)
300              {
301                  lock (m_disposeLock)
302                  {
303                      if (!m_isDisposed)
304                      {
305                          m_isDisposed = true;
306                          foreach (var cachedType in m_cachedTypes.Values.Where(v => v is IDisposable).Select(v => v as IDisposable))
307                          {
308                              cachedType.Dispose();
309                          }
310                          m_cachedTypes.Clear();
311                          Disconnect();
312                          if (m_parentConnection != null)
313                          {
314                              m_parentConnection.Dispose();
315                              m_parentConnection = null;
316                          }
317                      }
318                  }
319              }
320          }
321          private void CheckForDisposed()
322          {
323              if (m_isDisposed)
324              {
325                  throw new ObjectDisposedException(this.GetType().Name);
326              }
327          }
328          public Uri Uri
329          {
330              get
331              {
332                  return m_baseUrl;
333              }
334          }
335          public VssHttpMessageHandler InnerHandler
336          {
337              get
338              {
339                  return m_innerHandler;
340              }
341          }
342          public IEnumerable<DelegatingHandler> DelegatingHandlers
343          {
344              get
345              {
346                  return m_delegatingHandlers;
347              }
348          }
349          public VssCredentials Credentials
350          {
351              get
352              {
353                  return m_innerHandler.Credentials;
354              }
355          }
356          public VssClientHttpRequestSettings Settings
357          {
358              get
359              {
360                  return (VssClientHttpRequestSettings)m_innerHandler.Settings;
361              }
362          }
363          public Guid ServerId
364          {
365              get
366              {
367                  return ServerDataProvider.GetInstanceIdAsync().SyncResult();
368              }
369          }
370          public Guid ServerType
371          {
372              get
373              {
374                  return ServerDataProvider.GetInstanceTypeAsync().SyncResult();
375              }
376          }
377          public Identity.Identity AuthorizedIdentity
378          {
379              get
380              {
381                  return ServerDataProvider.GetAuthorizedIdentityAsync().SyncResult();
382              }
383          }
384          [EditorBrowsable(EditorBrowsableState.Never)]
385          public Identity.Identity AuthenticatedIdentity
386          {
387              get
388              {
389                  return ServerDataProvider.GetAuthenticatedIdentityAsync().SyncResult();
390              }
391          }
392          public Boolean HasAuthenticated
393          {
394              get
395              {
396                  return ServerDataProvider.HasConnected;
397              }
398          }
399          public VssConnection ParentConnection
400          {
401              get
402              {
403                  CheckForDisposed();
404                  if (m_parentConnection == null)
405                  {
406                      lock (m_parentConnectionLock)
407                      {
408                          ILocationService locationService = GetService<ILocationService>();
409                          ILocationDataProvider locationData = locationService.GetLocationData(Guid.Empty);
410                          String applicationLocation = locationData.LocationForCurrentConnection(
411                              ServiceInterfaces.LocationService2,
412                              LocationServiceConstants.ApplicationIdentifier);
413                          if (String.IsNullOrEmpty(applicationLocation))
414                          {
415                              throw new VssServiceException(WebApiResources.ServerDataProviderNotFound(LocationServiceConstants.ApplicationIdentifier));
416                          }
417                          m_parentConnection = new VssConnection(
418                              new Uri(applicationLocation),
419                              new VssHttpMessageHandler(Credentials, VssClientHttpRequestSettings.Default.Clone()),
420                              null,
421                              allowUnattributedClients: false);
422                      }
423                  }
424                  return m_parentConnection;
425              }
426          }
427          internal IVssServerDataProvider ServerDataProvider
428          {
429              get
430              {
431                  return m_serverDataProvider;
432              }
433              set
434              {
435                  m_serverDataProvider = value;
436              }
437          }
438          private IVssServerDataProvider m_serverDataProvider;
439          private VssConnection m_parentConnection;
440          private Object m_parentConnectionLock = new Object();
441          private readonly Uri m_baseUrl;
442          private readonly HttpMessageHandler m_pipeline;
443          private readonly VssHttpMessageHandler m_innerHandler;
444          private readonly IEnumerable<DelegatingHandler> m_delegatingHandlers;
445          private readonly Boolean m_allowUnattributedClients;
446          private readonly ConcurrentDictionary<ClientCacheKey, AsyncLock> m_loadingTypes = new ConcurrentDictionary<ClientCacheKey, AsyncLock>(ClientCacheKey.Comparer);
447          private readonly ConcurrentDictionary<ClientCacheKey, Object> m_cachedTypes = new ConcurrentDictionary<ClientCacheKey, Object>(ClientCacheKey.Comparer);
448          private readonly ConcurrentDictionary<String, Type> m_extensibleServiceTypes = new ConcurrentDictionary<String, Type>();
449          private struct ClientCacheKey
450          {
451              public ClientCacheKey(Type type, Guid serviceIdentifier)
452              {
453                  this.Type = type;
454                  this.ServiceIdentifier = serviceIdentifier;
455              }
456              public readonly Type Type;
457              public readonly Guid ServiceIdentifier;
458              public static readonly IEqualityComparer<ClientCacheKey> Comparer = new ClientCacheKeyComparer();
459              private class ClientCacheKeyComparer : IEqualityComparer<ClientCacheKey>
460              {
461                  public bool Equals(ClientCacheKey x, ClientCacheKey y)
462                  {
463                      return x.Type.Equals(y.Type) &&
464                             x.ServiceIdentifier.Equals(y.ServiceIdentifier);
465                  }
466                  public int GetHashCode(ClientCacheKey obj)
467                  {
468                      return obj.Type.GetHashCode() ^ obj.ServiceIdentifier.GetHashCode();
469                  }
470              }
471          }
472      }
473      public interface IVssClientService
474      {
475          void Initialize(VssConnection connection);
476      }
477      [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
478      [SuppressMessage("Microsoft.Design", "CA1019:DefineAccessorsForAttributeArguments", Justification = "FxCop can't tell that we have an accessor.")]
479      public sealed class VssClientServiceImplementationAttribute : Attribute
480      {
481          public VssClientServiceImplementationAttribute(Type type)
482          {
483              this.Type = type;
484          }
485          public VssClientServiceImplementationAttribute(String typeName)
486          {
487              this.TypeName = typeName;
488          }
489          public Type Type
490          {
491              get;
492              set;
493          }
494          public String TypeName
495          {
496              get;
497              set;
498          }
499      }
500      [ExceptionMapping("0.0", "3.0", "ExtensibleServiceTypeNotRegisteredException", "GitHub.Services.Client.ExtensibleServiceTypeNotRegisteredException, GitHub.Services.Client, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
501      public class ExtensibleServiceTypeNotRegisteredException : VssException
502      {
503          public ExtensibleServiceTypeNotRegisteredException(Type managedType)
504              : base(WebApiResources.ExtensibleServiceTypeNotRegistered(managedType.Name))
505          {
506          }
507          public ExtensibleServiceTypeNotRegisteredException(String message, Exception innerException)
508              : base(message, innerException)
509          {
510          }
511      }
512      [ExceptionMapping("0.0", "3.0", "ExtensibleServiceTypeNotValidException", "GitHub.Services.Client.ExtensibleServiceTypeNotValidException, GitHub.Services.Client, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
513      public class ExtensibleServiceTypeNotValidException : VssException
514      {
515          public ExtensibleServiceTypeNotValidException(Type managedType, Type extensibleType)
516              : base(WebApiResources.ExtensibleServiceTypeNotValid(managedType.Name, extensibleType.Name))
517          {
518          }
519          public ExtensibleServiceTypeNotValidException(String message, Exception innerException)
520              : base(message, innerException)
521          {
522          }
523      }
524      public class CannotGetUnattributedClientException : VssException
525      {
526          public CannotGetUnattributedClientException(Type clientType)
527              : base(WebApiResources.CannotGetUnattributedClient(clientType.Name))
528          {
529          }
530          public CannotGetUnattributedClientException(String message, Exception innerException)
531              : base(message, innerException)
532          {
533          }
534      }
535  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationService.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssConnection.cs</div>
                </div>
                <div class="column column_space"><pre><code>32                  Guid instanceId = await LocalDataProvider.GetInstanceIdAsync(cancellationToken).ConfigureAwait(false);
33                  Guid instanceType = await LocalDataProvider.GetInstanceTypeAsync(cancellationToken).ConfigureAwait(false);
</pre></code></div>
                <div class="column column_space"><pre><code>208              ApiResourceLocationCollection resourceLocations = await locationData.GetResourceLocationsAsync(cancellationToken).ConfigureAwait(false);
209              toReturn.SetResourceLocations(resourceLocations);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    