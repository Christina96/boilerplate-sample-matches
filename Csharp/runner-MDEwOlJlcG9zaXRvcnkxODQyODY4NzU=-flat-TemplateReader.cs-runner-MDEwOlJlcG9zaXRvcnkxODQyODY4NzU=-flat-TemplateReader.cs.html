
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateReader.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Globalization;
4  using System.Linq;
5  using System.Text;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.DistributedTask.ObjectTemplating.Tokens;
8  using GitHub.DistributedTask.ObjectTemplating.Schema;
9  namespace GitHub.DistributedTask.ObjectTemplating
10  {
11      internal sealed class TemplateReader
12      {
13          private TemplateReader(
14              TemplateContext context,
15              TemplateSchema schema,
16              IObjectReader objectReader,
17              Int32? fileId)
18          {
19              m_context = context;
20              m_schema = schema;
21              m_memory = context.Memory;
22              m_objectReader = objectReader;
23              m_fileId = fileId;
24          }
25          internal static TemplateToken Read(
26              TemplateContext context,
27              String type,
28              IObjectReader objectReader,
29              Int32? fileId,
30              out Int32 bytes)
31          {
32              return Read(context, type, objectReader, fileId, context.Schema, out bytes);
33          }
34          internal static TemplateToken Read(
35              TemplateContext context,
36              String type,
37              IObjectReader objectReader,
38              Int32? fileId,
39              TemplateSchema schema,
40              out Int32 bytes)
41          {
42              TemplateToken result = null;
43              var reader = new TemplateReader(context, schema, objectReader, fileId);
44              var originalBytes = context.Memory.CurrentBytes;
45              try
46              {
47                  objectReader.ValidateStart();
48                  var definition = new DefinitionInfo(schema, type);
49                  result = reader.ReadValue(definition);
50                  objectReader.ValidateEnd();
51              }
52              catch (Exception ex)
53              {
54                  context.Error(fileId, null, null, ex);
55              }
56              finally
57              {
58                  bytes = context.Memory.CurrentBytes - originalBytes;
59              }
60              return result;
61          }
62          private TemplateToken ReadValue(DefinitionInfo definition)
63          {
64              m_memory.IncrementEvents();
65              if (m_objectReader.AllowLiteral(out LiteralToken literal))
66              {
67                  var scalar = ParseScalar(literal, definition.AllowedContext);
68                  Validate(ref scalar, definition);
69                  m_memory.AddBytes(scalar);
70                  return scalar;
71              }
72              if (m_objectReader.AllowSequenceStart(out SequenceToken sequence))
73              {
74                  m_memory.IncrementDepth();
75                  m_memory.AddBytes(sequence);
76                  var sequenceDefinition = definition.Get<SequenceDefinition>().FirstOrDefault();
77                  if (sequenceDefinition != null)
78                  {
79                      var itemDefinition = new DefinitionInfo(definition, sequenceDefinition.ItemType);
80                      while (!m_objectReader.AllowSequenceEnd())
81                      {
82                          var item = ReadValue(itemDefinition);
83                          sequence.Add(item);
84                      }
85                  }
86                  else
87                  {
88                      m_context.Error(sequence, TemplateStrings.UnexpectedSequenceStart());
89                      while (!m_objectReader.AllowSequenceEnd())
90                      {
91                          SkipValue();
92                      }
93                  }
94                  m_memory.DecrementDepth();
95                  return sequence;
96              }
97              if (m_objectReader.AllowMappingStart(out MappingToken mapping))
98              {
99                  m_memory.IncrementDepth();
100                  m_memory.AddBytes(mapping);
101                  var mappingDefinitions = definition.Get<MappingDefinition>().ToList();
102                  if (mappingDefinitions.Count > 0)
103                  {
104                      if (mappingDefinitions.Count > 1 ||
105                          m_schema.HasProperties(mappingDefinitions[0]) ||
106                          String.IsNullOrEmpty(mappingDefinitions[0].LooseKeyType))
107                      {
108                          HandleMappingWithWellKnownProperties(definition, mappingDefinitions, mapping);
109                      }
110                      else
111                      {
112                          var keyDefinition = new DefinitionInfo(definition, mappingDefinitions[0].LooseKeyType);
113                          var valueDefinition = new DefinitionInfo(definition, mappingDefinitions[0].LooseValueType);
114                          HandleMappingWithAllLooseProperties(definition, keyDefinition, valueDefinition, mapping);
115                      }
116                  }
117                  else
118                  {
119                      m_context.Error(mapping, TemplateStrings.UnexpectedMappingStart());
120                      while (!m_objectReader.AllowMappingEnd())
121                      {
122                          SkipValue();
123                          SkipValue();
124                      }
125                  }
126                  m_memory.DecrementDepth();
127                  return mapping;
128              }
129              throw new InvalidOperationException(TemplateStrings.ExpectedScalarSequenceOrMapping());
130          }
131          private void HandleMappingWithWellKnownProperties(
132              DefinitionInfo definition,
133              List<MappingDefinition> mappingDefinitions,
134              MappingToken mapping)
135          {
136              String looseKeyType = null;
137              String looseValueType = null;
138              DefinitionInfo? looseKeyDefinition = null;
139              DefinitionInfo? looseValueDefinition = null;
140              if (!String.IsNullOrEmpty(mappingDefinitions[0].LooseKeyType))
141              {
142                  looseKeyType = mappingDefinitions[0].LooseKeyType;
143                  looseValueType = mappingDefinitions[0].LooseValueType;
144              }
145              var keys = new HashSet<String>(StringComparer.OrdinalIgnoreCase);
146              var hasExpressionKey = false;
147              while (m_objectReader.AllowLiteral(out LiteralToken rawLiteral))
148              {
149                  var nextKeyScalar = ParseScalar(rawLiteral, definition.AllowedContext);
150                  if (nextKeyScalar is ExpressionToken)
151                  {
152                      hasExpressionKey = true;
153                      if (definition.AllowedContext.Length > 0)
154                      {
155                          m_memory.AddBytes(nextKeyScalar);
156                          var anyDefinition = new DefinitionInfo(definition, TemplateConstants.Any);
157                          mapping.Add(nextKeyScalar, ReadValue(anyDefinition));
158                      }
159                      else
160                      {
161                          m_context.Error(nextKeyScalar, TemplateStrings.ExpressionNotAllowed());
162                          SkipValue();
163                      }
164                      continue;
165                  }
166                  if (!(nextKeyScalar is StringToken nextKey))
167                  {
168                      nextKey = new StringToken(nextKeyScalar.FileId, nextKeyScalar.Line, nextKeyScalar.Column, nextKeyScalar.ToString());
169                  }
170                  if (!keys.Add(nextKey.Value))
171                  {
172                      m_context.Error(nextKey, TemplateStrings.ValueAlreadyDefined(nextKey.Value));
173                      SkipValue();
174                      continue;
175                  }
176                  if (m_schema.TryMatchKey(mappingDefinitions, nextKey.Value, out String nextValueType))
177                  {
178                      m_memory.AddBytes(nextKey);
179                      var nextValueDefinition = new DefinitionInfo(definition, nextValueType);
180                      var nextValue = ReadValue(nextValueDefinition);
181                      mapping.Add(nextKey, nextValue);
182                      continue;
183                  }
184                  if (looseKeyType != null)
185                  {
186                      if (looseKeyDefinition == null)
187                      {
188                          looseKeyDefinition = new DefinitionInfo(definition, looseKeyType);
189                          looseValueDefinition = new DefinitionInfo(definition, looseValueType);
190                      }
191                      Validate(nextKey, looseKeyDefinition.Value);
192                      m_memory.AddBytes(nextKey);
193                      var nextValue = ReadValue(looseValueDefinition.Value);
194                      mapping.Add(nextKey, nextValue);
195                      continue;
196                  }
197                  m_context.Error(nextKey, TemplateStrings.UnexpectedValue(nextKey.Value));
198                  SkipValue();
199              }
200              if (mappingDefinitions.Count > 1)
201              {
202                  var hitCount = new Dictionary<String, Int32>();
203                  foreach (MappingDefinition mapdef in mappingDefinitions)
204                  {
205                      foreach (String key in mapdef.Properties.Keys)
206                      {
207                          if (!hitCount.TryGetValue(key, out Int32 value))
208                          {
209                              hitCount.Add(key, 1);
210                          }
211                          else
212                          {
213                              hitCount[key] = value + 1;
214                          }
215                      }
216                  }
217                  List<String> nonDuplicates = new List<String>();
218                  foreach (String key in hitCount.Keys)
219                  {
220                      if (hitCount[key] == 1)
221                      {
222                          nonDuplicates.Add(key);
223                      }
224                  }
225                  nonDuplicates.Sort();
226                  String listToDeDuplicate = String.Join(", ", nonDuplicates);
227                  m_context.Error(mapping, TemplateStrings.UnableToDetermineOneOf(listToDeDuplicate));
228              }
229              else if (mappingDefinitions.Count == 1 && !hasExpressionKey)
230              {
231                  foreach (var property in mappingDefinitions[0].Properties)
232                  {
233                      if (property.Value.Required)
234                      {
235                          if (!keys.Contains(property.Key))
236                          {
237                              m_context.Error(mapping, $"Required property is missing: {property.Key}");
238                          }
239                      }
240                  }
241              }
242              ExpectMappingEnd();
243          }
244          private void HandleMappingWithAllLooseProperties(
245              DefinitionInfo mappingDefinition,
246              DefinitionInfo keyDefinition,
247              DefinitionInfo valueDefinition,
248              MappingToken mapping)
249          {
250              TemplateToken nextValue;
251              var keys = new HashSet<String>(StringComparer.OrdinalIgnoreCase);
252              while (m_objectReader.AllowLiteral(out LiteralToken rawLiteral))
253              {
254                  var nextKeyScalar = ParseScalar(rawLiteral, mappingDefinition.AllowedContext);
255                  if (nextKeyScalar is ExpressionToken)
256                  {
257                      if (mappingDefinition.AllowedContext.Length > 0)
258                      {
259                          m_memory.AddBytes(nextKeyScalar);
260                          nextValue = ReadValue(valueDefinition);
261                          mapping.Add(nextKeyScalar, nextValue);
262                      }
263                      else
264                      {
265                          m_context.Error(nextKeyScalar, TemplateStrings.ExpressionNotAllowed());
266                          SkipValue();
267                      }
268                      continue;
269                  }
270                  if (!(nextKeyScalar is StringToken nextKey))
271                  {
272                      nextKey = new StringToken(nextKeyScalar.FileId, nextKeyScalar.Line, nextKeyScalar.Column, nextKeyScalar.ToString());
273                  }
274                  if (!keys.Add(nextKey.Value))
275                  {
276                      m_context.Error(nextKey, TemplateStrings.ValueAlreadyDefined(nextKey.Value));
277                      SkipValue();
278                      continue;
279                  }
280                  Validate(nextKey, keyDefinition);
281                  m_memory.AddBytes(nextKey);
282                  nextValue = ReadValue(valueDefinition);
283                  mapping.Add(nextKey, nextValue);
284              }
285              ExpectMappingEnd();
286          }
287          private void ExpectMappingEnd()
288          {
289              if (!m_objectReader.AllowMappingEnd())
290              {
291                  throw new Exception("Expected mapping end"); 
292              }
293          }
294          private void SkipValue(Boolean error = false)
295          {
296              m_memory.IncrementEvents();
297              if (m_objectReader.AllowLiteral(out LiteralToken literal))
298              {
299                  if (error)
300                  {
301                      m_context.Error(literal, TemplateStrings.UnexpectedValue(literal));
302                  }
303                  return;
304              }
305              if (m_objectReader.AllowSequenceStart(out SequenceToken sequence))
306              {
307                  m_memory.IncrementDepth();
308                  if (error)
309                  {
310                      m_context.Error(sequence, TemplateStrings.UnexpectedSequenceStart());
311                  }
312                  while (!m_objectReader.AllowSequenceEnd())
313                  {
314                      SkipValue();
315                  }
316                  m_memory.DecrementDepth();
317                  return;
318              }
319              if (m_objectReader.AllowMappingStart(out MappingToken mapping))
320              {
321                  m_memory.IncrementDepth();
322                  if (error)
323                  {
324                      m_context.Error(mapping, TemplateStrings.UnexpectedMappingStart());
325                  }
<span onclick='openModal()' class='match'>326                  while (!m_objectReader.AllowMappingEnd())
327                  {
328                      SkipValue();
329                      SkipValue();
</span>330                  }
331                  m_memory.DecrementDepth();
332                  return;
333              }
334              throw new InvalidOperationException(TemplateStrings.ExpectedScalarSequenceOrMapping());
335          }
336          private void Validate(
337              StringToken stringToken,
338              DefinitionInfo definition)
339          {
340              var scalar = stringToken as ScalarToken;
341              Validate(ref scalar, definition);
342          }
343          private void Validate(
344              ref ScalarToken scalar,
345              DefinitionInfo definition)
346          {
347              switch (scalar.Type)
348              {
349                  case TokenType.Null:
350                  case TokenType.Boolean:
351                  case TokenType.Number:
352                  case TokenType.String:
353                      var literal = scalar as LiteralToken;
354                      if (definition.Get<ScalarDefinition>().Any(x => x.IsMatch(literal)))
355                      {
356                          return;
357                      }
358                      if (literal.Type != TokenType.String)
359                      {
360                          literal = new StringToken(literal.FileId, literal.Line, literal.Column, literal.ToString());
361                          if (definition.Get<StringDefinition>().Any(x => x.IsMatch(literal)))
362                          {
363                              scalar = literal;
364                              return;
365                          }
366                      }
367                      m_context.Error(literal, TemplateStrings.UnexpectedValue(literal));
368                      break;
369                  case TokenType.BasicExpression:
370                      if (definition.AllowedContext.Length == 0)
371                      {
372                          m_context.Error(scalar, TemplateStrings.ExpressionNotAllowed());
373                      }
374                      break;
375                  default:
376                      m_context.Error(scalar, TemplateStrings.UnexpectedValue(scalar));
377                      break;
378              }
379          }
380          private ScalarToken ParseScalar(
381              LiteralToken token,
382              String[] allowedContext)
383          {
384              if (token.Type != TokenType.String)
385              {
386                  return token;
387              }
388              var raw = token.ToString();
389              Int32 startExpression;
390              if (String.IsNullOrEmpty(raw) ||
391                  (startExpression = raw.IndexOf(TemplateConstants.OpenExpression)) < 0) 
392              {
393                  return token;
394              }
395              var segments = new List<ScalarToken>();
396              var i = 0;
397              while (i < raw.Length)
398              {
399                  if (i == startExpression)
400                  {
401                      startExpression = i;
402                      var endExpression = -1;
403                      var inString = false;
404                      for (i += TemplateConstants.OpenExpression.Length; i < raw.Length; i++)
405                      {
406                          if (raw[i] == '\'')
407                          {
408                              inString = !inString; 
409                          }
410                          else if (!inString && raw[i] == '}' && raw[i - 1] == '}')
411                          {
412                              endExpression = i;
413                              i++;
414                              break;
415                          }
416                      }
417                      if (endExpression < startExpression)
418                      {
419                          m_context.Error(token, TemplateStrings.ExpressionNotClosed());
420                          return token;
421                      }
422                      var rawExpression = raw.Substring(
423                          startExpression + TemplateConstants.OpenExpression.Length,
424                          endExpression - startExpression + 1 - TemplateConstants.OpenExpression.Length - TemplateConstants.CloseExpression.Length);
425                      var expression = ParseExpression(token.Line, token.Column, rawExpression, allowedContext, out Exception ex);
426                      if (ex != null)
427                      {
428                          m_context.Error(token, ex);
429                          return token;
430                      }
431                      if (!String.IsNullOrEmpty(expression.Directive) &&
432                          ((startExpression != 0) || (i < raw.Length)))
433                      {
434                          m_context.Error(token, TemplateStrings.DirectiveNotAllowedInline(expression.Directive));
435                          return token;
436                      }
437                      segments.Add(expression);
438                      startExpression = raw.IndexOf(TemplateConstants.OpenExpression, i);
439                  }
440                  else if (i < startExpression)
441                  {
442                      AddString(segments, token.Line, token.Column, raw.Substring(i, startExpression - i));
443                      i = startExpression;
444                  }
445                  else
446                  {
447                      AddString(segments, token.Line, token.Column, raw.Substring(i));
448                      break;
449                  }
450              }
451              if (segments.Count == 1 &&
452                  segments[0] is BasicExpressionToken basicExpression &&
453                  IsExpressionString(basicExpression.Expression, out String str))
454              {
455                  return new StringToken(m_fileId, token.Line, token.Column, str);
456              }
457              if (segments.Count == 1)
458              {
459                  return segments[0];
460              }
461              var format = new StringBuilder();
462              var args = new StringBuilder();
463              var argIndex = 0;
464              foreach (var segment in segments)
465              {
466                  if (segment is StringToken literal)
467                  {
468                      var text = ExpressionUtility.StringEscape(literal.Value) 
469                          .Replace("{", "{{") 
470                          .Replace("}", "}}");
471                      format.Append(text);
472                  }
473                  else
474                  {
475                      format.Append("{" + argIndex.ToString(CultureInfo.InvariantCulture) + "}"); 
476                      argIndex++;
477                      var expression = segment as BasicExpressionToken;
478                      args.Append(", ");
479                      args.Append(expression.Expression);
480                  }
481              }
482              return new BasicExpressionToken(m_fileId, token.Line, token.Column, $"format('{format}'{args})");
483          }
484          private ExpressionToken ParseExpression(
485              Int32? line,
486              Int32? column,
487              String value,
488              String[] allowedContext,
489              out Exception ex)
490          {
491              var trimmed = value.Trim();
492              if (String.IsNullOrEmpty(trimmed))
493              {
494                  ex = new ArgumentException(TemplateStrings.ExpectedExpression());
495                  return null;
496              }
497              List<String> parameters;
498              if (MatchesDirective(trimmed, TemplateConstants.InsertDirective, 0, out parameters, out ex))
499              {
500                  return new InsertExpressionToken(m_fileId, line, column);
501              }
502              else if (ex != null)
503              {
504                  return null;
505              }
506              if (!ExpressionToken.IsValidExpression(trimmed, allowedContext, out ex))
507              {
508                  return null;
509              }
510              return new BasicExpressionToken(m_fileId, line, column, trimmed);
511          }
512          private void AddString(
513              List<ScalarToken> segments,
514              Int32? line,
515              Int32? column,
516              String value)
517          {
518              if (segments.Count > 0 && segments[segments.Count - 1] is StringToken lastSegment)
519              {
520                  segments[segments.Count - 1] = new StringToken(m_fileId, line, column, lastSegment.Value + value);
521              }
522              else
523              {
524                  segments.Add(new StringToken(m_fileId, line, column, value));
525              }
526          }
527          private static Boolean MatchesDirective(
528              String trimmed,
529              String directive,
530              Int32 expectedParameters,
531              out List<String> parameters,
532              out Exception ex)
533          {
534              if (trimmed.StartsWith(directive, StringComparison.Ordinal) &&
535                  (trimmed.Length == directive.Length || Char.IsWhiteSpace(trimmed[directive.Length])))
536              {
537                  parameters = new List<String>();
538                  var startIndex = directive.Length;
539                  var inString = false;
540                  var parens = 0;
541                  for (var i = startIndex; i < trimmed.Length; i++)
542                  {
543                      var c = trimmed[i];
544                      if (Char.IsWhiteSpace(c) && !inString && parens == 0)
545                      {
546                          if (startIndex < i)
547                          {
548                              parameters.Add(trimmed.Substring(startIndex, i - startIndex));
549                          }
550                          startIndex = i + 1;
551                      }
552                      else if (c == '\'')
553                      {
554                          inString = !inString;
555                      }
556                      else if (c == '(' && !inString)
557                      {
558                          parens++;
559                      }
560                      else if (c == ')' && !inString)
561                      {
562                          parens--;
563                      }
564                  }
565                  if (startIndex < trimmed.Length)
566                  {
567                      parameters.Add(trimmed.Substring(startIndex));
568                  }
569                  if (expectedParameters != parameters.Count)
570                  {
571                      ex = new ArgumentException(TemplateStrings.ExpectedNParametersFollowingDirective(expectedParameters, directive, parameters.Count));
572                      parameters = null;
573                      return false;
574                  }
575                  ex = null;
576                  return true;
577              }
578              ex = null;
579              parameters = null;
580              return false;
581          }
582          private static Boolean IsExpressionString(
583              String trimmed,
584              out String str)
585          {
586              var builder = new StringBuilder();
587              var inString = false;
588              for (var i = 0; i < trimmed.Length; i++)
589              {
590                  var c = trimmed[i];
591                  if (c == '\'')
592                  {
593                      inString = !inString;
594                      if (inString && i != 0)
595                      {
596                          builder.Append(c);
597                      }
598                  }
599                  else if (!inString)
600                  {
601                      str = default;
602                      return false;
603                  }
604                  else
605                  {
606                      builder.Append(c);
607                  }
608              }
609              str = builder.ToString();
610              return true;
611          }
612          private struct DefinitionInfo
613          {
614              public DefinitionInfo(
615                  TemplateSchema schema,
616                  String name)
617              {
618                  m_schema = schema;
619                  Definition = m_schema.GetDefinition(name);
620                  AllowedContext = Definition.ReaderContext;
621              }
622              public DefinitionInfo(
623                  DefinitionInfo parent,
624                  String name)
625              {
626                  m_schema = parent.m_schema;
627                  Definition = m_schema.GetDefinition(name);
628                  if (Definition.ReaderContext.Length > 0)
629                  {
630                      AllowedContext = new HashSet<String>(parent.AllowedContext.Concat(Definition.ReaderContext), StringComparer.OrdinalIgnoreCase).ToArray();
631                  }
632                  else
633                  {
634                      AllowedContext = parent.AllowedContext;
635                  }
636              }
637              public IEnumerable<T> Get<T>()
638                  where T : Definition
639              {
640                  return m_schema.Get<T>(Definition);
641              }
642              private TemplateSchema m_schema;
643              public Definition Definition;
644              public String[] AllowedContext;
645          }
646          private readonly TemplateContext m_context;
647          private readonly Int32? m_fileId;
648          private readonly TemplateMemory m_memory;
649          private readonly IObjectReader m_objectReader;
650          private readonly TemplateSchema m_schema;
651      }
652  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateReader.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Globalization;
4  using System.Linq;
5  using System.Text;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.DistributedTask.ObjectTemplating.Tokens;
8  using GitHub.DistributedTask.ObjectTemplating.Schema;
9  namespace GitHub.DistributedTask.ObjectTemplating
10  {
11      internal sealed class TemplateReader
12      {
13          private TemplateReader(
14              TemplateContext context,
15              TemplateSchema schema,
16              IObjectReader objectReader,
17              Int32? fileId)
18          {
19              m_context = context;
20              m_schema = schema;
21              m_memory = context.Memory;
22              m_objectReader = objectReader;
23              m_fileId = fileId;
24          }
25          internal static TemplateToken Read(
26              TemplateContext context,
27              String type,
28              IObjectReader objectReader,
29              Int32? fileId,
30              out Int32 bytes)
31          {
32              return Read(context, type, objectReader, fileId, context.Schema, out bytes);
33          }
34          internal static TemplateToken Read(
35              TemplateContext context,
36              String type,
37              IObjectReader objectReader,
38              Int32? fileId,
39              TemplateSchema schema,
40              out Int32 bytes)
41          {
42              TemplateToken result = null;
43              var reader = new TemplateReader(context, schema, objectReader, fileId);
44              var originalBytes = context.Memory.CurrentBytes;
45              try
46              {
47                  objectReader.ValidateStart();
48                  var definition = new DefinitionInfo(schema, type);
49                  result = reader.ReadValue(definition);
50                  objectReader.ValidateEnd();
51              }
52              catch (Exception ex)
53              {
54                  context.Error(fileId, null, null, ex);
55              }
56              finally
57              {
58                  bytes = context.Memory.CurrentBytes - originalBytes;
59              }
60              return result;
61          }
62          private TemplateToken ReadValue(DefinitionInfo definition)
63          {
64              m_memory.IncrementEvents();
65              if (m_objectReader.AllowLiteral(out LiteralToken literal))
66              {
67                  var scalar = ParseScalar(literal, definition.AllowedContext);
68                  Validate(ref scalar, definition);
69                  m_memory.AddBytes(scalar);
70                  return scalar;
71              }
72              if (m_objectReader.AllowSequenceStart(out SequenceToken sequence))
73              {
74                  m_memory.IncrementDepth();
75                  m_memory.AddBytes(sequence);
76                  var sequenceDefinition = definition.Get<SequenceDefinition>().FirstOrDefault();
77                  if (sequenceDefinition != null)
78                  {
79                      var itemDefinition = new DefinitionInfo(definition, sequenceDefinition.ItemType);
80                      while (!m_objectReader.AllowSequenceEnd())
81                      {
82                          var item = ReadValue(itemDefinition);
83                          sequence.Add(item);
84                      }
85                  }
86                  else
87                  {
88                      m_context.Error(sequence, TemplateStrings.UnexpectedSequenceStart());
89                      while (!m_objectReader.AllowSequenceEnd())
90                      {
91                          SkipValue();
92                      }
93                  }
94                  m_memory.DecrementDepth();
95                  return sequence;
96              }
97              if (m_objectReader.AllowMappingStart(out MappingToken mapping))
98              {
99                  m_memory.IncrementDepth();
100                  m_memory.AddBytes(mapping);
101                  var mappingDefinitions = definition.Get<MappingDefinition>().ToList();
102                  if (mappingDefinitions.Count > 0)
103                  {
104                      if (mappingDefinitions.Count > 1 ||
105                          m_schema.HasProperties(mappingDefinitions[0]) ||
106                          String.IsNullOrEmpty(mappingDefinitions[0].LooseKeyType))
107                      {
108                          HandleMappingWithWellKnownProperties(definition, mappingDefinitions, mapping);
109                      }
110                      else
111                      {
112                          var keyDefinition = new DefinitionInfo(definition, mappingDefinitions[0].LooseKeyType);
113                          var valueDefinition = new DefinitionInfo(definition, mappingDefinitions[0].LooseValueType);
114                          HandleMappingWithAllLooseProperties(definition, keyDefinition, valueDefinition, mapping);
115                      }
116                  }
117                  else
118                  {
119                      m_context.Error(mapping, TemplateStrings.UnexpectedMappingStart());
<span onclick='openModal()' class='match'>120                      while (!m_objectReader.AllowMappingEnd())
121                      {
122                          SkipValue();
123                          SkipValue();
</span>124                      }
125                  }
126                  m_memory.DecrementDepth();
127                  return mapping;
128              }
129              throw new InvalidOperationException(TemplateStrings.ExpectedScalarSequenceOrMapping());
130          }
131          private void HandleMappingWithWellKnownProperties(
132              DefinitionInfo definition,
133              List<MappingDefinition> mappingDefinitions,
134              MappingToken mapping)
135          {
136              String looseKeyType = null;
137              String looseValueType = null;
138              DefinitionInfo? looseKeyDefinition = null;
139              DefinitionInfo? looseValueDefinition = null;
140              if (!String.IsNullOrEmpty(mappingDefinitions[0].LooseKeyType))
141              {
142                  looseKeyType = mappingDefinitions[0].LooseKeyType;
143                  looseValueType = mappingDefinitions[0].LooseValueType;
144              }
145              var keys = new HashSet<String>(StringComparer.OrdinalIgnoreCase);
146              var hasExpressionKey = false;
147              while (m_objectReader.AllowLiteral(out LiteralToken rawLiteral))
148              {
149                  var nextKeyScalar = ParseScalar(rawLiteral, definition.AllowedContext);
150                  if (nextKeyScalar is ExpressionToken)
151                  {
152                      hasExpressionKey = true;
153                      if (definition.AllowedContext.Length > 0)
154                      {
155                          m_memory.AddBytes(nextKeyScalar);
156                          var anyDefinition = new DefinitionInfo(definition, TemplateConstants.Any);
157                          mapping.Add(nextKeyScalar, ReadValue(anyDefinition));
158                      }
159                      else
160                      {
161                          m_context.Error(nextKeyScalar, TemplateStrings.ExpressionNotAllowed());
162                          SkipValue();
163                      }
164                      continue;
165                  }
166                  if (!(nextKeyScalar is StringToken nextKey))
167                  {
168                      nextKey = new StringToken(nextKeyScalar.FileId, nextKeyScalar.Line, nextKeyScalar.Column, nextKeyScalar.ToString());
169                  }
170                  if (!keys.Add(nextKey.Value))
171                  {
172                      m_context.Error(nextKey, TemplateStrings.ValueAlreadyDefined(nextKey.Value));
173                      SkipValue();
174                      continue;
175                  }
176                  if (m_schema.TryMatchKey(mappingDefinitions, nextKey.Value, out String nextValueType))
177                  {
178                      m_memory.AddBytes(nextKey);
179                      var nextValueDefinition = new DefinitionInfo(definition, nextValueType);
180                      var nextValue = ReadValue(nextValueDefinition);
181                      mapping.Add(nextKey, nextValue);
182                      continue;
183                  }
184                  if (looseKeyType != null)
185                  {
186                      if (looseKeyDefinition == null)
187                      {
188                          looseKeyDefinition = new DefinitionInfo(definition, looseKeyType);
189                          looseValueDefinition = new DefinitionInfo(definition, looseValueType);
190                      }
191                      Validate(nextKey, looseKeyDefinition.Value);
192                      m_memory.AddBytes(nextKey);
193                      var nextValue = ReadValue(looseValueDefinition.Value);
194                      mapping.Add(nextKey, nextValue);
195                      continue;
196                  }
197                  m_context.Error(nextKey, TemplateStrings.UnexpectedValue(nextKey.Value));
198                  SkipValue();
199              }
200              if (mappingDefinitions.Count > 1)
201              {
202                  var hitCount = new Dictionary<String, Int32>();
203                  foreach (MappingDefinition mapdef in mappingDefinitions)
204                  {
205                      foreach (String key in mapdef.Properties.Keys)
206                      {
207                          if (!hitCount.TryGetValue(key, out Int32 value))
208                          {
209                              hitCount.Add(key, 1);
210                          }
211                          else
212                          {
213                              hitCount[key] = value + 1;
214                          }
215                      }
216                  }
217                  List<String> nonDuplicates = new List<String>();
218                  foreach (String key in hitCount.Keys)
219                  {
220                      if (hitCount[key] == 1)
221                      {
222                          nonDuplicates.Add(key);
223                      }
224                  }
225                  nonDuplicates.Sort();
226                  String listToDeDuplicate = String.Join(", ", nonDuplicates);
227                  m_context.Error(mapping, TemplateStrings.UnableToDetermineOneOf(listToDeDuplicate));
228              }
229              else if (mappingDefinitions.Count == 1 && !hasExpressionKey)
230              {
231                  foreach (var property in mappingDefinitions[0].Properties)
232                  {
233                      if (property.Value.Required)
234                      {
235                          if (!keys.Contains(property.Key))
236                          {
237                              m_context.Error(mapping, $"Required property is missing: {property.Key}");
238                          }
239                      }
240                  }
241              }
242              ExpectMappingEnd();
243          }
244          private void HandleMappingWithAllLooseProperties(
245              DefinitionInfo mappingDefinition,
246              DefinitionInfo keyDefinition,
247              DefinitionInfo valueDefinition,
248              MappingToken mapping)
249          {
250              TemplateToken nextValue;
251              var keys = new HashSet<String>(StringComparer.OrdinalIgnoreCase);
252              while (m_objectReader.AllowLiteral(out LiteralToken rawLiteral))
253              {
254                  var nextKeyScalar = ParseScalar(rawLiteral, mappingDefinition.AllowedContext);
255                  if (nextKeyScalar is ExpressionToken)
256                  {
257                      if (mappingDefinition.AllowedContext.Length > 0)
258                      {
259                          m_memory.AddBytes(nextKeyScalar);
260                          nextValue = ReadValue(valueDefinition);
261                          mapping.Add(nextKeyScalar, nextValue);
262                      }
263                      else
264                      {
265                          m_context.Error(nextKeyScalar, TemplateStrings.ExpressionNotAllowed());
266                          SkipValue();
267                      }
268                      continue;
269                  }
270                  if (!(nextKeyScalar is StringToken nextKey))
271                  {
272                      nextKey = new StringToken(nextKeyScalar.FileId, nextKeyScalar.Line, nextKeyScalar.Column, nextKeyScalar.ToString());
273                  }
274                  if (!keys.Add(nextKey.Value))
275                  {
276                      m_context.Error(nextKey, TemplateStrings.ValueAlreadyDefined(nextKey.Value));
277                      SkipValue();
278                      continue;
279                  }
280                  Validate(nextKey, keyDefinition);
281                  m_memory.AddBytes(nextKey);
282                  nextValue = ReadValue(valueDefinition);
283                  mapping.Add(nextKey, nextValue);
284              }
285              ExpectMappingEnd();
286          }
287          private void ExpectMappingEnd()
288          {
289              if (!m_objectReader.AllowMappingEnd())
290              {
291                  throw new Exception("Expected mapping end"); 
292              }
293          }
294          private void SkipValue(Boolean error = false)
295          {
296              m_memory.IncrementEvents();
297              if (m_objectReader.AllowLiteral(out LiteralToken literal))
298              {
299                  if (error)
300                  {
301                      m_context.Error(literal, TemplateStrings.UnexpectedValue(literal));
302                  }
303                  return;
304              }
305              if (m_objectReader.AllowSequenceStart(out SequenceToken sequence))
306              {
307                  m_memory.IncrementDepth();
308                  if (error)
309                  {
310                      m_context.Error(sequence, TemplateStrings.UnexpectedSequenceStart());
311                  }
312                  while (!m_objectReader.AllowSequenceEnd())
313                  {
314                      SkipValue();
315                  }
316                  m_memory.DecrementDepth();
317                  return;
318              }
319              if (m_objectReader.AllowMappingStart(out MappingToken mapping))
320              {
321                  m_memory.IncrementDepth();
322                  if (error)
323                  {
324                      m_context.Error(mapping, TemplateStrings.UnexpectedMappingStart());
325                  }
326                  while (!m_objectReader.AllowMappingEnd())
327                  {
328                      SkipValue();
329                      SkipValue();
330                  }
331                  m_memory.DecrementDepth();
332                  return;
333              }
334              throw new InvalidOperationException(TemplateStrings.ExpectedScalarSequenceOrMapping());
335          }
336          private void Validate(
337              StringToken stringToken,
338              DefinitionInfo definition)
339          {
340              var scalar = stringToken as ScalarToken;
341              Validate(ref scalar, definition);
342          }
343          private void Validate(
344              ref ScalarToken scalar,
345              DefinitionInfo definition)
346          {
347              switch (scalar.Type)
348              {
349                  case TokenType.Null:
350                  case TokenType.Boolean:
351                  case TokenType.Number:
352                  case TokenType.String:
353                      var literal = scalar as LiteralToken;
354                      if (definition.Get<ScalarDefinition>().Any(x => x.IsMatch(literal)))
355                      {
356                          return;
357                      }
358                      if (literal.Type != TokenType.String)
359                      {
360                          literal = new StringToken(literal.FileId, literal.Line, literal.Column, literal.ToString());
361                          if (definition.Get<StringDefinition>().Any(x => x.IsMatch(literal)))
362                          {
363                              scalar = literal;
364                              return;
365                          }
366                      }
367                      m_context.Error(literal, TemplateStrings.UnexpectedValue(literal));
368                      break;
369                  case TokenType.BasicExpression:
370                      if (definition.AllowedContext.Length == 0)
371                      {
372                          m_context.Error(scalar, TemplateStrings.ExpressionNotAllowed());
373                      }
374                      break;
375                  default:
376                      m_context.Error(scalar, TemplateStrings.UnexpectedValue(scalar));
377                      break;
378              }
379          }
380          private ScalarToken ParseScalar(
381              LiteralToken token,
382              String[] allowedContext)
383          {
384              if (token.Type != TokenType.String)
385              {
386                  return token;
387              }
388              var raw = token.ToString();
389              Int32 startExpression;
390              if (String.IsNullOrEmpty(raw) ||
391                  (startExpression = raw.IndexOf(TemplateConstants.OpenExpression)) < 0) 
392              {
393                  return token;
394              }
395              var segments = new List<ScalarToken>();
396              var i = 0;
397              while (i < raw.Length)
398              {
399                  if (i == startExpression)
400                  {
401                      startExpression = i;
402                      var endExpression = -1;
403                      var inString = false;
404                      for (i += TemplateConstants.OpenExpression.Length; i < raw.Length; i++)
405                      {
406                          if (raw[i] == '\'')
407                          {
408                              inString = !inString; 
409                          }
410                          else if (!inString && raw[i] == '}' && raw[i - 1] == '}')
411                          {
412                              endExpression = i;
413                              i++;
414                              break;
415                          }
416                      }
417                      if (endExpression < startExpression)
418                      {
419                          m_context.Error(token, TemplateStrings.ExpressionNotClosed());
420                          return token;
421                      }
422                      var rawExpression = raw.Substring(
423                          startExpression + TemplateConstants.OpenExpression.Length,
424                          endExpression - startExpression + 1 - TemplateConstants.OpenExpression.Length - TemplateConstants.CloseExpression.Length);
425                      var expression = ParseExpression(token.Line, token.Column, rawExpression, allowedContext, out Exception ex);
426                      if (ex != null)
427                      {
428                          m_context.Error(token, ex);
429                          return token;
430                      }
431                      if (!String.IsNullOrEmpty(expression.Directive) &&
432                          ((startExpression != 0) || (i < raw.Length)))
433                      {
434                          m_context.Error(token, TemplateStrings.DirectiveNotAllowedInline(expression.Directive));
435                          return token;
436                      }
437                      segments.Add(expression);
438                      startExpression = raw.IndexOf(TemplateConstants.OpenExpression, i);
439                  }
440                  else if (i < startExpression)
441                  {
442                      AddString(segments, token.Line, token.Column, raw.Substring(i, startExpression - i));
443                      i = startExpression;
444                  }
445                  else
446                  {
447                      AddString(segments, token.Line, token.Column, raw.Substring(i));
448                      break;
449                  }
450              }
451              if (segments.Count == 1 &&
452                  segments[0] is BasicExpressionToken basicExpression &&
453                  IsExpressionString(basicExpression.Expression, out String str))
454              {
455                  return new StringToken(m_fileId, token.Line, token.Column, str);
456              }
457              if (segments.Count == 1)
458              {
459                  return segments[0];
460              }
461              var format = new StringBuilder();
462              var args = new StringBuilder();
463              var argIndex = 0;
464              foreach (var segment in segments)
465              {
466                  if (segment is StringToken literal)
467                  {
468                      var text = ExpressionUtility.StringEscape(literal.Value) 
469                          .Replace("{", "{{") 
470                          .Replace("}", "}}");
471                      format.Append(text);
472                  }
473                  else
474                  {
475                      format.Append("{" + argIndex.ToString(CultureInfo.InvariantCulture) + "}"); 
476                      argIndex++;
477                      var expression = segment as BasicExpressionToken;
478                      args.Append(", ");
479                      args.Append(expression.Expression);
480                  }
481              }
482              return new BasicExpressionToken(m_fileId, token.Line, token.Column, $"format('{format}'{args})");
483          }
484          private ExpressionToken ParseExpression(
485              Int32? line,
486              Int32? column,
487              String value,
488              String[] allowedContext,
489              out Exception ex)
490          {
491              var trimmed = value.Trim();
492              if (String.IsNullOrEmpty(trimmed))
493              {
494                  ex = new ArgumentException(TemplateStrings.ExpectedExpression());
495                  return null;
496              }
497              List<String> parameters;
498              if (MatchesDirective(trimmed, TemplateConstants.InsertDirective, 0, out parameters, out ex))
499              {
500                  return new InsertExpressionToken(m_fileId, line, column);
501              }
502              else if (ex != null)
503              {
504                  return null;
505              }
506              if (!ExpressionToken.IsValidExpression(trimmed, allowedContext, out ex))
507              {
508                  return null;
509              }
510              return new BasicExpressionToken(m_fileId, line, column, trimmed);
511          }
512          private void AddString(
513              List<ScalarToken> segments,
514              Int32? line,
515              Int32? column,
516              String value)
517          {
518              if (segments.Count > 0 && segments[segments.Count - 1] is StringToken lastSegment)
519              {
520                  segments[segments.Count - 1] = new StringToken(m_fileId, line, column, lastSegment.Value + value);
521              }
522              else
523              {
524                  segments.Add(new StringToken(m_fileId, line, column, value));
525              }
526          }
527          private static Boolean MatchesDirective(
528              String trimmed,
529              String directive,
530              Int32 expectedParameters,
531              out List<String> parameters,
532              out Exception ex)
533          {
534              if (trimmed.StartsWith(directive, StringComparison.Ordinal) &&
535                  (trimmed.Length == directive.Length || Char.IsWhiteSpace(trimmed[directive.Length])))
536              {
537                  parameters = new List<String>();
538                  var startIndex = directive.Length;
539                  var inString = false;
540                  var parens = 0;
541                  for (var i = startIndex; i < trimmed.Length; i++)
542                  {
543                      var c = trimmed[i];
544                      if (Char.IsWhiteSpace(c) && !inString && parens == 0)
545                      {
546                          if (startIndex < i)
547                          {
548                              parameters.Add(trimmed.Substring(startIndex, i - startIndex));
549                          }
550                          startIndex = i + 1;
551                      }
552                      else if (c == '\'')
553                      {
554                          inString = !inString;
555                      }
556                      else if (c == '(' && !inString)
557                      {
558                          parens++;
559                      }
560                      else if (c == ')' && !inString)
561                      {
562                          parens--;
563                      }
564                  }
565                  if (startIndex < trimmed.Length)
566                  {
567                      parameters.Add(trimmed.Substring(startIndex));
568                  }
569                  if (expectedParameters != parameters.Count)
570                  {
571                      ex = new ArgumentException(TemplateStrings.ExpectedNParametersFollowingDirective(expectedParameters, directive, parameters.Count));
572                      parameters = null;
573                      return false;
574                  }
575                  ex = null;
576                  return true;
577              }
578              ex = null;
579              parameters = null;
580              return false;
581          }
582          private static Boolean IsExpressionString(
583              String trimmed,
584              out String str)
585          {
586              var builder = new StringBuilder();
587              var inString = false;
588              for (var i = 0; i < trimmed.Length; i++)
589              {
590                  var c = trimmed[i];
591                  if (c == '\'')
592                  {
593                      inString = !inString;
594                      if (inString && i != 0)
595                      {
596                          builder.Append(c);
597                      }
598                  }
599                  else if (!inString)
600                  {
601                      str = default;
602                      return false;
603                  }
604                  else
605                  {
606                      builder.Append(c);
607                  }
608              }
609              str = builder.ToString();
610              return true;
611          }
612          private struct DefinitionInfo
613          {
614              public DefinitionInfo(
615                  TemplateSchema schema,
616                  String name)
617              {
618                  m_schema = schema;
619                  Definition = m_schema.GetDefinition(name);
620                  AllowedContext = Definition.ReaderContext;
621              }
622              public DefinitionInfo(
623                  DefinitionInfo parent,
624                  String name)
625              {
626                  m_schema = parent.m_schema;
627                  Definition = m_schema.GetDefinition(name);
628                  if (Definition.ReaderContext.Length > 0)
629                  {
630                      AllowedContext = new HashSet<String>(parent.AllowedContext.Concat(Definition.ReaderContext), StringComparer.OrdinalIgnoreCase).ToArray();
631                  }
632                  else
633                  {
634                      AllowedContext = parent.AllowedContext;
635                  }
636              }
637              public IEnumerable<T> Get<T>()
638                  where T : Definition
639              {
640                  return m_schema.Get<T>(Definition);
641              }
642              private TemplateSchema m_schema;
643              public Definition Definition;
644              public String[] AllowedContext;
645          }
646          private readonly TemplateContext m_context;
647          private readonly Int32? m_fileId;
648          private readonly TemplateMemory m_memory;
649          private readonly IObjectReader m_objectReader;
650          private readonly TemplateSchema m_schema;
651      }
652  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateReader.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateReader.cs</div>
                </div>
                <div class="column column_space"><pre><code>326                  while (!m_objectReader.AllowMappingEnd())
327                  {
328                      SkipValue();
329                      SkipValue();
</pre></code></div>
                <div class="column column_space"><pre><code>120                      while (!m_objectReader.AllowMappingEnd())
121                      {
122                          SkipValue();
123                          SkipValue();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    