
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Text;
4  #pragma warning disable CA1034
5  namespace NpgsqlTypes;
6  public abstract class NpgsqlTsQuery : IEquatable&lt;NpgsqlTsQuery&gt;
7  {
8      public NodeKind Kind { get; }
9      public enum NodeKind
10      {
11          Empty = -1,
12          Lexeme = 0,
13          Not = 1,
14          And = 2,
15          Or = 3,
16          Phrase = 4
17      }
18      protected NpgsqlTsQuery(NodeKind kind) =&gt; Kind = kind;
19      public void Write(StringBuilder stringBuilder) =&gt; WriteCore(stringBuilder, true);
20      internal abstract void WriteCore(StringBuilder sb, bool first = false);
21      public override string ToString()
22      {
23          var sb = new StringBuilder();
24          Write(sb);
25          return sb.ToString();
26      }
27      public static NpgsqlTsQuery Parse(string value)
28      {
29          if (value == null)
30              throw new ArgumentNullException(nameof(value));
31          var valStack = new Stack&lt;NpgsqlTsQuery&gt;();
32          var opStack = new Stack&lt;NpgsqlTsQueryOperator&gt;();
33          var sb = new StringBuilder();
34          var pos = 0;
35          var expectingBinOp = false;
36          var lastFollowedByOpDistance = -1;
37          NextToken:
38          if (pos &gt;= value.Length)
39              goto Finish;
40          var ch = value[pos++];
41          if (ch == &#x27;\&#x27;&#x27;)
42              goto WaitEndComplex;
43          if ((ch == &#x27;)&#x27; || ch == &#x27;|&#x27; || ch == &#x27;&amp;&#x27;) &amp;&amp; !expectingBinOp || (ch == &#x27;(&#x27; || ch == &#x27;!&#x27;) &amp;&amp; expectingBinOp)
44              throw new FormatException(&quot;Syntax error in tsquery. Unexpected token.&quot;);
45          if (ch == &#x27;&lt;&#x27;)
46          {
47              var endOfOperatorConsumed = false;
48              var sbCurrentLength = sb.Length;
49              while (pos &lt; value.Length)
50              {
51                  var c = value[pos++];
52                  if (c == &#x27;&gt;&#x27;)
53                  {
54                      endOfOperatorConsumed = true;
55                      break;
56                  }
57                  sb.Append(c);
58              }
59              if (sb.Length == sbCurrentLength || !endOfOperatorConsumed)
60                  throw new FormatException(&quot;Syntax error in tsquery. Malformed &#x27;followed by&#x27; operator.&quot;);
61              var followedByOpDistanceString = sb.ToString(sbCurrentLength, sb.Length - sbCurrentLength);
62              if (followedByOpDistanceString == &quot;-&quot;)
63              {
64                  lastFollowedByOpDistance = 1;
65              }
66              else if (!int.TryParse(followedByOpDistanceString, out lastFollowedByOpDistance)
67                       || lastFollowedByOpDistance &lt; 0)
68              {
69                  throw new FormatException(&quot;Syntax error in tsquery. Malformed distance in &#x27;followed by&#x27; operator.&quot;);
70              }
71              sb.Length -= followedByOpDistanceString.Length;
72          }
73          if (ch == &#x27;(&#x27; || ch == &#x27;!&#x27; || ch == &#x27;&amp;&#x27; || ch == &#x27;&lt;&#x27;)
74          {
75              opStack.Push(new NpgsqlTsQueryOperator(ch, lastFollowedByOpDistance));
76              expectingBinOp = false;
77              lastFollowedByOpDistance = 0;
78              goto NextToken;
79          }
80          if (ch == &#x27;|&#x27;)
81          {
82              if (opStack.Count &gt; 0 &amp;&amp; opStack.Peek() == &#x27;|&#x27;)
83              {
84                  if (valStack.Count &lt; 2)
85                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
86                  var right = valStack.Pop();
87                  var left = valStack.Pop();
88                  valStack.Push(new NpgsqlTsQueryOr(left, right));
89              }
90              else
91                  opStack.Push(&#x27;|&#x27;);
92              expectingBinOp = false;
93              goto NextToken;
94          }
95          if (ch == &#x27;)&#x27;)
96          {
97              while (opStack.Count &gt; 0 &amp;&amp; opStack.Peek() != &#x27;(&#x27;)
98              {
99                  if (valStack.Count &lt; 2 || opStack.Peek() == &#x27;!&#x27;)
100                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
101                  var right = valStack.Pop();
102                  var left = valStack.Pop();
103                  var tsOp = opStack.Pop();
104                  valStack.Push((char)tsOp switch
105                  {
106                      &#x27;&amp;&#x27; =&gt; (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
107                      &#x27;|&#x27; =&gt; new NpgsqlTsQueryOr(left, right),
108                      &#x27;&lt;&#x27; =&gt; new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
109                      _   =&gt; throw new FormatException(&quot;Syntax error in tsquery&quot;)
110                  });
111              }
112              if (opStack.Count == 0)
113                  throw new FormatException(&quot;Syntax error in tsquery: closing parenthesis without an opening parenthesis&quot;);
114              opStack.Pop();
115              goto PushedVal;
116          }
117          if (ch == &#x27;:&#x27;)
118              throw new FormatException(&quot;Unexpected : while parsing tsquery&quot;);
119          if (char.IsWhiteSpace(ch))
120              goto NextToken;
121          pos--;
122          if (expectingBinOp)
123              throw new FormatException(&quot;Unexpected lexeme while parsing tsquery&quot;);
124          WaitEnd:
125          if (pos &gt;= value.Length || char.IsWhiteSpace(ch = value[pos]) || ch == &#x27;!&#x27; || ch == &#x27;&amp;&#x27; || ch == &#x27;|&#x27; || ch == &#x27;(&#x27; || ch == &#x27;)&#x27;)
126          {
127              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
128              goto PushedVal;
129          }
130          pos++;
131          if (ch == &#x27;:&#x27;)
132          {
133              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
134              sb.Clear();
135              goto InWeightInfo;
136          }
137          if (ch == &#x27;\\&#x27;)
138          {
139              if (pos &gt;= value.Length)
140                  throw new FormatException(@&quot;Unexpected \ in end of value&quot;);
141              ch = value[pos++];
142          }
143          sb.Append(ch);
144          goto WaitEnd;
145          WaitEndComplex:
146          if (pos &gt;= value.Length)
147              throw new FormatException(&quot;Missing terminating &#x27; in string literal&quot;);
148          ch = value[pos++];
149          if (ch == &#x27;\&#x27;&#x27;)
150          {
151              if (pos &lt; value.Length &amp;&amp; value[pos] == &#x27;\&#x27;&#x27;)
152              {
153                  ch = &#x27;\&#x27;&#x27;;
154                  pos++;
155              }
156              else
157              {
158                  valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
159                  if (pos &lt; value.Length &amp;&amp; value[pos] == &#x27;:&#x27;)
160                  {
161                      pos++;
162                      goto InWeightInfo;
163                  }
164                  goto PushedVal;
165              }
166          }
167          if (ch == &#x27;\\&#x27;)
168          {
169              if (pos &gt;= value.Length)
170                  throw new FormatException(@&quot;Unexpected \ in end of value&quot;);
171              ch = value[pos++];
172          }
173          sb.Append(ch);
174          goto WaitEndComplex;
175          InWeightInfo:
176          if (pos &gt;= value.Length)
177              goto Finish;
178          ch = value[pos];
179          switch (ch)
180          {
181          case &#x27;*&#x27;:
182              ((NpgsqlTsQueryLexeme)valStack.Peek()).IsPrefixSearch = true;
183              break;
184          case &#x27;a&#x27; or &#x27;A&#x27;:
185              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.A;
186              break;
187          case &#x27;b&#x27; or &#x27;B&#x27;:
188              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.B;
189              break;
190          case &#x27;c&#x27; or &#x27;C&#x27;:
191              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.C;
192              break;
193          case &#x27;d&#x27; or &#x27;D&#x27;:
194              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.D;
195              break;
196          default:
197              goto PushedVal;
198          }
199          pos++;
200          goto InWeightInfo;
201          PushedVal:
202          sb.Clear();
203          var processTightBindingOperator = true;
204          while (opStack.Count &gt; 0 &amp;&amp; processTightBindingOperator)
205          {
206              var tsOp = opStack.Peek();
207              switch (tsOp)
208              {
209              case &#x27;&amp;&#x27;:
210                  if (valStack.Count &lt; 2)
211                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
212                  var andRight = valStack.Pop();
213                  var andLeft = valStack.Pop();
214                  valStack.Push(new NpgsqlTsQueryAnd(andLeft, andRight));
215                  opStack.Pop();
216                  break;
217              case &#x27;!&#x27;:
218                  if (valStack.Count == 0)
219                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
220                  valStack.Push(new NpgsqlTsQueryNot(valStack.Pop()));
221                  opStack.Pop();
222                  break;
223              case &#x27;&lt;&#x27;:
224                  if (valStack.Count &lt; 2)
225                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
226                  var followedByRight = valStack.Pop();
227                  var followedByLeft = valStack.Pop();
228                  valStack.Push(
229                      new NpgsqlTsQueryFollowedBy(
230                          followedByLeft,
231                          tsOp.FollowedByDistance,
232                          followedByRight));
233                  opStack.Pop();
234                  break;
235              default:
236                  processTightBindingOperator = false;
237                  break;
238              }
239          }
240          expectingBinOp = true;
241          goto NextToken;
242          Finish:
243          while (opStack.Count &gt; 0)
244          {
245              if (valStack.Count &lt; 2)
246                  throw new FormatException(&quot;Syntax error in tsquery&quot;);
247              var right = valStack.Pop();
248              var left = valStack.Pop();
249              var tsOp = opStack.Pop();
250              var query = (char)tsOp switch
251              {
252                  &#x27;&amp;&#x27; =&gt; (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
253                  &#x27;|&#x27; =&gt; new NpgsqlTsQueryOr(left, right),
254                  &#x27;&lt;&#x27; =&gt; new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
255                  _   =&gt; throw new FormatException(&quot;Syntax error in tsquery&quot;)
256              };
257              valStack.Push(query);
258          }
259          if (valStack.Count != 1)
260              throw new FormatException(&quot;Syntax error in tsquery&quot;);
261          return valStack.Pop();
262      }
263      public override int GetHashCode()
264          =&gt; throw new NotSupportedException(&quot;Must be overridden&quot;);
265      public override bool Equals(object? obj)
266          =&gt; obj is NpgsqlTsQuery query &amp;&amp; query.Equals(this);
267      public abstract bool Equals(NpgsqlTsQuery? other);
268      public static bool operator ==(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
269          =&gt; left is null ? right is null : left.Equals(right);
270      public static bool operator !=(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
271          =&gt; left is null ? right is not null : !left.Equals(right);
272  }
273  readonly struct NpgsqlTsQueryOperator
274  {
275      public readonly char Char;
276      public readonly int FollowedByDistance;
277      public NpgsqlTsQueryOperator(char character, int followedByDistance)
278      {
279          Char = character;
280          FollowedByDistance = followedByDistance;
281      }
282      public static implicit operator NpgsqlTsQueryOperator(char c) =&gt; new(c, 0);
283      public static implicit operator char(NpgsqlTsQueryOperator o) =&gt; o.Char;
284  }
285  public sealed class NpgsqlTsQueryLexeme : NpgsqlTsQuery
286  {
287      string _text;
288      public string Text
289      {
290          get =&gt; _text;
291          set
292          {
293              if (string.IsNullOrEmpty(value))
294                  throw new ArgumentException(&quot;Text is null or empty string&quot;, nameof(value));
295              _text = value;
296          }
297      }
298      Weight _weights;
299      public Weight Weights
300      {
301          get =&gt; _weights;
302          set
303          {
304              if (((byte)value &gt;&gt; 4) != 0)
305                  throw new ArgumentOutOfRangeException(nameof(value), &quot;Illegal weights&quot;);
306              _weights = value;
307          }
308      }
309      public bool IsPrefixSearch { get; set; }
310      public NpgsqlTsQueryLexeme(string text) : this(text, Weight.None, false) { }
311      public NpgsqlTsQueryLexeme(string text, Weight weights) : this(text, weights, false) { }
312      public NpgsqlTsQueryLexeme(string text, Weight weights, bool isPrefixSearch)
313          : base(NodeKind.Lexeme)
314      {
315          _text = text;
316          Weights = weights;
317          IsPrefixSearch = isPrefixSearch;
318      }
319  #pragma warning disable CA1714
320      [Flags]
321      public enum Weight
322  #pragma warning restore CA1714
323      {
324          None = 0,
325          D = 1,
326          C = 2,
327          B = 4,
328          A = 8
329      }
330      internal override void WriteCore(StringBuilder sb, bool first = false)
331      {
332          sb.Append(&#x27;\&#x27;&#x27;).Append(Text.Replace(@&quot;\&quot;, @&quot;\\&quot;).Replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;)).Append(&#x27;\&#x27;&#x27;);
333          if (IsPrefixSearch || Weights != Weight.None)
334              sb.Append(&#x27;:&#x27;);
335          if (IsPrefixSearch)
336              sb.Append(&#x27;*&#x27;);
337          if ((Weights &amp; Weight.A) != Weight.None)
338              sb.Append(&#x27;A&#x27;);
339          if ((Weights &amp; Weight.B) != Weight.None)
340              sb.Append(&#x27;B&#x27;);
341          if ((Weights &amp; Weight.C) != Weight.None)
342              sb.Append(&#x27;C&#x27;);
343          if ((Weights &amp; Weight.D) != Weight.None)
344              sb.Append(&#x27;D&#x27;);
345      }
346      public override bool Equals(NpgsqlTsQuery? other)
347          =&gt; other is NpgsqlTsQueryLexeme lexeme &amp;&amp;
348             lexeme.Text == Text &amp;&amp;
349             lexeme.Weights == Weights &amp;&amp;
350             lexeme.IsPrefixSearch == IsPrefixSearch;
351      public override int GetHashCode()
352          =&gt; HashCode.Combine(Text, Weights, IsPrefixSearch);
353  }
354  public sealed class NpgsqlTsQueryNot : NpgsqlTsQuery
355  {
356      public NpgsqlTsQuery Child { get; set; }
357      public NpgsqlTsQueryNot(NpgsqlTsQuery child)
358          : base(NodeKind.Not)
359      {
<span onclick='openModal()' class='match'>360          Child = child;
361      }
362      internal override void WriteCore(StringBuilder sb, bool first = false)
363      {
364          sb.Append(&#x27;!&#x27;);
</span>365          if (Child == null)
366          {
367              sb.Append(&quot;&#x27;&#x27;&quot;);
368          }
369          else
370          {
371              if (Child.Kind != NodeKind.Lexeme)
372                  sb.Append(&quot;( &quot;);
373              Child.WriteCore(sb, true);
374              if (Child.Kind != NodeKind.Lexeme)
375                  sb.Append(&quot; )&quot;);
376          }
377      }
378      public override bool Equals(NpgsqlTsQuery? other)
379          =&gt; other is NpgsqlTsQueryNot not &amp;&amp; not.Child == Child;
380      public override int GetHashCode()
381          =&gt; Child?.GetHashCode() ?? 0;
382  }
383  public abstract class NpgsqlTsQueryBinOp : NpgsqlTsQuery
384  {
385      public NpgsqlTsQuery Left { get; set; }
386      public NpgsqlTsQuery Right { get; set; }
387      protected NpgsqlTsQueryBinOp(NodeKind kind, NpgsqlTsQuery left, NpgsqlTsQuery right)
388          : base(kind)
389      {
390          Left = left;
391          Right = right;
392      }
393  }
394  public sealed class NpgsqlTsQueryAnd : NpgsqlTsQueryBinOp
395  {
396      public NpgsqlTsQueryAnd(NpgsqlTsQuery left, NpgsqlTsQuery right)
397          : base(NodeKind.And, left, right) {}
398      internal override void WriteCore(StringBuilder sb, bool first = false)
399      {
400          Left.WriteCore(sb);
401          sb.Append(&quot; &amp; &quot;);
402          Right.WriteCore(sb);
403      }
404      public override bool Equals(NpgsqlTsQuery? other)
405          =&gt; other is NpgsqlTsQueryAnd and &amp;&amp; and.Left == Left &amp;&amp; and.Right == Right;
406      public override int GetHashCode()
407          =&gt; HashCode.Combine(Left, Right);
408  }
409  public sealed class NpgsqlTsQueryOr : NpgsqlTsQueryBinOp
410  {
411      public NpgsqlTsQueryOr(NpgsqlTsQuery left, NpgsqlTsQuery right)
412          : base(NodeKind.Or, left, right) {}
413      internal override void WriteCore(StringBuilder sb, bool first = false)
414      {
415          if (!first)
416              sb.Append(&quot;( &quot;);
417          Left.WriteCore(sb);
418          sb.Append(&quot; | &quot;);
419          Right.WriteCore(sb);
420          if (!first)
421              sb.Append(&quot; )&quot;);
422      }
423      public override bool Equals(NpgsqlTsQuery? other)
424          =&gt; other is NpgsqlTsQueryOr or &amp;&amp; or.Left == Left &amp;&amp; or.Right == Right;
425      public override int GetHashCode()
426          =&gt; HashCode.Combine(Left, Right);
427  }
428  public sealed class NpgsqlTsQueryFollowedBy : NpgsqlTsQueryBinOp
429  {
430      public int Distance { get; set; }
431      public NpgsqlTsQueryFollowedBy(
432          NpgsqlTsQuery left,
433          int distance,
434          NpgsqlTsQuery right)
435          : base(NodeKind.Phrase, left, right)
436      {
437          if (distance &lt; 0)
438              throw new ArgumentOutOfRangeException(nameof(distance));
439          Distance = distance;
440      }
441      internal override void WriteCore(StringBuilder sb, bool first = false)
442      {
443          if (!first)
444              sb.Append(&quot;( &quot;);
445          Left.WriteCore(sb);
446          sb.Append(&quot; &lt;&quot;);
447          if (Distance == 1) sb.Append(&quot;-&quot;);
448          else sb.Append(Distance);
449          sb.Append(&quot;&gt; &quot;);
450          Right.WriteCore(sb);
451          if (!first)
452              sb.Append(&quot; )&quot;);
453      }
454      public override bool Equals(NpgsqlTsQuery? other)
455          =&gt; other is NpgsqlTsQueryFollowedBy followedBy &amp;&amp;
456             followedBy.Left == Left &amp;&amp;
457             followedBy.Right == Right &amp;&amp;
458             followedBy.Distance == Distance;
459      public override int GetHashCode()
460          =&gt; HashCode.Combine(Left, Right, Distance);
461  }
462  public sealed class NpgsqlTsQueryEmpty : NpgsqlTsQuery
463  {
464      public NpgsqlTsQueryEmpty() : base(NodeKind.Empty) {}
465      internal override void WriteCore(StringBuilder sb, bool first = false) { }
466      public override bool Equals(NpgsqlTsQuery? other)
467          =&gt; other is NpgsqlTsQueryEmpty;
468      public override int GetHashCode()
469          =&gt; Kind.GetHashCode();
470  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Text;
4  #pragma warning disable CA1034
5  namespace NpgsqlTypes;
6  public abstract class NpgsqlTsQuery : IEquatable&lt;NpgsqlTsQuery&gt;
7  {
8      public NodeKind Kind { get; }
9      public enum NodeKind
10      {
11          Empty = -1,
12          Lexeme = 0,
13          Not = 1,
14          And = 2,
15          Or = 3,
16          Phrase = 4
17      }
18      protected NpgsqlTsQuery(NodeKind kind) =&gt; Kind = kind;
19      public void Write(StringBuilder stringBuilder) =&gt; WriteCore(stringBuilder, true);
20      internal abstract void WriteCore(StringBuilder sb, bool first = false);
21      public override string ToString()
22      {
23          var sb = new StringBuilder();
24          Write(sb);
25          return sb.ToString();
26      }
27      public static NpgsqlTsQuery Parse(string value)
28      {
29          if (value == null)
30              throw new ArgumentNullException(nameof(value));
31          var valStack = new Stack&lt;NpgsqlTsQuery&gt;();
32          var opStack = new Stack&lt;NpgsqlTsQueryOperator&gt;();
33          var sb = new StringBuilder();
34          var pos = 0;
35          var expectingBinOp = false;
36          var lastFollowedByOpDistance = -1;
37          NextToken:
38          if (pos &gt;= value.Length)
39              goto Finish;
40          var ch = value[pos++];
41          if (ch == &#x27;\&#x27;&#x27;)
42              goto WaitEndComplex;
43          if ((ch == &#x27;)&#x27; || ch == &#x27;|&#x27; || ch == &#x27;&amp;&#x27;) &amp;&amp; !expectingBinOp || (ch == &#x27;(&#x27; || ch == &#x27;!&#x27;) &amp;&amp; expectingBinOp)
44              throw new FormatException(&quot;Syntax error in tsquery. Unexpected token.&quot;);
45          if (ch == &#x27;&lt;&#x27;)
46          {
47              var endOfOperatorConsumed = false;
48              var sbCurrentLength = sb.Length;
49              while (pos &lt; value.Length)
50              {
51                  var c = value[pos++];
52                  if (c == &#x27;&gt;&#x27;)
53                  {
54                      endOfOperatorConsumed = true;
55                      break;
56                  }
57                  sb.Append(c);
58              }
59              if (sb.Length == sbCurrentLength || !endOfOperatorConsumed)
60                  throw new FormatException(&quot;Syntax error in tsquery. Malformed &#x27;followed by&#x27; operator.&quot;);
61              var followedByOpDistanceString = sb.ToString(sbCurrentLength, sb.Length - sbCurrentLength);
62              if (followedByOpDistanceString == &quot;-&quot;)
63              {
64                  lastFollowedByOpDistance = 1;
65              }
66              else if (!int.TryParse(followedByOpDistanceString, out lastFollowedByOpDistance)
67                       || lastFollowedByOpDistance &lt; 0)
68              {
69                  throw new FormatException(&quot;Syntax error in tsquery. Malformed distance in &#x27;followed by&#x27; operator.&quot;);
70              }
71              sb.Length -= followedByOpDistanceString.Length;
72          }
73          if (ch == &#x27;(&#x27; || ch == &#x27;!&#x27; || ch == &#x27;&amp;&#x27; || ch == &#x27;&lt;&#x27;)
74          {
75              opStack.Push(new NpgsqlTsQueryOperator(ch, lastFollowedByOpDistance));
76              expectingBinOp = false;
77              lastFollowedByOpDistance = 0;
78              goto NextToken;
79          }
80          if (ch == &#x27;|&#x27;)
81          {
82              if (opStack.Count &gt; 0 &amp;&amp; opStack.Peek() == &#x27;|&#x27;)
83              {
84                  if (valStack.Count &lt; 2)
85                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
86                  var right = valStack.Pop();
87                  var left = valStack.Pop();
88                  valStack.Push(new NpgsqlTsQueryOr(left, right));
89              }
90              else
91                  opStack.Push(&#x27;|&#x27;);
92              expectingBinOp = false;
93              goto NextToken;
94          }
95          if (ch == &#x27;)&#x27;)
96          {
97              while (opStack.Count &gt; 0 &amp;&amp; opStack.Peek() != &#x27;(&#x27;)
98              {
99                  if (valStack.Count &lt; 2 || opStack.Peek() == &#x27;!&#x27;)
100                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
101                  var right = valStack.Pop();
102                  var left = valStack.Pop();
103                  var tsOp = opStack.Pop();
104                  valStack.Push((char)tsOp switch
105                  {
106                      &#x27;&amp;&#x27; =&gt; (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
107                      &#x27;|&#x27; =&gt; new NpgsqlTsQueryOr(left, right),
108                      &#x27;&lt;&#x27; =&gt; new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
109                      _   =&gt; throw new FormatException(&quot;Syntax error in tsquery&quot;)
110                  });
111              }
112              if (opStack.Count == 0)
113                  throw new FormatException(&quot;Syntax error in tsquery: closing parenthesis without an opening parenthesis&quot;);
114              opStack.Pop();
115              goto PushedVal;
116          }
117          if (ch == &#x27;:&#x27;)
118              throw new FormatException(&quot;Unexpected : while parsing tsquery&quot;);
119          if (char.IsWhiteSpace(ch))
120              goto NextToken;
121          pos--;
122          if (expectingBinOp)
123              throw new FormatException(&quot;Unexpected lexeme while parsing tsquery&quot;);
124          WaitEnd:
125          if (pos &gt;= value.Length || char.IsWhiteSpace(ch = value[pos]) || ch == &#x27;!&#x27; || ch == &#x27;&amp;&#x27; || ch == &#x27;|&#x27; || ch == &#x27;(&#x27; || ch == &#x27;)&#x27;)
126          {
127              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
128              goto PushedVal;
129          }
130          pos++;
131          if (ch == &#x27;:&#x27;)
132          {
133              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
134              sb.Clear();
135              goto InWeightInfo;
136          }
137          if (ch == &#x27;\\&#x27;)
138          {
139              if (pos &gt;= value.Length)
140                  throw new FormatException(@&quot;Unexpected \ in end of value&quot;);
141              ch = value[pos++];
142          }
143          sb.Append(ch);
144          goto WaitEnd;
145          WaitEndComplex:
146          if (pos &gt;= value.Length)
147              throw new FormatException(&quot;Missing terminating &#x27; in string literal&quot;);
148          ch = value[pos++];
149          if (ch == &#x27;\&#x27;&#x27;)
150          {
151              if (pos &lt; value.Length &amp;&amp; value[pos] == &#x27;\&#x27;&#x27;)
152              {
153                  ch = &#x27;\&#x27;&#x27;;
154                  pos++;
155              }
156              else
157              {
158                  valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
159                  if (pos &lt; value.Length &amp;&amp; value[pos] == &#x27;:&#x27;)
160                  {
161                      pos++;
162                      goto InWeightInfo;
163                  }
164                  goto PushedVal;
165              }
166          }
167          if (ch == &#x27;\\&#x27;)
168          {
169              if (pos &gt;= value.Length)
170                  throw new FormatException(@&quot;Unexpected \ in end of value&quot;);
171              ch = value[pos++];
172          }
173          sb.Append(ch);
174          goto WaitEndComplex;
175          InWeightInfo:
176          if (pos &gt;= value.Length)
177              goto Finish;
178          ch = value[pos];
179          switch (ch)
180          {
181          case &#x27;*&#x27;:
182              ((NpgsqlTsQueryLexeme)valStack.Peek()).IsPrefixSearch = true;
183              break;
184          case &#x27;a&#x27; or &#x27;A&#x27;:
185              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.A;
186              break;
187          case &#x27;b&#x27; or &#x27;B&#x27;:
188              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.B;
189              break;
190          case &#x27;c&#x27; or &#x27;C&#x27;:
191              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.C;
192              break;
193          case &#x27;d&#x27; or &#x27;D&#x27;:
194              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.D;
195              break;
196          default:
197              goto PushedVal;
198          }
199          pos++;
200          goto InWeightInfo;
201          PushedVal:
202          sb.Clear();
203          var processTightBindingOperator = true;
204          while (opStack.Count &gt; 0 &amp;&amp; processTightBindingOperator)
205          {
206              var tsOp = opStack.Peek();
207              switch (tsOp)
208              {
209              case &#x27;&amp;&#x27;:
210                  if (valStack.Count &lt; 2)
211                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
212                  var andRight = valStack.Pop();
213                  var andLeft = valStack.Pop();
214                  valStack.Push(new NpgsqlTsQueryAnd(andLeft, andRight));
215                  opStack.Pop();
216                  break;
217              case &#x27;!&#x27;:
218                  if (valStack.Count == 0)
219                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
220                  valStack.Push(new NpgsqlTsQueryNot(valStack.Pop()));
221                  opStack.Pop();
222                  break;
223              case &#x27;&lt;&#x27;:
224                  if (valStack.Count &lt; 2)
225                      throw new FormatException(&quot;Syntax error in tsquery&quot;);
226                  var followedByRight = valStack.Pop();
227                  var followedByLeft = valStack.Pop();
228                  valStack.Push(
229                      new NpgsqlTsQueryFollowedBy(
230                          followedByLeft,
231                          tsOp.FollowedByDistance,
232                          followedByRight));
233                  opStack.Pop();
234                  break;
235              default:
236                  processTightBindingOperator = false;
237                  break;
238              }
239          }
240          expectingBinOp = true;
241          goto NextToken;
242          Finish:
243          while (opStack.Count &gt; 0)
244          {
245              if (valStack.Count &lt; 2)
246                  throw new FormatException(&quot;Syntax error in tsquery&quot;);
247              var right = valStack.Pop();
248              var left = valStack.Pop();
249              var tsOp = opStack.Pop();
250              var query = (char)tsOp switch
251              {
252                  &#x27;&amp;&#x27; =&gt; (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
253                  &#x27;|&#x27; =&gt; new NpgsqlTsQueryOr(left, right),
254                  &#x27;&lt;&#x27; =&gt; new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
255                  _   =&gt; throw new FormatException(&quot;Syntax error in tsquery&quot;)
256              };
257              valStack.Push(query);
258          }
259          if (valStack.Count != 1)
260              throw new FormatException(&quot;Syntax error in tsquery&quot;);
261          return valStack.Pop();
262      }
263      public override int GetHashCode()
264          =&gt; throw new NotSupportedException(&quot;Must be overridden&quot;);
265      public override bool Equals(object? obj)
266          =&gt; obj is NpgsqlTsQuery query &amp;&amp; query.Equals(this);
267      public abstract bool Equals(NpgsqlTsQuery? other);
268      public static bool operator ==(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
269          =&gt; left is null ? right is null : left.Equals(right);
270      public static bool operator !=(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
271          =&gt; left is null ? right is not null : !left.Equals(right);
272  }
273  readonly struct NpgsqlTsQueryOperator
274  {
275      public readonly char Char;
276      public readonly int FollowedByDistance;
277      public NpgsqlTsQueryOperator(char character, int followedByDistance)
278      {
279          Char = character;
280          FollowedByDistance = followedByDistance;
281      }
282      public static implicit operator NpgsqlTsQueryOperator(char c) =&gt; new(c, 0);
283      public static implicit operator char(NpgsqlTsQueryOperator o) =&gt; o.Char;
284  }
285  public sealed class NpgsqlTsQueryLexeme : NpgsqlTsQuery
286  {
287      string _text;
288      public string Text
289      {
290          get =&gt; _text;
291          set
292          {
293              if (string.IsNullOrEmpty(value))
294                  throw new ArgumentException(&quot;Text is null or empty string&quot;, nameof(value));
295              _text = value;
296          }
297      }
298      Weight _weights;
299      public Weight Weights
300      {
301          get =&gt; _weights;
302          set
303          {
304              if (((byte)value &gt;&gt; 4) != 0)
305                  throw new ArgumentOutOfRangeException(nameof(value), &quot;Illegal weights&quot;);
306              _weights = value;
307          }
308      }
309      public bool IsPrefixSearch { get; set; }
310      public NpgsqlTsQueryLexeme(string text) : this(text, Weight.None, false) { }
311      public NpgsqlTsQueryLexeme(string text, Weight weights) : this(text, weights, false) { }
312      public NpgsqlTsQueryLexeme(string text, Weight weights, bool isPrefixSearch)
313          : base(NodeKind.Lexeme)
314      {
315          _text = text;
316          Weights = weights;
317          IsPrefixSearch = isPrefixSearch;
318      }
319  #pragma warning disable CA1714
320      [Flags]
321      public enum Weight
322  #pragma warning restore CA1714
323      {
324          None = 0,
325          D = 1,
326          C = 2,
327          B = 4,
328          A = 8
329      }
330      internal override void WriteCore(StringBuilder sb, bool first = false)
331      {
332          sb.Append(&#x27;\&#x27;&#x27;).Append(Text.Replace(@&quot;\&quot;, @&quot;\\&quot;).Replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;)).Append(&#x27;\&#x27;&#x27;);
333          if (IsPrefixSearch || Weights != Weight.None)
334              sb.Append(&#x27;:&#x27;);
335          if (IsPrefixSearch)
336              sb.Append(&#x27;*&#x27;);
337          if ((Weights &amp; Weight.A) != Weight.None)
338              sb.Append(&#x27;A&#x27;);
339          if ((Weights &amp; Weight.B) != Weight.None)
340              sb.Append(&#x27;B&#x27;);
341          if ((Weights &amp; Weight.C) != Weight.None)
342              sb.Append(&#x27;C&#x27;);
343          if ((Weights &amp; Weight.D) != Weight.None)
344              sb.Append(&#x27;D&#x27;);
345      }
346      public override bool Equals(NpgsqlTsQuery? other)
347          =&gt; other is NpgsqlTsQueryLexeme lexeme &amp;&amp;
348             lexeme.Text == Text &amp;&amp;
349             lexeme.Weights == Weights &amp;&amp;
350             lexeme.IsPrefixSearch == IsPrefixSearch;
351      public override int GetHashCode()
352          =&gt; HashCode.Combine(Text, Weights, IsPrefixSearch);
353  }
354  public sealed class NpgsqlTsQueryNot : NpgsqlTsQuery
355  {
356      public NpgsqlTsQuery Child { get; set; }
357      public NpgsqlTsQueryNot(NpgsqlTsQuery child)
358          : base(NodeKind.Not)
359      {
360          Child = child;
361      }
362      internal override void WriteCore(StringBuilder sb, bool first = false)
363      {
364          sb.Append(&#x27;!&#x27;);
365          if (Child == null)
366          {
367              sb.Append(&quot;&#x27;&#x27;&quot;);
368          }
369          else
370          {
371              if (Child.Kind != NodeKind.Lexeme)
372                  sb.Append(&quot;( &quot;);
373              Child.WriteCore(sb, true);
374              if (Child.Kind != NodeKind.Lexeme)
375                  sb.Append(&quot; )&quot;);
376          }
377      }
378      public override bool Equals(NpgsqlTsQuery? other)
379          =&gt; other is NpgsqlTsQueryNot not &amp;&amp; not.Child == Child;
380      public override int GetHashCode()
381          =&gt; Child?.GetHashCode() ?? 0;
382  }
383  public abstract class NpgsqlTsQueryBinOp : NpgsqlTsQuery
384  {
385      public NpgsqlTsQuery Left { get; set; }
386      public NpgsqlTsQuery Right { get; set; }
387      protected NpgsqlTsQueryBinOp(NodeKind kind, NpgsqlTsQuery left, NpgsqlTsQuery right)
388          : base(kind)
389      {
390          Left = left;
391          Right = right;
392      }
393  }
394  public sealed class NpgsqlTsQueryAnd : NpgsqlTsQueryBinOp
395  {
396      public NpgsqlTsQueryAnd(NpgsqlTsQuery left, NpgsqlTsQuery right)
397          : base(NodeKind.And, left, right) {}
398      internal override void WriteCore(StringBuilder sb, bool first = false)
399      {
400          Left.WriteCore(sb);
401          sb.Append(&quot; &amp; &quot;);
402          Right.WriteCore(sb);
403      }
404      public override bool Equals(NpgsqlTsQuery? other)
405          =&gt; other is NpgsqlTsQueryAnd and &amp;&amp; and.Left == Left &amp;&amp; and.Right == Right;
406      public override int GetHashCode()
407          =&gt; HashCode.Combine(Left, Right);
408  }
409  public sealed class NpgsqlTsQueryOr : NpgsqlTsQueryBinOp
410  {
411      public NpgsqlTsQueryOr(NpgsqlTsQuery left, NpgsqlTsQuery right)
412          : base(NodeKind.Or, left, right) {}
413      internal override void WriteCore(StringBuilder sb, bool first = false)
414      {
415          if (!first)
416              sb.Append(&quot;( &quot;);
417          Left.WriteCore(sb);
418          sb.Append(&quot; | &quot;);
419          Right.WriteCore(sb);
420          if (!first)
421              sb.Append(&quot; )&quot;);
422      }
423      public override bool Equals(NpgsqlTsQuery? other)
424          =&gt; other is NpgsqlTsQueryOr or &amp;&amp; or.Left == Left &amp;&amp; or.Right == Right;
425      public override int GetHashCode()
426          =&gt; HashCode.Combine(Left, Right);
427  }
428  public sealed class NpgsqlTsQueryFollowedBy : NpgsqlTsQueryBinOp
429  {
430      public int Distance { get; set; }
431      public NpgsqlTsQueryFollowedBy(
432          NpgsqlTsQuery left,
433          int distance,
434          NpgsqlTsQuery right)
435          : base(NodeKind.Phrase, left, right)
436      {
437          if (distance &lt; 0)
438              throw new ArgumentOutOfRangeException(nameof(distance));
<span onclick='openModal()' class='match'>439          Distance = distance;
440      }
441      internal override void WriteCore(StringBuilder sb, bool first = false)
442      {
443          if (!first)
</span>444              sb.Append(&quot;( &quot;);
445          Left.WriteCore(sb);
446          sb.Append(&quot; &lt;&quot;);
447          if (Distance == 1) sb.Append(&quot;-&quot;);
448          else sb.Append(Distance);
449          sb.Append(&quot;&gt; &quot;);
450          Right.WriteCore(sb);
451          if (!first)
452              sb.Append(&quot; )&quot;);
453      }
454      public override bool Equals(NpgsqlTsQuery? other)
455          =&gt; other is NpgsqlTsQueryFollowedBy followedBy &amp;&amp;
456             followedBy.Left == Left &amp;&amp;
457             followedBy.Right == Right &amp;&amp;
458             followedBy.Distance == Distance;
459      public override int GetHashCode()
460          =&gt; HashCode.Combine(Left, Right, Distance);
461  }
462  public sealed class NpgsqlTsQueryEmpty : NpgsqlTsQuery
463  {
464      public NpgsqlTsQueryEmpty() : base(NodeKind.Empty) {}
465      internal override void WriteCore(StringBuilder sb, bool first = false) { }
466      public override bool Equals(NpgsqlTsQuery? other)
467          =&gt; other is NpgsqlTsQueryEmpty;
468      public override int GetHashCode()
469          =&gt; Kind.GetHashCode();
470  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</div>
                </div>
                <div class="column column_space"><pre><code>360          Child = child;
361      }
362      internal override void WriteCore(StringBuilder sb, bool first = false)
363      {
364          sb.Append(&#x27;!&#x27;);
</pre></code></div>
                <div class="column column_space"><pre><code>439          Distance = distance;
440      }
441      internal override void WriteCore(StringBuilder sb, bool first = false)
442      {
443          if (!first)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    