
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Text.RegularExpressions;
6  using System.Threading;
7  using System.Threading.Channels;
8  using System.Threading.Tasks;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  namespace GitHub.Runner.Worker.Container
12  {
13      [ServiceLocator(Default = typeof(DockerCommandManager))]
14      public interface IDockerCommandManager : IRunnerService
15      {
16          string DockerPath { get; }
17          string DockerInstanceLabel { get; }
18          Task&lt;DockerVersion&gt; DockerVersion(IExecutionContext context);
19          Task&lt;int&gt; DockerPull(IExecutionContext context, string image);
20          Task&lt;int&gt; DockerPull(IExecutionContext context, string image, string configFileDirectory);
21          Task&lt;int&gt; DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag);
22          Task&lt;string&gt; DockerCreate(IExecutionContext context, ContainerInfo container);
23          Task&lt;int&gt; DockerRun(IExecutionContext context, ContainerInfo container, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stdoutDataReceived, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stderrDataReceived);
24          Task&lt;int&gt; DockerStart(IExecutionContext context, string containerId);
25          Task&lt;int&gt; DockerLogs(IExecutionContext context, string containerId);
26          Task&lt;List&lt;string&gt;&gt; DockerPS(IExecutionContext context, string options);
27          Task&lt;int&gt; DockerRemove(IExecutionContext context, string containerId);
28          Task&lt;int&gt; DockerNetworkCreate(IExecutionContext context, string network);
29          Task&lt;int&gt; DockerNetworkRemove(IExecutionContext context, string network);
30          Task&lt;int&gt; DockerNetworkPrune(IExecutionContext context);
31          Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command);
32          Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command, List&lt;string&gt; outputs);
33          Task&lt;List&lt;string&gt;&gt; DockerInspect(IExecutionContext context, string dockerObject, string options);
34          Task&lt;List&lt;PortMapping&gt;&gt; DockerPort(IExecutionContext context, string containerId);
35          Task&lt;int&gt; DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password);
36      }
37      public class DockerCommandManager : RunnerService, IDockerCommandManager
38      {
39          public string DockerPath { get; private set; }
40          public string DockerInstanceLabel { get; private set; }
41          public override void Initialize(IHostContext hostContext)
42          {
43              base.Initialize(hostContext);
44              DockerPath = WhichUtil.Which(&quot;docker&quot;, true, Trace);
45              DockerInstanceLabel = IOUtil.GetSha256Hash(hostContext.GetDirectory(WellKnownDirectory.Root)).Substring(0, 6);
46          }
47          public async Task&lt;DockerVersion&gt; DockerVersion(IExecutionContext context)
48          {
49              string serverVersionStr = (await ExecuteDockerCommandAsync(context, &quot;version&quot;, &quot;--format &#x27;{{.Server.APIVersion}}&#x27;&quot;)).FirstOrDefault();
50              ArgUtil.NotNullOrEmpty(serverVersionStr, &quot;Docker.Server.Version&quot;);
51              context.Output($&quot;Docker daemon API version: {serverVersionStr}&quot;);
52              string clientVersionStr = (await ExecuteDockerCommandAsync(context, &quot;version&quot;, &quot;--format &#x27;{{.Client.APIVersion}}&#x27;&quot;)).FirstOrDefault();
53              ArgUtil.NotNullOrEmpty(serverVersionStr, &quot;Docker.Client.Version&quot;);
54              context.Output($&quot;Docker client API version: {clientVersionStr}&quot;);
55              Regex verRegex = new(&quot;\\d+\\.\\d+(\\.\\d+)?&quot;, RegexOptions.IgnoreCase);
56              Version serverVersion = null;
57              var serverVersionMatchResult = verRegex.Match(serverVersionStr);
58              if (serverVersionMatchResult.Success &amp;&amp; !string.IsNullOrEmpty(serverVersionMatchResult.Value))
59              {
60                  if (!Version.TryParse(serverVersionMatchResult.Value, out serverVersion))
61                  {
62                      serverVersion = null;
63                  }
64              }
65              Version clientVersion = null;
66              var clientVersionMatchResult = verRegex.Match(serverVersionStr);
67              if (clientVersionMatchResult.Success &amp;&amp; !string.IsNullOrEmpty(clientVersionMatchResult.Value))
68              {
69                  if (!Version.TryParse(clientVersionMatchResult.Value, out clientVersion))
70                  {
71                      clientVersion = null;
72                  }
73              }
74              return new DockerVersion(serverVersion, clientVersion);
75          }
76          public Task&lt;int&gt; DockerPull(IExecutionContext context, string image)
77          {
78              return DockerPull(context, image, null);
79          }
80          public async Task&lt;int&gt; DockerPull(IExecutionContext context, string image, string configFileDirectory)
81          {
82              if (string.IsNullOrEmpty(configFileDirectory))
83              {
84                  return await ExecuteDockerCommandAsync(context, $&quot;pull&quot;, image, context.CancellationToken);
85              }
86              return await ExecuteDockerCommandAsync(context, $&quot;--config {configFileDirectory} pull&quot;, image, context.CancellationToken);
87          }
88          public async Task&lt;int&gt; DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag)
89          {
90              return await ExecuteDockerCommandAsync(context, &quot;build&quot;, $&quot;-t {tag} -f \&quot;{dockerFile}\&quot; \&quot;{dockerContext}\&quot;&quot;, workingDirectory, context.CancellationToken);
91          }
92          public async Task&lt;string&gt; DockerCreate(IExecutionContext context, ContainerInfo container)
93          {
94              IList&lt;string&gt; dockerOptions = new List&lt;string&gt;();
95              dockerOptions.Add($&quot;--name {container.ContainerDisplayName}&quot;);
96              dockerOptions.Add($&quot;--label {DockerInstanceLabel}&quot;);
97              if (!string.IsNullOrEmpty(container.ContainerWorkDirectory))
98              {
99                  dockerOptions.Add($&quot;--workdir {container.ContainerWorkDirectory}&quot;);
100              }
101              if (!string.IsNullOrEmpty(container.ContainerNetwork))
102              {
103                  dockerOptions.Add($&quot;--network {container.ContainerNetwork}&quot;);
104              }
105              if (!string.IsNullOrEmpty(container.ContainerNetworkAlias))
106              {
107                  dockerOptions.Add($&quot;--network-alias {container.ContainerNetworkAlias}&quot;);
108              }
109              foreach (var port in container.UserPortMappings)
110              {
111                  dockerOptions.Add($&quot;-p {port.Value}&quot;);
112              }
113              dockerOptions.Add($&quot;{container.ContainerCreateOptions}&quot;);
114              foreach (var env in container.ContainerEnvironmentVariables)
115              {
116                  if (String.IsNullOrEmpty(env.Value))
117                  {
118                      dockerOptions.Add(DockerUtil.CreateEscapedOption(&quot;-e&quot;, env.Key));
119                  }
120                  else
121                  {
122                      dockerOptions.Add(DockerUtil.CreateEscapedOption(&quot;-e&quot;, env.Key, env.Value));
123                  }
124              }
125              dockerOptions.Add(&quot;-e GITHUB_ACTIONS=true&quot;);
126              if (!container.ContainerEnvironmentVariables.ContainsKey(&quot;CI&quot;))
127              {
128                  dockerOptions.Add(&quot;-e CI=true&quot;);
129              }
130              foreach (var volume in container.MountVolumes)
131              {
132                  String volumeArg;
133                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
134                  {
135                      volumeArg = $&quot;-v \&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
136                  }
137                  else
138                  {
139                      volumeArg = $&quot;-v \&quot;{volume.SourceVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;:\&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
140                  }
141                  if (volume.ReadOnly)
142                  {
143                      volumeArg += &quot;:ro&quot;;
144                  }
145                  dockerOptions.Add(volumeArg);
146              }
147              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
148              {
149                  dockerOptions.Add($&quot;--entrypoint \&quot;{container.ContainerEntryPoint}\&quot;&quot;);
150              }
151              dockerOptions.Add($&quot;{container.ContainerImage}&quot;);
<span onclick='openModal()' class='match'>152              dockerOptions.Add($&quot;{container.ContainerEntryPointArgs}&quot;);
153              var optionsString = string.Join(&quot; &quot;, dockerOptions);
154              List&lt;string&gt; outputStrings = await ExecuteDockerCommandAsync(context, &quot;create&quot;, optionsString);
</span>155              return outputStrings.FirstOrDefault();
156          }
157          public async Task&lt;int&gt; DockerRun(IExecutionContext context, ContainerInfo container, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stdoutDataReceived, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stderrDataReceived)
158          {
159              IList&lt;string&gt; dockerOptions = new List&lt;string&gt;();
160              dockerOptions.Add($&quot;--name {container.ContainerDisplayName}&quot;);
161              dockerOptions.Add($&quot;--label {DockerInstanceLabel}&quot;);
162              dockerOptions.Add($&quot;--workdir {container.ContainerWorkDirectory}&quot;);
163              dockerOptions.Add($&quot;--rm&quot;);
164              foreach (var env in container.ContainerEnvironmentVariables)
165              {
166                  dockerOptions.Add(DockerUtil.CreateEscapedOption(&quot;-e&quot;, env.Key));
167              }
168              dockerOptions.Add(&quot;-e GITHUB_ACTIONS=true&quot;);
169              if (!container.ContainerEnvironmentVariables.ContainsKey(&quot;CI&quot;))
170              {
171                  dockerOptions.Add(&quot;-e CI=true&quot;);
172              }
173              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
174              {
175                  dockerOptions.Add($&quot;--entrypoint \&quot;{container.ContainerEntryPoint}\&quot;&quot;);
176              }
177              if (!string.IsNullOrEmpty(container.ContainerNetwork))
178              {
179                  dockerOptions.Add($&quot;--network {container.ContainerNetwork}&quot;);
180              }
181              foreach (var volume in container.MountVolumes)
182              {
183                  String volumeArg;
184                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
185                  {
186                      volumeArg = $&quot;-v \&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
187                  }
188                  else
189                  {
190                      volumeArg = $&quot;-v \&quot;{volume.SourceVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;:\&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
191                  }
192                  if (volume.ReadOnly)
193                  {
194                      volumeArg += &quot;:ro&quot;;
195                  }
196                  dockerOptions.Add(volumeArg);
197              }
198              dockerOptions.Add($&quot;{container.ContainerImage}&quot;);
199              dockerOptions.Add($&quot;{container.ContainerEntryPointArgs}&quot;);
200              var optionsString = string.Join(&quot; &quot;, dockerOptions);
201              return await ExecuteDockerCommandAsync(context, &quot;run&quot;, optionsString, container.ContainerEnvironmentVariables, stdoutDataReceived, stderrDataReceived, context.CancellationToken);
202          }
203          public async Task&lt;int&gt; DockerStart(IExecutionContext context, string containerId)
204          {
205              return await ExecuteDockerCommandAsync(context, &quot;start&quot;, containerId, context.CancellationToken);
206          }
207          public async Task&lt;int&gt; DockerRemove(IExecutionContext context, string containerId)
208          {
209              return await ExecuteDockerCommandAsync(context, &quot;rm&quot;, $&quot;--force {containerId}&quot;, context.CancellationToken);
210          }
211          public async Task&lt;int&gt; DockerLogs(IExecutionContext context, string containerId)
212          {
213              return await ExecuteDockerCommandAsync(context, &quot;logs&quot;, $&quot;--details {containerId}&quot;, context.CancellationToken);
214          }
215          public async Task&lt;List&lt;string&gt;&gt; DockerPS(IExecutionContext context, string options)
216          {
217              return await ExecuteDockerCommandAsync(context, &quot;ps&quot;, options);
218          }
219          public async Task&lt;int&gt; DockerNetworkCreate(IExecutionContext context, string network)
220          {
221  #if OS_WINDOWS
222              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;create --label {DockerInstanceLabel} {network} --driver nat&quot;, context.CancellationToken);
223  #else
224              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;create --label {DockerInstanceLabel} {network}&quot;, context.CancellationToken);
225  #endif
226          }
227          public async Task&lt;int&gt; DockerNetworkRemove(IExecutionContext context, string network)
228          {
229              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;rm {network}&quot;, context.CancellationToken);
230          }
231          public async Task&lt;int&gt; DockerNetworkPrune(IExecutionContext context)
232          {
233              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;prune --force --filter \&quot;label={DockerInstanceLabel}\&quot;&quot;, context.CancellationToken);
234          }
235          public async Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command)
236          {
237              return await ExecuteDockerCommandAsync(context, &quot;exec&quot;, $&quot;{options} {containerId} {command}&quot;, context.CancellationToken);
238          }
239          public async Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command, List&lt;string&gt; output)
240          {
241              ArgUtil.NotNull(output, nameof(output));
242              string arg = $&quot;exec {options} {containerId} {command}&quot;.Trim();
243              context.Command($&quot;{DockerPath} {arg}&quot;);
244              object outputLock = new();
245              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
246              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
247              {
248                  if (!string.IsNullOrEmpty(message.Data))
249                  {
250                      lock (outputLock)
251                      {
252                          output.Add(message.Data);
253                      }
254                  }
255              };
256              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
257              {
258                  if (!string.IsNullOrEmpty(message.Data))
259                  {
260                      lock (outputLock)
261                      {
262                          output.Add(message.Data);
263                      }
264                  }
265              };
266              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
267              {
268                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
269              }
270              return await processInvoker.ExecuteAsync(
271                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
272                              fileName: DockerPath,
273                              arguments: arg,
274                              environment: null,
275                              requireExitCodeZero: false,
276                              outputEncoding: null,
277                              cancellationToken: CancellationToken.None);
278          }
279          public async Task&lt;List&lt;string&gt;&gt; DockerInspect(IExecutionContext context, string dockerObject, string options)
280          {
281              return await ExecuteDockerCommandAsync(context, &quot;inspect&quot;, $&quot;{options} {dockerObject}&quot;);
282          }
283          public async Task&lt;List&lt;PortMapping&gt;&gt; DockerPort(IExecutionContext context, string containerId)
284          {
285              List&lt;string&gt; portMappingLines = await ExecuteDockerCommandAsync(context, &quot;port&quot;, containerId);
286              return DockerUtil.ParseDockerPort(portMappingLines);
287          }
288          public Task&lt;int&gt; DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password)
289          {
290              string args = $&quot;--config {configFileDirectory} login {registry} -u {username} --password-stdin&quot;;
291              context.Command($&quot;{DockerPath} {args}&quot;);
292              var input = Channel.CreateBounded&lt;string&gt;(new BoundedChannelOptions(1) { SingleReader = true, SingleWriter = true });
293              input.Writer.TryWrite(password);
294              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
295              return processInvoker.ExecuteAsync(
296                  workingDirectory: context.GetGitHubContext(&quot;workspace&quot;),
297                  fileName: DockerPath,
298                  arguments: args,
299                  environment: null,
300                  requireExitCodeZero: false,
301                  outputEncoding: null,
302                  killProcessOnCancel: false,
303                  redirectStandardIn: input,
304                  cancellationToken: context.CancellationToken);
305          }
306          private Task&lt;int&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, CancellationToken cancellationToken = default(CancellationToken))
307          {
308              return ExecuteDockerCommandAsync(context, command, options, null, cancellationToken);
309          }
310          private async Task&lt;int&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, IDictionary&lt;string, string&gt; environment, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stdoutDataReceived, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stderrDataReceived, CancellationToken cancellationToken = default(CancellationToken))
311          {
312              string arg = $&quot;{command} {options}&quot;.Trim();
313              context.Command($&quot;{DockerPath} {arg}&quot;);
314              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
315              processInvoker.OutputDataReceived += stdoutDataReceived;
316              processInvoker.ErrorDataReceived += stderrDataReceived;
317              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
318              {
319                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
320              }
321              return await processInvoker.ExecuteAsync(
322                  workingDirectory: context.GetGitHubContext(&quot;workspace&quot;),
323                  fileName: DockerPath,
324                  arguments: arg,
325                  environment: environment,
326                  requireExitCodeZero: false,
327                  outputEncoding: null,
328                  killProcessOnCancel: false,
329                  cancellationToken: cancellationToken);
330          }
331          private async Task&lt;int&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, string workingDirectory, CancellationToken cancellationToken = default(CancellationToken))
332          {
333              string arg = $&quot;{command} {options}&quot;.Trim();
334              context.Command($&quot;{DockerPath} {arg}&quot;);
335              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
336              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
337              {
338                  context.Output(message.Data);
339              };
340              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
341              {
342                  context.Output(message.Data);
343              };
344              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
345              {
346                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
347              }
348              return await processInvoker.ExecuteAsync(
349                  workingDirectory: workingDirectory ?? context.GetGitHubContext(&quot;workspace&quot;),
350                  fileName: DockerPath,
351                  arguments: arg,
352                  environment: null,
353                  requireExitCodeZero: false,
354                  outputEncoding: null,
355                  killProcessOnCancel: false,
356                  redirectStandardIn: null,
357                  cancellationToken: cancellationToken);
358          }
359          private async Task&lt;List&lt;string&gt;&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options)
360          {
361              string arg = $&quot;{command} {options}&quot;.Trim();
362              context.Command($&quot;{DockerPath} {arg}&quot;);
363              List&lt;string&gt; output = new();
364              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
365              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
366              {
367                  if (!string.IsNullOrEmpty(message.Data))
368                  {
369                      output.Add(message.Data);
370                      context.Output(message.Data);
371                  }
372              };
373              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
374              {
375                  if (!string.IsNullOrEmpty(message.Data))
376                  {
377                      context.Output(message.Data);
378                  }
379              };
380              await processInvoker.ExecuteAsync(
381                              workingDirectory: context.GetGitHubContext(&quot;workspace&quot;),
382                              fileName: DockerPath,
383                              arguments: arg,
384                              environment: null,
385                              requireExitCodeZero: true,
386                              outputEncoding: null,
387                              cancellationToken: CancellationToken.None);
388              return output;
389          }
390      }
391  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Text.RegularExpressions;
6  using System.Threading;
7  using System.Threading.Channels;
8  using System.Threading.Tasks;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  namespace GitHub.Runner.Worker.Container
12  {
13      [ServiceLocator(Default = typeof(DockerCommandManager))]
14      public interface IDockerCommandManager : IRunnerService
15      {
16          string DockerPath { get; }
17          string DockerInstanceLabel { get; }
18          Task&lt;DockerVersion&gt; DockerVersion(IExecutionContext context);
19          Task&lt;int&gt; DockerPull(IExecutionContext context, string image);
20          Task&lt;int&gt; DockerPull(IExecutionContext context, string image, string configFileDirectory);
21          Task&lt;int&gt; DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag);
22          Task&lt;string&gt; DockerCreate(IExecutionContext context, ContainerInfo container);
23          Task&lt;int&gt; DockerRun(IExecutionContext context, ContainerInfo container, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stdoutDataReceived, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stderrDataReceived);
24          Task&lt;int&gt; DockerStart(IExecutionContext context, string containerId);
25          Task&lt;int&gt; DockerLogs(IExecutionContext context, string containerId);
26          Task&lt;List&lt;string&gt;&gt; DockerPS(IExecutionContext context, string options);
27          Task&lt;int&gt; DockerRemove(IExecutionContext context, string containerId);
28          Task&lt;int&gt; DockerNetworkCreate(IExecutionContext context, string network);
29          Task&lt;int&gt; DockerNetworkRemove(IExecutionContext context, string network);
30          Task&lt;int&gt; DockerNetworkPrune(IExecutionContext context);
31          Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command);
32          Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command, List&lt;string&gt; outputs);
33          Task&lt;List&lt;string&gt;&gt; DockerInspect(IExecutionContext context, string dockerObject, string options);
34          Task&lt;List&lt;PortMapping&gt;&gt; DockerPort(IExecutionContext context, string containerId);
35          Task&lt;int&gt; DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password);
36      }
37      public class DockerCommandManager : RunnerService, IDockerCommandManager
38      {
39          public string DockerPath { get; private set; }
40          public string DockerInstanceLabel { get; private set; }
41          public override void Initialize(IHostContext hostContext)
42          {
43              base.Initialize(hostContext);
44              DockerPath = WhichUtil.Which(&quot;docker&quot;, true, Trace);
45              DockerInstanceLabel = IOUtil.GetSha256Hash(hostContext.GetDirectory(WellKnownDirectory.Root)).Substring(0, 6);
46          }
47          public async Task&lt;DockerVersion&gt; DockerVersion(IExecutionContext context)
48          {
49              string serverVersionStr = (await ExecuteDockerCommandAsync(context, &quot;version&quot;, &quot;--format &#x27;{{.Server.APIVersion}}&#x27;&quot;)).FirstOrDefault();
50              ArgUtil.NotNullOrEmpty(serverVersionStr, &quot;Docker.Server.Version&quot;);
51              context.Output($&quot;Docker daemon API version: {serverVersionStr}&quot;);
52              string clientVersionStr = (await ExecuteDockerCommandAsync(context, &quot;version&quot;, &quot;--format &#x27;{{.Client.APIVersion}}&#x27;&quot;)).FirstOrDefault();
53              ArgUtil.NotNullOrEmpty(serverVersionStr, &quot;Docker.Client.Version&quot;);
54              context.Output($&quot;Docker client API version: {clientVersionStr}&quot;);
55              Regex verRegex = new(&quot;\\d+\\.\\d+(\\.\\d+)?&quot;, RegexOptions.IgnoreCase);
56              Version serverVersion = null;
57              var serverVersionMatchResult = verRegex.Match(serverVersionStr);
58              if (serverVersionMatchResult.Success &amp;&amp; !string.IsNullOrEmpty(serverVersionMatchResult.Value))
59              {
60                  if (!Version.TryParse(serverVersionMatchResult.Value, out serverVersion))
61                  {
62                      serverVersion = null;
63                  }
64              }
65              Version clientVersion = null;
66              var clientVersionMatchResult = verRegex.Match(serverVersionStr);
67              if (clientVersionMatchResult.Success &amp;&amp; !string.IsNullOrEmpty(clientVersionMatchResult.Value))
68              {
69                  if (!Version.TryParse(clientVersionMatchResult.Value, out clientVersion))
70                  {
71                      clientVersion = null;
72                  }
73              }
74              return new DockerVersion(serverVersion, clientVersion);
75          }
76          public Task&lt;int&gt; DockerPull(IExecutionContext context, string image)
77          {
78              return DockerPull(context, image, null);
79          }
80          public async Task&lt;int&gt; DockerPull(IExecutionContext context, string image, string configFileDirectory)
81          {
82              if (string.IsNullOrEmpty(configFileDirectory))
83              {
84                  return await ExecuteDockerCommandAsync(context, $&quot;pull&quot;, image, context.CancellationToken);
85              }
86              return await ExecuteDockerCommandAsync(context, $&quot;--config {configFileDirectory} pull&quot;, image, context.CancellationToken);
87          }
88          public async Task&lt;int&gt; DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag)
89          {
90              return await ExecuteDockerCommandAsync(context, &quot;build&quot;, $&quot;-t {tag} -f \&quot;{dockerFile}\&quot; \&quot;{dockerContext}\&quot;&quot;, workingDirectory, context.CancellationToken);
91          }
92          public async Task&lt;string&gt; DockerCreate(IExecutionContext context, ContainerInfo container)
93          {
94              IList&lt;string&gt; dockerOptions = new List&lt;string&gt;();
95              dockerOptions.Add($&quot;--name {container.ContainerDisplayName}&quot;);
96              dockerOptions.Add($&quot;--label {DockerInstanceLabel}&quot;);
97              if (!string.IsNullOrEmpty(container.ContainerWorkDirectory))
98              {
99                  dockerOptions.Add($&quot;--workdir {container.ContainerWorkDirectory}&quot;);
100              }
101              if (!string.IsNullOrEmpty(container.ContainerNetwork))
102              {
103                  dockerOptions.Add($&quot;--network {container.ContainerNetwork}&quot;);
104              }
105              if (!string.IsNullOrEmpty(container.ContainerNetworkAlias))
106              {
107                  dockerOptions.Add($&quot;--network-alias {container.ContainerNetworkAlias}&quot;);
108              }
109              foreach (var port in container.UserPortMappings)
110              {
111                  dockerOptions.Add($&quot;-p {port.Value}&quot;);
112              }
113              dockerOptions.Add($&quot;{container.ContainerCreateOptions}&quot;);
114              foreach (var env in container.ContainerEnvironmentVariables)
115              {
116                  if (String.IsNullOrEmpty(env.Value))
117                  {
118                      dockerOptions.Add(DockerUtil.CreateEscapedOption(&quot;-e&quot;, env.Key));
119                  }
120                  else
121                  {
122                      dockerOptions.Add(DockerUtil.CreateEscapedOption(&quot;-e&quot;, env.Key, env.Value));
123                  }
124              }
125              dockerOptions.Add(&quot;-e GITHUB_ACTIONS=true&quot;);
126              if (!container.ContainerEnvironmentVariables.ContainsKey(&quot;CI&quot;))
127              {
128                  dockerOptions.Add(&quot;-e CI=true&quot;);
129              }
130              foreach (var volume in container.MountVolumes)
131              {
132                  String volumeArg;
133                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
134                  {
135                      volumeArg = $&quot;-v \&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
136                  }
137                  else
138                  {
139                      volumeArg = $&quot;-v \&quot;{volume.SourceVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;:\&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
140                  }
141                  if (volume.ReadOnly)
142                  {
143                      volumeArg += &quot;:ro&quot;;
144                  }
145                  dockerOptions.Add(volumeArg);
146              }
147              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
148              {
149                  dockerOptions.Add($&quot;--entrypoint \&quot;{container.ContainerEntryPoint}\&quot;&quot;);
150              }
151              dockerOptions.Add($&quot;{container.ContainerImage}&quot;);
152              dockerOptions.Add($&quot;{container.ContainerEntryPointArgs}&quot;);
153              var optionsString = string.Join(&quot; &quot;, dockerOptions);
154              List&lt;string&gt; outputStrings = await ExecuteDockerCommandAsync(context, &quot;create&quot;, optionsString);
155              return outputStrings.FirstOrDefault();
156          }
157          public async Task&lt;int&gt; DockerRun(IExecutionContext context, ContainerInfo container, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stdoutDataReceived, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stderrDataReceived)
158          {
159              IList&lt;string&gt; dockerOptions = new List&lt;string&gt;();
160              dockerOptions.Add($&quot;--name {container.ContainerDisplayName}&quot;);
161              dockerOptions.Add($&quot;--label {DockerInstanceLabel}&quot;);
162              dockerOptions.Add($&quot;--workdir {container.ContainerWorkDirectory}&quot;);
163              dockerOptions.Add($&quot;--rm&quot;);
164              foreach (var env in container.ContainerEnvironmentVariables)
165              {
166                  dockerOptions.Add(DockerUtil.CreateEscapedOption(&quot;-e&quot;, env.Key));
167              }
168              dockerOptions.Add(&quot;-e GITHUB_ACTIONS=true&quot;);
169              if (!container.ContainerEnvironmentVariables.ContainsKey(&quot;CI&quot;))
170              {
171                  dockerOptions.Add(&quot;-e CI=true&quot;);
172              }
173              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
174              {
175                  dockerOptions.Add($&quot;--entrypoint \&quot;{container.ContainerEntryPoint}\&quot;&quot;);
176              }
177              if (!string.IsNullOrEmpty(container.ContainerNetwork))
178              {
179                  dockerOptions.Add($&quot;--network {container.ContainerNetwork}&quot;);
180              }
181              foreach (var volume in container.MountVolumes)
182              {
183                  String volumeArg;
184                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
185                  {
186                      volumeArg = $&quot;-v \&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
187                  }
188                  else
189                  {
190                      volumeArg = $&quot;-v \&quot;{volume.SourceVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;:\&quot;{volume.TargetVolumePath.Replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)}\&quot;&quot;;
191                  }
192                  if (volume.ReadOnly)
193                  {
194                      volumeArg += &quot;:ro&quot;;
195                  }
196                  dockerOptions.Add(volumeArg);
197              }
198              dockerOptions.Add($&quot;{container.ContainerImage}&quot;);
<span onclick='openModal()' class='match'>199              dockerOptions.Add($&quot;{container.ContainerEntryPointArgs}&quot;);
200              var optionsString = string.Join(&quot; &quot;, dockerOptions);
201              return await ExecuteDockerCommandAsync(context, &quot;run&quot;, optionsString, container.ContainerEnvironmentVariables, stdoutDataReceived, stderrDataReceived, context.CancellationToken);
</span>202          }
203          public async Task&lt;int&gt; DockerStart(IExecutionContext context, string containerId)
204          {
205              return await ExecuteDockerCommandAsync(context, &quot;start&quot;, containerId, context.CancellationToken);
206          }
207          public async Task&lt;int&gt; DockerRemove(IExecutionContext context, string containerId)
208          {
209              return await ExecuteDockerCommandAsync(context, &quot;rm&quot;, $&quot;--force {containerId}&quot;, context.CancellationToken);
210          }
211          public async Task&lt;int&gt; DockerLogs(IExecutionContext context, string containerId)
212          {
213              return await ExecuteDockerCommandAsync(context, &quot;logs&quot;, $&quot;--details {containerId}&quot;, context.CancellationToken);
214          }
215          public async Task&lt;List&lt;string&gt;&gt; DockerPS(IExecutionContext context, string options)
216          {
217              return await ExecuteDockerCommandAsync(context, &quot;ps&quot;, options);
218          }
219          public async Task&lt;int&gt; DockerNetworkCreate(IExecutionContext context, string network)
220          {
221  #if OS_WINDOWS
222              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;create --label {DockerInstanceLabel} {network} --driver nat&quot;, context.CancellationToken);
223  #else
224              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;create --label {DockerInstanceLabel} {network}&quot;, context.CancellationToken);
225  #endif
226          }
227          public async Task&lt;int&gt; DockerNetworkRemove(IExecutionContext context, string network)
228          {
229              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;rm {network}&quot;, context.CancellationToken);
230          }
231          public async Task&lt;int&gt; DockerNetworkPrune(IExecutionContext context)
232          {
233              return await ExecuteDockerCommandAsync(context, &quot;network&quot;, $&quot;prune --force --filter \&quot;label={DockerInstanceLabel}\&quot;&quot;, context.CancellationToken);
234          }
235          public async Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command)
236          {
237              return await ExecuteDockerCommandAsync(context, &quot;exec&quot;, $&quot;{options} {containerId} {command}&quot;, context.CancellationToken);
238          }
239          public async Task&lt;int&gt; DockerExec(IExecutionContext context, string containerId, string options, string command, List&lt;string&gt; output)
240          {
241              ArgUtil.NotNull(output, nameof(output));
242              string arg = $&quot;exec {options} {containerId} {command}&quot;.Trim();
243              context.Command($&quot;{DockerPath} {arg}&quot;);
244              object outputLock = new();
245              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
246              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
247              {
248                  if (!string.IsNullOrEmpty(message.Data))
249                  {
250                      lock (outputLock)
251                      {
252                          output.Add(message.Data);
253                      }
254                  }
255              };
256              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
257              {
258                  if (!string.IsNullOrEmpty(message.Data))
259                  {
260                      lock (outputLock)
261                      {
262                          output.Add(message.Data);
263                      }
264                  }
265              };
266              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
267              {
268                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
269              }
270              return await processInvoker.ExecuteAsync(
271                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
272                              fileName: DockerPath,
273                              arguments: arg,
274                              environment: null,
275                              requireExitCodeZero: false,
276                              outputEncoding: null,
277                              cancellationToken: CancellationToken.None);
278          }
279          public async Task&lt;List&lt;string&gt;&gt; DockerInspect(IExecutionContext context, string dockerObject, string options)
280          {
281              return await ExecuteDockerCommandAsync(context, &quot;inspect&quot;, $&quot;{options} {dockerObject}&quot;);
282          }
283          public async Task&lt;List&lt;PortMapping&gt;&gt; DockerPort(IExecutionContext context, string containerId)
284          {
285              List&lt;string&gt; portMappingLines = await ExecuteDockerCommandAsync(context, &quot;port&quot;, containerId);
286              return DockerUtil.ParseDockerPort(portMappingLines);
287          }
288          public Task&lt;int&gt; DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password)
289          {
290              string args = $&quot;--config {configFileDirectory} login {registry} -u {username} --password-stdin&quot;;
291              context.Command($&quot;{DockerPath} {args}&quot;);
292              var input = Channel.CreateBounded&lt;string&gt;(new BoundedChannelOptions(1) { SingleReader = true, SingleWriter = true });
293              input.Writer.TryWrite(password);
294              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
295              return processInvoker.ExecuteAsync(
296                  workingDirectory: context.GetGitHubContext(&quot;workspace&quot;),
297                  fileName: DockerPath,
298                  arguments: args,
299                  environment: null,
300                  requireExitCodeZero: false,
301                  outputEncoding: null,
302                  killProcessOnCancel: false,
303                  redirectStandardIn: input,
304                  cancellationToken: context.CancellationToken);
305          }
306          private Task&lt;int&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, CancellationToken cancellationToken = default(CancellationToken))
307          {
308              return ExecuteDockerCommandAsync(context, command, options, null, cancellationToken);
309          }
310          private async Task&lt;int&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, IDictionary&lt;string, string&gt; environment, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stdoutDataReceived, EventHandler&lt;ProcessDataReceivedEventArgs&gt; stderrDataReceived, CancellationToken cancellationToken = default(CancellationToken))
311          {
312              string arg = $&quot;{command} {options}&quot;.Trim();
313              context.Command($&quot;{DockerPath} {arg}&quot;);
314              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
315              processInvoker.OutputDataReceived += stdoutDataReceived;
316              processInvoker.ErrorDataReceived += stderrDataReceived;
317              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
318              {
319                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
320              }
321              return await processInvoker.ExecuteAsync(
322                  workingDirectory: context.GetGitHubContext(&quot;workspace&quot;),
323                  fileName: DockerPath,
324                  arguments: arg,
325                  environment: environment,
326                  requireExitCodeZero: false,
327                  outputEncoding: null,
328                  killProcessOnCancel: false,
329                  cancellationToken: cancellationToken);
330          }
331          private async Task&lt;int&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, string workingDirectory, CancellationToken cancellationToken = default(CancellationToken))
332          {
333              string arg = $&quot;{command} {options}&quot;.Trim();
334              context.Command($&quot;{DockerPath} {arg}&quot;);
335              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
336              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
337              {
338                  context.Output(message.Data);
339              };
340              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
341              {
342                  context.Output(message.Data);
343              };
344              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
345              {
346                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
347              }
348              return await processInvoker.ExecuteAsync(
349                  workingDirectory: workingDirectory ?? context.GetGitHubContext(&quot;workspace&quot;),
350                  fileName: DockerPath,
351                  arguments: arg,
352                  environment: null,
353                  requireExitCodeZero: false,
354                  outputEncoding: null,
355                  killProcessOnCancel: false,
356                  redirectStandardIn: null,
357                  cancellationToken: cancellationToken);
358          }
359          private async Task&lt;List&lt;string&gt;&gt; ExecuteDockerCommandAsync(IExecutionContext context, string command, string options)
360          {
361              string arg = $&quot;{command} {options}&quot;.Trim();
362              context.Command($&quot;{DockerPath} {arg}&quot;);
363              List&lt;string&gt; output = new();
364              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
365              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
366              {
367                  if (!string.IsNullOrEmpty(message.Data))
368                  {
369                      output.Add(message.Data);
370                      context.Output(message.Data);
371                  }
372              };
373              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
374              {
375                  if (!string.IsNullOrEmpty(message.Data))
376                  {
377                      context.Output(message.Data);
378                  }
379              };
380              await processInvoker.ExecuteAsync(
381                              workingDirectory: context.GetGitHubContext(&quot;workspace&quot;),
382                              fileName: DockerPath,
383                              arguments: arg,
384                              environment: null,
385                              requireExitCodeZero: true,
386                              outputEncoding: null,
387                              cancellationToken: CancellationToken.None);
388              return output;
389          }
390      }
391  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>152              dockerOptions.Add($&quot;{container.ContainerEntryPointArgs}&quot;);
153              var optionsString = string.Join(&quot; &quot;, dockerOptions);
154              List&lt;string&gt; outputStrings = await ExecuteDockerCommandAsync(context, &quot;create&quot;, optionsString);
</pre></code></div>
                <div class="column column_space"><pre><code>199              dockerOptions.Add($&quot;{container.ContainerEntryPointArgs}&quot;);
200              var optionsString = string.Join(&quot; &quot;, dockerOptions);
201              return await ExecuteDockerCommandAsync(context, &quot;run&quot;, optionsString, container.ContainerEnvironmentVariables, stdoutDataReceived, stderrDataReceived, context.CancellationToken);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    