
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 652, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-GoDummyPathEditor.cs</h3>
            <pre><code>1  using UnityEngine;
2  using UnityEditor;
3  using System.Collections;
4  using System.Linq;
5  using System.Collections.Generic;
6  using System.IO;
7  [CustomEditor( typeof( GoDummyPath ) )]
8  public class GoDummyPathEditor : Editor
9  {
10  	private GoDummyPath _target;
11  	private GUIStyle _labelStyle;
12  	private GUIStyle _indexStyle;
13  	private int _insertIndex = 0;
14  	private float _snapDistance = 5f;
15  	private bool _showNodeDetails;
16  	private bool _fileLoadSaveDetails;
17  	private int _selectedNodeIndex = -1;
18  	#region Monobehaviour and Editor
19  	void OnEnable()
20  	{
21  		_labelStyle = new GUIStyle();
22  		_labelStyle.fontStyle = FontStyle.Bold;
23  		_labelStyle.normal.textColor = Color.white;
24  		_labelStyle.fontSize = 16;
25  		_indexStyle = new GUIStyle();
26  		_indexStyle.fontStyle = FontStyle.Bold;
27  		_indexStyle.normal.textColor = Color.white;
28  		_indexStyle.fontSize = 12;
29  		_target = (GoDummyPath)target;
30  	}
31  	public override void OnInspectorGUI()
32  	{
33  		EditorGUILayout.BeginHorizontal();
34  		EditorGUILayout.PrefixLabel( "Use Standard Handles" );
35  		_target.useStandardHandles = EditorGUILayout.Toggle( _target.useStandardHandles );
36  		EditorGUILayout.EndHorizontal();
37  		EditorGUILayout.BeginHorizontal();
38  		EditorGUILayout.PrefixLabel( "Route Name" );
39  		_target.pathName = EditorGUILayout.TextField( _target.pathName );
40  		EditorGUILayout.EndHorizontal();
41  		if( _target.pathName == string.Empty )
42  			_target.pathName = "route" + Random.Range( 1, 100000 );
43  		EditorGUILayout.BeginHorizontal();
44  		EditorGUILayout.PrefixLabel( "Route Color" );
45  		_target.pathColor = EditorGUILayout.ColorField( _target.pathColor );
46  		EditorGUILayout.EndHorizontal();
47  		EditorGUILayout.BeginHorizontal();
48  		EditorGUILayout.PrefixLabel( "Force Straight Line Path" );
49  		_target.forceStraightLinePath = EditorGUILayout.Toggle( _target.forceStraightLinePath );
50  		EditorGUILayout.EndHorizontal();
51  		EditorGUILayout.BeginHorizontal();
52  		EditorGUILayout.PrefixLabel( "Editor Drawing Resolution" );
53  		_target.pathResolution = EditorGUILayout.IntSlider( _target.pathResolution, 2, 100 );
54  		EditorGUILayout.EndHorizontal();
55  		EditorGUILayout.Separator();
56  		if( _target.nodes.Count > 2 )
57  		{
58  			EditorGUILayout.BeginHorizontal();
59  			EditorGUILayout.PrefixLabel( "Insert Node" );
60  			_insertIndex = EditorGUILayout.IntField( _insertIndex );
61  			if( GUILayout.Button( "Insert" ) )
62  			{
63  				if( _insertIndex >= 0 && _insertIndex < _target.nodes.Count )
64  				{
65  					var copyNodeIndex = _insertIndex == 0 ? 0 : _insertIndex;
66  					var copyNode = _target.nodes[copyNodeIndex];
67  					copyNode.x += 10;
68  					copyNode.z += 10;
69  					insertNodeAtIndex( copyNode, _insertIndex );
70  				}
71  			}
72  			EditorGUILayout.EndHorizontal();
73  		}
74  		if( GUILayout.Button( "Close Path" ) )
75  		{
76  			Undo.RecordObject( _target, "Path Vector Changed" );
77  			closeRoute();
78  			GUI.changed = true;
79  		}
80  		if( GUILayout.Button( "Shift Path to Start at Origin" ) )
81  		{
82  			Undo.RecordObject( _target, "Path Vector Changed" );
83  			var offset = Vector3.zero;
84  			var path = new GoSpline( _target.nodes, _target.forceStraightLinePath );
85  			if( path.splineType == GoSplineType.StraightLine || _target.nodes.Count < 5 )
86  				offset = Vector3.zero - _target.nodes[0];
87  			else
88  				offset = Vector3.zero - _target.nodes[1];
89  			for( var i = 0; i < _target.nodes.Count; i++ )
90  				_target.nodes[i] += offset;
91  			GUI.changed = true;
92  		}
93  		if( GUILayout.Button( "Reverse Path" ) )
94  		{
95  			Undo.RecordObject( _target, "Path Vector Changed" );
96  			_target.nodes.Reverse();
97  			GUI.changed = true;
98  		}
99  		EditorGUILayout.Space();
100  		EditorGUILayout.LabelField( "Save to/Read from Disk" );
101  		EditorGUILayout.Space();
102  		EditorGUILayout.BeginHorizontal();
103  		EditorGUILayout.PrefixLabel( "Serialize and Save Path" );
104  		if( GUILayout.Button( "Save" ) )
105  		{
106  			var path = EditorUtility.SaveFilePanel( "Save path", Application.dataPath + "/StreamingAssets", _target.pathName + ".asset", "asset" );
107  			if( path != string.Empty )
108  			{
109  				persistRouteToDisk( path );
110  				_target.pathName = Path.GetFileName( path ).Replace( ".asset", string.Empty );
111  				GUI.changed = true;
112  			}
113  		}
114  		EditorGUILayout.EndHorizontal();
115  		EditorGUILayout.BeginHorizontal();
116  		EditorGUILayout.PrefixLabel( "Load saved path" );
117  		if( GUILayout.Button( "Load" ) )
118  		{
119  			var path = EditorUtility.OpenFilePanel( "Choose path to load", Path.Combine( Application.dataPath, "StreamingAssets" ), "asset" );
120  			if( path != string.Empty )
121  			{
122  				if( !File.Exists( path ) )
123  				{
124  					EditorUtility.DisplayDialog( "File does not exist", "Path couldn't find the file you specified", "Close" );
125  				}
126  				else
127  				{
128  					_target.nodes = GoSpline.bytesToVector3List( File.ReadAllBytes( path ) );
129  					_target.pathName = Path.GetFileName( path ).Replace( ".asset", string.Empty );
130  					GUI.changed = true;
131  				}
132  			}
133  		}
134  		EditorGUILayout.EndHorizontal();
135  		EditorGUILayout.Space();
136  		_showNodeDetails = EditorGUILayout.Foldout( _showNodeDetails, "Show Node Values" );
137  		if( _showNodeDetails )
138  		{
139  			EditorGUI.indentLevel++;
140  			for( int i = 0; i < _target.nodes.Count; i++ )
141  				_target.nodes[i] = EditorGUILayout.Vector3Field( "Node " + ( i + 1 ), _target.nodes[i] );
142  			EditorGUI.indentLevel--;
143  		}
144  		EditorGUILayout.Space();
145  		EditorGUILayout.HelpBox( "While dragging a node, hold down Ctrl and slowly move the cursor to snap to a nearby point\n\n" +
146  		               "Click the 'Close Path' button to add a new node that will close out the current path.\n\n" +
147  		               "Hold Command while dragging a node to snap in 5 point increments\n\n" +
148  		               "Double click to add a new node at the end of the path\n\n" +
149  					   "Hold down alt while adding a node to prepend the new node at the front of the route\n\n" +
150  		               "Press delete or backspace to delete the selected node\n\n" +
151  		               "NOTE: make sure you have the pan tool selected while editing paths", MessageType.None );
152  		if( GUI.changed )
153  		{
154  			EditorUtility.SetDirty( _target );
155  			Repaint();
156  		}
157  	}
158  	void OnSceneGUI()
159  	{
160  		if( !_target.gameObject.activeSelf )
161  			return;
162  		if( Event.current.type == EventType.mouseDown )
163  		{
164  			var nearestIndex = getNearestNodeForMousePosition( Event.current.mousePosition );
165  			_selectedNodeIndex = nearestIndex;
166  			if( Event.current.clickCount > 1 )
167  			{
168  				var translatedPoint = HandleUtility.GUIPointToWorldRay( Event.current.mousePosition )
169  						.GetPoint( ( _target.transform.position - Camera.current.transform.position ).magnitude );
170  				Undo.RecordObject( _target, "Path Node Added" );
171  				if( Event.current.alt )
172  					insertNodeAtIndex( translatedPoint, 0 );
173  				else
174  					appendNodeAtPoint( translatedPoint );
175  			}
176  		}
177  		if( _selectedNodeIndex >= 0 )
178  		{
179  			if( Event.current.keyCode == KeyCode.Delete || Event.current.keyCode == KeyCode.Backspace )
180  			{
181  				if (_target.nodes.Count > 2) {
182  					Undo.RecordObject( _target, "Path Node Deleted" );
183  					Event.current.Use();
184  					removeNodeAtIndex( _selectedNodeIndex );
185  					_selectedNodeIndex = -1;
186  				}
187  			}
188  		}
189  		if( _target.nodes.Count > 1 )
190  		{
191  			Undo.RecordObject( _target, "Path Vector Changed" );
192  			if( Vector3.Distance( _target.nodes[0], _target.nodes[_target.nodes.Count - 1] ) == 0 )
193  			{
194  				Handles.Label( _target.nodes[0], "  Begin and End", _labelStyle );
195  			}
196  			else
197  			{
198  				Handles.Label( _target.nodes[0], "  Begin", _labelStyle );
199  				Handles.Label( _target.nodes[_target.nodes.Count - 1], "  End", _labelStyle );
200  			}
201  			drawRoute();
202  			for( var i = 0; i < _target.nodes.Count; i++ )
203  			{
204  				Handles.color = _target.pathColor;
205  				if( i > 0 && i < _target.nodes.Count - 1 )
206  					Handles.Label( _target.nodes[i] + new Vector3( 3f, 0, 1.5f ), i.ToString(), _indexStyle );
207  				Handles.color = Color.white;
208  				if( _target.useStandardHandles )
209  				{
210  					_target.nodes[i] = Handles.PositionHandle( _target.nodes[i], Quaternion.identity );
211  				}
212  				else
213  				{
214  					var distanceToTarget = Vector3.Distance( SceneView.lastActiveSceneView.camera.transform.position, _target.transform.position );
215  					distanceToTarget = Mathf.Abs( distanceToTarget );
216  					var handleSize = Mathf.Ceil( distanceToTarget / 75 );
217  					_target.nodes[i] = Handles.FreeMoveHandle( _target.nodes[i],
218  					                        Quaternion.identity,
219  					                        handleSize,
220  					                        new Vector3( 5, 0, 5 ),
221  					                        Handles.SphereCap );
222  				}
223  				if( Event.current.control && _target.nodes.Count > 3 )
224  				{
225  					var index = getNearestNode( _target.nodes[i], i, i + 1, i - 1 );
226  					var nearest = _target.nodes[index];
227  					var distanceToNearestNode = Vector3.Distance( nearest, _target.nodes[i] );
228  					if( distanceToNearestNode <= _snapDistance )
229  					{
230  						GUI.changed = true;
231  						_target.nodes[i] = nearest;
232  					}
233  					else if( distanceToNearestNode <= _snapDistance * 2 )
234  					{
235  						var color = Color.red;
236  						color.a = 0.3f;
237  						Handles.color = color;
238  						Handles.SphereCap( 0, _target.nodes[i], Quaternion.identity, _snapDistance * 2 );
239  						Handles.color = Color.white;
240  					}
241  				}					
242  			} 
243  			if( GUI.changed )
244  			{
245  				Repaint();
246  				EditorUtility.SetDirty( _target );
247  			}
248  		} 
249  	}
250  	#endregion
251  	#region Private methods
252  	private void appendNodeAtPoint( Vector3 node )
253  	{
254  		_target.nodes.Add( node );
<span onclick='openModal()' class='match'>255  		GUI.changed = true;
256  	}
257  	private void removeNodeAtIndex( int index )
258  	{
259  		if( index >= _target.nodes.Count || index < 0 )
260  			return;
261  		_target.nodes.RemoveAt( index );
262  		GUI.changed = true;
263  	}
264  	private void insertNodeAtIndex( Vector3 node, int index )
265  	{
266  		if( index >= 0 && index < _target.nodes.Count )
267  		{
268  			_target.nodes.Insert( index, node );
269  			GUI.changed = true;
270  		}
271  	}
272  	private void drawArrowBetweenPoints( Vector3 point1, Vector3 point2 )
273  	{
274  		var distance = Vector3.Distance( point1, point2 );
275  		if( distance < 40 )
276  			return;
277  		var lerpModifier = ( distance * 0.5f - 25 ) / distance;
278  		Handles.color = _target.pathColor;
279  		var dir = Vector3.Lerp( point1, point2, lerpModifier );
280  		var quat = Quaternion.LookRotation( point2 - point1 );
281  		Handles.ArrowCap( 0, dir, quat, 25 );
282  		Handles.color = Color.white;
283  	}
284  	private int getNearestNode( Vector3 pos, params int[] excludeNodes )
285  	{
286  		var excludeNodesList = new System.Collections.Generic.List<int>( excludeNodes );
287  		var bestDistance = float.MaxValue;
288  		var index = -1;
289  		var distance = float.MaxValue;
290  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
291  		{
292  			if( excludeNodesList.Contains( i ) )
293  				continue;
294  			distance = Vector3.Distance( pos, _target.nodes[i] );
295  			if( distance < bestDistance )
296  			{
297  				bestDistance = distance;
298  				index = i;
299  			}
300  		}
301  		return index;
302  	}
303  	private int getNearestNodeForMousePosition( Vector3 mousePos )
304  	{
305  		var bestDistance = float.MaxValue;
306  		var index = -1;
307  		var distance = float.MaxValue;
308  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
309  		{
310  			var nodeToGui = HandleUtility.WorldToGUIPoint( _target.nodes[i] );
311  			distance = Vector2.Distance( nodeToGui, mousePos );
312  			if( distance < bestDistance )
313  			{
314  				bestDistance = distance;
315  				index = i;
316  			}
317  		}
318  		if( bestDistance < 10 )
319  			return index;
320  		return -1;
321  	}
322  	private void closeRoute()
323  	{
324  		var path = new GoSpline( _target.nodes, _target.forceStraightLinePath );
325  		path.closePath();
326  		_target.nodes = path.nodes;
327  		GUI.changed = true;
328  	}
329  	private void persistRouteToDisk( string path )
330  	{
331  		var bytes = new List<byte>();
332  		foreach( var vec in _target.nodes )
333  		{
334  			bytes.AddRange( System.BitConverter.GetBytes( vec.x ) );
335  			bytes.AddRange( System.BitConverter.GetBytes( vec.y ) );
336  			bytes.AddRange( System.BitConverter.GetBytes( vec.z ) );
337  		}
338  		File.WriteAllBytes( path, bytes.ToArray() );
339  	}
340  	private void drawRoute()
341  	{
342  		if( _target.forceStraightLinePath )
343  		{
344  			for( var i = 0; i < _target.nodes.Count; i++ )
345  			{
346  				Handles.color = _target.pathColor;
347  				if( i < _target.nodes.Count - 1 )
348  				{
349  					Handles.DrawLine( _target.nodes[i], _target.nodes[i + 1] );
350  					drawArrowBetweenPoints( _target.nodes[i], _target.nodes[i + 1] );
351  				}
352  			}
353  		}
354  	}
355  	#endregion
356  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-GoDummyPathEditor_122.cs</h3>
            <pre><code>1  using UnityEngine;
2  using UnityEditor;
3  using System.Collections;
4  using System.Linq;
5  using System.Collections.Generic;
6  using System.IO;
7  [CustomEditor( typeof( GoDummyPath ) )]
8  public class GoDummyPathEditor : Editor
9  {
10  	private GoDummyPath _target;
11  	private GUIStyle _labelStyle;
12  	private GUIStyle _indexStyle;
13  	private int _insertIndex = 0;
14  	private float _snapDistance = 5f;
15  	private bool _showNodeDetails;
16  	private bool _fileLoadSaveDetails;
17  	private int _selectedNodeIndex = -1;
18  	#region Monobehaviour and Editor
19  	void OnEnable()
20  	{
21  		_labelStyle = new GUIStyle();
22  		_labelStyle.fontStyle = FontStyle.Bold;
23  		_labelStyle.normal.textColor = Color.white;
24  		_labelStyle.fontSize = 16;
25  		_indexStyle = new GUIStyle();
26  		_indexStyle.fontStyle = FontStyle.Bold;
27  		_indexStyle.normal.textColor = Color.white;
28  		_indexStyle.fontSize = 12;
29  		_target = (GoDummyPath)target;
30  	}
31  	public override void OnInspectorGUI()
32  	{
33  		EditorGUILayout.BeginHorizontal();
34  		EditorGUILayout.PrefixLabel( "Use Standard Handles" );
35  		_target.useStandardHandles = EditorGUILayout.Toggle( _target.useStandardHandles );
36  		EditorGUILayout.EndHorizontal();
37  		EditorGUILayout.BeginHorizontal();
38  		EditorGUILayout.PrefixLabel( "Route Name" );
39  		_target.pathName = EditorGUILayout.TextField( _target.pathName );
40  		EditorGUILayout.EndHorizontal();
41  		if( _target.pathName == string.Empty )
42  			_target.pathName = "route" + Random.Range( 1, 100000 );
43  		EditorGUILayout.BeginHorizontal();
44  		EditorGUILayout.PrefixLabel( "Route Color" );
45  		_target.pathColor = EditorGUILayout.ColorField( _target.pathColor );
46  		EditorGUILayout.EndHorizontal();
47  		EditorGUILayout.BeginHorizontal();
48  		EditorGUILayout.PrefixLabel( "Force Straight Line Path" );
49  		_target.forceStraightLinePath = EditorGUILayout.Toggle( _target.forceStraightLinePath );
50  		EditorGUILayout.EndHorizontal();
51  		EditorGUILayout.BeginHorizontal();
52  		EditorGUILayout.PrefixLabel( "Editor Drawing Resolution" );
53  		_target.pathResolution = EditorGUILayout.IntSlider( _target.pathResolution, 2, 100 );
54  		EditorGUILayout.EndHorizontal();
55  		EditorGUILayout.Separator();
56  		if( _target.nodes.Count > 2 )
57  		{
58  			EditorGUILayout.BeginHorizontal();
59  			EditorGUILayout.PrefixLabel( "Insert Node" );
60  			_insertIndex = EditorGUILayout.IntField( _insertIndex );
61  			if( GUILayout.Button( "Insert" ) )
62  			{
63  				if( _insertIndex >= 0 && _insertIndex < _target.nodes.Count )
64  				{
65  					var copyNodeIndex = _insertIndex == 0 ? 0 : _insertIndex;
66  					var copyNode = _target.nodes[copyNodeIndex];
67  					copyNode.x += 10;
68  					copyNode.z += 10;
69  					insertNodeAtIndex( copyNode, _insertIndex );
70  				}
71  			}
72  			EditorGUILayout.EndHorizontal();
73  		}
74  		if( GUILayout.Button( "Close Path" ) )
75  		{
76  			Undo.RecordObject( _target, "Path Vector Changed" );
77  			closeRoute();
78  			GUI.changed = true;
79  		}
80  		if( GUILayout.Button( "Shift Path to Start at Origin" ) )
81  		{
82  			Undo.RecordObject( _target, "Path Vector Changed" );
83  			var offset = Vector3.zero;
84  			var path = new GoSpline( _target.nodes, _target.forceStraightLinePath );
85  			if( path.splineType == GoSplineType.StraightLine || _target.nodes.Count < 5 )
86  				offset = Vector3.zero - _target.nodes[0];
87  			else
88  				offset = Vector3.zero - _target.nodes[1];
89  			for( var i = 0; i < _target.nodes.Count; i++ )
90  				_target.nodes[i] += offset;
91  			GUI.changed = true;
92  		}
93  		if( GUILayout.Button( "Reverse Path" ) )
94  		{
95  			Undo.RecordObject( _target, "Path Vector Changed" );
96  			_target.nodes.Reverse();
97  			GUI.changed = true;
98  		}
99  		EditorGUILayout.Space();
100  		EditorGUILayout.LabelField( "Save to/Read from Disk" );
101  		EditorGUILayout.Space();
102  		EditorGUILayout.BeginHorizontal();
103  		EditorGUILayout.PrefixLabel( "Serialize and Save Path" );
104  		if( GUILayout.Button( "Save" ) )
105  		{
106  			var path = EditorUtility.SaveFilePanel( "Save path", Application.dataPath + "/StreamingAssets", _target.pathName + ".asset", "asset" );
107  			if( path != string.Empty )
108  			{
109  				persistRouteToDisk( path );
110  				_target.pathName = Path.GetFileName( path ).Replace( ".asset", string.Empty );
111  				GUI.changed = true;
112  			}
113  		}
114  		EditorGUILayout.EndHorizontal();
115  		EditorGUILayout.BeginHorizontal();
116  		EditorGUILayout.PrefixLabel( "Load saved path" );
117  		if( GUILayout.Button( "Load" ) )
118  		{
119  			var path = EditorUtility.OpenFilePanel( "Choose path to load", Path.Combine( Application.dataPath, "StreamingAssets" ), "asset" );
120  			if( path != string.Empty )
121  			{
122  				if( !File.Exists( path ) )
123  				{
124  					EditorUtility.DisplayDialog( "File does not exist", "Path couldn't find the file you specified", "Close" );
125  				}
126  				else
127  				{
128  					_target.nodes = GoSpline.bytesToVector3List( File.ReadAllBytes( path ) );
129  					_target.pathName = Path.GetFileName( path ).Replace( ".asset", string.Empty );
130  					GUI.changed = true;
131  				}
132  			}
133  		}
134  		EditorGUILayout.EndHorizontal();
135  		EditorGUILayout.Space();
136  		_showNodeDetails = EditorGUILayout.Foldout( _showNodeDetails, "Show Node Values" );
137  		if( _showNodeDetails )
138  		{
139  			EditorGUI.indentLevel++;
140  			for( int i = 0; i < _target.nodes.Count; i++ )
141  				_target.nodes[i] = EditorGUILayout.Vector3Field( "Node " + ( i + 1 ), _target.nodes[i] );
142  			EditorGUI.indentLevel--;
143  		}
144  		EditorGUILayout.Space();
145  		EditorGUILayout.HelpBox( "While dragging a node, hold down Ctrl and slowly move the cursor to snap to a nearby point\n\n" +
146  		               "Click the 'Close Path' button to add a new node that will close out the current path.\n\n" +
147  		               "Hold Command while dragging a node to snap in 5 point increments\n\n" +
148  		               "Double click to add a new node at the end of the path\n\n" +
149  					   "Hold down alt while adding a node to prepend the new node at the front of the route\n\n" +
150  		               "Press delete or backspace to delete the selected node\n\n" +
151  		               "NOTE: make sure you have the pan tool selected while editing paths", MessageType.None );
152  		if( GUI.changed )
153  		{
154  			EditorUtility.SetDirty( _target );
155  			Repaint();
156  		}
157  	}
158  	void OnSceneGUI()
159  	{
160  		if( !_target.gameObject.activeSelf )
161  			return;
162  		if( Event.current.type == EventType.mouseDown )
163  		{
164  			var nearestIndex = getNearestNodeForMousePosition( Event.current.mousePosition );
165  			_selectedNodeIndex = nearestIndex;
166  			if( Event.current.clickCount > 1 )
167  			{
168  				var translatedPoint = HandleUtility.GUIPointToWorldRay( Event.current.mousePosition )
169  						.GetPoint( ( _target.transform.position - Camera.current.transform.position ).magnitude );
170  				Undo.RecordObject( _target, "Path Node Added" );
171  				if( Event.current.alt )
172  					insertNodeAtIndex( translatedPoint, 0 );
173  				else
174  					appendNodeAtPoint( translatedPoint );
175  			}
176  		}
177  		if( _selectedNodeIndex >= 0 )
178  		{
179  			if( Event.current.keyCode == KeyCode.Delete || Event.current.keyCode == KeyCode.Backspace )
180  			{
181  				if (_target.nodes.Count > 2) {
182  					Undo.RecordObject( _target, "Path Node Deleted" );
183  					Event.current.Use();
184  					removeNodeAtIndex( _selectedNodeIndex );
185  					_selectedNodeIndex = -1;
186  				}
187  			}
188  		}
189  		if( _target.nodes.Count > 1 )
190  		{
191  			Undo.RecordObject( _target, "Path Vector Changed" );
192  			if( Vector3.Distance( _target.nodes[0], _target.nodes[_target.nodes.Count - 1] ) == 0 )
193  			{
194  				Handles.Label( _target.nodes[0], "  Begin and End", _labelStyle );
195  			}
196  			else
197  			{
198  				Handles.Label( _target.nodes[0], "  Begin", _labelStyle );
199  				Handles.Label( _target.nodes[_target.nodes.Count - 1], "  End", _labelStyle );
200  			}
201  			drawRoute();
202  			for( var i = 0; i < _target.nodes.Count; i++ )
203  			{
204  				Handles.color = _target.pathColor;
205  				if( i > 0 && i < _target.nodes.Count - 1 )
206  					Handles.Label( _target.nodes[i] + new Vector3( 3f, 0, 1.5f ), i.ToString(), _indexStyle );
207  				Handles.color = Color.white;
208  				if( _target.useStandardHandles )
209  				{
210  					_target.nodes[i] = Handles.PositionHandle( _target.nodes[i], Quaternion.identity );
211  				}
212  				else
213  				{
214  					var distanceToTarget = Vector3.Distance( SceneView.lastActiveSceneView.camera.transform.position, _target.transform.position );
215  					distanceToTarget = Mathf.Abs( distanceToTarget );
216  					var handleSize = Mathf.Ceil( distanceToTarget / 75 );
217  					_target.nodes[i] = Handles.FreeMoveHandle( _target.nodes[i],
218  					                        Quaternion.identity,
219  					                        handleSize,
220  					                        new Vector3( 5, 0, 5 ),
221  					                        Handles.SphereCap );
222  				}
223  				if( Event.current.control && _target.nodes.Count > 3 )
224  				{
225  					var index = getNearestNode( _target.nodes[i], i, i + 1, i - 1 );
226  					var nearest = _target.nodes[index];
227  					var distanceToNearestNode = Vector3.Distance( nearest, _target.nodes[i] );
228  					if( distanceToNearestNode <= _snapDistance )
229  					{
230  						GUI.changed = true;
231  						_target.nodes[i] = nearest;
232  					}
233  					else if( distanceToNearestNode <= _snapDistance * 2 )
234  					{
235  						var color = Color.red;
236  						color.a = 0.3f;
237  						Handles.color = color;
238  						Handles.SphereCap( 0, _target.nodes[i], Quaternion.identity, _snapDistance * 2 );
239  						Handles.color = Color.white;
240  					}
241  				}					
242  			} 
243  			if( GUI.changed )
244  			{
245  				Repaint();
246  				EditorUtility.SetDirty( _target );
247  			}
248  		} 
249  	}
250  	#endregion
251  	#region Private methods
252  	private void appendNodeAtPoint( Vector3 node )
253  	{
254  		_target.nodes.Add( node );
<span onclick='openModal()' class='match'>255  		GUI.changed = true;
256  	}
257  	private void removeNodeAtIndex( int index )
258  	{
259  		if( index >= _target.nodes.Count || index < 0 )
260  			return;
261  		_target.nodes.RemoveAt( index );
262  		GUI.changed = true;
263  	}
264  	private void insertNodeAtIndex( Vector3 node, int index )
265  	{
266  		if( index >= 0 && index < _target.nodes.Count )
267  		{
268  			_target.nodes.Insert( index, node );
269  			GUI.changed = true;
270  		}
271  	}
272  	private void drawArrowBetweenPoints( Vector3 point1, Vector3 point2 )
273  	{
274  		var distance = Vector3.Distance( point1, point2 );
275  		if( distance < 40 )
276  			return;
277  		var lerpModifier = ( distance * 0.5f - 25 ) / distance;
278  		Handles.color = _target.pathColor;
279  		var dir = Vector3.Lerp( point1, point2, lerpModifier );
280  		var quat = Quaternion.LookRotation( point2 - point1 );
281  		Handles.ArrowCap( 0, dir, quat, 25 );
282  		Handles.color = Color.white;
283  	}
284  	private int getNearestNode( Vector3 pos, params int[] excludeNodes )
285  	{
286  		var excludeNodesList = new System.Collections.Generic.List<int>( excludeNodes );
287  		var bestDistance = float.MaxValue;
288  		var index = -1;
289  		var distance = float.MaxValue;
290  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
291  		{
292  			if( excludeNodesList.Contains( i ) )
293  				continue;
294  			distance = Vector3.Distance( pos, _target.nodes[i] );
295  			if( distance < bestDistance )
296  			{
297  				bestDistance = distance;
298  				index = i;
299  			}
300  		}
301  		return index;
302  	}
303  	private int getNearestNodeForMousePosition( Vector3 mousePos )
304  	{
305  		var bestDistance = float.MaxValue;
306  		var index = -1;
307  		var distance = float.MaxValue;
308  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
309  		{
310  			var nodeToGui = HandleUtility.WorldToGUIPoint( _target.nodes[i] );
311  			distance = Vector2.Distance( nodeToGui, mousePos );
312  			if( distance < bestDistance )
313  			{
314  				bestDistance = distance;
315  				index = i;
316  			}
317  		}
318  		if( bestDistance < 10 )
319  			return index;
320  		return -1;
321  	}
322  	private void closeRoute()
323  	{
324  		var path = new GoSpline( _target.nodes, _target.forceStraightLinePath );
325  		path.closePath();
326  		_target.nodes = path.nodes;
327  		GUI.changed = true;
328  	}
329  	private void persistRouteToDisk( string path )
330  	{
331  		var bytes = new List<byte>();
332  		foreach( var vec in _target.nodes )
333  		{
334  			bytes.AddRange( System.BitConverter.GetBytes( vec.x ) );
335  			bytes.AddRange( System.BitConverter.GetBytes( vec.y ) );
336  			bytes.AddRange( System.BitConverter.GetBytes( vec.z ) );
337  		}
338  		File.WriteAllBytes( path, bytes.ToArray() );
339  	}
340  	private void drawRoute()
341  	{
342  		if( _target.forceStraightLinePath )
343  		{
344  			for( var i = 0; i < _target.nodes.Count; i++ )
345  			{
346  				Handles.color = _target.pathColor;
347  				if( i < _target.nodes.Count - 1 )
348  				{
349  					Handles.DrawLine( _target.nodes[i], _target.nodes[i + 1] );
350  					drawArrowBetweenPoints( _target.nodes[i], _target.nodes[i + 1] );
351  				}
352  			}
353  		}
354  	}
355  	#endregion
356  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-GoDummyPathEditor.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-GoDummyPathEditor_122.cs</div>
                </div>
                <div class="column column_space"><pre><code>255  		GUI.changed = true;
256  	}
257  	private void removeNodeAtIndex( int index )
258  	{
259  		if( index >= _target.nodes.Count || index < 0 )
260  			return;
261  		_target.nodes.RemoveAt( index );
262  		GUI.changed = true;
263  	}
264  	private void insertNodeAtIndex( Vector3 node, int index )
265  	{
266  		if( index >= 0 && index < _target.nodes.Count )
267  		{
268  			_target.nodes.Insert( index, node );
269  			GUI.changed = true;
270  		}
271  	}
272  	private void drawArrowBetweenPoints( Vector3 point1, Vector3 point2 )
273  	{
274  		var distance = Vector3.Distance( point1, point2 );
275  		if( distance < 40 )
276  			return;
277  		var lerpModifier = ( distance * 0.5f - 25 ) / distance;
278  		Handles.color = _target.pathColor;
279  		var dir = Vector3.Lerp( point1, point2, lerpModifier );
280  		var quat = Quaternion.LookRotation( point2 - point1 );
281  		Handles.ArrowCap( 0, dir, quat, 25 );
282  		Handles.color = Color.white;
283  	}
284  	private int getNearestNode( Vector3 pos, params int[] excludeNodes )
285  	{
286  		var excludeNodesList = new System.Collections.Generic.List<int>( excludeNodes );
287  		var bestDistance = float.MaxValue;
288  		var index = -1;
289  		var distance = float.MaxValue;
290  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
291  		{
292  			if( excludeNodesList.Contains( i ) )
293  				continue;
294  			distance = Vector3.Distance( pos, _target.nodes[i] );
295  			if( distance < bestDistance )
296  			{
297  				bestDistance = distance;
298  				index = i;
299  			}
300  		}
301  		return index;
302  	}
303  	private int getNearestNodeForMousePosition( Vector3 mousePos )
304  	{
305  		var bestDistance = float.MaxValue;
306  		var index = -1;
307  		var distance = float.MaxValue;
308  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
309  		{
310  			var nodeToGui = HandleUtility.WorldToGUIPoint( _target.nodes[i] );
311  			distance = Vector2.Distance( nodeToGui, mousePos );
312  			if( distance < bestDistance )
313  			{
314  				bestDistance = distance;
315  				index = i;
316  			}
317  		}
318  		if( bestDistance < 10 )
319  			return index;
320  		return -1;
321  	}
322  	private void closeRoute()
323  	{
324  		var path = new GoSpline( _target.nodes, _target.forceStraightLinePath );
325  		path.closePath();
326  		_target.nodes = path.nodes;
327  		GUI.changed = true;
328  	}
329  	private void persistRouteToDisk( string path )
330  	{
331  		var bytes = new List<byte>();
332  		foreach( var vec in _target.nodes )
333  		{
334  			bytes.AddRange( System.BitConverter.GetBytes( vec.x ) );
335  			bytes.AddRange( System.BitConverter.GetBytes( vec.y ) );
336  			bytes.AddRange( System.BitConverter.GetBytes( vec.z ) );
337  		}
338  		File.WriteAllBytes( path, bytes.ToArray() );
339  	}
340  	private void drawRoute()
341  	{
342  		if( _target.forceStraightLinePath )
343  		{
344  			for( var i = 0; i < _target.nodes.Count; i++ )
345  			{
346  				Handles.color = _target.pathColor;
347  				if( i < _target.nodes.Count - 1 )
348  				{
349  					Handles.DrawLine( _target.nodes[i], _target.nodes[i + 1] );
350  					drawArrowBetweenPoints( _target.nodes[i], _target.nodes[i + 1] );
351  				}
352  			}
353  		}
354  	}
355  	#endregion
356  }
</pre></code></div>
                <div class="column column_space"><pre><code>255  		GUI.changed = true;
256  	}
257  	private void removeNodeAtIndex( int index )
258  	{
259  		if( index >= _target.nodes.Count || index < 0 )
260  			return;
261  		_target.nodes.RemoveAt( index );
262  		GUI.changed = true;
263  	}
264  	private void insertNodeAtIndex( Vector3 node, int index )
265  	{
266  		if( index >= 0 && index < _target.nodes.Count )
267  		{
268  			_target.nodes.Insert( index, node );
269  			GUI.changed = true;
270  		}
271  	}
272  	private void drawArrowBetweenPoints( Vector3 point1, Vector3 point2 )
273  	{
274  		var distance = Vector3.Distance( point1, point2 );
275  		if( distance < 40 )
276  			return;
277  		var lerpModifier = ( distance * 0.5f - 25 ) / distance;
278  		Handles.color = _target.pathColor;
279  		var dir = Vector3.Lerp( point1, point2, lerpModifier );
280  		var quat = Quaternion.LookRotation( point2 - point1 );
281  		Handles.ArrowCap( 0, dir, quat, 25 );
282  		Handles.color = Color.white;
283  	}
284  	private int getNearestNode( Vector3 pos, params int[] excludeNodes )
285  	{
286  		var excludeNodesList = new System.Collections.Generic.List<int>( excludeNodes );
287  		var bestDistance = float.MaxValue;
288  		var index = -1;
289  		var distance = float.MaxValue;
290  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
291  		{
292  			if( excludeNodesList.Contains( i ) )
293  				continue;
294  			distance = Vector3.Distance( pos, _target.nodes[i] );
295  			if( distance < bestDistance )
296  			{
297  				bestDistance = distance;
298  				index = i;
299  			}
300  		}
301  		return index;
302  	}
303  	private int getNearestNodeForMousePosition( Vector3 mousePos )
304  	{
305  		var bestDistance = float.MaxValue;
306  		var index = -1;
307  		var distance = float.MaxValue;
308  		for( var i = _target.nodes.Count - 1; i >= 0; i-- )
309  		{
310  			var nodeToGui = HandleUtility.WorldToGUIPoint( _target.nodes[i] );
311  			distance = Vector2.Distance( nodeToGui, mousePos );
312  			if( distance < bestDistance )
313  			{
314  				bestDistance = distance;
315  				index = i;
316  			}
317  		}
318  		if( bestDistance < 10 )
319  			return index;
320  		return -1;
321  	}
322  	private void closeRoute()
323  	{
324  		var path = new GoSpline( _target.nodes, _target.forceStraightLinePath );
325  		path.closePath();
326  		_target.nodes = path.nodes;
327  		GUI.changed = true;
328  	}
329  	private void persistRouteToDisk( string path )
330  	{
331  		var bytes = new List<byte>();
332  		foreach( var vec in _target.nodes )
333  		{
334  			bytes.AddRange( System.BitConverter.GetBytes( vec.x ) );
335  			bytes.AddRange( System.BitConverter.GetBytes( vec.y ) );
336  			bytes.AddRange( System.BitConverter.GetBytes( vec.z ) );
337  		}
338  		File.WriteAllBytes( path, bytes.ToArray() );
339  	}
340  	private void drawRoute()
341  	{
342  		if( _target.forceStraightLinePath )
343  		{
344  			for( var i = 0; i < _target.nodes.Count; i++ )
345  			{
346  				Handles.color = _target.pathColor;
347  				if( i < _target.nodes.Count - 1 )
348  				{
349  					Handles.DrawLine( _target.nodes[i], _target.nodes[i + 1] );
350  					drawArrowBetweenPoints( _target.nodes[i], _target.nodes[i + 1] );
351  				}
352  			}
353  		}
354  	}
355  	#endregion
356  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    