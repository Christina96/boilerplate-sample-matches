
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 66, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-LeanTween.cs</h3>
            <pre><code>1  using UnityEngine;
2  using System.Collections;
3  using System;
4  public enum LeanTweenType{
5  	notUsed, linear, easeOutQuad, easeInQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart, 
6  	easeInQuint, easeOutQuint, easeInOutQuint, easeInSine, easeOutSine, easeInOutSine, easeInExpo, easeOutExpo, easeInOutExpo, easeInCirc, easeOutCirc, easeInOutCirc, 
7  	easeInBounce, easeOutBounce, easeInOutBounce, easeInBack, easeOutBack, easeInOutBack, easeInElastic, easeOutElastic, easeInOutElastic, easeSpring, easeShake, punch, once, clamp, pingPong, animationCurve
8  }
9  public class LTDescr{
10  	public bool toggle;
11  	public bool useEstimatedTime;
12  	public bool useFrames;
13  	public bool hasInitiliazed;
14  	public bool hasPhysics;
15  	public float passed;
16  	public float delay;
17  	public float time;
18  	public float lastVal;
19  	private uint _id;
20  	public int loopCount;
21  	public uint counter;
22  	public float direction;
23  	public bool destroyOnComplete;
24  	public Transform trans;
25  	public LTRect ltRect;
26  	public Vector3 from;
27  	public Vector3 to;
28  	public Vector3 diff;
29  	public Vector3 point;
30  	public Vector3 axis;
31  	public Vector3 origRotation;
32  	public LTBezierPath path;
33  	public LTSpline spline;
34  	public TweenAction type;
35  	public LeanTweenType tweenType;
36  	public AnimationCurve animationCurve;
37  	public LeanTweenType loopType;
38  	public Action&lt;float&gt; onUpdateFloat;
39  	public Action&lt;float,object&gt; onUpdateFloatObject;
40  	public Action&lt;Vector3&gt; onUpdateVector3;
41  	public Action&lt;Vector3,object&gt; onUpdateVector3Object;
42  	public Action onComplete;
43  	public Action&lt;object&gt; onCompleteObject;
44  	public object onCompleteParam;
45  	public object onUpdateParam;
46  	#if !UNITY_METRO
47  	public Hashtable optional;
48  	#endif
49  	private static uint global_counter = 0;
50      public override string ToString(){
51  		return (trans!=null ? &quot;gameObject:&quot;+trans.gameObject : &quot;gameObject:null&quot;)+&quot; toggle:&quot;+toggle+&quot; passed:&quot;+passed+&quot; time:&quot;+time+&quot; delay:&quot;+delay+&quot; from:&quot;+from+&quot; to:&quot;+to+&quot; type:&quot;+type+&quot; useEstimatedTime:&quot;+useEstimatedTime+&quot; id:&quot;+id+&quot; hasInitiliazed:&quot;+hasInitiliazed;
52  	}
53  	public LTDescr(){
54  	}
55  	public LTDescr cancel(){
56  		LeanTween.removeTween((int)this._id);
57  		return this;
58  	}
59  	public int uniqueId{
60  		get{ 
61  			uint toId = _id | counter &lt;&lt; 16;
62  			return (int)toId;
63  		}
64  	}
65  	public int id{
66  		get{ 
67  			return uniqueId;
68  		}
69  	}
70  	public void reset(){
71  		this.toggle = true;
72  		#if !UNITY_METRO
73  		this.optional = null;
74  		#endif
75  		this.destroyOnComplete = false;
76  		this.passed = this.delay = 0.0f;
77  		this.useEstimatedTime = this.useFrames = this.hasInitiliazed = false;
78  		this.animationCurve = null;
79  		this.tweenType = LeanTweenType.linear;
80  		this.loopType = LeanTweenType.once;
81  		this.loopCount = 0;
82  		this.direction = this.lastVal = 1.0f;
83  		this.onUpdateFloat = null;
84  		this.onUpdateVector3 = null;
85  		this.onUpdateFloatObject = null;
86  		this.onUpdateVector3Object = null;
87  		this.onComplete = null;
88  		this.onCompleteObject = null;
89  		this.onCompleteParam = null;
90  		this.point = Vector3.zero;
91  		global_counter++;
92  	}
93  	public LTDescr pause(){
94  		if(this.direction != 0.0f){ 
95          	this.lastVal =  this.direction;
96              this.direction = 0.0f;
97          }
98          return this;
99  	}
100  	public LTDescr resume(){
101  		this.direction = this.lastVal;
102  		return this;
103  	}
104  	public LTDescr setAxis( Vector3 axis ){
105  		this.axis = axis;
106  		return this;
107  	}
108  	public LTDescr setDelay( float delay ){
109  		if(this.useEstimatedTime){
110  			this.delay = delay;
111  		}else{
112  			this.delay = delay*Time.timeScale;
113  		}
114  		return this;
115  	}
116  	public LTDescr setEase( LeanTweenType easeType ){
117  		this.tweenType = easeType;
118  		return this;
119  	}
120  	public LTDescr setEase( AnimationCurve easeCurve ){
121  		this.animationCurve = easeCurve;
122  		return this;
123  	}
124  	public LTDescr setTo( Vector3 to ){
125  		this.to = to;
126  		return this;
127  	}
128  	public LTDescr setFrom( Vector3 from ){
129  		this.from = from;
130  		this.hasInitiliazed = true; 
131  		this.diff = this.to - this.from;
132  		return this;
133  	}
134  	public LTDescr setId( uint id ){
135  		this._id = id;
136  		this.counter = global_counter;
137  		return this;
138  	}
139  	public LTDescr setRepeat( int repeat ){
140  		this.loopCount = repeat;
141  		if((repeat&gt;1 &amp;&amp; this.loopType == LeanTweenType.once) || (repeat &lt; 0 &amp;&amp; this.loopType == LeanTweenType.once)){
142  			this.loopType = LeanTweenType.clamp;
143  		}
144  		return this;
145  	}
146  	public LTDescr setLoopType( LeanTweenType loopType ){
147  		this.loopType = loopType;
148  		return this;
149  	}
150  	public LTDescr setUseEstimatedTime( bool useEstimatedTime ){
151  		this.useEstimatedTime = useEstimatedTime;
152  		return this;
153  	}
154  	public LTDescr setUseFrames( bool useFrames ){
155  		this.useFrames = useFrames;
156  		return this;
157  	}
158  	public LTDescr setLoopCount( int loopCount ){
159  		this.loopCount = loopCount;
160  		return this;
161  	}
162  	public LTDescr setLoopOnce(){ this.loopType = LeanTweenType.once; return this; }
163  	public LTDescr setLoopClamp(){ 
164  		this.loopType = LeanTweenType.clamp; 
165  		if(this.loopCount==0)
166  			this.loopCount = -1;
167  		return this;
168  	}
169  	public LTDescr setLoopPingPong(){ 
170  		this.loopType = LeanTweenType.pingPong;
171  		if(this.loopCount==0)
172  			this.loopCount = -1;
173  		return this; 
174  	}
175  	public LTDescr setOnComplete( Action onComplete ){
176  		this.onComplete = onComplete;
177  		return this;
178  	}
179  	public LTDescr setOnComplete( Action&lt;object&gt; onComplete ){
180  		this.onCompleteObject = onComplete;
181  		return this;
182  	}
183  	public LTDescr setOnComplete( Action&lt;object&gt; onComplete, object onCompleteParam ){
184  		this.onCompleteObject = onComplete;
185  		if(onCompleteParam!=null)
186  			this.onCompleteParam = onCompleteParam;
187  		return this;
188  	}
189  	public LTDescr setOnCompleteParam( object onCompleteParam ){
190  		this.onCompleteParam = onCompleteParam;
191  		return this;
192  	}
193  	public LTDescr setOnUpdate( Action&lt;float&gt; onUpdate ){
194  		this.onUpdateFloat = onUpdate;
195  		return this;
196  	}
197  	public LTDescr setOnUpdateObject( Action&lt;float,object&gt; onUpdate ){
198  		this.onUpdateFloatObject = onUpdate;
199  		return this;
200  	}
201  	public LTDescr setOnUpdateVector3( Action&lt;Vector3&gt; onUpdate ){
202  		this.onUpdateVector3 = onUpdate;
203  		return this;
204  	}
205  	#if !UNITY_FLASH
206  	public LTDescr setOnUpdate( Action&lt;float,object&gt; onUpdate, object onUpdateParam = null ){
207  		this.onUpdateFloatObject = onUpdate;
208  		if(onUpdateParam!=null)
209  			this.onUpdateParam = onUpdateParam;
210  		return this;
211  	}
212  	public LTDescr setOnUpdate( Action&lt;Vector3,object&gt; onUpdate, object onUpdateParam = null ){
213  		this.onUpdateVector3Object = onUpdate;
214  		if(onUpdateParam!=null)
215  			this.onUpdateParam = onUpdateParam;
216  		return this;
217  	}
218  	public LTDescr setOnUpdate( Action&lt;Vector3&gt; onUpdate, object onUpdateParam = null ){
219  		this.onUpdateVector3 = onUpdate;
220  		if(onUpdateParam!=null)
221  			this.onUpdateParam = onUpdateParam;
222  		return this;
223  	}
224  	#endif
225  	public LTDescr setOnUpdateParam( object onUpdateParam ){
226  		this.onUpdateParam = onUpdateParam;
227  		return this;
228  	}
229  	public LTDescr setOrientToPath( bool doesOrient ){
230  		if(this.type==TweenAction.MOVE_CURVED || this.type==TweenAction.MOVE_CURVED_LOCAL){
231  			if(this.path==null)
232  				this.path = new LTBezierPath();
233  			this.path.orientToPath = doesOrient;
234  		}else{
235  			this.spline.orientToPath = doesOrient;
236  		}
237  		return this;
238  	}
239  	public LTDescr setRect( LTRect rect ){
240  		this.ltRect = rect;
241  		return this;
242  	}
243  	public LTDescr setRect( Rect rect ){
244  		this.ltRect = new LTRect(rect);
245  		return this;
246  	}
247  	public LTDescr setPath( LTBezierPath path ){
248  		this.path = path;
249  		return this;
250  	}
251  	public LTDescr setPoint( Vector3 point ){
252  		this.point = point;
253  		return this;
254  	}
255  	public LTDescr setDestroyOnComplete( bool doesDestroy ){
256  		this.destroyOnComplete = doesDestroy;
257  		return this;
258  	}
259  	public LTDescr setAudio( object audio ){
260  		this.onCompleteParam = audio;
261  		return this;
262  	}
263  }
264  [System.Serializable]
265  public class LTRect : System.Object{
266  	public Rect _rect;
267  	public float alpha = 1f;
268  	public float rotation;
269  	public Vector2 pivot;
270  	public Vector2 margin;
271  	public Rect relativeRect = new Rect(0f,0f,float.PositiveInfinity,float.PositiveInfinity);
272  	public bool rotateEnabled;
273  	[HideInInspector]
274  	public bool rotateFinished;
275  	public bool alphaEnabled;
276  	public string labelStr;
277  	public LTGUI.Element_Type type;
278  	public GUIStyle style;
279  	public bool useColor = false;
280  	public Color color = Color.white;
281  	public bool fontScaleToFit;
282  	public bool useSimpleScale;
283  	public bool sizeByHeight;
284  	public Texture texture;
285  	private int _id = -1;
286  	[HideInInspector]
287  	public int counter;
288  	public static bool colorTouched;
289  	public LTRect(){
290  		reset();
291  		this.rotateEnabled = this.alphaEnabled = true;
292  		_rect = new Rect(0f,0f,1f,1f);
293  	}
294  	public LTRect(Rect rect){
295  		_rect = rect;
296  		reset();
297  	}
298  	public LTRect(float x, float y, float width, float height){
299  		_rect = new Rect(x,y,width,height);
300  		this.alpha = 1.0f;
301  		this.rotation = 0.0f;
302  		this.rotateEnabled = this.alphaEnabled = false;
303  	}
304  	public LTRect(float x, float y, float width, float height, float alpha){
305  		_rect = new Rect(x,y,width,height);
306  		this.alpha = alpha;
307  		this.rotation = 0.0f;
308  		this.rotateEnabled = this.alphaEnabled = false;
309  	}
310  	public LTRect(float x, float y, float width, float height, float alpha, float rotation){
311  		_rect = new Rect(x,y,width,height);
312  		this.alpha = alpha;
313  		this.rotation = rotation;
314  		this.rotateEnabled = this.alphaEnabled = false;
315  		if(rotation!=0.0f){
316  			this.rotateEnabled = true;
317  			resetForRotation();
318  		}
319  	}
320  	public bool hasInitiliazed{
321  		get{ 
322  			return _id!=-1;
323  		}
324  	}
325  	public int id{
326  		get{ 
327  			int toId = _id | counter &lt;&lt; 16;
328  			return toId;
329  		}
330  	} 
331  	public void setId( int id, int counter){
332  		this._id = id;
333  		this.counter = counter;
334  	}
335  	public void reset(){
336  		this.alpha = 1.0f;
337  		this.rotation = 0.0f;
338  		this.rotateEnabled = this.alphaEnabled = false;
339  		this.margin = Vector2.zero;
340  		this.sizeByHeight = false;
341  		this.useColor = false;
342  	}
343  	public void resetForRotation(){
344  		Vector3 scale = new Vector3(GUI.matrix[0,0], GUI.matrix[1,1], GUI.matrix[2,2]);
345          if(pivot==Vector2.zero){
346              pivot = new Vector2((_rect.x+((_rect.width)*0.5f )) * scale.x + GUI.matrix[0,3], (_rect.y+((_rect.height)*0.5f )) * scale.y + GUI.matrix[1,3]);
347          }
348  	}
349  	public float x{
350  		get{ return _rect.x; }
351  		set{ _rect.x = value; }
352  	}
353  	public float y{
354  		get{ return _rect.y; }
355  		set{ _rect.y = value; }
356  	}
357  	public float width{
358  		get{ return _rect.width; }
359  		set{ _rect.width = value; }
360  	}
361  	public float height{
362  		get{ return _rect.height; }
363  		set{ _rect.height = value; }
364  	}
365  	public Rect rect{
366  		get{
367  			if(colorTouched){
368  				colorTouched = false;
369  				GUI.color = new Color(GUI.color.r,GUI.color.g,GUI.color.b,1.0f);
370  			}
371  			if(rotateEnabled){
372  				 if(rotateFinished){
373                      rotateFinished = false;
374                      rotateEnabled = false;
375                      pivot = Vector2.zero;
376                  }else{
377                      GUIUtility.RotateAroundPivot(rotation, pivot);
378                  }
379  			}
380  			if(alphaEnabled){
381  				GUI.color = new Color(GUI.color.r,GUI.color.g,GUI.color.b,alpha);
382  				colorTouched = true;
383  			}
384  			if(fontScaleToFit){
385  				if(this.useSimpleScale){
386  					style.fontSize = (int)(_rect.height*this.relativeRect.height);
387  				}else{
388  					style.fontSize = (int)_rect.height;
389  				}
390  			}
391  			return _rect;
392  		}
393  		set{
394  			_rect = value;
395  		}	
396  	}
397  	public LTRect setStyle( GUIStyle style ){
398  		this.style = style;
399  		return this;
400  	}
401  	public LTRect setFontScaleToFit( bool fontScaleToFit ){
402  		this.fontScaleToFit = fontScaleToFit;
403  		return this;
404  	}
405  	public LTRect setColor( Color color ){
406  		this.color = color;
407  		this.useColor = true;
408  		return this;
409  	}
410  	public LTRect setAlpha( float alpha ){
411  		this.alpha = alpha;
412  		return this;
413  	}
414  	public LTRect setLabel( String str ){
415  		this.labelStr = str;
416  		return this;
417  	}
418  	public LTRect setUseSimpleScale( bool useSimpleScale, Rect relativeRect){
419  		this.useSimpleScale = useSimpleScale;
420  		this.relativeRect = relativeRect;
421  		return this;
422  	}
423  	public LTRect setUseSimpleScale( bool useSimpleScale){
424  		this.useSimpleScale = useSimpleScale;
425  		this.relativeRect = new Rect(0f,0f,Screen.width,Screen.height);
426  		return this;
427  	}
428  	public LTRect setSizeByHeight( bool sizeByHeight){
429  		this.sizeByHeight = sizeByHeight;
430  		return this;
431  	}
432  	public override string ToString(){
433  		return &quot;x:&quot;+_rect.x+&quot; y:&quot;+_rect.y+&quot; width:&quot;+_rect.width+&quot; height:&quot;+_rect.height;
434  	}
435  }
436  public class LTBezier{
437  	public float length;
438  	private Vector3 a;
439  	private Vector3 aa;
440  	private Vector3 bb;
441  	private Vector3 cc;
442  	private float len;
443  	private float[] arcLengths;
444  	public LTBezier(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float precision){
445  		this.a = a;
446  	    aa = (-a + 3*(b-c) + d);
447  	    bb = 3*(a+c) - 6*b;
448  	    cc = 3*(b-a);
449  	    this.len = 1.0f / precision;
450  	    arcLengths = new float[(int)this.len + (int)1];
451  	    arcLengths[0] = 0;
452  	    Vector3 ov = a;
453  	    Vector3 v;
454  	    float clen = 0.0f;
455  	    for(int i = 1; i &lt;= this.len; i++) {
456  	        v = bezierPoint(i * precision);
457  	        clen += (ov - v).magnitude;
458  	        this.arcLengths[i] = clen;
459  	        ov = v;
460  	    }
461  	    this.length = clen;
462  	}
463      private float map(float u) {
464          float targetLength = u * this.arcLengths[(int)this.len];
465          int low = 0;
466          int high = (int)this.len;
467          int index = 0;
468          while (low &lt; high) {
469              index = low + ((int)((high - low) / 2.0f) | 0);
470              if (this.arcLengths[index] &lt; targetLength) {
471                  low = index + 1;
472              } else {
473                  high = index;
474              }
475          }
476          if(this.arcLengths[index] &gt; targetLength)
477              index--;
478          if(index&lt;0)
479          	index = 0;
480          return (index + (targetLength - arcLengths[index]) / (arcLengths[index + 1] - arcLengths[index])) / this.len;
481      }
482     	private Vector3 bezierPoint(float t){
483  	    return ((aa* t + (bb))* t + cc)* t + a;
484  	}
485      public Vector3 point(float t){ 
486      	return bezierPoint( map(t) ); 
487      }
488  }
489  public class LTBezierPath{
490  	public Vector3[] pts;
491  	public float length;
492  	public bool orientToPath;
493  	private LTBezier[] beziers;
494  	private float[] lengthRatio;
495  	public LTBezierPath(){ }
496  	public LTBezierPath( Vector3[] pts_ ){
497  		setPoints( pts_ );
498  	}
499  	public void setPoints( Vector3[] pts_ ){
500  		if(pts_.Length&lt;4)
501  			LeanTween.logError( &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot; );
502  		if(pts_.Length%4!=0)
503  			LeanTween.logError( &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot; );
504  		pts = pts_;
505  		int k = 0;
506  		beziers = new LTBezier[ pts.Length / 4 ];
507  		lengthRatio = new float[ beziers.Length ];
508  		int i;
509  		length = 0;
510  		for(i = 0; i &lt; pts.Length; i+=4){
511  			beziers[k] = new LTBezier(pts[i+0],pts[i+2],pts[i+1],pts[i+3],0.05f);
512  			length += beziers[k].length;
513  			k++;
514  		}
515  		for(i = 0; i &lt; beziers.Length; i++){
516  			lengthRatio[i] = beziers[i].length / length;
517  		}
518  	}
519  	public Vector3 point( float ratio ){
520  		float added = 0.0f;
521  		for(int i = 0; i &lt; lengthRatio.Length; i++){
522  			added += lengthRatio[i];
523  			if(added &gt;= ratio)
524  				return beziers[i].point( (ratio-(added-lengthRatio[i])) / lengthRatio[i] );
525  		}
526  		return beziers[lengthRatio.Length-1].point( 1.0f );
527  	}
528  	public void place( Transform transform, float ratio ){
529  		place( transform, ratio, Vector3.up );
530  	}
531  	public void place( Transform transform, float ratio, Vector3 worldUp ){
532  		transform.position = point( ratio );
533  		ratio += 0.001f;
534  		if(ratio&lt;=1.0f)
535  			transform.LookAt( point( ratio ), worldUp );
536  	}
537  	public void placeLocal( Transform transform, float ratio ){
538  		placeLocal( transform, ratio, Vector3.up );
539  	}
540  	public void placeLocal( Transform transform, float ratio, Vector3 worldUp ){
541  		transform.localPosition = point( ratio );
542  		ratio += 0.001f;
543  		if(ratio&lt;=1.0f)
544  			transform.LookAt( transform.parent.TransformPoint( point( ratio ) ), worldUp );
545  	}
546  }
547  [System.Serializable]
548  public class LTSpline {
549  	public Vector3[] pts;
550  	public bool orientToPath;
551  	private float[] lengthRatio;
552  	private float[] lengths;
553  	private int numSections;
554  	private int currPt;
555  	private float totalLength;
556  	public LTSpline(params Vector3[] pts) {
557  		this.pts = new Vector3[pts.Length];
558  		System.Array.Copy(pts, this.pts, pts.Length);
559  		numSections = pts.Length - 3;
560  		int precision = 20;
561  		lengthRatio = new float[precision];
562  		lengths = new float[precision];
563  		Vector3 lastPoint = new Vector3(Mathf.Infinity,0,0);
564  		totalLength = 0f;
565  		for(int i = 0; i &lt; precision; i++){
566  			float fract = (i*1f) / precision;
567  			Vector3 point = interp( fract );
568  			if(i&gt;=1){
569  				lengths[ i ] = (point - lastPoint).magnitude;
570  			}
571  			totalLength += lengths[ i ];
572  			lastPoint = point;
573  		}
574  		float ratioTotal = 0f;
575  		for(int i = 0; i &lt; lengths.Length; i++){
576  			float t = i *1f / (lengths.Length-1);
577  			currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
578  			float ratioLength = lengths[i] / totalLength;
579  			ratioTotal += ratioLength;
580  			lengthRatio[i] = ratioTotal;
581  		}
582  	}
583  	public float map( float t ){
584  		for(int i = 0; i &lt; lengthRatio.Length; i++){
585  			if(lengthRatio[i] &gt;= t){
586  				return lengthRatio[i]+(t-lengthRatio[i]);
587  			}
588  		}
589  		return 1f;
590  	}
591  	public Vector3 interp(float t) {
592  		currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
593  		float u = t * (float) numSections - (float) currPt;
594  		Vector3 a = pts[currPt];
595  		Vector3 b = pts[currPt + 1];
596  		Vector3 c = pts[currPt + 2];
597  		Vector3 d = pts[currPt + 3];
598  		return .5f * (
599  			(-a + 3f * b - 3f * c + d) * (u * u * u)
600  			+ (2f * a - 5f * b + 4f * c - d) * (u * u)
601  			+ (-a + c) * u
602  			+ 2f * b
603  		);
604  	}
605  	public Vector3 point( float ratio ){
606  		float t = map( ratio );
607  		return interp( t );
608  	}
609  	public void place( Transform transform, float ratio ){
610  		place(transform, ratio, Vector3.up);
611  	}
612  	public void place( Transform transform, float ratio, Vector3 worldUp ){
613  		transform.position = point( ratio );
614  		ratio += 0.001f;
615  		if(ratio&lt;=1.0f)
616  			transform.LookAt( point( ratio ), worldUp );
617  	}
618  	public void placeLocal( Transform transform, float ratio ){
619  		placeLocal( transform, ratio, Vector3.up );
620  	}
621  	public void placeLocal( Transform transform, float ratio, Vector3 worldUp ){
622  		transform.localPosition = point( ratio );
623  		ratio += 0.001f;
624  		if(ratio&lt;=1.0f)
625  			transform.LookAt( transform.parent.TransformPoint( point( ratio ) ), worldUp );
626  	}
627  	public void gizmoDraw(float t = -1.0f) {
628  		if(lengthRatio!=null &amp;&amp; lengthRatio.Length&gt;0){
629  			Vector3 prevPt = point(0);
630  			for (int i = 1; i &lt;= 120; i++) {
631  				float pm = (float) i / 120f;
632  				Vector3 currPt = point(pm);
633  				Gizmos.DrawLine(currPt, prevPt);
634  				prevPt = currPt;
635  			}
636  		}
637  	}
638  	public Vector3 Velocity(float t) {
639  		t = map( t );
640  		int numSections = pts.Length - 3;
641  		int currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
642  		float u = t * (float) numSections - (float) currPt;
643  		Vector3 a = pts[currPt];
644  		Vector3 b = pts[currPt + 1];
645  		Vector3 c = pts[currPt + 2];
646  		Vector3 d = pts[currPt + 3];
647  		return 1.5f * (-a + 3f * b - 3f * c + d) * (u * u)
648  				+ (2f * a -5f * b + 4f * c - d) * u
649  				+ .5f * c - .5f * a;
650  	}
651  }
652  public enum TweenAction{
653  	MOVE_X,
654  	MOVE_Y,
655  	MOVE_Z,
656  	MOVE_LOCAL_X,
657  	MOVE_LOCAL_Y,
658  	MOVE_LOCAL_Z,
659  	MOVE_CURVED,
660  	MOVE_CURVED_LOCAL,
661  	MOVE_SPLINE,
662  	MOVE_SPLINE_LOCAL,
663  	SCALE_X,
664  	SCALE_Y,
665  	SCALE_Z,
666  	ROTATE_X,
667  	ROTATE_Y,
668  	ROTATE_Z,
669  	ROTATE_AROUND,
670  	ALPHA,
671  	ALPHA_VERTEX,
672  	CALLBACK,
673  	MOVE,
674  	MOVE_LOCAL,
675  	ROTATE,
676  	ROTATE_LOCAL,
677  	SCALE,
678  	VALUE3,
679  	GUI_MOVE,
680  	GUI_MOVE_MARGIN,
681  	GUI_SCALE,
682  	GUI_ALPHA,
683  	GUI_ROTATE,
684  	DELAYED_SOUND
685  }
686  public class LeanTween: MonoBehaviour {
687  public static bool throwErrors = true;
688  private static LTDescr[] tweens;
689  private static int tweenMaxSearch = 0;
690  private static int maxTweens = 400;
691  private static int frameRendered= -1;
692  private static GameObject _tweenEmpty;
693  private static float dtEstimated;
694  private static float previousRealTime;
695  private static float dt;
696  private static float dtActual;
697  private static LTDescr tween;
698  private static int i;
699  private static int j;
700  private static AnimationCurve punch = new AnimationCurve( new Keyframe(0.0f, 0.0f ), new Keyframe(0.112586f, 0.9976035f ), new Keyframe(0.3120486f, -0.1720615f ), new Keyframe(0.4316337f, 0.07030682f ), new Keyframe(0.5524869f, -0.03141804f ), new Keyframe(0.6549395f, 0.003909959f ), new Keyframe(0.770987f, -0.009817753f ), new Keyframe(0.8838775f, 0.001939224f ), new Keyframe(1.0f, 0.0f ) );
701  private static AnimationCurve shake = new AnimationCurve( new Keyframe(0f, 0f), new Keyframe(0.25f, 1f), new Keyframe(0.75f, -1f), new Keyframe(1f, 0f) ) ;
702  public static void init(){
703  	init(maxTweens);
704  }
705  public static void init(int maxSimultaneousTweens){
706  	if(tweens==null){
707  		maxTweens = maxSimultaneousTweens;
708  		tweens = new LTDescr[maxTweens];
709  		_tweenEmpty = new GameObject();
710  		_tweenEmpty.name = &quot;~LeanTween&quot;;
711  		_tweenEmpty.AddComponent(typeof(LeanTween));
712  		_tweenEmpty.isStatic = true;
713  		#if !UNITY_EDITOR
714  		_tweenEmpty.hideFlags = HideFlags.HideAndDontSave;
715  		#endif
716  		DontDestroyOnLoad( _tweenEmpty );
717  		for(int i = 0; i &lt; maxTweens; i++){
718  			tweens[i] = new LTDescr();
719  		}
720  	}
721  }
722  public static void reset(){
723  	tweens = null;
724  }
725  public void Update(){
726  	LeanTween.update();
727  }
728  public void OnLevelWasLoaded( int lvl ){
729  	LTGUI.reset();
730  }
731  private static Transform trans;
732  private static float timeTotal;
733  private static TweenAction tweenAction;
734  private static float ratioPassed;
735  private static float from;
736  private static float to;
737  private static float val;
738  private static Vector3 newVect;
739  private static bool isTweenFinished;
740  private static GameObject target;
741  private static GameObject customTarget;
742  public static void update() {
743  	if(frameRendered != Time.frameCount){ 
744  		init();
745  		dtEstimated = Time.realtimeSinceStartup - previousRealTime;
746  		if(dtEstimated&gt;0.2f) 
747  			dtEstimated = 0.2f;
748  		previousRealTime = Time.realtimeSinceStartup;
749  		dtActual = Time.deltaTime*Time.timeScale;
750  		for( int i = 0; i &lt; tweenMaxSearch &amp;&amp; i &lt; maxTweens; i++){
751  			if(tweens[i].toggle){
752  				tween = tweens[i];
753  				trans = tween.trans;
754  				timeTotal = tween.time;
755  				tweenAction = tween.type;
756  				dt = dtActual;
757  				if( tween.useEstimatedTime ){
758  					dt = dtEstimated;
759  					timeTotal = tween.time;
760  				}else if( tween.useFrames ){
761  					dt = 1;
762  				}else if(tween.direction==0f){
763  					dt = 0f;
764  				}
765  				if(trans==null){
766  					removeTween(i);
767  					continue;
768  				}
769  				isTweenFinished = false;
770  				if(tween.delay&lt;=0){
771  					if((tween.passed + dt &gt; timeTotal &amp;&amp; tween.direction &gt; 0.0f )){
772  						isTweenFinished = true;
773  						tween.passed = tween.time; 
774  					}else if(tween.direction&lt;0.0f &amp;&amp; tween.passed - dt &lt; 0.0f){
775  						isTweenFinished = true;
776  						tween.passed = Mathf.Epsilon;
777  					}
778  				}
779  				if(!tween.hasInitiliazed &amp;&amp; ((tween.passed==0.0 &amp;&amp; tween.delay==0.0) || tween.passed&gt;0.0) ){
780  					tween.hasInitiliazed = true;
781  					if( !tween.useEstimatedTime ){
782  						tween.time = tween.time*Time.timeScale;
783  					}
784  					switch(tweenAction){
785  						case TweenAction.MOVE:
786  							tween.from = trans.position; break;
787  						case TweenAction.MOVE_X:
788  							tween.from.x = trans.position.x; break;
789  						case TweenAction.MOVE_Y:
790  							tween.from.x = trans.position.y; break;
791  						case TweenAction.MOVE_Z:
792  							tween.from.x = trans.position.z; break;
793  						case TweenAction.MOVE_LOCAL_X:
794  							tweens[i].from.x = trans.localPosition.x; break;
795  						case TweenAction.MOVE_LOCAL_Y:
796  							tweens[i].from.x = trans.localPosition.y; break;
797  						case TweenAction.MOVE_LOCAL_Z:
798  							tweens[i].from.x = trans.localPosition.z; break;
799  						case TweenAction.SCALE_X:
800  							tween.from.x = trans.localScale.x; break;
801  						case TweenAction.SCALE_Y:
802  							tween.from.x = trans.localScale.y; break;
803  						case TweenAction.SCALE_Z:
804  							tween.from.x = trans.localScale.z; break;
805  						case TweenAction.ALPHA:
806  							#if UNITY_3_5 || UNITY_4_0 || UNITY_4_0_1 || UNITY_4_1 || UNITY_4_2
807  								tween.from.x = trans.gameObject.renderer.material.color.a; 
808  								break;	
809  							#else
810  								SpriteRenderer ren = trans.gameObject.GetComponent&lt;SpriteRenderer&gt;();
811  								tween.from.x = (ren!=null) ? ren.color.a : trans.gameObject.GetComponent&lt;Renderer&gt;().material.color.a;
812  								break;
813  							#endif
814  						case TweenAction.MOVE_LOCAL:
815  							tween.from = trans.localPosition; break;
816  						case TweenAction.MOVE_CURVED:
817  						case TweenAction.MOVE_CURVED_LOCAL:
818  						case TweenAction.MOVE_SPLINE:
819  						case TweenAction.MOVE_SPLINE_LOCAL:
820  							tween.from.x = 0; break;
821  						case TweenAction.ROTATE:
822  							tween.from = trans.eulerAngles; 
823  							tween.to = new Vector3(LeanTween.closestRot( tween.from.x, tween.to.x), LeanTween.closestRot( tween.from.y, tween.to.y), LeanTween.closestRot( tween.from.z, tween.to.z));
824  							break;
825  						case TweenAction.ROTATE_X:
826  							tween.from.x = trans.eulerAngles.x; 
827  							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
828  							break;
829  						case TweenAction.ROTATE_Y:
830  							tween.from.x = trans.eulerAngles.y; 
831  							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
832  							break;
833  						case TweenAction.ROTATE_Z:
834  							tween.from.x = trans.eulerAngles.z; 
835  							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
836  							break;
837  						case TweenAction.ROTATE_AROUND:
838  							tween.lastVal = 0.0f; 
839  							tween.origRotation = trans.eulerAngles; 
840  							break;
841  						case TweenAction.ROTATE_LOCAL:
842  							tween.from = trans.localEulerAngles; 
843  							tween.to = new Vector3(LeanTween.closestRot( tween.from.x, tween.to.x), LeanTween.closestRot( tween.from.y, tween.to.y), LeanTween.closestRot( tween.from.z, tween.to.z));
844  							break;
845  						case TweenAction.SCALE:
846  							tween.from = trans.localScale; break;
847  						case TweenAction.GUI_MOVE:
848  							tween.from = new Vector3(tween.ltRect.rect.x, tween.ltRect.rect.y, 0); break;
849  						case TweenAction.GUI_MOVE_MARGIN:
850  							tween.from = new Vector2(tween.ltRect.margin.x, tween.ltRect.margin.y); break;
851  						case TweenAction.GUI_SCALE:
852  							tween.from = new  Vector3(tween.ltRect.rect.width, tween.ltRect.rect.height, 0); break;
853  						case TweenAction.GUI_ALPHA:
854  							tween.from.x = tween.ltRect.alpha; break;
855  						case TweenAction.GUI_ROTATE:
856  							if(tween.ltRect.rotateEnabled==false){
857  								tween.ltRect.rotateEnabled = true;
858  								tween.ltRect.resetForRotation();
859  							}
860  							tween.from.x = tween.ltRect.rotation; break;
861  						case TweenAction.ALPHA_VERTEX:
862  							tween.from.x = trans.GetComponent&lt;MeshFilter&gt;().mesh.colors32[0].a;
863  							break;
864  					}
865  					tween.diff = tween.to - tween.from;
866  				}
867  				if(tween.delay&lt;=0){
868  					if(timeTotal&lt;=0f){
869  						ratioPassed = 0f;
870  					}else{
871  						ratioPassed = tween.passed / timeTotal;
872  					}
873  					if(ratioPassed&gt;1.0f){
874  						ratioPassed = 1.0f;
875  					}else if(ratioPassed&lt;0f){
876  						ratioPassed = 0f;
877  					}
878  					if(tweenAction&gt;=TweenAction.MOVE_X &amp;&amp; tweenAction&lt;=TweenAction.CALLBACK){
879  						if(tween.animationCurve!=null){
880  							val = tweenOnCurve(tween, ratioPassed);
881  						}else {
882  							switch( tween.tweenType ){
883  								case LeanTweenType.linear:
884  									val = tween.from.x + tween.diff.x * ratioPassed; break;
885  								case LeanTweenType.easeOutQuad:
886  									val = easeOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
887  								case LeanTweenType.easeInQuad:
888  									val = easeInQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
889  								case LeanTweenType.easeInOutQuad:
890  									val = easeInOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
891  								case LeanTweenType.easeInCubic:
892  									val = easeInCubic(tween.from.x, tween.to.x, ratioPassed); break;
893  								case LeanTweenType.easeOutCubic:
894  									val = easeOutCubic(tween.from.x, tween.to.x, ratioPassed); break;
895  								case LeanTweenType.easeInOutCubic:
896  									val = easeInOutCubic(tween.from.x, tween.to.x, ratioPassed); break;
897  								case LeanTweenType.easeInQuart:
898  									val = easeInQuart(tween.from.x, tween.to.x, ratioPassed); break;
899  								case LeanTweenType.easeOutQuart:
900  									val = easeOutQuart(tween.from.x, tween.to.x, ratioPassed); break;
901  								case LeanTweenType.easeInOutQuart:
902  									val = easeInOutQuart(tween.from.x, tween.to.x, ratioPassed); break;
903  								case LeanTweenType.easeInQuint:
904  									val = easeInQuint(tween.from.x, tween.to.x, ratioPassed); break;
905  								case LeanTweenType.easeOutQuint:
906  									val = easeOutQuint(tween.from.x, tween.to.x, ratioPassed); break;
907  								case LeanTweenType.easeInOutQuint:
908  									val = easeInOutQuint(tween.from.x, tween.to.x, ratioPassed); break;
909  								case LeanTweenType.easeInSine:
910  									val = easeInSine(tween.from.x, tween.to.x, ratioPassed); break;
911  								case LeanTweenType.easeOutSine:
912  									val = easeOutSine(tween.from.x, tween.to.x, ratioPassed); break;
913  								case LeanTweenType.easeInOutSine:
914  									val = easeInOutSine(tween.from.x, tween.to.x, ratioPassed); break;
915  								case LeanTweenType.easeInExpo:
916  									val = easeInExpo(tween.from.x, tween.to.x, ratioPassed); break;
917  								case LeanTweenType.easeOutExpo:
918  									val = easeOutExpo(tween.from.x, tween.to.x, ratioPassed); break;
919  								case LeanTweenType.easeInOutExpo:
920  									val = easeInOutExpo(tween.from.x, tween.to.x, ratioPassed); break;
921  								case LeanTweenType.easeInCirc:
922  									val = easeInCirc(tween.from.x, tween.to.x, ratioPassed); break;
923  								case LeanTweenType.easeOutCirc:
924  									val = easeOutCirc(tween.from.x, tween.to.x, ratioPassed); break;
925  								case LeanTweenType.easeInOutCirc:
926  									val = easeInOutCirc(tween.from.x, tween.to.x, ratioPassed); break;
927  								case LeanTweenType.easeInBounce:
928  									val = easeInBounce(tween.from.x, tween.to.x, ratioPassed); break;
929  								case LeanTweenType.easeOutBounce:
930  									val = easeOutBounce(tween.from.x, tween.to.x, ratioPassed); break;
931  								case LeanTweenType.easeInOutBounce:
932  									val = easeInOutBounce(tween.from.x, tween.to.x, ratioPassed); break;
933  								case LeanTweenType.easeInBack:
934  									val = easeInBack(tween.from.x, tween.to.x, ratioPassed); break;
935  								case LeanTweenType.easeOutBack:
936  									val = easeOutBack(tween.from.x, tween.to.x, ratioPassed); break;
937  								case LeanTweenType.easeInOutBack:
938  									val = easeInOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
939  								case LeanTweenType.easeInElastic:
940  									val = easeInElastic(tween.from.x, tween.to.x, ratioPassed); break;
941  								case LeanTweenType.easeOutElastic:
942  									val = easeOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
943  								case LeanTweenType.easeInOutElastic:
944  									val = easeInOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
945                                  case LeanTweenType.punch:
946  								case LeanTweenType.easeShake:
947  									if(tween.tweenType==LeanTweenType.punch){
948  										tween.animationCurve = LeanTween.punch;
949  									}else if(tween.tweenType==LeanTweenType.easeShake){
950  										tween.animationCurve = LeanTween.shake;
951  									}
952  									tween.to.x = tween.from.x + tween.to.x;
953  									tween.diff.x = tween.to.x - tween.from.x;
954  									val = tweenOnCurve(tween, ratioPassed); break;
955  								case LeanTweenType.easeSpring:
956  									val = spring(tween.from.x, tween.to.x, ratioPassed); break;
957                                  default:
958                                      {
959                                          val = tween.from.x + tween.diff.x * ratioPassed; break;
960                                      }
961  							}
962  						}
963  						if(tweenAction==TweenAction.MOVE_X){
964  							trans.position=new Vector3( val,trans.position.y,trans.position.z);
965  						}else if(tweenAction==TweenAction.MOVE_Y){
966  							trans.position =new Vector3( trans.position.x,val,trans.position.z);
967  						}else if(tweenAction==TweenAction.MOVE_Z){
968  							trans.position=new Vector3( trans.position.x,trans.position.y,val);
969  						}if(tweenAction==TweenAction.MOVE_LOCAL_X){
970  							trans.localPosition=new Vector3( val,trans.localPosition.y,trans.localPosition.z);
971  						}else if(tweenAction==TweenAction.MOVE_LOCAL_Y){
972  							trans.localPosition=new Vector3( trans.localPosition.x,val,trans.localPosition.z);
973  						}else if(tweenAction==TweenAction.MOVE_LOCAL_Z){
974  							trans.localPosition=new Vector3( trans.localPosition.x,trans.localPosition.y,val);
975  						}else if(tweenAction==TweenAction.MOVE_CURVED){
976  							if(tween.path.orientToPath){
977  								tween.path.place( trans, val );
978  							}else{
979  								trans.position = tween.path.point( val );
980  							}
981  						}else if((TweenAction)tweenAction==TweenAction.MOVE_CURVED_LOCAL){
982  							if(tween.path.orientToPath){
983  								tween.path.placeLocal( trans, val );
984  							}else{
985  								trans.localPosition = tween.path.point( val );
986  							}
987  						}else if((TweenAction)tweenAction==TweenAction.MOVE_SPLINE){
988  							if(tween.spline.orientToPath){
989  								tween.spline.place( trans, val );
990  							}else{
991  								trans.position = tween.spline.point( val );
992  							}
993  						}else if((TweenAction)tweenAction==TweenAction.MOVE_SPLINE_LOCAL){
994  							if(tween.spline.orientToPath){
995  								tween.spline.placeLocal( trans, val );
996  							}else{
997  								trans.localPosition = tween.spline.point( val );
998  							}
999  						}else if(tweenAction==TweenAction.SCALE_X){
1000  							trans.localScale=new Vector3(val, trans.localScale.y,trans.localScale.z);
1001  						}else if(tweenAction==TweenAction.SCALE_Y){
1002  							trans.localScale=new Vector3( trans.localScale.x,val,trans.localScale.z);
1003  						}else if(tweenAction==TweenAction.SCALE_Z){
1004  							trans.localScale=new Vector3(trans.localScale.x,trans.localScale.y,val);
1005  						}else if(tweenAction==TweenAction.ROTATE_X){
1006  					    	trans.eulerAngles=new Vector3(val, trans.eulerAngles.y,trans.eulerAngles.z);
1007  					    }else if(tweenAction==TweenAction.ROTATE_Y){
1008  					    	trans.eulerAngles=new Vector3(trans.eulerAngles.x,val,trans.eulerAngles.z);
1009  					    }else if(tweenAction==TweenAction.ROTATE_Z){
1010  					    	trans.eulerAngles=new Vector3(trans.eulerAngles.x,trans.eulerAngles.y,val);
1011  					    }else if(tweenAction==TweenAction.ROTATE_AROUND){
1012  							float move = val -  tween.lastVal;
1013  					    	if(isTweenFinished){
1014  					    		trans.eulerAngles = tween.origRotation;
1015  					    		trans.RotateAround((Vector3)trans.TransformPoint( tween.point ), tween.axis, tween.to.x);
1016  					    	}else{
1017  								trans.RotateAround((Vector3)trans.TransformPoint( tween.point ), tween.axis, move);
1018  								tween.lastVal = val;
1019  					    	}
1020  					    }else if(tweenAction==TweenAction.ALPHA){
1021  					    	#if UNITY_3_5 || UNITY_4_0 || UNITY_4_0_1 || UNITY_4_1 || UNITY_4_2
1022  							foreach(Material mat in trans.gameObject.renderer.materials){
1023          						mat.color = new Color( mat.color.r, mat.color.g, mat.color.b, val);
1024      						}
1025  							#else
1026  							SpriteRenderer ren = trans.gameObject.GetComponent&lt;SpriteRenderer&gt;();
1027  							if(ren!=null){
1028  								ren.color = new Color( ren.color.r, ren.color.g, ren.color.b, val);
1029  							}else{
1030  								foreach(Material mat in trans.gameObject.GetComponent&lt;Renderer&gt;().materials){
1031  	        						mat.color = new Color( mat.color.r, mat.color.g, mat.color.b, val);
1032  	    						}
1033  							}
1034      						#endif
1035  						}else if(tweenAction==TweenAction.ALPHA_VERTEX){
1036  							Mesh mesh = trans.GetComponent&lt;MeshFilter&gt;().mesh;
1037  							Vector3[] vertices = mesh.vertices;
1038  							Color32[] colors = new Color32[vertices.Length];
1039  							Color32 c = mesh.colors32[0];
1040  							c = new Color( c.r, c.g, c.b, val);
1041  							for (int k= 0; k &lt; vertices.Length; k++) {
1042  								colors[k] = c;
1043  							}
1044  							mesh.colors32 = colors;
1045  						}
1046  					}else if(tweenAction&gt;=TweenAction.MOVE){
1047  						if(tween.animationCurve!=null){
1048  							newVect = tweenOnCurveVector(tween, ratioPassed);
1049  						}else{
1050  							if(tween.tweenType == LeanTweenType.linear){
1051  								newVect = new Vector3( tween.from.x + tween.diff.x * ratioPassed, tween.from.y + tween.diff.y * ratioPassed, tween.from.z + tween.diff.z * ratioPassed);
1052  							}else if(tween.tweenType &gt;= LeanTweenType.linear){
1053  								switch(tween.tweenType){
1054  									case LeanTweenType.easeOutQuad:
1055  										newVect = new Vector3(easeOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeOutQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeOutQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
1056  									case LeanTweenType.easeInQuad:
1057  										newVect = new Vector3(easeInQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeInQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeInQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
1058  									case LeanTweenType.easeInOutQuad:
1059  										newVect = new Vector3(easeInOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeInOutQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeInOutQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
1060  									case LeanTweenType.easeInCubic:
1061  										newVect = new Vector3(easeInCubic(tween.from.x, tween.to.x, ratioPassed), easeInCubic(tween.from.y, tween.to.y, ratioPassed), easeInCubic(tween.from.z, tween.to.z, ratioPassed)); break;
1062  									case LeanTweenType.easeOutCubic:
1063  										newVect = new Vector3(easeOutCubic(tween.from.x, tween.to.x, ratioPassed), easeOutCubic(tween.from.y, tween.to.y, ratioPassed), easeOutCubic(tween.from.z, tween.to.z, ratioPassed)); break;
1064  									case LeanTweenType.easeInOutCubic:
1065  										newVect = new Vector3(easeInOutCubic(tween.from.x, tween.to.x, ratioPassed), easeInOutCubic(tween.from.y, tween.to.y, ratioPassed), easeInOutCubic(tween.from.z, tween.to.z, ratioPassed)); break;
1066  									case LeanTweenType.easeInQuart:
1067  										newVect = new Vector3(easeInQuart(tween.from.x, tween.to.x, ratioPassed), easeInQuart(tween.from.y, tween.to.y, ratioPassed), easeInQuart(tween.from.z, tween.to.z, ratioPassed)); break;
1068  									case LeanTweenType.easeOutQuart:
1069  										newVect = new Vector3(easeOutQuart(tween.from.x, tween.to.x, ratioPassed), easeOutQuart(tween.from.y, tween.to.y, ratioPassed), easeOutQuart(tween.from.z, tween.to.z, ratioPassed)); break;
1070  									case LeanTweenType.easeInOutQuart:
1071  										newVect = new Vector3(easeInOutQuart(tween.from.x, tween.to.x, ratioPassed), easeInOutQuart(tween.from.y, tween.to.y, ratioPassed), easeInOutQuart(tween.from.z, tween.to.z, ratioPassed)); break;
1072  									case LeanTweenType.easeInQuint:
1073  										newVect = new Vector3(easeInQuint(tween.from.x, tween.to.x, ratioPassed), easeInQuint(tween.from.y, tween.to.y, ratioPassed), easeInQuint(tween.from.z, tween.to.z, ratioPassed)); break;
1074  									case LeanTweenType.easeOutQuint:
1075  										newVect = new Vector3(easeOutQuint(tween.from.x, tween.to.x, ratioPassed), easeOutQuint(tween.from.y, tween.to.y, ratioPassed), easeOutQuint(tween.from.z, tween.to.z, ratioPassed)); break;
1076  									case LeanTweenType.easeInOutQuint:
1077  										newVect = new Vector3(easeInOutQuint(tween.from.x, tween.to.x, ratioPassed), easeInOutQuint(tween.from.y, tween.to.y, ratioPassed), easeInOutQuint(tween.from.z, tween.to.z, ratioPassed)); break;
1078  									case LeanTweenType.easeInSine:
1079  										newVect = new Vector3(easeInSine(tween.from.x, tween.to.x, ratioPassed), easeInSine(tween.from.y, tween.to.y, ratioPassed), easeInSine(tween.from.z, tween.to.z, ratioPassed)); break;
1080  									case LeanTweenType.easeOutSine:
1081  										newVect = new Vector3(easeOutSine(tween.from.x, tween.to.x, ratioPassed), easeOutSine(tween.from.y, tween.to.y, ratioPassed), easeOutSine(tween.from.z, tween.to.z, ratioPassed)); break;
1082  									case LeanTweenType.easeInOutSine:
1083  										newVect = new Vector3(easeInOutSine(tween.from.x, tween.to.x, ratioPassed), easeInOutSine(tween.from.y, tween.to.y, ratioPassed), easeInOutSine(tween.from.z, tween.to.z, ratioPassed)); break;
1084  									case LeanTweenType.easeInExpo:
1085  										newVect = new Vector3(easeInExpo(tween.from.x, tween.to.x, ratioPassed), easeInExpo(tween.from.y, tween.to.y, ratioPassed), easeInExpo(tween.from.z, tween.to.z, ratioPassed)); break;
1086  									case LeanTweenType.easeOutExpo:
1087  										newVect = new Vector3(easeOutExpo(tween.from.x, tween.to.x, ratioPassed), easeOutExpo(tween.from.y, tween.to.y, ratioPassed), easeOutExpo(tween.from.z, tween.to.z, ratioPassed)); break;
1088  									case LeanTweenType.easeInOutExpo:
1089  										newVect = new Vector3(easeInOutExpo(tween.from.x, tween.to.x, ratioPassed), easeInOutExpo(tween.from.y, tween.to.y, ratioPassed), easeInOutExpo(tween.from.z, tween.to.z, ratioPassed)); break;
1090  									case LeanTweenType.easeInCirc:
1091  										newVect = new Vector3(easeInCirc(tween.from.x, tween.to.x, ratioPassed), easeInCirc(tween.from.y, tween.to.y, ratioPassed), easeInCirc(tween.from.z, tween.to.z, ratioPassed)); break;
1092  									case LeanTweenType.easeOutCirc:
1093  										newVect = new Vector3(easeOutCirc(tween.from.x, tween.to.x, ratioPassed), easeOutCirc(tween.from.y, tween.to.y, ratioPassed), easeOutCirc(tween.from.z, tween.to.z, ratioPassed)); break;
1094  									case LeanTweenType.easeInOutCirc:
1095  										newVect = new Vector3(easeInOutCirc(tween.from.x, tween.to.x, ratioPassed), easeInOutCirc(tween.from.y, tween.to.y, ratioPassed), easeInOutCirc(tween.from.z, tween.to.z, ratioPassed)); break;
1096  									case LeanTweenType.easeInBounce:
1097  										newVect = new Vector3(easeInBounce(tween.from.x, tween.to.x, ratioPassed), easeInBounce(tween.from.y, tween.to.y, ratioPassed), easeInBounce(tween.from.z, tween.to.z, ratioPassed)); break;
1098  									case LeanTweenType.easeOutBounce:
1099  										newVect = new Vector3(easeOutBounce(tween.from.x, tween.to.x, ratioPassed), easeOutBounce(tween.from.y, tween.to.y, ratioPassed), easeOutBounce(tween.from.z, tween.to.z, ratioPassed)); break;
1100  									case LeanTweenType.easeInOutBounce:
1101  										newVect = new Vector3(easeInOutBounce(tween.from.x, tween.to.x, ratioPassed), easeInOutBounce(tween.from.y, tween.to.y, ratioPassed), easeInOutBounce(tween.from.z, tween.to.z, ratioPassed)); break;
1102  									case LeanTweenType.easeInBack:
1103  										newVect = new Vector3(easeInBack(tween.from.x, tween.to.x, ratioPassed), easeInBack(tween.from.y, tween.to.y, ratioPassed), easeInBack(tween.from.z, tween.to.z, ratioPassed)); break;
1104  									case LeanTweenType.easeOutBack:
1105  										newVect = new Vector3(easeOutBack(tween.from.x, tween.to.x, ratioPassed), easeOutBack(tween.from.y, tween.to.y, ratioPassed), easeOutBack(tween.from.z, tween.to.z, ratioPassed)); break;
1106  									case LeanTweenType.easeInOutBack:
1107  										newVect = new Vector3(easeInOutBack(tween.from.x, tween.to.x, ratioPassed), easeInOutBack(tween.from.y, tween.to.y, ratioPassed), easeInOutBack(tween.from.z, tween.to.z, ratioPassed)); break;
1108  									case LeanTweenType.easeInElastic:
1109  										newVect = new Vector3(easeInElastic(tween.from.x, tween.to.x, ratioPassed), easeInElastic(tween.from.y, tween.to.y, ratioPassed), easeInElastic(tween.from.z, tween.to.z, ratioPassed)); break;
1110  									case LeanTweenType.easeOutElastic:
1111  										newVect = new Vector3(easeOutElastic(tween.from.x, tween.to.x, ratioPassed), easeOutElastic(tween.from.y, tween.to.y, ratioPassed), easeOutElastic(tween.from.z, tween.to.z, ratioPassed)); break;
1112  									case LeanTweenType.easeInOutElastic:
1113  										newVect = new Vector3(easeInOutElastic(tween.from.x, tween.to.x, ratioPassed), easeInOutElastic(tween.from.y, tween.to.y, ratioPassed), easeInOutElastic(tween.from.z, tween.to.z, ratioPassed)); break;
1114  									case LeanTweenType.punch:
1115  									case LeanTweenType.easeShake:
1116  										if(tween.tweenType==LeanTweenType.punch){
1117  											tween.animationCurve = LeanTween.punch;
1118  										}else if(tween.tweenType==LeanTweenType.easeShake){
1119  											tween.animationCurve = LeanTween.shake;
1120  										}
1121  										tween.to = tween.from + tween.to;
1122  										tween.diff = tween.to - tween.from;
1123  										if(tweenAction==TweenAction.ROTATE || tweenAction==TweenAction.ROTATE_LOCAL){
1124  											tween.to = new Vector3(closestRot(tween.from.x, tween.to.x), closestRot(tween.from.y, tween.to.y), closestRot(tween.from.z, tween.to.z));
1125  										}
1126  										newVect = tweenOnCurveVector(tween, ratioPassed); break;
1127  									case LeanTweenType.easeSpring:
1128  										newVect = new Vector3(spring(tween.from.x, tween.to.x, ratioPassed), spring(tween.from.y, tween.to.y, ratioPassed), spring(tween.from.z, tween.to.z, ratioPassed)); break;
1129  								}
1130  							}else{
1131  								newVect = new Vector3( tween.from.x + tween.diff.x * ratioPassed, tween.from.y + tween.diff.y * ratioPassed, tween.from.z + tween.diff.z * ratioPassed);
1132  							}
1133  						}
1134  						if(tweenAction==TweenAction.MOVE){
1135  							trans.position = newVect;
1136  					    }else if(tweenAction==TweenAction.MOVE_LOCAL){
1137  							trans.localPosition = newVect;
1138  					    }else if(tweenAction==TweenAction.ROTATE){
1139  				    			trans.eulerAngles = newVect;
1140  					    }else if(tweenAction==TweenAction.ROTATE_LOCAL){
1141  					    	trans.localEulerAngles = newVect;
1142  					    }else if(tweenAction==TweenAction.SCALE){
1143  					    	trans.localScale = newVect;
1144  					    }else if(tweenAction==TweenAction.GUI_MOVE){
1145  					    	tween.ltRect.rect = new Rect( newVect.x, newVect.y, tween.ltRect.rect.width, tween.ltRect.rect.height);
1146  					    }else if(tweenAction==TweenAction.GUI_MOVE_MARGIN){
1147  					    	tween.ltRect.margin = new Vector2(newVect.x, newVect.y);
1148  					    }else if(tweenAction==TweenAction.GUI_SCALE){
1149  					    	tween.ltRect.rect = new Rect( tween.ltRect.rect.x, tween.ltRect.rect.y, newVect.x, newVect.y);
1150  					    }else if(tweenAction==TweenAction.GUI_ALPHA){
1151  					    	tween.ltRect.alpha = newVect.x;
1152  					    }else if(tweenAction==TweenAction.GUI_ROTATE){
1153  					    	tween.ltRect.rotation = newVect.x;
1154  					    }
1155  					}
1156  					if(tween.onUpdateFloat!=null){
1157  						tween.onUpdateFloat(val);
1158  					}else if(tween.onUpdateFloatObject!=null){
1159  						tween.onUpdateFloatObject(val, tween.onUpdateParam);
1160  					}else if(tween.onUpdateVector3Object!=null){
1161  						tween.onUpdateVector3Object(newVect, tween.onUpdateParam);
1162  					}else if(tween.onUpdateVector3!=null){
1163  						tween.onUpdateVector3(newVect);
1164  					}
1165  					#if !UNITY_METRO
1166  					else if(tween.optional!=null){ 
1167  						var onUpdate = tween.optional[&quot;onUpdate&quot;];
1168  						if(onUpdate!=null){
1169  							Hashtable updateParam = (Hashtable)tween.optional[&quot;onUpdateParam&quot;];
1170  							if((TweenAction)tweenAction==TweenAction.VALUE3){
1171  								if(onUpdate.GetType() == typeof(string)){
1172  									string onUpdateS = onUpdate as string;
1173  									customTarget = tween.optional[&quot;onUpdateTarget&quot;]!=null ? tween.optional[&quot;onUpdateTarget&quot;] as GameObject : trans.gameObject;
1174  									customTarget.BroadcastMessage( onUpdateS, newVect );
1175  								}else if(onUpdate.GetType() == typeof(System.Action&lt;Vector3, Hashtable&gt;)){
1176  									System.Action&lt;Vector3, Hashtable&gt; onUpdateA = (System.Action&lt;Vector3, Hashtable&gt;)onUpdate;
1177  									onUpdateA(newVect, updateParam);
1178  								}else{
1179  									System.Action&lt;Vector3&gt; onUpdateA = (System.Action&lt;Vector3&gt;)onUpdate;
1180  									onUpdateA(newVect);
1181  								}
1182  							}else{
1183  								if(onUpdate.GetType() == typeof(string)){
1184  									string onUpdateS = onUpdate as string;
1185  									if (tween.optional[&quot;onUpdateTarget&quot;]!=null){
1186  										customTarget = tween.optional[&quot;onUpdateTarget&quot;] as GameObject;
1187  										customTarget.BroadcastMessage( onUpdateS, val );
1188  									}else{
1189  										trans.gameObject.BroadcastMessage( onUpdateS, val );
1190  									}
1191  								}else if(onUpdate.GetType() == typeof(System.Action&lt;float, Hashtable&gt;)){
1192  									System.Action&lt;float, Hashtable&gt; onUpdateA = (System.Action&lt;float, Hashtable&gt;)onUpdate;
1193  									onUpdateA(val, updateParam);
1194  								}else if(onUpdate.GetType() == typeof(System.Action&lt;Vector3&gt;)){
1195  									System.Action&lt;Vector3&gt; onUpdateA = (System.Action&lt;Vector3&gt;)onUpdate;
1196  									onUpdateA( newVect );
1197  								}else{
1198  									System.Action&lt;float&gt; onUpdateA = (System.Action&lt;float&gt;)onUpdate;
1199  									onUpdateA(val);
1200  								}
1201  							}
1202  						}
1203  					}
1204  					#endif
1205  				}
1206  				if(isTweenFinished){
1207  					if(tweenAction==TweenAction.GUI_ROTATE)
1208  						tween.ltRect.rotateFinished = true;
1209  					if(tween.loopType==LeanTweenType.once || tween.loopCount==1){
1210  						if(tweenAction==TweenAction.DELAYED_SOUND){
1211  							AudioSource.PlayClipAtPoint((AudioClip)tween.onCompleteParam, tween.to, tween.from.x);
1212  						}
1213  						if(tween.onComplete!=null){
1214  							removeTween(i);
1215  							tween.onComplete();
1216  						}else if(tween.onCompleteObject!=null){
1217  							removeTween(i);
1218  							tween.onCompleteObject(tween.onCompleteParam);
1219  						}
1220  						#if !UNITY_METRO
1221  						else if(tween.optional!=null){
1222  							System.Action callback=null;
1223  							System.Action&lt;object&gt; callbackWithParam = null;
1224  							string callbackS=string.Empty;
1225  							object callbackParam=null;
1226  							if(tween.optional!=null &amp;&amp; tween.trans){
1227  								if(tween.optional[&quot;onComplete&quot;]!=null){
1228  									callbackParam = tween.optional[&quot;onCompleteParam&quot;];
1229  									if(tween.optional[&quot;onComplete&quot;].GetType()==typeof(string)){
1230  										callbackS = tween.optional[&quot;onComplete&quot;] as string;
1231  									}else{
1232  										if(callbackParam!=null){
1233  											callbackWithParam = (System.Action&lt;object&gt;)tween.optional[&quot;onComplete&quot;];
1234  										}else{
1235  											callback = (System.Action)tween.optional[&quot;onComplete&quot;];	
1236  											if(callback==null)
1237  												Debug.LogWarning(&quot;callback was not converted&quot;);
1238  										}
1239  									}
1240  								}
1241  							}
1242  							removeTween(i);
1243  							if(callbackWithParam!=null){
1244  								callbackWithParam( callbackParam );
1245  							}else if(callback!=null){
1246  								callback();
1247  							}else if(callbackS!=string.Empty){
1248  								if (tween.optional[&quot;onCompleteTarget&quot;]!=null){
1249  									customTarget = tween.optional[&quot;onCompleteTarget&quot;] as GameObject;
1250  									if(callbackParam!=null) customTarget.BroadcastMessage ( callbackS, callbackParam );
1251  									else customTarget.BroadcastMessage( callbackS );
1252  								}else{
1253  									if(callbackParam!=null) trans.gameObject.BroadcastMessage ( callbackS, callbackParam );
1254  									else trans.gameObject.BroadcastMessage( callbackS );
1255  								}
1256  							}
1257  						}
1258  						#endif
1259  						else{
1260  							removeTween(i);
1261  						}
1262  					}else{
1263  						if(tween.loopCount&lt;0 &amp;&amp; tween.type==TweenAction.CALLBACK){
1264  							if(tween.onComplete!=null){
1265  								tween.onComplete();
1266  							}else if(tween.onCompleteObject!=null){
1267  								tween.onCompleteObject(tween.onCompleteParam);
1268  							}
1269  						}
1270  						if(tween.loopCount&gt;=1){
1271  							tween.loopCount--;
1272  						}
1273  						if(tween.loopType==LeanTweenType.clamp){
1274  							tween.passed = Mathf.Epsilon;
1275  						}else if(tween.loopType==LeanTweenType.pingPong){
1276  							tween.direction = 0.0f-(tween.direction);
1277  						}
1278  					}
1279  				}else if(tween.delay&lt;=0){
1280  					tween.passed += dt*tween.direction;
1281  				}else{
1282  					tween.delay -= dt;
1283  					if(tween.delay&lt;0){
1284  						tween.passed = 0.0f;
1285  						tween.delay = 0.0f;
1286  					}
1287  				}
1288  			}
1289  		}
1290  		frameRendered = Time.frameCount;
1291  	}
1292  }
1293  public static void removeTween( int i ){
1294  	if(tweens[i].toggle){
1295  		tweens[i].toggle = false;
1296  		if(tweens[i].destroyOnComplete){
1297  			if(tweens[i].ltRect!=null){
1298  				LTGUI.destroy( tweens[i].ltRect.id );
1299  			}else{ 
1300  			}
1301  		}
1302  		startSearch = i;
1303  		if(i+1&gt;=tweenMaxSearch){
1304  			startSearch = 0;
1305  			tweenMaxSearch--;
1306  		}
1307  	}
1308  }
1309  public static Vector3[] add(Vector3[] a, Vector3 b){
1310  	Vector3[] c = new Vector3[ a.Length ];
1311  	for(i=0; i&lt;a.Length; i++){
1312  		c[i] = a[i] + b;
1313  	}
1314  	return c;
1315  }
1316  public static float closestRot( float from, float to ){
1317  	float minusWhole = 0 - (360 - to);
1318  	float plusWhole = 360 + to;
1319  	float toDiffAbs = Mathf.Abs( to-from );
1320  	float minusDiff = Mathf.Abs(minusWhole-from);
1321  	float plusDiff = Mathf.Abs(plusWhole-from);
1322  	if( toDiffAbs &lt; minusDiff &amp;&amp; toDiffAbs &lt; plusDiff ){
1323  		return to;
1324  	}else {
1325  		if(minusDiff &lt; plusDiff){
1326  			return minusWhole;
1327  		}else{
1328  			return plusWhole;
1329  		}
1330  	}
1331  }
1332  public static void cancel( GameObject gameObject ){
1333  	init();
1334  	Transform trans = gameObject.transform;
1335  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1336  		if(tweens[i].trans==trans)
1337  			removeTween(i);
1338  	}
1339  }
1340  public static void cancel( GameObject gameObject, int uniqueId ){
1341  	if(uniqueId&gt;=0){
1342  		init();
1343  		int backId = uniqueId &amp; 0xFFFF;
1344  		int backCounter = uniqueId &gt;&gt; 16;
1345  		if(tweens[backId].trans==null || (tweens[backId].trans.gameObject == gameObject &amp;&amp; tweens[backId].counter==backCounter))
1346  			removeTween((int)backId);
1347  	}
1348  }
1349  public static void cancel( LTRect ltRect, int uniqueId ){
1350  	if(uniqueId&gt;=0){
1351  		init();
1352  		int backId = uniqueId &amp; 0xFFFF;
1353  		int backCounter = uniqueId &gt;&gt; 16;
1354  		if(tweens[backId].ltRect == ltRect &amp;&amp; tweens[backId].counter==backCounter)
1355  			removeTween((int)backId);
1356  	}
1357  }
1358  private static void cancel( int uniqueId ){
1359  	if(uniqueId&gt;=0){
1360  		init();
1361  		int backId = uniqueId &amp; 0xFFFF;
1362  		int backCounter = uniqueId &gt;&gt; 16;
1363  		if(tweens[backId].hasInitiliazed &amp;&amp; tweens[backId].counter==backCounter)
1364  			removeTween((int)backId);
1365  	}
1366  }
1367  public static LTDescr description( int uniqueId ){
1368  	int backId = uniqueId &amp; 0xFFFF;
1369  	int backCounter = uniqueId &gt;&gt; 16;
1370  	if(tweens[backId]!=null &amp;&amp; tweens[backId].uniqueId == uniqueId &amp;&amp; tweens[backId].counter==backCounter)
1371  		return tweens[backId];
1372  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1373  		if(tweens[i].uniqueId == uniqueId &amp;&amp; tweens[i].counter==backCounter)
1374  			return tweens[i];
1375  	}
1376  	return null;
1377  }
1378  public static void pause( GameObject gameObject, int uniqueId ){
1379  	pause( uniqueId );
1380  }
1381  public static void pause( int uniqueId ){
1382  	int backId = uniqueId &amp; 0xFFFF;
1383  	int backCounter = uniqueId &gt;&gt; 16;
1384  	if(tweens[backId].counter==backCounter){
1385  		tweens[backId].pause();
1386  	}
1387  }
1388  public static void pause( GameObject gameObject ){
1389  	Transform trans = gameObject.transform;
1390  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1391  		if(tweens[i].trans==trans){
1392  			tweens[i].pause();
1393  		}
1394  	}
1395  }
1396  public static void resume( GameObject gameObject, int uniqueId ){
1397  	resume( uniqueId );
1398  }
1399  public static void resume( int uniqueId ){
1400  	int backId = uniqueId &amp; 0xFFFF;
1401  	int backCounter = uniqueId &gt;&gt; 16;
1402  	if(tweens[backId].counter==backCounter){
1403  		tweens[backId].resume();
1404  	}
1405  }
1406  public static void resume( GameObject gameObject ){
1407  	Transform trans = gameObject.transform;
1408  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1409  		if(tweens[i].trans==trans)
1410  			tweens[i].resume();
1411  	}
1412  }
1413  public static bool isTweening( GameObject gameObject ){
1414  	Transform trans = gameObject.transform;
1415  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1416  		if(tweens[i].toggle &amp;&amp; tweens[i].trans==trans)
1417  			return true;
1418  	}
1419  	return false;
1420  }
1421  public static bool isTweening( int uniqueId ){
1422  	int backId = uniqueId &amp; 0xFFFF;
1423  	int backCounter = uniqueId &gt;&gt; 16;
1424  	if(tweens[backId].counter==backCounter &amp;&amp; tweens[backId].toggle){
1425  		return true;
1426  	}
1427  	return false;
1428  }
1429  public static bool isTweening( LTRect ltRect ){
1430  	for( int i = 0; i &lt; tweenMaxSearch; i++){
1431  		if(tweens[i].toggle &amp;&amp; tweens[i].ltRect==ltRect)
1432  			return true;
1433  	}
1434  	return false;
1435  }
1436  public static void drawBezierPath(Vector3 a, Vector3 b, Vector3 c, Vector3 d){
1437      Vector3 last = a;
1438      Vector3 p;
1439      Vector3 aa = (-a + 3*(b-c) + d);
1440  	Vector3 bb = 3*(a+c) - 6*b;
1441  	Vector3 cc = 3*(b-a);
1442  	float t;
1443      for(float k = 1.0f; k &lt;= 30.0f; k++){
1444      	t = k / 30.0f;
1445      	p = ((aa* t + (bb))* t + cc)* t + a;
1446  	    Gizmos.DrawLine(last, p);
1447  	    last = p;
1448  	}
1449  }
1450  public static object logError( string error ){
1451  	if(throwErrors) Debug.LogError(error); else Debug.Log(error);
1452  	return null;
1453  }
1454  public static LTDescr options(LTDescr seed){ Debug.LogError(&quot;error this function is no longer used&quot;); return null; }
1455  public static LTDescr options(){
1456  	init();
1457  	for(j=0, i = startSearch; j &lt; maxTweens; i++){
1458  		if(i&gt;=maxTweens-1)
1459  			i = 0;
1460  		if(tweens[i].toggle==false){
1461  			if(i+1&gt;tweenMaxSearch)
1462  				tweenMaxSearch = i+1;
1463  			startSearch = i + 1;
1464  			break;
1465  		}
1466  		j++;
1467  		if(j&gt;=maxTweens)
1468  			return logError(&quot;LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( &quot;+(maxTweens*2)+&quot; );&quot;) as LTDescr;
1469  	}
1470  	tween = tweens[i];
1471  	tween.reset();
1472  	tween.setId( (uint)i );
1473  	return tween;
1474  }
1475  public static GameObject tweenEmpty{
1476  	get{
1477  		init(maxTweens);
1478  		return _tweenEmpty;
1479  	}
1480  }
1481  public static int startSearch = 0;
1482  public static LTDescr descr;
1483  private static LTDescr pushNewTween( GameObject gameObject, Vector3 to, float time, TweenAction tweenAction, LTDescr tween ){
1484  	init(maxTweens);
1485  	if(gameObject==null)
1486  		return null;
1487  	tween.trans = gameObject.transform;
1488  	tween.to = to;
1489  	tween.time = time;
1490  	tween.type = tweenAction;
1491  	return tween;
1492  }
1493  public static LTDescr alpha(GameObject gameObject, float to, float time){
1494  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ALPHA, options() );
1495  }
1496  public static LTDescr alpha(LTRect ltRect, float to, float time){
1497  	ltRect.alphaEnabled = true;
1498  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ALPHA, options().setRect( ltRect ) );
1499  }
1500  public static LTDescr alphaVertex(GameObject gameObject, float to, float time){
1501  	return pushNewTween( gameObject, new Vector3(to,0f,0f), time, TweenAction.ALPHA_VERTEX, options() );
1502  }
1503  public static LTDescr delayedCall( float delayTime, Action callback){
1504  	return pushNewTween( tweenEmpty, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1505  }
1506  public static LTDescr delayedCall( float delayTime, Action&lt;object&gt; callback){
1507  	return pushNewTween( tweenEmpty, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1508  }
1509  public static LTDescr delayedCall( GameObject gameObject, float delayTime, Action callback){
1510  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1511  }
1512  public static LTDescr delayedCall( GameObject gameObject, float delayTime, Action&lt;object&gt; callback){
1513  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1514  }
1515  public static LTDescr destroyAfter( LTRect rect, float delayTime){
1516  	return pushNewTween( tweenEmpty, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setRect( rect ).setDestroyOnComplete(true) );
1517  }
1518  public static LTDescr move(GameObject gameObject, Vector3 to, float time){
1519  	return pushNewTween( gameObject, to, time, TweenAction.MOVE, options() );
1520  }
1521  public static LTDescr move(GameObject gameObject, Vector2 to, float time){
1522  	return pushNewTween( gameObject, new Vector3(to.x, to.y, gameObject.transform.position.z), time, TweenAction.MOVE, options() );
1523  }
1524  public static LTDescr move(GameObject gameObject, Vector3[] to, float time){
1525  	descr = options();
1526  	if(descr.path==null)
1527  		descr.path = new LTBezierPath( to );
1528  	else 
1529  		descr.path.setPoints( to );
1530  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED, descr );
1531  }
1532  public static LTDescr moveSpline(GameObject gameObject, Vector3[] to, float time){
1533  	descr = options();
1534  	descr.spline = new LTSpline( to );
1535  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_SPLINE, descr );
1536  }
1537  public static LTDescr moveSplineLocal(GameObject gameObject, Vector3[] to, float time){
1538  	descr = options();
1539  	descr.spline = new LTSpline( to );
1540  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_SPLINE_LOCAL, descr );
1541  }
1542  public static LTDescr move(LTRect ltRect, Vector2 to, float time){
1543  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE, options().setRect( ltRect ) );
1544  }
1545  public static LTDescr moveMargin(LTRect ltRect, Vector2 to, float time){
1546  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE_MARGIN, options().setRect( ltRect ) );
1547  }
1548  public static LTDescr moveX(GameObject gameObject, float to, float time){
1549  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_X, options() );
1550  }
1551  public static LTDescr moveY(GameObject gameObject, float to, float time){
1552  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Y, options() );
1553  }
1554  public static LTDescr moveZ(GameObject gameObject, float to, float time){
1555  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Z, options() );
1556  }
1557  public static LTDescr moveLocal(GameObject gameObject, Vector3 to, float time){
1558  	return pushNewTween( gameObject, to, time, TweenAction.MOVE_LOCAL, options() );
1559  }
1560  public static LTDescr moveLocal(GameObject gameObject, Vector3[] to, float time){
1561  	descr = options();
1562  	if(descr.path==null)
1563  		descr.path = new LTBezierPath( to );
1564  	else 
1565  		descr.path.setPoints( to );
1566  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED_LOCAL, descr );
1567  }
1568  public static LTDescr moveLocalX(GameObject gameObject, float to, float time){
1569  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_X, options() );
1570  }
1571  public static LTDescr moveLocalY(GameObject gameObject, float to, float time){
1572  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Y, options() );
1573  }
1574  public static LTDescr moveLocalZ(GameObject gameObject, float to, float time){
1575  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Z, options() );
1576  }
1577  public static LTDescr rotate(GameObject gameObject, Vector3 to, float time){
1578  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE, options() );
1579  }
1580  public static LTDescr rotate(LTRect ltRect, float to, float time){
1581  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ROTATE, options().setRect( ltRect ) );
1582  }
1583  public static LTDescr rotateLocal(GameObject gameObject, Vector3 to, float time){
1584  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE_LOCAL, options() );
1585  }
1586  public static LTDescr rotateX(GameObject gameObject, float to, float time){
1587  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_X, options() );
1588  }
1589  public static LTDescr rotateY(GameObject gameObject, float to, float time){
1590  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Y, options() );
1591  }
1592  public static LTDescr rotateZ(GameObject gameObject, float to, float time){
1593  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Z, options() );
1594  }
1595  public static LTDescr rotateAround(GameObject gameObject, Vector3 axis, float add, float time){
1596  	return pushNewTween( gameObject, new Vector3(add,0f,0f), time, TweenAction.ROTATE_AROUND, options().setAxis(axis) );
1597  }
1598  public static LTDescr scale(GameObject gameObject, Vector3 to, float time){
1599  	return pushNewTween( gameObject, to, time, TweenAction.SCALE, options() );
1600  }
1601  public static LTDescr scale(LTRect ltRect, Vector2 to, float time){
1602  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_SCALE, options().setRect( ltRect ) );
1603  }
1604  public static LTDescr scaleX(GameObject gameObject, float to, float time){
1605  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_X, options() );
1606  }
1607  public static LTDescr scaleY(GameObject gameObject, float to, float time){
1608  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Y, options() );
1609  }
1610  public static LTDescr scaleZ(GameObject gameObject, float to, float time){
1611  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Z, options());
1612  }
1613  public static LTDescr value(GameObject gameObject, Action&lt;float&gt; callOnUpdate, float from, float to, float time){
1614  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, options().setTo( new Vector3(to,0,0) ).setFrom( new Vector3(from,0,0) ).setOnUpdate(callOnUpdate) );
1615  }
1616  public static LTDescr value(GameObject gameObject, Action&lt;Vector3&gt; callOnUpdate, Vector3 from, Vector3 to, float time){
1617  	return pushNewTween( gameObject, to, time, TweenAction.VALUE3, options().setTo( to ).setFrom( from ).setOnUpdateVector3(callOnUpdate) );
1618  }
1619  public static LTDescr value(GameObject gameObject, Action&lt;float,object&gt; callOnUpdate, float from, float to, float time){
1620  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, options().setTo( new Vector3(to,0,0) ).setFrom( new Vector3(from,0,0) ).setOnUpdateObject(callOnUpdate) );
1621  }
1622  public static LTDescr delayedSound( AudioClip audio, Vector3 pos, float volume ){
1623  	return pushNewTween( tweenEmpty, pos, 0f, TweenAction.DELAYED_SOUND, options().setTo( pos ).setFrom( new Vector3(volume,0,0) ).setAudio( audio ) );
1624  }
1625  #if !UNITY_METRO
1626  public static Hashtable h( object[] arr ){
1627  	if(arr.Length%2==1){
1628  		logError(&quot;LeanTween - You have attempted to create a Hashtable with an odd number of values.&quot;);
1629  		return null;
1630  	}
1631  	Hashtable hash = new Hashtable();
1632  	for(i = 0; i &lt; arr.Length; i += 2){
1633  		hash.Add(arr[i] as string, arr[i+1]);
1634  	}
1635  	return hash;
1636  }
1637  private static int idFromUnique( int uniqueId ){
1638  	return uniqueId &amp; 0xFFFF;
1639  }
1640  private static int pushNewTween( GameObject gameObject, Vector3 to, float time, TweenAction tweenAction, Hashtable optional ){
1641  	init(maxTweens);
1642  	if(gameObject==null)
1643  		return -1;
1644  	j = 0;
1645  	for(i = startSearch; j &lt; maxTweens; i++){
1646  		if(i&gt;=maxTweens-1)
1647  			i = 0;
1648  		if(tweens[i].toggle==false){
1649  			if(i+1&gt;tweenMaxSearch)
1650  				tweenMaxSearch = i+1;
1651  			startSearch = i + 1;
1652  			break;
1653  		}
1654  		j++;
1655  		if(j&gt;=maxTweens){
1656  			logError(&quot;LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( &quot;+(maxTweens*2)+&quot; );&quot;);
1657  			return -1;
1658  		}
1659  	}
1660  	tween = tweens[i];
1661  	tween.toggle = true;
1662  	tween.reset();
1663  	tween.trans = gameObject.transform;
1664  	tween.to = to;
1665  	tween.time = time;
1666  	tween.type = tweenAction;
1667  	tween.optional = optional;
1668  	tween.setId( (uint)i );
1669  	if(optional!=null){
1670          var ease = optional[&quot;ease&quot;];
1671  		var optionsNotUsed = 0;
1672  		if(ease!=null) {
1673              tween.tweenType = LeanTweenType.linear;
1674  			if( ease.GetType() ==typeof( LeanTweenType) ){
1675                  tween.tweenType = (LeanTweenType)ease;
1676  			} else if(ease.GetType() == typeof(AnimationCurve)){
1677  				tween.animationCurve = optional[&quot;ease&quot;] as AnimationCurve;
1678  			} else{
1679  				string func = optional[&quot;ease&quot;].ToString();
1680  				if(func.Equals(&quot;easeOutQuad&quot;)){
1681  					tween.tweenType = LeanTweenType.easeOutQuad;
1682  				}else if(func.Equals(&quot;easeInQuad&quot;)){
1683  					tween.tweenType = LeanTweenType.easeInQuad;
1684  				}else if(func.Equals(&quot;easeInOutQuad&quot;)){
1685  					tween.tweenType = LeanTweenType.easeInOutQuad;
1686  				}
1687  			}
1688  			optionsNotUsed++;
1689  		}
1690  		if(optional[&quot;rect&quot;]!=null){
1691  			tween.ltRect = (LTRect)optional[&quot;rect&quot;];
1692  			optionsNotUsed++;
1693  		}
1694  		if(optional[&quot;path&quot;]!=null){
1695  			tween.path = (LTBezierPath)optional[&quot;path&quot;];
1696  			optionsNotUsed++;
1697  		}
1698  		if(optional[&quot;delay&quot;]!=null){
1699  			tween.delay = (float)optional[&quot;delay&quot;];
1700  			optionsNotUsed++;
1701  		}
1702  		if(optional[&quot;useEstimatedTime&quot;]!=null){
1703  			tween.useEstimatedTime =(bool) optional[&quot;useEstimatedTime&quot;];
1704  			optionsNotUsed++;
1705  		}
1706  		if(optional[&quot;useFrames&quot;]!=null){
1707  			tween.useFrames =(bool) optional[&quot;useFrames&quot;];
1708  			optionsNotUsed++;
1709  		}
1710  		if(optional[&quot;loopType&quot;]!=null){
1711  			tween.loopType = (LeanTweenType)optional[&quot;loopType&quot;];
1712  			optionsNotUsed++;
1713  		}
1714  		if(optional[&quot;repeat&quot;]!=null){
1715  			tween.loopCount = (int)optional[&quot;repeat&quot;];
1716  			if(tween.loopType==LeanTweenType.once)
1717  				tween.loopType = LeanTweenType.clamp;
1718  			optionsNotUsed++;
1719  		}
1720  		if(optional[&quot;point&quot;]!=null){
1721  			tween.point = (Vector3)optional[&quot;point&quot;];
1722  			optionsNotUsed++;
1723  		}
1724  		if(optional[&quot;axis&quot;]!=null){
1725  			tween.axis = (Vector3)optional[&quot;axis&quot;];
1726  			optionsNotUsed++;
1727  		}
1728  		if(optional.Count &lt;= optionsNotUsed)
1729  			tween.optional = null;  
1730  	}else{
1731  		tween.optional = null;
1732  	}
1733  	return tweens[i].uniqueId;
1734  }
1735  public static int value(string callOnUpdate, float from, float to, float time, Hashtable optional){
1736  	return value( tweenEmpty, callOnUpdate, from, to, time, optional );
1737  }
1738  public static int value(GameObject gameObject, string callOnUpdate, float from, float to, float time){
1739  	return value(gameObject, callOnUpdate, from, to, time, new Hashtable()); 
1740  }
1741  public static int value(GameObject gameObject, string callOnUpdate, float from, float to, float time, object[] optional){
1742  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1743  }
1744  public static int value(GameObject gameObject, Action&lt;float&gt; callOnUpdate, float from, float to, float time, object[] optional){
1745  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1746  }
1747  public static int value(GameObject gameObject, Action&lt;float,Hashtable&gt; callOnUpdate, float from, float to, float time, object[] optional){
1748  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1749  }
1750  public static int value(GameObject gameObject,string callOnUpdate, float from, float to, float time, Hashtable optional){
1751  	if(optional==null || optional.Count == 0)
1752  		optional = new Hashtable();
1753  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1754  	int id = idFromUnique( pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, optional ) );
1755  	tweens[id].from = new Vector3(from,0,0);
1756  	return id;
1757  }
1758  public static int value(GameObject gameObject,Action&lt;float&gt; callOnUpdate, float from, float to, float time, Hashtable optional){
1759  	if(optional==null || optional.Count == 0)
1760  		optional = new Hashtable();
1761  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1762  	int id = idFromUnique( pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, optional ) );
1763  	tweens[id].from = new Vector3(from,0,0);
1764  	return id;
1765  }
1766  public static int value(GameObject gameObject,Action&lt;float,Hashtable&gt; callOnUpdate, float from, float to, float time, Hashtable optional){
1767  	if(optional==null || optional.Count == 0)
1768  		optional = new Hashtable();
1769  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1770  	int id = idFromUnique( pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, optional ) );
1771  	tweens[id].from = new Vector3(from,0,0);
1772  	return id;
1773  }
1774  public static int value(GameObject gameObject, String callOnUpdate, Vector3 from, Vector3 to, float time, Hashtable optional){
1775  	if(optional==null || optional.Count==0)
1776  		optional = new Hashtable();
1777  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1778  	int id = idFromUnique( pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional ) );
1779  	tweens[id].from = from;
1780  	return id;
1781  }
1782  public static int value(GameObject gameObject, String callOnUpdate, Vector3 from, Vector3 to, float time, object[] optional){
1783  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1784  }
1785  public static int value(GameObject gameObject, System.Action&lt;Vector3&gt; callOnUpdate, Vector3 from, Vector3 to, float time, Hashtable optional){
1786  	if(optional==null || optional.Count==0)
1787  		optional = new Hashtable();
1788  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1789  	int id = idFromUnique( pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional ) );
1790  	tweens[id].from = from;
1791  	return id;
1792  }
1793  public static int value(GameObject gameObject, System.Action&lt;Vector3,Hashtable&gt; callOnUpdate, Vector3 from, Vector3 to, float time, Hashtable optional){
1794  	if(optional==null || optional.Count==0)
1795  		optional = new Hashtable();
1796  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1797  	int id = idFromUnique( pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional ) );
1798  	tweens[id].from = from;
1799  	return id;
1800  }
1801  public static int value(GameObject gameObject, System.Action&lt;Vector3&gt; callOnUpdate, Vector3 from, Vector3 to, float time, object[] optional){
1802  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1803  }
1804  public static int value(GameObject gameObject, System.Action&lt;Vector3,Hashtable&gt; callOnUpdate, Vector3 from, Vector3 to, float time, object[] optional){
1805  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1806  }
1807  public static int rotate(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1808  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE, optional );
1809  }
1810  public static int rotate(GameObject gameObject, Vector3 to, float time, object[] optional){
1811  	return rotate( gameObject, to, time, h( optional ) );
1812  }
1813  public static int rotate(LTRect ltRect, float to, float time, Hashtable optional){
1814  	init();
1815  	if( optional==null || optional.Count == 0 )
1816  		optional = new Hashtable();
1817  	optional[&quot;rect&quot;] = ltRect;
1818  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ROTATE, optional );
1819  }
1820  public static int rotate(LTRect ltRect, float to, float time, object[] optional){
1821  	return rotate( ltRect, to, time, h(optional) );
1822  }
1823  public static int rotateX(GameObject gameObject, float to, float time, Hashtable optional){
1824  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_X, optional );
1825  }
1826  public static int rotateX(GameObject gameObject, float to, float time, object[] optional){
1827  	return rotateX( gameObject, to, time, h(optional) );
1828  }
1829  public static int rotateY(GameObject gameObject, float to, float time, Hashtable optional){
1830  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Y, optional );
1831  }
1832  public static int rotateY(GameObject gameObject, float to, float time, object[] optional){
1833  	return rotateY( gameObject, to, time, h(optional) );
1834  }
1835  public static int rotateZ(GameObject gameObject, float to, float time, Hashtable optional){
1836  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Z, optional );
1837  }
1838  public static int rotateZ(GameObject gameObject, float to, float time, object[] optional){
1839  	return rotateZ( gameObject, to, time, h(optional) );
1840  }
1841  public static int rotateLocal(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1842  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE_LOCAL, optional );
1843  }
1844  public static int rotateLocal(GameObject gameObject, Vector3 to, float time, object[] optional){
1845  	return rotateLocal( gameObject, to, time, h(optional) );
1846  }
1847  public static int rotateAround(GameObject gameObject, Vector3 axis, float add, float time, Hashtable optional){
1848  	if(optional==null || optional.Count==0)
1849  		optional = new Hashtable();
1850  	optional[&quot;axis&quot;] = axis;
1851  	if(optional[&quot;point&quot;]==null)
1852  		optional[&quot;point&quot;] = Vector3.zero;
1853  	return pushNewTween( gameObject, new Vector3(add,0f,0f), time, TweenAction.ROTATE_AROUND, optional );
1854  }
1855  public static int rotateAround(GameObject gameObject, Vector3 axis, float add, float time, object[] optional){
1856  	return rotateAround(gameObject, axis, add, time, h(optional));
1857  }
1858  public static int moveX(GameObject gameObject, float to, float time, Hashtable optional){
1859  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_X, optional );
1860  }
1861  public static int moveX(GameObject gameObject, float to, float time, object[] optional){
1862  	return moveX( gameObject, to, time, h(optional) );
1863  }
1864  public static int moveY(GameObject gameObject, float to, float time, Hashtable optional){
1865  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Y, optional );
1866  }
1867  public static int moveY(GameObject gameObject, float to, float time, object[] optional){
1868  	return moveY( gameObject, to, time, h(optional) );
1869  }
1870  public static int moveZ(GameObject gameObject, float to, float time, Hashtable optional){
1871  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Z, optional );
1872  }
1873  public static int moveZ(GameObject gameObject, float to, float time, object[] optional){
1874  	return moveZ( gameObject, to, time, h(optional) );
1875  }
1876  public static int move(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1877  	return pushNewTween( gameObject, to, time, TweenAction.MOVE, optional );
1878  }
1879  public static int move(GameObject gameObject, Vector3 to, float time, object[] optional){
1880  	return move( gameObject, to, time, LeanTween.h( optional ) );
1881  }
1882  public static int move(GameObject gameObject, Vector3[] to, float time, Hashtable optional){
1883  	if(to.Length&lt;4){
1884  		string errorMsg = &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot;;
1885  		if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
1886  		return -1;
1887  	}
1888  	if(to.Length%4!=0){
1889  		string errorMsg2 = &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot;;
1890  		if(throwErrors) Debug.LogError(errorMsg2); else Debug.Log(errorMsg2);
1891  		return -1;
1892  	}
1893  	init();
1894  	if( optional==null || optional.Count == 0 )
1895  		optional = new Hashtable();
1896  	LTBezierPath ltPath = new LTBezierPath( to );
1897  	if(optional[&quot;orientToPath&quot;]!=null)
1898  		ltPath.orientToPath = true;
1899  	optional[&quot;path&quot;] = ltPath;
1900  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED, optional );
1901  }
1902  public static int move(GameObject gameObject, Vector3[] to, float time, object[] optional){
1903  	return move( gameObject, to, time, LeanTween.h( optional ) );
1904  }
1905  public static int move(LTRect ltRect, Vector2 to, float time, Hashtable optional){
1906  	init();
1907  	if( optional==null || optional.Count == 0 )
1908  		optional = new Hashtable();
1909  	optional[&quot;rect&quot;] = ltRect;
1910  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE, optional );
1911  }
1912  public static int move(LTRect ltRect, Vector3 to, float time, object[] optional){
1913  	return move( ltRect, to, time, LeanTween.h( optional ) );
1914  }
1915  public static int moveLocal(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1916  	return pushNewTween( gameObject, to, time, TweenAction.MOVE_LOCAL, optional );
1917  }
1918  public static int moveLocal(GameObject gameObject, Vector3 to, float time, object[] optional){
1919  	return moveLocal( gameObject, to, time, LeanTween.h( optional ) );
1920  }
1921  public static int moveLocal(GameObject gameObject, Vector3[] to, float time, Hashtable optional){
1922  	if(to.Length&lt;4){
1923  		string errorMsg = &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot;;
1924  		if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
1925  		return -1;
1926  	}
1927  	if(to.Length%4!=0){
1928  		string errorMsg2 = &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot;;
1929  		if(throwErrors) Debug.LogError(errorMsg2); else Debug.Log(errorMsg2);
1930  		return -1;
1931  	}
1932  	init();
1933  	if( optional == null )
1934  		optional = new Hashtable();
1935  	LTBezierPath ltPath = new LTBezierPath( to );
1936  	if(optional[&quot;orientToPath&quot;]!=null)
1937  		ltPath.orientToPath = true;
1938  	optional[&quot;path&quot;] = ltPath;
1939  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED_LOCAL, optional );
1940  }
1941  public static int moveLocal(GameObject gameObject, Vector3[] to, float time,object[] optional){
1942  	return moveLocal( gameObject, to, time, LeanTween.h( optional ) );
1943  }
1944  public static int moveLocalX(GameObject gameObject, float to, float time, Hashtable optional){
1945  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_X, optional );
1946  }
1947  public static int moveLocalX(GameObject gameObject, float to, float time, object[] optional){
1948  	return moveLocalX( gameObject, to, time, h(optional) );
1949  }
1950  public static int moveLocalY(GameObject gameObject, float to, float time, Hashtable optional){
1951  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Y, optional );
1952  }
1953  public static int moveLocalY(GameObject gameObject, float to, float time, object[] optional){
1954  	return moveLocalY( gameObject, to, time, h(optional) );
1955  }
1956  public static int moveLocalZ(GameObject gameObject, float to, float time, Hashtable optional){
1957  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Z, optional );
1958  }
1959  public static int moveLocalZ(GameObject gameObject, float to, float time, object[] optional){
1960  	return moveLocalZ( gameObject, to, time, h(optional) );
1961  }
1962  public static int scale(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1963  	return pushNewTween( gameObject, to, time, TweenAction.SCALE, optional );
1964  }
1965  public static int scale(GameObject gameObject, Vector3 to, float time, object[] optional){
1966  	return scale( gameObject, to, time, h(optional) );
1967  }
1968  public static int scale(LTRect ltRect,Vector2 to, float time, Hashtable optional)
1969  { 
1970  	init();
1971  	if( optional==null || optional.Count == 0 )
1972  		optional = new Hashtable();
1973  	optional[&quot;rect&quot;] = ltRect;
1974  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_SCALE, optional );
1975  }
1976  public static int scale(LTRect ltRect, Vector2 to, float time, object[] optional){
1977  	return scale( ltRect, to, time, h(optional) );
1978  }
1979  public static int alpha(LTRect ltRect, float to, float time, Hashtable optional){
1980  	init();
1981  	if( optional==null || optional.Count == 0 )
1982  		optional = new Hashtable();
1983  	ltRect.alphaEnabled = true;
1984  	optional[&quot;rect&quot;] = ltRect;
1985  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ALPHA, optional );
1986  }
1987  public static int alpha(LTRect ltRect, float to, float time, object[] optional){
1988  	return alpha( ltRect, to, time, h(optional) );
1989  }
1990  public static int scaleX(GameObject gameObject, float to, float time, Hashtable optional){
1991  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_X, optional );
1992  }
1993  public static int scaleX(GameObject gameObject, float to, float time, object[] optional){
1994  	return scaleX( gameObject, to, time, h(optional) );
1995  }
1996  public static int scaleY(GameObject gameObject, float to, float time, Hashtable optional){
1997  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Y, optional );
1998  }
1999  public static int scaleY(GameObject gameObject, float to, float time, object[] optional){
2000  	return scaleY( gameObject, to, time, h(optional) );
2001  }
2002  public static int scaleZ(GameObject gameObject, float to, float time, Hashtable optional){
2003  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Z, optional );
2004  }
2005  public static int scaleZ(GameObject gameObject, float to, float time, object[] optional){
2006  	return scaleZ( gameObject, to, time, h(optional) );
2007  }
2008  public static int delayedCall( float delayTime, string callback, Hashtable optional ){
2009  	init();
2010  	return delayedCall( tweenEmpty, delayTime, callback, optional );
2011  }
2012  public static int delayedCall( float delayTime, Action callback, object[] optional){
2013  	init();
2014  	return delayedCall( tweenEmpty, delayTime, callback, h(optional) );
2015  }
2016  public static int delayedCall( GameObject gameObject, float delayTime, string callback, object[] optional){
2017  	return delayedCall( gameObject, delayTime, callback, h(optional) );
2018  }
2019  public static int delayedCall( GameObject gameObject, float delayTime, Action callback, object[] optional){
2020  	return delayedCall( gameObject, delayTime, callback, h(optional) );
2021  }
2022  public static int delayedCall( GameObject gameObject, float delayTime, string callback, Hashtable optional){
2023  	if(optional==null || optional.Count == 0)
2024  		optional = new Hashtable();
2025  	optional[&quot;onComplete&quot;] = callback;
2026  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
2027  }
2028  public static int delayedCall( GameObject gameObject, float delayTime, Action callback, Hashtable optional){
2029  	if(optional==null)
2030  		optional = new Hashtable();
2031  	optional[&quot;onComplete&quot;] = callback;
2032  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
2033  }
2034  public static int delayedCall( GameObject gameObject, float delayTime, Action&lt;object&gt; callback, Hashtable optional){
2035  	if(optional==null)
2036  		optional = new Hashtable();
2037  	optional[&quot;onComplete&quot;] = callback;
2038  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
2039  }
2040  public static int alpha(GameObject gameObject, float to, float time, Hashtable optional){
2041  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ALPHA, optional );
2042  }
2043  public static int alpha(GameObject gameObject, float to, float time, object[] optional){
2044  	return alpha(gameObject, to, time, h(optional)); 
2045  }
2046  #endif
2047  private static float tweenOnCurve( LTDescr tweenDescr, float ratioPassed ){
2048  	return tweenDescr.from.x + (tweenDescr.diff.x) * tweenDescr.animationCurve.Evaluate(ratioPassed);
2049  }
2050  private static Vector3 tweenOnCurveVector( LTDescr tweenDescr, float ratioPassed ){
2051  	return	new Vector3(tweenDescr.from.x + (tweenDescr.diff.x) * tweenDescr.animationCurve.Evaluate(ratioPassed),
2052  						tweenDescr.from.y + (tweenDescr.diff.y) * tweenDescr.animationCurve.Evaluate(ratioPassed),
2053  						tweenDescr.from.z + (tweenDescr.diff.z) * tweenDescr.animationCurve.Evaluate(ratioPassed) );
2054  }
2055  private static float easeOutQuadOpt( float start, float diff, float ratioPassed ){
2056  	return -diff * ratioPassed * (ratioPassed - 2) + start;
2057  }
2058  private static float easeInQuadOpt( float start, float diff, float ratioPassed ){
2059  	return diff * ratioPassed * ratioPassed + start;
2060  }
2061  private static float easeInOutQuadOpt( float start, float diff, float ratioPassed ){
2062  	ratioPassed /= .5f;
2063  	if (ratioPassed &lt; 1) return diff / 2 * ratioPassed * ratioPassed + start;
2064  	ratioPassed--;
2065  	return -diff / 2 * (ratioPassed * (ratioPassed - 2) - 1) + start;
2066  }
2067  private static float linear(float start, float end, float val){
2068  	return Mathf.Lerp(start, end, val);
2069  }
2070  private static float clerp(float start, float end, float val){
2071  	float min = 0.0f;
2072  	float max = 360.0f;
2073  	float half = Mathf.Abs((max - min) / 2.0f);
2074  	float retval = 0.0f;
2075  	float diff = 0.0f;
2076  	if ((end - start) &lt; -half){
2077  		diff = ((max - start) + end) * val;
2078  		retval = start + diff;
2079  	}else if ((end - start) &gt; half){
2080  		diff = -((max - end) + start) * val;
2081  		retval = start + diff;
2082  	}else retval = start + (end - start) * val;
2083  	return retval;
2084  }
2085  private static float spring(float start, float end, float val){
2086  	val = Mathf.Clamp01(val);
<span onclick='openModal()' class='match'>2087  	val = (Mathf.Sin(val * Mathf.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + (1.2f * (1f - val)));
2088  	return start + (end - start) * val;
2089  }
2090  private static float easeInQuad(float start, float end, float val){
</span>2091  	end -= start;
2092  	return end * val * val + start;
2093  }
2094  private static float easeOutQuad(float start, float end, float val){
2095  	end -= start;
2096  	return -end * val * (val - 2) + start;
2097  }
2098  private static float easeInOutQuad(float start, float end, float val){
2099  	val /= .5f;
2100  	end -= start;
2101  	if (val &lt; 1) return end / 2 * val * val + start;
2102  	val--;
2103  	return -end / 2 * (val * (val - 2) - 1) + start;
2104  }
2105  private static float easeInCubic(float start, float end, float val){
2106  	end -= start;
2107  	return end * val * val * val + start;
2108  }
2109  private static float easeOutCubic(float start, float end, float val){
2110  	val--;
2111  	end -= start;
2112  	return end * (val * val * val + 1) + start;
2113  }
2114  private static float easeInOutCubic(float start, float end, float val){
2115  	val /= .5f;
2116  	end -= start;
2117  	if (val &lt; 1) return end / 2 * val * val * val + start;
2118  	val -= 2;
2119  	return end / 2 * (val * val * val + 2) + start;
2120  }
2121  private static float easeInQuart(float start, float end, float val){
2122  	end -= start;
2123  	return end * val * val * val * val + start;
2124  }
2125  private static float easeOutQuart(float start, float end, float val){
2126  	val--;
2127  	end -= start;
2128  	return -end * (val * val * val * val - 1) + start;
2129  }
2130  private static float easeInOutQuart(float start, float end, float val){
2131  	val /= .5f;
2132  	end -= start;
2133  	if (val &lt; 1) return end / 2 * val * val * val * val + start;
2134  	val -= 2;
2135  	return -end / 2 * (val * val * val * val - 2) + start;
2136  }
2137  private static float easeInQuint(float start, float end, float val){
2138  	end -= start;
2139  	return end * val * val * val * val * val + start;
2140  }
2141  private static float easeOutQuint(float start, float end, float val){
2142  	val--;
2143  	end -= start;
2144  	return end * (val * val * val * val * val + 1) + start;
2145  }
2146  private static float easeInOutQuint(float start, float end, float val){
2147  	val /= .5f;
2148  	end -= start;
2149  	if (val &lt; 1) return end / 2 * val * val * val * val * val + start;
2150  	val -= 2;
2151  	return end / 2 * (val * val * val * val * val + 2) + start;
2152  }
2153  private static float easeInSine(float start, float end, float val){
2154  	end -= start;
2155  	return -end * Mathf.Cos(val / 1 * (Mathf.PI / 2)) + end + start;
2156  }
2157  private static float easeOutSine(float start, float end, float val){
2158  	end -= start;
2159  	return end * Mathf.Sin(val / 1 * (Mathf.PI / 2)) + start;
2160  }
2161  private static float easeInOutSine(float start, float end, float val){
2162  	end -= start;
2163  	return -end / 2 * (Mathf.Cos(Mathf.PI * val / 1) - 1) + start;
2164  }
2165  private static float easeInExpo(float start, float end, float val){
2166  	end -= start;
2167  	return end * Mathf.Pow(2, 10 * (val / 1 - 1)) + start;
2168  }
2169  private static float easeOutExpo(float start, float end, float val){
2170  	end -= start;
2171  	return end * (-Mathf.Pow(2, -10 * val / 1) + 1) + start;
2172  }
2173  private static float easeInOutExpo(float start, float end, float val){
2174  	val /= .5f;
2175  	end -= start;
2176  	if (val &lt; 1) return end / 2 * Mathf.Pow(2, 10 * (val - 1)) + start;
2177  	val--;
2178  	return end / 2 * (-Mathf.Pow(2, -10 * val) + 2) + start;
2179  }
2180  private static float easeInCirc(float start, float end, float val){
2181  	end -= start;
2182  	return -end * (Mathf.Sqrt(1 - val * val) - 1) + start;
2183  }
2184  private static float easeOutCirc(float start, float end, float val){
2185  	val--;
2186  	end -= start;
2187  	return end * Mathf.Sqrt(1 - val * val) + start;
2188  }
2189  private static float easeInOutCirc(float start, float end, float val){
2190  	val /= .5f;
2191  	end -= start;
2192  	if (val &lt; 1) return -end / 2 * (Mathf.Sqrt(1 - val * val) - 1) + start;
2193  	val -= 2;
2194  	return end / 2 * (Mathf.Sqrt(1 - val * val) + 1) + start;
2195  }
2196  private static float easeInBounce(float start, float end, float val){
2197  	end -= start;
2198  	float d = 1f;
2199  	return end - easeOutBounce(0, end, d-val) + start;
2200  }
2201  private static float easeOutBounce(float start, float end, float val){
2202  	val /= 1f;
2203  	end -= start;
2204  	if (val &lt; (1 / 2.75f)){
2205  		return end * (7.5625f * val * val) + start;
2206  	}else if (val &lt; (2 / 2.75f)){
2207  		val -= (1.5f / 2.75f);
2208  		return end * (7.5625f * (val) * val + .75f) + start;
2209  	}else if (val &lt; (2.5 / 2.75)){
2210  		val -= (2.25f / 2.75f);
2211  		return end * (7.5625f * (val) * val + .9375f) + start;
2212  	}else{
2213  		val -= (2.625f / 2.75f);
2214  		return end * (7.5625f * (val) * val + .984375f) + start;
2215  	}
2216  }
2217  private static float easeInOutBounce(float start, float end, float val){
2218  	end -= start;
2219  	float d= 1f;
2220  	if (val &lt; d/2) return easeInBounce(0, end, val*2) * 0.5f + start;
2221  	else return easeOutBounce(0, end, val*2-d) * 0.5f + end*0.5f + start;
2222  }
2223  private static float easeInBack(float start, float end, float val){
2224  	end -= start;
2225  	val /= 1;
2226  	float s= 1.70158f;
2227  	return end * (val) * val * ((s + 1) * val - s) + start;
2228  }
2229  private static float easeOutBack(float start, float end, float val){
2230  	float s= 1.70158f;
2231  	end -= start;
2232  	val = (val / 1) - 1;
2233  	return end * ((val) * val * ((s + 1) * val + s) + 1) + start;
2234  }
2235  private static float easeInOutBack(float start, float end, float val){
2236  	float s= 1.70158f;
2237  	end -= start;
2238  	val /= .5f;
2239  	if ((val) &lt; 1){
2240  		s *= (1.525f);
2241  		return end / 2 * (val * val * (((s) + 1) * val - s)) + start;
2242  	}
2243  	val -= 2;
2244  	s *= (1.525f);
2245  	return end / 2 * ((val) * val * (((s) + 1) * val + s) + 2) + start;
2246  }
2247  private static float easeInElastic(float start, float end, float val){
2248  	end -= start;
2249  	float d = 1f;
2250  	float p = d * .3f;
2251  	float s= 0;
2252  	float a = 0;
2253  	if (val == 0) return start;
2254  	val = val/d;
2255  	if (val == 1) return start + end;
2256  	if (a == 0f || a &lt; Mathf.Abs(end)){
2257  		a = end;
2258  		s = p / 4;
2259  		}else{
2260  		s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
2261  	}
2262  	val = val-1;
2263  	return -(a * Mathf.Pow(2, 10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p)) + start;
2264  }		
2265  private static float easeOutElastic(float start, float end, float val){
2266  	end -= start;
2267  	float d = 1f;
2268  	float p= d * .3f;
2269  	float s= 0;
2270  	float a= 0;
2271  	if (val == 0) return start;
2272  	val = val / d;
2273  	if (val == 1) return start + end;
2274  	if (a == 0f || a &lt; Mathf.Abs(end)){
2275  		a = end;
2276  		s = p / 4;
2277  		}else{
2278  		s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
2279  	}
2280  	return (a * Mathf.Pow(2, -10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p) + end + start);
2281  }		
2282  private static float easeInOutElastic(float start, float end, float val)
2283  {
2284  	end -= start;
2285  	float d = 1f;
2286  	float p= d * .3f;
2287  	float s= 0;
2288  	float a = 0;
2289  	if (val == 0) return start;
2290  	val = val / (d/2);
2291  	if (val == 2) return start + end;
2292  	if (a == 0f || a &lt; Mathf.Abs(end)){
2293  		a = end;
2294  		s = p / 4;
2295  		}else{
2296  		s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
2297  	}
2298  	if (val &lt; 1){
2299  	 val = val-1;
2300  	 return -0.5f * (a * Mathf.Pow(2, 10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p)) + start;
2301  	}
2302  	val = val-1;
2303  	return a * Mathf.Pow(2, -10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p) * 0.5f + end + start;
2304  }
2305  private static System.Action&lt;LTEvent&gt;[] eventListeners;
2306  private static GameObject[] goListeners;
2307  private static int eventsMaxSearch = 0;
2308  public static int EVENTS_MAX = 10;
2309  public static int LISTENERS_MAX = 10;
2310  public static void addListener( int eventId, System.Action&lt;LTEvent&gt; callback ){
2311  	addListener(tweenEmpty, eventId, callback);
2312  }
2313  public static void addListener( GameObject caller, int eventId, System.Action&lt;LTEvent&gt; callback ){
2314  	if(eventListeners==null){
2315  		eventListeners = new System.Action&lt;LTEvent&gt;[ EVENTS_MAX * LISTENERS_MAX ];
2316  		goListeners = new GameObject[ EVENTS_MAX * LISTENERS_MAX ];
2317  	}
2318  	for(i = 0; i &lt; LISTENERS_MAX; i++){
2319  		int point = eventId*LISTENERS_MAX + i;
2320  		if(goListeners[ point ]==null || eventListeners[ point ]==null){
2321  			eventListeners[ point ] = callback;
2322  			goListeners[ point ] = caller;
2323  			if(i&gt;=eventsMaxSearch)
2324  				eventsMaxSearch = i+1;
2325  			return;
2326  		}
2327  		if(goListeners[ point ] == caller &amp;&amp; System.Object.ReferenceEquals( eventListeners[ point ], callback)){
2328  			return;
2329  		}
2330  	}
2331  	Debug.LogError(&quot;You ran out of areas to add listeners, consider increasing LISTENERS_MAX, ex: LeanTween.LISTENERS_MAX = &quot;+(LISTENERS_MAX*2));
2332  }
2333  public static bool removeListener( int eventId, System.Action&lt;LTEvent&gt; callback ){
2334  	return removeListener( tweenEmpty, eventId, callback);
2335  }
2336  public static bool removeListener( GameObject caller, int eventId, System.Action&lt;LTEvent&gt; callback ){
2337  	for(i = 0; i &lt; eventsMaxSearch; i++){
2338  		int point = eventId*LISTENERS_MAX + i;
2339  		if(goListeners[ point ] == caller &amp;&amp; System.Object.ReferenceEquals( eventListeners[ point ], callback) ){
2340  			eventListeners[ point ] = null;
2341  			goListeners[ point ] = null;
2342  			return true;
2343  		}
2344  	}
2345  	return false;
2346  }
2347  public static void dispatchEvent( int eventId ){
2348  	dispatchEvent( eventId, null);
2349  }
2350  public static void dispatchEvent( int eventId, object data ){
2351  	for(int k = 0; k &lt; eventsMaxSearch; k++){
2352  		int point = eventId*LISTENERS_MAX + k;
2353  		if(eventListeners[ point ]!=null){
2354  			if(goListeners[point]){
2355  				eventListeners[ point ]( new LTEvent(eventId, data) );
2356  			}else{
2357  				eventListeners[ point ] = null;
2358  			}
2359  		}
2360  	}
2361  }
2362  }
2363  public class LTEvent{
2364  	public int id;
2365  	public object data;
2366  	public LTEvent(int id, object data){
2367  		this.id = id;
2368  		this.data = data;
2369  	}
2370  }
2371  public class LTGUI{
2372  	public static int RECT_LEVELS = 5;
2373  	public static int RECTS_PER_LEVEL = 10;
2374  	public static int BUTTONS_MAX = 24;
2375  	private static LTRect[] levels;
2376  	private static int[] levelDepths;
2377  	private static Rect[] buttons;
2378  	private static int[] buttonLevels;
2379  	private static int[] buttonLastFrame;
2380  	private static LTRect r;
2381  	private static Color color = Color.white;
2382  	private static bool isGUIEnabled = false;
2383  	private static int global_counter = 0;
2384  	public enum Element_Type{
2385  		Texture,
2386  		Label
2387  	}
2388  	public static void init(){
2389  		if(levels==null){
2390  			levels = new LTRect[RECT_LEVELS*RECTS_PER_LEVEL];
2391  			levelDepths = new int[RECT_LEVELS];
2392  		}
2393  	}
2394  	public static void initRectCheck(){
2395  		if(buttons==null){
2396  			buttons = new Rect[BUTTONS_MAX];
2397  			buttonLevels = new int[BUTTONS_MAX];
2398  			buttonLastFrame = new int[BUTTONS_MAX];
2399  			for(int i = 0; i &lt; buttonLevels.Length; i++){
2400  				buttonLevels[i] = -1;
2401  			}
2402  		}
2403  	}
2404  	public static void reset(){
2405  		if(isGUIEnabled){
2406  			isGUIEnabled = false;
2407  			for(int i = 0; i &lt; levels.Length; i++){
2408  				levels[i] = null;
2409  			}
2410  			for(int i = 0; i &lt; levelDepths.Length; i++){
2411  				levelDepths[i] = 0;
2412  			}
2413  		}
2414  	}
2415  	public static void update( int updateLevel ){
2416  		if(isGUIEnabled){
2417  			init();
2418  			if(levelDepths[updateLevel]&gt;0){
2419  				color = GUI.color;
2420  				int baseI = updateLevel*RECTS_PER_LEVEL;
2421  				int maxLoop = baseI + levelDepths[updateLevel];
2422  				for(int i = baseI; i &lt; maxLoop; i++){
2423  					r = levels[i];
2424  					if(r!=null &amp;bsol;*&amp;&amp; checkOnScreen(r.rect)*/){
2425  						if(r.useColor)
2426  							GUI.color = r.color;
2427  						if(r.type == Element_Type.Label){
2428  							if(r.style!=null)
2429  								GUI.skin.label = r.style;
2430  							if(r.useSimpleScale){
2431  								GUI.Label( new Rect((r.rect.x + r.margin.x + r.relativeRect.x)*r.relativeRect.width, (r.rect.y + r.margin.y + r.relativeRect.y)*r.relativeRect.height, r.rect.width*r.relativeRect.width, r.rect.height*r.relativeRect.height), r.labelStr );
2432  							}else{
2433  								GUI.Label( new Rect(r.rect.x + r.margin.x, r.rect.y + r.margin.y, r.rect.width, r.rect.height), r.labelStr );
2434  							}
2435  						}else if(r.type == Element_Type.Texture &amp;&amp; r.texture!=null){
2436  							Vector2 size = r.useSimpleScale ? new Vector2(0f, r.rect.height*r.relativeRect.height) : new Vector2(r.rect.width, r.rect.height);
2437  							if(r.sizeByHeight){
2438  								size.x = (float)r.texture.width/(float)r.texture.height * size.y;
2439  							}
2440  							if(r.useSimpleScale){
2441  								GUI.DrawTexture( new Rect((r.rect.x + r.margin.x + r.relativeRect.x)*r.relativeRect.width, (r.rect.y + r.margin.y + r.relativeRect.y)*r.relativeRect.height, size.x, size.y), r.texture );
2442  							}else{
2443  								GUI.DrawTexture( new Rect(r.rect.x + r.margin.x, r.rect.y + r.margin.y, size.x, size.y), r.texture );
2444  							}
2445  						}
2446  					}
2447  				}
2448  				GUI.color = color;
2449  			}
2450  		}
2451  	}
2452  	public static bool checkOnScreen(Rect rect){
2453  		bool offLeft = rect.x + rect.width &lt; 0f;
2454  		bool offRight = rect.x &gt; Screen.width;
2455  		bool offBottom = rect.y &gt; Screen.height;
2456  		bool offTop = rect.y + rect.height &lt; 0f;
2457  		return !(offLeft || offRight || offBottom || offTop);
2458  	}
2459  	public static void destroy( int id ){
2460  		int backId = id &amp; 0xFFFF;
2461  		int backCounter = id &gt;&gt; 16;
2462  		if(id&gt;=0 &amp;&amp; levels[backId]!=null &amp;&amp; levels[backId].hasInitiliazed &amp;&amp; levels[backId].counter==backCounter)
2463  			levels[backId] = null;
2464  	}
2465  	public static LTRect label( Rect rect, string label, int depth){
2466  		return LTGUI.label(new LTRect(rect), label, depth);
2467  	}
2468  	public static LTRect label( LTRect rect, string label, int depth){
2469  		rect.type = Element_Type.Label;
2470  		rect.labelStr = label;
2471  		return element(rect, depth);
2472  	}
2473  	public static LTRect texture( Rect rect, Texture texture, int depth){
2474  		return LTGUI.texture( new LTRect(rect), texture, depth);
2475  	}
2476  	public static LTRect texture( LTRect rect, Texture texture, int depth){
2477  		rect.type = Element_Type.Texture;
2478  		rect.texture = texture;
2479  		return element(rect, depth);
2480  	}
2481  	public static LTRect element( LTRect rect, int depth){
2482  		isGUIEnabled = true;
2483  		init();
2484  		int maxLoop = depth*RECTS_PER_LEVEL + RECTS_PER_LEVEL;
2485  		int k = 0;
2486  		if(rect!=null){
2487  			destroy(rect.id);
2488  		}
2489  		if(rect.type==LTGUI.Element_Type.Label &amp;&amp; rect.style!=null){
2490  			if(rect.style.normal.textColor.a&lt;=0f){
2491  				Debug.LogWarning(&quot;Your GUI normal color has an alpha of zero, and will not be rendered.&quot;);
2492  			}
2493  		}
2494  		if(rect.relativeRect.width==float.PositiveInfinity){
2495  			rect.relativeRect = new Rect(0f,0f,Screen.width,Screen.height);
2496  		}
2497  		for(int i = depth*RECTS_PER_LEVEL; i &lt; maxLoop; i++){
2498  			r = levels[i];
2499  			if(r==null){
2500  				r = rect;
2501  				r.rotateEnabled = true;
2502  				r.alphaEnabled = true;
2503  				r.setId( i, global_counter );
2504  				levels[i] = r;
2505  				if(k&gt;=levelDepths[depth]){
2506  					levelDepths[depth] = k + 1;
2507  				}
2508  				global_counter++;
2509  				return r;
2510  			}
2511  			k++;
2512  		}
2513  		Debug.LogError(&quot;You ran out of GUI Element spaces&quot;);
2514  		return null;
2515  	}
2516  	public static bool hasNoOverlap( Rect rect, int depth ){
2517  		initRectCheck();
2518  		bool hasNoOverlap = true;
2519  		bool wasAddedToList = false;
2520  		for(int i = 0; i &lt; buttonLevels.Length; i++){
2521  			if(buttonLevels[i]&gt;=0){
2522  				if( buttonLastFrame[i] + 1 &lt; Time.frameCount ){ 
2523  					buttonLevels[i] = -1;
2524  				}else{
2525  					if(buttonLevels[i]&gt;depth){
2526  						if(pressedWithinRect( buttons[i] )){
2527  							hasNoOverlap = false; 
2528  						}
2529  					}
2530  				}
2531  			}
2532  			if(wasAddedToList==false &amp;&amp; buttonLevels[i]&lt;0){
2533  				wasAddedToList = true;
2534  				buttonLevels[i] = depth;
2535  				buttons[i] = rect;
2536  				buttonLastFrame[i] = Time.frameCount;
2537  			}
2538  		}
2539  		return hasNoOverlap;
2540  	}
2541  	public static bool pressedWithinRect( Rect rect ){
2542  		Vector2 vec2 = firstTouch();
2543  		if(vec2.x&lt;0f)
2544  			return false;
2545  		float vecY = Screen.height-vec2.y;
2546  		return (vec2.x &gt; rect.x &amp;&amp; vec2.x &lt; rect.x + rect.width &amp;&amp; vecY &gt; rect.y &amp;&amp; vecY &lt; rect.y + rect.height);
2547  	}
2548  	public static bool checkWithinRect(Vector2 vec2, Rect rect){
2549  		vec2.y = Screen.height-vec2.y;
2550  		return (vec2.x &gt; rect.x &amp;&amp; vec2.x &lt; rect.x + rect.width &amp;&amp; vec2.y &gt; rect.y &amp;&amp; vec2.y &lt; rect.y + rect.height);
2551  	}
2552  	public static Vector2 firstTouch(){
2553  		if(Input.touchCount&gt;0){
2554  			return Input.touches[0].position;
2555  		}else if(Input.GetMouseButton(0)){
2556  			return Input.mousePosition;
2557  		}
2558  		return new Vector2(Mathf.NegativeInfinity,Mathf.NegativeInfinity);
2559  	}
2560  }
</code></pre>
        </div>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-LeanTween_56.cs</h3>
            <pre><code>1  using UnityEngine;
2  using System.Collections;
3  using System;
4  public enum LeanTweenType{
5  	notUsed, linear, easeOutQuad, easeInQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart, 
6  	easeInQuint, easeOutQuint, easeInOutQuint, easeInSine, easeOutSine, easeInOutSine, easeInExpo, easeOutExpo, easeInOutExpo, easeInCirc, easeOutCirc, easeInOutCirc, 
7  	easeInBounce, easeOutBounce, easeInOutBounce, easeInBack, easeOutBack, easeInOutBack, easeInElastic, easeOutElastic, easeInOutElastic, easeSpring, easeShake, punch, once, clamp, pingPong, animationCurve
8  }
9  public class LTDescr{
10  	public bool toggle;
11  	public bool useEstimatedTime;
12  	public bool useFrames;
13  	public bool hasInitiliazed;
14  	public bool hasPhysics;
15  	public float passed;
16  	public float delay;
17  	public float time;
18  	public float lastVal;
19  	private uint _id;
20  	public int loopCount;
21  	public uint counter;
22  	public float direction;
23  	public bool destroyOnComplete;
24  	public Transform trans;
25  	public LTRect ltRect;
26  	public Vector3 from;
27  	public Vector3 to;
28  	public Vector3 diff;
29  	public Vector3 point;
30  	public Vector3 axis;
31  	public Vector3 origRotation;
32  	public LTBezierPath path;
33  	public LTSpline spline;
34  	public TweenAction type;
35  	public LeanTweenType tweenType;
36  	public AnimationCurve animationCurve;
37  	public LeanTweenType loopType;
38  	public Action&lt;float&gt; onUpdateFloat;
39  	public Action&lt;float,object&gt; onUpdateFloatObject;
40  	public Action&lt;Vector3&gt; onUpdateVector3;
41  	public Action&lt;Vector3,object&gt; onUpdateVector3Object;
42  	public Action onComplete;
43  	public Action&lt;object&gt; onCompleteObject;
44  	public object onCompleteParam;
45  	public object onUpdateParam;
46  	#if !UNITY_METRO
47  	public Hashtable optional;
48  	#endif
49  	private static uint global_counter = 0;
50      public override string ToString(){
51  		return (trans!=null ? &quot;gameObject:&quot;+trans.gameObject : &quot;gameObject:null&quot;)+&quot; toggle:&quot;+toggle+&quot; passed:&quot;+passed+&quot; time:&quot;+time+&quot; delay:&quot;+delay+&quot; from:&quot;+from+&quot; to:&quot;+to+&quot; type:&quot;+type+&quot; useEstimatedTime:&quot;+useEstimatedTime+&quot; id:&quot;+id+&quot; hasInitiliazed:&quot;+hasInitiliazed;
52  	}
53  	public LTDescr(){
54  	}
55  	public LTDescr cancel(){
56  		LeanTween.removeTween((int)this._id);
57  		return this;
58  	}
59  	public int uniqueId{
60  		get{ 
61  			uint toId = _id | counter &lt;&lt; 16;
62  			return (int)toId;
63  		}
64  	}
65  	public int id{
66  		get{ 
67  			return uniqueId;
68  		}
69  	}
70  	public void reset(){
71  		this.toggle = true;
72  		#if !UNITY_METRO
73  		this.optional = null;
74  		#endif
75  		this.destroyOnComplete = false;
76  		this.passed = this.delay = 0.0f;
77  		this.useEstimatedTime = this.useFrames = this.hasInitiliazed = false;
78  		this.animationCurve = null;
79  		this.tweenType = LeanTweenType.linear;
80  		this.loopType = LeanTweenType.once;
81  		this.loopCount = 0;
82  		this.direction = this.lastVal = 1.0f;
83  		this.onUpdateFloat = null;
84  		this.onUpdateVector3 = null;
85  		this.onUpdateFloatObject = null;
86  		this.onUpdateVector3Object = null;
87  		this.onComplete = null;
88  		this.onCompleteObject = null;
89  		this.onCompleteParam = null;
90  		this.point = Vector3.zero;
91  		global_counter++;
92  	}
93  	public LTDescr pause(){
94  		if(this.direction != 0.0f){ 
95          	this.lastVal =  this.direction;
96              this.direction = 0.0f;
97          }
98          return this;
99  	}
100  	public LTDescr resume(){
101  		this.direction = this.lastVal;
102  		return this;
103  	}
104  	public LTDescr setAxis( Vector3 axis ){
105  		this.axis = axis;
106  		return this;
107  	}
108  	public LTDescr setDelay( float delay ){
109  		if(this.useEstimatedTime){
110  			this.delay = delay;
111  		}else{
112  			this.delay = delay*Time.timeScale;
113  		}
114  		return this;
115  	}
116  	public LTDescr setEase( LeanTweenType easeType ){
117  		this.tweenType = easeType;
118  		return this;
119  	}
120  	public LTDescr setEase( AnimationCurve easeCurve ){
121  		this.animationCurve = easeCurve;
122  		return this;
123  	}
124  	public LTDescr setTo( Vector3 to ){
125  		this.to = to;
126  		return this;
127  	}
128  	public LTDescr setFrom( Vector3 from ){
129  		this.from = from;
130  		this.hasInitiliazed = true; 
131  		this.diff = this.to - this.from;
132  		return this;
133  	}
134  	public LTDescr setId( uint id ){
135  		this._id = id;
136  		this.counter = global_counter;
137  		return this;
138  	}
139  	public LTDescr setRepeat( int repeat ){
140  		this.loopCount = repeat;
141  		if((repeat&gt;1 &amp;&amp; this.loopType == LeanTweenType.once) || (repeat &lt; 0 &amp;&amp; this.loopType == LeanTweenType.once)){
142  			this.loopType = LeanTweenType.clamp;
143  		}
144  		return this;
145  	}
146  	public LTDescr setLoopType( LeanTweenType loopType ){
147  		this.loopType = loopType;
148  		return this;
149  	}
150  	public LTDescr setUseEstimatedTime( bool useEstimatedTime ){
151  		this.useEstimatedTime = useEstimatedTime;
152  		return this;
153  	}
154  	public LTDescr setUseFrames( bool useFrames ){
155  		this.useFrames = useFrames;
156  		return this;
157  	}
158  	public LTDescr setLoopCount( int loopCount ){
159  		this.loopCount = loopCount;
160  		return this;
161  	}
162  	public LTDescr setLoopOnce(){ this.loopType = LeanTweenType.once; return this; }
163  	public LTDescr setLoopClamp(){ 
164  		this.loopType = LeanTweenType.clamp; 
165  		if(this.loopCount==0)
166  			this.loopCount = -1;
167  		return this;
168  	}
169  	public LTDescr setLoopPingPong(){ 
170  		this.loopType = LeanTweenType.pingPong;
171  		if(this.loopCount==0)
172  			this.loopCount = -1;
173  		return this; 
174  	}
175  	public LTDescr setOnComplete( Action onComplete ){
176  		this.onComplete = onComplete;
177  		return this;
178  	}
179  	public LTDescr setOnComplete( Action&lt;object&gt; onComplete ){
180  		this.onCompleteObject = onComplete;
181  		return this;
182  	}
183  	public LTDescr setOnComplete( Action&lt;object&gt; onComplete, object onCompleteParam ){
184  		this.onCompleteObject = onComplete;
185  		if(onCompleteParam!=null)
186  			this.onCompleteParam = onCompleteParam;
187  		return this;
188  	}
189  	public LTDescr setOnCompleteParam( object onCompleteParam ){
190  		this.onCompleteParam = onCompleteParam;
191  		return this;
192  	}
193  	public LTDescr setOnUpdate( Action&lt;float&gt; onUpdate ){
194  		this.onUpdateFloat = onUpdate;
195  		return this;
196  	}
197  	public LTDescr setOnUpdateObject( Action&lt;float,object&gt; onUpdate ){
198  		this.onUpdateFloatObject = onUpdate;
199  		return this;
200  	}
201  	public LTDescr setOnUpdateVector3( Action&lt;Vector3&gt; onUpdate ){
202  		this.onUpdateVector3 = onUpdate;
203  		return this;
204  	}
205  	#if !UNITY_FLASH
206  	public LTDescr setOnUpdate( Action&lt;float,object&gt; onUpdate, object onUpdateParam = null ){
207  		this.onUpdateFloatObject = onUpdate;
208  		if(onUpdateParam!=null)
209  			this.onUpdateParam = onUpdateParam;
210  		return this;
211  	}
212  	public LTDescr setOnUpdate( Action&lt;Vector3,object&gt; onUpdate, object onUpdateParam = null ){
213  		this.onUpdateVector3Object = onUpdate;
214  		if(onUpdateParam!=null)
215  			this.onUpdateParam = onUpdateParam;
216  		return this;
217  	}
218  	public LTDescr setOnUpdate( Action&lt;Vector3&gt; onUpdate, object onUpdateParam = null ){
219  		this.onUpdateVector3 = onUpdate;
220  		if(onUpdateParam!=null)
221  			this.onUpdateParam = onUpdateParam;
222  		return this;
223  	}
224  	#endif
225  	public LTDescr setOnUpdateParam( object onUpdateParam ){
226  		this.onUpdateParam = onUpdateParam;
227  		return this;
228  	}
229  	public LTDescr setOrientToPath( bool doesOrient ){
230  		if(this.type==TweenAction.MOVE_CURVED || this.type==TweenAction.MOVE_CURVED_LOCAL){
231  			if(this.path==null)
232  				this.path = new LTBezierPath();
233  			this.path.orientToPath = doesOrient;
234  		}else{
235  			this.spline.orientToPath = doesOrient;
236  		}
237  		return this;
238  	}
239  	public LTDescr setRect( LTRect rect ){
240  		this.ltRect = rect;
241  		return this;
242  	}
243  	public LTDescr setRect( Rect rect ){
244  		this.ltRect = new LTRect(rect);
245  		return this;
246  	}
247  	public LTDescr setPath( LTBezierPath path ){
248  		this.path = path;
249  		return this;
250  	}
251  	public LTDescr setPoint( Vector3 point ){
252  		this.point = point;
253  		return this;
254  	}
255  	public LTDescr setDestroyOnComplete( bool doesDestroy ){
256  		this.destroyOnComplete = doesDestroy;
257  		return this;
258  	}
259  	public LTDescr setAudio( object audio ){
260  		this.onCompleteParam = audio;
261  		return this;
262  	}
263  }
264  [System.Serializable]
265  public class LTRect : System.Object{
266  	public Rect _rect;
267  	public float alpha = 1f;
268  	public float rotation;
269  	public Vector2 pivot;
270  	public Vector2 margin;
271  	public Rect relativeRect = new Rect(0f,0f,float.PositiveInfinity,float.PositiveInfinity);
272  	public bool rotateEnabled;
273  	[HideInInspector]
274  	public bool rotateFinished;
275  	public bool alphaEnabled;
276  	public string labelStr;
277  	public LTGUI.Element_Type type;
278  	public GUIStyle style;
279  	public bool useColor = false;
280  	public Color color = Color.white;
281  	public bool fontScaleToFit;
282  	public bool useSimpleScale;
283  	public bool sizeByHeight;
284  	public Texture texture;
285  	private int _id = -1;
286  	[HideInInspector]
287  	public int counter;
288  	public static bool colorTouched;
289  	public LTRect(){
290  		reset();
291  		this.rotateEnabled = this.alphaEnabled = true;
292  		_rect = new Rect(0f,0f,1f,1f);
293  	}
294  	public LTRect(Rect rect){
295  		_rect = rect;
296  		reset();
297  	}
298  	public LTRect(float x, float y, float width, float height){
299  		_rect = new Rect(x,y,width,height);
300  		this.alpha = 1.0f;
301  		this.rotation = 0.0f;
302  		this.rotateEnabled = this.alphaEnabled = false;
303  	}
304  	public LTRect(float x, float y, float width, float height, float alpha){
305  		_rect = new Rect(x,y,width,height);
306  		this.alpha = alpha;
307  		this.rotation = 0.0f;
308  		this.rotateEnabled = this.alphaEnabled = false;
309  	}
310  	public LTRect(float x, float y, float width, float height, float alpha, float rotation){
311  		_rect = new Rect(x,y,width,height);
312  		this.alpha = alpha;
313  		this.rotation = rotation;
314  		this.rotateEnabled = this.alphaEnabled = false;
315  		if(rotation!=0.0f){
316  			this.rotateEnabled = true;
317  			resetForRotation();
318  		}
319  	}
320  	public bool hasInitiliazed{
321  		get{ 
322  			return _id!=-1;
323  		}
324  	}
325  	public int id{
326  		get{ 
327  			int toId = _id | counter &lt;&lt; 16;
328  			return toId;
329  		}
330  	} 
331  	public void setId( int id, int counter){
332  		this._id = id;
333  		this.counter = counter;
334  	}
335  	public void reset(){
336  		this.alpha = 1.0f;
337  		this.rotation = 0.0f;
338  		this.rotateEnabled = this.alphaEnabled = false;
339  		this.margin = Vector2.zero;
340  		this.sizeByHeight = false;
341  		this.useColor = false;
342  	}
343  	public void resetForRotation(){
344  		Vector3 scale = new Vector3(GUI.matrix[0,0], GUI.matrix[1,1], GUI.matrix[2,2]);
345          if(pivot==Vector2.zero){
346              pivot = new Vector2((_rect.x+((_rect.width)*0.5f )) * scale.x + GUI.matrix[0,3], (_rect.y+((_rect.height)*0.5f )) * scale.y + GUI.matrix[1,3]);
347          }
348  	}
349  	public float x{
350  		get{ return _rect.x; }
351  		set{ _rect.x = value; }
352  	}
353  	public float y{
354  		get{ return _rect.y; }
355  		set{ _rect.y = value; }
356  	}
357  	public float width{
358  		get{ return _rect.width; }
359  		set{ _rect.width = value; }
360  	}
361  	public float height{
362  		get{ return _rect.height; }
363  		set{ _rect.height = value; }
364  	}
365  	public Rect rect{
366  		get{
367  			if(colorTouched){
368  				colorTouched = false;
369  				GUI.color = new Color(GUI.color.r,GUI.color.g,GUI.color.b,1.0f);
370  			}
371  			if(rotateEnabled){
372  				 if(rotateFinished){
373                      rotateFinished = false;
374                      rotateEnabled = false;
375                      pivot = Vector2.zero;
376                  }else{
377                      GUIUtility.RotateAroundPivot(rotation, pivot);
378                  }
379  			}
380  			if(alphaEnabled){
381  				GUI.color = new Color(GUI.color.r,GUI.color.g,GUI.color.b,alpha);
382  				colorTouched = true;
383  			}
384  			if(fontScaleToFit){
385  				if(this.useSimpleScale){
386  					style.fontSize = (int)(_rect.height*this.relativeRect.height);
387  				}else{
388  					style.fontSize = (int)_rect.height;
389  				}
390  			}
391  			return _rect;
392  		}
393  		set{
394  			_rect = value;
395  		}	
396  	}
397  	public LTRect setStyle( GUIStyle style ){
398  		this.style = style;
399  		return this;
400  	}
401  	public LTRect setFontScaleToFit( bool fontScaleToFit ){
402  		this.fontScaleToFit = fontScaleToFit;
403  		return this;
404  	}
405  	public LTRect setColor( Color color ){
406  		this.color = color;
407  		this.useColor = true;
408  		return this;
409  	}
410  	public LTRect setAlpha( float alpha ){
411  		this.alpha = alpha;
412  		return this;
413  	}
414  	public LTRect setLabel( String str ){
415  		this.labelStr = str;
416  		return this;
417  	}
418  	public LTRect setUseSimpleScale( bool useSimpleScale, Rect relativeRect){
419  		this.useSimpleScale = useSimpleScale;
420  		this.relativeRect = relativeRect;
421  		return this;
422  	}
423  	public LTRect setUseSimpleScale( bool useSimpleScale){
424  		this.useSimpleScale = useSimpleScale;
425  		this.relativeRect = new Rect(0f,0f,Screen.width,Screen.height);
426  		return this;
427  	}
428  	public LTRect setSizeByHeight( bool sizeByHeight){
429  		this.sizeByHeight = sizeByHeight;
430  		return this;
431  	}
432  	public override string ToString(){
433  		return &quot;x:&quot;+_rect.x+&quot; y:&quot;+_rect.y+&quot; width:&quot;+_rect.width+&quot; height:&quot;+_rect.height;
434  	}
435  }
436  public class LTBezier{
437  	public float length;
438  	private Vector3 a;
439  	private Vector3 aa;
440  	private Vector3 bb;
441  	private Vector3 cc;
442  	private float len;
443  	private float[] arcLengths;
444  	public LTBezier(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float precision){
445  		this.a = a;
446  	    aa = (-a + 3*(b-c) + d);
447  	    bb = 3*(a+c) - 6*b;
448  	    cc = 3*(b-a);
449  	    this.len = 1.0f / precision;
450  	    arcLengths = new float[(int)this.len + (int)1];
451  	    arcLengths[0] = 0;
452  	    Vector3 ov = a;
453  	    Vector3 v;
454  	    float clen = 0.0f;
455  	    for(int i = 1; i &lt;= this.len; i++) {
456  	        v = bezierPoint(i * precision);
457  	        clen += (ov - v).magnitude;
458  	        this.arcLengths[i] = clen;
459  	        ov = v;
460  	    }
461  	    this.length = clen;
462  	}
463      private float map(float u) {
464          float targetLength = u * this.arcLengths[(int)this.len];
465          int low = 0;
466          int high = (int)this.len;
467          int index = 0;
468          while (low &lt; high) {
469              index = low + ((int)((high - low) / 2.0f) | 0);
470              if (this.arcLengths[index] &lt; targetLength) {
471                  low = index + 1;
472              } else {
473                  high = index;
474              }
475          }
476          if(this.arcLengths[index] &gt; targetLength)
477              index--;
478          if(index&lt;0)
479          	index = 0;
480          return (index + (targetLength - arcLengths[index]) / (arcLengths[index + 1] - arcLengths[index])) / this.len;
481      }
482     	private Vector3 bezierPoint(float t){
483  	    return ((aa* t + (bb))* t + cc)* t + a;
484  	}
485      public Vector3 point(float t){ 
486      	return bezierPoint( map(t) ); 
487      }
488  }
489  public class LTBezierPath{
490  	public Vector3[] pts;
491  	public float length;
492  	public bool orientToPath;
493  	private LTBezier[] beziers;
494  	private float[] lengthRatio;
495  	public LTBezierPath(){ }
496  	public LTBezierPath( Vector3[] pts_ ){
497  		setPoints( pts_ );
498  	}
499  	public void setPoints( Vector3[] pts_ ){
500  		if(pts_.Length&lt;4)
501  			LeanTween.logError( &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot; );
502  		if(pts_.Length%4!=0)
503  			LeanTween.logError( &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot; );
504  		pts = pts_;
505  		int k = 0;
506  		beziers = new LTBezier[ pts.Length / 4 ];
507  		lengthRatio = new float[ beziers.Length ];
508  		int i;
509  		length = 0;
510  		for(i = 0; i &lt; pts.Length; i+=4){
511  			beziers[k] = new LTBezier(pts[i+0],pts[i+2],pts[i+1],pts[i+3],0.05f);
512  			length += beziers[k].length;
513  			k++;
514  		}
515  		for(i = 0; i &lt; beziers.Length; i++){
516  			lengthRatio[i] = beziers[i].length / length;
517  		}
518  	}
519  	public Vector3 point( float ratio ){
520  		float added = 0.0f;
521  		for(int i = 0; i &lt; lengthRatio.Length; i++){
522  			added += lengthRatio[i];
523  			if(added &gt;= ratio)
524  				return beziers[i].point( (ratio-(added-lengthRatio[i])) / lengthRatio[i] );
525  		}
526  		return beziers[lengthRatio.Length-1].point( 1.0f );
527  	}
528  	public void place( Transform transform, float ratio ){
529  		place( transform, ratio, Vector3.up );
530  	}
531  	public void place( Transform transform, float ratio, Vector3 worldUp ){
532  		transform.position = point( ratio );
533  		ratio += 0.001f;
534  		if(ratio&lt;=1.0f)
535  			transform.LookAt( point( ratio ), worldUp );
536  	}
537  	public void placeLocal( Transform transform, float ratio ){
538  		placeLocal( transform, ratio, Vector3.up );
539  	}
540  	public void placeLocal( Transform transform, float ratio, Vector3 worldUp ){
541  		transform.localPosition = point( ratio );
542  		ratio += 0.001f;
543  		if(ratio&lt;=1.0f)
544  			transform.LookAt( transform.parent.TransformPoint( point( ratio ) ), worldUp );
545  	}
546  }
547  [System.Serializable]
548  public class LTSpline {
549  	public Vector3[] pts;
550  	public bool orientToPath;
551  	private float[] lengthRatio;
552  	private float[] lengths;
553  	private int numSections;
554  	private int currPt;
555  	private float totalLength;
556  	public LTSpline(params Vector3[] pts) {
557  		this.pts = new Vector3[pts.Length];
558  		System.Array.Copy(pts, this.pts, pts.Length);
559  		numSections = pts.Length - 3;
560  		int precision = 20;
561  		lengthRatio = new float[precision];
562  		lengths = new float[precision];
563  		Vector3 lastPoint = new Vector3(Mathf.Infinity,0,0);
564  		totalLength = 0f;
565  		for(int i = 0; i &lt; precision; i++){
566  			float fract = (i*1f) / precision;
567  			Vector3 point = interp( fract );
568  			if(i&gt;=1){
569  				lengths[ i ] = (point - lastPoint).magnitude;
570  			}
571  			totalLength += lengths[ i ];
572  			lastPoint = point;
573  		}
574  		float ratioTotal = 0f;
575  		for(int i = 0; i &lt; lengths.Length; i++){
576  			float t = i *1f / (lengths.Length-1);
577  			currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
578  			float ratioLength = lengths[i] / totalLength;
579  			ratioTotal += ratioLength;
580  			lengthRatio[i] = ratioTotal;
581  		}
582  	}
583  	public float map( float t ){
584  		for(int i = 0; i &lt; lengthRatio.Length; i++){
585  			if(lengthRatio[i] &gt;= t){
586  				return lengthRatio[i]+(t-lengthRatio[i]);
587  			}
588  		}
589  		return 1f;
590  	}
591  	public Vector3 interp(float t) {
592  		currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
593  		float u = t * (float) numSections - (float) currPt;
594  		Vector3 a = pts[currPt];
595  		Vector3 b = pts[currPt + 1];
596  		Vector3 c = pts[currPt + 2];
597  		Vector3 d = pts[currPt + 3];
598  		return .5f * (
599  			(-a + 3f * b - 3f * c + d) * (u * u * u)
600  			+ (2f * a - 5f * b + 4f * c - d) * (u * u)
601  			+ (-a + c) * u
602  			+ 2f * b
603  		);
604  	}
605  	public Vector3 point( float ratio ){
606  		float t = map( ratio );
607  		return interp( t );
608  	}
609  	public void place( Transform transform, float ratio ){
610  		place(transform, ratio, Vector3.up);
611  	}
612  	public void place( Transform transform, float ratio, Vector3 worldUp ){
613  		transform.position = point( ratio );
614  		ratio += 0.001f;
615  		if(ratio&lt;=1.0f)
616  			transform.LookAt( point( ratio ), worldUp );
617  	}
618  	public void placeLocal( Transform transform, float ratio ){
619  		placeLocal( transform, ratio, Vector3.up );
620  	}
621  	public void placeLocal( Transform transform, float ratio, Vector3 worldUp ){
622  		transform.localPosition = point( ratio );
623  		ratio += 0.001f;
624  		if(ratio&lt;=1.0f)
625  			transform.LookAt( transform.parent.TransformPoint( point( ratio ) ), worldUp );
626  	}
627  	public void gizmoDraw(float t = -1.0f) {
628  		if(lengthRatio!=null &amp;&amp; lengthRatio.Length&gt;0){
629  			Vector3 prevPt = point(0);
630  			for (int i = 1; i &lt;= 120; i++) {
631  				float pm = (float) i / 120f;
632  				Vector3 currPt = point(pm);
633  				Gizmos.DrawLine(currPt, prevPt);
634  				prevPt = currPt;
635  			}
636  		}
637  	}
638  	public Vector3 Velocity(float t) {
639  		t = map( t );
640  		int numSections = pts.Length - 3;
641  		int currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
642  		float u = t * (float) numSections - (float) currPt;
643  		Vector3 a = pts[currPt];
644  		Vector3 b = pts[currPt + 1];
645  		Vector3 c = pts[currPt + 2];
646  		Vector3 d = pts[currPt + 3];
647  		return 1.5f * (-a + 3f * b - 3f * c + d) * (u * u)
648  				+ (2f * a -5f * b + 4f * c - d) * u
649  				+ .5f * c - .5f * a;
650  	}
651  }
652  public enum TweenAction{
653  	MOVE_X,
654  	MOVE_Y,
655  	MOVE_Z,
656  	MOVE_LOCAL_X,
657  	MOVE_LOCAL_Y,
658  	MOVE_LOCAL_Z,
659  	MOVE_CURVED,
660  	MOVE_CURVED_LOCAL,
661  	MOVE_SPLINE,
662  	MOVE_SPLINE_LOCAL,
663  	SCALE_X,
664  	SCALE_Y,
665  	SCALE_Z,
666  	ROTATE_X,
667  	ROTATE_Y,
668  	ROTATE_Z,
669  	ROTATE_AROUND,
670  	ALPHA,
671  	ALPHA_VERTEX,
672  	CALLBACK,
673  	MOVE,
674  	MOVE_LOCAL,
675  	ROTATE,
676  	ROTATE_LOCAL,
677  	SCALE,
678  	VALUE3,
679  	GUI_MOVE,
680  	GUI_MOVE_MARGIN,
681  	GUI_SCALE,
682  	GUI_ALPHA,
683  	GUI_ROTATE,
684  	DELAYED_SOUND
685  }
686  public class LeanTween: MonoBehaviour {
687  public static bool throwErrors = true;
688  private static LTDescr[] tweens;
689  private static int tweenMaxSearch = 0;
690  private static int maxTweens = 400;
691  private static int frameRendered= -1;
692  private static GameObject _tweenEmpty;
693  private static float dtEstimated;
694  private static float previousRealTime;
695  private static float dt;
696  private static float dtActual;
697  private static LTDescr tween;
698  private static int i;
699  private static int j;
700  private static AnimationCurve punch = new AnimationCurve( new Keyframe(0.0f, 0.0f ), new Keyframe(0.112586f, 0.9976035f ), new Keyframe(0.3120486f, -0.1720615f ), new Keyframe(0.4316337f, 0.07030682f ), new Keyframe(0.5524869f, -0.03141804f ), new Keyframe(0.6549395f, 0.003909959f ), new Keyframe(0.770987f, -0.009817753f ), new Keyframe(0.8838775f, 0.001939224f ), new Keyframe(1.0f, 0.0f ) );
701  private static AnimationCurve shake = new AnimationCurve( new Keyframe(0f, 0f), new Keyframe(0.25f, 1f), new Keyframe(0.75f, -1f), new Keyframe(1f, 0f) ) ;
702  public static void init(){
703  	init(maxTweens);
704  }
705  public static void init(int maxSimultaneousTweens){
706  	if(tweens==null){
707  		maxTweens = maxSimultaneousTweens;
708  		tweens = new LTDescr[maxTweens];
709  		_tweenEmpty = new GameObject();
710  		_tweenEmpty.name = &quot;~LeanTween&quot;;
711  		_tweenEmpty.AddComponent(typeof(LeanTween));
712  		_tweenEmpty.isStatic = true;
713  		#if !UNITY_EDITOR
714  		_tweenEmpty.hideFlags = HideFlags.HideAndDontSave;
715  		#endif
716  		DontDestroyOnLoad( _tweenEmpty );
717  		for(int i = 0; i &lt; maxTweens; i++){
718  			tweens[i] = new LTDescr();
719  		}
720  	}
721  }
722  public static void reset(){
723  	tweens = null;
724  }
725  public void Update(){
726  	LeanTween.update();
727  }
728  public void OnLevelWasLoaded( int lvl ){
729  	LTGUI.reset();
730  }
731  private static Transform trans;
732  private static float timeTotal;
733  private static TweenAction tweenAction;
734  private static float ratioPassed;
735  private static float from;
736  private static float to;
737  private static float val;
738  private static Vector3 newVect;
739  private static bool isTweenFinished;
740  private static GameObject target;
741  private static GameObject customTarget;
742  public static void update() {
743  	if(frameRendered != Time.frameCount){ 
744  		init();
745  		dtEstimated = Time.realtimeSinceStartup - previousRealTime;
746  		if(dtEstimated&gt;0.2f) 
747  			dtEstimated = 0.2f;
748  		previousRealTime = Time.realtimeSinceStartup;
749  		dtActual = Time.deltaTime*Time.timeScale;
750  		for( int i = 0; i &lt; tweenMaxSearch &amp;&amp; i &lt; maxTweens; i++){
751  			if(tweens[i].toggle){
752  				tween = tweens[i];
753  				trans = tween.trans;
754  				timeTotal = tween.time;
755  				tweenAction = tween.type;
756  				dt = dtActual;
757  				if( tween.useEstimatedTime ){
758  					dt = dtEstimated;
759  					timeTotal = tween.time;
760  				}else if( tween.useFrames ){
761  					dt = 1;
762  				}else if(tween.direction==0f){
763  					dt = 0f;
764  				}
765  				if(trans==null){
766  					removeTween(i);
767  					continue;
768  				}
769  				isTweenFinished = false;
770  				if(tween.delay&lt;=0){
771  					if((tween.passed + dt &gt; timeTotal &amp;&amp; tween.direction &gt; 0.0f )){
772  						isTweenFinished = true;
773  						tween.passed = tween.time; 
774  					}else if(tween.direction&lt;0.0f &amp;&amp; tween.passed - dt &lt; 0.0f){
775  						isTweenFinished = true;
776  						tween.passed = Mathf.Epsilon;
777  					}
778  				}
779  				if(!tween.hasInitiliazed &amp;&amp; ((tween.passed==0.0 &amp;&amp; tween.delay==0.0) || tween.passed&gt;0.0) ){
780  					tween.hasInitiliazed = true;
781  					if( !tween.useEstimatedTime ){
782  						tween.time = tween.time*Time.timeScale;
783  					}
784  					switch(tweenAction){
785  						case TweenAction.MOVE:
786  							tween.from = trans.position; break;
787  						case TweenAction.MOVE_X:
788  							tween.from.x = trans.position.x; break;
789  						case TweenAction.MOVE_Y:
790  							tween.from.x = trans.position.y; break;
791  						case TweenAction.MOVE_Z:
792  							tween.from.x = trans.position.z; break;
793  						case TweenAction.MOVE_LOCAL_X:
794  							tweens[i].from.x = trans.localPosition.x; break;
795  						case TweenAction.MOVE_LOCAL_Y:
796  							tweens[i].from.x = trans.localPosition.y; break;
797  						case TweenAction.MOVE_LOCAL_Z:
798  							tweens[i].from.x = trans.localPosition.z; break;
799  						case TweenAction.SCALE_X:
800  							tween.from.x = trans.localScale.x; break;
801  						case TweenAction.SCALE_Y:
802  							tween.from.x = trans.localScale.y; break;
803  						case TweenAction.SCALE_Z:
804  							tween.from.x = trans.localScale.z; break;
805  						case TweenAction.ALPHA:
806  							#if UNITY_3_5 || UNITY_4_0 || UNITY_4_0_1 || UNITY_4_1 || UNITY_4_2
807  								tween.from.x = trans.gameObject.renderer.material.color.a; 
808  								break;	
809  							#else
810  								SpriteRenderer ren = trans.gameObject.GetComponent&lt;SpriteRenderer&gt;();
811  								tween.from.x = (ren!=null) ? ren.color.a : trans.gameObject.renderer.material.color.a;
812  								break;
813  							#endif
814  						case TweenAction.MOVE_LOCAL:
815  							tween.from = trans.localPosition; break;
816  						case TweenAction.MOVE_CURVED:
817  						case TweenAction.MOVE_CURVED_LOCAL:
818  						case TweenAction.MOVE_SPLINE:
819  						case TweenAction.MOVE_SPLINE_LOCAL:
820  							tween.from.x = 0; break;
821  						case TweenAction.ROTATE:
822  							tween.from = trans.eulerAngles; 
823  							tween.to = new Vector3(LeanTween.closestRot( tween.from.x, tween.to.x), LeanTween.closestRot( tween.from.y, tween.to.y), LeanTween.closestRot( tween.from.z, tween.to.z));
824  							break;
825  						case TweenAction.ROTATE_X:
826  							tween.from.x = trans.eulerAngles.x; 
827  							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
828  							break;
829  						case TweenAction.ROTATE_Y:
830  							tween.from.x = trans.eulerAngles.y; 
831  							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
832  							break;
833  						case TweenAction.ROTATE_Z:
834  							tween.from.x = trans.eulerAngles.z; 
835  							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
836  							break;
837  						case TweenAction.ROTATE_AROUND:
838  							tween.lastVal = 0.0f; 
839  							tween.origRotation = trans.eulerAngles; 
840  							break;
841  						case TweenAction.ROTATE_LOCAL:
842  							tween.from = trans.localEulerAngles; 
843  							tween.to = new Vector3(LeanTween.closestRot( tween.from.x, tween.to.x), LeanTween.closestRot( tween.from.y, tween.to.y), LeanTween.closestRot( tween.from.z, tween.to.z));
844  							break;
845  						case TweenAction.SCALE:
846  							tween.from = trans.localScale; break;
847  						case TweenAction.GUI_MOVE:
848  							tween.from = new Vector3(tween.ltRect.rect.x, tween.ltRect.rect.y, 0); break;
849  						case TweenAction.GUI_MOVE_MARGIN:
850  							tween.from = new Vector2(tween.ltRect.margin.x, tween.ltRect.margin.y); break;
851  						case TweenAction.GUI_SCALE:
852  							tween.from = new  Vector3(tween.ltRect.rect.width, tween.ltRect.rect.height, 0); break;
853  						case TweenAction.GUI_ALPHA:
854  							tween.from.x = tween.ltRect.alpha; break;
855  						case TweenAction.GUI_ROTATE:
856  							if(tween.ltRect.rotateEnabled==false){
857  								tween.ltRect.rotateEnabled = true;
858  								tween.ltRect.resetForRotation();
859  							}
860  							tween.from.x = tween.ltRect.rotation; break;
861  						case TweenAction.ALPHA_VERTEX:
862  							tween.from.x = trans.GetComponent&lt;MeshFilter&gt;().mesh.colors32[0].a;
863  							break;
864  					}
865  					tween.diff = tween.to - tween.from;
866  				}
867  				if(tween.delay&lt;=0){
868  					if(timeTotal&lt;=0f){
869  						ratioPassed = 0f;
870  					}else{
871  						ratioPassed = tween.passed / timeTotal;
872  					}
873  					if(ratioPassed&gt;1.0f){
874  						ratioPassed = 1.0f;
875  					}else if(ratioPassed&lt;0f){
876  						ratioPassed = 0f;
877  					}
878  					if(tweenAction&gt;=TweenAction.MOVE_X &amp;&amp; tweenAction&lt;=TweenAction.CALLBACK){
879  						if(tween.animationCurve!=null){
880  							val = tweenOnCurve(tween, ratioPassed);
881  						}else {
882  							switch( tween.tweenType ){
883  								case LeanTweenType.linear:
884  									val = tween.from.x + tween.diff.x * ratioPassed; break;
885  								case LeanTweenType.easeOutQuad:
886  									val = easeOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
887  								case LeanTweenType.easeInQuad:
888  									val = easeInQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
889  								case LeanTweenType.easeInOutQuad:
890  									val = easeInOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
891  								case LeanTweenType.easeInCubic:
892  									val = easeInCubic(tween.from.x, tween.to.x, ratioPassed); break;
893  								case LeanTweenType.easeOutCubic:
894  									val = easeOutCubic(tween.from.x, tween.to.x, ratioPassed); break;
895  								case LeanTweenType.easeInOutCubic:
896  									val = easeInOutCubic(tween.from.x, tween.to.x, ratioPassed); break;
897  								case LeanTweenType.easeInQuart:
898  									val = easeInQuart(tween.from.x, tween.to.x, ratioPassed); break;
899  								case LeanTweenType.easeOutQuart:
900  									val = easeOutQuart(tween.from.x, tween.to.x, ratioPassed); break;
901  								case LeanTweenType.easeInOutQuart:
902  									val = easeInOutQuart(tween.from.x, tween.to.x, ratioPassed); break;
903  								case LeanTweenType.easeInQuint:
904  									val = easeInQuint(tween.from.x, tween.to.x, ratioPassed); break;
905  								case LeanTweenType.easeOutQuint:
906  									val = easeOutQuint(tween.from.x, tween.to.x, ratioPassed); break;
907  								case LeanTweenType.easeInOutQuint:
908  									val = easeInOutQuint(tween.from.x, tween.to.x, ratioPassed); break;
909  								case LeanTweenType.easeInSine:
910  									val = easeInSine(tween.from.x, tween.to.x, ratioPassed); break;
911  								case LeanTweenType.easeOutSine:
912  									val = easeOutSine(tween.from.x, tween.to.x, ratioPassed); break;
913  								case LeanTweenType.easeInOutSine:
914  									val = easeInOutSine(tween.from.x, tween.to.x, ratioPassed); break;
915  								case LeanTweenType.easeInExpo:
916  									val = easeInExpo(tween.from.x, tween.to.x, ratioPassed); break;
917  								case LeanTweenType.easeOutExpo:
918  									val = easeOutExpo(tween.from.x, tween.to.x, ratioPassed); break;
919  								case LeanTweenType.easeInOutExpo:
920  									val = easeInOutExpo(tween.from.x, tween.to.x, ratioPassed); break;
921  								case LeanTweenType.easeInCirc:
922  									val = easeInCirc(tween.from.x, tween.to.x, ratioPassed); break;
923  								case LeanTweenType.easeOutCirc:
924  									val = easeOutCirc(tween.from.x, tween.to.x, ratioPassed); break;
925  								case LeanTweenType.easeInOutCirc:
926  									val = easeInOutCirc(tween.from.x, tween.to.x, ratioPassed); break;
927  								case LeanTweenType.easeInBounce:
928  									val = easeInBounce(tween.from.x, tween.to.x, ratioPassed); break;
929  								case LeanTweenType.easeOutBounce:
930  									val = easeOutBounce(tween.from.x, tween.to.x, ratioPassed); break;
931  								case LeanTweenType.easeInOutBounce:
932  									val = easeInOutBounce(tween.from.x, tween.to.x, ratioPassed); break;
933  								case LeanTweenType.easeInBack:
934  									val = easeInBack(tween.from.x, tween.to.x, ratioPassed); break;
935  								case LeanTweenType.easeOutBack:
936  									val = easeOutBack(tween.from.x, tween.to.x, ratioPassed); break;
937  								case LeanTweenType.easeInOutBack:
938  									val = easeInOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
939  								case LeanTweenType.easeInElastic:
940  									val = easeInElastic(tween.from.x, tween.to.x, ratioPassed); break;
941  								case LeanTweenType.easeOutElastic:
942  									val = easeOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
943  								case LeanTweenType.easeInOutElastic:
944  									val = easeInOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
945                                  case LeanTweenType.punch:
946  								case LeanTweenType.easeShake:
947  									if(tween.tweenType==LeanTweenType.punch){
948  										tween.animationCurve = LeanTween.punch;
949  									}else if(tween.tweenType==LeanTweenType.easeShake){
950  										tween.animationCurve = LeanTween.shake;
951  									}
952  									tween.to.x = tween.from.x + tween.to.x;
953  									tween.diff.x = tween.to.x - tween.from.x;
954  									val = tweenOnCurve(tween, ratioPassed); break;
955  								case LeanTweenType.easeSpring:
956  									val = spring(tween.from.x, tween.to.x, ratioPassed); break;
957                                  default:
958                                      {
959                                          val = tween.from.x + tween.diff.x * ratioPassed; break;
960                                      }
961  							}
962  						}
963  						if(tweenAction==TweenAction.MOVE_X){
964  							trans.position=new Vector3( val,trans.position.y,trans.position.z);
965  						}else if(tweenAction==TweenAction.MOVE_Y){
966  							trans.position =new Vector3( trans.position.x,val,trans.position.z);
967  						}else if(tweenAction==TweenAction.MOVE_Z){
968  							trans.position=new Vector3( trans.position.x,trans.position.y,val);
969  						}if(tweenAction==TweenAction.MOVE_LOCAL_X){
970  							trans.localPosition=new Vector3( val,trans.localPosition.y,trans.localPosition.z);
971  						}else if(tweenAction==TweenAction.MOVE_LOCAL_Y){
972  							trans.localPosition=new Vector3( trans.localPosition.x,val,trans.localPosition.z);
973  						}else if(tweenAction==TweenAction.MOVE_LOCAL_Z){
974  							trans.localPosition=new Vector3( trans.localPosition.x,trans.localPosition.y,val);
975  						}else if(tweenAction==TweenAction.MOVE_CURVED){
976  							if(tween.path.orientToPath){
977  								tween.path.place( trans, val );
978  							}else{
979  								trans.position = tween.path.point( val );
980  							}
981  						}else if((TweenAction)tweenAction==TweenAction.MOVE_CURVED_LOCAL){
982  							if(tween.path.orientToPath){
983  								tween.path.placeLocal( trans, val );
984  							}else{
985  								trans.localPosition = tween.path.point( val );
986  							}
987  						}else if((TweenAction)tweenAction==TweenAction.MOVE_SPLINE){
988  							if(tween.spline.orientToPath){
989  								tween.spline.place( trans, val );
990  							}else{
991  								trans.position = tween.spline.point( val );
992  							}
993  						}else if((TweenAction)tweenAction==TweenAction.MOVE_SPLINE_LOCAL){
994  							if(tween.spline.orientToPath){
995  								tween.spline.placeLocal( trans, val );
996  							}else{
997  								trans.localPosition = tween.spline.point( val );
998  							}
999  						}else if(tweenAction==TweenAction.SCALE_X){
1000  							trans.localScale=new Vector3(val, trans.localScale.y,trans.localScale.z);
1001  						}else if(tweenAction==TweenAction.SCALE_Y){
1002  							trans.localScale=new Vector3( trans.localScale.x,val,trans.localScale.z);
1003  						}else if(tweenAction==TweenAction.SCALE_Z){
1004  							trans.localScale=new Vector3(trans.localScale.x,trans.localScale.y,val);
1005  						}else if(tweenAction==TweenAction.ROTATE_X){
1006  					    	trans.eulerAngles=new Vector3(val, trans.eulerAngles.y,trans.eulerAngles.z);
1007  					    }else if(tweenAction==TweenAction.ROTATE_Y){
1008  					    	trans.eulerAngles=new Vector3(trans.eulerAngles.x,val,trans.eulerAngles.z);
1009  					    }else if(tweenAction==TweenAction.ROTATE_Z){
1010  					    	trans.eulerAngles=new Vector3(trans.eulerAngles.x,trans.eulerAngles.y,val);
1011  					    }else if(tweenAction==TweenAction.ROTATE_AROUND){
1012  							float move = val -  tween.lastVal;
1013  					    	if(isTweenFinished){
1014  					    		trans.eulerAngles = tween.origRotation;
1015  					    		trans.RotateAround((Vector3)trans.TransformPoint( tween.point ), tween.axis, tween.to.x);
1016  					    	}else{
1017  								trans.RotateAround((Vector3)trans.TransformPoint( tween.point ), tween.axis, move);
1018  								tween.lastVal = val;
1019  					    	}
1020  					    }else if(tweenAction==TweenAction.ALPHA){
1021  					    	#if UNITY_3_5 || UNITY_4_0 || UNITY_4_0_1 || UNITY_4_1 || UNITY_4_2
1022  							foreach(Material mat in trans.gameObject.renderer.materials){
1023          						mat.color = new Color( mat.color.r, mat.color.g, mat.color.b, val);
1024      						}
1025  							#else
1026  							SpriteRenderer ren = trans.gameObject.GetComponent&lt;SpriteRenderer&gt;();
1027  							if(ren!=null){
1028  								ren.color = new Color( ren.color.r, ren.color.g, ren.color.b, val);
1029  							}else{
1030  								foreach(Material mat in trans.gameObject.renderer.materials){
1031  	        						mat.color = new Color( mat.color.r, mat.color.g, mat.color.b, val);
1032  	    						}
1033  							}
1034      						#endif
1035  						}else if(tweenAction==TweenAction.ALPHA_VERTEX){
1036  							Mesh mesh = trans.GetComponent&lt;MeshFilter&gt;().mesh;
1037  							Vector3[] vertices = mesh.vertices;
1038  							Color32[] colors = new Color32[vertices.Length];
1039  							Color32 c = mesh.colors32[0];
1040  							c = new Color( c.r, c.g, c.b, val);
1041  							for (int k= 0; k &lt; vertices.Length; k++) {
1042  								colors[k] = c;
1043  							}
1044  							mesh.colors32 = colors;
1045  						}
1046  					}else if(tweenAction&gt;=TweenAction.MOVE){
1047  						if(tween.animationCurve!=null){
1048  							newVect = tweenOnCurveVector(tween, ratioPassed);
1049  						}else{
1050  							if(tween.tweenType == LeanTweenType.linear){
1051  								newVect = new Vector3( tween.from.x + tween.diff.x * ratioPassed, tween.from.y + tween.diff.y * ratioPassed, tween.from.z + tween.diff.z * ratioPassed);
1052  							}else if(tween.tweenType &gt;= LeanTweenType.linear){
1053  								switch(tween.tweenType){
1054  									case LeanTweenType.easeOutQuad:
1055  										newVect = new Vector3(easeOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeOutQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeOutQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
1056  									case LeanTweenType.easeInQuad:
1057  										newVect = new Vector3(easeInQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeInQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeInQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
1058  									case LeanTweenType.easeInOutQuad:
1059  										newVect = new Vector3(easeInOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeInOutQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeInOutQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
1060  									case LeanTweenType.easeInCubic:
1061  										newVect = new Vector3(easeInCubic(tween.from.x, tween.to.x, ratioPassed), easeInCubic(tween.from.y, tween.to.y, ratioPassed), easeInCubic(tween.from.z, tween.to.z, ratioPassed)); break;
1062  									case LeanTweenType.easeOutCubic:
1063  										newVect = new Vector3(easeOutCubic(tween.from.x, tween.to.x, ratioPassed), easeOutCubic(tween.from.y, tween.to.y, ratioPassed), easeOutCubic(tween.from.z, tween.to.z, ratioPassed)); break;
1064  									case LeanTweenType.easeInOutCubic:
1065  										newVect = new Vector3(easeInOutCubic(tween.from.x, tween.to.x, ratioPassed), easeInOutCubic(tween.from.y, tween.to.y, ratioPassed), easeInOutCubic(tween.from.z, tween.to.z, ratioPassed)); break;
1066  									case LeanTweenType.easeInQuart:
1067  										newVect = new Vector3(easeInQuart(tween.from.x, tween.to.x, ratioPassed), easeInQuart(tween.from.y, tween.to.y, ratioPassed), easeInQuart(tween.from.z, tween.to.z, ratioPassed)); break;
1068  									case LeanTweenType.easeOutQuart:
1069  										newVect = new Vector3(easeOutQuart(tween.from.x, tween.to.x, ratioPassed), easeOutQuart(tween.from.y, tween.to.y, ratioPassed), easeOutQuart(tween.from.z, tween.to.z, ratioPassed)); break;
1070  									case LeanTweenType.easeInOutQuart:
1071  										newVect = new Vector3(easeInOutQuart(tween.from.x, tween.to.x, ratioPassed), easeInOutQuart(tween.from.y, tween.to.y, ratioPassed), easeInOutQuart(tween.from.z, tween.to.z, ratioPassed)); break;
1072  									case LeanTweenType.easeInQuint:
1073  										newVect = new Vector3(easeInQuint(tween.from.x, tween.to.x, ratioPassed), easeInQuint(tween.from.y, tween.to.y, ratioPassed), easeInQuint(tween.from.z, tween.to.z, ratioPassed)); break;
1074  									case LeanTweenType.easeOutQuint:
1075  										newVect = new Vector3(easeOutQuint(tween.from.x, tween.to.x, ratioPassed), easeOutQuint(tween.from.y, tween.to.y, ratioPassed), easeOutQuint(tween.from.z, tween.to.z, ratioPassed)); break;
1076  									case LeanTweenType.easeInOutQuint:
1077  										newVect = new Vector3(easeInOutQuint(tween.from.x, tween.to.x, ratioPassed), easeInOutQuint(tween.from.y, tween.to.y, ratioPassed), easeInOutQuint(tween.from.z, tween.to.z, ratioPassed)); break;
1078  									case LeanTweenType.easeInSine:
1079  										newVect = new Vector3(easeInSine(tween.from.x, tween.to.x, ratioPassed), easeInSine(tween.from.y, tween.to.y, ratioPassed), easeInSine(tween.from.z, tween.to.z, ratioPassed)); break;
1080  									case LeanTweenType.easeOutSine:
1081  										newVect = new Vector3(easeOutSine(tween.from.x, tween.to.x, ratioPassed), easeOutSine(tween.from.y, tween.to.y, ratioPassed), easeOutSine(tween.from.z, tween.to.z, ratioPassed)); break;
1082  									case LeanTweenType.easeInOutSine:
1083  										newVect = new Vector3(easeInOutSine(tween.from.x, tween.to.x, ratioPassed), easeInOutSine(tween.from.y, tween.to.y, ratioPassed), easeInOutSine(tween.from.z, tween.to.z, ratioPassed)); break;
1084  									case LeanTweenType.easeInExpo:
1085  										newVect = new Vector3(easeInExpo(tween.from.x, tween.to.x, ratioPassed), easeInExpo(tween.from.y, tween.to.y, ratioPassed), easeInExpo(tween.from.z, tween.to.z, ratioPassed)); break;
1086  									case LeanTweenType.easeOutExpo:
1087  										newVect = new Vector3(easeOutExpo(tween.from.x, tween.to.x, ratioPassed), easeOutExpo(tween.from.y, tween.to.y, ratioPassed), easeOutExpo(tween.from.z, tween.to.z, ratioPassed)); break;
1088  									case LeanTweenType.easeInOutExpo:
1089  										newVect = new Vector3(easeInOutExpo(tween.from.x, tween.to.x, ratioPassed), easeInOutExpo(tween.from.y, tween.to.y, ratioPassed), easeInOutExpo(tween.from.z, tween.to.z, ratioPassed)); break;
1090  									case LeanTweenType.easeInCirc:
1091  										newVect = new Vector3(easeInCirc(tween.from.x, tween.to.x, ratioPassed), easeInCirc(tween.from.y, tween.to.y, ratioPassed), easeInCirc(tween.from.z, tween.to.z, ratioPassed)); break;
1092  									case LeanTweenType.easeOutCirc:
1093  										newVect = new Vector3(easeOutCirc(tween.from.x, tween.to.x, ratioPassed), easeOutCirc(tween.from.y, tween.to.y, ratioPassed), easeOutCirc(tween.from.z, tween.to.z, ratioPassed)); break;
1094  									case LeanTweenType.easeInOutCirc:
1095  										newVect = new Vector3(easeInOutCirc(tween.from.x, tween.to.x, ratioPassed), easeInOutCirc(tween.from.y, tween.to.y, ratioPassed), easeInOutCirc(tween.from.z, tween.to.z, ratioPassed)); break;
1096  									case LeanTweenType.easeInBounce:
1097  										newVect = new Vector3(easeInBounce(tween.from.x, tween.to.x, ratioPassed), easeInBounce(tween.from.y, tween.to.y, ratioPassed), easeInBounce(tween.from.z, tween.to.z, ratioPassed)); break;
1098  									case LeanTweenType.easeOutBounce:
1099  										newVect = new Vector3(easeOutBounce(tween.from.x, tween.to.x, ratioPassed), easeOutBounce(tween.from.y, tween.to.y, ratioPassed), easeOutBounce(tween.from.z, tween.to.z, ratioPassed)); break;
1100  									case LeanTweenType.easeInOutBounce:
1101  										newVect = new Vector3(easeInOutBounce(tween.from.x, tween.to.x, ratioPassed), easeInOutBounce(tween.from.y, tween.to.y, ratioPassed), easeInOutBounce(tween.from.z, tween.to.z, ratioPassed)); break;
1102  									case LeanTweenType.easeInBack:
1103  										newVect = new Vector3(easeInBack(tween.from.x, tween.to.x, ratioPassed), easeInBack(tween.from.y, tween.to.y, ratioPassed), easeInBack(tween.from.z, tween.to.z, ratioPassed)); break;
1104  									case LeanTweenType.easeOutBack:
1105  										newVect = new Vector3(easeOutBack(tween.from.x, tween.to.x, ratioPassed), easeOutBack(tween.from.y, tween.to.y, ratioPassed), easeOutBack(tween.from.z, tween.to.z, ratioPassed)); break;
1106  									case LeanTweenType.easeInOutBack:
1107  										newVect = new Vector3(easeInOutBack(tween.from.x, tween.to.x, ratioPassed), easeInOutBack(tween.from.y, tween.to.y, ratioPassed), easeInOutBack(tween.from.z, tween.to.z, ratioPassed)); break;
1108  									case LeanTweenType.easeInElastic:
1109  										newVect = new Vector3(easeInElastic(tween.from.x, tween.to.x, ratioPassed), easeInElastic(tween.from.y, tween.to.y, ratioPassed), easeInElastic(tween.from.z, tween.to.z, ratioPassed)); break;
1110  									case LeanTweenType.easeOutElastic:
1111  										newVect = new Vector3(easeOutElastic(tween.from.x, tween.to.x, ratioPassed), easeOutElastic(tween.from.y, tween.to.y, ratioPassed), easeOutElastic(tween.from.z, tween.to.z, ratioPassed)); break;
1112  									case LeanTweenType.easeInOutElastic:
1113  										newVect = new Vector3(easeInOutElastic(tween.from.x, tween.to.x, ratioPassed), easeInOutElastic(tween.from.y, tween.to.y, ratioPassed), easeInOutElastic(tween.from.z, tween.to.z, ratioPassed)); break;
1114  									case LeanTweenType.punch:
1115  									case LeanTweenType.easeShake:
1116  										if(tween.tweenType==LeanTweenType.punch){
1117  											tween.animationCurve = LeanTween.punch;
1118  										}else if(tween.tweenType==LeanTweenType.easeShake){
1119  											tween.animationCurve = LeanTween.shake;
1120  										}
1121  										tween.to = tween.from + tween.to;
1122  										tween.diff = tween.to - tween.from;
1123  										if(tweenAction==TweenAction.ROTATE || tweenAction==TweenAction.ROTATE_LOCAL){
1124  											tween.to = new Vector3(closestRot(tween.from.x, tween.to.x), closestRot(tween.from.y, tween.to.y), closestRot(tween.from.z, tween.to.z));
1125  										}
1126  										newVect = tweenOnCurveVector(tween, ratioPassed); break;
1127  									case LeanTweenType.easeSpring:
1128  										newVect = new Vector3(spring(tween.from.x, tween.to.x, ratioPassed), spring(tween.from.y, tween.to.y, ratioPassed), spring(tween.from.z, tween.to.z, ratioPassed)); break;
1129  								}
1130  							}else{
1131  								newVect = new Vector3( tween.from.x + tween.diff.x * ratioPassed, tween.from.y + tween.diff.y * ratioPassed, tween.from.z + tween.diff.z * ratioPassed);
1132  							}
1133  						}
1134  						if(tweenAction==TweenAction.MOVE){
1135  							trans.position = newVect;
1136  					    }else if(tweenAction==TweenAction.MOVE_LOCAL){
1137  							trans.localPosition = newVect;
1138  					    }else if(tweenAction==TweenAction.ROTATE){
1139  				    			trans.eulerAngles = newVect;
1140  					    }else if(tweenAction==TweenAction.ROTATE_LOCAL){
1141  					    	trans.localEulerAngles = newVect;
1142  					    }else if(tweenAction==TweenAction.SCALE){
1143  					    	trans.localScale = newVect;
1144  					    }else if(tweenAction==TweenAction.GUI_MOVE){
1145  					    	tween.ltRect.rect = new Rect( newVect.x, newVect.y, tween.ltRect.rect.width, tween.ltRect.rect.height);
1146  					    }else if(tweenAction==TweenAction.GUI_MOVE_MARGIN){
1147  					    	tween.ltRect.margin = new Vector2(newVect.x, newVect.y);
1148  					    }else if(tweenAction==TweenAction.GUI_SCALE){
1149  					    	tween.ltRect.rect = new Rect( tween.ltRect.rect.x, tween.ltRect.rect.y, newVect.x, newVect.y);
1150  					    }else if(tweenAction==TweenAction.GUI_ALPHA){
1151  					    	tween.ltRect.alpha = newVect.x;
1152  					    }else if(tweenAction==TweenAction.GUI_ROTATE){
1153  					    	tween.ltRect.rotation = newVect.x;
1154  					    }
1155  					}
1156  					if(tween.onUpdateFloat!=null){
1157  						tween.onUpdateFloat(val);
1158  					}else if(tween.onUpdateFloatObject!=null){
1159  						tween.onUpdateFloatObject(val, tween.onUpdateParam);
1160  					}else if(tween.onUpdateVector3Object!=null){
1161  						tween.onUpdateVector3Object(newVect, tween.onUpdateParam);
1162  					}else if(tween.onUpdateVector3!=null){
1163  						tween.onUpdateVector3(newVect);
1164  					}
1165  					#if !UNITY_METRO
1166  					else if(tween.optional!=null){ 
1167  						var onUpdate = tween.optional[&quot;onUpdate&quot;];
1168  						if(onUpdate!=null){
1169  							Hashtable updateParam = (Hashtable)tween.optional[&quot;onUpdateParam&quot;];
1170  							if((TweenAction)tweenAction==TweenAction.VALUE3){
1171  								if(onUpdate.GetType() == typeof(string)){
1172  									string onUpdateS = onUpdate as string;
1173  									customTarget = tween.optional[&quot;onUpdateTarget&quot;]!=null ? tween.optional[&quot;onUpdateTarget&quot;] as GameObject : trans.gameObject;
1174  									customTarget.BroadcastMessage( onUpdateS, newVect );
1175  								}else if(onUpdate.GetType() == typeof(System.Action&lt;Vector3, Hashtable&gt;)){
1176  									System.Action&lt;Vector3, Hashtable&gt; onUpdateA = (System.Action&lt;Vector3, Hashtable&gt;)onUpdate;
1177  									onUpdateA(newVect, updateParam);
1178  								}else{
1179  									System.Action&lt;Vector3&gt; onUpdateA = (System.Action&lt;Vector3&gt;)onUpdate;
1180  									onUpdateA(newVect);
1181  								}
1182  							}else{
1183  								if(onUpdate.GetType() == typeof(string)){
1184  									string onUpdateS = onUpdate as string;
1185  									if (tween.optional[&quot;onUpdateTarget&quot;]!=null){
1186  										customTarget = tween.optional[&quot;onUpdateTarget&quot;] as GameObject;
1187  										customTarget.BroadcastMessage( onUpdateS, val );
1188  									}else{
1189  										trans.gameObject.BroadcastMessage( onUpdateS, val );
1190  									}
1191  								}else if(onUpdate.GetType() == typeof(System.Action&lt;float, Hashtable&gt;)){
1192  									System.Action&lt;float, Hashtable&gt; onUpdateA = (System.Action&lt;float, Hashtable&gt;)onUpdate;
1193  									onUpdateA(val, updateParam);
1194  								}else if(onUpdate.GetType() == typeof(System.Action&lt;Vector3&gt;)){
1195  									System.Action&lt;Vector3&gt; onUpdateA = (System.Action&lt;Vector3&gt;)onUpdate;
1196  									onUpdateA( newVect );
1197  								}else{
1198  									System.Action&lt;float&gt; onUpdateA = (System.Action&lt;float&gt;)onUpdate;
1199  									onUpdateA(val);
1200  								}
1201  							}
1202  						}
1203  					}
1204  					#endif
1205  				}
1206  				if(isTweenFinished){
1207  					if(tweenAction==TweenAction.GUI_ROTATE)
1208  						tween.ltRect.rotateFinished = true;
1209  					if(tween.loopType==LeanTweenType.once || tween.loopCount==1){
1210  						if(tweenAction==TweenAction.DELAYED_SOUND){
1211  							AudioSource.PlayClipAtPoint((AudioClip)tween.onCompleteParam, tween.to, tween.from.x);
1212  						}
1213  						if(tween.onComplete!=null){
1214  							removeTween(i);
1215  							tween.onComplete();
1216  						}else if(tween.onCompleteObject!=null){
1217  							removeTween(i);
1218  							tween.onCompleteObject(tween.onCompleteParam);
1219  						}
1220  						#if !UNITY_METRO
1221  						else if(tween.optional!=null){
1222  							System.Action callback=null;
1223  							System.Action&lt;object&gt; callbackWithParam = null;
1224  							string callbackS=string.Empty;
1225  							object callbackParam=null;
1226  							if(tween.optional!=null &amp;&amp; tween.trans){
1227  								if(tween.optional[&quot;onComplete&quot;]!=null){
1228  									callbackParam = tween.optional[&quot;onCompleteParam&quot;];
1229  									if(tween.optional[&quot;onComplete&quot;].GetType()==typeof(string)){
1230  										callbackS = tween.optional[&quot;onComplete&quot;] as string;
1231  									}else{
1232  										if(callbackParam!=null){
1233  											callbackWithParam = (System.Action&lt;object&gt;)tween.optional[&quot;onComplete&quot;];
1234  										}else{
1235  											callback = (System.Action)tween.optional[&quot;onComplete&quot;];	
1236  											if(callback==null)
1237  												Debug.LogWarning(&quot;callback was not converted&quot;);
1238  										}
1239  									}
1240  								}
1241  							}
1242  							removeTween(i);
1243  							if(callbackWithParam!=null){
1244  								callbackWithParam( callbackParam );
1245  							}else if(callback!=null){
1246  								callback();
1247  							}else if(callbackS!=string.Empty){
1248  								if (tween.optional[&quot;onCompleteTarget&quot;]!=null){
1249  									customTarget = tween.optional[&quot;onCompleteTarget&quot;] as GameObject;
1250  									if(callbackParam!=null) customTarget.BroadcastMessage ( callbackS, callbackParam );
1251  									else customTarget.BroadcastMessage( callbackS );
1252  								}else{
1253  									if(callbackParam!=null) trans.gameObject.BroadcastMessage ( callbackS, callbackParam );
1254  									else trans.gameObject.BroadcastMessage( callbackS );
1255  								}
1256  							}
1257  						}
1258  						#endif
1259  						else{
1260  							removeTween(i);
1261  						}
1262  					}else{
1263  						if(tween.loopCount&lt;0 &amp;&amp; tween.type==TweenAction.CALLBACK){
1264  							if(tween.onComplete!=null){
1265  								tween.onComplete();
1266  							}else if(tween.onCompleteObject!=null){
1267  								tween.onCompleteObject(tween.onCompleteParam);
1268  							}
1269  						}
1270  						if(tween.loopCount&gt;=1){
1271  							tween.loopCount--;
1272  						}
1273  						if(tween.loopType==LeanTweenType.clamp){
1274  							tween.passed = Mathf.Epsilon;
1275  						}else if(tween.loopType==LeanTweenType.pingPong){
1276  							tween.direction = 0.0f-(tween.direction);
1277  						}
1278  					}
1279  				}else if(tween.delay&lt;=0){
1280  					tween.passed += dt*tween.direction;
1281  				}else{
1282  					tween.delay -= dt;
1283  					if(tween.delay&lt;0){
1284  						tween.passed = 0.0f;
1285  						tween.delay = 0.0f;
1286  					}
1287  				}
1288  			}
1289  		}
1290  		frameRendered = Time.frameCount;
1291  	}
1292  }
1293  public static void removeTween( int i ){
1294  	if(tweens[i].toggle){
1295  		tweens[i].toggle = false;
1296  		if(tweens[i].destroyOnComplete){
1297  			if(tweens[i].ltRect!=null){
1298  				LTGUI.destroy( tweens[i].ltRect.id );
1299  			}else{ 
1300  			}
1301  		}
1302  		startSearch = i;
1303  		if(i+1&gt;=tweenMaxSearch){
1304  			startSearch = 0;
1305  			tweenMaxSearch--;
1306  		}
1307  	}
1308  }
1309  public static Vector3[] add(Vector3[] a, Vector3 b){
1310  	Vector3[] c = new Vector3[ a.Length ];
1311  	for(i=0; i&lt;a.Length; i++){
1312  		c[i] = a[i] + b;
1313  	}
1314  	return c;
1315  }
1316  public static float closestRot( float from, float to ){
1317  	float minusWhole = 0 - (360 - to);
1318  	float plusWhole = 360 + to;
1319  	float toDiffAbs = Mathf.Abs( to-from );
1320  	float minusDiff = Mathf.Abs(minusWhole-from);
1321  	float plusDiff = Mathf.Abs(plusWhole-from);
1322  	if( toDiffAbs &lt; minusDiff &amp;&amp; toDiffAbs &lt; plusDiff ){
1323  		return to;
1324  	}else {
1325  		if(minusDiff &lt; plusDiff){
1326  			return minusWhole;
1327  		}else{
1328  			return plusWhole;
1329  		}
1330  	}
1331  }
1332  public static void cancel( GameObject gameObject ){
1333  	init();
1334  	Transform trans = gameObject.transform;
1335  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1336  		if(tweens[i].trans==trans)
1337  			removeTween(i);
1338  	}
1339  }
1340  public static void cancel( GameObject gameObject, int uniqueId ){
1341  	if(uniqueId&gt;=0){
1342  		init();
1343  		int backId = uniqueId &amp; 0xFFFF;
1344  		int backCounter = uniqueId &gt;&gt; 16;
1345  		if(tweens[backId].trans==null || (tweens[backId].trans.gameObject == gameObject &amp;&amp; tweens[backId].counter==backCounter))
1346  			removeTween((int)backId);
1347  	}
1348  }
1349  public static void cancel( LTRect ltRect, int uniqueId ){
1350  	if(uniqueId&gt;=0){
1351  		init();
1352  		int backId = uniqueId &amp; 0xFFFF;
1353  		int backCounter = uniqueId &gt;&gt; 16;
1354  		if(tweens[backId].ltRect == ltRect &amp;&amp; tweens[backId].counter==backCounter)
1355  			removeTween((int)backId);
1356  	}
1357  }
1358  private static void cancel( int uniqueId ){
1359  	if(uniqueId&gt;=0){
1360  		init();
1361  		int backId = uniqueId &amp; 0xFFFF;
1362  		int backCounter = uniqueId &gt;&gt; 16;
1363  		if(tweens[backId].hasInitiliazed &amp;&amp; tweens[backId].counter==backCounter)
1364  			removeTween((int)backId);
1365  	}
1366  }
1367  public static LTDescr description( int uniqueId ){
1368  	int backId = uniqueId &amp; 0xFFFF;
1369  	int backCounter = uniqueId &gt;&gt; 16;
1370  	if(tweens[backId]!=null &amp;&amp; tweens[backId].uniqueId == uniqueId &amp;&amp; tweens[backId].counter==backCounter)
1371  		return tweens[backId];
1372  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1373  		if(tweens[i].uniqueId == uniqueId &amp;&amp; tweens[i].counter==backCounter)
1374  			return tweens[i];
1375  	}
1376  	return null;
1377  }
1378  public static void pause( GameObject gameObject, int uniqueId ){
1379  	pause( uniqueId );
1380  }
1381  public static void pause( int uniqueId ){
1382  	int backId = uniqueId &amp; 0xFFFF;
1383  	int backCounter = uniqueId &gt;&gt; 16;
1384  	if(tweens[backId].counter==backCounter){
1385  		tweens[backId].pause();
1386  	}
1387  }
1388  public static void pause( GameObject gameObject ){
1389  	Transform trans = gameObject.transform;
1390  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1391  		if(tweens[i].trans==trans){
1392  			tweens[i].pause();
1393  		}
1394  	}
1395  }
1396  public static void resume( GameObject gameObject, int uniqueId ){
1397  	resume( uniqueId );
1398  }
1399  public static void resume( int uniqueId ){
1400  	int backId = uniqueId &amp; 0xFFFF;
1401  	int backCounter = uniqueId &gt;&gt; 16;
1402  	if(tweens[backId].counter==backCounter){
1403  		tweens[backId].resume();
1404  	}
1405  }
1406  public static void resume( GameObject gameObject ){
1407  	Transform trans = gameObject.transform;
1408  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1409  		if(tweens[i].trans==trans)
1410  			tweens[i].resume();
1411  	}
1412  }
1413  public static bool isTweening( GameObject gameObject ){
1414  	Transform trans = gameObject.transform;
1415  	for(int i = 0; i &lt; tweenMaxSearch; i++){
1416  		if(tweens[i].toggle &amp;&amp; tweens[i].trans==trans)
1417  			return true;
1418  	}
1419  	return false;
1420  }
1421  public static bool isTweening( int uniqueId ){
1422  	int backId = uniqueId &amp; 0xFFFF;
1423  	int backCounter = uniqueId &gt;&gt; 16;
1424  	if(tweens[backId].counter==backCounter &amp;&amp; tweens[backId].toggle){
1425  		return true;
1426  	}
1427  	return false;
1428  }
1429  public static bool isTweening( LTRect ltRect ){
1430  	for( int i = 0; i &lt; tweenMaxSearch; i++){
1431  		if(tweens[i].toggle &amp;&amp; tweens[i].ltRect==ltRect)
1432  			return true;
1433  	}
1434  	return false;
1435  }
1436  public static void drawBezierPath(Vector3 a, Vector3 b, Vector3 c, Vector3 d){
1437      Vector3 last = a;
1438      Vector3 p;
1439      Vector3 aa = (-a + 3*(b-c) + d);
1440  	Vector3 bb = 3*(a+c) - 6*b;
1441  	Vector3 cc = 3*(b-a);
1442  	float t;
1443      for(float k = 1.0f; k &lt;= 30.0f; k++){
1444      	t = k / 30.0f;
1445      	p = ((aa* t + (bb))* t + cc)* t + a;
1446  	    Gizmos.DrawLine(last, p);
1447  	    last = p;
1448  	}
1449  }
1450  public static object logError( string error ){
1451  	if(throwErrors) Debug.LogError(error); else Debug.Log(error);
1452  	return null;
1453  }
1454  public static LTDescr options(LTDescr seed){ Debug.LogError(&quot;error this function is no longer used&quot;); return null; }
1455  public static LTDescr options(){
1456  	init();
1457  	for(j=0, i = startSearch; j &lt; maxTweens; i++){
1458  		if(i&gt;=maxTweens-1)
1459  			i = 0;
1460  		if(tweens[i].toggle==false){
1461  			if(i+1&gt;tweenMaxSearch)
1462  				tweenMaxSearch = i+1;
1463  			startSearch = i + 1;
1464  			break;
1465  		}
1466  		j++;
1467  		if(j&gt;=maxTweens)
1468  			return logError(&quot;LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( &quot;+(maxTweens*2)+&quot; );&quot;) as LTDescr;
1469  	}
1470  	tween = tweens[i];
1471  	tween.reset();
1472  	tween.setId( (uint)i );
1473  	return tween;
1474  }
1475  public static GameObject tweenEmpty{
1476  	get{
1477  		init(maxTweens);
1478  		return _tweenEmpty;
1479  	}
1480  }
1481  public static int startSearch = 0;
1482  public static LTDescr descr;
1483  private static LTDescr pushNewTween( GameObject gameObject, Vector3 to, float time, TweenAction tweenAction, LTDescr tween ){
1484  	init(maxTweens);
1485  	if(gameObject==null)
1486  		return null;
1487  	tween.trans = gameObject.transform;
1488  	tween.to = to;
1489  	tween.time = time;
1490  	tween.type = tweenAction;
1491  	return tween;
1492  }
1493  public static LTDescr alpha(GameObject gameObject, float to, float time){
1494  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ALPHA, options() );
1495  }
1496  public static LTDescr alpha(LTRect ltRect, float to, float time){
1497  	ltRect.alphaEnabled = true;
1498  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ALPHA, options().setRect( ltRect ) );
1499  }
1500  public static LTDescr alphaVertex(GameObject gameObject, float to, float time){
1501  	return pushNewTween( gameObject, new Vector3(to,0f,0f), time, TweenAction.ALPHA_VERTEX, options() );
1502  }
1503  public static LTDescr delayedCall( float delayTime, Action callback){
1504  	return pushNewTween( tweenEmpty, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1505  }
1506  public static LTDescr delayedCall( float delayTime, Action&lt;object&gt; callback){
1507  	return pushNewTween( tweenEmpty, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1508  }
1509  public static LTDescr delayedCall( GameObject gameObject, float delayTime, Action callback){
1510  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1511  }
1512  public static LTDescr delayedCall( GameObject gameObject, float delayTime, Action&lt;object&gt; callback){
1513  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setOnComplete(callback) );
1514  }
1515  public static LTDescr destroyAfter( LTRect rect, float delayTime){
1516  	return pushNewTween( tweenEmpty, Vector3.zero, delayTime, TweenAction.CALLBACK, options().setRect( rect ).setDestroyOnComplete(true) );
1517  }
1518  public static LTDescr move(GameObject gameObject, Vector3 to, float time){
1519  	return pushNewTween( gameObject, to, time, TweenAction.MOVE, options() );
1520  }
1521  public static LTDescr move(GameObject gameObject, Vector2 to, float time){
1522  	return pushNewTween( gameObject, new Vector3(to.x, to.y, gameObject.transform.position.z), time, TweenAction.MOVE, options() );
1523  }
1524  public static LTDescr move(GameObject gameObject, Vector3[] to, float time){
1525  	descr = options();
1526  	if(descr.path==null)
1527  		descr.path = new LTBezierPath( to );
1528  	else 
1529  		descr.path.setPoints( to );
1530  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED, descr );
1531  }
1532  public static LTDescr moveSpline(GameObject gameObject, Vector3[] to, float time){
1533  	descr = options();
1534  	descr.spline = new LTSpline( to );
1535  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_SPLINE, descr );
1536  }
1537  public static LTDescr moveSplineLocal(GameObject gameObject, Vector3[] to, float time){
1538  	descr = options();
1539  	descr.spline = new LTSpline( to );
1540  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_SPLINE_LOCAL, descr );
1541  }
1542  public static LTDescr move(LTRect ltRect, Vector2 to, float time){
1543  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE, options().setRect( ltRect ) );
1544  }
1545  public static LTDescr moveMargin(LTRect ltRect, Vector2 to, float time){
1546  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE_MARGIN, options().setRect( ltRect ) );
1547  }
1548  public static LTDescr moveX(GameObject gameObject, float to, float time){
1549  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_X, options() );
1550  }
1551  public static LTDescr moveY(GameObject gameObject, float to, float time){
1552  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Y, options() );
1553  }
1554  public static LTDescr moveZ(GameObject gameObject, float to, float time){
1555  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Z, options() );
1556  }
1557  public static LTDescr moveLocal(GameObject gameObject, Vector3 to, float time){
1558  	return pushNewTween( gameObject, to, time, TweenAction.MOVE_LOCAL, options() );
1559  }
1560  public static LTDescr moveLocal(GameObject gameObject, Vector3[] to, float time){
1561  	descr = options();
1562  	if(descr.path==null)
1563  		descr.path = new LTBezierPath( to );
1564  	else 
1565  		descr.path.setPoints( to );
1566  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED_LOCAL, descr );
1567  }
1568  public static LTDescr moveLocalX(GameObject gameObject, float to, float time){
1569  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_X, options() );
1570  }
1571  public static LTDescr moveLocalY(GameObject gameObject, float to, float time){
1572  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Y, options() );
1573  }
1574  public static LTDescr moveLocalZ(GameObject gameObject, float to, float time){
1575  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Z, options() );
1576  }
1577  public static LTDescr rotate(GameObject gameObject, Vector3 to, float time){
1578  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE, options() );
1579  }
1580  public static LTDescr rotate(LTRect ltRect, float to, float time){
1581  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ROTATE, options().setRect( ltRect ) );
1582  }
1583  public static LTDescr rotateLocal(GameObject gameObject, Vector3 to, float time){
1584  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE_LOCAL, options() );
1585  }
1586  public static LTDescr rotateX(GameObject gameObject, float to, float time){
1587  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_X, options() );
1588  }
1589  public static LTDescr rotateY(GameObject gameObject, float to, float time){
1590  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Y, options() );
1591  }
1592  public static LTDescr rotateZ(GameObject gameObject, float to, float time){
1593  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Z, options() );
1594  }
1595  public static LTDescr rotateAround(GameObject gameObject, Vector3 axis, float add, float time){
1596  	return pushNewTween( gameObject, new Vector3(add,0f,0f), time, TweenAction.ROTATE_AROUND, options().setAxis(axis) );
1597  }
1598  public static LTDescr scale(GameObject gameObject, Vector3 to, float time){
1599  	return pushNewTween( gameObject, to, time, TweenAction.SCALE, options() );
1600  }
1601  public static LTDescr scale(LTRect ltRect, Vector2 to, float time){
1602  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_SCALE, options().setRect( ltRect ) );
1603  }
1604  public static LTDescr scaleX(GameObject gameObject, float to, float time){
1605  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_X, options() );
1606  }
1607  public static LTDescr scaleY(GameObject gameObject, float to, float time){
1608  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Y, options() );
1609  }
1610  public static LTDescr scaleZ(GameObject gameObject, float to, float time){
1611  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Z, options());
1612  }
1613  public static LTDescr value(GameObject gameObject, Action&lt;float&gt; callOnUpdate, float from, float to, float time){
1614  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, options().setTo( new Vector3(to,0,0) ).setFrom( new Vector3(from,0,0) ).setOnUpdate(callOnUpdate) );
1615  }
1616  public static LTDescr value(GameObject gameObject, Action&lt;Vector3&gt; callOnUpdate, Vector3 from, Vector3 to, float time){
1617  	return pushNewTween( gameObject, to, time, TweenAction.VALUE3, options().setTo( to ).setFrom( from ).setOnUpdateVector3(callOnUpdate) );
1618  }
1619  public static LTDescr value(GameObject gameObject, Action&lt;float,object&gt; callOnUpdate, float from, float to, float time){
1620  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, options().setTo( new Vector3(to,0,0) ).setFrom( new Vector3(from,0,0) ).setOnUpdateObject(callOnUpdate) );
1621  }
1622  public static LTDescr delayedSound( AudioClip audio, Vector3 pos, float volume ){
1623  	return pushNewTween( tweenEmpty, pos, 0f, TweenAction.DELAYED_SOUND, options().setTo( pos ).setFrom( new Vector3(volume,0,0) ).setAudio( audio ) );
1624  }
1625  #if !UNITY_METRO
1626  public static Hashtable h( object[] arr ){
1627  	if(arr.Length%2==1){
1628  		logError(&quot;LeanTween - You have attempted to create a Hashtable with an odd number of values.&quot;);
1629  		return null;
1630  	}
1631  	Hashtable hash = new Hashtable();
1632  	for(i = 0; i &lt; arr.Length; i += 2){
1633  		hash.Add(arr[i] as string, arr[i+1]);
1634  	}
1635  	return hash;
1636  }
1637  private static int idFromUnique( int uniqueId ){
1638  	return uniqueId &amp; 0xFFFF;
1639  }
1640  private static int pushNewTween( GameObject gameObject, Vector3 to, float time, TweenAction tweenAction, Hashtable optional ){
1641  	init(maxTweens);
1642  	if(gameObject==null)
1643  		return -1;
1644  	j = 0;
1645  	for(i = startSearch; j &lt; maxTweens; i++){
1646  		if(i&gt;=maxTweens-1)
1647  			i = 0;
1648  		if(tweens[i].toggle==false){
1649  			if(i+1&gt;tweenMaxSearch)
1650  				tweenMaxSearch = i+1;
1651  			startSearch = i + 1;
1652  			break;
1653  		}
1654  		j++;
1655  		if(j&gt;=maxTweens){
1656  			logError(&quot;LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( &quot;+(maxTweens*2)+&quot; );&quot;);
1657  			return -1;
1658  		}
1659  	}
1660  	tween = tweens[i];
1661  	tween.toggle = true;
1662  	tween.reset();
1663  	tween.trans = gameObject.transform;
1664  	tween.to = to;
1665  	tween.time = time;
1666  	tween.type = tweenAction;
1667  	tween.optional = optional;
1668  	tween.setId( (uint)i );
1669  	if(optional!=null){
1670          var ease = optional[&quot;ease&quot;];
1671  		var optionsNotUsed = 0;
1672  		if(ease!=null) {
1673              tween.tweenType = LeanTweenType.linear;
1674  			if( ease.GetType() ==typeof( LeanTweenType) ){
1675                  tween.tweenType = (LeanTweenType)ease;
1676  			} else if(ease.GetType() == typeof(AnimationCurve)){
1677  				tween.animationCurve = optional[&quot;ease&quot;] as AnimationCurve;
1678  			} else{
1679  				string func = optional[&quot;ease&quot;].ToString();
1680  				if(func.Equals(&quot;easeOutQuad&quot;)){
1681  					tween.tweenType = LeanTweenType.easeOutQuad;
1682  				}else if(func.Equals(&quot;easeInQuad&quot;)){
1683  					tween.tweenType = LeanTweenType.easeInQuad;
1684  				}else if(func.Equals(&quot;easeInOutQuad&quot;)){
1685  					tween.tweenType = LeanTweenType.easeInOutQuad;
1686  				}
1687  			}
1688  			optionsNotUsed++;
1689  		}
1690  		if(optional[&quot;rect&quot;]!=null){
1691  			tween.ltRect = (LTRect)optional[&quot;rect&quot;];
1692  			optionsNotUsed++;
1693  		}
1694  		if(optional[&quot;path&quot;]!=null){
1695  			tween.path = (LTBezierPath)optional[&quot;path&quot;];
1696  			optionsNotUsed++;
1697  		}
1698  		if(optional[&quot;delay&quot;]!=null){
1699  			tween.delay = (float)optional[&quot;delay&quot;];
1700  			optionsNotUsed++;
1701  		}
1702  		if(optional[&quot;useEstimatedTime&quot;]!=null){
1703  			tween.useEstimatedTime =(bool) optional[&quot;useEstimatedTime&quot;];
1704  			optionsNotUsed++;
1705  		}
1706  		if(optional[&quot;useFrames&quot;]!=null){
1707  			tween.useFrames =(bool) optional[&quot;useFrames&quot;];
1708  			optionsNotUsed++;
1709  		}
1710  		if(optional[&quot;loopType&quot;]!=null){
1711  			tween.loopType = (LeanTweenType)optional[&quot;loopType&quot;];
1712  			optionsNotUsed++;
1713  		}
1714  		if(optional[&quot;repeat&quot;]!=null){
1715  			tween.loopCount = (int)optional[&quot;repeat&quot;];
1716  			if(tween.loopType==LeanTweenType.once)
1717  				tween.loopType = LeanTweenType.clamp;
1718  			optionsNotUsed++;
1719  		}
1720  		if(optional[&quot;point&quot;]!=null){
1721  			tween.point = (Vector3)optional[&quot;point&quot;];
1722  			optionsNotUsed++;
1723  		}
1724  		if(optional[&quot;axis&quot;]!=null){
1725  			tween.axis = (Vector3)optional[&quot;axis&quot;];
1726  			optionsNotUsed++;
1727  		}
1728  		if(optional.Count &lt;= optionsNotUsed)
1729  			tween.optional = null;  
1730  	}else{
1731  		tween.optional = null;
1732  	}
1733  	return tweens[i].uniqueId;
1734  }
1735  public static int value(string callOnUpdate, float from, float to, float time, Hashtable optional){
1736  	return value( tweenEmpty, callOnUpdate, from, to, time, optional );
1737  }
1738  public static int value(GameObject gameObject, string callOnUpdate, float from, float to, float time){
1739  	return value(gameObject, callOnUpdate, from, to, time, new Hashtable()); 
1740  }
1741  public static int value(GameObject gameObject, string callOnUpdate, float from, float to, float time, object[] optional){
1742  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1743  }
1744  public static int value(GameObject gameObject, Action&lt;float&gt; callOnUpdate, float from, float to, float time, object[] optional){
1745  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1746  }
1747  public static int value(GameObject gameObject, Action&lt;float,Hashtable&gt; callOnUpdate, float from, float to, float time, object[] optional){
1748  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1749  }
1750  public static int value(GameObject gameObject,string callOnUpdate, float from, float to, float time, Hashtable optional){
1751  	if(optional==null || optional.Count == 0)
1752  		optional = new Hashtable();
1753  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1754  	int id = idFromUnique( pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, optional ) );
1755  	tweens[id].from = new Vector3(from,0,0);
1756  	return id;
1757  }
1758  public static int value(GameObject gameObject,Action&lt;float&gt; callOnUpdate, float from, float to, float time, Hashtable optional){
1759  	if(optional==null || optional.Count == 0)
1760  		optional = new Hashtable();
1761  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1762  	int id = idFromUnique( pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, optional ) );
1763  	tweens[id].from = new Vector3(from,0,0);
1764  	return id;
1765  }
1766  public static int value(GameObject gameObject,Action&lt;float,Hashtable&gt; callOnUpdate, float from, float to, float time, Hashtable optional){
1767  	if(optional==null || optional.Count == 0)
1768  		optional = new Hashtable();
1769  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1770  	int id = idFromUnique( pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.CALLBACK, optional ) );
1771  	tweens[id].from = new Vector3(from,0,0);
1772  	return id;
1773  }
1774  public static int value(GameObject gameObject, String callOnUpdate, Vector3 from, Vector3 to, float time, Hashtable optional){
1775  	if(optional==null || optional.Count==0)
1776  		optional = new Hashtable();
1777  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1778  	int id = idFromUnique( pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional ) );
1779  	tweens[id].from = from;
1780  	return id;
1781  }
1782  public static int value(GameObject gameObject, String callOnUpdate, Vector3 from, Vector3 to, float time, object[] optional){
1783  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1784  }
1785  public static int value(GameObject gameObject, System.Action&lt;Vector3&gt; callOnUpdate, Vector3 from, Vector3 to, float time, Hashtable optional){
1786  	if(optional==null || optional.Count==0)
1787  		optional = new Hashtable();
1788  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1789  	int id = idFromUnique( pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional ) );
1790  	tweens[id].from = from;
1791  	return id;
1792  }
1793  public static int value(GameObject gameObject, System.Action&lt;Vector3,Hashtable&gt; callOnUpdate, Vector3 from, Vector3 to, float time, Hashtable optional){
1794  	if(optional==null || optional.Count==0)
1795  		optional = new Hashtable();
1796  	optional[&quot;onUpdate&quot;] = callOnUpdate;
1797  	int id = idFromUnique( pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional ) );
1798  	tweens[id].from = from;
1799  	return id;
1800  }
1801  public static int value(GameObject gameObject, System.Action&lt;Vector3&gt; callOnUpdate, Vector3 from, Vector3 to, float time, object[] optional){
1802  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1803  }
1804  public static int value(GameObject gameObject, System.Action&lt;Vector3,Hashtable&gt; callOnUpdate, Vector3 from, Vector3 to, float time, object[] optional){
1805  	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
1806  }
1807  public static int rotate(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1808  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE, optional );
1809  }
1810  public static int rotate(GameObject gameObject, Vector3 to, float time, object[] optional){
1811  	return rotate( gameObject, to, time, h( optional ) );
1812  }
1813  public static int rotate(LTRect ltRect, float to, float time, Hashtable optional){
1814  	init();
1815  	if( optional==null || optional.Count == 0 )
1816  		optional = new Hashtable();
1817  	optional[&quot;rect&quot;] = ltRect;
1818  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ROTATE, optional );
1819  }
1820  public static int rotate(LTRect ltRect, float to, float time, object[] optional){
1821  	return rotate( ltRect, to, time, h(optional) );
1822  }
1823  public static int rotateX(GameObject gameObject, float to, float time, Hashtable optional){
1824  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_X, optional );
1825  }
1826  public static int rotateX(GameObject gameObject, float to, float time, object[] optional){
1827  	return rotateX( gameObject, to, time, h(optional) );
1828  }
1829  public static int rotateY(GameObject gameObject, float to, float time, Hashtable optional){
1830  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Y, optional );
1831  }
1832  public static int rotateY(GameObject gameObject, float to, float time, object[] optional){
1833  	return rotateY( gameObject, to, time, h(optional) );
1834  }
1835  public static int rotateZ(GameObject gameObject, float to, float time, Hashtable optional){
1836  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ROTATE_Z, optional );
1837  }
1838  public static int rotateZ(GameObject gameObject, float to, float time, object[] optional){
1839  	return rotateZ( gameObject, to, time, h(optional) );
1840  }
1841  public static int rotateLocal(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1842  	return pushNewTween( gameObject, to, time, TweenAction.ROTATE_LOCAL, optional );
1843  }
1844  public static int rotateLocal(GameObject gameObject, Vector3 to, float time, object[] optional){
1845  	return rotateLocal( gameObject, to, time, h(optional) );
1846  }
1847  public static int rotateAround(GameObject gameObject, Vector3 axis, float add, float time, Hashtable optional){
1848  	if(optional==null || optional.Count==0)
1849  		optional = new Hashtable();
1850  	optional[&quot;axis&quot;] = axis;
1851  	if(optional[&quot;point&quot;]==null)
1852  		optional[&quot;point&quot;] = Vector3.zero;
1853  	return pushNewTween( gameObject, new Vector3(add,0f,0f), time, TweenAction.ROTATE_AROUND, optional );
1854  }
1855  public static int rotateAround(GameObject gameObject, Vector3 axis, float add, float time, object[] optional){
1856  	return rotateAround(gameObject, axis, add, time, h(optional));
1857  }
1858  public static int moveX(GameObject gameObject, float to, float time, Hashtable optional){
1859  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_X, optional );
1860  }
1861  public static int moveX(GameObject gameObject, float to, float time, object[] optional){
1862  	return moveX( gameObject, to, time, h(optional) );
1863  }
1864  public static int moveY(GameObject gameObject, float to, float time, Hashtable optional){
1865  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Y, optional );
1866  }
1867  public static int moveY(GameObject gameObject, float to, float time, object[] optional){
1868  	return moveY( gameObject, to, time, h(optional) );
1869  }
1870  public static int moveZ(GameObject gameObject, float to, float time, Hashtable optional){
1871  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_Z, optional );
1872  }
1873  public static int moveZ(GameObject gameObject, float to, float time, object[] optional){
1874  	return moveZ( gameObject, to, time, h(optional) );
1875  }
1876  public static int move(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1877  	return pushNewTween( gameObject, to, time, TweenAction.MOVE, optional );
1878  }
1879  public static int move(GameObject gameObject, Vector3 to, float time, object[] optional){
1880  	return move( gameObject, to, time, LeanTween.h( optional ) );
1881  }
1882  public static int move(GameObject gameObject, Vector3[] to, float time, Hashtable optional){
1883  	if(to.Length&lt;4){
1884  		string errorMsg = &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot;;
1885  		if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
1886  		return -1;
1887  	}
1888  	if(to.Length%4!=0){
1889  		string errorMsg2 = &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot;;
1890  		if(throwErrors) Debug.LogError(errorMsg2); else Debug.Log(errorMsg2);
1891  		return -1;
1892  	}
1893  	init();
1894  	if( optional==null || optional.Count == 0 )
1895  		optional = new Hashtable();
1896  	LTBezierPath ltPath = new LTBezierPath( to );
1897  	if(optional[&quot;orientToPath&quot;]!=null)
1898  		ltPath.orientToPath = true;
1899  	optional[&quot;path&quot;] = ltPath;
1900  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED, optional );
1901  }
1902  public static int move(GameObject gameObject, Vector3[] to, float time, object[] optional){
1903  	return move( gameObject, to, time, LeanTween.h( optional ) );
1904  }
1905  public static int move(LTRect ltRect, Vector2 to, float time, Hashtable optional){
1906  	init();
1907  	if( optional==null || optional.Count == 0 )
1908  		optional = new Hashtable();
1909  	optional[&quot;rect&quot;] = ltRect;
1910  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE, optional );
1911  }
1912  public static int move(LTRect ltRect, Vector3 to, float time, object[] optional){
1913  	return move( ltRect, to, time, LeanTween.h( optional ) );
1914  }
1915  public static int moveLocal(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1916  	return pushNewTween( gameObject, to, time, TweenAction.MOVE_LOCAL, optional );
1917  }
1918  public static int moveLocal(GameObject gameObject, Vector3 to, float time, object[] optional){
1919  	return moveLocal( gameObject, to, time, LeanTween.h( optional ) );
1920  }
1921  public static int moveLocal(GameObject gameObject, Vector3[] to, float time, Hashtable optional){
1922  	if(to.Length&lt;4){
1923  		string errorMsg = &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot;;
1924  		if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
1925  		return -1;
1926  	}
1927  	if(to.Length%4!=0){
1928  		string errorMsg2 = &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot;;
1929  		if(throwErrors) Debug.LogError(errorMsg2); else Debug.Log(errorMsg2);
1930  		return -1;
1931  	}
1932  	init();
1933  	if( optional == null )
1934  		optional = new Hashtable();
1935  	LTBezierPath ltPath = new LTBezierPath( to );
1936  	if(optional[&quot;orientToPath&quot;]!=null)
1937  		ltPath.orientToPath = true;
1938  	optional[&quot;path&quot;] = ltPath;
1939  	return pushNewTween( gameObject, new Vector3(1.0f,0.0f,0.0f), time, TweenAction.MOVE_CURVED_LOCAL, optional );
1940  }
1941  public static int moveLocal(GameObject gameObject, Vector3[] to, float time,object[] optional){
1942  	return moveLocal( gameObject, to, time, LeanTween.h( optional ) );
1943  }
1944  public static int moveLocalX(GameObject gameObject, float to, float time, Hashtable optional){
1945  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_X, optional );
1946  }
1947  public static int moveLocalX(GameObject gameObject, float to, float time, object[] optional){
1948  	return moveLocalX( gameObject, to, time, h(optional) );
1949  }
1950  public static int moveLocalY(GameObject gameObject, float to, float time, Hashtable optional){
1951  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Y, optional );
1952  }
1953  public static int moveLocalY(GameObject gameObject, float to, float time, object[] optional){
1954  	return moveLocalY( gameObject, to, time, h(optional) );
1955  }
1956  public static int moveLocalZ(GameObject gameObject, float to, float time, Hashtable optional){
1957  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Z, optional );
1958  }
1959  public static int moveLocalZ(GameObject gameObject, float to, float time, object[] optional){
1960  	return moveLocalZ( gameObject, to, time, h(optional) );
1961  }
1962  public static int scale(GameObject gameObject, Vector3 to, float time, Hashtable optional){
1963  	return pushNewTween( gameObject, to, time, TweenAction.SCALE, optional );
1964  }
1965  public static int scale(GameObject gameObject, Vector3 to, float time, object[] optional){
1966  	return scale( gameObject, to, time, h(optional) );
1967  }
1968  public static int scale(LTRect ltRect,Vector2 to, float time, Hashtable optional)
1969  { 
1970  	init();
1971  	if( optional==null || optional.Count == 0 )
1972  		optional = new Hashtable();
1973  	optional[&quot;rect&quot;] = ltRect;
1974  	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_SCALE, optional );
1975  }
1976  public static int scale(LTRect ltRect, Vector2 to, float time, object[] optional){
1977  	return scale( ltRect, to, time, h(optional) );
1978  }
1979  public static int alpha(LTRect ltRect, float to, float time, Hashtable optional){
1980  	init();
1981  	if( optional==null || optional.Count == 0 )
1982  		optional = new Hashtable();
1983  	ltRect.alphaEnabled = true;
1984  	optional[&quot;rect&quot;] = ltRect;
1985  	return pushNewTween( tweenEmpty, new Vector3(to,0f,0f), time, TweenAction.GUI_ALPHA, optional );
1986  }
1987  public static int alpha(LTRect ltRect, float to, float time, object[] optional){
1988  	return alpha( ltRect, to, time, h(optional) );
1989  }
1990  public static int scaleX(GameObject gameObject, float to, float time, Hashtable optional){
1991  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_X, optional );
1992  }
1993  public static int scaleX(GameObject gameObject, float to, float time, object[] optional){
1994  	return scaleX( gameObject, to, time, h(optional) );
1995  }
1996  public static int scaleY(GameObject gameObject, float to, float time, Hashtable optional){
1997  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Y, optional );
1998  }
1999  public static int scaleY(GameObject gameObject, float to, float time, object[] optional){
2000  	return scaleY( gameObject, to, time, h(optional) );
2001  }
2002  public static int scaleZ(GameObject gameObject, float to, float time, Hashtable optional){
2003  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.SCALE_Z, optional );
2004  }
2005  public static int scaleZ(GameObject gameObject, float to, float time, object[] optional){
2006  	return scaleZ( gameObject, to, time, h(optional) );
2007  }
2008  public static int delayedCall( float delayTime, string callback, Hashtable optional ){
2009  	init();
2010  	return delayedCall( tweenEmpty, delayTime, callback, optional );
2011  }
2012  public static int delayedCall( float delayTime, Action callback, object[] optional){
2013  	init();
2014  	return delayedCall( tweenEmpty, delayTime, callback, h(optional) );
2015  }
2016  public static int delayedCall( GameObject gameObject, float delayTime, string callback, object[] optional){
2017  	return delayedCall( gameObject, delayTime, callback, h(optional) );
2018  }
2019  public static int delayedCall( GameObject gameObject, float delayTime, Action callback, object[] optional){
2020  	return delayedCall( gameObject, delayTime, callback, h(optional) );
2021  }
2022  public static int delayedCall( GameObject gameObject, float delayTime, string callback, Hashtable optional){
2023  	if(optional==null || optional.Count == 0)
2024  		optional = new Hashtable();
2025  	optional[&quot;onComplete&quot;] = callback;
2026  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
2027  }
2028  public static int delayedCall( GameObject gameObject, float delayTime, Action callback, Hashtable optional){
2029  	if(optional==null)
2030  		optional = new Hashtable();
2031  	optional[&quot;onComplete&quot;] = callback;
2032  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
2033  }
2034  public static int delayedCall( GameObject gameObject, float delayTime, Action&lt;object&gt; callback, Hashtable optional){
2035  	if(optional==null)
2036  		optional = new Hashtable();
2037  	optional[&quot;onComplete&quot;] = callback;
2038  	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
2039  }
2040  public static int alpha(GameObject gameObject, float to, float time, Hashtable optional){
2041  	return pushNewTween( gameObject, new Vector3(to,0,0), time, TweenAction.ALPHA, optional );
2042  }
2043  public static int alpha(GameObject gameObject, float to, float time, object[] optional){
2044  	return alpha(gameObject, to, time, h(optional)); 
2045  }
2046  #endif
2047  private static float tweenOnCurve( LTDescr tweenDescr, float ratioPassed ){
2048  	return tweenDescr.from.x + (tweenDescr.diff.x) * tweenDescr.animationCurve.Evaluate(ratioPassed);
2049  }
2050  private static Vector3 tweenOnCurveVector( LTDescr tweenDescr, float ratioPassed ){
2051  	return	new Vector3(tweenDescr.from.x + (tweenDescr.diff.x) * tweenDescr.animationCurve.Evaluate(ratioPassed),
2052  						tweenDescr.from.y + (tweenDescr.diff.y) * tweenDescr.animationCurve.Evaluate(ratioPassed),
2053  						tweenDescr.from.z + (tweenDescr.diff.z) * tweenDescr.animationCurve.Evaluate(ratioPassed) );
2054  }
2055  private static float easeOutQuadOpt( float start, float diff, float ratioPassed ){
2056  	return -diff * ratioPassed * (ratioPassed - 2) + start;
2057  }
2058  private static float easeInQuadOpt( float start, float diff, float ratioPassed ){
2059  	return diff * ratioPassed * ratioPassed + start;
2060  }
2061  private static float easeInOutQuadOpt( float start, float diff, float ratioPassed ){
2062  	ratioPassed /= .5f;
2063  	if (ratioPassed &lt; 1) return diff / 2 * ratioPassed * ratioPassed + start;
2064  	ratioPassed--;
2065  	return -diff / 2 * (ratioPassed * (ratioPassed - 2) - 1) + start;
2066  }
2067  private static float linear(float start, float end, float val){
2068  	return Mathf.Lerp(start, end, val);
2069  }
2070  private static float clerp(float start, float end, float val){
2071  	float min = 0.0f;
2072  	float max = 360.0f;
2073  	float half = Mathf.Abs((max - min) / 2.0f);
2074  	float retval = 0.0f;
2075  	float diff = 0.0f;
2076  	if ((end - start) &lt; -half){
2077  		diff = ((max - start) + end) * val;
2078  		retval = start + diff;
2079  	}else if ((end - start) &gt; half){
2080  		diff = -((max - end) + start) * val;
2081  		retval = start + diff;
2082  	}else retval = start + (end - start) * val;
2083  	return retval;
2084  }
2085  private static float spring(float start, float end, float val){
2086  	val = Mathf.Clamp01(val);
<span onclick='openModal()' class='match'>2087  	val = (Mathf.Sin(val * Mathf.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + (1.2f * (1f - val)));
2088  	return start + (end - start) * val;
2089  }
2090  private static float easeInQuad(float start, float end, float val){
</span>2091  	end -= start;
2092  	return end * val * val + start;
2093  }
2094  private static float easeOutQuad(float start, float end, float val){
2095  	end -= start;
2096  	return -end * val * (val - 2) + start;
2097  }
2098  private static float easeInOutQuad(float start, float end, float val){
2099  	val /= .5f;
2100  	end -= start;
2101  	if (val &lt; 1) return end / 2 * val * val + start;
2102  	val--;
2103  	return -end / 2 * (val * (val - 2) - 1) + start;
2104  }
2105  private static float easeInCubic(float start, float end, float val){
2106  	end -= start;
2107  	return end * val * val * val + start;
2108  }
2109  private static float easeOutCubic(float start, float end, float val){
2110  	val--;
2111  	end -= start;
2112  	return end * (val * val * val + 1) + start;
2113  }
2114  private static float easeInOutCubic(float start, float end, float val){
2115  	val /= .5f;
2116  	end -= start;
2117  	if (val &lt; 1) return end / 2 * val * val * val + start;
2118  	val -= 2;
2119  	return end / 2 * (val * val * val + 2) + start;
2120  }
2121  private static float easeInQuart(float start, float end, float val){
2122  	end -= start;
2123  	return end * val * val * val * val + start;
2124  }
2125  private static float easeOutQuart(float start, float end, float val){
2126  	val--;
2127  	end -= start;
2128  	return -end * (val * val * val * val - 1) + start;
2129  }
2130  private static float easeInOutQuart(float start, float end, float val){
2131  	val /= .5f;
2132  	end -= start;
2133  	if (val &lt; 1) return end / 2 * val * val * val * val + start;
2134  	val -= 2;
2135  	return -end / 2 * (val * val * val * val - 2) + start;
2136  }
2137  private static float easeInQuint(float start, float end, float val){
2138  	end -= start;
2139  	return end * val * val * val * val * val + start;
2140  }
2141  private static float easeOutQuint(float start, float end, float val){
2142  	val--;
2143  	end -= start;
2144  	return end * (val * val * val * val * val + 1) + start;
2145  }
2146  private static float easeInOutQuint(float start, float end, float val){
2147  	val /= .5f;
2148  	end -= start;
2149  	if (val &lt; 1) return end / 2 * val * val * val * val * val + start;
2150  	val -= 2;
2151  	return end / 2 * (val * val * val * val * val + 2) + start;
2152  }
2153  private static float easeInSine(float start, float end, float val){
2154  	end -= start;
2155  	return -end * Mathf.Cos(val / 1 * (Mathf.PI / 2)) + end + start;
2156  }
2157  private static float easeOutSine(float start, float end, float val){
2158  	end -= start;
2159  	return end * Mathf.Sin(val / 1 * (Mathf.PI / 2)) + start;
2160  }
2161  private static float easeInOutSine(float start, float end, float val){
2162  	end -= start;
2163  	return -end / 2 * (Mathf.Cos(Mathf.PI * val / 1) - 1) + start;
2164  }
2165  private static float easeInExpo(float start, float end, float val){
2166  	end -= start;
2167  	return end * Mathf.Pow(2, 10 * (val / 1 - 1)) + start;
2168  }
2169  private static float easeOutExpo(float start, float end, float val){
2170  	end -= start;
2171  	return end * (-Mathf.Pow(2, -10 * val / 1) + 1) + start;
2172  }
2173  private static float easeInOutExpo(float start, float end, float val){
2174  	val /= .5f;
2175  	end -= start;
2176  	if (val &lt; 1) return end / 2 * Mathf.Pow(2, 10 * (val - 1)) + start;
2177  	val--;
2178  	return end / 2 * (-Mathf.Pow(2, -10 * val) + 2) + start;
2179  }
2180  private static float easeInCirc(float start, float end, float val){
2181  	end -= start;
2182  	return -end * (Mathf.Sqrt(1 - val * val) - 1) + start;
2183  }
2184  private static float easeOutCirc(float start, float end, float val){
2185  	val--;
2186  	end -= start;
2187  	return end * Mathf.Sqrt(1 - val * val) + start;
2188  }
2189  private static float easeInOutCirc(float start, float end, float val){
2190  	val /= .5f;
2191  	end -= start;
2192  	if (val &lt; 1) return -end / 2 * (Mathf.Sqrt(1 - val * val) - 1) + start;
2193  	val -= 2;
2194  	return end / 2 * (Mathf.Sqrt(1 - val * val) + 1) + start;
2195  }
2196  private static float easeInBounce(float start, float end, float val){
2197  	end -= start;
2198  	float d = 1f;
2199  	return end - easeOutBounce(0, end, d-val) + start;
2200  }
2201  private static float easeOutBounce(float start, float end, float val){
2202  	val /= 1f;
2203  	end -= start;
2204  	if (val &lt; (1 / 2.75f)){
2205  		return end * (7.5625f * val * val) + start;
2206  	}else if (val &lt; (2 / 2.75f)){
2207  		val -= (1.5f / 2.75f);
2208  		return end * (7.5625f * (val) * val + .75f) + start;
2209  	}else if (val &lt; (2.5 / 2.75)){
2210  		val -= (2.25f / 2.75f);
2211  		return end * (7.5625f * (val) * val + .9375f) + start;
2212  	}else{
2213  		val -= (2.625f / 2.75f);
2214  		return end * (7.5625f * (val) * val + .984375f) + start;
2215  	}
2216  }
2217  private static float easeInOutBounce(float start, float end, float val){
2218  	end -= start;
2219  	float d= 1f;
2220  	if (val &lt; d/2) return easeInBounce(0, end, val*2) * 0.5f + start;
2221  	else return easeOutBounce(0, end, val*2-d) * 0.5f + end*0.5f + start;
2222  }
2223  private static float easeInBack(float start, float end, float val){
2224  	end -= start;
2225  	val /= 1;
2226  	float s= 1.70158f;
2227  	return end * (val) * val * ((s + 1) * val - s) + start;
2228  }
2229  private static float easeOutBack(float start, float end, float val){
2230  	float s= 1.70158f;
2231  	end -= start;
2232  	val = (val / 1) - 1;
2233  	return end * ((val) * val * ((s + 1) * val + s) + 1) + start;
2234  }
2235  private static float easeInOutBack(float start, float end, float val){
2236  	float s= 1.70158f;
2237  	end -= start;
2238  	val /= .5f;
2239  	if ((val) &lt; 1){
2240  		s *= (1.525f);
2241  		return end / 2 * (val * val * (((s) + 1) * val - s)) + start;
2242  	}
2243  	val -= 2;
2244  	s *= (1.525f);
2245  	return end / 2 * ((val) * val * (((s) + 1) * val + s) + 2) + start;
2246  }
2247  private static float easeInElastic(float start, float end, float val){
2248  	end -= start;
2249  	float d = 1f;
2250  	float p = d * .3f;
2251  	float s= 0;
2252  	float a = 0;
2253  	if (val == 0) return start;
2254  	val = val/d;
2255  	if (val == 1) return start + end;
2256  	if (a == 0f || a &lt; Mathf.Abs(end)){
2257  		a = end;
2258  		s = p / 4;
2259  		}else{
2260  		s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
2261  	}
2262  	val = val-1;
2263  	return -(a * Mathf.Pow(2, 10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p)) + start;
2264  }		
2265  private static float easeOutElastic(float start, float end, float val){
2266  	end -= start;
2267  	float d = 1f;
2268  	float p= d * .3f;
2269  	float s= 0;
2270  	float a= 0;
2271  	if (val == 0) return start;
2272  	val = val / d;
2273  	if (val == 1) return start + end;
2274  	if (a == 0f || a &lt; Mathf.Abs(end)){
2275  		a = end;
2276  		s = p / 4;
2277  		}else{
2278  		s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
2279  	}
2280  	return (a * Mathf.Pow(2, -10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p) + end + start);
2281  }		
2282  private static float easeInOutElastic(float start, float end, float val)
2283  {
2284  	end -= start;
2285  	float d = 1f;
2286  	float p= d * .3f;
2287  	float s= 0;
2288  	float a = 0;
2289  	if (val == 0) return start;
2290  	val = val / (d/2);
2291  	if (val == 2) return start + end;
2292  	if (a == 0f || a &lt; Mathf.Abs(end)){
2293  		a = end;
2294  		s = p / 4;
2295  		}else{
2296  		s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
2297  	}
2298  	if (val &lt; 1){
2299  	 val = val-1;
2300  	 return -0.5f * (a * Mathf.Pow(2, 10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p)) + start;
2301  	}
2302  	val = val-1;
2303  	return a * Mathf.Pow(2, -10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) / p) * 0.5f + end + start;
2304  }
2305  private static System.Action&lt;LTEvent&gt;[] eventListeners;
2306  private static GameObject[] goListeners;
2307  private static int eventsMaxSearch = 0;
2308  public static int EVENTS_MAX = 10;
2309  public static int LISTENERS_MAX = 10;
2310  public static void addListener( int eventId, System.Action&lt;LTEvent&gt; callback ){
2311  	addListener(tweenEmpty, eventId, callback);
2312  }
2313  public static void addListener( GameObject caller, int eventId, System.Action&lt;LTEvent&gt; callback ){
2314  	if(eventListeners==null){
2315  		eventListeners = new System.Action&lt;LTEvent&gt;[ EVENTS_MAX * LISTENERS_MAX ];
2316  		goListeners = new GameObject[ EVENTS_MAX * LISTENERS_MAX ];
2317  	}
2318  	for(i = 0; i &lt; LISTENERS_MAX; i++){
2319  		int point = eventId*LISTENERS_MAX + i;
2320  		if(goListeners[ point ]==null || eventListeners[ point ]==null){
2321  			eventListeners[ point ] = callback;
2322  			goListeners[ point ] = caller;
2323  			if(i&gt;=eventsMaxSearch)
2324  				eventsMaxSearch = i+1;
2325  			return;
2326  		}
2327  		if(goListeners[ point ] == caller &amp;&amp; System.Object.ReferenceEquals( eventListeners[ point ], callback)){
2328  			return;
2329  		}
2330  	}
2331  	Debug.LogError(&quot;You ran out of areas to add listeners, consider increasing LISTENERS_MAX, ex: LeanTween.LISTENERS_MAX = &quot;+(LISTENERS_MAX*2));
2332  }
2333  public static bool removeListener( int eventId, System.Action&lt;LTEvent&gt; callback ){
2334  	return removeListener( tweenEmpty, eventId, callback);
2335  }
2336  public static bool removeListener( GameObject caller, int eventId, System.Action&lt;LTEvent&gt; callback ){
2337  	for(i = 0; i &lt; eventsMaxSearch; i++){
2338  		int point = eventId*LISTENERS_MAX + i;
2339  		if(goListeners[ point ] == caller &amp;&amp; System.Object.ReferenceEquals( eventListeners[ point ], callback) ){
2340  			eventListeners[ point ] = null;
2341  			goListeners[ point ] = null;
2342  			return true;
2343  		}
2344  	}
2345  	return false;
2346  }
2347  public static void dispatchEvent( int eventId ){
2348  	dispatchEvent( eventId, null);
2349  }
2350  public static void dispatchEvent( int eventId, object data ){
2351  	for(int k = 0; k &lt; eventsMaxSearch; k++){
2352  		int point = eventId*LISTENERS_MAX + k;
2353  		if(eventListeners[ point ]!=null){
2354  			if(goListeners[point]){
2355  				eventListeners[ point ]( new LTEvent(eventId, data) );
2356  			}else{
2357  				eventListeners[ point ] = null;
2358  			}
2359  		}
2360  	}
2361  }
2362  }
2363  public class LTEvent{
2364  	public int id;
2365  	public object data;
2366  	public LTEvent(int id, object data){
2367  		this.id = id;
2368  		this.data = data;
2369  	}
2370  }
2371  public class LTGUI{
2372  	public static int RECT_LEVELS = 5;
2373  	public static int RECTS_PER_LEVEL = 10;
2374  	public static int BUTTONS_MAX = 24;
2375  	private static LTRect[] levels;
2376  	private static int[] levelDepths;
2377  	private static Rect[] buttons;
2378  	private static int[] buttonLevels;
2379  	private static int[] buttonLastFrame;
2380  	private static LTRect r;
2381  	private static Color color = Color.white;
2382  	private static bool isGUIEnabled = false;
2383  	private static int global_counter = 0;
2384  	public enum Element_Type{
2385  		Texture,
2386  		Label
2387  	}
2388  	public static void init(){
2389  		if(levels==null){
2390  			levels = new LTRect[RECT_LEVELS*RECTS_PER_LEVEL];
2391  			levelDepths = new int[RECT_LEVELS];
2392  		}
2393  	}
2394  	public static void initRectCheck(){
2395  		if(buttons==null){
2396  			buttons = new Rect[BUTTONS_MAX];
2397  			buttonLevels = new int[BUTTONS_MAX];
2398  			buttonLastFrame = new int[BUTTONS_MAX];
2399  			for(int i = 0; i &lt; buttonLevels.Length; i++){
2400  				buttonLevels[i] = -1;
2401  			}
2402  		}
2403  	}
2404  	public static void reset(){
2405  		if(isGUIEnabled){
2406  			isGUIEnabled = false;
2407  			for(int i = 0; i &lt; levels.Length; i++){
2408  				levels[i] = null;
2409  			}
2410  			for(int i = 0; i &lt; levelDepths.Length; i++){
2411  				levelDepths[i] = 0;
2412  			}
2413  		}
2414  	}
2415  	public static void update( int updateLevel ){
2416  		if(isGUIEnabled){
2417  			init();
2418  			if(levelDepths[updateLevel]&gt;0){
2419  				color = GUI.color;
2420  				int baseI = updateLevel*RECTS_PER_LEVEL;
2421  				int maxLoop = baseI + levelDepths[updateLevel];
2422  				for(int i = baseI; i &lt; maxLoop; i++){
2423  					r = levels[i];
2424  					if(r!=null &amp;bsol;*&amp;&amp; checkOnScreen(r.rect)*/){
2425  						if(r.useColor)
2426  							GUI.color = r.color;
2427  						if(r.type == Element_Type.Label){
2428  							if(r.style!=null)
2429  								GUI.skin.label = r.style;
2430  							if(r.useSimpleScale){
2431  								GUI.Label( new Rect((r.rect.x + r.margin.x + r.relativeRect.x)*r.relativeRect.width, (r.rect.y + r.margin.y + r.relativeRect.y)*r.relativeRect.height, r.rect.width*r.relativeRect.width, r.rect.height*r.relativeRect.height), r.labelStr );
2432  							}else{
2433  								GUI.Label( new Rect(r.rect.x + r.margin.x, r.rect.y + r.margin.y, r.rect.width, r.rect.height), r.labelStr );
2434  							}
2435  						}else if(r.type == Element_Type.Texture &amp;&amp; r.texture!=null){
2436  							Vector2 size = r.useSimpleScale ? new Vector2(0f, r.rect.height*r.relativeRect.height) : new Vector2(r.rect.width, r.rect.height);
2437  							if(r.sizeByHeight){
2438  								size.x = (float)r.texture.width/(float)r.texture.height * size.y;
2439  							}
2440  							if(r.useSimpleScale){
2441  								GUI.DrawTexture( new Rect((r.rect.x + r.margin.x + r.relativeRect.x)*r.relativeRect.width, (r.rect.y + r.margin.y + r.relativeRect.y)*r.relativeRect.height, size.x, size.y), r.texture );
2442  							}else{
2443  								GUI.DrawTexture( new Rect(r.rect.x + r.margin.x, r.rect.y + r.margin.y, size.x, size.y), r.texture );
2444  							}
2445  						}
2446  					}
2447  				}
2448  				GUI.color = color;
2449  			}
2450  		}
2451  	}
2452  	public static bool checkOnScreen(Rect rect){
2453  		bool offLeft = rect.x + rect.width &lt; 0f;
2454  		bool offRight = rect.x &gt; Screen.width;
2455  		bool offBottom = rect.y &gt; Screen.height;
2456  		bool offTop = rect.y + rect.height &lt; 0f;
2457  		return !(offLeft || offRight || offBottom || offTop);
2458  	}
2459  	public static void destroy( int id ){
2460  		int backId = id &amp; 0xFFFF;
2461  		int backCounter = id &gt;&gt; 16;
2462  		if(id&gt;=0 &amp;&amp; levels[backId]!=null &amp;&amp; levels[backId].hasInitiliazed &amp;&amp; levels[backId].counter==backCounter)
2463  			levels[backId] = null;
2464  	}
2465  	public static LTRect label( Rect rect, string label, int depth){
2466  		return LTGUI.label(new LTRect(rect), label, depth);
2467  	}
2468  	public static LTRect label( LTRect rect, string label, int depth){
2469  		rect.type = Element_Type.Label;
2470  		rect.labelStr = label;
2471  		return element(rect, depth);
2472  	}
2473  	public static LTRect texture( Rect rect, Texture texture, int depth){
2474  		return LTGUI.texture( new LTRect(rect), texture, depth);
2475  	}
2476  	public static LTRect texture( LTRect rect, Texture texture, int depth){
2477  		rect.type = Element_Type.Texture;
2478  		rect.texture = texture;
2479  		return element(rect, depth);
2480  	}
2481  	public static LTRect element( LTRect rect, int depth){
2482  		isGUIEnabled = true;
2483  		init();
2484  		int maxLoop = depth*RECTS_PER_LEVEL + RECTS_PER_LEVEL;
2485  		int k = 0;
2486  		if(rect!=null){
2487  			destroy(rect.id);
2488  		}
2489  		if(rect.type==LTGUI.Element_Type.Label &amp;&amp; rect.style!=null){
2490  			if(rect.style.normal.textColor.a&lt;=0f){
2491  				Debug.LogWarning(&quot;Your GUI normal color has an alpha of zero, and will not be rendered.&quot;);
2492  			}
2493  		}
2494  		if(rect.relativeRect.width==float.PositiveInfinity){
2495  			rect.relativeRect = new Rect(0f,0f,Screen.width,Screen.height);
2496  		}
2497  		for(int i = depth*RECTS_PER_LEVEL; i &lt; maxLoop; i++){
2498  			r = levels[i];
2499  			if(r==null){
2500  				r = rect;
2501  				r.rotateEnabled = true;
2502  				r.alphaEnabled = true;
2503  				r.setId( i, global_counter );
2504  				levels[i] = r;
2505  				if(k&gt;=levelDepths[depth]){
2506  					levelDepths[depth] = k + 1;
2507  				}
2508  				global_counter++;
2509  				return r;
2510  			}
2511  			k++;
2512  		}
2513  		Debug.LogError(&quot;You ran out of GUI Element spaces&quot;);
2514  		return null;
2515  	}
2516  	public static bool hasNoOverlap( Rect rect, int depth ){
2517  		initRectCheck();
2518  		bool hasNoOverlap = true;
2519  		bool wasAddedToList = false;
2520  		for(int i = 0; i &lt; buttonLevels.Length; i++){
2521  			if(buttonLevels[i]&gt;=0){
2522  				if( buttonLastFrame[i] + 1 &lt; Time.frameCount ){ 
2523  					buttonLevels[i] = -1;
2524  				}else{
2525  					if(buttonLevels[i]&gt;depth){
2526  						if(pressedWithinRect( buttons[i] )){
2527  							hasNoOverlap = false; 
2528  						}
2529  					}
2530  				}
2531  			}
2532  			if(wasAddedToList==false &amp;&amp; buttonLevels[i]&lt;0){
2533  				wasAddedToList = true;
2534  				buttonLevels[i] = depth;
2535  				buttons[i] = rect;
2536  				buttonLastFrame[i] = Time.frameCount;
2537  			}
2538  		}
2539  		return hasNoOverlap;
2540  	}
2541  	public static bool pressedWithinRect( Rect rect ){
2542  		Vector2 vec2 = firstTouch();
2543  		if(vec2.x&lt;0f)
2544  			return false;
2545  		float vecY = Screen.height-vec2.y;
2546  		return (vec2.x &gt; rect.x &amp;&amp; vec2.x &lt; rect.x + rect.width &amp;&amp; vecY &gt; rect.y &amp;&amp; vecY &lt; rect.y + rect.height);
2547  	}
2548  	public static bool checkWithinRect(Vector2 vec2, Rect rect){
2549  		vec2.y = Screen.height-vec2.y;
2550  		return (vec2.x &gt; rect.x &amp;&amp; vec2.x &lt; rect.x + rect.width &amp;&amp; vec2.y &gt; rect.y &amp;&amp; vec2.y &lt; rect.y + rect.height);
2551  	}
2552  	public static Vector2 firstTouch(){
2553  		if(Input.touchCount&gt;0){
2554  			return Input.touches[0].position;
2555  		}else if(Input.GetMouseButton(0)){
2556  			return Input.mousePosition;
2557  		}
2558  		return new Vector2(Mathf.NegativeInfinity,Mathf.NegativeInfinity);
2559  	}
2560  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-LeanTween.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-LeanTween_56.cs</div>
                </div>
                <div class="column column_space"><pre><code>2087  	val = (Mathf.Sin(val * Mathf.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + (1.2f * (1f - val)));
2088  	return start + (end - start) * val;
2089  }
2090  private static float easeInQuad(float start, float end, float val){
</pre></code></div>
                <div class="column column_space"><pre><code>2087  	val = (Mathf.Sin(val * Mathf.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + (1.2f * (1f - val)));
2088  	return start + (end - start) * val;
2089  }
2090  private static float easeInQuad(float start, float end, float val){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    