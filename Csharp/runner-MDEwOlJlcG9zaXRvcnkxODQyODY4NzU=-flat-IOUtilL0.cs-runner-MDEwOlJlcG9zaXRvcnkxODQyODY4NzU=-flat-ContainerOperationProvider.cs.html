
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</h3>
            <pre><code>1  using GitHub.Runner.Sdk;
2  using System;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Xunit;
7  namespace GitHub.Runner.Common.Tests.Util
8  {
9      public sealed class IOUtilL0
10      {
11          [Fact]
12          [Trait("Level", "L0")]
13          [Trait("Category", "Common")]
14          public void Delete_DeletesDirectory()
15          {
16              using (TestHostContext hc = new(this))
17              {
18                  Tracing trace = hc.GetTrace();
19                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
20                  string file = Path.Combine(directory, "some file");
21                  try
22                  {
23                      Directory.CreateDirectory(directory);
24                      File.WriteAllText(path: file, contents: "some contents");
25                      IOUtil.Delete(directory, CancellationToken.None);
26                      Assert.False(Directory.Exists(directory));
27                  }
28                  finally
29                  {
30                      if (Directory.Exists(directory))
31                      {
32                          Directory.Delete(directory, recursive: true);
33                      }
34                  }
35              }
36          }
37          [Fact]
38          [Trait("Level", "L0")]
39          [Trait("Category", "Common")]
40          public void Delete_DeletesFile()
41          {
42              using (TestHostContext hc = new(this))
43              {
44                  Tracing trace = hc.GetTrace();
45                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
46                  string file = Path.Combine(directory, "some file");
47                  try
48                  {
49                      Directory.CreateDirectory(directory);
50                      File.WriteAllText(path: file, contents: "some contents");
51                      IOUtil.Delete(file, CancellationToken.None);
52                      Assert.False(File.Exists(file));
53                  }
54                  finally
55                  {
56                      if (Directory.Exists(directory))
57                      {
58                          Directory.Delete(directory, recursive: true);
59                      }
60                  }
61              }
62          }
63          [Fact]
64          [Trait("Level", "L0")]
65          [Trait("Category", "Common")]
66          public void DeleteDirectory_DeletesDirectoriesRecursively()
67          {
68              using (TestHostContext hc = new(this))
69              {
70                  Tracing trace = hc.GetTrace();
71                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
72                  try
73                  {
74                      Directory.CreateDirectory(Path.Combine(directory, "some child directory", "some grandchild directory"));
75                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
76                      Assert.False(Directory.Exists(directory));
77                  }
78                  finally
79                  {
80                      if (Directory.Exists(directory))
81                      {
82                          Directory.Delete(directory, recursive: true);
83                      }
84                  }
85              }
86          }
87          [Fact]
88          [Trait("Level", "L0")]
89          [Trait("Category", "Common")]
90          public async Task DeleteDirectory_DeletesDirectoryReparsePointChain()
91          {
92              using (TestHostContext hc = new(this))
93              {
94                  Tracing trace = hc.GetTrace();
95                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
96                  try
97                  {
98                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
99                      string file = Path.Combine(targetDir, "file.txt");
100                      File.WriteAllText(path: file, contents: "some contents");
101                      string linkDir1 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir1");
102                      string linkDir2 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir2");
103                      string linkDir3 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir3");
104                      string linkDir4 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir4");
105                      string linkDir5 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir5");
106                      await CreateDirectoryReparsePoint(context: hc, link: linkDir1, target: linkDir2);
107                      await CreateDirectoryReparsePoint(context: hc, link: linkDir2, target: linkDir3);
108                      await CreateDirectoryReparsePoint(context: hc, link: linkDir3, target: linkDir4);
109                      await CreateDirectoryReparsePoint(context: hc, link: linkDir4, target: linkDir5);
110                      await CreateDirectoryReparsePoint(context: hc, link: linkDir5, target: targetDir);
111                      Assert.True(Directory.Exists(linkDir1));
112                      Assert.True(new DirectoryInfo(linkDir1).Attributes.HasFlag(FileAttributes.ReparsePoint));
113                      Assert.True(File.Exists(Path.Combine(linkDir1, "file.txt")));
114                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
115                      Assert.False(Directory.Exists(linkDir1));
116                      Assert.False(Directory.Exists(targetDir));
117                      Assert.False(File.Exists(file));
118                      Assert.False(Directory.Exists(randomDir));
119                  }
120                  finally
121                  {
122                      if (Directory.Exists(randomDir))
123                      {
124                          Directory.Delete(randomDir, recursive: true);
125                      }
126                  }
127              }
128          }
129          [Fact]
130          [Trait("Level", "L0")]
131          [Trait("Category", "Common")]
132          public async Task DeleteDirectory_DeletesDirectoryReparsePointsBeforeDirectories()
133          {
134              using (TestHostContext hc = new(this))
135              {
136                  Tracing trace = hc.GetTrace();
137                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
138                  try
139                  {
140                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
141                      string file = Path.Combine(targetDir, "file.txt");
142                      File.WriteAllText(path: file, contents: "some contents");
143                      string linkDir = Path.Combine(randomDir, "linkDir");
144                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
145                      Assert.True(Directory.Exists(linkDir));
146                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
147                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
148                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
149                      Assert.False(Directory.Exists(linkDir));
150                      Assert.False(Directory.Exists(targetDir));
151                      Assert.False(File.Exists(file));
152                      Assert.False(Directory.Exists(randomDir));
153                  }
154                  finally
155                  {
156                      if (Directory.Exists(randomDir))
157                      {
158                          Directory.Delete(randomDir, recursive: true);
159                      }
160                  }
161              }
162          }
163          [Fact]
164          [Trait("Level", "L0")]
165          [Trait("Category", "Common")]
166          public void DeleteDirectory_DeletesFilesRecursively()
167          {
168              using (TestHostContext hc = new(this))
169              {
170                  Tracing trace = hc.GetTrace();
171                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
172                  try
173                  {
174                      string file = Path.Combine(directory, "some subdirectory", "some file");
175                      Directory.CreateDirectory(Path.GetDirectoryName(file));
176                      File.WriteAllText(path: file, contents: "some contents");
177                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
178                      Assert.False(Directory.Exists(directory));
179                  }
180                  finally
181                  {
182                      if (Directory.Exists(directory))
183                      {
<span onclick='openModal()' class='match'>184                          Directory.Delete(directory, recursive: true);
185                      }
186                  }
</span>187              }
188          }
189          [Fact]
190          [Trait("Level", "L0")]
191          [Trait("Category", "Common")]
192          public void DeleteDirectory_DeletesReadOnlyDirectories()
193          {
194              using (TestHostContext hc = new(this))
195              {
196                  Tracing trace = hc.GetTrace();
197                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
198                  string subdirectory = Path.Combine(directory, "some subdirectory");
199                  try
200                  {
201                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
202                      subdirectoryInfo.Create();
203                      subdirectoryInfo.Attributes = subdirectoryInfo.Attributes | FileAttributes.ReadOnly;
204                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
205                      Assert.False(Directory.Exists(directory));
206                  }
207                  finally
208                  {
209                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
210                      if (subdirectoryInfo.Exists)
211                      {
212                          subdirectoryInfo.Attributes = subdirectoryInfo.Attributes & ~FileAttributes.ReadOnly;
213                      }
214                      if (Directory.Exists(directory))
215                      {
216                          Directory.Delete(directory, recursive: true);
217                      }
218                  }
219              }
220          }
221          [Fact]
222          [Trait("Level", "L0")]
223          [Trait("Category", "Common")]
224          public void DeleteDirectory_DeletesReadOnlyRootDirectory()
225          {
226              using (TestHostContext hc = new(this))
227              {
228                  Tracing trace = hc.GetTrace();
229                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
230                  try
231                  {
232                      var directoryInfo = new DirectoryInfo(directory);
233                      directoryInfo.Create();
234                      directoryInfo.Attributes = directoryInfo.Attributes | FileAttributes.ReadOnly;
235                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
236                      Assert.False(Directory.Exists(directory));
237                  }
238                  finally
239                  {
240                      var directoryInfo = new DirectoryInfo(directory);
241                      if (directoryInfo.Exists)
242                      {
243                          directoryInfo.Attributes = directoryInfo.Attributes & ~FileAttributes.ReadOnly;
244                          directoryInfo.Delete();
245                      }
246                  }
247              }
248          }
249          [Fact]
250          [Trait("Level", "L0")]
251          [Trait("Category", "Common")]
252          public void DeleteDirectory_DeletesReadOnlyFiles()
253          {
254              using (TestHostContext hc = new(this))
255              {
256                  Tracing trace = hc.GetTrace();
257                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
258                  string file = Path.Combine(directory, "some file");
259                  try
260                  {
261                      Directory.CreateDirectory(directory);
262                      File.WriteAllText(path: file, contents: "some contents");
263                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
264                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
265                      Assert.False(Directory.Exists(directory));
266                  }
267                  finally
268                  {
269                      if (File.Exists(file))
270                      {
271                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
272                      }
273                      if (Directory.Exists(directory))
274                      {
275                          Directory.Delete(directory, recursive: true);
276                      }
277                  }
278              }
279          }
280          [Fact]
281          [Trait("Level", "L0")]
282          [Trait("Category", "Common")]
283          public async Task DeleteDirectory_DoesNotFollowDirectoryReparsePoint()
284          {
285              using (TestHostContext hc = new(this))
286              {
287                  Tracing trace = hc.GetTrace();
288                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
289                  try
290                  {
291                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
292                      string file = Path.Combine(targetDir, "file.txt");
293                      File.WriteAllText(path: file, contents: "some contents");
294                      string linkDir = Path.Combine(randomDir, "linkDir");
295                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
296                      Assert.True(Directory.Exists(linkDir));
297                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
298                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
299                      IOUtil.DeleteDirectory(linkDir, CancellationToken.None);
300                      Assert.False(Directory.Exists(linkDir));
301                      Assert.True(Directory.Exists(targetDir));
302                      Assert.True(File.Exists(file));
303                  }
304                  finally
305                  {
306                      if (Directory.Exists(randomDir))
307                      {
308                          Directory.Delete(randomDir, recursive: true);
309                      }
310                  }
311              }
312          }
313          [Fact]
314          [Trait("Level", "L0")]
315          [Trait("Category", "Common")]
316          public async Task DeleteDirectory_DoesNotFollowNestLevel1DirectoryReparsePoint()
317          {
318              using (TestHostContext hc = new(this))
319              {
320                  Tracing trace = hc.GetTrace();
321                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
322                  try
323                  {
324                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
325                      string file = Path.Combine(targetDir, "file.txt");
326                      File.WriteAllText(path: file, contents: "some contents");
327                      string subDir = Directory.CreateDirectory(Path.Combine(randomDir, "subDir")).FullName;
328                      string linkDir = Path.Combine(subDir, "linkDir");
329                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
330                      Assert.True(Directory.Exists(linkDir));
331                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
332                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
333                      IOUtil.DeleteDirectory(subDir, CancellationToken.None);
334                      Assert.False(Directory.Exists(subDir));
335                      Assert.True(Directory.Exists(targetDir));
336                      Assert.True(File.Exists(file));
337                  }
338                  finally
339                  {
340                      if (Directory.Exists(randomDir))
341                      {
342                          Directory.Delete(randomDir, recursive: true);
343                      }
344                  }
345              }
346          }
347          [Fact]
348          [Trait("Level", "L0")]
349          [Trait("Category", "Common")]
350          public async Task DeleteDirectory_DoesNotFollowNestLevel2DirectoryReparsePoint()
351          {
352              using (TestHostContext hc = new(this))
353              {
354                  Tracing trace = hc.GetTrace();
355                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
356                  try
357                  {
358                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
359                      string file = Path.Combine(targetDir, "file.txt");
360                      File.WriteAllText(path: file, contents: "some contents");
361                      string subDir1 = Directory.CreateDirectory(Path.Combine(randomDir, "subDir1")).FullName;
362                      string subDir2 = Directory.CreateDirectory(Path.Combine(subDir1, "subDir2")).FullName;
363                      string linkDir = Path.Combine(subDir2, "linkDir");
364                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
365                      Assert.True(Directory.Exists(linkDir));
366                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
367                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
368                      IOUtil.DeleteDirectory(subDir1, CancellationToken.None);
369                      Assert.False(Directory.Exists(subDir1));
370                      Assert.True(Directory.Exists(targetDir));
371                      Assert.True(File.Exists(file));
372                  }
373                  finally
374                  {
375                      if (Directory.Exists(randomDir))
376                      {
377                          Directory.Delete(randomDir, recursive: true);
378                      }
379                  }
380              }
381          }
382          [Fact]
383          [Trait("Level", "L0")]
384          [Trait("Category", "Common")]
385          public void DeleteDirectory_IgnoresFile()
386          {
387              using (TestHostContext hc = new(this))
388              {
389                  Tracing trace = hc.GetTrace();
390                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
391                  string file = Path.Combine(directory, "some file");
392                  try
393                  {
394                      Directory.CreateDirectory(directory);
395                      File.WriteAllText(path: file, contents: "some contents");
396                      IOUtil.DeleteDirectory(file, CancellationToken.None);
397                      Assert.True(File.Exists(file));
398                  }
399                  finally
400                  {
401                      if (Directory.Exists(directory))
402                      {
403                          Directory.Delete(directory, recursive: true);
404                      }
405                  }
406              }
407          }
408          [Fact]
409          [Trait("Level", "L0")]
410          [Trait("Category", "Common")]
411          public void DeleteFile_DeletesFile()
412          {
413              using (TestHostContext hc = new(this))
414              {
415                  Tracing trace = hc.GetTrace();
416                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
417                  string file = Path.Combine(directory, "some file");
418                  try
419                  {
420                      Directory.CreateDirectory(directory);
421                      File.WriteAllText(path: file, contents: "some contents");
422                      IOUtil.DeleteFile(file);
423                      Assert.False(File.Exists(file));
424                  }
425                  finally
426                  {
427                      if (Directory.Exists(directory))
428                      {
429                          Directory.Delete(directory, recursive: true);
430                      }
431                  }
432              }
433          }
434          [Fact]
435          [Trait("Level", "L0")]
436          [Trait("Category", "Common")]
437          public void DeleteFile_DeletesReadOnlyFile()
438          {
439              using (TestHostContext hc = new(this))
440              {
441                  Tracing trace = hc.GetTrace();
442                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
443                  string file = Path.Combine(directory, "some file");
444                  try
445                  {
446                      Directory.CreateDirectory(directory);
447                      File.WriteAllText(path: file, contents: "some contents");
448                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
449                      IOUtil.DeleteFile(file);
450                      Assert.False(File.Exists(file));
451                  }
452                  finally
453                  {
454                      if (File.Exists(file))
455                      {
456                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
457                      }
458                      if (Directory.Exists(directory))
459                      {
460                          Directory.Delete(directory, recursive: true);
461                      }
462                  }
463              }
464          }
465          [Fact]
466          [Trait("Level", "L0")]
467          [Trait("Category", "Common")]
468          public void DeleteFile_IgnoresDirectory()
469          {
470              using (TestHostContext hc = new(this))
471              {
472                  Tracing trace = hc.GetTrace();
473                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
474                  try
475                  {
476                      Directory.CreateDirectory(directory);
477                      IOUtil.DeleteFile(directory);
478                      Assert.True(Directory.Exists(directory));
479                  }
480                  finally
481                  {
482                      if (Directory.Exists(directory))
483                      {
484                          Directory.Delete(directory, recursive: true);
485                      }
486                  }
487              }
488          }
489          [Fact]
490          [Trait("Level", "L0")]
491          [Trait("Category", "Common")]
492          public void GetRelativePath()
493          {
494              using (TestHostContext hc = new(this))
495              {
496                  Tracing trace = hc.GetTrace();
497                  string relativePath;
498  #if OS_WINDOWS
499                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src");
500                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
501                  relativePath = IOUtil.MakeRelative(@"d:\", @"d:\specs");
502                  Assert.True(string.Equals(relativePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
503                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src\proj");
504                  Assert.True(string.Equals(relativePath, @"d:\src\project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
505                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo", @"d:\src");
506                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
507                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:\src\project");
508                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
509                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
510                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
511                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
512                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
513                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo", @"d:/src");
514                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
515                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:/src/project");
516                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
517  #else
518                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src");
519                  Assert.True(string.Equals(relativePath, @"project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
520                  relativePath = IOUtil.MakeRelative(@"/user", @"/user/specs");
521                  Assert.True(string.Equals(relativePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
522                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src/proj");
523                  Assert.True(string.Equals(relativePath, @"/user/src/project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
524                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo", @"/user/src");
525                  Assert.True(string.Equals(relativePath, @"project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
526                  relativePath = IOUtil.MakeRelative(@"/user/src/project", @"/user/src/project");
527                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
528  #endif
529              }
530          }
531          [Fact]
532          [Trait("Level", "L0")]
533          [Trait("Category", "Common")]
534          public void ResolvePath()
535          {
536              using (TestHostContext hc = new(this))
537              {
538                  Tracing trace = hc.GetTrace();
539                  string resolvePath;
540  #if OS_WINDOWS
541                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"foo");
542                  Assert.True(string.Equals(resolvePath, @"d:\src\project\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
543                  resolvePath = IOUtil.ResolvePath(@"d:\", @"specs");
544                  Assert.True(string.Equals(resolvePath, @"d:\specs", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
545                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"src\proj");
546                  Assert.True(string.Equals(resolvePath, @"d:\src\project\src\proj", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
547                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\foo", @"..");
548                  Assert.True(string.Equals(resolvePath, @"d:\src\project", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
549                  resolvePath = IOUtil.ResolvePath(@"d:\src\project", @"..\..\");
550                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
551                  resolvePath = IOUtil.ResolvePath(@"d:/src/project", @"../.");
552                  Assert.True(string.Equals(resolvePath, @"d:\src", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
553                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/", @"../../foo");
554                  Assert.True(string.Equals(resolvePath, @"d:\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
555                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/foo", @".././bar/.././../foo");
556                  Assert.True(string.Equals(resolvePath, @"d:\src\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
557                  resolvePath = IOUtil.ResolvePath(@"d:\", @".");
558                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
559  #else
560                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"foo");
561                  Assert.True(string.Equals(resolvePath, @"/user/src/project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
562                  resolvePath = IOUtil.ResolvePath(@"/root", @"./user/./specs");
563                  Assert.True(string.Equals(resolvePath, @"/root/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
564                  resolvePath = IOUtil.ResolvePath(@"/", @"user/specs/.");
565                  Assert.True(string.Equals(resolvePath, @"/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
566                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../");
567                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
568                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../../");
569                  Assert.True(string.Equals(resolvePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
570                  resolvePath = IOUtil.ResolvePath(@"/user/src/project/foo", @"../../../../user/./src");
571                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
572                  resolvePath = IOUtil.ResolvePath(@"/user/src", @"../../.");
573                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
574                  resolvePath = IOUtil.ResolvePath(@"/", @"./");
575                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
576  #endif
577              }
578          }
579          [Fact]
580          [Trait("Level", "L0")]
581          [Trait("Category", "Common")]
582          public void ValidateExecutePermission_DoesNotExceedFailsafe()
583          {
584              using (TestHostContext hc = new(this))
585              {
586                  Tracing trace = hc.GetTrace();
587                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
588                  try
589                  {
590                      Directory.CreateDirectory(directory);
591                      IOUtil.ValidateExecutePermission(directory);
592                  }
593                  finally
594                  {
595                      if (Directory.Exists(directory))
596                      {
597                          Directory.Delete(directory, recursive: true);
598                      }
599                  }
600              }
601          }
602          [Fact]
603          [Trait("Level", "L0")]
604          [Trait("Category", "Common")]
605          public void ValidateExecutePermission_ExceedsFailsafe()
606          {
607              using (TestHostContext hc = new(this))
608              {
609                  Tracing trace = hc.GetTrace();
610                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName(), "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20");
611                  try
612                  {
613                      Directory.CreateDirectory(directory);
614                      Environment.SetEnvironmentVariable("AGENT_TEST_VALIDATE_EXECUTE_PERMISSIONS_FAILSAFE", "20");
615                      try
616                      {
617                          IOUtil.ValidateExecutePermission(directory);
618                          throw new Exception("Should have thrown not supported exception.");
619                      }
620                      catch (NotSupportedException)
621                      {
622                      }
623                  }
624                  finally
625                  {
626                      if (Directory.Exists(directory))
627                      {
628                          Directory.Delete(directory, recursive: true);
629                      }
630                  }
631              }
632          }
633          [Fact]
634          [Trait("Level", "L0")]
635          [Trait("Category", "Common")]
636          public void LoadObject_ThrowsOnRequiredLoadObject()
637          {
638              using (TestHostContext hc = new(this))
639              {
640                  Tracing trace = hc.GetTrace();
641                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
642                  string file = Path.Combine(directory, "empty file");
643                  Directory.CreateDirectory(directory);
644                  File.WriteAllText(path: file, contents: "");
645                  Assert.Throws<ArgumentNullException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
646                  file = Path.Combine(directory, "invalid type file");
647                  File.WriteAllText(path: file, contents: " ");
648                  Assert.Throws<ArgumentException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
649                  if (Directory.Exists(directory))
650                  {
651                      Directory.Delete(directory, recursive: true);
652                  }
653              }
654          }
655          private static async Task CreateDirectoryReparsePoint(IHostContext context, string link, string target)
656          {
657  #if OS_WINDOWS
658              string fileName = Environment.GetEnvironmentVariable("ComSpec");
659              string arguments = $@"/c ""mklink /J ""{link}"" {target}""""";
660  #else
661              string fileName = "/bin/ln";
662              string arguments = $@"-s ""{target}"" ""{link}""";
663  #endif
664              ArgUtil.File(fileName, nameof(fileName));
665              using (var processInvoker = new ProcessInvokerWrapper())
666              {
667                  processInvoker.Initialize(context);
668                  await processInvoker.ExecuteAsync(
669                      workingDirectory: context.GetDirectory(WellKnownDirectory.Bin),
670                      fileName: fileName,
671                      arguments: arguments,
672                      environment: null,
673                      requireExitCodeZero: true,
674                      cancellationToken: CancellationToken.None);
675              }
676          }
677      }
678  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Threading.Tasks;
5  using System.Linq;
6  using System.Threading;
7  using GitHub.Runner.Worker.Container;
8  using GitHub.Services.Common;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
13  using GitHub.Runner.Worker.Container.ContainerHooks;
14  #if OS_WINDOWS 
15  using System.ServiceProcess;
16  using Microsoft.Win32;
17  #endif
18  namespace GitHub.Runner.Worker
19  {
20      [ServiceLocator(Default = typeof(ContainerOperationProvider))]
21      public interface IContainerOperationProvider : IRunnerService
22      {
23          Task StartContainersAsync(IExecutionContext executionContext, object data);
24          Task StopContainersAsync(IExecutionContext executionContext, object data);
25      }
26      public class ContainerOperationProvider : RunnerService, IContainerOperationProvider
27      {
28          private IDockerCommandManager _dockerManager;
29          private IContainerHookManager _containerHookManager;
30          public override void Initialize(IHostContext hostContext)
31          {
32              base.Initialize(hostContext);
33              if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable(Constants.Hooks.ContainerHooksPath)))
34              {
35                  _dockerManager = HostContext.GetService<IDockerCommandManager>();
36              }
37              else
38              {
39                  _containerHookManager = HostContext.GetService<IContainerHookManager>();
40              }
41          }
42          public async Task StartContainersAsync(IExecutionContext executionContext, object data)
43          {
44              Trace.Entering();
45              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
46              {
47                  throw new NotSupportedException("Container operations are only supported on Linux runners");
48              }
49              ArgUtil.NotNull(executionContext, nameof(executionContext));
50              List<ContainerInfo> containers = data as List<ContainerInfo>;
51              ArgUtil.NotNull(containers, nameof(containers));
52              var postJobStep = new JobExtensionRunner(runAsync: this.StopContainersAsync,
53                                                  condition: $"{PipelineTemplateConstants.Always}()",
54                                                  displayName: "Stop containers",
55                                                  data: data);
56              executionContext.Debug($"Register post job cleanup for stopping/deleting containers.");
57              executionContext.RegisterPostJobStep(postJobStep);
58              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
59              {
60                  containers.ForEach(container => UpdateRegistryAuthForGitHubToken(executionContext, container));
61                  containers.Where(container => container.IsJobContainer).ForEach(container => MountWellKnownDirectories(executionContext, container));
62                  await _containerHookManager.PrepareJobAsync(executionContext, containers);
63                  return;
64              }
65              await AssertCompatibleOS(executionContext);
66              executionContext.Output("##[group]Clean up resources from previous jobs");
67              var staleContainers = await _dockerManager.DockerPS(executionContext, $"--all --quiet --no-trunc --filter \"label={_dockerManager.DockerInstanceLabel}\"");
68              foreach (var staleContainer in staleContainers)
69              {
70                  int containerRemoveExitCode = await _dockerManager.DockerRemove(executionContext, staleContainer);
71                  if (containerRemoveExitCode != 0)
72                  {
73                      executionContext.Warning($"Delete stale containers failed, docker rm fail with exit code {containerRemoveExitCode} for container {staleContainer}");
74                  }
75              }
76              int networkPruneExitCode = await _dockerManager.DockerNetworkPrune(executionContext);
77              if (networkPruneExitCode != 0)
78              {
79                  executionContext.Warning($"Delete stale container networks failed, docker network prune fail with exit code {networkPruneExitCode}");
80              }
81              executionContext.Output("##[endgroup]");
82              executionContext.Output("##[group]Create local container network");
83              var containerNetwork = $"github_network_{Guid.NewGuid().ToString("N")}";
84              await CreateContainerNetworkAsync(executionContext, containerNetwork);
85              executionContext.JobContext.Container["network"] = new StringContextData(containerNetwork);
86              executionContext.Output("##[endgroup]");
87              foreach (var container in containers)
88              {
89                  container.ContainerNetwork = containerNetwork;
90                  await StartContainerAsync(executionContext, container);
91              }
92              await RunContainersHealthcheck(executionContext, containers);
93          }
94          public async Task RunContainersHealthcheck(IExecutionContext executionContext, List<ContainerInfo> containers)
95          {
96              executionContext.Output("##[group]Waiting for all services to be ready");
97              var unhealthyContainers = new List<ContainerInfo>();
98              foreach (var container in containers.Where(c => !c.IsJobContainer))
99              {
100                  var healthy_container = await ContainerHealthcheck(executionContext, container);
101                  if (!healthy_container)
102                  {
103                      unhealthyContainers.Add(container);
104                  }
105                  else
106                  {
107                      executionContext.Output($"{container.ContainerNetworkAlias} service is healthy.");
108                  }
109              }
110              executionContext.Output("##[endgroup]");
111              if (unhealthyContainers.Count > 0)
112              {
113                  foreach (var container in unhealthyContainers)
114                  {
115                      executionContext.Output($"##[group]Service container {container.ContainerNetworkAlias} failed.");
116                      await _dockerManager.DockerLogs(context: executionContext, containerId: container.ContainerId);
117                      executionContext.Error($"Failed to initialize container {container.ContainerImage}");
118                      container.FailedInitialization = true;
119                      executionContext.Output("##[endgroup]");
120                  }
121                  throw new InvalidOperationException("One or more containers failed to start.");
122              }
123          }
124          public async Task StopContainersAsync(IExecutionContext executionContext, object data)
125          {
126              Trace.Entering();
127              ArgUtil.NotNull(executionContext, nameof(executionContext));
128              List<ContainerInfo> containers = data as List<ContainerInfo>;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
131              {
132                  await _containerHookManager.CleanupJobAsync(executionContext, containers);
133                  return;
134              }
135              foreach (var container in containers)
136              {
137                  await StopContainerAsync(executionContext, container);
138              }
139              await RemoveContainerNetworkAsync(executionContext, containers.First().ContainerNetwork);
140          }
141          private async Task StartContainerAsync(IExecutionContext executionContext, ContainerInfo container)
142          {
143              Trace.Entering();
144              ArgUtil.NotNull(executionContext, nameof(executionContext));
145              ArgUtil.NotNull(container, nameof(container));
146              ArgUtil.NotNullOrEmpty(container.ContainerImage, nameof(container.ContainerImage));
147              Trace.Info($"Container name: {container.ContainerName}");
148              Trace.Info($"Container image: {container.ContainerImage}");
149              Trace.Info($"Container options: {container.ContainerCreateOptions}");
150              var groupName = container.IsJobContainer ? "Starting job container" : $"Starting {container.ContainerNetworkAlias} service container";
151              executionContext.Output($"##[group]{groupName}");
152              foreach (var port in container.UserPortMappings)
153              {
154                  Trace.Info($"User provided port: {port.Value}");
155              }
156              foreach (var mount in container.UserMountVolumes)
157              {
158                  Trace.Info($"User provided volume: {mount.UserProvidedValue}");
159                  if (string.Equals(mount.SourceVolumePath, "/", StringComparison.OrdinalIgnoreCase))
160                  {
161                      executionContext.Warning($"Volume mount {mount.UserProvidedValue} is going to mount '/' into the container which may cause file ownership change in the entire file system and cause Actions Runner to lose permission to access the disk.");
162                  }
163              }
164              UpdateRegistryAuthForGitHubToken(executionContext, container);
165              var configLocation = await ContainerRegistryLogin(executionContext, container);
166              int retryCount = 0;
167              int pullExitCode = 0;
168              while (retryCount < 3)
169              {
170                  pullExitCode = await _dockerManager.DockerPull(executionContext, container.ContainerImage, configLocation);
171                  if (pullExitCode == 0)
172                  {
173                      break;
174                  }
175                  else
176                  {
177                      retryCount++;
178                      if (retryCount < 3)
179                      {
180                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
181                          executionContext.Warning($"Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
182                          await Task.Delay(backOff);
183                      }
184                  }
185              }
186              ContainerRegistryLogout(configLocation);
187              if (retryCount == 3 && pullExitCode != 0)
188              {
189                  throw new InvalidOperationException($"Docker pull failed with exit code {pullExitCode}");
190              }
191              if (container.IsJobContainer)
192              {
193                  MountWellKnownDirectories(executionContext, container);
194              }
195              container.ContainerId = await _dockerManager.DockerCreate(executionContext, container);
196              ArgUtil.NotNullOrEmpty(container.ContainerId, nameof(container.ContainerId));
197              int startExitCode = await _dockerManager.DockerStart(executionContext, container.ContainerId);
198              if (startExitCode != 0)
199              {
200                  throw new InvalidOperationException($"Docker start fail with exit code {startExitCode}");
201              }
202              try
203              {
204                  var psOutputs = await _dockerManager.DockerPS(executionContext, $"--all --filter id={container.ContainerId} --filter status=running --no-trunc --format \"{{{{.ID}}}} {{{{.Status}}}}\"");
205                  if (psOutputs.FirstOrDefault(x => !string.IsNullOrEmpty(x))?.StartsWith(container.ContainerId) != true)
206                  {
207                      await _dockerManager.DockerPS(executionContext, $"--all --filter id={container.ContainerId} --no-trunc --format \"{{{{.ID}}}} {{{{.Status}}}}\"");
208                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
209                      if (logsExitCode != 0)
210                      {
211                          executionContext.Warning($"Docker logs fail with exit code {logsExitCode}");
212                      }
213                      executionContext.Warning($"Docker container {container.ContainerId} is not in running state.");
214                  }
215              }
216              catch (Exception ex)
217              {
218                  Trace.Error("Catch exception when check container log and container status.");
219                  Trace.Error(ex);
220              }
221              if (!container.IsJobContainer)
222              {
223                  var service = new DictionaryContextData()
224                  {
225                      ["id"] = new StringContextData(container.ContainerId),
226                      ["ports"] = new DictionaryContextData(),
227                      ["network"] = new StringContextData(container.ContainerNetwork)
228                  };
229                  container.AddPortMappings(await _dockerManager.DockerPort(executionContext, container.ContainerId));
230                  foreach (var port in container.PortMappings)
231                  {
232                      (service["ports"] as DictionaryContextData)[port.ContainerPort] = new StringContextData(port.HostPort);
233                  }
234                  executionContext.JobContext.Services[container.ContainerNetworkAlias] = service;
235              }
236              else
237              {
238                  var configEnvFormat = "--format \"{{range .Config.Env}}{{println .}}{{end}}\"";
239                  var containerEnv = await _dockerManager.DockerInspect(executionContext, container.ContainerId, configEnvFormat);
240                  container.ContainerRuntimePath = DockerUtil.ParsePathFromConfigEnv(containerEnv);
241                  executionContext.JobContext.Container["id"] = new StringContextData(container.ContainerId);
242              }
243              executionContext.Output("##[endgroup]");
244          }
245          private void MountWellKnownDirectories(IExecutionContext executionContext, ContainerInfo container)
246          {
247              var githubContext = executionContext.ExpressionValues["github"] as GitHubContext;
248              ArgUtil.NotNull(githubContext, nameof(githubContext));
249              var workingDirectory = githubContext["workspace"] as StringContextData;
250              ArgUtil.NotNullOrEmpty(workingDirectory, nameof(workingDirectory));
251              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Work), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Work))));
252  #if OS_WINDOWS
253                  container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals))));
254  #else
255              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals)), true));
256  #endif
257              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Temp), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Temp))));
258              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Actions), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Actions))));
259              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Tools), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Tools))));
260              var tempHomeDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), "_github_home");
261              Directory.CreateDirectory(tempHomeDirectory);
262              container.MountVolumes.Add(new MountVolume(tempHomeDirectory, "/github/home"));
263              container.AddPathTranslateMapping(tempHomeDirectory, "/github/home");
264              container.ContainerEnvironmentVariables["HOME"] = container.TranslateToContainerPath(tempHomeDirectory);
265              var tempWorkflowDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), "_github_workflow");
266              Directory.CreateDirectory(tempWorkflowDirectory);
267              container.MountVolumes.Add(new MountVolume(tempWorkflowDirectory, "/github/workflow"));
268              container.AddPathTranslateMapping(tempWorkflowDirectory, "/github/workflow");
269              container.ContainerWorkDirectory = container.TranslateToContainerPath(workingDirectory);
270              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
271              {
272                  container.ContainerEntryPoint = "tail";
273                  container.ContainerEntryPointArgs = "\"-f\" \"/dev/null\"";
274              }
275          }
276          private async Task StopContainerAsync(IExecutionContext executionContext, ContainerInfo container)
277          {
278              Trace.Entering();
279              ArgUtil.NotNull(executionContext, nameof(executionContext));
280              ArgUtil.NotNull(container, nameof(container));
281              if (!string.IsNullOrEmpty(container.ContainerId))
282              {
283                  if (!container.IsJobContainer && !container.FailedInitialization)
284                  {
285                      executionContext.Output($"Print service container logs: {container.ContainerDisplayName}");
286                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
287                      if (logsExitCode != 0)
288                      {
289                          executionContext.Warning($"Docker logs fail with exit code {logsExitCode}");
290                      }
291                  }
292                  executionContext.Output($"Stop and remove container: {container.ContainerDisplayName}");
293                  int rmExitCode = await _dockerManager.DockerRemove(executionContext, container.ContainerId);
294                  if (rmExitCode != 0)
295                  {
296                      executionContext.Warning($"Docker rm fail with exit code {rmExitCode}");
297                  }
298              }
299          }
300  #if !OS_WINDOWS
301          private async Task<List<string>> ExecuteCommandAsync(IExecutionContext context, string command, string arg)
302          {
303              context.Command($"{command} {arg}");
304              List<string> outputs = new();
305              object outputLock = new();
306              var processInvoker = HostContext.CreateService<IProcessInvoker>();
307              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
308              {
309                  if (!string.IsNullOrEmpty(message.Data))
310                  {
311                      lock (outputLock)
312                      {
313                          outputs.Add(message.Data);
314                      }
315                  }
316              };
317              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
318              {
319                  if (!string.IsNullOrEmpty(message.Data))
320                  {
321                      lock (outputLock)
322                      {
323                          outputs.Add(message.Data);
324                      }
325                  }
326              };
327              await processInvoker.ExecuteAsync(
328                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
329                              fileName: command,
330                              arguments: arg,
331                              environment: null,
332                              requireExitCodeZero: true,
333                              outputEncoding: null,
334                              cancellationToken: CancellationToken.None);
335              foreach (var outputLine in outputs)
336              {
337                  context.Output(outputLine);
338              }
339              return outputs;
340          }
341  #endif
342          private async Task CreateContainerNetworkAsync(IExecutionContext executionContext, string network)
343          {
344              Trace.Entering();
345              ArgUtil.NotNull(executionContext, nameof(executionContext));
346              int networkExitCode = await _dockerManager.DockerNetworkCreate(executionContext, network);
347              if (networkExitCode != 0)
348              {
349                  throw new InvalidOperationException($"Docker network create failed with exit code {networkExitCode}");
350              }
351          }
352          private async Task RemoveContainerNetworkAsync(IExecutionContext executionContext, string network)
353          {
354              Trace.Entering();
355              ArgUtil.NotNull(executionContext, nameof(executionContext));
356              ArgUtil.NotNull(network, nameof(network));
357              executionContext.Output($"Remove container network: {network}");
358              int removeExitCode = await _dockerManager.DockerNetworkRemove(executionContext, network);
359              if (removeExitCode != 0)
360              {
361                  executionContext.Warning($"Docker network rm failed with exit code {removeExitCode}");
362              }
363          }
364          private async Task<bool> ContainerHealthcheck(IExecutionContext executionContext, ContainerInfo container)
365          {
366              string healthCheck = "--format=\"{{if .Config.Healthcheck}}{{print .State.Health.Status}}{{end}}\"";
367              string serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
368              if (string.IsNullOrEmpty(serviceHealth))
369              {
370                  return true;
371              }
372              var retryCount = 0;
373              while (string.Equals(serviceHealth, "starting", StringComparison.OrdinalIgnoreCase))
374              {
375                  TimeSpan backoff = BackoffTimerHelper.GetExponentialBackoff(retryCount, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(32), TimeSpan.FromSeconds(2));
376                  executionContext.Output($"{container.ContainerNetworkAlias} service is starting, waiting {backoff.Seconds} seconds before checking again.");
377                  await Task.Delay(backoff, executionContext.CancellationToken);
378                  serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
379                  retryCount++;
380              }
381              return string.Equals(serviceHealth, "healthy", StringComparison.OrdinalIgnoreCase);
382          }
383          private async Task<string> ContainerRegistryLogin(IExecutionContext executionContext, ContainerInfo container)
384          {
385              if (string.IsNullOrEmpty(container.RegistryAuthUsername) || string.IsNullOrEmpty(container.RegistryAuthPassword))
386              {
387                  return "";
388              }
389              var configLocation = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), $".docker_{Guid.NewGuid()}");
390              try
391              {
392                  var dirInfo = Directory.CreateDirectory(configLocation);
393              }
394              catch (Exception e)
395              {
396                  throw new InvalidOperationException($"Failed to create directory to store registry client credentials: {e.Message}");
397              }
398              var loginExitCode = await _dockerManager.DockerLogin(
399                  executionContext,
400                  configLocation,
401                  container.RegistryServer,
402                  container.RegistryAuthUsername,
403                  container.RegistryAuthPassword);
404              if (loginExitCode != 0)
405              {
406                  throw new InvalidOperationException($"Docker login for '{container.RegistryServer}' failed with exit code {loginExitCode}");
407              }
408              return configLocation;
409          }
410          private void ContainerRegistryLogout(string configLocation)
411          {
412              try
413              {
414                  if (!string.IsNullOrEmpty(configLocation) && Directory.Exists(configLocation))
415                  {
<span onclick='openModal()' class='match'>416                      Directory.Delete(configLocation, recursive: true);
417                  }
418              }
</span>419              catch (Exception e)
420              {
421                  throw new InvalidOperationException($"Failed to remove directory containing Docker client credentials: {e.Message}");
422              }
423          }
424          private void UpdateRegistryAuthForGitHubToken(IExecutionContext executionContext, ContainerInfo container)
425          {
426              var registryIsTokenCompatible = container.RegistryServer.Equals("ghcr.io", StringComparison.OrdinalIgnoreCase) || container.RegistryServer.Equals("containers.pkg.github.com", StringComparison.OrdinalIgnoreCase);
427              var isFallbackTokenFromHostedGithub = HostContext.GetService<IConfigurationStore>().GetSettings().IsHostedServer;
428              if (!registryIsTokenCompatible || !isFallbackTokenFromHostedGithub)
429              {
430                  return;
431              }
432              var registryCredentialsNotSupplied = string.IsNullOrEmpty(container.RegistryAuthUsername) && string.IsNullOrEmpty(container.RegistryAuthPassword);
433              if (registryCredentialsNotSupplied)
434              {
435                  container.RegistryAuthUsername = executionContext.GetGitHubContext("actor");
436                  container.RegistryAuthPassword = executionContext.GetGitHubContext("token");
437              }
438          }
439          private async Task AssertCompatibleOS(IExecutionContext executionContext)
440          {
441  #if OS_WINDOWS
442  #pragma warning disable CA1416
443              ServiceController[] scServices = ServiceController.GetServices();
444              if (scServices.Any(x => String.Equals(x.ServiceName, "cexecsvc", StringComparison.OrdinalIgnoreCase) && x.Status == ServiceControllerStatus.Running))
445              {
446                  throw new NotSupportedException("Container feature is not supported when runner is already running inside container.");
447              }
448  #pragma warning restore CA1416
449  #else
450              var initProcessCgroup = File.ReadLines("/proc/1/cgroup");
451              if (initProcessCgroup.Any(x => x.IndexOf(":/docker/", StringComparison.OrdinalIgnoreCase) >= 0))
452              {
453                  throw new NotSupportedException("Container feature is not supported when runner is already running inside container.");
454              }
455  #endif
456  #if OS_WINDOWS
457  #pragma warning disable CA1416
458              object windowsInstallationType = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "InstallationType", defaultValue: null);
459              ArgUtil.NotNull(windowsInstallationType, nameof(windowsInstallationType));
460              object windowsReleaseId = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ReleaseId", defaultValue: null);
461              ArgUtil.NotNull(windowsReleaseId, nameof(windowsReleaseId));
462              executionContext.Debug($"Current Windows version: '{windowsReleaseId} ({windowsInstallationType})'");
463              if (int.TryParse(windowsReleaseId.ToString(), out int releaseId))
464              {
465                  if (!windowsInstallationType.ToString().StartsWith("Server", StringComparison.OrdinalIgnoreCase) || releaseId < 1803)
466                  {
467                      throw new NotSupportedException("Container feature requires Windows Server 1803 or higher.");
468                  }
469              }
470              else
471              {
472                  throw new ArgumentOutOfRangeException(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId");
473              }
474  #pragma warning restore CA1416
475  #endif
476              executionContext.Output("##[group]Checking docker version");
477              DockerVersion dockerVersion = await _dockerManager.DockerVersion(executionContext);
478              executionContext.Output("##[endgroup]");
479              ArgUtil.NotNull(dockerVersion.ServerVersion, nameof(dockerVersion.ServerVersion));
480              ArgUtil.NotNull(dockerVersion.ClientVersion, nameof(dockerVersion.ClientVersion));
481  #if OS_WINDOWS
482              Version requiredDockerEngineAPIVersion = new Version(1, 30);  
483  #else
484              Version requiredDockerEngineAPIVersion = new(1, 35); 
485  #endif
486              if (dockerVersion.ServerVersion < requiredDockerEngineAPIVersion)
487              {
488                  throw new NotSupportedException($"Min required docker engine API server version is '{requiredDockerEngineAPIVersion}', your docker ('{_dockerManager.DockerPath}') server version is '{dockerVersion.ServerVersion}'");
489              }
490              if (dockerVersion.ClientVersion < requiredDockerEngineAPIVersion)
491              {
492                  throw new NotSupportedException($"Min required docker engine API client version is '{requiredDockerEngineAPIVersion}', your docker ('{_dockerManager.DockerPath}') client version is '{dockerVersion.ClientVersion}'");
493              }
494          }
495      }
496  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</div>
                </div>
                <div class="column column_space"><pre><code>184                          Directory.Delete(directory, recursive: true);
185                      }
186                  }
</pre></code></div>
                <div class="column column_space"><pre><code>416                      Directory.Delete(configLocation, recursive: true);
417                  }
418              }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    