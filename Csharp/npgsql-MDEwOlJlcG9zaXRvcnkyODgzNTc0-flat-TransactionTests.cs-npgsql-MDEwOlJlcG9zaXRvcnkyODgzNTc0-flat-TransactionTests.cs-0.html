
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TransactionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading.Tasks;
4  using Npgsql.Internal;
5  using Npgsql.Tests.Support;
6  using Npgsql.Util;
7  using NUnit.Framework;
8  using static Npgsql.Tests.TestUtil;
9  namespace Npgsql.Tests;
10  public class TransactionTests : MultiplexingTestBase
11  {
12      [Test, Description(&quot;Basic insert within a commited transaction&quot;)]
13      public async Task Commit([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
14      {
15          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
16              return;
17          await using var conn = await OpenConnectionAsync();
18          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
19          var tx = await conn.BeginTransactionAsync();
20          await using (tx)
21          {
22              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
23              if (prepare == PrepareOrNot.Prepared)
24                  cmd.Prepare();
25              cmd.ExecuteNonQuery();
26              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
27              tx.Commit();
28              Assert.That(tx.IsCompleted);
29              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
30              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
31          }
32          if (!IsMultiplexing)
33              Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
34      }
35      [Test, Description(&quot;Basic insert within a commited transaction&quot;)]
36      public async Task CommitAsync([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
37      {
38          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
39              return;
40          await using var conn = await OpenConnectionAsync();
41          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
42          var tx = await conn.BeginTransactionAsync();
43          await using (tx)
44          {
45              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
46              if (prepare == PrepareOrNot.Prepared)
47                  cmd.Prepare();
48              await cmd.ExecuteNonQueryAsync();
49              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
50              await tx.CommitAsync();
51              Assert.That(tx.IsCompleted);
52              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
53              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
54          }
55          Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
56      }
57      [Test, Description(&quot;Basic insert within a rolled back transaction&quot;)]
58      public async Task Rollback([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
59      {
60          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
61              return;
62          await using var conn = await OpenConnectionAsync();
63          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
64          var tx = await conn.BeginTransactionAsync();
65          await using (tx)
66          {
67              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
68              if (prepare == PrepareOrNot.Prepared)
69                  cmd.Prepare();
70              cmd.ExecuteNonQuery();
71              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
72              tx.Rollback();
73              Assert.That(tx.IsCompleted);
74              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
75              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
76          }
77          Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
78      }
79      [Test, Description(&quot;Basic insert within a rolled back transaction&quot;)]
80      public async Task RollbackAsync([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
81      {
82          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
83              return;
84          await using var conn = await OpenConnectionAsync();
85          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
86          var tx = await conn.BeginTransactionAsync();
87          await using (tx)
88          {
89              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
90              if (prepare == PrepareOrNot.Prepared)
91                  cmd.Prepare();
92              await cmd.ExecuteNonQueryAsync();
93              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
94              await tx.RollbackAsync();
95              Assert.That(tx.IsCompleted);
96              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
97              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
98          }
99          Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
100      }
101      [Test, Description(&quot;Dispose a transaction in progress, should roll back&quot;)]
102      public async Task Rollback_on_Dispose()
103      {
104          await using var conn = await OpenConnectionAsync();
105          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
106          await using (var tx = await conn.BeginTransactionAsync())
107          {
108              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
109          }
110          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
111      }
112      [Test]
113      public async Task Rollback_on_Close()
114      {
115          await using var conn1 = await OpenConnectionAsync();
116          var table = await CreateTempTable(conn1, &quot;name TEXT&quot;);
117          using (var conn2 = await OpenConnectionAsync())
118          {
119              var tx = await conn2.BeginTransactionAsync();
120              await conn2.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx);
121          }
122          Assert.That(await conn1.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
123      }
124      [Test, Description(&quot;Intentionally generates an error, putting us in a failed transaction block. Rolls back.&quot;)]
125      public async Task Rollback_failed()
126      {
127          await using var conn = await OpenConnectionAsync();
128          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
129          await using var tx = await conn.BeginTransactionAsync();
130          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
131          Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;BAD QUERY&quot;), Throws.Exception.TypeOf&lt;PostgresException&gt;());
132          tx.Rollback();
133          Assert.That(tx.IsCompleted);
134          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
135      }
136      [Test, Description(&quot;Commits an empty transaction&quot;)]
137      public async Task Empty_commit()
138      {
139          await using var conn = await OpenConnectionAsync();
140          await conn.BeginTransaction().CommitAsync();
141      }
142      [Test, Description(&quot;Rolls back an empty transaction&quot;)]
143      public async Task Empty_rollback()
144      {
145          await using var conn = await OpenConnectionAsync();
146          await conn.BeginTransaction().RollbackAsync();
147      }
148      [Test, Description(&quot;Disposes an empty transaction&quot;)]
149      public async Task Empty_Dispose()
150      {
151          await using var dataSource = CreateDataSource();
152          using (var conn = await dataSource.OpenConnectionAsync())
153          using (conn.BeginTransaction())
154          { }
155          using (var conn = await dataSource.OpenConnectionAsync())
156          {
157              Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;SAVEPOINT foo&quot;),
158                  Throws.Exception.TypeOf&lt;PostgresException&gt;()
159                      .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.NoActiveSqlTransaction));
160          }
161      }
162      [Test, Description(&quot;Tests that the isolation levels are properly supported&quot;)]
163      [TestCase(IsolationLevel.ReadCommitted,   &quot;read committed&quot;)]
164      [TestCase(IsolationLevel.ReadUncommitted, &quot;read uncommitted&quot;)]
165      [TestCase(IsolationLevel.RepeatableRead,  &quot;repeatable read&quot;)]
166      [TestCase(IsolationLevel.Serializable,    &quot;serializable&quot;)]
167      [TestCase(IsolationLevel.Snapshot,        &quot;repeatable read&quot;)]
168      [TestCase(IsolationLevel.Unspecified,     &quot;read committed&quot;)]
169      public async Task Isolation_levels(IsolationLevel level, string expectedName)
170      {
171          await using var conn = await OpenConnectionAsync();
172          var tx = conn.BeginTransaction(level);
173          Assert.That(conn.ExecuteScalar(&quot;SHOW TRANSACTION ISOLATION LEVEL&quot;), Is.EqualTo(expectedName));
174          await tx.CommitAsync();
175      }
176      [Test]
177      public async Task IsolationLevel_Chaos_is_unsupported()
178      {
179          await using var conn = await OpenConnectionAsync();
180          Assert.That(() =&gt; conn.BeginTransaction(IsolationLevel.Chaos), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
181      }
182      [Test, Description(&quot;Rollback of an already rolled back transaction&quot;)]
183      public async Task Rollback_twice()
184      {
185          await using var conn = await OpenConnectionAsync();
186          var transaction = conn.BeginTransaction();
187          transaction.Rollback();
188          Assert.That(() =&gt; transaction.Rollback(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
189      }
190      [Test, Description(&quot;Makes sure the creating a transaction via DbConnection sets the proper isolation level&quot;)]
191      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/559&quot;)]
192      public async Task Default_IsolationLevel()
193      {
194          await using var conn = await OpenConnectionAsync();
195          var tx = conn.BeginTransaction();
196          Assert.That(tx.IsolationLevel, Is.EqualTo(IsolationLevel.ReadCommitted));
197          tx.Rollback();
198          tx = conn.BeginTransaction(IsolationLevel.Unspecified);
199          Assert.That(tx.IsolationLevel, Is.EqualTo(IsolationLevel.ReadCommitted));
200          tx.Rollback();
201      }
202      [Test, Description(&quot;Makes sure that transactions started in SQL work, except in multiplexing&quot;)]
203      public async Task Via_sql()
204      {
205          if (IsMultiplexing)
206              Assert.Ignore(&quot;Multiplexing: not implemented&quot;);
207          await using var conn = await OpenConnectionAsync();
208          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
209          if (IsMultiplexing)
210          {
211              Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;BEGIN&quot;), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
212              return;
213          }
214          await conn.ExecuteNonQueryAsync(&quot;BEGIN&quot;);
215          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;);
216          await conn.ExecuteNonQueryAsync(&quot;ROLLBACK&quot;);
217          Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
218      }
219      [Test]
220      public async Task Nested()
221      {
222          await using var conn = await OpenConnectionAsync();
223          conn.BeginTransaction();
224          Assert.That(() =&gt; conn.BeginTransaction(), Throws.TypeOf&lt;InvalidOperationException&gt;());
225      }
226      [Test]
227      public void Begin_transaction_on_closed_connection_throws()
228      {
229          using var conn = new NpgsqlConnection();
230          Assert.That(() =&gt; conn.BeginTransaction(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
231      }
232      [Test]
233      public async Task Rollback_failed_transaction_with_timeout()
234      {
235          await using var conn = await OpenConnectionAsync();
236          var tx = conn.BeginTransaction();
237          using var cmd = new NpgsqlCommand(&quot;BAD QUERY&quot;, conn, tx);
238          Assert.That(cmd.CommandTimeout != 1);
239          cmd.CommandTimeout = 1;
240          try
241          {
242              cmd.ExecuteScalar();
243              Assert.Fail();
244          }
245          catch (PostgresException)
246          {
247              await tx.RollbackAsync();
248              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
249          }
250      }
251      [Test, Description(&quot;If a custom command timeout is set, a failed transaction could not be rollbacked to a previous savepoint&quot;)]
252      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/363&quot;)]
253      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/184&quot;)]
254      public async Task Failed_transaction_cannot_rollback_to_savepoint_with_custom_timeout()
255      {
256          await using var conn = await OpenConnectionAsync();
257          var transaction = conn.BeginTransaction();
258          transaction.Save(&quot;TestSavePoint&quot;);
259          using var cmd = new NpgsqlCommand(&quot;SELECT unknown_thing&quot;, conn);
260          cmd.CommandTimeout = 1;
261          try
262          {
263              cmd.ExecuteScalar();
264          }
265          catch (PostgresException)
266          {
267              transaction.Rollback(&quot;TestSavePoint&quot;);
268              Assert.That(conn.ExecuteScalar(&quot;SELECT 1&quot;), Is.EqualTo(1));
269          }
270      }
271      [Test, Description(&quot;Closes a (pooled) connection with a failed transaction and a custom timeout&quot;)]
272      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/719&quot;)]
273      public async Task Failed_transaction_on_close_with_custom_timeout()
274      {
275          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = true);
276          await using var conn = await dataSource.OpenConnectionAsync();
277          conn.BeginTransaction();
278          var backendProcessId = conn.ProcessID;
279          using (var badCmd = new NpgsqlCommand(&quot;SEL&quot;, conn))
280          {
281              badCmd.CommandTimeout = NpgsqlCommand.DefaultTimeout + 1;
282              Assert.That(() =&gt; badCmd.ExecuteNonQuery(), Throws.Exception.TypeOf&lt;PostgresException&gt;());
283          }
284          conn.Close();
285          conn.Open();
286          conn.BeginTransaction();
287          Assert.That(conn.ProcessID, Is.EqualTo(backendProcessId));
288          Assert.That(conn.ExecuteScalar(&quot;SELECT 1&quot;), Is.EqualTo(1));
289      }
290      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/555&quot;)]
291      public async Task Transaction_on_recycled_connection()
292      {
293          if (IsMultiplexing)
294              Assert.Ignore(&quot;Multiplexing: fails&quot;);
295          await using var conn = new NpgsqlConnection(ConnectionString + $&quot;;Application Name={GetUniqueIdentifier(nameof(Transaction_on_recycled_connection))}&quot;);
296          conn.Open();
297          var prevConnectorId = conn.Connector!.Id;
298          conn.Close();
299          conn.Open();
300          Assert.That(conn.Connector.Id, Is.EqualTo(prevConnectorId), &quot;Connection pool returned a different connector, can&#x27;t test&quot;);
301          var tx = conn.BeginTransaction();
302          conn.ExecuteScalar(&quot;SELECT 1&quot;);
303          await tx.CommitAsync();
304          NpgsqlConnection.ClearPool(conn);
305      }
306      [Test]
307      public async Task Savepoint()
308      {
309          await using var conn = await OpenConnectionAsync();
310          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
311          const string name = &quot;theSavePoint&quot;;
312          using (var tx = conn.BeginTransaction())
313          {
314              tx.Save(name);
315              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
316              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
317              tx.Rollback(name);
318              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(0));
319              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
320              tx.Release(name);
321              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
322              await tx.CommitAsync();
323          }
<span onclick='openModal()' class='match'>324          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
325      }
</span>326      [Test]
327      public async Task Savepoint_async()
328      {
329          await using var conn = await OpenConnectionAsync();
330          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
331          const string name = &quot;theSavePoint&quot;;
332          using (var tx = conn.BeginTransaction())
333          {
334              await tx.SaveAsync(name);
335              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
336              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
337              await tx.RollbackAsync(name);
338              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(0));
339              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
340              await tx.ReleaseAsync(name);
341              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
342              await tx.CommitAsync();
343          }
344          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
345      }
346      [Test]
347      public async Task Savepoint_quoted()
348      {
349          await using var conn = await OpenConnectionAsync();
350          await using var tx = conn.BeginTransaction();
351          tx.Save(&quot;a;b&quot;);
352          tx.Rollback(&quot;a;b&quot;);
353      }
354      [Test(Description = &quot;Makes sure that creating a savepoint doesn&#x27;t perform an additional roundtrip, but prepends to the next command&quot;)]
355      public async Task Savepoint_prepends()
356      {
357          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
358          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
359          await using var conn = await dataSource.OpenConnectionAsync();
360          var pgMock = await postmasterMock.WaitForServerConnection();
361          using var tx = conn.BeginTransaction();
362          var saveTask = tx.SaveAsync(&quot;foo&quot;);
363          Assert.That(saveTask.Status, Is.EqualTo(TaskStatus.RanToCompletion));
364          await pgMock
365              .WriteCommandComplete()
366              .WriteReadyForQuery() 
367              .WriteCommandComplete()
368              .WriteReadyForQuery() 
369              .WriteScalarResponseAndFlush(1);
370          await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;);
371          await pgMock.ExpectSimpleQuery(&quot;BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED&quot;);
372          await pgMock.ExpectSimpleQuery(&quot;SAVEPOINT foo&quot;);
373          await pgMock.ExpectExtendedQuery();
374      }
375      [Test, Description(&quot;Check IsCompleted before, during and after a normal committed transaction&quot;)]
376      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/985&quot;)]
377      public async Task IsCompleted_commit()
378      {
379          await using var conn = await OpenConnectionAsync();
380          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
381          var tx = conn.BeginTransaction();
382          Assert.That(!tx.IsCompleted);
383          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
384          Assert.That(!tx.IsCompleted);
385          await tx.CommitAsync();
386          Assert.That(tx.IsCompleted);
387      }
388      [Test, Description(&quot;Check IsCompleted before, during, and after a successful but rolled back transaction&quot;)]
389      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/985&quot;)]
390      public async Task IsCompleted_rollback()
391      {
392          await using var conn = await OpenConnectionAsync();
393          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
394          var tx = conn.BeginTransaction();
395          Assert.That(!tx.IsCompleted);
396          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
397          Assert.That(!tx.IsCompleted);
398          tx.Rollback();
399          Assert.That(tx.IsCompleted);
400      }
401      [Test, Description(&quot;Check IsCompleted before, during, and after a failed then rolled back transaction&quot;)]
402      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/985&quot;)]
403      public async Task IsCompleted_rollback_failed()
404      {
405          await using var conn = await OpenConnectionAsync();
406          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
407          var tx = conn.BeginTransaction();
408          Assert.That(!tx.IsCompleted);
409          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
410          Assert.That(!tx.IsCompleted);
411          Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;BAD QUERY&quot;), Throws.Exception.TypeOf&lt;PostgresException&gt;());
412          Assert.That(!tx.IsCompleted);
413          tx.Rollback();
414          Assert.That(tx.IsCompleted);
415          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
416      }
417      [Test, Description(&quot;Tests that a if a DatabaseInfoFactory is registered for a database that doesn&#x27;t support transactions, no transactions are created&quot;)]
418      [Parallelizable(ParallelScope.None)]
419      public async Task Transaction_not_supported()
420      {
421          if (IsMultiplexing)
422              Assert.Ignore(&quot;Need to rethink/redo dummy transaction mode&quot;);
423          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
424          {
425              ApplicationName = nameof(Transaction_not_supported) + IsMultiplexing
426          }.ToString();
427          NpgsqlDatabaseInfo.RegisterFactory(new NoTransactionDatabaseInfoFactory());
428          try
429          {
430              using var conn = new NpgsqlConnection(connString);
431              await conn.OpenAsync();
432              using var tx = conn.BeginTransaction();
433              var prevTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
434              var nextTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
435              Assert.That(nextTxId, Is.Not.EqualTo(prevTxId));
436              conn.Close();
437          }
438          finally
439          {
440              NpgsqlDatabaseInfo.ResetFactories();
441          }
442          using (var conn = new NpgsqlConnection(connString))
443          {
444              await conn.OpenAsync();
445              NpgsqlConnection.ClearPool(conn);
446              conn.ReloadTypes();
447          }
448          using (var conn = new NpgsqlConnection(connString))
449          {
450              await conn.OpenAsync();
451              using (var tx = conn.BeginTransaction())
452              {
453                  var prevTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
454                  var nextTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
455                  Assert.That(nextTxId, Is.EqualTo(prevTxId));
456              }
457          }
458      }
459      [Test]
460      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3248&quot;)]
461      public async Task Bug3248_Dispose_transaction_Rollback()
462      {
463          if (!IsMultiplexing)
464              return;
465          using var conn = await OpenConnectionAsync();
466          await using (var tx = await conn.BeginTransactionAsync())
467          {
468              Assert.That(conn.Connector, Is.Not.Null);
469              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT * FROM \&quot;unknown_table\&quot;&quot;, tx: tx),
470                  Throws.Exception.TypeOf&lt;PostgresException&gt;());
471              Assert.That(conn.Connector, Is.Not.Null);
472          }
473          Assert.That(conn.Connector, Is.Null);
474      }
475      [Test]
476      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3248&quot;)]
477      public async Task Bug3248_Dispose_connection_Rollback()
478      {
479          if (!IsMultiplexing)
480              return;
481          var conn = await OpenConnectionAsync();
482          var tx = conn.BeginTransaction();
483          Assert.That(conn.Connector, Is.Not.Null);
484          Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT * FROM \&quot;unknown_table\&quot;&quot;, tx: tx),
485              Throws.Exception.TypeOf&lt;PostgresException&gt;());
486          Assert.That(conn.Connector, Is.Not.Null);
487          await conn.DisposeAsync();
488          Assert.That(conn.Connector, Is.Null);
489      }
490      [Test]
491      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3306&quot;)]
492      [TestCase(true)]
493      [TestCase(false)]
494      public async Task Bug3306(bool inTransactionBlock)
495      {
496          var conn = await OpenConnectionAsync();
497          var tx = await conn.BeginTransactionAsync();
498          await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;, tx);
499          if (!inTransactionBlock)
500              await tx.RollbackAsync();
501          await conn.CloseAsync();
502          conn = await OpenConnectionAsync();
503          var tx2 = await conn.BeginTransactionAsync();
504          await tx.DisposeAsync();
505          Assert.That(tx.IsDisposed, Is.True);
506          Assert.That(tx2.IsDisposed, Is.False);
507          await conn.DisposeAsync();
508      }
509      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/efcore.pg/issues/1593&quot;)]
510      public async Task Access_connection_on_completed_transaction()
511      {
512          using var conn = await OpenConnectionAsync();
513          using var tx = await conn.BeginTransactionAsync();
514          tx.Commit();
515          Assert.That(tx.Connection, Is.SameAs(conn));
516      }
517      [Test]
518      public async Task Unbound_transaction_reuse()
519      {
520          await using var dataSource = CreateDataSource(csb =&gt;
521          {
522              csb.MinPoolSize = 1;
523              csb.MaxPoolSize = 1;
524          });
525          await using var conn = await OpenConnectionAsync();
526          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
527          await using var conn1 = await dataSource.OpenConnectionAsync();
528          var tx1 = conn1.BeginTransaction();
529          await using (var ___ = tx1)
530          {
531              using var cmd1 = conn1.CreateCommand();
532              cmd1.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;); SELECT 1&quot;;
533              await using (var reader1 = await cmd1.ExecuteReaderAsync())
534              {
535                  Assert.That(async () =&gt; await reader1.ReadAsync(), Is.EqualTo(true));
536                  Assert.That(() =&gt; reader1.GetInt32(0), Is.EqualTo(1));
537                  Assert.That(reader1.RecordsAffected, Is.EqualTo(1));
538              }
539              await tx1.CommitAsync();
540              Assert.That(await conn1.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
541              await conn1.CloseAsync();
542          }
543          await using var conn2 = await dataSource.OpenConnectionAsync();
544          var tx2 = conn2.BeginTransaction();
545          await using (var ___ = tx2)
546          {
547              Assert.That(tx2, Is.Not.SameAs(tx1));
548              using var cmd2 = conn2.CreateCommand();
549              cmd2.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;Y&#x27;); SELECT 2&quot;;
550              await using (var reader2 = await cmd2.ExecuteReaderAsync())
551              {
552                  Assert.That(async () =&gt; await reader2.ReadAsync(), Is.EqualTo(true));
553                  Assert.That(() =&gt; reader2.GetInt32(0), Is.EqualTo(2));
554                  Assert.That(reader2.RecordsAffected, Is.EqualTo(1));
555              }
556              await tx2.CommitAsync();
557              Assert.That(await conn2.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(2));
558              await conn2.CloseAsync();
559          }
560          await using var conn3 = await dataSource.OpenConnectionAsync();
561          var tx3 = conn3.BeginTransaction();
562          await using (var ___ = tx3)
563          {
564              Assert.That(tx3, Is.SameAs(tx1));
565              using var cmd3 = conn3.CreateCommand();
566              cmd3.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;Z&#x27;); SELECT 3&quot;;
567              await using (var reader3 = await cmd3.ExecuteReaderAsync())
568              {
569                  Assert.That(async () =&gt; await reader3.ReadAsync(), Is.EqualTo(true));
570                  Assert.That(() =&gt; reader3.GetInt32(0), Is.EqualTo(3));
571                  Assert.That(reader3.RecordsAffected, Is.EqualTo(1));
572              }
573              await tx3.CommitAsync();
574              Assert.That(await conn3.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(3));
575              await conn3.CloseAsync();
576          }
577      }
578      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3686&quot;)]
579      public async Task Bug3686()
580      {
581          if (IsMultiplexing)
582              return;
583          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = false);
584          await using var conn = await dataSource.OpenConnectionAsync();
585          await using var tx = await conn.BeginTransactionAsync();
586          await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;, tx);
587          await tx.CommitAsync();
588          await conn.CloseAsync();
589          Assert.DoesNotThrow(() =&gt;
590          {
591              _ = tx.Connection;
592          });
593      }
594      class NoTransactionDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
595      {
596          public async Task&lt;NpgsqlDatabaseInfo?&gt; Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
597          {
598              var db = new NoTransactionDatabaseInfo(conn);
599              await db.LoadPostgresInfo(conn, timeout, async);
600              return db;
601          }
602      }
603      class NoTransactionDatabaseInfo : PostgresDatabaseInfo
604      {
605          public override bool SupportsTransactions =&gt; false;
606          internal NoTransactionDatabaseInfo(NpgsqlConnector conn) : base(conn) {}
607      }
608      [Test]
609      public void Bug184_Rollback_fails_on_aborted_transaction()
610      {
611          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
612          csb.CommandTimeout = 100000;
613          using var connTimeoutChanged = new NpgsqlConnection(csb.ToString());
614          connTimeoutChanged.Open();
615          using var t = connTimeoutChanged.BeginTransaction();
616          try {
617              var command = new NpgsqlCommand(&quot;select count(*) from dta&quot;, connTimeoutChanged, t);
618              _ = command.ExecuteScalar();
619          } catch (Exception) {
620              t.Rollback();
621          }
622      }
623      public TransactionTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
624  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TransactionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading.Tasks;
4  using Npgsql.Internal;
5  using Npgsql.Tests.Support;
6  using Npgsql.Util;
7  using NUnit.Framework;
8  using static Npgsql.Tests.TestUtil;
9  namespace Npgsql.Tests;
10  public class TransactionTests : MultiplexingTestBase
11  {
12      [Test, Description(&quot;Basic insert within a commited transaction&quot;)]
13      public async Task Commit([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
14      {
15          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
16              return;
17          await using var conn = await OpenConnectionAsync();
18          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
19          var tx = await conn.BeginTransactionAsync();
20          await using (tx)
21          {
22              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
23              if (prepare == PrepareOrNot.Prepared)
24                  cmd.Prepare();
25              cmd.ExecuteNonQuery();
26              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
27              tx.Commit();
28              Assert.That(tx.IsCompleted);
29              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
30              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
31          }
32          if (!IsMultiplexing)
33              Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
34      }
35      [Test, Description(&quot;Basic insert within a commited transaction&quot;)]
36      public async Task CommitAsync([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
37      {
38          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
39              return;
40          await using var conn = await OpenConnectionAsync();
41          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
42          var tx = await conn.BeginTransactionAsync();
43          await using (tx)
44          {
45              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
46              if (prepare == PrepareOrNot.Prepared)
47                  cmd.Prepare();
48              await cmd.ExecuteNonQueryAsync();
49              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
50              await tx.CommitAsync();
51              Assert.That(tx.IsCompleted);
52              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
53              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
54          }
55          Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
56      }
57      [Test, Description(&quot;Basic insert within a rolled back transaction&quot;)]
58      public async Task Rollback([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
59      {
60          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
61              return;
62          await using var conn = await OpenConnectionAsync();
63          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
64          var tx = await conn.BeginTransactionAsync();
65          await using (tx)
66          {
67              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
68              if (prepare == PrepareOrNot.Prepared)
69                  cmd.Prepare();
70              cmd.ExecuteNonQuery();
71              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
72              tx.Rollback();
73              Assert.That(tx.IsCompleted);
74              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
75              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
76          }
77          Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
78      }
79      [Test, Description(&quot;Basic insert within a rolled back transaction&quot;)]
80      public async Task RollbackAsync([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
81      {
82          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
83              return;
84          await using var conn = await OpenConnectionAsync();
85          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
86          var tx = await conn.BeginTransactionAsync();
87          await using (tx)
88          {
89              var cmd = new NpgsqlCommand($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, conn, tx);
90              if (prepare == PrepareOrNot.Prepared)
91                  cmd.Prepare();
92              await cmd.ExecuteNonQueryAsync();
93              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
94              await tx.RollbackAsync();
95              Assert.That(tx.IsCompleted);
96              Assert.That(() =&gt; tx.Connection, Throws.Nothing);
97              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
98          }
99          Assert.That(() =&gt; tx.Connection, Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
100      }
101      [Test, Description(&quot;Dispose a transaction in progress, should roll back&quot;)]
102      public async Task Rollback_on_Dispose()
103      {
104          await using var conn = await OpenConnectionAsync();
105          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
106          await using (var tx = await conn.BeginTransactionAsync())
107          {
108              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
109          }
110          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
111      }
112      [Test]
113      public async Task Rollback_on_Close()
114      {
115          await using var conn1 = await OpenConnectionAsync();
116          var table = await CreateTempTable(conn1, &quot;name TEXT&quot;);
117          using (var conn2 = await OpenConnectionAsync())
118          {
119              var tx = await conn2.BeginTransactionAsync();
120              await conn2.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx);
121          }
122          Assert.That(await conn1.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
123      }
124      [Test, Description(&quot;Intentionally generates an error, putting us in a failed transaction block. Rolls back.&quot;)]
125      public async Task Rollback_failed()
126      {
127          await using var conn = await OpenConnectionAsync();
128          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
129          await using var tx = await conn.BeginTransactionAsync();
130          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
131          Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;BAD QUERY&quot;), Throws.Exception.TypeOf&lt;PostgresException&gt;());
132          tx.Rollback();
133          Assert.That(tx.IsCompleted);
134          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
135      }
136      [Test, Description(&quot;Commits an empty transaction&quot;)]
137      public async Task Empty_commit()
138      {
139          await using var conn = await OpenConnectionAsync();
140          await conn.BeginTransaction().CommitAsync();
141      }
142      [Test, Description(&quot;Rolls back an empty transaction&quot;)]
143      public async Task Empty_rollback()
144      {
145          await using var conn = await OpenConnectionAsync();
146          await conn.BeginTransaction().RollbackAsync();
147      }
148      [Test, Description(&quot;Disposes an empty transaction&quot;)]
149      public async Task Empty_Dispose()
150      {
151          await using var dataSource = CreateDataSource();
152          using (var conn = await dataSource.OpenConnectionAsync())
153          using (conn.BeginTransaction())
154          { }
155          using (var conn = await dataSource.OpenConnectionAsync())
156          {
157              Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;SAVEPOINT foo&quot;),
158                  Throws.Exception.TypeOf&lt;PostgresException&gt;()
159                      .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.NoActiveSqlTransaction));
160          }
161      }
162      [Test, Description(&quot;Tests that the isolation levels are properly supported&quot;)]
163      [TestCase(IsolationLevel.ReadCommitted,   &quot;read committed&quot;)]
164      [TestCase(IsolationLevel.ReadUncommitted, &quot;read uncommitted&quot;)]
165      [TestCase(IsolationLevel.RepeatableRead,  &quot;repeatable read&quot;)]
166      [TestCase(IsolationLevel.Serializable,    &quot;serializable&quot;)]
167      [TestCase(IsolationLevel.Snapshot,        &quot;repeatable read&quot;)]
168      [TestCase(IsolationLevel.Unspecified,     &quot;read committed&quot;)]
169      public async Task Isolation_levels(IsolationLevel level, string expectedName)
170      {
171          await using var conn = await OpenConnectionAsync();
172          var tx = conn.BeginTransaction(level);
173          Assert.That(conn.ExecuteScalar(&quot;SHOW TRANSACTION ISOLATION LEVEL&quot;), Is.EqualTo(expectedName));
174          await tx.CommitAsync();
175      }
176      [Test]
177      public async Task IsolationLevel_Chaos_is_unsupported()
178      {
179          await using var conn = await OpenConnectionAsync();
180          Assert.That(() =&gt; conn.BeginTransaction(IsolationLevel.Chaos), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
181      }
182      [Test, Description(&quot;Rollback of an already rolled back transaction&quot;)]
183      public async Task Rollback_twice()
184      {
185          await using var conn = await OpenConnectionAsync();
186          var transaction = conn.BeginTransaction();
187          transaction.Rollback();
188          Assert.That(() =&gt; transaction.Rollback(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
189      }
190      [Test, Description(&quot;Makes sure the creating a transaction via DbConnection sets the proper isolation level&quot;)]
191      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/559&quot;)]
192      public async Task Default_IsolationLevel()
193      {
194          await using var conn = await OpenConnectionAsync();
195          var tx = conn.BeginTransaction();
196          Assert.That(tx.IsolationLevel, Is.EqualTo(IsolationLevel.ReadCommitted));
197          tx.Rollback();
198          tx = conn.BeginTransaction(IsolationLevel.Unspecified);
199          Assert.That(tx.IsolationLevel, Is.EqualTo(IsolationLevel.ReadCommitted));
200          tx.Rollback();
201      }
202      [Test, Description(&quot;Makes sure that transactions started in SQL work, except in multiplexing&quot;)]
203      public async Task Via_sql()
204      {
205          if (IsMultiplexing)
206              Assert.Ignore(&quot;Multiplexing: not implemented&quot;);
207          await using var conn = await OpenConnectionAsync();
208          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
209          if (IsMultiplexing)
210          {
211              Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;BEGIN&quot;), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
212              return;
213          }
214          await conn.ExecuteNonQueryAsync(&quot;BEGIN&quot;);
215          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;);
216          await conn.ExecuteNonQueryAsync(&quot;ROLLBACK&quot;);
217          Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
218      }
219      [Test]
220      public async Task Nested()
221      {
222          await using var conn = await OpenConnectionAsync();
223          conn.BeginTransaction();
224          Assert.That(() =&gt; conn.BeginTransaction(), Throws.TypeOf&lt;InvalidOperationException&gt;());
225      }
226      [Test]
227      public void Begin_transaction_on_closed_connection_throws()
228      {
229          using var conn = new NpgsqlConnection();
230          Assert.That(() =&gt; conn.BeginTransaction(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
231      }
232      [Test]
233      public async Task Rollback_failed_transaction_with_timeout()
234      {
235          await using var conn = await OpenConnectionAsync();
236          var tx = conn.BeginTransaction();
237          using var cmd = new NpgsqlCommand(&quot;BAD QUERY&quot;, conn, tx);
238          Assert.That(cmd.CommandTimeout != 1);
239          cmd.CommandTimeout = 1;
240          try
241          {
242              cmd.ExecuteScalar();
243              Assert.Fail();
244          }
245          catch (PostgresException)
246          {
247              await tx.RollbackAsync();
248              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
249          }
250      }
251      [Test, Description(&quot;If a custom command timeout is set, a failed transaction could not be rollbacked to a previous savepoint&quot;)]
252      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/363&quot;)]
253      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/184&quot;)]
254      public async Task Failed_transaction_cannot_rollback_to_savepoint_with_custom_timeout()
255      {
256          await using var conn = await OpenConnectionAsync();
257          var transaction = conn.BeginTransaction();
258          transaction.Save(&quot;TestSavePoint&quot;);
259          using var cmd = new NpgsqlCommand(&quot;SELECT unknown_thing&quot;, conn);
260          cmd.CommandTimeout = 1;
261          try
262          {
263              cmd.ExecuteScalar();
264          }
265          catch (PostgresException)
266          {
267              transaction.Rollback(&quot;TestSavePoint&quot;);
268              Assert.That(conn.ExecuteScalar(&quot;SELECT 1&quot;), Is.EqualTo(1));
269          }
270      }
271      [Test, Description(&quot;Closes a (pooled) connection with a failed transaction and a custom timeout&quot;)]
272      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/719&quot;)]
273      public async Task Failed_transaction_on_close_with_custom_timeout()
274      {
275          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = true);
276          await using var conn = await dataSource.OpenConnectionAsync();
277          conn.BeginTransaction();
278          var backendProcessId = conn.ProcessID;
279          using (var badCmd = new NpgsqlCommand(&quot;SEL&quot;, conn))
280          {
281              badCmd.CommandTimeout = NpgsqlCommand.DefaultTimeout + 1;
282              Assert.That(() =&gt; badCmd.ExecuteNonQuery(), Throws.Exception.TypeOf&lt;PostgresException&gt;());
283          }
284          conn.Close();
285          conn.Open();
286          conn.BeginTransaction();
287          Assert.That(conn.ProcessID, Is.EqualTo(backendProcessId));
288          Assert.That(conn.ExecuteScalar(&quot;SELECT 1&quot;), Is.EqualTo(1));
289      }
290      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/555&quot;)]
291      public async Task Transaction_on_recycled_connection()
292      {
293          if (IsMultiplexing)
294              Assert.Ignore(&quot;Multiplexing: fails&quot;);
295          await using var conn = new NpgsqlConnection(ConnectionString + $&quot;;Application Name={GetUniqueIdentifier(nameof(Transaction_on_recycled_connection))}&quot;);
296          conn.Open();
297          var prevConnectorId = conn.Connector!.Id;
298          conn.Close();
299          conn.Open();
300          Assert.That(conn.Connector.Id, Is.EqualTo(prevConnectorId), &quot;Connection pool returned a different connector, can&#x27;t test&quot;);
301          var tx = conn.BeginTransaction();
302          conn.ExecuteScalar(&quot;SELECT 1&quot;);
303          await tx.CommitAsync();
304          NpgsqlConnection.ClearPool(conn);
305      }
306      [Test]
307      public async Task Savepoint()
308      {
309          await using var conn = await OpenConnectionAsync();
310          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
311          const string name = &quot;theSavePoint&quot;;
312          using (var tx = conn.BeginTransaction())
313          {
314              tx.Save(name);
315              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
316              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
317              tx.Rollback(name);
318              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(0));
319              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
320              tx.Release(name);
321              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
322              await tx.CommitAsync();
323          }
324          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
325      }
326      [Test]
327      public async Task Savepoint_async()
328      {
329          await using var conn = await OpenConnectionAsync();
330          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
331          const string name = &quot;theSavePoint&quot;;
332          using (var tx = conn.BeginTransaction())
333          {
334              await tx.SaveAsync(name);
335              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
336              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
337              await tx.RollbackAsync(name);
338              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(0));
339              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;savepointtest&#x27;)&quot;, tx: tx);
340              await tx.ReleaseAsync(name);
341              Assert.That(conn.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;, tx: tx), Is.EqualTo(1));
342              await tx.CommitAsync();
343          }
344          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
345      }
346      [Test]
347      public async Task Savepoint_quoted()
348      {
349          await using var conn = await OpenConnectionAsync();
350          await using var tx = conn.BeginTransaction();
351          tx.Save(&quot;a;b&quot;);
352          tx.Rollback(&quot;a;b&quot;);
353      }
354      [Test(Description = &quot;Makes sure that creating a savepoint doesn&#x27;t perform an additional roundtrip, but prepends to the next command&quot;)]
355      public async Task Savepoint_prepends()
356      {
357          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
358          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
359          await using var conn = await dataSource.OpenConnectionAsync();
360          var pgMock = await postmasterMock.WaitForServerConnection();
361          using var tx = conn.BeginTransaction();
362          var saveTask = tx.SaveAsync(&quot;foo&quot;);
363          Assert.That(saveTask.Status, Is.EqualTo(TaskStatus.RanToCompletion));
364          await pgMock
365              .WriteCommandComplete()
366              .WriteReadyForQuery() 
367              .WriteCommandComplete()
368              .WriteReadyForQuery() 
369              .WriteScalarResponseAndFlush(1);
370          await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;);
371          await pgMock.ExpectSimpleQuery(&quot;BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED&quot;);
372          await pgMock.ExpectSimpleQuery(&quot;SAVEPOINT foo&quot;);
373          await pgMock.ExpectExtendedQuery();
374      }
375      [Test, Description(&quot;Check IsCompleted before, during and after a normal committed transaction&quot;)]
376      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/985&quot;)]
377      public async Task IsCompleted_commit()
378      {
379          await using var conn = await OpenConnectionAsync();
380          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
381          var tx = conn.BeginTransaction();
382          Assert.That(!tx.IsCompleted);
383          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
384          Assert.That(!tx.IsCompleted);
385          await tx.CommitAsync();
386          Assert.That(tx.IsCompleted);
387      }
388      [Test, Description(&quot;Check IsCompleted before, during, and after a successful but rolled back transaction&quot;)]
389      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/985&quot;)]
390      public async Task IsCompleted_rollback()
391      {
392          await using var conn = await OpenConnectionAsync();
393          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
394          var tx = conn.BeginTransaction();
395          Assert.That(!tx.IsCompleted);
396          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
397          Assert.That(!tx.IsCompleted);
398          tx.Rollback();
399          Assert.That(tx.IsCompleted);
400      }
401      [Test, Description(&quot;Check IsCompleted before, during, and after a failed then rolled back transaction&quot;)]
402      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/985&quot;)]
403      public async Task IsCompleted_rollback_failed()
404      {
405          await using var conn = await OpenConnectionAsync();
406          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
407          var tx = conn.BeginTransaction();
408          Assert.That(!tx.IsCompleted);
409          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;, tx: tx);
410          Assert.That(!tx.IsCompleted);
411          Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;BAD QUERY&quot;), Throws.Exception.TypeOf&lt;PostgresException&gt;());
412          Assert.That(!tx.IsCompleted);
413          tx.Rollback();
414          Assert.That(tx.IsCompleted);
415          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(0));
416      }
417      [Test, Description(&quot;Tests that a if a DatabaseInfoFactory is registered for a database that doesn&#x27;t support transactions, no transactions are created&quot;)]
418      [Parallelizable(ParallelScope.None)]
419      public async Task Transaction_not_supported()
420      {
421          if (IsMultiplexing)
422              Assert.Ignore(&quot;Need to rethink/redo dummy transaction mode&quot;);
423          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
424          {
425              ApplicationName = nameof(Transaction_not_supported) + IsMultiplexing
426          }.ToString();
427          NpgsqlDatabaseInfo.RegisterFactory(new NoTransactionDatabaseInfoFactory());
428          try
429          {
430              using var conn = new NpgsqlConnection(connString);
431              await conn.OpenAsync();
432              using var tx = conn.BeginTransaction();
433              var prevTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
434              var nextTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
435              Assert.That(nextTxId, Is.Not.EqualTo(prevTxId));
436              conn.Close();
437          }
438          finally
439          {
440              NpgsqlDatabaseInfo.ResetFactories();
441          }
442          using (var conn = new NpgsqlConnection(connString))
443          {
444              await conn.OpenAsync();
445              NpgsqlConnection.ClearPool(conn);
446              conn.ReloadTypes();
447          }
448          using (var conn = new NpgsqlConnection(connString))
449          {
450              await conn.OpenAsync();
451              using (var tx = conn.BeginTransaction())
452              {
453                  var prevTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
454                  var nextTxId = conn.ExecuteScalar(&quot;SELECT txid_current()&quot;);
455                  Assert.That(nextTxId, Is.EqualTo(prevTxId));
456              }
457          }
458      }
459      [Test]
460      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3248&quot;)]
461      public async Task Bug3248_Dispose_transaction_Rollback()
462      {
463          if (!IsMultiplexing)
464              return;
465          using var conn = await OpenConnectionAsync();
466          await using (var tx = await conn.BeginTransactionAsync())
467          {
468              Assert.That(conn.Connector, Is.Not.Null);
469              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT * FROM \&quot;unknown_table\&quot;&quot;, tx: tx),
470                  Throws.Exception.TypeOf&lt;PostgresException&gt;());
471              Assert.That(conn.Connector, Is.Not.Null);
472          }
473          Assert.That(conn.Connector, Is.Null);
474      }
475      [Test]
476      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3248&quot;)]
477      public async Task Bug3248_Dispose_connection_Rollback()
478      {
479          if (!IsMultiplexing)
480              return;
481          var conn = await OpenConnectionAsync();
482          var tx = conn.BeginTransaction();
483          Assert.That(conn.Connector, Is.Not.Null);
484          Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT * FROM \&quot;unknown_table\&quot;&quot;, tx: tx),
485              Throws.Exception.TypeOf&lt;PostgresException&gt;());
486          Assert.That(conn.Connector, Is.Not.Null);
487          await conn.DisposeAsync();
488          Assert.That(conn.Connector, Is.Null);
489      }
490      [Test]
491      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3306&quot;)]
492      [TestCase(true)]
493      [TestCase(false)]
494      public async Task Bug3306(bool inTransactionBlock)
495      {
496          var conn = await OpenConnectionAsync();
497          var tx = await conn.BeginTransactionAsync();
498          await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;, tx);
499          if (!inTransactionBlock)
500              await tx.RollbackAsync();
501          await conn.CloseAsync();
502          conn = await OpenConnectionAsync();
503          var tx2 = await conn.BeginTransactionAsync();
504          await tx.DisposeAsync();
505          Assert.That(tx.IsDisposed, Is.True);
506          Assert.That(tx2.IsDisposed, Is.False);
507          await conn.DisposeAsync();
508      }
509      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/efcore.pg/issues/1593&quot;)]
510      public async Task Access_connection_on_completed_transaction()
511      {
512          using var conn = await OpenConnectionAsync();
513          using var tx = await conn.BeginTransactionAsync();
514          tx.Commit();
515          Assert.That(tx.Connection, Is.SameAs(conn));
516      }
517      [Test]
518      public async Task Unbound_transaction_reuse()
519      {
520          await using var dataSource = CreateDataSource(csb =&gt;
521          {
522              csb.MinPoolSize = 1;
523              csb.MaxPoolSize = 1;
524          });
525          await using var conn = await OpenConnectionAsync();
526          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
527          await using var conn1 = await dataSource.OpenConnectionAsync();
528          var tx1 = conn1.BeginTransaction();
529          await using (var ___ = tx1)
530          {
531              using var cmd1 = conn1.CreateCommand();
532              cmd1.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;); SELECT 1&quot;;
533              await using (var reader1 = await cmd1.ExecuteReaderAsync())
534              {
535                  Assert.That(async () =&gt; await reader1.ReadAsync(), Is.EqualTo(true));
536                  Assert.That(() =&gt; reader1.GetInt32(0), Is.EqualTo(1));
537                  Assert.That(reader1.RecordsAffected, Is.EqualTo(1));
538              }
539              await tx1.CommitAsync();
<span onclick='openModal()' class='match'>540              Assert.That(await conn1.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
541              await conn1.CloseAsync();
</span>542          }
543          await using var conn2 = await dataSource.OpenConnectionAsync();
544          var tx2 = conn2.BeginTransaction();
545          await using (var ___ = tx2)
546          {
547              Assert.That(tx2, Is.Not.SameAs(tx1));
548              using var cmd2 = conn2.CreateCommand();
549              cmd2.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;Y&#x27;); SELECT 2&quot;;
550              await using (var reader2 = await cmd2.ExecuteReaderAsync())
551              {
552                  Assert.That(async () =&gt; await reader2.ReadAsync(), Is.EqualTo(true));
553                  Assert.That(() =&gt; reader2.GetInt32(0), Is.EqualTo(2));
554                  Assert.That(reader2.RecordsAffected, Is.EqualTo(1));
555              }
556              await tx2.CommitAsync();
557              Assert.That(await conn2.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(2));
558              await conn2.CloseAsync();
559          }
560          await using var conn3 = await dataSource.OpenConnectionAsync();
561          var tx3 = conn3.BeginTransaction();
562          await using (var ___ = tx3)
563          {
564              Assert.That(tx3, Is.SameAs(tx1));
565              using var cmd3 = conn3.CreateCommand();
566              cmd3.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;Z&#x27;); SELECT 3&quot;;
567              await using (var reader3 = await cmd3.ExecuteReaderAsync())
568              {
569                  Assert.That(async () =&gt; await reader3.ReadAsync(), Is.EqualTo(true));
570                  Assert.That(() =&gt; reader3.GetInt32(0), Is.EqualTo(3));
571                  Assert.That(reader3.RecordsAffected, Is.EqualTo(1));
572              }
573              await tx3.CommitAsync();
574              Assert.That(await conn3.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(3));
575              await conn3.CloseAsync();
576          }
577      }
578      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3686&quot;)]
579      public async Task Bug3686()
580      {
581          if (IsMultiplexing)
582              return;
583          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = false);
584          await using var conn = await dataSource.OpenConnectionAsync();
585          await using var tx = await conn.BeginTransactionAsync();
586          await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;, tx);
587          await tx.CommitAsync();
588          await conn.CloseAsync();
589          Assert.DoesNotThrow(() =&gt;
590          {
591              _ = tx.Connection;
592          });
593      }
594      class NoTransactionDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
595      {
596          public async Task&lt;NpgsqlDatabaseInfo?&gt; Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
597          {
598              var db = new NoTransactionDatabaseInfo(conn);
599              await db.LoadPostgresInfo(conn, timeout, async);
600              return db;
601          }
602      }
603      class NoTransactionDatabaseInfo : PostgresDatabaseInfo
604      {
605          public override bool SupportsTransactions =&gt; false;
606          internal NoTransactionDatabaseInfo(NpgsqlConnector conn) : base(conn) {}
607      }
608      [Test]
609      public void Bug184_Rollback_fails_on_aborted_transaction()
610      {
611          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
612          csb.CommandTimeout = 100000;
613          using var connTimeoutChanged = new NpgsqlConnection(csb.ToString());
614          connTimeoutChanged.Open();
615          using var t = connTimeoutChanged.BeginTransaction();
616          try {
617              var command = new NpgsqlCommand(&quot;select count(*) from dta&quot;, connTimeoutChanged, t);
618              _ = command.ExecuteScalar();
619          } catch (Exception) {
620              t.Rollback();
621          }
622      }
623      public TransactionTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
624  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TransactionTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TransactionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>324          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
325      }
</pre></code></div>
                <div class="column column_space"><pre><code>540              Assert.That(await conn1.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(1));
541              await conn1.CloseAsync();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    