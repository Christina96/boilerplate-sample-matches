
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-WhereClauseHandler.cs</h3>
            <pre><code>1  namespace Simple.Data.QueryPolyfills
2  {
3      using System;
4      using System.Collections;
5      using System.Collections.Generic;
6      using System.Linq;
7      using System.Text.RegularExpressions;
8      using Extensions;
9      internal class WhereClauseHandler
10      {
11          private readonly Dictionary<SimpleExpressionType, Func<SimpleExpression, Func<IDictionary<string, object>, bool>>> _expressionFormatters;
12          private readonly string _mainTableName;
<span onclick='openModal()' class='match'>13          private readonly WhereClause _whereClause;
14          public WhereClauseHandler(string mainTableName, WhereClause whereClause)
15          {
16              _mainTableName = mainTableName;
</span>17              _whereClause = whereClause;
18              _expressionFormatters = new Dictionary<SimpleExpressionType, Func<SimpleExpression, Func<IDictionary<string, object>, bool>>>
19                                          {
20                                              {SimpleExpressionType.And, LogicalExpressionToWhereClause},
21                                              {SimpleExpressionType.Or, LogicalExpressionToWhereClause},
22                                              {SimpleExpressionType.Equal, EqualExpressionToWhereClause},
23                                              {SimpleExpressionType.NotEqual, NotEqualExpressionToWhereClause},
24                                              {SimpleExpressionType.Function, FunctionExpressionToWhereClause},
25                                              {SimpleExpressionType.GreaterThan, GreaterThanToWhereClause},
26                                              {SimpleExpressionType.LessThan, LessThanToWhereClause},
27                                              {SimpleExpressionType.GreaterThanOrEqual, GreaterThanOrEqualToWhereClause},
28                                              {SimpleExpressionType.LessThanOrEqual, LessThanOrEqualToWhereClause},
29                                              {SimpleExpressionType.Empty, expr => _ => true },
30                                          };
31          }
32          private Func<IDictionary<string, object>, bool> FunctionExpressionToWhereClause(SimpleExpression arg)
33          {
34              var function = arg.RightOperand as SimpleFunction;
35              if (ReferenceEquals(function, null)) throw new InvalidOperationException("Expression type of function but no function supplied.");
36              if (function.Name.Equals("like", StringComparison.OrdinalIgnoreCase) ||
37                  function.Name.Equals("notlike", StringComparison.OrdinalIgnoreCase))
38              {
39                  var pattern = function.Args[0].ToString();
40                  if (pattern.Contains("%") || pattern.Contains("_")) 
41                  {
42                      pattern = pattern.Replace("%", ".*").Replace('_', '.');
43                  }
44                  var regex = new Regex("^" + pattern + "$", RegexOptions.Multiline | RegexOptions.IgnoreCase);
45                  if (function.Name.Equals("like", StringComparison.OrdinalIgnoreCase))
46                  {
47                      return d => Resolve(d, arg.LeftOperand).Count > 0 && Resolve(d, arg.LeftOperand).OfType<string>().Any(regex.IsMatch);
48                  }
49                  if (function.Name.Equals("notlike", StringComparison.OrdinalIgnoreCase))
50                  {
51                      return d => Resolve(d, arg.LeftOperand).Count > 0 && Resolve(d, arg.LeftOperand).OfType<string>().All(input => !regex.IsMatch(input));
52                  }
53              }
54              throw new NotSupportedException("Expression Function not supported.");
55          }
56          private Func<IDictionary<string, object>, bool> GreaterThanToWhereClause(SimpleExpression arg)
57          {
58              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) > 0);
59          }
60          private Func<IDictionary<string, object>, bool> LessThanToWhereClause(SimpleExpression arg)
61          {
62              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) < 0);
63          }
64          private Func<IDictionary<string, object>, bool> GreaterThanOrEqualToWhereClause(SimpleExpression arg)
65          {
66              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) >= 0);
67          }
68          private Func<IDictionary<string, object>, bool> LessThanOrEqualToWhereClause(SimpleExpression arg)
69          {
70              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) <= 0);
71          }
72          private Func<IDictionary<string, object>, bool> NotEqualExpressionToWhereClause(SimpleExpression arg)
73          {
74              var equal = EqualExpressionToWhereClause(arg);
75              return d => !equal(d);
76          }
77          private Func<IDictionary<string, object>, bool> EqualExpressionToWhereClause(SimpleExpression arg)
78          {
79              if (ReferenceEquals(arg.RightOperand, null))
80              {
81                  return d => Resolve(d, arg.LeftOperand).Count == 0 || Resolve(d, arg.LeftOperand).Any(o => ReferenceEquals(o, null));
82              }
83              if (arg.RightOperand.GetType().IsArray)
84              {
85                  return
86                      d =>
87                          {
88                              var resolvedLeftOperand = Resolve(d, arg.LeftOperand);
89                              if (resolvedLeftOperand.Any(o => !(o is string) && o is IEnumerable))
90                              {
91                                  return resolvedLeftOperand.OfType<IEnumerable>().Any(
92                                      o => o.Cast<object>().SequenceEqual(((IEnumerable)arg.RightOperand).Cast<object>()));
93                              }
94                              return resolvedLeftOperand.Any(
95                                  o => ((IEnumerable)arg.RightOperand).Cast<object>().Contains(o));
96                          };
97              }
98              return d => Resolve(d, arg.LeftOperand).Contains(arg.RightOperand);
99          }
100          private Func<IDictionary<string, object>, bool> Format(SimpleExpression expression)
101          {
102              Func<SimpleExpression, Func<IDictionary<string, object>, bool>> formatter;
103              if (_expressionFormatters.TryGetValue(expression.Type, out formatter))
104              {
105                  return formatter(expression);
106              }
107              return _ => true;
108          }
109          private Func<IDictionary<string, object>, bool> LogicalExpressionToWhereClause(SimpleExpression arg)
110          {
111              var left = Format((SimpleExpression)arg.LeftOperand);
112              var right = Format((SimpleExpression)arg.RightOperand);
113              if (arg.Type == SimpleExpressionType.Or)
114              {
115                  return d => (left(d) || right(d));
116              }
117              return d => (left(d) && right(d));
118          }
119          private IList<object> Resolve(IDictionary<string, object> dict, object operand, string key = null)
120          {
121              var objectReference = operand as ObjectReference;
122              if (objectReference.IsNull()) return new object[0];
123              key = key ?? objectReference.GetAliasOrName();
124              var keys = objectReference.GetAllObjectNames();
125              if (keys.Length > 2)
126              {
127                  if (_mainTableName.Contains("."))
128                  {
129                      keys = keys.Skip(1).ToArray();
130                      keys[0] = _mainTableName;
131                  }
132              }
133              if (keys.Length > 2)
134              {
135                  return ResolveSubs(dict, objectReference.GetOwner(), key).ToList();
136              }
137              if (keys.Length == 2 && !HomogenizedEqualityComparer.DefaultInstance.Equals(keys[0].Singularize(), _mainTableName.Singularize()))
138              {
139                  var joinedDict = dict[keys[0]] as IDictionary<string, object>;
140                  if (joinedDict != null && joinedDict.ContainsKey(keys[1]))
141                  {
142                      return new[] { joinedDict[keys[1]] };
143                  }
144                  var joinedDicts = dict[keys[0]] as IEnumerable<IDictionary<string, object>>;
145                  if (joinedDicts != null)
146                  {
147                      return joinedDicts.Select(d => d.ContainsKey(keys[1]) ? d[keys[1]] : null).ToArray();
148                  }
149              }
150              if (dict.ContainsKey(key))
151                  return new[] { dict[key] };
152              return new object[0];
153          }
154          private IEnumerable<object> ResolveSubs(IDictionary<string, object> dict, ObjectReference objectReference, string key)
155          {
156              if (objectReference.IsNull()) return Enumerable.Empty<object>();
157              if (dict.ContainsKey(objectReference.GetName()))
158              {
159                  var master = dict[objectReference.GetName()] as IDictionary<string, object>;
160                  if (master != null)
161                  {
162                      if (master.ContainsKey(key))
163                      {
164                          return new[] { master[key] };
165                      }
166                  }
167                  var detail = dict[objectReference.GetName()] as IEnumerable<IDictionary<string, object>>;
168                  if (detail != null)
169                  {
170                      return detail.SelectMany(d => Resolve(d, objectReference, key));
171                  }
172              }
173              return ResolveSubs(dict, objectReference.GetOwner(), key);
174          }
175          public IEnumerable<IDictionary<string, object>> Run(IEnumerable<IDictionary<string, object>> source)
176          {
177              var predicate = Format(_whereClause.Criteria);
178              return source.Where(predicate);
179          }
180      }
181  }
</code></pre>
        </div>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-WhereClauseHandler.cs</h3>
            <pre><code>1  namespace Simple.Data.QueryPolyfills
2  {
3      using System;
4      using System.Collections;
5      using System.Collections.Generic;
6      using System.Linq;
7      using System.Text.RegularExpressions;
8      using Extensions;
9      internal class WhereClauseHandler
10      {
11          private readonly Dictionary<SimpleExpressionType, Func<SimpleExpression, Func<IDictionary<string, object>, bool>>> _expressionFormatters;
12          private readonly string _mainTableName;
<span onclick='openModal()' class='match'>13          private readonly WhereClause _whereClause;
14          public WhereClauseHandler(string mainTableName, WhereClause whereClause)
15          {
16              _mainTableName = mainTableName;
</span>17              _whereClause = whereClause;
18              _expressionFormatters = new Dictionary<SimpleExpressionType, Func<SimpleExpression, Func<IDictionary<string, object>, bool>>>
19                                          {
20                                              {SimpleExpressionType.And, LogicalExpressionToWhereClause},
21                                              {SimpleExpressionType.Or, LogicalExpressionToWhereClause},
22                                              {SimpleExpressionType.Equal, EqualExpressionToWhereClause},
23                                              {SimpleExpressionType.NotEqual, NotEqualExpressionToWhereClause},
24                                              {SimpleExpressionType.Function, FunctionExpressionToWhereClause},
25                                              {SimpleExpressionType.GreaterThan, GreaterThanToWhereClause},
26                                              {SimpleExpressionType.LessThan, LessThanToWhereClause},
27                                              {SimpleExpressionType.GreaterThanOrEqual, GreaterThanOrEqualToWhereClause},
28                                              {SimpleExpressionType.LessThanOrEqual, LessThanOrEqualToWhereClause},
29                                              {SimpleExpressionType.Empty, expr => _ => true },
30                                          };
31          }
32          private Func<IDictionary<string, object>, bool> FunctionExpressionToWhereClause(SimpleExpression arg)
33          {
34              var function = arg.RightOperand as SimpleFunction;
35              if (ReferenceEquals(function, null)) throw new InvalidOperationException("Expression type of function but no function supplied.");
36              if (function.Name.Equals("like", StringComparison.OrdinalIgnoreCase) ||
37                  function.Name.Equals("notlike", StringComparison.OrdinalIgnoreCase))
38              {
39                  var pattern = function.Args[0].ToString();
40                  if (pattern.Contains("%") || pattern.Contains("_")) 
41                  {
42                      pattern = pattern.Replace("%", ".*").Replace('_', '.');
43                  }
44                  var regex = new Regex("^" + pattern + "$", RegexOptions.Multiline | RegexOptions.IgnoreCase);
45                  if (function.Name.Equals("like", StringComparison.OrdinalIgnoreCase))
46                  {
47                      return d => Resolve(d, arg.LeftOperand).Count > 0 && Resolve(d, arg.LeftOperand).OfType<string>().Any(regex.IsMatch);
48                  }
49                  if (function.Name.Equals("notlike", StringComparison.OrdinalIgnoreCase))
50                  {
51                      return d => Resolve(d, arg.LeftOperand).Count > 0 && Resolve(d, arg.LeftOperand).OfType<string>().All(input => !regex.IsMatch(input));
52                  }
53              }
54              throw new NotSupportedException("Expression Function not supported.");
55          }
56          private Func<IDictionary<string, object>, bool> GreaterThanToWhereClause(SimpleExpression arg)
57          {
58              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) > 0);
59          }
60          private Func<IDictionary<string, object>, bool> LessThanToWhereClause(SimpleExpression arg)
61          {
62              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) < 0);
63          }
64          private Func<IDictionary<string, object>, bool> GreaterThanOrEqualToWhereClause(SimpleExpression arg)
65          {
66              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) >= 0);
67          }
68          private Func<IDictionary<string, object>, bool> LessThanOrEqualToWhereClause(SimpleExpression arg)
69          {
70              return d => Resolve(d, arg.LeftOperand).OfType<IComparable>().Any(o => o.CompareTo(arg.RightOperand) <= 0);
71          }
72          private Func<IDictionary<string, object>, bool> NotEqualExpressionToWhereClause(SimpleExpression arg)
73          {
74              var equal = EqualExpressionToWhereClause(arg);
75              return d => !equal(d);
76          }
77          private Func<IDictionary<string, object>, bool> EqualExpressionToWhereClause(SimpleExpression arg)
78          {
79              if (ReferenceEquals(arg.RightOperand, null))
80              {
81                  return d => Resolve(d, arg.LeftOperand).Count == 0 || Resolve(d, arg.LeftOperand).Any(o => ReferenceEquals(o, null));
82              }
83              if (arg.RightOperand.GetType().IsArray)
84              {
85                  return
86                      d =>
87                          {
88                              var resolvedLeftOperand = Resolve(d, arg.LeftOperand);
89                              if (resolvedLeftOperand.Any(o => !(o is string) && o is IEnumerable))
90                              {
91                                  return resolvedLeftOperand.OfType<IEnumerable>().Any(
92                                      o => o.Cast<object>().SequenceEqual(((IEnumerable)arg.RightOperand).Cast<object>()));
93                              }
94                              return resolvedLeftOperand.Any(
95                                  o => ((IEnumerable)arg.RightOperand).Cast<object>().Contains(o));
96                          };
97              }
98              return d => Resolve(d, arg.LeftOperand).Contains(arg.RightOperand);
99          }
100          private Func<IDictionary<string, object>, bool> Format(SimpleExpression expression)
101          {
102              Func<SimpleExpression, Func<IDictionary<string, object>, bool>> formatter;
103              if (_expressionFormatters.TryGetValue(expression.Type, out formatter))
104              {
105                  return formatter(expression);
106              }
107              return _ => true;
108          }
109          private Func<IDictionary<string, object>, bool> LogicalExpressionToWhereClause(SimpleExpression arg)
110          {
111              var left = Format((SimpleExpression)arg.LeftOperand);
112              var right = Format((SimpleExpression)arg.RightOperand);
113              if (arg.Type == SimpleExpressionType.Or)
114              {
115                  return d => (left(d) || right(d));
116              }
117              return d => (left(d) && right(d));
118          }
119          private IList<object> Resolve(IDictionary<string, object> dict, object operand, string key = null)
120          {
121              var objectReference = operand as ObjectReference;
122              if (objectReference.IsNull()) return new object[0];
123              key = key ?? objectReference.GetAliasOrName();
124              var keys = objectReference.GetAllObjectNames();
125              if (keys.Length > 2)
126              {
127                  if (_mainTableName.Contains("."))
128                  {
129                      keys = keys.Skip(1).ToArray();
130                      keys[0] = _mainTableName;
131                  }
132              }
133              if (keys.Length > 2)
134              {
135                  return ResolveSubs(dict, objectReference.GetOwner(), key).ToList();
136              }
137              if (keys.Length == 2 && !HomogenizedEqualityComparer.DefaultInstance.Equals(keys[0].Singularize(), _mainTableName.Singularize()))
138              {
139                  var joinedDict = dict[keys[0]] as IDictionary<string, object>;
140                  if (joinedDict != null && joinedDict.ContainsKey(keys[1]))
141                  {
142                      return new[] { joinedDict[keys[1]] };
143                  }
144                  var joinedDicts = dict[keys[0]] as IEnumerable<IDictionary<string, object>>;
145                  if (joinedDicts != null)
146                  {
147                      return joinedDicts.Select(d => d.ContainsKey(keys[1]) ? d[keys[1]] : null).ToArray();
148                  }
149              }
150              if (dict.ContainsKey(key))
151                  return new[] { dict[key] };
152              return new object[0];
153          }
154          private IEnumerable<object> ResolveSubs(IDictionary<string, object> dict, ObjectReference objectReference, string key)
155          {
156              if (objectReference.IsNull()) return Enumerable.Empty<object>();
157              if (dict.ContainsKey(objectReference.GetName()))
158              {
159                  var master = dict[objectReference.GetName()] as IDictionary<string, object>;
160                  if (master != null)
161                  {
162                      if (master.ContainsKey(key))
163                      {
164                          return new[] { master[key] };
165                      }
166                  }
167                  var detail = dict[objectReference.GetName()] as IEnumerable<IDictionary<string, object>>;
168                  if (detail != null)
169                  {
170                      return detail.SelectMany(d => Resolve(d, objectReference, key));
171                  }
172              }
173              return ResolveSubs(dict, objectReference.GetOwner(), key);
174          }
175          public IEnumerable<IDictionary<string, object>> Run(IEnumerable<IDictionary<string, object>> source)
176          {
177              var predicate = Format(_whereClause.Criteria);
178              return source.Where(predicate);
179          }
180      }
181  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-WhereClauseHandler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-WhereClauseHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>13          private readonly WhereClause _whereClause;
14          public WhereClauseHandler(string mainTableName, WhereClause whereClause)
15          {
16              _mainTableName = mainTableName;
</pre></code></div>
                <div class="column column_space"><pre><code>13          private readonly WhereClause _whereClause;
14          public WhereClauseHandler(string mainTableName, WhereClause whereClause)
15          {
16              _mainTableName = mainTableName;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    