
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 40, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationCacheManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Threading;
7  using System.Xml;
8  using GitHub.Services.Common;
9  using GitHub.Services.Location;
10  using GitHub.Services.Common.Internal;
11  namespace GitHub.Services.WebApi.Location
12  {
13      internal class LocationCacheManager
14      {
15          public LocationCacheManager(Guid serverGuid, Guid serviceOwner, Uri connectionBaseUrl)
16          {
17              m_cacheAvailable = (serverGuid.Equals(Guid.Empty)) ? false : true;
18              m_lastChangeId = -1;
19              m_cacheExpirationDate = DateTime.MinValue;
20              if (serviceOwner == Guid.Empty)
21              {
22                  m_cacheFilePath = Path.Combine(Path.Combine(VssClientSettings.ClientCacheDirectory, serverGuid.ToString()),
23                                                 s_cacheFileName);
24              }
25              else
26              {
27                  m_cacheFilePath = Path.Combine(Path.Combine(Path.Combine(VssClientSettings.ClientCacheDirectory, serverGuid.ToString()), serviceOwner.ToString()),
28                                                 s_cacheFileName);
29              }
30              m_cacheLocallyFresh = false;
31              m_accessMappings = new Dictionary<String, AccessMapping>(VssStringComparer.AccessMappingMoniker);
32              m_services = new Dictionary<String, Dictionary<Guid, ServiceDefinition>>(VssStringComparer.ServiceType);
33              m_cachedMisses = new HashSet<String>(VssStringComparer.ServiceType);
34              m_connectionBaseUrl = connectionBaseUrl;
35              m_locationXmlOperator = new LocationXmlOperator(true);
36          }
37          public Boolean LocalCacheAvailable
38          {
39              get
40              {
41                  EnsureDiskCacheLoaded();
42                  return m_cacheAvailable;
43              }
44          }
45          internal Boolean CacheDataExpired
46          {
47              get
48              {
49                  return m_cacheAvailable && m_cacheLocallyFresh && DateTime.UtcNow >= m_cacheExpirationDate;
50              }
51          }
<span onclick='openModal()' class='match'>52          public AccessMapping ClientAccessMapping
53          {
54              get
55              {
56                  m_accessLock.EnterReadLock();
57                  try
58                  {
59                      return !CacheDataExpired ? m_clientAccessMapping : null;
60                  }
61                  finally
62                  {
63                      m_accessLock.ExitReadLock();
64                  }
65              }
66          }
67          public AccessMapping DefaultAccessMapping
68          {
69              get
70              {
71                  m_accessLock.EnterReadLock();
</span>72                  try
73                  {
74                      return !CacheDataExpired ? m_defaultAccessMapping : null;
75                  }
76                  finally
77                  {
78                      m_accessLock.ExitReadLock();
79                  }
80              }
81          }
82          public String WebApplicationRelativeDirectory
83          {
84              get
85              {
86                  return m_webApplicationRelativeDirectory;
87              }
88              set
89              {
90                  m_webApplicationRelativeDirectory = String.IsNullOrEmpty(value) ? m_webApplicationRelativeDirectory : value;
91              }
92          }
93          public void ClearIfCacheNotFresh(Int32 serverLastChangeId)
94          {
95              if (serverLastChangeId != m_lastChangeId)
96              {
97                  m_accessLock.EnterWriteLock();
98                  try
99                  {
100                      if (serverLastChangeId != m_lastChangeId)
101                      {
102                          m_accessMappings.Clear();
103                          m_services.Clear();
104                          m_cachedMisses.Clear();
105                          m_lastChangeId = -1;
106                          m_cacheExpirationDate = DateTime.MinValue;
107                      }
108                  }
109                  finally
110                  {
111                      m_accessLock.ExitWriteLock();
112                  }
113              }
114          }
115          public void RemoveServices(IEnumerable<ServiceDefinition> serviceDefinitions, Int32 lastChangeId)
116          {
117              EnsureDiskCacheLoaded();
118              m_accessLock.EnterWriteLock();
119              try
120              {
121                  foreach (ServiceDefinition serviceDefinition in serviceDefinitions)
122                  {
123                      Dictionary<Guid, ServiceDefinition> definitions = null;
124                      if (!m_services.TryGetValue(serviceDefinition.ServiceType, out definitions))
125                      {
126                          continue;
127                      }
128                      if (definitions.Remove(serviceDefinition.Identifier) && definitions.Count == 0)
129                      {
130                          m_services.Remove(serviceDefinition.ServiceType);
131                      }
132                  }
133                  SetLastChangeId(lastChangeId, false);
134                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
135                  WriteCacheToDisk();
136              }
137              finally
138              {
139                  m_accessLock.ExitWriteLock();
140              }
141          }
142          public AccessMapping GetAccessMapping(String moniker)
143          {
144              ArgumentUtility.CheckStringForNullOrEmpty(moniker, "moniker");
145              EnsureDiskCacheLoaded();
146              m_accessLock.EnterReadLock();
147              try
148              {
149                  if (CacheDataExpired)
150                  {
151                      return null;
152                  }
153                  AccessMapping accessMapping;
154                  m_accessMappings.TryGetValue(moniker, out accessMapping);
155                  return accessMapping;
156              }
157              finally
158              {
159                  m_accessLock.ExitReadLock();
160              }
161          }
162          public Boolean TryFindService(String serviceType, Guid serviceIdentifier, out ServiceDefinition serviceDefinition)
163          {
164              EnsureDiskCacheLoaded();
165              m_accessLock.EnterReadLock();
166              try
167              {
168                  Dictionary<Guid, ServiceDefinition> services = null;
169                  serviceDefinition = null;
170                  if (CacheDataExpired)
171                  {
172                      return false;
173                  }
174                  if (m_services.TryGetValue(serviceType, out services))
175                  {
176                      if (services.TryGetValue(serviceIdentifier, out serviceDefinition))
177                      {
178                          return true;
179                      }
180                  }
181                  if (m_cachedMisses.Contains(BuildCacheMissString(serviceType, serviceIdentifier)))
182                  {
183                      return true;
184                  }
185                  return false;
186              }
187              finally
188              {
189                  m_accessLock.ExitReadLock();
190              }
191          }
192          public IEnumerable<ServiceDefinition> FindServices(String serviceType)
193          {
194              EnsureDiskCacheLoaded();
195              m_accessLock.EnterReadLock();
196              try
197              {
198                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
199                  if (CacheDataExpired)
200                  {
201                      return null;
202                  }
203                  if (m_services.Count == 0)
204                  {
205                      return null;
206                  }
207                  IEnumerable<Dictionary<Guid, ServiceDefinition>> dictionaries;
208                  if (String.IsNullOrEmpty(serviceType))
209                  {
210                      dictionaries = m_services.Values;
211                  }
212                  else
213                  {
214                      Dictionary<Guid, ServiceDefinition> services = null;
215                      if (!m_services.TryGetValue(serviceType, out services))
216                      {
217                          return null;
218                      }
219                      dictionaries = new Dictionary<Guid, ServiceDefinition>[] { services };
220                  }
221                  List<ServiceDefinition> serviceDefinitions = new List<ServiceDefinition>();
222                  foreach (Dictionary<Guid, ServiceDefinition> dict in dictionaries)
223                  {
224                      foreach (ServiceDefinition definition in dict.Values)
225                      {
226                          serviceDefinitions.Add(definition.Clone());
227                      }
228                  }
229                  return serviceDefinitions;
230              }
231              finally
232              {
233                  m_accessLock.ExitReadLock();
234              }
235          }
236          public void LoadServicesData(LocationServiceData locationServiceData, Boolean allServicesIncluded)
237          {
238              m_accessLock.EnterWriteLock();
239              try
240              {
241                  if (!locationServiceData.ClientCacheFresh && locationServiceData.LastChangeId != m_lastChangeId)
242                  {
243                      m_accessMappings = new Dictionary<String, AccessMapping>(VssStringComparer.AccessMappingMoniker);
244                      m_services = new Dictionary<String, Dictionary<Guid, ServiceDefinition>>(VssStringComparer.ServiceType);
245                      m_cachedMisses = new HashSet<String>(VssStringComparer.ServiceType);
246                      m_lastChangeId = -1;
247                      m_cacheExpirationDate = DateTime.MinValue;
248                  }
249                  else
250                  {
251                      EnsureDiskCacheLoadedHelper();
252                  }
253                  SetLastChangeId(locationServiceData.LastChangeId, allServicesIncluded);
254                  Int32 clientCacheTimeToLive = (ClientCacheTimeToLive != null) ? ClientCacheTimeToLive.Value : locationServiceData.ClientCacheTimeToLive;
255                  m_cacheExpirationDate = DateTime.UtcNow.AddSeconds(clientCacheTimeToLive);
256                  ICollection<AccessMapping> accessMappings = locationServiceData.AccessMappings;
257                  if (accessMappings != null && accessMappings.Count > 0)
258                  {
259                      foreach (AccessMapping accessMapping in accessMappings)
260                      {
261                          if (accessMapping.VirtualDirectory == null &&
262                              !String.IsNullOrEmpty(WebApplicationRelativeDirectory))
263                          {
264                              String absoluteUriTrimmed = accessMapping.AccessPoint.TrimEnd('/');
265                              String relativeDirectoryTrimmed = WebApplicationRelativeDirectory.TrimEnd('/');
266                              if (VssStringComparer.ServerUrl.EndsWith(absoluteUriTrimmed, relativeDirectoryTrimmed))
267                              {
268                                  accessMapping.AccessPoint = absoluteUriTrimmed.Substring(0, absoluteUriTrimmed.Length - relativeDirectoryTrimmed.Length);
269                              }
270                          }
271                          AccessMapping existingAccessMapping;
272                          if (m_accessMappings.TryGetValue(accessMapping.Moniker, out existingAccessMapping))
273                          {
274                              existingAccessMapping.DisplayName = accessMapping.DisplayName;
275                              existingAccessMapping.AccessPoint = accessMapping.AccessPoint;
276                              existingAccessMapping.VirtualDirectory = accessMapping.VirtualDirectory;
277                          }
278                          else
279                          {
280                              existingAccessMapping = accessMapping;
281                              m_accessMappings[accessMapping.Moniker] = accessMapping;
282                          }
283                      }
284                      DetermineClientAndDefaultZones(locationServiceData.DefaultAccessMappingMoniker);
285                  }
286                  if (locationServiceData.ServiceDefinitions != null)
287                  {
288                      foreach (ServiceDefinition definition in locationServiceData.ServiceDefinitions)
289                      {
290                          Dictionary<Guid, ServiceDefinition> definitions = null;
291                          if (!m_services.TryGetValue(definition.ServiceType, out definitions))
292                          {
293                              definitions = new Dictionary<Guid, ServiceDefinition>();
294                              m_services[definition.ServiceType] = definitions;
295                          }
296                          definitions[definition.Identifier] = definition;
297                      }
298                  }
299                  m_cacheAvailable = true;
300                  WriteCacheToDisk();
301              }
302              finally
303              {
304                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
305                  m_accessLock.ExitWriteLock();
306              }
307          }
308          private void DetermineClientAndDefaultZones(String defaultAccessMappingMoniker)
309          {
310              Debug.Assert(m_accessLock.IsWriteLockHeld);
311              m_defaultAccessMapping = null;
312              m_clientAccessMapping = null;
313              String relativeDirectoryTrimmed = (WebApplicationRelativeDirectory != null) ? WebApplicationRelativeDirectory.TrimEnd('/') : String.Empty;
314              foreach (AccessMapping accessMapping in m_accessMappings.Values)
315              {
316                  if (VssStringComparer.ServerUrl.StartsWith(m_connectionBaseUrl.ToString(), accessMapping.AccessPoint.TrimEnd('/')) &&
317                      (accessMapping.VirtualDirectory == null ||
318                      VssStringComparer.UrlPath.Equals(accessMapping.VirtualDirectory, relativeDirectoryTrimmed)))
319                  {
320                      m_clientAccessMapping = accessMapping;
321                  }
322              }
323              m_defaultAccessMapping = m_accessMappings[defaultAccessMappingMoniker];
324              if (m_clientAccessMapping == null)
325              {
326                  String accessPoint = m_connectionBaseUrl.ToString().TrimEnd('/');
327                  String virtualDirectory = String.Empty;
328                  if (!String.IsNullOrEmpty(WebApplicationRelativeDirectory))
329                  {
330                      if (VssStringComparer.ServerUrl.EndsWith(accessPoint, relativeDirectoryTrimmed))
331                      {
332                          accessPoint = accessPoint.Substring(0, accessPoint.Length - relativeDirectoryTrimmed.Length);
333                          virtualDirectory = relativeDirectoryTrimmed;
334                      }
335                  }
336                  m_clientAccessMapping = new AccessMapping()
337                  {
338                      Moniker = accessPoint,
339                      DisplayName = accessPoint,
340                      AccessPoint = accessPoint,
341                      VirtualDirectory = virtualDirectory
342                  };
343              }
344          }
345          public IEnumerable<AccessMapping> AccessMappings
346          {
347              get
348              {
349                  EnsureDiskCacheLoaded();
350                  m_accessLock.EnterReadLock();
351                  try
352                  {
353                      List<AccessMapping> accessMappings = new List<AccessMapping>();
354                      if (!CacheDataExpired)
355                      {
356                          foreach (AccessMapping accessMapping in m_accessMappings.Values)
357                          {
358                              accessMappings.Add(accessMapping);
359                          }
360                      }
361                      return accessMappings;
362                  }
363                  finally
364                  {
365                      m_accessLock.ExitReadLock();
366                  }
367              }
368          }
369          public void RemoveAccessMapping(String moniker)
370          {
371              EnsureDiskCacheLoaded();
372              m_accessLock.EnterWriteLock();
373              try
374              {
375                  m_accessMappings.Remove(moniker);
376                  foreach (Dictionary<Guid, ServiceDefinition> serviceGroup in m_services.Values)
377                  {
378                      foreach (ServiceDefinition definition in serviceGroup.Values)
379                      {
380                          for (int i = 0; i < definition.LocationMappings.Count; i++)
381                          {
382                              if (VssStringComparer.AccessMappingMoniker.Equals(moniker, definition.LocationMappings[i].AccessMappingMoniker))
383                              {
384                                  definition.LocationMappings.RemoveAt(i);
385                                  break;
386                              }
387                          }
388                      }
389                  }
390                  WriteCacheToDisk();
391              }
392              finally
393              {
394                  m_accessLock.ExitWriteLock();
395              }
396          }
397          public void AddCachedMiss(String serviceType, Guid serviceIdentifier, int missedLastChangeId)
398          {
399              if (missedLastChangeId < 0)
400              {
401                  return;
402              }
403              EnsureDiskCacheLoaded();
404              m_accessLock.EnterWriteLock();
405              try
406              {
407                  if (missedLastChangeId == m_lastChangeId &&
408                      m_cachedMisses.Add(BuildCacheMissString(serviceType, serviceIdentifier)))
409                  {
410                      WriteCacheToDisk();
411                  }
412              }
413              finally
414              {
415                  m_accessLock.ExitWriteLock();
416              }
417          }
418          public Int32 GetLastChangeId()
419          {
420              EnsureDiskCacheLoaded();
421              m_accessLock.EnterReadLock();
422              try
423              {
424                  return m_lastChangeId;
425              }
426              finally
427              {
428                  m_accessLock.ExitReadLock();
429              }
430          }
431          internal DateTime GetCacheExpirationDate()
432          {
433              EnsureDiskCacheLoaded();
434              m_accessLock.EnterReadLock();
435              try
436              {
437                  return m_cacheExpirationDate;
438              }
439              finally
440              {
441                  m_accessLock.ExitReadLock();
442              }
443          }
444          private void SetLastChangeId(Int32 lastChangeId, Boolean allServicesUpdated)
445          {
446              Debug.Assert(m_accessLock.IsWriteLockHeld);
447              if (m_lastChangeId != -1 || allServicesUpdated)
448              {
449                  m_lastChangeId = lastChangeId;
450              }
451          }
452          private static String BuildCacheMissString(String serviceType, Guid serviceIdentifier)
453          {
454              return String.Concat(serviceType, "_", serviceIdentifier.ToString());
455          }
456          internal void EnsureDiskCacheLoaded()
457          {
458              if (m_cacheLocallyFresh || !m_cacheAvailable)
459              {
460                  return;
461              }
462              m_accessLock.EnterWriteLock();
463              try
464              {
465                  EnsureDiskCacheLoadedHelper();
466              }
467              finally
468              {
469                  m_accessLock.ExitWriteLock();
470              }
471          }
472          private void EnsureDiskCacheLoadedHelper()
473          {
474              Debug.Assert(m_accessLock.IsWriteLockHeld);
475              FileStream unusedFile = null;
476              try
477              {
478                  if (m_cacheLocallyFresh || !m_cacheAvailable)
479                  {
480                      return;
481                  }
482                  XmlDocument document = XmlUtility.OpenXmlFile(out unusedFile, m_cacheFilePath, FileShare.Read, saveFile: false);
483                  if (document != null)
484                  {
485                      m_accessMappings = new Dictionary<String, AccessMapping>(VssStringComparer.AccessMappingMoniker);
486                      m_services = new Dictionary<String, Dictionary<Guid, ServiceDefinition>>(VssStringComparer.ServiceType);
487                      m_cachedMisses = new HashSet<String>(VssStringComparer.ServiceType);
488                      m_lastChangeId = m_locationXmlOperator.ReadLastChangeId(document);
489                      m_cacheExpirationDate = m_locationXmlOperator.ReadCacheExpirationDate(document);
490                      String defaultAccessMappingMoniker = m_locationXmlOperator.ReadDefaultAccessMappingMoniker(document);
491                      m_webApplicationRelativeDirectory = m_locationXmlOperator.ReadVirtualDirectory(document);
492                      List<AccessMapping> accessMappings = m_locationXmlOperator.ReadAccessMappings(document);
493                      foreach (AccessMapping accessMapping in accessMappings)
494                      {
495                          m_accessMappings[accessMapping.Moniker] = accessMapping;
496                      }
497                      if (accessMappings.Count > 0)
498                      {
499                          DetermineClientAndDefaultZones(defaultAccessMappingMoniker);
500                      }
501                      else
502                      {
503                          m_cacheAvailable = false;
504                          m_lastChangeId = -1;
505                          return;
506                      }
507                      List<ServiceDefinition> serviceDefinitions = m_locationXmlOperator.ReadServices(document, m_accessMappings);
508                      foreach (ServiceDefinition definition in serviceDefinitions)
509                      {
510                          Dictionary<Guid, ServiceDefinition> serviceTypeSet;
511                          if (!m_services.TryGetValue(definition.ServiceType, out serviceTypeSet))
512                          {
513                              serviceTypeSet = new Dictionary<Guid, ServiceDefinition>();
514                              m_services.Add(definition.ServiceType, serviceTypeSet);
515                          }
516                          serviceTypeSet[definition.Identifier] = definition;
517                      }
518                      List<String> cachedMisses = m_locationXmlOperator.ReadCachedMisses(document);
519                      foreach (String cachedMiss in cachedMisses)
520                      {
521                          m_cachedMisses.Add(cachedMiss);
522                      }
523                  }
524                  if (m_fileSystemWatcher == null)
525                  {
526                      m_fileSystemWatcher = new FileSystemWatcher(Path.GetDirectoryName(m_cacheFilePath), s_cacheFileName);
527                      m_fileSystemWatcher.NotifyFilter = NotifyFilters.LastWrite;
528                      m_fileSystemWatcher.Changed += new FileSystemEventHandler(m_fileSystemWatcher_Changed);
529                  }
530                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
531              }
532              catch (Exception)
533              {
534                  m_cacheAvailable = false;
535                  m_lastChangeId = -1;
536              }
537              finally
538              {
539                  m_cacheLocallyFresh = true;
540                  if (unusedFile != null)
541                  {
542                      unusedFile.Dispose();
543                  }
544              }
545          }
546          void m_fileSystemWatcher_Changed(object sender, FileSystemEventArgs e)
547          {
548              m_cacheLocallyFresh = false;
549          }
550          private void WriteCacheToDisk()
551          {
552              Debug.Assert(m_accessLock.IsWriteLockHeld);
553              if (!m_cacheAvailable)
554              {
555                  return;
556              }
557              try
558              {
559                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
560                  using (FileStream file = XmlUtility.OpenFile(m_cacheFilePath, FileShare.None, true))
561                  {
562                      XmlDocument document = new XmlDocument();
563                      XmlNode documentNode = document.CreateNode(XmlNodeType.Element, s_docStartElement, null);
564                      document.AppendChild(documentNode);
565                      m_locationXmlOperator.WriteLastChangeId(documentNode, m_lastChangeId);
566                      m_locationXmlOperator.WriteCacheExpirationDate(documentNode, m_cacheExpirationDate);
567                      m_locationXmlOperator.WriteDefaultAccessMappingMoniker(documentNode, m_defaultAccessMapping.Moniker);
568                      m_locationXmlOperator.WriteVirtualDirectory(documentNode, m_webApplicationRelativeDirectory);
569                      m_locationXmlOperator.WriteAccessMappings(documentNode, m_accessMappings.Values);
570                      List<ServiceDefinition> serviceDefinitions = new List<ServiceDefinition>();
571                      foreach (Dictionary<Guid, ServiceDefinition> serviceTypeSet in m_services.Values)
572                      {
573                          serviceDefinitions.AddRange(serviceTypeSet.Values);
574                      }
575                      m_locationXmlOperator.WriteServices(documentNode, serviceDefinitions);
576                      m_locationXmlOperator.WriteCachedMisses(documentNode, m_cachedMisses);
577                      file.SetLength(0);
578                      file.Position = 0;
579                      document.Save(file);
580                  }
581              }
582              catch (Exception)
583              {
584                  m_cacheAvailable = false;
585              }
586          }
587          internal Int32? ClientCacheTimeToLive
588          {
589              get;
590              set;
591          }
592          private Dictionary<String, Dictionary<Guid, ServiceDefinition>> m_services;
593          private HashSet<String> m_cachedMisses;
594          private Dictionary<String, AccessMapping> m_accessMappings;
595          private Int32 m_lastChangeId;
596          private DateTime m_cacheExpirationDate;
597          private ReaderWriterLockSlim m_accessLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
598          private String m_webApplicationRelativeDirectory;
599          private static Object s_cacheMutex = new Object();
600          private Boolean m_cacheLocallyFresh;
601          private Boolean m_cacheAvailable;
602          private FileSystemWatcher m_fileSystemWatcher;
603          private Uri m_connectionBaseUrl;
604          private AccessMapping m_clientAccessMapping;
605          private AccessMapping m_defaultAccessMapping;
606          private static readonly String s_cacheFileName = "LocationServiceData.config";
607          private String m_cacheFilePath;
608          private LocationXmlOperator m_locationXmlOperator;
609          private const String s_docStartElement = "LocationServiceConfiguration";
610      }
611  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationCacheManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Threading;
7  using System.Xml;
8  using GitHub.Services.Common;
9  using GitHub.Services.Location;
10  using GitHub.Services.Common.Internal;
11  namespace GitHub.Services.WebApi.Location
12  {
13      internal class LocationCacheManager
14      {
15          public LocationCacheManager(Guid serverGuid, Guid serviceOwner, Uri connectionBaseUrl)
16          {
17              m_cacheAvailable = (serverGuid.Equals(Guid.Empty)) ? false : true;
18              m_lastChangeId = -1;
19              m_cacheExpirationDate = DateTime.MinValue;
20              if (serviceOwner == Guid.Empty)
21              {
22                  m_cacheFilePath = Path.Combine(Path.Combine(VssClientSettings.ClientCacheDirectory, serverGuid.ToString()),
23                                                 s_cacheFileName);
24              }
25              else
26              {
27                  m_cacheFilePath = Path.Combine(Path.Combine(Path.Combine(VssClientSettings.ClientCacheDirectory, serverGuid.ToString()), serviceOwner.ToString()),
28                                                 s_cacheFileName);
29              }
30              m_cacheLocallyFresh = false;
31              m_accessMappings = new Dictionary<String, AccessMapping>(VssStringComparer.AccessMappingMoniker);
32              m_services = new Dictionary<String, Dictionary<Guid, ServiceDefinition>>(VssStringComparer.ServiceType);
33              m_cachedMisses = new HashSet<String>(VssStringComparer.ServiceType);
34              m_connectionBaseUrl = connectionBaseUrl;
35              m_locationXmlOperator = new LocationXmlOperator(true);
36          }
37          public Boolean LocalCacheAvailable
38          {
39              get
40              {
41                  EnsureDiskCacheLoaded();
42                  return m_cacheAvailable;
43              }
44          }
45          internal Boolean CacheDataExpired
46          {
47              get
48              {
49                  return m_cacheAvailable && m_cacheLocallyFresh && DateTime.UtcNow >= m_cacheExpirationDate;
50              }
51          }
52          public AccessMapping ClientAccessMapping
53          {
54              get
55              {
56                  m_accessLock.EnterReadLock();
57                  try
58                  {
59                      return !CacheDataExpired ? m_clientAccessMapping : null;
60                  }
61                  finally
62                  {
63                      m_accessLock.ExitReadLock();
64                  }
65              }
66          }
<span onclick='openModal()' class='match'>67          public AccessMapping DefaultAccessMapping
68          {
69              get
70              {
71                  m_accessLock.EnterReadLock();
72                  try
73                  {
74                      return !CacheDataExpired ? m_defaultAccessMapping : null;
75                  }
76                  finally
77                  {
78                      m_accessLock.ExitReadLock();
79                  }
80              }
81          }
82          public String WebApplicationRelativeDirectory
83          {
84              get
85              {
86                  return m_webApplicationRelativeDirectory;
</span>87              }
88              set
89              {
90                  m_webApplicationRelativeDirectory = String.IsNullOrEmpty(value) ? m_webApplicationRelativeDirectory : value;
91              }
92          }
93          public void ClearIfCacheNotFresh(Int32 serverLastChangeId)
94          {
95              if (serverLastChangeId != m_lastChangeId)
96              {
97                  m_accessLock.EnterWriteLock();
98                  try
99                  {
100                      if (serverLastChangeId != m_lastChangeId)
101                      {
102                          m_accessMappings.Clear();
103                          m_services.Clear();
104                          m_cachedMisses.Clear();
105                          m_lastChangeId = -1;
106                          m_cacheExpirationDate = DateTime.MinValue;
107                      }
108                  }
109                  finally
110                  {
111                      m_accessLock.ExitWriteLock();
112                  }
113              }
114          }
115          public void RemoveServices(IEnumerable<ServiceDefinition> serviceDefinitions, Int32 lastChangeId)
116          {
117              EnsureDiskCacheLoaded();
118              m_accessLock.EnterWriteLock();
119              try
120              {
121                  foreach (ServiceDefinition serviceDefinition in serviceDefinitions)
122                  {
123                      Dictionary<Guid, ServiceDefinition> definitions = null;
124                      if (!m_services.TryGetValue(serviceDefinition.ServiceType, out definitions))
125                      {
126                          continue;
127                      }
128                      if (definitions.Remove(serviceDefinition.Identifier) && definitions.Count == 0)
129                      {
130                          m_services.Remove(serviceDefinition.ServiceType);
131                      }
132                  }
133                  SetLastChangeId(lastChangeId, false);
134                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
135                  WriteCacheToDisk();
136              }
137              finally
138              {
139                  m_accessLock.ExitWriteLock();
140              }
141          }
142          public AccessMapping GetAccessMapping(String moniker)
143          {
144              ArgumentUtility.CheckStringForNullOrEmpty(moniker, "moniker");
145              EnsureDiskCacheLoaded();
146              m_accessLock.EnterReadLock();
147              try
148              {
149                  if (CacheDataExpired)
150                  {
151                      return null;
152                  }
153                  AccessMapping accessMapping;
154                  m_accessMappings.TryGetValue(moniker, out accessMapping);
155                  return accessMapping;
156              }
157              finally
158              {
159                  m_accessLock.ExitReadLock();
160              }
161          }
162          public Boolean TryFindService(String serviceType, Guid serviceIdentifier, out ServiceDefinition serviceDefinition)
163          {
164              EnsureDiskCacheLoaded();
165              m_accessLock.EnterReadLock();
166              try
167              {
168                  Dictionary<Guid, ServiceDefinition> services = null;
169                  serviceDefinition = null;
170                  if (CacheDataExpired)
171                  {
172                      return false;
173                  }
174                  if (m_services.TryGetValue(serviceType, out services))
175                  {
176                      if (services.TryGetValue(serviceIdentifier, out serviceDefinition))
177                      {
178                          return true;
179                      }
180                  }
181                  if (m_cachedMisses.Contains(BuildCacheMissString(serviceType, serviceIdentifier)))
182                  {
183                      return true;
184                  }
185                  return false;
186              }
187              finally
188              {
189                  m_accessLock.ExitReadLock();
190              }
191          }
192          public IEnumerable<ServiceDefinition> FindServices(String serviceType)
193          {
194              EnsureDiskCacheLoaded();
195              m_accessLock.EnterReadLock();
196              try
197              {
198                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
199                  if (CacheDataExpired)
200                  {
201                      return null;
202                  }
203                  if (m_services.Count == 0)
204                  {
205                      return null;
206                  }
207                  IEnumerable<Dictionary<Guid, ServiceDefinition>> dictionaries;
208                  if (String.IsNullOrEmpty(serviceType))
209                  {
210                      dictionaries = m_services.Values;
211                  }
212                  else
213                  {
214                      Dictionary<Guid, ServiceDefinition> services = null;
215                      if (!m_services.TryGetValue(serviceType, out services))
216                      {
217                          return null;
218                      }
219                      dictionaries = new Dictionary<Guid, ServiceDefinition>[] { services };
220                  }
221                  List<ServiceDefinition> serviceDefinitions = new List<ServiceDefinition>();
222                  foreach (Dictionary<Guid, ServiceDefinition> dict in dictionaries)
223                  {
224                      foreach (ServiceDefinition definition in dict.Values)
225                      {
226                          serviceDefinitions.Add(definition.Clone());
227                      }
228                  }
229                  return serviceDefinitions;
230              }
231              finally
232              {
233                  m_accessLock.ExitReadLock();
234              }
235          }
236          public void LoadServicesData(LocationServiceData locationServiceData, Boolean allServicesIncluded)
237          {
238              m_accessLock.EnterWriteLock();
239              try
240              {
241                  if (!locationServiceData.ClientCacheFresh && locationServiceData.LastChangeId != m_lastChangeId)
242                  {
243                      m_accessMappings = new Dictionary<String, AccessMapping>(VssStringComparer.AccessMappingMoniker);
244                      m_services = new Dictionary<String, Dictionary<Guid, ServiceDefinition>>(VssStringComparer.ServiceType);
245                      m_cachedMisses = new HashSet<String>(VssStringComparer.ServiceType);
246                      m_lastChangeId = -1;
247                      m_cacheExpirationDate = DateTime.MinValue;
248                  }
249                  else
250                  {
251                      EnsureDiskCacheLoadedHelper();
252                  }
253                  SetLastChangeId(locationServiceData.LastChangeId, allServicesIncluded);
254                  Int32 clientCacheTimeToLive = (ClientCacheTimeToLive != null) ? ClientCacheTimeToLive.Value : locationServiceData.ClientCacheTimeToLive;
255                  m_cacheExpirationDate = DateTime.UtcNow.AddSeconds(clientCacheTimeToLive);
256                  ICollection<AccessMapping> accessMappings = locationServiceData.AccessMappings;
257                  if (accessMappings != null && accessMappings.Count > 0)
258                  {
259                      foreach (AccessMapping accessMapping in accessMappings)
260                      {
261                          if (accessMapping.VirtualDirectory == null &&
262                              !String.IsNullOrEmpty(WebApplicationRelativeDirectory))
263                          {
264                              String absoluteUriTrimmed = accessMapping.AccessPoint.TrimEnd('/');
265                              String relativeDirectoryTrimmed = WebApplicationRelativeDirectory.TrimEnd('/');
266                              if (VssStringComparer.ServerUrl.EndsWith(absoluteUriTrimmed, relativeDirectoryTrimmed))
267                              {
268                                  accessMapping.AccessPoint = absoluteUriTrimmed.Substring(0, absoluteUriTrimmed.Length - relativeDirectoryTrimmed.Length);
269                              }
270                          }
271                          AccessMapping existingAccessMapping;
272                          if (m_accessMappings.TryGetValue(accessMapping.Moniker, out existingAccessMapping))
273                          {
274                              existingAccessMapping.DisplayName = accessMapping.DisplayName;
275                              existingAccessMapping.AccessPoint = accessMapping.AccessPoint;
276                              existingAccessMapping.VirtualDirectory = accessMapping.VirtualDirectory;
277                          }
278                          else
279                          {
280                              existingAccessMapping = accessMapping;
281                              m_accessMappings[accessMapping.Moniker] = accessMapping;
282                          }
283                      }
284                      DetermineClientAndDefaultZones(locationServiceData.DefaultAccessMappingMoniker);
285                  }
286                  if (locationServiceData.ServiceDefinitions != null)
287                  {
288                      foreach (ServiceDefinition definition in locationServiceData.ServiceDefinitions)
289                      {
290                          Dictionary<Guid, ServiceDefinition> definitions = null;
291                          if (!m_services.TryGetValue(definition.ServiceType, out definitions))
292                          {
293                              definitions = new Dictionary<Guid, ServiceDefinition>();
294                              m_services[definition.ServiceType] = definitions;
295                          }
296                          definitions[definition.Identifier] = definition;
297                      }
298                  }
299                  m_cacheAvailable = true;
300                  WriteCacheToDisk();
301              }
302              finally
303              {
304                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
305                  m_accessLock.ExitWriteLock();
306              }
307          }
308          private void DetermineClientAndDefaultZones(String defaultAccessMappingMoniker)
309          {
310              Debug.Assert(m_accessLock.IsWriteLockHeld);
311              m_defaultAccessMapping = null;
312              m_clientAccessMapping = null;
313              String relativeDirectoryTrimmed = (WebApplicationRelativeDirectory != null) ? WebApplicationRelativeDirectory.TrimEnd('/') : String.Empty;
314              foreach (AccessMapping accessMapping in m_accessMappings.Values)
315              {
316                  if (VssStringComparer.ServerUrl.StartsWith(m_connectionBaseUrl.ToString(), accessMapping.AccessPoint.TrimEnd('/')) &&
317                      (accessMapping.VirtualDirectory == null ||
318                      VssStringComparer.UrlPath.Equals(accessMapping.VirtualDirectory, relativeDirectoryTrimmed)))
319                  {
320                      m_clientAccessMapping = accessMapping;
321                  }
322              }
323              m_defaultAccessMapping = m_accessMappings[defaultAccessMappingMoniker];
324              if (m_clientAccessMapping == null)
325              {
326                  String accessPoint = m_connectionBaseUrl.ToString().TrimEnd('/');
327                  String virtualDirectory = String.Empty;
328                  if (!String.IsNullOrEmpty(WebApplicationRelativeDirectory))
329                  {
330                      if (VssStringComparer.ServerUrl.EndsWith(accessPoint, relativeDirectoryTrimmed))
331                      {
332                          accessPoint = accessPoint.Substring(0, accessPoint.Length - relativeDirectoryTrimmed.Length);
333                          virtualDirectory = relativeDirectoryTrimmed;
334                      }
335                  }
336                  m_clientAccessMapping = new AccessMapping()
337                  {
338                      Moniker = accessPoint,
339                      DisplayName = accessPoint,
340                      AccessPoint = accessPoint,
341                      VirtualDirectory = virtualDirectory
342                  };
343              }
344          }
345          public IEnumerable<AccessMapping> AccessMappings
346          {
347              get
348              {
349                  EnsureDiskCacheLoaded();
350                  m_accessLock.EnterReadLock();
351                  try
352                  {
353                      List<AccessMapping> accessMappings = new List<AccessMapping>();
354                      if (!CacheDataExpired)
355                      {
356                          foreach (AccessMapping accessMapping in m_accessMappings.Values)
357                          {
358                              accessMappings.Add(accessMapping);
359                          }
360                      }
361                      return accessMappings;
362                  }
363                  finally
364                  {
365                      m_accessLock.ExitReadLock();
366                  }
367              }
368          }
369          public void RemoveAccessMapping(String moniker)
370          {
371              EnsureDiskCacheLoaded();
372              m_accessLock.EnterWriteLock();
373              try
374              {
375                  m_accessMappings.Remove(moniker);
376                  foreach (Dictionary<Guid, ServiceDefinition> serviceGroup in m_services.Values)
377                  {
378                      foreach (ServiceDefinition definition in serviceGroup.Values)
379                      {
380                          for (int i = 0; i < definition.LocationMappings.Count; i++)
381                          {
382                              if (VssStringComparer.AccessMappingMoniker.Equals(moniker, definition.LocationMappings[i].AccessMappingMoniker))
383                              {
384                                  definition.LocationMappings.RemoveAt(i);
385                                  break;
386                              }
387                          }
388                      }
389                  }
390                  WriteCacheToDisk();
391              }
392              finally
393              {
394                  m_accessLock.ExitWriteLock();
395              }
396          }
397          public void AddCachedMiss(String serviceType, Guid serviceIdentifier, int missedLastChangeId)
398          {
399              if (missedLastChangeId < 0)
400              {
401                  return;
402              }
403              EnsureDiskCacheLoaded();
404              m_accessLock.EnterWriteLock();
405              try
406              {
407                  if (missedLastChangeId == m_lastChangeId &&
408                      m_cachedMisses.Add(BuildCacheMissString(serviceType, serviceIdentifier)))
409                  {
410                      WriteCacheToDisk();
411                  }
412              }
413              finally
414              {
415                  m_accessLock.ExitWriteLock();
416              }
417          }
418          public Int32 GetLastChangeId()
419          {
420              EnsureDiskCacheLoaded();
421              m_accessLock.EnterReadLock();
422              try
423              {
424                  return m_lastChangeId;
425              }
426              finally
427              {
428                  m_accessLock.ExitReadLock();
429              }
430          }
431          internal DateTime GetCacheExpirationDate()
432          {
433              EnsureDiskCacheLoaded();
434              m_accessLock.EnterReadLock();
435              try
436              {
437                  return m_cacheExpirationDate;
438              }
439              finally
440              {
441                  m_accessLock.ExitReadLock();
442              }
443          }
444          private void SetLastChangeId(Int32 lastChangeId, Boolean allServicesUpdated)
445          {
446              Debug.Assert(m_accessLock.IsWriteLockHeld);
447              if (m_lastChangeId != -1 || allServicesUpdated)
448              {
449                  m_lastChangeId = lastChangeId;
450              }
451          }
452          private static String BuildCacheMissString(String serviceType, Guid serviceIdentifier)
453          {
454              return String.Concat(serviceType, "_", serviceIdentifier.ToString());
455          }
456          internal void EnsureDiskCacheLoaded()
457          {
458              if (m_cacheLocallyFresh || !m_cacheAvailable)
459              {
460                  return;
461              }
462              m_accessLock.EnterWriteLock();
463              try
464              {
465                  EnsureDiskCacheLoadedHelper();
466              }
467              finally
468              {
469                  m_accessLock.ExitWriteLock();
470              }
471          }
472          private void EnsureDiskCacheLoadedHelper()
473          {
474              Debug.Assert(m_accessLock.IsWriteLockHeld);
475              FileStream unusedFile = null;
476              try
477              {
478                  if (m_cacheLocallyFresh || !m_cacheAvailable)
479                  {
480                      return;
481                  }
482                  XmlDocument document = XmlUtility.OpenXmlFile(out unusedFile, m_cacheFilePath, FileShare.Read, saveFile: false);
483                  if (document != null)
484                  {
485                      m_accessMappings = new Dictionary<String, AccessMapping>(VssStringComparer.AccessMappingMoniker);
486                      m_services = new Dictionary<String, Dictionary<Guid, ServiceDefinition>>(VssStringComparer.ServiceType);
487                      m_cachedMisses = new HashSet<String>(VssStringComparer.ServiceType);
488                      m_lastChangeId = m_locationXmlOperator.ReadLastChangeId(document);
489                      m_cacheExpirationDate = m_locationXmlOperator.ReadCacheExpirationDate(document);
490                      String defaultAccessMappingMoniker = m_locationXmlOperator.ReadDefaultAccessMappingMoniker(document);
491                      m_webApplicationRelativeDirectory = m_locationXmlOperator.ReadVirtualDirectory(document);
492                      List<AccessMapping> accessMappings = m_locationXmlOperator.ReadAccessMappings(document);
493                      foreach (AccessMapping accessMapping in accessMappings)
494                      {
495                          m_accessMappings[accessMapping.Moniker] = accessMapping;
496                      }
497                      if (accessMappings.Count > 0)
498                      {
499                          DetermineClientAndDefaultZones(defaultAccessMappingMoniker);
500                      }
501                      else
502                      {
503                          m_cacheAvailable = false;
504                          m_lastChangeId = -1;
505                          return;
506                      }
507                      List<ServiceDefinition> serviceDefinitions = m_locationXmlOperator.ReadServices(document, m_accessMappings);
508                      foreach (ServiceDefinition definition in serviceDefinitions)
509                      {
510                          Dictionary<Guid, ServiceDefinition> serviceTypeSet;
511                          if (!m_services.TryGetValue(definition.ServiceType, out serviceTypeSet))
512                          {
513                              serviceTypeSet = new Dictionary<Guid, ServiceDefinition>();
514                              m_services.Add(definition.ServiceType, serviceTypeSet);
515                          }
516                          serviceTypeSet[definition.Identifier] = definition;
517                      }
518                      List<String> cachedMisses = m_locationXmlOperator.ReadCachedMisses(document);
519                      foreach (String cachedMiss in cachedMisses)
520                      {
521                          m_cachedMisses.Add(cachedMiss);
522                      }
523                  }
524                  if (m_fileSystemWatcher == null)
525                  {
526                      m_fileSystemWatcher = new FileSystemWatcher(Path.GetDirectoryName(m_cacheFilePath), s_cacheFileName);
527                      m_fileSystemWatcher.NotifyFilter = NotifyFilters.LastWrite;
528                      m_fileSystemWatcher.Changed += new FileSystemEventHandler(m_fileSystemWatcher_Changed);
529                  }
530                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
531              }
532              catch (Exception)
533              {
534                  m_cacheAvailable = false;
535                  m_lastChangeId = -1;
536              }
537              finally
538              {
539                  m_cacheLocallyFresh = true;
540                  if (unusedFile != null)
541                  {
542                      unusedFile.Dispose();
543                  }
544              }
545          }
546          void m_fileSystemWatcher_Changed(object sender, FileSystemEventArgs e)
547          {
548              m_cacheLocallyFresh = false;
549          }
550          private void WriteCacheToDisk()
551          {
552              Debug.Assert(m_accessLock.IsWriteLockHeld);
553              if (!m_cacheAvailable)
554              {
555                  return;
556              }
557              try
558              {
559                  Debug.Assert(m_lastChangeId == -1 || m_services.Count > 0);
560                  using (FileStream file = XmlUtility.OpenFile(m_cacheFilePath, FileShare.None, true))
561                  {
562                      XmlDocument document = new XmlDocument();
563                      XmlNode documentNode = document.CreateNode(XmlNodeType.Element, s_docStartElement, null);
564                      document.AppendChild(documentNode);
565                      m_locationXmlOperator.WriteLastChangeId(documentNode, m_lastChangeId);
566                      m_locationXmlOperator.WriteCacheExpirationDate(documentNode, m_cacheExpirationDate);
567                      m_locationXmlOperator.WriteDefaultAccessMappingMoniker(documentNode, m_defaultAccessMapping.Moniker);
568                      m_locationXmlOperator.WriteVirtualDirectory(documentNode, m_webApplicationRelativeDirectory);
569                      m_locationXmlOperator.WriteAccessMappings(documentNode, m_accessMappings.Values);
570                      List<ServiceDefinition> serviceDefinitions = new List<ServiceDefinition>();
571                      foreach (Dictionary<Guid, ServiceDefinition> serviceTypeSet in m_services.Values)
572                      {
573                          serviceDefinitions.AddRange(serviceTypeSet.Values);
574                      }
575                      m_locationXmlOperator.WriteServices(documentNode, serviceDefinitions);
576                      m_locationXmlOperator.WriteCachedMisses(documentNode, m_cachedMisses);
577                      file.SetLength(0);
578                      file.Position = 0;
579                      document.Save(file);
580                  }
581              }
582              catch (Exception)
583              {
584                  m_cacheAvailable = false;
585              }
586          }
587          internal Int32? ClientCacheTimeToLive
588          {
589              get;
590              set;
591          }
592          private Dictionary<String, Dictionary<Guid, ServiceDefinition>> m_services;
593          private HashSet<String> m_cachedMisses;
594          private Dictionary<String, AccessMapping> m_accessMappings;
595          private Int32 m_lastChangeId;
596          private DateTime m_cacheExpirationDate;
597          private ReaderWriterLockSlim m_accessLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
598          private String m_webApplicationRelativeDirectory;
599          private static Object s_cacheMutex = new Object();
600          private Boolean m_cacheLocallyFresh;
601          private Boolean m_cacheAvailable;
602          private FileSystemWatcher m_fileSystemWatcher;
603          private Uri m_connectionBaseUrl;
604          private AccessMapping m_clientAccessMapping;
605          private AccessMapping m_defaultAccessMapping;
606          private static readonly String s_cacheFileName = "LocationServiceData.config";
607          private String m_cacheFilePath;
608          private LocationXmlOperator m_locationXmlOperator;
609          private const String s_docStartElement = "LocationServiceConfiguration";
610      }
611  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationCacheManager.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationCacheManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>52          public AccessMapping ClientAccessMapping
53          {
54              get
55              {
56                  m_accessLock.EnterReadLock();
57                  try
58                  {
59                      return !CacheDataExpired ? m_clientAccessMapping : null;
60                  }
61                  finally
62                  {
63                      m_accessLock.ExitReadLock();
64                  }
65              }
66          }
67          public AccessMapping DefaultAccessMapping
68          {
69              get
70              {
71                  m_accessLock.EnterReadLock();
</pre></code></div>
                <div class="column column_space"><pre><code>67          public AccessMapping DefaultAccessMapping
68          {
69              get
70              {
71                  m_accessLock.EnterReadLock();
72                  try
73                  {
74                      return !CacheDataExpired ? m_defaultAccessMapping : null;
75                  }
76                  finally
77                  {
78                      m_accessLock.ExitReadLock();
79                  }
80              }
81          }
82          public String WebApplicationRelativeDirectory
83          {
84              get
85              {
86                  return m_webApplicationRelativeDirectory;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    