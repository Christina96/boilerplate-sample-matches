
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateConverter.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Linq;
5  using GitHub.DistributedTask.Expressions2;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.DistributedTask.Expressions2.Sdk.Functions;
8  using GitHub.DistributedTask.ObjectTemplating;
9  using GitHub.DistributedTask.ObjectTemplating.Tokens;
10  using GitHub.DistributedTask.Pipelines.ContextData;
11  using GitHub.DistributedTask.Pipelines.Validation;
12  using GitHub.Services.Common;
13  using Newtonsoft.Json.Linq;
14  namespace GitHub.DistributedTask.Pipelines.ObjectTemplating
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)]
17      public static class PipelineTemplateConverter
18      {
19          public static List&lt;Step&gt; ConvertToSteps(
20              TemplateContext context,
21              TemplateToken steps)
22          {
23              var stepsSequence = steps.AssertSequence($&quot;job {PipelineTemplateConstants.Steps}&quot;);
24              var result = new List&lt;Step&gt;();
25              var nameBuilder = new ReferenceNameBuilder();
26              foreach (var stepsItem in stepsSequence)
27              {
28                  var step = ConvertToStep(context, stepsItem, nameBuilder);
29                  if (step != null) 
30                  {
31                      if (step.Enabled)
32                      {
33                          result.Add(step);
34                      }
35                  }
36              }
37              foreach (ActionStep step in result)
38              {
39                  if (!String.IsNullOrEmpty(step.ContextName))
40                  {
41                      continue;
42                  }
43                  var name = default(string);
44                  switch (step.Reference.Type)
45                  {
46                      case ActionSourceType.ContainerRegistry:
47                          var containerReference = step.Reference as ContainerRegistryReference;
48                          name = containerReference.Image;
49                          break;
50                      case ActionSourceType.Repository:
51                          var repositoryReference = step.Reference as RepositoryPathReference;
52                          name = !String.IsNullOrEmpty(repositoryReference.Name) ? repositoryReference.Name : PipelineConstants.SelfAlias;
53                          break;
54                  }
55                  if (String.IsNullOrEmpty(name))
56                  {
57                      name = &quot;run&quot;;
58                  }
59                  nameBuilder.AppendSegment($&quot;__{name}&quot;);
60                  step.ContextName = nameBuilder.Build();
61              }
62              return result;
63          }
64          internal static Boolean ConvertToIfResult(
65              TemplateContext context,
66              TemplateToken ifResult)
67          {
68              var expression = ifResult.Traverse().FirstOrDefault(x =&gt; x is ExpressionToken);
69              if (expression != null)
70              {
71                  throw new ArgumentException($&quot;Unexpected type &#x27;{expression.GetType().Name}&#x27; encountered while reading &#x27;if&#x27;.&quot;);
72              }
73              var evaluationResult = EvaluationResult.CreateIntermediateResult(null, ifResult);
74              return evaluationResult.IsTruthy;
75          }
76          internal static Boolean? ConvertToStepContinueOnError(
77              TemplateContext context,
78              TemplateToken token,
79              Boolean allowExpressions = false)
80          {
81              if (allowExpressions &amp;&amp; token is ExpressionToken)
82              {
83                  return null;
84              }
85              var booleanToken = token.AssertBoolean($&quot;step {PipelineTemplateConstants.ContinueOnError}&quot;);
86              return booleanToken.Value;
87          }
88          internal static String ConvertToStepDisplayName(
89              TemplateContext context,
90              TemplateToken token,
91              Boolean allowExpressions = false)
92          {
93              if (allowExpressions &amp;&amp; token is ExpressionToken)
94              {
95                  return null;
96              }
97              var stringToken = token.AssertString($&quot;step {PipelineTemplateConstants.Name}&quot;);
98              return stringToken.Value;
99          }
100          internal static Dictionary&lt;String, String&gt; ConvertToStepEnvironment(
101              TemplateContext context,
102              TemplateToken environment,
103              StringComparer keyComparer,
104              Boolean allowExpressions = false)
105          {
106              var result = new Dictionary&lt;String, String&gt;(keyComparer);
107              if (allowExpressions &amp;&amp; environment is ExpressionToken)
108              {
109                  return result;
110              }
111              var mapping = environment.AssertMapping(&quot;environment&quot;);
112              foreach (var pair in mapping)
113              {
114                  if (allowExpressions &amp;&amp; pair.Key is ExpressionToken)
115                  {
116                      continue;
117                  }
118                  var key = pair.Key.AssertString(&quot;environment key&quot;);
119                  if (allowExpressions &amp;&amp; pair.Value is ExpressionToken)
120                  {
121                      continue;
122                  }
123                  var value = pair.Value.AssertString(&quot;environment value&quot;);
124                  result[key.Value] = value.Value;
125              }
126              return result;
127          }
128          internal static Dictionary&lt;String, String&gt; ConvertToStepInputs(
129              TemplateContext context,
130              TemplateToken inputs,
131              Boolean allowExpressions = false)
132          {
133              var result = new Dictionary&lt;String, String&gt;(StringComparer.OrdinalIgnoreCase);
134              if (allowExpressions &amp;&amp; inputs is ExpressionToken)
135              {
136                  return result;
137              }
138              var mapping = inputs.AssertMapping(&quot;inputs&quot;);
139              foreach (var pair in mapping)
140              {
141                  if (allowExpressions &amp;&amp; pair.Key is ExpressionToken)
142                  {
143                      continue;
144                  }
145                  var key = pair.Key.AssertString(&quot;inputs key&quot;);
146                  if (allowExpressions &amp;&amp; pair.Value is ExpressionToken)
147                  {
148                      continue;
149                  }
150                  var value = pair.Value.AssertString(&quot;inputs value&quot;);
151                  result[key.Value] = value.Value;
152              }
153              return result;
154          }
155          internal static Int32? ConvertToStepTimeout(
156              TemplateContext context,
157              TemplateToken token,
158              Boolean allowExpressions = false)
159          {
160              if (allowExpressions &amp;&amp; token is ExpressionToken)
161              {
162                  return null;
163              }
164              var numberToken = token.AssertNumber($&quot;step {PipelineTemplateConstants.TimeoutMinutes}&quot;);
165              return (Int32)numberToken.Value;
166          }
167          internal static ContainerRegistryCredentials ConvertToContainerCredentials(TemplateToken token)
168          {
169              var credentials = token.AssertMapping(PipelineTemplateConstants.Credentials);
170              var result = new ContainerRegistryCredentials();
171              foreach (var credentialProperty in credentials)
172              {
173                  var propertyName = credentialProperty.Key.AssertString($&quot;{PipelineTemplateConstants.Credentials} key&quot;);
174                  switch (propertyName.Value)
175                  {
176                      case PipelineTemplateConstants.Username:
177                          result.Username = credentialProperty.Value.AssertString(PipelineTemplateConstants.Username).Value;
178                          break;
179                      case PipelineTemplateConstants.Password:
180                          result.Password = credentialProperty.Value.AssertString(PipelineTemplateConstants.Password).Value;
181                          break;
182                      default:
183                          propertyName.AssertUnexpectedValue($&quot;{PipelineTemplateConstants.Credentials} key {propertyName}&quot;);
184                          break;
185                  }
186              }
187              return result;
188          }
189          internal static JobContainer ConvertToJobContainer(
190              TemplateContext context,
191              TemplateToken value,
192              bool allowExpressions = false)
193          {
194              var result = new JobContainer();
195              if (allowExpressions &amp;&amp; value.Traverse().Any(x =&gt; x is ExpressionToken))
196              {
197                  return result;
198              }
199              if (value is StringToken containerLiteral)
200              {
201                  if (String.IsNullOrEmpty(containerLiteral.Value))
202                  {
203                      return null;
204                  }
205                  result.Image = containerLiteral.Value;
206              }
207              else
208              {
209                  var containerMapping = value.AssertMapping($&quot;{PipelineTemplateConstants.Container}&quot;);
210                  foreach (var containerPropertyPair in containerMapping)
211                  {
212                      var propertyName = containerPropertyPair.Key.AssertString($&quot;{PipelineTemplateConstants.Container} key&quot;);
213                      switch (propertyName.Value)
214                      {
215                          case PipelineTemplateConstants.Image:
216                              result.Image = containerPropertyPair.Value.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;).Value;
217                              break;
218                          case PipelineTemplateConstants.Env:
219                              var env = containerPropertyPair.Value.AssertMapping($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;);
220                              var envDict = new Dictionary&lt;String, String&gt;(env.Count);
221                              foreach (var envPair in env)
222                              {
223                                  var envKey = envPair.Key.ToString();
224                                  var envValue = envPair.Value.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName} {envPair.Key.ToString()}&quot;).Value;
225                                  envDict.Add(envKey, envValue);
226                              }
227                              result.Environment = envDict;
228                              break;
229                          case PipelineTemplateConstants.Options:
230                              result.Options = containerPropertyPair.Value.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;).Value;
231                              break;
232                          case PipelineTemplateConstants.Ports:
233                              var ports = containerPropertyPair.Value.AssertSequence($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;);
234                              var portList = new List&lt;String&gt;(ports.Count);
235                              foreach (var portItem in ports)
236                              {
237                                  var portString = portItem.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName} {portItem.ToString()}&quot;).Value;
238                                  portList.Add(portString);
239                              }
240                              result.Ports = portList;
241                              break;
242                          case PipelineTemplateConstants.Volumes:
243                              var volumes = containerPropertyPair.Value.AssertSequence($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;);
244                              var volumeList = new List&lt;String&gt;(volumes.Count);
245                              foreach (var volumeItem in volumes)
246                              {
247                                  var volumeString = volumeItem.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName} {volumeItem.ToString()}&quot;).Value;
248                                  volumeList.Add(volumeString);
249                              }
250                              result.Volumes = volumeList;
251                              break;
252                          case PipelineTemplateConstants.Credentials:
253                              result.Credentials = ConvertToContainerCredentials(containerPropertyPair.Value);
254                              break;
255                          default:
256                              propertyName.AssertUnexpectedValue($&quot;{PipelineTemplateConstants.Container} key&quot;);
257                              break;
258                      }
259                  }
260              }
261              if (result.Image.StartsWith(&quot;docker:&amp;bsol;&amp;bsol;&quot;, StringComparison.Ordinal))
262              {
263                  result.Image = result.Image.Substring(&quot;docker:&amp;bsol;&amp;bsol;&quot;.Length);
264              }
265              if (String.IsNullOrEmpty(result.Image))
266              {
267                  return null;
268              }
269              return result;
270          }
271          internal static List&lt;KeyValuePair&lt;String, JobContainer&gt;&gt; ConvertToJobServiceContainers(
272              TemplateContext context,
273              TemplateToken services,
274              bool allowExpressions = false)
275          {
276              var result = new List&lt;KeyValuePair&lt;String, JobContainer&gt;&gt;();
277              if (allowExpressions &amp;&amp; services.Traverse().Any(x =&gt; x is ExpressionToken))
278              {
279                  return result;
280              }
281              var servicesMapping = services.AssertMapping(&quot;services&quot;);
282              foreach (var servicePair in servicesMapping)
283              {
284                  var networkAlias = servicePair.Key.AssertString(&quot;services key&quot;).Value;
285                  var container = ConvertToJobContainer(context, servicePair.Value);
286                  result.Add(new KeyValuePair&lt;String, JobContainer&gt;(networkAlias, container));
287              }
288              return result;
289          }
290          private static ActionStep ConvertToStep(
291              TemplateContext context,
292              TemplateToken stepsItem,
293              ReferenceNameBuilder nameBuilder)
294          {
295              var step = stepsItem.AssertMapping($&quot;{PipelineTemplateConstants.Steps} item&quot;);
296              var continueOnError = default(ScalarToken);
297              var env = default(TemplateToken);
298              var id = default(StringToken);
299              var ifCondition = default(String);
300              var ifToken = default(ScalarToken);
301              var name = default(ScalarToken);
302              var run = default(ScalarToken);
303              var timeoutMinutes = default(ScalarToken);
304              var uses = default(StringToken);
305              var with = default(TemplateToken);
306              var workingDir = default(ScalarToken);
<span onclick='openModal()' class='match'>307              var path = default(ScalarToken);
308              var clean = default(ScalarToken);
309              var fetchDepth = default(ScalarToken);
</span>310              var lfs = default(ScalarToken);
311              var submodules = default(ScalarToken);
312              var shell = default(ScalarToken);
313              foreach (var stepProperty in step)
314              {
315                  var propertyName = stepProperty.Key.AssertString($&quot;{PipelineTemplateConstants.Steps} item key&quot;);
316                  switch (propertyName.Value)
317                  {
318                      case PipelineTemplateConstants.Clean:
319                          clean = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Clean}&quot;);
320                          break;
321                      case PipelineTemplateConstants.ContinueOnError:
322                          ConvertToStepContinueOnError(context, stepProperty.Value, allowExpressions: true); 
323                          continueOnError = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} {PipelineTemplateConstants.ContinueOnError}&quot;);
324                          break;
325                      case PipelineTemplateConstants.Env:
326                          ConvertToStepEnvironment(context, stepProperty.Value, StringComparer.Ordinal, allowExpressions: true); 
327                          env = stepProperty.Value;
328                          break;
329                      case PipelineTemplateConstants.FetchDepth:
330                          fetchDepth = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.FetchDepth}&quot;);
331                          break;
332                      case PipelineTemplateConstants.Id:
333                          id = stepProperty.Value.AssertString($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Id}&quot;);
334                          if (!String.IsNullOrEmpty(id.Value))
335                          {
336                              if (!nameBuilder.TryAddKnownName(id.Value, out var error))
337                              {
338                                  context.Error(id, error);
339                              }
340                          }
341                          break;
342                      case PipelineTemplateConstants.If:
343                          ifToken = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.If}&quot;);
344                          break;
345                      case PipelineTemplateConstants.Lfs:
346                          lfs = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Lfs}&quot;);
347                          break;
348                      case PipelineTemplateConstants.Name:
349                          name = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Name}&quot;);
350                          break;
351                      case PipelineTemplateConstants.Path:
352                          path = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Path}&quot;);
353                          break;
354                      case PipelineTemplateConstants.Run:
355                          run = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Run}&quot;);
356                          break;
357                      case PipelineTemplateConstants.Shell:
358                          shell = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Shell}&quot;);
359                          break;
360                      case PipelineTemplateConstants.Submodules:
361                          submodules = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Submodules}&quot;);
362                          break;
363                      case PipelineTemplateConstants.TimeoutMinutes:
364                          ConvertToStepTimeout(context, stepProperty.Value, allowExpressions: true); 
365                          timeoutMinutes = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.TimeoutMinutes}&quot;);
366                          break;
367                      case PipelineTemplateConstants.Uses:
368                          uses = stepProperty.Value.AssertString($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Uses}&quot;);
369                          break;
370                      case PipelineTemplateConstants.With:
371                          ConvertToStepInputs(context, stepProperty.Value, allowExpressions: true); 
372                          with = stepProperty.Value;
373                          break;
374                      case PipelineTemplateConstants.WorkingDirectory:
375                          workingDir = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.WorkingDirectory}&quot;);
376                          break;
377                      default:
378                          propertyName.AssertUnexpectedValue($&quot;{PipelineTemplateConstants.Steps} item key&quot;); 
379                          break;
380                  }
381              }
382              ifCondition = ConvertToIfCondition(context, ifToken, false);
383              if (run != null)
384              {
385                  var result = new ActionStep
386                  {
387                      ContextName = id?.Value,
388                      ContinueOnError = continueOnError,
389                      DisplayNameToken = name,
390                      Condition = ifCondition,
391                      TimeoutInMinutes = timeoutMinutes,
392                      Environment = env,
393                      Reference = new ScriptReference(),
394                  };
395                  var inputs = new MappingToken(null, null, null);
396                  inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.Script), run);
397                  if (workingDir != null)
398                  {
399                      inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.WorkingDirectory), workingDir);
400                  }
401                  if (shell != null)
402                  {
403                      inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.Shell), shell);
404                  }
405                  result.Inputs = inputs;
406                  return result;
407              }
408              else
409              {
410                  uses.AssertString($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Uses}&quot;);
411                  var result = new ActionStep
412                  {
413                      ContextName = id?.Value,
414                      ContinueOnError = continueOnError,
415                      DisplayNameToken = name,
416                      Condition = ifCondition,
417                      TimeoutInMinutes = timeoutMinutes,
418                      Inputs = with,
419                      Environment = env,
420                  };
421                  if (uses.Value.StartsWith(&quot;docker:&amp;bsol;&amp;bsol;&quot;, StringComparison.Ordinal))
422                  {
423                      var image = uses.Value.Substring(&quot;docker:&amp;bsol;&amp;bsol;&quot;.Length);
424                      result.Reference = new ContainerRegistryReference { Image = image };
425                  }
426                  else if (uses.Value.StartsWith(&quot;./&quot;) || uses.Value.StartsWith(&quot;.\\&quot;))
427                  {
428                      result.Reference = new RepositoryPathReference
429                      {
430                          RepositoryType = PipelineConstants.SelfAlias,
431                          Path = uses.Value
432                      };
433                  }
434                  else
435                  {
436                      var usesSegments = uses.Value.Split(&#x27;@&#x27;);
437                      var pathSegments = usesSegments[0].Split(new[] { &#x27;/&#x27;, &#x27;\\&#x27; }, StringSplitOptions.RemoveEmptyEntries);
438                      var gitRef = usesSegments.Length == 2 ? usesSegments[1] : String.Empty;
439                      if (usesSegments.Length != 2 ||
440                          pathSegments.Length &lt; 2 ||
441                          String.IsNullOrEmpty(pathSegments[0]) ||
442                          String.IsNullOrEmpty(pathSegments[1]) ||
443                          String.IsNullOrEmpty(gitRef))
444                      {
445                          context.Error(uses, $&quot;Expected format {{org}}/{{repo}}[/path]@ref. Actual &#x27;{uses.Value}&#x27;&quot;);
446                      }
447                      else
448                      {
449                          var repositoryName = $&quot;{pathSegments[0]}/{pathSegments[1]}&quot;;
450                          var directoryPath = pathSegments.Length &gt; 2 ? String.Join(&quot;/&quot;, pathSegments.Skip(2)) : String.Empty;
451                          result.Reference = new RepositoryPathReference
452                          {
453                              RepositoryType = RepositoryTypes.GitHub,
454                              Name = repositoryName,
455                              Ref = gitRef,
456                              Path = directoryPath,
457                          };
458                      }
459                  }
460                  return result;
461              }
462          }
463          private static String ConvertToIfCondition(
464              TemplateContext context,
465              TemplateToken token,
466              Boolean isJob)
467          {
468              String condition;
469              if (token is null)
470              {
471                  condition = null;
472              }
473              else if (token is BasicExpressionToken expressionToken)
474              {
475                  condition = expressionToken.Expression;
476              }
477              else
478              {
479                  var stringToken = token.AssertString($&quot;{(isJob ? &quot;job&quot; : &quot;step&quot;)} {PipelineTemplateConstants.If}&quot;);
480                  condition = stringToken.Value;
481              }
482              if (String.IsNullOrWhiteSpace(condition))
483              {
484                  return $&quot;{PipelineTemplateConstants.Success}()&quot;;
485              }
486              var expressionParser = new ExpressionParser();
487              var functions = default(IFunctionInfo[]);
488              var namedValues = default(INamedValueInfo[]);
489              if (isJob)
490              {
491                  namedValues = s_jobIfNamedValues;
492              }
493              else
494              {
495                  namedValues = s_stepNamedValues;
496                  functions = s_stepConditionFunctions;
497              }
498              var node = default(ExpressionNode);
499              try
500              {
501                  node = expressionParser.CreateTree(condition, null, namedValues, functions) as ExpressionNode;
502              }
503              catch (Exception ex)
504              {
505                  context.Error(token, ex);
506                  return null;
507              }
508              if (node == null)
509              {
510                  return $&quot;{PipelineTemplateConstants.Success}()&quot;;
511              }
512              var hasStatusFunction = node.Traverse().Any(x =&gt;
513              {
514                  if (x is Function function)
515                  {
516                      return String.Equals(function.Name, PipelineTemplateConstants.Always, StringComparison.OrdinalIgnoreCase) ||
517                          String.Equals(function.Name, PipelineTemplateConstants.Cancelled, StringComparison.OrdinalIgnoreCase) ||
518                          String.Equals(function.Name, PipelineTemplateConstants.Failure, StringComparison.OrdinalIgnoreCase) ||
519                          String.Equals(function.Name, PipelineTemplateConstants.Success, StringComparison.OrdinalIgnoreCase);
520                  }
521                  return false;
522              });
523              return hasStatusFunction ? condition : $&quot;{PipelineTemplateConstants.Success}() &amp;&amp; ({condition})&quot;;
524          }
525          private static readonly INamedValueInfo[] s_jobIfNamedValues = new INamedValueInfo[]
526          {
527              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.GitHub),
528              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Needs),
529              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Vars),
530          };
531          private static readonly INamedValueInfo[] s_stepNamedValues = new INamedValueInfo[]
532          {
533              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Strategy),
534              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Matrix),
535              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Steps),
536              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.GitHub),
537              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Inputs),
538              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Job),
539              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Runner),
540              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Env),
541              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Needs),
542              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Vars),
543          };
544          private static readonly IFunctionInfo[] s_stepConditionFunctions = new IFunctionInfo[]
545          {
546              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Always, 0, 0),
547              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Cancelled, 0, 0),
548              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Failure, 0, 0),
549              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Success, 0, 0),
550              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.HashFiles, 1, Byte.MaxValue),
551          };
552      }
553  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateConverter.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Linq;
5  using GitHub.DistributedTask.Expressions2;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.DistributedTask.Expressions2.Sdk.Functions;
8  using GitHub.DistributedTask.ObjectTemplating;
9  using GitHub.DistributedTask.ObjectTemplating.Tokens;
10  using GitHub.DistributedTask.Pipelines.ContextData;
11  using GitHub.DistributedTask.Pipelines.Validation;
12  using GitHub.Services.Common;
13  using Newtonsoft.Json.Linq;
14  namespace GitHub.DistributedTask.Pipelines.ObjectTemplating
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)]
17      public static class PipelineTemplateConverter
18      {
19          public static List&lt;Step&gt; ConvertToSteps(
20              TemplateContext context,
21              TemplateToken steps)
22          {
23              var stepsSequence = steps.AssertSequence($&quot;job {PipelineTemplateConstants.Steps}&quot;);
24              var result = new List&lt;Step&gt;();
25              var nameBuilder = new ReferenceNameBuilder();
26              foreach (var stepsItem in stepsSequence)
27              {
28                  var step = ConvertToStep(context, stepsItem, nameBuilder);
29                  if (step != null) 
30                  {
31                      if (step.Enabled)
32                      {
33                          result.Add(step);
34                      }
35                  }
36              }
37              foreach (ActionStep step in result)
38              {
39                  if (!String.IsNullOrEmpty(step.ContextName))
40                  {
41                      continue;
42                  }
43                  var name = default(string);
44                  switch (step.Reference.Type)
45                  {
46                      case ActionSourceType.ContainerRegistry:
47                          var containerReference = step.Reference as ContainerRegistryReference;
48                          name = containerReference.Image;
49                          break;
50                      case ActionSourceType.Repository:
51                          var repositoryReference = step.Reference as RepositoryPathReference;
52                          name = !String.IsNullOrEmpty(repositoryReference.Name) ? repositoryReference.Name : PipelineConstants.SelfAlias;
53                          break;
54                  }
55                  if (String.IsNullOrEmpty(name))
56                  {
57                      name = &quot;run&quot;;
58                  }
59                  nameBuilder.AppendSegment($&quot;__{name}&quot;);
60                  step.ContextName = nameBuilder.Build();
61              }
62              return result;
63          }
64          internal static Boolean ConvertToIfResult(
65              TemplateContext context,
66              TemplateToken ifResult)
67          {
68              var expression = ifResult.Traverse().FirstOrDefault(x =&gt; x is ExpressionToken);
69              if (expression != null)
70              {
71                  throw new ArgumentException($&quot;Unexpected type &#x27;{expression.GetType().Name}&#x27; encountered while reading &#x27;if&#x27;.&quot;);
72              }
73              var evaluationResult = EvaluationResult.CreateIntermediateResult(null, ifResult);
74              return evaluationResult.IsTruthy;
75          }
76          internal static Boolean? ConvertToStepContinueOnError(
77              TemplateContext context,
78              TemplateToken token,
79              Boolean allowExpressions = false)
80          {
81              if (allowExpressions &amp;&amp; token is ExpressionToken)
82              {
83                  return null;
84              }
85              var booleanToken = token.AssertBoolean($&quot;step {PipelineTemplateConstants.ContinueOnError}&quot;);
86              return booleanToken.Value;
87          }
88          internal static String ConvertToStepDisplayName(
89              TemplateContext context,
90              TemplateToken token,
91              Boolean allowExpressions = false)
92          {
93              if (allowExpressions &amp;&amp; token is ExpressionToken)
94              {
95                  return null;
96              }
97              var stringToken = token.AssertString($&quot;step {PipelineTemplateConstants.Name}&quot;);
98              return stringToken.Value;
99          }
100          internal static Dictionary&lt;String, String&gt; ConvertToStepEnvironment(
101              TemplateContext context,
102              TemplateToken environment,
103              StringComparer keyComparer,
104              Boolean allowExpressions = false)
105          {
106              var result = new Dictionary&lt;String, String&gt;(keyComparer);
107              if (allowExpressions &amp;&amp; environment is ExpressionToken)
108              {
109                  return result;
110              }
111              var mapping = environment.AssertMapping(&quot;environment&quot;);
112              foreach (var pair in mapping)
113              {
114                  if (allowExpressions &amp;&amp; pair.Key is ExpressionToken)
115                  {
116                      continue;
117                  }
118                  var key = pair.Key.AssertString(&quot;environment key&quot;);
119                  if (allowExpressions &amp;&amp; pair.Value is ExpressionToken)
120                  {
121                      continue;
122                  }
123                  var value = pair.Value.AssertString(&quot;environment value&quot;);
124                  result[key.Value] = value.Value;
125              }
126              return result;
127          }
128          internal static Dictionary&lt;String, String&gt; ConvertToStepInputs(
129              TemplateContext context,
130              TemplateToken inputs,
131              Boolean allowExpressions = false)
132          {
133              var result = new Dictionary&lt;String, String&gt;(StringComparer.OrdinalIgnoreCase);
134              if (allowExpressions &amp;&amp; inputs is ExpressionToken)
135              {
136                  return result;
137              }
138              var mapping = inputs.AssertMapping(&quot;inputs&quot;);
139              foreach (var pair in mapping)
140              {
141                  if (allowExpressions &amp;&amp; pair.Key is ExpressionToken)
142                  {
143                      continue;
144                  }
145                  var key = pair.Key.AssertString(&quot;inputs key&quot;);
146                  if (allowExpressions &amp;&amp; pair.Value is ExpressionToken)
147                  {
148                      continue;
149                  }
150                  var value = pair.Value.AssertString(&quot;inputs value&quot;);
151                  result[key.Value] = value.Value;
152              }
153              return result;
154          }
155          internal static Int32? ConvertToStepTimeout(
156              TemplateContext context,
157              TemplateToken token,
158              Boolean allowExpressions = false)
159          {
160              if (allowExpressions &amp;&amp; token is ExpressionToken)
161              {
162                  return null;
163              }
164              var numberToken = token.AssertNumber($&quot;step {PipelineTemplateConstants.TimeoutMinutes}&quot;);
165              return (Int32)numberToken.Value;
166          }
167          internal static ContainerRegistryCredentials ConvertToContainerCredentials(TemplateToken token)
168          {
169              var credentials = token.AssertMapping(PipelineTemplateConstants.Credentials);
170              var result = new ContainerRegistryCredentials();
171              foreach (var credentialProperty in credentials)
172              {
173                  var propertyName = credentialProperty.Key.AssertString($&quot;{PipelineTemplateConstants.Credentials} key&quot;);
174                  switch (propertyName.Value)
175                  {
176                      case PipelineTemplateConstants.Username:
177                          result.Username = credentialProperty.Value.AssertString(PipelineTemplateConstants.Username).Value;
178                          break;
179                      case PipelineTemplateConstants.Password:
180                          result.Password = credentialProperty.Value.AssertString(PipelineTemplateConstants.Password).Value;
181                          break;
182                      default:
183                          propertyName.AssertUnexpectedValue($&quot;{PipelineTemplateConstants.Credentials} key {propertyName}&quot;);
184                          break;
185                  }
186              }
187              return result;
188          }
189          internal static JobContainer ConvertToJobContainer(
190              TemplateContext context,
191              TemplateToken value,
192              bool allowExpressions = false)
193          {
194              var result = new JobContainer();
195              if (allowExpressions &amp;&amp; value.Traverse().Any(x =&gt; x is ExpressionToken))
196              {
197                  return result;
198              }
199              if (value is StringToken containerLiteral)
200              {
201                  if (String.IsNullOrEmpty(containerLiteral.Value))
202                  {
203                      return null;
204                  }
205                  result.Image = containerLiteral.Value;
206              }
207              else
208              {
209                  var containerMapping = value.AssertMapping($&quot;{PipelineTemplateConstants.Container}&quot;);
210                  foreach (var containerPropertyPair in containerMapping)
211                  {
212                      var propertyName = containerPropertyPair.Key.AssertString($&quot;{PipelineTemplateConstants.Container} key&quot;);
213                      switch (propertyName.Value)
214                      {
215                          case PipelineTemplateConstants.Image:
216                              result.Image = containerPropertyPair.Value.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;).Value;
217                              break;
218                          case PipelineTemplateConstants.Env:
219                              var env = containerPropertyPair.Value.AssertMapping($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;);
220                              var envDict = new Dictionary&lt;String, String&gt;(env.Count);
221                              foreach (var envPair in env)
222                              {
223                                  var envKey = envPair.Key.ToString();
224                                  var envValue = envPair.Value.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName} {envPair.Key.ToString()}&quot;).Value;
225                                  envDict.Add(envKey, envValue);
226                              }
227                              result.Environment = envDict;
228                              break;
229                          case PipelineTemplateConstants.Options:
230                              result.Options = containerPropertyPair.Value.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;).Value;
231                              break;
232                          case PipelineTemplateConstants.Ports:
233                              var ports = containerPropertyPair.Value.AssertSequence($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;);
234                              var portList = new List&lt;String&gt;(ports.Count);
235                              foreach (var portItem in ports)
236                              {
237                                  var portString = portItem.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName} {portItem.ToString()}&quot;).Value;
238                                  portList.Add(portString);
239                              }
240                              result.Ports = portList;
241                              break;
242                          case PipelineTemplateConstants.Volumes:
243                              var volumes = containerPropertyPair.Value.AssertSequence($&quot;{PipelineTemplateConstants.Container} {propertyName}&quot;);
244                              var volumeList = new List&lt;String&gt;(volumes.Count);
245                              foreach (var volumeItem in volumes)
246                              {
247                                  var volumeString = volumeItem.AssertString($&quot;{PipelineTemplateConstants.Container} {propertyName} {volumeItem.ToString()}&quot;).Value;
248                                  volumeList.Add(volumeString);
249                              }
250                              result.Volumes = volumeList;
251                              break;
252                          case PipelineTemplateConstants.Credentials:
253                              result.Credentials = ConvertToContainerCredentials(containerPropertyPair.Value);
254                              break;
255                          default:
256                              propertyName.AssertUnexpectedValue($&quot;{PipelineTemplateConstants.Container} key&quot;);
257                              break;
258                      }
259                  }
260              }
261              if (result.Image.StartsWith(&quot;docker:&amp;bsol;&amp;bsol;&quot;, StringComparison.Ordinal))
262              {
263                  result.Image = result.Image.Substring(&quot;docker:&amp;bsol;&amp;bsol;&quot;.Length);
264              }
265              if (String.IsNullOrEmpty(result.Image))
266              {
267                  return null;
268              }
269              return result;
270          }
271          internal static List&lt;KeyValuePair&lt;String, JobContainer&gt;&gt; ConvertToJobServiceContainers(
272              TemplateContext context,
273              TemplateToken services,
274              bool allowExpressions = false)
275          {
276              var result = new List&lt;KeyValuePair&lt;String, JobContainer&gt;&gt;();
277              if (allowExpressions &amp;&amp; services.Traverse().Any(x =&gt; x is ExpressionToken))
278              {
279                  return result;
280              }
281              var servicesMapping = services.AssertMapping(&quot;services&quot;);
282              foreach (var servicePair in servicesMapping)
283              {
284                  var networkAlias = servicePair.Key.AssertString(&quot;services key&quot;).Value;
285                  var container = ConvertToJobContainer(context, servicePair.Value);
286                  result.Add(new KeyValuePair&lt;String, JobContainer&gt;(networkAlias, container));
287              }
288              return result;
289          }
290          private static ActionStep ConvertToStep(
291              TemplateContext context,
292              TemplateToken stepsItem,
293              ReferenceNameBuilder nameBuilder)
294          {
295              var step = stepsItem.AssertMapping($&quot;{PipelineTemplateConstants.Steps} item&quot;);
296              var continueOnError = default(ScalarToken);
297              var env = default(TemplateToken);
<span onclick='openModal()' class='match'>298              var id = default(StringToken);
299              var ifCondition = default(String);
300              var ifToken = default(ScalarToken);
</span>301              var name = default(ScalarToken);
302              var run = default(ScalarToken);
303              var timeoutMinutes = default(ScalarToken);
304              var uses = default(StringToken);
305              var with = default(TemplateToken);
306              var workingDir = default(ScalarToken);
307              var path = default(ScalarToken);
308              var clean = default(ScalarToken);
309              var fetchDepth = default(ScalarToken);
310              var lfs = default(ScalarToken);
311              var submodules = default(ScalarToken);
312              var shell = default(ScalarToken);
313              foreach (var stepProperty in step)
314              {
315                  var propertyName = stepProperty.Key.AssertString($&quot;{PipelineTemplateConstants.Steps} item key&quot;);
316                  switch (propertyName.Value)
317                  {
318                      case PipelineTemplateConstants.Clean:
319                          clean = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Clean}&quot;);
320                          break;
321                      case PipelineTemplateConstants.ContinueOnError:
322                          ConvertToStepContinueOnError(context, stepProperty.Value, allowExpressions: true); 
323                          continueOnError = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} {PipelineTemplateConstants.ContinueOnError}&quot;);
324                          break;
325                      case PipelineTemplateConstants.Env:
326                          ConvertToStepEnvironment(context, stepProperty.Value, StringComparer.Ordinal, allowExpressions: true); 
327                          env = stepProperty.Value;
328                          break;
329                      case PipelineTemplateConstants.FetchDepth:
330                          fetchDepth = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.FetchDepth}&quot;);
331                          break;
332                      case PipelineTemplateConstants.Id:
333                          id = stepProperty.Value.AssertString($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Id}&quot;);
334                          if (!String.IsNullOrEmpty(id.Value))
335                          {
336                              if (!nameBuilder.TryAddKnownName(id.Value, out var error))
337                              {
338                                  context.Error(id, error);
339                              }
340                          }
341                          break;
342                      case PipelineTemplateConstants.If:
343                          ifToken = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.If}&quot;);
344                          break;
345                      case PipelineTemplateConstants.Lfs:
346                          lfs = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Lfs}&quot;);
347                          break;
348                      case PipelineTemplateConstants.Name:
349                          name = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Name}&quot;);
350                          break;
351                      case PipelineTemplateConstants.Path:
352                          path = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Path}&quot;);
353                          break;
354                      case PipelineTemplateConstants.Run:
355                          run = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Run}&quot;);
356                          break;
357                      case PipelineTemplateConstants.Shell:
358                          shell = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Shell}&quot;);
359                          break;
360                      case PipelineTemplateConstants.Submodules:
361                          submodules = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Submodules}&quot;);
362                          break;
363                      case PipelineTemplateConstants.TimeoutMinutes:
364                          ConvertToStepTimeout(context, stepProperty.Value, allowExpressions: true); 
365                          timeoutMinutes = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.TimeoutMinutes}&quot;);
366                          break;
367                      case PipelineTemplateConstants.Uses:
368                          uses = stepProperty.Value.AssertString($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Uses}&quot;);
369                          break;
370                      case PipelineTemplateConstants.With:
371                          ConvertToStepInputs(context, stepProperty.Value, allowExpressions: true); 
372                          with = stepProperty.Value;
373                          break;
374                      case PipelineTemplateConstants.WorkingDirectory:
375                          workingDir = stepProperty.Value.AssertScalar($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.WorkingDirectory}&quot;);
376                          break;
377                      default:
378                          propertyName.AssertUnexpectedValue($&quot;{PipelineTemplateConstants.Steps} item key&quot;); 
379                          break;
380                  }
381              }
382              ifCondition = ConvertToIfCondition(context, ifToken, false);
383              if (run != null)
384              {
385                  var result = new ActionStep
386                  {
387                      ContextName = id?.Value,
388                      ContinueOnError = continueOnError,
389                      DisplayNameToken = name,
390                      Condition = ifCondition,
391                      TimeoutInMinutes = timeoutMinutes,
392                      Environment = env,
393                      Reference = new ScriptReference(),
394                  };
395                  var inputs = new MappingToken(null, null, null);
396                  inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.Script), run);
397                  if (workingDir != null)
398                  {
399                      inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.WorkingDirectory), workingDir);
400                  }
401                  if (shell != null)
402                  {
403                      inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.Shell), shell);
404                  }
405                  result.Inputs = inputs;
406                  return result;
407              }
408              else
409              {
410                  uses.AssertString($&quot;{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Uses}&quot;);
411                  var result = new ActionStep
412                  {
413                      ContextName = id?.Value,
414                      ContinueOnError = continueOnError,
415                      DisplayNameToken = name,
416                      Condition = ifCondition,
417                      TimeoutInMinutes = timeoutMinutes,
418                      Inputs = with,
419                      Environment = env,
420                  };
421                  if (uses.Value.StartsWith(&quot;docker:&amp;bsol;&amp;bsol;&quot;, StringComparison.Ordinal))
422                  {
423                      var image = uses.Value.Substring(&quot;docker:&amp;bsol;&amp;bsol;&quot;.Length);
424                      result.Reference = new ContainerRegistryReference { Image = image };
425                  }
426                  else if (uses.Value.StartsWith(&quot;./&quot;) || uses.Value.StartsWith(&quot;.\\&quot;))
427                  {
428                      result.Reference = new RepositoryPathReference
429                      {
430                          RepositoryType = PipelineConstants.SelfAlias,
431                          Path = uses.Value
432                      };
433                  }
434                  else
435                  {
436                      var usesSegments = uses.Value.Split(&#x27;@&#x27;);
437                      var pathSegments = usesSegments[0].Split(new[] { &#x27;/&#x27;, &#x27;\\&#x27; }, StringSplitOptions.RemoveEmptyEntries);
438                      var gitRef = usesSegments.Length == 2 ? usesSegments[1] : String.Empty;
439                      if (usesSegments.Length != 2 ||
440                          pathSegments.Length &lt; 2 ||
441                          String.IsNullOrEmpty(pathSegments[0]) ||
442                          String.IsNullOrEmpty(pathSegments[1]) ||
443                          String.IsNullOrEmpty(gitRef))
444                      {
445                          context.Error(uses, $&quot;Expected format {{org}}/{{repo}}[/path]@ref. Actual &#x27;{uses.Value}&#x27;&quot;);
446                      }
447                      else
448                      {
449                          var repositoryName = $&quot;{pathSegments[0]}/{pathSegments[1]}&quot;;
450                          var directoryPath = pathSegments.Length &gt; 2 ? String.Join(&quot;/&quot;, pathSegments.Skip(2)) : String.Empty;
451                          result.Reference = new RepositoryPathReference
452                          {
453                              RepositoryType = RepositoryTypes.GitHub,
454                              Name = repositoryName,
455                              Ref = gitRef,
456                              Path = directoryPath,
457                          };
458                      }
459                  }
460                  return result;
461              }
462          }
463          private static String ConvertToIfCondition(
464              TemplateContext context,
465              TemplateToken token,
466              Boolean isJob)
467          {
468              String condition;
469              if (token is null)
470              {
471                  condition = null;
472              }
473              else if (token is BasicExpressionToken expressionToken)
474              {
475                  condition = expressionToken.Expression;
476              }
477              else
478              {
479                  var stringToken = token.AssertString($&quot;{(isJob ? &quot;job&quot; : &quot;step&quot;)} {PipelineTemplateConstants.If}&quot;);
480                  condition = stringToken.Value;
481              }
482              if (String.IsNullOrWhiteSpace(condition))
483              {
484                  return $&quot;{PipelineTemplateConstants.Success}()&quot;;
485              }
486              var expressionParser = new ExpressionParser();
487              var functions = default(IFunctionInfo[]);
488              var namedValues = default(INamedValueInfo[]);
489              if (isJob)
490              {
491                  namedValues = s_jobIfNamedValues;
492              }
493              else
494              {
495                  namedValues = s_stepNamedValues;
496                  functions = s_stepConditionFunctions;
497              }
498              var node = default(ExpressionNode);
499              try
500              {
501                  node = expressionParser.CreateTree(condition, null, namedValues, functions) as ExpressionNode;
502              }
503              catch (Exception ex)
504              {
505                  context.Error(token, ex);
506                  return null;
507              }
508              if (node == null)
509              {
510                  return $&quot;{PipelineTemplateConstants.Success}()&quot;;
511              }
512              var hasStatusFunction = node.Traverse().Any(x =&gt;
513              {
514                  if (x is Function function)
515                  {
516                      return String.Equals(function.Name, PipelineTemplateConstants.Always, StringComparison.OrdinalIgnoreCase) ||
517                          String.Equals(function.Name, PipelineTemplateConstants.Cancelled, StringComparison.OrdinalIgnoreCase) ||
518                          String.Equals(function.Name, PipelineTemplateConstants.Failure, StringComparison.OrdinalIgnoreCase) ||
519                          String.Equals(function.Name, PipelineTemplateConstants.Success, StringComparison.OrdinalIgnoreCase);
520                  }
521                  return false;
522              });
523              return hasStatusFunction ? condition : $&quot;{PipelineTemplateConstants.Success}() &amp;&amp; ({condition})&quot;;
524          }
525          private static readonly INamedValueInfo[] s_jobIfNamedValues = new INamedValueInfo[]
526          {
527              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.GitHub),
528              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Needs),
529              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Vars),
530          };
531          private static readonly INamedValueInfo[] s_stepNamedValues = new INamedValueInfo[]
532          {
533              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Strategy),
534              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Matrix),
535              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Steps),
536              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.GitHub),
537              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Inputs),
538              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Job),
539              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Runner),
540              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Env),
541              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Needs),
542              new NamedValueInfo&lt;NoOperationNamedValue&gt;(PipelineTemplateConstants.Vars),
543          };
544          private static readonly IFunctionInfo[] s_stepConditionFunctions = new IFunctionInfo[]
545          {
546              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Always, 0, 0),
547              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Cancelled, 0, 0),
548              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Failure, 0, 0),
549              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.Success, 0, 0),
550              new FunctionInfo&lt;NoOperation&gt;(PipelineTemplateConstants.HashFiles, 1, Byte.MaxValue),
551          };
552      }
553  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateConverter.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateConverter.cs</div>
                </div>
                <div class="column column_space"><pre><code>307              var path = default(ScalarToken);
308              var clean = default(ScalarToken);
309              var fetchDepth = default(ScalarToken);
</pre></code></div>
                <div class="column column_space"><pre><code>298              var id = default(StringToken);
299              var ifCondition = default(String);
300              var ifToken = default(ScalarToken);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    