
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobRunner.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Net.Http;
6  using System.Net.Http.Headers;
7  using System.Text;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using GitHub.DistributedTask.ObjectTemplating.Tokens;
11  using GitHub.DistributedTask.Pipelines;
12  using GitHub.DistributedTask.WebApi;
13  using GitHub.Runner.Common;
14  using GitHub.Runner.Common.Util;
15  using GitHub.Runner.Sdk;
16  using GitHub.Services.Common;
17  using GitHub.Services.WebApi;
18  using Pipelines = GitHub.DistributedTask.Pipelines;
19  namespace GitHub.Runner.Worker
20  {
21      [ServiceLocator(Default = typeof(JobRunner))]
22      public interface IJobRunner : IRunnerService
23      {
24          Task&lt;TaskResult&gt; RunAsync(AgentJobRequestMessage message, CancellationToken jobRequestCancellationToken);
25      }
26      public sealed class JobRunner : RunnerService, IJobRunner
27      {
28          private IJobServerQueue _jobServerQueue;
29          private RunnerSettings _runnerSettings;
30          private ITempDirectoryManager _tempDirectoryManager;
31          public async Task&lt;TaskResult&gt; RunAsync(AgentJobRequestMessage message, CancellationToken jobRequestCancellationToken)
32          {
33              Trace.Entering();
34              ArgUtil.NotNull(message, nameof(message));
35              ArgUtil.NotNull(message.Resources, nameof(message.Resources));
36              ArgUtil.NotNull(message.Variables, nameof(message.Variables));
37              ArgUtil.NotNull(message.Steps, nameof(message.Steps));
38              Trace.Info(&quot;Job ID {0}&quot;, message.JobId);
39              DateTime jobStartTimeUtc = DateTime.UtcNow;
40              IRunnerService server = null;
41              if (message.Variables.TryGetValue(Constants.Variables.System.OrchestrationId, out VariableValue orchestrationId) &amp;&amp;
42                  !string.IsNullOrEmpty(orchestrationId.Value))
43              {
44                  HostContext.UserAgents.Add(new ProductInfoHeaderValue(&quot;OrchestrationId&quot;, orchestrationId.Value));
45              }
46              ServiceEndpoint systemConnection = message.Resources.Endpoints.Single(x =&gt; string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
47              if (MessageUtil.IsRunServiceJob(message.MessageType))
48              {
49                  var runServer = HostContext.GetService&lt;IRunServer&gt;();
50                  VssCredentials jobServerCredential = VssUtil.GetVssCredential(systemConnection);
51                  await runServer.ConnectAsync(systemConnection.Url, jobServerCredential);
52                  server = runServer;
53                  message.Variables.TryGetValue(&quot;system.github.launch_endpoint&quot;, out VariableValue launchEndpointVariable);
54                  var launchReceiverEndpoint = launchEndpointVariable?.Value;
55                  if (systemConnection?.Authorization != null &amp;&amp;
56                      systemConnection.Authorization.Parameters.TryGetValue(&quot;AccessToken&quot;, out var accessToken) &amp;&amp;
57                      !string.IsNullOrEmpty(accessToken) &amp;&amp;
58                      !string.IsNullOrEmpty(launchReceiverEndpoint))
59                  {
60                      Trace.Info(&quot;Initializing launch client&quot;);
61                      var launchServer = HostContext.GetService&lt;ILaunchServer&gt;();
62                      launchServer.InitializeLaunchClient(new Uri(launchReceiverEndpoint), accessToken);
63                  }
64                  _jobServerQueue = HostContext.GetService&lt;IJobServerQueue&gt;();
65                  _jobServerQueue.Start(message, resultServiceOnly: true);
66              }
67              else
68              {
69                  var jobServer = HostContext.GetService&lt;IJobServer&gt;();
70                  VssCredentials jobServerCredential = VssUtil.GetVssCredential(systemConnection);
71                  Uri jobServerUrl = systemConnection.Url;
72                  Trace.Info($&quot;Creating job server with URL: {jobServerUrl}&quot;);
73                  _jobServerQueue = HostContext.GetService&lt;IJobServerQueue&gt;();
74                  VssConnection jobConnection = VssUtil.CreateConnection(jobServerUrl, jobServerCredential, new DelegatingHandler[] { new ThrottlingReportHandler(_jobServerQueue) });
75                  await jobServer.ConnectAsync(jobConnection);
76                  _jobServerQueue.Start(message);
77                  server = jobServer;
78              }
79              HostContext.WritePerfCounter($&quot;WorkerJobServerQueueStarted_{message.RequestId.ToString()}&quot;);
80              IExecutionContext jobContext = null;
81              CancellationTokenRegistration? runnerShutdownRegistration = null;
82              try
83              {
84                  jobContext = HostContext.CreateService&lt;IExecutionContext&gt;();
85                  jobContext.InitializeJob(message, jobRequestCancellationToken);
86                  Trace.Info(&quot;Starting the job execution context.&quot;);
87                  jobContext.Start();
88                  jobContext.Debug($&quot;Starting: {message.JobDisplayName}&quot;);
89                  runnerShutdownRegistration = HostContext.RunnerShutdownToken.Register(() =&gt;
90                  {
91                      string errorMessage;
92                      switch (HostContext.RunnerShutdownReason)
93                      {
94                          case ShutdownReason.UserCancelled:
95                              errorMessage = &quot;The runner has received a shutdown signal. This can happen when the runner service is stopped, or a manually started runner is canceled.&quot;;
96                              break;
97                          case ShutdownReason.OperatingSystemShutdown:
98                              errorMessage = $&quot;Operating system is shutting down for computer &#x27;{Environment.MachineName}&#x27;&quot;;
99                              break;
100                          default:
101                              throw new ArgumentException(HostContext.RunnerShutdownReason.ToString(), nameof(HostContext.RunnerShutdownReason));
102                      }
103                      var issue = new Issue() { Type = IssueType.Error, Message = errorMessage };
104                      jobContext.AddIssue(issue, ExecutionContextLogOptions.Default);
105                  });
106                  string workDirectory = HostContext.GetDirectory(WellKnownDirectory.Work);
107                  Trace.Info($&quot;Validating directory permissions for: &#x27;{workDirectory}&#x27;&quot;);
108                  try
109                  {
110                      Directory.CreateDirectory(workDirectory);
111                      IOUtil.ValidateExecutePermission(workDirectory);
112                  }
113                  catch (Exception ex)
114                  {
115                      Trace.Error(ex);
116                      jobContext.Error(ex);
117                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Failed);
118                  }
119                  if (jobContext.Global.WriteDebug)
120                  {
121                      jobContext.SetRunnerContext(&quot;debug&quot;, &quot;1&quot;);
122                  }
123                  jobContext.SetRunnerContext(&quot;os&quot;, VarUtil.OS);
124                  jobContext.SetRunnerContext(&quot;arch&quot;, VarUtil.OSArchitecture);
125                  _runnerSettings = HostContext.GetService&lt;IConfigurationStore&gt;().GetSettings();
126                  jobContext.SetRunnerContext(&quot;name&quot;, _runnerSettings.AgentName);
127                  if (jobContext.Global.Variables.TryGetValue(WellKnownDistributedTaskVariables.RunnerEnvironment, out var runnerEnvironment))
128                  {
129                      jobContext.SetRunnerContext(&quot;environment&quot;, runnerEnvironment);
130                  }
131                  string toolsDirectory = HostContext.GetDirectory(WellKnownDirectory.Tools);
132                  Directory.CreateDirectory(toolsDirectory);
133                  jobContext.SetRunnerContext(&quot;tool_cache&quot;, toolsDirectory);
134                  _tempDirectoryManager = HostContext.GetService&lt;ITempDirectoryManager&gt;();
135                  _tempDirectoryManager.InitializeTempDirectory(jobContext);
136                  Trace.Info(&quot;Getting job extension.&quot;);
137                  IJobExtension jobExtension = HostContext.CreateService&lt;IJobExtension&gt;();
138                  List&lt;IStep&gt; jobSteps = null;
139                  try
140                  {
141                      Trace.Info(&quot;Initialize job. Getting all job steps.&quot;);
142                      jobSteps = await jobExtension.InitializeJob(jobContext, message);
143                  }
144                  catch (OperationCanceledException ex) when (jobContext.CancellationToken.IsCancellationRequested)
145                  {
146                      Trace.Error($&quot;Job is cancelled during initialize.&quot;);
147                      Trace.Error($&quot;Caught exception: {ex}&quot;);
148                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Canceled);
149                  }
150                  catch (Exception ex)
151                  {
152                      Trace.Error($&quot;Job initialize failed.&quot;);
153                      Trace.Error($&quot;Caught exception from {nameof(jobExtension.InitializeJob)}: {ex}&quot;);
154                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Failed);
155                  }
156                  Trace.Info($&quot;Total job steps: {jobSteps.Count}.&quot;);
157                  Trace.Verbose($&quot;Job steps: &#x27;{string.Join(&quot;, &quot;, jobSteps.Select(x =&gt; x.DisplayName))}&#x27;&quot;);
158                  HostContext.WritePerfCounter($&quot;WorkerJobInitialized_{message.RequestId.ToString()}&quot;);
159                  if (systemConnection.Data.TryGetValue(&quot;GenerateIdTokenUrl&quot;, out var generateIdTokenUrl) &amp;&amp;
160                      !string.IsNullOrEmpty(generateIdTokenUrl))
161                  {
162                      Trace.Info($&quot;Waiting for job to be marked as started.&quot;);
163                      await Task.WhenAny(_jobServerQueue.JobRecordUpdated.Task, Task.Delay(1000));
164                  }
165                  Trace.Info(&quot;Run all job steps.&quot;);
166                  var stepsRunner = HostContext.GetService&lt;IStepsRunner&gt;();
167                  try
168                  {
169                      foreach (var step in jobSteps)
170                      {
171                          jobContext.JobSteps.Enqueue(step);
172                      }
173                      await stepsRunner.RunAsync(jobContext);
174                  }
175                  catch (Exception ex)
176                  {
177                      Trace.Error($&quot;Caught exception from job steps {nameof(StepsRunner)}: {ex}&quot;);
178                      jobContext.Error(ex);
179                      return await CompleteJobAsync(server, jobContext, message, TaskResult.Failed);
180                  }
181                  finally
182                  {
183                      Trace.Info(&quot;Finalize job.&quot;);
184                      jobExtension.FinalizeJob(jobContext, message, jobStartTimeUtc);
185                  }
186                  Trace.Info($&quot;Job result after all job steps finish: {jobContext.Result ?? TaskResult.Succeeded}&quot;);
187                  Trace.Info(&quot;Completing the job execution context.&quot;);
188                  return await CompleteJobAsync(server, jobContext, message);
189              }
190              finally
191              {
192                  if (runnerShutdownRegistration != null)
193                  {
194                      runnerShutdownRegistration.Value.Dispose();
195                      runnerShutdownRegistration = null;
196                  }
197                  await ShutdownQueue(throwOnFailure: false);
198              }
199          }
200          private async Task&lt;TaskResult&gt; CompleteJobAsync(IRunnerService server, IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, TaskResult? taskResult = null)
201          {
202              if (server is IRunServer runServer)
203              {
204                  return await CompleteJobAsync(runServer, jobContext, message, taskResult);
205              }
206              else if (server is IJobServer jobServer)
207              {
208                  return await CompleteJobAsync(jobServer, jobContext, message, taskResult);
209              }
210              else
211              {
212                  throw new NotSupportedException();
213              }
214          }
215          private async Task&lt;TaskResult&gt; CompleteJobAsync(IRunServer runServer, IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, TaskResult? taskResult = null)
216          {
217              jobContext.Debug($&quot;Finishing: {message.JobDisplayName}&quot;);
218              TaskResult result = jobContext.Complete(taskResult);
219              if (jobContext.Global.Variables.TryGetValue(&quot;Node12ActionsWarnings&quot;, out var node12Warnings))
220              {
221                  var actions = string.Join(&quot;, &quot;, StringUtil.ConvertFromJson&lt;HashSet&lt;string&gt;&gt;(node12Warnings));
222                  jobContext.Warning(string.Format(Constants.Runner.Node12DetectedAfterEndOfLife, actions));
223              }
224              _tempDirectoryManager?.CleanupTempDirectory();
225              LoadFromTelemetryFile(jobContext.Global.JobTelemetry);
226              MaskTelemetrySecrets(jobContext.Global.JobTelemetry);
227              string environmentUrl = null;
228              if (jobContext.ActionsEnvironment?.Url is StringToken urlStringToken)
229              {
230                  environmentUrl = urlStringToken.Value;
231              }
232              Trace.Info($&quot;Raising job completed against run service&quot;);
233              var completeJobRetryLimit = 5;
234              var exceptions = new List&lt;Exception&gt;();
235              while (completeJobRetryLimit-- &gt; 0)
236              {
237                  try
238                  {
239                      await runServer.CompleteJobAsync(message.Plan.PlanId, message.JobId, result, jobContext.JobOutputs, jobContext.Global.StepsResult, jobContext.Global.JobAnnotations, environmentUrl, default);
240                      return result;
241                  }
242                  catch (Exception ex)
243                  {
244                      Trace.Error($&quot;Catch exception while attempting to complete job {message.JobId}, job request {message.RequestId}.&quot;);
245                      Trace.Error(ex);
246                      exceptions.Add(ex);
247                  }
248                  await Task.Delay(TimeSpan.FromSeconds(5));
249              }
250              throw new AggregateException(exceptions);
251          }
252          private async Task&lt;TaskResult&gt; CompleteJobAsync(IJobServer jobServer, IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, TaskResult? taskResult = null)
253          {
254              jobContext.Debug($&quot;Finishing: {message.JobDisplayName}&quot;);
255              TaskResult result = jobContext.Complete(taskResult);
256              if (_runnerSettings.DisableUpdate == true)
257              {
258                  try
259                  {
<span onclick='openModal()' class='match'>260                      var currentVersion = new PackageVersion(BuildConstants.RunnerPackage.Version);
261                      ServiceEndpoint systemConnection = message.Resources.Endpoints.Single(x =&gt; string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
</span>262                      VssCredentials serverCredential = VssUtil.GetVssCredential(systemConnection);
263                      var runnerServer = HostContext.GetService&lt;IRunnerServer&gt;();
264                      await runnerServer.ConnectAsync(systemConnection.Url, serverCredential);
265                      var serverPackages = await runnerServer.GetPackagesAsync(&quot;agent&quot;, BuildConstants.RunnerPackage.PackageName, 5, includeToken: false, cancellationToken: CancellationToken.None);
266                      if (serverPackages.Count &gt; 0)
267                      {
268                          serverPackages = serverPackages.OrderByDescending(x =&gt; x.Version).ToList();
269                          Trace.Info($&quot;Newer packages {StringUtil.ConvertToJson(serverPackages.Select(x =&gt; x.Version.ToString()))}&quot;);
270                          var warnOnFailedJob = false; 
271                          var warnOnOldRunnerVersion = false; 
272                          if (serverPackages.Any(x =&gt; x.Version.CompareTo(currentVersion) &gt; 0))
273                          {
274                              Trace.Info($&quot;Current runner version {currentVersion} is behind the latest runner version {serverPackages[0].Version}.&quot;);
275                              warnOnFailedJob = true;
276                          }
277                          if (serverPackages.Where(x =&gt; x.Version.Major == currentVersion.Major &amp;&amp; x.Version.Minor &gt; currentVersion.Minor).Count() &gt; 1)
278                          {
279                              Trace.Info($&quot;Current runner version {currentVersion} is way behind the latest runner version {serverPackages[0].Version}.&quot;);
280                              warnOnOldRunnerVersion = true;
281                          }
282                          if (result == TaskResult.Failed &amp;&amp; warnOnFailedJob)
283                          {
284                              jobContext.Warning($&quot;This job failure may be caused by using an out of date self-hosted runner. You are currently using runner version {currentVersion}. Please update to the latest version {serverPackages[0].Version}&quot;);
285                          }
286                          else if (warnOnOldRunnerVersion)
287                          {
288                              jobContext.Warning($&quot;This self-hosted runner is currently using runner version {currentVersion}. This version is out of date. Please update to the latest version {serverPackages[0].Version}&quot;);
289                          }
290                      }
291                  }
292                  catch (Exception ex)
293                  {
294                      Trace.Error($&quot;Caught exception during runner version check: {ex}&quot;);
295                  }
296              }
297              if (jobContext.Global.Variables.TryGetValue(&quot;Node12ActionsWarnings&quot;, out var node12Warnings))
298              {
299                  var actions = string.Join(&quot;, &quot;, StringUtil.ConvertFromJson&lt;HashSet&lt;string&gt;&gt;(node12Warnings));
300                  jobContext.Warning(string.Format(Constants.Runner.Node12DetectedAfterEndOfLife, actions));
301              }
302              try
303              {
304                  await ShutdownQueue(throwOnFailure: true);
305              }
306              catch (Exception ex)
307              {
308                  Trace.Error($&quot;Caught exception from {nameof(JobServerQueue)}.{nameof(_jobServerQueue.ShutdownAsync)}&quot;);
309                  Trace.Error(&quot;This indicate a failure during publish output variables. Fail the job to prevent unexpected job outputs.&quot;);
310                  Trace.Error(ex);
311                  result = TaskResultUtil.MergeTaskResults(result, TaskResult.Failed);
312              }
313              _tempDirectoryManager?.CleanupTempDirectory();
314              if (!jobContext.Global.Features.HasFlag(PlanFeatures.JobCompletedPlanEvent))
315              {
316                  Trace.Info($&quot;Skip raise job completed event call from worker because Plan version is {message.Plan.Version}&quot;);
317                  return result;
318              }
319              LoadFromTelemetryFile(jobContext.Global.JobTelemetry);
320              MaskTelemetrySecrets(jobContext.Global.JobTelemetry);
321              Trace.Info($&quot;Raising job completed event&quot;);
322              var jobCompletedEvent = new JobCompletedEvent(message.RequestId, message.JobId, result, jobContext.JobOutputs, jobContext.ActionsEnvironment, jobContext.Global.StepsTelemetry, jobContext.Global.JobTelemetry);
323              var completeJobRetryLimit = 5;
324              var exceptions = new List&lt;Exception&gt;();
325              while (completeJobRetryLimit-- &gt; 0)
326              {
327                  try
328                  {
329                      await jobServer.RaisePlanEventAsync(message.Plan.ScopeIdentifier, message.Plan.PlanType, message.Plan.PlanId, jobCompletedEvent, default(CancellationToken));
330                      return result;
331                  }
332                  catch (TaskOrchestrationPlanNotFoundException ex)
333                  {
334                      Trace.Error($&quot;TaskOrchestrationPlanNotFoundException received, while attempting to raise JobCompletedEvent for job {message.JobId}.&quot;);
335                      Trace.Error(ex);
336                      return TaskResult.Failed;
337                  }
338                  catch (TaskOrchestrationPlanSecurityException ex)
339                  {
340                      Trace.Error($&quot;TaskOrchestrationPlanSecurityException received, while attempting to raise JobCompletedEvent for job {message.JobId}.&quot;);
341                      Trace.Error(ex);
342                      return TaskResult.Failed;
343                  }
344                  catch (TaskOrchestrationPlanTerminatedException ex)
345                  {
346                      Trace.Error($&quot;TaskOrchestrationPlanTerminatedException received, while attempting to raise JobCompletedEvent for job {message.JobId}.&quot;);
347                      Trace.Error(ex);
348                      return TaskResult.Failed;
349                  }
350                  catch (Exception ex)
351                  {
352                      Trace.Error($&quot;Catch exception while attempting to raise JobCompletedEvent for job {message.JobId}, job request {message.RequestId}.&quot;);
353                      Trace.Error(ex);
354                      exceptions.Add(ex);
355                  }
356                  await Task.Delay(TimeSpan.FromSeconds(5));
357              }
358              throw new AggregateException(exceptions);
359          }
360          private void MaskTelemetrySecrets(List&lt;JobTelemetry&gt; jobTelemetry)
361          {
362              foreach (var telemetryItem in jobTelemetry)
363              {
364                  telemetryItem.Message = HostContext.SecretMasker.MaskSecrets(telemetryItem.Message);
365              }
366          }
367          private void LoadFromTelemetryFile(List&lt;JobTelemetry&gt; jobTelemetry)
368          {
369              try
370              {
371                  var telemetryFilePath = HostContext.GetConfigFile(WellKnownConfigFile.Telemetry);
372                  if (File.Exists(telemetryFilePath))
373                  {
374                      var telemetryData = File.ReadAllText(telemetryFilePath, Encoding.UTF8);
375                      var telemetry = new JobTelemetry
376                      {
377                          Message = $&quot;Runner File Telemetry:\n{telemetryData}&quot;,
378                          Type = JobTelemetryType.General
379                      };
380                      jobTelemetry.Add(telemetry);
381                      IOUtil.DeleteFile(telemetryFilePath);
382                  }
383              }
384              catch (Exception e)
385              {
386                  Trace.Error(&quot;Error when trying to load telemetry from telemetry file&quot;);
387                  Trace.Error(e);
388              }
389          }
390          private async Task ShutdownQueue(bool throwOnFailure)
391          {
392              if (_jobServerQueue != null)
393              {
394                  try
395                  {
396                      Trace.Info(&quot;Shutting down the job server queue.&quot;);
397                      await _jobServerQueue.ShutdownAsync();
398                  }
399                  catch (Exception ex) when (!throwOnFailure)
400                  {
401                      Trace.Error($&quot;Caught exception from {nameof(JobServerQueue)}.{nameof(_jobServerQueue.ShutdownAsync)}&quot;);
402                      Trace.Error(ex);
403                  }
404                  finally
405                  {
406                      _jobServerQueue = null; 
407                  }
408              }
409          }
410      }
411  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-CookieConsentTests.cs</h3>
            <pre><code>1  using System;
2  using System.IO;
3  using System.Threading.Tasks;
4  using Microsoft.AspNetCore.Builder;
5  using Microsoft.AspNetCore.Hosting;
6  using Microsoft.AspNetCore.Http;
7  using Microsoft.AspNetCore.Http.Features;
8  using Microsoft.AspNetCore.TestHost;
9  using Microsoft.Extensions.DependencyInjection;
10  using Microsoft.Net.Http.Headers;
11  using Xunit;
12  namespace Microsoft.AspNetCore.CookiePolicy.Test
13  {
14      public class CookieConsentTests
15      {
16          [Fact]
17          public async Task ConsentChecksOffByDefault()
18          {
19              var httpContext = await RunTestAsync(options =&gt; { }, requestContext =&gt; { }, context =&gt;
20              {
21                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
22                  Assert.False(feature.IsConsentNeeded);
23                  Assert.False(feature.HasConsent);
24                  Assert.True(feature.CanTrack);
25                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
26                  return Task.CompletedTask;
27              });
28              Assert.Equal(&quot;Test=Value; path=/; samesite=lax&quot;, httpContext.Response.Headers[HeaderNames.SetCookie]);
29          }
30          [Fact]
31          public async Task ConsentEnabledForTemplateScenario()
32          {
33              var httpContext = await RunTestAsync(options =&gt;
34              {
35                  options.CheckConsentNeeded = context =&gt; true;
36              },
37              requestContext =&gt; { }, context =&gt;
38              {
39                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
40                  Assert.True(feature.IsConsentNeeded);
41                  Assert.False(feature.HasConsent);
42                  Assert.False(feature.CanTrack);
43                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
44                  return Task.CompletedTask;
45              });
46              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
47          }
48          [Fact]
49          public async Task NonEssentialCookiesWithOptionsExcluded()
50          {
51              var httpContext = await RunTestAsync(options =&gt;
52              {
53                  options.CheckConsentNeeded = context =&gt; true;
54              },
55              requestContext =&gt; { }, context =&gt;
56              {
57                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
58                  Assert.True(feature.IsConsentNeeded);
59                  Assert.False(feature.HasConsent);
60                  Assert.False(feature.CanTrack);
61                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;, new CookieOptions() { IsEssential = false });
62                  return Task.CompletedTask;
63              });
64              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
65          }
66          [Fact]
67          public async Task NonEssentialCookiesCanBeAllowedViaOnAppendCookie()
68          {
69              var httpContext = await RunTestAsync(options =&gt;
70              {
71                  options.CheckConsentNeeded = context =&gt; true;
72                  options.OnAppendCookie = context =&gt;
73                  {
74                      Assert.True(context.IsConsentNeeded);
75                      Assert.False(context.HasConsent);
76                      Assert.False(context.IssueCookie);
77                      context.IssueCookie = true;
78                  };
79              },
80              requestContext =&gt; { }, context =&gt;
81              {
82                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
83                  Assert.True(feature.IsConsentNeeded);
84                  Assert.False(feature.HasConsent);
85                  Assert.False(feature.CanTrack);
86                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;, new CookieOptions() { IsEssential = false });
87                  return Task.CompletedTask;
88              });
89              Assert.Equal(&quot;Test=Value; path=/; samesite=lax&quot;, httpContext.Response.Headers[HeaderNames.SetCookie]);
90          }
91          [Fact]
92          public async Task NeedsConsentDoesNotPreventEssentialCookies()
93          {
94              var httpContext = await RunTestAsync(options =&gt;
95              {
96                  options.CheckConsentNeeded = context =&gt; true;
97              },
98              requestContext =&gt; { }, context =&gt;
99              {
100                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
101                  Assert.True(feature.IsConsentNeeded);
102                  Assert.False(feature.HasConsent);
103                  Assert.False(feature.CanTrack);
104                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;, new CookieOptions() { IsEssential = true });
105                  return Task.CompletedTask;
106              });
107              Assert.Equal(&quot;Test=Value; path=/; samesite=lax&quot;, httpContext.Response.Headers[HeaderNames.SetCookie]);
108          }
109          [Fact]
110          public async Task EssentialCookiesCanBeExcludedByOnAppendCookie()
111          {
112              var httpContext = await RunTestAsync(options =&gt;
113              {
114                  options.CheckConsentNeeded = context =&gt; true;
115                  options.OnAppendCookie = context =&gt;
116                  {
117                      Assert.True(context.IsConsentNeeded);
118                      Assert.True(context.HasConsent);
119                      Assert.True(context.IssueCookie);
120                      context.IssueCookie = false;
121                  };
122              },
123              requestContext =&gt;
124              {
125                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=yes&quot;;
126              },
127              context =&gt;
128              {
129                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
130                  Assert.True(feature.IsConsentNeeded);
131                  Assert.True(feature.HasConsent);
132                  Assert.True(feature.CanTrack);
133                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;, new CookieOptions() { IsEssential = true });
134                  return Task.CompletedTask;
135              });
136              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
137          }
138          [Fact]
139          public async Task HasConsentReadsRequestCookie()
140          {
141              var httpContext = await RunTestAsync(options =&gt;
142              {
143                  options.CheckConsentNeeded = context =&gt; true;
144              },
145              requestContext =&gt;
146              {
147                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=yes&quot;;
148              },
149              context =&gt;
150              {
151                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
152                  Assert.True(feature.IsConsentNeeded);
153                  Assert.True(feature.HasConsent);
154                  Assert.True(feature.CanTrack);
155                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
156                  return Task.CompletedTask;
157              });
158              Assert.Equal(&quot;Test=Value; path=/; samesite=lax&quot;, httpContext.Response.Headers[HeaderNames.SetCookie]);
159          }
160          [Fact]
161          public async Task HasConsentIgnoresInvalidRequestCookie()
162          {
163              var httpContext = await RunTestAsync(options =&gt;
164              {
165                  options.CheckConsentNeeded = context =&gt; true;
166              },
167              requestContext =&gt;
168              {
169                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=IAmATeapot&quot;;
170              },
171              context =&gt;
172              {
173                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
174                  Assert.True(feature.IsConsentNeeded);
175                  Assert.False(feature.HasConsent);
176                  Assert.False(feature.CanTrack);
177                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
178                  return Task.CompletedTask;
179              });
180              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
181          }
182          [Fact]
183          public async Task GrantConsentSetsCookie()
184          {
185              var httpContext = await RunTestAsync(options =&gt;
186              {
187                  options.CheckConsentNeeded = context =&gt; true;
188              },
189              requestContext =&gt; { },
190              context =&gt;
191              {
192                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
193                  Assert.True(feature.IsConsentNeeded);
194                  Assert.False(feature.HasConsent);
195                  Assert.False(feature.CanTrack);
196                  feature.GrantConsent();
197                  Assert.True(feature.IsConsentNeeded);
198                  Assert.True(feature.HasConsent);
199                  Assert.True(feature.CanTrack);
200                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
201                  return Task.CompletedTask;
202              });
203              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
204              Assert.Equal(2, cookies.Count);
205              var consentCookie = cookies[0];
206              Assert.Equal(&quot;.AspNet.Consent&quot;, consentCookie.Name);
207              Assert.Equal(&quot;yes&quot;, consentCookie.Value);
208              Assert.True(consentCookie.Expires.HasValue);
209              Assert.True(consentCookie.Expires.Value &gt; DateTimeOffset.Now + TimeSpan.FromDays(364));
210              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, consentCookie.SameSite);
211              Assert.NotNull(consentCookie.Expires);
212              var testCookie = cookies[1];
213              Assert.Equal(&quot;Test&quot;, testCookie.Name);
214              Assert.Equal(&quot;Value&quot;, testCookie.Value);
215              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, testCookie.SameSite);
216              Assert.Null(testCookie.Expires);
217          }
218          [Fact]
219          public async Task GrantConsentAppliesPolicyToConsentCookie()
220          {
221              var httpContext = await RunTestAsync(options =&gt;
222              {
223                  options.CheckConsentNeeded = context =&gt; true;
224                  options.MinimumSameSitePolicy = Http.SameSiteMode.Strict;
225                  options.OnAppendCookie = context =&gt;
226                  {
227                      Assert.Equal(&quot;.AspNet.Consent&quot;, context.CookieName);
228                      Assert.Equal(&quot;yes&quot;, context.CookieValue);
229                      Assert.Equal(Http.SameSiteMode.Strict, context.CookieOptions.SameSite);
230                      context.CookieName += &quot;1&quot;;
231                      context.CookieValue += &quot;1&quot;;
232                  };
233              },
234              requestContext =&gt; { },
235              context =&gt;
236              {
237                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
238                  Assert.True(feature.IsConsentNeeded);
239                  Assert.False(feature.HasConsent);
240                  Assert.False(feature.CanTrack);
241                  feature.GrantConsent();
242                  Assert.True(feature.IsConsentNeeded);
243                  Assert.True(feature.HasConsent);
244                  Assert.True(feature.CanTrack);
245                  return Task.CompletedTask;
246              });
247              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
248              Assert.Equal(1, cookies.Count);
249              var consentCookie = cookies[0];
250              Assert.Equal(&quot;.AspNet.Consent1&quot;, consentCookie.Name);
251              Assert.Equal(&quot;yes1&quot;, consentCookie.Value);
252              Assert.Equal(Net.Http.Headers.SameSiteMode.Strict, consentCookie.SameSite);
253              Assert.NotNull(consentCookie.Expires);
254          }
255          [Fact]
256          public async Task GrantConsentWhenAlreadyHasItDoesNotSetCookie()
257          {
258              var httpContext = await RunTestAsync(options =&gt;
259              {
260                  options.CheckConsentNeeded = context =&gt; true;
261              },
262              requestContext =&gt;
263              {
264                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=yes&quot;;
265              },
266              context =&gt;
267              {
268                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
269                  Assert.True(feature.IsConsentNeeded);
270                  Assert.True(feature.HasConsent);
271                  Assert.True(feature.CanTrack);
272                  feature.GrantConsent();
273                  Assert.True(feature.IsConsentNeeded);
274                  Assert.True(feature.HasConsent);
275                  Assert.True(feature.CanTrack);
276                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
277                  return Task.CompletedTask;
278              });
279              Assert.Equal(&quot;Test=Value; path=/; samesite=lax&quot;, httpContext.Response.Headers[HeaderNames.SetCookie]);
280          }
281          [Fact]
282          public async Task GrantConsentAfterResponseStartsSetsHasConsentButDoesNotSetCookie()
283          {
284              var httpContext = await RunTestAsync(options =&gt;
285              {
286                  options.CheckConsentNeeded = context =&gt; true;
287              },
288              requestContext =&gt; { },
289              async context =&gt;
290              {
291                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
292                  Assert.True(feature.IsConsentNeeded);
293                  Assert.False(feature.HasConsent);
294                  Assert.False(feature.CanTrack);
295                  await context.Response.WriteAsync(&quot;Started.&quot;);
296                  feature.GrantConsent();
297                  Assert.True(feature.IsConsentNeeded);
298                  Assert.True(feature.HasConsent);
299                  Assert.True(feature.CanTrack);
300                  Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;));
301                  await context.Response.WriteAsync(&quot;Granted.&quot;);
302              });
<span onclick='openModal()' class='match'>303              var reader = new StreamReader(httpContext.Response.Body);
304              Assert.Equal(&quot;Started.Granted.&quot;, await reader.ReadToEndAsync());
</span>305              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
306          }
307          [Fact]
308          public async Task WithdrawConsentWhenNotHasConsentNoOps()
309          {
310              var httpContext = await RunTestAsync(options =&gt;
311              {
312                  options.CheckConsentNeeded = context =&gt; true;
313              },
314              requestContext =&gt; { },
315              context =&gt;
316              {
317                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
318                  Assert.True(feature.IsConsentNeeded);
319                  Assert.False(feature.HasConsent);
320                  Assert.False(feature.CanTrack);
321                  feature.WithdrawConsent();
322                  Assert.True(feature.IsConsentNeeded);
323                  Assert.False(feature.HasConsent);
324                  Assert.False(feature.CanTrack);
325                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value&quot;);
326                  return Task.CompletedTask;
327              });
328              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
329          }
330          [Fact]
331          public async Task WithdrawConsentDeletesCookie()
332          {
333              var httpContext = await RunTestAsync(options =&gt;
334              {
335                  options.CheckConsentNeeded = context =&gt; true;
336              },
337              requestContext =&gt;
338              {
339                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=yes&quot;;
340              },
341              context =&gt;
342              {
343                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
344                  Assert.True(feature.IsConsentNeeded);
345                  Assert.True(feature.HasConsent);
346                  Assert.True(feature.CanTrack);
347                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value1&quot;);
348                  feature.WithdrawConsent();
349                  Assert.True(feature.IsConsentNeeded);
350                  Assert.False(feature.HasConsent);
351                  Assert.False(feature.CanTrack);
352                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value2&quot;);
353                  return Task.CompletedTask;
354              });
355              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
356              Assert.Equal(2, cookies.Count);
357              var testCookie = cookies[0];
358              Assert.Equal(&quot;Test&quot;, testCookie.Name);
359              Assert.Equal(&quot;Value1&quot;, testCookie.Value);
360              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, testCookie.SameSite);
361              Assert.Null(testCookie.Expires);
362              var consentCookie = cookies[1];
363              Assert.Equal(&quot;.AspNet.Consent&quot;, consentCookie.Name);
364              Assert.Equal(&quot;&quot;, consentCookie.Value);
365              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, consentCookie.SameSite);
366              Assert.NotNull(consentCookie.Expires);
367          }
368          [Fact]
369          public async Task WithdrawConsentAppliesPolicyToDeleteCookie()
370          {
371              var httpContext = await RunTestAsync(options =&gt;
372              {
373                  options.CheckConsentNeeded = context =&gt; true;
374                  options.MinimumSameSitePolicy = Http.SameSiteMode.Strict;
375                  options.OnDeleteCookie = context =&gt;
376                  {
377                      Assert.Equal(&quot;.AspNet.Consent&quot;, context.CookieName);
378                      context.CookieName += &quot;1&quot;;
379                  };
380              },
381              requestContext =&gt;
382              {
383                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=yes&quot;;
384              },
385              context =&gt;
386              {
387                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
388                  Assert.True(feature.IsConsentNeeded);
389                  Assert.True(feature.HasConsent);
390                  Assert.True(feature.CanTrack);
391                  feature.WithdrawConsent();
392                  Assert.True(feature.IsConsentNeeded);
393                  Assert.False(feature.HasConsent);
394                  Assert.False(feature.CanTrack);
395                  return Task.CompletedTask;
396              });
397              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
398              Assert.Equal(1, cookies.Count);
399              var consentCookie = cookies[0];
400              Assert.Equal(&quot;.AspNet.Consent1&quot;, consentCookie.Name);
401              Assert.Equal(&quot;&quot;, consentCookie.Value);
402              Assert.Equal(Net.Http.Headers.SameSiteMode.Strict, consentCookie.SameSite);
403              Assert.NotNull(consentCookie.Expires);
404          }
405          [Fact]
406          public async Task WithdrawConsentAfterResponseHasStartedDoesNotDeleteCookie()
407          {
408              var httpContext = await RunTestAsync(options =&gt;
409              {
410                  options.CheckConsentNeeded = context =&gt; true;
411              },
412              requestContext =&gt;
413              {
414                  requestContext.Request.Headers[HeaderNames.Cookie] = &quot;.AspNet.Consent=yes&quot;;
415              },
416              async context =&gt;
417              {
418                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
419                  Assert.True(feature.IsConsentNeeded);
420                  Assert.True(feature.HasConsent);
421                  Assert.True(feature.CanTrack);
422                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value1&quot;);
423                  await context.Response.WriteAsync(&quot;Started.&quot;);
424                  feature.WithdrawConsent();
425                  Assert.True(feature.IsConsentNeeded);
426                  Assert.False(feature.HasConsent);
427                  Assert.False(feature.CanTrack);
428                  context.Response.Cookies.Append(&quot;Test&quot;, &quot;Value2&quot;);
429                  await context.Response.WriteAsync(&quot;Withdrawn.&quot;);
430              });
431              var reader = new StreamReader(httpContext.Response.Body);
432              Assert.Equal(&quot;Started.Withdrawn.&quot;, await reader.ReadToEndAsync());
433              Assert.Equal(&quot;Test=Value1; path=/; samesite=lax&quot;, httpContext.Response.Headers[HeaderNames.SetCookie]);
434          }
435          [Fact]
436          public async Task DeleteCookieDoesNotRequireConsent()
437          {
438              var httpContext = await RunTestAsync(options =&gt;
439              {
440                  options.CheckConsentNeeded = context =&gt; true;
441              },
442              requestContext =&gt; { },
443              context =&gt;
444              {
445                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
446                  Assert.True(feature.IsConsentNeeded);
447                  Assert.False(feature.HasConsent);
448                  Assert.False(feature.CanTrack);
449                  context.Response.Cookies.Delete(&quot;Test&quot;);
450                  return Task.CompletedTask;
451              });
452              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
453              Assert.Equal(1, cookies.Count);
454              var testCookie = cookies[0];
455              Assert.Equal(&quot;Test&quot;, testCookie.Name);
456              Assert.Equal(&quot;&quot;, testCookie.Value);
457              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, testCookie.SameSite);
458              Assert.NotNull(testCookie.Expires);
459          }
460          [Fact]
461          public async Task OnDeleteCookieCanSuppressCookie()
462          {
463              var httpContext = await RunTestAsync(options =&gt;
464              {
465                  options.CheckConsentNeeded = context =&gt; true;
466                  options.OnDeleteCookie = context =&gt;
467                  {
468                      Assert.True(context.IsConsentNeeded);
469                      Assert.False(context.HasConsent);
470                      Assert.True(context.IssueCookie);
471                      context.IssueCookie = false;
472                  };
473              },
474              requestContext =&gt; { },
475              context =&gt;
476              {
477                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
478                  Assert.True(feature.IsConsentNeeded);
479                  Assert.False(feature.HasConsent);
480                  Assert.False(feature.CanTrack);
481                  context.Response.Cookies.Delete(&quot;Test&quot;);
482                  return Task.CompletedTask;
483              });
484              Assert.Empty(httpContext.Response.Headers[HeaderNames.SetCookie]);
485          }
486          [Fact]
487          public async Task CreateConsentCookieMatchesGrantConsentCookie()
488          {
489              var httpContext = await RunTestAsync(options =&gt;
490              {
491                  options.CheckConsentNeeded = context =&gt; true;
492              },
493              requestContext =&gt; { },
494              context =&gt;
495              {
496                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
497                  Assert.True(feature.IsConsentNeeded);
498                  Assert.False(feature.HasConsent);
499                  Assert.False(feature.CanTrack);
500                  feature.GrantConsent();
501                  Assert.True(feature.IsConsentNeeded);
502                  Assert.True(feature.HasConsent);
503                  Assert.True(feature.CanTrack);
504                  var cookie = feature.CreateConsentCookie();
505                  context.Response.Headers[&quot;ManualCookie&quot;] = cookie;
506                  return Task.CompletedTask;
507              });
508              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
509              Assert.Equal(1, cookies.Count);
510              var consentCookie = cookies[0];
511              Assert.Equal(&quot;.AspNet.Consent&quot;, consentCookie.Name);
512              Assert.Equal(&quot;yes&quot;, consentCookie.Value);
513              Assert.Equal(Net.Http.Headers.SameSiteMode.Lax, consentCookie.SameSite);
514              Assert.NotNull(consentCookie.Expires);
515              cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[&quot;ManualCookie&quot;]);
516              Assert.Equal(1, cookies.Count);
517              var manualCookie = cookies[0];
518              Assert.Equal(consentCookie.Name, manualCookie.Name);
519              Assert.Equal(consentCookie.Value, manualCookie.Value);
520              Assert.Equal(consentCookie.SameSite, manualCookie.SameSite);
521              Assert.NotNull(manualCookie.Expires); 
522          }
523          [Fact]
524          public async Task CreateConsentCookieAppliesPolicy()
525          {
526              var httpContext = await RunTestAsync(options =&gt;
527              {
528                  options.CheckConsentNeeded = context =&gt; true;
529                  options.MinimumSameSitePolicy = Http.SameSiteMode.Strict;
530                  options.OnAppendCookie = context =&gt;
531                  {
532                      Assert.Equal(&quot;.AspNet.Consent&quot;, context.CookieName);
533                      Assert.Equal(&quot;yes&quot;, context.CookieValue);
534                      Assert.Equal(Http.SameSiteMode.Strict, context.CookieOptions.SameSite);
535                      context.CookieName += &quot;1&quot;;
536                      context.CookieValue += &quot;1&quot;;
537                  };
538              },
539              requestContext =&gt; { },
540              context =&gt;
541              {
542                  var feature = context.Features.Get&lt;ITrackingConsentFeature&gt;();
543                  Assert.True(feature.IsConsentNeeded);
544                  Assert.False(feature.HasConsent);
545                  Assert.False(feature.CanTrack);
546                  feature.GrantConsent();
547                  Assert.True(feature.IsConsentNeeded);
548                  Assert.True(feature.HasConsent);
549                  Assert.True(feature.CanTrack);
550                  var cookie = feature.CreateConsentCookie();
551                  context.Response.Headers[&quot;ManualCookie&quot;] = cookie;
552                  return Task.CompletedTask;
553              });
554              var cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[HeaderNames.SetCookie]);
555              Assert.Equal(1, cookies.Count);
556              var consentCookie = cookies[0];
557              Assert.Equal(&quot;.AspNet.Consent1&quot;, consentCookie.Name);
558              Assert.Equal(&quot;yes1&quot;, consentCookie.Value);
559              Assert.Equal(Net.Http.Headers.SameSiteMode.Strict, consentCookie.SameSite);
560              Assert.NotNull(consentCookie.Expires);
561              cookies = SetCookieHeaderValue.ParseList(httpContext.Response.Headers[&quot;ManualCookie&quot;]);
562              Assert.Equal(1, cookies.Count);
563              var manualCookie = cookies[0];
564              Assert.Equal(consentCookie.Name, manualCookie.Name);
565              Assert.Equal(consentCookie.Value, manualCookie.Value);
566              Assert.Equal(consentCookie.SameSite, manualCookie.SameSite);
567              Assert.NotNull(manualCookie.Expires); 
568          }
569          private Task&lt;HttpContext&gt; RunTestAsync(Action&lt;CookiePolicyOptions&gt; configureOptions, Action&lt;HttpContext&gt; configureRequest, RequestDelegate handleRequest)
570          {
571              var builder = new WebHostBuilder()
572                  .ConfigureServices(services =&gt;
573                  {
574                      services.Configure(configureOptions);
575                  })
576                  .Configure(app =&gt;
577                  {
578                      app.UseCookiePolicy();
579                      app.Run(handleRequest);
580                  });
581              var server = new TestServer(builder);
582              return server.SendAsync(configureRequest);
583          }
584      }
585  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobRunner.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-CookieConsentTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>260                      var currentVersion = new PackageVersion(BuildConstants.RunnerPackage.Version);
261                      ServiceEndpoint systemConnection = message.Resources.Endpoints.Single(x =&gt; string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
</pre></code></div>
                <div class="column column_space"><pre><code>303              var reader = new StreamReader(httpContext.Response.Body);
304              Assert.Equal(&quot;Started.Granted.&quot;, await reader.ReadToEndAsync());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    