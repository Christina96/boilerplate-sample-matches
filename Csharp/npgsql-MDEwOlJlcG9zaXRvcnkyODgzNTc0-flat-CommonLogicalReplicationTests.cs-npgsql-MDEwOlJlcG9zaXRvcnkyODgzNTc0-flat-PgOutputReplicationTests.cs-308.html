
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonLogicalReplicationTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading.Tasks;
4  using NUnit.Framework;
5  using Npgsql.Replication;
6  using Npgsql.Replication.Internal;
7  using NpgsqlTypes;
8  namespace Npgsql.Tests.Replication;
9  [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Replication tests are flaky in CI on Mac&quot;)]
10  [NonParallelizable]
11  public class CommonLogicalReplicationTests : SafeReplicationTestBase&lt;LogicalReplicationConnection&gt;
12  {
13      const string OutputPlugin = &quot;test_decoding&quot;;
14      [Test]
15      public Task CreateLogicalReplicationSlot([Values]bool temporary, [Values]bool twoPhase)
16          =&gt; SafeReplicationTest(
17              async (slotName, _) =&gt;
18              {
19                  await using var c = await OpenConnectionAsync();
20                  if (twoPhase)
21                      TestUtil.MinimumPgVersion(c, &quot;15.0&quot;, &quot;Replication slots with two phase commit support were introduced in PostgreSQL 15&quot;);
22                  if (temporary)
23                      TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;Temporary replication slots were introduced in PostgreSQL 10&quot;);
24                  await using var rc = await OpenReplicationConnectionAsync();
25                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, twoPhase: twoPhase);
26                  using var cmd =
27                      new NpgsqlCommand($&quot;SELECT * FROM pg_replication_slots WHERE slot_name = &#x27;{options.SlotName}&#x27;&quot;,
28                          c);
29                  await using var reader = await cmd.ExecuteReaderAsync();
30                  Assert.That(reader.Read, Is.True);
31                  Assert.That(reader.GetFieldValue&lt;string&gt;(reader.GetOrdinal(&quot;slot_type&quot;)), Is.EqualTo(&quot;logical&quot;));
32                  if (c.PostgreSqlVersion &gt;= Version.Parse(&quot;15.0&quot;))
33                      Assert.That(reader.GetFieldValue&lt;bool&gt;(reader.GetOrdinal(&quot;two_phase&quot;)), Is.EqualTo(twoPhase));
34                  if (c.PostgreSqlVersion &gt;= Version.Parse(&quot;10.0&quot;))
35                      Assert.That(reader.GetFieldValue&lt;bool&gt;(reader.GetOrdinal(&quot;temporary&quot;)), Is.EqualTo(temporary));
36                  Assert.That(reader.GetFieldValue&lt;bool&gt;(reader.GetOrdinal(&quot;active&quot;)), Is.EqualTo(temporary));
37                  if (c.PostgreSqlVersion &gt;= Version.Parse(&quot;9.6&quot;))
38                      Assert.That(reader.GetFieldValue&lt;NpgsqlLogSequenceNumber&gt;(reader.GetOrdinal(&quot;confirmed_flush_lsn&quot;)),
39                          Is.EqualTo(options.ConsistentPoint));
40                  Assert.That(reader.Read, Is.False);
41              }, nameof(CreateLogicalReplicationSlot) + (temporary ? &quot;_tmp&quot; : &quot;&quot;) + (twoPhase ? &quot;_tp&quot; : &quot;&quot;));
42      [Test]
43      public Task CreateLogicalReplicationSlot_NoExport([Values]bool temporary, [Values]bool twoPhase)
44          =&gt; SafeReplicationTest(
45              async (slotName, _) =&gt;
46              {
47                  await using var c = await OpenConnectionAsync();
48                  if (temporary)
49                      TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;Temporary replication slots were introduced in PostgreSQL 10&quot;);
50                  if (twoPhase)
51                      TestUtil.MinimumPgVersion(c, &quot;15.0&quot;, &quot;Replication slots with two phase commit support were introduced in PostgreSQL 15&quot;);
52                  TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;The *_SNAPSHOT syntax was introduced in PostgreSQL 10&quot;);
53                  await using var rc = await OpenReplicationConnectionAsync();
54                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, LogicalSlotSnapshotInitMode.NoExport, twoPhase);
55                  Assert.That(options.SnapshotName, Is.Null);
56              }, nameof(CreateLogicalReplicationSlot_NoExport) + (temporary ? &quot;_tmp&quot; : &quot;&quot;) + (twoPhase ? &quot;_tp&quot; : &quot;&quot;));
57      [Test(Description = &quot;Tests whether we throw a helpful exception about the unsupported *_SNAPSHOT syntax on old servers.&quot;)]
58      [TestCase(LogicalSlotSnapshotInitMode.Export)]
59      [TestCase(LogicalSlotSnapshotInitMode.NoExport)]
60      [TestCase(LogicalSlotSnapshotInitMode.Use)]
61      public Task CreateLogicalReplicationSlot_with_SnapshotInitMode_on_old_postgres_throws(LogicalSlotSnapshotInitMode mode)
62          =&gt; SafeReplicationTest(
63              async (slotName, _) =&gt;
64              {
65                  await using var c = await OpenConnectionAsync();
66                  TestUtil.MaximumPgVersionExclusive(c, &quot;10.0&quot;, &quot;The *_SNAPSHOT syntax was introduced in PostgreSQL 10&quot;);
67                  Assert.That(async () =&gt;
68                  {
69                      await using var rc = await OpenReplicationConnectionAsync();
70                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, slotSnapshotInitMode: mode);
71                  }, Throws.InstanceOf&lt;NotSupportedException&gt;()
72                      .With.Message.StartsWith(&quot;The EXPORT_SNAPSHOT, USE_SNAPSHOT and NOEXPORT_SNAPSHOT syntax was introduced in PostgreSQL&quot;)
73                      .And.InnerException.TypeOf&lt;PostgresException&gt;()
74                      .And.InnerException.Property(&quot;SqlState&quot;).EqualTo(PostgresErrorCodes.SyntaxError));
75              });
76      [Test(Description = &quot;Tests whether we throw a helpful exception about unsupported temporary replication slots on old servers.&quot;)]
77      public Task CreateLogicalReplicationSlot_with_isTemporary_set_to_true_on_old_postgres_throws()
78          =&gt; SafeReplicationTest(
79              async (slotName, _) =&gt;
80              {
81                  await using var c = await OpenConnectionAsync();
82                  TestUtil.MaximumPgVersionExclusive(c, &quot;10.0&quot;, &quot;Temporary replication slots were introduced in PostgreSQL 10&quot;);
83                  Assert.That(async () =&gt;
84                  {
85                      await using var rc = await OpenReplicationConnectionAsync();
86                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, isTemporary: true);
87                  }, Throws.InstanceOf&lt;NotSupportedException&gt;()
88                      .With.Message.StartsWith(&quot;Temporary replication slots were introduced in PostgreSQL&quot;)
89                      .And.InnerException.TypeOf&lt;PostgresException&gt;()
90                      .And.InnerException.Property(&quot;SqlState&quot;).EqualTo(PostgresErrorCodes.SyntaxError));
91              });
92      [Test(Description = &quot;Tests whether we throw a helpful exception about the unsupported TWO_PHASE syntax on old servers.&quot;)]
93      public Task CreateLogicalReplicationSlot_with_twoPhase_set_to_true_on_old_postgres_throws()
94          =&gt; SafeReplicationTest(
95              async (slotName, _) =&gt;
96              {
97                  await using var c = await OpenConnectionAsync();
98                  TestUtil.MaximumPgVersionExclusive(c, &quot;15.0&quot;,
99                      &quot;Logical replication support for prepared transactions was  introduced in PostgreSQL 15&quot;);
100                  Assert.That(async () =&gt;
101                  {
102                      await using var rc = await OpenReplicationConnectionAsync();
103                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, twoPhase: true);
104                  }, Throws.InstanceOf&lt;NotSupportedException&gt;()
105                      .With.Message.StartsWith(&quot;Logical replication support for prepared transactions was introduced in PostgreSQL&quot;)
106                      .And.InnerException.TypeOf&lt;PostgresException&gt;()
107                      .And.InnerException.Property(&quot;SqlState&quot;).EqualTo(PostgresErrorCodes.SyntaxError));
108              });
109      [Test(Description = &quot;We can use the exported snapshot to query the database in the very moment the replication slot was created.&quot;)]
110      public Task CreateLogicalReplicationSlot_Export([Values]bool temporary, [Values]bool twoPhase, [Values]bool implicitInitMode)
111          =&gt; SafeReplicationTest(
112              async (slotName, tableName) =&gt;
113              {
114                  await using var c = await OpenConnectionAsync();
115                  if (temporary)
<span onclick='openModal()' class='match'>116                      TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;Temporary replication slots were introduced in PostgreSQL 10&quot;);
117                  if (twoPhase)
118                      TestUtil.MinimumPgVersion(c, &quot;15.0&quot;, &quot;Replication slots with two phase commit support were introduced in PostgreSQL 15&quot;);
</span>119                  if (!implicitInitMode)
120                      TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;The *_SNAPSHOT syntax was introduced in PostgreSQL 10&quot;);
121                  await using (var transaction = c.BeginTransaction())
122                  {
123                      await c.ExecuteNonQueryAsync($&quot;CREATE TABLE {tableName} (value text)&quot;);
124                      await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} (value) VALUES(&#x27;Before snapshot&#x27;)&quot;);
125                      transaction.Commit();
126                  }
127                  await using var rc = await OpenReplicationConnectionAsync();
128                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, implicitInitMode ? null : LogicalSlotSnapshotInitMode.Export, twoPhase);
129                  await using (var transaction = c.BeginTransaction())
130                  {
131                      await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} (value) VALUES(&#x27;After snapshot&#x27;)&quot;);
132                      transaction.Commit();
133                  }
134                  await using (var transaction = c.BeginTransaction(IsolationLevel.RepeatableRead))
135                  {
136                      await c.ExecuteScalarAsync($&quot;SET TRANSACTION SNAPSHOT &#x27;{options.SnapshotName}&#x27;;&quot;, transaction);
137                      using var cmd = new NpgsqlCommand($&quot;SELECT value FROM {tableName}&quot;, c, transaction);
138                      await using var reader = await cmd.ExecuteReaderAsync();
139                      Assert.That(reader.Read, Is.True);
140                      Assert.That(reader.GetFieldValue&lt;string&gt;(0), Is.EqualTo(&quot;Before snapshot&quot;));
141                      Assert.That(reader.Read, Is.False);
142                  }
143              }, nameof(CreateLogicalReplicationSlot_Export) + (temporary ? &quot;_tmp&quot; : &quot;&quot;) + (twoPhase ? &quot;_tp&quot; : &quot;&quot;) + (implicitInitMode ? &quot;_i&quot; : &quot;&quot;));
144      [Test(Description = &quot;Since we currently don&#x27;t provide an API to start a transaction on a logical replication connection, &quot; +
145                          &quot;USE_SNAPSHOT currently doesn&#x27;t work and always leads to an exception. On the other hand, starting&quot; +
146                          &quot;a transaction would only be useful if we&#x27;d also provide an API to issue commands.&quot;)]
147      public Task CreateLogicalReplicationSlot_Use([Values]bool temporary, [Values]bool twoPhase)
148          =&gt; SafeReplicationTest(
149              async (slotName, _) =&gt;
150              {
151                  await using var c = await OpenConnectionAsync();
152                  if (temporary)
153                      TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;Temporary replication slots were introduced in PostgreSQL 10&quot;);
154                  if (twoPhase)
155                      TestUtil.MinimumPgVersion(c, &quot;15.0&quot;, &quot;Replication slots with two phase commit support were introduced in PostgreSQL 15&quot;);
156                  TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;The *_SNAPSHOT syntax was introduced in PostgreSQL 10&quot;);
157                  Assert.That(async () =&gt;
158                  {
159                      await using var rc = await OpenReplicationConnectionAsync();
160                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, LogicalSlotSnapshotInitMode.Use, twoPhase);
161                  }, Throws.InstanceOf&lt;PostgresException&gt;()
162                      .With.Property(&quot;SqlState&quot;)
163                      .EqualTo(&quot;XX000&quot;)
164                      .And.Message.Contains(
165                          c.PostgreSqlVersion.Major &lt; 15
166                              ? &quot;USE_SNAPSHOT&quot;
167                              : &quot;(SNAPSHOT &#x27;use&#x27;)&quot;
168                          ));
169              }, nameof(CreateLogicalReplicationSlot_Use) + (temporary ? &quot;_tmp&quot; : &quot;&quot;) + (twoPhase ? &quot;_tp&quot; : &quot;&quot;));
170      [Test]
171      public void CreateLogicalReplicationSlot_with_null_slot_throws()
172          =&gt; Assert.That(async () =&gt;
173          {
174              await using var rc = await OpenReplicationConnectionAsync();
175              await rc.CreateLogicalReplicationSlot(null!, OutputPlugin);
176          }, Throws.ArgumentNullException
177              .With.Property(&quot;ParamName&quot;)
178              .EqualTo(&quot;slotName&quot;));
179      [Test]
180      public Task CreateLogicalReplicationSlot_with_null_output_plugin_throws()
181          =&gt; SafeReplicationTest(
182              (slotName, _) =&gt;
183              {
184                  Assert.That(async () =&gt;
185                  {
186                      await using var rc = await OpenReplicationConnectionAsync();
187                      await rc.CreateLogicalReplicationSlot(slotName, null!);
188                  }, Throws.ArgumentNullException
189                      .With.Property(&quot;ParamName&quot;)
190                      .EqualTo(&quot;outputPlugin&quot;));
191                  return Task.CompletedTask;
192              });
193      [Test]
194      public Task CreateLogicalReplicationSlot_with_cancelled_token()
195          =&gt; SafeReplicationTest(
196              (slotName, _) =&gt;
197              {
198                  Assert.That(async () =&gt;
199                  {
200                      await using var rc = await OpenReplicationConnectionAsync();
201                      var token = GetCancelledCancellationToken();
202                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, cancellationToken: token);
203                  }, Throws.Exception.AssignableTo&lt;OperationCanceledException&gt;());
204                  return Task.CompletedTask;
205              });
206      [Test]
207      public Task CreateLogicalReplicationSlot_with_invalid_SnapshotInitMode_throws()
208          =&gt; SafeReplicationTest(
209              (slotName, _) =&gt;
210              {
211                  Assert.That(async () =&gt;
212                  {
213                      await using var rc = await OpenReplicationConnectionAsync();
214                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, slotSnapshotInitMode: (LogicalSlotSnapshotInitMode)42);
215                  }, Throws.InstanceOf&lt;ArgumentOutOfRangeException&gt;()
216                      .With.Property(&quot;ParamName&quot;)
217                      .EqualTo(&quot;slotSnapshotInitMode&quot;)
218                      .And.Property(&quot;ActualValue&quot;)
219                      .EqualTo((LogicalSlotSnapshotInitMode)42));
220                  return Task.CompletedTask;
221              });
222      [Test]
223      public Task CreateLogicalReplicationSlot_with_disposed_connection_throws()
224          =&gt; SafeReplicationTest(
225              (slotName, _) =&gt;
226              {
227                  Assert.That(async () =&gt;
228                  {
229                      var rc = await OpenReplicationConnectionAsync();
230                      await rc.DisposeAsync();
231                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin);
232                  }, Throws.InstanceOf&lt;ObjectDisposedException&gt;()
233                      .With.Property(nameof(ObjectDisposedException.ObjectName))
234                      .EqualTo(nameof(LogicalReplicationConnection)));
235                  return Task.CompletedTask;
236              });
237      protected override string Postfix =&gt; &quot;commonl_l&quot;;
238  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputReplicationTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Runtime.CompilerServices;
6  using System.Text;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using NUnit.Framework;
10  using Npgsql.Replication;
11  using Npgsql.Replication.PgOutput;
12  using Npgsql.Replication.PgOutput.Messages;
13  using TruncateOptions = Npgsql.Replication.PgOutput.Messages.TruncateMessage.TruncateOptions;
14  using ReplicaIdentitySetting = Npgsql.Replication.PgOutput.Messages.RelationMessage.ReplicaIdentitySetting;
15  using static Npgsql.Tests.TestUtil;
16  namespace Npgsql.Tests.Replication;
17  [TestFixture(ProtocolVersion.V1, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.DefaultTransactionMode)]
18  [TestFixture(ProtocolVersion.V1, ReplicationDataMode.BinaryReplicationDataMode, TransactionMode.DefaultTransactionMode)]
19  [TestFixture(ProtocolVersion.V2, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.StreamingTransactionMode)]
20  [TestFixture(ProtocolVersion.V3, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.DefaultTransactionMode)]
21  [TestFixture(ProtocolVersion.V3, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.StreamingTransactionMode)]
22  [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Replication tests are flaky in CI on Mac&quot;)]
23  [NonParallelizable] 
24  public class PgOutputReplicationTests : SafeReplicationTestBase&lt;LogicalReplicationConnection&gt;
25  {
26      readonly ulong _protocolVersion;
27      readonly bool? _binary;
28      readonly bool? _streaming;
29      bool IsBinary =&gt; _binary ?? false;
30      bool IsStreaming =&gt; _streaming ?? false;
31      ulong Version =&gt; _protocolVersion;
32      public PgOutputReplicationTests(ProtocolVersion protocolVersion, ReplicationDataMode dataMode, TransactionMode transactionMode)
33      {
34          _protocolVersion = (ulong)protocolVersion;
35          _binary = dataMode == ReplicationDataMode.BinaryReplicationDataMode
36              ? true
37              : dataMode == ReplicationDataMode.TextReplicationDataMode
38                  ? false
39                  : null;
40          _streaming = transactionMode == TransactionMode.StreamingTransactionMode
41              ? true
42              : transactionMode == TransactionMode.NonStreamingTransactionMode
43                  ? false
44                  : null;
45      }
46      [Test]
47      public Task CreatePgOutputReplicationSlot()
48      {
49          if (IsBinary || IsStreaming)
50              return Task.CompletedTask;
51          return SafeReplicationTest(
52              async (slotName, _) =&gt;
53              {
54                  await using var c = await OpenConnectionAsync();
55                  await using var rc = await OpenReplicationConnectionAsync();
56                  var options = await rc.CreatePgOutputReplicationSlot(slotName);
57                  using var cmd =
58                      new NpgsqlCommand($&quot;SELECT * FROM pg_replication_slots WHERE slot_name = &#x27;{options.Name}&#x27;&quot;,
59                          c);
60                  await using var reader = await cmd.ExecuteReaderAsync();
61                  Assert.That(reader.Read, Is.True);
62                  Assert.That(reader.GetFieldValue&lt;string&gt;(reader.GetOrdinal(&quot;slot_type&quot;)), Is.EqualTo(&quot;logical&quot;));
63                  Assert.That(reader.GetFieldValue&lt;string&gt;(reader.GetOrdinal(&quot;plugin&quot;)), Is.EqualTo(&quot;pgoutput&quot;));
64                  Assert.That(reader.Read, Is.False);
65              });
66      }
67      [Test(Description = &quot;Tests whether INSERT commands get replicated as Logical Replication Protocol Messages&quot;)]
68      public Task Insert()
69          =&gt; SafePgOutputReplicationTest(
70              async (slotName, tableName, publicationName) =&gt;
71              {
72                  await using var c = await OpenConnectionAsync();
73                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NULL);
74                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
75                  await using var rc = await OpenReplicationConnectionAsync();
76                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
77                  await using var tran = await c.BeginTransactionAsync();
78                  await c.ExecuteNonQueryAsync(@$&quot;INSERT INTO {tableName} VALUES (1, &#x27;val1&#x27;), (2, NULL), (3, &#x27;ignored&#x27;);
79                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(4, 15000) s(i);&quot;);
80                  await tran.CommitAsync();
81                  using var streamingCts = new CancellationTokenSource();
82                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
83                      .GetAsyncEnumerator();
84                  var transactionXid = await AssertTransactionStart(messages);
85                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
86                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
87                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
88                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
89                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
90                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
91                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
92                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
93                  var insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
94                  Assert.That(insertMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
95                  Assert.That(insertMsg.Relation, Is.SameAs(relationMsg));
96                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
97                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
98                  if (IsBinary)
99                      Assert.That(await columnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
100                  else
101                      Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
102                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
103                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
104                  Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1&quot;));
105                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
106                  insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
107                  Assert.That(insertMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
108                  Assert.That(insertMsg.Relation, Is.SameAs(relationMsg));
109                  columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
110                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
111                  if (IsBinary)
112                      Assert.That(await columnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(2));
113                  else
114                      Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;2&quot;));
115                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
116                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
117                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
118                  insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
119                  Assert.That(insertMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
120                  Assert.That(insertMsg.Relation, Is.SameAs(relationMsg));
121                  await foreach (var tuple in insertMsg.NewRow) 
122                      Assert.That(tuple.Kind, IsBinary ? Is.EqualTo(TupleDataKind.BinaryValue) : Is.EqualTo(TupleDataKind.TextValue));
123                  for (var insertCount = 0; insertCount &lt; 14997; insertCount++)
124                  {
125                      await NextMessage&lt;InsertMessage&gt;(messages);
126                  }
127                  await AssertTransactionCommit(messages);
128                  streamingCts.Cancel();
129                  await AssertReplicationCancellation(messages);
130                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
131              });
132      [Test(Description = &quot;Tests whether UPDATE commands get replicated as Logical Replication Protocol Messages for tables using the default replica identity&quot;)]
133      public Task Update_for_default_replica_identity()
134          =&gt; SafeReplicationTest(
135              async (slotName, tableName, publicationName) =&gt;
136              {
137                  await using var c = await OpenConnectionAsync();
138                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
139                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
140                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
141                  await using var rc = await OpenReplicationConnectionAsync();
142                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
143                  await using var tran = await c.BeginTransactionAsync();
144                  await c.ExecuteNonQueryAsync(@$&quot;UPDATE {tableName} SET name=&#x27;val1_updated&#x27; WHERE id = 1;
145                                                      UPDATE {tableName} SET name = md5(name) WHERE id &gt; 1&quot;);
146                  await tran.CommitAsync();
147                  using var streamingCts = new CancellationTokenSource();
148                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
149                      .GetAsyncEnumerator();
150                  var transactionXid = await AssertTransactionStart(messages);
151                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
152                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
153                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
154                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
155                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
156                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
157                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
158                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
159                  var updateMsg = await NextMessage&lt;DefaultUpdateMessage&gt;(messages);
160                  Assert.That(updateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
161                  Assert.That(updateMsg.Relation, Is.SameAs(relationMsg));
162                  var columnEnumerator = updateMsg.NewRow.GetAsyncEnumerator();
163                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
164                  if (IsBinary)
165                      Assert.That(await columnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
166                  else
167                      Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
168                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
169                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
170                  Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1_updated&quot;));
171                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
172                  for (var updateCount = 0; updateCount &lt; 14999; updateCount++)
173                      await NextMessage&lt;DefaultUpdateMessage&gt;(messages);
174                  await AssertTransactionCommit(messages);
175                  streamingCts.Cancel();
176                  await AssertReplicationCancellation(messages);
177                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
178              });
179      [Test(Description = &quot;Tests whether UPDATE commands get replicated as Logical Replication Protocol Messages for tables using an index as replica identity&quot;)]
180      public  Task Update_for_index_replica_identity()
181          =&gt; SafeReplicationTest(
182              async (slotName, tableName, publicationName) =&gt;
183              {
184                  await using var c = await OpenConnectionAsync();
185                  var indexName = $&quot;i_{tableName.Substring(2)}&quot;;
186                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
187                                                      CREATE UNIQUE INDEX {indexName} ON {tableName} (name);
188                                                      ALTER TABLE {tableName} REPLICA IDENTITY USING INDEX {indexName};
189                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
190                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
191                  await using var rc = await OpenReplicationConnectionAsync();
192                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
193                  await using var tran = await c.BeginTransactionAsync();
194                  await c.ExecuteNonQueryAsync(@$&quot;UPDATE {tableName} SET name=&#x27;val1_updated&#x27; WHERE id = 1;
195                                                      UPDATE {tableName} SET name = md5(name) WHERE id &gt; 1&quot;);
196                  await tran.CommitAsync();
197                  using var streamingCts = new CancellationTokenSource();
198                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
199                      .GetAsyncEnumerator();
200                  var transactionXid = await AssertTransactionStart(messages);
201                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
202                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
203                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.IndexWithIndIsReplIdent));
204                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
205                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
206                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
207                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
208                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
209                  var updateMsg = await NextMessage&lt;IndexUpdateMessage&gt;(messages);
210                  Assert.That(updateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
211                  Assert.That(updateMsg.Relation, Is.SameAs(relationMsg));
212                  var oldRowColumnEnumerator = updateMsg.Key.GetAsyncEnumerator();
213                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
214                  Assert.That(oldRowColumnEnumerator.Current.IsDBNull, Is.True);
215                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
216                  Assert.That(await oldRowColumnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1&quot;));
217                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.False);
218                  var newRowColumnEnumerator = updateMsg.NewRow.GetAsyncEnumerator();
219                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
220                  if (IsBinary)
221                      Assert.That(await newRowColumnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
222                  else
223                      Assert.That(await newRowColumnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
224                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
225                  Assert.That(await newRowColumnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1_updated&quot;));
226                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.False);
227                  for (var updateCount = 0; updateCount &lt; 14999; updateCount++)
228                      await NextMessage&lt;IndexUpdateMessage&gt;(messages);
229                  await AssertTransactionCommit(messages);
230                  streamingCts.Cancel();
231                  await AssertReplicationCancellation(messages);
232                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
233              });
234      [Test(Description = &quot;Tests whether UPDATE commands get replicated as Logical Replication Protocol Messages for tables using full replica identity&quot;)]
235      public  Task Update_for_full_replica_identity()
236          =&gt; SafeReplicationTest(
237              async (slotName, tableName, publicationName) =&gt;
238              {
239                  await using var c = await OpenConnectionAsync();
240                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
241                                                      ALTER TABLE {tableName} REPLICA IDENTITY FULL;
242                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
243                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
244                  await using var rc = await OpenReplicationConnectionAsync();
245                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
246                  await using var tran = await c.BeginTransactionAsync();
247                  await c.ExecuteNonQueryAsync(@$&quot;UPDATE {tableName} SET name=&#x27;val1_updated&#x27; WHERE id = 1;
248                                                      UPDATE {tableName} SET name = md5(name) WHERE id &gt; 1&quot;);
249                  await tran.CommitAsync();
250                  using var streamingCts = new CancellationTokenSource();
251                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
252                      .GetAsyncEnumerator();
253                  var transactionXid = await AssertTransactionStart(messages);
254                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
255                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
256                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.AllColumns));
257                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
258                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
259                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
260                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
261                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
262                  var updateMsg = await NextMessage&lt;FullUpdateMessage&gt;(messages);
263                  Assert.That(updateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
264                  Assert.That(updateMsg.Relation, Is.SameAs(relationMsg));
265                  var oldRowColumnEnumerator = updateMsg.OldRow.GetAsyncEnumerator();
266                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
267                  if (IsBinary)
268                      Assert.That(await oldRowColumnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
269                  else
270                      Assert.That(await oldRowColumnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
271                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
272                  Assert.That(await oldRowColumnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1&quot;));
273                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.False);
274                  var newRowColumnEnumerator = updateMsg.NewRow.GetAsyncEnumerator();
275                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
276                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
277                  Assert.That(await newRowColumnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1_updated&quot;));
278                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.False);
279                  for (var updateCount = 0; updateCount &lt; 14999; updateCount++)
280                      await NextMessage&lt;FullUpdateMessage&gt;(messages);
281                  await AssertTransactionCommit(messages);
282                  streamingCts.Cancel();
283                  Assert.That(async () =&gt; await messages.MoveNextAsync(), Throws.Exception.AssignableTo&lt;OperationCanceledException&gt;()
284                      .With.InnerException.InstanceOf&lt;PostgresException&gt;()
285                      .And.InnerException.Property(nameof(PostgresException.SqlState))
286                      .EqualTo(PostgresErrorCodes.QueryCanceled));
287                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
288              });
289      [Test(Description = &quot;Tests whether DELETE commands get replicated as Logical Replication Protocol Messages for tables using the default replica identity&quot;)]
290      public Task Delete_for_default_replica_identity()
291          =&gt; SafeReplicationTest(
292              async (slotName, tableName, publicationName) =&gt;
293              {
294                  await using var c = await OpenConnectionAsync();
295                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
296                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
297                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
298                  await using var rc = await OpenReplicationConnectionAsync();
299                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
300                  await using var tran = await c.BeginTransactionAsync();
301                  await c.ExecuteNonQueryAsync(@$&quot;DELETE FROM {tableName} WHERE id = 1;
302                                                      DELETE FROM {tableName} WHERE id &gt; 1&quot;);
303                  await tran.CommitAsync();
304                  using var streamingCts = new CancellationTokenSource();
305                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
306                      .GetAsyncEnumerator();
307                  var transactionXid = await AssertTransactionStart(messages);
308                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
309                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
310                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
311                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
312                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
313                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
314                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
315                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
316                  var deleteMsg = await NextMessage&lt;KeyDeleteMessage&gt;(messages);
317                  Assert.That(deleteMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
318                  Assert.That(deleteMsg.Relation, Is.SameAs(relationMsg));
319                  var columnEnumerator = deleteMsg.Key.GetAsyncEnumerator();
320                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
321                  if (IsBinary)
322                      Assert.That(await columnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
323                  else
324                      Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
325                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
326                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
327                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
328                  for (var deleteCount = 0; deleteCount &lt; 14999; deleteCount++)
329                      await NextMessage&lt;KeyDeleteMessage&gt;(messages);
330                  await AssertTransactionCommit(messages);
331                  streamingCts.Cancel();
332                  await AssertReplicationCancellation(messages);
333                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
334              });
335      [Test(Description = &quot;Tests whether DELETE commands get replicated as Logical Replication Protocol Messages for tables using an index as replica identity&quot;)]
336      public Task Delete_for_index_replica_identity()
337          =&gt; SafeReplicationTest(
338              async (slotName, tableName, publicationName) =&gt;
339              {
340                  await using var c = await OpenConnectionAsync();
341                  var indexName = $&quot;i_{tableName.Substring(2)}&quot;;
342                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
343                                                      CREATE UNIQUE INDEX {indexName} ON {tableName} (name);
344                                                      ALTER TABLE {tableName} REPLICA IDENTITY USING INDEX {indexName};
345                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
346                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
347                  await using var rc = await OpenReplicationConnectionAsync();
348                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
349                  await using var tran = await c.BeginTransactionAsync();
350                  await c.ExecuteNonQueryAsync(@$&quot;DELETE FROM {tableName} WHERE id = 1;
351                                                      DELETE FROM {tableName} WHERE id &gt; 1&quot;);
352                  await tran.CommitAsync();
353                  using var streamingCts = new CancellationTokenSource();
354                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
355                      .GetAsyncEnumerator();
356                  var transactionXid = await AssertTransactionStart(messages);
357                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
358                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
359                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.IndexWithIndIsReplIdent));
360                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
361                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
362                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
363                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
364                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
365                  var deleteMsg = await NextMessage&lt;KeyDeleteMessage&gt;(messages);
366                  Assert.That(deleteMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
367                  Assert.That(deleteMsg.Relation, Is.SameAs(relationMsg));
368                  var columnEnumerator = deleteMsg.Key.GetAsyncEnumerator();
369                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
370                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
371                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
372                  Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1&quot;));
373                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
374                  for (var deleteCount = 0; deleteCount &lt; 14999; deleteCount++)
375                      await NextMessage&lt;KeyDeleteMessage&gt;(messages);
376                  await AssertTransactionCommit(messages);
377                  streamingCts.Cancel();
378                  await AssertReplicationCancellation(messages);
379                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
380              });
381      [Test(Description = &quot;Tests whether DELETE commands get replicated as Logical Replication Protocol Messages for tables using full replica identity&quot;)]
382      public Task Delete_for_full_replica_identity()
383          =&gt; SafeReplicationTest(
384              async (slotName, tableName, publicationName) =&gt;
385              {
386                  await using var c = await OpenConnectionAsync();
387                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
388                                                      ALTER TABLE {tableName} REPLICA IDENTITY FULL;
389                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
390                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
391                  await using var rc = await OpenReplicationConnectionAsync();
392                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
393                  await using var tran = await c.BeginTransactionAsync();
394                  await c.ExecuteNonQueryAsync(@$&quot;DELETE FROM {tableName} WHERE id = 1;
395                                                      DELETE FROM {tableName} WHERE id &gt; 1&quot;);
396                  await tran.CommitAsync();
397                  using var streamingCts = new CancellationTokenSource();
398                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
399                      .GetAsyncEnumerator();
400                  var transactionXid = await AssertTransactionStart(messages);
401                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
402                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
403                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.AllColumns));
404                  Assert.That(relationMsg.Namespace, Is.EqualTo(&quot;public&quot;));
405                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
406                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
407                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
408                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
409                  var deleteMsg = await NextMessage&lt;FullDeleteMessage&gt;(messages);
410                  Assert.That(deleteMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
411                  Assert.That(deleteMsg.Relation, Is.SameAs(relationMsg));
412                  var columnEnumerator = deleteMsg.OldRow.GetAsyncEnumerator();
413                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
414                  if (IsBinary)
415                      Assert.That(await columnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
416                  else
417                      Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
418                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
419                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
420                  Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;val1&quot;));
421                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
422                  for (var deleteCount = 0; deleteCount &lt; 14999; deleteCount++)
423                      await NextMessage&lt;FullDeleteMessage&gt;(messages);
424                  await AssertTransactionCommit(messages);
425                  streamingCts.Cancel();
426                  await AssertReplicationCancellation(messages);
427                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
428              });
429      [Test(Description = &quot;Tests whether TRUNCATE commands get replicated as Logical Replication Protocol Messages on PostgreSQL 11 and above&quot;)]
430      [TestCase(TruncateOptions.None)]
431      [TestCase(TruncateOptions.Cascade)]
432      [TestCase(TruncateOptions.RestartIdentity)]
433      [TestCase(TruncateOptions.Cascade | TruncateOptions.RestartIdentity)]
434      public Task Truncate(TruncateOptions truncateOptionFlags)
435          =&gt; SafeReplicationTest(
436              async (slotName, tableName, publicationName) =&gt;
437              {
438                  await using var c = await OpenConnectionAsync();
439                  TestUtil.MinimumPgVersion(c, &quot;11.0&quot;, &quot;Replication of TRUNCATE commands was introduced in PostgreSQL 11&quot;);
440                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY, name TEXT NOT NULL);
441                                                      INSERT INTO {tableName} (name) VALUES (&#x27;val1&#x27;);
442                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
443                  await using var rc = await OpenReplicationConnectionAsync();
444                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
445                  var sb = new StringBuilder(&quot;TRUNCATE TABLE &quot;).Append(tableName);
446                  if (truncateOptionFlags.HasFlag(TruncateOptions.RestartIdentity))
447                      sb.Append(&quot; RESTART IDENTITY&quot;);
448                  if (truncateOptionFlags.HasFlag(TruncateOptions.Cascade))
449                      sb.Append(&quot; CASCADE&quot;);
450                  sb.Append($&quot;; INSERT INTO {tableName} (name) SELECT &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);&quot;);
451                  await using var tran = await c.BeginTransactionAsync();
452                  await c.ExecuteNonQueryAsync(sb.ToString());
453                  await tran.CommitAsync();
454                  using var streamingCts = new CancellationTokenSource();
455                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
456                      .GetAsyncEnumerator();
457                  var transactionXid = await AssertTransactionStart(messages);
458                  var relationMessage = await NextMessage&lt;RelationMessage&gt;(messages);
459                  Assert.That(relationMessage.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
460                  Assert.That(relationMessage.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
461                  Assert.That(relationMessage.Namespace, Is.EqualTo(&quot;public&quot;));
462                  Assert.That(relationMessage.RelationName, Is.EqualTo(tableName));
463                  Assert.That(relationMessage.Columns.Count, Is.EqualTo(2));
464                  Assert.That(relationMessage.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
465                  Assert.That(relationMessage.Columns[1].ColumnName, Is.EqualTo(&quot;name&quot;));
466                  var truncateMsg = await NextMessage&lt;TruncateMessage&gt;(messages);
467                  Assert.That(truncateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
468                  Assert.That(truncateMsg.Options, Is.EqualTo(truncateOptionFlags));
469                  Assert.That(truncateMsg.Relations.Single(), Is.SameAs(relationMessage));
470                  for (var insertCount = 0; insertCount &lt; 15000; insertCount++)
471                      await NextMessage&lt;InsertMessage&gt;(messages, expectRelationMessage: true);
472                  await AssertTransactionCommit(messages);
473                  streamingCts.Cancel();
474                  await AssertReplicationCancellation(messages);
475                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
476              }, nameof(Truncate) + truncateOptionFlags.ToString(&quot;D&quot;));
477      [Test(Description = &quot;Tests whether disposing while replicating will get us stuck forever.&quot;)]
478      public Task Dispose_while_replicating()
479          =&gt; SafeReplicationTest(
480              async (slotName, tableName, publicationName) =&gt;
481              {
482                  await using var c = await OpenConnectionAsync();
483                  await c.ExecuteNonQueryAsync(@$&quot;
484  CREATE TABLE {tableName} (id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY, name TEXT NOT NULL);
485  CREATE PUBLICATION {publicationName} FOR TABLE {tableName};
486  &quot;);
487                  await using var rc = await OpenReplicationConnectionAsync();
488                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
489                  await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} (name) VALUES (&#x27;value 1&#x27;), (&#x27;value 2&#x27;);&quot;);
490                  using var streamingCts = new CancellationTokenSource();
491                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
492                      .GetAsyncEnumerator();
493                  await NextMessage&lt;BeginMessage&gt;(messages);
494              }, nameof(Dispose_while_replicating));
495      [TestCase(true)]
496      [TestCase(false)]
497      [Test(Description = &quot;Tests whether logical decoding messages get replicated as Logical Replication Protocol Messages on PostgreSQL 14 and above&quot;)]
498      public Task LogicalDecodingMessage(bool writeMessages)
499          =&gt; SafeReplicationTest(
500              async (slotName, tableName, publicationName) =&gt;
501              {
502                  const string prefix = &quot;My test Prefix&quot;;
503                  const string transactionalMessage = &quot;A transactional message&quot;;
504                  const string nonTransactionalMessage = &quot;A non-transactional message&quot;;
505                  await using var c = await OpenConnectionAsync();
506                  TestUtil.MinimumPgVersion(c, &quot;14.0&quot;, &quot;Replication of logical decoding messages was introduced in PostgreSQL 14&quot;);
507                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
508                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
509                  await using var rc = await OpenReplicationConnectionAsync();
510                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
511                  await using var tran = await c.BeginTransactionAsync();
512                  await c.ExecuteNonQueryAsync(@$&quot;SELECT pg_logical_emit_message(true, &#x27;{prefix}&#x27;, &#x27;{transactionalMessage}&#x27;);
513                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);&quot;, tran);
514                  await tran.CommitAsync();
515                  await using var tran2 = await c.BeginTransactionAsync();
516                  await c.ExecuteNonQueryAsync(@$&quot;SELECT pg_logical_emit_message(false, &#x27;{prefix}&#x27;, &#x27;{nonTransactionalMessage}&#x27;);
517                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(15001, 15010) s(i);
518                                                      SELECT pg_logical_emit_message(true, &#x27;{prefix}&#x27;, &#x27;{transactionalMessage}&#x27;);
519                                                      INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(15011, 30000) s(i);
520                                                      SELECT pg_logical_emit_message(false, &#x27;{prefix}&#x27;, &#x27;{nonTransactionalMessage}&#x27;);
521                                                      &quot;, tran2);
522                  await tran2.RollbackAsync();
523                  await c.ExecuteNonQueryAsync(@$&quot;SELECT pg_switch_wal();&quot;);
524                  using var streamingCts = new CancellationTokenSource();
525                  var messages = SkipEmptyTransactions(rc.StartReplication(slot,
526                          GetOptions(publicationName, writeMessages), streamingCts.Token))
527                      .GetAsyncEnumerator();
528                  var transactionXid = await AssertTransactionStart(messages);
529                  if (writeMessages)
530                  {
531                      var msg = await NextMessage&lt;LogicalDecodingMessage&gt;(messages);
532                      Assert.That(msg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
533                      Assert.That(msg.Flags, Is.EqualTo(1));
534                      Assert.That(msg.Prefix, Is.EqualTo(prefix));
535                      Assert.That(msg.Data.Length, Is.EqualTo(transactionalMessage.Length));
536                      var buffer = new MemoryStream();
537                      await msg.Data.CopyToAsync(buffer, CancellationToken.None);
538                      Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(transactionalMessage));
539                  }
540                  await NextMessage&lt;RelationMessage&gt;(messages);
541                  for (var insertCount = 0; insertCount &lt; 15000; insertCount++)
542                      await NextMessage&lt;InsertMessage&gt;(messages);
543                  await AssertTransactionCommit(messages);
544                  if (writeMessages)
545                  {
546                      var msg = await NextMessage&lt;LogicalDecodingMessage&gt;(messages);
547                      Assert.That(msg.TransactionXid, Is.Null);
548                      Assert.That(msg.Flags, Is.EqualTo(0));
549                      Assert.That(msg.Prefix, Is.EqualTo(prefix));
550                      Assert.That(msg.Data.Length, Is.EqualTo(nonTransactionalMessage.Length));
551                      var buffer = new MemoryStream();
552                      await msg.Data.CopyToAsync(buffer, CancellationToken.None);
553                      Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(nonTransactionalMessage));
554                  }
555                  if (IsStreaming)
556                  {
557                      transactionXid = await AssertTransactionStart(messages);
558                      await NextMessage&lt;RelationMessage&gt;(messages);
559                      for (var insertCount = 0; insertCount &lt; 10; insertCount++)
560                          await NextMessage&lt;InsertMessage&gt;(messages);
561                      if (writeMessages)
562                      {
563                          var msg = await NextMessage&lt;LogicalDecodingMessage&gt;(messages);
564                          Assert.That(msg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
565                          Assert.That(msg.Flags, Is.EqualTo(1));
566                          Assert.That(msg.Prefix, Is.EqualTo(prefix));
567                          Assert.That(msg.Data.Length, Is.EqualTo(transactionalMessage.Length));
568                          var buffer = new MemoryStream();
569                          await msg.Data.CopyToAsync(buffer, CancellationToken.None);
570                          Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(transactionalMessage));
571                      }
572                      while (await messages.MoveNextAsync() &amp;&amp; messages.Current is InsertMessage
573                             || messages.Current is StreamStopMessage
574                             &amp;&amp; await messages.MoveNextAsync()
575                             &amp;&amp; messages.Current is StreamStartMessage
576                             &amp;&amp; await messages.MoveNextAsync()
577                             &amp;&amp; messages.Current is InsertMessage)
578                      {
579                      }
580                  }
581                  else if (writeMessages)
582                      await messages.MoveNextAsync();
583                  if (writeMessages)
584                  {
585                      var msg = (LogicalDecodingMessage)messages.Current;
586                      Assert.That(msg.TransactionXid, Is.Null);
587                      Assert.That(msg.Flags, Is.EqualTo(0));
588                      Assert.That(msg.Prefix, Is.EqualTo(prefix));
589                      Assert.That(msg.Data.Length, Is.EqualTo(nonTransactionalMessage.Length));
590                      var buffer = new MemoryStream();
591                      await msg.Data.CopyToAsync(buffer, CancellationToken.None);
592                      Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(nonTransactionalMessage));
593                      if (IsStreaming)
594                          await messages.MoveNextAsync();
595                  }
596                  if (IsStreaming)
597                      Assert.That(messages.Current, Is.TypeOf&lt;StreamAbortMessage&gt;());
598                  streamingCts.Cancel();
599                  await AssertReplicationCancellation(messages);
600                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
601              }, $&quot;{GetObjectName(nameof(LogicalDecodingMessage))}_m_{BoolToChar(writeMessages)}&quot;);
602      [Test]
603      public Task Stream()
604      {
605          if (IsStreaming)
606              return Task.CompletedTask;
607          return SafePgOutputReplicationTest(
608              async (slotName, tableName, publicationName) =&gt;
609              {
610                  await using var c = await OpenConnectionAsync();
611                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (bytes bytea);
612                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
613                  var rc = await OpenReplicationConnectionAsync();
614                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
615                  var bytes = new byte[16384];
616                  for (var i = 0; i &lt; 10; i++)
617                      bytes[i] = (byte)i;
618                  using (var command = new NpgsqlCommand($&quot;INSERT INTO {tableName} VALUES ($1)&quot;, c))
619                  {
620                      command.Parameters.Add(new() { Value = bytes });
621                      await command.ExecuteNonQueryAsync();
622                  }
623                  using var streamingCts = new CancellationTokenSource();
624                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
625                      .GetAsyncEnumerator();
626                  await AssertTransactionStart(messages);
627                  await NextMessage&lt;RelationMessage&gt;(messages);
628                  var insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
629                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
630                  await columnEnumerator.MoveNextAsync();
631                  var stream = columnEnumerator.Current.GetStream();
632                  Assert.That(() =&gt; columnEnumerator.Current.GetStream(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
633                  Assert.That(() =&gt; columnEnumerator.Current.Get(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
634                  Assert.That(() =&gt; columnEnumerator.Current.Get&lt;byte[]&gt;(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
635                  if (IsBinary)
636                  {
637                      var someBytes = new byte[10];
638                      Assert.That(await stream.ReadAsync(someBytes, 0, 10), Is.EqualTo(10));
639                      Assert.That(someBytes, Is.EquivalentTo(bytes[..10]));
640                  }
641                  else
642                  {
643                      var hexString = &quot;\\x&quot; + BitConverter.ToString(bytes[..10]).Replace(&quot;-&quot;, string.Empty);
644                      var expected = Encoding.ASCII.GetBytes(hexString);
645                      var someBytes = new byte[expected.Length];
646                      Assert.That(await stream.ReadAsync(someBytes, 0, someBytes.Length), Is.EqualTo(someBytes.Length));
647                      Assert.That(someBytes, Is.EquivalentTo(expected));
648                  }
649                  await AssertTransactionCommit(messages);
650                  streamingCts.Cancel();
651                  await AssertReplicationCancellation(messages);
652                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
653              });
654      }
655      [Test]
656      public Task TextReader()
657      {
658          if (IsStreaming)
659              return Task.CompletedTask;
660          return SafePgOutputReplicationTest(
661              async (slotName, tableName, publicationName) =&gt;
662              {
663                  await using var c = await OpenConnectionAsync();
664                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NULL);
665                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
666                  var rc = await OpenReplicationConnectionAsync();
667                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
668                  var expectedText = &quot;val1&quot;;
669                  await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} VALUES (1, &#x27;{expectedText}&#x27;)&quot;);
670                  using var streamingCts = new CancellationTokenSource();
671                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
672                      .GetAsyncEnumerator();
673                  await AssertTransactionStart(messages);
674                  await NextMessage&lt;RelationMessage&gt;(messages);
675                  var insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
676                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
677                  await columnEnumerator.MoveNextAsync(); 
678                  await columnEnumerator.MoveNextAsync();
679                  using var reader = columnEnumerator.Current.GetTextReader();
680                  Assert.That(await reader.ReadToEndAsync(), Is.EqualTo(expectedText));
681                  await AssertTransactionCommit(messages);
682                  streamingCts.Cancel();
683                  await AssertReplicationCancellation(messages);
684                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
685              });
686      }
687      [Test]
688      public Task ValueMetadata()
689      {
690          if (IsStreaming)
691              return Task.CompletedTask;
692          return SafePgOutputReplicationTest(
693              async (slotName, tableName, publicationName) =&gt;
694              {
695                  await using var c = await OpenConnectionAsync();
696                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NULL);
697                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
698                  var rc = await OpenReplicationConnectionAsync();
699                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
700                  await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} VALUES (1, &#x27;val1&#x27;)&quot;);
701                  using var streamingCts = new CancellationTokenSource();
702                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
703                      .GetAsyncEnumerator();
704                  await AssertTransactionStart(messages);
705                  await NextMessage&lt;RelationMessage&gt;(messages);
706                  var insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
707                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
708                  await columnEnumerator.MoveNextAsync();
709                  Assert.That(columnEnumerator.Current.GetFieldType(), Is.SameAs(IsBinary ? typeof(int) : typeof(string)));
710                  Assert.That(columnEnumerator.Current.GetPostgresType().Name, Is.EqualTo(&quot;integer&quot;));
711                  Assert.That(columnEnumerator.Current.GetDataTypeName(), Is.EqualTo(&quot;integer&quot;));
712                  Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
713                  await AssertTransactionCommit(messages);
714                  streamingCts.Cancel();
715                  await AssertReplicationCancellation(messages);
716                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
717              });
718      }
719      [Test]
720      public Task Null()
721      {
722          if (IsStreaming)
723              return Task.CompletedTask;
724          return SafePgOutputReplicationTest(
725              async (slotName, tableName, publicationName) =&gt;
726              {
727                  await using var c = await OpenConnectionAsync();
728                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (int1 INT, int2 INT);
729                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
730                  var rc = await OpenReplicationConnectionAsync();
731                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
732                  await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} VALUES (1, 1), (NULL, NULL)&quot;);
733                  using var streamingCts = new CancellationTokenSource();
734                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
735                      .GetAsyncEnumerator();
736                  await AssertTransactionStart(messages);
737                  await NextMessage&lt;RelationMessage&gt;(messages);
738                  var columnEnumerator = (await NextMessage&lt;InsertMessage&gt;(messages)).NewRow.GetAsyncEnumerator();
739                  await columnEnumerator.MoveNextAsync();
740                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
741                  Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
742                  if (IsBinary)
743                      Assert.That(await columnEnumerator.Current.Get&lt;int&gt;(), Is.EqualTo(1));
744                  else
745                      Assert.That(await columnEnumerator.Current.Get&lt;string&gt;(), Is.EqualTo(&quot;1&quot;));
746                  await columnEnumerator.MoveNextAsync();
747                  Assert.That(await columnEnumerator.Current.Get(), Is.EqualTo(IsBinary ? 1 : &quot;1&quot;));
748                  columnEnumerator = (await NextMessage&lt;InsertMessage&gt;(messages)).NewRow.GetAsyncEnumerator();
749                  await columnEnumerator.MoveNextAsync();
750                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
751                  Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
752                  if (IsBinary)
753                      Assert.That(() =&gt; columnEnumerator.Current.Get&lt;int&gt;(), Throws.Exception.TypeOf&lt;InvalidCastException&gt;());
754                  else
755                      Assert.That(() =&gt; columnEnumerator.Current.Get&lt;string&gt;(), Throws.Exception.TypeOf&lt;InvalidCastException&gt;());
756                  await columnEnumerator.MoveNextAsync();
757                  Assert.That(await columnEnumerator.Current.Get(), Is.SameAs(DBNull.Value));
758                  await AssertTransactionCommit(messages);
759                  streamingCts.Cancel();
760                  await AssertReplicationCancellation(messages);
761                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
762              });
763      }
764      [NpgsqlTypes.PgName(&quot;descriptor&quot;)]
765      public class Descriptor
766      {
767          [NpgsqlTypes.PgName(&quot;id&quot;)]
768          public long Id { get; set; }
769          [NpgsqlTypes.PgName(&quot;name&quot;)]
770          public string Name { get; set; } = string.Empty;
771      }
772  #pragma warning disable CS0618 
773      [Test, NonParallelizable]
774      public Task CompositeType()
775      {
776          if (IsStreaming)
777              return Task.CompletedTask;
778          return SafePgOutputReplicationTest(
779              async (slotName, tableName, publicationName) =&gt;
780              {
781                  await using var adminConnection = await OpenConnectionAsync();
782                  await adminConnection.ExecuteNonQueryAsync(@$&quot;
783  DROP TYPE IF EXISTS descriptor CASCADE;
784  CREATE TYPE descriptor AS (id bigint, name text);
785  CREATE TABLE {tableName} (descriptor_field descriptor);
786  CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
787                  NpgsqlConnection.GlobalTypeMapper.MapComposite&lt;Descriptor&gt;(&quot;descriptor&quot;);
788                  try
789                  {
790                      using var _ = CreateTempPool(ConnectionString, out var connString);
791                      var rc = await OpenReplicationConnectionAsync(connString);
792                      var slot = await rc.CreatePgOutputReplicationSlot(slotName);
793                      var expected = new Descriptor { Id = 1248, Name = &quot;My Descriptor&quot; };
794                      var stringValue = $&quot;({expected.Id},\&quot;{expected.Name}\&quot;)&quot;;
795                      await using var c = await OpenConnectionAsync();
796                      await c.ExecuteNonQueryAsync($&quot;INSERT INTO {tableName} VALUES (&#x27;{stringValue}&#x27;)&quot;);
797                      using var streamingCts = new CancellationTokenSource();
798                      var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
799                          .GetAsyncEnumerator();
800                      await AssertTransactionStart(messages);
801                      await NextMessage&lt;TypeMessage&gt;(messages);
802                      await NextMessage&lt;RelationMessage&gt;(messages);
803                      var columnEnumerator = (await NextMessage&lt;InsertMessage&gt;(messages)).NewRow.GetAsyncEnumerator();
804                      await columnEnumerator.MoveNextAsync();
805                      Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
806                      Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
807                      if (IsBinary)
808                      {
809                          var result = await columnEnumerator.Current.Get&lt;Descriptor&gt;();
810                          Assert.That(result.Id, Is.EqualTo(expected.Id));
811                          Assert.That(result.Name, Is.EqualTo(expected.Name));
812                      }
813                      else
814                          Assert.That(await columnEnumerator.Current.Get(), Is.EqualTo(stringValue));
815                      await columnEnumerator.MoveNextAsync();
816                      await AssertTransactionCommit(messages);
817                      streamingCts.Cancel();
818                      await AssertReplicationCancellation(messages);
819                      await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
820                  }
821                  finally
822                  {
823                      await adminConnection.ExecuteNonQueryAsync(&quot;DROP TYPE IF EXISTS descriptor CASCADE;&quot;);
824                      NpgsqlConnection.GlobalTypeMapper.Reset();
825                  }
826              });
827      }
828  #pragma warning restore CS0618 
829      [Test]
830      public Task TwoPhase([Values]bool commit)
831      {
832          if (_protocolVersion &lt; 3UL)
833              return Task.CompletedTask;
834          return SafePgOutputReplicationTest(
835              async (slotName, tableName, publicationName) =&gt;
836              {
837                  var gid = Guid.NewGuid().ToString();
838                  await using var c = await OpenConnectionAsync();
839                  await c.ExecuteNonQueryAsync(@$&quot;CREATE TABLE {tableName} (a int primary key, b varchar);
840                                                  CREATE PUBLICATION {publicationName} FOR TABLE {tableName};&quot;);
841                  await using var rc = await OpenReplicationConnectionAsync();
842                  var slot = await rc.CreatePgOutputReplicationSlot(slotName, twoPhase: true);
843                  await using var tran = await c.BeginTransactionAsync();
844                  await c.ExecuteNonQueryAsync(@$&quot;INSERT INTO {tableName} SELECT i, &#x27;val&#x27; || i::text FROM generate_series(1, 15000) s(i);
845  	                                            PREPARE TRANSACTION &#x27;{gid}&#x27;;&quot;);
846                  try
847                  {
848                      using var streamingCts = new CancellationTokenSource();
849                      var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
850                          .GetAsyncEnumerator();
851                      var transactionXid = await AssertTransactionStart(messages);
852                      await NextMessage&lt;RelationMessage&gt;(messages);
853                      for (var insertCount = 0; insertCount &lt; 15000; insertCount++)
854                      {
855                          await NextMessage&lt;InsertMessage&gt;(messages);
856                      }
857                      var prepareMessageBase = await AssertPrepare(messages);
858                      Assert.That(prepareMessageBase.TransactionXid, Is.EqualTo(transactionXid));
859                      Assert.That(prepareMessageBase.TransactionGid, Is.EqualTo(gid));
860                      if (commit)
861                      {
862                          await c.ExecuteNonQueryAsync(@$&quot;COMMIT PREPARED &#x27;{gid}&#x27;;&quot;);
863                          var commitPreparedMessage = await NextMessage&lt;CommitPreparedMessage&gt;(messages);
864                          Assert.That(commitPreparedMessage.TransactionXid, Is.EqualTo(transactionXid));
865                          Assert.That(commitPreparedMessage.TransactionGid, Is.EqualTo(gid));
866                      }
867                      else
868                      {
869                          await c.ExecuteNonQueryAsync(@$&quot;ROLLBACK PREPARED &#x27;{gid}&#x27;;&quot;);
870                          var rollbackPreparedMessage = await NextMessage&lt;RollbackPreparedMessage&gt;(messages);
871                          Assert.That(rollbackPreparedMessage.TransactionXid, Is.EqualTo(transactionXid));
872                          Assert.That(rollbackPreparedMessage.TransactionGid, Is.EqualTo(gid));
873                      }
874                      streamingCts.Cancel();
875                      await AssertReplicationCancellation(messages);
876                      await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
877                  }
878                  finally
879                  {
880                      try
881                      {
882                          await using var cx = await OpenConnectionAsync();
883                          await cx.ExecuteNonQueryAsync(@$&quot;ROLLBACK PREPARED &#x27;{gid}&#x27;;&quot;);
884                      }
885                      catch
886                      {
887                      }
888                  }
889              }, $&quot;{GetObjectName(nameof(TwoPhase))}_{(commit ? &quot;commit&quot; : &quot;rollback&quot;)}&quot;);
890      }
891      [Test(Description = &quot;Tests whether columns of internally cached RelationMessage instances are accidentally overwritten.&quot;)]
892      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4633&quot;)]
893      public Task Bug4633()
894      {
895          if (IsStreaming || IsBinary || Version &gt; 1)
896              return Task.CompletedTask;
897          return SafePgOutputReplicationTest(
898              async (slotName, tableNames, publicationName) =&gt;
899              {
900                  await using var c = await OpenConnectionAsync();
901                  await c.ExecuteNonQueryAsync(@$&quot;
902  CREATE TABLE {tableNames[0]}
903  (
904      id uuid NOT NULL,
905      text text NOT NULL,
906      created_at timestamp with time zone NOT NULL,
907      CONSTRAINT pk_{tableNames[0]} PRIMARY KEY (id)
908  );
909  CREATE TABLE {tableNames[1]}
910  (
911      id uuid NOT NULL,
912      message_id uuid NOT NULL,
913      created_at timestamp with time zone NOT NULL,
914      CONSTRAINT pk_{tableNames[1]} PRIMARY KEY (id),
915      CONSTRAINT fk_{tableNames[1]}_message_id FOREIGN KEY (message_id) REFERENCES {tableNames[0]} (id)
916  );
917  CREATE PUBLICATION {publicationName} FOR TABLE {tableNames[0]}, {tableNames[1]} WITH (PUBLISH = &#x27;insert&#x27;);&quot;);
918                  await using var rc = await OpenReplicationConnectionAsync();
919                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
920                  await using var tran = await c.BeginTransactionAsync();
921                  await c.ExecuteNonQueryAsync(@$&quot;
922  INSERT INTO {tableNames[0]} VALUES (&#x27;B6CB5293-F65E-4F48-A74B-06D5355DAA74&#x27;, &#x27;random&#x27;, now());
923  INSERT INTO {tableNames[1]} VALUES (&#x27;55870BEC-C42E-4AB0-83BA-225BB7777B37&#x27;, &#x27;B6CB5293-F65E-4F48-A74B-06D5355DAA74&#x27;, now());
924  INSERT INTO {tableNames[0]} VALUES (&#x27;5F89F5FE-6F4F-465F-BB87-716B1413F88D&#x27;, &#x27;another random&#x27;, now());&quot;);
925                  await tran.CommitAsync();
926                  using var streamingCts = new CancellationTokenSource();
927                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
928                      .GetAsyncEnumerator();
929                  var transactionXid = await AssertTransactionStart(messages);
930                  var relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
931                  var relation1Name = relationMsg.RelationName;
932                  var relation1Id = relationMsg.RelationId;
933                  Assert.That(relation1Name, Is.EqualTo(tableNames[0]));
934                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(3));
935                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
936                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;text&quot;));
937                  Assert.That(relationMsg.Columns[2].ColumnName, Is.EqualTo(&quot;created_at&quot;));
938                  var insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
939                  Assert.That(insertMsg.Relation.RelationName, Is.EqualTo(relation1Name));
940                  Assert.That(insertMsg.Relation.RelationId, Is.EqualTo(relation1Id));
941                  Assert.That(insertMsg.Relation.Columns.Count, Is.EqualTo(3));
942                  Assert.That(insertMsg.Relation.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
943                  Assert.That(insertMsg.Relation.Columns[1].ColumnName, Is.EqualTo(&quot;text&quot;));
944                  Assert.That(insertMsg.Relation.Columns[2].ColumnName, Is.EqualTo(&quot;created_at&quot;));
945                  relationMsg = await NextMessage&lt;RelationMessage&gt;(messages);
946                  var relation2Name = relationMsg.RelationName;
947                  var relation2Id = relationMsg.RelationId;
948                  Assert.That(relation2Name, Is.EqualTo(tableNames[1]));
949                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(3));
950                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
951                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo(&quot;message_id&quot;));
952                  Assert.That(relationMsg.Columns[2].ColumnName, Is.EqualTo(&quot;created_at&quot;));
953                  insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
954                  Assert.That(insertMsg.Relation.RelationName, Is.EqualTo(relation2Name));
955                  Assert.That(insertMsg.Relation.RelationId, Is.EqualTo(relation2Id));
956                  Assert.That(insertMsg.Relation.Columns.Count, Is.EqualTo(3));
957                  Assert.That(insertMsg.Relation.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
958                  Assert.That(insertMsg.Relation.Columns[1].ColumnName, Is.EqualTo(&quot;message_id&quot;));
959                  Assert.That(insertMsg.Relation.Columns[2].ColumnName, Is.EqualTo(&quot;created_at&quot;));
960                  insertMsg = await NextMessage&lt;InsertMessage&gt;(messages);
961                  Assert.That(insertMsg.Relation.RelationName, Is.EqualTo(relation1Name));
962                  Assert.That(insertMsg.Relation.RelationId, Is.EqualTo(relation1Id));
963                  Assert.That(insertMsg.Relation.Columns.Count, Is.EqualTo(3));
964                  Assert.That(insertMsg.Relation.Columns[0].ColumnName, Is.EqualTo(&quot;id&quot;));
965                  Assert.That(insertMsg.Relation.Columns[1].ColumnName, Is.EqualTo(&quot;text&quot;));
966                  Assert.That(insertMsg.Relation.Columns[2].ColumnName, Is.EqualTo(&quot;created_at&quot;));
967                  await AssertTransactionCommit(messages);
968                  streamingCts.Cancel();
969                  await AssertReplicationCancellation(messages);
970                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
971              }, 2);
972      }
973      #region Non-Test stuff (helper methods, initialization, enums, ...)
974      async Task&lt;uint?&gt; AssertTransactionStart(IAsyncEnumerator&lt;PgOutputReplicationMessage&gt; messages)
975      {
976          Assert.True(await messages.MoveNextAsync());
977          switch (messages.Current)
978          {
979          case StreamStartMessage streamStartMessage:
980              Assert.That(IsStreaming);
981              return streamStartMessage.TransactionXid;
982          case BeginMessage beginMessage:
983              Assert.That(!IsStreaming);
984              return beginMessage.TransactionXid;
985          case BeginPrepareMessage beginPrepareMessage:
986              Assert.That(!IsStreaming);
987              return beginPrepareMessage.TransactionXid;
988          default:
989              Assert.Fail(&quot;Expected transaction start message but got: &quot; + messages.Current);
990              throw new Exception();
991          }
992      }
993      async Task AssertTransactionCommit(IAsyncEnumerator&lt;PgOutputReplicationMessage&gt; messages)
994      {
995          Assert.True(await messages.MoveNextAsync());
996          switch (messages.Current)
997          {
998          case StreamStopMessage:
999              Assert.That(IsStreaming);
1000              Assert.True(await messages.MoveNextAsync());
1001              Assert.That(messages.Current, Is.TypeOf&lt;StreamCommitMessage&gt;());
1002              return;
1003          case CommitMessage:
1004              return;
1005          default:
1006              Assert.Fail(&quot;Expected transaction end message but got: &quot; + messages.Current);
1007              throw new Exception();
1008          }
1009      }
1010      async Task&lt;PrepareMessageBase&gt; AssertPrepare(IAsyncEnumerator&lt;PgOutputReplicationMessage&gt; enumerator)
1011      {
1012          Assert.True(await enumerator.MoveNextAsync());
1013          if (IsStreaming &amp;&amp; enumerator.Current is StreamStopMessage)
1014          {
1015              Assert.True(await enumerator.MoveNextAsync());
1016              Assert.That(enumerator.Current, Is.TypeOf&lt;StreamPrepareMessage&gt;());
1017              return (PrepareMessageBase)enumerator.Current!;
1018          }
1019          Assert.That(enumerator.Current, Is.TypeOf&lt;PrepareMessage&gt;());
1020          return (PrepareMessageBase)enumerator.Current!;
1021      }
1022      async ValueTask&lt;TExpected&gt; NextMessage&lt;TExpected&gt;(IAsyncEnumerator&lt;PgOutputReplicationMessage&gt; enumerator, bool expectRelationMessage = false)
1023          where TExpected : PgOutputReplicationMessage
1024      {
1025          Assert.True(await enumerator.MoveNextAsync());
1026          if (IsStreaming &amp;&amp; enumerator.Current is StreamStopMessage)
1027          {
1028              Assert.True(await enumerator.MoveNextAsync());
1029              Assert.That(enumerator.Current, Is.TypeOf&lt;StreamStartMessage&gt;());
1030              Assert.True(await enumerator.MoveNextAsync());
1031              if (expectRelationMessage)
1032              {
1033                  Assert.That(enumerator.Current, Is.TypeOf&lt;RelationMessage&gt;());
1034                  Assert.True(await enumerator.MoveNextAsync());
1035              }
1036          }
1037          Assert.That(enumerator.Current, Is.TypeOf&lt;TExpected&gt;());
1038          return (TExpected)enumerator.Current!;
1039      }
1040      async IAsyncEnumerable&lt;PgOutputReplicationMessage&gt; SkipEmptyTransactions(IAsyncEnumerable&lt;PgOutputReplicationMessage&gt; messages)
1041      {
1042          var enumerator = messages.GetAsyncEnumerator();
1043          while (await enumerator.MoveNextAsync())
1044          {
1045              if (enumerator.Current is BeginMessage)
1046              {
1047                  var current = enumerator.Current;
1048                  if (!await enumerator.MoveNextAsync())
1049                  {
1050                      yield return current;
1051                      yield break;
1052                  }
1053                  var next = enumerator.Current;
1054                  if (next is CommitMessage)
1055                      continue;
1056                  yield return current;
1057                  yield return next;
1058                  continue;
1059              }
1060              yield return enumerator.Current;
1061          }
1062      }
1063      PgOutputReplicationOptions GetOptions(string publicationName, bool? messages = null)
1064          =&gt; new(publicationName, _protocolVersion, _binary, _streaming, messages);
1065      Task SafePgOutputReplicationTest(Func&lt;string, string, string, Task&gt; testAction, [CallerMemberName] string memberName = &quot;&quot;)
1066          =&gt; SafeReplicationTest(testAction, GetObjectName(memberName));
1067      Task SafePgOutputReplicationTest(Func&lt;string, string[], string, Task&gt; testAction, int tableCount, [CallerMemberName] string memberName = &quot;&quot;)
1068          =&gt; SafeReplicationTest(testAction, tableCount, GetObjectName(memberName));
1069      string GetObjectName(string memberName)
1070      {
1071          var sb = new StringBuilder(memberName)
1072              .Append(&quot;_v&quot;).Append(_protocolVersion);
1073          if (_binary.HasValue)
1074              sb.Append(&quot;_b_&quot;).Append(BoolToChar(_binary.Value));
1075          if (_streaming.HasValue)
1076              sb.Append(&quot;_s_&quot;).Append(BoolToChar(_streaming.Value));
1077          return sb.ToString();
1078      }
1079      static char BoolToChar(bool value)
1080          =&gt; value ? &#x27;t&#x27; : &#x27;f&#x27;;
1081      protected override string Postfix =&gt; &quot;pgoutput_l&quot;;
1082      [OneTimeSetUp]
1083      public async Task SetUp()
1084      {
1085          await using var c = await OpenConnectionAsync();
1086          TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;The Logical Replication Protocol (via pgoutput plugin) was introduced in PostgreSQL 10&quot;);
1087          if (_protocolVersion &gt; 2)
1088              TestUtil.MinimumPgVersion(c, &quot;15.0&quot;, &quot;Logical Streaming Replication Protocol version 3 was introduced in PostgreSQL 15&quot;);
1089          if (_protocolVersion &gt; 1)
1090              TestUtil.MinimumPgVersion(c, &quot;14.0&quot;, &quot;Logical Streaming Replication Protocol version 2 was introduced in PostgreSQL 14&quot;);
1091          if (IsBinary)
<span onclick='openModal()' class='match'>1092              TestUtil.MinimumPgVersion(c, &quot;14.0&quot;, &quot;Sending replication values in binary representation was introduced in PostgreSQL 14&quot;);
1093          if (IsStreaming)
1094          {
</span>1095              TestUtil.MinimumPgVersion(c, &quot;14.0&quot;, &quot;Streaming of in-progress transactions was introduced in PostgreSQL 14&quot;);
1096              var logicalDecodingWorkMem = (string)(await c.ExecuteScalarAsync(&quot;SHOW logical_decoding_work_mem&quot;))!;
1097              if (logicalDecodingWorkMem != &quot;64kB&quot;)
1098              {
1099                  TestUtil.IgnoreExceptOnBuildServer(
1100                      $&quot;logical_decoding_work_mem is set to &#x27;{logicalDecodingWorkMem}&#x27;, but must be set to &#x27;64kB&#x27; in order for the &quot; +
1101                      &quot;streaming replication tests to work correctly. Skipping replication tests&quot;);
1102              }
1103          }
1104      }
1105      public enum ProtocolVersion : ulong
1106      {
1107          V1 = 1UL,
1108          V2 = 2UL,
1109          V3 = 3UL,
1110      }
1111      public enum ReplicationDataMode
1112      {
1113          DefaultReplicationDataMode,
1114          TextReplicationDataMode,
1115          BinaryReplicationDataMode,
1116      }
1117      public enum TransactionMode
1118      {
1119          DefaultTransactionMode,
1120          NonStreamingTransactionMode,
1121          StreamingTransactionMode,
1122      }
1123      #endregion Non-Test stuff (helper methods, initialization, ennums, ...)
1124  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonLogicalReplicationTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputReplicationTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>116                      TestUtil.MinimumPgVersion(c, &quot;10.0&quot;, &quot;Temporary replication slots were introduced in PostgreSQL 10&quot;);
117                  if (twoPhase)
118                      TestUtil.MinimumPgVersion(c, &quot;15.0&quot;, &quot;Replication slots with two phase commit support were introduced in PostgreSQL 15&quot;);
</pre></code></div>
                <div class="column column_space"><pre><code>1092              TestUtil.MinimumPgVersion(c, &quot;14.0&quot;, &quot;Sending replication values in binary representation was introduced in PostgreSQL 14&quot;);
1093          if (IsStreaming)
1094          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    