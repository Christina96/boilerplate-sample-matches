
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 65, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-BatchTests.cs</h3>
            <pre><code>1  using Npgsql.Util;
2  using NUnit.Framework;
3  using System;
4  using System.Collections.Generic;
5  using System.Data;
6  using System.Linq;
7  using System.Threading.Tasks;
8  using static Npgsql.Tests.TestUtil;
9  namespace Npgsql.Tests;
10  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.Default)]
11  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.Default)]
12  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.SequentialAccess)]
13  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.SequentialAccess)]
14  public class BatchTests : MultiplexingTestBase
15  {
16      #region Parameters
17      [Test]
18      public async Task Named_parameters()
19      {
20          await using var conn = await OpenConnectionAsync();
21          await using var batch = new NpgsqlBatch(conn)
22          {
23              BatchCommands =
24              {
25                  new("SELECT @p") { Parameters = { new("p", 8) } },
26                  new("SELECT @p1, @p2") { Parameters = { new("p1", 9), new("p2", 10) } }
27              }
28          };
29          await using var reader = await batch.ExecuteReaderAsync(Behavior);
30          Assert.That(await reader.ReadAsync(), Is.True);
31          Assert.That(reader.FieldCount, Is.EqualTo(1));
32          Assert.That(reader[0], Is.EqualTo(8));
33          Assert.That(await reader.ReadAsync(), Is.False);
34          Assert.That(await reader.NextResultAsync(), Is.True);
35          Assert.That(reader.FieldCount, Is.EqualTo(2));
36          Assert.That(await reader.ReadAsync(), Is.True);
37          Assert.That(reader[0], Is.EqualTo(9));
38          Assert.That(reader[1], Is.EqualTo(10));
39          Assert.That(await reader.ReadAsync(), Is.False);
40          Assert.That(await reader.NextResultAsync(), Is.False);
41      }
42      [Test]
43      public async Task Positional_parameters()
44      {
45          await using var conn = await OpenConnectionAsync();
46          await using var batch = new NpgsqlBatch(conn)
47          {
48              BatchCommands =
49              {
50                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
51                  new("SELECT $1, $2") { Parameters = { new() { Value = 9 }, new() { Value = 10 } } }
52              }
53          };
54          await using var reader = await batch.ExecuteReaderAsync(Behavior);
55          Assert.That(await reader.ReadAsync(), Is.True);
56          Assert.That(reader.FieldCount, Is.EqualTo(1));
57          Assert.That(reader[0], Is.EqualTo(8));
58          Assert.That(await reader.ReadAsync(), Is.False);
59          Assert.That(await reader.NextResultAsync(), Is.True);
60          Assert.That(await reader.ReadAsync(), Is.True);
61          Assert.That(reader.FieldCount, Is.EqualTo(2));
62          Assert.That(reader[0], Is.EqualTo(9));
63          Assert.That(reader[1], Is.EqualTo(10));
64          Assert.That(await reader.ReadAsync(), Is.False);
65          Assert.That(await reader.NextResultAsync(), Is.False);
66      }
67      [Test]
68      public async Task Out_parameters_are_not_allowed()
69      {
70          await using var conn = await OpenConnectionAsync();
71          await using var batch = new NpgsqlBatch(conn)
72          {
73              BatchCommands =
74              {
75                  new("SELECT @p1")
76                  {
77                      Parameters = { new("p", 8) { Direction = ParameterDirection.InputOutput } }
78                  }
79              }
80          };
81          Assert.That(() => batch.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<NotSupportedException>());
82      }
83      #endregion Parameters
84      #region NpgsqlBatchCommand
85      [Test]
86      public async Task RecordsAffected_and_Rows()
87      {
88          await using var conn = await OpenConnectionAsync();
89          var table = await CreateTempTable(conn, "name TEXT");
90          await using var batch = new NpgsqlBatch(conn)
91          {
92              BatchCommands =
93              {
94                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
95                  new($"UPDATE {table} SET name='c' WHERE name='b'"),
96                  new($"UPDATE {table} SET name='d' WHERE name='doesnt_exist'"),
97                  new($"SELECT name FROM {table}"),
98                  new($"DELETE FROM {table}")
99              }
100          };
101          await using var reader = await batch.ExecuteReaderAsync(Behavior);
102          await reader.CloseAsync();
103          var command = batch.BatchCommands[0];
104          Assert.That(command.RecordsAffected, Is.EqualTo(2));
105          Assert.That(command.Rows, Is.EqualTo(2));
106          command = batch.BatchCommands[1];
107          Assert.That(command.RecordsAffected, Is.EqualTo(1));
108          Assert.That(command.Rows, Is.EqualTo(1));
109          command = batch.BatchCommands[2];
110          Assert.That(command.RecordsAffected, Is.EqualTo(0));
111          Assert.That(command.Rows, Is.EqualTo(0));
112          command = batch.BatchCommands[3];
113          Assert.That(command.RecordsAffected, Is.EqualTo(-1));
114          Assert.That(command.Rows, Is.EqualTo(2));
115          command = batch.BatchCommands[4];
116          Assert.That(command.RecordsAffected, Is.EqualTo(2));
117          Assert.That(command.Rows, Is.EqualTo(2));
118      }
119      [Test]
120      public async Task Merge_RecordsAffected_and_Rows()
121      {
122          await using var conn = await OpenConnectionAsync();
123          MinimumPgVersion(conn, "15.0", "MERGE statement was introduced in PostgreSQL 15");
124          var table = await CreateTempTable(conn, "name TEXT");
125          await using var batch = new NpgsqlBatch(conn)
126          {
127              BatchCommands =
128              {
129                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
130                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN MATCHED THEN UPDATE SET name = 'c'"),
131                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN INSERT (name) VALUES ('b')"),
132                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN MATCHED THEN DELETE"),
133                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING")
134              }
135          };
136          await using var reader = await batch.ExecuteReaderAsync(Behavior);
137          await reader.CloseAsync();
138          var command = batch.BatchCommands[0];
139          Assert.That(command.StatementType, Is.EqualTo(StatementType.Insert));
140          Assert.That(command.RecordsAffected, Is.EqualTo(2));
141          Assert.That(command.Rows, Is.EqualTo(2));
142          command = batch.BatchCommands[1];
143          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
144          Assert.That(command.RecordsAffected, Is.EqualTo(1));
145          Assert.That(command.Rows, Is.EqualTo(1));
146          command = batch.BatchCommands[2];
147          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
148          Assert.That(command.RecordsAffected, Is.EqualTo(1));
149          Assert.That(command.Rows, Is.EqualTo(1));
150          command = batch.BatchCommands[3];
151          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
152          Assert.That(command.RecordsAffected, Is.EqualTo(1));
153          Assert.That(command.Rows, Is.EqualTo(1));
154          command = batch.BatchCommands[4];
155          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
156          Assert.That(command.RecordsAffected, Is.EqualTo(0));
157          Assert.That(command.Rows, Is.EqualTo(0));
158      }
159      [Test]
160      public async Task StatementTypes()
161      {
162          await using var conn = await OpenConnectionAsync();
163          var table = await CreateTempTable(conn, "name TEXT");
164          await using var batch = new NpgsqlBatch(conn)
165          {
166              BatchCommands =
167              {
168                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
169                  new($"UPDATE {table} SET name='c' WHERE name='b'"),
170                  new($"UPDATE {table} SET name='d' WHERE name='doesnt_exist'"),
171                  new("BEGIN"),
172                  new($"SELECT name FROM {table}"),
173                  new($"DELETE FROM {table}"),
174                  new("COMMIT")
175              }
176          };
177          await using var reader = await batch.ExecuteReaderAsync(Behavior);
178          await reader.CloseAsync();
179          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Insert));
180          Assert.That(batch.BatchCommands[1].StatementType, Is.EqualTo(StatementType.Update));
181          Assert.That(batch.BatchCommands[2].StatementType, Is.EqualTo(StatementType.Update));
182          Assert.That(batch.BatchCommands[3].StatementType, Is.EqualTo(StatementType.Other));
183          Assert.That(batch.BatchCommands[4].StatementType, Is.EqualTo(StatementType.Select));
184          Assert.That(batch.BatchCommands[5].StatementType, Is.EqualTo(StatementType.Delete));
185          Assert.That(batch.BatchCommands[6].StatementType, Is.EqualTo(StatementType.Other));
186      }
187      [Test]
188      public async Task StatementType_Call()
189      {
190          await using var conn = await OpenConnectionAsync();
191          MinimumPgVersion(conn, "11.0", "Stored procedures are supported starting with PG 11");
192          var sproc = await GetTempProcedureName(conn);
193          await conn.ExecuteNonQueryAsync($"CREATE PROCEDURE {sproc}() LANGUAGE sql AS ''");
194          await using var batch = new NpgsqlBatch(conn)
195          {
<span onclick='openModal()' class='match'>196              BatchCommands = { new($"CALL {sproc}()") }
197          };
198          await using var reader = await batch.ExecuteReaderAsync(Behavior);
199          await reader.CloseAsync();
200          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Call));
201      }
202      [Test]
203      public async Task StatementType_Merge()
204      {
205          await using var conn = await OpenConnectionAsync();
</span>206          MinimumPgVersion(conn, "15.0", "Stored procedures are supported starting with PG 11");
207          var table = await CreateTempTable(conn, "name TEXT");
208          await using var batch = new NpgsqlBatch(conn)
209          {
210              BatchCommands = { new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING") }
211          };
212          await using var reader = await batch.ExecuteReaderAsync(Behavior);
213          await reader.CloseAsync();
214          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Merge));
215      }
216      [Test]
217      public async Task StatementOID()
218      {
219          using var conn = await OpenConnectionAsync();
220          MaximumPgVersionExclusive(conn, "12.0",
221              "Support for 'CREATE TABLE ... WITH OIDS' has been removed in 12.0. See https:&bsol;&bsol;www.postgresql.org/docs/12/release-12.html#id-1.11.6.5.4");
222          var table = await GetTempTableName(conn);
223          await conn.ExecuteNonQueryAsync($"CREATE TABLE {table} (name TEXT) WITH OIDS");
224          await using var batch = new NpgsqlBatch(conn)
225          {
226              BatchCommands =
227              {
228                  new($"INSERT INTO {table} (name) VALUES (@p1)") { Parameters = { new("p1", "foo") } },
229                  new($"UPDATE {table} SET name='b' WHERE name=@p2") { Parameters = { new("p2", "bar") } }
230              }
231          };
232          await batch.ExecuteNonQueryAsync();
233          Assert.That(batch.BatchCommands[0].OID, Is.Not.EqualTo(0));
234          Assert.That(batch.BatchCommands[1].OID, Is.EqualTo(0));
235      }
236      #endregion NpgsqlBatchCommand
237      #region Command behaviors
238      [Test]
239      public async Task SingleResult()
240      {
241          await using var conn = await OpenConnectionAsync();
242          await using var batch = new NpgsqlBatch(conn)
243          {
244              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
245          };
246          var reader = await batch.ExecuteReaderAsync(CommandBehavior.SingleResult | Behavior);
247          Assert.That(reader.Read(), Is.True);
248          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
249          Assert.That(reader.NextResult(), Is.False);
250      }
251      [Test]
252      public async Task SingleRow()
253      {
254          await using var conn = await OpenConnectionAsync();
255          await using var batch = new NpgsqlBatch(conn)
256          {
257              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
258          };
259          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SingleRow | Behavior);
260          Assert.That(reader.Read(), Is.True);
261          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
262          Assert.That(reader.Read(), Is.False);
263          Assert.That(reader.NextResult(), Is.False);
264      }
265      [Test]
266      public async Task SchemaOnly_GetFieldType()
267      {
268          await using var conn = await OpenConnectionAsync();
269          await using var batch = new NpgsqlBatch(conn)
270          {
271              BatchCommands = { new("SELECT 1"), new("SELECT 'foo'") }
272          };
273          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
274          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
275          Assert.That(await reader.NextResultAsync(), Is.True);
276          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(string)));
277          Assert.That(await reader.NextResultAsync(), Is.False);
278      }
279      [Test]
280      public async Task SchemaOnly_returns_no_data()
281      {
282          await using var conn = await OpenConnectionAsync();
283          await using var batch = new NpgsqlBatch(conn)
284          {
285              BatchCommands = { new("SELECT 1"), new("SELECT 'foo'") }
286          };
287          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
288          Assert.That(reader.Read(), Is.False);
289          Assert.That(await reader.NextResultAsync(), Is.True);
290          Assert.That(reader.Read(), Is.False);
291          Assert.That(await reader.NextResultAsync(), Is.False);
292      }
293      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/693")]
294      public async Task CloseConnection()
295      {
296          await using var conn = await OpenConnectionAsync();
297          await using var batch = new NpgsqlBatch(conn)
298          {
299              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
300          };
301          await using (var reader = await batch.ExecuteReaderAsync(CommandBehavior.CloseConnection | Behavior))
302              while (reader.Read()) {}
303          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
304      }
305      #endregion Command behaviors
306      #region Error barriers
307      [Test]
308      public async Task Batch_with_error_at_start([Values] bool withErrorBarriers)
309      {
310          await using var conn = await OpenConnectionAsync();
311          var table = await CreateTempTable(conn, "id INT");
312          await using var batch = new NpgsqlBatch(conn)
313          {
314              BatchCommands =
315              {
316                  new("INVALID SQL"),
317                  new($"INSERT INTO {table} (id) VALUES (8)")
318              },
319              EnableErrorBarriers = withErrorBarriers
320          };
321          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
322          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[0]));
323          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
324              ? Is.EqualTo(1)
325              : Is.EqualTo(0));
326      }
327      [Test]
328      public async Task Batch_with_error_at_end([Values] bool withErrorBarriers)
329      {
330          await using var conn = await OpenConnectionAsync();
331          var table = await CreateTempTable(conn, "id INT");
332          await using var batch = new NpgsqlBatch(conn)
333          {
334              BatchCommands =
335              {
336                  new($"INSERT INTO {table} (id) VALUES (8)"),
337                  new("INVALID SQL")
338              },
339              EnableErrorBarriers = withErrorBarriers
340          };
341          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
342          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
343          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
344              ? Is.EqualTo(1)
345              : Is.EqualTo(0));
346      }
347      [Test]
348      public async Task Batch_with_multiple_errors([Values] bool withErrorBarriers)
349      {
350          await using var conn = await OpenConnectionAsync();
351          var table = await CreateTempTable(conn, "id INT");
352          await using var batch = new NpgsqlBatch(conn)
353          {
354              BatchCommands =
355              {
356                  new($"INSERT INTO {table} (id) VALUES (8)"),
357                  new("INVALID SQL"),
358                  new($"INSERT INTO {table} (id) VALUES (9)"),
359                  new("INVALID SQL"),
360                  new($"INSERT INTO {table} (id) VALUES (10)")
361              },
362              EnableErrorBarriers = withErrorBarriers
363          };
364          if (withErrorBarriers)
365          {
366              var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
367              var aggregateException = (AggregateException)exception.InnerException!;
368              Assert.That(((PostgresException)aggregateException.InnerExceptions[0]).BatchCommand, Is.SameAs(batch.BatchCommands[1]));
369              Assert.That(((PostgresException)aggregateException.InnerExceptions[1]).BatchCommand, Is.SameAs(batch.BatchCommands[3]));
370              Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), Is.EqualTo(3));
371          }
372          else
373          {
374              var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
375              Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
376              Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), Is.EqualTo(0));
377          }
378          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
379      }
380      [Test]
381      public async Task Batch_close_dispose_reader_with_multiple_errors([Values] bool withErrorBarriers, [Values] bool dispose)
382      {
383          await using var dataSource = CreateDataSource();
384          await using var conn = await dataSource.OpenConnectionAsync();
385          var table = await CreateTempTable(conn, "id INT");
386          await using var batch = new NpgsqlBatch(conn)
387          {
388              BatchCommands =
389              {
390                  new("SELECT NULL WHERE 1=0"),
391                  new($"INSERT INTO {table} (id) VALUES (8)"),
392                  new("INVALID SQL"),
393                  new($"INSERT INTO {table} (id) VALUES (9)"),
394                  new("INVALID SQL"),
395                  new($"INSERT INTO {table} (id) VALUES (10)")
396              },
397              EnableErrorBarriers = withErrorBarriers
398          };
399          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
400          {
401              if (withErrorBarriers)
402              {
403                  var exception = Assert.ThrowsAsync<NpgsqlException>(async () =>
404                  {
405                      if (dispose)
406                          await reader.DisposeAsync();
407                      else
408                          await reader.CloseAsync();
409                  })!;
410                  var aggregateException = (AggregateException)exception.InnerException!;
411                  Assert.That(((PostgresException)aggregateException.InnerExceptions[0]).BatchCommand, Is.SameAs(batch.BatchCommands[2]));
412                  Assert.That(((PostgresException)aggregateException.InnerExceptions[1]).BatchCommand, Is.SameAs(batch.BatchCommands[4]));
413              }
414              else
415              {
416                  var exception = Assert.ThrowsAsync<PostgresException>(async () =>
417                  {
418                      if (dispose)
419                          await reader.DisposeAsync();
420                      else
421                          await reader.CloseAsync();
422                  })!;
423                  Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[2]));
424              }
425              Assert.That(reader.State, Is.EqualTo(dispose ? ReaderState.Disposed : ReaderState.Closed));
426          }
427          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
428      }
429      [Test]
430      public async Task Batch_with_result_sets_and_error([Values] bool withErrorBarriers)
431      {
432          await using var conn = await OpenConnectionAsync();
433          var table = await CreateTempTable(conn, "id INT");
434          await using var batch = new NpgsqlBatch(conn)
435          {
436              BatchCommands =
437              {
438                  new($"INSERT INTO {table} (id) VALUES (9)"),
439                  new("SELECT 1"),
440                  new("INVALID SQL"),
441                  new($"INSERT INTO {table} (id) VALUES (9)"),
442                  new("SELECT 2")
443              },
444              EnableErrorBarriers = withErrorBarriers
445          };
446          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
447          {
448              Assert.That(await reader.ReadAsync(), Is.True);
449              Assert.That(reader[0], Is.EqualTo(1));
450              Assert.That(await reader.ReadAsync(), Is.False);
451              Assert.That(async () => await reader.NextResultAsync(), Throws.Exception.TypeOf<PostgresException>());
452              Assert.That(reader.State, Is.EqualTo(ReaderState.Consumed));
453              Assert.That(await reader.ReadAsync(), Is.False);
454              Assert.That(await reader.NextResultAsync(), Is.False);
455          }
456          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
457              ? Is.EqualTo(2)
458              : Is.EqualTo(0));
459      }
460      [Test]
461      public async Task Error_with_AppendErrorBarrier()
462      {
463          await using var conn = await OpenConnectionAsync();
464          var table = await CreateTempTable(conn, "id INT");
465          await using var batch = new NpgsqlBatch(conn)
466          {
467              BatchCommands =
468              {
469                  new($"INSERT INTO {table} (id) VALUES (8)"),
470                  new("INVALID SQL") { AppendErrorBarrier = true },
471                  new($"INSERT INTO {table} (id) VALUES (9)")
472              }
473          };
474          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
475          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
476          Assert.That(await conn.ExecuteScalarAsync($"SELECT id FROM {table} ORDER BY id"), Is.EqualTo(9));
477      }
478      [Test]
479      public async Task AppendErrorBarrier_on_last_command([Values] bool enabled)
480      {
481          await using var conn = await OpenConnectionAsync();
482          var table = await CreateTempTable(conn, "id INT");
483          await using var batch = new NpgsqlBatch(conn)
484          {
485              BatchCommands =
486              {
487                  new($"INSERT INTO {table} (id) VALUES (8)"),
488                  new($"INSERT INTO {table} (id) VALUES (9)") { AppendErrorBarrier = enabled }
489              },
490              EnableErrorBarriers = true
491          };
492          Assert.That(await batch.ExecuteNonQueryAsync(), Is.EqualTo(2));
493      }
494      [Test]
495      public async Task Error_barriers_with_SchemaOnly()
496      {
497          await using var conn = await OpenConnectionAsync();
498          await using var batch = new NpgsqlBatch(conn)
499          {
500              BatchCommands =
501              {
502                  new("SELECT 1"),
503                  new("SELECT 'foo'")
504              },
505              EnableErrorBarriers = true
506          };
507          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
508          var columnSchema = await reader.GetColumnSchemaAsync();
509          Assert.That(columnSchema[0].DataType, Is.SameAs(typeof(int)));
510          Assert.That(await reader.NextResultAsync(), Is.True);
511          columnSchema = await reader.GetColumnSchemaAsync();
512          Assert.That(columnSchema[0].DataType, Is.SameAs(typeof(string)));
513      }
514      #endregion Error barriers
515      #region Miscellaneous
516      [Test]
517      public async Task Single_batch_command()
518      {
519          await using var conn = await OpenConnectionAsync();
520          await using var batch = new NpgsqlBatch(conn)
521          {
522              BatchCommands = { new("SELECT 8") }
523          };
524          await using var reader = await batch.ExecuteReaderAsync(Behavior);
525          Assert.That(await reader.ReadAsync(), Is.True);
526          Assert.That(reader.FieldCount, Is.EqualTo(1));
527          Assert.That(reader[0], Is.EqualTo(8));
528          Assert.That(await reader.ReadAsync(), Is.False);
529          Assert.That(await reader.NextResultAsync(), Is.False);
530      }
531      [Test]
532      public async Task Empty_batch()
533      {
534          await using var conn = await OpenConnectionAsync();
535          await using var batch = new NpgsqlBatch(conn);
536          await using var reader = await batch.ExecuteReaderAsync(Behavior);
537          Assert.That(await reader.ReadAsync(), Is.False);
538          Assert.That(await reader.NextResultAsync(), Is.False);
539      }
540      [Test]
541      public async Task Semicolon_is_not_allowed()
542      {
543          await using var conn = await OpenConnectionAsync();
544          await using var batch = new NpgsqlBatch(conn)
545          {
546              BatchCommands = { new("SELECT 1; SELECT 2") }
547          };
548          Assert.That(() => batch.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<NotSupportedException>());
549      }
550      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
551      public async Task NpgsqlException_references_BatchCommand_with_single_command()
552      {
553          await using var conn = await OpenConnectionAsync();
554          var function = await GetTempFunctionName(conn);
555          await conn.ExecuteNonQueryAsync($@"
556  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
557     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
558  LANGUAGE 'plpgsql'");
559          var batch = conn.CreateBatch();
560          batch.BatchCommands.Add(new($"SELECT {function}()"));
561          var e = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
562          Assert.That(e.BatchCommand, Is.SameAs(batch.BatchCommands[0]));
563          batch.Dispose();
564          var cmd2 = conn.CreateBatch();
565          Assert.AreNotSame(cmd2, batch);
566      }
567      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
568      public async Task NpgsqlException_references_BatchCommand_with_multiple_commands()
569      {
570          await using var conn = await OpenConnectionAsync();
571          var function = await GetTempFunctionName(conn);
572          await conn.ExecuteNonQueryAsync($@"
573  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
574     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
575  LANGUAGE 'plpgsql'");
576          var batch = conn.CreateBatch();
577          batch.BatchCommands.Add(new("SELECT 1"));
578          batch.BatchCommands.Add(new($"SELECT {function}()"));
579          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
580          {
581              var e = Assert.ThrowsAsync<PostgresException>(async () => await reader.NextResultAsync())!;
582              Assert.That(e.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
583          }
584          batch.Dispose();
585          var cmd2 = conn.CreateBatch();
586          Assert.AreNotSame(cmd2, batch);
587      }
588      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4202")]
589      public async Task ExecuteScalar_without_parameters()
590      {
591          await using var conn = await OpenConnectionAsync();
592          var batch = new NpgsqlBatch(conn) { BatchCommands = { new("SELECT 1") } };
593          Assert.That(await batch.ExecuteScalarAsync(), Is.EqualTo(1));
594      }
595      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4264")]
596      public async Task Batch_with_auto_prepare_reuse()
597      {
598          await using var dataSource = CreateDataSource(csb => csb.MaxAutoPrepare = 20);
599          await using var conn = await dataSource.OpenConnectionAsync();
600          var tempTableName = await CreateTempTable(conn, "id int");
601          await using var batch = new NpgsqlBatch(conn);
602          for (var i = 0; i < 2; ++i)
603          {
604              for (var j = 0; j < 10; ++j)
605              {
606                  batch.BatchCommands.Add(new NpgsqlBatchCommand($"DELETE FROM {tempTableName} WHERE 1=0"));
607              }
608              await batch.ExecuteNonQueryAsync();
609              batch.BatchCommands.Clear();
610          }
611      }
612      #endregion Miscellaneous
613      #region Logging
614      [Test]
615      public async Task Log_ExecuteScalar_single_statement_without_parameters()
616      {
617          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
618          await using var conn = await dataSource.OpenConnectionAsync();
619          await using var cmd = new NpgsqlBatch(conn)
620          {
621              BatchCommands = { new("SELECT 1") }
622          };
623          using (listLoggerProvider.Record())
624          {
625              await cmd.ExecuteScalarAsync();
626          }
627          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
628          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains("SELECT 1"));
629          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT 1");
630          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
631          if (!IsMultiplexing)
632              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
633      }
634      [Test]
635      public async Task Log_ExecuteScalar_multiple_statements_with_parameters()
636      {
637          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
638          await using var conn = await dataSource.OpenConnectionAsync();
639          await using var batch = new NpgsqlBatch(conn)
640          {
641              BatchCommands =
642              {
643                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
644                  new("SELECT $1, 9") { Parameters = { new() { Value = 9 } } }
645              }
646          };
647          using (listLoggerProvider.Record())
648          {
649              await batch.ExecuteScalarAsync();
650          }
651          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
652          Assert.That(executingCommandEvent.Message, Does.Contain("Batch execution completed").And.Contains("[(SELECT $1, System.Object[]), (SELECT $1, 9, System.Object[])]"));
653          AssertLoggingStateDoesNotContain(executingCommandEvent, "CommandText");
654          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
655          if (!IsMultiplexing)
656              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
657          var batchCommands = (IList<(string CommandText, object[] Parameters)>)AssertLoggingStateContains(executingCommandEvent, "BatchCommands");
658          Assert.That(batchCommands.Count, Is.EqualTo(2));
659          Assert.That(batchCommands[0].CommandText, Is.EqualTo("SELECT $1"));
660          Assert.That(batchCommands[0].Parameters[0], Is.EqualTo(8));
661          Assert.That(batchCommands[1].CommandText, Is.EqualTo("SELECT $1, 9"));
662          Assert.That(batchCommands[1].Parameters[0], Is.EqualTo(9));
663      }
664      [Test]
665      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
666      {
667          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
668          await using var conn = await dataSource.OpenConnectionAsync();
669          await using var batch = new NpgsqlBatch(conn)
670          {
671              BatchCommands =
672              {
673                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
674                  new("SELECT $1, 9") { Parameters = { new() { Value = 9 } } }
675              }
676          };
677          using (listLoggerProvider.Record())
678          {
679              await batch.ExecuteScalarAsync();
680          }
681          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
682          Assert.That(executingCommandEvent.Message, Does.Contain("Batch execution completed").And.Contains("[SELECT $1, SELECT $1, 9]"));
683          var batchCommands = (IList<string>)AssertLoggingStateContains(executingCommandEvent, "BatchCommands");
684          Assert.That(batchCommands.Count, Is.EqualTo(2));
685          Assert.That(batchCommands[0], Is.EqualTo("SELECT $1"));
686          Assert.That(batchCommands[1], Is.EqualTo("SELECT $1, 9"));
687      }
688      #endregion Logging
689      #region Initialization / setup / teardown
690      readonly bool IsSequential;
691      readonly CommandBehavior Behavior;
692      public BatchTests(MultiplexingMode multiplexingMode, CommandBehavior behavior) : base(multiplexingMode)
693      {
694          Behavior = behavior;
695          IsSequential = (Behavior & CommandBehavior.SequentialAccess) != 0;
696      }
697      #endregion
698  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-BatchTests.cs</h3>
            <pre><code>1  using Npgsql.Util;
2  using NUnit.Framework;
3  using System;
4  using System.Collections.Generic;
5  using System.Data;
6  using System.Linq;
7  using System.Threading.Tasks;
8  using static Npgsql.Tests.TestUtil;
9  namespace Npgsql.Tests;
10  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.Default)]
11  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.Default)]
12  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.SequentialAccess)]
13  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.SequentialAccess)]
14  public class BatchTests : MultiplexingTestBase
15  {
16      #region Parameters
17      [Test]
18      public async Task Named_parameters()
19      {
20          await using var conn = await OpenConnectionAsync();
21          await using var batch = new NpgsqlBatch(conn)
22          {
23              BatchCommands =
24              {
25                  new("SELECT @p") { Parameters = { new("p", 8) } },
26                  new("SELECT @p1, @p2") { Parameters = { new("p1", 9), new("p2", 10) } }
27              }
28          };
29          await using var reader = await batch.ExecuteReaderAsync(Behavior);
30          Assert.That(await reader.ReadAsync(), Is.True);
31          Assert.That(reader.FieldCount, Is.EqualTo(1));
32          Assert.That(reader[0], Is.EqualTo(8));
33          Assert.That(await reader.ReadAsync(), Is.False);
34          Assert.That(await reader.NextResultAsync(), Is.True);
35          Assert.That(reader.FieldCount, Is.EqualTo(2));
36          Assert.That(await reader.ReadAsync(), Is.True);
37          Assert.That(reader[0], Is.EqualTo(9));
38          Assert.That(reader[1], Is.EqualTo(10));
39          Assert.That(await reader.ReadAsync(), Is.False);
40          Assert.That(await reader.NextResultAsync(), Is.False);
41      }
42      [Test]
43      public async Task Positional_parameters()
44      {
45          await using var conn = await OpenConnectionAsync();
46          await using var batch = new NpgsqlBatch(conn)
47          {
48              BatchCommands =
49              {
50                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
51                  new("SELECT $1, $2") { Parameters = { new() { Value = 9 }, new() { Value = 10 } } }
52              }
53          };
54          await using var reader = await batch.ExecuteReaderAsync(Behavior);
55          Assert.That(await reader.ReadAsync(), Is.True);
56          Assert.That(reader.FieldCount, Is.EqualTo(1));
57          Assert.That(reader[0], Is.EqualTo(8));
58          Assert.That(await reader.ReadAsync(), Is.False);
59          Assert.That(await reader.NextResultAsync(), Is.True);
60          Assert.That(await reader.ReadAsync(), Is.True);
61          Assert.That(reader.FieldCount, Is.EqualTo(2));
62          Assert.That(reader[0], Is.EqualTo(9));
63          Assert.That(reader[1], Is.EqualTo(10));
64          Assert.That(await reader.ReadAsync(), Is.False);
65          Assert.That(await reader.NextResultAsync(), Is.False);
66      }
67      [Test]
68      public async Task Out_parameters_are_not_allowed()
69      {
70          await using var conn = await OpenConnectionAsync();
71          await using var batch = new NpgsqlBatch(conn)
72          {
73              BatchCommands =
74              {
75                  new("SELECT @p1")
76                  {
77                      Parameters = { new("p", 8) { Direction = ParameterDirection.InputOutput } }
78                  }
79              }
80          };
81          Assert.That(() => batch.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<NotSupportedException>());
82      }
83      #endregion Parameters
84      #region NpgsqlBatchCommand
85      [Test]
86      public async Task RecordsAffected_and_Rows()
87      {
88          await using var conn = await OpenConnectionAsync();
89          var table = await CreateTempTable(conn, "name TEXT");
90          await using var batch = new NpgsqlBatch(conn)
91          {
92              BatchCommands =
93              {
94                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
95                  new($"UPDATE {table} SET name='c' WHERE name='b'"),
96                  new($"UPDATE {table} SET name='d' WHERE name='doesnt_exist'"),
97                  new($"SELECT name FROM {table}"),
98                  new($"DELETE FROM {table}")
99              }
100          };
101          await using var reader = await batch.ExecuteReaderAsync(Behavior);
102          await reader.CloseAsync();
103          var command = batch.BatchCommands[0];
104          Assert.That(command.RecordsAffected, Is.EqualTo(2));
105          Assert.That(command.Rows, Is.EqualTo(2));
106          command = batch.BatchCommands[1];
107          Assert.That(command.RecordsAffected, Is.EqualTo(1));
108          Assert.That(command.Rows, Is.EqualTo(1));
109          command = batch.BatchCommands[2];
110          Assert.That(command.RecordsAffected, Is.EqualTo(0));
111          Assert.That(command.Rows, Is.EqualTo(0));
112          command = batch.BatchCommands[3];
113          Assert.That(command.RecordsAffected, Is.EqualTo(-1));
114          Assert.That(command.Rows, Is.EqualTo(2));
115          command = batch.BatchCommands[4];
116          Assert.That(command.RecordsAffected, Is.EqualTo(2));
117          Assert.That(command.Rows, Is.EqualTo(2));
118      }
119      [Test]
120      public async Task Merge_RecordsAffected_and_Rows()
121      {
122          await using var conn = await OpenConnectionAsync();
123          MinimumPgVersion(conn, "15.0", "MERGE statement was introduced in PostgreSQL 15");
124          var table = await CreateTempTable(conn, "name TEXT");
125          await using var batch = new NpgsqlBatch(conn)
126          {
127              BatchCommands =
128              {
129                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
130                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN MATCHED THEN UPDATE SET name = 'c'"),
131                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN INSERT (name) VALUES ('b')"),
132                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN MATCHED THEN DELETE"),
133                  new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING")
134              }
135          };
136          await using var reader = await batch.ExecuteReaderAsync(Behavior);
137          await reader.CloseAsync();
138          var command = batch.BatchCommands[0];
139          Assert.That(command.StatementType, Is.EqualTo(StatementType.Insert));
140          Assert.That(command.RecordsAffected, Is.EqualTo(2));
141          Assert.That(command.Rows, Is.EqualTo(2));
142          command = batch.BatchCommands[1];
143          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
144          Assert.That(command.RecordsAffected, Is.EqualTo(1));
145          Assert.That(command.Rows, Is.EqualTo(1));
146          command = batch.BatchCommands[2];
147          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
148          Assert.That(command.RecordsAffected, Is.EqualTo(1));
149          Assert.That(command.Rows, Is.EqualTo(1));
150          command = batch.BatchCommands[3];
151          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
152          Assert.That(command.RecordsAffected, Is.EqualTo(1));
153          Assert.That(command.Rows, Is.EqualTo(1));
154          command = batch.BatchCommands[4];
155          Assert.That(command.StatementType, Is.EqualTo(StatementType.Merge));
156          Assert.That(command.RecordsAffected, Is.EqualTo(0));
157          Assert.That(command.Rows, Is.EqualTo(0));
158      }
159      [Test]
160      public async Task StatementTypes()
161      {
162          await using var conn = await OpenConnectionAsync();
163          var table = await CreateTempTable(conn, "name TEXT");
164          await using var batch = new NpgsqlBatch(conn)
165          {
166              BatchCommands =
167              {
168                  new($"INSERT INTO {table} (name) VALUES ('a'), ('b')"),
169                  new($"UPDATE {table} SET name='c' WHERE name='b'"),
170                  new($"UPDATE {table} SET name='d' WHERE name='doesnt_exist'"),
171                  new("BEGIN"),
172                  new($"SELECT name FROM {table}"),
173                  new($"DELETE FROM {table}"),
174                  new("COMMIT")
175              }
176          };
177          await using var reader = await batch.ExecuteReaderAsync(Behavior);
178          await reader.CloseAsync();
179          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Insert));
180          Assert.That(batch.BatchCommands[1].StatementType, Is.EqualTo(StatementType.Update));
181          Assert.That(batch.BatchCommands[2].StatementType, Is.EqualTo(StatementType.Update));
182          Assert.That(batch.BatchCommands[3].StatementType, Is.EqualTo(StatementType.Other));
183          Assert.That(batch.BatchCommands[4].StatementType, Is.EqualTo(StatementType.Select));
184          Assert.That(batch.BatchCommands[5].StatementType, Is.EqualTo(StatementType.Delete));
185          Assert.That(batch.BatchCommands[6].StatementType, Is.EqualTo(StatementType.Other));
186      }
187      [Test]
188      public async Task StatementType_Call()
189      {
190          await using var conn = await OpenConnectionAsync();
191          MinimumPgVersion(conn, "11.0", "Stored procedures are supported starting with PG 11");
192          var sproc = await GetTempProcedureName(conn);
193          await conn.ExecuteNonQueryAsync($"CREATE PROCEDURE {sproc}() LANGUAGE sql AS ''");
194          await using var batch = new NpgsqlBatch(conn)
195          {
196              BatchCommands = { new($"CALL {sproc}()") }
197          };
198          await using var reader = await batch.ExecuteReaderAsync(Behavior);
199          await reader.CloseAsync();
200          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Call));
201      }
202      [Test]
203      public async Task StatementType_Merge()
204      {
205          await using var conn = await OpenConnectionAsync();
206          MinimumPgVersion(conn, "15.0", "Stored procedures are supported starting with PG 11");
207          var table = await CreateTempTable(conn, "name TEXT");
208          await using var batch = new NpgsqlBatch(conn)
209          {
<span onclick='openModal()' class='match'>210              BatchCommands = { new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING") }
211          };
212          await using var reader = await batch.ExecuteReaderAsync(Behavior);
213          await reader.CloseAsync();
214          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Merge));
215      }
216      [Test]
217      public async Task StatementOID()
218      {
219          using var conn = await OpenConnectionAsync();
</span>220          MaximumPgVersionExclusive(conn, "12.0",
221              "Support for 'CREATE TABLE ... WITH OIDS' has been removed in 12.0. See https:&bsol;&bsol;www.postgresql.org/docs/12/release-12.html#id-1.11.6.5.4");
222          var table = await GetTempTableName(conn);
223          await conn.ExecuteNonQueryAsync($"CREATE TABLE {table} (name TEXT) WITH OIDS");
224          await using var batch = new NpgsqlBatch(conn)
225          {
226              BatchCommands =
227              {
228                  new($"INSERT INTO {table} (name) VALUES (@p1)") { Parameters = { new("p1", "foo") } },
229                  new($"UPDATE {table} SET name='b' WHERE name=@p2") { Parameters = { new("p2", "bar") } }
230              }
231          };
232          await batch.ExecuteNonQueryAsync();
233          Assert.That(batch.BatchCommands[0].OID, Is.Not.EqualTo(0));
234          Assert.That(batch.BatchCommands[1].OID, Is.EqualTo(0));
235      }
236      #endregion NpgsqlBatchCommand
237      #region Command behaviors
238      [Test]
239      public async Task SingleResult()
240      {
241          await using var conn = await OpenConnectionAsync();
242          await using var batch = new NpgsqlBatch(conn)
243          {
244              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
245          };
246          var reader = await batch.ExecuteReaderAsync(CommandBehavior.SingleResult | Behavior);
247          Assert.That(reader.Read(), Is.True);
248          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
249          Assert.That(reader.NextResult(), Is.False);
250      }
251      [Test]
252      public async Task SingleRow()
253      {
254          await using var conn = await OpenConnectionAsync();
255          await using var batch = new NpgsqlBatch(conn)
256          {
257              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
258          };
259          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SingleRow | Behavior);
260          Assert.That(reader.Read(), Is.True);
261          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
262          Assert.That(reader.Read(), Is.False);
263          Assert.That(reader.NextResult(), Is.False);
264      }
265      [Test]
266      public async Task SchemaOnly_GetFieldType()
267      {
268          await using var conn = await OpenConnectionAsync();
269          await using var batch = new NpgsqlBatch(conn)
270          {
271              BatchCommands = { new("SELECT 1"), new("SELECT 'foo'") }
272          };
273          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
274          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
275          Assert.That(await reader.NextResultAsync(), Is.True);
276          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(string)));
277          Assert.That(await reader.NextResultAsync(), Is.False);
278      }
279      [Test]
280      public async Task SchemaOnly_returns_no_data()
281      {
282          await using var conn = await OpenConnectionAsync();
283          await using var batch = new NpgsqlBatch(conn)
284          {
285              BatchCommands = { new("SELECT 1"), new("SELECT 'foo'") }
286          };
287          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
288          Assert.That(reader.Read(), Is.False);
289          Assert.That(await reader.NextResultAsync(), Is.True);
290          Assert.That(reader.Read(), Is.False);
291          Assert.That(await reader.NextResultAsync(), Is.False);
292      }
293      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/693")]
294      public async Task CloseConnection()
295      {
296          await using var conn = await OpenConnectionAsync();
297          await using var batch = new NpgsqlBatch(conn)
298          {
299              BatchCommands = { new("SELECT 1"), new("SELECT 2") }
300          };
301          await using (var reader = await batch.ExecuteReaderAsync(CommandBehavior.CloseConnection | Behavior))
302              while (reader.Read()) {}
303          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
304      }
305      #endregion Command behaviors
306      #region Error barriers
307      [Test]
308      public async Task Batch_with_error_at_start([Values] bool withErrorBarriers)
309      {
310          await using var conn = await OpenConnectionAsync();
311          var table = await CreateTempTable(conn, "id INT");
312          await using var batch = new NpgsqlBatch(conn)
313          {
314              BatchCommands =
315              {
316                  new("INVALID SQL"),
317                  new($"INSERT INTO {table} (id) VALUES (8)")
318              },
319              EnableErrorBarriers = withErrorBarriers
320          };
321          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
322          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[0]));
323          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
324              ? Is.EqualTo(1)
325              : Is.EqualTo(0));
326      }
327      [Test]
328      public async Task Batch_with_error_at_end([Values] bool withErrorBarriers)
329      {
330          await using var conn = await OpenConnectionAsync();
331          var table = await CreateTempTable(conn, "id INT");
332          await using var batch = new NpgsqlBatch(conn)
333          {
334              BatchCommands =
335              {
336                  new($"INSERT INTO {table} (id) VALUES (8)"),
337                  new("INVALID SQL")
338              },
339              EnableErrorBarriers = withErrorBarriers
340          };
341          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
342          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
343          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
344              ? Is.EqualTo(1)
345              : Is.EqualTo(0));
346      }
347      [Test]
348      public async Task Batch_with_multiple_errors([Values] bool withErrorBarriers)
349      {
350          await using var conn = await OpenConnectionAsync();
351          var table = await CreateTempTable(conn, "id INT");
352          await using var batch = new NpgsqlBatch(conn)
353          {
354              BatchCommands =
355              {
356                  new($"INSERT INTO {table} (id) VALUES (8)"),
357                  new("INVALID SQL"),
358                  new($"INSERT INTO {table} (id) VALUES (9)"),
359                  new("INVALID SQL"),
360                  new($"INSERT INTO {table} (id) VALUES (10)")
361              },
362              EnableErrorBarriers = withErrorBarriers
363          };
364          if (withErrorBarriers)
365          {
366              var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
367              var aggregateException = (AggregateException)exception.InnerException!;
368              Assert.That(((PostgresException)aggregateException.InnerExceptions[0]).BatchCommand, Is.SameAs(batch.BatchCommands[1]));
369              Assert.That(((PostgresException)aggregateException.InnerExceptions[1]).BatchCommand, Is.SameAs(batch.BatchCommands[3]));
370              Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), Is.EqualTo(3));
371          }
372          else
373          {
374              var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
375              Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
376              Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), Is.EqualTo(0));
377          }
378          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
379      }
380      [Test]
381      public async Task Batch_close_dispose_reader_with_multiple_errors([Values] bool withErrorBarriers, [Values] bool dispose)
382      {
383          await using var dataSource = CreateDataSource();
384          await using var conn = await dataSource.OpenConnectionAsync();
385          var table = await CreateTempTable(conn, "id INT");
386          await using var batch = new NpgsqlBatch(conn)
387          {
388              BatchCommands =
389              {
390                  new("SELECT NULL WHERE 1=0"),
391                  new($"INSERT INTO {table} (id) VALUES (8)"),
392                  new("INVALID SQL"),
393                  new($"INSERT INTO {table} (id) VALUES (9)"),
394                  new("INVALID SQL"),
395                  new($"INSERT INTO {table} (id) VALUES (10)")
396              },
397              EnableErrorBarriers = withErrorBarriers
398          };
399          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
400          {
401              if (withErrorBarriers)
402              {
403                  var exception = Assert.ThrowsAsync<NpgsqlException>(async () =>
404                  {
405                      if (dispose)
406                          await reader.DisposeAsync();
407                      else
408                          await reader.CloseAsync();
409                  })!;
410                  var aggregateException = (AggregateException)exception.InnerException!;
411                  Assert.That(((PostgresException)aggregateException.InnerExceptions[0]).BatchCommand, Is.SameAs(batch.BatchCommands[2]));
412                  Assert.That(((PostgresException)aggregateException.InnerExceptions[1]).BatchCommand, Is.SameAs(batch.BatchCommands[4]));
413              }
414              else
415              {
416                  var exception = Assert.ThrowsAsync<PostgresException>(async () =>
417                  {
418                      if (dispose)
419                          await reader.DisposeAsync();
420                      else
421                          await reader.CloseAsync();
422                  })!;
423                  Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[2]));
424              }
425              Assert.That(reader.State, Is.EqualTo(dispose ? ReaderState.Disposed : ReaderState.Closed));
426          }
427          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
428      }
429      [Test]
430      public async Task Batch_with_result_sets_and_error([Values] bool withErrorBarriers)
431      {
432          await using var conn = await OpenConnectionAsync();
433          var table = await CreateTempTable(conn, "id INT");
434          await using var batch = new NpgsqlBatch(conn)
435          {
436              BatchCommands =
437              {
438                  new($"INSERT INTO {table} (id) VALUES (9)"),
439                  new("SELECT 1"),
440                  new("INVALID SQL"),
441                  new($"INSERT INTO {table} (id) VALUES (9)"),
442                  new("SELECT 2")
443              },
444              EnableErrorBarriers = withErrorBarriers
445          };
446          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
447          {
448              Assert.That(await reader.ReadAsync(), Is.True);
449              Assert.That(reader[0], Is.EqualTo(1));
450              Assert.That(await reader.ReadAsync(), Is.False);
451              Assert.That(async () => await reader.NextResultAsync(), Throws.Exception.TypeOf<PostgresException>());
452              Assert.That(reader.State, Is.EqualTo(ReaderState.Consumed));
453              Assert.That(await reader.ReadAsync(), Is.False);
454              Assert.That(await reader.NextResultAsync(), Is.False);
455          }
456          Assert.That(await conn.ExecuteScalarAsync($"SELECT count(*) FROM {table}"), withErrorBarriers
457              ? Is.EqualTo(2)
458              : Is.EqualTo(0));
459      }
460      [Test]
461      public async Task Error_with_AppendErrorBarrier()
462      {
463          await using var conn = await OpenConnectionAsync();
464          var table = await CreateTempTable(conn, "id INT");
465          await using var batch = new NpgsqlBatch(conn)
466          {
467              BatchCommands =
468              {
469                  new($"INSERT INTO {table} (id) VALUES (8)"),
470                  new("INVALID SQL") { AppendErrorBarrier = true },
471                  new($"INSERT INTO {table} (id) VALUES (9)")
472              }
473          };
474          var exception = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
475          Assert.That(exception.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
476          Assert.That(await conn.ExecuteScalarAsync($"SELECT id FROM {table} ORDER BY id"), Is.EqualTo(9));
477      }
478      [Test]
479      public async Task AppendErrorBarrier_on_last_command([Values] bool enabled)
480      {
481          await using var conn = await OpenConnectionAsync();
482          var table = await CreateTempTable(conn, "id INT");
483          await using var batch = new NpgsqlBatch(conn)
484          {
485              BatchCommands =
486              {
487                  new($"INSERT INTO {table} (id) VALUES (8)"),
488                  new($"INSERT INTO {table} (id) VALUES (9)") { AppendErrorBarrier = enabled }
489              },
490              EnableErrorBarriers = true
491          };
492          Assert.That(await batch.ExecuteNonQueryAsync(), Is.EqualTo(2));
493      }
494      [Test]
495      public async Task Error_barriers_with_SchemaOnly()
496      {
497          await using var conn = await OpenConnectionAsync();
498          await using var batch = new NpgsqlBatch(conn)
499          {
500              BatchCommands =
501              {
502                  new("SELECT 1"),
503                  new("SELECT 'foo'")
504              },
505              EnableErrorBarriers = true
506          };
507          await using var reader = await batch.ExecuteReaderAsync(CommandBehavior.SchemaOnly | Behavior);
508          var columnSchema = await reader.GetColumnSchemaAsync();
509          Assert.That(columnSchema[0].DataType, Is.SameAs(typeof(int)));
510          Assert.That(await reader.NextResultAsync(), Is.True);
511          columnSchema = await reader.GetColumnSchemaAsync();
512          Assert.That(columnSchema[0].DataType, Is.SameAs(typeof(string)));
513      }
514      #endregion Error barriers
515      #region Miscellaneous
516      [Test]
517      public async Task Single_batch_command()
518      {
519          await using var conn = await OpenConnectionAsync();
520          await using var batch = new NpgsqlBatch(conn)
521          {
522              BatchCommands = { new("SELECT 8") }
523          };
524          await using var reader = await batch.ExecuteReaderAsync(Behavior);
525          Assert.That(await reader.ReadAsync(), Is.True);
526          Assert.That(reader.FieldCount, Is.EqualTo(1));
527          Assert.That(reader[0], Is.EqualTo(8));
528          Assert.That(await reader.ReadAsync(), Is.False);
529          Assert.That(await reader.NextResultAsync(), Is.False);
530      }
531      [Test]
532      public async Task Empty_batch()
533      {
534          await using var conn = await OpenConnectionAsync();
535          await using var batch = new NpgsqlBatch(conn);
536          await using var reader = await batch.ExecuteReaderAsync(Behavior);
537          Assert.That(await reader.ReadAsync(), Is.False);
538          Assert.That(await reader.NextResultAsync(), Is.False);
539      }
540      [Test]
541      public async Task Semicolon_is_not_allowed()
542      {
543          await using var conn = await OpenConnectionAsync();
544          await using var batch = new NpgsqlBatch(conn)
545          {
546              BatchCommands = { new("SELECT 1; SELECT 2") }
547          };
548          Assert.That(() => batch.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<NotSupportedException>());
549      }
550      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
551      public async Task NpgsqlException_references_BatchCommand_with_single_command()
552      {
553          await using var conn = await OpenConnectionAsync();
554          var function = await GetTempFunctionName(conn);
555          await conn.ExecuteNonQueryAsync($@"
556  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
557     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
558  LANGUAGE 'plpgsql'");
559          var batch = conn.CreateBatch();
560          batch.BatchCommands.Add(new($"SELECT {function}()"));
561          var e = Assert.ThrowsAsync<PostgresException>(async () => await batch.ExecuteReaderAsync(Behavior))!;
562          Assert.That(e.BatchCommand, Is.SameAs(batch.BatchCommands[0]));
563          batch.Dispose();
564          var cmd2 = conn.CreateBatch();
565          Assert.AreNotSame(cmd2, batch);
566      }
567      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
568      public async Task NpgsqlException_references_BatchCommand_with_multiple_commands()
569      {
570          await using var conn = await OpenConnectionAsync();
571          var function = await GetTempFunctionName(conn);
572          await conn.ExecuteNonQueryAsync($@"
573  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
574     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
575  LANGUAGE 'plpgsql'");
576          var batch = conn.CreateBatch();
577          batch.BatchCommands.Add(new("SELECT 1"));
578          batch.BatchCommands.Add(new($"SELECT {function}()"));
579          await using (var reader = await batch.ExecuteReaderAsync(Behavior))
580          {
581              var e = Assert.ThrowsAsync<PostgresException>(async () => await reader.NextResultAsync())!;
582              Assert.That(e.BatchCommand, Is.SameAs(batch.BatchCommands[1]));
583          }
584          batch.Dispose();
585          var cmd2 = conn.CreateBatch();
586          Assert.AreNotSame(cmd2, batch);
587      }
588      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4202")]
589      public async Task ExecuteScalar_without_parameters()
590      {
591          await using var conn = await OpenConnectionAsync();
592          var batch = new NpgsqlBatch(conn) { BatchCommands = { new("SELECT 1") } };
593          Assert.That(await batch.ExecuteScalarAsync(), Is.EqualTo(1));
594      }
595      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4264")]
596      public async Task Batch_with_auto_prepare_reuse()
597      {
598          await using var dataSource = CreateDataSource(csb => csb.MaxAutoPrepare = 20);
599          await using var conn = await dataSource.OpenConnectionAsync();
600          var tempTableName = await CreateTempTable(conn, "id int");
601          await using var batch = new NpgsqlBatch(conn);
602          for (var i = 0; i < 2; ++i)
603          {
604              for (var j = 0; j < 10; ++j)
605              {
606                  batch.BatchCommands.Add(new NpgsqlBatchCommand($"DELETE FROM {tempTableName} WHERE 1=0"));
607              }
608              await batch.ExecuteNonQueryAsync();
609              batch.BatchCommands.Clear();
610          }
611      }
612      #endregion Miscellaneous
613      #region Logging
614      [Test]
615      public async Task Log_ExecuteScalar_single_statement_without_parameters()
616      {
617          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
618          await using var conn = await dataSource.OpenConnectionAsync();
619          await using var cmd = new NpgsqlBatch(conn)
620          {
621              BatchCommands = { new("SELECT 1") }
622          };
623          using (listLoggerProvider.Record())
624          {
625              await cmd.ExecuteScalarAsync();
626          }
627          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
628          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains("SELECT 1"));
629          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT 1");
630          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
631          if (!IsMultiplexing)
632              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
633      }
634      [Test]
635      public async Task Log_ExecuteScalar_multiple_statements_with_parameters()
636      {
637          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
638          await using var conn = await dataSource.OpenConnectionAsync();
639          await using var batch = new NpgsqlBatch(conn)
640          {
641              BatchCommands =
642              {
643                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
644                  new("SELECT $1, 9") { Parameters = { new() { Value = 9 } } }
645              }
646          };
647          using (listLoggerProvider.Record())
648          {
649              await batch.ExecuteScalarAsync();
650          }
651          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
652          Assert.That(executingCommandEvent.Message, Does.Contain("Batch execution completed").And.Contains("[(SELECT $1, System.Object[]), (SELECT $1, 9, System.Object[])]"));
653          AssertLoggingStateDoesNotContain(executingCommandEvent, "CommandText");
654          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
655          if (!IsMultiplexing)
656              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
657          var batchCommands = (IList<(string CommandText, object[] Parameters)>)AssertLoggingStateContains(executingCommandEvent, "BatchCommands");
658          Assert.That(batchCommands.Count, Is.EqualTo(2));
659          Assert.That(batchCommands[0].CommandText, Is.EqualTo("SELECT $1"));
660          Assert.That(batchCommands[0].Parameters[0], Is.EqualTo(8));
661          Assert.That(batchCommands[1].CommandText, Is.EqualTo("SELECT $1, 9"));
662          Assert.That(batchCommands[1].Parameters[0], Is.EqualTo(9));
663      }
664      [Test]
665      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
666      {
667          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
668          await using var conn = await dataSource.OpenConnectionAsync();
669          await using var batch = new NpgsqlBatch(conn)
670          {
671              BatchCommands =
672              {
673                  new("SELECT $1") { Parameters = { new() { Value = 8 } } },
674                  new("SELECT $1, 9") { Parameters = { new() { Value = 9 } } }
675              }
676          };
677          using (listLoggerProvider.Record())
678          {
679              await batch.ExecuteScalarAsync();
680          }
681          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
682          Assert.That(executingCommandEvent.Message, Does.Contain("Batch execution completed").And.Contains("[SELECT $1, SELECT $1, 9]"));
683          var batchCommands = (IList<string>)AssertLoggingStateContains(executingCommandEvent, "BatchCommands");
684          Assert.That(batchCommands.Count, Is.EqualTo(2));
685          Assert.That(batchCommands[0], Is.EqualTo("SELECT $1"));
686          Assert.That(batchCommands[1], Is.EqualTo("SELECT $1, 9"));
687      }
688      #endregion Logging
689      #region Initialization / setup / teardown
690      readonly bool IsSequential;
691      readonly CommandBehavior Behavior;
692      public BatchTests(MultiplexingMode multiplexingMode, CommandBehavior behavior) : base(multiplexingMode)
693      {
694          Behavior = behavior;
695          IsSequential = (Behavior & CommandBehavior.SequentialAccess) != 0;
696      }
697      #endregion
698  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-BatchTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-BatchTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>196              BatchCommands = { new($"CALL {sproc}()") }
197          };
198          await using var reader = await batch.ExecuteReaderAsync(Behavior);
199          await reader.CloseAsync();
200          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Call));
201      }
202      [Test]
203      public async Task StatementType_Merge()
204      {
205          await using var conn = await OpenConnectionAsync();
</pre></code></div>
                <div class="column column_space"><pre><code>210              BatchCommands = { new($"MERGE INTO {table} S USING (SELECT 'b' as name) T ON T.name = S.name WHEN NOT MATCHED THEN DO NOTHING") }
211          };
212          await using var reader = await batch.ExecuteReaderAsync(Behavior);
213          await reader.CloseAsync();
214          Assert.That(batch.BatchCommands[0].StatementType, Is.EqualTo(StatementType.Merge));
215      }
216      [Test]
217      public async Task StatementOID()
218      {
219          using var conn = await OpenConnectionAsync();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    