
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionRunner.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Threading.Tasks;
4  using GitHub.DistributedTask.ObjectTemplating;
5  using GitHub.DistributedTask.ObjectTemplating.Tokens;
6  using GitHub.DistributedTask.Pipelines;
7  using GitHub.DistributedTask.Pipelines.ContextData;
8  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Common.Util;
11  using GitHub.Runner.Sdk;
12  using GitHub.Runner.Worker.Handlers;
13  using Pipelines = GitHub.DistributedTask.Pipelines;
14  namespace GitHub.Runner.Worker
15  {
16      public enum ActionRunStage
17      {
18          Pre,
19          Main,
20          Post,
21      }
22      [ServiceLocator(Default = typeof(ActionRunner))]
23      public interface IActionRunner : IStep, IRunnerService
24      {
25          ActionRunStage Stage { get; set; }
26          Pipelines.ActionStep Action { get; set; }
27      }
28      public sealed class ActionRunner : RunnerService, IActionRunner
29      {
30          private bool _didFullyEvaluateDisplayName = false;
31          private string _displayName;
32          public ActionRunStage Stage { get; set; }
33          public string Condition { get; set; }
34          public TemplateToken ContinueOnError => Action?.ContinueOnError;
35          public string DisplayName
36          {
37              get
38              {
39                  if (!string.IsNullOrEmpty(Action?.DisplayName))
40                  {
41                      return Action?.DisplayName;
42                  }
43                  return string.IsNullOrEmpty(_displayName) ? "run" : _displayName;
44              }
45              set
46              {
47                  _displayName = value;
48              }
49          }
50          public IExecutionContext ExecutionContext { get; set; }
51          public Pipelines.ActionStep Action { get; set; }
52          public TemplateToken Timeout => Action?.TimeoutInMinutes;
53          public async Task RunAsync()
54          {
55              Trace.Entering();
56              ArgUtil.NotNull(ExecutionContext, nameof(ExecutionContext));
57              ArgUtil.NotNull(Action, nameof(Action));
58              var taskManager = HostContext.GetService<IActionManager>();
59              var handlerFactory = HostContext.GetService<IHandlerFactory>();
60              Definition definition = taskManager.LoadAction(ExecutionContext, Action);
61              ArgUtil.NotNull(definition, nameof(definition));
62              ActionExecutionData handlerData = definition.Data?.Execution;
63              ArgUtil.NotNull(handlerData, nameof(handlerData));
64              List<JobExtensionRunner> localActionContainerSetupSteps = null;
65              if (handlerData.ExecutionType == ActionExecutionType.Composite &&
66                  handlerData is CompositeActionExecutionData compositeHandlerData &&
67                  Stage == ActionRunStage.Main &&
68                  Action.Reference is Pipelines.RepositoryPathReference localAction &&
69                  string.Equals(localAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
70              {
71                  var actionManager = HostContext.GetService<IActionManager>();
72                  var prepareResult = await actionManager.PrepareActionsAsync(ExecutionContext, compositeHandlerData.Steps, ExecutionContext.Id);
73                  definition = taskManager.LoadAction(ExecutionContext, Action);
74                  ArgUtil.NotNull(definition, nameof(definition));
75                  handlerData = definition.Data?.Execution;
76                  ArgUtil.NotNull(handlerData, nameof(handlerData));
77                  localActionContainerSetupSteps = prepareResult.ContainerSetupSteps;
78              }
79              if (handlerData.HasPre &&
80                  Action.Reference is Pipelines.RepositoryPathReference repoAction &&
81                  string.Equals(repoAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
82              {
83                  ExecutionContext.Warning($"`pre` execution is not supported for local action from '{repoAction.Path}'");
84              }
85              if (handlerData.HasPost && (Stage == ActionRunStage.Pre || Stage == ActionRunStage.Main))
86              {
87                  string postDisplayName = $"Post {this.DisplayName}";
88                  if (Stage == ActionRunStage.Pre &&
89                      this.DisplayName.StartsWith("Pre ", StringComparison.OrdinalIgnoreCase))
90                  {
91                      postDisplayName = $"Post {this.DisplayName.Substring("Pre ".Length)}";
92                  }
93                  var repositoryReference = Action.Reference as RepositoryPathReference;
94                  var pathString = string.IsNullOrEmpty(repositoryReference.Path) ? string.Empty : $"/{repositoryReference.Path}";
95                  var repoString = string.IsNullOrEmpty(repositoryReference.Ref) ? $"{repositoryReference.Name}{pathString}" :
96                      $"{repositoryReference.Name}{pathString}@{repositoryReference.Ref}";
97                  ExecutionContext.Debug($"Register post job cleanup for action: {repoString}");
98                  var actionRunner = HostContext.CreateService<IActionRunner>();
99                  actionRunner.Action = Action;
100                  actionRunner.Stage = ActionRunStage.Post;
101                  actionRunner.Condition = handlerData.CleanupCondition;
102                  actionRunner.DisplayName = postDisplayName;
103                  ExecutionContext.RegisterPostJobStep(actionRunner);
104              }
105              IStepHost stepHost = HostContext.CreateService<IDefaultStepHost>();
106              ExecutionContext.WriteWebhookPayload();
107              if (Action.Reference is Pipelines.RepositoryPathReference repoPathReferenceAction &&
108                  !string.Equals(repoPathReferenceAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
109              {
110                  ExecutionContext.SetGitHubContext("action_repository", repoPathReferenceAction.Name);
111                  ExecutionContext.SetGitHubContext("action_ref", repoPathReferenceAction.Ref);
112              }
113              else
114              {
115                  ExecutionContext.SetGitHubContext("action_repository", null);
116                  ExecutionContext.SetGitHubContext("action_ref", null);
117              }
118              if (ExecutionContext.Global.Container != null)
119              {
120                  if (!FeatureManager.IsContainerHooksEnabled(ExecutionContext.Global.Variables))
121                  {
122                      ArgUtil.NotNullOrEmpty(ExecutionContext.Global.Container.ContainerId, nameof(ExecutionContext.Global.Container.ContainerId));
123                  }
124                  var containerStepHost = HostContext.CreateService<IContainerStepHost>();
125                  containerStepHost.Container = ExecutionContext.Global.Container;
126                  stepHost = containerStepHost;
127              }
128              var fileCommandManager = HostContext.CreateService<IFileCommandManager>();
129              fileCommandManager.InitializeFiles(ExecutionContext, null);
130              ExecutionContext.Debug("Loading inputs");
131              Dictionary<string, string> inputs;
132              if (ExecutionContext.Global.Variables.GetBoolean(Constants.Runner.Features.UseContainerPathForTemplate) ?? false)
133              {
134                  inputs = EvaluateStepInputs(stepHost);
135              }
136              else
137              {
138                  var templateEvaluator = ExecutionContext.ToPipelineTemplateEvaluator();
139                  inputs = templateEvaluator.EvaluateStepInputs(Action.Inputs, ExecutionContext.ExpressionValues, ExecutionContext.ExpressionFunctions);
140              }
141              var userInputs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
142              foreach (KeyValuePair<string, string> input in inputs)
143              {
144                  userInputs.Add(input.Key);
145                  string message = "";
146                  if (definition.Data?.Deprecated?.TryGetValue(input.Key, out message) == true)
147                  {
148                      ExecutionContext.Warning(String.Format("Input '{0}' has been deprecated with message: {1}", input.Key, message));
149                  }
150              }
151              var validInputs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
152              if (handlerData.ExecutionType == ActionExecutionType.Container)
153              {
154                  validInputs.Add("entryPoint");
155                  validInputs.Add("args");
156              }
157              if (definition.Data?.Inputs != null)
158              {
159                  var manifestManager = HostContext.GetService<IActionManifestManager>();
160                  foreach (var input in definition.Data.Inputs)
161                  {
162                      string key = input.Key.AssertString("action input name").Value;
163                      validInputs.Add(key);
164                      if (!inputs.ContainsKey(key))
165                      {
166                          inputs[key] = manifestManager.EvaluateDefaultInput(ExecutionContext, key, input.Value);
167                      }
168                  }
169              }
170              if (Action.Reference.Type == Pipelines.ActionSourceType.Repository)
171              {
<span onclick='openModal()' class='match'>172                  var unexpectedInputs = new List<string>();
173                  foreach (var input in userInputs)
174                  {
175                      if (!validInputs.Contains(input))
</span>176                      {
177                          unexpectedInputs.Add(input);
178                      }
179                  }
180                  if (unexpectedInputs.Count > 0)
181                  {
182                      ExecutionContext.Warning($"Unexpected input(s) '{string.Join("', '", unexpectedInputs)}', valid inputs are ['{string.Join("', '", validInputs)}']");
183                  }
184              }
185              ExecutionContext.Debug("Loading env");
186              var environment = new Dictionary<String, String>(VarUtil.EnvironmentVariableKeyComparer);
187  #if OS_WINDOWS
188              var envContext = ExecutionContext.ExpressionValues["env"] as DictionaryContextData;
189  #else
190              var envContext = ExecutionContext.ExpressionValues["env"] as CaseSensitiveDictionaryContextData;
191  #endif
192              foreach (var env in envContext)
193              {
194                  environment[env.Key] = env.Value.ToString();
195              }
196              foreach (var state in ExecutionContext.IntraActionState)
197              {
198                  environment[$"STATE_{state.Key}"] = state.Value ?? string.Empty;
199              }
200              IHandler handler = handlerFactory.Create(
201                              ExecutionContext,
202                              Action.Reference,
203                              stepHost,
204                              handlerData,
205                              inputs,
206                              environment,
207                              ExecutionContext.Global.Variables,
208                              actionDirectory: definition.Directory,
209                              localActionContainerSetupSteps: localActionContainerSetupSteps);
210              handler.PrepareExecution(Stage);
211              try
212              {
213                  await handler.RunAsync(Stage);
214              }
215              finally
216              {
217                  fileCommandManager.ProcessFiles(ExecutionContext, ExecutionContext.Global.Container);
218              }
219          }
220          public bool TryUpdateDisplayName(out bool updated)
221          {
222              updated = false;
223              try
224              {
225                  if (this.Stage == ActionRunStage.Main && EvaluateDisplayName(this.ExecutionContext.ExpressionValues, this.ExecutionContext, out updated))
226                  {
227                      if (updated)
228                      {
229                          this.ExecutionContext.UpdateTimelineRecordDisplayName(this.DisplayName);
230                      }
231                  }
232              }
233              catch (Exception ex)
234              {
235                  Trace.Warning("Caught exception while attempting to evaulate/update the step's DisplayName.  Exception Details:  {0}", ex);
236              }
237              return !string.IsNullOrEmpty(this.DisplayName);
238          }
239          public bool EvaluateDisplayName(DictionaryContextData contextData, IExecutionContext context, out bool updated)
240          {
241              ArgUtil.NotNull(context, nameof(context));
242              ArgUtil.NotNull(Action, nameof(Action));
243              updated = false;
244              if (_didFullyEvaluateDisplayName || !string.IsNullOrEmpty(Action.DisplayName))
245              {
246                  return true;
247              }
248              _displayName = GenerateDisplayName(Action, contextData, context, out bool didFullyEvaluate);
249              if (didFullyEvaluate)
250              {
251                  _displayName = HostContext.SecretMasker.MaskSecrets(_displayName);
252                  updated = true;
253              }
254              context.Debug($"Set step '{Action.Name}' display name to: '{_displayName}'");
255              _didFullyEvaluateDisplayName = didFullyEvaluate;
256              return didFullyEvaluate;
257          }
258          private Dictionary<String, String> EvaluateStepInputs(IStepHost stepHost)
259          {
260              DictionaryContextData expressionValues = ExecutionContext.GetExpressionValues(stepHost);
261              var templateEvaluator = ExecutionContext.ToPipelineTemplateEvaluator();
262              var inputs = templateEvaluator.EvaluateStepInputs(Action.Inputs, expressionValues, ExecutionContext.ExpressionFunctions);
263              return inputs;
264          }
265          private string GenerateDisplayName(ActionStep action, DictionaryContextData contextData, IExecutionContext context, out bool didFullyEvaluate)
266          {
267              ArgUtil.NotNull(context, nameof(context));
268              ArgUtil.NotNull(action, nameof(action));
269              var displayName = string.Empty;
270              var prefix = string.Empty;
271              var tokenToParse = default(ScalarToken);
272              didFullyEvaluate = false;
273              if (action.DisplayNameToken != null)
274              {
275                  tokenToParse = action.DisplayNameToken as ScalarToken;
276              }
277              else if (action.Reference?.Type == ActionSourceType.Repository)
278              {
279                  prefix = PipelineTemplateConstants.RunDisplayPrefix;
280                  var repositoryReference = action.Reference as RepositoryPathReference;
281                  var pathString = string.IsNullOrEmpty(repositoryReference.Path) ? string.Empty : $"/{repositoryReference.Path}";
282                  var repoString = string.IsNullOrEmpty(repositoryReference.Ref) ? $"{repositoryReference.Name}{pathString}" :
283                      $"{repositoryReference.Name}{pathString}@{repositoryReference.Ref}";
284                  tokenToParse = new StringToken(null, null, null, repoString);
285              }
286              else if (action.Reference?.Type == ActionSourceType.ContainerRegistry)
287              {
288                  prefix = PipelineTemplateConstants.RunDisplayPrefix;
289                  var containerReference = action.Reference as ContainerRegistryReference;
290                  tokenToParse = new StringToken(null, null, null, containerReference.Image);
291              }
292              else if (action.Reference?.Type == ActionSourceType.Script)
293              {
294                  prefix = PipelineTemplateConstants.RunDisplayPrefix;
295                  var inputs = action.Inputs.AssertMapping(null);
296                  foreach (var pair in inputs)
297                  {
298                      var propertyName = pair.Key.AssertString($"{PipelineTemplateConstants.Steps}");
299                      if (string.Equals(propertyName.Value, "script", StringComparison.OrdinalIgnoreCase))
300                      {
301                          tokenToParse = pair.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Run}");
302                          break;
303                      }
304                  }
305              }
306              else
307              {
308                  context.Error($"Encountered an unknown action reference type when evaluating the display name: {action.Reference?.Type}");
309                  return displayName;
310              }
311              if (tokenToParse == null)
312              {
313                  return displayName;
314              }
315              try
316              {
317                  if (tokenToParse.CheckHasRequiredContext(contextData, context.ExpressionFunctions))
318                  {
319                      var templateEvaluator = context.ToPipelineTemplateEvaluator();
320                      displayName = templateEvaluator.EvaluateStepDisplayName(tokenToParse, contextData, context.ExpressionFunctions);
321                      didFullyEvaluate = true;
322                  }
323              }
324              catch (TemplateValidationException e)
325              {
326                  context.Warning($"Encountered an error when evaluating display name {tokenToParse.ToString()}. {e.Message}");
327                  return displayName;
328              }
329              if (!didFullyEvaluate)
330              {
331                  displayName = tokenToParse.ToDisplayString();
332              }
333              displayName = FormatStepName(prefix, displayName);
334              return displayName;
335          }
336          private static string FormatStepName(string prefix, string stepName)
337          {
338              if (string.IsNullOrEmpty(stepName))
339              {
340                  return string.Empty;
341              }
342              var result = stepName.TrimStart(' ', '\t', '\r', '\n');
343              var firstNewLine = result.IndexOfAny(new[] { '\r', '\n' });
344              if (firstNewLine >= 0)
345              {
346                  result = result.Substring(0, firstNewLine);
347              }
348              return $"{prefix}{result}";
349          }
350      }
351  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-JwtBearerHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Security.Claims;
5  using System.Text;
6  using System.Text.Encodings.Web;
7  using System.Threading.Tasks;
8  using Microsoft.AspNetCore.DataProtection;
9  using Microsoft.AspNetCore.Http;
10  using Microsoft.Extensions.Logging;
11  using Microsoft.Extensions.Options;
12  using Microsoft.IdentityModel.Protocols.OpenIdConnect;
13  using Microsoft.IdentityModel.Tokens;
14  using Microsoft.Net.Http.Headers;
15  namespace Microsoft.AspNetCore.Authentication.JwtBearer
16  {
17      public class JwtBearerHandler : AuthenticationHandler<JwtBearerOptions>
18      {
19          private OpenIdConnectConfiguration _configuration;
20          public JwtBearerHandler(IOptionsMonitor<JwtBearerOptions> options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
21              : base(options, logger, encoder, clock)
22          { }
23          protected new JwtBearerEvents Events
24          {
25              get => (JwtBearerEvents)base.Events;
26              set => base.Events = value;
27          }
28          protected override Task<object> CreateEventsAsync() => Task.FromResult<object>(new JwtBearerEvents());
29          protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
30          {
31              string token = null;
32              try
33              {
34                  var messageReceivedContext = new MessageReceivedContext(Context, Scheme, Options);
35                  await Events.MessageReceived(messageReceivedContext);
36                  if (messageReceivedContext.Result != null)
37                  {
38                      return messageReceivedContext.Result;
39                  }
40                  token = messageReceivedContext.Token;
41                  if (string.IsNullOrEmpty(token))
42                  {
43                      string authorization = Request.Headers["Authorization"];
44                      if (string.IsNullOrEmpty(authorization))
45                      {
46                          return AuthenticateResult.NoResult();
47                      }
48                      if (authorization.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
49                      {
50                          token = authorization.Substring("Bearer ".Length).Trim();
51                      }
52                      if (string.IsNullOrEmpty(token))
53                      {
54                          return AuthenticateResult.NoResult();
55                      }
56                  }
57                  if (_configuration == null && Options.ConfigurationManager != null)
58                  {
59                      _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
60                  }
61                  var validationParameters = Options.TokenValidationParameters.Clone();
62                  if (_configuration != null)
63                  {
64                      var issuers = new[] { _configuration.Issuer };
65                      validationParameters.ValidIssuers = validationParameters.ValidIssuers?.Concat(issuers) ?? issuers;
66                      validationParameters.IssuerSigningKeys = validationParameters.IssuerSigningKeys?.Concat(_configuration.SigningKeys)
67                          ?? _configuration.SigningKeys;
68                  }
69                  List<Exception> validationFailures = null;
70                  SecurityToken validatedToken;
71                  foreach (var validator in Options.SecurityTokenValidators)
72                  {
73                      if (validator.CanReadToken(token))
74                      {
75                          ClaimsPrincipal principal;
76                          try
77                          {
78                              principal = validator.ValidateToken(token, validationParameters, out validatedToken);
79                          }
80                          catch (Exception ex)
81                          {
82                              Logger.TokenValidationFailed(ex);
83                              if (Options.RefreshOnIssuerKeyNotFound && Options.ConfigurationManager != null
84                                  && ex is SecurityTokenSignatureKeyNotFoundException)
85                              {
86                                  Options.ConfigurationManager.RequestRefresh();
87                              }
88                              if (validationFailures == null)
89                              {
90                                  validationFailures = new List<Exception>(1);
91                              }
92                              validationFailures.Add(ex);
93                              continue;
94                          }
95                          Logger.TokenValidationSucceeded();
96                          var tokenValidatedContext = new TokenValidatedContext(Context, Scheme, Options)
97                          {
98                              Principal = principal,
99                              SecurityToken = validatedToken
100                          };
101                          await Events.TokenValidated(tokenValidatedContext);
102                          if (tokenValidatedContext.Result != null)
103                          {
104                              return tokenValidatedContext.Result;
105                          }
106                          if (Options.SaveToken)
107                          {
108                              tokenValidatedContext.Properties.StoreTokens(new[]
109                              {
110                                  new AuthenticationToken { Name = "access_token", Value = token }
111                              });
112                          }
113                          tokenValidatedContext.Success();
114                          return tokenValidatedContext.Result;
115                      }
116                  }
117                  if (validationFailures != null)
118                  {
119                      var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
120                      {
121                          Exception = (validationFailures.Count == 1) ? validationFailures[0] : new AggregateException(validationFailures)
122                      };
123                      await Events.AuthenticationFailed(authenticationFailedContext);
124                      if (authenticationFailedContext.Result != null)
125                      {
126                          return authenticationFailedContext.Result;
127                      }
128                      return AuthenticateResult.Fail(authenticationFailedContext.Exception);
129                  }
130                  return AuthenticateResult.Fail("No SecurityTokenValidator available for token: " + token ?? "[null]");
131              }
132              catch (Exception ex)
133              {
134                  Logger.ErrorProcessingMessage(ex);
135                  var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
136                  {
137                      Exception = ex
138                  };
139                  await Events.AuthenticationFailed(authenticationFailedContext);
140                  if (authenticationFailedContext.Result != null)
141                  {
142                      return authenticationFailedContext.Result;
143                  }
144                  throw;
145              }
146          }
147          protected override async Task HandleChallengeAsync(AuthenticationProperties properties)
148          {
149              var authResult = await HandleAuthenticateOnceSafeAsync();
150              var eventContext = new JwtBearerChallengeContext(Context, Scheme, Options, properties)
151              {
152                  AuthenticateFailure = authResult?.Failure
153              };
154              if (Options.IncludeErrorDetails && eventContext.AuthenticateFailure != null)
155              {
156                  eventContext.Error = "invalid_token";
157                  eventContext.ErrorDescription = CreateErrorDescription(eventContext.AuthenticateFailure);
158              }
159              await Events.Challenge(eventContext);
160              if (eventContext.Handled)
161              {
162                  return;
163              }
164              Response.StatusCode = 401;
165              if (string.IsNullOrEmpty(eventContext.Error) &&
166                  string.IsNullOrEmpty(eventContext.ErrorDescription) &&
167                  string.IsNullOrEmpty(eventContext.ErrorUri))
168              {
169                  Response.Headers.Append(HeaderNames.WWWAuthenticate, Options.Challenge);
170              }
171              else
172              {
173                  var builder = new StringBuilder(Options.Challenge);
174                  if (Options.Challenge.IndexOf(" ", StringComparison.Ordinal) > 0)
175                  {
176                      builder.Append(',');
177                  }
178                  if (!string.IsNullOrEmpty(eventContext.Error))
179                  {
180                      builder.Append(" error=\"");
181                      builder.Append(eventContext.Error);
182                      builder.Append("\"");
183                  }
184                  if (!string.IsNullOrEmpty(eventContext.ErrorDescription))
185                  {
186                      if (!string.IsNullOrEmpty(eventContext.Error))
187                      {
188                          builder.Append(",");
189                      }
190                      builder.Append(" error_description=\"");
191                      builder.Append(eventContext.ErrorDescription);
192                      builder.Append('\"');
193                  }
194                  if (!string.IsNullOrEmpty(eventContext.ErrorUri))
195                  {
196                      if (!string.IsNullOrEmpty(eventContext.Error) ||
197                          !string.IsNullOrEmpty(eventContext.ErrorDescription))
198                      {
199                          builder.Append(",");
200                      }
201                      builder.Append(" error_uri=\"");
202                      builder.Append(eventContext.ErrorUri);
203                      builder.Append('\"');
204                  }
205                  Response.Headers.Append(HeaderNames.WWWAuthenticate, builder.ToString());
206              }
207          }
208          private static string CreateErrorDescription(Exception authFailure)
209          {
210              IEnumerable<Exception> exceptions;
211              if (authFailure is AggregateException agEx)
212              {
213                  exceptions = agEx.InnerExceptions;
214              }
215              else
216              {
217                  exceptions = new[] { authFailure };
218              }
<span onclick='openModal()' class='match'>219              var messages = new List<string>();
220              foreach (var ex in exceptions)
221              {
222                  switch (ex)
</span>223                  {
224                      case SecurityTokenInvalidAudienceException _:
225                          messages.Add("The audience is invalid");
226                          break;
227                      case SecurityTokenInvalidIssuerException _:
228                          messages.Add("The issuer is invalid");
229                          break;
230                      case SecurityTokenNoExpirationException _:
231                          messages.Add("The token has no expiration");
232                          break;
233                      case SecurityTokenInvalidLifetimeException _:
234                          messages.Add("The token lifetime is invalid");
235                          break;
236                      case SecurityTokenNotYetValidException _:
237                          messages.Add("The token is not valid yet");
238                          break;
239                      case SecurityTokenExpiredException _:
240                          messages.Add("The token is expired");
241                          break;
242                      case SecurityTokenSignatureKeyNotFoundException _:
243                          messages.Add("The signature key was not found");
244                          break;
245                      case SecurityTokenInvalidSignatureException _:
246                          messages.Add("The signature is invalid");
247                          break;
248                  }
249              }
250              return string.Join("; ", messages);
251          }
252      }
253  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionRunner.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-JwtBearerHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>172                  var unexpectedInputs = new List<string>();
173                  foreach (var input in userInputs)
174                  {
175                      if (!validInputs.Contains(input))
</pre></code></div>
                <div class="column column_space"><pre><code>219              var messages = new List<string>();
220              foreach (var ex in exceptions)
221              {
222                  switch (ex)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    