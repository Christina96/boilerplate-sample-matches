
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 30.186170212765955%, Tokens: 10</h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-DrawerTest.cs</h3>
            <pre><code>1  #pragma warning disable CS1998 
2  using System;
3  using System.Threading.Tasks;
4  using Bunit;
5  using FluentAssertions;
6  using Microsoft.Extensions.DependencyInjection;
7  using Moq;
8  using MudBlazor.Services;
9  using MudBlazor.UnitTests.Mocks;
10  using MudBlazor.UnitTests.TestComponents;
11  using NUnit.Framework;
12  using static Bunit.ComponentParameterFactory;
13  namespace MudBlazor.UnitTests.Components
14  {
15      [TestFixture]
16      public class DrawerTest : BunitTest
17      {
18          private Mock<IBreakpointService> _breakpointListenerServiceMock;
19          private Action<Breakpoint> _breakpointUpdateCallback;
20          public override void Setup()
21          {
22              base.Setup();
23              _breakpointListenerServiceMock = new Mock<IBreakpointService>();
24              _breakpointListenerServiceMock
25                  .Setup(x => x.SubscribeAsync(It.IsAny<Action<Breakpoint>>()))
26                  .ReturnsAsync(new BreakpointServiceSubscribeResult(Guid.NewGuid(), Breakpoint.Md))
27                  .Callback<Action<Breakpoint>>(x => _breakpointUpdateCallback = x)
28                  .Verifiable();
29              Context.Services.AddScoped(sp => _breakpointListenerServiceMock.Object);
30          }
31          [Test]
32          public async Task TemporaryClosed_Open_CheckOpened_Close_CheckClosed()
33          {
34              var comp = Context.RenderComponent<DrawerTest1>(Parameter(nameof(DrawerTest1.Variant), DrawerVariant.Temporary));
35              comp.Find("button").Click();
36              comp.FindAll("aside.mud-drawer--open.mud-drawer-temporary").Count.Should().Be(1);
37              comp.FindAll("aside+.mud-overlay-drawer").Count.Should().Be(1);
38              comp.Instance.Drawer.Open.Should().BeTrue();
39              comp.Find("button").Click();
40              comp.FindAll("aside.mud-drawer--closed.mud-drawer-temporary").Count.Should().Be(1);
41              comp.Instance.Drawer.Open.Should().BeFalse();
42          }
43          [Test]
44          public async Task TemporaryClosedWithoutOverlay_Open_CheckOverlay()
45          {
46              var comp = Context.RenderComponent<DrawerTest1>(
47                  Parameter(nameof(DrawerTest1.Variant), DrawerVariant.Temporary),
48                  Parameter(nameof(DrawerTest1.DisableOverlay), true));
49              comp.Find("button").Click();
50              comp.FindAll("aside+mud-overlay-drawer").Count.Should().Be(0);
51              comp.Instance.Drawer.Open.Should().BeTrue();
52              comp.Find("button").Click();
53              comp.FindAll("aside+mud-overlay-drawer").Count.Should().Be(0);
54              comp.Instance.Drawer.Open.Should().BeFalse();
55          }
56          [Test]
57          public async Task TemporaryClosedClipped_Open_CheckState()
58          {
59              var comp = Context.RenderComponent<DrawerTest1>(
60                  Parameter(nameof(DrawerTest1.Variant), DrawerVariant.Temporary),
61                  Parameter(nameof(DrawerTest1.ClipMode), DrawerClipMode.Always));
62              comp.Find("button").Click();
63              comp.FindAll("aside.mud-drawer-clipped-always").Count.Should().Be(1);
64              comp.Instance.Drawer.Open.Should().BeTrue();
65              comp.Find("button").Click();
66              comp.FindAll("aside.mud-drawer--closed.mud-drawer-temporary").Count.Should().Be(1);
67              comp.Instance.Drawer.Open.Should().BeFalse();
68          }
69          [Test]
70          public async Task PersistentClosed_Open_CheckOpened_Close_CheckClosed()
71          {
72              var comp = Context.RenderComponent<DrawerTest1>(Parameter(nameof(DrawerTest1.Variant), DrawerVariant.Persistent));
73              comp.Find("button").Click();
74              comp.FindAll("aside.mud-drawer--open.mud-drawer-persistent").Count.Should().Be(1);
75              comp.FindAll("aside+mud-overlay-drawer").Count.Should().Be(0);
76              comp.Instance.Drawer.Open.Should().BeTrue();
77              comp.Find("button").Click();
78              comp.FindAll("aside.mud-drawer--closed.mud-drawer-persistent").Count.Should().Be(1);
79              comp.Instance.Drawer.Open.Should().BeFalse();
80          }
81          [Test]
82          public async Task PersistentClosedClipped_Open_CheckState()
83          {
84              var comp = Context.RenderComponent<DrawerTest1>(
85                  Parameter(nameof(DrawerTest1.Variant),
86                      DrawerVariant.Persistent), Parameter(nameof(DrawerTest1.ClipMode), DrawerClipMode.Always));
87              comp.Find("button").Click();
88              comp.FindAll("aside.mud-drawer-clipped-always").Count.Should().Be(1);
<span onclick='openModal()' class='match'>89              comp.Instance.Drawer.Open.Should().BeTrue();
90              comp.Find("button").Click();
91              comp.FindAll("aside.mud-drawer--closed.mud-drawer-persistent").Count.Should().Be(1);
92              comp.Instance.Drawer.Open.Should().BeFalse();
93          }
94          [Test]
</span>95          public async Task MiniClosed_Open_CheckOpened_Close_CheckClosed()
96          {
97              var comp = Context.RenderComponent<DrawerTest1>(Parameter(nameof(DrawerTest1.Variant), DrawerVariant.Mini));
98              comp.Find("button").Click();
99              comp.FindAll("aside.mud-drawer--open.mud-drawer-mini").Count.Should().Be(1);
100              comp.FindAll("aside+mud-overlay-drawer").Count.Should().Be(0);
101              comp.Instance.Drawer.Open.Should().BeTrue();
102              comp.Find("button").Click();
103              comp.FindAll("aside.mud-drawer--closed.mud-drawer-mini").Count.Should().Be(1);
104              comp.Instance.Drawer.Open.Should().BeFalse();
105          }
106          [Test]
107          public async Task MiniClosedClipped_Open_CheckState()
108          {
109              var comp = Context.RenderComponent<DrawerTest1>(
110                  Parameter(nameof(DrawerTest1.Variant), DrawerVariant.Mini),
111                  Parameter(nameof(DrawerTest1.ClipMode), DrawerClipMode.Always));
112              comp.Find("button").Click();
113              comp.FindAll("aside.mud-drawer-clipped-always").Count.Should().Be(1);
114              comp.Instance.Drawer.Open.Should().BeTrue();
115              comp.Find("button").Click();
116              comp.FindAll("aside.mud-drawer--closed.mud-drawer-mini").Count.Should().Be(1);
117              comp.Instance.Drawer.Open.Should().BeFalse();
118          }
119          [Test]
120          public async Task ResponsiveClosed_Open_CheckOpened_Close_CheckClosed()
121          {
122              var comp = Context.RenderComponent<DrawerResponsiveTest>();
123              comp.Find("button").Click();
124              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
125              comp.FindAll("aside+mud-overlay-drawer").Count.Should().Be(0);
126              comp.Instance.Drawer.Open.Should().BeTrue();
127              comp.Find("button").Click();
128              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
129              comp.Instance.Drawer.Open.Should().BeFalse();
130          }
131          [Test]
132          [TestCase(Breakpoint.Xs)]
133          [TestCase(Breakpoint.Sm)]
134          public async Task ResponsiveSmallClosed_Open_CheckOpenedAndOverlay(Breakpoint point)
135          {
136              var comp = Context.RenderComponent<DrawerResponsiveTest>();
137              await comp.InvokeAsync(() => _breakpointUpdateCallback(point));
138              comp.Find("button").Click();
139              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
140              comp.FindAll("aside+.mud-drawer-overlay").Count.Should().Be(1);
141              comp.Instance.Drawer.Open.Should().BeTrue();
142              comp.Find("button").Click();
143              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
144              comp.Instance.Drawer.Open.Should().BeFalse();
145          }
146          [TestCase(Breakpoint.Xs)]
147          [TestCase(Breakpoint.Sm)]
148          [TestCase(Breakpoint.Md)]
149          [TestCase(Breakpoint.Lg)]
150          [TestCase(Breakpoint.Xl)]
151          public async Task ResponsiveClosed_LargeScreen_SetBreakpoint_Open_CheckState(Breakpoint breakpoint)
152          {
153              var comp = Context.RenderComponent<DrawerResponsiveTest>(Parameter(nameof(DrawerResponsiveTest.Breakpoint), breakpoint));
154              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Xl));
155              comp.Find("button").Click();
156              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
157              comp.FindAll("aside+.mud-drawer-overlay").Count.Should().Be(0);
158              comp.Instance.Drawer.Open.Should().BeTrue();
159              comp.Find("button").Click();
160              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
161              comp.Instance.Drawer.Open.Should().BeFalse();
162          }
163          [TestCase(Breakpoint.Xs)]
164          [TestCase(Breakpoint.Sm)]
165          [TestCase(Breakpoint.Md)]
166          [TestCase(Breakpoint.Lg)]
167          [TestCase(Breakpoint.Xl)]
168          public async Task ResponsiveClosed_SmallScreen_SetBreakpoint_Open_CheckState(Breakpoint breakpoint)
169          {
170              var comp = Context.RenderComponent<DrawerResponsiveTest>(Parameter(nameof(DrawerResponsiveTest.Breakpoint), breakpoint));
171              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Xs));
172              comp.Find("button").Click();
173              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
174              comp.FindAll("aside+.mud-drawer-overlay").Count.Should().Be(breakpoint == Breakpoint.Xs ? 0 : 1);
175              comp.Instance.Drawer.Open.Should().BeTrue();
176              comp.Find("button").Click();
177              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
178              comp.Instance.Drawer.Open.Should().BeFalse();
179          }
180          [Test]
181          public async Task ResponsiveClosed_ResizeMultiple_CheckStates()
182          {
183              var srv = Context.Services.GetService<IResizeListenerService>() as MockResizeListenerService;
184              var comp = Context.RenderComponent<DrawerResponsiveTest>(Parameter(nameof(DrawerResponsiveTest.PreserveOpenState), true));
185              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Lg));
186              comp.Find("button").Click();
187              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
188              comp.Instance.Drawer.Open.Should().BeTrue();
189              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Xs));
190              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
191              comp.Instance.Drawer.Open.Should().BeFalse();
192              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Lg));
193              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
194              comp.Instance.Drawer.Open.Should().BeTrue();
195              comp.Find("button").Click();
196              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
197              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Sm));
198              comp.Find("button").Click();
199              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
200              comp.FindAll("aside+.mud-drawer-overlay").Count.Should().Be(1);
201              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Lg));
202              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
203              comp.FindAll("aside+.mud-drawer-overlay").Count.Should().Be(0);
204          }
205          [Test]
206          public async Task Responsive_ResizeToSmall_RestoreToLarge_CheckStates()
207          {
208              var comp = Context.RenderComponent<DrawerResponsiveTest>(Parameter(nameof(DrawerResponsiveTest.PreserveOpenState), true));
209              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Lg));
210              comp.Find("button").Click();
211              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
212              comp.Instance.Drawer.Open.Should().BeTrue();
213              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Sm));
214              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
215              comp.Instance.Drawer.Open.Should().BeFalse();
216              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Xs));
217              comp.FindAll("aside.mud-drawer--closed.mud-drawer-responsive").Count.Should().Be(1);
218              comp.Instance.Drawer.Open.Should().BeFalse();
219              await comp.InvokeAsync(() => _breakpointUpdateCallback(Breakpoint.Lg));
220              comp.FindAll("aside.mud-drawer--open.mud-drawer-responsive").Count.Should().Be(1);
221              comp.Instance.Drawer.Open.Should().BeTrue();
222          }
223          [Test]
224          public async Task DrawerContainer_RemoveDrawer_CheckStates()
225          {
226              var comp = Context.RenderComponent<DrawerContainerTest1>();
227              comp.FindAll("div.mud-drawer-open-responsive-md-right").Count.Should().Be(1);
228              comp.Find("button").Click();
229              comp.FindAll("div.mud-drawer-open-responsive-md-right").Count.Should().Be(0);
230          }
231      }
232  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CopyTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.IO;
6  using System.Numerics;
7  using System.Text;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using Npgsql.Internal;
11  using NpgsqlTypes;
12  using NUnit.Framework;
13  using static Npgsql.Tests.TestUtil;
14  namespace Npgsql.Tests;
15  public class CopyTests : MultiplexingTestBase
16  {
17      #region Issue 2257
18      [Test, Description("Reproduce #2257")]
19      public async Task Issue2257()
20      {
21          await using var conn = await OpenConnectionAsync();
22          var table1 = await GetTempTableName(conn);
23          var table2 = await GetTempTableName(conn);
24          const int rowCount = 1000000;
25          using (var cmd = conn.CreateCommand())
26          {
27              cmd.CommandText = $"CREATE TABLE {table1} AS SELECT * FROM generate_series(1, {rowCount}) id";
28              await cmd.ExecuteNonQueryAsync();
29              cmd.CommandText = $"ALTER TABLE {table1} ADD CONSTRAINT {table1}_pk PRIMARY KEY (id)";
30              await cmd.ExecuteNonQueryAsync();
31              cmd.CommandText = $"CREATE TABLE {table2} (master_id integer NOT NULL REFERENCES {table1} (id))";
32              await cmd.ExecuteNonQueryAsync();
33          }
34          await using var writer = conn.BeginBinaryImport($"COPY {table2} FROM STDIN BINARY");
35          writer.Timeout = TimeSpan.FromMilliseconds(3);
36          var e = Assert.Throws<NpgsqlException>(() =>
37          {
38              for (var i = 1; i <= rowCount; ++i)
39              {
40                  writer.StartRow();
41                  writer.Write(i);
42              }
43              writer.Complete();
44          })!;
45          Assert.That(e.InnerException, Is.TypeOf<TimeoutException>());
46      }
47      #endregion
48      #region Raw
49      [Test, Description("Exports data in binary format (raw mode) and then loads it back in")]
50      public async Task Raw_binary_roundtrip([Values(false, true)] bool async)
51      {
52          using var conn = await OpenConnectionAsync();
53          const int iterations = 500;
54          var table = await GetTempTableName(conn);
55          using (var tx = conn.BeginTransaction())
56          {
57              await conn.ExecuteNonQueryAsync($@"CREATE TABLE {table} (field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER)");
58              using (var cmd =
59                     new NpgsqlCommand($"INSERT INTO {table} (field_text, field_int4) VALUES (@p1, @p2)", conn))
60              {
61                  cmd.Parameters.AddWithValue("p1", NpgsqlDbType.Text, "HELLO");
62                  cmd.Parameters.AddWithValue("p2", NpgsqlDbType.Integer, 8);
63                  for (var i = 0; i < iterations; i++)
64                  {
65                      await cmd.ExecuteNonQueryAsync();
66                  }
67              }
68              await tx.CommitAsync();
69          }
70          var data = new byte[10000];
71          var len = 0;
72          using (var outStream = async
73                     ? await conn.BeginRawBinaryCopyAsync($"COPY {table} (field_text, field_int4) TO STDIN BINARY")
74                     : conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) TO STDIN BINARY"))
75          {
76              StateAssertions(conn);
77              while (true)
78              {
79                  var read = outStream.Read(data, len, data.Length - len);
80                  if (read == 0)
81                      break;
82                  len += read;
83              }
84              Assert.That(len, Is.GreaterThan(conn.Settings.ReadBufferSize) & Is.LessThan(data.Length));
85          }
86          await conn.ExecuteNonQueryAsync($"TRUNCATE {table}");
87          using (var inStream = async
88                     ? await conn.BeginRawBinaryCopyAsync($"COPY {table} (field_text, field_int4) FROM STDIN BINARY")
89                     : conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) FROM STDIN BINARY"))
90          {
91              StateAssertions(conn);
92              inStream.Write(data, 0, len);
93          }
94          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(iterations));
95      }
96      [Test, Description("Disposes a raw binary stream in the middle of an export")]
97      public async Task Dispose_in_middle_of_raw_binary_export()
98      {
99          using var conn = await OpenConnectionAsync();
100          var table = await GetTempTableName(conn);
101          await conn.ExecuteNonQueryAsync($@"
102  CREATE TABLE {table} (field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER);
103  INSERT INTO {table} (field_text, field_int4) VALUES ('HELLO', 8)");
104          var data = new byte[3];
105          using (var inStream = conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) TO STDIN BINARY"))
106          {
107              var len = inStream.Read(data, 0, data.Length);
108              Assert.That(len, Is.EqualTo(data.Length));
109          }
110          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
111      }
112      [Test, Description("Disposes a raw binary stream in the middle of an import")]
113      public async Task Dispose_in_middle_of_raw_binary_import()
114      {
115          using var conn = await OpenConnectionAsync();
116          var table = await GetTempTableName(conn);
117          await conn.ExecuteNonQueryAsync($@"CREATE TABLE {table} (field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER)");
118          var inStream = conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) FROM STDIN BINARY");
119          inStream.Write(NpgsqlRawCopyStream.BinarySignature, 0, NpgsqlRawCopyStream.BinarySignature.Length);
120          Assert.That(() => inStream.Dispose(), Throws.Exception
121              .TypeOf<PostgresException>()
122              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.BadCopyFileFormat)
123          );
124          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
125      }
126      [Test, Description("Cancels a binary write")]
127      public async Task Cancel_raw_binary_import()
128      {
129          using var conn = await OpenConnectionAsync();
130          var table = await GetTempTableName(conn);
131          await conn.ExecuteNonQueryAsync($@"CREATE TABLE {table} (field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER)");
132          var garbage = new byte[] {1, 2, 3, 4};
133          using (var s = conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) FROM STDIN BINARY"))
134          {
135              s.Write(garbage, 0, garbage.Length);
136              s.Cancel();
137          }
138          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(0));
139      }
140      [Test]
141      public async Task Import_large_value_raw()
142      {
143          using var conn = await OpenConnectionAsync();
144          var table = await CreateTempTable(conn, "blob BYTEA");
145          var data = new byte[conn.Settings.WriteBufferSize + 10];
146          var dump = new byte[conn.Settings.WriteBufferSize + 200];
147          var len = 0;
148          using (var cmd = new NpgsqlCommand($"INSERT INTO {table} (blob) VALUES (@p)", conn))
149          {
150              cmd.Parameters.AddWithValue("p", data);
151              await cmd.ExecuteNonQueryAsync();
152          }
153          using (var outStream = conn.BeginRawBinaryCopy($"COPY {table} (blob) TO STDIN BINARY"))
154          {
155              while (true)
156              {
157                  var read = outStream.Read(dump, len, dump.Length - len);
158                  if (read == 0)
159                      break;
160                  len += read;
161              }
162              Assert.That(len < dump.Length);
163          }
164          await conn.ExecuteNonQueryAsync($"TRUNCATE {table}");
165          using (var inStream = conn.BeginRawBinaryCopy($"COPY {table} (blob) FROM STDIN BINARY"))
166          {
167              inStream.Write(dump, 0, len);
168          }
169      }
170      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
171      public async Task Wrong_table_definition_raw_binary_copy()
172      {
173          using var conn = await OpenConnectionAsync();
174          Assert.Throws<PostgresException>(() => conn.BeginRawBinaryCopy("COPY table_is_not_exist (blob) TO STDOUT BINARY"));
175          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
176          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
177          Assert.Throws<PostgresException>(() => conn.BeginRawBinaryCopy("COPY table_is_not_exist (blob) FROM STDIN BINARY"));
178          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
179          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
180      }
181      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
182      public async Task Wrong_format_raw_binary_copy()
183      {
184          if (IsMultiplexing)
185              Assert.Ignore("Multiplexing: fails");
186          using (var conn = await OpenConnectionAsync())
187          {
188              var table = await CreateTempTable(conn, "blob BYTEA");
189              Assert.Throws<ArgumentException>(() => conn.BeginRawBinaryCopy($"COPY {table} (blob) TO STDOUT"));
190              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
191          }
192          using (var conn = await OpenConnectionAsync())
193          {
194              var table = await CreateTempTable(conn, "blob BYTEA");
195              Assert.Throws<ArgumentException>(() => conn.BeginRawBinaryCopy($"COPY {table} (blob) FROM STDIN"));
196              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
197          }
198      }
199      #endregion
200      #region Binary
201      [Test, Description("Roundtrips some data")]
202      public async Task Binary_roundtrip([Values(false, true)] bool async)
203      {
204          using var conn = await OpenConnectionAsync();
205          var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT");
206          var longString = new StringBuilder(conn.Settings.WriteBufferSize + 50).Append('a').ToString();
207          using (var writer = async
208                     ? await conn.BeginBinaryImportAsync($"COPY {table} (field_text, field_int2) FROM STDIN BINARY")
209                     : conn.BeginBinaryImport($"COPY {table} (field_text, field_int2) FROM STDIN BINARY"))
210          {
211              StateAssertions(conn);
212              writer.StartRow();
213              writer.Write("Hello");
214              writer.Write((short)8, NpgsqlDbType.Smallint);
215              writer.WriteRow("Something", (short)9);
216              writer.StartRow();
217              writer.Write(longString, "text");
218              writer.WriteNull();
219              var rowsWritten = writer.Complete();
220              Assert.That(rowsWritten, Is.EqualTo(3));
221          }
222          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
223          using (var reader = async
224                     ? await conn.BeginBinaryExportAsync($"COPY {table} (field_text, field_int2) TO STDIN BINARY")
225                     : conn.BeginBinaryExport($"COPY {table} (field_text, field_int2) TO STDIN BINARY"))
226          {
227              StateAssertions(conn);
228              Assert.That(reader.StartRow(), Is.EqualTo(2));
229              Assert.That(reader.Read<string>(), Is.EqualTo("Hello"));
230              Assert.That(reader.Read<int>(NpgsqlDbType.Smallint), Is.EqualTo(8));
231              Assert.That(reader.StartRow(), Is.EqualTo(2));
232              Assert.That(reader.IsNull, Is.False);
233              Assert.That(reader.Read<string>(), Is.EqualTo("Something"));
234              reader.Skip();
235              Assert.That(reader.StartRow(), Is.EqualTo(2));
236              Assert.That(reader.Read<string>(), Is.EqualTo(longString));
237              Assert.That(reader.IsNull, Is.True);
238              reader.Skip();
239              Assert.That(reader.StartRow(), Is.EqualTo(-1));
240          }
241          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
242      }
243      [Test]
244      public async Task Cancel_binary_import()
245      {
246          using var conn = await OpenConnectionAsync();
247          var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
248          using (var writer = conn.BeginBinaryImport($"COPY {table} (field_text, field_int4) FROM STDIN BINARY"))
249          {
250              writer.StartRow();
251              writer.Write("Hello");
252              writer.Write(8);
253          }
254          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(0));
255      }
256      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/657")]
257      public async Task Import_bytea()
258      {
259          using var conn = await OpenConnectionAsync();
260          var table = await CreateTempTable(conn, "field BYTEA");
261          var data = new byte[] {1, 5, 8};
262          using (var writer = conn.BeginBinaryImport($"COPY {table} (field) FROM STDIN BINARY"))
263          {
264              writer.StartRow();
265              writer.Write(data, NpgsqlDbType.Bytea);
266              var rowsWritten = writer.Complete();
267              Assert.That(rowsWritten, Is.EqualTo(1));
268          }
269          Assert.That(await conn.ExecuteScalarAsync($"SELECT field FROM {table}"), Is.EqualTo(data));
270      }
271      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4693")]
272      public async Task Import_numeric()
273      {
274          await using var conn = await OpenConnectionAsync();
275          var table = await CreateTempTable(conn, "field NUMERIC(1000)");
276          await using (var writer = await conn.BeginBinaryImportAsync($"COPY {table} (field) FROM STDIN BINARY"))
277          {
278              await writer.StartRowAsync();
279              await writer.WriteAsync(new BigInteger(1234), NpgsqlDbType.Numeric);
280              await writer.StartRowAsync();
281              await writer.WriteAsync(new BigInteger(5678), NpgsqlDbType.Numeric);
282              var rowsWritten = await writer.CompleteAsync();
283              Assert.That(rowsWritten, Is.EqualTo(2));
284          }
285          await using var cmd = conn.CreateCommand();
286          cmd.CommandText = $"SELECT field FROM {table}";
287          await using var reader = await cmd.ExecuteReaderAsync();
288          Assert.IsTrue(await reader.ReadAsync());
289          Assert.That(reader.GetValue(0), Is.EqualTo(1234m));
290          Assert.IsTrue(await reader.ReadAsync());
291          Assert.That(reader.GetValue(0), Is.EqualTo(5678m));
292      }
293      [Test]
294      public async Task Import_string_array()
295      {
296          using var conn = await OpenConnectionAsync();
297          var table = await CreateTempTable(conn, "field TEXT[]");
298          var data = new[] {"foo", "a", "bar"};
299          using (var writer = conn.BeginBinaryImport($"COPY {table} (field) FROM STDIN BINARY"))
300          {
301              writer.StartRow();
302              writer.Write(data, NpgsqlDbType.Array | NpgsqlDbType.Text);
303              var rowsWritten = writer.Complete();
304              Assert.That(rowsWritten, Is.EqualTo(1));
305          }
306          Assert.That(await conn.ExecuteScalarAsync($"SELECT field FROM {table}"), Is.EqualTo(data));
307      }
308      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/816")]
309      public async Task Import_string_with_buffer_length()
310      {
311          using var conn = await OpenConnectionAsync();
312          var table = await CreateTempTable(conn, "field TEXT");
313          var data = new string('a', conn.Settings.WriteBufferSize);
314          using (var writer = conn.BeginBinaryImport($"COPY {table} (field) FROM STDIN BINARY"))
315          {
316              writer.StartRow();
317              writer.Write(data, NpgsqlDbType.Text);
318              var rowsWritten = writer.Complete();
319              Assert.That(rowsWritten, Is.EqualTo(1));
320          }
321          Assert.That(await conn.ExecuteScalarAsync($"SELECT field FROM {table}"), Is.EqualTo(data));
322      }
323      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/662")]
324      public async Task Import_direct_buffer()
325      {
326          using var conn = await OpenConnectionAsync();
327          var table = await CreateTempTable(conn, "blob BYTEA");
328          using var writer = conn.BeginBinaryImport($"COPY {table} (blob) FROM STDIN BINARY");
329          var data = new byte[conn.Settings.WriteBufferSize + 10];
330          writer.StartRow();
331          writer.Write(data);
332          writer.StartRow();
333          writer.Write(data);
334      }
335      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
336      public async Task Wrong_table_definition_binary_import()
337      {
338          using var conn = await OpenConnectionAsync();
339          Assert.Throws<PostgresException>(() => conn.BeginBinaryImport("COPY table_is_not_exist (blob) FROM STDIN BINARY"));
340          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
341          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
342      }
343      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
344      public async Task Wrong_format_binary_import()
345      {
346          if (IsMultiplexing)
347              Assert.Ignore("Multiplexing: fails");
348          using var conn = await OpenConnectionAsync();
349          var table = await CreateTempTable(conn, "blob BYTEA");
350          Assert.Throws<ArgumentException>(() => conn.BeginBinaryImport($"COPY {table} (blob) FROM STDIN"));
351          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
352      }
353      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
354      public async Task Wrong_table_definition_binary_export()
355      {
356          using var conn = await OpenConnectionAsync();
357          Assert.Throws<PostgresException>(() => conn.BeginBinaryExport("COPY table_is_not_exist (blob) TO STDOUT BINARY"));
358          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
359          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
360      }
361      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
362      public async Task Wrong_format_binary_export()
363      {
364          if (IsMultiplexing)
365              Assert.Ignore("Multiplexing: fails");
366          using var conn = await OpenConnectionAsync();
367          var table = await CreateTempTable(conn, "blob BYTEA");
368          Assert.Throws<ArgumentException>(() => conn.BeginBinaryExport($"COPY {table} (blob) TO STDOUT"));
369          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
370      }
371      [Test, NonParallelizable, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/661")]
372      [Ignore("Unreliable")]
373      public async Task Unexpected_exception_binary_import()
374      {
375          if (IsMultiplexing)
376              return;
377          await using var dataSource = CreateDataSource();
378          await using var conn = await dataSource.OpenConnectionAsync();
379          var table = await CreateTempTable(conn, "blob BYTEA");
380          var data = new byte[conn.Settings.WriteBufferSize + 10];
381          var writer = conn.BeginBinaryImport($"COPY {table} (blob) FROM STDIN BINARY");
382          using (var conn2 = await OpenConnectionAsync())
383              conn2.ExecuteNonQuery($"SELECT pg_terminate_backend({conn.ProcessID})");
384          Thread.Sleep(50);
385          Assert.That(() =>
386          {
387              writer.StartRow();
388              writer.Write(data);
389              writer.Dispose();
390          }, Throws.Exception.TypeOf<IOException>());
391          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
392      }
393      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/657")]
394      [Explicit]
395      public async Task Import_bytea_massive()
396      {
397          using var conn = await OpenConnectionAsync();
398          var table = await CreateTempTable(conn, "field BYTEA");
399          const int iterations = 10000;
400          var data = new byte[1024*1024];
401          using (var writer = conn.BeginBinaryImport($"COPY {table} (field) FROM STDIN BINARY"))
402          {
403              for (var i = 0; i < iterations; i++)
404              {
405                  if (i%100 == 0)
406                      Console.WriteLine("Iteration " + i);
407                  writer.StartRow();
408                  writer.Write(data, NpgsqlDbType.Bytea);
409              }
410          }
411          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(iterations));
412      }
413      [Test]
414      public async Task Export_long_string()
415      {
416          const int iterations = 100;
417          using var conn = await OpenConnectionAsync();
418          var len = conn.Settings.WriteBufferSize;
419          var table = await CreateTempTable(conn, "foo1 TEXT, foo2 TEXT, foo3 TEXT, foo4 TEXT, foo5 TEXT");
420          using (var cmd = new NpgsqlCommand($"INSERT INTO {table} VALUES (@p, @p, @p, @p, @p)", conn))
421          {
422              cmd.Parameters.AddWithValue("p", new string('x', len));
423              for (var i = 0; i < iterations; i++)
424                  await cmd.ExecuteNonQueryAsync();
425          }
426          using (var reader = conn.BeginBinaryExport($"COPY {table} (foo1, foo2, foo3, foo4, foo5) TO STDIN BINARY"))
427          {
428              for (var row = 0; row < iterations; row++)
429              {
430                  Assert.That(reader.StartRow(), Is.EqualTo(5));
431                  for (var col = 0; col < 5; col++)
432                      Assert.That(reader.Read<string>().Length, Is.EqualTo(len));
433              }
434          }
435      }
436      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1134")]
437      public async Task Read_bit_string()
438      {
439          using var conn = await OpenConnectionAsync();
440          var table = await GetTempTableName(conn);
441          await conn.ExecuteNonQueryAsync($@"
442  CREATE TABLE {table} (bits BIT(3), bitarray BIT(3)[]);
443  INSERT INTO {table} (bits, bitarray) VALUES (B'101', ARRAY[B'101', B'111'])");
444          using var reader = conn.BeginBinaryExport($"COPY {table} (bits, bitarray) TO STDIN BINARY");
445          reader.StartRow();
446          Assert.That(reader.Read<BitArray>(), Is.EqualTo(new BitArray(new[] { true, false, true })));
447          Assert.That(reader.Read<BitArray[]>(), Is.EqualTo(new[]
448          {
449              new BitArray(new[] { true, false, true }),
450              new BitArray(new[] { true, true, true })
451          }));
452      }
453      [Test]
454      public async Task Array()
455      {
456          var expected = new[] { 8 };
457          using var conn = await OpenConnectionAsync();
458          var table = await CreateTempTable(conn, "arr INTEGER[]");
459          using (var writer = conn.BeginBinaryImport($"COPY {table} (arr) FROM STDIN BINARY"))
460          {
461              writer.StartRow();
462              writer.Write(expected);
463              var rowsWritten = writer.Complete();
464              Assert.That(rowsWritten, Is.EqualTo(1));
465          }
466          using (var reader = conn.BeginBinaryExport($"COPY {table} (arr) TO STDIN BINARY"))
467          {
468              reader.StartRow();
469              Assert.That(reader.Read<int[]>(), Is.EqualTo(expected));
470          }
471      }
472      [Test]
473      public async Task Enum()
474      {
475          await using var adminConnection = await OpenConnectionAsync();
476          var type = await GetTempTypeName(adminConnection);
477          await adminConnection.ExecuteNonQueryAsync($"CREATE TYPE {type} AS ENUM ('sad', 'ok', 'happy')");
478          var dataSourceBuilder = CreateDataSourceBuilder();
479          dataSourceBuilder.MapEnum<Mood>(type);
480          await using var dataSource = dataSourceBuilder.Build();
481          await using var connection = await dataSource.OpenConnectionAsync();
482          var table = await CreateTempTable(connection, $"mymood {type}, mymoodarr {type}[]");
483          await using (var writer = await connection.BeginBinaryImportAsync($"COPY {table} (mymood, mymoodarr) FROM STDIN BINARY"))
484          {
485              await writer.StartRowAsync();
486              await writer.WriteAsync(Mood.Happy);
487              await writer.WriteAsync(new[] { Mood.Happy });
488              var rowsWritten = await writer.CompleteAsync();
489              Assert.That(rowsWritten, Is.EqualTo(1));
490          }
491          await using (var reader = await connection.BeginBinaryExportAsync($"COPY {table} (mymood, mymoodarr) TO STDIN BINARY"))
492          {
493              await reader.StartRowAsync();
494              Assert.That(reader.Read<Mood>(), Is.EqualTo(Mood.Happy));
495              Assert.That(reader.Read<Mood[]>(), Is.EqualTo(new[] { Mood.Happy }));
496          }
497      }
498      enum Mood { Sad, Ok, Happy };
499      [Test]
500      public async Task Read_null_as_nullable()
501      {
502          using var connection = await OpenConnectionAsync();
503          using var exporter = connection.BeginBinaryExport("COPY (SELECT NULL::int) TO STDOUT BINARY");
504          exporter.StartRow();
505          Assert.That(exporter.Read<int?>(), Is.Null);
506      }
507      [Test]
508      public async Task Read_null_as_non_nullable_throws()
509      {
510          using var connection = await OpenConnectionAsync();
511          using var exporter = connection.BeginBinaryExport("COPY (SELECT NULL::int) TO STDOUT BINARY");
512          exporter.StartRow();
513          Assert.Throws<InvalidCastException>(() => exporter.Read<int>());
514      }
515      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1440")]
516      public async Task Error_during_import()
517      {
518          using var conn = await OpenConnectionAsync();
519          var table = await CreateTempTable(conn, "foo INT UNIQUE");
520          var writer = conn.BeginBinaryImport($"COPY {table} (foo) FROM STDIN BINARY");
521          writer.StartRow();
522          writer.Write(8);
523          writer.StartRow();
524          writer.Write(8);
525          Assert.That(() => writer.Complete(), Throws.Exception
526              .TypeOf<PostgresException>()
527              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.UniqueViolation));
528          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
529      }
530      [Test]
531      public async Task Import_cannot_write_after_commit()
532      {
533          using var conn = await OpenConnectionAsync();
534          var table = await CreateTempTable(conn, "foo INT");
535          try
536          {
537              using var writer = conn.BeginBinaryImport($"COPY {table} (foo) FROM STDIN BINARY");
538              writer.StartRow();
539              writer.Write(8);
540              var rowsWritten = writer.Complete();
541              Assert.That(rowsWritten, Is.EqualTo(1));
542              writer.StartRow();
543              Assert.Fail("StartRow should have thrown");
544          }
545          catch (InvalidOperationException)
546          {
547              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(1));
548          }
549      }
550      [Test]
551      public async Task Import_commit_in_middle_of_row()
552      {
553          using var conn = await OpenConnectionAsync();
554          var table = await CreateTempTable(conn, "foo INT, bar TEXT");
555          try
556          {
557              using var writer = conn.BeginBinaryImport($"COPY {table} (foo, bar) FROM STDIN BINARY");
558              writer.StartRow();
559              writer.Write(8);
560              writer.Write("hello");
561              writer.StartRow();
562              writer.Write(9);
563              writer.Complete();
564              Assert.Fail("Commit should have thrown");
565          }
566          catch (InvalidOperationException)
567          {
568              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(0));
569          }
570      }
571      [Test]
572      public async Task Import_exception_does_not_commit()
573      {
574          using var conn = await OpenConnectionAsync();
575          var table = await CreateTempTable(conn, "foo INT");
576          try
577          {
578              using var writer = conn.BeginBinaryImport($"COPY {table} (foo) FROM STDIN BINARY");
579              writer.StartRow();
580              writer.Write(8);
581              throw new Exception("FOO");
582          }
583          catch (Exception e) when (e.Message == "FOO")
584          {
585              Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.Zero);
586          }
587      }
588      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2347")]
589      public async Task Write_column_out_of_bounds_throws()
590      {
591          using var conn = await OpenConnectionAsync();
592          var table = await CreateTempTable(conn, "field_text TEXT, field_int2 INTEGER");
593          using var writer = conn.BeginBinaryImport($"COPY {table} (field_text, field_int2) FROM STDIN BINARY");
594          StateAssertions(conn);
595          writer.StartRow();
596          writer.Write("Hello");
597          writer.Write(8, NpgsqlDbType.Smallint);
598          Assert.Throws<InvalidOperationException>(() => writer.Write("I should not be here"));
599          writer.StartRow();
600          writer.Write("Hello");
601          writer.Write(8, NpgsqlDbType.Smallint);
602          Assert.Throws<InvalidOperationException>(() => writer.Write("I should not be here", NpgsqlDbType.Text));
603          writer.StartRow();
604          writer.Write("Hello");
605          writer.Write(8, NpgsqlDbType.Smallint);
606          Assert.Throws<InvalidOperationException>(() => writer.Write("I should not be here", "text"));
607          Assert.Throws<InvalidOperationException>(() => writer.WriteRow("Hello", 8, "I should not be here"));
608      }
609      [Test]
610      public async Task Cancel_raw_binary_export_when_not_consumed_and_then_Dispose()
611      {
612          await using var conn = await OpenConnectionAsync();
613          var stream = conn.BeginRawBinaryCopy("COPY (select md5(random()::text) as id from generate_series(1, 100000)) TO STDOUT BINARY");
614          var buffer = new byte[32];
615          await stream.ReadAsync(buffer, 0, buffer.Length);
616          stream.Cancel();
617          Assert.DoesNotThrowAsync(async () => await stream.DisposeAsync());
618          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1), "The connection is still OK");
619      }
620      [Test]
621      public async Task Cancel_binary_export_when_not_consumed_and_then_Dispose()
622      {
623          await using var conn = await OpenConnectionAsync();
<span onclick='openModal()' class='match'>624          var exporter = conn.BeginBinaryExport("COPY (select md5(random()::text) as id from generate_series(1, 100000)) TO STDOUT BINARY");
625          await exporter.StartRowAsync();
626          await exporter.ReadAsync<string>();
627          exporter.Cancel();
628          Assert.DoesNotThrowAsync(async () => await exporter.DisposeAsync());
629          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1), "The connection is still OK");
630      }
631      [Test]
</span>632      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4417")]
633      public async Task Binary_copy_throws_for_nullable()
634      {
635          await using var conn = await OpenConnectionAsync();
636          var tableName = await CreateTempTable(conn, "house_number integer");
637          await using var writer = await conn.BeginBinaryImportAsync($"COPY {tableName}(house_number) FROM STDIN BINARY");
638          int? value = 1;
639          await writer.StartRowAsync();
640          Assert.ThrowsAsync<InvalidCastException>(async () => await writer.WriteAsync(value, NpgsqlDbType.Integer));
641      }
642      #endregion
643      #region Text
644      [Test]
645      public async Task Text_import([Values(false, true)] bool async)
646      {
647          using var conn = await OpenConnectionAsync();
648          var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
649          const string line = "HELLO\t1\n";
650          var writer = async
651              ? await conn.BeginTextImportAsync($"COPY {table} (field_text, field_int4) FROM STDIN")
652              : conn.BeginTextImport($"COPY {table} (field_text, field_int4) FROM STDIN");
653          StateAssertions(conn);
654          writer.Write(line);
655          writer.Dispose();
656          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table} WHERE field_int4=1"), Is.EqualTo(1));
657          Assert.That(() => writer.Write(line), Throws.Exception.TypeOf<ObjectDisposedException>());
658          await conn.ExecuteNonQueryAsync($"TRUNCATE {table}");
659          var iterations = NpgsqlWriteBuffer.MinimumSize/line.Length + 100;
660          writer = async
661              ? await conn.BeginTextImportAsync($"COPY {table} (field_text, field_int4) FROM STDIN")
662              : conn.BeginTextImport($"COPY {table} (field_text, field_int4) FROM STDIN");
663          for (var i = 0; i < iterations; i++)
664              writer.Write(line);
665          writer.Dispose();
666          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table} WHERE field_int4=1"), Is.EqualTo(iterations));
667      }
668      [Test]
669      public async Task Cancel_text_import()
670      {
671          using var conn = await OpenConnectionAsync();
672          var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
673          var writer = (NpgsqlCopyTextWriter)conn.BeginTextImport($"COPY {table} (field_text, field_int4) FROM STDIN");
674          writer.Write("HELLO\t1\n");
675          writer.Cancel();
676          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(0));
677      }
678      [Test]
679      public async Task Text_import_empty()
680      {
681          using var conn = await OpenConnectionAsync();
682          var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
683          using (conn.BeginTextImport($"COPY {table} (field_text, field_int4) FROM STDIN"))
684          {
685          }
686          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(0));
687      }
688      [Test]
689      public async Task Text_export([Values(false, true)] bool async)
690      {
691          using var conn = await OpenConnectionAsync();
692          var table = await GetTempTableName(conn);
693          await conn.ExecuteNonQueryAsync($@"
694  CREATE  TABLE {table} (field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER);
695  INSERT INTO {table} (field_text, field_int4) VALUES ('HELLO', 1)");
696          var chars = new char[30];
697          var reader = async
698              ? await conn.BeginTextExportAsync($"COPY {table} (field_text, field_int4) TO STDIN")
699              : conn.BeginTextExport($"COPY {table} (field_text, field_int4) TO STDIN");
700          StateAssertions(conn);
701          Assert.That(reader.Read(chars, 0, chars.Length), Is.EqualTo(8));
702          Assert.That(new string(chars, 0, 8), Is.EqualTo("HELLO\t1\n"));
703          Assert.That(reader.Read(chars, 0, chars.Length), Is.EqualTo(0));
704          Assert.That(reader.Read(chars, 0, chars.Length), Is.EqualTo(0));
705          reader.Dispose();
706          Assert.That(() => reader.Read(chars, 0, chars.Length), Throws.Exception.TypeOf<ObjectDisposedException>());
707          await conn.ExecuteNonQueryAsync($"TRUNCATE {table}");
708      }
709      [Test]
710      public async Task Dispose_in_middle_of_text_export()
711      {
712          using var conn = await OpenConnectionAsync();
713          var table = await GetTempTableName(conn);
714          await conn.ExecuteNonQueryAsync($@"
715  CREATE TABLE {table} (field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER);
716  INSERT INTO {table} (field_text, field_int4) VALUES ('HELLO', 1)");
717          var reader = conn.BeginTextExport($"COPY {table} (field_text, field_int4) TO STDIN");
718          reader.Dispose();
719          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
720      }
721      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
722      public async Task Wrong_table_definition_text_import()
723      {
724          if (IsMultiplexing)
725              Assert.Ignore("Multiplexing: fails");
726          using var conn = await OpenConnectionAsync();
727          Assert.Throws<PostgresException>(() => conn.BeginTextImport("COPY table_is_not_exist (blob) FROM STDIN"));
728          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
729          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
730      }
731      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
732      public async Task Wrong_format_text_import()
733      {
734          if (IsMultiplexing)
735              Assert.Ignore("Multiplexing: fails");
736          using var conn = await OpenConnectionAsync();
737          var table = await CreateTempTable(conn, "blob BYTEA");
738          Assert.Throws<Exception>(() => conn.BeginTextImport($"COPY {table} (blob) FROM STDIN BINARY"));
739          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
740      }
741      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
742      public async Task Wrong_table_definition_text_export()
743      {
744          if (IsMultiplexing)
745              Assert.Ignore("Multiplexing: fails");
746          using var conn = await OpenConnectionAsync();
747          Assert.Throws<PostgresException>(() => conn.BeginTextExport("COPY table_is_not_exist (blob) TO STDOUT"));
748          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
749          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
750      }
751      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2330")]
752      public async Task Wrong_format_text_export()
753      {
754          if (IsMultiplexing)
755              Assert.Ignore("Multiplexing: fails");
756          using var conn = await OpenConnectionAsync();
757          var table = await CreateTempTable(conn, "blob BYTEA");
758          Assert.Throws<Exception>(() => conn.BeginTextExport($"COPY {table} (blob) TO STDOUT BINARY"));
759          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
760      }
761      [Test]
762      public async Task Cancel_text_export_when_not_consumed_and_then_Dispose()
763      {
764          await using var conn = await OpenConnectionAsync();
765          var reader = (NpgsqlCopyTextReader) conn.BeginTextExport("COPY (select md5(random()::text) as id from generate_series(1, 100000)) TO STDOUT");
766          var buffer = new char[32];
767          await reader.ReadAsync(buffer, 0, buffer.Length);
768          reader.Cancel();
769          Assert.DoesNotThrow(reader.Dispose);
770          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1), "The connection is still OK");
771      }
772      #endregion
773      #region Other
774      [Test, Description("Starts a transaction before a COPY, testing that prepended messages are handled well")]
775      public async Task Prepended_messages()
776      {
777          using var conn = await OpenConnectionAsync();
778          conn.BeginTransaction();
779          await Text_import(async: false);
780      }
781      [Test]
782      public async Task Undefined_table_throws()
783      {
784          using var conn = await OpenConnectionAsync();
785          Assert.That(() => conn.BeginBinaryImport("COPY undefined_table (field_text, field_int2) FROM STDIN BINARY"),
786              Throws.Exception
787                  .TypeOf<PostgresException>()
788                  .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.UndefinedTable)
789          );
790      }
791      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/621")]
792      public async Task Close_during_copy_throws()
793      {
794          using (var conn = await OpenConnectionAsync()) {
795              var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
796              conn.BeginBinaryImport($"COPY {table} (field_text, field_int4) FROM STDIN BINARY");
797          }
798          using (var conn = await OpenConnectionAsync()) {
799              var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
800              conn.BeginBinaryExport($"COPY {table} (field_text, field_int2) TO STDIN BINARY");
801          }
802          using (var conn = await OpenConnectionAsync()) {
803              var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
804              conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) FROM STDIN BINARY");
805          }
806          using (var conn = await OpenConnectionAsync()) {
807              var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
808              conn.BeginRawBinaryCopy($"COPY {table} (field_text, field_int4) TO STDIN BINARY");
809          }
810          using (var conn = await OpenConnectionAsync()) {
811              var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
812              conn.BeginTextImport($"COPY {table} (field_text, field_int4) FROM STDIN");
813          }
814          using (var conn = await OpenConnectionAsync()) {
815              var table = await CreateTempTable(conn, "field_text TEXT, field_int2 SMALLINT, field_int4 INTEGER");
816              conn.BeginTextExport($"COPY {table} (field_text, field_int4) TO STDIN");
817          }
818      }
819      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/994")]
820      public async Task Non_ascii_column_name()
821      {
822          using var conn = await OpenConnectionAsync();
823          var table = await CreateTempTable(conn, "non_ascii_ TEXT");
824          using (conn.BeginBinaryImport($"COPY {table} (non_ascii_) FROM STDIN BINARY")) { }
825      }
826      [Test, IssueLink("https:&bsol;&bsol;stackoverflow.com/questions/37431054/08p01-insufficient-data-left-in-message-for-nullable-datetime/37431464")]
827      public async Task Write_null_values()
828      {
829          using var conn = await OpenConnectionAsync();
830          var table = await CreateTempTable(conn, "foo1 INT, foo2 UUID, foo3 INT, foo4 UUID");
831          using (var writer = conn.BeginBinaryImport($"COPY {table} (foo1, foo2, foo3, foo4) FROM STDIN BINARY"))
832          {
833              writer.StartRow();
834              writer.Write(DBNull.Value, NpgsqlDbType.Integer);
835              writer.Write((string?)null, NpgsqlDbType.Uuid);
836              writer.Write(DBNull.Value);
837              writer.Write((string?)null);
838              var rowsWritten = writer.Complete();
839              Assert.That(rowsWritten, Is.EqualTo(1));
840          }
841          using (var cmd = new NpgsqlCommand($"SELECT foo1,foo2,foo3,foo4 FROM {table}", conn))
842          using (var reader = await cmd.ExecuteReaderAsync())
843          {
844              Assert.That(reader.Read(), Is.True);
845              for (var i = 0; i < reader.FieldCount; i++)
846                  Assert.That(reader.IsDBNull(i), Is.True);
847          }
848      }
849      [Test]
850      public async Task Write_different_types()
851      {
852          using var conn = await OpenConnectionAsync();
853          var table = await CreateTempTable(conn, "foo INT, bar INT[]");
854          using (var writer = conn.BeginBinaryImport($"COPY {table} (foo, bar) FROM STDIN BINARY"))
855          {
856              writer.StartRow();
857              writer.Write(3.0, NpgsqlDbType.Integer);
858              writer.Write((object)new[] { 1, 2, 3 });
859              writer.StartRow();
860              writer.Write(3, NpgsqlDbType.Integer);
861              writer.Write((object)new List<int> { 4, 5, 6 });
862              var rowsWritten = writer.Complete();
863              Assert.That(rowsWritten, Is.EqualTo(2));
864          }
865          Assert.That(await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(2));
866      }
867      [Test, Description("Tests nested binding scopes in multiplexing")]
868      public async Task Within_transaction()
869      {
870          using var conn = await OpenConnectionAsync();
871          var table = await CreateTempTable(conn, "foo INT");
872          using (var tx = conn.BeginTransaction())
873          using (var writer = conn.BeginBinaryImport($"COPY {table} (foo) FROM STDIN BINARY"))
874          {
875              writer.StartRow();
876              writer.Write(1);
877              writer.Dispose();
878              await tx.CommitAsync();
879          }
880          using (var tx = conn.BeginTransaction())
881          using (var writer = conn.BeginBinaryImport($"COPY {table} (foo) FROM STDIN BINARY"))
882          {
883              writer.StartRow();
884              writer.Write(2);
885              writer.Complete();
886          }
887          using (var tx = conn.BeginTransaction())
888          {
889              using (var writer = conn.BeginBinaryImport($"COPY {table} (foo) FROM STDIN BINARY"))
890              {
891                  writer.StartRow();
892                  writer.Write(3);
893                  writer.Complete();
894              }
895              await tx.CommitAsync();
896          }
897          Assert.That(async () => await conn.ExecuteScalarAsync($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(1));
898          Assert.That(async () => await conn.ExecuteScalarAsync($"SELECT foo FROM {table}"), Is.EqualTo(3));
899      }
900      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4199")]
901      public async Task Copy_from_is_not_supported_in_regular_command_execution()
902      {
903          await using var dataSource = CreateDataSource();
904          await using var conn = await dataSource.OpenConnectionAsync();
905          var table = await CreateTempTable(conn, "foo INT");
906          Assert.That(() => conn.ExecuteNonQuery($@"COPY {table} (foo) FROM stdin"), Throws.Exception.TypeOf<NotSupportedException>());
907      }
908      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4974")]
909      public async Task Copy_to_is_not_supported_in_regular_command_execution()
910      {
911          await using var dataSource = CreateDataSource();
912          await using var conn = await dataSource.OpenConnectionAsync();
913          var table = await CreateTempTable(conn, "foo INT");
914          Assert.That(() => conn.ExecuteNonQuery($@"COPY {table} (foo) TO stdin"), Throws.Exception.TypeOf<NotSupportedException>());
915      }
916      #endregion
917      #region Utils
918      void StateAssertions(NpgsqlConnection conn)
919      {
920          Assert.That(conn.Connector!.State, Is.EqualTo(ConnectorState.Copy));
921          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
922          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
923          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
924      }
925      #endregion
926      public CopyTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
927  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-DrawerTest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CopyTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>89              comp.Instance.Drawer.Open.Should().BeTrue();
90              comp.Find("button").Click();
91              comp.FindAll("aside.mud-drawer--closed.mud-drawer-persistent").Count.Should().Be(1);
92              comp.Instance.Drawer.Open.Should().BeFalse();
93          }
94          [Test]
</pre></code></div>
                <div class="column column_space"><pre><code>624          var exporter = conn.BeginBinaryExport("COPY (select md5(random()::text) as id from generate_series(1, 100000)) TO STDOUT BINARY");
625          await exporter.StartRowAsync();
626          await exporter.ReadAsync<string>();
627          exporter.Cancel();
628          Assert.DoesNotThrowAsync(async () => await exporter.DisposeAsync());
629          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1), "The connection is still OK");
630      }
631      [Test]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    