
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 65, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateToken.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Runtime.Serialization;
5  using GitHub.DistributedTask.Expressions2;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.Services.WebApi.Internal;
8  using Newtonsoft.Json;
9  namespace GitHub.DistributedTask.ObjectTemplating.Tokens
10  {
11      [DataContract]
12      [JsonConverter(typeof(TemplateTokenJsonConverter))]
13      [ClientIgnore]
14      [EditorBrowsable(EditorBrowsableState.Never)]
15      public abstract class TemplateToken
16      {
17          protected TemplateToken(
18              Int32 type,
19              Int32? fileId,
20              Int32? line,
21              Int32? column)
22          {
23              Type = type;
24              FileId = fileId;
25              Line = line;
26              Column = column;
27          }
28          [DataMember(Name = "file", EmitDefaultValue = false)]
29          internal Int32? FileId { get; private set; }
30          [DataMember(Name = "line", EmitDefaultValue = false)]
31          internal Int32? Line { get; private set; }
32          [DataMember(Name = "col", EmitDefaultValue = false)]
33          internal Int32? Column { get; private set; }
34          [DataMember(Name = "type", EmitDefaultValue = false)]
35          internal Int32 Type { get; }
36          public TemplateToken Clone()
37          {
38              return Clone(false);
39          }
40          public abstract TemplateToken Clone(Boolean omitSource);
41          protected StringToken EvaluateStringToken(
42              TemplateContext context,
43              String expression,
44              out Int32 bytes)
45          {
46              var originalBytes = context.Memory.CurrentBytes;
47              try
48              {
49                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
50                  var options = new EvaluationOptions
51                  {
52                      MaxMemory = context.Memory.MaxBytes,
53                  };
54                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
55                  if (result.Raw is LiteralToken literalToken)
56                  {
57                      var stringToken = new StringToken(FileId, Line, Column, literalToken.ToString());
58                      context.Memory.AddBytes(stringToken);
59                      return stringToken;
60                  }
61                  if (!result.IsPrimitive)
62                  {
63                      context.Error(this, "Expected a string");
64                      return CreateStringToken(context, expression);
65                  }
66                  var stringValue = result.Kind == ValueKind.Null ? String.Empty : result.ConvertToString();
67                  return CreateStringToken(context, stringValue);
68              }
69              finally
70              {
71                  bytes = context.Memory.CurrentBytes - originalBytes;
72              }
73          }
74          protected SequenceToken EvaluateSequenceToken(
75              TemplateContext context,
76              String expression,
77              out Int32 bytes)
78          {
79              var originalBytes = context.Memory.CurrentBytes;
80              try
81              {
82                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
83                  var options = new EvaluationOptions
84                  {
85                      MaxMemory = context.Memory.MaxBytes,
86                  };
87                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
88                  var templateToken = ConvertToTemplateToken(context, result);
89                  if (templateToken is SequenceToken sequence)
90                  {
91                      return sequence;
92                  }
93                  context.Error(this, TemplateStrings.ExpectedSequence());
94                  return CreateSequenceToken(context);
95              }
96              finally
97              {
98                  bytes = context.Memory.CurrentBytes - originalBytes;
99              }
100          }
101          protected MappingToken EvaluateMappingToken(
102              TemplateContext context,
103              String expression,
104              out Int32 bytes)
105          {
106              var originalBytes = context.Memory.CurrentBytes;
<span onclick='openModal()' class='match'>107              try
108              {
109                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
110                  var options = new EvaluationOptions
111                  {
112                      MaxMemory = context.Memory.MaxBytes,
113                  };
114                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
115                  var templateToken = ConvertToTemplateToken(context, result);
</span>116                  if (templateToken is MappingToken mapping)
117                  {
118                      return mapping;
119                  }
120                  context.Error(this, TemplateStrings.ExpectedMapping());
121                  return CreateMappingToken(context);
122              }
123              finally
124              {
125                  bytes = context.Memory.CurrentBytes - originalBytes;
126              }
127          }
128          protected TemplateToken EvaluateTemplateToken(
129              TemplateContext context,
130              String expression,
131              out Int32 bytes)
132          {
133              var originalBytes = context.Memory.CurrentBytes;
134              try
135              {
136                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
137                  var options = new EvaluationOptions
138                  {
139                      MaxMemory = context.Memory.MaxBytes,
140                  };
141                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
142                  return ConvertToTemplateToken(context, result);
143              }
144              finally
145              {
146                  bytes = context.Memory.CurrentBytes - originalBytes;
147              }
148          }
149          private TemplateToken ConvertToTemplateToken(
150              TemplateContext context,
151              EvaluationResult result)
152          {
153              if (TryConvertToLiteralToken(context, result, out LiteralToken literal))
154              {
155                  return literal;
156              }
157              else if (!Object.ReferenceEquals(result.Raw, null))
158              {
159                  if (result.Raw is SequenceToken sequence)
160                  {
161                      context.Memory.AddBytes(sequence, true);
162                      return sequence;
163                  }
164                  else if (result.Raw is MappingToken mapping)
165                  {
166                      context.Memory.AddBytes(mapping, true);
167                      return mapping;
168                  }
169              }
170              if (result.TryGetCollectionInterface(out Object collection))
171              {
172                  if (collection is IReadOnlyObject dictionary)
173                  {
174                      var mapping = CreateMappingToken(context);
175                      foreach (KeyValuePair<String, Object> pair in dictionary)
176                      {
177                          var keyToken = CreateStringToken(context, pair.Key);
178                          var valueResult = EvaluationResult.CreateIntermediateResult(null, pair.Value);
179                          var valueToken = ConvertToTemplateToken(context, valueResult);
180                          mapping.Add(keyToken, valueToken);
181                      }
182                      return mapping;
183                  }
184                  else if (collection is IReadOnlyArray list)
185                  {
186                      var sequence = CreateSequenceToken(context);
187                      foreach (var item in list)
188                      {
189                          var itemResult = EvaluationResult.CreateIntermediateResult(null, item);
190                          var itemToken = ConvertToTemplateToken(context, itemResult);
191                          sequence.Add(itemToken);
192                      }
193                      return sequence;
194                  }
195              }
196              throw new ArgumentException(TemplateStrings.UnableToConvertToTemplateToken(result.Value?.GetType().FullName));
197          }
198          private Boolean TryConvertToLiteralToken(
199              TemplateContext context,
200              EvaluationResult result,
201              out LiteralToken literal)
202          {
203              if (result.Raw is LiteralToken literal2)
204              {
205                  context.Memory.AddBytes(literal2);
206                  literal = literal2;
207                  return true;
208              }
209              switch (result.Kind)
210              {
211                  case ValueKind.Null:
212                      literal = new NullToken(FileId, Line, Column);
213                      break;
214                  case ValueKind.Boolean:
215                      literal = new BooleanToken(FileId, Line, Column, (Boolean)result.Value);
216                      break;
217                  case ValueKind.Number:
218                      literal = new NumberToken(FileId, Line, Column, (Double)result.Value);
219                      break;
220                  case ValueKind.String:
221                      literal = new StringToken(FileId, Line, Column, (String)result.Value);
222                      break;
223                  default:
224                      literal = null;
225                      return false;
226              }
227              context.Memory.AddBytes(literal);
228              return true;
229          }
230          private StringToken CreateStringToken(
231              TemplateContext context,
232              String value)
233          {
234              var result = new StringToken(FileId, Line, Column, value);
235              context.Memory.AddBytes(result);
236              return result;
237          }
238          private SequenceToken CreateSequenceToken(TemplateContext context)
239          {
240              var result = new SequenceToken(FileId, Line, Column);
241              context.Memory.AddBytes(result);
242              return result;
243          }
244          private MappingToken CreateMappingToken(TemplateContext context)
245          {
246              var result = new MappingToken(FileId, Line, Column);
247              context.Memory.AddBytes(result);
248              return result;
249          }
250      }
251  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateToken.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Runtime.Serialization;
5  using GitHub.DistributedTask.Expressions2;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.Services.WebApi.Internal;
8  using Newtonsoft.Json;
9  namespace GitHub.DistributedTask.ObjectTemplating.Tokens
10  {
11      [DataContract]
12      [JsonConverter(typeof(TemplateTokenJsonConverter))]
13      [ClientIgnore]
14      [EditorBrowsable(EditorBrowsableState.Never)]
15      public abstract class TemplateToken
16      {
17          protected TemplateToken(
18              Int32 type,
19              Int32? fileId,
20              Int32? line,
21              Int32? column)
22          {
23              Type = type;
24              FileId = fileId;
25              Line = line;
26              Column = column;
27          }
28          [DataMember(Name = "file", EmitDefaultValue = false)]
29          internal Int32? FileId { get; private set; }
30          [DataMember(Name = "line", EmitDefaultValue = false)]
31          internal Int32? Line { get; private set; }
32          [DataMember(Name = "col", EmitDefaultValue = false)]
33          internal Int32? Column { get; private set; }
34          [DataMember(Name = "type", EmitDefaultValue = false)]
35          internal Int32 Type { get; }
36          public TemplateToken Clone()
37          {
38              return Clone(false);
39          }
40          public abstract TemplateToken Clone(Boolean omitSource);
41          protected StringToken EvaluateStringToken(
42              TemplateContext context,
43              String expression,
44              out Int32 bytes)
45          {
46              var originalBytes = context.Memory.CurrentBytes;
47              try
48              {
49                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
50                  var options = new EvaluationOptions
51                  {
52                      MaxMemory = context.Memory.MaxBytes,
53                  };
54                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
55                  if (result.Raw is LiteralToken literalToken)
56                  {
57                      var stringToken = new StringToken(FileId, Line, Column, literalToken.ToString());
58                      context.Memory.AddBytes(stringToken);
59                      return stringToken;
60                  }
61                  if (!result.IsPrimitive)
62                  {
63                      context.Error(this, "Expected a string");
64                      return CreateStringToken(context, expression);
65                  }
66                  var stringValue = result.Kind == ValueKind.Null ? String.Empty : result.ConvertToString();
67                  return CreateStringToken(context, stringValue);
68              }
69              finally
70              {
71                  bytes = context.Memory.CurrentBytes - originalBytes;
72              }
73          }
74          protected SequenceToken EvaluateSequenceToken(
75              TemplateContext context,
76              String expression,
77              out Int32 bytes)
78          {
79              var originalBytes = context.Memory.CurrentBytes;
80              try
81              {
82                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
83                  var options = new EvaluationOptions
84                  {
85                      MaxMemory = context.Memory.MaxBytes,
86                  };
87                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
88                  var templateToken = ConvertToTemplateToken(context, result);
89                  if (templateToken is SequenceToken sequence)
90                  {
91                      return sequence;
92                  }
93                  context.Error(this, TemplateStrings.ExpectedSequence());
94                  return CreateSequenceToken(context);
95              }
96              finally
97              {
98                  bytes = context.Memory.CurrentBytes - originalBytes;
99              }
100          }
101          protected MappingToken EvaluateMappingToken(
102              TemplateContext context,
103              String expression,
104              out Int32 bytes)
105          {
106              var originalBytes = context.Memory.CurrentBytes;
<span onclick='openModal()' class='match'>107              try
108              {
109                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
110                  var options = new EvaluationOptions
111                  {
112                      MaxMemory = context.Memory.MaxBytes,
113                  };
114                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
115                  var templateToken = ConvertToTemplateToken(context, result);
</span>116                  if (templateToken is MappingToken mapping)
117                  {
118                      return mapping;
119                  }
120                  context.Error(this, TemplateStrings.ExpectedMapping());
121                  return CreateMappingToken(context);
122              }
123              finally
124              {
125                  bytes = context.Memory.CurrentBytes - originalBytes;
126              }
127          }
128          protected TemplateToken EvaluateTemplateToken(
129              TemplateContext context,
130              String expression,
131              out Int32 bytes)
132          {
133              var originalBytes = context.Memory.CurrentBytes;
134              try
135              {
136                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
137                  var options = new EvaluationOptions
138                  {
139                      MaxMemory = context.Memory.MaxBytes,
140                  };
141                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
142                  return ConvertToTemplateToken(context, result);
143              }
144              finally
145              {
146                  bytes = context.Memory.CurrentBytes - originalBytes;
147              }
148          }
149          private TemplateToken ConvertToTemplateToken(
150              TemplateContext context,
151              EvaluationResult result)
152          {
153              if (TryConvertToLiteralToken(context, result, out LiteralToken literal))
154              {
155                  return literal;
156              }
157              else if (!Object.ReferenceEquals(result.Raw, null))
158              {
159                  if (result.Raw is SequenceToken sequence)
160                  {
161                      context.Memory.AddBytes(sequence, true);
162                      return sequence;
163                  }
164                  else if (result.Raw is MappingToken mapping)
165                  {
166                      context.Memory.AddBytes(mapping, true);
167                      return mapping;
168                  }
169              }
170              if (result.TryGetCollectionInterface(out Object collection))
171              {
172                  if (collection is IReadOnlyObject dictionary)
173                  {
174                      var mapping = CreateMappingToken(context);
175                      foreach (KeyValuePair<String, Object> pair in dictionary)
176                      {
177                          var keyToken = CreateStringToken(context, pair.Key);
178                          var valueResult = EvaluationResult.CreateIntermediateResult(null, pair.Value);
179                          var valueToken = ConvertToTemplateToken(context, valueResult);
180                          mapping.Add(keyToken, valueToken);
181                      }
182                      return mapping;
183                  }
184                  else if (collection is IReadOnlyArray list)
185                  {
186                      var sequence = CreateSequenceToken(context);
187                      foreach (var item in list)
188                      {
189                          var itemResult = EvaluationResult.CreateIntermediateResult(null, item);
190                          var itemToken = ConvertToTemplateToken(context, itemResult);
191                          sequence.Add(itemToken);
192                      }
193                      return sequence;
194                  }
195              }
196              throw new ArgumentException(TemplateStrings.UnableToConvertToTemplateToken(result.Value?.GetType().FullName));
197          }
198          private Boolean TryConvertToLiteralToken(
199              TemplateContext context,
200              EvaluationResult result,
201              out LiteralToken literal)
202          {
203              if (result.Raw is LiteralToken literal2)
204              {
205                  context.Memory.AddBytes(literal2);
206                  literal = literal2;
207                  return true;
208              }
209              switch (result.Kind)
210              {
211                  case ValueKind.Null:
212                      literal = new NullToken(FileId, Line, Column);
213                      break;
214                  case ValueKind.Boolean:
215                      literal = new BooleanToken(FileId, Line, Column, (Boolean)result.Value);
216                      break;
217                  case ValueKind.Number:
218                      literal = new NumberToken(FileId, Line, Column, (Double)result.Value);
219                      break;
220                  case ValueKind.String:
221                      literal = new StringToken(FileId, Line, Column, (String)result.Value);
222                      break;
223                  default:
224                      literal = null;
225                      return false;
226              }
227              context.Memory.AddBytes(literal);
228              return true;
229          }
230          private StringToken CreateStringToken(
231              TemplateContext context,
232              String value)
233          {
234              var result = new StringToken(FileId, Line, Column, value);
235              context.Memory.AddBytes(result);
236              return result;
237          }
238          private SequenceToken CreateSequenceToken(TemplateContext context)
239          {
240              var result = new SequenceToken(FileId, Line, Column);
241              context.Memory.AddBytes(result);
242              return result;
243          }
244          private MappingToken CreateMappingToken(TemplateContext context)
245          {
246              var result = new MappingToken(FileId, Line, Column);
247              context.Memory.AddBytes(result);
248              return result;
249          }
250      }
251  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateToken.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateToken.cs</div>
                </div>
                <div class="column column_space"><pre><code>107              try
108              {
109                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
110                  var options = new EvaluationOptions
111                  {
112                      MaxMemory = context.Memory.MaxBytes,
113                  };
114                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
115                  var templateToken = ConvertToTemplateToken(context, result);
</pre></code></div>
                <div class="column column_space"><pre><code>107              try
108              {
109                  var tree = new ExpressionParser().CreateTree(expression, null, context.GetExpressionNamedValues(), context.ExpressionFunctions);
110                  var options = new EvaluationOptions
111                  {
112                      MaxMemory = context.Memory.MaxBytes,
113                  };
114                  var result = tree.Evaluate(context.TraceWriter.ToExpressionTraceWriter(), null, context, options);
115                  var templateToken = ConvertToTemplateToken(context, result);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    