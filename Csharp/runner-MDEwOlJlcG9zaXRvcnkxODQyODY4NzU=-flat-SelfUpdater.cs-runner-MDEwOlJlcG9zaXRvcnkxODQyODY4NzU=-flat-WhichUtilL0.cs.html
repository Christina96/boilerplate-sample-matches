
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-SelfUpdater.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Diagnostics;
5  using System.IO;
6  using System.IO.Compression;
7  using System.Linq;
8  using System.Net.Http;
9  using System.Reflection;
10  using System.Security.Cryptography;
11  using System.Threading;
12  using System.Threading.Tasks;
13  using GitHub.DistributedTask.WebApi;
14  using GitHub.Runner.Common;
15  using GitHub.Runner.Common.Util;
16  using GitHub.Runner.Sdk;
17  using GitHub.Services.Common;
18  using GitHub.Services.WebApi;
19  namespace GitHub.Runner.Listener
20  {
21      [ServiceLocator(Default = typeof(SelfUpdater))]
22      public interface ISelfUpdater : IRunnerService
23      {
24          bool Busy { get; }
25          Task<bool> SelfUpdate(AgentRefreshMessage updateMessage, IJobDispatcher jobDispatcher, bool restartInteractiveRunner, CancellationToken token);
26      }
27      public class SelfUpdater : RunnerService, ISelfUpdater
28      {
29          private static string _packageType = "agent";
30          private static string _platform = BuildConstants.RunnerPackage.PackageName;
31          private static string _dotnetRuntime = "dotnetRuntime";
32          private static string _externals = "externals";
33          private readonly Dictionary<string, string> _contentHashes = new();
34          private PackageMetadata _targetPackage;
35          private ITerminal _terminal;
36          private IRunnerServer _runnerServer;
37          private int _poolId;
38          private int _agentId;
39          private readonly ConcurrentQueue<string> _updateTrace = new();
40          private Task _cloneAndCalculateContentHashTask;
41          private string _dotnetRuntimeCloneDirectory;
42          private string _externalsCloneDirectory;
43          public bool Busy { get; private set; }
44          public override void Initialize(IHostContext hostContext)
45          {
46              base.Initialize(hostContext);
47              _terminal = hostContext.GetService<ITerminal>();
48              _runnerServer = HostContext.GetService<IRunnerServer>();
49              var configStore = HostContext.GetService<IConfigurationStore>();
50              var settings = configStore.GetSettings();
51              _poolId = settings.PoolId;
52              _agentId = settings.AgentId;
53              _dotnetRuntimeCloneDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Work), "__dotnet_runtime__");
54              _externalsCloneDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Work), "__externals__");
55          }
56          public async Task<bool> SelfUpdate(AgentRefreshMessage updateMessage, IJobDispatcher jobDispatcher, bool restartInteractiveRunner, CancellationToken token)
57          {
58              Busy = true;
59              try
60              {
61                  var totalUpdateTime = Stopwatch.StartNew();
62                  var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token);
63                  _cloneAndCalculateContentHashTask = CloneAndCalculateAssetsHash(_dotnetRuntimeCloneDirectory, _externalsCloneDirectory, linkedTokenSource.Token);
64                  if (!await UpdateNeeded(updateMessage.TargetVersion, token))
65                  {
66                      Trace.Info($"Can't find available update package.");
67                      return false;
68                  }
69                  Trace.Info($"An update is available.");
70                  _updateTrace.Enqueue($"RunnerPlatform: {_targetPackage.Platform}");
71                  await UpdateRunnerUpdateStateAsync("Runner update in progress, do not shutdown runner.");
72                  await UpdateRunnerUpdateStateAsync($"Downloading {_targetPackage.Version} runner");
73                  if (_targetPackage.TrimmedPackages?.Count > 0)
74                  {
75                      await _cloneAndCalculateContentHashTask;
76                  }
77                  else
78                  {
79                      linkedTokenSource.Cancel();
80                      try
81                      {
82                          await _cloneAndCalculateContentHashTask;
83                      }
84                      catch (Exception ex)
85                      {
86                          Trace.Info($"Ingore errors after cancelling cloning assets task: {ex}");
87                      }
88                  }
89                  await DownloadLatestRunner(token, updateMessage.TargetVersion);
90                  Trace.Info($"Download latest runner and unzip into runner root.");
91                  await UpdateRunnerUpdateStateAsync("Waiting for current job finish running.");
92                  await jobDispatcher.WaitAsync(token);
93                  Trace.Info($"All running job has exited.");
94                  var stopWatch = Stopwatch.StartNew();
95                  DeletePreviousVersionRunnerBackup(token);
96                  Trace.Info($"Delete old version runner backup.");
97                  stopWatch.Stop();
98                  _updateTrace.Enqueue($"DeleteRunnerBackupTime: {stopWatch.ElapsedMilliseconds}ms");
99                  await UpdateRunnerUpdateStateAsync("Generate and execute update script.");
100                  string updateScript = GenerateUpdateScript(restartInteractiveRunner);
101                  Trace.Info($"Generate update script into: {updateScript}");
102                  if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable("_GITHUB_ACTION_EXECUTE_UPDATE_SCRIPT")))
103                  {
104                      string flagFile = "update.finished";
105                      IOUtil.DeleteFile(flagFile);
106                      Process invokeScript = new();
107  #if OS_WINDOWS
108                      invokeScript.StartInfo.FileName = WhichUtil.Which("cmd.exe", trace: Trace);
109                      invokeScript.StartInfo.Arguments = $"/c \"{updateScript}\"";
110  #elif (OS_OSX || OS_LINUX)
111                      invokeScript.StartInfo.FileName = WhichUtil.Which("bash", trace: Trace);
112                      invokeScript.StartInfo.Arguments = $"\"{updateScript}\"";
113  #endif
114                      invokeScript.Start();
115                      Trace.Info($"Update script start running");
116                  }
117                  totalUpdateTime.Stop();
118                  _updateTrace.Enqueue($"TotalUpdateTime: {totalUpdateTime.ElapsedMilliseconds}ms");
119                  await UpdateRunnerUpdateStateAsync("Runner will exit shortly for update, should be back online within 10 seconds.");
120                  return true;
121              }
122              catch (Exception ex)
123              {
124                  _updateTrace.Enqueue(ex.ToString());
125                  throw;
126              }
127              finally
128              {
129                  await UpdateRunnerUpdateStateAsync("Runner update process finished.");
130                  Busy = false;
131              }
132          }
133          private async Task<bool> UpdateNeeded(string targetVersion, CancellationToken token)
134          {
135              if (string.IsNullOrEmpty(targetVersion))
136              {
137                  var packages = await _runnerServer.GetPackagesAsync(_packageType, _platform, 1, true, token);
138                  if (packages == null || packages.Count == 0)
139                  {
140                      Trace.Info($"There is no package for {_packageType} and {_platform}.");
141                      return false;
142                  }
143                  _targetPackage = packages.FirstOrDefault();
144              }
145              else
146              {
147                  _targetPackage = await _runnerServer.GetPackageAsync(_packageType, _platform, targetVersion, true, token);
148                  if (_targetPackage == null)
149                  {
150                      Trace.Info($"There is no package for {_packageType} and {_platform} with version {targetVersion}.");
151                      return false;
152                  }
153              }
154              Trace.Info($"Version '{_targetPackage.Version}' of '{_targetPackage.Type}' package available in server.");
155              PackageVersion serverVersion = new(_targetPackage.Version);
156              Trace.Info($"Current running runner version is {BuildConstants.RunnerPackage.Version}");
157              PackageVersion runnerVersion = new(BuildConstants.RunnerPackage.Version);
158              return serverVersion.CompareTo(runnerVersion) > 0;
159          }
160          private async Task DownloadLatestRunner(CancellationToken token, string targetVersion)
161          {
162              string latestRunnerDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Work), Constants.Path.UpdateDirectory);
163              IOUtil.DeleteDirectory(latestRunnerDirectory, token);
164              Directory.CreateDirectory(latestRunnerDirectory);
165              string archiveFile = null;
166              var packageDownloadUrl = _targetPackage.DownloadUrl;
167              var packageHashValue = _targetPackage.HashValue;
168              var runtimeTrimmed = false;
169              var externalsTrimmed = false;
170              var fallbackToFullPackage = false;
171              if (_contentHashes.Count == 2 &&
172                  _contentHashes.ContainsKey(_dotnetRuntime) &&
173                  _contentHashes.ContainsKey(_externals) &&
174                  _targetPackage.TrimmedPackages?.Count > 0)
175              {
176                  Trace.Info($"Current runner content hash: {StringUtil.ConvertToJson(_contentHashes)}");
177                  Trace.Info($"Trimmed packages info from service: {StringUtil.ConvertToJson(_targetPackage.TrimmedPackages)}");
178                  foreach (var trimmedPackage in _targetPackage.TrimmedPackages)
179                  {
180                      if (trimmedPackage.TrimmedContents.Count == 2 &&
181                          trimmedPackage.TrimmedContents.TryGetValue(_dotnetRuntime, out var trimmedRuntimeHash) &&
182                          trimmedRuntimeHash == _contentHashes[_dotnetRuntime] &&
183                          trimmedPackage.TrimmedContents.TryGetValue(_externals, out var trimmedExternalsHash) &&
184                          trimmedExternalsHash == _contentHashes[_externals])
185                      {
186                          Trace.Info($"Use trimmed (runtime+externals) package '{trimmedPackage.DownloadUrl}' to update runner.");
187                          packageDownloadUrl = trimmedPackage.DownloadUrl;
188                          packageHashValue = trimmedPackage.HashValue;
189                          runtimeTrimmed = true;
190                          externalsTrimmed = true;
191                          break;
192                      }
193                      else if (trimmedPackage.TrimmedContents.Count == 1 &&
194                               trimmedPackage.TrimmedContents.TryGetValue(_externals, out trimmedExternalsHash) &&
195                               trimmedExternalsHash == _contentHashes[_externals])
196                      {
197                          Trace.Info($"Use trimmed (externals) package '{trimmedPackage.DownloadUrl}' to update runner.");
198                          packageDownloadUrl = trimmedPackage.DownloadUrl;
199                          packageHashValue = trimmedPackage.HashValue;
200                          externalsTrimmed = true;
201                          break;
202                      }
203                      else
204                      {
205                          Trace.Info($"Can't use trimmed package from '{trimmedPackage.DownloadUrl}' since the current runner does not carry those trimmed content (Hash mismatch).");
206                      }
207                  }
208              }
209              _updateTrace.Enqueue($"DownloadUrl: {packageDownloadUrl}");
210              _updateTrace.Enqueue($"RuntimeTrimmed: {runtimeTrimmed}");
211              _updateTrace.Enqueue($"ExternalsTrimmed: {externalsTrimmed}");
212              try
213              {
214  #if DEBUG
215                  if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_IS_MOCK_UPDATE")))
216                  {
217                      var waitForDebugger = StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_IS_MOCK_UPDATE_WAIT_FOR_DEBUGGER"));
218                      if (waitForDebugger)
219                      {
220                          int waitInSeconds = 20;
221                          while (!Debugger.IsAttached && waitInSeconds-- > 0)
222                          {
223                              await Task.Delay(1000);
224                          }
225                          Debugger.Break();
226                      }
227                      if (_targetPackage.Platform.StartsWith("win"))
228                      {
229                          archiveFile = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"runner{targetVersion}.zip");
230                      }
231                      else
232                      {
233                          archiveFile = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"runner{targetVersion}.tar.gz");
234                      }
235                      if (File.Exists(archiveFile))
236                      {
237                          _updateTrace.Enqueue($"Mocking update with file: '{archiveFile}' and targetVersion: '{targetVersion}', nothing is downloaded");
238                          _terminal.WriteLine($"Mocking update with file: '{archiveFile}' and targetVersion: '{targetVersion}', nothing is downloaded");
239                      }
240                      else
241                      {
242                          archiveFile = null;
243                          _terminal.WriteLine($"Mock runner archive not found at {archiveFile} for target version {targetVersion}, proceeding with download instead");
244                          _updateTrace.Enqueue($"Mock runner archive not found at {archiveFile} for target version {targetVersion}, proceeding with download instead");
245                      }
246                  }
247  #endif
248                  if (string.IsNullOrEmpty(archiveFile))
249                  {
250                      archiveFile = await DownLoadRunner(latestRunnerDirectory, packageDownloadUrl, packageHashValue, token);
251                      if (string.IsNullOrEmpty(archiveFile))
252                      {
253                          throw new TaskCanceledException($"Runner package '{packageDownloadUrl}' failed after {Constants.RunnerDownloadRetryMaxAttempts} download attempts");
254                      }
255                      await ValidateRunnerHash(archiveFile, packageHashValue);
256                  }
257                  await ExtractRunnerPackage(archiveFile, latestRunnerDirectory, token);
258              }
259              catch (Exception ex) when (runtimeTrimmed || externalsTrimmed)
260              {
261                  Trace.Error($"Fail to download latest runner using trimmed package: {ex}");
262                  fallbackToFullPackage = true;
263              }
264              finally
265              {
266                  try
267                  {
268                      if (!string.IsNullOrEmpty(archiveFile) && File.Exists(archiveFile))
269                      {
270                          Trace.Verbose("Deleting latest runner package zip: {0}", archiveFile);
271                          IOUtil.DeleteFile(archiveFile);
272                      }
273                  }
274                  catch (Exception ex)
275                  {
276                      Trace.Warning("Failed to delete runner package zip '{0}'. Exception: {1}", archiveFile, ex);
277                  }
278              }
279              var trimmedPackageRestoreTasks = new List<Task<bool>>();
280              if (!fallbackToFullPackage)
281              {
282                  if (externalsTrimmed)
283                  {
284                      trimmedPackageRestoreTasks.Add(RestoreTrimmedExternals(latestRunnerDirectory, token));
285                  }
286                  if (runtimeTrimmed)
287                  {
288                      trimmedPackageRestoreTasks.Add(RestoreTrimmedDotnetRuntime(latestRunnerDirectory, token));
289                  }
290              }
291              if (trimmedPackageRestoreTasks.Count > 0)
292              {
293                  var restoreResults = await Task.WhenAll(trimmedPackageRestoreTasks);
294                  if (restoreResults.Any(x => x == false))
295                  {
296                      fallbackToFullPackage = true;
297                  }
298              }
299              if (fallbackToFullPackage)
300              {
301                  Trace.Error("Something wrong with the trimmed runner package, failback to use the full package for runner updates.");
302                  _updateTrace.Enqueue($"FallbackToFullPackage: {fallbackToFullPackage}");
303                  IOUtil.DeleteDirectory(latestRunnerDirectory, token);
304                  Directory.CreateDirectory(latestRunnerDirectory);
305                  packageDownloadUrl = _targetPackage.DownloadUrl;
306                  packageHashValue = _targetPackage.HashValue;
307                  _updateTrace.Enqueue($"DownloadUrl: {packageDownloadUrl}");
308                  try
309                  {
310                      archiveFile = await DownLoadRunner(latestRunnerDirectory, packageDownloadUrl, packageHashValue, token);
311                      if (string.IsNullOrEmpty(archiveFile))
312                      {
313                          throw new TaskCanceledException($"Runner package '{packageDownloadUrl}' failed after {Constants.RunnerDownloadRetryMaxAttempts} download attempts");
314                      }
315                      await ValidateRunnerHash(archiveFile, packageHashValue);
316                      await ExtractRunnerPackage(archiveFile, latestRunnerDirectory, token);
317                  }
318                  finally
319                  {
320                      try
321                      {
322                          if (!string.IsNullOrEmpty(archiveFile) && File.Exists(archiveFile))
323                          {
324                              Trace.Verbose("Deleting latest runner package zip: {0}", archiveFile);
325                              IOUtil.DeleteFile(archiveFile);
326                          }
327                      }
328                      catch (Exception ex)
329                      {
330                          Trace.Warning("Failed to delete runner package zip '{0}'. Exception: {1}", archiveFile, ex);
331                      }
332                  }
333              }
334              await CopyLatestRunnerToRoot(latestRunnerDirectory, token);
335          }
336          private async Task<string> DownLoadRunner(string downloadDirectory, string packageDownloadUrl, string packageHashValue, CancellationToken token)
337          {
338              var stopWatch = Stopwatch.StartNew();
339              int runnerSuffix = 1;
340              string archiveFile = null;
341              bool downloadSucceeded = false;
342              for (int attempt = 1; attempt <= Constants.RunnerDownloadRetryMaxAttempts; attempt++)
343              {
344                  while (true)
345                  {
346                      if (_targetPackage.Platform.StartsWith("win"))
347                      {
348                          archiveFile = Path.Combine(downloadDirectory, $"runner{runnerSuffix}.zip");
349                      }
350                      else
351                      {
352                          archiveFile = Path.Combine(downloadDirectory, $"runner{runnerSuffix}.tar.gz");
353                      }
354                      try
355                      {
356                          if (!string.IsNullOrEmpty(archiveFile) && File.Exists(archiveFile))
357                          {
358                              Trace.Verbose("Deleting latest runner package zip '{0}'", archiveFile);
359                              IOUtil.DeleteFile(archiveFile);
360                          }
361                          break;
362                      }
363                      catch (Exception ex)
364                      {
365                          Trace.Warning("Failed to delete runner package zip '{0}'. Exception: {1}", archiveFile, ex);
366                          runnerSuffix++;
367                      }
368                  }
369                  if (!int.TryParse(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_DOWNLOAD_TIMEOUT") ?? string.Empty, out int timeoutSeconds))
370                  {
371                      timeoutSeconds = 15 * 60;
372                  }
373                  Trace.Info($"Attempt {attempt}: save latest runner into {archiveFile}.");
374                  using (var downloadTimeout = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds)))
375                  using (var downloadCts = CancellationTokenSource.CreateLinkedTokenSource(downloadTimeout.Token, token))
376                  {
377                      try
378                      {
379                          Trace.Info($"Download runner: begin download");
380                          long downloadSize = 0;
381                          using (HttpClient httpClient = new(HostContext.CreateHttpClientHandler()))
382                          {
383                              if (!string.IsNullOrEmpty(_targetPackage.Token))
384                              {
385                                  Trace.Info($"Adding authorization token ({_targetPackage.Token.Length} chars)");
386                                  httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _targetPackage.Token);
387                              }
388                              Trace.Info($"Downloading {packageDownloadUrl}");
389                              using (FileStream fs = new(archiveFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: 4096, useAsync: true))
390                              using (Stream result = await httpClient.GetStreamAsync(packageDownloadUrl))
391                              {
392                                  await result.CopyToAsync(fs, 81920, downloadCts.Token);
393                                  await fs.FlushAsync(downloadCts.Token);
394                                  downloadSize = fs.Length;
395                              }
396                          }
397                          Trace.Info($"Download runner: finished download");
398                          downloadSucceeded = true;
399                          stopWatch.Stop();
400                          _updateTrace.Enqueue($"PackageDownloadTime: {stopWatch.ElapsedMilliseconds}ms");
401                          _updateTrace.Enqueue($"Attempts: {attempt}");
402                          _updateTrace.Enqueue($"PackageSize: {downloadSize / 1024 / 1024}MB");
403                          break;
404                      }
405                      catch (OperationCanceledException) when (token.IsCancellationRequested)
406                      {
407                          Trace.Info($"Runner download has been cancelled.");
408                          throw;
409                      }
410                      catch (Exception ex)
411                      {
412                          if (downloadCts.Token.IsCancellationRequested)
413                          {
414                              Trace.Warning($"Runner download has timed out after {timeoutSeconds} seconds");
415                          }
416                          Trace.Warning($"Failed to get package '{archiveFile}' from '{packageDownloadUrl}'. Exception {ex}");
417                      }
418                  }
419              }
420              if (downloadSucceeded)
421              {
422                  return archiveFile;
423              }
424              else
425              {
426                  return null;
427              }
428          }
429          private async Task ValidateRunnerHash(string archiveFile, string packageHashValue)
430          {
431              var stopWatch = Stopwatch.StartNew();
432              using (FileStream stream = File.OpenRead(archiveFile))
433              {
434                  if (!string.IsNullOrEmpty(packageHashValue))
435                  {
436                      using (SHA256 sha256 = SHA256.Create())
437                      {
438                          byte[] srcHashBytes = await sha256.ComputeHashAsync(stream);
439                          var hash = PrimitiveExtensions.ConvertToHexString(srcHashBytes);
440                          if (hash != packageHashValue)
441                          {
442                              throw new Exception($"Computed runner hash {hash} did not match expected Runner Hash {packageHashValue} for {archiveFile}");
443                          }
444                          stopWatch.Stop();
445                          Trace.Info($"Validated Runner Hash matches {archiveFile} : {packageHashValue}");
446                          _updateTrace.Enqueue($"ValidateHashTime: {stopWatch.ElapsedMilliseconds}ms");
447                      }
448                  }
449              }
450          }
451          private async Task ExtractRunnerPackage(string archiveFile, string extractDirectory, CancellationToken token)
452          {
453              var stopWatch = Stopwatch.StartNew();
454              if (archiveFile.EndsWith(".zip", StringComparison.OrdinalIgnoreCase))
455              {
456                  ZipFile.ExtractToDirectory(archiveFile, extractDirectory);
457              }
458              else if (archiveFile.EndsWith(".tar.gz", StringComparison.OrdinalIgnoreCase))
459              {
<span onclick='openModal()' class='match'>460                  string tar = WhichUtil.Which("tar", trace: Trace);
461                  if (string.IsNullOrEmpty(tar))
</span>462                  {
463                      throw new NotSupportedException($"tar -xzf");
464                  }
465                  using (var processInvoker = HostContext.CreateService<IProcessInvoker>())
466                  {
467                      processInvoker.OutputDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
468                      {
469                          if (!string.IsNullOrEmpty(args.Data))
470                          {
471                              Trace.Info(args.Data);
472                          }
473                      });
474                      processInvoker.ErrorDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
475                      {
476                          if (!string.IsNullOrEmpty(args.Data))
477                          {
478                              Trace.Error(args.Data);
479                          }
480                      });
481                      int exitCode = await processInvoker.ExecuteAsync(extractDirectory, tar, $"-xzf \"{archiveFile}\"", null, token);
482                      if (exitCode != 0)
483                      {
484                          throw new NotSupportedException($"Can't use 'tar -xzf' to extract archive file: {archiveFile}. return code: {exitCode}.");
485                      }
486                  }
487              }
488              else
489              {
490                  throw new NotSupportedException($"{archiveFile}");
491              }
492              stopWatch.Stop();
493              Trace.Info($"Finished getting latest runner package at: {extractDirectory}.");
494              _updateTrace.Enqueue($"PackageExtractTime: {stopWatch.ElapsedMilliseconds}ms");
495          }
496          private Task CopyLatestRunnerToRoot(string latestRunnerDirectory, CancellationToken token)
497          {
498              var stopWatch = Stopwatch.StartNew();
499              string binVersionDir = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"{Constants.Path.BinDirectory}.{_targetPackage.Version}");
500              Directory.CreateDirectory(binVersionDir);
501              Trace.Info($"Copy {Path.Combine(latestRunnerDirectory, Constants.Path.BinDirectory)} to {binVersionDir}.");
502              IOUtil.CopyDirectory(Path.Combine(latestRunnerDirectory, Constants.Path.BinDirectory), binVersionDir, token);
503              string externalsVersionDir = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"{Constants.Path.ExternalsDirectory}.{_targetPackage.Version}");
504              Directory.CreateDirectory(externalsVersionDir);
505              Trace.Info($"Copy {Path.Combine(latestRunnerDirectory, Constants.Path.ExternalsDirectory)} to {externalsVersionDir}.");
506              IOUtil.CopyDirectory(Path.Combine(latestRunnerDirectory, Constants.Path.ExternalsDirectory), externalsVersionDir, token);
507              Trace.Info($"Copy any remaining .sh/.cmd files into runner root.");
508              foreach (FileInfo file in new DirectoryInfo(latestRunnerDirectory).GetFiles() ?? new FileInfo[0])
509              {
510                  string destination = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), file.Name);
511                  Trace.Info($"Copy {file.FullName} to {destination}");
512                  IOUtil.DeleteFile(destination);
513                  file.CopyTo(destination, true);
514              }
515              stopWatch.Stop();
516              _updateTrace.Enqueue($"CopyRunnerToRootTime: {stopWatch.ElapsedMilliseconds}ms");
517              return Task.CompletedTask;
518          }
519          private void DeletePreviousVersionRunnerBackup(CancellationToken token)
520          {
521              foreach (string existBackUp in Directory.GetDirectories(HostContext.GetDirectory(WellKnownDirectory.Root), "*.bak.*"))
522              {
523                  Trace.Info($"Delete existing runner backup at {existBackUp}.");
524                  try
525                  {
526                      IOUtil.DeleteDirectory(existBackUp, token);
527                  }
528                  catch (Exception ex) when (!(ex is OperationCanceledException))
529                  {
530                      Trace.Error(ex);
531                      Trace.Info($"Catch exception during delete backup folder {existBackUp}, ignore this error try delete the backup folder on next auto-update.");
532                  }
533              }
534              var allBinDirs = Directory.GetDirectories(HostContext.GetDirectory(WellKnownDirectory.Root), "bin.*");
535              if (allBinDirs.Length > 2)
536              {
537                  foreach (var oldBinDir in allBinDirs)
538                  {
539                      if (string.Equals(oldBinDir, Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"bin"), StringComparison.OrdinalIgnoreCase) ||
540                          string.Equals(oldBinDir, Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"bin.{BuildConstants.RunnerPackage.Version}"), StringComparison.OrdinalIgnoreCase) ||
541                          string.Equals(oldBinDir, Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"bin.{_targetPackage.Version}"), StringComparison.OrdinalIgnoreCase))
542                      {
543                          continue;
544                      }
545                      Trace.Info($"Delete runner bin folder's backup at {oldBinDir}.");
546                      try
547                      {
548                          IOUtil.DeleteDirectory(oldBinDir, token);
549                      }
550                      catch (Exception ex) when (!(ex is OperationCanceledException))
551                      {
552                          Trace.Error(ex);
553                          Trace.Info($"Catch exception during delete backup folder {oldBinDir}, ignore this error try delete the backup folder on next auto-update.");
554                      }
555                  }
556              }
557              var allExternalsDirs = Directory.GetDirectories(HostContext.GetDirectory(WellKnownDirectory.Root), "externals.*");
558              if (allExternalsDirs.Length > 2)
559              {
560                  foreach (var oldExternalDir in allExternalsDirs)
561                  {
562                      if (string.Equals(oldExternalDir, Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"externals"), StringComparison.OrdinalIgnoreCase) ||
563                          string.Equals(oldExternalDir, Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"externals.{BuildConstants.RunnerPackage.Version}"), StringComparison.OrdinalIgnoreCase) ||
564                          string.Equals(oldExternalDir, Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), $"externals.{_targetPackage.Version}"), StringComparison.OrdinalIgnoreCase))
565                      {
566                          continue;
567                      }
568                      Trace.Info($"Delete runner externals folder's backup at {oldExternalDir}.");
569                      try
570                      {
571                          IOUtil.DeleteDirectory(oldExternalDir, token);
572                      }
573                      catch (Exception ex) when (!(ex is OperationCanceledException))
574                      {
575                          Trace.Error(ex);
576                          Trace.Info($"Catch exception during delete backup folder {oldExternalDir}, ignore this error try delete the backup folder on next auto-update.");
577                      }
578                  }
579              }
580          }
581          private string GenerateUpdateScript(bool restartInteractiveRunner)
582          {
583              int processId = Process.GetCurrentProcess().Id;
584              string updateLog = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Diag), $"SelfUpdate-{DateTime.UtcNow.ToString("yyyyMMdd-HHmmss")}.log");
585              string runnerRoot = HostContext.GetDirectory(WellKnownDirectory.Root);
586  #if OS_WINDOWS
587              string templateName = "update.cmd.template";
588  #else
589              string templateName = "update.sh.template";
590  #endif
591              string templatePath = Path.Combine(runnerRoot, $"bin.{_targetPackage.Version}", templateName);
592              string template = File.ReadAllText(templatePath);
593              template = template.Replace("_PROCESS_ID_", processId.ToString());
594              template = template.Replace("_RUNNER_PROCESS_NAME_", $"Runner.Listener{IOUtil.ExeExtension}");
595              template = template.Replace("_ROOT_FOLDER_", runnerRoot);
596              template = template.Replace("_EXIST_RUNNER_VERSION_", BuildConstants.RunnerPackage.Version);
597              template = template.Replace("_DOWNLOAD_RUNNER_VERSION_", _targetPackage.Version);
598              template = template.Replace("_UPDATE_LOG_", updateLog);
599              template = template.Replace("_RESTART_INTERACTIVE_RUNNER_", restartInteractiveRunner ? "1" : "0");
600  #if OS_WINDOWS
601              string scriptName = "_update.cmd";
602  #else
603              string scriptName = "_update.sh";
604  #endif
605              string updateScript = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Work), scriptName);
606              if (File.Exists(updateScript))
607              {
608                  IOUtil.DeleteFile(updateScript);
609              }
610              File.WriteAllText(updateScript, template);
611              return updateScript;
612          }
613          private async Task UpdateRunnerUpdateStateAsync(string currentState)
614          {
615              _terminal.WriteLine(currentState);
616              var traces = new List<string>();
617              while (_updateTrace.TryDequeue(out var trace))
618              {
619                  traces.Add(trace);
620              }
621              if (traces.Count > 0)
622              {
623                  foreach (var trace in traces)
624                  {
625                      Trace.Info(trace);
626                  }
627              }
628              try
629              {
630                  await _runnerServer.UpdateAgentUpdateStateAsync(_poolId, _agentId, currentState, string.Join(Environment.NewLine, traces));
631                  _updateTrace.Clear();
632              }
633              catch (VssResourceNotFoundException)
634              {
635                  Trace.Info($"Catch VssResourceNotFoundException during report update state, ignore this error for backcompat.");
636              }
637              catch (Exception ex)
638              {
639                  Trace.Error(ex);
640                  Trace.Info($"Catch exception during report update state, ignore this error and continue auto-update.");
641              }
642          }
643          private async Task<bool> RestoreTrimmedExternals(string downloadDirectory, CancellationToken token)
644          {
645              var stopWatch = Stopwatch.StartNew();
646              try
647              {
648                  Trace.Info($"Copy {_externalsCloneDirectory} to {Path.Combine(downloadDirectory, Constants.Path.ExternalsDirectory)}.");
649                  IOUtil.CopyDirectory(_externalsCloneDirectory, Path.Combine(downloadDirectory, Constants.Path.ExternalsDirectory), token);
650                  var nodeVersions = NodeUtil.BuiltInNodeVersions;
651                  foreach (var nodeVersion in nodeVersions)
652                  {
653                      var newNodeBinary = Path.Combine(downloadDirectory, Constants.Path.ExternalsDirectory, nodeVersion, "bin", $"node{IOUtil.ExeExtension}");
654                      if (File.Exists(newNodeBinary))
655                      {
656                          using (var p = HostContext.CreateService<IProcessInvoker>())
657                          {
658                              var outputs = "";
659                              p.ErrorDataReceived += (_, data) =>
660                              {
661                                  if (!string.IsNullOrEmpty(data.Data))
662                                  {
663                                      Trace.Error(data.Data);
664                                  }
665                              };
666                              p.OutputDataReceived += (_, data) =>
667                              {
668                                  if (!string.IsNullOrEmpty(data.Data))
669                                  {
670                                      Trace.Info(data.Data);
671                                      outputs = data.Data;
672                                  }
673                              };
674                              var exitCode = await p.ExecuteAsync(HostContext.GetDirectory(WellKnownDirectory.Root), newNodeBinary, $"-e \"console.log('{nameof(RestoreTrimmedExternals)}')\"", null, token);
675                              if (exitCode != 0)
676                              {
677                                  Trace.Error($"{newNodeBinary} -e \"console.log()\" failed with exit code {exitCode}");
678                                  return false;
679                              }
680                              if (!string.Equals(outputs, nameof(RestoreTrimmedExternals), StringComparison.OrdinalIgnoreCase))
681                              {
682                                  Trace.Error($"{newNodeBinary} -e \"console.log()\" did not output expected content.");
683                                  return false;
684                              }
685                          }
686                      }
687                  }
688                  return true;
689              }
690              catch (Exception ex)
691              {
692                  Trace.Error($"Fail to restore externals for trimmed package: {ex}");
693                  return false;
694              }
695              finally
696              {
697                  stopWatch.Stop();
698                  _updateTrace.Enqueue($"{nameof(RestoreTrimmedExternals)}Time: {stopWatch.ElapsedMilliseconds}ms");
699              }
700          }
701          private async Task<bool> RestoreTrimmedDotnetRuntime(string downloadDirectory, CancellationToken token)
702          {
703              var stopWatch = Stopwatch.StartNew();
704              try
705              {
706                  Trace.Info($"Copy {_dotnetRuntimeCloneDirectory} to {Path.Combine(downloadDirectory, Constants.Path.BinDirectory)}.");
707                  IOUtil.CopyDirectory(_dotnetRuntimeCloneDirectory, Path.Combine(downloadDirectory, Constants.Path.BinDirectory), token);
708                  var newRunnerBinary = Path.Combine(downloadDirectory, Constants.Path.BinDirectory, "Runner.Listener");
709                  using (var p = HostContext.CreateService<IProcessInvoker>())
710                  {
711                      p.ErrorDataReceived += (_, data) =>
712                      {
713                          if (!string.IsNullOrEmpty(data.Data))
714                          {
715                              Trace.Error(data.Data);
716                          }
717                      };
718                      p.OutputDataReceived += (_, data) =>
719                      {
720                          if (!string.IsNullOrEmpty(data.Data))
721                          {
722                              Trace.Info(data.Data);
723                          }
724                      };
725                      var exitCode = await p.ExecuteAsync(HostContext.GetDirectory(WellKnownDirectory.Root), newRunnerBinary, "--version", null, token);
726                      if (exitCode != 0)
727                      {
728                          Trace.Error($"{newRunnerBinary} --version failed with exit code {exitCode}");
729                          return false;
730                      }
731                      else
732                      {
733                          return true;
734                      }
735                  }
736              }
737              catch (Exception ex)
738              {
739                  Trace.Error($"Fail to restore dotnet runtime for trimmed package: {ex}");
740                  return false;
741              }
742              finally
743              {
744                  stopWatch.Stop();
745                  _updateTrace.Enqueue($"{nameof(RestoreTrimmedDotnetRuntime)}Time: {stopWatch.ElapsedMilliseconds}ms");
746              }
747          }
748          private async Task CloneAndCalculateAssetsHash(string dotnetRuntimeCloneDirectory, string externalsCloneDirectory, CancellationToken token)
749          {
750              var runtimeCloneTask = CloneDotnetRuntime(dotnetRuntimeCloneDirectory, token);
751              var externalsCloneTask = CloneExternals(externalsCloneDirectory, token);
752              var waitingTasks = new Dictionary<string, Task>()
753              {
754                  {nameof(CloneDotnetRuntime), runtimeCloneTask},
755                  {nameof(CloneExternals),externalsCloneTask}
756              };
757              while (waitingTasks.Count > 0)
758              {
759                  Trace.Info($"Waiting for {waitingTasks.Count} tasks to complete.");
760                  var complatedTask = await Task.WhenAny(waitingTasks.Values);
761                  if (waitingTasks.ContainsKey(nameof(CloneExternals)) &&
762                      complatedTask == waitingTasks[nameof(CloneExternals)])
763                  {
764                      Trace.Info($"Externals clone finished.");
765                      waitingTasks.Remove(nameof(CloneExternals));
766                      try
767                      {
768                          if (await externalsCloneTask && !token.IsCancellationRequested)
769                          {
770                              var externalsHash = await HashFiles(externalsCloneDirectory, token);
771                              Trace.Info($"Externals content hash: {externalsHash}");
772                              _contentHashes[_externals] = externalsHash;
773                              _updateTrace.Enqueue($"ExternalsHash: {_contentHashes[_externals]}");
774                          }
775                          else
776                          {
777                              Trace.Error($"Skip compute hash since clone externals failed/cancelled.");
778                          }
779                      }
780                      catch (Exception ex)
781                      {
782                          Trace.Error($"Fail to hash externals content: {ex}");
783                      }
784                  }
785                  else if (waitingTasks.ContainsKey(nameof(CloneDotnetRuntime)) &&
786                           complatedTask == waitingTasks[nameof(CloneDotnetRuntime)])
787                  {
788                      Trace.Info($"Dotnet runtime clone finished.");
789                      waitingTasks.Remove(nameof(CloneDotnetRuntime));
790                      try
791                      {
792                          if (await runtimeCloneTask && !token.IsCancellationRequested)
793                          {
794                              var runtimeHash = await HashFiles(dotnetRuntimeCloneDirectory, token);
795                              Trace.Info($"Runtime content hash: {runtimeHash}");
796                              _contentHashes[_dotnetRuntime] = runtimeHash;
797                              _updateTrace.Enqueue($"DotnetRuntimeHash: {_contentHashes[_dotnetRuntime]}");
798                          }
799                          else
800                          {
801                              Trace.Error($"Skip compute hash since clone dotnet runtime failed/cancelled.");
802                          }
803                      }
804                      catch (Exception ex)
805                      {
806                          Trace.Error($"Fail to hash runtime content: {ex}");
807                      }
808                  }
809                  Trace.Info($"Still waiting for {waitingTasks.Count} tasks to complete.");
810              }
811          }
812          private async Task<bool> CloneDotnetRuntime(string runtimeDir, CancellationToken token)
813          {
814              var stopWatch = Stopwatch.StartNew();
815              try
816              {
817                  Trace.Info($"Cloning dotnet runtime to {runtimeDir}");
818                  IOUtil.DeleteDirectory(runtimeDir, CancellationToken.None);
819                  Directory.CreateDirectory(runtimeDir);
820                  var assembly = Assembly.GetExecutingAssembly();
821                  var assetsContent = default(string);
822                  using (var stream = assembly.GetManifestResourceStream("GitHub.Runner.Listener.runnercoreassets"))
823                  using (var streamReader = new StreamReader(stream))
824                  {
825                      assetsContent = await streamReader.ReadToEndAsync();
826                  }
827                  if (!string.IsNullOrEmpty(assetsContent))
828                  {
829                      var runnerCoreAssets = assetsContent.Split(new[] { "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
830                      if (runnerCoreAssets.Length > 0)
831                      {
832                          var binDir = HostContext.GetDirectory(WellKnownDirectory.Bin);
833                          IOUtil.CopyDirectory(binDir, runtimeDir, token);
834                          var clonedFile = 0;
835                          foreach (var file in Directory.EnumerateFiles(runtimeDir, "*", SearchOption.AllDirectories))
836                          {
837                              token.ThrowIfCancellationRequested();
838                              if (runnerCoreAssets.Any(x => file.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar).EndsWith(x.Trim())))
839                              {
840                                  Trace.Verbose($"{file} is part of the runner core, delete from cloned runtime directory.");
841                                  IOUtil.DeleteFile(file);
842                              }
843                              else
844                              {
845                                  clonedFile++;
846                              }
847                          }
848                          Trace.Info($"Successfully cloned dotnet runtime to {runtimeDir}. Total files: {clonedFile}");
849                          return true;
850                      }
851                  }
852              }
853              catch (Exception ex)
854              {
855                  Trace.Error($"Fail to clone dotnet runtime to {runtimeDir}");
856                  Trace.Error(ex);
857              }
858              finally
859              {
860                  stopWatch.Stop();
861                  _updateTrace.Enqueue($"{nameof(CloneDotnetRuntime)}Time: {stopWatch.ElapsedMilliseconds}ms");
862              }
863              return false;
864          }
865          private Task<bool> CloneExternals(string externalsDir, CancellationToken token)
866          {
867              var stopWatch = Stopwatch.StartNew();
868              try
869              {
870                  Trace.Info($"Cloning externals to {externalsDir}");
871                  IOUtil.DeleteDirectory(externalsDir, CancellationToken.None);
872                  Directory.CreateDirectory(externalsDir);
873                  IOUtil.CopyDirectory(HostContext.GetDirectory(WellKnownDirectory.Externals), externalsDir, token);
874                  Trace.Info($"Successfully cloned externals to {externalsDir}.");
875                  return Task.FromResult(true);
876              }
877              catch (Exception ex)
878              {
879                  Trace.Error($"Fail to clone externals to {externalsDir}");
880                  Trace.Error(ex);
881              }
882              finally
883              {
884                  stopWatch.Stop();
885                  _updateTrace.Enqueue($"{nameof(CloneExternals)}Time: {stopWatch.ElapsedMilliseconds}ms");
886              }
887              return Task.FromResult(false);
888          }
889          private async Task<string> HashFiles(string fileFolder, CancellationToken token)
890          {
891              Trace.Info($"Calculating hash for {fileFolder}");
892              var stopWatch = Stopwatch.StartNew();
893              string binDir = HostContext.GetDirectory(WellKnownDirectory.Bin);
894              string node = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Externals), NodeUtil.GetInternalNodeVersion(), "bin", $"node{IOUtil.ExeExtension}");
895              string hashFilesScript = Path.Combine(binDir, "hashFiles");
896              var hashResult = string.Empty;
897              using (var processInvoker = HostContext.CreateService<IProcessInvoker>())
898              {
899                  processInvoker.ErrorDataReceived += (_, data) =>
900                  {
901                      if (!string.IsNullOrEmpty(data.Data) && data.Data.StartsWith("__OUTPUT__") && data.Data.EndsWith("__OUTPUT__"))
902                      {
903                          hashResult = data.Data.Substring(10, data.Data.Length - 20);
904                          Trace.Info($"Hash result: '{hashResult}'");
905                      }
906                      else
907                      {
908                          Trace.Info(data.Data);
909                      }
910                  };
911                  processInvoker.OutputDataReceived += (_, data) =>
912                  {
913                      Trace.Verbose(data.Data);
914                  };
915                  var env = new Dictionary<string, string>
916                  {
917                      ["patterns"] = "**"
918                  };
919                  int exitCode = await processInvoker.ExecuteAsync(workingDirectory: fileFolder,
920                                                fileName: node,
921                                                arguments: $"\"{hashFilesScript.Replace("\"", "\\\"")}\"",
922                                                environment: env,
923                                                requireExitCodeZero: false,
924                                                outputEncoding: null,
925                                                killProcessOnCancel: true,
926                                                cancellationToken: token);
927                  if (exitCode != 0)
928                  {
929                      Trace.Error($"hashFiles returns '{exitCode}' failed. Fail to hash files under directory '{fileFolder}'");
930                  }
931                  stopWatch.Stop();
932                  _updateTrace.Enqueue($"{nameof(HashFiles)}{Path.GetFileName(fileFolder)}Time: {stopWatch.ElapsedMilliseconds}ms");
933                  return hashResult;
934              }
935          }
936      }
937  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-WhichUtilL0.cs</h3>
            <pre><code>1  using GitHub.Runner.Common.Util;
2  using GitHub.Runner.Sdk;
3  using System;
4  using System.IO;
5  using Xunit;
6  namespace GitHub.Runner.Common.Tests.Util
7  {
8      public sealed class WhichUtilL0
9      {
10          [Fact]
11          [Trait("Level", "L0")]
12          [Trait("Category", "Common")]
13          public void UseWhichFindGit()
14          {
15              using (TestHostContext hc = new(this))
16              {
17                  Tracing trace = hc.GetTrace();
<span onclick='openModal()' class='match'>18                  string gitPath = WhichUtil.Which("git", trace: trace);
19                  trace.Info($"Which(\"git\") returns: {gitPath ?? string.Empty}");
</span>20                  Assert.True(!string.IsNullOrEmpty(gitPath) && File.Exists(gitPath), $"Unable to find Git through: {nameof(WhichUtil.Which)}");
21              }
22          }
23          [Fact]
24          [Trait("Level", "L0")]
25          [Trait("Category", "Common")]
26          public void WhichReturnsNullWhenNotFound()
27          {
28              using (TestHostContext hc = new(this))
29              {
30                  Tracing trace = hc.GetTrace();
31                  string nosuch = WhichUtil.Which("no-such-file-cf7e351f", trace: trace);
32                  trace.Info($"result: {nosuch ?? string.Empty}");
33                  Assert.True(string.IsNullOrEmpty(nosuch), "Path should not be resolved");
34              }
35          }
36          [Fact]
37          [Trait("Level", "L0")]
38          [Trait("Category", "Common")]
39          public void WhichThrowsWhenRequireAndNotFound()
40          {
41              using (TestHostContext hc = new(this))
42              {
43                  Tracing trace = hc.GetTrace();
44                  try
45                  {
46                      WhichUtil.Which("no-such-file-cf7e351f", require: true, trace: trace);
47                      throw new Exception("which should have thrown");
48                  }
49                  catch (FileNotFoundException ex)
50                  {
51                      Assert.Equal("no-such-file-cf7e351f", ex.FileName);
52                  }
53              }
54          }
55          [Fact]
56          [Trait("Level", "L0")]
57          [Trait("Category", "Common")]
58          public void WhichHandleFullyQualifiedPath()
59          {
60              using (TestHostContext hc = new(this))
61              {
62                  Tracing trace = hc.GetTrace();
63                  var gitPath = WhichUtil.Which("git", require: true, trace: trace);
64                  var gitPath2 = WhichUtil.Which(gitPath, require: true, trace: trace);
65                  Assert.Equal(gitPath, gitPath2);
66              }
67          }
68          [Fact]
69          [Trait("Level", "L0")]
70          [Trait("Category", "Common")]
71          public void WhichHandlesSymlinkToTargetFullPath()
72          {
73              using TestHostContext hc = new TestHostContext(this);
74              Tracing trace = hc.GetTrace();
75              string oldValue = Environment.GetEnvironmentVariable(PathUtil.PathVariable);
76  #if OS_WINDOWS
77              string newValue = oldValue + @$";{Path.GetTempPath()}";
78              string symlinkName = $"symlink-{Guid.NewGuid()}";
79              string symlink = Path.GetTempPath() + $"{symlinkName}.exe";
80              string target = Path.GetTempPath() + $"target-{Guid.NewGuid()}.exe";
81  #else
82              string newValue = oldValue + @$":{Path.GetTempPath()}";
83              string symlinkName = $"symlink-{Guid.NewGuid()}";
84              string symlink = Path.GetTempPath() + $"{symlinkName}";
85              string target = Path.GetTempPath() + $"target-{Guid.NewGuid()}";
86  #endif
87              Environment.SetEnvironmentVariable(PathUtil.PathVariable, newValue);
88              using (File.Create(target))
89              {
90                  File.CreateSymbolicLink(symlink, target);
91                  var result = WhichUtil.Which(symlinkName, require: true, trace: trace);
92                  Assert.True(!string.IsNullOrEmpty(result) && File.Exists(result), $"Unable to find symlink through: {nameof(WhichUtil.Which)}");
93              }
94              File.Delete(symlink);
95              File.Delete(target);
96              Environment.SetEnvironmentVariable(PathUtil.PathVariable, oldValue);
97          }
98          [Fact]
99          [Trait("Level", "L0")]
100          [Trait("Category", "Common")]
101          public void WhichHandlesSymlinkToTargetRelativePath()
102          {
103              using TestHostContext hc = new TestHostContext(this);
104              Tracing trace = hc.GetTrace();
105              string oldValue = Environment.GetEnvironmentVariable(PathUtil.PathVariable);
106  #if OS_WINDOWS
107              string newValue = oldValue + @$";{Path.GetTempPath()}";
108              string symlinkName = $"symlink-{Guid.NewGuid()}";
109              string symlink = Path.GetTempPath() + $"{symlinkName}.exe";
110              string targetName = $"target-{Guid.NewGuid()}.exe";
111              string target = Path.GetTempPath() + targetName;
112  #else
113              string newValue = oldValue + @$":{Path.GetTempPath()}";
114              string symlinkName = $"symlink-{Guid.NewGuid()}";
115              string symlink = Path.GetTempPath() + $"{symlinkName}";
116              string targetName = $"target-{Guid.NewGuid()}";
117              string target = Path.GetTempPath() + targetName;
118  #endif
119              Environment.SetEnvironmentVariable(PathUtil.PathVariable, newValue);
120              using (File.Create(target))
121              {
122                  File.CreateSymbolicLink(symlink, targetName);
123                  var result = WhichUtil.Which(symlinkName, require: true, trace: trace);
124                  Assert.True(!string.IsNullOrEmpty(result) && File.Exists(result), $"Unable to find {symlinkName} through: {nameof(WhichUtil.Which)}");
125              }
126              File.Delete(symlink);
127              File.Delete(target);
128              Environment.SetEnvironmentVariable(PathUtil.PathVariable, oldValue);
129          }
130          [Fact]
131          [Trait("Level", "L0")]
132          [Trait("Category", "Common")]
133          public void WhichThrowsWhenSymlinkBroken()
134          {
135              using TestHostContext hc = new TestHostContext(this);
136              Tracing trace = hc.GetTrace();
137              string oldValue = Environment.GetEnvironmentVariable(PathUtil.PathVariable);
138  #if OS_WINDOWS
139              string newValue = oldValue + @$";{Path.GetTempPath()}";
140              string brokenSymlinkName = $"broken-symlink-{Guid.NewGuid()}";
141              string brokenSymlink = Path.GetTempPath() + $"{brokenSymlinkName}.exe";
142  #else
143              string newValue = oldValue + @$":{Path.GetTempPath()}";
144              string brokenSymlinkName = $"broken-symlink-{Guid.NewGuid()}";
145              string brokenSymlink = Path.GetTempPath() + $"{brokenSymlinkName}";
146  #endif
147              string target = "no-such-file-cf7e351f";
148              Environment.SetEnvironmentVariable(PathUtil.PathVariable, newValue);
149              File.CreateSymbolicLink(brokenSymlink, target);
150              var exception = Assert.Throws<FileNotFoundException>(() => WhichUtil.Which(brokenSymlinkName, require: true, trace: trace));
151              Assert.Equal(brokenSymlinkName, exception.FileName);
152              File.Delete(brokenSymlink);
153              Environment.SetEnvironmentVariable(PathUtil.PathVariable, oldValue);
154          }
155      }
156  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-SelfUpdater.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-WhichUtilL0.cs</div>
                </div>
                <div class="column column_space"><pre><code>460                  string tar = WhichUtil.Which("tar", trace: Trace);
461                  if (string.IsNullOrEmpty(tar))
</pre></code></div>
                <div class="column column_space"><pre><code>18                  string gitPath = WhichUtil.Which("git", trace: trace);
19                  trace.Info($"Which(\"git\") returns: {gitPath ?? string.Empty}");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    