
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.836477987421384%, Tokens: 11</h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-FacebookOptions.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Security.Claims;
4  using Microsoft.AspNetCore.Authentication;
5  using System.Globalization;
6  using Microsoft.AspNetCore.Authentication.OAuth;
7  using Microsoft.AspNetCore.Http;
8  namespace Microsoft.AspNetCore.Authentication.Facebook
9  {
10      public class FacebookOptions : OAuthOptions
11      {
12          public FacebookOptions()
13          {
14              CallbackPath = new PathString("/signin-facebook");
15              SendAppSecretProof = true;
16              AuthorizationEndpoint = FacebookDefaults.AuthorizationEndpoint;
17              TokenEndpoint = FacebookDefaults.TokenEndpoint;
18              UserInformationEndpoint = FacebookDefaults.UserInformationEndpoint;
19              Scope.Add("email");
20              Fields.Add("name");
21              Fields.Add("email");
22              Fields.Add("first_name");
23              Fields.Add("last_name");
24              ClaimActions.MapJsonKey(ClaimTypes.NameIdentifier, "id");
25              ClaimActions.MapJsonSubKey("urn:facebook:age_range_min", "age_range", "min");
26              ClaimActions.MapJsonSubKey("urn:facebook:age_range_max", "age_range", "max");
27              ClaimActions.MapJsonKey(ClaimTypes.DateOfBirth, "birthday");
28              ClaimActions.MapJsonKey(ClaimTypes.Email, "email");
29              ClaimActions.MapJsonKey(ClaimTypes.Name, "name");
30              ClaimActions.MapJsonKey(ClaimTypes.GivenName, "first_name");
31              ClaimActions.MapJsonKey("urn:facebook:middle_name", "middle_name");
32              ClaimActions.MapJsonKey(ClaimTypes.Surname, "last_name");
33              ClaimActions.MapJsonKey(ClaimTypes.Gender, "gender");
34              ClaimActions.MapJsonKey("urn:facebook:link", "link");
35              ClaimActions.MapJsonSubKey("urn:facebook:location", "location", "name");
36              ClaimActions.MapJsonKey(ClaimTypes.Locality, "locale");
37              ClaimActions.MapJsonKey("urn:facebook:timezone", "timezone");
38          }
39          public override void Validate()
40          {
41              if (string.IsNullOrEmpty(AppId))
42              {
43                  throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(AppId)), nameof(AppId));
44              }
45              if (string.IsNullOrEmpty(AppSecret))
46              {
47                  throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(AppSecret)), nameof(AppSecret));
48              }
49              base.Validate();
50          }
51          public string AppId
52          {
53              get { return ClientId; }
54              set { ClientId = value; }
55          }
56          public string AppSecret
57          {
58              get { return ClientSecret; }
59              set { ClientSecret = value; }
60          }
<span onclick='openModal()' class='match'>61          public bool SendAppSecretProof { get; set; }
62          public ICollection<string> Fields { get; } = new HashSet<string>();
</span>63      }
64  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-FileContainerServer.cs</h3>
            <pre><code>1  using GitHub.Services.FileContainer.Client;
2  using System;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.IO;
6  using System.Linq;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using System.Diagnostics;
10  using GitHub.Services.WebApi;
11  using System.Net.Http;
12  using System.Net;
13  using GitHub.Runner.Sdk;
14  using GitHub.Services.FileContainer;
15  using GitHub.Services.Common;
16  namespace GitHub.Runner.Plugins.Artifact
17  {
18      public class FileContainerServer
19      {
20          private const int _defaultFileStreamBufferSize = 4096;
21          private const int _defaultCopyBufferSize = 81920;
22          private readonly ConcurrentQueue<string> _fileUploadQueue = new();
23          private readonly ConcurrentQueue<DownloadInfo> _fileDownloadQueue = new();
24          private readonly ConcurrentDictionary<string, ConcurrentQueue<string>> _fileUploadTraceLog = new();
25          private readonly ConcurrentDictionary<string, ConcurrentQueue<string>> _fileUploadProgressLog = new();
26          private readonly FileContainerHttpClient _fileContainerHttpClient;
27          private CancellationTokenSource _uploadCancellationTokenSource;
28          private CancellationTokenSource _downloadCancellationTokenSource;
29          private TaskCompletionSource<int> _uploadFinished;
30          private TaskCompletionSource<int> _downloadFinished;
31          private Guid _projectId;
32          private long _containerId;
33          private string _containerPath;
34          private int _uploadFilesProcessed = 0;
35          private int _downloadFilesProcessed = 0;
36          private string _sourceParentDirectory;
37          public FileContainerServer(
38              VssConnection connection,
39              Guid projectId,
40              long containerId,
41              string containerPath)
42          {
43              _projectId = projectId;
44              _containerId = containerId;
45              _containerPath = containerPath;
46              var fileContainerClientConnectionSetting = connection.Settings.Clone();
47              if (fileContainerClientConnectionSetting.SendTimeout < TimeSpan.FromSeconds(600))
48              {
49                  fileContainerClientConnectionSetting.SendTimeout = TimeSpan.FromSeconds(600);
50              }
51              var fileContainerClientConnection = new VssConnection(connection.Uri, connection.Credentials, fileContainerClientConnectionSetting);
52              _fileContainerHttpClient = fileContainerClientConnection.GetClient<FileContainerHttpClient>();
53          }
54          public async Task DownloadFromContainerAsync(
55              RunnerActionPluginExecutionContext context,
56              String destination,
57              CancellationToken cancellationToken)
58          {
59              List<FileContainerItem> containerItems = new();
60              int retryCount = 0;
61              while (retryCount < 3)
62              {
63                  try
64                  {
65                      containerItems = await _fileContainerHttpClient.QueryContainerItemsAsync(_containerId,
66                                                                                               _projectId,
67                                                                                               _containerPath,
68                                                                                               cancellationToken: cancellationToken);
69                      break;
70                  }
71                  catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
72                  {
73                      context.Debug($"Container query has been cancelled.");
74                      throw;
75                  }
76                  catch (Exception ex) when (retryCount < 2)
77                  {
78                      retryCount++;
79                      context.Warning($"Fail to query container items under #/{_containerId}/{_containerPath}, Error: {ex.Message}");
80                      context.Debug(ex.ToString());
81                  }
82                  var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(15));
83                  context.Warning($"Back off {backOff.TotalSeconds} seconds before retry.");
84                  await Task.Delay(backOff);
85              }
86              if (containerItems.Count == 0)
87              {
88                  context.Output($"There is nothing under #/{_containerId}/{_containerPath}");
89                  return;
90              }
91              int foldersCreated = 0;
92              int emptryFilesCreated = 0;
93              List<DownloadInfo> downloadFiles = new();
94              foreach (var item in containerItems.OrderBy(x => x.Path))
95              {
96                  if (!item.Path.StartsWith(_containerPath, StringComparison.OrdinalIgnoreCase))
97                  {
98                      throw new ArgumentOutOfRangeException($"Item {item.Path} is not under #/{_containerId}/{_containerPath}");
99                  }
100                  var localRelativePath = item.Path.Substring(_containerPath.Length).TrimStart('/');
101                  var localPath = Path.Combine(destination, localRelativePath);
102                  if (item.ItemType == ContainerItemType.Folder)
103                  {
104                      context.Debug($"Ensure folder exists: {localPath}");
105                      Directory.CreateDirectory(localPath);
106                      foldersCreated++;
107                  }
108                  else if (item.ItemType == ContainerItemType.File)
109                  {
110                      if (item.FileLength == 0)
111                      {
112                          context.Debug($"Create empty file at: {localPath}");
113                          var parentDirectory = Path.GetDirectoryName(localPath);
114                          Directory.CreateDirectory(parentDirectory);
115                          IOUtil.DeleteFile(localPath);
116                          using (new FileStream(localPath, FileMode.Create))
117                          {
118                          }
119                          emptryFilesCreated++;
120                      }
121                      else
122                      {
123                          context.Debug($"Prepare download {item.Path} to {localPath}");
124                          downloadFiles.Add(new DownloadInfo(item.Path, localPath));
125                      }
126                  }
127                  else
128                  {
129                      throw new NotSupportedException(item.ItemType.ToString());
130                  }
131              }
132              if (foldersCreated > 0)
133              {
134                  context.Output($"{foldersCreated} folders created.");
135              }
136              if (emptryFilesCreated > 0)
137              {
138                  context.Output($"{emptryFilesCreated} empty files created.");
139              }
140              if (downloadFiles.Count == 0)
141              {
142                  context.Output($"There is nothing to download");
143                  return;
144              }
145              using (_downloadCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
146              {
147                  DownloadResult downloadResult = await ParallelDownloadAsync(context, downloadFiles.AsReadOnly(), Math.Min(downloadFiles.Count, Environment.ProcessorCount), _downloadCancellationTokenSource.Token);
148                  if (downloadResult.FailedFiles.Count == 0)
149                  {
150                      context.Output($"{downloadFiles.Count} files download succeed.");
151                      return;
152                  }
153                  else
154                  {
155                      context.Output($"{downloadResult.FailedFiles.Count} files failed to download, retry these files after a minute.");
156                  }
157                  for (int timer = 60; timer > 0; timer -= 5)
158                  {
159                      context.Output($"Retry file download after {timer} seconds.");
160                      await Task.Delay(TimeSpan.FromSeconds(5), _uploadCancellationTokenSource.Token);
161                  }
162                  context.Output($"Start retry {downloadResult.FailedFiles.Count} failed files upload.");
163                  DownloadResult retryDownloadResult = await ParallelDownloadAsync(context, downloadResult.FailedFiles.AsReadOnly(), Math.Min(downloadResult.FailedFiles.Count, Environment.ProcessorCount), _downloadCancellationTokenSource.Token);
164                  if (retryDownloadResult.FailedFiles.Count == 0)
165                  {
166                      context.Output($"{downloadResult.FailedFiles} files download succeed after retry.");
167                      return;
168                  }
169                  else
170                  {
171                      throw new Exception($"{retryDownloadResult.FailedFiles.Count} files failed to download even after retry.");
172                  }
173              }
174          }
175          public async Task<long> CopyToContainerAsync(
176              RunnerActionPluginExecutionContext context,
177              String source,
178              CancellationToken cancellationToken)
179          {
180              int maxConcurrentUploads = Math.Min(Environment.ProcessorCount, 2);
181              List<String> files;
182              if (File.Exists(source))
183              {
184                  files = new List<String>() { source };
185                  _sourceParentDirectory = Path.GetDirectoryName(source);
186              }
187              else
188              {
189                  files = Directory.EnumerateFiles(source, "*", SearchOption.AllDirectories).ToList();
190                  _sourceParentDirectory = source.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
191              }
192              context.Output($"Uploading {files.Count()} files");
193              using (_uploadCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
194              {
195                  _fileContainerHttpClient.UploadFileReportTrace += UploadFileTraceReportReceived;
196                  _fileContainerHttpClient.UploadFileReportProgress += UploadFileProgressReportReceived;
197                  try
198                  {
199                      UploadResult uploadResult = await ParallelUploadAsync(context, files, maxConcurrentUploads, _uploadCancellationTokenSource.Token);
200                      if (uploadResult.RetryFiles.Count == 0)
201                      {
202                          context.Output("File upload complete.");
203                          return uploadResult.TotalFileSizeUploaded;
204                      }
205                      else
206                      {
207                          context.Output($"{uploadResult.RetryFiles.Count} files failed to upload, retry these files after a minute.");
208                      }
209                      for (int timer = 60; timer > 0; timer -= 5)
210                      {
211                          context.Output($"Retry file upload after {timer} seconds.");
212                          await Task.Delay(TimeSpan.FromSeconds(5), _uploadCancellationTokenSource.Token);
213                      }
214                      context.Output($"Start retry {uploadResult.RetryFiles.Count} failed files upload.");
215                      UploadResult retryUploadResult = await ParallelUploadAsync(context, uploadResult.RetryFiles, maxConcurrentUploads, _uploadCancellationTokenSource.Token);
216                      if (retryUploadResult.RetryFiles.Count == 0)
217                      {
218                          context.Output("File upload complete after retry.");
219                          return uploadResult.TotalFileSizeUploaded + retryUploadResult.TotalFileSizeUploaded;
220                      }
221                      else
222                      {
223                          throw new Exception("File upload failed even after retry.");
224                      }
225                  }
226                  finally
227                  {
228                      _fileContainerHttpClient.UploadFileReportTrace -= UploadFileTraceReportReceived;
229                      _fileContainerHttpClient.UploadFileReportProgress -= UploadFileProgressReportReceived;
230                  }
231              }
232          }
233          private async Task<DownloadResult> ParallelDownloadAsync(RunnerActionPluginExecutionContext context, IReadOnlyList<DownloadInfo> files, int concurrentDownloads, CancellationToken token)
234          {
235              var downloadResult = new DownloadResult();
236              if (files.Count == 0)
237              {
238                  return downloadResult;
239              }
240              if (!_fileDownloadQueue.IsEmpty)
241              {
242                  throw new ArgumentOutOfRangeException(nameof(_fileDownloadQueue));
243              }
244              foreach (var file in files)
245              {
246                  _fileDownloadQueue.Enqueue(file);
247              }
248              _downloadFilesProcessed = 0;
249              _downloadFinished = new TaskCompletionSource<int>();
250              Task downloadMonitor = DownloadReportingAsync(context, files.Count(), token);
251              List<Task<DownloadResult>> parallelDownloadingTasks = new();
252              for (int downloader = 0; downloader < concurrentDownloads; downloader++)
253              {
254                  parallelDownloadingTasks.Add(DownloadAsync(context, downloader, token));
255              }
256              await Task.WhenAll(parallelDownloadingTasks);
257              foreach (var downloadTask in parallelDownloadingTasks)
258              {
259                  downloadResult.AddDownloadResult(await downloadTask);
260              }
261              _downloadFinished.TrySetResult(0);
262              await downloadMonitor;
263              return downloadResult;
264          }
265          private async Task<UploadResult> ParallelUploadAsync(RunnerActionPluginExecutionContext context, IReadOnlyList<string> files, int concurrentUploads, CancellationToken token)
266          {
267              var uploadResult = new UploadResult();
268              if (files.Count == 0)
269              {
270                  return uploadResult;
271              }
272              if (!_fileUploadQueue.IsEmpty)
273              {
274                  throw new ArgumentOutOfRangeException(nameof(_fileUploadQueue));
275              }
276              foreach (var file in files)
277              {
278                  _fileUploadQueue.Enqueue(file);
279              }
280              _uploadFilesProcessed = 0;
281              _uploadFinished = new TaskCompletionSource<int>();
282              _fileUploadTraceLog.Clear();
283              _fileUploadProgressLog.Clear();
284              Task uploadMonitor = UploadReportingAsync(context, files.Count(), _uploadCancellationTokenSource.Token);
285              List<Task<UploadResult>> parallelUploadingTasks = new();
286              for (int uploader = 0; uploader < concurrentUploads; uploader++)
287              {
288                  parallelUploadingTasks.Add(UploadAsync(context, uploader, _uploadCancellationTokenSource.Token));
289              }
290              await Task.WhenAll(parallelUploadingTasks);
291              foreach (var uploadTask in parallelUploadingTasks)
292              {
293                  uploadResult.AddUploadResult(await uploadTask);
294              }
295              _uploadFinished.TrySetResult(0);
296              await uploadMonitor;
297              return uploadResult;
298          }
299          private async Task<DownloadResult> DownloadAsync(RunnerActionPluginExecutionContext context, int downloaderId, CancellationToken token)
300          {
301              List<DownloadInfo> failedFiles = new();
302              Stopwatch downloadTimer = new();
303              while (_fileDownloadQueue.TryDequeue(out DownloadInfo fileToDownload))
304              {
305                  token.ThrowIfCancellationRequested();
306                  try
307                  {
308                      int retryCount = 0;
309                      bool downloadFailed = false;
310                      while (true)
311                      {
312                          try
313                          {
314                              context.Debug($"Start downloading file: '{fileToDownload.ItemPath}' (Downloader {downloaderId})");
315                              downloadTimer.Restart();
316                              using (FileStream fs = new(fileToDownload.LocalPath, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: _defaultFileStreamBufferSize, useAsync: true))
317                              using (var downloadStream = await _fileContainerHttpClient.DownloadFileAsync(_containerId, fileToDownload.ItemPath, token, _projectId))
318                              {
319                                  await downloadStream.CopyToAsync(fs, _defaultCopyBufferSize, token);
320                                  await fs.FlushAsync(token);
321                                  downloadTimer.Stop();
322                                  context.Debug($"File: '{fileToDownload.LocalPath}' took {downloadTimer.ElapsedMilliseconds} milliseconds to finish download (Downloader {downloaderId})");
323                                  break;
324                              }
325                          }
326                          catch (OperationCanceledException) when (token.IsCancellationRequested)
327                          {
328                              context.Debug($"Download has been cancelled while downloading {fileToDownload.ItemPath}. (Downloader {downloaderId})");
329                              throw;
330                          }
331                          catch (Exception ex)
332                          {
333                              retryCount++;
334                              context.Warning($"Fail to download '{fileToDownload.ItemPath}', error: {ex.Message} (Downloader {downloaderId})");
335                              context.Debug(ex.ToString());
336                          }
337                          if (retryCount < 3)
338                          {
339                              var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
340                              context.Warning($"Back off {backOff.TotalSeconds} seconds before retry. (Downloader {downloaderId})");
341                              await Task.Delay(backOff);
342                          }
343                          else
344                          {
345                              downloadFailed = true;
346                              break;
347                          }
348                      }
349                      if (downloadFailed)
350                      {
351                          failedFiles.Add(fileToDownload);
352                      }
353                      Interlocked.Increment(ref _downloadFilesProcessed);
354                  }
355                  catch (Exception ex)
356                  {
357                      context.Error($"Error '{ex.Message}' when downloading file '{fileToDownload}'. (Downloader {downloaderId})");
358                      throw;
359                  }
360              }
361              return new DownloadResult(failedFiles);
362          }
363          private async Task<UploadResult> UploadAsync(RunnerActionPluginExecutionContext context, int uploaderId, CancellationToken token)
364          {
365              List<string> failedFiles = new();
366              long uploadedSize = 0;
367              string fileToUpload;
368              Stopwatch uploadTimer = new();
369              while (_fileUploadQueue.TryDequeue(out fileToUpload))
370              {
371                  token.ThrowIfCancellationRequested();
372                  try
373                  {
374                      using (FileStream fs = File.Open(fileToUpload, FileMode.Open, FileAccess.Read, FileShare.Read))
375                      {
376                          string itemPath = (_containerPath.TrimEnd('/') + "/" + fileToUpload.Remove(0, _sourceParentDirectory.Length + 1)).Replace('\\', '/');
377                          bool failAndExit = false;
378                          try
379                          {
380                              uploadTimer.Restart();
381                              using (HttpResponseMessage response = await _fileContainerHttpClient.UploadFileAsync(_containerId, itemPath, fs, _projectId, cancellationToken: token))
382                              {
383                                  if (response == null || response.StatusCode != HttpStatusCode.Created)
384                                  {
385                                      context.Output($"Unable to copy file to server StatusCode={response?.StatusCode}: {response?.ReasonPhrase}. Source file path: {fileToUpload}. Target server path: {itemPath}");
386                                      if (response?.StatusCode == HttpStatusCode.Conflict)
387                                      {
388                                          context.Error($"Error '{fileToUpload}' has already been uploaded.");
389                                      }
390                                      else if (_fileContainerHttpClient.IsFastFailResponse(response))
391                                      {
392                                          context.Output($"Cannot continue uploading files, so draining upload queue of {_fileUploadQueue.Count} items.");
393                                          DrainUploadQueue(context);
394                                          failedFiles.Clear();
395                                          failAndExit = true;
396                                          throw new UploadFailedException($"Critical failure uploading '{fileToUpload}'");
397                                      }
398                                      else
399                                      {
400                                          context.Debug($"Adding '{fileToUpload}' to retry list.");
401                                          failedFiles.Add(fileToUpload);
402                                      }
403                                      throw new UploadFailedException($"Http failure response '{response?.StatusCode}': '{response?.ReasonPhrase}' while uploading '{fileToUpload}'");
404                                  }
405                                  uploadTimer.Stop();
406                                  context.Debug($"File: '{fileToUpload}' took {uploadTimer.ElapsedMilliseconds} milliseconds to finish upload");
407                                  uploadedSize += fs.Length;
408                                  OutputLogForFile(context, fileToUpload, $"Detail upload trace for file: {itemPath}", context.Debug);
409                              }
410                          }
411                          catch (OperationCanceledException) when (token.IsCancellationRequested)
412                          {
413                              context.Output($"File upload has been cancelled during upload file: '{fileToUpload}'.");
414                              throw;
415                          }
416                          catch (Exception ex)
417                          {
418                              context.Output($"Fail to upload '{fileToUpload}' due to '{ex.Message}'.");
419                              context.Output(ex.ToString());
420                              OutputLogForFile(context, fileToUpload, $"Detail upload trace for file that fail to upload: {itemPath}", context.Output);
421                              if (failAndExit)
422                              {
423                                  context.Debug("Exiting upload.");
424                                  throw;
425                              }
426                          }
427                      }
428                      Interlocked.Increment(ref _uploadFilesProcessed);
429                  }
430                  catch (Exception ex)
431                  {
432                      context.Output($"File error '{ex.Message}' when uploading file '{fileToUpload}'.");
433                      throw;
434                  }
435              }
436              return new UploadResult(failedFiles, uploadedSize);
437          }
438          private async Task UploadReportingAsync(RunnerActionPluginExecutionContext context, int totalFiles, CancellationToken token)
439          {
440              int traceInterval = 0;
441              while (!_uploadFinished.Task.IsCompleted && !token.IsCancellationRequested)
442              {
443                  bool hasDetailProgress = false;
444                  foreach (var file in _fileUploadProgressLog)
445                  {
446                      string message;
447                      while (file.Value.TryDequeue(out message))
448                      {
449                          hasDetailProgress = true;
450                          context.Output(message);
451                      }
452                  }
453                  if (++traceInterval % 2 == 0 && !hasDetailProgress)
454                  {
455                      context.Output($"Total file: {totalFiles} ---- Processed file: {_uploadFilesProcessed} ({(_uploadFilesProcessed * 100) / totalFiles}%)");
456                  }
457                  await Task.WhenAny(_uploadFinished.Task, Task.Delay(5000, token));
458              }
459          }
460          private async Task DownloadReportingAsync(RunnerActionPluginExecutionContext context, int totalFiles, CancellationToken token)
461          {
462              int traceInterval = 0;
463              while (!_downloadFinished.Task.IsCompleted && !token.IsCancellationRequested)
464              {
465                  if (++traceInterval % 2 == 0)
466                  {
467                      context.Output($"Total file: {totalFiles} ---- Downloaded file: {_downloadFilesProcessed} ({(_downloadFilesProcessed * 100) / totalFiles}%)");
468                  }
469                  await Task.WhenAny(_downloadFinished.Task, Task.Delay(5000, token));
470              }
471          }
472          private void DrainUploadQueue(RunnerActionPluginExecutionContext context)
473          {
474              while (_fileUploadQueue.TryDequeue(out string fileToUpload))
475              {
476                  context.Debug($"Clearing upload queue: '{fileToUpload}'");
477                  Interlocked.Increment(ref _uploadFilesProcessed);
478              }
479          }
480          private void OutputLogForFile(RunnerActionPluginExecutionContext context, string itemPath, string logDescription, Action<string> log)
481          {
482              ConcurrentQueue<string> logQueue;
483              if (_fileUploadTraceLog.TryGetValue(itemPath, out logQueue))
484              {
485                  log(logDescription);
486                  string message;
487                  while (logQueue.TryDequeue(out message))
488                  {
489                      log(message);
490                  }
491              }
492          }
493          private void UploadFileTraceReportReceived(object sender, ReportTraceEventArgs e)
494          {
495              ConcurrentQueue<string> logQueue = _fileUploadTraceLog.GetOrAdd(e.File, new ConcurrentQueue<string>());
496              logQueue.Enqueue(e.Message);
497          }
498          private void UploadFileProgressReportReceived(object sender, ReportProgressEventArgs e)
499          {
500              ConcurrentQueue<string> progressQueue = _fileUploadProgressLog.GetOrAdd(e.File, new ConcurrentQueue<string>());
501              progressQueue.Enqueue($"Uploading '{e.File}' ({(e.CurrentChunk * 100) / e.TotalChunks}%)");
502          }
503      }
504      public class UploadResult
505      {
506          public UploadResult()
507          {
508              RetryFiles = new List<string>();
509              TotalFileSizeUploaded = 0;
510          }
511          public UploadResult(List<string> retryFiles, long totalFileSizeUploaded)
512          {
513              RetryFiles = retryFiles ?? new List<string>();
514              TotalFileSizeUploaded = totalFileSizeUploaded;
515          }
<span onclick='openModal()' class='match'>516          public List<string> RetryFiles { get; set; }
517          public long TotalFileSizeUploaded { get; set; }
</span>518          public void AddUploadResult(UploadResult resultToAdd)
519          {
520              this.RetryFiles.AddRange(resultToAdd.RetryFiles);
521              this.TotalFileSizeUploaded += resultToAdd.TotalFileSizeUploaded;
522          }
523      }
524      public class DownloadInfo
525      {
526          public DownloadInfo(string itemPath, string localPath)
527          {
528              this.ItemPath = itemPath;
529              this.LocalPath = localPath;
530          }
531          public string ItemPath { get; set; }
532          public string LocalPath { get; set; }
533      }
534      public class DownloadResult
535      {
536          public DownloadResult()
537          {
538              FailedFiles = new List<DownloadInfo>();
539          }
540          public DownloadResult(List<DownloadInfo> failedFiles)
541          {
542              FailedFiles = failedFiles;
543          }
544          public List<DownloadInfo> FailedFiles { get; set; }
545          public void AddDownloadResult(DownloadResult resultToAdd)
546          {
547              this.FailedFiles.AddRange(resultToAdd.FailedFiles);
548          }
549      }
550      public class UploadFailedException : Exception
551      {
552          public UploadFailedException()
553              : base()
554          { }
555          public UploadFailedException(string message)
556              : base(message)
557          { }
558          public UploadFailedException(string message, Exception inner)
559              : base(message, inner)
560          { }
561      }
562  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-FacebookOptions.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-FileContainerServer.cs</div>
                <div class="column column_space"><pre><code>61          public bool SendAppSecretProof { get; set; }
62          public ICollection<string> Fields { get; } = new HashSet<string>();
</pre></code></div>
                <div class="column column_space"><pre><code>516          public List<string> RetryFiles { get; set; }
517          public long TotalFileSizeUploaded { get; set; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    