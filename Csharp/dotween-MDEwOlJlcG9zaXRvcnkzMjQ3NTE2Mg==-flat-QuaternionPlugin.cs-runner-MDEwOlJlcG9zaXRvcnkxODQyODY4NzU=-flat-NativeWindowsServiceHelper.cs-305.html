
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-QuaternionPlugin.cs</h3>
            <pre><code>1  #if !COMPATIBLE
2  using DG.Tweening.Core;
3  using DG.Tweening.Core.Easing;
4  using DG.Tweening.Core.Enums;
5  using DG.Tweening.Plugins.Core;
6  using DG.Tweening.Plugins.Options;
7  using UnityEngine;
8  #pragma warning disable 1591
9  namespace DG.Tweening.Plugins
10  {
11      public class QuaternionPlugin : ABSTweenPlugin&lt;Quaternion,Vector3,QuaternionOptions&gt;
12      {
13          public override void Reset(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t) { }
14          public override void SetFrom(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t, bool isRelative)
15          {
16              Vector3 prevEndVal = t.endValue;
17              t.endValue = t.getter().eulerAngles;
18              if (t.plugOptions.rotateMode == RotateMode.Fast &amp;&amp; !t.isRelative) {
19                  t.startValue = GetEulerValForCalculations(t, prevEndVal, t.endValue);
20              } else if (t.plugOptions.rotateMode == RotateMode.FastBeyond360) {
21                  t.startValue = GetEulerValForCalculations(t, t.endValue + prevEndVal, t.endValue);
22              } else {
23                  Quaternion rot = t.getter();
24                  if (t.plugOptions.rotateMode == RotateMode.WorldAxisAdd) {
25                      t.startValue = (rot * Quaternion.Inverse(rot) * Quaternion.Euler(prevEndVal) * rot).eulerAngles;
26                  } else {
27                      t.startValue = (rot * Quaternion.Euler(prevEndVal)).eulerAngles;
28                  }
29                  t.endValue = -prevEndVal;
30              }
31              t.setter(Quaternion.Euler(t.startValue));
32          }
33          public override void SetFrom(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t, Vector3 fromValue, bool setImmediately, bool isRelative)
34          {
35              if (isRelative) {
36                  Vector3 currVal = t.getter().eulerAngles;
37                  t.endValue += currVal;
38                  fromValue += currVal;
39              }
40              t.startValue = GetEulerValForCalculations(t, fromValue, t.endValue);
41              if (setImmediately) t.setter(Quaternion.Euler(fromValue));
42          }
43          public override Vector3 ConvertToStartValue(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t, Quaternion value)
44          {
45              return value.eulerAngles;
46          }
47          public override void SetRelativeEndValue(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t)
48          {
49              t.endValue += t.startValue;
50          }
51          public override void SetChangeValue(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t)
52          {
53              Vector3 endVal = t.isFrom ? t.endValue : GetEulerValForCalculations(t, t.endValue, t.startValue);
54              Vector3 startVal = t.startValue;
55              if (t.plugOptions.rotateMode == RotateMode.Fast &amp;&amp; !t.isRelative) {
56                  if (endVal.x &gt; 360 || endVal.x &lt; 360) endVal.x = endVal.x % 360;
57                  if (endVal.y &gt; 360 || endVal.y &lt; 360) endVal.y = endVal.y % 360;
58                  if (endVal.z &gt; 360 || endVal.z &lt; 360) endVal.z = endVal.z % 360;
59                  Vector3 changeVal = endVal - startVal;
60                  float abs = (changeVal.x &gt; 0 ? changeVal.x : -changeVal.x);
61                  if (abs &gt; 180) changeVal.x = changeVal.x &gt; 0 ? -(360 - abs) : 360 - abs;
62                  abs = (changeVal.y &gt; 0 ? changeVal.y : -changeVal.y);
63                  if (abs &gt; 180) changeVal.y = changeVal.y &gt; 0 ? -(360 - abs) : 360 - abs;
64                  abs = (changeVal.z &gt; 0 ? changeVal.z : -changeVal.z);
65                  if (abs &gt; 180) changeVal.z = changeVal.z &gt; 0 ? -(360 - abs) : 360 - abs;
66                  t.changeValue = changeVal;
67              } else if (t.plugOptions.rotateMode == RotateMode.FastBeyond360 || t.isRelative) {
68                  t.changeValue = endVal - startVal;
69              } else {
70                  t.changeValue = endVal;
71              }
72          }
73          public override float GetSpeedBasedDuration(QuaternionOptions options, float unitsXSecond, Vector3 changeValue)
74          {
75              return changeValue.magnitude / unitsXSecond;
76          }
77          public override void EvaluateAndApply(
78              QuaternionOptions options, Tween t, bool isRelative, DOGetter&lt;Quaternion&gt; getter, DOSetter&lt;Quaternion&gt; setter,
79              float elapsed, Vector3 startValue, Vector3 changeValue, float duration, bool usingInversePosition, int newCompletedSteps,
80              UpdateNotice updateNotice
81          ){
82              if (options.dynamicLookAt) {
83                  TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; tweener = (TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt;)t;
84                  tweener.endValue = options.dynamicLookAtWorldPosition;
85                  SpecialPluginsUtils.SetLookAt(tweener);
<span onclick='openModal()' class='match'>86                  SetChangeValue(tweener);
87                  changeValue = tweener.changeValue;
88              }
89              Vector3 endValue = startValue;
</span>90              if (t.loopType == LoopType.Incremental) endValue += changeValue * (t.isComplete ? t.completedLoops - 1 : t.completedLoops);
91              if (t.isSequenced &amp;&amp; t.sequenceParent.loopType == LoopType.Incremental) {
92                  endValue += changeValue * (t.loopType == LoopType.Incremental ? t.loops : 1)
93                      * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
94              }
95              float easeVal = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
96              switch (options.rotateMode) {
97              case RotateMode.WorldAxisAdd:
98              case RotateMode.LocalAxisAdd:
99                  Quaternion startRot = Quaternion.Euler(startValue); 
100                  endValue.x = changeValue.x * easeVal;
101                  endValue.y = changeValue.y * easeVal;
102                  endValue.z = changeValue.z * easeVal;
103                  if (options.rotateMode == RotateMode.WorldAxisAdd) setter(startRot * Quaternion.Inverse(startRot) * Quaternion.Euler(endValue) * startRot);
104                  else setter(startRot * Quaternion.Euler(endValue));
105                  break;
106              default:
107                  endValue.x += changeValue.x * easeVal;
108                  endValue.y += changeValue.y * easeVal;
109                  endValue.z += changeValue.z * easeVal;
110                  setter(Quaternion.Euler(endValue));
111                  break;
112              }
113          }
114          Vector3 GetEulerValForCalculations(TweenerCore&lt;Quaternion, Vector3, QuaternionOptions&gt; t, Vector3 val, Vector3 counterVal)
115          {
116              if (t.isRelative) return val;
117              switch (t.plugOptions.rotateMode) {
118              case RotateMode.WorldAxisAdd:
119              case RotateMode.LocalAxisAdd:
120                  return val;
121              }
122              Vector3 valFlipped = FlipEulerAngles(val);
123              bool xVsNormalSame = Mathf.Approximately(counterVal.x, val.x);
124              bool xVsFlippedSame = Mathf.Approximately(counterVal.x, valFlipped.x);
125              bool yVsNormalSame = Mathf.Approximately(counterVal.y, val.y);
126              bool yVsFlippedSame = Mathf.Approximately(counterVal.y, valFlipped.y);
127              bool zVsNormalSame = Mathf.Approximately(counterVal.z, val.z);
128              bool zVsFlippedSame = Mathf.Approximately(counterVal.z, valFlipped.z);
129              bool isSingleAxisRotationNormal = xVsNormalSame &amp;&amp; (yVsNormalSame || zVsNormalSame)
130                                                || yVsNormalSame &amp;&amp; zVsNormalSame;
131              bool isSingleAxisRotationFlipped = !isSingleAxisRotationNormal
132                                                 &amp;&amp; xVsFlippedSame &amp;&amp; (yVsFlippedSame || zVsFlippedSame)
133                                                 || yVsFlippedSame &amp;&amp; zVsFlippedSame;
134              if (!isSingleAxisRotationNormal &amp;&amp; !isSingleAxisRotationFlipped) return val;
135              int axisToRotate = 0;
136              if (isSingleAxisRotationNormal) {
137                  axisToRotate = xVsNormalSame
138                      ? yVsNormalSame 
139                          ? 2 : 1
140                      : 0;
141              } else {
142                  axisToRotate = xVsFlippedSame
143                      ? yVsFlippedSame 
144                          ? 2 : 1
145                      : 0;
146              }
147              bool flip = false;
148              switch (axisToRotate) {
149              case 0: 
150                  flip = !Mathf.Approximately(counterVal.y, val.y) || !Mathf.Approximately(counterVal.z, val.z);
151                  break;
152              case 1: 
153                  flip = !Mathf.Approximately(counterVal.x, val.x) || !Mathf.Approximately(counterVal.z, val.z);
154                  break;
155              case 2: 
156                  flip = !Mathf.Approximately(counterVal.x, val.x) || !Mathf.Approximately(counterVal.y, val.y);
157                  break;
158              }
159              return flip ? valFlipped : val;
160          }
161          Vector3 FlipEulerAngles(Vector3 euler)
162          {
163              return new Vector3(180 - euler.x, euler.y + 180, euler.z + 180);
164          }
165      }
166  }
167  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-NativeWindowsServiceHelper.cs</h3>
            <pre><code>1  #if OS_WINDOWS
2  #pragma warning disable CA1416
3  using System;
4  using System.Collections;
5  using System.Collections.Generic;
6  using System.ComponentModel;
7  using System.IO;
8  using System.Linq;
9  using System.Runtime.InteropServices;
10  using System.Security;
11  using System.Security.AccessControl;
12  using System.Security.Principal;
13  using System.ServiceProcess;
14  using System.Threading;
15  using GitHub.Runner.Common.Util;
16  using Microsoft.Win32;
17  using GitHub.Runner.Common;
18  using GitHub.Runner.Sdk;
19  namespace GitHub.Runner.Listener.Configuration
20  {
21      [ServiceLocator(Default = typeof(NativeWindowsServiceHelper))]
22      public interface INativeWindowsServiceHelper : IRunnerService
23      {
24          string GetUniqueRunnerGroupName();
25          bool LocalGroupExists(string groupName);
26          void CreateLocalGroup(string groupName);
27          void DeleteLocalGroup(string groupName);
28          void AddMemberToLocalGroup(string accountName, string groupName);
29          void GrantFullControlToGroup(string path, string groupName);
30          void RemoveGroupFromFolderSecuritySetting(string folderPath, string groupName);
31          bool IsUserHasLogonAsServicePrivilege(string domain, string userName);
32          bool GrantUserLogonAsServicePrivilege(string domain, string userName);
33          bool IsValidCredential(string domain, string userName, string logonPassword);
34          NTAccount GetDefaultServiceAccount();
35          NTAccount GetDefaultAdminServiceAccount();
36          bool IsServiceExists(string serviceName);
37          void InstallService(string serviceName, string serviceDisplayName, string logonAccount, string logonPassword);
38          void UninstallService(string serviceName);
39          void StartService(string serviceName);
40          void StopService(string serviceName);
41          string GetSecurityId(string domainName, string userName);
42          void SetAutoLogonPassword(string password);
43          void ResetAutoLogonPassword();
44          bool IsRunningInElevatedMode();
45          void LoadUserProfile(string domain, string userName, string logonPassword, out IntPtr tokenHandle, out PROFILEINFO userProfile);
46          void UnloadUserProfile(IntPtr tokenHandle, PROFILEINFO userProfile);
47          bool IsValidAutoLogonCredential(string domain, string userName, string logonPassword);
48          void GrantDirectoryPermissionForAccount(string accountName, IList&lt;string&gt; folders);
49          void RevokeDirectoryPermissionForAccount(IList&lt;string&gt; folders);
50      }
51      public class NativeWindowsServiceHelper : RunnerService, INativeWindowsServiceHelper
52      {
53          private const string RunnerServiceLocalGroupPrefix = &quot;GITHUB_ActionsRunner_G&quot;;
54          private ITerminal _term;
55          public override void Initialize(IHostContext hostContext)
56          {
57              base.Initialize(hostContext);
58              _term = hostContext.GetService&lt;ITerminal&gt;();
59          }
60          public string GetUniqueRunnerGroupName()
61          {
62              return RunnerServiceLocalGroupPrefix + IOUtil.GetSha256Hash(HostContext.GetDirectory(WellKnownDirectory.Bin)).Substring(0, 5);
63          }
64          public bool LocalGroupExists(string groupName)
65          {
66              Trace.Entering();
67              bool exists = false;
68              IntPtr bufptr;
69              int returnCode = NetLocalGroupGetInfo(null,            
70                                                    groupName,
71                                                    1,               
72                                                    out bufptr);     
73              try
74              {
75                  switch (returnCode)
76                  {
77                      case ReturnCode.S_OK:
78                          Trace.Info($&quot;Local group &#x27;{groupName}&#x27; exist.&quot;);
79                          exists = true;
80                          break;
81                      case ReturnCode.NERR_GroupNotFound:
82                      case ReturnCode.ERROR_NO_SUCH_ALIAS:
83                          exists = false;
84                          break;
85                      case ReturnCode.ERROR_ACCESS_DENIED:
86                          throw new UnauthorizedAccessException(&quot;Access Denied&quot;);
87                      default:
88                          throw new Exception($&quot;Error: Operation {nameof(NetLocalGroupGetInfo)} failed with return code {returnCode}&quot;);
89                  }
90              }
91              finally
92              {
93                  int bufferFreeError = NetApiBufferFree(bufptr);
94                  if (bufferFreeError != 0)
95                  {
96                      Trace.Error(StringUtil.Format(&quot;Buffer free error, could not free buffer allocated, error code: {0}&quot;, bufferFreeError));
97                  }
98              }
99              return exists;
100          }
101          public void CreateLocalGroup(string groupName)
102          {
103              Trace.Entering();
104              LocalGroupInfo groupInfo = new LocalGroupInfo();
105              groupInfo.Name = groupName;
106              groupInfo.Comment = StringUtil.Format(&quot;Built-in group used by GitHub Actions Runner.&quot;);
107              int returnCode = NetLocalGroupAdd(null,               
108                                                1,                  
109                                                ref groupInfo,
110                                                0);                 
111              if (returnCode == ReturnCode.S_OK)
112              {
113                  Trace.Info($&quot;Local Group &#x27;{groupName}&#x27; created&quot;);
114                  return;
115              }
116              switch (returnCode)
117              {
118                  case ReturnCode.NERR_GroupExists:
119                  case ReturnCode.ERROR_ALIAS_EXISTS:
120                      Trace.Info(StringUtil.Format(&quot;Group {0} already exists&quot;, groupName));
121                      break;
122                  case ReturnCode.ERROR_ACCESS_DENIED:
123                      throw new UnauthorizedAccessException(&quot;Access Denied&quot;);
124                  case ReturnCode.ERROR_INVALID_PARAMETER:
125                      throw new ArgumentException($&quot;Invalid Group Name - {groupName}&quot;);
126                  default:
127                      throw new Exception($&quot;Error: Operation {nameof(NetLocalGroupAdd)} failed with return code {returnCode}&quot;);
128              }
129          }
130          public void DeleteLocalGroup(string groupName)
131          {
132              Trace.Entering();
133              int returnCode = NetLocalGroupDel(null,  
134                                                groupName);
135              if (returnCode == ReturnCode.S_OK)
136              {
137                  Trace.Info($&quot;Local Group &#x27;{groupName}&#x27; deleted&quot;);
138                  return;
139              }
140              switch (returnCode)
141              {
142                  case ReturnCode.NERR_GroupNotFound:
143                  case ReturnCode.ERROR_NO_SUCH_ALIAS:
144                      Trace.Info(StringUtil.Format(&quot;Group {0} not exists.&quot;, groupName));
145                      break;
146                  case ReturnCode.ERROR_ACCESS_DENIED:
147                      throw new UnauthorizedAccessException(&quot;Access Denied&quot;);
148                  default:
149                      throw new Exception($&quot;Error: Operation {nameof(NetLocalGroupDel)} failed with return code {returnCode}&quot;);
150              }
151          }
152          public void AddMemberToLocalGroup(string accountName, string groupName)
153          {
154              Trace.Entering();
155              LocalGroupMemberInfo memberInfo = new LocalGroupMemberInfo();
156              memberInfo.FullName = accountName;
157              int returnCode = NetLocalGroupAddMembers(null,              
158                                                       groupName,
159                                                       3,                 
160                                                       ref memberInfo,
161                                                       1);                
162              if (returnCode == ReturnCode.S_OK)
163              {
164                  Trace.Info($&quot;Account &#x27;{accountName}&#x27; is added to local group &#x27;{groupName}&#x27;.&quot;);
165                  return;
166              }
167              switch (returnCode)
168              {
169                  case ReturnCode.ERROR_MEMBER_IN_ALIAS:
170                      Trace.Info(StringUtil.Format(&quot;Account {0} is already member of group {1}&quot;, accountName, groupName));
171                      break;
172                  case ReturnCode.NERR_GroupNotFound:
173                  case ReturnCode.ERROR_NO_SUCH_ALIAS:
174                      throw new ArgumentException($&quot;Group: {groupName} does not Exist&quot;);
175                  case ReturnCode.ERROR_NO_SUCH_MEMBER:
176                      throw new ArgumentException($&quot;Member: {accountName} does not Exist&quot;);
177                  case ReturnCode.ERROR_INVALID_MEMBER:
178                      throw new ArgumentException(&quot;A new member could not be added to a local group because the member has the wrong account type. If you are configuring on a domain controller, built-in machine accounts cannot be added to local groups. You must use a domain user account instead&quot;);
179                  case ReturnCode.ERROR_ACCESS_DENIED:
180                      throw new UnauthorizedAccessException(&quot;Access Denied&quot;);
181                  default:
182                      throw new Exception($&quot;Error: Operation {nameof(NetLocalGroupAddMembers)} failed with return code {returnCode}&quot;);
183              }
184          }
185          public void GrantFullControlToGroup(string path, string groupName)
186          {
187              Trace.Entering();
188              if (IsGroupHasFullControl(path, groupName))
189              {
190                  Trace.Info($&quot;Local group &#x27;{groupName}&#x27; already has full control to path &#x27;{path}&#x27;.&quot;);
191                  return;
192              }
193              DirectoryInfo dInfo = new DirectoryInfo(path);
194              DirectorySecurity dSecurity = dInfo.GetAccessControl();
195              if (!dSecurity.AreAccessRulesCanonical)
196              {
197                  Trace.Warning(&quot;Acls are not canonical, this may cause failure&quot;);
198              }
199              dSecurity.AddAccessRule(
200                  new FileSystemAccessRule(
201                      groupName,
202                      FileSystemRights.FullControl,
203                      InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit,
204                      PropagationFlags.None,
205                      AccessControlType.Allow));
206              dInfo.SetAccessControl(dSecurity);
207          }
208          private bool IsGroupHasFullControl(string path, string groupName)
209          {
210              DirectoryInfo dInfo = new DirectoryInfo(path);
211              DirectorySecurity dSecurity = dInfo.GetAccessControl();
212              var allAccessRuls = dSecurity.GetAccessRules(true, true, typeof(SecurityIdentifier)).Cast&lt;FileSystemAccessRule&gt;();
213              SecurityIdentifier sid = (SecurityIdentifier)new NTAccount(groupName).Translate(typeof(SecurityIdentifier));
214              if (allAccessRuls.Any(x =&gt; x.IdentityReference.Value == sid.ToString() &amp;&amp;
215                                         x.AccessControlType == AccessControlType.Allow &amp;&amp;
216                                         x.FileSystemRights.HasFlag(FileSystemRights.FullControl) &amp;&amp;
217                                         x.InheritanceFlags == (InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit) &amp;&amp;
218                                         x.PropagationFlags == PropagationFlags.None))
219              {
220                  return true;
221              }
222              else
223              {
224                  return false;
225              }
226          }
227          public bool IsUserHasLogonAsServicePrivilege(string domain, string userName)
228          {
229              Trace.Entering();
230              ArgUtil.NotNullOrEmpty(userName, nameof(userName));
231              bool userHasPermission = false;
232              using (LsaPolicy lsaPolicy = new LsaPolicy())
233              {
234                  IntPtr rightsPtr;
235                  uint count;
236                  uint result = LsaEnumerateAccountRights(lsaPolicy.Handle, GetSidBinaryFromWindows(domain, userName), out rightsPtr, out count);
237                  try
238                  {
239                      if (result == 0)
240                      {
241                          IntPtr incrementPtr = rightsPtr;
242                          for (int i = 0; i &lt; count; i++)
243                          {
244                              LSA_UNICODE_STRING nativeRightString = Marshal.PtrToStructure&lt;LSA_UNICODE_STRING&gt;(incrementPtr);
245                              string rightString = Marshal.PtrToStringUni(nativeRightString.Buffer);
246                              Trace.Verbose($&quot;Account {userName} has &#x27;{rightString}&#x27; right.&quot;);
247                              if (string.Equals(rightString, s_logonAsServiceName, StringComparison.OrdinalIgnoreCase))
248                              {
249                                  userHasPermission = true;
250                              }
251                              incrementPtr += Marshal.SizeOf(nativeRightString);
252                          }
253                      }
254                      else
255                      {
256                          Trace.Error($&quot;Can&#x27;t enumerate account rights, return code {result}.&quot;);
257                      }
258                  }
259                  finally
260                  {
261                      result = LsaFreeMemory(rightsPtr);
262                      if (result != 0)
263                      {
264                          Trace.Error(StringUtil.Format(&quot;Failed to free memory from LsaEnumerateAccountRights. Return code : {0} &quot;, result));
265                      }
266                  }
267              }
268              return userHasPermission;
269          }
270          public bool GrantUserLogonAsServicePrivilege(string domain, string userName)
271          {
272              Trace.Entering();
273              ArgUtil.NotNullOrEmpty(userName, nameof(userName));
274              using (LsaPolicy lsaPolicy = new LsaPolicy())
275              {
276                  uint result = LsaAddAccountRights(lsaPolicy.Handle, GetSidBinaryFromWindows(domain, userName), LogonAsServiceRights, 1);
277                  if (result == 0)
278                  {
279                      Trace.Info($&quot;Successfully grant logon as service privilege to account &#x27;{userName}&#x27;&quot;);
280                      return true;
281                  }
282                  else
283                  {
284                      Trace.Info($&quot;Fail to grant logon as service privilege to account &#x27;{userName}&#x27;, error code {result}.&quot;);
285                      return false;
286                  }
287              }
288          }
289          public static bool IsWellKnownIdentity(String accountName)
290          {
291              NTAccount ntaccount = new NTAccount(accountName);
292              SecurityIdentifier sid = (SecurityIdentifier)ntaccount.Translate(typeof(SecurityIdentifier));
293              SecurityIdentifier networkServiceSid = new SecurityIdentifier(WellKnownSidType.NetworkServiceSid, null);
294              SecurityIdentifier localServiceSid = new SecurityIdentifier(WellKnownSidType.LocalServiceSid, null);
295              SecurityIdentifier localSystemSid = new SecurityIdentifier(WellKnownSidType.LocalSystemSid, null);
296              return sid.Equals(networkServiceSid) ||
297                     sid.Equals(localServiceSid) ||
298                     sid.Equals(localSystemSid);
299          }
300          public bool IsValidCredential(string domain, string userName, string logonPassword)
301          {
302              return IsValidCredentialInternal(domain, userName, logonPassword, LOGON32_LOGON_NETWORK);
303          }
304          public bool IsValidAutoLogonCredential(string domain, string userName, string logonPassword)
305          {
306              return IsValidCredentialInternal(domain, userName, logonPassword, LOGON32_LOGON_INTERACTIVE);
307          }
308          public NTAccount GetDefaultServiceAccount()
309          {
310              SecurityIdentifier sid = new SecurityIdentifier(WellKnownSidType.NetworkServiceSid, domainSid: null);
311              NTAccount account = sid.Translate(typeof(NTAccount)) as NTAccount;
312              if (account == null)
313              {
314                  throw new InvalidOperationException(&quot;Cannot find network service account&quot;);
315              }
316              return account;
317          }
318          public NTAccount GetDefaultAdminServiceAccount()
319          {
320              SecurityIdentifier sid = new SecurityIdentifier(WellKnownSidType.LocalSystemSid, domainSid: null);
321              NTAccount account = sid.Translate(typeof(NTAccount)) as NTAccount;
322              if (account == null)
323              {
324                  throw new InvalidOperationException(&quot;Cannot find local system account&quot;);
325              }
326              return account;
327          }
328          public void RemoveGroupFromFolderSecuritySetting(string folderPath, string groupName)
329          {
330              DirectoryInfo dInfo = new DirectoryInfo(folderPath);
331              if (dInfo.Exists)
332              {
333                  DirectorySecurity dSecurity = dInfo.GetAccessControl();
334                  var allAccessRuls = dSecurity.GetAccessRules(true, true, typeof(SecurityIdentifier)).Cast&lt;FileSystemAccessRule&gt;();
335                  SecurityIdentifier sid = (SecurityIdentifier)new NTAccount(groupName).Translate(typeof(SecurityIdentifier));
336                  foreach (FileSystemAccessRule ace in allAccessRuls)
337                  {
338                      if (String.Equals(sid.ToString(), ace.IdentityReference.Value, StringComparison.OrdinalIgnoreCase))
339                      {
340                          dSecurity.RemoveAccessRuleSpecific(ace);
341                      }
342                  }
343                  dInfo.SetAccessControl(dSecurity);
344              }
345          }
346          public bool IsServiceExists(string serviceName)
347          {
348              Trace.Entering();
349              ServiceController service = ServiceController.GetServices().FirstOrDefault(x =&gt; x.ServiceName.Equals(serviceName, StringComparison.OrdinalIgnoreCase));
350              return service != null;
351          }
352          public void InstallService(string serviceName, string serviceDisplayName, string logonAccount, string logonPassword)
353          {
354              Trace.Entering();
355              string runnerServiceExecutable = &quot;\&quot;&quot; + Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Bin), WindowsServiceControlManager.WindowsServiceControllerName) + &quot;\&quot;&quot;;
356              IntPtr scmHndl = IntPtr.Zero;
357              IntPtr svcHndl = IntPtr.Zero;
358              IntPtr tmpBuf = IntPtr.Zero;
359              IntPtr svcLock = IntPtr.Zero;
360              try
361              {
362                  using (var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;())
363                  {
364                      processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
365                      {
366                          _term.WriteLine(message.Data);
367                      };
368                      processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
369                      {
370                          _term.WriteLine(message.Data);
371                      };
372                      processInvoker.ExecuteAsync(workingDirectory: string.Empty,
373                                                  fileName: runnerServiceExecutable,
374                                                  arguments: &quot;init&quot;,
375                                                  environment: null,
376                                                  requireExitCodeZero: true,
377                                                  cancellationToken: CancellationToken.None).GetAwaiter().GetResult();
378                  }
379                  Trace.Verbose(StringUtil.Format(&quot;Trying to open SCManager.&quot;));
380                  scmHndl = OpenSCManager(null, null, ServiceManagerRights.AllAccess);
381                  if (scmHndl.ToInt64() &lt;= 0)
382                  {
383                      throw new Exception(&quot;Failed to Open Service Control Manager&quot;);
384                  }
385                  Trace.Verbose(StringUtil.Format(&quot;Opened SCManager. Trying to create service {0}&quot;, serviceName));
386                  svcHndl = CreateService(scmHndl,
387                                          serviceName,
388                                          serviceDisplayName,
389                                          ServiceRights.AllAccess,
390                                          SERVICE_WIN32_OWN_PROCESS,
391                                          ServiceBootFlag.AutoStart,
392                                          ServiceError.Normal,
393                                          runnerServiceExecutable,
394                                          null,
395                                          IntPtr.Zero,
396                                          null,
397                                          logonAccount,
398                                          logonPassword);
399                  if (svcHndl.ToInt64() &lt;= 0)
400                  {
401                      throw new InvalidOperationException($&quot;Error: Operation {nameof(CreateService)} failed with return code {GetLastError()}&quot;);
402                  }
403                  _term.WriteLine($&quot;Service {serviceName} successfully installed&quot;);
404                  ArrayList failureActions = new ArrayList();
405                  failureActions.Add(new FailureAction(RecoverAction.Restart, 0));
406                  failureActions.Add(new FailureAction(RecoverAction.Restart, 60000));
407                  failureActions.Add(new FailureAction(RecoverAction.Restart, 60000));
408                  svcLock = LockServiceDatabase(scmHndl);
409                  if (svcLock.ToInt64() &lt;= 0)
410                  {
411                      throw new Exception(&quot;Failed to Lock Service Database for Write&quot;);
412                  }
413                  int[] actions = new int[failureActions.Count * 2];
414                  int currInd = 0;
415                  foreach (FailureAction fa in failureActions)
416                  {
417                      actions[currInd] = (int)fa.Type;
418                      actions[++currInd] = fa.Delay;
419                      currInd++;
420                  }
421                  tmpBuf = Marshal.AllocHGlobal(failureActions.Count * 8);
422                  Marshal.Copy(actions, 0, tmpBuf, failureActions.Count * 2);
423                  SERVICE_FAILURE_ACTIONS sfa = new SERVICE_FAILURE_ACTIONS();
424                  sfa.cActions = failureActions.Count;
425                  sfa.dwResetPeriod = SERVICE_NO_CHANGE;
426                  sfa.lpCommand = String.Empty;
427                  sfa.lpRebootMsg = String.Empty;
428                  sfa.lpsaActions = tmpBuf.ToInt64();
429                  bool falureActionsResult = ChangeServiceFailureActions(svcHndl, SERVICE_CONFIG_FAILURE_ACTIONS, ref sfa);
430                  if (!falureActionsResult)
431                  {
432                      int lastErrorCode = (int)GetLastError();
433                      Exception win32exception = new Win32Exception(lastErrorCode);
434                      if (lastErrorCode == ReturnCode.ERROR_ACCESS_DENIED)
435                      {
436                          throw new SecurityException(&quot;Access Denied while setting service recovery options.&quot;, win32exception);
437                      }
438                      else
439                      {
440                          throw win32exception;
441                      }
442                  }
443                  else
444                  {
445                      _term.WriteLine($&quot;Service {serviceName} successfully set recovery option&quot;);
446                  }
447                  SERVICE_DELAYED_AUTO_START_INFO sdasi = new SERVICE_DELAYED_AUTO_START_INFO();
448                  sdasi.fDelayedAutostart = true;
449                  bool delayedStartResult = ChangeServiceDelayedAutoStart(svcHndl, SERVICE_CONFIG_DELAYED_AUTO_START_INFO, ref sdasi);
450                  if (!delayedStartResult)
451                  {
452                      int lastErrorCode = (int)GetLastError();
453                      Exception win32exception = new Win32Exception(lastErrorCode);
454                      if (lastErrorCode == ReturnCode.ERROR_ACCESS_DENIED)
455                      {
456                          throw new SecurityException(&quot;Access Denied while setting service delayed auto start options.&quot;, win32exception);
457                      }
458                      else
459                      {
460                          throw win32exception;
461                      }
462                  }
463                  else
464                  {
465                      _term.WriteLine($&quot;Service {serviceName} successfully set to delayed auto start&quot;);
466                  }
467                  _term.WriteLine($&quot;Service {serviceName} successfully configured&quot;);
468              }
469              finally
470              {
471                  if (scmHndl != IntPtr.Zero)
472                  {
473                      if (svcLock != IntPtr.Zero)
474                      {
<span onclick='openModal()' class='match'>475                          UnlockServiceDatabase(svcLock);
476                          svcLock = IntPtr.Zero;
477                      }
478                      CloseServiceHandle(scmHndl);
</span>479                      scmHndl = IntPtr.Zero;
480                  }
481                  if (svcHndl != IntPtr.Zero)
482                  {
483                      CloseServiceHandle(svcHndl);
484                      svcHndl = IntPtr.Zero;
485                  }
486                  if (tmpBuf != IntPtr.Zero)
487                  {
488                      Marshal.FreeHGlobal(tmpBuf);
489                      tmpBuf = IntPtr.Zero;
490                  }
491              }
492          }
493          public void UninstallService(string serviceName)
494          {
495              Trace.Entering();
496              Trace.Verbose(StringUtil.Format(&quot;Trying to open SCManager.&quot;));
497              IntPtr scmHndl = OpenSCManager(null, null, ServiceManagerRights.Connect);
498              if (scmHndl.ToInt64() &lt;= 0)
499              {
500                  throw new Exception(&quot;Failed to Open Service Control Manager&quot;);
501              }
502              try
503              {
504                  Trace.Verbose(StringUtil.Format(&quot;Opened SCManager. query installed service {0}&quot;, serviceName));
505                  IntPtr serviceHndl = OpenService(scmHndl,
506                                                   serviceName,
507                                                   ServiceRights.StandardRightsRequired | ServiceRights.Stop | ServiceRights.QueryStatus);
508                  if (serviceHndl == IntPtr.Zero)
509                  {
510                      int lastError = Marshal.GetLastWin32Error();
511                      throw new Win32Exception(lastError);
512                  }
513                  try
514                  {
515                      Trace.Info(StringUtil.Format(&quot;Trying to delete service {0}&quot;, serviceName));
516                      int result = DeleteService(serviceHndl);
517                      if (result == 0)
518                      {
519                          result = Marshal.GetLastWin32Error();
520                          throw new Win32Exception(result, $&quot;Could not delete service &#x27;{serviceName}&#x27;&quot;);
521                      }
522                      Trace.Info(&quot;successfully removed the service&quot;);
523                  }
524                  finally
525                  {
526                      CloseServiceHandle(serviceHndl);
527                  }
528              }
529              finally
530              {
531                  CloseServiceHandle(scmHndl);
532              }
533          }
534          public void StartService(string serviceName)
535          {
536              Trace.Entering();
537              try
538              {
539                  ServiceController service = ServiceController.GetServices().FirstOrDefault(x =&gt; x.ServiceName.Equals(serviceName, StringComparison.OrdinalIgnoreCase));
540                  if (service != null)
541                  {
542                      service.Start();
543                      try
544                      {
545                          _term.WriteLine(&quot;Waiting for service to start...&quot;);
546                          service.WaitForStatus(ServiceControllerStatus.Running, TimeSpan.FromSeconds(60));
547                      }
548                      catch (System.ServiceProcess.TimeoutException)
549                      {
550                          throw new InvalidOperationException($&quot;Cannot start the service {serviceName} in a timely fashion.&quot;);
551                      }
552                      _term.WriteLine($&quot;Service {serviceName} started successfully&quot;);
553                  }
554                  else
555                  {
556                      throw new InvalidOperationException($&quot;Cannot find service {serviceName}&quot;);
557                  }
558              }
559              catch (Exception exception)
560              {
561                  Trace.Error(exception);
562                  _term.WriteError(&quot;Cannot start the service. Check the logs for more details.&quot;);
563                  throw;
564              }
565          }
566          public void StopService(string serviceName)
567          {
568              Trace.Entering();
569              try
570              {
571                  ServiceController service = ServiceController.GetServices().FirstOrDefault(x =&gt; x.ServiceName.Equals(serviceName, StringComparison.OrdinalIgnoreCase));
572                  if (service != null)
573                  {
574                      if (service.Status == ServiceControllerStatus.Running)
575                      {
576                          Trace.Info(&quot;Trying to stop the service&quot;);
577                          service.Stop();
578                          try
579                          {
580                              _term.WriteLine(&quot;Waiting for service to stop...&quot;);
581                              service.WaitForStatus(ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(35));
582                          }
583                          catch (System.ServiceProcess.TimeoutException)
584                          {
585                              throw new InvalidOperationException($&quot;Cannot stop the service {serviceName} in a timely fashion.&quot;);
586                          }
587                      }
588                      Trace.Info(&quot;Successfully stopped the service&quot;);
589                  }
590                  else
591                  {
592                      Trace.Info($&quot;Cannot find service {serviceName}&quot;);
593                  }
594              }
595              catch (Exception exception)
596              {
597                  Trace.Error(exception);
598                  _term.WriteError($&quot;Cannot stop the service {serviceName} in a timely fashion.&quot;);
599              }
600          }
601          public string GetSecurityId(string domainName, string userName)
602          {
603              var account = new NTAccount(domainName, userName);
604              var sid = account.Translate(typeof(SecurityIdentifier));
605              return sid != null ? sid.ToString() : null;
606          }
607          public void SetAutoLogonPassword(string password)
608          {
609              using (LsaPolicy lsaPolicy = new LsaPolicy(LSA_AccessPolicy.POLICY_CREATE_SECRET))
610              {
611                  lsaPolicy.SetSecretData(LsaPolicy.DefaultPassword, password);
612              }
613          }
614          public void ResetAutoLogonPassword()
615          {
616              using (LsaPolicy lsaPolicy = new LsaPolicy(LSA_AccessPolicy.POLICY_CREATE_SECRET))
617              {
618                  lsaPolicy.SetSecretData(LsaPolicy.DefaultPassword, null);
619              }
620          }
621          public bool IsRunningInElevatedMode()
622          {
623              return new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);
624          }
625          public void LoadUserProfile(string domain, string userName, string logonPassword, out IntPtr tokenHandle, out PROFILEINFO userProfile)
626          {
627              Trace.Entering();
628              tokenHandle = IntPtr.Zero;
629              ArgUtil.NotNullOrEmpty(userName, nameof(userName));
630              if (LogonUser(userName, domain, logonPassword, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, out tokenHandle) == 0)
631              {
632                  throw new Win32Exception(Marshal.GetLastWin32Error());
633              }
634              userProfile = new PROFILEINFO();
635              userProfile.dwSize = Marshal.SizeOf(typeof(PROFILEINFO));
636              userProfile.lpUserName = userName;
637              if (!LoadUserProfile(tokenHandle, ref userProfile))
638              {
639                  throw new Win32Exception(Marshal.GetLastWin32Error());
640              }
641              Trace.Info($&quot;Successfully loaded the profile for {domain}\\{userName}.&quot;);
642          }
643          public void UnloadUserProfile(IntPtr tokenHandle, PROFILEINFO userProfile)
644          {
645              Trace.Entering();
646              if (tokenHandle == IntPtr.Zero)
647              {
648                  Trace.Verbose(&quot;The handle to unload user profile is not set. Returning.&quot;);
649              }
650              if (!UnloadUserProfile(tokenHandle, userProfile.hProfile))
651              {
652                  throw new Win32Exception(Marshal.GetLastWin32Error());
653              }
654              Trace.Info($&quot;Successfully unloaded the profile for {userProfile.lpUserName}.&quot;);
655          }
656          public void GrantDirectoryPermissionForAccount(string accountName, IList&lt;string&gt; folders)
657          {
658              Trace.Entering();
659              string groupName = GetUniqueRunnerGroupName();
660              Trace.Info(StringUtil.Format(&quot;Calculated unique group name {0}&quot;, groupName));
661              if (!LocalGroupExists(groupName))
662              {
663                  Trace.Info(StringUtil.Format(&quot;Trying to create group {0}&quot;, groupName));
664                  CreateLocalGroup(groupName);
665              }
666              Trace.Info(StringUtil.Format(&quot;Trying to add userName {0} to the group {1}&quot;, accountName, groupName));
667              AddMemberToLocalGroup(accountName, groupName);
668              foreach(var folder in folders)
669              {
670                  if (Directory.Exists(folder))
671                  {
672                      Trace.Info(StringUtil.Format(&quot;Set full access control to group for the folder {0}&quot;, folder));
673                      GrantFullControlToGroup(folder, groupName);
674                  }
675              }
676          }
677          public void RevokeDirectoryPermissionForAccount(IList&lt;string&gt; folders)
678          {
679              Trace.Entering();
680              string groupName = GetUniqueRunnerGroupName();
681              Trace.Info(StringUtil.Format(&quot;Calculated unique group name {0}&quot;, groupName));
682              foreach(var folder in folders)
683              {
684                  if (Directory.Exists(folder))
685                  {
686                      Trace.Info(StringUtil.Format($&quot;Remove the group {groupName} for the folder {folder}.&quot;));
687                      try
688                      {
689                          RemoveGroupFromFolderSecuritySetting(folder, groupName);
690                      }
691                      catch(Exception ex)
692                      {
693                          Trace.Error(ex);
694                      }
695                  }
696              }
697              Trace.Info(StringUtil.Format($&quot;Delete the group {groupName}.&quot;));
698              DeleteLocalGroup(groupName);
699          }
700          private bool IsValidCredentialInternal(string domain, string userName, string logonPassword, UInt32 logonType)
701          {
702              Trace.Entering();
703              IntPtr tokenHandle = IntPtr.Zero;
704              ArgUtil.NotNullOrEmpty(userName, nameof(userName));
705              Trace.Info($&quot;Verify credential for account {userName}.&quot;);
706              int result = LogonUser(userName, domain, logonPassword, logonType, LOGON32_PROVIDER_DEFAULT, out tokenHandle);
707              if (tokenHandle.ToInt32() != 0)
708              {
709                  if (!CloseHandle(tokenHandle))
710                  {
711                      Trace.Error(&quot;Failed during CloseHandle on token from LogonUser&quot;);
712                  }
713              }
714              if (result != 0)
715              {
716                  Trace.Info($&quot;Credential for account &#x27;{userName}&#x27; is valid.&quot;);
717                  return true;
718              }
719              else
720              {
721                  Trace.Info($&quot;Credential for account &#x27;{userName}&#x27; is invalid.&quot;);
722                  return false;
723              }
724          }
725          private byte[] GetSidBinaryFromWindows(string domain, string user)
726          {
727              try
728              {
729                  SecurityIdentifier sid = (SecurityIdentifier)new NTAccount(StringUtil.Format(&quot;{0}\\{1}&quot;, domain, user).TrimStart(&#x27;\\&#x27;)).Translate(typeof(SecurityIdentifier));
730                  byte[] binaryForm = new byte[sid.BinaryLength];
731                  sid.GetBinaryForm(binaryForm, 0);
732                  return binaryForm;
733              }
734              catch (Exception exception)
735              {
736                  Trace.Error(exception);
737                  return null;
738              }
739          }
740          internal class LsaPolicy : IDisposable
741          {
742              public IntPtr Handle { get; set; }
743              public LsaPolicy()
744                  : this(LSA_AccessPolicy.POLICY_ALL_ACCESS)
745              {
746              }
747              public LsaPolicy(LSA_AccessPolicy access)
748              {
749                  LSA_UNICODE_STRING system = new LSA_UNICODE_STRING();
750                  LSA_OBJECT_ATTRIBUTES attrib = new LSA_OBJECT_ATTRIBUTES()
751                  {
752                      Length = 0,
753                      RootDirectory = IntPtr.Zero,
754                      Attributes = 0,
755                      SecurityDescriptor = IntPtr.Zero,
756                      SecurityQualityOfService = IntPtr.Zero,
757                  };
758                  IntPtr handle = IntPtr.Zero;
759                  uint hr = LsaOpenPolicy(ref system, ref attrib, (uint)access, out handle);
760                  if (hr != 0 || handle == IntPtr.Zero)
761                  {
762                      throw new Exception($&quot;Error: Operation {nameof(LsaOpenPolicy)} failed with return code {hr}&quot;);
763                  }
764                  Handle = handle;
765              }
766              public void SetSecretData(string key, string value)
767              {
768                  LSA_UNICODE_STRING secretData = new LSA_UNICODE_STRING();
769                  LSA_UNICODE_STRING secretName = new LSA_UNICODE_STRING();
770                  secretName.Buffer = Marshal.StringToHGlobalUni(key);
771                  var charSize = sizeof(char);
772                  secretName.Length = (UInt16)(key.Length * charSize);
773                  secretName.MaximumLength = (UInt16)((key.Length + 1) * charSize);
774                  if (value != null &amp;&amp; value.Length &gt; 0)
775                  {
776                      secretData.Buffer = Marshal.StringToHGlobalUni(value);
777                      secretData.Length = (UInt16)(value.Length * charSize);
778                      secretData.MaximumLength = (UInt16)((value.Length + 1) * charSize);
779                  }
780                  else
781                  {
782                      secretData.Buffer = IntPtr.Zero;
783                      secretData.Length = 0;
784                      secretData.MaximumLength = 0;
785                  }
786                  uint result = LsaStorePrivateData(Handle, ref secretName, ref secretData);
787                  uint winErrorCode = LsaNtStatusToWinError(result);
788                  if (winErrorCode != 0)
789                  {
790                      throw new Exception($&quot;Error: Operation {nameof(LsaNtStatusToWinError)} failed with return code {winErrorCode}&quot;);
791                  }
792              }
793              void IDisposable.Dispose()
794              {
795                  LsaClose(Handle);
796                  GC.SuppressFinalize(this);
797              }
798              internal static string DefaultPassword = &quot;DefaultPassword&quot;;
799          }
800          internal enum LSA_AccessPolicy : long
801          {
802              POLICY_VIEW_LOCAL_INFORMATION = 0x00000001L,
803              POLICY_VIEW_AUDIT_INFORMATION = 0x00000002L,
804              POLICY_GET_PRIVATE_INFORMATION = 0x00000004L,
805              POLICY_TRUST_ADMIN = 0x00000008L,
806              POLICY_CREATE_ACCOUNT = 0x00000010L,
807              POLICY_CREATE_SECRET = 0x00000020L,
808              POLICY_CREATE_PRIVILEGE = 0x00000040L,
809              POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080L,
810              POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100L,
811              POLICY_AUDIT_LOG_ADMIN = 0x00000200L,
812              POLICY_SERVER_ADMIN = 0x00000400L,
813              POLICY_LOOKUP_NAMES = 0x00000800L,
814              POLICY_NOTIFICATION = 0x00001000L,
815              POLICY_ALL_ACCESS = 0x00001FFFL
816          }
817          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, PreserveSig = true)]
818          public static extern uint LsaStorePrivateData(
819              IntPtr policyHandle,
820              ref LSA_UNICODE_STRING KeyName,
821              ref LSA_UNICODE_STRING PrivateData
822          );
823          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, PreserveSig = true)]
824          public static extern uint LsaNtStatusToWinError(
825              uint status
826          );
827          private static UInt32 LOGON32_LOGON_INTERACTIVE = 2;
828          private const UInt32 LOGON32_LOGON_NETWORK = 3;
829          private static readonly string s_logonAsServiceName = &quot;SeServiceLogonRight&quot;;
830          private const UInt32 LOGON32_PROVIDER_DEFAULT = 0;
831          private const int SERVICE_WIN32_OWN_PROCESS = 0x00000010;
832          private const int SERVICE_NO_CHANGE = -1;
833          private const int SERVICE_CONFIG_FAILURE_ACTIONS = 0x2;
834          private const int SERVICE_CONFIG_DELAYED_AUTO_START_INFO = 0x3;
835          private const int UnicodeCharSize = 2;
836          private static LSA_UNICODE_STRING[] LogonAsServiceRights
837          {
838              get
839              {
840                  return new[]
841                             {
842                                 new LSA_UNICODE_STRING()
843                                     {
844                                         Buffer = Marshal.StringToHGlobalUni(s_logonAsServiceName),
845                                         Length = (UInt16)(s_logonAsServiceName.Length * UnicodeCharSize),
846                                         MaximumLength = (UInt16) ((s_logonAsServiceName.Length + 1) * UnicodeCharSize)
847                                     }
848                             };
849              }
850          }
851          public struct ReturnCode
852          {
853              public const int S_OK = 0;
854              public const int ERROR_ACCESS_DENIED = 5;
855              public const int ERROR_INVALID_PARAMETER = 87;
856              public const int ERROR_MEMBER_NOT_IN_ALIAS = 1377; 
857              public const int ERROR_MEMBER_IN_ALIAS = 1378; 
858              public const int ERROR_ALIAS_EXISTS = 1379;  
859              public const int ERROR_NO_SUCH_ALIAS = 1376;
860              public const int ERROR_NO_SUCH_MEMBER = 1387;
861              public const int ERROR_INVALID_MEMBER = 1388;
862              public const int NERR_GroupNotFound = 2220;
863              public const int NERR_GroupExists = 2223;
864              public const int NERR_UserInGroup = 2236;
865              public const uint STATUS_ACCESS_DENIED = 0XC0000022; 
866          }
867          [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
868          public struct LocalGroupInfo
869          {
870              [MarshalAs(UnmanagedType.LPWStr)]
871              public string Name;
872              [MarshalAs(UnmanagedType.LPWStr)]
873              public string Comment;
874          }
875          [StructLayout(LayoutKind.Sequential)]
876          public struct LSA_UNICODE_STRING
877          {
878              public UInt16 Length;
879              public UInt16 MaximumLength;
880              public IntPtr Buffer;
881          }
882          [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
883          public struct LocalGroupMemberInfo
884          {
885              [MarshalAs(UnmanagedType.LPWStr)]
886              public string FullName;
887          }
888          [StructLayout(LayoutKind.Sequential)]
889          public struct LSA_OBJECT_ATTRIBUTES
890          {
891              public UInt32 Length;
892              public IntPtr RootDirectory;
893              public LSA_UNICODE_STRING ObjectName;
894              public UInt32 Attributes;
895              public IntPtr SecurityDescriptor;
896              public IntPtr SecurityQualityOfService;
897          }
898          [StructLayout(LayoutKind.Sequential)]
899          public struct SERVICE_FAILURE_ACTIONS
900          {
901              public int dwResetPeriod;
902              public string lpRebootMsg;
903              public string lpCommand;
904              public int cActions;
905              public long lpsaActions;
906          }
907          [StructLayout(LayoutKind.Sequential)]
908          public struct SERVICE_DELAYED_AUTO_START_INFO
909          {
910              public bool fDelayedAutostart;
911          }
912          private class FailureAction
913          {
914              public RecoverAction Type { get; set; }
915              public int Delay { get; set; }
916              public FailureAction(RecoverAction actionType, int actionDelay)
917              {
918                  Type = actionType;
919                  Delay = actionDelay;
920              }
921          }
922          [Flags]
923          public enum ServiceManagerRights
924          {
925              Connect = 0x0001,
926              CreateService = 0x0002,
927              EnumerateService = 0x0004,
928              Lock = 0x0008,
929              QueryLockStatus = 0x0010,
930              ModifyBootConfig = 0x0020,
931              StandardRightsRequired = 0xF0000,
932              AllAccess =
933                  (StandardRightsRequired | Connect | CreateService | EnumerateService | Lock | QueryLockStatus
934                   | ModifyBootConfig)
935          }
936          [Flags]
937          public enum ServiceRights
938          {
939              QueryConfig = 0x1,
940              ChangeConfig = 0x2,
941              QueryStatus = 0x4,
942              EnumerateDependants = 0x8,
943              Start = 0x10,
944              Stop = 0x20,
945              PauseContinue = 0x40,
946              Interrogate = 0x80,
947              UserDefinedControl = 0x100,
948              Delete = 0x00010000,
949              StandardRightsRequired = 0xF0000,
950              AllAccess =
951                  (StandardRightsRequired | QueryConfig | ChangeConfig | QueryStatus | EnumerateDependants | Start | Stop
952                   | PauseContinue | Interrogate | UserDefinedControl)
953          }
954          public enum ServiceError
955          {
956              Ignore = 0x00000000,
957              Normal = 0x00000001,
958              Severe = 0x00000002,
959              Critical = 0x00000003
960          }
961          public enum ServiceBootFlag
962          {
963              Start = 0x00000000,
964              SystemStart = 0x00000001,
965              AutoStart = 0x00000002,
966              DemandStart = 0x00000003,
967              Disabled = 0x00000004
968          }
969          private enum RecoverAction
970          {
971              None = 0,
972              Restart = 1,
973              Reboot = 2,
974              RunCommand = 3
975          }
976          [DllImport(&quot;Netapi32.dll&quot;)]
977          private extern static int NetLocalGroupGetInfo(string servername,
978                                                   string groupname,
979                                                   int level,
980                                                   out IntPtr bufptr);
981          [DllImport(&quot;Netapi32.dll&quot;)]
982          private extern static int NetApiBufferFree(IntPtr Buffer);
983          [DllImport(&quot;Netapi32.dll&quot;)]
984          private extern static int NetLocalGroupAdd([MarshalAs(UnmanagedType.LPWStr)] string servername,
985                                                     int level,
986                                                     ref LocalGroupInfo buf,
987                                                     int parm_err);
988          [DllImport(&quot;Netapi32.dll&quot;)]
989          private extern static int NetLocalGroupAddMembers([MarshalAs(UnmanagedType.LPWStr)] string serverName,
990                                                            [MarshalAs(UnmanagedType.LPWStr)] string groupName,
991                                                            int level,
992                                                            ref LocalGroupMemberInfo buf,
993                                                            int totalEntries);
994          [DllImport(&quot;Netapi32.dll&quot;)]
995          public extern static int NetLocalGroupDel([MarshalAs(UnmanagedType.LPWStr)] string servername, [MarshalAs(UnmanagedType.LPWStr)] string groupname);
996          [DllImport(&quot;advapi32.dll&quot;)]
997          private static extern Int32 LsaClose(IntPtr ObjectHandle);
998          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, PreserveSig = true)]
999          private static extern uint LsaOpenPolicy(
1000              ref LSA_UNICODE_STRING SystemName,
1001              ref LSA_OBJECT_ATTRIBUTES ObjectAttributes,
1002              uint DesiredAccess,
1003              out IntPtr PolicyHandle);
1004          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, PreserveSig = true)]
1005          private static extern uint LsaAddAccountRights(
1006             IntPtr PolicyHandle,
1007             byte[] AccountSid,
1008             LSA_UNICODE_STRING[] UserRights,
1009             uint CountOfRights);
1010          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, PreserveSig = true)]
1011          public static extern uint LsaEnumerateAccountRights(
1012            IntPtr PolicyHandle,
1013            byte[] AccountSid,
1014            out IntPtr UserRights,
1015            out uint CountOfRights);
1016          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, PreserveSig = true)]
1017          public static extern uint LsaFreeMemory(IntPtr pBuffer);
1018          [DllImport(&quot;advapi32.dll&quot;, CharSet = CharSet.Unicode, SetLastError = true)]
1019          public static extern int LogonUser(string userName, string domain, string password, uint logonType, uint logonProvider, out IntPtr tokenHandle);
1020          [DllImport(&quot;userenv.dll&quot;, SetLastError = true, CharSet = CharSet.Unicode)]
1021          public static extern Boolean LoadUserProfile(IntPtr hToken, ref PROFILEINFO lpProfileInfo);
1022          [DllImport(&quot;userenv.dll&quot;, SetLastError = true, CharSet = CharSet.Unicode)]
1023          public static extern Boolean UnloadUserProfile(IntPtr hToken, IntPtr hProfile);
1024          [DllImport(&quot;kernel32&quot;, SetLastError = true)]
1025          public static extern bool CloseHandle(IntPtr handle);
1026          [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;CreateServiceA&quot;)]
1027          private static extern IntPtr CreateService(
1028              IntPtr hSCManager,
1029              string lpServiceName,
1030              string lpDisplayName,
1031              ServiceRights dwDesiredAccess,
1032              int dwServiceType,
1033              ServiceBootFlag dwStartType,
1034              ServiceError dwErrorControl,
1035              string lpBinaryPathName,
1036              string lpLoadOrderGroup,
1037              IntPtr lpdwTagId,
1038              string lpDependencies,
1039              string lp,
1040              string lpPassword);
1041          [DllImport(&quot;advapi32.dll&quot;)]
1042          public static extern IntPtr OpenSCManager(string lpMachineName, string lpDatabaseName, ServiceManagerRights dwDesiredAccess);
1043          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true)]
1044          public static extern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, ServiceRights dwDesiredAccess);
1045          [DllImport(&quot;advapi32.dll&quot;, SetLastError = true)]
1046          public static extern int DeleteService(IntPtr hService);
1047          [DllImport(&quot;advapi32.dll&quot;)]
1048          public static extern int CloseServiceHandle(IntPtr hSCObject);
1049          [DllImport(&quot;advapi32.dll&quot;)]
1050          public static extern IntPtr LockServiceDatabase(IntPtr hSCManager);
1051          [DllImport(&quot;advapi32.dll&quot;)]
1052          public static extern bool UnlockServiceDatabase(IntPtr hSCManager);
1053          [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;ChangeServiceConfig2&quot;)]
1054          public static extern bool ChangeServiceFailureActions(IntPtr hService, int dwInfoLevel, ref SERVICE_FAILURE_ACTIONS lpInfo);
1055          [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;ChangeServiceConfig2&quot;)]
1056          public static extern bool ChangeServiceDelayedAutoStart(IntPtr hService, int dwInfoLevel, ref SERVICE_DELAYED_AUTO_START_INFO lpInfo);
1057          [DllImport(&quot;kernel32.dll&quot;)]
1058          static extern uint GetLastError();
1059      }
1060      [StructLayout(LayoutKind.Sequential)]
1061      public struct PROFILEINFO
1062      {
1063          public int dwSize;
1064          public int dwFlags;
1065          [MarshalAs(UnmanagedType.LPTStr)]
1066          public String lpUserName;
1067          [MarshalAs(UnmanagedType.LPTStr)]
1068          public String lpProfilePath;
1069          [MarshalAs(UnmanagedType.LPTStr)]
1070          public String lpDefaultPath;
1071          [MarshalAs(UnmanagedType.LPTStr)]
1072          public String lpServerName;
1073          [MarshalAs(UnmanagedType.LPTStr)]
1074          public String lpPolicyPath;
1075          public IntPtr hProfile;
1076      }
1077  }
1078  #pragma warning restore CA1416
1079  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-QuaternionPlugin.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-NativeWindowsServiceHelper.cs</div>
                </div>
                <div class="column column_space"><pre><code>86                  SetChangeValue(tweener);
87                  changeValue = tweener.changeValue;
88              }
89              Vector3 endValue = startValue;
</pre></code></div>
                <div class="column column_space"><pre><code>475                          UnlockServiceDatabase(svcLock);
476                          svcLock = IntPtr.Zero;
477                      }
478                      CloseServiceHandle(scmHndl);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    