
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 90, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-GitSourceProvider_1.cs</h3>
            <pre><code>1  using Pipelines = GitHub.DistributedTask.Pipelines;
2  using System;
3  using System.Collections.Generic;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using System.IO;
7  using System.Text;
8  using GitHub.Runner.Sdk;
9  using System.Linq;
10  using GitHub.DistributedTask.WebApi;
11  using GitHub.Services.WebApi;
12  namespace GitHub.Runner.Plugins.Repository.v1_1
13  {
14      public sealed class GitHubSourceProvider
15      {
16          private const string _refsPrefix = "refs/heads/";
17          private const string _remoteRefsPrefix = "refs/remotes/origin/";
18          private const string _pullRefsPrefix = "refs/pull/";
19          private const string _remotePullRefsPrefix = "refs/remotes/pull/";
20          private const string _tagRefsPrefix = "refs/tags/";
21          private Version _minGitVersionSupportAuthHeader = new(2, 9);
22  #if OS_WINDOWS
23          private Version _minGitVersionSupportSSLBackendOverride = new Version(2, 14, 2);
24  #endif
25          private Version _minGitLfsVersionSupportAuthHeader = new(2, 1);
26          public static string ProblemMatcher => @"    
27  {
28      ""problemMatcher"": [
29          {
30              ""owner"": ""checkout-git"",
31              ""pattern"": [
32                  {
33                      ""regexp"": ""^(fatal|error): (.*)$"",
34                      ""message"": 2
35                  }
36              ]
37          }
38      ]
39  }";
40          public async Task GetSourceAsync(
41              RunnerActionPluginExecutionContext executionContext,
42              string repositoryPath,
43              string repoFullName,
44              string sourceBranch,
45              string sourceVersion,
46              bool clean,
47              string submoduleInput,
48              int fetchDepth,
49              bool gitLfsSupport,
50              string accessToken,
51              CancellationToken cancellationToken)
52          {
53              ArgUtil.NotNull(executionContext, nameof(executionContext));
54              Dictionary<string, string> configModifications = new();
55              executionContext.Output($"Syncing repository: {repoFullName}");
56              Uri repositoryUrl = new($"https:&bsol;&bsol;github.com/{repoFullName}");
57              if (!repositoryUrl.IsAbsoluteUri)
58              {
59                  throw new InvalidOperationException("Repository url need to be an absolute uri.");
60              }
61              string targetPath = repositoryPath;
62              bool checkoutSubmodules = false;
63              bool checkoutNestedSubmodules = false;
64              if (!string.IsNullOrEmpty(submoduleInput))
65              {
66                  if (string.Equals(submoduleInput, Pipelines.PipelineConstants.CheckoutTaskInputs.SubmodulesOptions.Recursive, StringComparison.OrdinalIgnoreCase))
67                  {
68                      checkoutSubmodules = true;
69                      checkoutNestedSubmodules = true;
70                  }
71                  else
72                  {
73                      checkoutSubmodules = StringUtil.ConvertToBoolean(submoduleInput);
74                  }
75              }
76              executionContext.Debug($"repository url={repositoryUrl}");
77              executionContext.Debug($"targetPath={targetPath}");
78              executionContext.Debug($"sourceBranch={sourceBranch}");
79              executionContext.Debug($"sourceVersion={sourceVersion}");
80              executionContext.Debug($"clean={clean}");
81              executionContext.Debug($"checkoutSubmodules={checkoutSubmodules}");
82              executionContext.Debug($"checkoutNestedSubmodules={checkoutNestedSubmodules}");
83              executionContext.Debug($"fetchDepth={fetchDepth}");
84              executionContext.Debug($"gitLfsSupport={gitLfsSupport}");
85              Dictionary<string, string> gitEnv = new(StringComparer.OrdinalIgnoreCase);
86              gitEnv["GIT_TERMINAL_PROMPT"] = "0";
87              gitEnv["GCM_INTERACTIVE"] = "Never";
88              if (!gitLfsSupport)
89              {
90                  gitEnv["GIT_LFS_SKIP_SMUDGE"] = "1";
91              }
92              foreach (var variable in executionContext.Variables)
93              {
94                  string formattedKey = (variable.Key ?? string.Empty).Replace('.', '_').Replace(' ', '_').ToUpperInvariant();
95                  gitEnv[formattedKey] = variable.Value?.Value ?? string.Empty;
96              }
97              GitCliManager gitCommandManager = new(gitEnv);
98              await gitCommandManager.LoadGitExecutionInfo(executionContext);
99              RequirementCheck(executionContext, gitCommandManager, gitLfsSupport);
100              var systemConnection = executionContext.Endpoints.Single(x => string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
101              if (!await IsRepositoryOriginUrlMatch(executionContext, gitCommandManager, targetPath, repositoryUrl))
102              {
103                  IOUtil.DeleteDirectory(targetPath, cancellationToken);
104              }
105              else
106              {
107                  string lockFile = Path.Combine(targetPath, ".git\\index.lock");
108                  if (File.Exists(lockFile))
109                  {
110                      try
111                      {
112                          File.Delete(lockFile);
113                      }
114                      catch (Exception ex)
115                      {
116                          executionContext.Debug($"Unable to delete the index.lock file: {lockFile}");
117                          executionContext.Debug(ex.ToString());
118                      }
119                  }
120                  string shallowLockFile = Path.Combine(targetPath, ".git\\shallow.lock");
121                  if (File.Exists(shallowLockFile))
122                  {
123                      try
124                      {
125                          File.Delete(shallowLockFile);
126                      }
127                      catch (Exception ex)
128                      {
129                          executionContext.Debug($"Unable to delete the shallow.lock file: {shallowLockFile}");
130                          executionContext.Debug(ex.ToString());
131                      }
132                  }
133                  if (clean)
134                  {
135                      Boolean softCleanSucceed = true;
136                      int exitCode_clean = await gitCommandManager.GitClean(executionContext, targetPath);
137                      if (exitCode_clean != 0)
138                      {
139                          executionContext.Debug($"'git clean -ffdx' failed with exit code {exitCode_clean}, this normally caused by:\n    1) Path too long\n    2) Permission issue\n    3) File in use\nFor futher investigation, manually run 'git clean -ffdx' on repo root: {targetPath} after each build.");
140                          softCleanSucceed = false;
141                      }
142                      if (softCleanSucceed)
143                      {
144                          int exitCode_reset = await gitCommandManager.GitReset(executionContext, targetPath);
145                          if (exitCode_reset != 0)
146                          {
147                              executionContext.Debug($"'git reset --hard HEAD' failed with exit code {exitCode_reset}\nFor futher investigation, manually run 'git reset --hard HEAD' on repo root: {targetPath} after each build.");
148                              softCleanSucceed = false;
149                          }
150                      }
151                      if (checkoutSubmodules)
152                      {
153                          if (softCleanSucceed)
154                          {
155                              int exitCode_submoduleclean = await gitCommandManager.GitSubmoduleClean(executionContext, targetPath);
156                              if (exitCode_submoduleclean != 0)
157                              {
158                                  executionContext.Debug($"'git submodule foreach git clean -ffdx' failed with exit code {exitCode_submoduleclean}\nFor futher investigation, manually run 'git submodule foreach git clean -ffdx' on repo root: {targetPath} after each build.");
159                                  softCleanSucceed = false;
160                              }
161                          }
162                          if (softCleanSucceed)
163                          {
164                              int exitCode_submodulereset = await gitCommandManager.GitSubmoduleReset(executionContext, targetPath);
165                              if (exitCode_submodulereset != 0)
166                              {
167                                  executionContext.Debug($"'git submodule foreach git reset --hard HEAD' failed with exit code {exitCode_submodulereset}\nFor futher investigation, manually run 'git submodule foreach git reset --hard HEAD' on repo root: {targetPath} after each build.");
168                                  softCleanSucceed = false;
169                              }
170                          }
171                      }
172                      if (!softCleanSucceed)
173                      {
174                          executionContext.Warning("Unable to run \"git clean -ffdx\" and \"git reset --hard HEAD\" successfully, delete source folder instead.");
175                          IOUtil.DeleteDirectory(targetPath, cancellationToken);
176                      }
177                  }
178              }
179              if (!Directory.Exists(targetPath))
180              {
181                  Directory.CreateDirectory(targetPath);
182              }
183              if (!Directory.Exists(Path.Combine(targetPath, ".git")))
184              {
185                  int exitCode_init = await gitCommandManager.GitInit(executionContext, targetPath);
186                  if (exitCode_init != 0)
187                  {
188                      throw new InvalidOperationException($"Unable to use git.exe init repository under {targetPath}, 'git init' failed with exit code: {exitCode_init}");
189                  }
190                  int exitCode_addremote = await gitCommandManager.GitRemoteAdd(executionContext, targetPath, "origin", repositoryUrl.AbsoluteUri);
191                  if (exitCode_addremote != 0)
192                  {
193                      throw new InvalidOperationException($"Unable to use git.exe add remote 'origin', 'git remote add' failed with exit code: {exitCode_addremote}");
194                  }
195              }
196              cancellationToken.ThrowIfCancellationRequested();
197              int exitCode_disableGC = await gitCommandManager.GitDisableAutoGC(executionContext, targetPath);
198              if (exitCode_disableGC != 0)
199              {
200                  executionContext.Warning("Unable turn off git auto garbage collection, git fetch operation may trigger auto garbage collection which will affect the performance of fetching.");
201              }
202              if (await gitCommandManager.GitConfigExist(executionContext, targetPath, $"http.{repositoryUrl.AbsoluteUri}.extraheader"))
203              {
204                  executionContext.Debug("Remove any extraheader setting from git config.");
205                  await RemoveGitConfig(executionContext, gitCommandManager, targetPath, $"http.{repositoryUrl.AbsoluteUri}.extraheader", string.Empty);
206              }
207              List<string> additionalFetchArgs = new();
208              List<string> additionalLfsFetchArgs = new();
209              string configKey = $"http.https:&bsol;&bsol;github.com/.extraheader";
210              string configValue = $"\"AUTHORIZATION: {GenerateBasicAuthHeader(executionContext, accessToken)}\"";
211              configModifications[configKey] = configValue.Trim('\"');
212              int exitCode_config = await gitCommandManager.GitConfig(executionContext, targetPath, configKey, configValue);
213              if (exitCode_config != 0)
214              {
215                  throw new InvalidOperationException($"Git config failed with exit code: {exitCode_config}");
216              }
217              if (gitLfsSupport)
218              {
219                  executionContext.Debug("Setup the local Git hooks for Git LFS.");
220                  int exitCode_lfsInstall = await gitCommandManager.GitLFSInstall(executionContext, targetPath);
221                  if (exitCode_lfsInstall != 0)
222                  {
223                      throw new InvalidOperationException($"Git-lfs installation failed with exit code: {exitCode_lfsInstall}");
224                  }
225              }
226              List<string> additionalFetchSpecs = new();
227              additionalFetchSpecs.Add("+refs/heads&bsol;*:refs/remotes/origin&bsol;*");
228              if (IsPullRequest(sourceBranch))
229              {
230                  additionalFetchSpecs.Add($"+{sourceBranch}:{GetRemoteRefName(sourceBranch)}");
231              }
232              int exitCode_fetch = await gitCommandManager.GitFetch(executionContext, targetPath, "origin", fetchDepth, additionalFetchSpecs, string.Join(" ", additionalFetchArgs), cancellationToken);
233              if (exitCode_fetch != 0)
234              {
235                  throw new InvalidOperationException($"Git fetch failed with exit code: {exitCode_fetch}");
236              }
237              cancellationToken.ThrowIfCancellationRequested();
238              string sourcesToBuild;
239              if (IsPullRequest(sourceBranch) || string.IsNullOrEmpty(sourceVersion))
240              {
241                  sourcesToBuild = GetRemoteRefName(sourceBranch);
242              }
243              else
244              {
245                  sourcesToBuild = sourceVersion;
246              }
247              if (gitLfsSupport)
248              {
249                  int exitCode_lfsFetch = await gitCommandManager.GitLFSFetch(executionContext, targetPath, "origin", sourcesToBuild, string.Join(" ", additionalLfsFetchArgs), cancellationToken);
250                  if (exitCode_lfsFetch != 0)
251                  {
252                      if (fetchDepth > 0)
253                      {
254                          executionContext.Warning($"Git lfs fetch failed on shallow repository, this might because of git fetch with depth '{fetchDepth}' doesn't include the lfs fetch commit '{sourcesToBuild}'.");
255                      }
256                      int exitCode_lfsLogs = await gitCommandManager.GitLFSLogs(executionContext, targetPath);
257                      throw new InvalidOperationException($"Git lfs fetch failed with exit code: {exitCode_lfsFetch}. Git lfs logs returned with exit code: {exitCode_lfsLogs}.");
258                  }
259              }
260              int exitCode_checkout = await gitCommandManager.GitCheckout(executionContext, targetPath, sourcesToBuild, cancellationToken);
261              if (exitCode_checkout != 0)
262              {
263                  if (fetchDepth > 0)
264                  {
265                      executionContext.Warning($"Git checkout failed on shallow repository, this might because of git fetch with depth '{fetchDepth}' doesn't include the checkout commit '{sourcesToBuild}'.");
266                  }
267                  throw new InvalidOperationException($"Git checkout failed with exit code: {exitCode_checkout}");
268              }
269              if (checkoutSubmodules)
270              {
271                  cancellationToken.ThrowIfCancellationRequested();
272                  int exitCode_submoduleSync = await gitCommandManager.GitSubmoduleSync(executionContext, targetPath, checkoutNestedSubmodules, cancellationToken);
273                  if (exitCode_submoduleSync != 0)
274                  {
275                      throw new InvalidOperationException($"Git submodule sync failed with exit code: {exitCode_submoduleSync}");
276                  }
277                  List<string> additionalSubmoduleUpdateArgs = new();
278                  int exitCode_submoduleUpdate = await gitCommandManager.GitSubmoduleUpdate(executionContext, targetPath, fetchDepth, string.Join(" ", additionalSubmoduleUpdateArgs), checkoutNestedSubmodules, cancellationToken);
279                  if (exitCode_submoduleUpdate != 0)
280                  {
281                      throw new InvalidOperationException($"Git submodule update failed with exit code: {exitCode_submoduleUpdate}");
282                  }
283              }
284              executionContext.SetIntraActionState("repositoryPath", targetPath);
285              executionContext.SetIntraActionState("modifiedgitconfig", JsonUtility.ToString(configModifications.Keys));
286              foreach (var config in configModifications)
287              {
288                  executionContext.SetIntraActionState(config.Key, config.Value);
289              }
290          }
291          public async Task CleanupAsync(RunnerActionPluginExecutionContext executionContext)
292          {
293              ArgUtil.NotNull(executionContext, nameof(executionContext));
294              var repositoryPath = Environment.GetEnvironmentVariable("STATE_repositoryPath");
295              ArgUtil.NotNullOrEmpty(repositoryPath, nameof(repositoryPath));
296              executionContext.Output($"Cleanup cached git credential from {repositoryPath}.");
297              GitCliManager gitCommandManager = new();
298              await gitCommandManager.LoadGitExecutionInfo(executionContext);
299              executionContext.Debug("Remove any extraheader setting from git config.");
300              var configKeys = JsonUtility.FromString<List<string>>(Environment.GetEnvironmentVariable("STATE_modifiedgitconfig"));
301              if (configKeys?.Count > 0)
302              {
303                  foreach (var config in configKeys)
304                  {
305                      var configValue = Environment.GetEnvironmentVariable($"STATE_{config}");
306                      if (!string.IsNullOrEmpty(configValue))
307                      {
308                          await RemoveGitConfig(executionContext, gitCommandManager, repositoryPath, config, configValue);
309                      }
310                  }
311              }
312          }
313          private void RequirementCheck(RunnerActionPluginExecutionContext executionContext, GitCliManager gitCommandManager, bool checkGitLfs)
314          {
315              gitCommandManager.EnsureGitVersion(_minGitVersionSupportAuthHeader, throwOnNotMatch: true);
316  #if OS_WINDOWS
317              bool schannelSslBackend = StringUtil.ConvertToBoolean(executionContext.GetRunnerContext("gituseschannel"));
318              if (schannelSslBackend)
319              {
320                  gitCommandManager.EnsureGitVersion(_minGitVersionSupportSSLBackendOverride, throwOnNotMatch: true);
321              }
322  #endif
323              if (checkGitLfs)
324              {
325                  gitCommandManager.EnsureGitLFSVersion(_minGitLfsVersionSupportAuthHeader, throwOnNotMatch: true);
326              }
327          }
328          private string GenerateBasicAuthHeader(RunnerActionPluginExecutionContext executionContext, string accessToken)
329          {
330              string authHeader = $"x-access-token:{accessToken}";
331              string base64encodedAuthHeader = Convert.ToBase64String(Encoding.UTF8.GetBytes(authHeader));
332              executionContext.AddMask(base64encodedAuthHeader);
333              return $"basic {base64encodedAuthHeader}";
334          }
335          private async Task<bool> IsRepositoryOriginUrlMatch(RunnerActionPluginExecutionContext context, GitCliManager gitCommandManager, string repositoryPath, Uri expectedRepositoryOriginUrl)
336          {
337              context.Debug($"Checking if the repo on {repositoryPath} matches the expected repository origin URL. expected Url: {expectedRepositoryOriginUrl.AbsoluteUri}");
338              if (!Directory.Exists(Path.Combine(repositoryPath, ".git")))
339              {
340                  context.Debug($"Repository is not found since '.git' directory does not exist under. {repositoryPath}");
341                  return false;
342              }
343              Uri remoteUrl;
344              remoteUrl = await gitCommandManager.GitGetFetchUrl(context, repositoryPath);
345              if (remoteUrl == null)
346              {
347                  context.Debug("Repository remote origin fetch url is empty.");
348                  return false;
349              }
350              context.Debug($"Repository remote origin fetch url is {remoteUrl}");
351              if (expectedRepositoryOriginUrl.Equals(remoteUrl))
352              {
353                  context.Debug("URLs match.");
354                  return true;
355              }
356              else
357              {
358                  context.Debug($"The remote.origin.url of the repository under root folder '{repositoryPath}' doesn't matches source repository url.");
359                  return false;
360              }
361          }
362          private async Task RemoveGitConfig(RunnerActionPluginExecutionContext executionContext, GitCliManager gitCommandManager, string targetPath, string configKey, string configValue)
363          {
364              int exitCode_configUnset = await gitCommandManager.GitConfigUnset(executionContext, targetPath, configKey);
365              if (exitCode_configUnset != 0)
366              {
367                  if (!string.IsNullOrEmpty(configValue))
368                  {
369                      executionContext.Warning("An unsuccessful attempt was made using git command line to remove \"http.extraheader\" from the git config. Attempting to modify the git config file directly to remove the credential.");
370                      string gitConfig = Path.Combine(targetPath, ".git/config");
371                      if (File.Exists(gitConfig))
372                      {
373                          List<string> safeGitConfig = new();
374                          var gitConfigContents = File.ReadAllLines(gitConfig);
375                          foreach (var line in gitConfigContents)
376                          {
377                              if (!line.Contains(configValue))
378                              {
379                                  safeGitConfig.Add(line);
380                              }
381                          }
382                          File.WriteAllLines(gitConfig, safeGitConfig);
383                      }
384                  }
385                  else
386                  {
387                      executionContext.Warning($"Unable to remove \"{configKey}\" from the git config. To remove the credential, execute \"git config --unset - all {configKey}\" from the repository root \"{targetPath}\".");
388                  }
389              }
390          }
391          private bool IsPullRequest(string sourceBranch)
392          {
393              return !string.IsNullOrEmpty(sourceBranch) &&
394                  (sourceBranch.StartsWith(_pullRefsPrefix, StringComparison.OrdinalIgnoreCase) ||
395                   sourceBranch.StartsWith(_remotePullRefsPrefix, StringComparison.OrdinalIgnoreCase));
396          }
397          private string GetRemoteRefName(string refName)
398          {
399              if (string.IsNullOrEmpty(refName))
400              {
<span onclick='openModal()' class='match'>401                  refName = _remoteRefsPrefix + "master";
402              }
403              else if (refName.Equals("master", StringComparison.OrdinalIgnoreCase))
404              {
405                  refName = _remoteRefsPrefix + refName;
406              }
407              else if (refName.StartsWith(_refsPrefix, StringComparison.OrdinalIgnoreCase))
408              {
409                  refName = _remoteRefsPrefix + refName.Substring(_refsPrefix.Length);
410              }
411              else if (refName.StartsWith(_pullRefsPrefix, StringComparison.OrdinalIgnoreCase))
412              {
413                  refName = refName.Replace(_pullRefsPrefix, _remotePullRefsPrefix);
414              }
415              return refName;
416          }
417      }
418  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-GitSourceProvider_1.cs</h3>
            <pre><code>1  using Pipelines = GitHub.DistributedTask.Pipelines;
2  using System;
3  using System.Collections.Generic;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using System.IO;
7  using System.Text;
8  using GitHub.Runner.Sdk;
9  using System.Linq;
10  using GitHub.DistributedTask.WebApi;
11  using GitHub.Services.WebApi;
12  namespace GitHub.Runner.Plugins.Repository.v1_1
13  {
14      public sealed class GitHubSourceProvider
15      {
16          private const string _refsPrefix = "refs/heads/";
17          private const string _remoteRefsPrefix = "refs/remotes/origin/";
18          private const string _pullRefsPrefix = "refs/pull/";
19          private const string _remotePullRefsPrefix = "refs/remotes/pull/";
20          private const string _tagRefsPrefix = "refs/tags/";
21          private Version _minGitVersionSupportAuthHeader = new(2, 9);
22  #if OS_WINDOWS
23          private Version _minGitVersionSupportSSLBackendOverride = new Version(2, 14, 2);
24  #endif
25          private Version _minGitLfsVersionSupportAuthHeader = new(2, 1);
26          public static string ProblemMatcher => @"    
27  {
28      ""problemMatcher"": [
29          {
30              ""owner"": ""checkout-git"",
31              ""pattern"": [
32                  {
33                      ""regexp"": ""^(fatal|error): (.*)$"",
34                      ""message"": 2
35                  }
36              ]
37          }
38      ]
39  }";
40          public async Task GetSourceAsync(
41              RunnerActionPluginExecutionContext executionContext,
42              string repositoryPath,
43              string repoFullName,
44              string sourceBranch,
45              string sourceVersion,
46              bool clean,
47              string submoduleInput,
48              int fetchDepth,
49              bool gitLfsSupport,
50              string accessToken,
51              CancellationToken cancellationToken)
52          {
53              ArgUtil.NotNull(executionContext, nameof(executionContext));
54              Dictionary<string, string> configModifications = new();
55              executionContext.Output($"Syncing repository: {repoFullName}");
56              Uri repositoryUrl = new($"https:&bsol;&bsol;github.com/{repoFullName}");
57              if (!repositoryUrl.IsAbsoluteUri)
58              {
59                  throw new InvalidOperationException("Repository url need to be an absolute uri.");
60              }
61              string targetPath = repositoryPath;
62              bool checkoutSubmodules = false;
63              bool checkoutNestedSubmodules = false;
64              if (!string.IsNullOrEmpty(submoduleInput))
65              {
66                  if (string.Equals(submoduleInput, Pipelines.PipelineConstants.CheckoutTaskInputs.SubmodulesOptions.Recursive, StringComparison.OrdinalIgnoreCase))
67                  {
68                      checkoutSubmodules = true;
69                      checkoutNestedSubmodules = true;
70                  }
71                  else
72                  {
73                      checkoutSubmodules = StringUtil.ConvertToBoolean(submoduleInput);
74                  }
75              }
76              executionContext.Debug($"repository url={repositoryUrl}");
77              executionContext.Debug($"targetPath={targetPath}");
78              executionContext.Debug($"sourceBranch={sourceBranch}");
79              executionContext.Debug($"sourceVersion={sourceVersion}");
80              executionContext.Debug($"clean={clean}");
81              executionContext.Debug($"checkoutSubmodules={checkoutSubmodules}");
82              executionContext.Debug($"checkoutNestedSubmodules={checkoutNestedSubmodules}");
83              executionContext.Debug($"fetchDepth={fetchDepth}");
84              executionContext.Debug($"gitLfsSupport={gitLfsSupport}");
85              Dictionary<string, string> gitEnv = new(StringComparer.OrdinalIgnoreCase);
86              gitEnv["GIT_TERMINAL_PROMPT"] = "0";
87              gitEnv["GCM_INTERACTIVE"] = "Never";
88              if (!gitLfsSupport)
89              {
90                  gitEnv["GIT_LFS_SKIP_SMUDGE"] = "1";
91              }
92              foreach (var variable in executionContext.Variables)
93              {
94                  string formattedKey = (variable.Key ?? string.Empty).Replace('.', '_').Replace(' ', '_').ToUpperInvariant();
95                  gitEnv[formattedKey] = variable.Value?.Value ?? string.Empty;
96              }
97              GitCliManager gitCommandManager = new(gitEnv);
98              await gitCommandManager.LoadGitExecutionInfo(executionContext);
99              RequirementCheck(executionContext, gitCommandManager, gitLfsSupport);
100              var systemConnection = executionContext.Endpoints.Single(x => string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
101              if (!await IsRepositoryOriginUrlMatch(executionContext, gitCommandManager, targetPath, repositoryUrl))
102              {
103                  IOUtil.DeleteDirectory(targetPath, cancellationToken);
104              }
105              else
106              {
107                  string lockFile = Path.Combine(targetPath, ".git\\index.lock");
108                  if (File.Exists(lockFile))
109                  {
110                      try
111                      {
112                          File.Delete(lockFile);
113                      }
114                      catch (Exception ex)
115                      {
116                          executionContext.Debug($"Unable to delete the index.lock file: {lockFile}");
117                          executionContext.Debug(ex.ToString());
118                      }
119                  }
120                  string shallowLockFile = Path.Combine(targetPath, ".git\\shallow.lock");
121                  if (File.Exists(shallowLockFile))
122                  {
123                      try
124                      {
125                          File.Delete(shallowLockFile);
126                      }
127                      catch (Exception ex)
128                      {
129                          executionContext.Debug($"Unable to delete the shallow.lock file: {shallowLockFile}");
130                          executionContext.Debug(ex.ToString());
131                      }
132                  }
133                  if (clean)
134                  {
135                      Boolean softCleanSucceed = true;
136                      int exitCode_clean = await gitCommandManager.GitClean(executionContext, targetPath);
137                      if (exitCode_clean != 0)
138                      {
139                          executionContext.Debug($"'git clean -ffdx' failed with exit code {exitCode_clean}, this normally caused by:\n    1) Path too long\n    2) Permission issue\n    3) File in use\nFor futher investigation, manually run 'git clean -ffdx' on repo root: {targetPath} after each build.");
140                          softCleanSucceed = false;
141                      }
142                      if (softCleanSucceed)
143                      {
144                          int exitCode_reset = await gitCommandManager.GitReset(executionContext, targetPath);
145                          if (exitCode_reset != 0)
146                          {
147                              executionContext.Debug($"'git reset --hard HEAD' failed with exit code {exitCode_reset}\nFor futher investigation, manually run 'git reset --hard HEAD' on repo root: {targetPath} after each build.");
148                              softCleanSucceed = false;
149                          }
150                      }
151                      if (checkoutSubmodules)
152                      {
153                          if (softCleanSucceed)
154                          {
155                              int exitCode_submoduleclean = await gitCommandManager.GitSubmoduleClean(executionContext, targetPath);
156                              if (exitCode_submoduleclean != 0)
157                              {
158                                  executionContext.Debug($"'git submodule foreach git clean -ffdx' failed with exit code {exitCode_submoduleclean}\nFor futher investigation, manually run 'git submodule foreach git clean -ffdx' on repo root: {targetPath} after each build.");
159                                  softCleanSucceed = false;
160                              }
161                          }
162                          if (softCleanSucceed)
163                          {
164                              int exitCode_submodulereset = await gitCommandManager.GitSubmoduleReset(executionContext, targetPath);
165                              if (exitCode_submodulereset != 0)
166                              {
167                                  executionContext.Debug($"'git submodule foreach git reset --hard HEAD' failed with exit code {exitCode_submodulereset}\nFor futher investigation, manually run 'git submodule foreach git reset --hard HEAD' on repo root: {targetPath} after each build.");
168                                  softCleanSucceed = false;
169                              }
170                          }
171                      }
172                      if (!softCleanSucceed)
173                      {
174                          executionContext.Warning("Unable to run \"git clean -ffdx\" and \"git reset --hard HEAD\" successfully, delete source folder instead.");
175                          IOUtil.DeleteDirectory(targetPath, cancellationToken);
176                      }
177                  }
178              }
179              if (!Directory.Exists(targetPath))
180              {
181                  Directory.CreateDirectory(targetPath);
182              }
183              if (!Directory.Exists(Path.Combine(targetPath, ".git")))
184              {
185                  int exitCode_init = await gitCommandManager.GitInit(executionContext, targetPath);
186                  if (exitCode_init != 0)
187                  {
188                      throw new InvalidOperationException($"Unable to use git.exe init repository under {targetPath}, 'git init' failed with exit code: {exitCode_init}");
189                  }
190                  int exitCode_addremote = await gitCommandManager.GitRemoteAdd(executionContext, targetPath, "origin", repositoryUrl.AbsoluteUri);
191                  if (exitCode_addremote != 0)
192                  {
193                      throw new InvalidOperationException($"Unable to use git.exe add remote 'origin', 'git remote add' failed with exit code: {exitCode_addremote}");
194                  }
195              }
196              cancellationToken.ThrowIfCancellationRequested();
197              int exitCode_disableGC = await gitCommandManager.GitDisableAutoGC(executionContext, targetPath);
198              if (exitCode_disableGC != 0)
199              {
200                  executionContext.Warning("Unable turn off git auto garbage collection, git fetch operation may trigger auto garbage collection which will affect the performance of fetching.");
201              }
202              if (await gitCommandManager.GitConfigExist(executionContext, targetPath, $"http.{repositoryUrl.AbsoluteUri}.extraheader"))
203              {
204                  executionContext.Debug("Remove any extraheader setting from git config.");
205                  await RemoveGitConfig(executionContext, gitCommandManager, targetPath, $"http.{repositoryUrl.AbsoluteUri}.extraheader", string.Empty);
206              }
207              List<string> additionalFetchArgs = new();
208              List<string> additionalLfsFetchArgs = new();
209              string configKey = $"http.https:&bsol;&bsol;github.com/.extraheader";
210              string configValue = $"\"AUTHORIZATION: {GenerateBasicAuthHeader(executionContext, accessToken)}\"";
211              configModifications[configKey] = configValue.Trim('\"');
212              int exitCode_config = await gitCommandManager.GitConfig(executionContext, targetPath, configKey, configValue);
213              if (exitCode_config != 0)
214              {
215                  throw new InvalidOperationException($"Git config failed with exit code: {exitCode_config}");
216              }
217              if (gitLfsSupport)
218              {
219                  executionContext.Debug("Setup the local Git hooks for Git LFS.");
220                  int exitCode_lfsInstall = await gitCommandManager.GitLFSInstall(executionContext, targetPath);
221                  if (exitCode_lfsInstall != 0)
222                  {
223                      throw new InvalidOperationException($"Git-lfs installation failed with exit code: {exitCode_lfsInstall}");
224                  }
225              }
226              List<string> additionalFetchSpecs = new();
227              additionalFetchSpecs.Add("+refs/heads&bsol;*:refs/remotes/origin&bsol;*");
228              if (IsPullRequest(sourceBranch))
229              {
230                  additionalFetchSpecs.Add($"+{sourceBranch}:{GetRemoteRefName(sourceBranch)}");
231              }
232              int exitCode_fetch = await gitCommandManager.GitFetch(executionContext, targetPath, "origin", fetchDepth, additionalFetchSpecs, string.Join(" ", additionalFetchArgs), cancellationToken);
233              if (exitCode_fetch != 0)
234              {
235                  throw new InvalidOperationException($"Git fetch failed with exit code: {exitCode_fetch}");
236              }
237              cancellationToken.ThrowIfCancellationRequested();
238              string sourcesToBuild;
239              if (IsPullRequest(sourceBranch) || string.IsNullOrEmpty(sourceVersion))
240              {
241                  sourcesToBuild = GetRemoteRefName(sourceBranch);
242              }
243              else
244              {
245                  sourcesToBuild = sourceVersion;
246              }
247              if (gitLfsSupport)
248              {
249                  int exitCode_lfsFetch = await gitCommandManager.GitLFSFetch(executionContext, targetPath, "origin", sourcesToBuild, string.Join(" ", additionalLfsFetchArgs), cancellationToken);
250                  if (exitCode_lfsFetch != 0)
251                  {
252                      if (fetchDepth > 0)
253                      {
254                          executionContext.Warning($"Git lfs fetch failed on shallow repository, this might because of git fetch with depth '{fetchDepth}' doesn't include the lfs fetch commit '{sourcesToBuild}'.");
255                      }
256                      int exitCode_lfsLogs = await gitCommandManager.GitLFSLogs(executionContext, targetPath);
257                      throw new InvalidOperationException($"Git lfs fetch failed with exit code: {exitCode_lfsFetch}. Git lfs logs returned with exit code: {exitCode_lfsLogs}.");
258                  }
259              }
260              int exitCode_checkout = await gitCommandManager.GitCheckout(executionContext, targetPath, sourcesToBuild, cancellationToken);
261              if (exitCode_checkout != 0)
262              {
263                  if (fetchDepth > 0)
264                  {
265                      executionContext.Warning($"Git checkout failed on shallow repository, this might because of git fetch with depth '{fetchDepth}' doesn't include the checkout commit '{sourcesToBuild}'.");
266                  }
267                  throw new InvalidOperationException($"Git checkout failed with exit code: {exitCode_checkout}");
268              }
269              if (checkoutSubmodules)
270              {
271                  cancellationToken.ThrowIfCancellationRequested();
272                  int exitCode_submoduleSync = await gitCommandManager.GitSubmoduleSync(executionContext, targetPath, checkoutNestedSubmodules, cancellationToken);
273                  if (exitCode_submoduleSync != 0)
274                  {
275                      throw new InvalidOperationException($"Git submodule sync failed with exit code: {exitCode_submoduleSync}");
276                  }
277                  List<string> additionalSubmoduleUpdateArgs = new();
278                  int exitCode_submoduleUpdate = await gitCommandManager.GitSubmoduleUpdate(executionContext, targetPath, fetchDepth, string.Join(" ", additionalSubmoduleUpdateArgs), checkoutNestedSubmodules, cancellationToken);
279                  if (exitCode_submoduleUpdate != 0)
280                  {
281                      throw new InvalidOperationException($"Git submodule update failed with exit code: {exitCode_submoduleUpdate}");
282                  }
283              }
284              executionContext.SetIntraActionState("repositoryPath", targetPath);
285              executionContext.SetIntraActionState("modifiedgitconfig", JsonUtility.ToString(configModifications.Keys));
286              foreach (var config in configModifications)
287              {
288                  executionContext.SetIntraActionState(config.Key, config.Value);
289              }
290          }
291          public async Task CleanupAsync(RunnerActionPluginExecutionContext executionContext)
292          {
293              ArgUtil.NotNull(executionContext, nameof(executionContext));
294              var repositoryPath = Environment.GetEnvironmentVariable("STATE_repositoryPath");
295              ArgUtil.NotNullOrEmpty(repositoryPath, nameof(repositoryPath));
296              executionContext.Output($"Cleanup cached git credential from {repositoryPath}.");
297              GitCliManager gitCommandManager = new();
298              await gitCommandManager.LoadGitExecutionInfo(executionContext);
299              executionContext.Debug("Remove any extraheader setting from git config.");
300              var configKeys = JsonUtility.FromString<List<string>>(Environment.GetEnvironmentVariable("STATE_modifiedgitconfig"));
301              if (configKeys?.Count > 0)
302              {
303                  foreach (var config in configKeys)
304                  {
305                      var configValue = Environment.GetEnvironmentVariable($"STATE_{config}");
306                      if (!string.IsNullOrEmpty(configValue))
307                      {
308                          await RemoveGitConfig(executionContext, gitCommandManager, repositoryPath, config, configValue);
309                      }
310                  }
311              }
312          }
313          private void RequirementCheck(RunnerActionPluginExecutionContext executionContext, GitCliManager gitCommandManager, bool checkGitLfs)
314          {
315              gitCommandManager.EnsureGitVersion(_minGitVersionSupportAuthHeader, throwOnNotMatch: true);
316  #if OS_WINDOWS
317              bool schannelSslBackend = StringUtil.ConvertToBoolean(executionContext.GetRunnerContext("gituseschannel"));
318              if (schannelSslBackend)
319              {
320                  gitCommandManager.EnsureGitVersion(_minGitVersionSupportSSLBackendOverride, throwOnNotMatch: true);
321              }
322  #endif
323              if (checkGitLfs)
324              {
325                  gitCommandManager.EnsureGitLFSVersion(_minGitLfsVersionSupportAuthHeader, throwOnNotMatch: true);
326              }
327          }
328          private string GenerateBasicAuthHeader(RunnerActionPluginExecutionContext executionContext, string accessToken)
329          {
330              string authHeader = $"x-access-token:{accessToken}";
331              string base64encodedAuthHeader = Convert.ToBase64String(Encoding.UTF8.GetBytes(authHeader));
332              executionContext.AddMask(base64encodedAuthHeader);
333              return $"basic {base64encodedAuthHeader}";
334          }
335          private async Task<bool> IsRepositoryOriginUrlMatch(RunnerActionPluginExecutionContext context, GitCliManager gitCommandManager, string repositoryPath, Uri expectedRepositoryOriginUrl)
336          {
337              context.Debug($"Checking if the repo on {repositoryPath} matches the expected repository origin URL. expected Url: {expectedRepositoryOriginUrl.AbsoluteUri}");
338              if (!Directory.Exists(Path.Combine(repositoryPath, ".git")))
339              {
340                  context.Debug($"Repository is not found since '.git' directory does not exist under. {repositoryPath}");
341                  return false;
342              }
343              Uri remoteUrl;
344              remoteUrl = await gitCommandManager.GitGetFetchUrl(context, repositoryPath);
345              if (remoteUrl == null)
346              {
347                  context.Debug("Repository remote origin fetch url is empty.");
348                  return false;
349              }
350              context.Debug($"Repository remote origin fetch url is {remoteUrl}");
351              if (expectedRepositoryOriginUrl.Equals(remoteUrl))
352              {
353                  context.Debug("URLs match.");
354                  return true;
355              }
356              else
357              {
358                  context.Debug($"The remote.origin.url of the repository under root folder '{repositoryPath}' doesn't matches source repository url.");
359                  return false;
360              }
361          }
362          private async Task RemoveGitConfig(RunnerActionPluginExecutionContext executionContext, GitCliManager gitCommandManager, string targetPath, string configKey, string configValue)
363          {
364              int exitCode_configUnset = await gitCommandManager.GitConfigUnset(executionContext, targetPath, configKey);
365              if (exitCode_configUnset != 0)
366              {
367                  if (!string.IsNullOrEmpty(configValue))
368                  {
369                      executionContext.Warning("An unsuccessful attempt was made using git command line to remove \"http.extraheader\" from the git config. Attempting to modify the git config file directly to remove the credential.");
370                      string gitConfig = Path.Combine(targetPath, ".git/config");
371                      if (File.Exists(gitConfig))
372                      {
373                          List<string> safeGitConfig = new();
374                          var gitConfigContents = File.ReadAllLines(gitConfig);
375                          foreach (var line in gitConfigContents)
376                          {
377                              if (!line.Contains(configValue))
378                              {
379                                  safeGitConfig.Add(line);
380                              }
381                          }
382                          File.WriteAllLines(gitConfig, safeGitConfig);
383                      }
384                  }
385                  else
386                  {
387                      executionContext.Warning($"Unable to remove \"{configKey}\" from the git config. To remove the credential, execute \"git config --unset - all {configKey}\" from the repository root \"{targetPath}\".");
388                  }
389              }
390          }
391          private bool IsPullRequest(string sourceBranch)
392          {
393              return !string.IsNullOrEmpty(sourceBranch) &&
394                  (sourceBranch.StartsWith(_pullRefsPrefix, StringComparison.OrdinalIgnoreCase) ||
395                   sourceBranch.StartsWith(_remotePullRefsPrefix, StringComparison.OrdinalIgnoreCase));
396          }
397          private string GetRemoteRefName(string refName)
398          {
399              if (string.IsNullOrEmpty(refName))
400              {
<span onclick='openModal()' class='match'>401                  refName = _remoteRefsPrefix + "master";
402              }
403              else if (refName.Equals("master", StringComparison.OrdinalIgnoreCase))
404              {
405                  refName = _remoteRefsPrefix + refName;
406              }
407              else if (refName.StartsWith(_refsPrefix, StringComparison.OrdinalIgnoreCase))
408              {
409                  refName = _remoteRefsPrefix + refName.Substring(_refsPrefix.Length);
410              }
411              else if (refName.StartsWith(_pullRefsPrefix, StringComparison.OrdinalIgnoreCase))
412              {
413                  refName = refName.Replace(_pullRefsPrefix, _remotePullRefsPrefix);
414              }
415              return refName;
416          }
417      }
418  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-GitSourceProvider_1.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-GitSourceProvider_1.cs</div>
                </div>
                <div class="column column_space"><pre><code>401                  refName = _remoteRefsPrefix + "master";
402              }
403              else if (refName.Equals("master", StringComparison.OrdinalIgnoreCase))
404              {
405                  refName = _remoteRefsPrefix + refName;
406              }
407              else if (refName.StartsWith(_refsPrefix, StringComparison.OrdinalIgnoreCase))
408              {
409                  refName = _remoteRefsPrefix + refName.Substring(_refsPrefix.Length);
410              }
411              else if (refName.StartsWith(_pullRefsPrefix, StringComparison.OrdinalIgnoreCase))
412              {
413                  refName = refName.Replace(_pullRefsPrefix, _remotePullRefsPrefix);
414              }
415              return refName;
416          }
417      }
418  }
</pre></code></div>
                <div class="column column_space"><pre><code>401                  refName = _remoteRefsPrefix + "master";
402              }
403              else if (refName.Equals("master", StringComparison.OrdinalIgnoreCase))
404              {
405                  refName = _remoteRefsPrefix + refName;
406              }
407              else if (refName.StartsWith(_refsPrefix, StringComparison.OrdinalIgnoreCase))
408              {
409                  refName = _remoteRefsPrefix + refName.Substring(_refsPrefix.Length);
410              }
411              else if (refName.StartsWith(_pullRefsPrefix, StringComparison.OrdinalIgnoreCase))
412              {
413                  refName = refName.Replace(_pullRefsPrefix, _remotePullRefsPrefix);
414              }
415              return refName;
416          }
417      }
418  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    