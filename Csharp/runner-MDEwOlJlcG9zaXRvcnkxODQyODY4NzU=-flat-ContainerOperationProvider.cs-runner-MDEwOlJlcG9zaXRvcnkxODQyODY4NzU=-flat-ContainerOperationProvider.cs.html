
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Threading.Tasks;
5  using System.Linq;
6  using System.Threading;
7  using GitHub.Runner.Worker.Container;
8  using GitHub.Services.Common;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
13  using GitHub.Runner.Worker.Container.ContainerHooks;
14  #if OS_WINDOWS 
15  using System.ServiceProcess;
16  using Microsoft.Win32;
17  #endif
18  namespace GitHub.Runner.Worker
19  {
20      [ServiceLocator(Default = typeof(ContainerOperationProvider))]
21      public interface IContainerOperationProvider : IRunnerService
22      {
23          Task StartContainersAsync(IExecutionContext executionContext, object data);
24          Task StopContainersAsync(IExecutionContext executionContext, object data);
25      }
26      public class ContainerOperationProvider : RunnerService, IContainerOperationProvider
27      {
28          private IDockerCommandManager _dockerManager;
29          private IContainerHookManager _containerHookManager;
30          public override void Initialize(IHostContext hostContext)
31          {
32              base.Initialize(hostContext);
33              if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable(Constants.Hooks.ContainerHooksPath)))
34              {
35                  _dockerManager = HostContext.GetService<IDockerCommandManager>();
36              }
37              else
38              {
39                  _containerHookManager = HostContext.GetService<IContainerHookManager>();
40              }
41          }
42          public async Task StartContainersAsync(IExecutionContext executionContext, object data)
43          {
44              Trace.Entering();
45              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
46              {
47                  throw new NotSupportedException("Container operations are only supported on Linux runners");
48              }
49              ArgUtil.NotNull(executionContext, nameof(executionContext));
50              List<ContainerInfo> containers = data as List<ContainerInfo>;
51              ArgUtil.NotNull(containers, nameof(containers));
52              var postJobStep = new JobExtensionRunner(runAsync: this.StopContainersAsync,
53                                                  condition: $"{PipelineTemplateConstants.Always}()",
54                                                  displayName: "Stop containers",
55                                                  data: data);
56              executionContext.Debug($"Register post job cleanup for stopping/deleting containers.");
57              executionContext.RegisterPostJobStep(postJobStep);
58              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
59              {
60                  containers.ForEach(container => UpdateRegistryAuthForGitHubToken(executionContext, container));
61                  containers.Where(container => container.IsJobContainer).ForEach(container => MountWellKnownDirectories(executionContext, container));
62                  await _containerHookManager.PrepareJobAsync(executionContext, containers);
63                  return;
64              }
65              await AssertCompatibleOS(executionContext);
66              executionContext.Output("##[group]Clean up resources from previous jobs");
67              var staleContainers = await _dockerManager.DockerPS(executionContext, $"--all --quiet --no-trunc --filter \"label={_dockerManager.DockerInstanceLabel}\"");
68              foreach (var staleContainer in staleContainers)
69              {
70                  int containerRemoveExitCode = await _dockerManager.DockerRemove(executionContext, staleContainer);
71                  if (containerRemoveExitCode != 0)
72                  {
73                      executionContext.Warning($"Delete stale containers failed, docker rm fail with exit code {containerRemoveExitCode} for container {staleContainer}");
74                  }
75              }
76              int networkPruneExitCode = await _dockerManager.DockerNetworkPrune(executionContext);
77              if (networkPruneExitCode != 0)
78              {
79                  executionContext.Warning($"Delete stale container networks failed, docker network prune fail with exit code {networkPruneExitCode}");
80              }
81              executionContext.Output("##[endgroup]");
82              executionContext.Output("##[group]Create local container network");
83              var containerNetwork = $"github_network_{Guid.NewGuid().ToString("N")}";
84              await CreateContainerNetworkAsync(executionContext, containerNetwork);
85              executionContext.JobContext.Container["network"] = new StringContextData(containerNetwork);
86              executionContext.Output("##[endgroup]");
87              foreach (var container in containers)
88              {
89                  container.ContainerNetwork = containerNetwork;
90                  await StartContainerAsync(executionContext, container);
91              }
92              await RunContainersHealthcheck(executionContext, containers);
93          }
94          public async Task RunContainersHealthcheck(IExecutionContext executionContext, List<ContainerInfo> containers)
95          {
96              executionContext.Output("##[group]Waiting for all services to be ready");
97              var unhealthyContainers = new List<ContainerInfo>();
98              foreach (var container in containers.Where(c => !c.IsJobContainer))
99              {
100                  var healthy_container = await ContainerHealthcheck(executionContext, container);
101                  if (!healthy_container)
102                  {
103                      unhealthyContainers.Add(container);
104                  }
105                  else
106                  {
107                      executionContext.Output($"{container.ContainerNetworkAlias} service is healthy.");
108                  }
109              }
110              executionContext.Output("##[endgroup]");
111              if (unhealthyContainers.Count > 0)
112              {
113                  foreach (var container in unhealthyContainers)
114                  {
115                      executionContext.Output($"##[group]Service container {container.ContainerNetworkAlias} failed.");
116                      await _dockerManager.DockerLogs(context: executionContext, containerId: container.ContainerId);
117                      executionContext.Error($"Failed to initialize container {container.ContainerImage}");
118                      container.FailedInitialization = true;
119                      executionContext.Output("##[endgroup]");
120                  }
121                  throw new InvalidOperationException("One or more containers failed to start.");
122              }
123          }
124          public async Task StopContainersAsync(IExecutionContext executionContext, object data)
125          {
126              Trace.Entering();
127              ArgUtil.NotNull(executionContext, nameof(executionContext));
<span onclick='openModal()' class='match'>128              List<ContainerInfo> containers = data as List<ContainerInfo>;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
</span>131              {
132                  await _containerHookManager.CleanupJobAsync(executionContext, containers);
133                  return;
134              }
135              foreach (var container in containers)
136              {
137                  await StopContainerAsync(executionContext, container);
138              }
139              await RemoveContainerNetworkAsync(executionContext, containers.First().ContainerNetwork);
140          }
141          private async Task StartContainerAsync(IExecutionContext executionContext, ContainerInfo container)
142          {
143              Trace.Entering();
144              ArgUtil.NotNull(executionContext, nameof(executionContext));
145              ArgUtil.NotNull(container, nameof(container));
146              ArgUtil.NotNullOrEmpty(container.ContainerImage, nameof(container.ContainerImage));
147              Trace.Info($"Container name: {container.ContainerName}");
148              Trace.Info($"Container image: {container.ContainerImage}");
149              Trace.Info($"Container options: {container.ContainerCreateOptions}");
150              var groupName = container.IsJobContainer ? "Starting job container" : $"Starting {container.ContainerNetworkAlias} service container";
151              executionContext.Output($"##[group]{groupName}");
152              foreach (var port in container.UserPortMappings)
153              {
154                  Trace.Info($"User provided port: {port.Value}");
155              }
156              foreach (var mount in container.UserMountVolumes)
157              {
158                  Trace.Info($"User provided volume: {mount.UserProvidedValue}");
159                  if (string.Equals(mount.SourceVolumePath, "/", StringComparison.OrdinalIgnoreCase))
160                  {
161                      executionContext.Warning($"Volume mount {mount.UserProvidedValue} is going to mount '/' into the container which may cause file ownership change in the entire file system and cause Actions Runner to lose permission to access the disk.");
162                  }
163              }
164              UpdateRegistryAuthForGitHubToken(executionContext, container);
165              var configLocation = await ContainerRegistryLogin(executionContext, container);
166              int retryCount = 0;
167              int pullExitCode = 0;
168              while (retryCount < 3)
169              {
170                  pullExitCode = await _dockerManager.DockerPull(executionContext, container.ContainerImage, configLocation);
171                  if (pullExitCode == 0)
172                  {
173                      break;
174                  }
175                  else
176                  {
177                      retryCount++;
178                      if (retryCount < 3)
179                      {
180                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
181                          executionContext.Warning($"Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
182                          await Task.Delay(backOff);
183                      }
184                  }
185              }
186              ContainerRegistryLogout(configLocation);
187              if (retryCount == 3 && pullExitCode != 0)
188              {
189                  throw new InvalidOperationException($"Docker pull failed with exit code {pullExitCode}");
190              }
191              if (container.IsJobContainer)
192              {
193                  MountWellKnownDirectories(executionContext, container);
194              }
195              container.ContainerId = await _dockerManager.DockerCreate(executionContext, container);
196              ArgUtil.NotNullOrEmpty(container.ContainerId, nameof(container.ContainerId));
197              int startExitCode = await _dockerManager.DockerStart(executionContext, container.ContainerId);
198              if (startExitCode != 0)
199              {
200                  throw new InvalidOperationException($"Docker start fail with exit code {startExitCode}");
201              }
202              try
203              {
204                  var psOutputs = await _dockerManager.DockerPS(executionContext, $"--all --filter id={container.ContainerId} --filter status=running --no-trunc --format \"{{{{.ID}}}} {{{{.Status}}}}\"");
205                  if (psOutputs.FirstOrDefault(x => !string.IsNullOrEmpty(x))?.StartsWith(container.ContainerId) != true)
206                  {
207                      await _dockerManager.DockerPS(executionContext, $"--all --filter id={container.ContainerId} --no-trunc --format \"{{{{.ID}}}} {{{{.Status}}}}\"");
208                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
209                      if (logsExitCode != 0)
210                      {
211                          executionContext.Warning($"Docker logs fail with exit code {logsExitCode}");
212                      }
213                      executionContext.Warning($"Docker container {container.ContainerId} is not in running state.");
214                  }
215              }
216              catch (Exception ex)
217              {
218                  Trace.Error("Catch exception when check container log and container status.");
219                  Trace.Error(ex);
220              }
221              if (!container.IsJobContainer)
222              {
223                  var service = new DictionaryContextData()
224                  {
225                      ["id"] = new StringContextData(container.ContainerId),
226                      ["ports"] = new DictionaryContextData(),
227                      ["network"] = new StringContextData(container.ContainerNetwork)
228                  };
229                  container.AddPortMappings(await _dockerManager.DockerPort(executionContext, container.ContainerId));
230                  foreach (var port in container.PortMappings)
231                  {
232                      (service["ports"] as DictionaryContextData)[port.ContainerPort] = new StringContextData(port.HostPort);
233                  }
234                  executionContext.JobContext.Services[container.ContainerNetworkAlias] = service;
235              }
236              else
237              {
238                  var configEnvFormat = "--format \"{{range .Config.Env}}{{println .}}{{end}}\"";
239                  var containerEnv = await _dockerManager.DockerInspect(executionContext, container.ContainerId, configEnvFormat);
240                  container.ContainerRuntimePath = DockerUtil.ParsePathFromConfigEnv(containerEnv);
241                  executionContext.JobContext.Container["id"] = new StringContextData(container.ContainerId);
242              }
243              executionContext.Output("##[endgroup]");
244          }
245          private void MountWellKnownDirectories(IExecutionContext executionContext, ContainerInfo container)
246          {
247              var githubContext = executionContext.ExpressionValues["github"] as GitHubContext;
248              ArgUtil.NotNull(githubContext, nameof(githubContext));
249              var workingDirectory = githubContext["workspace"] as StringContextData;
250              ArgUtil.NotNullOrEmpty(workingDirectory, nameof(workingDirectory));
251              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Work), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Work))));
252  #if OS_WINDOWS
253                  container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals))));
254  #else
255              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals)), true));
256  #endif
257              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Temp), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Temp))));
258              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Actions), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Actions))));
259              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Tools), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Tools))));
260              var tempHomeDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), "_github_home");
261              Directory.CreateDirectory(tempHomeDirectory);
262              container.MountVolumes.Add(new MountVolume(tempHomeDirectory, "/github/home"));
263              container.AddPathTranslateMapping(tempHomeDirectory, "/github/home");
264              container.ContainerEnvironmentVariables["HOME"] = container.TranslateToContainerPath(tempHomeDirectory);
265              var tempWorkflowDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), "_github_workflow");
266              Directory.CreateDirectory(tempWorkflowDirectory);
267              container.MountVolumes.Add(new MountVolume(tempWorkflowDirectory, "/github/workflow"));
268              container.AddPathTranslateMapping(tempWorkflowDirectory, "/github/workflow");
269              container.ContainerWorkDirectory = container.TranslateToContainerPath(workingDirectory);
270              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
271              {
272                  container.ContainerEntryPoint = "tail";
273                  container.ContainerEntryPointArgs = "\"-f\" \"/dev/null\"";
274              }
275          }
276          private async Task StopContainerAsync(IExecutionContext executionContext, ContainerInfo container)
277          {
278              Trace.Entering();
279              ArgUtil.NotNull(executionContext, nameof(executionContext));
280              ArgUtil.NotNull(container, nameof(container));
281              if (!string.IsNullOrEmpty(container.ContainerId))
282              {
283                  if (!container.IsJobContainer && !container.FailedInitialization)
284                  {
285                      executionContext.Output($"Print service container logs: {container.ContainerDisplayName}");
286                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
287                      if (logsExitCode != 0)
288                      {
289                          executionContext.Warning($"Docker logs fail with exit code {logsExitCode}");
290                      }
291                  }
292                  executionContext.Output($"Stop and remove container: {container.ContainerDisplayName}");
293                  int rmExitCode = await _dockerManager.DockerRemove(executionContext, container.ContainerId);
294                  if (rmExitCode != 0)
295                  {
296                      executionContext.Warning($"Docker rm fail with exit code {rmExitCode}");
297                  }
298              }
299          }
300  #if !OS_WINDOWS
301          private async Task<List<string>> ExecuteCommandAsync(IExecutionContext context, string command, string arg)
302          {
303              context.Command($"{command} {arg}");
304              List<string> outputs = new();
305              object outputLock = new();
306              var processInvoker = HostContext.CreateService<IProcessInvoker>();
307              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
308              {
309                  if (!string.IsNullOrEmpty(message.Data))
310                  {
311                      lock (outputLock)
312                      {
313                          outputs.Add(message.Data);
314                      }
315                  }
316              };
317              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
318              {
319                  if (!string.IsNullOrEmpty(message.Data))
320                  {
321                      lock (outputLock)
322                      {
323                          outputs.Add(message.Data);
324                      }
325                  }
326              };
327              await processInvoker.ExecuteAsync(
328                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
329                              fileName: command,
330                              arguments: arg,
331                              environment: null,
332                              requireExitCodeZero: true,
333                              outputEncoding: null,
334                              cancellationToken: CancellationToken.None);
335              foreach (var outputLine in outputs)
336              {
337                  context.Output(outputLine);
338              }
339              return outputs;
340          }
341  #endif
342          private async Task CreateContainerNetworkAsync(IExecutionContext executionContext, string network)
343          {
344              Trace.Entering();
345              ArgUtil.NotNull(executionContext, nameof(executionContext));
346              int networkExitCode = await _dockerManager.DockerNetworkCreate(executionContext, network);
347              if (networkExitCode != 0)
348              {
349                  throw new InvalidOperationException($"Docker network create failed with exit code {networkExitCode}");
350              }
351          }
352          private async Task RemoveContainerNetworkAsync(IExecutionContext executionContext, string network)
353          {
354              Trace.Entering();
355              ArgUtil.NotNull(executionContext, nameof(executionContext));
356              ArgUtil.NotNull(network, nameof(network));
357              executionContext.Output($"Remove container network: {network}");
358              int removeExitCode = await _dockerManager.DockerNetworkRemove(executionContext, network);
359              if (removeExitCode != 0)
360              {
361                  executionContext.Warning($"Docker network rm failed with exit code {removeExitCode}");
362              }
363          }
364          private async Task<bool> ContainerHealthcheck(IExecutionContext executionContext, ContainerInfo container)
365          {
366              string healthCheck = "--format=\"{{if .Config.Healthcheck}}{{print .State.Health.Status}}{{end}}\"";
367              string serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
368              if (string.IsNullOrEmpty(serviceHealth))
369              {
370                  return true;
371              }
372              var retryCount = 0;
373              while (string.Equals(serviceHealth, "starting", StringComparison.OrdinalIgnoreCase))
374              {
375                  TimeSpan backoff = BackoffTimerHelper.GetExponentialBackoff(retryCount, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(32), TimeSpan.FromSeconds(2));
376                  executionContext.Output($"{container.ContainerNetworkAlias} service is starting, waiting {backoff.Seconds} seconds before checking again.");
377                  await Task.Delay(backoff, executionContext.CancellationToken);
378                  serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
379                  retryCount++;
380              }
381              return string.Equals(serviceHealth, "healthy", StringComparison.OrdinalIgnoreCase);
382          }
383          private async Task<string> ContainerRegistryLogin(IExecutionContext executionContext, ContainerInfo container)
384          {
385              if (string.IsNullOrEmpty(container.RegistryAuthUsername) || string.IsNullOrEmpty(container.RegistryAuthPassword))
386              {
387                  return "";
388              }
389              var configLocation = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), $".docker_{Guid.NewGuid()}");
390              try
391              {
392                  var dirInfo = Directory.CreateDirectory(configLocation);
393              }
394              catch (Exception e)
395              {
396                  throw new InvalidOperationException($"Failed to create directory to store registry client credentials: {e.Message}");
397              }
398              var loginExitCode = await _dockerManager.DockerLogin(
399                  executionContext,
400                  configLocation,
401                  container.RegistryServer,
402                  container.RegistryAuthUsername,
403                  container.RegistryAuthPassword);
404              if (loginExitCode != 0)
405              {
406                  throw new InvalidOperationException($"Docker login for '{container.RegistryServer}' failed with exit code {loginExitCode}");
407              }
408              return configLocation;
409          }
410          private void ContainerRegistryLogout(string configLocation)
411          {
412              try
413              {
414                  if (!string.IsNullOrEmpty(configLocation) && Directory.Exists(configLocation))
415                  {
416                      Directory.Delete(configLocation, recursive: true);
417                  }
418              }
419              catch (Exception e)
420              {
421                  throw new InvalidOperationException($"Failed to remove directory containing Docker client credentials: {e.Message}");
422              }
423          }
424          private void UpdateRegistryAuthForGitHubToken(IExecutionContext executionContext, ContainerInfo container)
425          {
426              var registryIsTokenCompatible = container.RegistryServer.Equals("ghcr.io", StringComparison.OrdinalIgnoreCase) || container.RegistryServer.Equals("containers.pkg.github.com", StringComparison.OrdinalIgnoreCase);
427              var isFallbackTokenFromHostedGithub = HostContext.GetService<IConfigurationStore>().GetSettings().IsHostedServer;
428              if (!registryIsTokenCompatible || !isFallbackTokenFromHostedGithub)
429              {
430                  return;
431              }
432              var registryCredentialsNotSupplied = string.IsNullOrEmpty(container.RegistryAuthUsername) && string.IsNullOrEmpty(container.RegistryAuthPassword);
433              if (registryCredentialsNotSupplied)
434              {
435                  container.RegistryAuthUsername = executionContext.GetGitHubContext("actor");
436                  container.RegistryAuthPassword = executionContext.GetGitHubContext("token");
437              }
438          }
439          private async Task AssertCompatibleOS(IExecutionContext executionContext)
440          {
441  #if OS_WINDOWS
442  #pragma warning disable CA1416
443              ServiceController[] scServices = ServiceController.GetServices();
444              if (scServices.Any(x => String.Equals(x.ServiceName, "cexecsvc", StringComparison.OrdinalIgnoreCase) && x.Status == ServiceControllerStatus.Running))
445              {
446                  throw new NotSupportedException("Container feature is not supported when runner is already running inside container.");
447              }
448  #pragma warning restore CA1416
449  #else
450              var initProcessCgroup = File.ReadLines("/proc/1/cgroup");
451              if (initProcessCgroup.Any(x => x.IndexOf(":/docker/", StringComparison.OrdinalIgnoreCase) >= 0))
452              {
453                  throw new NotSupportedException("Container feature is not supported when runner is already running inside container.");
454              }
455  #endif
456  #if OS_WINDOWS
457  #pragma warning disable CA1416
458              object windowsInstallationType = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "InstallationType", defaultValue: null);
459              ArgUtil.NotNull(windowsInstallationType, nameof(windowsInstallationType));
460              object windowsReleaseId = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ReleaseId", defaultValue: null);
461              ArgUtil.NotNull(windowsReleaseId, nameof(windowsReleaseId));
462              executionContext.Debug($"Current Windows version: '{windowsReleaseId} ({windowsInstallationType})'");
463              if (int.TryParse(windowsReleaseId.ToString(), out int releaseId))
464              {
465                  if (!windowsInstallationType.ToString().StartsWith("Server", StringComparison.OrdinalIgnoreCase) || releaseId < 1803)
466                  {
467                      throw new NotSupportedException("Container feature requires Windows Server 1803 or higher.");
468                  }
469              }
470              else
471              {
472                  throw new ArgumentOutOfRangeException(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId");
473              }
474  #pragma warning restore CA1416
475  #endif
476              executionContext.Output("##[group]Checking docker version");
477              DockerVersion dockerVersion = await _dockerManager.DockerVersion(executionContext);
478              executionContext.Output("##[endgroup]");
479              ArgUtil.NotNull(dockerVersion.ServerVersion, nameof(dockerVersion.ServerVersion));
480              ArgUtil.NotNull(dockerVersion.ClientVersion, nameof(dockerVersion.ClientVersion));
481  #if OS_WINDOWS
482              Version requiredDockerEngineAPIVersion = new Version(1, 30);  
483  #else
484              Version requiredDockerEngineAPIVersion = new(1, 35); 
485  #endif
486              if (dockerVersion.ServerVersion < requiredDockerEngineAPIVersion)
487              {
488                  throw new NotSupportedException($"Min required docker engine API server version is '{requiredDockerEngineAPIVersion}', your docker ('{_dockerManager.DockerPath}') server version is '{dockerVersion.ServerVersion}'");
489              }
490              if (dockerVersion.ClientVersion < requiredDockerEngineAPIVersion)
491              {
492                  throw new NotSupportedException($"Min required docker engine API client version is '{requiredDockerEngineAPIVersion}', your docker ('{_dockerManager.DockerPath}') client version is '{dockerVersion.ClientVersion}'");
493              }
494          }
495      }
496  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Threading.Tasks;
5  using System.Linq;
6  using System.Threading;
7  using GitHub.Runner.Worker.Container;
8  using GitHub.Services.Common;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
13  using GitHub.Runner.Worker.Container.ContainerHooks;
14  #if OS_WINDOWS 
15  using System.ServiceProcess;
16  using Microsoft.Win32;
17  #endif
18  namespace GitHub.Runner.Worker
19  {
20      [ServiceLocator(Default = typeof(ContainerOperationProvider))]
21      public interface IContainerOperationProvider : IRunnerService
22      {
23          Task StartContainersAsync(IExecutionContext executionContext, object data);
24          Task StopContainersAsync(IExecutionContext executionContext, object data);
25      }
26      public class ContainerOperationProvider : RunnerService, IContainerOperationProvider
27      {
28          private IDockerCommandManager _dockerManager;
29          private IContainerHookManager _containerHookManager;
30          public override void Initialize(IHostContext hostContext)
31          {
32              base.Initialize(hostContext);
33              if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable(Constants.Hooks.ContainerHooksPath)))
34              {
35                  _dockerManager = HostContext.GetService<IDockerCommandManager>();
36              }
37              else
38              {
39                  _containerHookManager = HostContext.GetService<IContainerHookManager>();
40              }
41          }
42          public async Task StartContainersAsync(IExecutionContext executionContext, object data)
43          {
44              Trace.Entering();
45              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
46              {
47                  throw new NotSupportedException("Container operations are only supported on Linux runners");
48              }
49              ArgUtil.NotNull(executionContext, nameof(executionContext));
50              List<ContainerInfo> containers = data as List<ContainerInfo>;
51              ArgUtil.NotNull(containers, nameof(containers));
52              var postJobStep = new JobExtensionRunner(runAsync: this.StopContainersAsync,
53                                                  condition: $"{PipelineTemplateConstants.Always}()",
54                                                  displayName: "Stop containers",
55                                                  data: data);
56              executionContext.Debug($"Register post job cleanup for stopping/deleting containers.");
57              executionContext.RegisterPostJobStep(postJobStep);
58              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
59              {
60                  containers.ForEach(container => UpdateRegistryAuthForGitHubToken(executionContext, container));
61                  containers.Where(container => container.IsJobContainer).ForEach(container => MountWellKnownDirectories(executionContext, container));
62                  await _containerHookManager.PrepareJobAsync(executionContext, containers);
63                  return;
64              }
65              await AssertCompatibleOS(executionContext);
66              executionContext.Output("##[group]Clean up resources from previous jobs");
67              var staleContainers = await _dockerManager.DockerPS(executionContext, $"--all --quiet --no-trunc --filter \"label={_dockerManager.DockerInstanceLabel}\"");
68              foreach (var staleContainer in staleContainers)
69              {
70                  int containerRemoveExitCode = await _dockerManager.DockerRemove(executionContext, staleContainer);
71                  if (containerRemoveExitCode != 0)
72                  {
73                      executionContext.Warning($"Delete stale containers failed, docker rm fail with exit code {containerRemoveExitCode} for container {staleContainer}");
74                  }
75              }
76              int networkPruneExitCode = await _dockerManager.DockerNetworkPrune(executionContext);
77              if (networkPruneExitCode != 0)
78              {
79                  executionContext.Warning($"Delete stale container networks failed, docker network prune fail with exit code {networkPruneExitCode}");
80              }
81              executionContext.Output("##[endgroup]");
82              executionContext.Output("##[group]Create local container network");
83              var containerNetwork = $"github_network_{Guid.NewGuid().ToString("N")}";
84              await CreateContainerNetworkAsync(executionContext, containerNetwork);
85              executionContext.JobContext.Container["network"] = new StringContextData(containerNetwork);
86              executionContext.Output("##[endgroup]");
87              foreach (var container in containers)
88              {
89                  container.ContainerNetwork = containerNetwork;
90                  await StartContainerAsync(executionContext, container);
91              }
92              await RunContainersHealthcheck(executionContext, containers);
93          }
94          public async Task RunContainersHealthcheck(IExecutionContext executionContext, List<ContainerInfo> containers)
95          {
96              executionContext.Output("##[group]Waiting for all services to be ready");
97              var unhealthyContainers = new List<ContainerInfo>();
98              foreach (var container in containers.Where(c => !c.IsJobContainer))
99              {
100                  var healthy_container = await ContainerHealthcheck(executionContext, container);
101                  if (!healthy_container)
102                  {
103                      unhealthyContainers.Add(container);
104                  }
105                  else
106                  {
107                      executionContext.Output($"{container.ContainerNetworkAlias} service is healthy.");
108                  }
109              }
110              executionContext.Output("##[endgroup]");
111              if (unhealthyContainers.Count > 0)
112              {
113                  foreach (var container in unhealthyContainers)
114                  {
115                      executionContext.Output($"##[group]Service container {container.ContainerNetworkAlias} failed.");
116                      await _dockerManager.DockerLogs(context: executionContext, containerId: container.ContainerId);
117                      executionContext.Error($"Failed to initialize container {container.ContainerImage}");
118                      container.FailedInitialization = true;
119                      executionContext.Output("##[endgroup]");
120                  }
121                  throw new InvalidOperationException("One or more containers failed to start.");
122              }
123          }
124          public async Task StopContainersAsync(IExecutionContext executionContext, object data)
125          {
126              Trace.Entering();
127              ArgUtil.NotNull(executionContext, nameof(executionContext));
<span onclick='openModal()' class='match'>128              List<ContainerInfo> containers = data as List<ContainerInfo>;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
</span>131              {
132                  await _containerHookManager.CleanupJobAsync(executionContext, containers);
133                  return;
134              }
135              foreach (var container in containers)
136              {
137                  await StopContainerAsync(executionContext, container);
138              }
139              await RemoveContainerNetworkAsync(executionContext, containers.First().ContainerNetwork);
140          }
141          private async Task StartContainerAsync(IExecutionContext executionContext, ContainerInfo container)
142          {
143              Trace.Entering();
144              ArgUtil.NotNull(executionContext, nameof(executionContext));
145              ArgUtil.NotNull(container, nameof(container));
146              ArgUtil.NotNullOrEmpty(container.ContainerImage, nameof(container.ContainerImage));
147              Trace.Info($"Container name: {container.ContainerName}");
148              Trace.Info($"Container image: {container.ContainerImage}");
149              Trace.Info($"Container options: {container.ContainerCreateOptions}");
150              var groupName = container.IsJobContainer ? "Starting job container" : $"Starting {container.ContainerNetworkAlias} service container";
151              executionContext.Output($"##[group]{groupName}");
152              foreach (var port in container.UserPortMappings)
153              {
154                  Trace.Info($"User provided port: {port.Value}");
155              }
156              foreach (var mount in container.UserMountVolumes)
157              {
158                  Trace.Info($"User provided volume: {mount.UserProvidedValue}");
159                  if (string.Equals(mount.SourceVolumePath, "/", StringComparison.OrdinalIgnoreCase))
160                  {
161                      executionContext.Warning($"Volume mount {mount.UserProvidedValue} is going to mount '/' into the container which may cause file ownership change in the entire file system and cause Actions Runner to lose permission to access the disk.");
162                  }
163              }
164              UpdateRegistryAuthForGitHubToken(executionContext, container);
165              var configLocation = await ContainerRegistryLogin(executionContext, container);
166              int retryCount = 0;
167              int pullExitCode = 0;
168              while (retryCount < 3)
169              {
170                  pullExitCode = await _dockerManager.DockerPull(executionContext, container.ContainerImage, configLocation);
171                  if (pullExitCode == 0)
172                  {
173                      break;
174                  }
175                  else
176                  {
177                      retryCount++;
178                      if (retryCount < 3)
179                      {
180                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
181                          executionContext.Warning($"Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
182                          await Task.Delay(backOff);
183                      }
184                  }
185              }
186              ContainerRegistryLogout(configLocation);
187              if (retryCount == 3 && pullExitCode != 0)
188              {
189                  throw new InvalidOperationException($"Docker pull failed with exit code {pullExitCode}");
190              }
191              if (container.IsJobContainer)
192              {
193                  MountWellKnownDirectories(executionContext, container);
194              }
195              container.ContainerId = await _dockerManager.DockerCreate(executionContext, container);
196              ArgUtil.NotNullOrEmpty(container.ContainerId, nameof(container.ContainerId));
197              int startExitCode = await _dockerManager.DockerStart(executionContext, container.ContainerId);
198              if (startExitCode != 0)
199              {
200                  throw new InvalidOperationException($"Docker start fail with exit code {startExitCode}");
201              }
202              try
203              {
204                  var psOutputs = await _dockerManager.DockerPS(executionContext, $"--all --filter id={container.ContainerId} --filter status=running --no-trunc --format \"{{{{.ID}}}} {{{{.Status}}}}\"");
205                  if (psOutputs.FirstOrDefault(x => !string.IsNullOrEmpty(x))?.StartsWith(container.ContainerId) != true)
206                  {
207                      await _dockerManager.DockerPS(executionContext, $"--all --filter id={container.ContainerId} --no-trunc --format \"{{{{.ID}}}} {{{{.Status}}}}\"");
208                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
209                      if (logsExitCode != 0)
210                      {
211                          executionContext.Warning($"Docker logs fail with exit code {logsExitCode}");
212                      }
213                      executionContext.Warning($"Docker container {container.ContainerId} is not in running state.");
214                  }
215              }
216              catch (Exception ex)
217              {
218                  Trace.Error("Catch exception when check container log and container status.");
219                  Trace.Error(ex);
220              }
221              if (!container.IsJobContainer)
222              {
223                  var service = new DictionaryContextData()
224                  {
225                      ["id"] = new StringContextData(container.ContainerId),
226                      ["ports"] = new DictionaryContextData(),
227                      ["network"] = new StringContextData(container.ContainerNetwork)
228                  };
229                  container.AddPortMappings(await _dockerManager.DockerPort(executionContext, container.ContainerId));
230                  foreach (var port in container.PortMappings)
231                  {
232                      (service["ports"] as DictionaryContextData)[port.ContainerPort] = new StringContextData(port.HostPort);
233                  }
234                  executionContext.JobContext.Services[container.ContainerNetworkAlias] = service;
235              }
236              else
237              {
238                  var configEnvFormat = "--format \"{{range .Config.Env}}{{println .}}{{end}}\"";
239                  var containerEnv = await _dockerManager.DockerInspect(executionContext, container.ContainerId, configEnvFormat);
240                  container.ContainerRuntimePath = DockerUtil.ParsePathFromConfigEnv(containerEnv);
241                  executionContext.JobContext.Container["id"] = new StringContextData(container.ContainerId);
242              }
243              executionContext.Output("##[endgroup]");
244          }
245          private void MountWellKnownDirectories(IExecutionContext executionContext, ContainerInfo container)
246          {
247              var githubContext = executionContext.ExpressionValues["github"] as GitHubContext;
248              ArgUtil.NotNull(githubContext, nameof(githubContext));
249              var workingDirectory = githubContext["workspace"] as StringContextData;
250              ArgUtil.NotNullOrEmpty(workingDirectory, nameof(workingDirectory));
251              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Work), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Work))));
252  #if OS_WINDOWS
253                  container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals))));
254  #else
255              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals)), true));
256  #endif
257              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Temp), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Temp))));
258              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Actions), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Actions))));
259              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Tools), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Tools))));
260              var tempHomeDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), "_github_home");
261              Directory.CreateDirectory(tempHomeDirectory);
262              container.MountVolumes.Add(new MountVolume(tempHomeDirectory, "/github/home"));
263              container.AddPathTranslateMapping(tempHomeDirectory, "/github/home");
264              container.ContainerEnvironmentVariables["HOME"] = container.TranslateToContainerPath(tempHomeDirectory);
265              var tempWorkflowDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), "_github_workflow");
266              Directory.CreateDirectory(tempWorkflowDirectory);
267              container.MountVolumes.Add(new MountVolume(tempWorkflowDirectory, "/github/workflow"));
268              container.AddPathTranslateMapping(tempWorkflowDirectory, "/github/workflow");
269              container.ContainerWorkDirectory = container.TranslateToContainerPath(workingDirectory);
270              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
271              {
272                  container.ContainerEntryPoint = "tail";
273                  container.ContainerEntryPointArgs = "\"-f\" \"/dev/null\"";
274              }
275          }
276          private async Task StopContainerAsync(IExecutionContext executionContext, ContainerInfo container)
277          {
278              Trace.Entering();
279              ArgUtil.NotNull(executionContext, nameof(executionContext));
280              ArgUtil.NotNull(container, nameof(container));
281              if (!string.IsNullOrEmpty(container.ContainerId))
282              {
283                  if (!container.IsJobContainer && !container.FailedInitialization)
284                  {
285                      executionContext.Output($"Print service container logs: {container.ContainerDisplayName}");
286                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
287                      if (logsExitCode != 0)
288                      {
289                          executionContext.Warning($"Docker logs fail with exit code {logsExitCode}");
290                      }
291                  }
292                  executionContext.Output($"Stop and remove container: {container.ContainerDisplayName}");
293                  int rmExitCode = await _dockerManager.DockerRemove(executionContext, container.ContainerId);
294                  if (rmExitCode != 0)
295                  {
296                      executionContext.Warning($"Docker rm fail with exit code {rmExitCode}");
297                  }
298              }
299          }
300  #if !OS_WINDOWS
301          private async Task<List<string>> ExecuteCommandAsync(IExecutionContext context, string command, string arg)
302          {
303              context.Command($"{command} {arg}");
304              List<string> outputs = new();
305              object outputLock = new();
306              var processInvoker = HostContext.CreateService<IProcessInvoker>();
307              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
308              {
309                  if (!string.IsNullOrEmpty(message.Data))
310                  {
311                      lock (outputLock)
312                      {
313                          outputs.Add(message.Data);
314                      }
315                  }
316              };
317              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
318              {
319                  if (!string.IsNullOrEmpty(message.Data))
320                  {
321                      lock (outputLock)
322                      {
323                          outputs.Add(message.Data);
324                      }
325                  }
326              };
327              await processInvoker.ExecuteAsync(
328                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
329                              fileName: command,
330                              arguments: arg,
331                              environment: null,
332                              requireExitCodeZero: true,
333                              outputEncoding: null,
334                              cancellationToken: CancellationToken.None);
335              foreach (var outputLine in outputs)
336              {
337                  context.Output(outputLine);
338              }
339              return outputs;
340          }
341  #endif
342          private async Task CreateContainerNetworkAsync(IExecutionContext executionContext, string network)
343          {
344              Trace.Entering();
345              ArgUtil.NotNull(executionContext, nameof(executionContext));
346              int networkExitCode = await _dockerManager.DockerNetworkCreate(executionContext, network);
347              if (networkExitCode != 0)
348              {
349                  throw new InvalidOperationException($"Docker network create failed with exit code {networkExitCode}");
350              }
351          }
352          private async Task RemoveContainerNetworkAsync(IExecutionContext executionContext, string network)
353          {
354              Trace.Entering();
355              ArgUtil.NotNull(executionContext, nameof(executionContext));
356              ArgUtil.NotNull(network, nameof(network));
357              executionContext.Output($"Remove container network: {network}");
358              int removeExitCode = await _dockerManager.DockerNetworkRemove(executionContext, network);
359              if (removeExitCode != 0)
360              {
361                  executionContext.Warning($"Docker network rm failed with exit code {removeExitCode}");
362              }
363          }
364          private async Task<bool> ContainerHealthcheck(IExecutionContext executionContext, ContainerInfo container)
365          {
366              string healthCheck = "--format=\"{{if .Config.Healthcheck}}{{print .State.Health.Status}}{{end}}\"";
367              string serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
368              if (string.IsNullOrEmpty(serviceHealth))
369              {
370                  return true;
371              }
372              var retryCount = 0;
373              while (string.Equals(serviceHealth, "starting", StringComparison.OrdinalIgnoreCase))
374              {
375                  TimeSpan backoff = BackoffTimerHelper.GetExponentialBackoff(retryCount, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(32), TimeSpan.FromSeconds(2));
376                  executionContext.Output($"{container.ContainerNetworkAlias} service is starting, waiting {backoff.Seconds} seconds before checking again.");
377                  await Task.Delay(backoff, executionContext.CancellationToken);
378                  serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
379                  retryCount++;
380              }
381              return string.Equals(serviceHealth, "healthy", StringComparison.OrdinalIgnoreCase);
382          }
383          private async Task<string> ContainerRegistryLogin(IExecutionContext executionContext, ContainerInfo container)
384          {
385              if (string.IsNullOrEmpty(container.RegistryAuthUsername) || string.IsNullOrEmpty(container.RegistryAuthPassword))
386              {
387                  return "";
388              }
389              var configLocation = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), $".docker_{Guid.NewGuid()}");
390              try
391              {
392                  var dirInfo = Directory.CreateDirectory(configLocation);
393              }
394              catch (Exception e)
395              {
396                  throw new InvalidOperationException($"Failed to create directory to store registry client credentials: {e.Message}");
397              }
398              var loginExitCode = await _dockerManager.DockerLogin(
399                  executionContext,
400                  configLocation,
401                  container.RegistryServer,
402                  container.RegistryAuthUsername,
403                  container.RegistryAuthPassword);
404              if (loginExitCode != 0)
405              {
406                  throw new InvalidOperationException($"Docker login for '{container.RegistryServer}' failed with exit code {loginExitCode}");
407              }
408              return configLocation;
409          }
410          private void ContainerRegistryLogout(string configLocation)
411          {
412              try
413              {
414                  if (!string.IsNullOrEmpty(configLocation) && Directory.Exists(configLocation))
415                  {
416                      Directory.Delete(configLocation, recursive: true);
417                  }
418              }
419              catch (Exception e)
420              {
421                  throw new InvalidOperationException($"Failed to remove directory containing Docker client credentials: {e.Message}");
422              }
423          }
424          private void UpdateRegistryAuthForGitHubToken(IExecutionContext executionContext, ContainerInfo container)
425          {
426              var registryIsTokenCompatible = container.RegistryServer.Equals("ghcr.io", StringComparison.OrdinalIgnoreCase) || container.RegistryServer.Equals("containers.pkg.github.com", StringComparison.OrdinalIgnoreCase);
427              var isFallbackTokenFromHostedGithub = HostContext.GetService<IConfigurationStore>().GetSettings().IsHostedServer;
428              if (!registryIsTokenCompatible || !isFallbackTokenFromHostedGithub)
429              {
430                  return;
431              }
432              var registryCredentialsNotSupplied = string.IsNullOrEmpty(container.RegistryAuthUsername) && string.IsNullOrEmpty(container.RegistryAuthPassword);
433              if (registryCredentialsNotSupplied)
434              {
435                  container.RegistryAuthUsername = executionContext.GetGitHubContext("actor");
436                  container.RegistryAuthPassword = executionContext.GetGitHubContext("token");
437              }
438          }
439          private async Task AssertCompatibleOS(IExecutionContext executionContext)
440          {
441  #if OS_WINDOWS
442  #pragma warning disable CA1416
443              ServiceController[] scServices = ServiceController.GetServices();
444              if (scServices.Any(x => String.Equals(x.ServiceName, "cexecsvc", StringComparison.OrdinalIgnoreCase) && x.Status == ServiceControllerStatus.Running))
445              {
446                  throw new NotSupportedException("Container feature is not supported when runner is already running inside container.");
447              }
448  #pragma warning restore CA1416
449  #else
450              var initProcessCgroup = File.ReadLines("/proc/1/cgroup");
451              if (initProcessCgroup.Any(x => x.IndexOf(":/docker/", StringComparison.OrdinalIgnoreCase) >= 0))
452              {
453                  throw new NotSupportedException("Container feature is not supported when runner is already running inside container.");
454              }
455  #endif
456  #if OS_WINDOWS
457  #pragma warning disable CA1416
458              object windowsInstallationType = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "InstallationType", defaultValue: null);
459              ArgUtil.NotNull(windowsInstallationType, nameof(windowsInstallationType));
460              object windowsReleaseId = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ReleaseId", defaultValue: null);
461              ArgUtil.NotNull(windowsReleaseId, nameof(windowsReleaseId));
462              executionContext.Debug($"Current Windows version: '{windowsReleaseId} ({windowsInstallationType})'");
463              if (int.TryParse(windowsReleaseId.ToString(), out int releaseId))
464              {
465                  if (!windowsInstallationType.ToString().StartsWith("Server", StringComparison.OrdinalIgnoreCase) || releaseId < 1803)
466                  {
467                      throw new NotSupportedException("Container feature requires Windows Server 1803 or higher.");
468                  }
469              }
470              else
471              {
472                  throw new ArgumentOutOfRangeException(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId");
473              }
474  #pragma warning restore CA1416
475  #endif
476              executionContext.Output("##[group]Checking docker version");
477              DockerVersion dockerVersion = await _dockerManager.DockerVersion(executionContext);
478              executionContext.Output("##[endgroup]");
479              ArgUtil.NotNull(dockerVersion.ServerVersion, nameof(dockerVersion.ServerVersion));
480              ArgUtil.NotNull(dockerVersion.ClientVersion, nameof(dockerVersion.ClientVersion));
481  #if OS_WINDOWS
482              Version requiredDockerEngineAPIVersion = new Version(1, 30);  
483  #else
484              Version requiredDockerEngineAPIVersion = new(1, 35); 
485  #endif
486              if (dockerVersion.ServerVersion < requiredDockerEngineAPIVersion)
487              {
488                  throw new NotSupportedException($"Min required docker engine API server version is '{requiredDockerEngineAPIVersion}', your docker ('{_dockerManager.DockerPath}') server version is '{dockerVersion.ServerVersion}'");
489              }
490              if (dockerVersion.ClientVersion < requiredDockerEngineAPIVersion)
491              {
492                  throw new NotSupportedException($"Min required docker engine API client version is '{requiredDockerEngineAPIVersion}', your docker ('{_dockerManager.DockerPath}') client version is '{dockerVersion.ClientVersion}'");
493              }
494          }
495      }
496  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</div>
                </div>
                <div class="column column_space"><pre><code>128              List<ContainerInfo> containers = data as List<ContainerInfo>;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
</pre></code></div>
                <div class="column column_space"><pre><code>128              List<ContainerInfo> containers = data as List<ContainerInfo>;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    