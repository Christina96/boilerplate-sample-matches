
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.624277456647398%, Tokens: 12</h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobResources.cs</h3>
            <pre><code>1  using System.Collections.Generic;
2  using System.ComponentModel;
3  using System.Runtime.Serialization;
4  using GitHub.DistributedTask.WebApi;
5  namespace GitHub.DistributedTask.Pipelines
6  {
7      [DataContract]
8      [EditorBrowsable(EditorBrowsableState.Never)]
9      public sealed class JobResources
10      {
11          public List<ContainerResource> Containers
12          {
13              get
14              {
15                  if (m_containers == null)
16                  {
17                      m_containers = new List<ContainerResource>();
18                  }
19                  return m_containers;
20              }
21          }
22          public List<ServiceEndpoint> Endpoints
23          {
24              get
25              {
26                  if (m_endpoints == null)
27                  {
28                      m_endpoints = new List<ServiceEndpoint>();
29                  }
30                  return m_endpoints;
31              }
32          }
33          public List<RepositoryResource> Repositories
34          {
35              get
36              {
37                  if (m_repositories == null)
38                  {
39                      m_repositories = new List<RepositoryResource>();
40                  }
41                  return m_repositories;
42              }
43          }
44          [OnSerializing]
45          private void OnSerializing(StreamingContext context)
46          {
<span onclick='openModal()' class='match'>47              if (m_containers?.Count == 0)
48              {
49                  m_containers = null;
50              }
51              if (m_endpoints?.Count == 0)
52              {
53                  m_endpoints = null;
54              }
55              if (m_repositories?.Count == 0)
56              {
57                  m_repositories = null;
58              }
</span>59          }
60          [DataMember(Name = "Containers", EmitDefaultValue = false)]
61          private List<ContainerResource> m_containers;
62          [DataMember(Name = "Endpoints", EmitDefaultValue = false)]
63          private List<ServiceEndpoint> m_endpoints;
64          [DataMember(Name = "Repositories", EmitDefaultValue = false)]
65          private List<RepositoryResource> m_repositories;
66      }
67  }
</code></pre>
        </div>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-Sequence.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using DG.Tweening.Core;
4  using DG.Tweening.Core.Easing;
5  using DG.Tweening.Core.Enums;
6  using UnityEngine;
7  namespace DG.Tweening
8  {
9      public sealed class Sequence : Tween
10      {
11          internal readonly List<Tween> sequencedTweens = new List<Tween>(); 
12          readonly List<ABSSequentiable> _sequencedObjs = new List<ABSSequentiable>(); 
13          internal float lastTweenInsertTime; 
14          #region Constructor
15          internal Sequence()
16          {
17              tweenType = TweenType.Sequence;
18              Reset();
19          }
20          #endregion
21          #region Creation Methods
22          internal static Sequence DoPrepend(Sequence inSequence, Tween t)
23          {
24              if (t.loops == -1) {
25                  t.loops = int.MaxValue;
26                  Debugger.LogWarning("Infinite loops aren't allowed inside a Sequence (only on the Sequence itself) and will be changed to int.MaxValue", t);
27              }
28              float tFullTime = t.delay + (t.duration * t.loops);
29              inSequence.duration += tFullTime;
30              int len = inSequence._sequencedObjs.Count;
31              for (int i = 0; i < len; ++i) {
32                  ABSSequentiable sequentiable = inSequence._sequencedObjs[i];
33                  sequentiable.sequencedPosition += tFullTime;
34                  sequentiable.sequencedEndPosition += tFullTime;
35              }
36              return DoInsert(inSequence, t, 0);
37          }
38          internal static Sequence DoInsert(Sequence inSequence, Tween t, float atPosition)
39          {
40              TweenManager.AddActiveTweenToSequence(t);
41              atPosition += t.delay;
42              inSequence.lastTweenInsertTime = atPosition;
43              t.isSequenced = t.creationLocked = true;
44              t.sequenceParent = inSequence;
45              if (t.loops == -1) {
46                  t.loops = int.MaxValue;
47                  Debugger.LogWarning("Infinite loops aren't allowed inside a Sequence (only on the Sequence itself) and will be changed to int.MaxValue", t);
48              }
49              float tFullTime = t.duration * t.loops;
50              t.autoKill = false;
51              t.delay = t.elapsedDelay = 0;
52              t.delayComplete = true;
53              if (t.isSpeedBased) {
54                  t.isSpeedBased = false;
55                  Debugger.LogWarning("SpeedBased tweens are not allowed inside a Sequence: interpreting speed as duration", t);
56              }
57              t.sequencedPosition = atPosition;
58              t.sequencedEndPosition = atPosition + tFullTime;
59              if (t.sequencedEndPosition > inSequence.duration) inSequence.duration = t.sequencedEndPosition;
60              inSequence._sequencedObjs.Add(t);
61              inSequence.sequencedTweens.Add(t);
62              return inSequence;
63          }
64          internal static Sequence DoAppendInterval(Sequence inSequence, float interval)
65          {
66              inSequence.lastTweenInsertTime = inSequence.duration;
67              inSequence.duration += interval;
68              return inSequence;
69          }
70          internal static Sequence DoPrependInterval(Sequence inSequence, float interval)
71          {
72              inSequence.lastTweenInsertTime = 0;
73              inSequence.duration += interval;
74              int len = inSequence._sequencedObjs.Count;
75              for (int i = 0; i < len; ++i) {
76                  ABSSequentiable sequentiable = inSequence._sequencedObjs[i];
77                  sequentiable.sequencedPosition += interval;
78                  sequentiable.sequencedEndPosition += interval;
79              }
80              return inSequence;
81          }
82          internal static Sequence DoInsertCallback(Sequence inSequence, TweenCallback callback, float atPosition)
83          {
84              inSequence.lastTweenInsertTime = atPosition;
85              SequenceCallback c = new SequenceCallback(atPosition, callback);
86              c.sequencedPosition = c.sequencedEndPosition = atPosition;
87              inSequence._sequencedObjs.Add(c);
88              if (inSequence.duration < atPosition) inSequence.duration = atPosition;
89              return inSequence;
90          }
91          #endregion
92          internal override float UpdateDelay(float elapsed)
93          {
94              float tweenDelay = delay;
95              if (elapsed > tweenDelay) {
96                  elapsedDelay = tweenDelay;
97                  delayComplete = true;
98                  return elapsed - tweenDelay;
99              }
100              elapsedDelay = elapsed;
101              return 0;
102          }
103          internal override void Reset()
104          {
105              base.Reset();
106              sequencedTweens.Clear();
107              _sequencedObjs.Clear();
108              lastTweenInsertTime = 0;
109          }
110          internal override bool Validate()
111          {
112              int len = sequencedTweens.Count;
113              for (int i = 0; i < len; i++) {
114                  if (!sequencedTweens[i].Validate()) return false;
115              }
116              return true;
117          }
118          internal override bool Startup()
119          {
120              return DoStartup(this);
121          }
122          internal override bool ApplyTween(float prevPosition, int prevCompletedLoops, int newCompletedSteps, bool useInversePosition, UpdateMode updateMode, UpdateNotice updateNotice)
123          {
124              return DoApplyTween(this, prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode);
125          }
126          internal static void Setup(Sequence s)
127          {
128              s.autoKill = DOTween.defaultAutoKill;
129              s.isRecyclable = DOTween.defaultRecyclable;
130              s.isPlaying = DOTween.defaultAutoPlay == AutoPlay.All || DOTween.defaultAutoPlay == AutoPlay.AutoPlaySequences;
131              s.loopType = DOTween.defaultLoopType;
132              s.easeType = Ease.Linear;
133              s.easeOvershootOrAmplitude = DOTween.defaultEaseOvershootOrAmplitude;
134              s.easePeriod = DOTween.defaultEasePeriod;
135          }
136          internal static bool DoStartup(Sequence s)
137          {
138              int sequencedObjsLen = s._sequencedObjs.Count;
139              if (s.sequencedTweens.Count == 0 && sequencedObjsLen == 0 && !IsAnyCallbackSet(s)) {
140                  return false; 
141              }
142              s.startupDone = true;
143              s.fullDuration = s.loops > -1 ? s.duration * s.loops : Mathf.Infinity;
144              StableSortSequencedObjs(s._sequencedObjs);
145              if (s.isRelative) {
146                  for (int len = s.sequencedTweens.Count, i = 0; i < len; ++i) {
147                      Tween t = s.sequencedTweens[i];
148                      if (!s.isBlendable) s.sequencedTweens[i].isRelative = true;
149                  }
150              }
151              if (s.isInverted) {
152                  for (int i = 0; i < sequencedObjsLen; i++) {
153                      ABSSequentiable sequentiable = s._sequencedObjs[i];
154                      if (sequentiable.tweenType == TweenType.Tweener) {
155                          Tween t = (Tween)sequentiable;
156                          TweenManager.Goto(t, t.duration * t.loops, false, UpdateMode.IgnoreOnComplete);
157                          t.isInverted = true;
158                      }
159                  }
160              }
161              return true;
162          }
163          internal static bool DoApplyTween(Sequence s, float prevPosition, int prevCompletedLoops, int newCompletedSteps, bool useInversePosition, UpdateMode updateMode)
164          {
165              float prevPos = prevPosition;
166              float newPos = s.position;
167              if (s.isInverted) useInversePosition = !useInversePosition;
168              if (s.easeType != Ease.Linear) {
169                  prevPos = s.duration * EaseManager.Evaluate(s.easeType, s.customEase, prevPos, s.duration, s.easeOvershootOrAmplitude, s.easePeriod);
170                  newPos = s.duration * EaseManager.Evaluate(s.easeType, s.customEase, newPos, s.duration, s.easeOvershootOrAmplitude, s.easePeriod);
171              }
172              float from, to = 0;
173              bool prevPosIsInverse = (s.loops == -1 || s.loops > 1) && s.loopType == LoopType.Yoyo
174                  && (prevPos < s.duration ? prevCompletedLoops % 2 != 0 : prevCompletedLoops % 2 == 0);
175              if (s.isBackwards) prevPosIsInverse = !prevPosIsInverse;
176              if (s.isInverted) prevPosIsInverse = !prevPosIsInverse;
177              if (newCompletedSteps > 0) {
178                  int expectedCompletedLoops = s.completedLoops;
179                  float expectedPosition = s.position;
180                  int cycles = newCompletedSteps;
181                  int cyclesDone = 0;
182                  from = prevPos;
183                  if (updateMode == UpdateMode.Update) {
184                      while (cyclesDone < cycles) {
185                          if (cyclesDone > 0) from = to;
186                          else if (prevPosIsInverse && !s.isBackwards) from = s.duration - from;
187                          to = prevPosIsInverse ? 0 : s.duration;
188                          if (ApplyInternalCycle(s, from, to, updateMode, useInversePosition, prevPosIsInverse, true)) return true;
189                          cyclesDone++;
190                          if (s.hasLoops && s.loopType == LoopType.Yoyo) prevPosIsInverse = !prevPosIsInverse;
191                      }
192                      if (expectedCompletedLoops != s.completedLoops || Math.Abs(expectedPosition - s.position) > Single.Epsilon) return !s.active;
193                  } else {
194                      if (s.hasLoops && s.loopType == LoopType.Yoyo && newCompletedSteps % 2 != 0) {
195                          prevPosIsInverse = !prevPosIsInverse;
196                          prevPos = s.duration - prevPos;
197                      }
198                      newCompletedSteps = 0;
199                  }
200              }
201              if (newCompletedSteps == 1 && s.isComplete) return false; 
202              if (newCompletedSteps > 0 && !s.isComplete) {
203                  from = useInversePosition ? s.duration : 0;
204                  if (s.loopType == LoopType.Restart && to > 0) ApplyInternalCycle(s, s.duration, 0, UpdateMode.Goto, false, false, false);
205              } else from = useInversePosition ? s.duration - prevPos : prevPos;
206              return ApplyInternalCycle(s, from, useInversePosition ? s.duration - newPos : newPos, updateMode, useInversePosition, prevPosIsInverse);
207          }
208          static bool ApplyInternalCycle(Sequence s, float fromPos, float toPos, UpdateMode updateMode, bool useInverse, bool prevPosIsInverse, bool multiCycleStep = false)
209          {
210              bool wasPlaying = s.isPlaying; 
211              bool isBackwardsUpdate = toPos < fromPos;
212              if (isBackwardsUpdate) {
213                  int len = s._sequencedObjs.Count - 1;
214                  for (int i = len; i > -1; --i) {
215                      if (!s.active) return true; 
216                      if (!s.isPlaying && wasPlaying) return false; 
217                      ABSSequentiable sequentiable = s._sequencedObjs[i];
218                      if (sequentiable.sequencedEndPosition < toPos || sequentiable.sequencedPosition > fromPos) continue;
219                      if (sequentiable.tweenType == TweenType.Callback) {
220                          if (updateMode == UpdateMode.Update && prevPosIsInverse) {
221                              OnTweenCallback(sequentiable.onStart, s);
222                          }
223                      } else {
224                          float gotoPos = toPos - sequentiable.sequencedPosition;
225                          if (gotoPos < 0) gotoPos = 0;
226                          Tween t = (Tween)sequentiable;
227                          if (!t.startupDone) continue; 
228                          t.isBackwards = true;
229                          if (s.isInverted) gotoPos = t.fullDuration - gotoPos;
230                          if (TweenManager.Goto(t, gotoPos, false, updateMode)) {
231                              if (DOTween.nestedTweenFailureBehaviour == NestedTweenFailureBehaviour.KillWholeSequence) return true;
232                              if (s.sequencedTweens.Count == 1 && s._sequencedObjs.Count == 1 && !IsAnyCallbackSet(s)) return true;
233                              TweenManager.Despawn(t, false);
234                              s._sequencedObjs.RemoveAt(i);
235                              s.sequencedTweens.Remove(t);
236                              --i; --len;
237                              continue;
238                          }
239                          if (multiCycleStep && t.tweenType == TweenType.Sequence) {
240                              if (s.position <= 0 && s.completedLoops == 0) t.position = 0;
241                              else {
242                                  bool toZero = s.completedLoops == 0 || s.isBackwards && (s.completedLoops < s.loops || s.loops == -1);
<span onclick='openModal()' class='match'>243                                  if (t.isBackwards) toZero = !toZero;
244                                  if (useInverse) toZero = !toZero;
245                                  if (s.isBackwards && !useInverse && !prevPosIsInverse) toZero = !toZero;
</span>246                                  t.position = toZero ? 0 : t.duration;
247                              }
248                          }
249                      }
250                  }
251              } else {
252                  int len = s._sequencedObjs.Count;
253                  for (int i = 0; i < len; ++i) {
254                      if (!s.active) return true; 
255                      if (!s.isPlaying && wasPlaying) return false; 
256                      ABSSequentiable sequentiable = s._sequencedObjs[i];
257                      if (
258                          sequentiable.sequencedPosition > toPos
259                          || sequentiable.sequencedPosition > 0 && sequentiable.sequencedEndPosition <= fromPos
260                          || sequentiable.sequencedPosition <= 0 && sequentiable.sequencedEndPosition < fromPos
261                      ) continue;
262                      if (sequentiable.tweenType == TweenType.Callback) {
263                          if (updateMode == UpdateMode.Update) {
264                              bool fire = !s.isBackwards && !useInverse && !prevPosIsInverse
265                                  || s.isBackwards && useInverse && !prevPosIsInverse;
266                              if (fire) OnTweenCallback(sequentiable.onStart, s);
267                          }
268                      } else {
269                          float gotoPos = toPos - sequentiable.sequencedPosition;
270                          if (gotoPos < 0) gotoPos = 0;
271                          Tween t = (Tween)sequentiable;
272                          if (toPos >= sequentiable.sequencedEndPosition) {
273                              if (!t.startupDone) TweenManager.ForceInit(t, true);
274                              if (gotoPos < t.fullDuration) gotoPos = t.fullDuration;
275                          }
276                          t.isBackwards = false;
277                          if (s.isInverted) gotoPos = t.fullDuration - gotoPos;
278                          if (TweenManager.Goto(t, gotoPos, false, updateMode)) {
279                              if (DOTween.nestedTweenFailureBehaviour == NestedTweenFailureBehaviour.KillWholeSequence) return true;
280                              if (s.sequencedTweens.Count == 1 && s._sequencedObjs.Count == 1 && !IsAnyCallbackSet(s)) return true;
281                              TweenManager.Despawn(t, false);
282                              s._sequencedObjs.RemoveAt(i);
283                              s.sequencedTweens.Remove(t);
284                              --i; --len;
285                              continue;
286                          }
287                          if (multiCycleStep && t.tweenType == TweenType.Sequence) {
288                              if (s.position <= 0 && s.completedLoops == 0) t.position = 0;
289                              else {
290                                  bool toZero = s.completedLoops == 0 || !s.isBackwards && (s.completedLoops < s.loops || s.loops == -1);
291                                  if (t.isBackwards) toZero = !toZero;
292                                  if (useInverse) toZero = !toZero;
293                                  if (s.isBackwards && !useInverse && !prevPosIsInverse) toZero = !toZero;
294                                  t.position = toZero ? 0 : t.duration;
295                              }
296                          }
297                      }
298                  }
299              }
300              return false;
301          }
302          static void StableSortSequencedObjs(List<ABSSequentiable> list)
303          {
304              int len = list.Count;
305              for (int i = 1; i < len; i++) {
306                  int j = i;
307                  ABSSequentiable temp = list[i];
308                  while (j > 0 && list[j - 1].sequencedPosition > temp.sequencedPosition) {
309                      list[j] = list[j - 1];
310                      j = j - 1;
311                  }
312                  list[j] = temp;
313              }
314          }
315          static bool IsAnyCallbackSet(Sequence s)
316          {
317              return s.onComplete != null || s.onKill != null || s.onPause != null || s.onPlay != null || s.onRewind != null
318                     || s.onStart != null || s.onStepComplete != null || s.onUpdate != null;
319          }
320      }
321  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobResources.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-Sequence.cs</div>
                <div class="column column_space"><pre><code>47              if (m_containers?.Count == 0)
48              {
49                  m_containers = null;
50              }
51              if (m_endpoints?.Count == 0)
52              {
53                  m_endpoints = null;
54              }
55              if (m_repositories?.Count == 0)
56              {
57                  m_repositories = null;
58              }
</pre></code></div>
                <div class="column column_space"><pre><code>243                                  if (t.isBackwards) toZero = !toZero;
244                                  if (useInverse) toZero = !toZero;
245                                  if (s.isBackwards && !useInverse && !prevPosIsInverse) toZero = !toZero;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    