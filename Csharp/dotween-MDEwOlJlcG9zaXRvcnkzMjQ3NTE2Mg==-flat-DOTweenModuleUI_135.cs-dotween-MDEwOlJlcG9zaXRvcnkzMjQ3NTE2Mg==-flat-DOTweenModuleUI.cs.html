
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 567, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DOTweenModuleUI_135.cs</h3>
            <pre><code>1  #if true && (UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER) 
2  using System;
3  using System.Globalization;
4  using UnityEngine;
5  using UnityEngine.UI;
6  using DG.Tweening.Core;
7  using DG.Tweening.Core.Enums;
8  using DG.Tweening.Plugins;
9  using DG.Tweening.Plugins.Options;
10  using Outline = UnityEngine.UI.Outline;
11  using Text = UnityEngine.UI.Text;
12  #pragma warning disable 1591
13  namespace DG.Tweening
14  {
15  	public static class DOTweenModuleUI
16      {
17          #region Shortcuts
18          #region CanvasGroup
19          public static TweenerCore<float, float, FloatOptions> DOFade(this CanvasGroup target, float endValue, float duration)
20          {
21              TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.alpha, x => target.alpha = x, endValue, duration);
22              t.SetTarget(target);
23              return t;
24          }
25          #endregion
26          #region Graphic
27          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Graphic target, Color endValue, float duration)
28          {
29              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
30              t.SetTarget(target);
31              return t;
32          }
33          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Graphic target, float endValue, float duration)
34          {
35              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
36              t.SetTarget(target);
37              return t;
38          }
39          #endregion
40          #region Image
41          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Image target, Color endValue, float duration)
42          {
43              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
44              t.SetTarget(target);
45              return t;
46          }
47          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Image target, float endValue, float duration)
48          {
49              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
50              t.SetTarget(target);
51              return t;
52          }
53          public static TweenerCore<float, float, FloatOptions> DOFillAmount(this Image target, float endValue, float duration)
54          {
55              if (endValue > 1) endValue = 1;
56              else if (endValue < 0) endValue = 0;
57              TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.fillAmount, x => target.fillAmount = x, endValue, duration);
58              t.SetTarget(target);
59              return t;
60          }
61          public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
62          {
63              Sequence s = DOTween.Sequence();
64              GradientColorKey[] colors = gradient.colorKeys;
65              int len = colors.Length;
66              for (int i = 0; i < len; ++i) {
67                  GradientColorKey c = colors[i];
68                  if (i == 0 && c.time <= 0) {
69                      target.color = c.color;
70                      continue;
71                  }
72                  float colorDuration = i == len - 1
73                      ? duration - s.Duration(false) 
74                      : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
75                  s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
76              }
77              s.SetTarget(target);
78              return s;
79          }
80          #endregion
81          #region LayoutElement
82          public static TweenerCore<Vector2, Vector2, VectorOptions> DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
83          {
84              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), x => {
85                      target.flexibleWidth = x.x;
86                      target.flexibleHeight = x.y;
87                  }, endValue, duration);
88              t.SetOptions(snapping).SetTarget(target);
89              return t;
90          }
91          public static TweenerCore<Vector2, Vector2, VectorOptions> DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
92          {
93              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.minWidth, target.minHeight), x => {
94                  target.minWidth = x.x;
95                  target.minHeight = x.y;
96              }, endValue, duration);
97              t.SetOptions(snapping).SetTarget(target);
98              return t;
99          }
100          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
101          {
102              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), x => {
103                  target.preferredWidth = x.x;
104                  target.preferredHeight = x.y;
105              }, endValue, duration);
106              t.SetOptions(snapping).SetTarget(target);
107              return t;
108          }
109          #endregion
110          #region Outline
111          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Outline target, Color endValue, float duration)
112          {
113              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.effectColor, x => target.effectColor = x, endValue, duration);
114              t.SetTarget(target);
115              return t;
116          }
117          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Outline target, float endValue, float duration)
118          {
119              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.effectColor, x => target.effectColor = x, endValue, duration);
120              t.SetTarget(target);
121              return t;
122          }
123          public static TweenerCore<Vector2, Vector2, VectorOptions> DOScale(this Outline target, Vector2 endValue, float duration)
124          {
125              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.effectDistance, x => target.effectDistance = x, endValue, duration);
126              t.SetTarget(target);
127              return t;
128          }
129          #endregion
130          #region RectTransform
131          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
132          {
133              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, endValue, duration);
134              t.SetOptions(snapping).SetTarget(target);
135              return t;
136          }
137          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
138          {
139              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue, 0), duration);
140              t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
141              return t;
142          }
143          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
144          {
145              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, endValue), duration);
146              t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
147              return t;
148          }
149          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
150          {
151              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, endValue, duration);
152              t.SetOptions(snapping).SetTarget(target);
153              return t;
154          }
155          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
156          {
157              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(endValue, 0, 0), duration);
158              t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
159              return t;
160          }
161          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
162          {
163              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, endValue, 0), duration);
164              t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
165              return t;
166          }
167          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
168          {
169              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, 0, endValue), duration);
170              t.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
171              return t;
172          }
173          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
174          {
175              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMax, x => target.anchorMax = x, endValue, duration);
176              t.SetOptions(snapping).SetTarget(target);
177              return t;
178          }
179          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
180          {
181              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMin, x => target.anchorMin = x, endValue, duration);
182              t.SetOptions(snapping).SetTarget(target);
183              return t;
184          }
185          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivot(this RectTransform target, Vector2 endValue, float duration)
186          {
187              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, endValue, duration);
188              t.SetTarget(target);
189              return t;
190          }
191          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotX(this RectTransform target, float endValue, float duration)
192          {
193              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(endValue, 0), duration);
194              t.SetOptions(AxisConstraint.X).SetTarget(target);
195              return t;
196          }
197          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotY(this RectTransform target, float endValue, float duration)
198          {
199              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(0, endValue), duration);
200              t.SetOptions(AxisConstraint.Y).SetTarget(target);
201              return t;
202          }
203          public static TweenerCore<Vector2, Vector2, VectorOptions> DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
204          {
205              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.sizeDelta, x => target.sizeDelta = x, endValue, duration);
206              t.SetOptions(snapping).SetTarget(target);
207              return t;
208          }
209          public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1, bool snapping = false)
210          {
211              return DOTween.Punch(() => target.anchoredPosition, x => target.anchoredPosition = x, punch, duration, vibrato, elasticity)
212                  .SetTarget(target).SetOptions(snapping);
213          }
214          public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true, ShakeRandomnessMode randomnessMode = ShakeRandomnessMode.Full)
215          {
216              return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode)
217                  .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
218          }
219          public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true, ShakeRandomnessMode randomnessMode = ShakeRandomnessMode.Full)
220          {
221              return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, fadeOut, randomnessMode)
222                  .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
223          }
224          #region Special
225          public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
226          {
227              if (numJumps < 1) numJumps = 1;
228              float startPosY = 0;
229              float offsetY = -1;
230              bool offsetYSet = false;
231              Sequence s = DOTween.Sequence();
232              Tween yTween = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, jumpPower), duration / (numJumps * 2))
233                  .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
234                  .SetLoops(numJumps * 2, LoopType.Yoyo)
235                  .OnStart(()=> startPosY = target.anchoredPosition.y);
236              s.Append(DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue.x, 0), duration)
237                      .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
238                  ).Join(yTween)
239                  .SetTarget(target).SetEase(DOTween.defaultEaseType);
240              s.OnUpdate(() => {
241                  if (!offsetYSet) {
242                      offsetYSet = true;
243                      offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
244                  }
245                  Vector2 pos = target.anchoredPosition;
246                  pos.y += DOVirtual.EasedValue(0, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
247                  target.anchoredPosition = pos;
248              });
249              return s;
250          }
251          #endregion
252          #endregion
253          #region ScrollRect
254          public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
255          {
256              return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition),
257                  x => {
258                      target.horizontalNormalizedPosition = x.x;
259                      target.verticalNormalizedPosition = x.y;
260                  }, endValue, duration)
261                  .SetOptions(snapping).SetTarget(target);
262          }
263          public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
264          {
265              return DOTween.To(() => target.horizontalNormalizedPosition, x => target.horizontalNormalizedPosition = x, endValue, duration)
266                  .SetOptions(snapping).SetTarget(target);
267          }
268          public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
269          {
270              return DOTween.To(() => target.verticalNormalizedPosition, x => target.verticalNormalizedPosition = x, endValue, duration)
271                  .SetOptions(snapping).SetTarget(target);
272          }
273          #endregion
274          #region Slider
275          public static TweenerCore<float, float, FloatOptions> DOValue(this Slider target, float endValue, float duration, bool snapping = false)
276          {
277              TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.value, x => target.value = x, endValue, duration);
278              t.SetOptions(snapping).SetTarget(target);
279              return t;
280          }
281          #endregion
282          #region Text
283          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Text target, Color endValue, float duration)
284          {
285              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
286              t.SetTarget(target);
287              return t;
288          }
289          public static TweenerCore<int, int, NoOptions> DOCounter(
290              this Text target, int fromValue, int endValue, float duration, bool addThousandsSeparator = true, CultureInfo culture = null
291          ){
292              int v = fromValue;
293              CultureInfo cInfo = !addThousandsSeparator ? null : culture ?? CultureInfo.InvariantCulture;
294              TweenerCore<int, int, NoOptions> t = DOTween.To(() => v, x => {
295                  v = x;
296                  target.text = addThousandsSeparator
297                      ? v.ToString("N0", cInfo)
298                      : v.ToString();
299              }, endValue, duration);
300              t.SetTarget(target);
301              return t;
302          }
303          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Text target, float endValue, float duration)
304          {
305              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
306              t.SetTarget(target);
307              return t;
308          }
309          public static TweenerCore<string, string, StringOptions> DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
310          {
311              if (endValue == null) {
312                  if (Debugger.logPriority > 0) Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
313                  endValue = "";
314              }
<span onclick='openModal()' class='match'>315              TweenerCore<string, string, StringOptions> t = DOTween.To(() => target.text, x => target.text = x, endValue, duration);
316              t.SetOptions(richTextEnabled, scrambleMode, scrambleChars)
317                  .SetTarget(target);
318              return t;
319          }
320          #endregion
321          #region Blendables
322          #region Graphic
323          public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
324          {
325              endValue = endValue - target.color;
326              Color to = new Color(0, 0, 0, 0);
327              return DOTween.To(() => to, x => {
328                  Color diff = x - to;
329                  to = x;
330                  target.color += diff;
331              }, endValue, duration)
332                  .Blendable().SetTarget(target);
333          }
334          #endregion
335          #region Image
336          public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
337          {
338              endValue = endValue - target.color;
339              Color to = new Color(0, 0, 0, 0);
340              return DOTween.To(() => to, x => {
341                  Color diff = x - to;
342                  to = x;
343                  target.color += diff;
344              }, endValue, duration)
345                  .Blendable().SetTarget(target);
346          }
347          #endregion
348          #region Text
349          public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
350          {
351              endValue = endValue - target.color;
352              Color to = new Color(0, 0, 0, 0);
353              return DOTween.To(() => to, x => {
354                  Color diff = x - to;
355                  to = x;
356                  target.color += diff;
357              }, endValue, duration)
358                  .Blendable().SetTarget(target);
359          }
360          #endregion
361          #endregion
362          #region Shapes
363          public static TweenerCore<Vector2, Vector2, CircleOptions> DOShapeCircle(
364              this RectTransform target, Vector2 center, float endValueDegrees, float duration, bool relativeCenter = false, bool snapping = false
365          )
366          {
367              TweenerCore<Vector2, Vector2, CircleOptions> t = DOTween.To(
368                  CirclePlugin.Get(), () => target.anchoredPosition, x => target.anchoredPosition = x, center, duration
369              );
370              t.SetOptions(endValueDegrees, relativeCenter, snapping).SetTarget(target);
371              return t;
372          }
373          #endregion
374          #endregion
375          public static class Utils
376          {
377              public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
378              {
379                  Vector2 localPoint;
380                  Vector2 fromPivotDerivedOffset = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
381                  Vector2 screenP = RectTransformUtility.WorldToScreenPoint(null, from.position);
382                  screenP += fromPivotDerivedOffset;
383                  RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, out localPoint);
384                  Vector2 pivotDerivedOffset = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
385                  return to.anchoredPosition + localPoint - pivotDerivedOffset;
386              }
387          }
388  	}
389  }
390  #endif
</span></code></pre>
        </div>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DOTweenModuleUI.cs</h3>
            <pre><code>1  #if true && (UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER) 
2  using System;
3  using System.Globalization;
4  using UnityEngine;
5  using UnityEngine.UI;
6  using DG.Tweening.Core;
7  using DG.Tweening.Core.Enums;
8  using DG.Tweening.Plugins;
9  using DG.Tweening.Plugins.Options;
10  using Outline = UnityEngine.UI.Outline;
11  using Text = UnityEngine.UI.Text;
12  #pragma warning disable 1591
13  namespace DG.Tweening
14  {
15  	public static class DOTweenModuleUI
16      {
17          #region Shortcuts
18          #region CanvasGroup
19          public static TweenerCore<float, float, FloatOptions> DOFade(this CanvasGroup target, float endValue, float duration)
20          {
21              TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.alpha, x => target.alpha = x, endValue, duration);
22              t.SetTarget(target);
23              return t;
24          }
25          #endregion
26          #region Graphic
27          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Graphic target, Color endValue, float duration)
28          {
29              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
30              t.SetTarget(target);
31              return t;
32          }
33          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Graphic target, float endValue, float duration)
34          {
35              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
36              t.SetTarget(target);
37              return t;
38          }
39          #endregion
40          #region Image
41          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Image target, Color endValue, float duration)
42          {
43              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
44              t.SetTarget(target);
45              return t;
46          }
47          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Image target, float endValue, float duration)
48          {
49              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
50              t.SetTarget(target);
51              return t;
52          }
53          public static TweenerCore<float, float, FloatOptions> DOFillAmount(this Image target, float endValue, float duration)
54          {
55              if (endValue > 1) endValue = 1;
56              else if (endValue < 0) endValue = 0;
57              TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.fillAmount, x => target.fillAmount = x, endValue, duration);
58              t.SetTarget(target);
59              return t;
60          }
61          public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
62          {
63              Sequence s = DOTween.Sequence();
64              GradientColorKey[] colors = gradient.colorKeys;
65              int len = colors.Length;
66              for (int i = 0; i < len; ++i) {
67                  GradientColorKey c = colors[i];
68                  if (i == 0 && c.time <= 0) {
69                      target.color = c.color;
70                      continue;
71                  }
72                  float colorDuration = i == len - 1
73                      ? duration - s.Duration(false) 
74                      : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
75                  s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
76              }
77              s.SetTarget(target);
78              return s;
79          }
80          #endregion
81          #region LayoutElement
82          public static TweenerCore<Vector2, Vector2, VectorOptions> DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
83          {
84              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), x => {
85                      target.flexibleWidth = x.x;
86                      target.flexibleHeight = x.y;
87                  }, endValue, duration);
88              t.SetOptions(snapping).SetTarget(target);
89              return t;
90          }
91          public static TweenerCore<Vector2, Vector2, VectorOptions> DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
92          {
93              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.minWidth, target.minHeight), x => {
94                  target.minWidth = x.x;
95                  target.minHeight = x.y;
96              }, endValue, duration);
97              t.SetOptions(snapping).SetTarget(target);
98              return t;
99          }
100          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
101          {
102              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), x => {
103                  target.preferredWidth = x.x;
104                  target.preferredHeight = x.y;
105              }, endValue, duration);
106              t.SetOptions(snapping).SetTarget(target);
107              return t;
108          }
109          #endregion
110          #region Outline
111          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Outline target, Color endValue, float duration)
112          {
113              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.effectColor, x => target.effectColor = x, endValue, duration);
114              t.SetTarget(target);
115              return t;
116          }
117          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Outline target, float endValue, float duration)
118          {
119              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.effectColor, x => target.effectColor = x, endValue, duration);
120              t.SetTarget(target);
121              return t;
122          }
123          public static TweenerCore<Vector2, Vector2, VectorOptions> DOScale(this Outline target, Vector2 endValue, float duration)
124          {
125              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.effectDistance, x => target.effectDistance = x, endValue, duration);
126              t.SetTarget(target);
127              return t;
128          }
129          #endregion
130          #region RectTransform
131          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
132          {
133              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, endValue, duration);
134              t.SetOptions(snapping).SetTarget(target);
135              return t;
136          }
137          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
138          {
139              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue, 0), duration);
140              t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
141              return t;
142          }
143          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
144          {
145              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, endValue), duration);
146              t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
147              return t;
148          }
149          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
150          {
151              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, endValue, duration);
152              t.SetOptions(snapping).SetTarget(target);
153              return t;
154          }
155          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
156          {
157              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(endValue, 0, 0), duration);
158              t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
159              return t;
160          }
161          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
162          {
163              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, endValue, 0), duration);
164              t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
165              return t;
166          }
167          public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
168          {
169              TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, 0, endValue), duration);
170              t.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
171              return t;
172          }
173          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
174          {
175              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMax, x => target.anchorMax = x, endValue, duration);
176              t.SetOptions(snapping).SetTarget(target);
177              return t;
178          }
179          public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
180          {
181              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMin, x => target.anchorMin = x, endValue, duration);
182              t.SetOptions(snapping).SetTarget(target);
183              return t;
184          }
185          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivot(this RectTransform target, Vector2 endValue, float duration)
186          {
187              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, endValue, duration);
188              t.SetTarget(target);
189              return t;
190          }
191          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotX(this RectTransform target, float endValue, float duration)
192          {
193              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(endValue, 0), duration);
194              t.SetOptions(AxisConstraint.X).SetTarget(target);
195              return t;
196          }
197          public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotY(this RectTransform target, float endValue, float duration)
198          {
199              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(0, endValue), duration);
200              t.SetOptions(AxisConstraint.Y).SetTarget(target);
201              return t;
202          }
203          public static TweenerCore<Vector2, Vector2, VectorOptions> DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
204          {
205              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.sizeDelta, x => target.sizeDelta = x, endValue, duration);
206              t.SetOptions(snapping).SetTarget(target);
207              return t;
208          }
209          public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1, bool snapping = false)
210          {
211              return DOTween.Punch(() => target.anchoredPosition, x => target.anchoredPosition = x, punch, duration, vibrato, elasticity)
212                  .SetTarget(target).SetOptions(snapping);
213          }
214          public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true, ShakeRandomnessMode randomnessMode = ShakeRandomnessMode.Full)
215          {
216              return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode)
217                  .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
218          }
219          public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true, ShakeRandomnessMode randomnessMode = ShakeRandomnessMode.Full)
220          {
221              return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, fadeOut, randomnessMode)
222                  .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
223          }
224          #region Special
225          public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
226          {
227              if (numJumps < 1) numJumps = 1;
228              float startPosY = 0;
229              float offsetY = -1;
230              bool offsetYSet = false;
231              Sequence s = DOTween.Sequence();
232              Tween yTween = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, jumpPower), duration / (numJumps * 2))
233                  .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
234                  .SetLoops(numJumps * 2, LoopType.Yoyo)
235                  .OnStart(()=> startPosY = target.anchoredPosition.y);
236              s.Append(DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue.x, 0), duration)
237                      .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
238                  ).Join(yTween)
239                  .SetTarget(target).SetEase(DOTween.defaultEaseType);
240              s.OnUpdate(() => {
241                  if (!offsetYSet) {
242                      offsetYSet = true;
243                      offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
244                  }
245                  Vector2 pos = target.anchoredPosition;
246                  pos.y += DOVirtual.EasedValue(0, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
247                  target.anchoredPosition = pos;
248              });
249              return s;
250          }
251          #endregion
252          #endregion
253          #region ScrollRect
254          public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
255          {
256              return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition),
257                  x => {
258                      target.horizontalNormalizedPosition = x.x;
259                      target.verticalNormalizedPosition = x.y;
260                  }, endValue, duration)
261                  .SetOptions(snapping).SetTarget(target);
262          }
263          public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
264          {
265              return DOTween.To(() => target.horizontalNormalizedPosition, x => target.horizontalNormalizedPosition = x, endValue, duration)
266                  .SetOptions(snapping).SetTarget(target);
267          }
268          public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
269          {
270              return DOTween.To(() => target.verticalNormalizedPosition, x => target.verticalNormalizedPosition = x, endValue, duration)
271                  .SetOptions(snapping).SetTarget(target);
272          }
273          #endregion
274          #region Slider
275          public static TweenerCore<float, float, FloatOptions> DOValue(this Slider target, float endValue, float duration, bool snapping = false)
276          {
277              TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.value, x => target.value = x, endValue, duration);
278              t.SetOptions(snapping).SetTarget(target);
279              return t;
280          }
281          #endregion
282          #region Text
283          public static TweenerCore<Color, Color, ColorOptions> DOColor(this Text target, Color endValue, float duration)
284          {
285              TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
286              t.SetTarget(target);
287              return t;
288          }
289          public static TweenerCore<int, int, NoOptions> DOCounter(
290              this Text target, int fromValue, int endValue, float duration, bool addThousandsSeparator = true, CultureInfo culture = null
291          ){
292              int v = fromValue;
293              CultureInfo cInfo = !addThousandsSeparator ? null : culture ?? CultureInfo.InvariantCulture;
294              TweenerCore<int, int, NoOptions> t = DOTween.To(() => v, x => {
295                  v = x;
296                  target.text = addThousandsSeparator
297                      ? v.ToString("N0", cInfo)
298                      : v.ToString();
299              }, endValue, duration);
300              t.SetTarget(target);
301              return t;
302          }
303          public static TweenerCore<Color, Color, ColorOptions> DOFade(this Text target, float endValue, float duration)
304          {
305              TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
306              t.SetTarget(target);
307              return t;
308          }
309          public static TweenerCore<string, string, StringOptions> DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
310          {
311              if (endValue == null) {
312                  if (Debugger.logPriority > 0) Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
313                  endValue = "";
314              }
<span onclick='openModal()' class='match'>315              TweenerCore<string, string, StringOptions> t = DOTween.To(() => target.text, x => target.text = x, endValue, duration);
316              t.SetOptions(richTextEnabled, scrambleMode, scrambleChars)
317                  .SetTarget(target);
318              return t;
319          }
320          #endregion
321          #region Blendables
322          #region Graphic
323          public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
324          {
325              endValue = endValue - target.color;
326              Color to = new Color(0, 0, 0, 0);
327              return DOTween.To(() => to, x => {
328                  Color diff = x - to;
329                  to = x;
330                  target.color += diff;
331              }, endValue, duration)
332                  .Blendable().SetTarget(target);
333          }
334          #endregion
335          #region Image
336          public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
337          {
338              endValue = endValue - target.color;
339              Color to = new Color(0, 0, 0, 0);
340              return DOTween.To(() => to, x => {
341                  Color diff = x - to;
342                  to = x;
343                  target.color += diff;
344              }, endValue, duration)
345                  .Blendable().SetTarget(target);
346          }
347          #endregion
348          #region Text
349          public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
350          {
351              endValue = endValue - target.color;
352              Color to = new Color(0, 0, 0, 0);
353              return DOTween.To(() => to, x => {
354                  Color diff = x - to;
355                  to = x;
356                  target.color += diff;
357              }, endValue, duration)
358                  .Blendable().SetTarget(target);
359          }
360          #endregion
361          #endregion
362          #region Shapes
363          public static TweenerCore<Vector2, Vector2, CircleOptions> DOShapeCircle(
364              this RectTransform target, Vector2 center, float endValueDegrees, float duration, bool relativeCenter = false, bool snapping = false
365          )
366          {
367              TweenerCore<Vector2, Vector2, CircleOptions> t = DOTween.To(
368                  CirclePlugin.Get(), () => target.anchoredPosition, x => target.anchoredPosition = x, center, duration
369              );
370              t.SetOptions(endValueDegrees, relativeCenter, snapping).SetTarget(target);
371              return t;
372          }
373          #endregion
374          #endregion
375          public static class Utils
376          {
377              public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
378              {
379                  Vector2 localPoint;
380                  Vector2 fromPivotDerivedOffset = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
381                  Vector2 screenP = RectTransformUtility.WorldToScreenPoint(null, from.position);
382                  screenP += fromPivotDerivedOffset;
383                  RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, out localPoint);
384                  Vector2 pivotDerivedOffset = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
385                  return to.anchoredPosition + localPoint - pivotDerivedOffset;
386              }
387          }
388  	}
389  }
390  #endif
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DOTweenModuleUI_135.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DOTweenModuleUI.cs</div>
                </div>
                <div class="column column_space"><pre><code>315              TweenerCore<string, string, StringOptions> t = DOTween.To(() => target.text, x => target.text = x, endValue, duration);
316              t.SetOptions(richTextEnabled, scrambleMode, scrambleChars)
317                  .SetTarget(target);
318              return t;
319          }
320          #endregion
321          #region Blendables
322          #region Graphic
323          public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
324          {
325              endValue = endValue - target.color;
326              Color to = new Color(0, 0, 0, 0);
327              return DOTween.To(() => to, x => {
328                  Color diff = x - to;
329                  to = x;
330                  target.color += diff;
331              }, endValue, duration)
332                  .Blendable().SetTarget(target);
333          }
334          #endregion
335          #region Image
336          public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
337          {
338              endValue = endValue - target.color;
339              Color to = new Color(0, 0, 0, 0);
340              return DOTween.To(() => to, x => {
341                  Color diff = x - to;
342                  to = x;
343                  target.color += diff;
344              }, endValue, duration)
345                  .Blendable().SetTarget(target);
346          }
347          #endregion
348          #region Text
349          public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
350          {
351              endValue = endValue - target.color;
352              Color to = new Color(0, 0, 0, 0);
353              return DOTween.To(() => to, x => {
354                  Color diff = x - to;
355                  to = x;
356                  target.color += diff;
357              }, endValue, duration)
358                  .Blendable().SetTarget(target);
359          }
360          #endregion
361          #endregion
362          #region Shapes
363          public static TweenerCore<Vector2, Vector2, CircleOptions> DOShapeCircle(
364              this RectTransform target, Vector2 center, float endValueDegrees, float duration, bool relativeCenter = false, bool snapping = false
365          )
366          {
367              TweenerCore<Vector2, Vector2, CircleOptions> t = DOTween.To(
368                  CirclePlugin.Get(), () => target.anchoredPosition, x => target.anchoredPosition = x, center, duration
369              );
370              t.SetOptions(endValueDegrees, relativeCenter, snapping).SetTarget(target);
371              return t;
372          }
373          #endregion
374          #endregion
375          public static class Utils
376          {
377              public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
378              {
379                  Vector2 localPoint;
380                  Vector2 fromPivotDerivedOffset = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
381                  Vector2 screenP = RectTransformUtility.WorldToScreenPoint(null, from.position);
382                  screenP += fromPivotDerivedOffset;
383                  RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, out localPoint);
384                  Vector2 pivotDerivedOffset = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
385                  return to.anchoredPosition + localPoint - pivotDerivedOffset;
386              }
387          }
388  	}
389  }
390  #endif
</pre></code></div>
                <div class="column column_space"><pre><code>315              TweenerCore<string, string, StringOptions> t = DOTween.To(() => target.text, x => target.text = x, endValue, duration);
316              t.SetOptions(richTextEnabled, scrambleMode, scrambleChars)
317                  .SetTarget(target);
318              return t;
319          }
320          #endregion
321          #region Blendables
322          #region Graphic
323          public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
324          {
325              endValue = endValue - target.color;
326              Color to = new Color(0, 0, 0, 0);
327              return DOTween.To(() => to, x => {
328                  Color diff = x - to;
329                  to = x;
330                  target.color += diff;
331              }, endValue, duration)
332                  .Blendable().SetTarget(target);
333          }
334          #endregion
335          #region Image
336          public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
337          {
338              endValue = endValue - target.color;
339              Color to = new Color(0, 0, 0, 0);
340              return DOTween.To(() => to, x => {
341                  Color diff = x - to;
342                  to = x;
343                  target.color += diff;
344              }, endValue, duration)
345                  .Blendable().SetTarget(target);
346          }
347          #endregion
348          #region Text
349          public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
350          {
351              endValue = endValue - target.color;
352              Color to = new Color(0, 0, 0, 0);
353              return DOTween.To(() => to, x => {
354                  Color diff = x - to;
355                  to = x;
356                  target.color += diff;
357              }, endValue, duration)
358                  .Blendable().SetTarget(target);
359          }
360          #endregion
361          #endregion
362          #region Shapes
363          public static TweenerCore<Vector2, Vector2, CircleOptions> DOShapeCircle(
364              this RectTransform target, Vector2 center, float endValueDegrees, float duration, bool relativeCenter = false, bool snapping = false
365          )
366          {
367              TweenerCore<Vector2, Vector2, CircleOptions> t = DOTween.To(
368                  CirclePlugin.Get(), () => target.anchoredPosition, x => target.anchoredPosition = x, center, duration
369              );
370              t.SetOptions(endValueDegrees, relativeCenter, snapping).SetTarget(target);
371              return t;
372          }
373          #endregion
374          #endregion
375          public static class Utils
376          {
377              public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
378              {
379                  Vector2 localPoint;
380                  Vector2 fromPivotDerivedOffset = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
381                  Vector2 screenP = RectTransformUtility.WorldToScreenPoint(null, from.position);
382                  screenP += fromPivotDerivedOffset;
383                  RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, out localPoint);
384                  Vector2 pivotDerivedOffset = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
385                  return to.anchoredPosition + localPoint - pivotDerivedOffset;
386              }
387          }
388  	}
389  }
390  #endif
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    