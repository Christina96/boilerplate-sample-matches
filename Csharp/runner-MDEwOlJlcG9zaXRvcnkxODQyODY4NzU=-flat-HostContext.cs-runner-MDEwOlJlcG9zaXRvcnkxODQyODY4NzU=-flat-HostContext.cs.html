
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-HostContext.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Diagnostics;
5  using System.Diagnostics.Tracing;
6  using System.Globalization;
7  using System.IO;
8  using System.Linq;
9  using System.Net.Http;
10  using System.Net.Http.Headers;
11  using System.Reflection;
12  using System.Runtime.Loader;
13  using System.Threading;
14  using System.Threading.Tasks;
15  using GitHub.DistributedTask.Logging;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  namespace GitHub.Runner.Common
19  {
20      public interface IHostContext : IDisposable
21      {
22          StartupType StartupType { get; set; }
23          CancellationToken RunnerShutdownToken { get; }
24          ShutdownReason RunnerShutdownReason { get; }
25          ISecretMasker SecretMasker { get; }
26          List<ProductInfoHeaderValue> UserAgents { get; }
27          RunnerWebProxy WebProxy { get; }
28          string GetDirectory(WellKnownDirectory directory);
29          string GetConfigFile(WellKnownConfigFile configFile);
30          Tracing GetTrace(string name);
31          Task Delay(TimeSpan delay, CancellationToken cancellationToken);
32          T CreateService<T>() where T : class, IRunnerService;
33          T GetService<T>() where T : class, IRunnerService;
34          void SetDefaultCulture(string name);
35          event EventHandler Unloading;
36          void ShutdownRunner(ShutdownReason reason);
37          void WritePerfCounter(string counter);
38      }
39      public enum StartupType
40      {
41          Manual,
42          Service,
43          AutoStartup
44      }
45      public sealed class HostContext : EventListener, IObserver<DiagnosticListener>, IObserver<KeyValuePair<string, object>>, IHostContext, IDisposable
46      {
47          private const int _defaultLogPageSize = 8;  
48          private static int _defaultLogRetentionDays = 30;
49          private static int[] _vssHttpMethodEventIds = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 24 };
50          private static int[] _vssHttpCredentialEventIds = new int[] { 11, 13, 14, 15, 16, 17, 18, 20, 21, 22, 27, 29 };
51          private readonly ConcurrentDictionary<Type, object> _serviceInstances = new();
52          private readonly ConcurrentDictionary<Type, Type> _serviceTypes = new();
53          private readonly ISecretMasker _secretMasker = new SecretMasker();
54          private readonly List<ProductInfoHeaderValue> _userAgents = new() { new ProductInfoHeaderValue($"GitHubActionsRunner-{BuildConstants.RunnerPackage.PackageName}", BuildConstants.RunnerPackage.Version) };
55          private CancellationTokenSource _runnerShutdownTokenSource = new();
56          private object _perfLock = new();
57          private Tracing _trace;
58          private Tracing _actionsHttpTrace;
59          private Tracing _netcoreHttpTrace;
60          private ITraceManager _traceManager;
61          private AssemblyLoadContext _loadContext;
62          private IDisposable _httpTraceSubscription;
63          private IDisposable _diagListenerSubscription;
64          private StartupType _startupType;
65          private string _perfFile;
66          private RunnerWebProxy _webProxy = new();
67          public event EventHandler Unloading;
68          public CancellationToken RunnerShutdownToken => _runnerShutdownTokenSource.Token;
69          public ShutdownReason RunnerShutdownReason { get; private set; }
70          public ISecretMasker SecretMasker => _secretMasker;
71          public List<ProductInfoHeaderValue> UserAgents => _userAgents;
72          public RunnerWebProxy WebProxy => _webProxy;
73          public HostContext(string hostType, string logFile = null)
74          {
75              ArgUtil.NotNullOrEmpty(hostType, nameof(hostType));
76              _loadContext = AssemblyLoadContext.GetLoadContext(typeof(HostContext).GetTypeInfo().Assembly);
77              _loadContext.Unloading += LoadContext_Unloading;
78              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscape);
79              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscapeShift1);
80              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscapeShift2);
81              this.SecretMasker.AddValueEncoder(ValueEncoders.CommandLineArgumentEscape);
82              this.SecretMasker.AddValueEncoder(ValueEncoders.ExpressionStringEscape);
83              this.SecretMasker.AddValueEncoder(ValueEncoders.JsonStringEscape);
84              this.SecretMasker.AddValueEncoder(ValueEncoders.UriDataEscape);
85              this.SecretMasker.AddValueEncoder(ValueEncoders.XmlDataEscape);
86              this.SecretMasker.AddValueEncoder(ValueEncoders.TrimDoubleQuotes);
87              this.SecretMasker.AddValueEncoder(ValueEncoders.PowerShellPreAmpersandEscape);
88              this.SecretMasker.AddValueEncoder(ValueEncoders.PowerShellPostAmpersandEscape);
89              StdoutTraceListener stdoutTraceListener = null;
90              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(Constants.Variables.Agent.PrintLogToStdout)))
91              {
92                  stdoutTraceListener = new StdoutTraceListener(hostType);
93              }
94              if (string.IsNullOrEmpty(logFile))
95              {
96                  int logPageSize;
97                  string logSizeEnv = Environment.GetEnvironmentVariable($"{hostType.ToUpperInvariant()}_LOGSIZE");
98                  if (string.IsNullOrEmpty(logSizeEnv) || !int.TryParse(logSizeEnv, out logPageSize))
99                  {
100                      logPageSize = _defaultLogPageSize;
101                  }
102                  int logRetentionDays;
103                  string logRetentionDaysEnv = Environment.GetEnvironmentVariable($"{hostType.ToUpperInvariant()}_LOGRETENTION");
104                  if (string.IsNullOrEmpty(logRetentionDaysEnv) || !int.TryParse(logRetentionDaysEnv, out logRetentionDays))
105                  {
106                      logRetentionDays = _defaultLogRetentionDays;
107                  }
108                  string diagLogDirectory = Path.Combine(new DirectoryInfo(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location)).Parent.FullName, Constants.Path.DiagDirectory);
109                  _traceManager = new TraceManager(new HostTraceListener(diagLogDirectory, hostType, logPageSize, logRetentionDays), stdoutTraceListener, this.SecretMasker);
110              }
111              else
112              {
113                  _traceManager = new TraceManager(new HostTraceListener(logFile), stdoutTraceListener, this.SecretMasker);
114              }
115              _trace = GetTrace(nameof(HostContext));
116              _actionsHttpTrace = GetTrace("GitHubActionsService");
117              bool enableHttpTrace;
118              if (bool.TryParse(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_HTTPTRACE"), out enableHttpTrace) && enableHttpTrace)
119              {
120                  _trace.Warning("*****************************************************************************************");
121                  _trace.Warning("**                                                                                     **");
122                  _trace.Warning("** Http trace is enabled, all your http traffic will be dumped into runner diag log.   **");
123                  _trace.Warning("** DO NOT share the log in public place! The trace may contains secrets in plain text. **");
124                  _trace.Warning("**                                                                                     **");
125                  _trace.Warning("*****************************************************************************************");
126                  _netcoreHttpTrace = GetTrace("HttpTrace");
127                  _diagListenerSubscription = DiagnosticListener.AllListeners.Subscribe(this);
128              }
129              string perfCounterLocation = Environment.GetEnvironmentVariable("RUNNER_PERFLOG");
130              if (!string.IsNullOrEmpty(perfCounterLocation))
131              {
132                  try
133                  {
134                      Directory.CreateDirectory(perfCounterLocation);
135                      _perfFile = Path.Combine(perfCounterLocation, $"{hostType}.perf");
136                  }
137                  catch (Exception ex)
138                  {
139                      _trace.Error(ex);
140                  }
141              }
142              if (!string.IsNullOrEmpty(WebProxy.HttpProxyAddress))
143              {
144                  if (string.IsNullOrEmpty(WebProxy.HttpProxyUsername) && string.IsNullOrEmpty(WebProxy.HttpProxyPassword))
145                  {
146                      _trace.Info($"Configuring anonymous proxy {WebProxy.HttpProxyAddress} for all HTTP requests.");
147                  }
148                  else
149                  {
150                      if (!string.IsNullOrEmpty(WebProxy.HttpProxyPassword))
151                      {
152                          this.SecretMasker.AddValue(WebProxy.HttpProxyPassword);
153                      }
154                      _trace.Info($"Configuring authenticated proxy {WebProxy.HttpProxyAddress} for all HTTP requests.");
155                  }
156              }
157              if (!string.IsNullOrEmpty(WebProxy.HttpsProxyAddress))
158              {
159                  if (string.IsNullOrEmpty(WebProxy.HttpsProxyUsername) && string.IsNullOrEmpty(WebProxy.HttpsProxyPassword))
160                  {
161                      _trace.Info($"Configuring anonymous proxy {WebProxy.HttpsProxyAddress} for all HTTPS requests.");
162                  }
163                  else
164                  {
165                      if (!string.IsNullOrEmpty(WebProxy.HttpsProxyPassword))
166                      {
167                          this.SecretMasker.AddValue(WebProxy.HttpsProxyPassword);
168                      }
169                      _trace.Info($"Configuring authenticated proxy {WebProxy.HttpsProxyAddress} for all HTTPS requests.");
170                  }
171              }
172              if (string.IsNullOrEmpty(WebProxy.HttpProxyAddress) && string.IsNullOrEmpty(WebProxy.HttpsProxyAddress))
173              {
174                  _trace.Info($"No proxy settings were found based on environmental variables (http_proxy/https_proxy/HTTP_PROXY/HTTPS_PROXY)");
175              }
176              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY")))
177              {
178                  _trace.Warning($"Runner is running under insecure mode: HTTPS server certifcate validation has been turned off by GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY environment variable.");
179              }
180              var credFile = GetConfigFile(WellKnownConfigFile.Credentials);
181              if (File.Exists(credFile))
182              {
183                  var credData = IOUtil.LoadObject<CredentialData>(credFile);
184                  if (credData != null &&
185                      credData.Data.TryGetValue("clientId", out var clientId))
186                  {
187                      _userAgents.Add(new ProductInfoHeaderValue("ClientId", clientId));
188                  }
189              }
190              var runnerFile = GetConfigFile(WellKnownConfigFile.Runner);
191              if (File.Exists(runnerFile))
192              {
193                  var runnerSettings = IOUtil.LoadObject<RunnerSettings>(runnerFile, true);
194                  _userAgents.Add(new ProductInfoHeaderValue("RunnerId", runnerSettings.AgentId.ToString(CultureInfo.InvariantCulture)));
195                  _userAgents.Add(new ProductInfoHeaderValue("GroupId", runnerSettings.PoolId.ToString(CultureInfo.InvariantCulture)));
196              }
197              _userAgents.Add(new ProductInfoHeaderValue("CommitSHA", BuildConstants.Source.CommitHash));
198              var extraUserAgent = Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_EXTRA_USER_AGENT");
199              if (!string.IsNullOrEmpty(extraUserAgent))
200              {
201                  var extraUserAgentSplit = extraUserAgent.Split('/', StringSplitOptions.RemoveEmptyEntries);
202                  if (extraUserAgentSplit.Length != 2)
203                  {
204                      _trace.Error($"GITHUB_ACTIONS_RUNNER_EXTRA_USER_AGENT is not in the format of 'name/version'.");
205                  }
206                  var extraUserAgentHeader = new ProductInfoHeaderValue(extraUserAgentSplit[0], extraUserAgentSplit[1]);
207                  _trace.Info($"Adding extra user agent '{extraUserAgentHeader}' to all HTTP requests.");
208                  _userAgents.Add(extraUserAgentHeader);
209              }
210          }
211          public string GetDirectory(WellKnownDirectory directory)
212          {
213              string path;
214              switch (directory)
215              {
216                  case WellKnownDirectory.Bin:
217                      path = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
218                      break;
219                  case WellKnownDirectory.Diag:
220                      path = Path.Combine(
221                          GetDirectory(WellKnownDirectory.Root),
222                          Constants.Path.DiagDirectory);
223                      break;
224                  case WellKnownDirectory.Externals:
225                      path = Path.Combine(
226                          GetDirectory(WellKnownDirectory.Root),
227                          Constants.Path.ExternalsDirectory);
228                      break;
229                  case WellKnownDirectory.Root:
230                      path = new DirectoryInfo(GetDirectory(WellKnownDirectory.Bin)).Parent.FullName;
231                      break;
232                  case WellKnownDirectory.Temp:
233                      path = Path.Combine(
234                          GetDirectory(WellKnownDirectory.Work),
235                          Constants.Path.TempDirectory);
236                      break;
237                  case WellKnownDirectory.Actions:
238                      path = Path.Combine(
239                          GetDirectory(WellKnownDirectory.Work),
240                          Constants.Path.ActionsDirectory);
241                      break;
242                  case WellKnownDirectory.Tools:
243                      path = Environment.GetEnvironmentVariable("RUNNER_TOOL_CACHE") ?? Environment.GetEnvironmentVariable("RUNNER_TOOLSDIRECTORY") ?? Environment.GetEnvironmentVariable("AGENT_TOOLSDIRECTORY") ?? Environment.GetEnvironmentVariable(Constants.Variables.Agent.ToolsDirectory);
244                      if (string.IsNullOrEmpty(path))
245                      {
246                          path = Path.Combine(
247                              GetDirectory(WellKnownDirectory.Work),
248                              Constants.Path.ToolDirectory);
249                      }
250                      break;
251                  case WellKnownDirectory.Update:
252                      path = Path.Combine(
253                          GetDirectory(WellKnownDirectory.Work),
254                          Constants.Path.UpdateDirectory);
255                      break;
256                  case WellKnownDirectory.Work:
257                      var configurationStore = GetService<IConfigurationStore>();
258                      RunnerSettings settings = configurationStore.GetSettings();
259                      ArgUtil.NotNull(settings, nameof(settings));
260                      ArgUtil.NotNullOrEmpty(settings.WorkFolder, nameof(settings.WorkFolder));
261                      path = Path.GetFullPath(Path.Combine(
262                          GetDirectory(WellKnownDirectory.Root),
263                          settings.WorkFolder));
264                      break;
265                  default:
266                      throw new NotSupportedException($"Unexpected well known directory: '{directory}'");
267              }
268              _trace.Info($"Well known directory '{directory}': '{path}'");
269              return path;
270          }
271          public string GetConfigFile(WellKnownConfigFile configFile)
272          {
273              string path;
274              switch (configFile)
275              {
276                  case WellKnownConfigFile.Runner:
277                      path = Path.Combine(
278                          GetDirectory(WellKnownDirectory.Root),
279                          ".runner");
280                      break;
281                  case WellKnownConfigFile.Credentials:
282                      path = Path.Combine(
283                          GetDirectory(WellKnownDirectory.Root),
284                          ".credentials");
285                      break;
286                  case WellKnownConfigFile.MigratedCredentials:
287                      path = Path.Combine(
288                          GetDirectory(WellKnownDirectory.Root),
289                          ".credentials_migrated");
290                      break;
291                  case WellKnownConfigFile.RSACredentials:
292                      path = Path.Combine(
293                          GetDirectory(WellKnownDirectory.Root),
294                          ".credentials_rsaparams");
295                      break;
296                  case WellKnownConfigFile.Service:
297                      path = Path.Combine(
298                          GetDirectory(WellKnownDirectory.Root),
299                          ".service");
300                      break;
301                  case WellKnownConfigFile.CredentialStore:
302  #if OS_OSX
303                      path = Path.Combine(
304                          GetDirectory(WellKnownDirectory.Root),
305                          ".credential_store.keychain");
306  #else
307                      path = Path.Combine(
308                          GetDirectory(WellKnownDirectory.Root),
309                          ".credential_store");
310  #endif
311                      break;
312                  case WellKnownConfigFile.Certificates:
313                      path = Path.Combine(
314                          GetDirectory(WellKnownDirectory.Root),
315                          ".certificates");
316                      break;
317                  case WellKnownConfigFile.Options:
318                      path = Path.Combine(
319                          GetDirectory(WellKnownDirectory.Root),
320                          ".options");
321                      break;
322                  case WellKnownConfigFile.SetupInfo:
323                      path = Path.Combine(
324                          GetDirectory(WellKnownDirectory.Root),
325                          ".setup_info");
326                      break;
327                  case WellKnownConfigFile.Telemetry:
328                      path = Path.Combine(
329                          GetDirectory(WellKnownDirectory.Diag),
330                          ".telemetry");
331                      break;
332                  default:
333                      throw new NotSupportedException($"Unexpected well known config file: '{configFile}'");
334              }
335              _trace.Info($"Well known config file '{configFile}': '{path}'");
336              return path;
337          }
338          public Tracing GetTrace(string name)
339          {
340              return _traceManager[name];
341          }
342          public async Task Delay(TimeSpan delay, CancellationToken cancellationToken)
343          {
344              await Task.Delay(delay, cancellationToken);
345          }
346          public T CreateService<T>() where T : class, IRunnerService
347          {
348              Type target;
349              if (!_serviceTypes.TryGetValue(typeof(T), out target))
350              {
351                  CustomAttributeData attribute = typeof(T)
352                      .GetTypeInfo()
353                      .CustomAttributes
354                      .FirstOrDefault(x => x.AttributeType == typeof(ServiceLocatorAttribute));
355                  if (attribute != null)
356                  {
357                      foreach (CustomAttributeNamedArgument arg in attribute.NamedArguments)
358                      {
359                          if (string.Equals(arg.MemberName, ServiceLocatorAttribute.DefaultPropertyName, StringComparison.Ordinal))
360                          {
361                              target = arg.TypedValue.Value as Type;
362                          }
363                      }
364                  }
365                  if (target == null)
366                  {
367                      throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, "Service mapping not found for key '{0}'.", typeof(T).FullName));
368                  }
369                  _serviceTypes.TryAdd(typeof(T), target);
370                  target = _serviceTypes[typeof(T)];
371              }
372              T svc = Activator.CreateInstance(target) as T;
373              svc.Initialize(this);
374              return svc;
375          }
376          public T GetService<T>() where T : class, IRunnerService
377          {
378              object instance;
379              if (_serviceInstances.TryGetValue(typeof(T), out instance))
380              {
381                  return instance as T;
382              }
383              _serviceInstances.TryAdd(typeof(T), CreateService<T>());
384              return _serviceInstances[typeof(T)] as T;
385          }
386          public void SetDefaultCulture(string name)
387          {
388              ArgUtil.NotNull(name, nameof(name));
389              _trace.Verbose($"Setting default culture and UI culture to: '{name}'");
390              CultureInfo.DefaultThreadCurrentCulture = new CultureInfo(name);
391              CultureInfo.DefaultThreadCurrentUICulture = new CultureInfo(name);
392          }
393          public void ShutdownRunner(ShutdownReason reason)
394          {
395              ArgUtil.NotNull(reason, nameof(reason));
396              _trace.Info($"Runner will be shutdown for {reason.ToString()}");
397              RunnerShutdownReason = reason;
398              _runnerShutdownTokenSource.Cancel();
399          }
400          public override void Dispose()
401          {
402              Dispose(true);
403              GC.SuppressFinalize(this);
404          }
405          public StartupType StartupType
406          {
407              get
408              {
409                  return _startupType;
410              }
411              set
412              {
413                  _startupType = value;
414              }
415          }
416          public void WritePerfCounter(string counter)
417          {
418              if (!string.IsNullOrEmpty(_perfFile))
419              {
420                  string normalizedCounter = counter.Replace(':', '_');
421                  lock (_perfLock)
422                  {
423                      try
424                      {
425                          File.AppendAllLines(_perfFile, new[] { $"{normalizedCounter}:{DateTime.UtcNow.ToString("O")}" });
426                      }
427                      catch (Exception ex)
428                      {
429                          _trace.Error(ex);
430                      }
431                  }
432              }
433          }
434          private void Dispose(bool disposing)
435          {
436              if (disposing)
437              {
438                  if (_loadContext != null)
439                  {
440                      _loadContext.Unloading -= LoadContext_Unloading;
441                      _loadContext = null;
442                  }
443                  _httpTraceSubscription?.Dispose();
444                  _diagListenerSubscription?.Dispose();
445                  _traceManager?.Dispose();
446                  _traceManager = null;
447                  _runnerShutdownTokenSource?.Dispose();
448                  _runnerShutdownTokenSource = null;
449                  base.Dispose();
450              }
451          }
452          private void LoadContext_Unloading(AssemblyLoadContext obj)
453          {
454              if (Unloading != null)
455              {
456                  Unloading(this, null);
457              }
458          }
459          void IObserver<DiagnosticListener>.OnCompleted()
460          {
461              _netcoreHttpTrace.Info("DiagListeners finished transmitting data.");
462          }
463          void IObserver<DiagnosticListener>.OnError(Exception error)
464          {
465              _netcoreHttpTrace.Error(error);
<span onclick='openModal()' class='match'>466          }
467          void IObserver<DiagnosticListener>.OnNext(DiagnosticListener listener)
468          {
</span>469              if (listener.Name == "HttpHandlerDiagnosticListener" && _httpTraceSubscription == null)
470              {
471                  _httpTraceSubscription = listener.Subscribe(this);
472              }
473          }
474          void IObserver<KeyValuePair<string, object>>.OnCompleted()
475          {
476              _netcoreHttpTrace.Info("HttpHandlerDiagnosticListener finished transmitting data.");
477          }
478          void IObserver<KeyValuePair<string, object>>.OnError(Exception error)
479          {
480              _netcoreHttpTrace.Error(error);
481          }
482          void IObserver<KeyValuePair<string, object>>.OnNext(KeyValuePair<string, object> value)
483          {
484              _netcoreHttpTrace.Info($"Trace {value.Key} event:{Environment.NewLine}{value.Value.ToString()}");
485          }
486          protected override void OnEventSourceCreated(EventSource source)
487          {
488              if (source.Name.Equals("GitHub-Actions-Http"))
489              {
490                  EnableEvents(source, EventLevel.Verbose);
491              }
492          }
493          protected override void OnEventWritten(EventWrittenEventArgs eventData)
494          {
495              if (eventData == null)
496              {
497                  return;
498              }
499              string message = eventData.Message;
500              object[] payload = new object[0];
501              if (eventData.Payload != null && eventData.Payload.Count > 0)
502              {
503                  payload = eventData.Payload.ToArray();
504              }
505              try
506              {
507                  if (_vssHttpMethodEventIds.Contains(eventData.EventId))
508                  {
509                      payload[0] = Enum.Parse(typeof(VssHttpMethod), ((int)payload[0]).ToString());
510                  }
511                  else if (_vssHttpCredentialEventIds.Contains(eventData.EventId))
512                  {
513                      payload[0] = Enum.Parse(typeof(GitHub.Services.Common.VssCredentialsType), ((int)payload[0]).ToString());
514                  }
515                  if (payload.Length > 0)
516                  {
517                      message = String.Format(eventData.Message.Replace("%n", Environment.NewLine), payload);
518                  }
519                  switch (eventData.Level)
520                  {
521                      case EventLevel.Critical:
522                      case EventLevel.Error:
523                          _actionsHttpTrace.Error(message);
524                          break;
525                      case EventLevel.Warning:
526                          _actionsHttpTrace.Warning(message);
527                          break;
528                      case EventLevel.Informational:
529                          _actionsHttpTrace.Info(message);
530                          break;
531                      default:
532                          _actionsHttpTrace.Verbose(message);
533                          break;
534                  }
535              }
536              catch (Exception ex)
537              {
538                  _actionsHttpTrace.Error(ex);
539                  _actionsHttpTrace.Info(eventData.Message);
540                  _actionsHttpTrace.Info(string.Join(", ", eventData.Payload?.ToArray() ?? new string[0]));
541              }
542          }
543          internal enum VssHttpMethod
544          {
545              UNKNOWN,
546              DELETE,
547              HEAD,
548              GET,
549              OPTIONS,
550              PATCH,
551              POST,
552              PUT,
553          }
554      }
555      public static class HostContextExtension
556      {
557          public static HttpClientHandler CreateHttpClientHandler(this IHostContext context)
558          {
559              var handlerFactory = context.GetService<IHttpClientHandlerFactory>();
560              return handlerFactory.CreateClientHandler(context.WebProxy);
561          }
562          public static string GetDefaultShellForScript(this IHostContext hostContext, string path, string prependPath)
563          {
564              var trace = hostContext.GetTrace(nameof(GetDefaultShellForScript));
565              switch (Path.GetExtension(path))
566              {
567                  case ".sh":
568                      if (WhichUtil.Which("bash", false, trace, prependPath) != null)
569                      {
570                          return "bash";
571                      }
572                      return "sh";
573                  case ".ps1":
574                      if (WhichUtil.Which("pwsh", false, trace, prependPath) != null)
575                      {
576                          return "pwsh";
577                      }
578                      return "powershell";
579                  case ".js":
580                      return Path.Combine(hostContext.GetDirectory(WellKnownDirectory.Externals), NodeUtil.GetInternalNodeVersion(), "bin", $"node{IOUtil.ExeExtension}") + " {0}";
581                  default:
582                      throw new ArgumentException($"{path} is not a valid path to a script. Make sure it ends in '.sh', '.ps1' or '.js'.");
583              }
584          }
585      }
586      public enum ShutdownReason
587      {
588          UserCancelled = 0,
589          OperatingSystemShutdown = 1,
590      }
591  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-HostContext.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Diagnostics;
5  using System.Diagnostics.Tracing;
6  using System.Globalization;
7  using System.IO;
8  using System.Linq;
9  using System.Net.Http;
10  using System.Net.Http.Headers;
11  using System.Reflection;
12  using System.Runtime.Loader;
13  using System.Threading;
14  using System.Threading.Tasks;
15  using GitHub.DistributedTask.Logging;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  namespace GitHub.Runner.Common
19  {
20      public interface IHostContext : IDisposable
21      {
22          StartupType StartupType { get; set; }
23          CancellationToken RunnerShutdownToken { get; }
24          ShutdownReason RunnerShutdownReason { get; }
25          ISecretMasker SecretMasker { get; }
26          List<ProductInfoHeaderValue> UserAgents { get; }
27          RunnerWebProxy WebProxy { get; }
28          string GetDirectory(WellKnownDirectory directory);
29          string GetConfigFile(WellKnownConfigFile configFile);
30          Tracing GetTrace(string name);
31          Task Delay(TimeSpan delay, CancellationToken cancellationToken);
32          T CreateService<T>() where T : class, IRunnerService;
33          T GetService<T>() where T : class, IRunnerService;
34          void SetDefaultCulture(string name);
35          event EventHandler Unloading;
36          void ShutdownRunner(ShutdownReason reason);
37          void WritePerfCounter(string counter);
38      }
39      public enum StartupType
40      {
41          Manual,
42          Service,
43          AutoStartup
44      }
45      public sealed class HostContext : EventListener, IObserver<DiagnosticListener>, IObserver<KeyValuePair<string, object>>, IHostContext, IDisposable
46      {
47          private const int _defaultLogPageSize = 8;  
48          private static int _defaultLogRetentionDays = 30;
49          private static int[] _vssHttpMethodEventIds = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 24 };
50          private static int[] _vssHttpCredentialEventIds = new int[] { 11, 13, 14, 15, 16, 17, 18, 20, 21, 22, 27, 29 };
51          private readonly ConcurrentDictionary<Type, object> _serviceInstances = new();
52          private readonly ConcurrentDictionary<Type, Type> _serviceTypes = new();
53          private readonly ISecretMasker _secretMasker = new SecretMasker();
54          private readonly List<ProductInfoHeaderValue> _userAgents = new() { new ProductInfoHeaderValue($"GitHubActionsRunner-{BuildConstants.RunnerPackage.PackageName}", BuildConstants.RunnerPackage.Version) };
55          private CancellationTokenSource _runnerShutdownTokenSource = new();
56          private object _perfLock = new();
57          private Tracing _trace;
58          private Tracing _actionsHttpTrace;
59          private Tracing _netcoreHttpTrace;
60          private ITraceManager _traceManager;
61          private AssemblyLoadContext _loadContext;
62          private IDisposable _httpTraceSubscription;
63          private IDisposable _diagListenerSubscription;
64          private StartupType _startupType;
65          private string _perfFile;
66          private RunnerWebProxy _webProxy = new();
67          public event EventHandler Unloading;
68          public CancellationToken RunnerShutdownToken => _runnerShutdownTokenSource.Token;
69          public ShutdownReason RunnerShutdownReason { get; private set; }
70          public ISecretMasker SecretMasker => _secretMasker;
71          public List<ProductInfoHeaderValue> UserAgents => _userAgents;
72          public RunnerWebProxy WebProxy => _webProxy;
73          public HostContext(string hostType, string logFile = null)
74          {
75              ArgUtil.NotNullOrEmpty(hostType, nameof(hostType));
76              _loadContext = AssemblyLoadContext.GetLoadContext(typeof(HostContext).GetTypeInfo().Assembly);
77              _loadContext.Unloading += LoadContext_Unloading;
78              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscape);
79              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscapeShift1);
80              this.SecretMasker.AddValueEncoder(ValueEncoders.Base64StringEscapeShift2);
81              this.SecretMasker.AddValueEncoder(ValueEncoders.CommandLineArgumentEscape);
82              this.SecretMasker.AddValueEncoder(ValueEncoders.ExpressionStringEscape);
83              this.SecretMasker.AddValueEncoder(ValueEncoders.JsonStringEscape);
84              this.SecretMasker.AddValueEncoder(ValueEncoders.UriDataEscape);
85              this.SecretMasker.AddValueEncoder(ValueEncoders.XmlDataEscape);
86              this.SecretMasker.AddValueEncoder(ValueEncoders.TrimDoubleQuotes);
87              this.SecretMasker.AddValueEncoder(ValueEncoders.PowerShellPreAmpersandEscape);
88              this.SecretMasker.AddValueEncoder(ValueEncoders.PowerShellPostAmpersandEscape);
89              StdoutTraceListener stdoutTraceListener = null;
90              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(Constants.Variables.Agent.PrintLogToStdout)))
91              {
92                  stdoutTraceListener = new StdoutTraceListener(hostType);
93              }
94              if (string.IsNullOrEmpty(logFile))
95              {
96                  int logPageSize;
97                  string logSizeEnv = Environment.GetEnvironmentVariable($"{hostType.ToUpperInvariant()}_LOGSIZE");
98                  if (string.IsNullOrEmpty(logSizeEnv) || !int.TryParse(logSizeEnv, out logPageSize))
99                  {
100                      logPageSize = _defaultLogPageSize;
101                  }
102                  int logRetentionDays;
103                  string logRetentionDaysEnv = Environment.GetEnvironmentVariable($"{hostType.ToUpperInvariant()}_LOGRETENTION");
104                  if (string.IsNullOrEmpty(logRetentionDaysEnv) || !int.TryParse(logRetentionDaysEnv, out logRetentionDays))
105                  {
106                      logRetentionDays = _defaultLogRetentionDays;
107                  }
108                  string diagLogDirectory = Path.Combine(new DirectoryInfo(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location)).Parent.FullName, Constants.Path.DiagDirectory);
109                  _traceManager = new TraceManager(new HostTraceListener(diagLogDirectory, hostType, logPageSize, logRetentionDays), stdoutTraceListener, this.SecretMasker);
110              }
111              else
112              {
113                  _traceManager = new TraceManager(new HostTraceListener(logFile), stdoutTraceListener, this.SecretMasker);
114              }
115              _trace = GetTrace(nameof(HostContext));
116              _actionsHttpTrace = GetTrace("GitHubActionsService");
117              bool enableHttpTrace;
118              if (bool.TryParse(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_HTTPTRACE"), out enableHttpTrace) && enableHttpTrace)
119              {
120                  _trace.Warning("*****************************************************************************************");
121                  _trace.Warning("**                                                                                     **");
122                  _trace.Warning("** Http trace is enabled, all your http traffic will be dumped into runner diag log.   **");
123                  _trace.Warning("** DO NOT share the log in public place! The trace may contains secrets in plain text. **");
124                  _trace.Warning("**                                                                                     **");
125                  _trace.Warning("*****************************************************************************************");
126                  _netcoreHttpTrace = GetTrace("HttpTrace");
127                  _diagListenerSubscription = DiagnosticListener.AllListeners.Subscribe(this);
128              }
129              string perfCounterLocation = Environment.GetEnvironmentVariable("RUNNER_PERFLOG");
130              if (!string.IsNullOrEmpty(perfCounterLocation))
131              {
132                  try
133                  {
134                      Directory.CreateDirectory(perfCounterLocation);
135                      _perfFile = Path.Combine(perfCounterLocation, $"{hostType}.perf");
136                  }
137                  catch (Exception ex)
138                  {
139                      _trace.Error(ex);
140                  }
141              }
142              if (!string.IsNullOrEmpty(WebProxy.HttpProxyAddress))
143              {
144                  if (string.IsNullOrEmpty(WebProxy.HttpProxyUsername) && string.IsNullOrEmpty(WebProxy.HttpProxyPassword))
145                  {
146                      _trace.Info($"Configuring anonymous proxy {WebProxy.HttpProxyAddress} for all HTTP requests.");
147                  }
148                  else
149                  {
150                      if (!string.IsNullOrEmpty(WebProxy.HttpProxyPassword))
151                      {
152                          this.SecretMasker.AddValue(WebProxy.HttpProxyPassword);
153                      }
154                      _trace.Info($"Configuring authenticated proxy {WebProxy.HttpProxyAddress} for all HTTP requests.");
155                  }
156              }
157              if (!string.IsNullOrEmpty(WebProxy.HttpsProxyAddress))
158              {
159                  if (string.IsNullOrEmpty(WebProxy.HttpsProxyUsername) && string.IsNullOrEmpty(WebProxy.HttpsProxyPassword))
160                  {
161                      _trace.Info($"Configuring anonymous proxy {WebProxy.HttpsProxyAddress} for all HTTPS requests.");
162                  }
163                  else
164                  {
165                      if (!string.IsNullOrEmpty(WebProxy.HttpsProxyPassword))
166                      {
167                          this.SecretMasker.AddValue(WebProxy.HttpsProxyPassword);
168                      }
169                      _trace.Info($"Configuring authenticated proxy {WebProxy.HttpsProxyAddress} for all HTTPS requests.");
170                  }
171              }
172              if (string.IsNullOrEmpty(WebProxy.HttpProxyAddress) && string.IsNullOrEmpty(WebProxy.HttpsProxyAddress))
173              {
174                  _trace.Info($"No proxy settings were found based on environmental variables (http_proxy/https_proxy/HTTP_PROXY/HTTPS_PROXY)");
175              }
176              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY")))
177              {
178                  _trace.Warning($"Runner is running under insecure mode: HTTPS server certifcate validation has been turned off by GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY environment variable.");
179              }
180              var credFile = GetConfigFile(WellKnownConfigFile.Credentials);
181              if (File.Exists(credFile))
182              {
183                  var credData = IOUtil.LoadObject<CredentialData>(credFile);
184                  if (credData != null &&
185                      credData.Data.TryGetValue("clientId", out var clientId))
186                  {
187                      _userAgents.Add(new ProductInfoHeaderValue("ClientId", clientId));
188                  }
189              }
190              var runnerFile = GetConfigFile(WellKnownConfigFile.Runner);
191              if (File.Exists(runnerFile))
192              {
193                  var runnerSettings = IOUtil.LoadObject<RunnerSettings>(runnerFile, true);
194                  _userAgents.Add(new ProductInfoHeaderValue("RunnerId", runnerSettings.AgentId.ToString(CultureInfo.InvariantCulture)));
195                  _userAgents.Add(new ProductInfoHeaderValue("GroupId", runnerSettings.PoolId.ToString(CultureInfo.InvariantCulture)));
196              }
197              _userAgents.Add(new ProductInfoHeaderValue("CommitSHA", BuildConstants.Source.CommitHash));
198              var extraUserAgent = Environment.GetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_EXTRA_USER_AGENT");
199              if (!string.IsNullOrEmpty(extraUserAgent))
200              {
201                  var extraUserAgentSplit = extraUserAgent.Split('/', StringSplitOptions.RemoveEmptyEntries);
202                  if (extraUserAgentSplit.Length != 2)
203                  {
204                      _trace.Error($"GITHUB_ACTIONS_RUNNER_EXTRA_USER_AGENT is not in the format of 'name/version'.");
205                  }
206                  var extraUserAgentHeader = new ProductInfoHeaderValue(extraUserAgentSplit[0], extraUserAgentSplit[1]);
207                  _trace.Info($"Adding extra user agent '{extraUserAgentHeader}' to all HTTP requests.");
208                  _userAgents.Add(extraUserAgentHeader);
209              }
210          }
211          public string GetDirectory(WellKnownDirectory directory)
212          {
213              string path;
214              switch (directory)
215              {
216                  case WellKnownDirectory.Bin:
217                      path = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
218                      break;
219                  case WellKnownDirectory.Diag:
220                      path = Path.Combine(
221                          GetDirectory(WellKnownDirectory.Root),
222                          Constants.Path.DiagDirectory);
223                      break;
224                  case WellKnownDirectory.Externals:
225                      path = Path.Combine(
226                          GetDirectory(WellKnownDirectory.Root),
227                          Constants.Path.ExternalsDirectory);
228                      break;
229                  case WellKnownDirectory.Root:
230                      path = new DirectoryInfo(GetDirectory(WellKnownDirectory.Bin)).Parent.FullName;
231                      break;
232                  case WellKnownDirectory.Temp:
233                      path = Path.Combine(
234                          GetDirectory(WellKnownDirectory.Work),
235                          Constants.Path.TempDirectory);
236                      break;
237                  case WellKnownDirectory.Actions:
238                      path = Path.Combine(
239                          GetDirectory(WellKnownDirectory.Work),
240                          Constants.Path.ActionsDirectory);
241                      break;
242                  case WellKnownDirectory.Tools:
243                      path = Environment.GetEnvironmentVariable("RUNNER_TOOL_CACHE") ?? Environment.GetEnvironmentVariable("RUNNER_TOOLSDIRECTORY") ?? Environment.GetEnvironmentVariable("AGENT_TOOLSDIRECTORY") ?? Environment.GetEnvironmentVariable(Constants.Variables.Agent.ToolsDirectory);
244                      if (string.IsNullOrEmpty(path))
245                      {
246                          path = Path.Combine(
247                              GetDirectory(WellKnownDirectory.Work),
248                              Constants.Path.ToolDirectory);
249                      }
250                      break;
251                  case WellKnownDirectory.Update:
252                      path = Path.Combine(
253                          GetDirectory(WellKnownDirectory.Work),
254                          Constants.Path.UpdateDirectory);
255                      break;
256                  case WellKnownDirectory.Work:
257                      var configurationStore = GetService<IConfigurationStore>();
258                      RunnerSettings settings = configurationStore.GetSettings();
259                      ArgUtil.NotNull(settings, nameof(settings));
260                      ArgUtil.NotNullOrEmpty(settings.WorkFolder, nameof(settings.WorkFolder));
261                      path = Path.GetFullPath(Path.Combine(
262                          GetDirectory(WellKnownDirectory.Root),
263                          settings.WorkFolder));
264                      break;
265                  default:
266                      throw new NotSupportedException($"Unexpected well known directory: '{directory}'");
267              }
268              _trace.Info($"Well known directory '{directory}': '{path}'");
269              return path;
270          }
271          public string GetConfigFile(WellKnownConfigFile configFile)
272          {
273              string path;
274              switch (configFile)
275              {
276                  case WellKnownConfigFile.Runner:
277                      path = Path.Combine(
278                          GetDirectory(WellKnownDirectory.Root),
279                          ".runner");
280                      break;
281                  case WellKnownConfigFile.Credentials:
282                      path = Path.Combine(
283                          GetDirectory(WellKnownDirectory.Root),
284                          ".credentials");
285                      break;
286                  case WellKnownConfigFile.MigratedCredentials:
287                      path = Path.Combine(
288                          GetDirectory(WellKnownDirectory.Root),
289                          ".credentials_migrated");
290                      break;
291                  case WellKnownConfigFile.RSACredentials:
292                      path = Path.Combine(
293                          GetDirectory(WellKnownDirectory.Root),
294                          ".credentials_rsaparams");
295                      break;
296                  case WellKnownConfigFile.Service:
297                      path = Path.Combine(
298                          GetDirectory(WellKnownDirectory.Root),
299                          ".service");
300                      break;
301                  case WellKnownConfigFile.CredentialStore:
302  #if OS_OSX
303                      path = Path.Combine(
304                          GetDirectory(WellKnownDirectory.Root),
305                          ".credential_store.keychain");
306  #else
307                      path = Path.Combine(
308                          GetDirectory(WellKnownDirectory.Root),
309                          ".credential_store");
310  #endif
311                      break;
312                  case WellKnownConfigFile.Certificates:
313                      path = Path.Combine(
314                          GetDirectory(WellKnownDirectory.Root),
315                          ".certificates");
316                      break;
317                  case WellKnownConfigFile.Options:
318                      path = Path.Combine(
319                          GetDirectory(WellKnownDirectory.Root),
320                          ".options");
321                      break;
322                  case WellKnownConfigFile.SetupInfo:
323                      path = Path.Combine(
324                          GetDirectory(WellKnownDirectory.Root),
325                          ".setup_info");
326                      break;
327                  case WellKnownConfigFile.Telemetry:
328                      path = Path.Combine(
329                          GetDirectory(WellKnownDirectory.Diag),
330                          ".telemetry");
331                      break;
332                  default:
333                      throw new NotSupportedException($"Unexpected well known config file: '{configFile}'");
334              }
335              _trace.Info($"Well known config file '{configFile}': '{path}'");
336              return path;
337          }
338          public Tracing GetTrace(string name)
339          {
340              return _traceManager[name];
341          }
342          public async Task Delay(TimeSpan delay, CancellationToken cancellationToken)
343          {
344              await Task.Delay(delay, cancellationToken);
345          }
346          public T CreateService<T>() where T : class, IRunnerService
347          {
348              Type target;
349              if (!_serviceTypes.TryGetValue(typeof(T), out target))
350              {
351                  CustomAttributeData attribute = typeof(T)
352                      .GetTypeInfo()
353                      .CustomAttributes
354                      .FirstOrDefault(x => x.AttributeType == typeof(ServiceLocatorAttribute));
355                  if (attribute != null)
356                  {
357                      foreach (CustomAttributeNamedArgument arg in attribute.NamedArguments)
358                      {
359                          if (string.Equals(arg.MemberName, ServiceLocatorAttribute.DefaultPropertyName, StringComparison.Ordinal))
360                          {
361                              target = arg.TypedValue.Value as Type;
362                          }
363                      }
364                  }
365                  if (target == null)
366                  {
367                      throw new KeyNotFoundException(string.Format(CultureInfo.InvariantCulture, "Service mapping not found for key '{0}'.", typeof(T).FullName));
368                  }
369                  _serviceTypes.TryAdd(typeof(T), target);
370                  target = _serviceTypes[typeof(T)];
371              }
372              T svc = Activator.CreateInstance(target) as T;
373              svc.Initialize(this);
374              return svc;
375          }
376          public T GetService<T>() where T : class, IRunnerService
377          {
378              object instance;
379              if (_serviceInstances.TryGetValue(typeof(T), out instance))
380              {
381                  return instance as T;
382              }
383              _serviceInstances.TryAdd(typeof(T), CreateService<T>());
384              return _serviceInstances[typeof(T)] as T;
385          }
386          public void SetDefaultCulture(string name)
387          {
388              ArgUtil.NotNull(name, nameof(name));
389              _trace.Verbose($"Setting default culture and UI culture to: '{name}'");
390              CultureInfo.DefaultThreadCurrentCulture = new CultureInfo(name);
391              CultureInfo.DefaultThreadCurrentUICulture = new CultureInfo(name);
392          }
393          public void ShutdownRunner(ShutdownReason reason)
394          {
395              ArgUtil.NotNull(reason, nameof(reason));
396              _trace.Info($"Runner will be shutdown for {reason.ToString()}");
397              RunnerShutdownReason = reason;
398              _runnerShutdownTokenSource.Cancel();
399          }
400          public override void Dispose()
401          {
402              Dispose(true);
403              GC.SuppressFinalize(this);
404          }
405          public StartupType StartupType
406          {
407              get
408              {
409                  return _startupType;
410              }
411              set
412              {
413                  _startupType = value;
414              }
415          }
416          public void WritePerfCounter(string counter)
417          {
418              if (!string.IsNullOrEmpty(_perfFile))
419              {
420                  string normalizedCounter = counter.Replace(':', '_');
421                  lock (_perfLock)
422                  {
423                      try
424                      {
425                          File.AppendAllLines(_perfFile, new[] { $"{normalizedCounter}:{DateTime.UtcNow.ToString("O")}" });
426                      }
427                      catch (Exception ex)
428                      {
429                          _trace.Error(ex);
430                      }
431                  }
432              }
433          }
434          private void Dispose(bool disposing)
435          {
436              if (disposing)
437              {
438                  if (_loadContext != null)
439                  {
440                      _loadContext.Unloading -= LoadContext_Unloading;
441                      _loadContext = null;
442                  }
443                  _httpTraceSubscription?.Dispose();
444                  _diagListenerSubscription?.Dispose();
445                  _traceManager?.Dispose();
446                  _traceManager = null;
447                  _runnerShutdownTokenSource?.Dispose();
448                  _runnerShutdownTokenSource = null;
449                  base.Dispose();
450              }
451          }
452          private void LoadContext_Unloading(AssemblyLoadContext obj)
453          {
454              if (Unloading != null)
455              {
456                  Unloading(this, null);
457              }
458          }
459          void IObserver<DiagnosticListener>.OnCompleted()
460          {
461              _netcoreHttpTrace.Info("DiagListeners finished transmitting data.");
<span onclick='openModal()' class='match'>462          }
463          void IObserver<DiagnosticListener>.OnError(Exception error)
464          {
</span>465              _netcoreHttpTrace.Error(error);
466          }
467          void IObserver<DiagnosticListener>.OnNext(DiagnosticListener listener)
468          {
469              if (listener.Name == "HttpHandlerDiagnosticListener" && _httpTraceSubscription == null)
470              {
471                  _httpTraceSubscription = listener.Subscribe(this);
472              }
473          }
474          void IObserver<KeyValuePair<string, object>>.OnCompleted()
475          {
476              _netcoreHttpTrace.Info("HttpHandlerDiagnosticListener finished transmitting data.");
477          }
478          void IObserver<KeyValuePair<string, object>>.OnError(Exception error)
479          {
480              _netcoreHttpTrace.Error(error);
481          }
482          void IObserver<KeyValuePair<string, object>>.OnNext(KeyValuePair<string, object> value)
483          {
484              _netcoreHttpTrace.Info($"Trace {value.Key} event:{Environment.NewLine}{value.Value.ToString()}");
485          }
486          protected override void OnEventSourceCreated(EventSource source)
487          {
488              if (source.Name.Equals("GitHub-Actions-Http"))
489              {
490                  EnableEvents(source, EventLevel.Verbose);
491              }
492          }
493          protected override void OnEventWritten(EventWrittenEventArgs eventData)
494          {
495              if (eventData == null)
496              {
497                  return;
498              }
499              string message = eventData.Message;
500              object[] payload = new object[0];
501              if (eventData.Payload != null && eventData.Payload.Count > 0)
502              {
503                  payload = eventData.Payload.ToArray();
504              }
505              try
506              {
507                  if (_vssHttpMethodEventIds.Contains(eventData.EventId))
508                  {
509                      payload[0] = Enum.Parse(typeof(VssHttpMethod), ((int)payload[0]).ToString());
510                  }
511                  else if (_vssHttpCredentialEventIds.Contains(eventData.EventId))
512                  {
513                      payload[0] = Enum.Parse(typeof(GitHub.Services.Common.VssCredentialsType), ((int)payload[0]).ToString());
514                  }
515                  if (payload.Length > 0)
516                  {
517                      message = String.Format(eventData.Message.Replace("%n", Environment.NewLine), payload);
518                  }
519                  switch (eventData.Level)
520                  {
521                      case EventLevel.Critical:
522                      case EventLevel.Error:
523                          _actionsHttpTrace.Error(message);
524                          break;
525                      case EventLevel.Warning:
526                          _actionsHttpTrace.Warning(message);
527                          break;
528                      case EventLevel.Informational:
529                          _actionsHttpTrace.Info(message);
530                          break;
531                      default:
532                          _actionsHttpTrace.Verbose(message);
533                          break;
534                  }
535              }
536              catch (Exception ex)
537              {
538                  _actionsHttpTrace.Error(ex);
539                  _actionsHttpTrace.Info(eventData.Message);
540                  _actionsHttpTrace.Info(string.Join(", ", eventData.Payload?.ToArray() ?? new string[0]));
541              }
542          }
543          internal enum VssHttpMethod
544          {
545              UNKNOWN,
546              DELETE,
547              HEAD,
548              GET,
549              OPTIONS,
550              PATCH,
551              POST,
552              PUT,
553          }
554      }
555      public static class HostContextExtension
556      {
557          public static HttpClientHandler CreateHttpClientHandler(this IHostContext context)
558          {
559              var handlerFactory = context.GetService<IHttpClientHandlerFactory>();
560              return handlerFactory.CreateClientHandler(context.WebProxy);
561          }
562          public static string GetDefaultShellForScript(this IHostContext hostContext, string path, string prependPath)
563          {
564              var trace = hostContext.GetTrace(nameof(GetDefaultShellForScript));
565              switch (Path.GetExtension(path))
566              {
567                  case ".sh":
568                      if (WhichUtil.Which("bash", false, trace, prependPath) != null)
569                      {
570                          return "bash";
571                      }
572                      return "sh";
573                  case ".ps1":
574                      if (WhichUtil.Which("pwsh", false, trace, prependPath) != null)
575                      {
576                          return "pwsh";
577                      }
578                      return "powershell";
579                  case ".js":
580                      return Path.Combine(hostContext.GetDirectory(WellKnownDirectory.Externals), NodeUtil.GetInternalNodeVersion(), "bin", $"node{IOUtil.ExeExtension}") + " {0}";
581                  default:
582                      throw new ArgumentException($"{path} is not a valid path to a script. Make sure it ends in '.sh', '.ps1' or '.js'.");
583              }
584          }
585      }
586      public enum ShutdownReason
587      {
588          UserCancelled = 0,
589          OperatingSystemShutdown = 1,
590      }
591  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-HostContext.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-HostContext.cs</div>
                </div>
                <div class="column column_space"><pre><code>466          }
467          void IObserver<DiagnosticListener>.OnNext(DiagnosticListener listener)
468          {
</pre></code></div>
                <div class="column column_space"><pre><code>462          }
463          void IObserver<DiagnosticListener>.OnError(Exception error)
464          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    