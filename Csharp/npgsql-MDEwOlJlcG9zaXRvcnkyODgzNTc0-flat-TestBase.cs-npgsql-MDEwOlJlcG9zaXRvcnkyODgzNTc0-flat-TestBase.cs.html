
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 30, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics;
6  using System.Linq;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using Microsoft.Extensions.Logging;
10  using Npgsql.Tests.Support;
11  using NpgsqlTypes;
12  using NUnit.Framework;
13  namespace Npgsql.Tests;
14  public abstract class TestBase
15  {
16      public virtual string ConnectionString => TestUtil.ConnectionString;
17      static readonly SemaphoreSlim DatabaseCreationLock = new(1);
18      static readonly object dataSourceLockObject = new();
19      static ConcurrentDictionary<string, NpgsqlDataSource> DataSources = new(StringComparer.Ordinal);
20      #region Type testing
21      public async Task<T> AssertType<T>(
22          T value,
23          string sqlLiteral,
24          string pgTypeName,
25          NpgsqlDbType? npgsqlDbType,
26          DbType? dbType = null,
27          DbType? inferredDbType = null,
28          bool isDefaultForReading = true,
29          bool isDefaultForWriting = true,
30          bool? isDefault = null,
31          bool isNpgsqlDbTypeInferredFromClrType = true,
32          Func<T, T, bool>? comparer = null)
33      {
34          await using var connection = await OpenConnectionAsync();
35          return await AssertType(
36              connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading, isDefaultForWriting,
37              isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
38      }
39      public async Task<T> AssertType<T>(
40          NpgsqlDataSource dataSource,
41          T value,
42          string sqlLiteral,
43          string pgTypeName,
44          NpgsqlDbType? npgsqlDbType,
45          DbType? dbType = null,
46          DbType? inferredDbType = null,
47          bool isDefaultForReading = true,
48          bool isDefaultForWriting = true,
49          bool? isDefault = null,
50          bool isNpgsqlDbTypeInferredFromClrType = true,
51          Func<T, T, bool>? comparer = null)
52      {
53          await using var connection = await dataSource.OpenConnectionAsync();
54          return await AssertType(connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading,
55              isDefaultForWriting, isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
56      }
57      public async Task<T> AssertType<T>(
58          NpgsqlConnection connection,
59          T value,
60          string sqlLiteral,
61          string pgTypeName,
62          NpgsqlDbType? npgsqlDbType,
63          DbType? dbType = null,
64          DbType? inferredDbType = null,
65          bool isDefaultForReading = true,
<span onclick='openModal()' class='match'>66          bool isDefaultForWriting = true,
67          bool? isDefault = null,
68          bool isNpgsqlDbTypeInferredFromClrType = true,
69          Func<T, T, bool>? comparer = null)
70      {
71          if (isDefault is not null)
</span>72              isDefaultForReading = isDefaultForWriting = isDefault.Value;
73          await AssertTypeWrite(connection, () => value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForWriting, isNpgsqlDbTypeInferredFromClrType);
74          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, value, isDefaultForReading, comparer);
75      }
76      public async Task<T> AssertTypeRead<T>(string sqlLiteral, string pgTypeName, T expected, bool isDefault = true)
77      {
78          await using var connection = await OpenConnectionAsync();
79          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, expected, isDefault);
80      }
81      public async Task AssertTypeWrite<T>(
82          NpgsqlDataSource dataSource,
83          T value,
84          string expectedSqlLiteral,
85          string pgTypeName,
86          NpgsqlDbType npgsqlDbType,
87          DbType? dbType = null,
88          DbType? inferredDbType = null,
89          bool isDefault = true,
90          bool isNpgsqlDbTypeInferredFromClrType = true)
91      {
92          await using var connection = await dataSource.OpenConnectionAsync();
93          await AssertTypeWrite(connection, () => value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
94              isNpgsqlDbTypeInferredFromClrType);
95      }
96      public Task AssertTypeWrite<T>(
97          T value,
98          string expectedSqlLiteral,
99          string pgTypeName,
100          NpgsqlDbType npgsqlDbType,
101          DbType? dbType = null,
102          DbType? inferredDbType = null,
103          bool isDefault = true,
104          bool isNpgsqlDbTypeInferredFromClrType = true)
105          => AssertTypeWrite(() => value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
106              isNpgsqlDbTypeInferredFromClrType);
107      public async Task AssertTypeWrite<T>(
108          Func<T> valueFactory,
109          string expectedSqlLiteral,
110          string pgTypeName,
111          NpgsqlDbType npgsqlDbType,
112          DbType? dbType = null,
113          DbType? inferredDbType = null,
114          bool isDefault = true,
115          bool isNpgsqlDbTypeInferredFromClrType = true)
116      {
117          await using var connection = await OpenConnectionAsync();
118          await AssertTypeWrite(connection, valueFactory, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault, isNpgsqlDbTypeInferredFromClrType);
119      }
120      internal static async Task<T> AssertTypeRead<T>(
121          NpgsqlConnection connection,
122          string sqlLiteral,
123          string pgTypeName,
124          T expected,
125          bool isDefault = true,
126          Func<T, T, bool>? comparer = null)
127      {
128          if (sqlLiteral.Contains('\''))
129              sqlLiteral = sqlLiteral.Replace("'", "''");
130          await using var cmd = new NpgsqlCommand($"SELECT '{sqlLiteral}'::{pgTypeName}", connection);
131          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
132          await reader.ReadAsync();
133          var truncatedSqlLiteral = sqlLiteral.Length > 40 ? sqlLiteral[..40] + "..." : sqlLiteral;
134          var dataTypeName = reader.GetDataTypeName(0);
135          var dotIndex = dataTypeName.IndexOf('.');
136          if (dotIndex > -1 && dataTypeName.Substring(0, dotIndex) is "pg_catalog" or "public")
137              dataTypeName = dataTypeName.Substring(dotIndex + 1);
138          Assert.That(dataTypeName, Is.EqualTo(pgTypeName),
139              $"Got wrong result from GetDataTypeName when reading '{truncatedSqlLiteral}'");
140          if (isDefault)
141          {
142              Assert.That(reader.GetFieldType(0), Is.EqualTo(dataTypeName.EndsWith("[]") ? typeof(Array) : typeof(T)),
143                  $"Got wrong result from GetFieldType when reading '{truncatedSqlLiteral}'");
144          }
145          var actual = isDefault ? (T)reader.GetValue(0) : reader.GetFieldValue<T>(0);
146          Assert.That(actual, comparer is null ? Is.EqualTo(expected) : Is.EqualTo(expected).Using(new SimpleComparer<T>(comparer)),
147              $"Got wrong result from GetFieldValue value when reading '{truncatedSqlLiteral}'");
148          return actual;
149      }
150      internal static async Task AssertTypeWrite<T>(
151          NpgsqlConnection connection,
152          Func<T> valueFactory,
153          string expectedSqlLiteral,
154          string pgTypeName,
155          NpgsqlDbType? npgsqlDbType,
156          DbType? dbType = null,
157          DbType? inferredDbType = null,
158          bool isDefault = true,
159          bool isNpgsqlDbTypeInferredFromClrType = true)
160      {
161          if (npgsqlDbType is null)
162              isNpgsqlDbTypeInferredFromClrType = false;
163          var parenIndex = pgTypeName.IndexOf('(');
164          var pgTypeNameWithoutFacets = parenIndex > -1 ? pgTypeName[..parenIndex] : pgTypeName;
165          var errorIdentifierIndex = -1;
166          var errorIdentifier = new Dictionary<int, string>();
167          await using var cmd = new NpgsqlCommand { Connection = connection };
168          NpgsqlParameter p;
169          if (npgsqlDbType is not null)
170          {
171              p = new NpgsqlParameter { Value = valueFactory(), NpgsqlDbType = npgsqlDbType.Value };
172              cmd.Parameters.Add(p);
173              errorIdentifier[++errorIdentifierIndex] = $"NpgsqlDbType={npgsqlDbType}";
174              CheckInference();
175          }
176          p = new NpgsqlParameter { Value = valueFactory(), DataTypeName = pgTypeNameWithoutFacets };
177          cmd.Parameters.Add(p);
178          errorIdentifier[++errorIdentifierIndex] = $"DataTypeName={pgTypeNameWithoutFacets}";
179          CheckInference();
180          if (dbType is not null)
181          {
182              p = new NpgsqlParameter { Value = valueFactory(), DbType = dbType.Value };
183              cmd.Parameters.Add(p);
184              errorIdentifier[++errorIdentifierIndex] = $"DbType={dbType}";
185              CheckInference();
186          }
187          if (isDefault)
188          {
189              p = new NpgsqlParameter { Value = valueFactory() };
190              cmd.Parameters.Add(p);
191              errorIdentifier[++errorIdentifierIndex] = "Value only (non-generic)";
192              if (isNpgsqlDbTypeInferredFromClrType)
193                  CheckInference();
194              p = new NpgsqlParameter<T> { TypedValue = valueFactory() };
195              cmd.Parameters.Add(p);
196              errorIdentifier[++errorIdentifierIndex] = "Value only (generic)";
197              if (isNpgsqlDbTypeInferredFromClrType)
198                  CheckInference();
199          }
200          Debug.Assert(cmd.Parameters.Count == errorIdentifierIndex + 1);
201          cmd.CommandText = "SELECT " + string.Join(", ", Enumerable.Range(1, cmd.Parameters.Count).Select(i =>
202              "pg_typeof($1)::text, $1::text".Replace("$1", $"${i}")));
203          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
204          await reader.ReadAsync();
205          for (var i = 0; i < cmd.Parameters.Count * 2; i += 2)
206          {
207              Assert.That(reader[i], Is.EqualTo(pgTypeNameWithoutFacets), $"Got wrong PG type name when writing with {errorIdentifier[i / 2]}");
208              Assert.That(reader[i+1], Is.EqualTo(expectedSqlLiteral), $"Got wrong SQL literal when writing with {errorIdentifier[i / 2]}");
209          }
210          void CheckInference()
211          {
212              if (npgsqlDbType is not null)
213              {
214                  Assert.That(p.NpgsqlDbType, Is.EqualTo(npgsqlDbType),
215                      () => $"Got wrong inferred NpgsqlDbType when inferring with {errorIdentifier[errorIdentifierIndex]}");
216              }
217              Assert.That(p.DbType, Is.EqualTo(inferredDbType ?? dbType ?? DbType.Object),
218                  () => $"Got wrong inferred DbType when inferring with {errorIdentifier[errorIdentifierIndex]}");
219              Assert.That(p.DataTypeName, Is.EqualTo(pgTypeNameWithoutFacets),
220                  () => $"Got wrong inferred DataTypeName when inferring with {errorIdentifier[errorIdentifierIndex]}");
221          }
222      }
223      public async Task AssertTypeUnsupported<T>(T value, string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
224      {
225          await AssertTypeUnsupportedRead<T>(sqlLiteral, pgTypeName, dataSource);
226          await AssertTypeUnsupportedWrite(value, pgTypeName, dataSource);
227      }
228      public async Task AssertTypeUnsupportedRead(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
229      {
230          dataSource ??= DefaultDataSource;
231          await using var conn = await dataSource.OpenConnectionAsync();
232          await using var cmd = new NpgsqlCommand($"SELECT '{sqlLiteral}'::{pgTypeName}", conn);
233          await using var reader = await cmd.ExecuteReaderAsync();
234          await reader.ReadAsync();
235          Assert.That(() => reader.GetValue(0), Throws.Exception.TypeOf<InvalidCastException>());
236      }
237      public Task<InvalidCastException> AssertTypeUnsupportedRead<T>(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
238          => AssertTypeUnsupportedRead<T, InvalidCastException>(sqlLiteral, pgTypeName, dataSource);
239      public async Task<TException> AssertTypeUnsupportedRead<T, TException>(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
240          where TException : Exception
241      {
242          dataSource ??= DefaultDataSource;
243          await using var conn = await dataSource.OpenConnectionAsync();
244          await using var cmd = new NpgsqlCommand($"SELECT '{sqlLiteral}'::{pgTypeName}", conn);
245          await using var reader = await cmd.ExecuteReaderAsync();
246          await reader.ReadAsync();
247          return Assert.Throws<TException>(() => reader.GetFieldValue<T>(0))!;
248      }
249      public Task<InvalidCastException> AssertTypeUnsupportedWrite<T>(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
250          => AssertTypeUnsupportedWrite<T, InvalidCastException>(value, pgTypeName, dataSource);
251      public async Task<TException> AssertTypeUnsupportedWrite<T, TException>(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
252          where TException : Exception
253      {
254          dataSource ??= DefaultDataSource;
255          await using var conn = await dataSource.OpenConnectionAsync();
256          await using var cmd = new NpgsqlCommand("SELECT $1", conn)
257          {
258              Parameters = { new() { Value = value } }
259          };
260          if (pgTypeName is not null)
261              cmd.Parameters[0].DataTypeName = pgTypeName;
262          return Assert.ThrowsAsync<TException>(() => cmd.ExecuteReaderAsync())!;
263      }
264      class SimpleComparer<T> : IEqualityComparer<T>
265      {
266          readonly Func<T, T, bool> _comparerDelegate;
267          public SimpleComparer(Func<T, T, bool> comparerDelegate)
268              => _comparerDelegate = comparerDelegate;
269          public bool Equals(T? x, T? y)
270              => x is null
271                  ? y is null
272                  : y is not null && _comparerDelegate(x, y);
273          public int GetHashCode(T obj) => throw new NotSupportedException();
274      }
275      #endregion Type testing
276      #region Utilities for use by tests
277      protected static readonly NpgsqlDataSource SharedDataSource = NpgsqlDataSource.Create(TestUtil.ConnectionString);
278      protected virtual NpgsqlDataSourceBuilder CreateDataSourceBuilder()
279          => new(ConnectionString);
280      protected virtual NpgsqlDataSource CreateDataSource()
281          => CreateDataSource(ConnectionString);
282      protected virtual NpgsqlDataSource CreateDataSource(string connectionString)
283          => NpgsqlDataSource.Create(connectionString);
284      protected virtual NpgsqlDataSource CreateDataSource(Action<NpgsqlConnectionStringBuilder> connectionStringBuilderAction)
285      {
286          var connectionStringBuilder = new NpgsqlConnectionStringBuilder(ConnectionString);
287          connectionStringBuilderAction(connectionStringBuilder);
288          return NpgsqlDataSource.Create(connectionStringBuilder);
289      }
290      protected static NpgsqlDataSource GetDataSource(string connectionString)
291      {
292          if (!DataSources.TryGetValue(connectionString, out var dataSource))
293          {
294              lock (dataSourceLockObject)
295              {
296                  if (!DataSources.TryGetValue(connectionString, out dataSource))
297                  {
298                      DataSources[connectionString] = dataSource = NpgsqlDataSource.Create(connectionString);
299                  }
300              }
301          }
302          return dataSource;
303      }
304      protected virtual NpgsqlDataSource CreateLoggingDataSource(
305          out ListLoggerProvider listLoggerProvider,
306          string? connectionString = null,
307          bool sensitiveDataLoggingEnabled = true)
308      {
309          var builder = new NpgsqlDataSourceBuilder(connectionString ?? ConnectionString);
310          var provider = listLoggerProvider = new ListLoggerProvider();
311          builder.UseLoggerFactory(LoggerFactory.Create(loggerFactoryBuilder =>
312          {
313              loggerFactoryBuilder.SetMinimumLevel(LogLevel.Trace);
314              loggerFactoryBuilder.AddProvider(provider);
315          }));
316          builder.EnableParameterLogging(sensitiveDataLoggingEnabled);
317          return builder.Build();
318      }
319      protected NpgsqlDataSource DefaultDataSource
320          => GetDataSource(ConnectionString);
321      protected virtual NpgsqlConnection CreateConnection()
322          => DefaultDataSource.CreateConnection();
323      protected virtual NpgsqlConnection OpenConnection()
324      {
325          var connection = CreateConnection();
326          try
327          {
328              OpenConnection(connection, async: false).GetAwaiter().GetResult();
329              return connection;
330          }
331          catch
332          {
333              connection.Dispose();
334              throw;
335          }
336      }
337      protected virtual async ValueTask<NpgsqlConnection> OpenConnectionAsync()
338      {
339          var connection = CreateConnection();
340          try
341          {
342              await OpenConnection(connection, async: true);
343              return connection;
344          }
345          catch
346          {
347              await connection.DisposeAsync();
348              throw;
349          }
350      }
351      static Task OpenConnection(NpgsqlConnection conn, bool async)
352      {
353          return OpenConnectionInternal(hasLock: false);
354          async Task OpenConnectionInternal(bool hasLock)
355          {
356              try
357              {
358                  if (async)
359                      await conn.OpenAsync();
360                  else
361                      conn.Open();
362              }
363              catch (PostgresException e)
364              {
365                  if (e.SqlState == PostgresErrorCodes.InvalidPassword)
366                      throw new Exception("Please create a user npgsql_tests as follows: CREATE USER npgsql_tests PASSWORD 'npgsql_tests' SUPERUSER");
367                  if (e.SqlState == PostgresErrorCodes.InvalidCatalogName)
368                  {
369                      if (!hasLock)
370                      {
371                          DatabaseCreationLock.Wait();
372                          try
373                          {
374                              await OpenConnectionInternal(hasLock: true);
375                          }
376                          finally
377                          {
378                              DatabaseCreationLock.Release();
379                          }
380                      }
381                      var builder = new NpgsqlConnectionStringBuilder(TestUtil.ConnectionString)
382                      {
383                          Pooling = false,
384                          Multiplexing = false,
385                          Database = "postgres"
386                      };
387                      using var adminConn = new NpgsqlConnection(builder.ConnectionString);
388                      adminConn.Open();
389                      adminConn.ExecuteNonQuery("CREATE DATABASE " + conn.Database);
390                      adminConn.Close();
391                      Thread.Sleep(1000);
392                      if (async)
393                          await conn.OpenAsync();
394                      else
395                          conn.Open();
396                      return;
397                  }
398                  throw;
399              }
400          }
401      }
402      protected static NpgsqlCommand CreateSleepCommand(NpgsqlConnection conn, int seconds = 1000)
403          => new($"SELECT pg_sleep({seconds}){(conn.PostgreSqlVersion < new Version(9, 1, 0) ? "::TEXT" : "")}", conn);
404      #endregion
405  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics;
6  using System.Linq;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using Microsoft.Extensions.Logging;
10  using Npgsql.Tests.Support;
11  using NpgsqlTypes;
12  using NUnit.Framework;
13  namespace Npgsql.Tests;
14  public abstract class TestBase
15  {
16      public virtual string ConnectionString => TestUtil.ConnectionString;
17      static readonly SemaphoreSlim DatabaseCreationLock = new(1);
18      static readonly object dataSourceLockObject = new();
19      static ConcurrentDictionary<string, NpgsqlDataSource> DataSources = new(StringComparer.Ordinal);
20      #region Type testing
21      public async Task<T> AssertType<T>(
22          T value,
23          string sqlLiteral,
24          string pgTypeName,
25          NpgsqlDbType? npgsqlDbType,
26          DbType? dbType = null,
27          DbType? inferredDbType = null,
28          bool isDefaultForReading = true,
29          bool isDefaultForWriting = true,
30          bool? isDefault = null,
31          bool isNpgsqlDbTypeInferredFromClrType = true,
32          Func<T, T, bool>? comparer = null)
33      {
34          await using var connection = await OpenConnectionAsync();
35          return await AssertType(
36              connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading, isDefaultForWriting,
37              isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
38      }
39      public async Task<T> AssertType<T>(
40          NpgsqlDataSource dataSource,
41          T value,
42          string sqlLiteral,
43          string pgTypeName,
44          NpgsqlDbType? npgsqlDbType,
45          DbType? dbType = null,
46          DbType? inferredDbType = null,
47          bool isDefaultForReading = true,
<span onclick='openModal()' class='match'>48          bool isDefaultForWriting = true,
49          bool? isDefault = null,
50          bool isNpgsqlDbTypeInferredFromClrType = true,
51          Func<T, T, bool>? comparer = null)
52      {
53          await using var connection = await dataSource.OpenConnectionAsync();
</span>54          return await AssertType(connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading,
55              isDefaultForWriting, isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
56      }
57      public async Task<T> AssertType<T>(
58          NpgsqlConnection connection,
59          T value,
60          string sqlLiteral,
61          string pgTypeName,
62          NpgsqlDbType? npgsqlDbType,
63          DbType? dbType = null,
64          DbType? inferredDbType = null,
65          bool isDefaultForReading = true,
66          bool isDefaultForWriting = true,
67          bool? isDefault = null,
68          bool isNpgsqlDbTypeInferredFromClrType = true,
69          Func<T, T, bool>? comparer = null)
70      {
71          if (isDefault is not null)
72              isDefaultForReading = isDefaultForWriting = isDefault.Value;
73          await AssertTypeWrite(connection, () => value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForWriting, isNpgsqlDbTypeInferredFromClrType);
74          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, value, isDefaultForReading, comparer);
75      }
76      public async Task<T> AssertTypeRead<T>(string sqlLiteral, string pgTypeName, T expected, bool isDefault = true)
77      {
78          await using var connection = await OpenConnectionAsync();
79          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, expected, isDefault);
80      }
81      public async Task AssertTypeWrite<T>(
82          NpgsqlDataSource dataSource,
83          T value,
84          string expectedSqlLiteral,
85          string pgTypeName,
86          NpgsqlDbType npgsqlDbType,
87          DbType? dbType = null,
88          DbType? inferredDbType = null,
89          bool isDefault = true,
90          bool isNpgsqlDbTypeInferredFromClrType = true)
91      {
92          await using var connection = await dataSource.OpenConnectionAsync();
93          await AssertTypeWrite(connection, () => value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
94              isNpgsqlDbTypeInferredFromClrType);
95      }
96      public Task AssertTypeWrite<T>(
97          T value,
98          string expectedSqlLiteral,
99          string pgTypeName,
100          NpgsqlDbType npgsqlDbType,
101          DbType? dbType = null,
102          DbType? inferredDbType = null,
103          bool isDefault = true,
104          bool isNpgsqlDbTypeInferredFromClrType = true)
105          => AssertTypeWrite(() => value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
106              isNpgsqlDbTypeInferredFromClrType);
107      public async Task AssertTypeWrite<T>(
108          Func<T> valueFactory,
109          string expectedSqlLiteral,
110          string pgTypeName,
111          NpgsqlDbType npgsqlDbType,
112          DbType? dbType = null,
113          DbType? inferredDbType = null,
114          bool isDefault = true,
115          bool isNpgsqlDbTypeInferredFromClrType = true)
116      {
117          await using var connection = await OpenConnectionAsync();
118          await AssertTypeWrite(connection, valueFactory, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault, isNpgsqlDbTypeInferredFromClrType);
119      }
120      internal static async Task<T> AssertTypeRead<T>(
121          NpgsqlConnection connection,
122          string sqlLiteral,
123          string pgTypeName,
124          T expected,
125          bool isDefault = true,
126          Func<T, T, bool>? comparer = null)
127      {
128          if (sqlLiteral.Contains('\''))
129              sqlLiteral = sqlLiteral.Replace("'", "''");
130          await using var cmd = new NpgsqlCommand($"SELECT '{sqlLiteral}'::{pgTypeName}", connection);
131          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
132          await reader.ReadAsync();
133          var truncatedSqlLiteral = sqlLiteral.Length > 40 ? sqlLiteral[..40] + "..." : sqlLiteral;
134          var dataTypeName = reader.GetDataTypeName(0);
135          var dotIndex = dataTypeName.IndexOf('.');
136          if (dotIndex > -1 && dataTypeName.Substring(0, dotIndex) is "pg_catalog" or "public")
137              dataTypeName = dataTypeName.Substring(dotIndex + 1);
138          Assert.That(dataTypeName, Is.EqualTo(pgTypeName),
139              $"Got wrong result from GetDataTypeName when reading '{truncatedSqlLiteral}'");
140          if (isDefault)
141          {
142              Assert.That(reader.GetFieldType(0), Is.EqualTo(dataTypeName.EndsWith("[]") ? typeof(Array) : typeof(T)),
143                  $"Got wrong result from GetFieldType when reading '{truncatedSqlLiteral}'");
144          }
145          var actual = isDefault ? (T)reader.GetValue(0) : reader.GetFieldValue<T>(0);
146          Assert.That(actual, comparer is null ? Is.EqualTo(expected) : Is.EqualTo(expected).Using(new SimpleComparer<T>(comparer)),
147              $"Got wrong result from GetFieldValue value when reading '{truncatedSqlLiteral}'");
148          return actual;
149      }
150      internal static async Task AssertTypeWrite<T>(
151          NpgsqlConnection connection,
152          Func<T> valueFactory,
153          string expectedSqlLiteral,
154          string pgTypeName,
155          NpgsqlDbType? npgsqlDbType,
156          DbType? dbType = null,
157          DbType? inferredDbType = null,
158          bool isDefault = true,
159          bool isNpgsqlDbTypeInferredFromClrType = true)
160      {
161          if (npgsqlDbType is null)
162              isNpgsqlDbTypeInferredFromClrType = false;
163          var parenIndex = pgTypeName.IndexOf('(');
164          var pgTypeNameWithoutFacets = parenIndex > -1 ? pgTypeName[..parenIndex] : pgTypeName;
165          var errorIdentifierIndex = -1;
166          var errorIdentifier = new Dictionary<int, string>();
167          await using var cmd = new NpgsqlCommand { Connection = connection };
168          NpgsqlParameter p;
169          if (npgsqlDbType is not null)
170          {
171              p = new NpgsqlParameter { Value = valueFactory(), NpgsqlDbType = npgsqlDbType.Value };
172              cmd.Parameters.Add(p);
173              errorIdentifier[++errorIdentifierIndex] = $"NpgsqlDbType={npgsqlDbType}";
174              CheckInference();
175          }
176          p = new NpgsqlParameter { Value = valueFactory(), DataTypeName = pgTypeNameWithoutFacets };
177          cmd.Parameters.Add(p);
178          errorIdentifier[++errorIdentifierIndex] = $"DataTypeName={pgTypeNameWithoutFacets}";
179          CheckInference();
180          if (dbType is not null)
181          {
182              p = new NpgsqlParameter { Value = valueFactory(), DbType = dbType.Value };
183              cmd.Parameters.Add(p);
184              errorIdentifier[++errorIdentifierIndex] = $"DbType={dbType}";
185              CheckInference();
186          }
187          if (isDefault)
188          {
189              p = new NpgsqlParameter { Value = valueFactory() };
190              cmd.Parameters.Add(p);
191              errorIdentifier[++errorIdentifierIndex] = "Value only (non-generic)";
192              if (isNpgsqlDbTypeInferredFromClrType)
193                  CheckInference();
194              p = new NpgsqlParameter<T> { TypedValue = valueFactory() };
195              cmd.Parameters.Add(p);
196              errorIdentifier[++errorIdentifierIndex] = "Value only (generic)";
197              if (isNpgsqlDbTypeInferredFromClrType)
198                  CheckInference();
199          }
200          Debug.Assert(cmd.Parameters.Count == errorIdentifierIndex + 1);
201          cmd.CommandText = "SELECT " + string.Join(", ", Enumerable.Range(1, cmd.Parameters.Count).Select(i =>
202              "pg_typeof($1)::text, $1::text".Replace("$1", $"${i}")));
203          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
204          await reader.ReadAsync();
205          for (var i = 0; i < cmd.Parameters.Count * 2; i += 2)
206          {
207              Assert.That(reader[i], Is.EqualTo(pgTypeNameWithoutFacets), $"Got wrong PG type name when writing with {errorIdentifier[i / 2]}");
208              Assert.That(reader[i+1], Is.EqualTo(expectedSqlLiteral), $"Got wrong SQL literal when writing with {errorIdentifier[i / 2]}");
209          }
210          void CheckInference()
211          {
212              if (npgsqlDbType is not null)
213              {
214                  Assert.That(p.NpgsqlDbType, Is.EqualTo(npgsqlDbType),
215                      () => $"Got wrong inferred NpgsqlDbType when inferring with {errorIdentifier[errorIdentifierIndex]}");
216              }
217              Assert.That(p.DbType, Is.EqualTo(inferredDbType ?? dbType ?? DbType.Object),
218                  () => $"Got wrong inferred DbType when inferring with {errorIdentifier[errorIdentifierIndex]}");
219              Assert.That(p.DataTypeName, Is.EqualTo(pgTypeNameWithoutFacets),
220                  () => $"Got wrong inferred DataTypeName when inferring with {errorIdentifier[errorIdentifierIndex]}");
221          }
222      }
223      public async Task AssertTypeUnsupported<T>(T value, string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
224      {
225          await AssertTypeUnsupportedRead<T>(sqlLiteral, pgTypeName, dataSource);
226          await AssertTypeUnsupportedWrite(value, pgTypeName, dataSource);
227      }
228      public async Task AssertTypeUnsupportedRead(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
229      {
230          dataSource ??= DefaultDataSource;
231          await using var conn = await dataSource.OpenConnectionAsync();
232          await using var cmd = new NpgsqlCommand($"SELECT '{sqlLiteral}'::{pgTypeName}", conn);
233          await using var reader = await cmd.ExecuteReaderAsync();
234          await reader.ReadAsync();
235          Assert.That(() => reader.GetValue(0), Throws.Exception.TypeOf<InvalidCastException>());
236      }
237      public Task<InvalidCastException> AssertTypeUnsupportedRead<T>(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
238          => AssertTypeUnsupportedRead<T, InvalidCastException>(sqlLiteral, pgTypeName, dataSource);
239      public async Task<TException> AssertTypeUnsupportedRead<T, TException>(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
240          where TException : Exception
241      {
242          dataSource ??= DefaultDataSource;
243          await using var conn = await dataSource.OpenConnectionAsync();
244          await using var cmd = new NpgsqlCommand($"SELECT '{sqlLiteral}'::{pgTypeName}", conn);
245          await using var reader = await cmd.ExecuteReaderAsync();
246          await reader.ReadAsync();
247          return Assert.Throws<TException>(() => reader.GetFieldValue<T>(0))!;
248      }
249      public Task<InvalidCastException> AssertTypeUnsupportedWrite<T>(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
250          => AssertTypeUnsupportedWrite<T, InvalidCastException>(value, pgTypeName, dataSource);
251      public async Task<TException> AssertTypeUnsupportedWrite<T, TException>(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
252          where TException : Exception
253      {
254          dataSource ??= DefaultDataSource;
255          await using var conn = await dataSource.OpenConnectionAsync();
256          await using var cmd = new NpgsqlCommand("SELECT $1", conn)
257          {
258              Parameters = { new() { Value = value } }
259          };
260          if (pgTypeName is not null)
261              cmd.Parameters[0].DataTypeName = pgTypeName;
262          return Assert.ThrowsAsync<TException>(() => cmd.ExecuteReaderAsync())!;
263      }
264      class SimpleComparer<T> : IEqualityComparer<T>
265      {
266          readonly Func<T, T, bool> _comparerDelegate;
267          public SimpleComparer(Func<T, T, bool> comparerDelegate)
268              => _comparerDelegate = comparerDelegate;
269          public bool Equals(T? x, T? y)
270              => x is null
271                  ? y is null
272                  : y is not null && _comparerDelegate(x, y);
273          public int GetHashCode(T obj) => throw new NotSupportedException();
274      }
275      #endregion Type testing
276      #region Utilities for use by tests
277      protected static readonly NpgsqlDataSource SharedDataSource = NpgsqlDataSource.Create(TestUtil.ConnectionString);
278      protected virtual NpgsqlDataSourceBuilder CreateDataSourceBuilder()
279          => new(ConnectionString);
280      protected virtual NpgsqlDataSource CreateDataSource()
281          => CreateDataSource(ConnectionString);
282      protected virtual NpgsqlDataSource CreateDataSource(string connectionString)
283          => NpgsqlDataSource.Create(connectionString);
284      protected virtual NpgsqlDataSource CreateDataSource(Action<NpgsqlConnectionStringBuilder> connectionStringBuilderAction)
285      {
286          var connectionStringBuilder = new NpgsqlConnectionStringBuilder(ConnectionString);
287          connectionStringBuilderAction(connectionStringBuilder);
288          return NpgsqlDataSource.Create(connectionStringBuilder);
289      }
290      protected static NpgsqlDataSource GetDataSource(string connectionString)
291      {
292          if (!DataSources.TryGetValue(connectionString, out var dataSource))
293          {
294              lock (dataSourceLockObject)
295              {
296                  if (!DataSources.TryGetValue(connectionString, out dataSource))
297                  {
298                      DataSources[connectionString] = dataSource = NpgsqlDataSource.Create(connectionString);
299                  }
300              }
301          }
302          return dataSource;
303      }
304      protected virtual NpgsqlDataSource CreateLoggingDataSource(
305          out ListLoggerProvider listLoggerProvider,
306          string? connectionString = null,
307          bool sensitiveDataLoggingEnabled = true)
308      {
309          var builder = new NpgsqlDataSourceBuilder(connectionString ?? ConnectionString);
310          var provider = listLoggerProvider = new ListLoggerProvider();
311          builder.UseLoggerFactory(LoggerFactory.Create(loggerFactoryBuilder =>
312          {
313              loggerFactoryBuilder.SetMinimumLevel(LogLevel.Trace);
314              loggerFactoryBuilder.AddProvider(provider);
315          }));
316          builder.EnableParameterLogging(sensitiveDataLoggingEnabled);
317          return builder.Build();
318      }
319      protected NpgsqlDataSource DefaultDataSource
320          => GetDataSource(ConnectionString);
321      protected virtual NpgsqlConnection CreateConnection()
322          => DefaultDataSource.CreateConnection();
323      protected virtual NpgsqlConnection OpenConnection()
324      {
325          var connection = CreateConnection();
326          try
327          {
328              OpenConnection(connection, async: false).GetAwaiter().GetResult();
329              return connection;
330          }
331          catch
332          {
333              connection.Dispose();
334              throw;
335          }
336      }
337      protected virtual async ValueTask<NpgsqlConnection> OpenConnectionAsync()
338      {
339          var connection = CreateConnection();
340          try
341          {
342              await OpenConnection(connection, async: true);
343              return connection;
344          }
345          catch
346          {
347              await connection.DisposeAsync();
348              throw;
349          }
350      }
351      static Task OpenConnection(NpgsqlConnection conn, bool async)
352      {
353          return OpenConnectionInternal(hasLock: false);
354          async Task OpenConnectionInternal(bool hasLock)
355          {
356              try
357              {
358                  if (async)
359                      await conn.OpenAsync();
360                  else
361                      conn.Open();
362              }
363              catch (PostgresException e)
364              {
365                  if (e.SqlState == PostgresErrorCodes.InvalidPassword)
366                      throw new Exception("Please create a user npgsql_tests as follows: CREATE USER npgsql_tests PASSWORD 'npgsql_tests' SUPERUSER");
367                  if (e.SqlState == PostgresErrorCodes.InvalidCatalogName)
368                  {
369                      if (!hasLock)
370                      {
371                          DatabaseCreationLock.Wait();
372                          try
373                          {
374                              await OpenConnectionInternal(hasLock: true);
375                          }
376                          finally
377                          {
378                              DatabaseCreationLock.Release();
379                          }
380                      }
381                      var builder = new NpgsqlConnectionStringBuilder(TestUtil.ConnectionString)
382                      {
383                          Pooling = false,
384                          Multiplexing = false,
385                          Database = "postgres"
386                      };
387                      using var adminConn = new NpgsqlConnection(builder.ConnectionString);
388                      adminConn.Open();
389                      adminConn.ExecuteNonQuery("CREATE DATABASE " + conn.Database);
390                      adminConn.Close();
391                      Thread.Sleep(1000);
392                      if (async)
393                          await conn.OpenAsync();
394                      else
395                          conn.Open();
396                      return;
397                  }
398                  throw;
399              }
400          }
401      }
402      protected static NpgsqlCommand CreateSleepCommand(NpgsqlConnection conn, int seconds = 1000)
403          => new($"SELECT pg_sleep({seconds}){(conn.PostgreSqlVersion < new Version(9, 1, 0) ? "::TEXT" : "")}", conn);
404      #endregion
405  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</div>
                </div>
                <div class="column column_space"><pre><code>66          bool isDefaultForWriting = true,
67          bool? isDefault = null,
68          bool isNpgsqlDbTypeInferredFromClrType = true,
69          Func<T, T, bool>? comparer = null)
70      {
71          if (isDefault is not null)
</pre></code></div>
                <div class="column column_space"><pre><code>48          bool isDefaultForWriting = true,
49          bool? isDefault = null,
50          bool isNpgsqlDbTypeInferredFromClrType = true,
51          Func<T, T, bool>? comparer = null)
52      {
53          await using var connection = await dataSource.OpenConnectionAsync();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    