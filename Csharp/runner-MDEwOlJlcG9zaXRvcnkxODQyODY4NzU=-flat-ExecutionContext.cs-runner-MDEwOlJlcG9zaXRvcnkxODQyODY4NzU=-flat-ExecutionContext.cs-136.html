
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ExecutionContext.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Globalization;
4  using System.IO;
5  using System.Linq;
6  using System.Text;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using GitHub.Actions.RunService.WebApi;
10  using GitHub.DistributedTask.Expressions2;
11  using GitHub.DistributedTask.ObjectTemplating.Tokens;
12  using GitHub.DistributedTask.Pipelines.ContextData;
13  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
14  using GitHub.DistributedTask.WebApi;
15  using GitHub.Runner.Common;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  using GitHub.Runner.Worker.Container;
19  using GitHub.Runner.Worker.Handlers;
20  using Newtonsoft.Json;
21  using Sdk.RSWebApi.Contracts;
22  using ObjectTemplating = GitHub.DistributedTask.ObjectTemplating;
23  using Pipelines = GitHub.DistributedTask.Pipelines;
24  namespace GitHub.Runner.Worker
25  {
26      public static class ExecutionContextType
27      {
28          public const string Job = &quot;Job&quot;;
29          public const string Task = &quot;Task&quot;;
30      }
31      public record ExecutionContextLogOptions(bool WriteToLog, string LogMessageOverride)
32      {
33          public static readonly ExecutionContextLogOptions None = new(false, null);
34          public static readonly ExecutionContextLogOptions Default = new(true, null);
35      }
36      [ServiceLocator(Default = typeof(ExecutionContext))]
37      public interface IExecutionContext : IRunnerService
38      {
39          Guid Id { get; }
40          Guid EmbeddedId { get; }
41          string ScopeName { get; }
42          string SiblingScopeName { get; }
43          string ContextName { get; }
44          ActionRunStage Stage { get; }
45          Task ForceCompleted { get; }
46          TaskResult? Result { get; set; }
47          TaskResult? Outcome { get; set; }
48          string ResultCode { get; set; }
49          TaskResult? CommandResult { get; set; }
50          CancellationToken CancellationToken { get; }
51          GlobalContext Global { get; }
52          Dictionary&lt;string, string&gt; IntraActionState { get; }
53          Dictionary&lt;string, VariableValue&gt; JobOutputs { get; }
54          ActionsEnvironmentReference ActionsEnvironment { get; }
55          ActionsStepTelemetry StepTelemetry { get; }
56          DictionaryContextData ExpressionValues { get; }
57          IList&lt;IFunctionInfo&gt; ExpressionFunctions { get; }
58          JobContext JobContext { get; }
59          Queue&lt;IStep&gt; JobSteps { get; }
60          Stack&lt;IStep&gt; PostJobSteps { get; }
61          Dictionary&lt;Guid, string&gt; EmbeddedStepsWithPostRegistered { get; }
62          Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt; EmbeddedIntraActionState { get; }
63          bool EchoOnActionCommand { get; set; }
64          bool IsEmbedded { get; }
65          List&lt;string&gt; StepEnvironmentOverrides { get; }
66          ExecutionContext Root { get; }
67          void InitializeJob(Pipelines.AgentJobRequestMessage message, CancellationToken token);
68          void CancelToken();
69          IExecutionContext CreateChild(Guid recordId, string displayName, string refName, string scopeName, string contextName, ActionRunStage stage, Dictionary&lt;string, string&gt; intraActionState = null, int? recordOrder = null, IPagingLogger logger = null, bool isEmbedded = false, CancellationTokenSource cancellationTokenSource = null, Guid embeddedId = default(Guid), string siblingScopeName = null);
70          IExecutionContext CreateEmbeddedChild(string scopeName, string contextName, Guid embeddedId, ActionRunStage stage, Dictionary&lt;string, string&gt; intraActionState = null, string siblingScopeName = null);
71          long Write(string tag, string message);
72          void QueueAttachFile(string type, string name, string filePath);
73          void QueueSummaryFile(string name, string filePath, Guid stepRecordId);
74          void Start(string currentOperation = null);
75          TaskResult Complete(TaskResult? result = null, string currentOperation = null, string resultCode = null);
76          void SetEnvContext(string name, string value);
77          void SetRunnerContext(string name, string value);
78          string GetGitHubContext(string name);
79          void SetGitHubContext(string name, string value);
80          void SetOutput(string name, string value, out string reference);
81          void SetTimeout(TimeSpan? timeout);
82          void AddIssue(Issue issue, ExecutionContextLogOptions logOptions);
83          void Progress(int percentage, string currentOperation = null);
84          void UpdateDetailTimelineRecord(TimelineRecord record);
85          void UpdateTimelineRecordDisplayName(string displayName);
86          void Add(OnMatcherChanged handler);
87          void Remove(OnMatcherChanged handler);
88          void AddMatchers(IssueMatchersConfig matcher);
89          void RemoveMatchers(IEnumerable&lt;string&gt; owners);
90          IEnumerable&lt;IssueMatcherConfig&gt; GetMatchers();
91          void ForceTaskComplete();
92          void RegisterPostJobStep(IStep step);
93          void PublishStepTelemetry();
94          void ApplyContinueOnError(TemplateToken continueOnError);
95          void UpdateGlobalStepsContext();
96          void WriteWebhookPayload();
97      }
98      public sealed class ExecutionContext : RunnerService, IExecutionContext
99      {
100          private const int _maxCountPerIssueType = 10;
101          private const int _throttlingDelayReportThreshold = 10 * 1000; 
102          private const int _maxIssueMessageLength = 4096; 
103          private const int _maxIssueCountInTelemetry = 3; 
104          private const int _maxIssueMessageLengthInTelemetry = 256; 
105          private readonly TimelineRecord _record = new();
106          private readonly Dictionary&lt;Guid, TimelineRecord&gt; _detailRecords = new();
107          private readonly List&lt;Issue&gt; _embeddedIssueCollector;
108          private readonly object _loggerLock = new();
109          private readonly object _matchersLock = new();
110          private readonly ExecutionContext _parentExecutionContext;
111          private event OnMatcherChanged _onMatcherChanged;
112          private IssueMatcherConfig[] _matchers;
113          private IPagingLogger _logger;
114          private IJobServerQueue _jobServerQueue;
115          private Guid _mainTimelineId;
116          private Guid _detailTimelineId;
117          private bool _expandedForPostJob = false;
118          private int _childTimelineRecordOrder = 0;
119          private CancellationTokenSource _cancellationTokenSource;
120          private TaskCompletionSource&lt;int&gt; _forceCompleted = new();
121          private bool _throttlingReported = false;
122          private long _totalThrottlingDelayInMilliseconds = 0;
123          private bool _stepTelemetryPublished = false;
124          public ExecutionContext()
125              : this(parent: null, embedded: false)
126          {
127          }
128          private ExecutionContext(ExecutionContext parent, bool embedded)
129          {
130              if (embedded)
131              {
132                  ArgUtil.NotNull(parent, nameof(parent));
133              }
134              _parentExecutionContext = parent;
135              this.IsEmbedded = embedded;
136              this.StepTelemetry = new ActionsStepTelemetry
137              {
138                  IsEmbedded = embedded
139              };
140              _embeddedIssueCollector = embedded ? parent._embeddedIssueCollector : new();
141          }
142          public Guid Id =&gt; _record.Id;
143          public Guid EmbeddedId { get; private set; }
144          public string ScopeName { get; private set; }
145          public string SiblingScopeName { get; private set; }
146          public string ContextName { get; private set; }
147          public ActionRunStage Stage { get; private set; }
148          public Task ForceCompleted =&gt; _forceCompleted.Task;
149          public CancellationToken CancellationToken =&gt; _cancellationTokenSource.Token;
150          public Dictionary&lt;string, string&gt; IntraActionState { get; private set; }
151          public Dictionary&lt;string, VariableValue&gt; JobOutputs { get; private set; }
152          public ActionsEnvironmentReference ActionsEnvironment { get; private set; }
153          public ActionsStepTelemetry StepTelemetry { get; private init; }
154          public DictionaryContextData ExpressionValues { get; } = new DictionaryContextData();
155          public IList&lt;IFunctionInfo&gt; ExpressionFunctions { get; } = new List&lt;IFunctionInfo&gt;();
156          public GlobalContext Global { get; private set; }
157          public Queue&lt;IStep&gt; JobSteps { get; private set; }
158          public Stack&lt;IStep&gt; PostJobSteps { get; private set; }
159          public HashSet&lt;Guid&gt; StepsWithPostRegistered { get; private set; }
160          public Dictionary&lt;Guid, string&gt; EmbeddedStepsWithPostRegistered { get; private set; }
161          public Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt; EmbeddedIntraActionState { get; private set; }
162          public bool EchoOnActionCommand { get; set; }
163          public bool IsEmbedded { get; private init; }
164          public TaskResult? Result
165          {
166              get
167              {
168                  return _record.Result;
169              }
170              set
171              {
172                  _record.Result = value;
173              }
174          }
175          public TaskResult? Outcome { get; set; }
176          public TaskResult? CommandResult { get; set; }
177          private string ContextType =&gt; _record.RecordType;
178          public string ResultCode
179          {
180              get
181              {
182                  return _record.ResultCode;
183              }
184              set
185              {
186                  _record.ResultCode = value;
187              }
188          }
189          public ExecutionContext Root
190          {
191              get
192              {
193                  var result = this;
194                  while (result._parentExecutionContext != null)
195                  {
196                      result = result._parentExecutionContext;
197                  }
198                  return result;
199              }
200          }
201          public JobContext JobContext
202          {
203              get
204              {
205                  return ExpressionValues[&quot;job&quot;] as JobContext;
206              }
207          }
208          public List&lt;string&gt; StepEnvironmentOverrides { get; } = new List&lt;string&gt;();
209          public override void Initialize(IHostContext hostContext)
210          {
211              base.Initialize(hostContext);
212              _jobServerQueue = HostContext.GetService&lt;IJobServerQueue&gt;();
213          }
214          public void CancelToken()
215          {
216              try
217              {
218                  _cancellationTokenSource.Cancel();
219              }
220              catch (ObjectDisposedException e)
221              {
222                  Trace.Info($&quot;Attempted to cancel a disposed token, the execution is already complete: {e.ToString()}&quot;);
223              }
224          }
225          public void ForceTaskComplete()
226          {
227              Trace.Info(&quot;Force finish current task in 5 sec.&quot;);
228              Task.Run(async () =&gt;
229              {
230                  await Task.Delay(TimeSpan.FromSeconds(5));
231                  _forceCompleted?.TrySetResult(1);
232              });
233          }
234          public void RegisterPostJobStep(IStep step)
235          {
236              string siblingScopeName = null;
237              if (this.IsEmbedded)
238              {
239                  if (step is IActionRunner actionRunner)
240                  {
241                      if (Root.EmbeddedStepsWithPostRegistered.ContainsKey(actionRunner.Action.Id))
242                      {
243                          Trace.Info($&quot;&#x27;post&#x27; of &#x27;{actionRunner.DisplayName}&#x27; already push to child post step stack.&quot;);
244                      }
245                      else
246                      {
247                          Root.EmbeddedStepsWithPostRegistered[actionRunner.Action.Id] = actionRunner.Condition;
248                      }
249                      return;
250                  }
251              }
252              else if (step is IActionRunner actionRunner &amp;&amp; !Root.StepsWithPostRegistered.Add(actionRunner.Action.Id))
253              {
254                  Trace.Info($&quot;&#x27;post&#x27; of &#x27;{actionRunner.DisplayName}&#x27; already push to post step stack.&quot;);
255                  return;
256              }
257              if (step is IActionRunner runner)
258              {
259                  siblingScopeName = runner.Action.ContextName;
260              }
261              step.ExecutionContext = Root.CreatePostChild(step.DisplayName, IntraActionState, siblingScopeName);
262              Root.PostJobSteps.Push(step);
263          }
264          public IExecutionContext CreateChild(
265              Guid recordId,
266              string displayName,
267              string refName,
268              string scopeName,
269              string contextName,
270              ActionRunStage stage,
271              Dictionary&lt;string, string&gt; intraActionState = null,
272              int? recordOrder = null,
273              IPagingLogger logger = null,
274              bool isEmbedded = false,
275              CancellationTokenSource cancellationTokenSource = null,
276              Guid embeddedId = default(Guid),
277              string siblingScopeName = null)
278          {
279              Trace.Entering();
280              var child = new ExecutionContext(this, isEmbedded);
281              child.Initialize(HostContext);
282              child.Global = Global;
283              child.ScopeName = scopeName;
284              child.ContextName = contextName;
285              child.Stage = stage;
286              child.EmbeddedId = embeddedId;
287              child.SiblingScopeName = siblingScopeName;
288              if (intraActionState == null)
289              {
290                  child.IntraActionState = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
291              }
292              else
293              {
294                  child.IntraActionState = intraActionState;
295              }
296              foreach (var pair in ExpressionValues)
297              {
298                  child.ExpressionValues[pair.Key] = pair.Value;
299              }
300              foreach (var item in ExpressionFunctions)
301              {
302                  child.ExpressionFunctions.Add(item);
303              }
304              child._cancellationTokenSource = cancellationTokenSource ?? new CancellationTokenSource();
305              child.EchoOnActionCommand = EchoOnActionCommand;
306              if (recordOrder != null)
307              {
308                  child.InitializeTimelineRecord(_mainTimelineId, recordId, _record.Id, ExecutionContextType.Task, displayName, refName, recordOrder);
309              }
310              else
311              {
312                  child.InitializeTimelineRecord(_mainTimelineId, recordId, _record.Id, ExecutionContextType.Task, displayName, refName, ++_childTimelineRecordOrder);
313              }
314              if (logger != null)
315              {
316                  child._logger = logger;
317              }
318              else
319              {
320                  child._logger = HostContext.CreateService&lt;IPagingLogger&gt;();
321                  child._logger.Setup(_mainTimelineId, recordId);
322              }
323              child.StepTelemetry.StepId = recordId;
324              child.StepTelemetry.Stage = stage.ToString();
325              child.StepTelemetry.StepContextName = child.GetFullyQualifiedContextName();
326              return child;
327          }
328          public IExecutionContext CreateEmbeddedChild(
329              string scopeName,
330              string contextName,
331              Guid embeddedId,
332              ActionRunStage stage,
333              Dictionary&lt;string, string&gt; intraActionState = null,
334              string siblingScopeName = null)
335          {
336              return Root.CreateChild(_record.Id, _record.Name, _record.Id.ToString(&quot;N&quot;), scopeName, contextName, stage, logger: _logger, isEmbedded: true, cancellationTokenSource: CancellationTokenSource.CreateLinkedTokenSource(_cancellationTokenSource.Token), intraActionState: intraActionState, embeddedId: embeddedId, siblingScopeName: siblingScopeName);
337          }
338          public void Start(string currentOperation = null)
339          {
340              _record.CurrentOperation = currentOperation ?? _record.CurrentOperation;
341              _record.StartTime = DateTime.UtcNow;
342              _record.State = TimelineRecordState.InProgress;
343              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
344          }
345          public TaskResult Complete(TaskResult? result = null, string currentOperation = null, string resultCode = null)
346          {
347              if (result != null)
348              {
349                  Result = result;
350              }
351              if (_totalThrottlingDelayInMilliseconds &gt; _throttlingDelayReportThreshold)
352              {
353                  this.Warning($&quot;The job has experienced {TimeSpan.FromMilliseconds(_totalThrottlingDelayInMilliseconds).TotalSeconds} seconds total delay caused by server throttling.&quot;);
354              }
355              DateTime now = DateTime.UtcNow;
356              _record.CurrentOperation = currentOperation ?? _record.CurrentOperation;
357              _record.ResultCode = resultCode ?? _record.ResultCode;
358              _record.FinishTime = now;
359              _record.PercentComplete = 100;
360              _record.Result = _record.Result ?? TaskResult.Succeeded;
361              _record.State = TimelineRecordState.Completed;
362              if (!this.IsEmbedded)
363              {
364                  foreach (var issue in _embeddedIssueCollector)
365                  {
366                      AddIssue(issue, ExecutionContextLogOptions.None);
367                  }
368              }
369              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
370              if (_detailTimelineId != Guid.Empty &amp;&amp; _detailRecords.Count &gt; 0)
371              {
372                  foreach (var record in _detailRecords)
373                  {
374                      record.Value.FinishTime = record.Value.FinishTime ?? now;
375                      record.Value.PercentComplete = record.Value.PercentComplete ?? 100;
376                      record.Value.Result = record.Value.Result ?? TaskResult.Succeeded;
377                      record.Value.State = TimelineRecordState.Completed;
378                      _jobServerQueue.QueueTimelineRecordUpdate(_detailTimelineId, record.Value);
379                  }
380              }
381              PublishStepTelemetry();
382              var stepResult = new StepResult
383              {
384                  ExternalID = _record.Id,
385                  Conclusion = _record.Result ?? TaskResult.Succeeded,
386                  Status = _record.State,
387                  Number = _record.Order,
388                  Name = _record.Name,
389                  StartedAt = _record.StartTime,
390                  CompletedAt = _record.FinishTime,
391                  Annotations = new List&lt;Annotation&gt;()
392              };
393              _record.Issues?.ForEach(issue =&gt;
394              {
395                  var annotation = issue.ToAnnotation();
396                  if (annotation != null)
397                  {
398                      stepResult.Annotations.Add(annotation.Value);
399                  }
400              });
401              Global.StepsResult.Add(stepResult);
402              if (Root != this)
403              {
404                  _cancellationTokenSource?.Dispose();
405              }
406              _logger.End();
407              UpdateGlobalStepsContext();
408              return Result.Value;
409          }
410          public void UpdateGlobalStepsContext()
411          {
412              if (!string.IsNullOrEmpty(ContextName) &amp;&amp; !ContextName.StartsWith(&quot;__&quot;, StringComparison.Ordinal))
413              {
414                  Global.StepsContext.SetOutcome(ScopeName, ContextName, (Outcome ?? Result ?? TaskResult.Succeeded).ToActionResult());
415                  Global.StepsContext.SetConclusion(ScopeName, ContextName, (Result ?? TaskResult.Succeeded).ToActionResult());
416              }
417          }
418          public void SetRunnerContext(string name, string value)
419          {
420              ArgUtil.NotNullOrEmpty(name, nameof(name));
421              var runnerContext = ExpressionValues[&quot;runner&quot;] as RunnerContext;
422              runnerContext[name] = new StringContextData(value);
423          }
424          public void SetEnvContext(string name, string value)
425          {
426              ArgUtil.NotNullOrEmpty(name, nameof(name));
427  #if OS_WINDOWS
428              var envContext = ExpressionValues[&quot;env&quot;] as DictionaryContextData;
429              envContext[name] = new StringContextData(value);
430  #else
<span onclick='openModal()' class='match'>431              var envContext = ExpressionValues[&quot;env&quot;] as CaseSensitiveDictionaryContextData;
432              envContext[name] = new StringContextData(value);
433  #endif
</span>434          }
435          public void SetGitHubContext(string name, string value)
436          {
437              ArgUtil.NotNullOrEmpty(name, nameof(name));
438              var githubContext = ExpressionValues[&quot;github&quot;] as GitHubContext;
439              githubContext[name] = new StringContextData(value);
440          }
441          public string GetGitHubContext(string name)
442          {
443              ArgUtil.NotNullOrEmpty(name, nameof(name));
444              var githubContext = ExpressionValues[&quot;github&quot;] as GitHubContext;
445              if (githubContext.TryGetValue(name, out var value))
446              {
447                  if (value is StringContextData)
448                  {
449                      return value as StringContextData;
450                  }
451                  else
452                  {
453                      return value.ToJToken().ToString(Formatting.Indented);
454                  }
455              }
456              else
457              {
458                  return null;
459              }
460          }
461          public void SetOutput(string name, string value, out string reference)
462          {
463              ArgUtil.NotNullOrEmpty(name, nameof(name));
464              if (string.IsNullOrEmpty(ContextName) || ContextName.StartsWith(&quot;__&quot;, StringComparison.Ordinal))
465              {
466                  reference = null;
467                  return;
468              }
469              Global.StepsContext.SetOutput(ScopeName, ContextName, name, value, out reference);
470          }
471          public void SetTimeout(TimeSpan? timeout)
472          {
473              if (timeout != null)
474              {
475                  _cancellationTokenSource.CancelAfter(timeout.Value);
476              }
477          }
478          public void Progress(int percentage, string currentOperation = null)
479          {
480              if (percentage &gt; 100 || percentage &lt; 0)
481              {
482                  throw new ArgumentOutOfRangeException(nameof(percentage));
483              }
484              _record.CurrentOperation = currentOperation ?? _record.CurrentOperation;
485              _record.PercentComplete = Math.Max(percentage, _record.PercentComplete.Value);
486              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
487          }
488          public void AddIssue(Issue issue, ExecutionContextLogOptions logOptions)
489          {
490              ArgUtil.NotNull(issue, nameof(issue));
491              ArgUtil.NotNull(logOptions, nameof(logOptions));
492              issue.Message = HostContext.SecretMasker.MaskSecrets(issue.Message);
493              if (issue.Message.Length &gt; _maxIssueMessageLength)
494              {
495                  issue.Message = issue.Message[.._maxIssueMessageLength];
496              }
497              if (_record.Order != null)
498              {
499                  issue.Data[&quot;stepNumber&quot;] = _record.Order.ToString();
500              }
501              string wellKnownTag = null;
502              Int32 previousCountForIssueType = 0;
503              Action incrementIssueTypeCount = NoOp;
504              switch (issue.Type)
505              {
506                  case IssueType.Error:
507                      wellKnownTag = WellKnownTags.Error;
508                      previousCountForIssueType = _record.ErrorCount;
509                      incrementIssueTypeCount = () =&gt; { _record.ErrorCount++; };
510                      break;
511                  case IssueType.Warning:
512                      wellKnownTag = WellKnownTags.Warning;
513                      previousCountForIssueType = _record.WarningCount;
514                      incrementIssueTypeCount = () =&gt; { _record.WarningCount++; };
515                      break;
516                  case IssueType.Notice:
517                      wellKnownTag = WellKnownTags.Notice;
518                      previousCountForIssueType = _record.NoticeCount;
519                      incrementIssueTypeCount = () =&gt; { _record.NoticeCount++; };
520                      break;
521              }
522              if (!string.IsNullOrEmpty(wellKnownTag))
523              {
524                  if (!this.IsEmbedded &amp;&amp; previousCountForIssueType &lt; _maxCountPerIssueType)
525                  {
526                      incrementIssueTypeCount();
527                      _record.Issues.Add(issue);
528                  }
529                  if (logOptions.WriteToLog)
530                  {
531                      string logMessage = issue.Message;
532                      if (!string.IsNullOrEmpty(logOptions.LogMessageOverride))
533                      {
534                          logMessage = logOptions.LogMessageOverride;
535                      }
536                      if (!string.IsNullOrEmpty(logMessage))
537                      {
538                          long logLineNumber = Write(wellKnownTag, logMessage);
539                          issue.Data[&quot;logFileLineNumber&quot;] = logLineNumber.ToString();
540                      }
541                  }
542              }
543              if (this.IsEmbedded)
544              {
545                  _embeddedIssueCollector.Add(issue);
546              }
547              else
548              {
549                  _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
550              }
551          }
552          public void UpdateDetailTimelineRecord(TimelineRecord record)
553          {
554              ArgUtil.NotNull(record, nameof(record));
555              if (record.RecordType == ExecutionContextType.Job)
556              {
557                  throw new ArgumentOutOfRangeException(nameof(record));
558              }
559              if (_detailTimelineId == Guid.Empty)
560              {
561                  _detailTimelineId = Guid.NewGuid();
562                  _record.Details = new Timeline(_detailTimelineId);
563                  _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
564              }
565              TimelineRecord existRecord;
566              if (_detailRecords.TryGetValue(record.Id, out existRecord))
567              {
568                  existRecord.Name = record.Name ?? existRecord.Name;
569                  existRecord.RecordType = record.RecordType ?? existRecord.RecordType;
570                  existRecord.Order = record.Order ?? existRecord.Order;
571                  existRecord.ParentId = record.ParentId ?? existRecord.ParentId;
572                  existRecord.StartTime = record.StartTime ?? existRecord.StartTime;
573                  existRecord.FinishTime = record.FinishTime ?? existRecord.FinishTime;
574                  existRecord.PercentComplete = record.PercentComplete ?? existRecord.PercentComplete;
575                  existRecord.CurrentOperation = record.CurrentOperation ?? existRecord.CurrentOperation;
576                  existRecord.Result = record.Result ?? existRecord.Result;
577                  existRecord.ResultCode = record.ResultCode ?? existRecord.ResultCode;
578                  existRecord.State = record.State ?? existRecord.State;
579                  _jobServerQueue.QueueTimelineRecordUpdate(_detailTimelineId, existRecord);
580              }
581              else
582              {
583                  _detailRecords[record.Id] = record;
584                  _jobServerQueue.QueueTimelineRecordUpdate(_detailTimelineId, record);
585              }
586          }
587          public void UpdateTimelineRecordDisplayName(string displayName)
588          {
589              ArgUtil.NotNull(displayName, nameof(displayName));
590              _record.Name = displayName;
591              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
592          }
593          public void InitializeJob(Pipelines.AgentJobRequestMessage message, CancellationToken token)
594          {
595              Trace.Entering();
596              ArgUtil.NotNull(message, nameof(message));
597              ArgUtil.NotNull(message.Resources, nameof(message.Resources));
598              ArgUtil.NotNull(message.Variables, nameof(message.Variables));
599              ArgUtil.NotNull(message.Plan, nameof(message.Plan));
600              _cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token);
601              Global = new GlobalContext();
602              Global.Plan = message.Plan;
603              Global.Features = PlanUtil.GetFeatures(message.Plan);
604              Global.Endpoints = message.Resources.Endpoints;
605              var variables = message.Variables;
606              SetDebugUsingVars(variables, message.ContextData);
607              Global.Variables = new Variables(HostContext, variables);
608              if (Global.Variables.GetBoolean(&quot;DistributedTask.ForceInternalNodeVersionOnRunnerTo12&quot;) ?? false)
609              {
610                  Environment.SetEnvironmentVariable(Constants.Variables.Agent.ForcedInternalNodeVersion, &quot;node12&quot;);
611              }
612              Global.EnvironmentVariables = new Dictionary&lt;string, string&gt;(VarUtil.EnvironmentVariableKeyComparer);
613              Global.JobDefaults = new Dictionary&lt;string, IDictionary&lt;string, string&gt;&gt;(StringComparer.OrdinalIgnoreCase);
614              Global.JobTelemetry = new List&lt;JobTelemetry&gt;();
615              Global.StepsTelemetry = new List&lt;ActionsStepTelemetry&gt;();
616              Global.StepsResult = new List&lt;StepResult&gt;();
617              Global.JobAnnotations = new List&lt;Annotation&gt;();
618              JobOutputs = new Dictionary&lt;string, VariableValue&gt;(StringComparer.OrdinalIgnoreCase);
619              ActionsEnvironment = message.ActionsEnvironment;
620              Global.ServiceContainers = new List&lt;ContainerInfo&gt;();
621              Global.StepsContext = new StepsContext();
622              Global.FileTable = new List&lt;String&gt;(message.FileTable ?? new string[0]);
623              Global.Variables.Set(Constants.Variables.System.JobRequestType, message.MessageType);
624              if (message.ContextData?.Count &gt; 0)
625              {
626                  foreach (var pair in message.ContextData)
627                  {
628                      ExpressionValues[pair.Key] = pair.Value;
629                  }
630              }
631              ExpressionValues[&quot;secrets&quot;] = Global.Variables.ToSecretsContext();
632              ExpressionValues[&quot;runner&quot;] = new RunnerContext();
633              ExpressionValues[&quot;job&quot;] = new JobContext();
634              Trace.Info(&quot;Initialize GitHub context&quot;);
635              var githubAccessToken = new StringContextData(Global.Variables.Get(&quot;system.github.token&quot;));
636              var base64EncodedToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{githubAccessToken}&quot;));
637              HostContext.SecretMasker.AddValue(base64EncodedToken);
638              var githubJob = Global.Variables.Get(&quot;system.github.job&quot;);
639              var githubContext = new GitHubContext();
640              githubContext[&quot;token&quot;] = githubAccessToken;
641              if (!string.IsNullOrEmpty(githubJob))
642              {
643                  githubContext[&quot;job&quot;] = new StringContextData(githubJob);
644              }
645              var githubDictionary = ExpressionValues[&quot;github&quot;].AssertDictionary(&quot;github&quot;);
646              foreach (var pair in githubDictionary)
647              {
648                  githubContext[pair.Key] = pair.Value;
649              }
650              ExpressionValues[&quot;github&quot;] = githubContext;
651              Trace.Info(&quot;Initialize Env context&quot;);
652  #if OS_WINDOWS
653              ExpressionValues[&quot;env&quot;] = new DictionaryContextData();
654  #else
655              ExpressionValues[&quot;env&quot;] = new CaseSensitiveDictionaryContextData();
656  #endif
657              Global.PrependPath = new List&lt;string&gt;();
658              JobSteps = new Queue&lt;IStep&gt;();
659              PostJobSteps = new Stack&lt;IStep&gt;();
660              StepsWithPostRegistered = new HashSet&lt;Guid&gt;();
661              EmbeddedStepsWithPostRegistered = new Dictionary&lt;Guid, string&gt;();
662              EmbeddedIntraActionState = new Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt;();
663              InitializeTimelineRecord(
664                  timelineId: message.Timeline.Id,
665                  timelineRecordId: message.JobId,
666                  parentTimelineRecordId: null,
667                  recordType: ExecutionContextType.Job,
668                  displayName: message.JobDisplayName,
669                  refName: message.JobName,
670                  order: null); 
671              _logger = HostContext.CreateService&lt;IPagingLogger&gt;();
672              _logger.Setup(_mainTimelineId, _record.Id);
673              EchoOnActionCommand = Global.Variables.Step_Debug ?? false;
674              Global.WriteDebug = Global.Variables.Step_Debug ?? false;
675              _jobServerQueue.JobServerQueueThrottling += JobServerQueueThrottling_EventReceived;
676          }
677          public long Write(string tag, string message)
678          {
679              string msg = HostContext.SecretMasker.MaskSecrets($&quot;{tag}{message}&quot;);
680              long totalLines;
681              lock (_loggerLock)
682              {
683                  totalLines = _logger.TotalLines + 1;
684                  _logger.Write(msg);
685              }
686              if (_parentExecutionContext != null)
687              {
688                  lock (_parentExecutionContext._loggerLock)
689                  {
690                      _parentExecutionContext._logger.Write(msg);
691                  }
692              }
693              _jobServerQueue.QueueWebConsoleLine(_record.Id, msg, totalLines);
694              return totalLines;
695          }
696          public void QueueAttachFile(string type, string name, string filePath)
697          {
698              ArgUtil.NotNullOrEmpty(type, nameof(type));
699              ArgUtil.NotNullOrEmpty(name, nameof(name));
700              ArgUtil.NotNullOrEmpty(filePath, nameof(filePath));
701              if (!File.Exists(filePath))
702              {
703                  throw new FileNotFoundException($&quot;Can&#x27;t attach (type:{type} name:{name}) file: {filePath}. File does not exist.&quot;);
704              }
705              _jobServerQueue.QueueFileUpload(_mainTimelineId, _record.Id, type, name, filePath, deleteSource: false);
706          }
707          public void QueueSummaryFile(string name, string filePath, Guid stepRecordId)
708          {
709              ArgUtil.NotNullOrEmpty(name, nameof(name));
710              ArgUtil.NotNullOrEmpty(filePath, nameof(filePath));
711              if (!File.Exists(filePath))
712              {
713                  throw new FileNotFoundException($&quot;Can&#x27;t upload (name:{name}) file: {filePath}. File does not exist.&quot;);
714              }
715              _jobServerQueue.QueueResultsUpload(stepRecordId, name, filePath, ChecksAttachmentType.StepSummary, deleteSource: false, finalize: true, firstBlock: true, totalLines: 0);
716          }
717          public void Add(OnMatcherChanged handler)
718          {
719              Root._onMatcherChanged += handler;
720          }
721          public void Remove(OnMatcherChanged handler)
722          {
723              Root._onMatcherChanged -= handler;
724          }
725          public void AddMatchers(IssueMatchersConfig config)
726          {
727              var root = Root;
728              lock (root._matchersLock)
729              {
730                  var newMatchers = new List&lt;IssueMatcherConfig&gt;();
731                  var newOwners = new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase);
732                  foreach (var matcher in config.Matchers)
733                  {
734                      newOwners.Add(matcher.Owner);
735                      newMatchers.Add(matcher);
736                  }
737                  var existingMatchers = root._matchers ?? Array.Empty&lt;IssueMatcherConfig&gt;();
738                  newMatchers.AddRange(existingMatchers.Where(x =&gt; !newOwners.Contains(x.Owner)));
739                  root._matchers = newMatchers.ToArray();
740                  foreach (var matcher in config.Matchers)
741                  {
742                      root._onMatcherChanged(null, new MatcherChangedEventArgs(matcher));
743                  }
744                  var owners = config.Matchers.Select(x =&gt; $&quot;&#x27;{x.Owner}&#x27;&quot;);
745                  var joinedOwners = string.Join(&quot;, &quot;, owners);
746                  this.Debug($&quot;Added matchers: {joinedOwners}. Problem matchers scan action output for known warning or error strings and report these inline.&quot;);
747              }
748          }
749          public void RemoveMatchers(IEnumerable&lt;string&gt; owners)
750          {
751              var root = Root;
752              var distinctOwners = new HashSet&lt;string&gt;(owners, StringComparer.OrdinalIgnoreCase);
753              var removedMatchers = new List&lt;IssueMatcherConfig&gt;();
754              var newMatchers = new List&lt;IssueMatcherConfig&gt;();
755              lock (root._matchersLock)
756              {
757                  var existingMatchers = root._matchers ?? Array.Empty&lt;IssueMatcherConfig&gt;();
758                  foreach (var matcher in existingMatchers)
759                  {
760                      if (distinctOwners.Contains(matcher.Owner))
761                      {
762                          removedMatchers.Add(matcher);
763                      }
764                      else
765                      {
766                          newMatchers.Add(matcher);
767                      }
768                  }
769                  root._matchers = newMatchers.ToArray();
770                  foreach (var removedMatcher in removedMatchers)
771                  {
772                      root._onMatcherChanged(null, new MatcherChangedEventArgs(new IssueMatcherConfig { Owner = removedMatcher.Owner }));
773                  }
774                  owners = removedMatchers.Select(x =&gt; $&quot;&#x27;{x.Owner}&#x27;&quot;);
775                  var joinedOwners = string.Join(&quot;, &quot;, owners);
776                  this.Debug($&quot;Removed matchers: {joinedOwners}&quot;);
777              }
778          }
779          public IEnumerable&lt;IssueMatcherConfig&gt; GetMatchers()
780          {
781              return Root._matchers ?? Array.Empty&lt;IssueMatcherConfig&gt;();
782          }
783          public void PublishStepTelemetry()
784          {
785              if (!_stepTelemetryPublished)
786              {
787                  if (!string.IsNullOrEmpty(StepTelemetry?.Type))
788                  {
789                      if (!IsEmbedded)
790                      {
791                          StepTelemetry.Result = _record.Result;
792                      }
793                      if (!IsEmbedded &amp;&amp;
794                          _record.FinishTime != null &amp;&amp;
795                          _record.StartTime != null)
796                      {
797                          StepTelemetry.ExecutionTimeInSeconds = (int)Math.Ceiling((_record.FinishTime - _record.StartTime)?.TotalSeconds ?? 0);
798                          StepTelemetry.StartTime = _record.StartTime;
799                          StepTelemetry.FinishTime = _record.FinishTime;
800                      }
801                      if (!IsEmbedded)
802                      {
803                          foreach (var issue in _record.Issues)
804                          {
805                              if ((issue.Type == IssueType.Error || issue.Type == IssueType.Warning) &amp;&amp;
806                                  !string.IsNullOrEmpty(issue.Message))
807                              {
808                                  string issueTelemetry;
809                                  if (issue.Message.Length &gt; _maxIssueMessageLengthInTelemetry)
810                                  {
811                                      issueTelemetry = $&quot;{issue.Message[.._maxIssueMessageLengthInTelemetry]}&quot;;
812                                  }
813                                  else
814                                  {
815                                      issueTelemetry = issue.Message;
816                                  }
817                                  StepTelemetry.ErrorMessages.Add(issueTelemetry);
818                                  if (StepTelemetry.ErrorMessages.Count &gt;= _maxIssueCountInTelemetry)
819                                  {
820                                      break;
821                                  }
822                              }
823                          }
824                      }
825                      Trace.Info($&quot;Publish step telemetry for current step {StringUtil.ConvertToJson(StepTelemetry)}.&quot;);
826                      Global.StepsTelemetry.Add(StepTelemetry);
827                      _stepTelemetryPublished = true;
828                  }
829              }
830              else
831              {
832                  Trace.Info($&quot;Step telemetry has already been published.&quot;);
833              }
834          }
835          public void WriteWebhookPayload()
836          {
837              var tempDirectory = HostContext.GetDirectory(WellKnownDirectory.Temp);
838              var workflowDirectory = Path.Combine(tempDirectory, &quot;_github_workflow&quot;);
839              Directory.CreateDirectory(workflowDirectory);
840              var gitHubEvent = GetGitHubContext(&quot;event&quot;);
841              if (gitHubEvent != null)
842              {
843                  var workflowFile = Path.Combine(workflowDirectory, &quot;event.json&quot;);
844                  Trace.Info($&quot;Write event payload to {workflowFile}&quot;);
845                  File.WriteAllText(workflowFile, gitHubEvent, new UTF8Encoding(false));
846                  SetGitHubContext(&quot;event_path&quot;, workflowFile);
847              }
848          }
849          private void InitializeTimelineRecord(Guid timelineId, Guid timelineRecordId, Guid? parentTimelineRecordId, string recordType, string displayName, string refName, int? order)
850          {
851              _mainTimelineId = timelineId;
852              _record.Id = timelineRecordId;
853              _record.RecordType = recordType;
854              _record.Name = displayName;
855              _record.RefName = refName;
856              _record.Order = order;
857              _record.PercentComplete = 0;
858              _record.State = TimelineRecordState.Pending;
859              _record.ErrorCount = 0;
860              _record.WarningCount = 0;
861              _record.NoticeCount = 0;
862              if (parentTimelineRecordId != null &amp;&amp; parentTimelineRecordId.Value != Guid.Empty)
863              {
864                  _record.ParentId = parentTimelineRecordId;
865              }
866              else if (parentTimelineRecordId == null)
867              {
868                  _record.AgentPlatform = VarUtil.OS;
869              }
870              var configuration = HostContext.GetService&lt;IConfigurationStore&gt;();
871              _record.WorkerName = configuration.GetSettings().AgentName;
872              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
873          }
874          private void JobServerQueueThrottling_EventReceived(object sender, ThrottlingEventArgs data)
875          {
876              Interlocked.Add(ref _totalThrottlingDelayInMilliseconds, Convert.ToInt64(data.Delay.TotalMilliseconds));
877              if (!_throttlingReported &amp;&amp;
878                  _totalThrottlingDelayInMilliseconds &gt; _throttlingDelayReportThreshold)
879              {
880                  this.Warning(string.Format(&quot;The job is currently being throttled by the server. You may experience delays in console line output, job status reporting, and action log uploads.&quot;));
881                  _throttlingReported = true;
882              }
883          }
884          private IExecutionContext CreatePostChild(string displayName, Dictionary&lt;string, string&gt; intraActionState, string siblingScopeName = null)
885          {
886              if (!_expandedForPostJob)
887              {
888                  Trace.Info($&quot;Reserve record order {_childTimelineRecordOrder + 1} to {_childTimelineRecordOrder * 2} for post job actions.&quot;);
889                  _expandedForPostJob = true;
890                  _childTimelineRecordOrder = _childTimelineRecordOrder * 2;
891              }
892              var newGuid = Guid.NewGuid();
893              return CreateChild(newGuid, displayName, newGuid.ToString(&quot;N&quot;), null, null, ActionRunStage.Post, intraActionState, _childTimelineRecordOrder - Root.PostJobSteps.Count, siblingScopeName: siblingScopeName);
894          }
895          private static void SetDebugUsingVars(IDictionary&lt;string, VariableValue&gt; variables, IDictionary&lt;string, PipelineContextData&gt; contextData)
896          {
897              if (contextData != null &amp;&amp;
898                  contextData.TryGetValue(PipelineTemplateConstants.Vars, out var varsPipelineContextData) &amp;&amp;
899                  varsPipelineContextData != null &amp;&amp;
900                  varsPipelineContextData is DictionaryContextData varsContextData)
901              {
902                  if (!variables.ContainsKey(Constants.Variables.Actions.StepDebug) &amp;&amp;
903                      varsContextData.TryGetValue(Constants.Variables.Actions.StepDebug, out var stepDebugValue) &amp;&amp;
904                      stepDebugValue is StringContextData)
905                  {
906                      variables[Constants.Variables.Actions.StepDebug] = stepDebugValue.ToString();
907                  }
908                  if (!variables.ContainsKey(Constants.Variables.Actions.RunnerDebug) &amp;&amp;
909                      varsContextData.TryGetValue(Constants.Variables.Actions.RunnerDebug, out var runDebugValue) &amp;&amp;
910                      runDebugValue is StringContextData)
911                  {
912                      variables[Constants.Variables.Actions.RunnerDebug] = runDebugValue.ToString();
913                  }
914              }
915          }
916          public void ApplyContinueOnError(TemplateToken continueOnErrorToken)
917          {
918              if (Result != TaskResult.Failed)
919              {
920                  return;
921              }
922              var continueOnError = false;
923              try
924              {
925                  var templateEvaluator = this.ToPipelineTemplateEvaluator();
926                  continueOnError = templateEvaluator.EvaluateStepContinueOnError(continueOnErrorToken, ExpressionValues, ExpressionFunctions);
927              }
928              catch (Exception ex)
929              {
930                  Trace.Info(&quot;The step failed and an error occurred when attempting to determine whether to continue on error.&quot;);
931                  Trace.Error(ex);
932                  this.Error(&quot;The step failed and an error occurred when attempting to determine whether to continue on error.&quot;);
933                  this.Error(ex);
934              }
935              if (continueOnError)
936              {
937                  Outcome = Result;
938                  Result = TaskResult.Succeeded;
939                  Trace.Info($&quot;Updated step result (continue on error)&quot;);
940              }
941              UpdateGlobalStepsContext();
942          }
943          private static void NoOp()
944          {
945          }
946      }
947      public static class ExecutionContextExtension
948      {
949          public static string GetFullyQualifiedContextName(this IExecutionContext context)
950          {
951              if (!string.IsNullOrEmpty(context.ScopeName))
952              {
953                  return $&quot;{context.ScopeName}.{context.ContextName}&quot;;
954              }
955              return context.ContextName;
956          }
957          public static void Error(this IExecutionContext context, Exception ex)
958          {
959              context.Error(ex.Message);
960              context.Debug(ex.ToString());
961          }
962          public static void Error(this IExecutionContext context, string message)
963          {
964              var issue = new Issue() { Type = IssueType.Error, Message = message };
965              context.AddIssue(issue, ExecutionContextLogOptions.Default);
966          }
967          public static void InfrastructureError(this IExecutionContext context, string message)
968          {
969              var issue = new Issue() { Type = IssueType.Error, Message = message, IsInfrastructureIssue = true };
970              context.AddIssue(issue, ExecutionContextLogOptions.Default);
971          }
972          public static void Warning(this IExecutionContext context, string message)
973          {
974              var issue = new Issue() { Type = IssueType.Warning, Message = message };
975              context.AddIssue(issue, ExecutionContextLogOptions.Default);
976          }
977          public static void Output(this IExecutionContext context, string message)
978          {
979              context.Write(null, message);
980          }
981          public static void Command(this IExecutionContext context, string message)
982          {
983              context.Write(WellKnownTags.Command, message);
984          }
985          public static void Debug(this IExecutionContext context, string message)
986          {
987              if (context.Global.WriteDebug)
988              {
989                  var multilines = message?.Replace(&quot;\r\n&quot;, &quot;\n&quot;)?.Split(&quot;\n&quot;);
990                  if (multilines != null)
991                  {
992                      foreach (var line in multilines)
993                      {
994                          context.Write(WellKnownTags.Debug, line);
995                      }
996                  }
997              }
998          }
999          public static IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt; ToExpressionState(this IExecutionContext context)
1000          {
1001              return new[] { new KeyValuePair&lt;string, object&gt;(nameof(IExecutionContext), context) };
1002          }
1003          public static PipelineTemplateEvaluator ToPipelineTemplateEvaluator(this IExecutionContext context, ObjectTemplating.ITraceWriter traceWriter = null)
1004          {
1005              if (traceWriter == null)
1006              {
1007                  traceWriter = context.ToTemplateTraceWriter();
1008              }
1009              var schema = PipelineTemplateSchemaFactory.GetSchema();
1010              return new PipelineTemplateEvaluator(traceWriter, schema, context.Global.FileTable)
1011              {
1012                  MaxErrorMessageLength = int.MaxValue, 
1013              };
1014          }
1015          public static ObjectTemplating.ITraceWriter ToTemplateTraceWriter(this IExecutionContext context)
1016          {
1017              return new TemplateTraceWriter(context);
1018          }
1019          public static DictionaryContextData GetExpressionValues(this IExecutionContext context, IStepHost stepHost)
1020          {
1021              if (stepHost is ContainerStepHost)
1022              {
1023                  var expressionValues = context.ExpressionValues.Clone() as DictionaryContextData;
1024                  context.UpdatePathsInExpressionValues(&quot;github&quot;, expressionValues, stepHost);
1025                  context.UpdatePathsInExpressionValues(&quot;runner&quot;, expressionValues, stepHost);
1026                  return expressionValues;
1027              }
1028              else
1029              {
1030                  return context.ExpressionValues.Clone() as DictionaryContextData;
1031              }
1032          }
1033          private static void UpdatePathsInExpressionValues(this IExecutionContext context, string contextName, DictionaryContextData expressionValues, IStepHost stepHost)
1034          {
1035              var dict = expressionValues[contextName].AssertDictionary($&quot;expected context {contextName} to be a dictionary&quot;);
1036              context.ResolvePathsInExpressionValuesDictionary(dict, stepHost);
1037              expressionValues[contextName] = dict;
1038          }
1039          private static void ResolvePathsInExpressionValuesDictionary(this IExecutionContext context, DictionaryContextData dict, IStepHost stepHost)
1040          {
1041              foreach (var key in dict.Keys.ToList())
1042              {
1043                  if (dict[key] is StringContextData)
1044                  {
1045                      var value = dict[key].ToString();
1046                      if (!string.IsNullOrEmpty(value))
1047                      {
1048                          dict[key] = new StringContextData(stepHost.ResolvePathForStepHost(context, value));
1049                      }
1050                  }
1051                  else if (dict[key] is DictionaryContextData)
1052                  {
1053                      var innerDict = dict[key].AssertDictionary(&quot;expected dictionary&quot;);
1054                      context.ResolvePathsInExpressionValuesDictionary(innerDict, stepHost);
1055                      var updatedDict = new DictionaryContextData();
1056                      foreach (var k in innerDict.Keys.ToList())
1057                      {
1058                          updatedDict[k] = innerDict[k];
1059                      }
1060                      dict[key] = updatedDict;
1061                  }
1062                  else if (dict[key] is CaseSensitiveDictionaryContextData)
1063                  {
1064                      var innerDict = dict[key].AssertDictionary(&quot;expected dictionary&quot;);
1065                      context.ResolvePathsInExpressionValuesDictionary(innerDict, stepHost);
1066                      var updatedDict = new CaseSensitiveDictionaryContextData();
1067                      foreach (var k in innerDict.Keys.ToList())
1068                      {
1069                          updatedDict[k] = innerDict[k];
1070                      }
1071                      dict[key] = updatedDict;
1072                  }
1073              }
1074          }
1075      }
1076      internal sealed class TemplateTraceWriter : ObjectTemplating.ITraceWriter
1077      {
1078          private readonly IExecutionContext _executionContext;
1079          internal TemplateTraceWriter(IExecutionContext executionContext)
1080          {
1081              ArgUtil.NotNull(executionContext, nameof(executionContext));
1082              _executionContext = executionContext;
1083          }
1084          public void Error(string format, params Object[] args)
1085          {
1086              if (logTemplateErrorsAsDebugMessages())
1087              {
1088                  _executionContext.Debug(string.Format(CultureInfo.CurrentCulture, format, args));
1089              }
1090              else
1091              {
1092                  _executionContext.Error(string.Format(CultureInfo.CurrentCulture, format, args));
1093              }
1094          }
1095          public void Info(string format, params Object[] args)
1096          {
1097              _executionContext.Debug(string.Format(CultureInfo.CurrentCulture, $&quot;{format}&quot;, args));
1098          }
1099          public void Verbose(string format, params Object[] args)
1100          {
1101              _executionContext.Debug(string.Format(CultureInfo.CurrentCulture, $&quot;{format}&quot;, args));
1102          }
1103          private bool logTemplateErrorsAsDebugMessages()
1104          {
1105              if (_executionContext.Global.EnvironmentVariables.TryGetValue(Constants.Runner.Features.LogTemplateErrorsAsDebugMessages, out var logErrorsAsDebug))
1106              {
1107                  return StringUtil.ConvertToBoolean(logErrorsAsDebug, defaultValue: false);
1108              }
1109              return false;
1110          }
1111      }
1112      public static class WellKnownTags
1113      {
1114          public static readonly string Section = &quot;##[section]&quot;;
1115          public static readonly string Command = &quot;##[command]&quot;;
1116          public static readonly string Error = &quot;##[error]&quot;;
1117          public static readonly string Warning = &quot;##[warning]&quot;;
1118          public static readonly string Notice = &quot;##[notice]&quot;;
1119          public static readonly string Debug = &quot;##[debug]&quot;;
1120      }
1121  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ExecutionContext.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Globalization;
4  using System.IO;
5  using System.Linq;
6  using System.Text;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using GitHub.Actions.RunService.WebApi;
10  using GitHub.DistributedTask.Expressions2;
11  using GitHub.DistributedTask.ObjectTemplating.Tokens;
12  using GitHub.DistributedTask.Pipelines.ContextData;
13  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
14  using GitHub.DistributedTask.WebApi;
15  using GitHub.Runner.Common;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  using GitHub.Runner.Worker.Container;
19  using GitHub.Runner.Worker.Handlers;
20  using Newtonsoft.Json;
21  using Sdk.RSWebApi.Contracts;
22  using ObjectTemplating = GitHub.DistributedTask.ObjectTemplating;
23  using Pipelines = GitHub.DistributedTask.Pipelines;
24  namespace GitHub.Runner.Worker
25  {
26      public static class ExecutionContextType
27      {
28          public const string Job = &quot;Job&quot;;
29          public const string Task = &quot;Task&quot;;
30      }
31      public record ExecutionContextLogOptions(bool WriteToLog, string LogMessageOverride)
32      {
33          public static readonly ExecutionContextLogOptions None = new(false, null);
34          public static readonly ExecutionContextLogOptions Default = new(true, null);
35      }
36      [ServiceLocator(Default = typeof(ExecutionContext))]
37      public interface IExecutionContext : IRunnerService
38      {
39          Guid Id { get; }
40          Guid EmbeddedId { get; }
41          string ScopeName { get; }
42          string SiblingScopeName { get; }
43          string ContextName { get; }
44          ActionRunStage Stage { get; }
45          Task ForceCompleted { get; }
46          TaskResult? Result { get; set; }
47          TaskResult? Outcome { get; set; }
48          string ResultCode { get; set; }
49          TaskResult? CommandResult { get; set; }
50          CancellationToken CancellationToken { get; }
51          GlobalContext Global { get; }
52          Dictionary&lt;string, string&gt; IntraActionState { get; }
53          Dictionary&lt;string, VariableValue&gt; JobOutputs { get; }
54          ActionsEnvironmentReference ActionsEnvironment { get; }
55          ActionsStepTelemetry StepTelemetry { get; }
56          DictionaryContextData ExpressionValues { get; }
57          IList&lt;IFunctionInfo&gt; ExpressionFunctions { get; }
58          JobContext JobContext { get; }
59          Queue&lt;IStep&gt; JobSteps { get; }
60          Stack&lt;IStep&gt; PostJobSteps { get; }
61          Dictionary&lt;Guid, string&gt; EmbeddedStepsWithPostRegistered { get; }
62          Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt; EmbeddedIntraActionState { get; }
63          bool EchoOnActionCommand { get; set; }
64          bool IsEmbedded { get; }
65          List&lt;string&gt; StepEnvironmentOverrides { get; }
66          ExecutionContext Root { get; }
67          void InitializeJob(Pipelines.AgentJobRequestMessage message, CancellationToken token);
68          void CancelToken();
69          IExecutionContext CreateChild(Guid recordId, string displayName, string refName, string scopeName, string contextName, ActionRunStage stage, Dictionary&lt;string, string&gt; intraActionState = null, int? recordOrder = null, IPagingLogger logger = null, bool isEmbedded = false, CancellationTokenSource cancellationTokenSource = null, Guid embeddedId = default(Guid), string siblingScopeName = null);
70          IExecutionContext CreateEmbeddedChild(string scopeName, string contextName, Guid embeddedId, ActionRunStage stage, Dictionary&lt;string, string&gt; intraActionState = null, string siblingScopeName = null);
71          long Write(string tag, string message);
72          void QueueAttachFile(string type, string name, string filePath);
73          void QueueSummaryFile(string name, string filePath, Guid stepRecordId);
74          void Start(string currentOperation = null);
75          TaskResult Complete(TaskResult? result = null, string currentOperation = null, string resultCode = null);
76          void SetEnvContext(string name, string value);
77          void SetRunnerContext(string name, string value);
78          string GetGitHubContext(string name);
79          void SetGitHubContext(string name, string value);
80          void SetOutput(string name, string value, out string reference);
81          void SetTimeout(TimeSpan? timeout);
82          void AddIssue(Issue issue, ExecutionContextLogOptions logOptions);
83          void Progress(int percentage, string currentOperation = null);
84          void UpdateDetailTimelineRecord(TimelineRecord record);
85          void UpdateTimelineRecordDisplayName(string displayName);
86          void Add(OnMatcherChanged handler);
87          void Remove(OnMatcherChanged handler);
88          void AddMatchers(IssueMatchersConfig matcher);
89          void RemoveMatchers(IEnumerable&lt;string&gt; owners);
90          IEnumerable&lt;IssueMatcherConfig&gt; GetMatchers();
91          void ForceTaskComplete();
92          void RegisterPostJobStep(IStep step);
93          void PublishStepTelemetry();
94          void ApplyContinueOnError(TemplateToken continueOnError);
95          void UpdateGlobalStepsContext();
96          void WriteWebhookPayload();
97      }
98      public sealed class ExecutionContext : RunnerService, IExecutionContext
99      {
100          private const int _maxCountPerIssueType = 10;
101          private const int _throttlingDelayReportThreshold = 10 * 1000; 
102          private const int _maxIssueMessageLength = 4096; 
103          private const int _maxIssueCountInTelemetry = 3; 
104          private const int _maxIssueMessageLengthInTelemetry = 256; 
105          private readonly TimelineRecord _record = new();
106          private readonly Dictionary&lt;Guid, TimelineRecord&gt; _detailRecords = new();
107          private readonly List&lt;Issue&gt; _embeddedIssueCollector;
108          private readonly object _loggerLock = new();
109          private readonly object _matchersLock = new();
110          private readonly ExecutionContext _parentExecutionContext;
111          private event OnMatcherChanged _onMatcherChanged;
112          private IssueMatcherConfig[] _matchers;
113          private IPagingLogger _logger;
114          private IJobServerQueue _jobServerQueue;
115          private Guid _mainTimelineId;
116          private Guid _detailTimelineId;
117          private bool _expandedForPostJob = false;
118          private int _childTimelineRecordOrder = 0;
119          private CancellationTokenSource _cancellationTokenSource;
120          private TaskCompletionSource&lt;int&gt; _forceCompleted = new();
121          private bool _throttlingReported = false;
122          private long _totalThrottlingDelayInMilliseconds = 0;
123          private bool _stepTelemetryPublished = false;
124          public ExecutionContext()
125              : this(parent: null, embedded: false)
126          {
127          }
128          private ExecutionContext(ExecutionContext parent, bool embedded)
129          {
130              if (embedded)
131              {
132                  ArgUtil.NotNull(parent, nameof(parent));
133              }
134              _parentExecutionContext = parent;
135              this.IsEmbedded = embedded;
136              this.StepTelemetry = new ActionsStepTelemetry
137              {
138                  IsEmbedded = embedded
139              };
140              _embeddedIssueCollector = embedded ? parent._embeddedIssueCollector : new();
141          }
142          public Guid Id =&gt; _record.Id;
143          public Guid EmbeddedId { get; private set; }
144          public string ScopeName { get; private set; }
145          public string SiblingScopeName { get; private set; }
146          public string ContextName { get; private set; }
147          public ActionRunStage Stage { get; private set; }
148          public Task ForceCompleted =&gt; _forceCompleted.Task;
149          public CancellationToken CancellationToken =&gt; _cancellationTokenSource.Token;
150          public Dictionary&lt;string, string&gt; IntraActionState { get; private set; }
151          public Dictionary&lt;string, VariableValue&gt; JobOutputs { get; private set; }
152          public ActionsEnvironmentReference ActionsEnvironment { get; private set; }
153          public ActionsStepTelemetry StepTelemetry { get; private init; }
154          public DictionaryContextData ExpressionValues { get; } = new DictionaryContextData();
155          public IList&lt;IFunctionInfo&gt; ExpressionFunctions { get; } = new List&lt;IFunctionInfo&gt;();
156          public GlobalContext Global { get; private set; }
157          public Queue&lt;IStep&gt; JobSteps { get; private set; }
158          public Stack&lt;IStep&gt; PostJobSteps { get; private set; }
159          public HashSet&lt;Guid&gt; StepsWithPostRegistered { get; private set; }
160          public Dictionary&lt;Guid, string&gt; EmbeddedStepsWithPostRegistered { get; private set; }
161          public Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt; EmbeddedIntraActionState { get; private set; }
162          public bool EchoOnActionCommand { get; set; }
163          public bool IsEmbedded { get; private init; }
164          public TaskResult? Result
165          {
166              get
167              {
168                  return _record.Result;
169              }
170              set
171              {
172                  _record.Result = value;
173              }
174          }
175          public TaskResult? Outcome { get; set; }
176          public TaskResult? CommandResult { get; set; }
177          private string ContextType =&gt; _record.RecordType;
178          public string ResultCode
179          {
180              get
181              {
182                  return _record.ResultCode;
183              }
184              set
185              {
186                  _record.ResultCode = value;
187              }
188          }
189          public ExecutionContext Root
190          {
191              get
192              {
193                  var result = this;
194                  while (result._parentExecutionContext != null)
195                  {
196                      result = result._parentExecutionContext;
197                  }
198                  return result;
199              }
200          }
201          public JobContext JobContext
202          {
203              get
204              {
205                  return ExpressionValues[&quot;job&quot;] as JobContext;
206              }
207          }
208          public List&lt;string&gt; StepEnvironmentOverrides { get; } = new List&lt;string&gt;();
209          public override void Initialize(IHostContext hostContext)
210          {
211              base.Initialize(hostContext);
212              _jobServerQueue = HostContext.GetService&lt;IJobServerQueue&gt;();
213          }
214          public void CancelToken()
215          {
216              try
217              {
218                  _cancellationTokenSource.Cancel();
219              }
220              catch (ObjectDisposedException e)
221              {
222                  Trace.Info($&quot;Attempted to cancel a disposed token, the execution is already complete: {e.ToString()}&quot;);
223              }
224          }
225          public void ForceTaskComplete()
226          {
227              Trace.Info(&quot;Force finish current task in 5 sec.&quot;);
228              Task.Run(async () =&gt;
229              {
230                  await Task.Delay(TimeSpan.FromSeconds(5));
231                  _forceCompleted?.TrySetResult(1);
232              });
233          }
234          public void RegisterPostJobStep(IStep step)
235          {
236              string siblingScopeName = null;
237              if (this.IsEmbedded)
238              {
239                  if (step is IActionRunner actionRunner)
240                  {
241                      if (Root.EmbeddedStepsWithPostRegistered.ContainsKey(actionRunner.Action.Id))
242                      {
243                          Trace.Info($&quot;&#x27;post&#x27; of &#x27;{actionRunner.DisplayName}&#x27; already push to child post step stack.&quot;);
244                      }
245                      else
246                      {
247                          Root.EmbeddedStepsWithPostRegistered[actionRunner.Action.Id] = actionRunner.Condition;
248                      }
249                      return;
250                  }
251              }
252              else if (step is IActionRunner actionRunner &amp;&amp; !Root.StepsWithPostRegistered.Add(actionRunner.Action.Id))
253              {
254                  Trace.Info($&quot;&#x27;post&#x27; of &#x27;{actionRunner.DisplayName}&#x27; already push to post step stack.&quot;);
255                  return;
256              }
257              if (step is IActionRunner runner)
258              {
259                  siblingScopeName = runner.Action.ContextName;
260              }
261              step.ExecutionContext = Root.CreatePostChild(step.DisplayName, IntraActionState, siblingScopeName);
262              Root.PostJobSteps.Push(step);
263          }
264          public IExecutionContext CreateChild(
265              Guid recordId,
266              string displayName,
267              string refName,
268              string scopeName,
269              string contextName,
270              ActionRunStage stage,
271              Dictionary&lt;string, string&gt; intraActionState = null,
272              int? recordOrder = null,
273              IPagingLogger logger = null,
274              bool isEmbedded = false,
275              CancellationTokenSource cancellationTokenSource = null,
276              Guid embeddedId = default(Guid),
277              string siblingScopeName = null)
278          {
279              Trace.Entering();
280              var child = new ExecutionContext(this, isEmbedded);
281              child.Initialize(HostContext);
282              child.Global = Global;
283              child.ScopeName = scopeName;
284              child.ContextName = contextName;
285              child.Stage = stage;
286              child.EmbeddedId = embeddedId;
287              child.SiblingScopeName = siblingScopeName;
288              if (intraActionState == null)
289              {
290                  child.IntraActionState = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
291              }
292              else
293              {
294                  child.IntraActionState = intraActionState;
295              }
296              foreach (var pair in ExpressionValues)
297              {
298                  child.ExpressionValues[pair.Key] = pair.Value;
299              }
300              foreach (var item in ExpressionFunctions)
301              {
302                  child.ExpressionFunctions.Add(item);
303              }
304              child._cancellationTokenSource = cancellationTokenSource ?? new CancellationTokenSource();
305              child.EchoOnActionCommand = EchoOnActionCommand;
306              if (recordOrder != null)
307              {
308                  child.InitializeTimelineRecord(_mainTimelineId, recordId, _record.Id, ExecutionContextType.Task, displayName, refName, recordOrder);
309              }
310              else
311              {
312                  child.InitializeTimelineRecord(_mainTimelineId, recordId, _record.Id, ExecutionContextType.Task, displayName, refName, ++_childTimelineRecordOrder);
313              }
314              if (logger != null)
315              {
316                  child._logger = logger;
317              }
318              else
319              {
320                  child._logger = HostContext.CreateService&lt;IPagingLogger&gt;();
321                  child._logger.Setup(_mainTimelineId, recordId);
322              }
323              child.StepTelemetry.StepId = recordId;
324              child.StepTelemetry.Stage = stage.ToString();
325              child.StepTelemetry.StepContextName = child.GetFullyQualifiedContextName();
326              return child;
327          }
328          public IExecutionContext CreateEmbeddedChild(
329              string scopeName,
330              string contextName,
331              Guid embeddedId,
332              ActionRunStage stage,
333              Dictionary&lt;string, string&gt; intraActionState = null,
334              string siblingScopeName = null)
335          {
336              return Root.CreateChild(_record.Id, _record.Name, _record.Id.ToString(&quot;N&quot;), scopeName, contextName, stage, logger: _logger, isEmbedded: true, cancellationTokenSource: CancellationTokenSource.CreateLinkedTokenSource(_cancellationTokenSource.Token), intraActionState: intraActionState, embeddedId: embeddedId, siblingScopeName: siblingScopeName);
337          }
338          public void Start(string currentOperation = null)
339          {
340              _record.CurrentOperation = currentOperation ?? _record.CurrentOperation;
341              _record.StartTime = DateTime.UtcNow;
342              _record.State = TimelineRecordState.InProgress;
343              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
344          }
345          public TaskResult Complete(TaskResult? result = null, string currentOperation = null, string resultCode = null)
346          {
347              if (result != null)
348              {
349                  Result = result;
350              }
351              if (_totalThrottlingDelayInMilliseconds &gt; _throttlingDelayReportThreshold)
352              {
353                  this.Warning($&quot;The job has experienced {TimeSpan.FromMilliseconds(_totalThrottlingDelayInMilliseconds).TotalSeconds} seconds total delay caused by server throttling.&quot;);
354              }
355              DateTime now = DateTime.UtcNow;
356              _record.CurrentOperation = currentOperation ?? _record.CurrentOperation;
357              _record.ResultCode = resultCode ?? _record.ResultCode;
358              _record.FinishTime = now;
359              _record.PercentComplete = 100;
360              _record.Result = _record.Result ?? TaskResult.Succeeded;
361              _record.State = TimelineRecordState.Completed;
362              if (!this.IsEmbedded)
363              {
364                  foreach (var issue in _embeddedIssueCollector)
365                  {
366                      AddIssue(issue, ExecutionContextLogOptions.None);
367                  }
368              }
369              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
370              if (_detailTimelineId != Guid.Empty &amp;&amp; _detailRecords.Count &gt; 0)
371              {
372                  foreach (var record in _detailRecords)
373                  {
374                      record.Value.FinishTime = record.Value.FinishTime ?? now;
375                      record.Value.PercentComplete = record.Value.PercentComplete ?? 100;
376                      record.Value.Result = record.Value.Result ?? TaskResult.Succeeded;
377                      record.Value.State = TimelineRecordState.Completed;
378                      _jobServerQueue.QueueTimelineRecordUpdate(_detailTimelineId, record.Value);
379                  }
380              }
381              PublishStepTelemetry();
382              var stepResult = new StepResult
383              {
384                  ExternalID = _record.Id,
385                  Conclusion = _record.Result ?? TaskResult.Succeeded,
386                  Status = _record.State,
387                  Number = _record.Order,
388                  Name = _record.Name,
389                  StartedAt = _record.StartTime,
390                  CompletedAt = _record.FinishTime,
391                  Annotations = new List&lt;Annotation&gt;()
392              };
393              _record.Issues?.ForEach(issue =&gt;
394              {
395                  var annotation = issue.ToAnnotation();
396                  if (annotation != null)
397                  {
398                      stepResult.Annotations.Add(annotation.Value);
399                  }
400              });
401              Global.StepsResult.Add(stepResult);
402              if (Root != this)
403              {
404                  _cancellationTokenSource?.Dispose();
405              }
406              _logger.End();
407              UpdateGlobalStepsContext();
408              return Result.Value;
409          }
410          public void UpdateGlobalStepsContext()
411          {
412              if (!string.IsNullOrEmpty(ContextName) &amp;&amp; !ContextName.StartsWith(&quot;__&quot;, StringComparison.Ordinal))
413              {
414                  Global.StepsContext.SetOutcome(ScopeName, ContextName, (Outcome ?? Result ?? TaskResult.Succeeded).ToActionResult());
415                  Global.StepsContext.SetConclusion(ScopeName, ContextName, (Result ?? TaskResult.Succeeded).ToActionResult());
416              }
417          }
418          public void SetRunnerContext(string name, string value)
419          {
420              ArgUtil.NotNullOrEmpty(name, nameof(name));
421              var runnerContext = ExpressionValues[&quot;runner&quot;] as RunnerContext;
422              runnerContext[name] = new StringContextData(value);
423          }
424          public void SetEnvContext(string name, string value)
425          {
426              ArgUtil.NotNullOrEmpty(name, nameof(name));
427  #if OS_WINDOWS
428              var envContext = ExpressionValues[&quot;env&quot;] as DictionaryContextData;
429              envContext[name] = new StringContextData(value);
430  #else
431              var envContext = ExpressionValues[&quot;env&quot;] as CaseSensitiveDictionaryContextData;
432              envContext[name] = new StringContextData(value);
433  #endif
434          }
435          public void SetGitHubContext(string name, string value)
436          {
437              ArgUtil.NotNullOrEmpty(name, nameof(name));
<span onclick='openModal()' class='match'>438              var githubContext = ExpressionValues[&quot;github&quot;] as GitHubContext;
439              githubContext[name] = new StringContextData(value);
440          }
</span>441          public string GetGitHubContext(string name)
442          {
443              ArgUtil.NotNullOrEmpty(name, nameof(name));
444              var githubContext = ExpressionValues[&quot;github&quot;] as GitHubContext;
445              if (githubContext.TryGetValue(name, out var value))
446              {
447                  if (value is StringContextData)
448                  {
449                      return value as StringContextData;
450                  }
451                  else
452                  {
453                      return value.ToJToken().ToString(Formatting.Indented);
454                  }
455              }
456              else
457              {
458                  return null;
459              }
460          }
461          public void SetOutput(string name, string value, out string reference)
462          {
463              ArgUtil.NotNullOrEmpty(name, nameof(name));
464              if (string.IsNullOrEmpty(ContextName) || ContextName.StartsWith(&quot;__&quot;, StringComparison.Ordinal))
465              {
466                  reference = null;
467                  return;
468              }
469              Global.StepsContext.SetOutput(ScopeName, ContextName, name, value, out reference);
470          }
471          public void SetTimeout(TimeSpan? timeout)
472          {
473              if (timeout != null)
474              {
475                  _cancellationTokenSource.CancelAfter(timeout.Value);
476              }
477          }
478          public void Progress(int percentage, string currentOperation = null)
479          {
480              if (percentage &gt; 100 || percentage &lt; 0)
481              {
482                  throw new ArgumentOutOfRangeException(nameof(percentage));
483              }
484              _record.CurrentOperation = currentOperation ?? _record.CurrentOperation;
485              _record.PercentComplete = Math.Max(percentage, _record.PercentComplete.Value);
486              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
487          }
488          public void AddIssue(Issue issue, ExecutionContextLogOptions logOptions)
489          {
490              ArgUtil.NotNull(issue, nameof(issue));
491              ArgUtil.NotNull(logOptions, nameof(logOptions));
492              issue.Message = HostContext.SecretMasker.MaskSecrets(issue.Message);
493              if (issue.Message.Length &gt; _maxIssueMessageLength)
494              {
495                  issue.Message = issue.Message[.._maxIssueMessageLength];
496              }
497              if (_record.Order != null)
498              {
499                  issue.Data[&quot;stepNumber&quot;] = _record.Order.ToString();
500              }
501              string wellKnownTag = null;
502              Int32 previousCountForIssueType = 0;
503              Action incrementIssueTypeCount = NoOp;
504              switch (issue.Type)
505              {
506                  case IssueType.Error:
507                      wellKnownTag = WellKnownTags.Error;
508                      previousCountForIssueType = _record.ErrorCount;
509                      incrementIssueTypeCount = () =&gt; { _record.ErrorCount++; };
510                      break;
511                  case IssueType.Warning:
512                      wellKnownTag = WellKnownTags.Warning;
513                      previousCountForIssueType = _record.WarningCount;
514                      incrementIssueTypeCount = () =&gt; { _record.WarningCount++; };
515                      break;
516                  case IssueType.Notice:
517                      wellKnownTag = WellKnownTags.Notice;
518                      previousCountForIssueType = _record.NoticeCount;
519                      incrementIssueTypeCount = () =&gt; { _record.NoticeCount++; };
520                      break;
521              }
522              if (!string.IsNullOrEmpty(wellKnownTag))
523              {
524                  if (!this.IsEmbedded &amp;&amp; previousCountForIssueType &lt; _maxCountPerIssueType)
525                  {
526                      incrementIssueTypeCount();
527                      _record.Issues.Add(issue);
528                  }
529                  if (logOptions.WriteToLog)
530                  {
531                      string logMessage = issue.Message;
532                      if (!string.IsNullOrEmpty(logOptions.LogMessageOverride))
533                      {
534                          logMessage = logOptions.LogMessageOverride;
535                      }
536                      if (!string.IsNullOrEmpty(logMessage))
537                      {
538                          long logLineNumber = Write(wellKnownTag, logMessage);
539                          issue.Data[&quot;logFileLineNumber&quot;] = logLineNumber.ToString();
540                      }
541                  }
542              }
543              if (this.IsEmbedded)
544              {
545                  _embeddedIssueCollector.Add(issue);
546              }
547              else
548              {
549                  _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
550              }
551          }
552          public void UpdateDetailTimelineRecord(TimelineRecord record)
553          {
554              ArgUtil.NotNull(record, nameof(record));
555              if (record.RecordType == ExecutionContextType.Job)
556              {
557                  throw new ArgumentOutOfRangeException(nameof(record));
558              }
559              if (_detailTimelineId == Guid.Empty)
560              {
561                  _detailTimelineId = Guid.NewGuid();
562                  _record.Details = new Timeline(_detailTimelineId);
563                  _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
564              }
565              TimelineRecord existRecord;
566              if (_detailRecords.TryGetValue(record.Id, out existRecord))
567              {
568                  existRecord.Name = record.Name ?? existRecord.Name;
569                  existRecord.RecordType = record.RecordType ?? existRecord.RecordType;
570                  existRecord.Order = record.Order ?? existRecord.Order;
571                  existRecord.ParentId = record.ParentId ?? existRecord.ParentId;
572                  existRecord.StartTime = record.StartTime ?? existRecord.StartTime;
573                  existRecord.FinishTime = record.FinishTime ?? existRecord.FinishTime;
574                  existRecord.PercentComplete = record.PercentComplete ?? existRecord.PercentComplete;
575                  existRecord.CurrentOperation = record.CurrentOperation ?? existRecord.CurrentOperation;
576                  existRecord.Result = record.Result ?? existRecord.Result;
577                  existRecord.ResultCode = record.ResultCode ?? existRecord.ResultCode;
578                  existRecord.State = record.State ?? existRecord.State;
579                  _jobServerQueue.QueueTimelineRecordUpdate(_detailTimelineId, existRecord);
580              }
581              else
582              {
583                  _detailRecords[record.Id] = record;
584                  _jobServerQueue.QueueTimelineRecordUpdate(_detailTimelineId, record);
585              }
586          }
587          public void UpdateTimelineRecordDisplayName(string displayName)
588          {
589              ArgUtil.NotNull(displayName, nameof(displayName));
590              _record.Name = displayName;
591              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
592          }
593          public void InitializeJob(Pipelines.AgentJobRequestMessage message, CancellationToken token)
594          {
595              Trace.Entering();
596              ArgUtil.NotNull(message, nameof(message));
597              ArgUtil.NotNull(message.Resources, nameof(message.Resources));
598              ArgUtil.NotNull(message.Variables, nameof(message.Variables));
599              ArgUtil.NotNull(message.Plan, nameof(message.Plan));
600              _cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token);
601              Global = new GlobalContext();
602              Global.Plan = message.Plan;
603              Global.Features = PlanUtil.GetFeatures(message.Plan);
604              Global.Endpoints = message.Resources.Endpoints;
605              var variables = message.Variables;
606              SetDebugUsingVars(variables, message.ContextData);
607              Global.Variables = new Variables(HostContext, variables);
608              if (Global.Variables.GetBoolean(&quot;DistributedTask.ForceInternalNodeVersionOnRunnerTo12&quot;) ?? false)
609              {
610                  Environment.SetEnvironmentVariable(Constants.Variables.Agent.ForcedInternalNodeVersion, &quot;node12&quot;);
611              }
612              Global.EnvironmentVariables = new Dictionary&lt;string, string&gt;(VarUtil.EnvironmentVariableKeyComparer);
613              Global.JobDefaults = new Dictionary&lt;string, IDictionary&lt;string, string&gt;&gt;(StringComparer.OrdinalIgnoreCase);
614              Global.JobTelemetry = new List&lt;JobTelemetry&gt;();
615              Global.StepsTelemetry = new List&lt;ActionsStepTelemetry&gt;();
616              Global.StepsResult = new List&lt;StepResult&gt;();
617              Global.JobAnnotations = new List&lt;Annotation&gt;();
618              JobOutputs = new Dictionary&lt;string, VariableValue&gt;(StringComparer.OrdinalIgnoreCase);
619              ActionsEnvironment = message.ActionsEnvironment;
620              Global.ServiceContainers = new List&lt;ContainerInfo&gt;();
621              Global.StepsContext = new StepsContext();
622              Global.FileTable = new List&lt;String&gt;(message.FileTable ?? new string[0]);
623              Global.Variables.Set(Constants.Variables.System.JobRequestType, message.MessageType);
624              if (message.ContextData?.Count &gt; 0)
625              {
626                  foreach (var pair in message.ContextData)
627                  {
628                      ExpressionValues[pair.Key] = pair.Value;
629                  }
630              }
631              ExpressionValues[&quot;secrets&quot;] = Global.Variables.ToSecretsContext();
632              ExpressionValues[&quot;runner&quot;] = new RunnerContext();
633              ExpressionValues[&quot;job&quot;] = new JobContext();
634              Trace.Info(&quot;Initialize GitHub context&quot;);
635              var githubAccessToken = new StringContextData(Global.Variables.Get(&quot;system.github.token&quot;));
636              var base64EncodedToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{githubAccessToken}&quot;));
637              HostContext.SecretMasker.AddValue(base64EncodedToken);
638              var githubJob = Global.Variables.Get(&quot;system.github.job&quot;);
639              var githubContext = new GitHubContext();
640              githubContext[&quot;token&quot;] = githubAccessToken;
641              if (!string.IsNullOrEmpty(githubJob))
642              {
643                  githubContext[&quot;job&quot;] = new StringContextData(githubJob);
644              }
645              var githubDictionary = ExpressionValues[&quot;github&quot;].AssertDictionary(&quot;github&quot;);
646              foreach (var pair in githubDictionary)
647              {
648                  githubContext[pair.Key] = pair.Value;
649              }
650              ExpressionValues[&quot;github&quot;] = githubContext;
651              Trace.Info(&quot;Initialize Env context&quot;);
652  #if OS_WINDOWS
653              ExpressionValues[&quot;env&quot;] = new DictionaryContextData();
654  #else
655              ExpressionValues[&quot;env&quot;] = new CaseSensitiveDictionaryContextData();
656  #endif
657              Global.PrependPath = new List&lt;string&gt;();
658              JobSteps = new Queue&lt;IStep&gt;();
659              PostJobSteps = new Stack&lt;IStep&gt;();
660              StepsWithPostRegistered = new HashSet&lt;Guid&gt;();
661              EmbeddedStepsWithPostRegistered = new Dictionary&lt;Guid, string&gt;();
662              EmbeddedIntraActionState = new Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt;();
663              InitializeTimelineRecord(
664                  timelineId: message.Timeline.Id,
665                  timelineRecordId: message.JobId,
666                  parentTimelineRecordId: null,
667                  recordType: ExecutionContextType.Job,
668                  displayName: message.JobDisplayName,
669                  refName: message.JobName,
670                  order: null); 
671              _logger = HostContext.CreateService&lt;IPagingLogger&gt;();
672              _logger.Setup(_mainTimelineId, _record.Id);
673              EchoOnActionCommand = Global.Variables.Step_Debug ?? false;
674              Global.WriteDebug = Global.Variables.Step_Debug ?? false;
675              _jobServerQueue.JobServerQueueThrottling += JobServerQueueThrottling_EventReceived;
676          }
677          public long Write(string tag, string message)
678          {
679              string msg = HostContext.SecretMasker.MaskSecrets($&quot;{tag}{message}&quot;);
680              long totalLines;
681              lock (_loggerLock)
682              {
683                  totalLines = _logger.TotalLines + 1;
684                  _logger.Write(msg);
685              }
686              if (_parentExecutionContext != null)
687              {
688                  lock (_parentExecutionContext._loggerLock)
689                  {
690                      _parentExecutionContext._logger.Write(msg);
691                  }
692              }
693              _jobServerQueue.QueueWebConsoleLine(_record.Id, msg, totalLines);
694              return totalLines;
695          }
696          public void QueueAttachFile(string type, string name, string filePath)
697          {
698              ArgUtil.NotNullOrEmpty(type, nameof(type));
699              ArgUtil.NotNullOrEmpty(name, nameof(name));
700              ArgUtil.NotNullOrEmpty(filePath, nameof(filePath));
701              if (!File.Exists(filePath))
702              {
703                  throw new FileNotFoundException($&quot;Can&#x27;t attach (type:{type} name:{name}) file: {filePath}. File does not exist.&quot;);
704              }
705              _jobServerQueue.QueueFileUpload(_mainTimelineId, _record.Id, type, name, filePath, deleteSource: false);
706          }
707          public void QueueSummaryFile(string name, string filePath, Guid stepRecordId)
708          {
709              ArgUtil.NotNullOrEmpty(name, nameof(name));
710              ArgUtil.NotNullOrEmpty(filePath, nameof(filePath));
711              if (!File.Exists(filePath))
712              {
713                  throw new FileNotFoundException($&quot;Can&#x27;t upload (name:{name}) file: {filePath}. File does not exist.&quot;);
714              }
715              _jobServerQueue.QueueResultsUpload(stepRecordId, name, filePath, ChecksAttachmentType.StepSummary, deleteSource: false, finalize: true, firstBlock: true, totalLines: 0);
716          }
717          public void Add(OnMatcherChanged handler)
718          {
719              Root._onMatcherChanged += handler;
720          }
721          public void Remove(OnMatcherChanged handler)
722          {
723              Root._onMatcherChanged -= handler;
724          }
725          public void AddMatchers(IssueMatchersConfig config)
726          {
727              var root = Root;
728              lock (root._matchersLock)
729              {
730                  var newMatchers = new List&lt;IssueMatcherConfig&gt;();
731                  var newOwners = new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase);
732                  foreach (var matcher in config.Matchers)
733                  {
734                      newOwners.Add(matcher.Owner);
735                      newMatchers.Add(matcher);
736                  }
737                  var existingMatchers = root._matchers ?? Array.Empty&lt;IssueMatcherConfig&gt;();
738                  newMatchers.AddRange(existingMatchers.Where(x =&gt; !newOwners.Contains(x.Owner)));
739                  root._matchers = newMatchers.ToArray();
740                  foreach (var matcher in config.Matchers)
741                  {
742                      root._onMatcherChanged(null, new MatcherChangedEventArgs(matcher));
743                  }
744                  var owners = config.Matchers.Select(x =&gt; $&quot;&#x27;{x.Owner}&#x27;&quot;);
745                  var joinedOwners = string.Join(&quot;, &quot;, owners);
746                  this.Debug($&quot;Added matchers: {joinedOwners}. Problem matchers scan action output for known warning or error strings and report these inline.&quot;);
747              }
748          }
749          public void RemoveMatchers(IEnumerable&lt;string&gt; owners)
750          {
751              var root = Root;
752              var distinctOwners = new HashSet&lt;string&gt;(owners, StringComparer.OrdinalIgnoreCase);
753              var removedMatchers = new List&lt;IssueMatcherConfig&gt;();
754              var newMatchers = new List&lt;IssueMatcherConfig&gt;();
755              lock (root._matchersLock)
756              {
757                  var existingMatchers = root._matchers ?? Array.Empty&lt;IssueMatcherConfig&gt;();
758                  foreach (var matcher in existingMatchers)
759                  {
760                      if (distinctOwners.Contains(matcher.Owner))
761                      {
762                          removedMatchers.Add(matcher);
763                      }
764                      else
765                      {
766                          newMatchers.Add(matcher);
767                      }
768                  }
769                  root._matchers = newMatchers.ToArray();
770                  foreach (var removedMatcher in removedMatchers)
771                  {
772                      root._onMatcherChanged(null, new MatcherChangedEventArgs(new IssueMatcherConfig { Owner = removedMatcher.Owner }));
773                  }
774                  owners = removedMatchers.Select(x =&gt; $&quot;&#x27;{x.Owner}&#x27;&quot;);
775                  var joinedOwners = string.Join(&quot;, &quot;, owners);
776                  this.Debug($&quot;Removed matchers: {joinedOwners}&quot;);
777              }
778          }
779          public IEnumerable&lt;IssueMatcherConfig&gt; GetMatchers()
780          {
781              return Root._matchers ?? Array.Empty&lt;IssueMatcherConfig&gt;();
782          }
783          public void PublishStepTelemetry()
784          {
785              if (!_stepTelemetryPublished)
786              {
787                  if (!string.IsNullOrEmpty(StepTelemetry?.Type))
788                  {
789                      if (!IsEmbedded)
790                      {
791                          StepTelemetry.Result = _record.Result;
792                      }
793                      if (!IsEmbedded &amp;&amp;
794                          _record.FinishTime != null &amp;&amp;
795                          _record.StartTime != null)
796                      {
797                          StepTelemetry.ExecutionTimeInSeconds = (int)Math.Ceiling((_record.FinishTime - _record.StartTime)?.TotalSeconds ?? 0);
798                          StepTelemetry.StartTime = _record.StartTime;
799                          StepTelemetry.FinishTime = _record.FinishTime;
800                      }
801                      if (!IsEmbedded)
802                      {
803                          foreach (var issue in _record.Issues)
804                          {
805                              if ((issue.Type == IssueType.Error || issue.Type == IssueType.Warning) &amp;&amp;
806                                  !string.IsNullOrEmpty(issue.Message))
807                              {
808                                  string issueTelemetry;
809                                  if (issue.Message.Length &gt; _maxIssueMessageLengthInTelemetry)
810                                  {
811                                      issueTelemetry = $&quot;{issue.Message[.._maxIssueMessageLengthInTelemetry]}&quot;;
812                                  }
813                                  else
814                                  {
815                                      issueTelemetry = issue.Message;
816                                  }
817                                  StepTelemetry.ErrorMessages.Add(issueTelemetry);
818                                  if (StepTelemetry.ErrorMessages.Count &gt;= _maxIssueCountInTelemetry)
819                                  {
820                                      break;
821                                  }
822                              }
823                          }
824                      }
825                      Trace.Info($&quot;Publish step telemetry for current step {StringUtil.ConvertToJson(StepTelemetry)}.&quot;);
826                      Global.StepsTelemetry.Add(StepTelemetry);
827                      _stepTelemetryPublished = true;
828                  }
829              }
830              else
831              {
832                  Trace.Info($&quot;Step telemetry has already been published.&quot;);
833              }
834          }
835          public void WriteWebhookPayload()
836          {
837              var tempDirectory = HostContext.GetDirectory(WellKnownDirectory.Temp);
838              var workflowDirectory = Path.Combine(tempDirectory, &quot;_github_workflow&quot;);
839              Directory.CreateDirectory(workflowDirectory);
840              var gitHubEvent = GetGitHubContext(&quot;event&quot;);
841              if (gitHubEvent != null)
842              {
843                  var workflowFile = Path.Combine(workflowDirectory, &quot;event.json&quot;);
844                  Trace.Info($&quot;Write event payload to {workflowFile}&quot;);
845                  File.WriteAllText(workflowFile, gitHubEvent, new UTF8Encoding(false));
846                  SetGitHubContext(&quot;event_path&quot;, workflowFile);
847              }
848          }
849          private void InitializeTimelineRecord(Guid timelineId, Guid timelineRecordId, Guid? parentTimelineRecordId, string recordType, string displayName, string refName, int? order)
850          {
851              _mainTimelineId = timelineId;
852              _record.Id = timelineRecordId;
853              _record.RecordType = recordType;
854              _record.Name = displayName;
855              _record.RefName = refName;
856              _record.Order = order;
857              _record.PercentComplete = 0;
858              _record.State = TimelineRecordState.Pending;
859              _record.ErrorCount = 0;
860              _record.WarningCount = 0;
861              _record.NoticeCount = 0;
862              if (parentTimelineRecordId != null &amp;&amp; parentTimelineRecordId.Value != Guid.Empty)
863              {
864                  _record.ParentId = parentTimelineRecordId;
865              }
866              else if (parentTimelineRecordId == null)
867              {
868                  _record.AgentPlatform = VarUtil.OS;
869              }
870              var configuration = HostContext.GetService&lt;IConfigurationStore&gt;();
871              _record.WorkerName = configuration.GetSettings().AgentName;
872              _jobServerQueue.QueueTimelineRecordUpdate(_mainTimelineId, _record);
873          }
874          private void JobServerQueueThrottling_EventReceived(object sender, ThrottlingEventArgs data)
875          {
876              Interlocked.Add(ref _totalThrottlingDelayInMilliseconds, Convert.ToInt64(data.Delay.TotalMilliseconds));
877              if (!_throttlingReported &amp;&amp;
878                  _totalThrottlingDelayInMilliseconds &gt; _throttlingDelayReportThreshold)
879              {
880                  this.Warning(string.Format(&quot;The job is currently being throttled by the server. You may experience delays in console line output, job status reporting, and action log uploads.&quot;));
881                  _throttlingReported = true;
882              }
883          }
884          private IExecutionContext CreatePostChild(string displayName, Dictionary&lt;string, string&gt; intraActionState, string siblingScopeName = null)
885          {
886              if (!_expandedForPostJob)
887              {
888                  Trace.Info($&quot;Reserve record order {_childTimelineRecordOrder + 1} to {_childTimelineRecordOrder * 2} for post job actions.&quot;);
889                  _expandedForPostJob = true;
890                  _childTimelineRecordOrder = _childTimelineRecordOrder * 2;
891              }
892              var newGuid = Guid.NewGuid();
893              return CreateChild(newGuid, displayName, newGuid.ToString(&quot;N&quot;), null, null, ActionRunStage.Post, intraActionState, _childTimelineRecordOrder - Root.PostJobSteps.Count, siblingScopeName: siblingScopeName);
894          }
895          private static void SetDebugUsingVars(IDictionary&lt;string, VariableValue&gt; variables, IDictionary&lt;string, PipelineContextData&gt; contextData)
896          {
897              if (contextData != null &amp;&amp;
898                  contextData.TryGetValue(PipelineTemplateConstants.Vars, out var varsPipelineContextData) &amp;&amp;
899                  varsPipelineContextData != null &amp;&amp;
900                  varsPipelineContextData is DictionaryContextData varsContextData)
901              {
902                  if (!variables.ContainsKey(Constants.Variables.Actions.StepDebug) &amp;&amp;
903                      varsContextData.TryGetValue(Constants.Variables.Actions.StepDebug, out var stepDebugValue) &amp;&amp;
904                      stepDebugValue is StringContextData)
905                  {
906                      variables[Constants.Variables.Actions.StepDebug] = stepDebugValue.ToString();
907                  }
908                  if (!variables.ContainsKey(Constants.Variables.Actions.RunnerDebug) &amp;&amp;
909                      varsContextData.TryGetValue(Constants.Variables.Actions.RunnerDebug, out var runDebugValue) &amp;&amp;
910                      runDebugValue is StringContextData)
911                  {
912                      variables[Constants.Variables.Actions.RunnerDebug] = runDebugValue.ToString();
913                  }
914              }
915          }
916          public void ApplyContinueOnError(TemplateToken continueOnErrorToken)
917          {
918              if (Result != TaskResult.Failed)
919              {
920                  return;
921              }
922              var continueOnError = false;
923              try
924              {
925                  var templateEvaluator = this.ToPipelineTemplateEvaluator();
926                  continueOnError = templateEvaluator.EvaluateStepContinueOnError(continueOnErrorToken, ExpressionValues, ExpressionFunctions);
927              }
928              catch (Exception ex)
929              {
930                  Trace.Info(&quot;The step failed and an error occurred when attempting to determine whether to continue on error.&quot;);
931                  Trace.Error(ex);
932                  this.Error(&quot;The step failed and an error occurred when attempting to determine whether to continue on error.&quot;);
933                  this.Error(ex);
934              }
935              if (continueOnError)
936              {
937                  Outcome = Result;
938                  Result = TaskResult.Succeeded;
939                  Trace.Info($&quot;Updated step result (continue on error)&quot;);
940              }
941              UpdateGlobalStepsContext();
942          }
943          private static void NoOp()
944          {
945          }
946      }
947      public static class ExecutionContextExtension
948      {
949          public static string GetFullyQualifiedContextName(this IExecutionContext context)
950          {
951              if (!string.IsNullOrEmpty(context.ScopeName))
952              {
953                  return $&quot;{context.ScopeName}.{context.ContextName}&quot;;
954              }
955              return context.ContextName;
956          }
957          public static void Error(this IExecutionContext context, Exception ex)
958          {
959              context.Error(ex.Message);
960              context.Debug(ex.ToString());
961          }
962          public static void Error(this IExecutionContext context, string message)
963          {
964              var issue = new Issue() { Type = IssueType.Error, Message = message };
965              context.AddIssue(issue, ExecutionContextLogOptions.Default);
966          }
967          public static void InfrastructureError(this IExecutionContext context, string message)
968          {
969              var issue = new Issue() { Type = IssueType.Error, Message = message, IsInfrastructureIssue = true };
970              context.AddIssue(issue, ExecutionContextLogOptions.Default);
971          }
972          public static void Warning(this IExecutionContext context, string message)
973          {
974              var issue = new Issue() { Type = IssueType.Warning, Message = message };
975              context.AddIssue(issue, ExecutionContextLogOptions.Default);
976          }
977          public static void Output(this IExecutionContext context, string message)
978          {
979              context.Write(null, message);
980          }
981          public static void Command(this IExecutionContext context, string message)
982          {
983              context.Write(WellKnownTags.Command, message);
984          }
985          public static void Debug(this IExecutionContext context, string message)
986          {
987              if (context.Global.WriteDebug)
988              {
989                  var multilines = message?.Replace(&quot;\r\n&quot;, &quot;\n&quot;)?.Split(&quot;\n&quot;);
990                  if (multilines != null)
991                  {
992                      foreach (var line in multilines)
993                      {
994                          context.Write(WellKnownTags.Debug, line);
995                      }
996                  }
997              }
998          }
999          public static IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt; ToExpressionState(this IExecutionContext context)
1000          {
1001              return new[] { new KeyValuePair&lt;string, object&gt;(nameof(IExecutionContext), context) };
1002          }
1003          public static PipelineTemplateEvaluator ToPipelineTemplateEvaluator(this IExecutionContext context, ObjectTemplating.ITraceWriter traceWriter = null)
1004          {
1005              if (traceWriter == null)
1006              {
1007                  traceWriter = context.ToTemplateTraceWriter();
1008              }
1009              var schema = PipelineTemplateSchemaFactory.GetSchema();
1010              return new PipelineTemplateEvaluator(traceWriter, schema, context.Global.FileTable)
1011              {
1012                  MaxErrorMessageLength = int.MaxValue, 
1013              };
1014          }
1015          public static ObjectTemplating.ITraceWriter ToTemplateTraceWriter(this IExecutionContext context)
1016          {
1017              return new TemplateTraceWriter(context);
1018          }
1019          public static DictionaryContextData GetExpressionValues(this IExecutionContext context, IStepHost stepHost)
1020          {
1021              if (stepHost is ContainerStepHost)
1022              {
1023                  var expressionValues = context.ExpressionValues.Clone() as DictionaryContextData;
1024                  context.UpdatePathsInExpressionValues(&quot;github&quot;, expressionValues, stepHost);
1025                  context.UpdatePathsInExpressionValues(&quot;runner&quot;, expressionValues, stepHost);
1026                  return expressionValues;
1027              }
1028              else
1029              {
1030                  return context.ExpressionValues.Clone() as DictionaryContextData;
1031              }
1032          }
1033          private static void UpdatePathsInExpressionValues(this IExecutionContext context, string contextName, DictionaryContextData expressionValues, IStepHost stepHost)
1034          {
1035              var dict = expressionValues[contextName].AssertDictionary($&quot;expected context {contextName} to be a dictionary&quot;);
1036              context.ResolvePathsInExpressionValuesDictionary(dict, stepHost);
1037              expressionValues[contextName] = dict;
1038          }
1039          private static void ResolvePathsInExpressionValuesDictionary(this IExecutionContext context, DictionaryContextData dict, IStepHost stepHost)
1040          {
1041              foreach (var key in dict.Keys.ToList())
1042              {
1043                  if (dict[key] is StringContextData)
1044                  {
1045                      var value = dict[key].ToString();
1046                      if (!string.IsNullOrEmpty(value))
1047                      {
1048                          dict[key] = new StringContextData(stepHost.ResolvePathForStepHost(context, value));
1049                      }
1050                  }
1051                  else if (dict[key] is DictionaryContextData)
1052                  {
1053                      var innerDict = dict[key].AssertDictionary(&quot;expected dictionary&quot;);
1054                      context.ResolvePathsInExpressionValuesDictionary(innerDict, stepHost);
1055                      var updatedDict = new DictionaryContextData();
1056                      foreach (var k in innerDict.Keys.ToList())
1057                      {
1058                          updatedDict[k] = innerDict[k];
1059                      }
1060                      dict[key] = updatedDict;
1061                  }
1062                  else if (dict[key] is CaseSensitiveDictionaryContextData)
1063                  {
1064                      var innerDict = dict[key].AssertDictionary(&quot;expected dictionary&quot;);
1065                      context.ResolvePathsInExpressionValuesDictionary(innerDict, stepHost);
1066                      var updatedDict = new CaseSensitiveDictionaryContextData();
1067                      foreach (var k in innerDict.Keys.ToList())
1068                      {
1069                          updatedDict[k] = innerDict[k];
1070                      }
1071                      dict[key] = updatedDict;
1072                  }
1073              }
1074          }
1075      }
1076      internal sealed class TemplateTraceWriter : ObjectTemplating.ITraceWriter
1077      {
1078          private readonly IExecutionContext _executionContext;
1079          internal TemplateTraceWriter(IExecutionContext executionContext)
1080          {
1081              ArgUtil.NotNull(executionContext, nameof(executionContext));
1082              _executionContext = executionContext;
1083          }
1084          public void Error(string format, params Object[] args)
1085          {
1086              if (logTemplateErrorsAsDebugMessages())
1087              {
1088                  _executionContext.Debug(string.Format(CultureInfo.CurrentCulture, format, args));
1089              }
1090              else
1091              {
1092                  _executionContext.Error(string.Format(CultureInfo.CurrentCulture, format, args));
1093              }
1094          }
1095          public void Info(string format, params Object[] args)
1096          {
1097              _executionContext.Debug(string.Format(CultureInfo.CurrentCulture, $&quot;{format}&quot;, args));
1098          }
1099          public void Verbose(string format, params Object[] args)
1100          {
1101              _executionContext.Debug(string.Format(CultureInfo.CurrentCulture, $&quot;{format}&quot;, args));
1102          }
1103          private bool logTemplateErrorsAsDebugMessages()
1104          {
1105              if (_executionContext.Global.EnvironmentVariables.TryGetValue(Constants.Runner.Features.LogTemplateErrorsAsDebugMessages, out var logErrorsAsDebug))
1106              {
1107                  return StringUtil.ConvertToBoolean(logErrorsAsDebug, defaultValue: false);
1108              }
1109              return false;
1110          }
1111      }
1112      public static class WellKnownTags
1113      {
1114          public static readonly string Section = &quot;##[section]&quot;;
1115          public static readonly string Command = &quot;##[command]&quot;;
1116          public static readonly string Error = &quot;##[error]&quot;;
1117          public static readonly string Warning = &quot;##[warning]&quot;;
1118          public static readonly string Notice = &quot;##[notice]&quot;;
1119          public static readonly string Debug = &quot;##[debug]&quot;;
1120      }
1121  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ExecutionContext.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ExecutionContext.cs</div>
                </div>
                <div class="column column_space"><pre><code>431              var envContext = ExpressionValues[&quot;env&quot;] as CaseSensitiveDictionaryContextData;
432              envContext[name] = new StringContextData(value);
433  #endif
</pre></code></div>
                <div class="column column_space"><pre><code>438              var githubContext = ExpressionValues[&quot;github&quot;] as GitHubContext;
439              githubContext[name] = new StringContextData(value);
440          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    