
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ResizeObserverTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Threading.Tasks;
5  using FluentAssertions;
6  using Microsoft.AspNetCore.Components;
7  using Microsoft.JSInterop;
8  using Microsoft.JSInterop.Infrastructure;
9  using Moq;
10  using MudBlazor.Interop;
11  using MudBlazor.Services;
12  using NUnit.Framework;
13  namespace MudBlazor.UnitTests.Services
14  {
15      [TestFixture]
16      public class ResizeObserverTests
17      {
18          private class PseudoElementReferenceContext : ElementReferenceContext
19          {
20          }
21          private Mock&lt;IJSRuntime&gt; _runtimeMock;
22          private ResizeObserver _service;
23          [SetUp]
24          public void SetUp()
25          {
26              _runtimeMock = new Mock&lt;IJSRuntime&gt;(MockBehavior.Strict);
27              _service = new ResizeObserver(_runtimeMock.Object);
28          }
29          [Test]
30          public async Task ObserveAndCache()
31          {
32              var random = new Random();
<span onclick='openModal()' class='match'>33              List&lt;ElementReference&gt; allReferences = new();
34              List&lt;ElementReference&gt; notObservedReferences = new();
35              Dictionary&lt;ElementReference, BoundingClientRect&gt; resolvedElements = new();
</span>36              var amount = 13;
37              for (var i = 1; i &lt;= amount; i++)
38              {
39                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
40                  var rect = GetRandomRect(random);
41                  if (i % 4 == 0)
42                  {
43                      reference = new ElementReference();
44                      notObservedReferences.Add(reference);
45                  }
46                  else if (i % 5 == 0)
47                  {
48                      reference = new ElementReference(Guid.NewGuid().ToString());
49                      notObservedReferences.Add(reference);
50                  }
51                  else
52                  {
53                      resolvedElements.Add(reference, rect);
54                  }
55                  allReferences.Add(reference);
56              }
57              _runtimeMock.Setup(x =&gt; x.InvokeAsync&lt;IEnumerable&lt;BoundingClientRect&gt;&gt;(
58                  &quot;mudResizeObserver.connect&quot;,
59                  It.Is&lt;object[]&gt;(z =&gt;
60                      (Guid)z[0] != default &amp;&amp;
61                      (z[1] is DotNetObjectReference&lt;ResizeObserver&gt;) == true &amp;&amp;
62                      (z[2] is IEnumerable&lt;ElementReference&gt;) == true &amp;&amp;
63                      (z[3] is IEnumerable&lt;Guid&gt;) == true &amp;&amp;
64                      (z[4] is ResizeObserverOptions) == true &amp;&amp; ((ResizeObserverOptions)z[4]).EnableLogging == false &amp;&amp; ((ResizeObserverOptions)z[4]).ReportRate == 200
65                  )
66              )).ReturnsAsync(resolvedElements.Values).Verifiable();
67              var actual = await _service.Observe(allReferences);
68              actual.Should().BeEquivalentTo(resolvedElements.Values);
69              foreach (var item in resolvedElements.Keys)
70              {
71                  _service.IsElementObserved(item).Should().BeTrue();
72                  var size = _service.GetSizeInfo(item);
73                  size.Should().BeEquivalentTo(resolvedElements[item]);
74                  size.Width.Should().Be(_service.GetWidth(item));
75                  size.Height.Should().Be(_service.GetHeight(item));
76              }
77              foreach (var item in notObservedReferences)
78              {
79                  _service.IsElementObserved(item).Should().BeFalse();
80                  var size = _service.GetSizeInfo(item);
81                  size.Should().BeNull();
82                  _service.GetWidth(item).Should().Be(0.0);
83                  _service.GetHeight(item).Should().Be(0.0);
84              }
85              _runtimeMock.Verify();
86          }
87          [Test]
88          public async Task NotValidElementsToObserve()
89          {
90              List&lt;ElementReference&gt; notObservedReferences = new();
91              var amount = 10;
92              for (var i = 1; i &lt;= amount; i++)
93              {
94                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
95                  if (i % 2 == 0)
96                  {
97                      reference = new ElementReference();
98                  }
99                  else
100                  {
101                      reference = new ElementReference(Guid.NewGuid().ToString());
102                  }
103                  notObservedReferences.Add(reference);
104              }
105              var actual = await _service.Observe(notObservedReferences);
106              actual.Should().BeEmpty();
107          }
108          [Test]
109          public async Task Unobserve()
110          {
111              var random = new Random();
112              Dictionary&lt;ElementReference, BoundingClientRect&gt; resolvedElements = new();
113              var amount = 13;
114              for (var i = 1; i &lt;= amount; i++)
115              {
116                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
117                  var rect = GetRandomRect(random);
118                  resolvedElements.Add(reference, rect);
119              }
120              List&lt;Guid&gt; ids = new();
121              var observerId = Guid.Empty;
122              _runtimeMock.Setup(x =&gt; x.InvokeAsync&lt;IEnumerable&lt;BoundingClientRect&gt;&gt;(
123                  &quot;mudResizeObserver.connect&quot;,
124                  It.Is&lt;object[]&gt;(z =&gt;
125                      (Guid)z[0] != default &amp;&amp;
126                      (z[1] is DotNetObjectReference&lt;ResizeObserver&gt;) == true &amp;&amp;
127                      (z[2] is IEnumerable&lt;ElementReference&gt;) == true &amp;&amp;
128                      (z[3] is IEnumerable&lt;Guid&gt;) == true &amp;&amp;
129                      (z[4] is ResizeObserverOptions) == true &amp;&amp; ((ResizeObserverOptions)z[4]).EnableLogging == false &amp;&amp; ((ResizeObserverOptions)z[4]).ReportRate == 200
130                  )
131              )).ReturnsAsync(resolvedElements.Values).Callback&lt;String, object[]&gt;((x, y) =&gt; { observerId = (Guid)y[0]; ids = new List&lt;Guid&gt;((IEnumerable&lt;Guid&gt;)y[3]); }).Verifiable();
132              foreach (var item in resolvedElements)
133              {
134                  _runtimeMock.Setup(x =&gt; x.InvokeAsync&lt;IJSVoidResult&gt;(
135                  &quot;mudResizeObserver.disconnect&quot;,
136                  It.Is&lt;object[]&gt;(z =&gt;
137                      (Guid)z[0] == observerId &amp;&amp;
138                      ids.Contains((Guid)z[1]) == true
139                  )
140              )).ReturnsAsync(Mock.Of&lt;IJSVoidResult&gt;).Callback&lt;String, Object[]&gt;((x, y) =&gt; { ids.Remove((Guid)y[1]); }).Verifiable();
141              }
142              await _service.Observe(resolvedElements.Keys);
143              foreach (var item in resolvedElements.Keys)
144              {
145                  _service.IsElementObserved(item).Should().BeTrue();
146                  await _service.Unobserve(item);
147                  _service.IsElementObserved(item).Should().BeFalse();
148              }
149              _runtimeMock.Verify();
150          }
151          [Test]
152          public async Task OnSizeChanged()
153          {
154              var random = new Random();
155              Dictionary&lt;ElementReference, BoundingClientRect&gt; resolvedElements = new();
156              var amount = 13;
157              for (var i = 1; i &lt;= amount; i++)
158              {
159                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
160                  var rect = GetRandomRect(random);
161                  resolvedElements.Add(reference, rect);
162              }
163              List&lt;Guid&gt; ids = new();
164              _runtimeMock.Setup(x =&gt; x.InvokeAsync&lt;IEnumerable&lt;BoundingClientRect&gt;&gt;(
165                  &quot;mudResizeObserver.connect&quot;,
166                  It.Is&lt;object[]&gt;(z =&gt;
167                      (Guid)z[0] != default &amp;&amp;
168                      (z[1] is DotNetObjectReference&lt;ResizeObserver&gt;) == true &amp;&amp;
169                      (z[2] is IEnumerable&lt;ElementReference&gt;) == true &amp;&amp;
170                      (z[3] is IEnumerable&lt;Guid&gt;) == true &amp;&amp;
171                      (z[4] is ResizeObserverOptions) == true &amp;&amp; ((ResizeObserverOptions)z[4]).EnableLogging == false &amp;&amp; ((ResizeObserverOptions)z[4]).ReportRate == 200
172                  )
173              )).ReturnsAsync(resolvedElements.Values).Callback&lt;String, object[]&gt;((x, y) =&gt; { ids = new List&lt;Guid&gt;((IEnumerable&lt;Guid&gt;)y[3]); }).Verifiable();
174              await _service.Observe(resolvedElements.Keys);
175              var changes = new List&lt;ResizeObserver.SizeChangeUpdateInfo&gt;();
176              Dictionary&lt;ElementReference, BoundingClientRect&gt; expectedRects = new();
177              for (var i = 0; i &lt; resolvedElements.Count(); i++)
178              {
179                  var item = resolvedElements.ElementAt(i);
180                  var correspondingId = ids[i];
181                  if (random.NextDouble() &gt; 0.5)
182                  {
183                      changes.Add(new ResizeObserver.SizeChangeUpdateInfo(Guid.NewGuid(), GetRandomRect(random)));
184                  }
185                  else
186                  {
187                      var rect = GetRandomRect(random);
188                      expectedRects.Add(item.Key, rect);
189                      changes.Add(new ResizeObserver.SizeChangeUpdateInfo(correspondingId, rect));
190                  }
191              }
192              foreach (var item in expectedRects)
193              {
194                  resolvedElements[item.Key] = item.Value;
195              }
196              var sizeChangesChecked = false;
197              _service.OnResized += (sizeChanges) =&gt;
198              {
199                  sizeChanges.Should().NotBeEmpty().And.BeEquivalentTo(expectedRects);
200                  sizeChangesChecked = true;
201              };
202              _service.OnSizeChanged(changes);
203              sizeChangesChecked.Should().BeTrue();
204              foreach (var item in resolvedElements)
205              {
206                  var sizeInfo = _service.GetSizeInfo(item.Key);
207                  sizeInfo.Should().BeEquivalentTo(item.Value);
208              }
209              _runtimeMock.Verify();
210          }
211          #region Helper
212          private static BoundingClientRect GetRandomRect(Random random)
213          {
214              return new BoundingClientRect
215              {
216                  Height = random.Next(10, 200) + random.NextDouble(),
217                  Left = random.Next(10, 200) + random.NextDouble(),
218                  Top = random.Next(10, 200) + random.NextDouble(),
219                  Width = random.Next(10, 200) + random.NextDouble(),
220              };
221          }
222          #endregion
223      }
224  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobExtension.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Linq;
7  using System.Runtime.Serialization;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using GitHub.DistributedTask.ObjectTemplating.Tokens;
11  using GitHub.DistributedTask.Pipelines;
12  using GitHub.DistributedTask.Pipelines.ContextData;
13  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
14  using GitHub.DistributedTask.WebApi;
15  using GitHub.Runner.Common;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  using Pipelines = GitHub.DistributedTask.Pipelines;
19  namespace GitHub.Runner.Worker
20  {
21      [DataContract]
22      public class SetupInfo
23      {
24          [DataMember]
25          public string Group { get; set; }
26          [DataMember]
27          public string Detail { get; set; }
28      }
29      [ServiceLocator(Default = typeof(JobExtension))]
30      public interface IJobExtension : IRunnerService
31      {
32          Task&lt;List&lt;IStep&gt;&gt; InitializeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message);
33          void FinalizeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, DateTime jobStartTimeUtc);
34      }
35      public sealed class JobExtension : RunnerService, IJobExtension
36      {
37          private readonly HashSet&lt;string&gt; _existingProcesses = new(StringComparer.OrdinalIgnoreCase);
38          private bool _processCleanup;
39          private string _processLookupId = $&quot;github_{Guid.NewGuid()}&quot;;
40          private CancellationTokenSource _diskSpaceCheckToken = new();
41          private Task _diskSpaceCheckTask = null;
42          public async Task&lt;List&lt;IStep&gt;&gt; InitializeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message)
43          {
44              Trace.Entering();
45              ArgUtil.NotNull(jobContext, nameof(jobContext));
46              ArgUtil.NotNull(message, nameof(message));
47              IExecutionContext context = jobContext.CreateChild(Guid.NewGuid(), &quot;Set up job&quot;, $&quot;{nameof(JobExtension)}_Init&quot;, null, null, ActionRunStage.Pre);
48              context.StepTelemetry.Type = &quot;runner&quot;;
49              context.StepTelemetry.Action = &quot;setup_job&quot;;
<span onclick='openModal()' class='match'>50              List&lt;IStep&gt; preJobSteps = new();
51              List&lt;IStep&gt; jobSteps = new();
52              using (var register = jobContext.CancellationToken.Register(() =&gt; { context.CancelToken(); }))
</span>53              {
54                  try
55                  {
56                      context.Start();
57                      context.Debug($&quot;Starting: Set up job&quot;);
58                      context.Output($&quot;Current runner version: &#x27;{BuildConstants.RunnerPackage.Version}&#x27;&quot;);
59                      var setting = HostContext.GetService&lt;IConfigurationStore&gt;().GetSettings();
60                      var credFile = HostContext.GetConfigFile(WellKnownConfigFile.Credentials);
61                      if (File.Exists(credFile))
62                      {
63                          var credData = IOUtil.LoadObject&lt;CredentialData&gt;(credFile);
64                          if (credData != null &amp;&amp;
65                              credData.Data.TryGetValue(&quot;clientId&quot;, out var clientId))
66                          {
67                              context.Output($&quot;Runner name: &#x27;{setting.AgentName}&#x27;&quot;);
68                              if (message.Variables.TryGetValue(&quot;system.runnerGroupName&quot;, out VariableValue runnerGroupName))
69                              {
70                                  context.Output($&quot;Runner group name: &#x27;{runnerGroupName.Value}&#x27;&quot;);
71                              }
72                              context.Output($&quot;Machine name: &#x27;{Environment.MachineName}&#x27;&quot;);
73                          }
74                      }
75                      var setupInfoFile = HostContext.GetConfigFile(WellKnownConfigFile.SetupInfo);
76                      if (File.Exists(setupInfoFile))
77                      {
78                          Trace.Info($&quot;Load machine setup info from {setupInfoFile}&quot;);
79                          try
80                          {
81                              var setupInfo = IOUtil.LoadObject&lt;List&lt;SetupInfo&gt;&gt;(setupInfoFile);
82                              if (setupInfo?.Count &gt; 0)
83                              {
84                                  foreach (var info in setupInfo)
85                                  {
86                                      if (!string.IsNullOrEmpty(info?.Detail))
87                                      {
88                                          var groupName = info.Group;
89                                          if (string.IsNullOrEmpty(groupName))
90                                          {
91                                              groupName = &quot;Machine Setup Info&quot;;
92                                          }
93                                          context.Output($&quot;##[group]{groupName}&quot;);
94                                          var multiLines = info.Detail.Replace(&quot;\r\n&quot;, &quot;\n&quot;).TrimEnd(&#x27;\n&#x27;).Split(&#x27;\n&#x27;);
95                                          foreach (var line in multiLines)
96                                          {
97                                              context.Output(line);
98                                          }
99                                          context.Output(&quot;##[endgroup]&quot;);
100                                      }
101                                  }
102                              }
103                          }
104                          catch (Exception ex)
105                          {
106                              context.Output($&quot;Fail to load and print machine setup info: {ex.Message}&quot;);
107                              Trace.Error(ex);
108                          }
109                      }
110                      try
111                      {
112                          var tokenPermissions = jobContext.Global.Variables.Get(&quot;system.github.token.permissions&quot;) ?? &quot;&quot;;
113                          if (!string.IsNullOrEmpty(tokenPermissions))
114                          {
115                              context.Output($&quot;##[group]GITHUB_TOKEN Permissions&quot;);
116                              var permissions = StringUtil.ConvertFromJson&lt;Dictionary&lt;string, string&gt;&gt;(tokenPermissions);
117                              foreach (KeyValuePair&lt;string, string&gt; entry in permissions)
118                              {
119                                  context.Output($&quot;{entry.Key}: {entry.Value}&quot;);
120                              }
121                              context.Output(&quot;##[endgroup]&quot;);
122                          }
123                      }
124                      catch (Exception ex)
125                      {
126                          context.Output($&quot;Fail to parse and display GITHUB_TOKEN permissions list: {ex.Message}&quot;);
127                          Trace.Error(ex);
128                      }
129                      var secretSource = context.GetGitHubContext(&quot;secret_source&quot;);
130                      if (!string.IsNullOrEmpty(secretSource))
131                      {
132                          context.Output($&quot;Secret source: {secretSource}&quot;);
133                      }
134                      var repoFullName = context.GetGitHubContext(&quot;repository&quot;);
135                      ArgUtil.NotNull(repoFullName, nameof(repoFullName));
136                      context.Debug($&quot;Primary repository: {repoFullName}&quot;);
137                      if (!string.IsNullOrEmpty(HostContext.WebProxy.HttpProxyAddress))
138                      {
139                          context.Output($&quot;Runner is running behind proxy server &#x27;{HostContext.WebProxy.HttpProxyAddress}&#x27; for all HTTP requests.&quot;);
140                      }
141                      if (!string.IsNullOrEmpty(HostContext.WebProxy.HttpsProxyAddress))
142                      {
143                          context.Output($&quot;Runner is running behind proxy server &#x27;{HostContext.WebProxy.HttpsProxyAddress}&#x27; for all HTTPS requests.&quot;);
144                      }
145                      context.Output(&quot;Prepare workflow directory&quot;);
146                      var directoryManager = HostContext.GetService&lt;IPipelineDirectoryManager&gt;();
147                      TrackingConfig trackingConfig = directoryManager.PrepareDirectory(
148                          context,
149                          message.Workspace);
150                      context.Debug(&quot;Update context data&quot;);
151                      string _workDirectory = HostContext.GetDirectory(WellKnownDirectory.Work);
152                      context.SetRunnerContext(&quot;workspace&quot;, Path.Combine(_workDirectory, trackingConfig.PipelineDirectory));
153                      context.SetGitHubContext(&quot;workspace&quot;, Path.Combine(_workDirectory, trackingConfig.WorkspaceDirectory));
154                      var configurationStore = HostContext.GetService&lt;IConfigurationStore&gt;();
155                      var runnerSettings = configurationStore.GetSettings();
156                      if (string.IsNullOrEmpty(context.GetGitHubContext(&quot;server_url&quot;)) &amp;&amp; !runnerSettings.IsHostedServer &amp;&amp; !string.IsNullOrEmpty(runnerSettings.GitHubUrl))
157                      {
158                          var url = new Uri(runnerSettings.GitHubUrl);
159                          var portInfo = url.IsDefaultPort ? string.Empty : $&quot;:{url.Port.ToString(CultureInfo.InvariantCulture)}&quot;;
160                          context.SetGitHubContext(&quot;server_url&quot;, $&quot;{url.Scheme}:&amp;bsol;&amp;bsol;{url.Host}{portInfo}&quot;);
161                          context.SetGitHubContext(&quot;api_url&quot;, $&quot;{url.Scheme}:&amp;bsol;&amp;bsol;{url.Host}{portInfo}/api/v3&quot;);
162                          context.SetGitHubContext(&quot;graphql_url&quot;, $&quot;{url.Scheme}:&amp;bsol;&amp;bsol;{url.Host}{portInfo}/api/graphql&quot;);
163                      }
164                      context.Debug(&quot;Evaluating job-level environment variables&quot;);
165                      var templateEvaluator = context.ToPipelineTemplateEvaluator();
166                      foreach (var token in message.EnvironmentVariables)
167                      {
168                          var environmentVariables = templateEvaluator.EvaluateStepEnvironment(token, jobContext.ExpressionValues, jobContext.ExpressionFunctions, VarUtil.EnvironmentVariableKeyComparer);
169                          foreach (var pair in environmentVariables)
170                          {
171                              context.Global.EnvironmentVariables[pair.Key] = pair.Value ?? string.Empty;
172                              context.SetEnvContext(pair.Key, pair.Value ?? string.Empty);
173                          }
174                      }
175                      context.Debug(&quot;Evaluating job container&quot;);
176                      var container = templateEvaluator.EvaluateJobContainer(message.JobContainer, jobContext.ExpressionValues, jobContext.ExpressionFunctions);
177                      ValidateJobContainer(container);
178                      if (container != null)
179                      {
180                          jobContext.Global.Container = new Container.ContainerInfo(HostContext, container);
181                      }
182                      context.Debug(&quot;Evaluating job service containers&quot;);
183                      var serviceContainers = templateEvaluator.EvaluateJobServiceContainers(message.JobServiceContainers, jobContext.ExpressionValues, jobContext.ExpressionFunctions);
184                      if (serviceContainers?.Count &gt; 0)
185                      {
186                          foreach (var pair in serviceContainers)
187                          {
188                              var networkAlias = pair.Key;
189                              var serviceContainer = pair.Value;
190                              if (serviceContainer == null)
191                              {
192                                  context.Output($&quot;The service &#x27;{networkAlias}&#x27; will not be started because the container definition has an empty image.&quot;);
193                                  continue;
194                              }
195                              jobContext.Global.ServiceContainers.Add(new Container.ContainerInfo(HostContext, serviceContainer, false, networkAlias));
196                          }
197                      }
198                      context.Debug(&quot;Evaluating job defaults&quot;);
199                      foreach (var token in message.Defaults)
200                      {
201                          var defaults = token.AssertMapping(&quot;defaults&quot;);
202                          if (defaults.Any(x =&gt; string.Equals(x.Key.AssertString(&quot;defaults key&quot;).Value, &quot;run&quot;, StringComparison.OrdinalIgnoreCase)))
203                          {
204                              context.Global.JobDefaults[&quot;run&quot;] = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
205                              var defaultsRun = defaults.First(x =&gt; string.Equals(x.Key.AssertString(&quot;defaults key&quot;).Value, &quot;run&quot;, StringComparison.OrdinalIgnoreCase));
206                              var jobDefaults = templateEvaluator.EvaluateJobDefaultsRun(defaultsRun.Value, jobContext.ExpressionValues, jobContext.ExpressionFunctions);
207                              foreach (var pair in jobDefaults)
208                              {
209                                  if (!string.IsNullOrEmpty(pair.Value))
210                                  {
211                                      context.Global.JobDefaults[&quot;run&quot;][pair.Key] = pair.Value;
212                                  }
213                              }
214                          }
215                      }
216                      Trace.Info(&quot;Downloading actions&quot;);
217                      var actionManager = HostContext.GetService&lt;IActionManager&gt;();
218                      var prepareResult = await actionManager.PrepareActionsAsync(context, message.Steps);
219                      var startedHookPath = Environment.GetEnvironmentVariable(&quot;ACTIONS_RUNNER_HOOK_JOB_STARTED&quot;);
220                      if (!string.IsNullOrEmpty(startedHookPath))
221                      {
222                          var hookProvider = HostContext.GetService&lt;IJobHookProvider&gt;();
223                          var jobHookData = new JobHookData(ActionRunStage.Pre, startedHookPath);
224                          preJobSteps.Add(new JobExtensionRunner(runAsync: hookProvider.RunHook,
225                                                                            condition: $&quot;{PipelineTemplateConstants.Always}()&quot;,
226                                                                            displayName: Constants.Hooks.JobStartedStepName,
227                                                                            data: (object)jobHookData));
228                      }
229                      preJobSteps.AddRange(prepareResult.ContainerSetupSteps);
230                      if (jobContext.Global.Container != null || jobContext.Global.ServiceContainers.Count &gt; 0)
231                      {
232                          var containerProvider = HostContext.GetService&lt;IContainerOperationProvider&gt;();
233                          var containers = new List&lt;Container.ContainerInfo&gt;();
234                          if (jobContext.Global.Container != null)
235                          {
236                              containers.Add(jobContext.Global.Container);
237                          }
238                          containers.AddRange(jobContext.Global.ServiceContainers);
239                          preJobSteps.Add(new JobExtensionRunner(runAsync: containerProvider.StartContainersAsync,
240                                                                            condition: $&quot;{PipelineTemplateConstants.Success}()&quot;,
241                                                                            displayName: &quot;Initialize containers&quot;,
242                                                                            data: (object)containers));
243                      }
244                      foreach (var step in message.Steps)
245                      {
246                          if (step.Type == Pipelines.StepType.Action)
247                          {
248                              var action = step as Pipelines.ActionStep;
249                              Trace.Info($&quot;Adding {action.DisplayName}.&quot;);
250                              var actionRunner = HostContext.CreateService&lt;IActionRunner&gt;();
251                              actionRunner.Action = action;
252                              actionRunner.Stage = ActionRunStage.Main;
253                              actionRunner.Condition = step.Condition;
254                              var contextData = new Pipelines.ContextData.DictionaryContextData();
255                              if (message.ContextData?.Count &gt; 0)
256                              {
257                                  foreach (var pair in message.ContextData)
258                                  {
259                                      contextData[pair.Key] = pair.Value;
260                                  }
261                              }
262                              actionRunner.EvaluateDisplayName(contextData, context, out _);
263                              jobSteps.Add(actionRunner);
264                              if (prepareResult.PreStepTracker.TryGetValue(step.Id, out var preStep))
265                              {
266                                  Trace.Info($&quot;Adding pre-{action.DisplayName}.&quot;);
267                                  preStep.EvaluateDisplayName(contextData, context, out _);
268                                  preStep.DisplayName = $&quot;Pre {preStep.DisplayName}&quot;;
269                                  preJobSteps.Add(preStep);
270                              }
271                          }
272                      }
273                      if (message.Variables.TryGetValue(&quot;system.workflowFileFullPath&quot;, out VariableValue workflowFileFullPath))
274                      {
275                          var usesLogText = $&quot;Uses: {workflowFileFullPath.Value}&quot;;
276                          var reference = GetWorkflowReference(message.Variables);
277                          context.Output(usesLogText + reference);
278                          if (message.ContextData.TryGetValue(&quot;inputs&quot;, out var pipelineContextData))
279                          {
280                              var inputs = pipelineContextData.AssertDictionary(&quot;inputs&quot;);
281                              if (inputs.Any())
282                              {
283                                  context.Output($&quot;##[group] Inputs&quot;);
284                                  foreach (var input in inputs)
285                                  {
286                                      context.Output($&quot;  {input.Key}: {input.Value}&quot;);
287                                  }
288                                  context.Output(&quot;##[endgroup]&quot;);
289                              }
290                          }
291                      }
292                      if (!string.IsNullOrWhiteSpace(message.JobDisplayName))
293                      {
294                          context.Output($&quot;Complete job name: {message.JobDisplayName}&quot;);
295                      }
296                      var intraActionStates = new Dictionary&lt;Guid, Dictionary&lt;string, string&gt;&gt;();
297                      foreach (var preStep in prepareResult.PreStepTracker)
298                      {
299                          intraActionStates[preStep.Key] = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
300                      }
301                      foreach (var step in preJobSteps)
302                      {
303                          if (step is JobExtensionRunner)
304                          {
305                              JobExtensionRunner extensionStep = step as JobExtensionRunner;
306                              ArgUtil.NotNull(extensionStep, extensionStep.DisplayName);
307                              Guid stepId = Guid.NewGuid();
308                              extensionStep.ExecutionContext = jobContext.CreateChild(stepId, extensionStep.DisplayName, stepId.ToString(&quot;N&quot;), null, stepId.ToString(&quot;N&quot;), ActionRunStage.Pre);
309                              extensionStep.ExecutionContext.StepTelemetry.Type = &quot;runner&quot;;
310                              extensionStep.ExecutionContext.StepTelemetry.Action = extensionStep.DisplayName.ToLowerInvariant().Replace(&#x27; &#x27;, &#x27;_&#x27;);
311                          }
312                          else if (step is IActionRunner actionStep)
313                          {
314                              ArgUtil.NotNull(actionStep, step.DisplayName);
315                              Guid stepId = Guid.NewGuid();
316                              actionStep.ExecutionContext = jobContext.CreateChild(stepId, actionStep.DisplayName, stepId.ToString(&quot;N&quot;), null, null, ActionRunStage.Pre, intraActionStates[actionStep.Action.Id]);
317                          }
318                      }
319                      foreach (var step in jobSteps)
320                      {
321                          if (step is IActionRunner actionStep)
322                          {
323                              ArgUtil.NotNull(actionStep, step.DisplayName);
324                              intraActionStates.TryGetValue(actionStep.Action.Id, out var intraActionState);
325                              actionStep.ExecutionContext = jobContext.CreateChild(actionStep.Action.Id, actionStep.DisplayName, actionStep.Action.Name, null, actionStep.Action.ContextName, ActionRunStage.Main, intraActionState);
326                          }
327                      }
328                      var completedHookPath = Environment.GetEnvironmentVariable(&quot;ACTIONS_RUNNER_HOOK_JOB_COMPLETED&quot;);
329                      if (!string.IsNullOrEmpty(completedHookPath))
330                      {
331                          var hookProvider = HostContext.GetService&lt;IJobHookProvider&gt;();
332                          var jobHookData = new JobHookData(ActionRunStage.Post, completedHookPath);
333                          jobContext.RegisterPostJobStep(new JobExtensionRunner(runAsync: hookProvider.RunHook,
334                                                                            condition: $&quot;{PipelineTemplateConstants.Always}()&quot;,
335                                                                            displayName: Constants.Hooks.JobCompletedStepName,
336                                                                            data: (object)jobHookData));
337                      }
338                      List&lt;IStep&gt; steps = new();
339                      steps.AddRange(preJobSteps);
340                      steps.AddRange(jobSteps);
341                      _processCleanup = jobContext.Global.Variables.GetBoolean(&quot;process.clean&quot;) ?? true;
342                      if (_processCleanup)
343                      {
344                          Environment.SetEnvironmentVariable(Constants.ProcessTrackingId, _processLookupId);
345                          context.Debug(&quot;Collect running processes for tracking orphan processes.&quot;);
346                          Dictionary&lt;int, Process&gt; processes = SnapshotProcesses();
347                          foreach (var proc in processes)
348                          {
349                              _existingProcesses.Add($&quot;{proc.Key}_{proc.Value.ProcessName}&quot;);
350                          }
351                      }
352                      jobContext.Global.EnvironmentVariables.TryGetValue(Constants.Runner.Features.DiskSpaceWarning, out var enableWarning);
353                      if (StringUtil.ConvertToBoolean(enableWarning, defaultValue: true))
354                      {
355                          _diskSpaceCheckTask = CheckDiskSpaceAsync(context, _diskSpaceCheckToken.Token);
356                      }
357                      return steps;
358                  }
359                  catch (OperationCanceledException ex) when (jobContext.CancellationToken.IsCancellationRequested)
360                  {
361                      Trace.Error($&quot;Caught cancellation exception from JobExtension Initialization: {ex}&quot;);
362                      context.Error(ex);
363                      context.Result = TaskResult.Canceled;
364                      throw;
365                  }
366                  catch (Exception ex)
367                  {
368                      Trace.Error($&quot;Caught exception from JobExtension Initialization: {ex}&quot;);
369                      context.Error(ex);
370                      context.Result = TaskResult.Failed;
371                      throw;
372                  }
373                  finally
374                  {
375                      context.Debug(&quot;Finishing: Set up job&quot;);
376                      context.Complete();
377                  }
378              }
379          }
380          private string GetWorkflowReference(IDictionary&lt;string, VariableValue&gt; variables)
381          {
382              var reference = &quot;&quot;;
383              if (variables.TryGetValue(&quot;system.workflowFileSha&quot;, out VariableValue workflowFileSha))
384              {
385                  if (variables.TryGetValue(&quot;system.workflowFileRef&quot;, out VariableValue workflowFileRef)
386                      &amp;&amp; !string.IsNullOrEmpty(workflowFileRef.Value))
387                  {
388                      reference += $&quot;@{workflowFileRef.Value} ({workflowFileSha.Value})&quot;;
389                  }
390                  else
391                  {
392                      reference += $&quot;@{workflowFileSha.Value}&quot;;
393                  }
394              }
395              return reference;
396          }
397          public void FinalizeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, DateTime jobStartTimeUtc)
398          {
399              Trace.Entering();
400              ArgUtil.NotNull(jobContext, nameof(jobContext));
401              IExecutionContext context = jobContext.CreateChild(Guid.NewGuid(), &quot;Complete job&quot;, $&quot;{nameof(JobExtension)}_Final&quot;, null, null, ActionRunStage.Post);
402              context.StepTelemetry.Type = &quot;runner&quot;;
403              context.StepTelemetry.Action = &quot;complete_job&quot;;
404              using (var register = jobContext.CancellationToken.Register(() =&gt; { context.CancelToken(); }))
405              {
406                  try
407                  {
408                      context.Start();
409                      context.Debug(&quot;Starting: Complete job&quot;);
410                      Trace.Info(&quot;Initialize Env context&quot;);
411  #if OS_WINDOWS
412                      var envContext = new DictionaryContextData();
413  #else
414                      var envContext = new CaseSensitiveDictionaryContextData();
415  #endif
416                      context.ExpressionValues[&quot;env&quot;] = envContext;
417                      foreach (var pair in context.Global.EnvironmentVariables)
418                      {
419                          envContext[pair.Key] = new StringContextData(pair.Value ?? string.Empty);
420                      }
421                      Trace.Info(&quot;Initialize steps context&quot;);
422                      context.ExpressionValues[&quot;steps&quot;] = context.Global.StepsContext.GetScope(context.ScopeName);
423                      var templateEvaluator = context.ToPipelineTemplateEvaluator();
424                      if (message.JobOutputs != null &amp;&amp; message.JobOutputs.Type != TokenType.Null)
425                      {
426                          try
427                          {
428                              context.Output($&quot;Evaluate and set job outputs&quot;);
429                              Trace.Info(&quot;Initialize Env context for evaluating job outputs&quot;);
430                              var outputs = templateEvaluator.EvaluateJobOutput(message.JobOutputs, context.ExpressionValues, context.ExpressionFunctions);
431                              foreach (var output in outputs)
432                              {
433                                  if (string.IsNullOrEmpty(output.Value))
434                                  {
435                                      context.Debug($&quot;Skip output &#x27;{output.Key}&#x27; since it&#x27;s empty&quot;);
436                                      continue;
437                                  }
438                                  if (!string.Equals(output.Value, HostContext.SecretMasker.MaskSecrets(output.Value)))
439                                  {
440                                      context.Warning($&quot;Skip output &#x27;{output.Key}&#x27; since it may contain secret.&quot;);
441                                      continue;
442                                  }
443                                  context.Output($&quot;Set output &#x27;{output.Key}&#x27;&quot;);
444                                  jobContext.JobOutputs[output.Key] = output.Value;
445                              }
446                          }
447                          catch (Exception ex)
448                          {
449                              context.Result = TaskResult.Failed;
450                              context.Error($&quot;Fail to evaluate job outputs&quot;);
451                              context.Error(ex);
452                              jobContext.Result = TaskResultUtil.MergeTaskResults(jobContext.Result, TaskResult.Failed);
453                          }
454                      }
455                      if (jobContext.ActionsEnvironment?.Url != null &amp;&amp; jobContext.ActionsEnvironment?.Url.Type != TokenType.Null)
456                      {
457                          try
458                          {
459                              context.Output($&quot;Evaluate and set environment url&quot;);
460                              var environmentUrlToken = templateEvaluator.EvaluateEnvironmentUrl(jobContext.ActionsEnvironment.Url, context.ExpressionValues, context.ExpressionFunctions);
461                              var environmentUrl = environmentUrlToken.AssertString(&quot;environment.url&quot;);
462                              if (!string.Equals(environmentUrl.Value, HostContext.SecretMasker.MaskSecrets(environmentUrl.Value)))
463                              {
464                                  context.Warning($&quot;Skip setting environment url as environment &#x27;{jobContext.ActionsEnvironment.Name}&#x27; may contain secret.&quot;);
465                              }
466                              else
467                              {
468                                  context.Output($&quot;Evaluated environment url: {environmentUrl}&quot;);
469                                  jobContext.ActionsEnvironment.Url = environmentUrlToken;
470                              }
471                          }
472                          catch (Exception ex)
473                          {
474                              context.Result = TaskResult.Failed;
475                              context.Error($&quot;Failed to evaluate environment url&quot;);
476                              context.Error(ex);
477                              jobContext.Result = TaskResultUtil.MergeTaskResults(jobContext.Result, TaskResult.Failed);
478                          }
479                      }
480                      if (context.Global.Variables.GetBoolean(Constants.Variables.Actions.RunnerDebug) ?? false)
481                      {
482                          Trace.Info(&quot;Support log upload starting.&quot;);
483                          context.Output(&quot;Uploading runner diagnostic logs&quot;);
484                          IDiagnosticLogManager diagnosticLogManager = HostContext.GetService&lt;IDiagnosticLogManager&gt;();
485                          try
486                          {
487                              diagnosticLogManager.UploadDiagnosticLogs(executionContext: context, parentContext: jobContext, message: message, jobStartTimeUtc: jobStartTimeUtc);
488                              Trace.Info(&quot;Support log upload complete.&quot;);
489                              context.Output(&quot;Completed runner diagnostic log upload&quot;);
490                          }
491                          catch (Exception ex)
492                          {
493                              Trace.Info(&quot;Error uploading support logs.&quot;);
494                              context.Output(&quot;Error uploading runner diagnostic logs&quot;);
495                              Trace.Error(ex);
496                          }
497                      }
498                      if (_processCleanup)
499                      {
500                          context.Output(&quot;Cleaning up orphan processes&quot;);
501                          Dictionary&lt;int, Process&gt; currentProcesses = SnapshotProcesses();
502                          foreach (var proc in currentProcesses)
503                          {
504                              if (proc.Key == Process.GetCurrentProcess().Id)
505                              {
506                                  continue;
507                              }
508                              if (_existingProcesses.Contains($&quot;{proc.Key}_{proc.Value.ProcessName}&quot;))
509                              {
510                                  Trace.Verbose($&quot;Skip existing process. PID: {proc.Key} ({proc.Value.ProcessName})&quot;);
511                              }
512                              else
513                              {
514                                  Trace.Info($&quot;Inspecting process environment variables. PID: {proc.Key} ({proc.Value.ProcessName})&quot;);
515                                  string lookupId = null;
516                                  try
517                                  {
518                                      lookupId = proc.Value.GetEnvironmentVariable(HostContext, Constants.ProcessTrackingId);
519                                  }
520                                  catch (Exception ex)
521                                  {
522                                      Trace.Warning($&quot;Ignore exception during read process environment variables: {ex.Message}&quot;);
523                                      Trace.Verbose(ex.ToString());
524                                  }
525                                  if (string.Equals(lookupId, _processLookupId, StringComparison.OrdinalIgnoreCase))
526                                  {
527                                      context.Output($&quot;Terminate orphan process: pid ({proc.Key}) ({proc.Value.ProcessName})&quot;);
528                                      try
529                                      {
530                                          proc.Value.Kill();
531                                      }
532                                      catch (Exception ex)
533                                      {
534                                          Trace.Error(&quot;Catch exception during orphan process cleanup.&quot;);
535                                          Trace.Error(ex);
536                                      }
537                                  }
538                              }
539                          }
540                      }
541                      if (_diskSpaceCheckTask != null)
542                      {
543                          _diskSpaceCheckToken.Cancel();
544                      }
545                  }
546                  catch (Exception ex)
547                  {
548                      Trace.Error($&quot;Caught exception from JobExtension finalization: {ex}&quot;);
549                      context.Output(ex.Message);
550                  }
551                  finally
552                  {
553                      context.Debug(&quot;Finishing: Complete job&quot;);
554                      context.Complete();
555                  }
556              }
557          }
558          private async Task CheckDiskSpaceAsync(IExecutionContext context, CancellationToken token)
559          {
560              while (!token.IsCancellationRequested)
561              {
562                  var lowDiskSpaceThreshold = context.Global.Variables.GetInt(WellKnownDistributedTaskVariables.RunnerLowDiskspaceThreshold);
563                  if (lowDiskSpaceThreshold == null)
564                  {
565                      Trace.Info($&quot;Low diskspace warning is not enabled.&quot;);
566                      return;
567                  }
568                  var workDirRoot = Directory.GetDirectoryRoot(HostContext.GetDirectory(WellKnownDirectory.Work));
569                  var driveInfo = new DriveInfo(workDirRoot);
570                  var freeSpaceInMB = driveInfo.AvailableFreeSpace / 1024 / 1024;
571                  if (freeSpaceInMB &lt; lowDiskSpaceThreshold)
572                  {
573                      var issue = new Issue() { Type = IssueType.Warning, Message = $&quot;You are running out of disk space. The runner will stop working when the machine runs out of disk space. Free space left: {freeSpaceInMB} MB&quot; };
574                      issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = Constants.Runner.LowDiskSpace;
575                      context.AddIssue(issue, ExecutionContextLogOptions.Default);
576                      return;
577                  }
578                  try
579                  {
580                      await Task.Delay(10 * 1000, token);
581                  }
582                  catch (TaskCanceledException)
583                  {
584                  }
585              }
586          }
587          private Dictionary&lt;int, Process&gt; SnapshotProcesses()
588          {
589              Dictionary&lt;int, Process&gt; snapshot = new();
590              foreach (var proc in Process.GetProcesses())
591              {
592                  try
593                  {
594                      if (!string.IsNullOrEmpty(proc.ProcessName))
595                      {
596                          snapshot[proc.Id] = proc;
597                      }
598                  }
599                  catch (Exception ex)
600                  {
601                      Trace.Verbose($&quot;Ignore any exception during taking process snapshot of process pid={proc.Id}: &#x27;{ex.Message}&#x27;.&quot;);
602                  }
603              }
604              Trace.Info($&quot;Total accessible running process: {snapshot.Count}.&quot;);
605              return snapshot;
606          }
607          private static void ValidateJobContainer(JobContainer container)
608          {
609              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(Constants.Variables.Actions.RequireJobContainer)) &amp;&amp; container == null)
610              {
611                  throw new ArgumentException(&quot;Jobs without a job container are forbidden on this runner, please add a &#x27;container:&#x27; to your job or contact your self-hosted runner administrator.&quot;);
612              }
613          }
614      }
615  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ResizeObserverTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobExtension.cs</div>
                </div>
                <div class="column column_space"><pre><code>33              List&lt;ElementReference&gt; allReferences = new();
34              List&lt;ElementReference&gt; notObservedReferences = new();
35              Dictionary&lt;ElementReference, BoundingClientRect&gt; resolvedElements = new();
</pre></code></div>
                <div class="column column_space"><pre><code>50              List&lt;IStep&gt; preJobSteps = new();
51              List&lt;IStep&gt; jobSteps = new();
52              using (var register = jobContext.CancellationToken.Register(() =&gt; { context.CancelToken(); }))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    