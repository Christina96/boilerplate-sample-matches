
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</h3>
            <pre><code>1  using GitHub.Runner.Sdk;
2  using System;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Xunit;
7  namespace GitHub.Runner.Common.Tests.Util
8  {
9      public sealed class IOUtilL0
10      {
11          [Fact]
12          [Trait("Level", "L0")]
13          [Trait("Category", "Common")]
14          public void Delete_DeletesDirectory()
15          {
16              using (TestHostContext hc = new(this))
17              {
18                  Tracing trace = hc.GetTrace();
19                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
20                  string file = Path.Combine(directory, "some file");
21                  try
22                  {
23                      Directory.CreateDirectory(directory);
24                      File.WriteAllText(path: file, contents: "some contents");
25                      IOUtil.Delete(directory, CancellationToken.None);
26                      Assert.False(Directory.Exists(directory));
27                  }
28                  finally
29                  {
30                      if (Directory.Exists(directory))
31                      {
32                          Directory.Delete(directory, recursive: true);
33                      }
34                  }
35              }
36          }
37          [Fact]
38          [Trait("Level", "L0")]
39          [Trait("Category", "Common")]
40          public void Delete_DeletesFile()
41          {
42              using (TestHostContext hc = new(this))
43              {
44                  Tracing trace = hc.GetTrace();
45                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
46                  string file = Path.Combine(directory, "some file");
47                  try
48                  {
49                      Directory.CreateDirectory(directory);
50                      File.WriteAllText(path: file, contents: "some contents");
51                      IOUtil.Delete(file, CancellationToken.None);
52                      Assert.False(File.Exists(file));
53                  }
54                  finally
55                  {
56                      if (Directory.Exists(directory))
57                      {
58                          Directory.Delete(directory, recursive: true);
59                      }
60                  }
61              }
62          }
63          [Fact]
64          [Trait("Level", "L0")]
65          [Trait("Category", "Common")]
66          public void DeleteDirectory_DeletesDirectoriesRecursively()
67          {
68              using (TestHostContext hc = new(this))
69              {
70                  Tracing trace = hc.GetTrace();
71                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
72                  try
73                  {
74                      Directory.CreateDirectory(Path.Combine(directory, "some child directory", "some grandchild directory"));
75                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
76                      Assert.False(Directory.Exists(directory));
77                  }
78                  finally
79                  {
80                      if (Directory.Exists(directory))
81                      {
82                          Directory.Delete(directory, recursive: true);
83                      }
84                  }
85              }
86          }
87          [Fact]
88          [Trait("Level", "L0")]
89          [Trait("Category", "Common")]
90          public async Task DeleteDirectory_DeletesDirectoryReparsePointChain()
91          {
92              using (TestHostContext hc = new(this))
93              {
94                  Tracing trace = hc.GetTrace();
95                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
96                  try
97                  {
98                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
99                      string file = Path.Combine(targetDir, "file.txt");
100                      File.WriteAllText(path: file, contents: "some contents");
101                      string linkDir1 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir1");
102                      string linkDir2 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir2");
103                      string linkDir3 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir3");
104                      string linkDir4 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir4");
105                      string linkDir5 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir5");
106                      await CreateDirectoryReparsePoint(context: hc, link: linkDir1, target: linkDir2);
107                      await CreateDirectoryReparsePoint(context: hc, link: linkDir2, target: linkDir3);
108                      await CreateDirectoryReparsePoint(context: hc, link: linkDir3, target: linkDir4);
109                      await CreateDirectoryReparsePoint(context: hc, link: linkDir4, target: linkDir5);
110                      await CreateDirectoryReparsePoint(context: hc, link: linkDir5, target: targetDir);
111                      Assert.True(Directory.Exists(linkDir1));
112                      Assert.True(new DirectoryInfo(linkDir1).Attributes.HasFlag(FileAttributes.ReparsePoint));
113                      Assert.True(File.Exists(Path.Combine(linkDir1, "file.txt")));
114                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
115                      Assert.False(Directory.Exists(linkDir1));
116                      Assert.False(Directory.Exists(targetDir));
117                      Assert.False(File.Exists(file));
118                      Assert.False(Directory.Exists(randomDir));
119                  }
120                  finally
121                  {
122                      if (Directory.Exists(randomDir))
123                      {
124                          Directory.Delete(randomDir, recursive: true);
125                      }
126                  }
127              }
128          }
129          [Fact]
130          [Trait("Level", "L0")]
131          [Trait("Category", "Common")]
132          public async Task DeleteDirectory_DeletesDirectoryReparsePointsBeforeDirectories()
133          {
134              using (TestHostContext hc = new(this))
135              {
136                  Tracing trace = hc.GetTrace();
137                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
138                  try
139                  {
140                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
141                      string file = Path.Combine(targetDir, "file.txt");
142                      File.WriteAllText(path: file, contents: "some contents");
143                      string linkDir = Path.Combine(randomDir, "linkDir");
144                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
145                      Assert.True(Directory.Exists(linkDir));
146                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
147                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
148                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
149                      Assert.False(Directory.Exists(linkDir));
150                      Assert.False(Directory.Exists(targetDir));
151                      Assert.False(File.Exists(file));
152                      Assert.False(Directory.Exists(randomDir));
153                  }
154                  finally
155                  {
156                      if (Directory.Exists(randomDir))
157                      {
158                          Directory.Delete(randomDir, recursive: true);
159                      }
160                  }
161              }
162          }
163          [Fact]
164          [Trait("Level", "L0")]
165          [Trait("Category", "Common")]
166          public void DeleteDirectory_DeletesFilesRecursively()
167          {
168              using (TestHostContext hc = new(this))
169              {
170                  Tracing trace = hc.GetTrace();
171                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
172                  try
173                  {
174                      string file = Path.Combine(directory, "some subdirectory", "some file");
175                      Directory.CreateDirectory(Path.GetDirectoryName(file));
176                      File.WriteAllText(path: file, contents: "some contents");
177                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
178                      Assert.False(Directory.Exists(directory));
179                  }
180                  finally
181                  {
182                      if (Directory.Exists(directory))
183                      {
184                          Directory.Delete(directory, recursive: true);
185                      }
186                  }
187              }
188          }
189          [Fact]
190          [Trait("Level", "L0")]
191          [Trait("Category", "Common")]
192          public void DeleteDirectory_DeletesReadOnlyDirectories()
193          {
194              using (TestHostContext hc = new(this))
195              {
196                  Tracing trace = hc.GetTrace();
197                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
198                  string subdirectory = Path.Combine(directory, "some subdirectory");
199                  try
200                  {
201                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
202                      subdirectoryInfo.Create();
203                      subdirectoryInfo.Attributes = subdirectoryInfo.Attributes | FileAttributes.ReadOnly;
204                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
205                      Assert.False(Directory.Exists(directory));
206                  }
207                  finally
208                  {
209                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
210                      if (subdirectoryInfo.Exists)
211                      {
212                          subdirectoryInfo.Attributes = subdirectoryInfo.Attributes & ~FileAttributes.ReadOnly;
213                      }
214                      if (Directory.Exists(directory))
215                      {
216                          Directory.Delete(directory, recursive: true);
217                      }
218                  }
219              }
220          }
221          [Fact]
222          [Trait("Level", "L0")]
223          [Trait("Category", "Common")]
224          public void DeleteDirectory_DeletesReadOnlyRootDirectory()
225          {
226              using (TestHostContext hc = new(this))
227              {
228                  Tracing trace = hc.GetTrace();
229                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
230                  try
231                  {
232                      var directoryInfo = new DirectoryInfo(directory);
233                      directoryInfo.Create();
234                      directoryInfo.Attributes = directoryInfo.Attributes | FileAttributes.ReadOnly;
235                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
236                      Assert.False(Directory.Exists(directory));
237                  }
238                  finally
239                  {
240                      var directoryInfo = new DirectoryInfo(directory);
241                      if (directoryInfo.Exists)
242                      {
243                          directoryInfo.Attributes = directoryInfo.Attributes & ~FileAttributes.ReadOnly;
244                          directoryInfo.Delete();
245                      }
246                  }
247              }
248          }
249          [Fact]
250          [Trait("Level", "L0")]
251          [Trait("Category", "Common")]
252          public void DeleteDirectory_DeletesReadOnlyFiles()
253          {
254              using (TestHostContext hc = new(this))
255              {
256                  Tracing trace = hc.GetTrace();
257                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
258                  string file = Path.Combine(directory, "some file");
259                  try
260                  {
261                      Directory.CreateDirectory(directory);
262                      File.WriteAllText(path: file, contents: "some contents");
263                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
264                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
265                      Assert.False(Directory.Exists(directory));
266                  }
267                  finally
268                  {
269                      if (File.Exists(file))
270                      {
271                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
272                      }
273                      if (Directory.Exists(directory))
274                      {
275                          Directory.Delete(directory, recursive: true);
276                      }
277                  }
278              }
279          }
280          [Fact]
281          [Trait("Level", "L0")]
282          [Trait("Category", "Common")]
283          public async Task DeleteDirectory_DoesNotFollowDirectoryReparsePoint()
284          {
285              using (TestHostContext hc = new(this))
286              {
287                  Tracing trace = hc.GetTrace();
288                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
289                  try
290                  {
291                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
292                      string file = Path.Combine(targetDir, "file.txt");
293                      File.WriteAllText(path: file, contents: "some contents");
294                      string linkDir = Path.Combine(randomDir, "linkDir");
295                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
296                      Assert.True(Directory.Exists(linkDir));
297                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
298                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
299                      IOUtil.DeleteDirectory(linkDir, CancellationToken.None);
300                      Assert.False(Directory.Exists(linkDir));
301                      Assert.True(Directory.Exists(targetDir));
302                      Assert.True(File.Exists(file));
303                  }
304                  finally
305                  {
306                      if (Directory.Exists(randomDir))
307                      {
308                          Directory.Delete(randomDir, recursive: true);
309                      }
310                  }
311              }
312          }
313          [Fact]
314          [Trait("Level", "L0")]
315          [Trait("Category", "Common")]
316          public async Task DeleteDirectory_DoesNotFollowNestLevel1DirectoryReparsePoint()
317          {
318              using (TestHostContext hc = new(this))
319              {
320                  Tracing trace = hc.GetTrace();
321                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
322                  try
323                  {
324                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
325                      string file = Path.Combine(targetDir, "file.txt");
326                      File.WriteAllText(path: file, contents: "some contents");
327                      string subDir = Directory.CreateDirectory(Path.Combine(randomDir, "subDir")).FullName;
328                      string linkDir = Path.Combine(subDir, "linkDir");
329                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
330                      Assert.True(Directory.Exists(linkDir));
331                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
332                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
333                      IOUtil.DeleteDirectory(subDir, CancellationToken.None);
334                      Assert.False(Directory.Exists(subDir));
335                      Assert.True(Directory.Exists(targetDir));
336                      Assert.True(File.Exists(file));
337                  }
338                  finally
339                  {
340                      if (Directory.Exists(randomDir))
341                      {
342                          Directory.Delete(randomDir, recursive: true);
343                      }
344                  }
345              }
346          }
347          [Fact]
348          [Trait("Level", "L0")]
349          [Trait("Category", "Common")]
350          public async Task DeleteDirectory_DoesNotFollowNestLevel2DirectoryReparsePoint()
351          {
352              using (TestHostContext hc = new(this))
353              {
354                  Tracing trace = hc.GetTrace();
355                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
356                  try
357                  {
358                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
359                      string file = Path.Combine(targetDir, "file.txt");
360                      File.WriteAllText(path: file, contents: "some contents");
361                      string subDir1 = Directory.CreateDirectory(Path.Combine(randomDir, "subDir1")).FullName;
362                      string subDir2 = Directory.CreateDirectory(Path.Combine(subDir1, "subDir2")).FullName;
363                      string linkDir = Path.Combine(subDir2, "linkDir");
364                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
365                      Assert.True(Directory.Exists(linkDir));
366                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
367                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
368                      IOUtil.DeleteDirectory(subDir1, CancellationToken.None);
369                      Assert.False(Directory.Exists(subDir1));
370                      Assert.True(Directory.Exists(targetDir));
371                      Assert.True(File.Exists(file));
372                  }
373                  finally
374                  {
375                      if (Directory.Exists(randomDir))
376                      {
377                          Directory.Delete(randomDir, recursive: true);
378                      }
379                  }
380              }
381          }
382          [Fact]
383          [Trait("Level", "L0")]
384          [Trait("Category", "Common")]
385          public void DeleteDirectory_IgnoresFile()
386          {
387              using (TestHostContext hc = new(this))
388              {
389                  Tracing trace = hc.GetTrace();
390                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
391                  string file = Path.Combine(directory, "some file");
392                  try
393                  {
394                      Directory.CreateDirectory(directory);
395                      File.WriteAllText(path: file, contents: "some contents");
396                      IOUtil.DeleteDirectory(file, CancellationToken.None);
397                      Assert.True(File.Exists(file));
398                  }
399                  finally
400                  {
401                      if (Directory.Exists(directory))
402                      {
403                          Directory.Delete(directory, recursive: true);
404                      }
405                  }
406              }
407          }
408          [Fact]
409          [Trait("Level", "L0")]
410          [Trait("Category", "Common")]
411          public void DeleteFile_DeletesFile()
412          {
413              using (TestHostContext hc = new(this))
414              {
415                  Tracing trace = hc.GetTrace();
416                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
417                  string file = Path.Combine(directory, "some file");
418                  try
419                  {
420                      Directory.CreateDirectory(directory);
421                      File.WriteAllText(path: file, contents: "some contents");
422                      IOUtil.DeleteFile(file);
423                      Assert.False(File.Exists(file));
424                  }
425                  finally
426                  {
427                      if (Directory.Exists(directory))
428                      {
429                          Directory.Delete(directory, recursive: true);
430                      }
431                  }
432              }
433          }
434          [Fact]
435          [Trait("Level", "L0")]
436          [Trait("Category", "Common")]
437          public void DeleteFile_DeletesReadOnlyFile()
438          {
439              using (TestHostContext hc = new(this))
440              {
441                  Tracing trace = hc.GetTrace();
442                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
443                  string file = Path.Combine(directory, "some file");
444                  try
445                  {
446                      Directory.CreateDirectory(directory);
447                      File.WriteAllText(path: file, contents: "some contents");
448                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
449                      IOUtil.DeleteFile(file);
450                      Assert.False(File.Exists(file));
451                  }
452                  finally
453                  {
454                      if (File.Exists(file))
455                      {
456                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
457                      }
458                      if (Directory.Exists(directory))
459                      {
460                          Directory.Delete(directory, recursive: true);
461                      }
462                  }
463              }
464          }
465          [Fact]
466          [Trait("Level", "L0")]
467          [Trait("Category", "Common")]
468          public void DeleteFile_IgnoresDirectory()
469          {
470              using (TestHostContext hc = new(this))
471              {
472                  Tracing trace = hc.GetTrace();
473                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
474                  try
475                  {
476                      Directory.CreateDirectory(directory);
477                      IOUtil.DeleteFile(directory);
478                      Assert.True(Directory.Exists(directory));
479                  }
480                  finally
481                  {
482                      if (Directory.Exists(directory))
483                      {
484                          Directory.Delete(directory, recursive: true);
485                      }
486                  }
487              }
488          }
489          [Fact]
490          [Trait("Level", "L0")]
491          [Trait("Category", "Common")]
492          public void GetRelativePath()
493          {
494              using (TestHostContext hc = new(this))
495              {
496                  Tracing trace = hc.GetTrace();
497                  string relativePath;
498  #if OS_WINDOWS
499                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src");
500                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
501                  relativePath = IOUtil.MakeRelative(@"d:\", @"d:\specs");
502                  Assert.True(string.Equals(relativePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
503                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src\proj");
504                  Assert.True(string.Equals(relativePath, @"d:\src\project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
505                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo", @"d:\src");
506                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
507                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:\src\project");
508                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
509                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
510                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
511                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
512                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
513                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo", @"d:/src");
514                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
515                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:/src/project");
516                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
517  #else
518                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src");
519                  Assert.True(string.Equals(relativePath, @"project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
520                  relativePath = IOUtil.MakeRelative(@"/user", @"/user/specs");
521                  Assert.True(string.Equals(relativePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
522                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src/proj");
523                  Assert.True(string.Equals(relativePath, @"/user/src/project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
524                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo", @"/user/src");
525                  Assert.True(string.Equals(relativePath, @"project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
526                  relativePath = IOUtil.MakeRelative(@"/user/src/project", @"/user/src/project");
527                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
528  #endif
529              }
530          }
531          [Fact]
532          [Trait("Level", "L0")]
533          [Trait("Category", "Common")]
534          public void ResolvePath()
535          {
536              using (TestHostContext hc = new(this))
537              {
538                  Tracing trace = hc.GetTrace();
539                  string resolvePath;
540  #if OS_WINDOWS
541                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"foo");
542                  Assert.True(string.Equals(resolvePath, @"d:\src\project\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
543                  resolvePath = IOUtil.ResolvePath(@"d:\", @"specs");
544                  Assert.True(string.Equals(resolvePath, @"d:\specs", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
545                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"src\proj");
546                  Assert.True(string.Equals(resolvePath, @"d:\src\project\src\proj", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
547                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\foo", @"..");
548                  Assert.True(string.Equals(resolvePath, @"d:\src\project", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
549                  resolvePath = IOUtil.ResolvePath(@"d:\src\project", @"..\..\");
550                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
551                  resolvePath = IOUtil.ResolvePath(@"d:/src/project", @"../.");
552                  Assert.True(string.Equals(resolvePath, @"d:\src", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
553                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/", @"../../foo");
554                  Assert.True(string.Equals(resolvePath, @"d:\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
555                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/foo", @".././bar/.././../foo");
556                  Assert.True(string.Equals(resolvePath, @"d:\src\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
557                  resolvePath = IOUtil.ResolvePath(@"d:\", @".");
558                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
559  #else
560                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"foo");
561                  Assert.True(string.Equals(resolvePath, @"/user/src/project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
562                  resolvePath = IOUtil.ResolvePath(@"/root", @"./user/./specs");
563                  Assert.True(string.Equals(resolvePath, @"/root/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
564                  resolvePath = IOUtil.ResolvePath(@"/", @"user/specs/.");
565                  Assert.True(string.Equals(resolvePath, @"/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
566                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../");
<span onclick='openModal()' class='match'>567                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
568                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../../");
</span>569                  Assert.True(string.Equals(resolvePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
570                  resolvePath = IOUtil.ResolvePath(@"/user/src/project/foo", @"../../../../user/./src");
571                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
572                  resolvePath = IOUtil.ResolvePath(@"/user/src", @"../../.");
573                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
574                  resolvePath = IOUtil.ResolvePath(@"/", @"./");
575                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
576  #endif
577              }
578          }
579          [Fact]
580          [Trait("Level", "L0")]
581          [Trait("Category", "Common")]
582          public void ValidateExecutePermission_DoesNotExceedFailsafe()
583          {
584              using (TestHostContext hc = new(this))
585              {
586                  Tracing trace = hc.GetTrace();
587                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
588                  try
589                  {
590                      Directory.CreateDirectory(directory);
591                      IOUtil.ValidateExecutePermission(directory);
592                  }
593                  finally
594                  {
595                      if (Directory.Exists(directory))
596                      {
597                          Directory.Delete(directory, recursive: true);
598                      }
599                  }
600              }
601          }
602          [Fact]
603          [Trait("Level", "L0")]
604          [Trait("Category", "Common")]
605          public void ValidateExecutePermission_ExceedsFailsafe()
606          {
607              using (TestHostContext hc = new(this))
608              {
609                  Tracing trace = hc.GetTrace();
610                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName(), "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20");
611                  try
612                  {
613                      Directory.CreateDirectory(directory);
614                      Environment.SetEnvironmentVariable("AGENT_TEST_VALIDATE_EXECUTE_PERMISSIONS_FAILSAFE", "20");
615                      try
616                      {
617                          IOUtil.ValidateExecutePermission(directory);
618                          throw new Exception("Should have thrown not supported exception.");
619                      }
620                      catch (NotSupportedException)
621                      {
622                      }
623                  }
624                  finally
625                  {
626                      if (Directory.Exists(directory))
627                      {
628                          Directory.Delete(directory, recursive: true);
629                      }
630                  }
631              }
632          }
633          [Fact]
634          [Trait("Level", "L0")]
635          [Trait("Category", "Common")]
636          public void LoadObject_ThrowsOnRequiredLoadObject()
637          {
638              using (TestHostContext hc = new(this))
639              {
640                  Tracing trace = hc.GetTrace();
641                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
642                  string file = Path.Combine(directory, "empty file");
643                  Directory.CreateDirectory(directory);
644                  File.WriteAllText(path: file, contents: "");
645                  Assert.Throws<ArgumentNullException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
646                  file = Path.Combine(directory, "invalid type file");
647                  File.WriteAllText(path: file, contents: " ");
648                  Assert.Throws<ArgumentException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
649                  if (Directory.Exists(directory))
650                  {
651                      Directory.Delete(directory, recursive: true);
652                  }
653              }
654          }
655          private static async Task CreateDirectoryReparsePoint(IHostContext context, string link, string target)
656          {
657  #if OS_WINDOWS
658              string fileName = Environment.GetEnvironmentVariable("ComSpec");
659              string arguments = $@"/c ""mklink /J ""{link}"" {target}""""";
660  #else
661              string fileName = "/bin/ln";
662              string arguments = $@"-s ""{target}"" ""{link}""";
663  #endif
664              ArgUtil.File(fileName, nameof(fileName));
665              using (var processInvoker = new ProcessInvokerWrapper())
666              {
667                  processInvoker.Initialize(context);
668                  await processInvoker.ExecuteAsync(
669                      workingDirectory: context.GetDirectory(WellKnownDirectory.Bin),
670                      fileName: fileName,
671                      arguments: arguments,
672                      environment: null,
673                      requireExitCodeZero: true,
674                      cancellationToken: CancellationToken.None);
675              }
676          }
677      }
678  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</h3>
            <pre><code>1  using GitHub.Runner.Sdk;
2  using System;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Xunit;
7  namespace GitHub.Runner.Common.Tests.Util
8  {
9      public sealed class IOUtilL0
10      {
11          [Fact]
12          [Trait("Level", "L0")]
13          [Trait("Category", "Common")]
14          public void Delete_DeletesDirectory()
15          {
16              using (TestHostContext hc = new(this))
17              {
18                  Tracing trace = hc.GetTrace();
19                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
20                  string file = Path.Combine(directory, "some file");
21                  try
22                  {
23                      Directory.CreateDirectory(directory);
24                      File.WriteAllText(path: file, contents: "some contents");
25                      IOUtil.Delete(directory, CancellationToken.None);
26                      Assert.False(Directory.Exists(directory));
27                  }
28                  finally
29                  {
30                      if (Directory.Exists(directory))
31                      {
32                          Directory.Delete(directory, recursive: true);
33                      }
34                  }
35              }
36          }
37          [Fact]
38          [Trait("Level", "L0")]
39          [Trait("Category", "Common")]
40          public void Delete_DeletesFile()
41          {
42              using (TestHostContext hc = new(this))
43              {
44                  Tracing trace = hc.GetTrace();
45                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
46                  string file = Path.Combine(directory, "some file");
47                  try
48                  {
49                      Directory.CreateDirectory(directory);
50                      File.WriteAllText(path: file, contents: "some contents");
51                      IOUtil.Delete(file, CancellationToken.None);
52                      Assert.False(File.Exists(file));
53                  }
54                  finally
55                  {
56                      if (Directory.Exists(directory))
57                      {
58                          Directory.Delete(directory, recursive: true);
59                      }
60                  }
61              }
62          }
63          [Fact]
64          [Trait("Level", "L0")]
65          [Trait("Category", "Common")]
66          public void DeleteDirectory_DeletesDirectoriesRecursively()
67          {
68              using (TestHostContext hc = new(this))
69              {
70                  Tracing trace = hc.GetTrace();
71                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
72                  try
73                  {
74                      Directory.CreateDirectory(Path.Combine(directory, "some child directory", "some grandchild directory"));
75                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
76                      Assert.False(Directory.Exists(directory));
77                  }
78                  finally
79                  {
80                      if (Directory.Exists(directory))
81                      {
82                          Directory.Delete(directory, recursive: true);
83                      }
84                  }
85              }
86          }
87          [Fact]
88          [Trait("Level", "L0")]
89          [Trait("Category", "Common")]
90          public async Task DeleteDirectory_DeletesDirectoryReparsePointChain()
91          {
92              using (TestHostContext hc = new(this))
93              {
94                  Tracing trace = hc.GetTrace();
95                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
96                  try
97                  {
98                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
99                      string file = Path.Combine(targetDir, "file.txt");
100                      File.WriteAllText(path: file, contents: "some contents");
101                      string linkDir1 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir1");
102                      string linkDir2 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir2");
103                      string linkDir3 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir3");
104                      string linkDir4 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir4");
105                      string linkDir5 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir5");
106                      await CreateDirectoryReparsePoint(context: hc, link: linkDir1, target: linkDir2);
107                      await CreateDirectoryReparsePoint(context: hc, link: linkDir2, target: linkDir3);
108                      await CreateDirectoryReparsePoint(context: hc, link: linkDir3, target: linkDir4);
109                      await CreateDirectoryReparsePoint(context: hc, link: linkDir4, target: linkDir5);
110                      await CreateDirectoryReparsePoint(context: hc, link: linkDir5, target: targetDir);
111                      Assert.True(Directory.Exists(linkDir1));
112                      Assert.True(new DirectoryInfo(linkDir1).Attributes.HasFlag(FileAttributes.ReparsePoint));
113                      Assert.True(File.Exists(Path.Combine(linkDir1, "file.txt")));
114                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
115                      Assert.False(Directory.Exists(linkDir1));
116                      Assert.False(Directory.Exists(targetDir));
117                      Assert.False(File.Exists(file));
118                      Assert.False(Directory.Exists(randomDir));
119                  }
120                  finally
121                  {
122                      if (Directory.Exists(randomDir))
123                      {
124                          Directory.Delete(randomDir, recursive: true);
125                      }
126                  }
127              }
128          }
129          [Fact]
130          [Trait("Level", "L0")]
131          [Trait("Category", "Common")]
132          public async Task DeleteDirectory_DeletesDirectoryReparsePointsBeforeDirectories()
133          {
134              using (TestHostContext hc = new(this))
135              {
136                  Tracing trace = hc.GetTrace();
137                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
138                  try
139                  {
140                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
141                      string file = Path.Combine(targetDir, "file.txt");
142                      File.WriteAllText(path: file, contents: "some contents");
143                      string linkDir = Path.Combine(randomDir, "linkDir");
144                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
145                      Assert.True(Directory.Exists(linkDir));
146                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
147                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
148                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
149                      Assert.False(Directory.Exists(linkDir));
150                      Assert.False(Directory.Exists(targetDir));
151                      Assert.False(File.Exists(file));
152                      Assert.False(Directory.Exists(randomDir));
153                  }
154                  finally
155                  {
156                      if (Directory.Exists(randomDir))
157                      {
158                          Directory.Delete(randomDir, recursive: true);
159                      }
160                  }
161              }
162          }
163          [Fact]
164          [Trait("Level", "L0")]
165          [Trait("Category", "Common")]
166          public void DeleteDirectory_DeletesFilesRecursively()
167          {
168              using (TestHostContext hc = new(this))
169              {
170                  Tracing trace = hc.GetTrace();
171                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
172                  try
173                  {
174                      string file = Path.Combine(directory, "some subdirectory", "some file");
175                      Directory.CreateDirectory(Path.GetDirectoryName(file));
176                      File.WriteAllText(path: file, contents: "some contents");
177                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
178                      Assert.False(Directory.Exists(directory));
179                  }
180                  finally
181                  {
182                      if (Directory.Exists(directory))
183                      {
184                          Directory.Delete(directory, recursive: true);
185                      }
186                  }
187              }
188          }
189          [Fact]
190          [Trait("Level", "L0")]
191          [Trait("Category", "Common")]
192          public void DeleteDirectory_DeletesReadOnlyDirectories()
193          {
194              using (TestHostContext hc = new(this))
195              {
196                  Tracing trace = hc.GetTrace();
197                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
198                  string subdirectory = Path.Combine(directory, "some subdirectory");
199                  try
200                  {
201                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
202                      subdirectoryInfo.Create();
203                      subdirectoryInfo.Attributes = subdirectoryInfo.Attributes | FileAttributes.ReadOnly;
204                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
205                      Assert.False(Directory.Exists(directory));
206                  }
207                  finally
208                  {
209                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
210                      if (subdirectoryInfo.Exists)
211                      {
212                          subdirectoryInfo.Attributes = subdirectoryInfo.Attributes & ~FileAttributes.ReadOnly;
213                      }
214                      if (Directory.Exists(directory))
215                      {
216                          Directory.Delete(directory, recursive: true);
217                      }
218                  }
219              }
220          }
221          [Fact]
222          [Trait("Level", "L0")]
223          [Trait("Category", "Common")]
224          public void DeleteDirectory_DeletesReadOnlyRootDirectory()
225          {
226              using (TestHostContext hc = new(this))
227              {
228                  Tracing trace = hc.GetTrace();
229                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
230                  try
231                  {
232                      var directoryInfo = new DirectoryInfo(directory);
233                      directoryInfo.Create();
234                      directoryInfo.Attributes = directoryInfo.Attributes | FileAttributes.ReadOnly;
235                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
236                      Assert.False(Directory.Exists(directory));
237                  }
238                  finally
239                  {
240                      var directoryInfo = new DirectoryInfo(directory);
241                      if (directoryInfo.Exists)
242                      {
243                          directoryInfo.Attributes = directoryInfo.Attributes & ~FileAttributes.ReadOnly;
244                          directoryInfo.Delete();
245                      }
246                  }
247              }
248          }
249          [Fact]
250          [Trait("Level", "L0")]
251          [Trait("Category", "Common")]
252          public void DeleteDirectory_DeletesReadOnlyFiles()
253          {
254              using (TestHostContext hc = new(this))
255              {
256                  Tracing trace = hc.GetTrace();
257                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
258                  string file = Path.Combine(directory, "some file");
259                  try
260                  {
261                      Directory.CreateDirectory(directory);
262                      File.WriteAllText(path: file, contents: "some contents");
263                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
264                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
265                      Assert.False(Directory.Exists(directory));
266                  }
267                  finally
268                  {
269                      if (File.Exists(file))
270                      {
271                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
272                      }
273                      if (Directory.Exists(directory))
274                      {
275                          Directory.Delete(directory, recursive: true);
276                      }
277                  }
278              }
279          }
280          [Fact]
281          [Trait("Level", "L0")]
282          [Trait("Category", "Common")]
283          public async Task DeleteDirectory_DoesNotFollowDirectoryReparsePoint()
284          {
285              using (TestHostContext hc = new(this))
286              {
287                  Tracing trace = hc.GetTrace();
288                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
289                  try
290                  {
291                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
292                      string file = Path.Combine(targetDir, "file.txt");
293                      File.WriteAllText(path: file, contents: "some contents");
294                      string linkDir = Path.Combine(randomDir, "linkDir");
295                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
296                      Assert.True(Directory.Exists(linkDir));
297                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
298                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
299                      IOUtil.DeleteDirectory(linkDir, CancellationToken.None);
300                      Assert.False(Directory.Exists(linkDir));
301                      Assert.True(Directory.Exists(targetDir));
302                      Assert.True(File.Exists(file));
303                  }
304                  finally
305                  {
306                      if (Directory.Exists(randomDir))
307                      {
308                          Directory.Delete(randomDir, recursive: true);
309                      }
310                  }
311              }
312          }
313          [Fact]
314          [Trait("Level", "L0")]
315          [Trait("Category", "Common")]
316          public async Task DeleteDirectory_DoesNotFollowNestLevel1DirectoryReparsePoint()
317          {
318              using (TestHostContext hc = new(this))
319              {
320                  Tracing trace = hc.GetTrace();
321                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
322                  try
323                  {
324                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
325                      string file = Path.Combine(targetDir, "file.txt");
326                      File.WriteAllText(path: file, contents: "some contents");
327                      string subDir = Directory.CreateDirectory(Path.Combine(randomDir, "subDir")).FullName;
328                      string linkDir = Path.Combine(subDir, "linkDir");
329                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
330                      Assert.True(Directory.Exists(linkDir));
331                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
332                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
333                      IOUtil.DeleteDirectory(subDir, CancellationToken.None);
334                      Assert.False(Directory.Exists(subDir));
335                      Assert.True(Directory.Exists(targetDir));
336                      Assert.True(File.Exists(file));
337                  }
338                  finally
339                  {
340                      if (Directory.Exists(randomDir))
341                      {
342                          Directory.Delete(randomDir, recursive: true);
343                      }
344                  }
345              }
346          }
347          [Fact]
348          [Trait("Level", "L0")]
349          [Trait("Category", "Common")]
350          public async Task DeleteDirectory_DoesNotFollowNestLevel2DirectoryReparsePoint()
351          {
352              using (TestHostContext hc = new(this))
353              {
354                  Tracing trace = hc.GetTrace();
355                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
356                  try
357                  {
358                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
359                      string file = Path.Combine(targetDir, "file.txt");
360                      File.WriteAllText(path: file, contents: "some contents");
361                      string subDir1 = Directory.CreateDirectory(Path.Combine(randomDir, "subDir1")).FullName;
362                      string subDir2 = Directory.CreateDirectory(Path.Combine(subDir1, "subDir2")).FullName;
363                      string linkDir = Path.Combine(subDir2, "linkDir");
364                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
365                      Assert.True(Directory.Exists(linkDir));
366                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
367                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
368                      IOUtil.DeleteDirectory(subDir1, CancellationToken.None);
369                      Assert.False(Directory.Exists(subDir1));
370                      Assert.True(Directory.Exists(targetDir));
371                      Assert.True(File.Exists(file));
372                  }
373                  finally
374                  {
375                      if (Directory.Exists(randomDir))
376                      {
377                          Directory.Delete(randomDir, recursive: true);
378                      }
379                  }
380              }
381          }
382          [Fact]
383          [Trait("Level", "L0")]
384          [Trait("Category", "Common")]
385          public void DeleteDirectory_IgnoresFile()
386          {
387              using (TestHostContext hc = new(this))
388              {
389                  Tracing trace = hc.GetTrace();
390                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
391                  string file = Path.Combine(directory, "some file");
392                  try
393                  {
394                      Directory.CreateDirectory(directory);
395                      File.WriteAllText(path: file, contents: "some contents");
396                      IOUtil.DeleteDirectory(file, CancellationToken.None);
397                      Assert.True(File.Exists(file));
398                  }
399                  finally
400                  {
401                      if (Directory.Exists(directory))
402                      {
403                          Directory.Delete(directory, recursive: true);
404                      }
405                  }
406              }
407          }
408          [Fact]
409          [Trait("Level", "L0")]
410          [Trait("Category", "Common")]
411          public void DeleteFile_DeletesFile()
412          {
413              using (TestHostContext hc = new(this))
414              {
415                  Tracing trace = hc.GetTrace();
416                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
417                  string file = Path.Combine(directory, "some file");
418                  try
419                  {
420                      Directory.CreateDirectory(directory);
421                      File.WriteAllText(path: file, contents: "some contents");
422                      IOUtil.DeleteFile(file);
423                      Assert.False(File.Exists(file));
424                  }
425                  finally
426                  {
427                      if (Directory.Exists(directory))
428                      {
429                          Directory.Delete(directory, recursive: true);
430                      }
431                  }
432              }
433          }
434          [Fact]
435          [Trait("Level", "L0")]
436          [Trait("Category", "Common")]
437          public void DeleteFile_DeletesReadOnlyFile()
438          {
439              using (TestHostContext hc = new(this))
440              {
441                  Tracing trace = hc.GetTrace();
442                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
443                  string file = Path.Combine(directory, "some file");
444                  try
445                  {
446                      Directory.CreateDirectory(directory);
447                      File.WriteAllText(path: file, contents: "some contents");
448                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
449                      IOUtil.DeleteFile(file);
450                      Assert.False(File.Exists(file));
451                  }
452                  finally
453                  {
454                      if (File.Exists(file))
455                      {
456                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
457                      }
458                      if (Directory.Exists(directory))
459                      {
460                          Directory.Delete(directory, recursive: true);
461                      }
462                  }
463              }
464          }
465          [Fact]
466          [Trait("Level", "L0")]
467          [Trait("Category", "Common")]
468          public void DeleteFile_IgnoresDirectory()
469          {
470              using (TestHostContext hc = new(this))
471              {
472                  Tracing trace = hc.GetTrace();
473                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
474                  try
475                  {
476                      Directory.CreateDirectory(directory);
477                      IOUtil.DeleteFile(directory);
478                      Assert.True(Directory.Exists(directory));
479                  }
480                  finally
481                  {
482                      if (Directory.Exists(directory))
483                      {
484                          Directory.Delete(directory, recursive: true);
485                      }
486                  }
487              }
488          }
489          [Fact]
490          [Trait("Level", "L0")]
491          [Trait("Category", "Common")]
492          public void GetRelativePath()
493          {
494              using (TestHostContext hc = new(this))
495              {
496                  Tracing trace = hc.GetTrace();
497                  string relativePath;
498  #if OS_WINDOWS
499                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src");
500                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
501                  relativePath = IOUtil.MakeRelative(@"d:\", @"d:\specs");
502                  Assert.True(string.Equals(relativePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
503                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src\proj");
504                  Assert.True(string.Equals(relativePath, @"d:\src\project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
505                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo", @"d:\src");
506                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
507                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:\src\project");
508                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
509                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
510                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
511                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
512                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
513                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo", @"d:/src");
514                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
515                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:/src/project");
516                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
517  #else
518                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src");
519                  Assert.True(string.Equals(relativePath, @"project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
520                  relativePath = IOUtil.MakeRelative(@"/user", @"/user/specs");
521                  Assert.True(string.Equals(relativePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
522                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src/proj");
523                  Assert.True(string.Equals(relativePath, @"/user/src/project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
524                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo", @"/user/src");
525                  Assert.True(string.Equals(relativePath, @"project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
526                  relativePath = IOUtil.MakeRelative(@"/user/src/project", @"/user/src/project");
527                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
528  #endif
529              }
530          }
531          [Fact]
532          [Trait("Level", "L0")]
533          [Trait("Category", "Common")]
534          public void ResolvePath()
535          {
536              using (TestHostContext hc = new(this))
537              {
538                  Tracing trace = hc.GetTrace();
539                  string resolvePath;
540  #if OS_WINDOWS
541                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"foo");
542                  Assert.True(string.Equals(resolvePath, @"d:\src\project\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
543                  resolvePath = IOUtil.ResolvePath(@"d:\", @"specs");
544                  Assert.True(string.Equals(resolvePath, @"d:\specs", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
545                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"src\proj");
546                  Assert.True(string.Equals(resolvePath, @"d:\src\project\src\proj", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
547                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\foo", @"..");
548                  Assert.True(string.Equals(resolvePath, @"d:\src\project", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
549                  resolvePath = IOUtil.ResolvePath(@"d:\src\project", @"..\..\");
550                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
551                  resolvePath = IOUtil.ResolvePath(@"d:/src/project", @"../.");
552                  Assert.True(string.Equals(resolvePath, @"d:\src", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
553                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/", @"../../foo");
554                  Assert.True(string.Equals(resolvePath, @"d:\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
555                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/foo", @".././bar/.././../foo");
556                  Assert.True(string.Equals(resolvePath, @"d:\src\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
557                  resolvePath = IOUtil.ResolvePath(@"d:\", @".");
558                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
559  #else
560                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"foo");
561                  Assert.True(string.Equals(resolvePath, @"/user/src/project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
562                  resolvePath = IOUtil.ResolvePath(@"/root", @"./user/./specs");
563                  Assert.True(string.Equals(resolvePath, @"/root/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
564                  resolvePath = IOUtil.ResolvePath(@"/", @"user/specs/.");
565                  Assert.True(string.Equals(resolvePath, @"/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
566                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../");
<span onclick='openModal()' class='match'>567                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
568                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../../");
</span>569                  Assert.True(string.Equals(resolvePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
570                  resolvePath = IOUtil.ResolvePath(@"/user/src/project/foo", @"../../../../user/./src");
571                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
572                  resolvePath = IOUtil.ResolvePath(@"/user/src", @"../../.");
573                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
574                  resolvePath = IOUtil.ResolvePath(@"/", @"./");
575                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
576  #endif
577              }
578          }
579          [Fact]
580          [Trait("Level", "L0")]
581          [Trait("Category", "Common")]
582          public void ValidateExecutePermission_DoesNotExceedFailsafe()
583          {
584              using (TestHostContext hc = new(this))
585              {
586                  Tracing trace = hc.GetTrace();
587                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
588                  try
589                  {
590                      Directory.CreateDirectory(directory);
591                      IOUtil.ValidateExecutePermission(directory);
592                  }
593                  finally
594                  {
595                      if (Directory.Exists(directory))
596                      {
597                          Directory.Delete(directory, recursive: true);
598                      }
599                  }
600              }
601          }
602          [Fact]
603          [Trait("Level", "L0")]
604          [Trait("Category", "Common")]
605          public void ValidateExecutePermission_ExceedsFailsafe()
606          {
607              using (TestHostContext hc = new(this))
608              {
609                  Tracing trace = hc.GetTrace();
610                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName(), "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20");
611                  try
612                  {
613                      Directory.CreateDirectory(directory);
614                      Environment.SetEnvironmentVariable("AGENT_TEST_VALIDATE_EXECUTE_PERMISSIONS_FAILSAFE", "20");
615                      try
616                      {
617                          IOUtil.ValidateExecutePermission(directory);
618                          throw new Exception("Should have thrown not supported exception.");
619                      }
620                      catch (NotSupportedException)
621                      {
622                      }
623                  }
624                  finally
625                  {
626                      if (Directory.Exists(directory))
627                      {
628                          Directory.Delete(directory, recursive: true);
629                      }
630                  }
631              }
632          }
633          [Fact]
634          [Trait("Level", "L0")]
635          [Trait("Category", "Common")]
636          public void LoadObject_ThrowsOnRequiredLoadObject()
637          {
638              using (TestHostContext hc = new(this))
639              {
640                  Tracing trace = hc.GetTrace();
641                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
642                  string file = Path.Combine(directory, "empty file");
643                  Directory.CreateDirectory(directory);
644                  File.WriteAllText(path: file, contents: "");
645                  Assert.Throws<ArgumentNullException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
646                  file = Path.Combine(directory, "invalid type file");
647                  File.WriteAllText(path: file, contents: " ");
648                  Assert.Throws<ArgumentException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
649                  if (Directory.Exists(directory))
650                  {
651                      Directory.Delete(directory, recursive: true);
652                  }
653              }
654          }
655          private static async Task CreateDirectoryReparsePoint(IHostContext context, string link, string target)
656          {
657  #if OS_WINDOWS
658              string fileName = Environment.GetEnvironmentVariable("ComSpec");
659              string arguments = $@"/c ""mklink /J ""{link}"" {target}""""";
660  #else
661              string fileName = "/bin/ln";
662              string arguments = $@"-s ""{target}"" ""{link}""";
663  #endif
664              ArgUtil.File(fileName, nameof(fileName));
665              using (var processInvoker = new ProcessInvokerWrapper())
666              {
667                  processInvoker.Initialize(context);
668                  await processInvoker.ExecuteAsync(
669                      workingDirectory: context.GetDirectory(WellKnownDirectory.Bin),
670                      fileName: fileName,
671                      arguments: arguments,
672                      environment: null,
673                      requireExitCodeZero: true,
674                      cancellationToken: CancellationToken.None);
675              }
676          }
677      }
678  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</div>
                </div>
                <div class="column column_space"><pre><code>567                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
568                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../../");
</pre></code></div>
                <div class="column column_space"><pre><code>567                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
568                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../../");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    