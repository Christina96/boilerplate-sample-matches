
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.047619047619047%, Tokens: 14</h2>
        <div class="column">
            <h3>EarTrumpet-MDEwOlJlcG9zaXRvcnkzODkxOTcwMg==-flat-EarTrumpetActionsAddon.cs</h3>
            <pre><code>1  using EarTrumpet.Actions.DataModel;
2  using EarTrumpet.Actions.DataModel.Processing;
3  using EarTrumpet.Actions.DataModel.Serialization;
4  using EarTrumpet.Actions.ViewModel;
5  using EarTrumpet.DataModel.Storage;
6  using EarTrumpet.Extensibility;
7  using EarTrumpet.UI.Helpers;
8  using EarTrumpet.UI.ViewModels;
9  using System;
10  using System.Collections.Generic;
11  using System.ComponentModel.Composition;
12  using System.IO;
13  using System.Linq;
14  namespace EarTrumpet.Actions
15  {
16      [Export(typeof(EarTrumpetAddon))]
17      public class EarTrumpetActionsAddon : EarTrumpetAddon, IEarTrumpetAddonEvents, IEarTrumpetAddonSettingsPage, IEarTrumpetAddonNotificationAreaContextMenu
18      {
<span onclick='openModal()' class='match'>19          public static EarTrumpetActionsAddon Current { get; private set; }
20          public LocalVariablesContainer LocalVariables { get; private set; }
</span>21          public EarTrumpetActionsAddon() : base()
22          {
23              DisplayName = Properties.Resources.MyActionsText;
24          }
25          public EarTrumpetAction[] Actions
26          {
27              get => _actions;
28              set
29              {
30                  Settings.Set(c_actionsSettingKey, value);
31                  LoadAndRegister();
32              }
33          }
34          private readonly string c_actionsSettingKey = "ActionsData";
35          private EarTrumpetAction[] _actions = new EarTrumpetAction[] { };
36          private TriggerManager _triggerManager = new TriggerManager();
37          public void OnAddonEvent(AddonEventKind evt)
38          {
39              if (evt == AddonEventKind.AddonsInitialized)
40              {
41                  Current = this;
42                  LocalVariables = new LocalVariablesContainer(Settings);
43                  _triggerManager.Triggered += OnTriggered;
44                  LoadAndRegister();
45                  _triggerManager.OnEvent(AddonEventKind.InitializeAddon);
46              }
47              else if (evt == AddonEventKind.AppShuttingDown)
48              {
49                  _triggerManager.OnEvent(AddonEventKind.AppShuttingDown);
50              }
51          }
52          public SettingsCategoryViewModel GetSettingsCategory()
53          {
54              LoadAddonResources();
55              return new ActionsCategoryViewModel();
56          }
57          public IEnumerable<ContextMenuItem> NotificationAreaContextMenuItems
58          {
59              get
60              {
61                  var ret = new List<ContextMenuItem>();
62                  if (EarTrumpetActionsAddon.Current == null)
63                  {
64                      return ret;
65                  }
66                  foreach (var item in EarTrumpetActionsAddon.Current.Actions.Where(a => a.Triggers.FirstOrDefault(ax => ax is ContextMenuTrigger) != null))
67                  {
68                      ret.Add(new ContextMenuItem
69                      {
70                          Glyph = "\xE1CE",
71                          IsChecked = true,
72                          DisplayName = item.DisplayName,
73                          Command = new RelayCommand(() => EarTrumpetActionsAddon.Current.TriggerAction(item))
74                      });
75                  }
76                  return ret;
77              }
78          }
79          private void LoadAndRegister()
80          {
81              _triggerManager.Clear();
82              _actions = Settings.Get(c_actionsSettingKey, new EarTrumpetAction[] { });
83              _actions.SelectMany(a => a.Triggers).ToList().ForEach(t => _triggerManager.Register(t));
84          }
85          public void Import(string fileName)
86          {
87              var imported = Serializer.FromString<EarTrumpetAction[]>(File.ReadAllText(fileName)).ToList();
88              foreach(var imp in imported)
89              {
90                  imp.Id = Guid.NewGuid();
91              }
92              imported.AddRange(Actions);
93              Actions = imported.ToArray();
94          }
95          public string Export()
96          {
97              return Settings.Get(c_actionsSettingKey, "");
98          }
99          private void OnTriggered(BaseTrigger trigger)
100          {
101              var action = Actions.FirstOrDefault(a => a.Triggers.Contains(trigger));
102              if (action != null && action.Conditions.All(c => ConditionProcessor.IsMet(c)))
103              {
104                  TriggerAction(action);
105              }
106          }
107          public void TriggerAction(EarTrumpetAction action)
108          {
109              action.Actions.ToList().ForEach(a => ActionProcessor.Invoke(a));
110          }
111      }
112  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnector.cs</h3>
            <pre><code>1  using System;
2  using System.Buffers;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics;
6  using System.IO;
7  using System.Linq;
8  using System.Net;
9  using System.Net.Security;
10  using System.Net.Sockets;
11  using System.Runtime.CompilerServices;
12  using System.Runtime.InteropServices;
13  using System.Runtime.ExceptionServices;
14  using System.Security.Authentication;
15  using System.Security.Cryptography.X509Certificates;
16  using System.Text;
17  using System.Threading;
18  using System.Threading.Channels;
19  using System.Threading.Tasks;
20  using Npgsql.BackendMessages;
21  using Npgsql.TypeMapping;
22  using Npgsql.Util;
23  using static Npgsql.Util.Statics;
24  using System.Transactions;
25  using Microsoft.Extensions.Logging;
26  using Npgsql.Internal.TypeMapping;
27  using Npgsql.Properties;
28  namespace Npgsql.Internal;
29  public sealed partial class NpgsqlConnector
30  {
31      #region Fields and Properties
32      Socket _socket = default!;
33      NetworkStream _baseStream = default!;
34      Stream _stream = default!;
35      public NpgsqlConnectionStringBuilder Settings { get; }
36      Action<X509CertificateCollection>? ClientCertificatesCallback { get; }
37      RemoteCertificateValidationCallback? UserCertificateValidationCallback { get; }
38  #pragma warning disable CS0618 
39      ProvidePasswordCallback? ProvidePasswordCallback { get; }
40  #pragma warning restore CS0618
<span onclick='openModal()' class='match'>41      public Encoding TextEncoding { get; private set; } = default!;
42      internal Encoding RelaxedTextEncoding { get; private set; } = default!;
</span>43      internal NpgsqlReadBuffer ReadBuffer { get; private set; } = default!;
44      NpgsqlReadBuffer? _origReadBuffer;
45      internal NpgsqlWriteBuffer WriteBuffer { get; private set; } = default!;
46      int _backendSecretKey;
47      internal int BackendProcessId { get; private set; }
48      string? _inferredUserName;
49      internal string InferredUserName
50      {
51          get => _inferredUserName ?? throw new InvalidOperationException($"{nameof(InferredUserName)} cannot be accessed before the connector has been opened.");
52          private set => _inferredUserName = value;
53      }
54      bool SupportsPostgresCancellation => BackendProcessId != 0;
55      internal int Id => BackendProcessId;
56      public NpgsqlDatabaseInfo DatabaseInfo { get; internal set; } = default!;
57      internal TypeMapper TypeMapper { get; set; } = default!;
58      internal TransactionStatus TransactionStatus { get; set; }
59      internal NpgsqlTransaction? Transaction { get; set; }
60      internal NpgsqlTransaction? UnboundTransaction { get; set; }
61      internal NpgsqlConnection? Connection { get; set; }
62      internal int PendingPrependedResponses { get; set; }
63      readonly ManualResetEventSlim ReadingPrependedMessagesMRE = new(initialState: true);
64      internal NpgsqlDataReader? CurrentReader;
65      internal PreparedStatementManager PreparedStatementManager { get; }
66      internal SqlQueryParser SqlQueryParser { get; } = new();
67      internal ICancelable? CurrentCopyOperation;
68      internal Dictionary<string, string> PostgresParameters { get; }
69      readonly List<(byte[] Name, byte[] Value)> _rawParameters = new();
70      volatile Exception? _breakReason;
71      internal volatile int MultiplexAsyncWritingLock;
72      internal void FlagAsNotWritableForMultiplexing()
73      {
74          Debug.Assert(Settings.Multiplexing);
75          Debug.Assert(CommandsInFlightCount > 0 || IsBroken || IsClosed,
76              $"About to mark multiplexing connector as non-writable, but {nameof(CommandsInFlightCount)} is {CommandsInFlightCount}");
77          Interlocked.Exchange(ref MultiplexAsyncWritingLock, 1);
78      }
79      internal void FlagAsWritableForMultiplexing()
80      {
81          Debug.Assert(Settings.Multiplexing);
82          if (Interlocked.CompareExchange(ref MultiplexAsyncWritingLock, 0, 1) != 1)
83              throw new Exception("Multiplexing lock was not taken when releasing. Please report a bug.");
84      }
85      internal int UserTimeout { private get; set; }
86      object CancelLock { get; } = new();
87      object SyncObj { get; } = new();
88      object CleanupLock { get; } = new();
89      readonly bool _isKeepAliveEnabled;
90      readonly Timer? _keepAliveTimer;
91      NpgsqlCommand? _currentCommand;
92      bool _sendResetOnClose;
93      internal NpgsqlDataSource DataSource { get; }
94      internal string UserFacingConnectionString => DataSource.ConnectionString;
95      internal DateTime OpenTimestamp { get; private set; }
96      internal int ClearCounter { get; set; }
97      volatile bool _postgresCancellationPerformed;
98      internal bool PostgresCancellationPerformed
99      {
100          get => _postgresCancellationPerformed;
101          private set => _postgresCancellationPerformed = value;
102      }
103      volatile bool _userCancellationRequested;
104      CancellationTokenRegistration _cancellationTokenRegistration;
105      internal bool UserCancellationRequested => _userCancellationRequested;
106      internal CancellationToken UserCancellationToken { get; set; }
107      internal bool AttemptPostgresCancellation { get; private set; }
108      static readonly TimeSpan _cancelImmediatelyTimeout = TimeSpan.FromMilliseconds(-1);
109      IDisposable? _certificate;
110      internal NpgsqlLoggingConfiguration LoggingConfiguration { get; }
111      internal ILogger ConnectionLogger { get; }
112      internal ILogger CommandLogger { get; }
113      internal ILogger TransactionLogger { get; }
114      internal ILogger CopyLogger { get; }
115      internal readonly Stopwatch QueryLogStopWatch = new();
116      internal EndPoint? ConnectedEndPoint { get; private set; }
117      #endregion
118      #region Constants
119      internal const int MinimumInternalCommandTimeout = 3;
120      #endregion
121      #region Reusable Message Objects
122      byte[]? _resetWithoutDeallocateMessage;
123      int _resetWithoutDeallocateResponseCount;
124      readonly CommandCompleteMessage      _commandCompleteMessage      = new();
125      readonly ReadyForQueryMessage        _readyForQueryMessage        = new();
126      readonly ParameterDescriptionMessage _parameterDescriptionMessage = new();
127      readonly DataRowMessage              _dataRowMessage              = new();
128      readonly RowDescriptionMessage       _rowDescriptionMessage       = new();
129      CopyInResponseMessage?  _copyInResponseMessage;
130      CopyOutResponseMessage? _copyOutResponseMessage;
131      CopyDataMessage?        _copyDataMessage;
132      CopyBothResponseMessage? _copyBothResponseMessage;
133      #endregion
134      internal NpgsqlDataReader DataReader { get; set; }
135      internal NpgsqlDataReader? UnboundDataReader { get; set; }
136      #region Constructors
137      internal NpgsqlConnector(NpgsqlDataSource dataSource, NpgsqlConnection conn)
138          : this(dataSource)
139      {
140          if (conn.ProvideClientCertificatesCallback is not null)
141              ClientCertificatesCallback = certs => conn.ProvideClientCertificatesCallback(certs);
142          if (conn.UserCertificateValidationCallback is not null)
143              UserCertificateValidationCallback = conn.UserCertificateValidationCallback;
144  #pragma warning disable CS0618 
145          ProvidePasswordCallback = conn.ProvidePasswordCallback;
146  #pragma warning restore CS0618
147      }
148      NpgsqlConnector(NpgsqlConnector connector)
149          : this(connector.DataSource)
150      {
151          ClientCertificatesCallback = connector.ClientCertificatesCallback;
152          UserCertificateValidationCallback = connector.UserCertificateValidationCallback;
153          ProvidePasswordCallback = connector.ProvidePasswordCallback;
154      }
155      NpgsqlConnector(NpgsqlDataSource dataSource)
156      {
157          Debug.Assert(dataSource.OwnsConnectors);
158          DataSource = dataSource;
159          LoggingConfiguration = dataSource.LoggingConfiguration;
160          ConnectionLogger = LoggingConfiguration.ConnectionLogger;
161          CommandLogger = LoggingConfiguration.CommandLogger;
162          TransactionLogger = LoggingConfiguration.TransactionLogger;
163          CopyLogger = LoggingConfiguration.CopyLogger;
164          ClientCertificatesCallback = dataSource.ClientCertificatesCallback;
165          UserCertificateValidationCallback = dataSource.UserCertificateValidationCallback;
166          State = ConnectorState.Closed;
167          TransactionStatus = TransactionStatus.Idle;
168          Settings = dataSource.Settings;
169          PostgresParameters = new Dictionary<string, string>();
170          _isKeepAliveEnabled = Settings.KeepAlive > 0;
171          if (_isKeepAliveEnabled)
172              _keepAliveTimer = new Timer(PerformKeepAlive, null, Timeout.Infinite, Timeout.Infinite);
173          DataReader = new NpgsqlDataReader(this);
174          PreparedStatementManager = new PreparedStatementManager(this);
175          if (Settings.Multiplexing)
176          {
177              var commandsInFlightChannel = Channel.CreateUnbounded<NpgsqlCommand>(
178                  new UnboundedChannelOptions { SingleReader = true });
179              CommandsInFlightReader = commandsInFlightChannel.Reader;
180              CommandsInFlightWriter = commandsInFlightChannel.Writer;
181              if (_isKeepAliveEnabled)
182                  throw new NotImplementedException("Keepalive not yet implemented for multiplexing");
183          }
184      }
185      #endregion
186      #region Configuration settings
187      internal string Host => Settings.Host!;
188      internal int Port => Settings.Port;
189      internal string Database => Settings.Database!;
190      string KerberosServiceName => Settings.KerberosServiceName;
191      int ConnectionTimeout => Settings.Timeout;
192      int InternalCommandTimeout
193      {
194          get
195          {
196              var internalTimeout = Settings.InternalCommandTimeout;
197              if (internalTimeout == -1)
198                  return Math.Max(Settings.CommandTimeout, MinimumInternalCommandTimeout) * 1000;
199              Debug.Assert(internalTimeout == 0 || internalTimeout >= MinimumInternalCommandTimeout);
200              return internalTimeout * 1000;
201          }
202      }
203      #endregion Configuration settings
204      #region State management
205      int _state;
206      internal ConnectorState State
207      {
208          get => (ConnectorState)_state;
209          set
210          {
211              var newState = (int)value;
212              if (newState == _state)
213                  return;
214              Interlocked.Exchange(ref _state, newState);
215          }
216      }
217      bool IsConnected
218          => State switch
219          {
220              ConnectorState.Ready       => true,
221              ConnectorState.Executing   => true,
222              ConnectorState.Fetching    => true,
223              ConnectorState.Waiting     => true,
224              ConnectorState.Copy        => true,
225              ConnectorState.Replication => true,
226              ConnectorState.Closed      => false,
227              ConnectorState.Connecting  => false,
228              ConnectorState.Broken      => false,
229              _                          => throw new ArgumentOutOfRangeException("Unknown state: " + State)
230          };
231      internal bool IsReady => State == ConnectorState.Ready;
232      internal bool IsClosed => State == ConnectorState.Closed;
233      internal bool IsBroken => State == ConnectorState.Broken;
234      #endregion
235      #region Open
236      internal async Task Open(NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken)
237      {
238          Debug.Assert(State == ConnectorState.Closed);
239          State = ConnectorState.Connecting;
240          LogMessages.OpeningPhysicalConnection(ConnectionLogger, Host, Port, Database, UserFacingConnectionString);
241          var stopwatch = Stopwatch.StartNew();
242          try
243          {
244              await OpenCore(this, Settings.SslMode, timeout, async, cancellationToken);
245              await DataSource.Bootstrap(this, timeout, forceReload: false, async, cancellationToken);
246              Debug.Assert(DataSource.TypeMapper is not null);
247              Debug.Assert(DataSource.DatabaseInfo is not null);
248              TypeMapper = DataSource.TypeMapper;
249              DatabaseInfo = DataSource.DatabaseInfo;
250              if (Settings.Pooling && !Settings.Multiplexing && !Settings.NoResetOnClose && DatabaseInfo.SupportsDiscard)
251              {
252                  _sendResetOnClose = true;
253                  GenerateResetMessage();
254              }
255              OpenTimestamp = DateTime.UtcNow;
256              if (Settings.Multiplexing)
257              {
258                  _ = Task.Run(MultiplexingReadLoop, CancellationToken.None)
259                      .ContinueWith(t =>
260                      {
261                          ConnectionLogger.LogError(t.Exception!, "Exception bubbled out of multiplexing read loop", Id);
262                      }, TaskContinuationOptions.OnlyOnFaulted);
263              }
264              if (_isKeepAliveEnabled)
265              {
266                  lock (SyncObj)
267                  {
268                      var keepAlive = Settings.KeepAlive * 1000;
269                      _keepAliveTimer!.Change(keepAlive, keepAlive);
270                  }
271              }
272              if (DataSource.ConnectionInitializerAsync is not null)
273              {
274                  Debug.Assert(DataSource.ConnectionInitializer is not null);
275                  var tempConnection = new NpgsqlConnection(DataSource, this);
276                  try
277                  {
278                      if (async)
279                          await DataSource.ConnectionInitializerAsync(tempConnection);
280                      else if (!async)
281                          DataSource.ConnectionInitializer(tempConnection);
282                  }
283                  finally
284                  {
285                      Connection?.MakeDisposed();
286                      Connection = null;
287                  }
288              }
289              LogMessages.OpenedPhysicalConnection(
290                  ConnectionLogger, Host, Port, Database, UserFacingConnectionString, stopwatch.ElapsedMilliseconds, Id);
291          }
292          catch (Exception e)
293          {
294              Break(e);
295              throw;
296          }
297          static async Task OpenCore(
298              NpgsqlConnector conn,
299              SslMode sslMode,
300              NpgsqlTimeout timeout,
301              bool async,
302              CancellationToken cancellationToken,
303              bool isFirstAttempt = true)
304          {
305              await conn.RawOpen(sslMode, timeout, async, cancellationToken, isFirstAttempt);
306              var username = await conn.GetUsernameAsync(async, cancellationToken);
307              timeout.CheckAndApply(conn);
308              conn.WriteStartupMessage(username);
309              await conn.Flush(async, cancellationToken);
310              var cancellationRegistration = conn.StartCancellableOperation(cancellationToken, attemptPgCancellation: false);
311              try
312              {
313                  await conn.Authenticate(username, timeout, async, cancellationToken);
314              }
315              catch (PostgresException e)
316                  when (e.SqlState == PostgresErrorCodes.InvalidAuthorizationSpecification &&
317                        (sslMode == SslMode.Prefer && conn.IsSecure || sslMode == SslMode.Allow && !conn.IsSecure))
318              {
319                  cancellationRegistration.Dispose();
320                  Debug.Assert(!conn.IsBroken);
321                  conn.Cleanup();
322                  await OpenCore(
323                      conn,
324                      sslMode == SslMode.Prefer ? SslMode.Disable : SslMode.Require,
325                      timeout,
326                      async,
327                      cancellationToken,
328                      isFirstAttempt: false);
329                  return;
330              }
331              using var _ = cancellationRegistration;
332              var msg = await conn.ReadMessage(async);
333              if (msg.Code == BackendMessageCode.BackendKeyData)
334              {
335                  var keyDataMsg = (BackendKeyDataMessage)msg;
336                  conn.BackendProcessId = keyDataMsg.BackendProcessId;
337                  conn._backendSecretKey = keyDataMsg.BackendSecretKey;
338                  msg = await conn.ReadMessage(async);
339              }
340              if (msg.Code != BackendMessageCode.ReadyForQuery)
341                  throw new NpgsqlException($"Received backend message {msg.Code} while expecting ReadyForQuery. Please file a bug.");
342              conn.State = ConnectorState.Ready;
343          }
344      }
345      internal async ValueTask<DatabaseState> QueryDatabaseState(
346          NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken = default)
347      {
348          using var batch = CreateBatch();
349          batch.BatchCommands.Add(new NpgsqlBatchCommand("select pg_is_in_recovery()"));
350          batch.BatchCommands.Add(new NpgsqlBatchCommand("SHOW default_transaction_read_only"));
351          batch.Timeout = (int)timeout.CheckAndGetTimeLeft().TotalSeconds;
352          var reader = async ? await batch.ExecuteReaderAsync(cancellationToken) : batch.ExecuteReader();
353          try
354          {
355              if (async)
356              {
357                  await reader.ReadAsync(cancellationToken);
358                  _isHotStandBy = reader.GetBoolean(0);
359                  await reader.NextResultAsync(cancellationToken);
360                  await reader.ReadAsync(cancellationToken);
361              }
362              else
363              {
364                  reader.Read();
365                  _isHotStandBy = reader.GetBoolean(0);
366                  reader.NextResult();
367                  reader.Read();
368              }
369              _isTransactionReadOnly = reader.GetString(0) != "off";
370              var databaseState = UpdateDatabaseState();
371              Debug.Assert(databaseState.HasValue);
372              return databaseState.Value;
373          }
374          finally
375          {
376              if (async)
377                  await reader.DisposeAsync();
378              else
379                  reader.Dispose();
380          }
381      }
382      void WriteStartupMessage(string username)
383      {
384          var startupParams = new Dictionary<string, string>
385          {
386              ["user"] = username,
387              ["client_encoding"] = Settings.ClientEncoding ??
388                                    PostgresEnvironment.ClientEncoding ??
389                                    "UTF8"
390          };
391          if (Settings.Database is not null)
392              startupParams["database"] = Settings.Database;
393          if (Settings.ApplicationName?.Length > 0)
394              startupParams["application_name"] = Settings.ApplicationName;
395          if (Settings.SearchPath?.Length > 0)
396              startupParams["search_path"] = Settings.SearchPath;
397          var timezone = Settings.Timezone ?? PostgresEnvironment.TimeZone;
398          if (timezone != null)
399              startupParams["TimeZone"] = timezone;
400          var options = Settings.Options ?? PostgresEnvironment.Options;
401          if (options?.Length > 0)
402              startupParams["options"] = options;
403          switch (Settings.ReplicationMode)
404          {
405          case ReplicationMode.Logical:
406              startupParams["replication"] = "database";
407              break;
408          case ReplicationMode.Physical:
409              startupParams["replication"] = "true";
410              break;
411          }
412          WriteStartup(startupParams);
413      }
414      ValueTask<string> GetUsernameAsync(bool async, CancellationToken cancellationToken)
415      {
416          var username = Settings.Username;
417          if (username?.Length > 0)
418          {
419              InferredUserName = username;
420              return new(username);
421          }
422          username = PostgresEnvironment.User;
423          if (username?.Length > 0)
424          {
425              InferredUserName = username;
426              return new(username);
427          }
428          return GetUsernameAsyncInternal();
429          async ValueTask<string> GetUsernameAsyncInternal()
430          {
431              if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
432              {
433                  username = await KerberosUsernameProvider.GetUsernameAsync(Settings.IncludeRealm, ConnectionLogger, async,
434                      cancellationToken);
435                  if (username?.Length > 0)
436                  {
437                      InferredUserName = username;
438                      return username;
439                  }
440              }
441              username = Environment.UserName;
442              if (username?.Length > 0)
443              {
444                  InferredUserName = username;
445                  return username;
446              }
447              throw new NpgsqlException("No username could be found, please specify one explicitly");
448          }
449      }
450      async Task RawOpen(SslMode sslMode, NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken, bool isFirstAttempt = true)
451      {
452          try
453          {
454              if (async)
455                  await ConnectAsync(timeout, cancellationToken);
456              else
457                  Connect(timeout);
458              _baseStream = new NetworkStream(_socket, true);
459              _stream = _baseStream;
460              if (Settings.Encoding == "UTF8")
461              {
462                  TextEncoding = PGUtil.UTF8Encoding;
463                  RelaxedTextEncoding = PGUtil.RelaxedUTF8Encoding;
464              }
465              else
466              {
467                  TextEncoding = Encoding.GetEncoding(Settings.Encoding, EncoderFallback.ExceptionFallback, DecoderFallback.ExceptionFallback);
468                  RelaxedTextEncoding = Encoding.GetEncoding(Settings.Encoding, EncoderFallback.ReplacementFallback, DecoderFallback.ReplacementFallback);
469              }
470              ReadBuffer = new NpgsqlReadBuffer(this, _stream, _socket, Settings.ReadBufferSize, TextEncoding, RelaxedTextEncoding);
471              WriteBuffer = new NpgsqlWriteBuffer(this, _stream, _socket, Settings.WriteBufferSize, TextEncoding);
472              timeout.CheckAndApply(this);
473              IsSecure = false;
474              if ((sslMode is SslMode.Prefer && DataSource.EncryptionHandler.SupportEncryption) ||
475                  sslMode is SslMode.Require or SslMode.VerifyCA or SslMode.VerifyFull)
476              {
477                  WriteSslRequest();
478                  await Flush(async, cancellationToken);
479                  await ReadBuffer.Ensure(1, async);
480                  var response = (char)ReadBuffer.ReadByte();
481                  timeout.CheckAndApply(this);
482                  switch (response)
483                  {
484                  default:
485                      throw new NpgsqlException($"Received unknown response {response} for SSLRequest (expecting S or N)");
486                  case 'N':
487                      if (sslMode != SslMode.Prefer)
488                          throw new NpgsqlException("SSL connection requested. No SSL enabled connection from this host is configured.");
489                      break;
490                  case 'S':
491                      await DataSource.EncryptionHandler.NegotiateEncryption(this, sslMode, timeout, async, isFirstAttempt);
492                      break;
493                  }
494                  if (ReadBuffer.ReadBytesLeft > 0)
495                      throw new NpgsqlException("Additional unencrypted data received after SSL negotiation - this should never happen, and may be an indication of a man-in-the-middle attack.");
496              }
497              ConnectionLogger.LogTrace("Socket connected to {Host}:{Port}", Host, Port);
498          }
499          catch
500          {
501              _stream?.Dispose();
502              _stream = null!;
503              _baseStream?.Dispose();
504              _baseStream = null!;
505              _socket?.Dispose();
506              _socket = null!;
507              throw;
508          }
509      }
510      internal async Task NegotiateEncryption(SslMode sslMode, NpgsqlTimeout timeout, bool async, bool isFirstAttempt)
511      {
512          var clientCertificates = new X509Certificate2Collection();
513          var certPath = Settings.SslCertificate ?? PostgresEnvironment.SslCert ?? PostgresEnvironment.SslCertDefault;
514          if (certPath != null)
515          {
516              var password = Settings.SslPassword;
517              X509Certificate2? cert = null;
518              if (Path.GetExtension(certPath).ToUpperInvariant() != ".PFX")
519              {
520  #if NET5_0_OR_GREATER
521                  var keyPath = Settings.SslKey ?? PostgresEnvironment.SslKey ?? PostgresEnvironment.SslKeyDefault;
522                  cert = string.IsNullOrEmpty(password)
523                      ? X509Certificate2.CreateFromPemFile(certPath, keyPath)
524                      : X509Certificate2.CreateFromEncryptedPemFile(certPath, password, keyPath);
525                  if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
526                  {
527                      using var previousCert = cert;
528                      cert = new X509Certificate2(cert.Export(X509ContentType.Pkcs12));
529                  }
530  #else
531                  throw new NotSupportedException("PEM certificates are only supported with .NET 6 and higher");
532  #endif
533              }
534              cert ??= new X509Certificate2(certPath, password);
535              clientCertificates.Add(cert);
536              _certificate = cert;
537          }
538          try
539          {
540              ClientCertificatesCallback?.Invoke(clientCertificates);
541              var checkCertificateRevocation = Settings.CheckCertificateRevocation;
542              RemoteCertificateValidationCallback? certificateValidationCallback;
543              X509Certificate2? caCert;
544              string? certRootPath = null;
545              if (UserCertificateValidationCallback is not null)
546              {
547                  if (sslMode is SslMode.VerifyCA or SslMode.VerifyFull)
548                      throw new ArgumentException(string.Format(NpgsqlStrings.CannotUseSslVerifyWithUserCallback, sslMode));
549                  if (Settings.RootCertificate is not null)
550                      throw new ArgumentException(NpgsqlStrings.CannotUseSslRootCertificateWithUserCallback);
551                  if (DataSource.EncryptionHandler.RootCertificateCallback is not null)
552                      throw new ArgumentException(NpgsqlStrings.CannotUseValidationRootCertificateCallbackWithUserCallback);
553                  certificateValidationCallback = UserCertificateValidationCallback;
554              }
555              else if (sslMode is SslMode.Prefer or SslMode.Require)
556              {
557                  if (isFirstAttempt && sslMode is SslMode.Require && !Settings.TrustServerCertificate)
558                      throw new ArgumentException(NpgsqlStrings.CannotUseSslModeRequireWithoutTrustServerCertificate);
559                  certificateValidationCallback = SslTrustServerValidation;
560                  checkCertificateRevocation = false;
561              }
562              else if ((caCert = DataSource.EncryptionHandler.RootCertificateCallback?.Invoke()) is not null ||
563                       (certRootPath = Settings.RootCertificate ??
564                                       PostgresEnvironment.SslCertRoot ?? PostgresEnvironment.SslCertRootDefault) is not null)
565              {
566                  certificateValidationCallback = SslRootValidation(sslMode == SslMode.VerifyFull, certRootPath, caCert);
567              }
568              else if (sslMode == SslMode.VerifyCA)
569              {
570                  certificateValidationCallback = SslVerifyCAValidation;
571              }
572              else
573              {
574                  Debug.Assert(sslMode == SslMode.VerifyFull);
575                  certificateValidationCallback = SslVerifyFullValidation;
576              }
577              timeout.CheckAndApply(this);
578              try
579              {
580                  var sslStream = new SslStream(_stream, leaveInnerStreamOpen: false, certificateValidationCallback);
581                  var sslProtocols = SslProtocols.None;
582  #if NETSTANDARD2_0
583                  sslProtocols = SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12;
584  #endif
585                  if (async)
586                      await sslStream.AuthenticateAsClientAsync(Host, clientCertificates, sslProtocols, checkCertificateRevocation);
587                  else
588                      sslStream.AuthenticateAsClient(Host, clientCertificates, sslProtocols, checkCertificateRevocation);
589                  _stream = sslStream;
590              }
591              catch (Exception e)
592              {
593                  throw new NpgsqlException("Exception while performing SSL handshake", e);
594              }
595              ReadBuffer.Underlying = _stream;
596              WriteBuffer.Underlying = _stream;
597              IsSecure = true;
598              ConnectionLogger.LogTrace("SSL negotiation successful");
599          }
600          catch
601          {
602              _certificate?.Dispose();
603              _certificate = null;
604              throw;
605          }
606      }
607      void Connect(NpgsqlTimeout timeout)
608      {
609          var endpoints = NpgsqlConnectionStringBuilder.IsUnixSocket(Host, Port, out var socketPath)
610              ? new EndPoint[] { new UnixDomainSocketEndPoint(socketPath) }
611              : Dns.GetHostAddresses(Host).Select(a => new IPEndPoint(a, Port)).ToArray();
612          timeout.Check();
613          var perEndpointTimeout = -1;  
614          if (timeout.IsSet)
615              perEndpointTimeout = (int)(timeout.CheckAndGetTimeLeft().Ticks / endpoints.Length / 10);
616          for (var i = 0; i < endpoints.Length; i++)
617          {
618              var endpoint = endpoints[i];
619              ConnectionLogger.LogTrace("Attempting to connect to {Endpoint}", endpoint);
620              var protocolType =
621                  endpoint.AddressFamily == AddressFamily.InterNetwork ||
622                  endpoint.AddressFamily == AddressFamily.InterNetworkV6
623                      ? ProtocolType.Tcp
624                      : ProtocolType.IP;
625              var socket = new Socket(endpoint.AddressFamily, SocketType.Stream, protocolType)
626              {
627                  Blocking = false
628              };
629              try
630              {
631                  try
632                  {
633                      socket.Connect(endpoint);
634                  }
635                  catch (SocketException e)
636                  {
637                      if (e.SocketErrorCode != SocketError.WouldBlock)
638                          throw;
639                  }
640                  var write = new List<Socket> { socket };
641                  var error = new List<Socket> { socket };
642                  Socket.Select(null, write, error, perEndpointTimeout);
643                  var errorCode = (int) socket.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Error)!;
644                  if (errorCode != 0)
645                      throw new SocketException(errorCode);
646                  if (!write.Any())
647                      throw new TimeoutException("Timeout during connection attempt");
648                  socket.Blocking = true;
649                  SetSocketOptions(socket);
650                  _socket = socket;
651                  ConnectedEndPoint = endpoint;
652                  return;
653              }
654              catch (Exception e)
655              {
656                  try { socket.Dispose(); }
657                  catch
658                  {
659                  }
660                  ConnectionLogger.LogTrace(e, "Failed to connect to {Endpoint}", endpoint);
661                  if (i == endpoints.Length - 1)
662                      throw new NpgsqlException($"Failed to connect to {endpoint}", e);
663              }
664          }
665      }
666      async Task ConnectAsync(NpgsqlTimeout timeout, CancellationToken cancellationToken)
667      {
668          Task<IPAddress[]> GetHostAddressesAsync(CancellationToken ct) =>
669  #if NET6_0_OR_GREATER
670              Dns.GetHostAddressesAsync(Host, ct);
671  #else
672              Dns.GetHostAddressesAsync(Host);
673  #endif
674          var endpoints = NpgsqlConnectionStringBuilder.IsUnixSocket(Host, Port, out var socketPath)
675              ? new EndPoint[] { new UnixDomainSocketEndPoint(socketPath) }
676              : (await TaskTimeoutAndCancellation.ExecuteAsync(GetHostAddressesAsync, timeout, cancellationToken))
677              .Select(a => new IPEndPoint(a, Port)).ToArray();
678          var perIpTimespan = default(TimeSpan);
679          var perIpTimeout = timeout;
680          if (timeout.IsSet)
681          {
682              perIpTimespan = new TimeSpan(timeout.CheckAndGetTimeLeft().Ticks / endpoints.Length);
683              perIpTimeout = new NpgsqlTimeout(perIpTimespan);
684          }
685          for (var i = 0; i < endpoints.Length; i++)
686          {
687              var endpoint = endpoints[i];
688              ConnectionLogger.LogTrace("Attempting to connect to {Endpoint}", endpoint);
689              var protocolType =
690                  endpoint.AddressFamily == AddressFamily.InterNetwork ||
691                  endpoint.AddressFamily == AddressFamily.InterNetworkV6
692                      ? ProtocolType.Tcp
693                      : ProtocolType.IP;
694              var socket = new Socket(endpoint.AddressFamily, SocketType.Stream, protocolType);
695              try
696              {
697                  await OpenSocketConnectionAsync(socket, endpoint, perIpTimeout, cancellationToken);
698                  SetSocketOptions(socket);
699                  _socket = socket;
700                  ConnectedEndPoint = endpoint;
701                  return;
702              }
703              catch (Exception e)
704              {
705                  try
706                  {
707                      socket.Dispose();
708                  }
709                  catch
710                  {
711                  }
712                  cancellationToken.ThrowIfCancellationRequested();
713                  if (e is OperationCanceledException)
714                      e = new TimeoutException("Timeout during connection attempt");
715                  ConnectionLogger.LogTrace(e, "Failed to connect to {Endpoint}", endpoint);
716                  if (i == endpoints.Length - 1)
717                      throw new NpgsqlException($"Failed to connect to {endpoint}", e);
718              }
719          }
720          static Task OpenSocketConnectionAsync(Socket socket, EndPoint endpoint, NpgsqlTimeout perIpTimeout, CancellationToken cancellationToken)
721          {
722              Task ConnectAsync(CancellationToken ct) =>
723  #if NET5_0_OR_GREATER
724                  socket.ConnectAsync(endpoint, ct).AsTask();
725  #else
726                  socket.ConnectAsync(endpoint);
727  #endif
728              return TaskTimeoutAndCancellation.ExecuteAsync(ConnectAsync, perIpTimeout, cancellationToken);
729          }
730      }
731      void SetSocketOptions(Socket socket)
732      {
733          if (socket.AddressFamily == AddressFamily.InterNetwork || socket.AddressFamily == AddressFamily.InterNetworkV6)
734              socket.NoDelay = true;
735          if (Settings.SocketReceiveBufferSize > 0)
736              socket.ReceiveBufferSize = Settings.SocketReceiveBufferSize;
737          if (Settings.SocketSendBufferSize > 0)
738              socket.SendBufferSize = Settings.SocketSendBufferSize;
739          if (Settings.TcpKeepAlive)
740              socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
741          if (Settings.TcpKeepAliveInterval > 0 && Settings.TcpKeepAliveTime == 0)
742              throw new ArgumentException("If TcpKeepAliveInterval is defined, TcpKeepAliveTime must be defined as well");
743          if (Settings.TcpKeepAliveTime > 0)
744          {
745              var timeSeconds = Settings.TcpKeepAliveTime;
746              var intervalSeconds = Settings.TcpKeepAliveInterval > 0
747                  ? Settings.TcpKeepAliveInterval
748                  : Settings.TcpKeepAliveTime;
749  #if NETSTANDARD2_0 || NETSTANDARD2_1
750              var timeMilliseconds = timeSeconds * 1000;
751              var intervalMilliseconds = intervalSeconds * 1000;
752              var uintSize = Marshal.SizeOf(typeof(uint));
753              var inOptionValues = new byte[uintSize * 3];
754              BitConverter.GetBytes((uint)1).CopyTo(inOptionValues, 0);
755              BitConverter.GetBytes((uint)timeMilliseconds).CopyTo(inOptionValues, uintSize);
756              BitConverter.GetBytes((uint)intervalMilliseconds).CopyTo(inOptionValues, uintSize * 2);
757              var result = 0;
758              try
759              {
760                  result = socket.IOControl(IOControlCode.KeepAliveValues, inOptionValues, null);
761              }
762              catch (PlatformNotSupportedException)
763              {
764                  throw new PlatformNotSupportedException("Setting TCP Keepalive Time and TCP Keepalive Interval is supported only on Windows, Mono and .NET Core 3.1+. " +
765                      "TCP keepalives can still be used on other systems but are enabled via the TcpKeepAlive option or configured globally for the machine, see the relevant docs.");
766              }
767              if (result != 0)
768                  throw new NpgsqlException($"Got non-zero value when trying to set TCP keepalive: {result}");
769  #else
770              socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
771              socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.TcpKeepAliveTime, timeSeconds);
772              socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.TcpKeepAliveInterval, intervalSeconds);
773  #endif
774          }
775      }
776      #endregion
777      #region I/O
778      readonly ChannelReader<NpgsqlCommand>? CommandsInFlightReader;
779      internal readonly ChannelWriter<NpgsqlCommand>? CommandsInFlightWriter;
780      internal volatile int CommandsInFlightCount;
781      internal ManualResetValueTaskSource<object?> ReaderCompleted { get; } =
782          new() { RunContinuationsAsynchronously = true };
783      async Task MultiplexingReadLoop()
784      {
785          Debug.Assert(Settings.Multiplexing);
786          Debug.Assert(CommandsInFlightReader != null);
787          NpgsqlCommand? command = null;
788          var commandsRead = 0;
789          try
790          {
791              while (await CommandsInFlightReader.WaitToReadAsync())
792              {
793                  commandsRead = 0;
794                  Debug.Assert(!InTransaction);
795                  while (CommandsInFlightReader.TryRead(out command))
796                  {
797                      commandsRead++;
798                      await ReadBuffer.Ensure(5, true);
799                      command.TraceReceivedFirstResponse();
800                      ReaderCompleted.Reset();
801                      command.ExecutionCompletion.SetResult(this);
802                      await new ValueTask(ReaderCompleted, ReaderCompleted.Version);
803                      Debug.Assert(!InTransaction);
804                  }
805                  if (Interlocked.Add(ref CommandsInFlightCount, -commandsRead) == 0)
806                  {
807                      SpinWait.SpinUntil(() => MultiplexAsyncWritingLock == 0 || IsBroken);
808                      ResetReadBuffer();
809                      DataSource.Return(this);
810                  }
811              }
812              ConnectionLogger.LogTrace("Exiting multiplexing read loop", Id);
813          }
814          catch (Exception e)
815          {
816              Debug.Assert(IsBroken);
817              Interlocked.Add(ref CommandsInFlightCount, -commandsRead);
818              command?.ExecutionCompletion.SetException(_breakReason!);
819              try
820              {
821                  while (true)
822                  {
823                      var pendingCommand = await CommandsInFlightReader.ReadAsync();
824                      pendingCommand.ExecutionCompletion.SetException(_breakReason!);
825                  }
826              }
827              catch (ChannelClosedException)
828              {
829              }
830              DataSource.Return(this);
831              ConnectionLogger.LogError(e, "Exception in multiplexing read loop", Id);
832          }
833          Debug.Assert(CommandsInFlightCount == 0);
834      }
835      #endregion
836      #region Frontend message processing
837      internal void PrependInternalMessage(byte[] rawMessage, int responseMessageCount)
838      {
839          PendingPrependedResponses += responseMessageCount;
840          var t = WritePregenerated(rawMessage);
841          Debug.Assert(t.IsCompleted, "Could not fully write pregenerated message into the buffer");
842      }
843      #endregion
844      #region Backend message processing
845      internal ValueTask<IBackendMessage?> ReadMessageWithNotifications(bool async)
846          => ReadMessageLong(async, DataRowLoadingMode.NonSequential, readingNotifications: true);
847      internal ValueTask<IBackendMessage> ReadMessage(
848          bool async,
849          DataRowLoadingMode dataRowLoadingMode = DataRowLoadingMode.NonSequential)
850      {
851          if (PendingPrependedResponses > 0 ||
852              dataRowLoadingMode == DataRowLoadingMode.Skip ||
853              ReadBuffer.ReadBytesLeft < 5)
854          {
855              return ReadMessageLong(async, dataRowLoadingMode, readingNotifications: false)!;
856          }
857          var messageCode = (BackendMessageCode)ReadBuffer.ReadByte();
858          switch (messageCode)
859          {
860          case BackendMessageCode.NoticeResponse:
861          case BackendMessageCode.NotificationResponse:
862          case BackendMessageCode.ParameterStatus:
863          case BackendMessageCode.ErrorResponse:
864              ReadBuffer.ReadPosition--;
865              return ReadMessageLong(async, dataRowLoadingMode, readingNotifications: false)!;
866          }
867          PGUtil.ValidateBackendMessageCode(messageCode);
868          var len = ReadBuffer.ReadInt32() - 4; 
869          if (len > ReadBuffer.ReadBytesLeft)
870          {
871              ReadBuffer.ReadPosition -= 5;
872              return ReadMessageLong(async, dataRowLoadingMode, readingNotifications: false)!;
873          }
874          return new ValueTask<IBackendMessage?>(ParseServerMessage(ReadBuffer, messageCode, len, false))!;
875      }
876      async ValueTask<IBackendMessage?> ReadMessageLong(
877          bool async,
878          DataRowLoadingMode dataRowLoadingMode,
879          bool readingNotifications,
880          bool isReadingPrependedMessage = false)
881      {
882          if (PendingPrependedResponses > 0 && !isReadingPrependedMessage)
883          {
884              try
885              {
886                  ReadBuffer.Timeout = TimeSpan.FromMilliseconds(InternalCommandTimeout);
887                  for (; PendingPrependedResponses > 0; PendingPrependedResponses--)
888                      await ReadMessageLong(async, DataRowLoadingMode.Skip, readingNotifications: false, isReadingPrependedMessage: true);
889                  ReadingPrependedMessagesMRE.Set();
890              }
891              catch (Exception e)
892              {
893                  throw Break(e);
894              }
895          }
896          PostgresException? error = null;
897          try
898          {
899              ReadBuffer.Timeout = TimeSpan.FromMilliseconds(UserTimeout);
900              while (true)
901              {
902                  await ReadBuffer.Ensure(5, async, readingNotifications);
903                  var messageCode = (BackendMessageCode)ReadBuffer.ReadByte();
904                  PGUtil.ValidateBackendMessageCode(messageCode);
905                  var len = ReadBuffer.ReadInt32() - 4; 
906                  if ((messageCode == BackendMessageCode.DataRow &&
907                       dataRowLoadingMode != DataRowLoadingMode.NonSequential) ||
908                      messageCode == BackendMessageCode.CopyData)
909                  {
910                      if (dataRowLoadingMode == DataRowLoadingMode.Skip)
911                      {
912                          await ReadBuffer.Skip(len, async);
913                          continue;
914                      }
915                  }
916                  else if (len > ReadBuffer.ReadBytesLeft)
917                  {
918                      if (len > ReadBuffer.Size)
919                      {
920                          var oversizeBuffer = ReadBuffer.AllocateOversize(len);
921                          if (_origReadBuffer == null)
922                              _origReadBuffer = ReadBuffer;
923                          else
924                              ReadBuffer.Dispose();
925                          ReadBuffer = oversizeBuffer;
926                      }
927                      await ReadBuffer.Ensure(len, async);
928                  }
929                  var msg = ParseServerMessage(ReadBuffer, messageCode, len, isReadingPrependedMessage);
930                  switch (messageCode)
931                  {
932                  case BackendMessageCode.ErrorResponse:
933                      Debug.Assert(msg == null);
934                      error = PostgresException.Load(
935                          ReadBuffer,
936                          Settings.IncludeErrorDetail,
937                          LoggingConfiguration.ExceptionLogger);
938                      if (State == ConnectorState.Connecting)
939                      {
940                          throw error;
941                      }
942                      if (PostgresErrorCodes.IsCriticalFailure(error, clusterError: false))
943                      {
944                          throw Break(error);
945                      }
946                      continue;
947                  case BackendMessageCode.ReadyForQuery:
948                      if (error != null)
949                      {
950                          NpgsqlEventSource.Log.CommandFailed();
951                          throw error;
952                      }
953                      break;
954                  case BackendMessageCode.NoticeResponse:
955                  case BackendMessageCode.NotificationResponse:
956                  case BackendMessageCode.ParameterStatus:
957                      Debug.Assert(msg == null);
958                      if (!readingNotifications)
959                          continue;
960                      return null;
961                  }
962                  Debug.Assert(msg != null, "Message is null for code: " + messageCode);
963                  return msg;
964              }
965          }
966          catch (PostgresException e)
967          {
968              if (e.SqlState == PostgresErrorCodes.QueryCanceled && PostgresCancellationPerformed)
969              {
970                  throw UserCancellationRequested
971                      ? new OperationCanceledException("Query was cancelled", e, UserCancellationToken)
972                      : new NpgsqlException("Exception while reading from stream",
973                          new TimeoutException("Timeout during reading attempt"));
974              }
975              throw;
976          }
977          catch (NpgsqlException)
978          {
979              if (error != null)
980                  ExceptionDispatchInfo.Capture(error).Throw();
981              throw;
982          }
983      }
984      internal IBackendMessage? ParseServerMessage(NpgsqlReadBuffer buf, BackendMessageCode code, int len, bool isPrependedMessage)
985      {
986          switch (code)
987          {
988          case BackendMessageCode.RowDescription:
989              return _rowDescriptionMessage.Load(buf, TypeMapper);
990          case BackendMessageCode.DataRow:
991              return _dataRowMessage.Load(len);
992          case BackendMessageCode.CommandComplete:
993              return _commandCompleteMessage.Load(buf, len);
994          case BackendMessageCode.ReadyForQuery:
995              var rfq = _readyForQueryMessage.Load(buf);
996              if (!isPrependedMessage) {
997                  ProcessNewTransactionStatus(rfq.TransactionStatusIndicator);
998              }
999              return rfq;
1000          case BackendMessageCode.EmptyQueryResponse:
1001              return EmptyQueryMessage.Instance;
1002          case BackendMessageCode.ParseComplete:
1003              return ParseCompleteMessage.Instance;
1004          case BackendMessageCode.ParameterDescription:
1005              return _parameterDescriptionMessage.Load(buf);
1006          case BackendMessageCode.BindComplete:
1007              return BindCompleteMessage.Instance;
1008          case BackendMessageCode.NoData:
1009              return NoDataMessage.Instance;
1010          case BackendMessageCode.CloseComplete:
1011              return CloseCompletedMessage.Instance;
1012          case BackendMessageCode.ParameterStatus:
1013              ReadParameterStatus(buf.GetNullTerminatedBytes(), buf.GetNullTerminatedBytes());
1014              return null;
1015          case BackendMessageCode.NoticeResponse:
1016              var notice = PostgresNotice.Load(buf, Settings.IncludeErrorDetail, LoggingConfiguration.ExceptionLogger);
1017              LogMessages.ReceivedNotice(ConnectionLogger, notice.MessageText, Id);
1018              Connection?.OnNotice(notice);
1019              return null;
1020          case BackendMessageCode.NotificationResponse:
1021              Connection?.OnNotification(new NpgsqlNotificationEventArgs(buf));
1022              return null;
1023          case BackendMessageCode.AuthenticationRequest:
1024              var authType = (AuthenticationRequestType)buf.ReadInt32();
1025              return authType switch
1026              {
1027                  AuthenticationRequestType.AuthenticationOk                => AuthenticationOkMessage.Instance,
1028                  AuthenticationRequestType.AuthenticationCleartextPassword => AuthenticationCleartextPasswordMessage.Instance,
1029                  AuthenticationRequestType.AuthenticationMD5Password       => AuthenticationMD5PasswordMessage.Load(buf),
1030                  AuthenticationRequestType.AuthenticationGSS               => AuthenticationGSSMessage.Instance,
1031                  AuthenticationRequestType.AuthenticationSSPI              => AuthenticationSSPIMessage.Instance,
1032                  AuthenticationRequestType.AuthenticationGSSContinue       => AuthenticationGSSContinueMessage.Load(buf, len),
1033                  AuthenticationRequestType.AuthenticationSASL              => new AuthenticationSASLMessage(buf),
1034                  AuthenticationRequestType.AuthenticationSASLContinue      => new AuthenticationSASLContinueMessage(buf, len - 4),
1035                  AuthenticationRequestType.AuthenticationSASLFinal         => new AuthenticationSASLFinalMessage(buf, len - 4),
1036                  _ => throw new NotSupportedException($"Authentication method not supported (Received: {authType})")
1037              };
1038          case BackendMessageCode.BackendKeyData:
1039              return new BackendKeyDataMessage(buf);
1040          case BackendMessageCode.CopyInResponse:
1041              return (_copyInResponseMessage ??= new CopyInResponseMessage()).Load(ReadBuffer);
1042          case BackendMessageCode.CopyOutResponse:
1043              return (_copyOutResponseMessage ??= new CopyOutResponseMessage()).Load(ReadBuffer);
1044          case BackendMessageCode.CopyData:
1045              return (_copyDataMessage ??= new CopyDataMessage()).Load(len);
1046          case BackendMessageCode.CopyBothResponse:
1047              return (_copyBothResponseMessage ??= new CopyBothResponseMessage()).Load(ReadBuffer);
1048          case BackendMessageCode.CopyDone:
1049              return CopyDoneMessage.Instance;
1050          case BackendMessageCode.PortalSuspended:
1051              throw new NpgsqlException("Unimplemented message: " + code);
1052          case BackendMessageCode.ErrorResponse:
1053              return null;
1054          case BackendMessageCode.FunctionCallResponse:
1055              throw new NpgsqlException("Unexpected backend message: " + code);
1056          default:
1057              throw new InvalidOperationException($"Internal Npgsql bug: unexpected value {code} of enum {nameof(BackendMessageCode)}. Please file a bug.");
1058          }
1059      }
1060      [MethodImpl(MethodImplOptions.AggressiveInlining)]
1061      internal IBackendMessage SkipUntil(BackendMessageCode stopAt)
1062      {
1063          Debug.Assert(stopAt != BackendMessageCode.DataRow, "Shouldn't be used for rows, doesn't know about sequential");
1064          while (true)
1065          {
1066              var msg = ReadMessage(async: false, DataRowLoadingMode.Skip).GetAwaiter().GetResult()!;
1067              Debug.Assert(!(msg is DataRowMessage));
1068              if (msg.Code == stopAt)
1069                  return msg;
1070          }
1071      }
1072      #endregion Backend message processing
1073      #region Transactions
1074      internal Task Rollback(bool async, CancellationToken cancellationToken = default)
1075      {
1076          ConnectionLogger.LogDebug("Rolling back transaction", Id);
1077          return ExecuteInternalCommand(PregeneratedMessages.RollbackTransaction, async, cancellationToken);
1078      }
1079      internal bool InTransaction
1080      {
1081          get
1082          {
1083              switch (TransactionStatus)
1084              {
1085              case TransactionStatus.Idle:
1086                  return false;
1087              case TransactionStatus.Pending:
1088              case TransactionStatus.InTransactionBlock:
1089              case TransactionStatus.InFailedTransactionBlock:
1090                  return true;
1091              default:
1092                  ThrowHelper.ThrowInvalidOperationException($"Internal Npgsql bug: unexpected value {{0}} of enum {nameof(TransactionStatus)}. Please file a bug.", TransactionStatus);
1093                  return false;
1094              }
1095          }
1096      }
1097      void ProcessNewTransactionStatus(TransactionStatus newStatus)
1098      {
1099          if (newStatus == TransactionStatus)
1100              return;
1101          TransactionStatus = newStatus;
1102          switch (newStatus)
1103          {
1104          case TransactionStatus.Idle:
1105              return;
1106          case TransactionStatus.InTransactionBlock:
1107          case TransactionStatus.InFailedTransactionBlock:
1108              if (Connection is null)
1109              {
1110                  Debug.Assert(Settings.Multiplexing);
1111                  ThrowHelper.ThrowNotSupportedException("In multiplexing mode, transactions must be started with BeginTransaction");
1112              }
1113              return;
1114          case TransactionStatus.Pending:
1115              ThrowHelper.ThrowInvalidOperationException($"Internal Npgsql bug: invalid TransactionStatus {nameof(TransactionStatus.Pending)} received, should be frontend-only");
1116              return;
1117          default:
1118              ThrowHelper.ThrowInvalidOperationException($"Internal Npgsql bug: unexpected value {{0}} of enum {nameof(TransactionStatus)}. Please file a bug.", newStatus);
1119              return;
1120          }
1121      }
1122      internal void ClearTransaction(Exception? disposeReason = null)
1123      {
1124          Transaction?.DisposeImmediately(disposeReason);
1125          TransactionStatus = TransactionStatus.Idle;
1126      }
1127      #endregion
1128      #region SSL
1129      internal bool IsSecure { get; private set; }
1130      internal bool IsScram { get; private set; }
1131      internal bool IsScramPlus { get; private set; }
1132      static readonly RemoteCertificateValidationCallback SslVerifyFullValidation =
1133          (sender, certificate, chain, sslPolicyErrors)
1134              => sslPolicyErrors == SslPolicyErrors.None;
1135      static readonly RemoteCertificateValidationCallback SslVerifyCAValidation =
1136          (sender, certificate, chain, sslPolicyErrors)
1137              => sslPolicyErrors == SslPolicyErrors.None || sslPolicyErrors == SslPolicyErrors.RemoteCertificateNameMismatch;
1138      static readonly RemoteCertificateValidationCallback SslTrustServerValidation =
1139          (sender, certificate, chain, sslPolicyErrors)
1140              => true;
1141      static RemoteCertificateValidationCallback SslRootValidation(bool verifyFull, string? certRootPath, X509Certificate2? caCertificate)
1142          => (_, certificate, chain, sslPolicyErrors) =>
1143          {
1144              if (certificate is null || chain is null)
1145                  return false;
1146              if (sslPolicyErrors == SslPolicyErrors.None)
1147                  return true;
1148              if (!verifyFull && sslPolicyErrors == SslPolicyErrors.RemoteCertificateNameMismatch)
1149                  return true;
1150              if (verifyFull && sslPolicyErrors.HasFlag(SslPolicyErrors.RemoteCertificateNameMismatch))
1151                  return false;
1152              var certs = new X509Certificate2Collection();
1153              if (certRootPath is null)
1154              {
1155                  Debug.Assert(caCertificate is not null);
1156                  certs.Add(caCertificate);
1157              }
1158              else
1159              {
1160                  Debug.Assert(caCertificate is null);
1161  #if NET5_0_OR_GREATER
1162                  if (Path.GetExtension(certRootPath).ToUpperInvariant() != ".PFX")
1163                      certs.ImportFromPemFile(certRootPath);
1164  #endif
1165                  if (certs.Count == 0)
1166                      certs.Add(new X509Certificate2(certRootPath));
1167              }
1168  #if NET5_0_OR_GREATER
1169              chain.ChainPolicy.CustomTrustStore.AddRange(certs);
1170              chain.ChainPolicy.TrustMode = X509ChainTrustMode.CustomRootTrust;
1171  #endif
1172              chain.ChainPolicy.ExtraStore.AddRange(certs);
1173              return chain.Build(certificate as X509Certificate2 ?? new X509Certificate2(certificate));
1174          };
1175      #endregion SSL
1176      #region Cancel
1177      internal void ResetCancellation()
1178      {
1179          lock (CancelLock)
1180          {
1181              if (PendingPrependedResponses > 0)
1182                  ReadingPrependedMessagesMRE.Reset();
1183              Debug.Assert(ReadingPrependedMessagesMRE.IsSet || PendingPrependedResponses > 0);
1184          }
1185      }
1186      internal void PerformUserCancellation()
1187      {
1188          var connection = Connection;
1189          if (connection is null || connection.ConnectorBindingScope == ConnectorBindingScope.Reader || UserCancellationRequested)
1190              return;
1191          lock (SyncObj)
1192          {
1193              if (!IsConnected)
1194                  return;
1195              Monitor.Enter(CancelLock);
1196          }
1197          try
1198          {
1199              if (!ReadingPrependedMessagesMRE.Wait(0))
1200                  return;
1201              _userCancellationRequested = true;
1202              if (AttemptPostgresCancellation && SupportsPostgresCancellation)
1203              {
1204                  var cancellationTimeout = Settings.CancellationTimeout;
1205                  if (PerformPostgresCancellation() && cancellationTimeout >= 0)
1206                  {
1207                      if (cancellationTimeout > 0)
1208                      {
1209                          UserTimeout = cancellationTimeout;
1210                          ReadBuffer.Timeout = TimeSpan.FromMilliseconds(cancellationTimeout);
1211                          ReadBuffer.Cts.CancelAfter(cancellationTimeout);
1212                      }
1213                      return;
1214                  }
1215              }
1216              UserTimeout = -1;
1217              ReadBuffer.Timeout = _cancelImmediatelyTimeout;
1218              ReadBuffer.Cts.Cancel();
1219          }
1220          finally
1221          {
1222              Monitor.Exit(CancelLock);
1223          }
1224      }
1225      internal bool PerformPostgresCancellation()
1226      {
1227          Debug.Assert(BackendProcessId != 0, "PostgreSQL cancellation requested by the backend doesn't support it");
1228          lock (CancelLock)
1229          {
1230              if (PostgresCancellationPerformed)
1231                  return true;
1232              LogMessages.CancellingCommand(ConnectionLogger, Id);
1233              PostgresCancellationPerformed = true;
1234              try
1235              {
1236                  var cancelConnector = new NpgsqlConnector(this);
1237                  cancelConnector.DoCancelRequest(BackendProcessId, _backendSecretKey);
1238              }
1239              catch (Exception e)
1240              {
1241                  var socketException = e.InnerException as SocketException;
1242                  if (socketException == null || socketException.SocketErrorCode != SocketError.ConnectionReset)
1243                  {
1244                      ConnectionLogger.LogDebug(e, "Exception caught while attempting to cancel command", Id);
1245                      return false;
1246                  }
1247              }
1248              return true;
1249          }
1250      }
1251      void DoCancelRequest(int backendProcessId, int backendSecretKey)
1252      {
1253          Debug.Assert(State == ConnectorState.Closed);
1254          try
1255          {
1256              RawOpen(Settings.SslMode, new NpgsqlTimeout(TimeSpan.FromSeconds(ConnectionTimeout)), false, CancellationToken.None)
1257                  .GetAwaiter().GetResult();
1258              WriteCancelRequest(backendProcessId, backendSecretKey);
1259              Flush();
1260              Debug.Assert(ReadBuffer.ReadBytesLeft == 0);
1261              var count = _stream.Read(ReadBuffer.Buffer, 0, 1);
1262              if (count > 0)
1263                  ConnectionLogger.LogError("Received response after sending cancel request, shouldn't happen! First byte: " + ReadBuffer.Buffer[0]);
1264          }
1265          finally
1266          {
1267              FullCleanup();
1268          }
1269      }
1270      [MethodImpl(MethodImplOptions.AggressiveInlining)]
1271      internal CancellationTokenRegistration StartCancellableOperation(
1272          CancellationToken cancellationToken = default,
1273          bool attemptPgCancellation = true)
1274      {
1275          _userCancellationRequested = PostgresCancellationPerformed = false;
1276          UserCancellationToken = cancellationToken;
1277          ReadBuffer.Cts.ResetCts();
1278          AttemptPostgresCancellation = attemptPgCancellation;
1279          return _cancellationTokenRegistration =
1280              cancellationToken.Register(static c => ((NpgsqlConnector)c!).PerformUserCancellation(), this);
1281      }
1282      [MethodImpl(MethodImplOptions.AggressiveInlining)]
1283      internal CancellationTokenRegistration StartNestedCancellableOperation(
1284          CancellationToken cancellationToken = default,
1285          bool attemptPgCancellation = true)
1286      {
1287          UserCancellationToken = cancellationToken;
1288          AttemptPostgresCancellation = attemptPgCancellation;
1289          return _cancellationTokenRegistration =
1290              cancellationToken.Register(static c => ((NpgsqlConnector)c!).PerformUserCancellation(), this);
1291      }
1292      #endregion Cancel
1293      #region Close / Reset
1294      internal async Task CloseOngoingOperations(bool async)
1295      {
1296          var reader = CurrentReader;
1297          var copyOperation = CurrentCopyOperation;
1298          if (reader != null)
1299              await reader.Close(connectionClosing: true, async, isDisposing: false);
1300          else if (copyOperation != null)
1301          {
1302              if (copyOperation is NpgsqlBinaryImporter ||
1303                  copyOperation is NpgsqlCopyTextWriter ||
1304                  copyOperation is NpgsqlRawCopyStream rawCopyStream && rawCopyStream.CanWrite)
1305              {
1306                  try
1307                  {
1308                      if (async)
1309                          await copyOperation.CancelAsync();
1310                      else
1311                          copyOperation.Cancel();
1312                  }
1313                  catch (Exception e)
1314                  {
1315                      CopyLogger.LogWarning(e, "Error while cancelling COPY on connector close", Id);
1316                  }
1317              }
1318              try
1319              {
1320                  if (async)
1321                      await copyOperation.DisposeAsync();
1322                  else
1323                      copyOperation.Dispose();
1324              }
1325              catch (Exception e)
1326              {
1327                  CopyLogger.LogWarning(e, "Error while disposing cancelled COPY on connector close", Id);
1328              }
1329          }
1330      }
1331      internal void Close()
1332      {
1333          lock (SyncObj)
1334          {
1335              if (IsReady)
1336              {
1337                  LogMessages.ClosingPhysicalConnection(ConnectionLogger, Host, Port, Database, UserFacingConnectionString, Id);
1338                  try
1339                  {
1340                      WriteBuffer.Clear();
1341                      WriteTerminate();
1342                      Flush();
1343                  }
1344                  catch (Exception e)
1345                  {
1346                      ConnectionLogger.LogError(e, "Exception while closing connector", Id);
1347                      Debug.Assert(IsBroken);
1348                  }
1349              }
1350              switch (State)
1351              {
1352              case ConnectorState.Broken:
1353              case ConnectorState.Closed:
1354                  return;
1355              }
1356              State = ConnectorState.Closed;
1357          }
1358          FullCleanup();
1359          LogMessages.ClosedPhysicalConnection(ConnectionLogger, Host, Port, Database, UserFacingConnectionString, Id);
1360      }
1361      internal bool TryRemovePendingEnlistedConnector(Transaction transaction)
1362          => DataSource.TryRemovePendingEnlistedConnector(this, transaction);
1363      internal void Return() => DataSource.Return(this);
1364      internal Exception UnexpectedMessageReceived(BackendMessageCode received)
1365          => throw Break(new Exception($"Received unexpected backend message {received}. Please file a bug."));
1366      internal Exception Break(Exception reason)
1367      {
1368          Debug.Assert(!IsClosed);
1369          Monitor.Enter(SyncObj);
1370          if (State == ConnectorState.Broken)
1371          {
1372              Monitor.Exit(SyncObj);
1373              lock (CleanupLock) { }
1374              return reason;
1375          }
1376          try
1377          {
1378              ReadingPrependedMessagesMRE.Set();
1379              LogMessages.BreakingConnection(ConnectionLogger, Id, reason);
1380              Interlocked.CompareExchange(ref _breakReason, reason, null);
1381              State = ConnectorState.Broken;
1382              Monitor.Enter(CleanupLock);
1383          }
1384          finally
1385          {
1386              Monitor.Exit(SyncObj);
1387          }
1388          try
1389          {
1390              lock (CancelLock)
1391              {
1392                  if (reason is NpgsqlException { IsTransient: true } ne &&
1393                      (ne.InnerException is not TimeoutException || Settings.CancellationTimeout != -1) ||
1394                      reason is PostgresException pe && PostgresErrorCodes.IsCriticalFailure(pe))
1395                  {
1396                      DataSource.UpdateDatabaseState(DatabaseState.Offline, DateTime.UtcNow, Settings.HostRecheckSecondsTranslated);
1397                      DataSource.Clear();
1398                  }
1399                  var connection = Connection;
1400                  FullCleanup();
1401                  if (connection is not null)
1402                  {
1403                      var closeLockTaken = connection.TakeCloseLock();
1404                      Debug.Assert(closeLockTaken);
1405                      if (Settings.ReplicationMode == ReplicationMode.Off)
1406                      {
1407                          Connection = null;
1408                          if (connection.ConnectorBindingScope != ConnectorBindingScope.None)
1409                              Return();
1410                          connection.EnlistedTransaction = null;
1411                          connection.Connector = null;
1412                          connection.ConnectorBindingScope = ConnectorBindingScope.None;
1413                      }
1414                      connection.FullState = ConnectionState.Broken;
1415                      connection.ReleaseCloseLock();
1416                  }
1417                  return reason;
1418              }
1419          }
1420          finally
1421          {
1422              Monitor.Exit(CleanupLock);
1423          }
1424      }
1425      void FullCleanup()
1426      {
1427          lock (CleanupLock)
1428          {
1429              if (Settings.Multiplexing)
1430              {
1431                  FlagAsNotWritableForMultiplexing();
1432                  CommandsInFlightWriter!.Complete();
1433              }
1434              ConnectionLogger.LogTrace("Cleaning up connector", Id);
1435              Cleanup();
1436              if (_isKeepAliveEnabled)
1437              {
1438                  _keepAliveTimer!.Change(Timeout.Infinite, Timeout.Infinite);
1439                  _keepAliveTimer.Dispose();
1440              }
1441              ReadingPrependedMessagesMRE.Dispose();
1442          }
1443      }
1444      void Cleanup()
1445      {
1446          try
1447          {
1448              _stream?.Dispose();
1449          }
1450          catch
1451          {
1452          }
1453          if (CurrentReader != null)
1454          {
1455              CurrentReader.Command.State = CommandState.Idle;
1456              try
1457              {
1458                  CurrentReader.Close();
1459              }
1460              catch
1461              {
1462              }
1463              CurrentReader = null;
1464          }
1465          if (CurrentCopyOperation != null)
1466          {
1467              try
1468              {
1469                  CurrentCopyOperation.Dispose();
1470              }
1471              catch
1472              {
1473              }
1474              CurrentCopyOperation = null;
1475          }
1476          ClearTransaction(_breakReason);
1477          _stream = null!;
1478          _baseStream = null!;
1479          _origReadBuffer?.Dispose();
1480          _origReadBuffer = null;
1481          ReadBuffer?.Dispose();
1482          ReadBuffer = null!;
1483          WriteBuffer?.Dispose();
1484          WriteBuffer = null!;
1485          Connection = null;
1486          PostgresParameters.Clear();
1487          _currentCommand = null;
1488          if (_certificate is not null)
1489          {
1490              _certificate.Dispose();
1491              _certificate = null;
1492          }
1493      }
1494      void GenerateResetMessage()
1495      {
1496          var sb = new StringBuilder("SET SESSION AUTHORIZATION DEFAULT;RESET ALL;");
1497          _resetWithoutDeallocateResponseCount = 2;
1498          if (DatabaseInfo.SupportsCloseAll)
1499          {
1500              sb.Append("CLOSE ALL;");
1501              _resetWithoutDeallocateResponseCount++;
1502          }
1503          if (DatabaseInfo.SupportsUnlisten)
1504          {
1505              sb.Append("UNLISTEN *;");
1506              _resetWithoutDeallocateResponseCount++;
1507          }
1508          if (DatabaseInfo.SupportsAdvisoryLocks)
1509          {
1510              sb.Append("SELECT pg_advisory_unlock_all();");
1511              _resetWithoutDeallocateResponseCount += 2;
1512          }
1513          if (DatabaseInfo.SupportsDiscardSequences)
1514          {
1515              sb.Append("DISCARD SEQUENCES;");
1516              _resetWithoutDeallocateResponseCount++;
1517          }
1518          if (DatabaseInfo.SupportsDiscardTemp)
1519          {
1520              sb.Append("DISCARD TEMP");
1521              _resetWithoutDeallocateResponseCount++;
1522          }
1523          _resetWithoutDeallocateResponseCount++;  
1524          _resetWithoutDeallocateMessage = PregeneratedMessages.Generate(WriteBuffer, sb.ToString());
1525      }
1526      internal async Task Reset(bool async)
1527      {
1528          bool endBindingScope;
1529          using (StartUserAction(attemptPgCancellation: false))
1530          {
1531              WriteBuffer.Clear();
1532              PendingPrependedResponses = 0;
1533              ResetReadBuffer();
1534              Transaction?.UnbindIfNecessary();
1535              switch (TransactionStatus)
1536              {
1537              case TransactionStatus.Idle:
1538                  endBindingScope = Connection?.ConnectorBindingScope == ConnectorBindingScope.Transaction;
1539                  break;
1540              case TransactionStatus.Pending:
1541                  ProcessNewTransactionStatus(TransactionStatus.Idle);
1542                  ClearTransaction();
1543                  endBindingScope = true;
1544                  break;
1545              case TransactionStatus.InTransactionBlock:
1546              case TransactionStatus.InFailedTransactionBlock:
1547                  await Rollback(async);
1548                  ClearTransaction();
1549                  endBindingScope = true;
1550                  break;
1551              default:
1552                  ThrowHelper.ThrowInvalidOperationException($"Internal Npgsql bug: unexpected value {TransactionStatus} of enum {nameof(TransactionStatus)}. Please file a bug.");
1553                  return;
1554              }
1555              if (_sendResetOnClose)
1556              {
1557                  if (PreparedStatementManager.NumPrepared > 0)
1558                  {
1559                      PrependInternalMessage(_resetWithoutDeallocateMessage!, _resetWithoutDeallocateResponseCount);
1560                  }
1561                  else
1562                  {
1563                      PrependInternalMessage(PregeneratedMessages.DiscardAll, 2);
1564                  }
1565              }
1566              DataReader.UnbindIfNecessary();
1567          }
1568          if (endBindingScope)
1569          {
1570              Connection?.EndBindingScope(ConnectorBindingScope.Transaction);
1571          }
1572      }
1573      [MethodImpl(MethodImplOptions.AggressiveInlining)]
1574      void ResetReadBuffer()
1575      {
1576          if (_origReadBuffer != null)
1577          {
1578              ReadBuffer.Dispose();
1579              ReadBuffer = _origReadBuffer;
1580              _origReadBuffer = null;
1581          }
1582      }
1583      internal void UnprepareAll()
1584      {
1585          ExecuteInternalCommand("DEALLOCATE ALL");
1586          PreparedStatementManager.ClearAll();
1587      }
1588      #endregion Close / Reset
1589      #region Locking
1590      internal UserAction StartUserAction(CancellationToken cancellationToken = default, bool attemptPgCancellation = true)
1591          => StartUserAction(ConnectorState.Executing, command: null, cancellationToken, attemptPgCancellation);
1592      internal UserAction StartUserAction(
1593          ConnectorState newState,
1594          CancellationToken cancellationToken = default,
1595          bool attemptPgCancellation = true)
1596          => StartUserAction(newState, command: null, cancellationToken, attemptPgCancellation);
1597      internal UserAction StartUserAction(
1598          ConnectorState newState,
1599          NpgsqlCommand? command,
1600          CancellationToken cancellationToken = default,
1601          bool attemptPgCancellation = true)
1602      {
1603          return _isKeepAliveEnabled 
1604              ? DoStartUserActionWithKeepAlive(newState, command, cancellationToken, attemptPgCancellation)
1605              : DoStartUserAction(newState, command, cancellationToken, attemptPgCancellation);
1606          UserAction DoStartUserAction(ConnectorState newState, NpgsqlCommand? command,
1607              CancellationToken cancellationToken, bool attemptPgCancellation)
1608          {
1609              switch (State)
1610              {
1611              case ConnectorState.Ready:
1612                  break;
1613              case ConnectorState.Closed:
1614              case ConnectorState.Broken:
1615                  ThrowHelper.ThrowInvalidOperationException("Connection is not open");
1616                  break;
1617              case ConnectorState.Executing:
1618              case ConnectorState.Fetching:
1619              case ConnectorState.Waiting:
1620              case ConnectorState.Replication:
1621              case ConnectorState.Connecting:
1622              case ConnectorState.Copy:
1623                  var currentCommand = _currentCommand;
1624                  if (currentCommand is null)
1625                      ThrowHelper.ThrowNpgsqlOperationInProgressException(State);
1626                  else
1627                      ThrowHelper.ThrowNpgsqlOperationInProgressException(currentCommand);
1628                  break;
1629              default:
1630                  ThrowHelper.ThrowArgumentOutOfRangeException(nameof(State), "Invalid connector state: {0}", State);
1631                  break;
1632              }
1633              Debug.Assert(IsReady);
1634              cancellationToken.ThrowIfCancellationRequested();
1635              LogMessages.StartUserAction(ConnectionLogger, Id);
1636              State = newState;
1637              _currentCommand = command;
1638              StartCancellableOperation(cancellationToken, attemptPgCancellation);
1639              UserTimeout = (command?.CommandTimeout ?? Settings.CommandTimeout) * 1000;
1640              return new UserAction(this);
1641          }
1642          UserAction DoStartUserActionWithKeepAlive(ConnectorState newState, NpgsqlCommand? command,
1643              CancellationToken cancellationToken, bool attemptPgCancellation)
1644          {
1645              lock (SyncObj)
1646              {
1647                  if (!IsConnected)
1648                  {
1649                      if (IsBroken)
1650                          ThrowHelper.ThrowNpgsqlException("The connection was previously broken because of the following exception", _breakReason);
1651                      else
1652                          ThrowHelper.ThrowNpgsqlException("The connection is closed");
1653                  }
1654                  _keepAliveTimer!.Change(Timeout.Infinite, Timeout.Infinite);
1655                  try
1656                  {
1657                      return DoStartUserAction(newState, command, cancellationToken, attemptPgCancellation);
1658                  }
1659                  catch (Exception ex) when (ex is not NpgsqlOperationInProgressException)
1660                  {
1661                      var keepAlive = Settings.KeepAlive * 1000;
1662                      _keepAliveTimer!.Change(keepAlive, keepAlive);
1663                      throw;
1664                  }
1665              }
1666          }
1667      }
1668      internal void EndUserAction()
1669      {
1670          Debug.Assert(CurrentReader == null);
1671          _cancellationTokenRegistration.Dispose();
1672          if (_isKeepAliveEnabled)
1673          {
1674              lock (SyncObj)
1675              {
1676                  if (IsReady || !IsConnected)
1677                      return;
1678                  var keepAlive = Settings.KeepAlive * 1000;
1679                  _keepAliveTimer!.Change(keepAlive, keepAlive);
1680                  LogMessages.EndUserAction(ConnectionLogger, Id);
1681                  _currentCommand = null;
1682                  State = ConnectorState.Ready;
1683              }
1684          }
1685          else
1686          {
1687              if (IsReady || !IsConnected)
1688                  return;
1689              LogMessages.EndUserAction(ConnectionLogger, Id);
1690              _currentCommand = null;
1691              State = ConnectorState.Ready;
1692          }
1693      }
1694      internal readonly struct UserAction : IDisposable
1695      {
1696          readonly NpgsqlConnector _connector;
1697          internal UserAction(NpgsqlConnector connector) => _connector = connector;
1698          public void Dispose() => _connector.EndUserAction();
1699      }
1700      #endregion
1701      #region Keepalive
1702  #pragma warning disable CA1801 
1703      void PerformKeepAlive(object? state)
1704      {
1705          Debug.Assert(_isKeepAliveEnabled);
1706          if (!Monitor.TryEnter(SyncObj))
1707              return;
1708          try
1709          {
1710              if (!IsReady)
1711                  return;
1712              LogMessages.SendingKeepalive(ConnectionLogger, Id);
1713              AttemptPostgresCancellation = false;
1714              var timeout = InternalCommandTimeout;
1715              WriteBuffer.Timeout = TimeSpan.FromSeconds(timeout);
1716              UserTimeout = timeout;
1717              WriteSync(async: false).GetAwaiter().GetResult();
1718              Flush();
1719              SkipUntil(BackendMessageCode.ReadyForQuery);
1720              LogMessages.CompletedKeepalive(ConnectionLogger, Id);
1721          }
1722          catch (Exception e)
1723          {
1724              LogMessages.KeepaliveFailed(ConnectionLogger, Id, e);
1725              try
1726              {
1727                  Break(new NpgsqlException("Exception while sending a keepalive", e));
1728              }
1729              catch (Exception e2)
1730              {
1731                  ConnectionLogger.LogError(e2, "Further exception while breaking connector on keepalive failure", Id);
1732              }
1733          }
1734          finally
1735          {
1736              Monitor.Exit(SyncObj);
1737          }
1738      }
1739  #pragma warning restore CA1801 
1740      #endregion
1741      #region Wait
1742      internal async Task<bool> Wait(bool async, int timeout, CancellationToken cancellationToken = default)
1743      {
1744          using var _ = StartUserAction(ConnectorState.Waiting, cancellationToken: cancellationToken, attemptPgCancellation: false);
1745          await Flush(async, cancellationToken);
1746          var keepaliveMs = Settings.KeepAlive * 1000;
1747          while (true)
1748          {
1749              cancellationToken.ThrowIfCancellationRequested();
1750              var timeoutForKeepalive = _isKeepAliveEnabled && (timeout <= 0 || keepaliveMs < timeout);
1751              UserTimeout = timeoutForKeepalive ? keepaliveMs : timeout;
1752              try
1753              {
1754                  var msg = await ReadMessageWithNotifications(async);
1755                  if (msg != null)
1756                  {
1757                      throw Break(
1758                          new NpgsqlException($"Received unexpected message of type {msg.Code} while waiting"));
1759                  }
1760                  return true;
1761              }
1762              catch (NpgsqlException e) when (e.InnerException is TimeoutException)
1763              {
1764                  if (!timeoutForKeepalive)  
1765                      return false;
1766              }
1767              LogMessages.SendingKeepalive(ConnectionLogger, Id);
1768              var keepaliveTime = Stopwatch.StartNew();
1769              await WriteSync(async, cancellationToken);
1770              await Flush(async, cancellationToken);
1771              var receivedNotification = false;
1772              var expectedMessageCode = BackendMessageCode.RowDescription;
1773              while (true)
1774              {
1775                  IBackendMessage? msg;
1776                  try
1777                  {
1778                      msg = await ReadMessageWithNotifications(async);
1779                  }
1780                  catch (Exception e) when (e is OperationCanceledException || e is NpgsqlException npgEx && npgEx.InnerException is TimeoutException)
1781                  {
1782                      throw Break(e);
1783                  }
1784                  if (msg == null)
1785                  {
1786                      receivedNotification = true;
1787                      continue;
1788                  }
1789                  if (msg.Code != BackendMessageCode.ReadyForQuery)
1790                      throw new NpgsqlException($"Received unexpected message of type {msg.Code} while expecting {expectedMessageCode} as part of keepalive");
1791                  LogMessages.CompletedKeepalive(ConnectionLogger, Id);
1792                  if (receivedNotification)
1793                      return true; 
1794                  cancellationToken.ThrowIfCancellationRequested();
1795                  break;
1796              }
1797              if (timeout > 0)
1798                  timeout -= (keepaliveMs + (int)keepaliveTime.ElapsedMilliseconds);
1799          }
1800      }
1801      #endregion
1802      #region Supported features and PostgreSQL settings
1803      internal bool UseConformingStrings { get; private set; }
1804      internal string Timezone { get; private set; } = default!;
1805      bool? _isTransactionReadOnly;
1806      bool? _isHotStandBy;
1807      #endregion Supported features and PostgreSQL settings
1808      #region Execute internal command
1809      internal void ExecuteInternalCommand(string query)
1810          => ExecuteInternalCommand(query, false).GetAwaiter().GetResult();
1811      internal async Task ExecuteInternalCommand(string query, bool async, CancellationToken cancellationToken = default)
1812      {
1813          LogMessages.ExecutingInternalCommand(CommandLogger, query, Id);
1814          await WriteQuery(query, async, cancellationToken);
1815          await Flush(async, cancellationToken);
1816          Expect<CommandCompleteMessage>(await ReadMessage(async), this);
1817          Expect<ReadyForQueryMessage>(await ReadMessage(async), this);
1818      }
1819      internal async Task ExecuteInternalCommand(byte[] data, bool async, CancellationToken cancellationToken = default)
1820      {
1821          Debug.Assert(State != ConnectorState.Ready, "Forgot to start a user action...");
1822          await WritePregenerated(data, async, cancellationToken);
1823          await Flush(async, cancellationToken);
1824          Expect<CommandCompleteMessage>(await ReadMessage(async), this);
1825          Expect<ReadyForQueryMessage>(await ReadMessage(async), this);
1826      }
1827      #endregion
1828      #region Misc
1829      public NpgsqlCommand CreateCommand(string? cmdText = null) => new(cmdText, this);
1830      public NpgsqlBatch CreateBatch() => new NpgsqlBatch(this);
1831      void ReadParameterStatus(ReadOnlySpan<byte> incomingName, ReadOnlySpan<byte> incomingValue)
1832      {
1833          byte[] rawName;
1834          byte[] rawValue;
1835          for (var i = 0; i < _rawParameters.Count; i++)
1836          {
1837              (var currentName, var currentValue) = _rawParameters[i];
1838              if (incomingName.SequenceEqual(currentName))
1839              {
1840                  if (incomingValue.SequenceEqual(currentValue))
1841                      return;
1842                  rawName = currentName;
1843                  rawValue = incomingValue.ToArray();
1844                  _rawParameters[i] = (rawName, rawValue);
1845                  goto ProcessParameter;
1846              }
1847          }
1848          rawName = incomingName.ToArray();
1849          rawValue = incomingValue.ToArray();
1850          _rawParameters.Add((rawName, rawValue));
1851          ProcessParameter:
1852          var name = TextEncoding.GetString(rawName);
1853          var value = TextEncoding.GetString(rawValue);
1854          PostgresParameters[name] = value;
1855          switch (name)
1856          {
1857          case "standard_conforming_strings":
1858              if (value != "on" && Settings.Multiplexing)
1859                  throw Break(new NotSupportedException("standard_conforming_strings must be on with multiplexing"));
1860              UseConformingStrings = value == "on";
1861              return;
1862          case "TimeZone":
1863              Timezone = value;
1864              return;
1865          case "default_transaction_read_only":
1866              _isTransactionReadOnly = value == "on";
1867              UpdateDatabaseState();
1868              return;
1869          case "in_hot_standby":
1870              _isHotStandBy = value == "on";
1871              UpdateDatabaseState();
1872              return;
1873          }
1874      }
1875      DatabaseState? UpdateDatabaseState()
1876      {
1877          if (_isTransactionReadOnly.HasValue && _isHotStandBy.HasValue)
1878          {
1879              var state = _isHotStandBy.Value
1880                  ? DatabaseState.Standby
1881                  : _isTransactionReadOnly.Value
1882                      ? DatabaseState.PrimaryReadOnly
1883                      : DatabaseState.PrimaryReadWrite;
1884              return DataSource.UpdateDatabaseState(state, DateTime.UtcNow, Settings.HostRecheckSecondsTranslated);
1885          }
1886          return null;
1887      }
1888      #endregion Misc
1889  }
1890  #region Enums
1891  enum ConnectorState
1892  {
1893      Closed,
1894      Connecting,
1895      Ready,
1896      Executing,
1897      Fetching,
1898      Waiting,
1899      Broken,
1900      Copy,
1901      Replication,
1902  }
1903  #pragma warning disable CA1717
1904  enum TransactionStatus : byte
1905  #pragma warning restore CA1717
1906  {
1907      Idle = (byte)'I',
1908      InTransactionBlock = (byte)'T',
1909      InFailedTransactionBlock = (byte)'E',
1910      Pending = byte.MaxValue,
1911  }
1912  enum DataRowLoadingMode
1913  {
1914      NonSequential,
1915      Sequential,
1916      Skip
1917  }
1918  #endregion
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from EarTrumpet-MDEwOlJlcG9zaXRvcnkzODkxOTcwMg==-flat-EarTrumpetActionsAddon.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnector.cs</div>
                <div class="column column_space"><pre><code>19          public static EarTrumpetActionsAddon Current { get; private set; }
20          public LocalVariablesContainer LocalVariables { get; private set; }
</pre></code></div>
                <div class="column column_space"><pre><code>41      public Encoding TextEncoding { get; private set; } = default!;
42      internal Encoding RelaxedTextEncoding { get; private set; } = default!;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    