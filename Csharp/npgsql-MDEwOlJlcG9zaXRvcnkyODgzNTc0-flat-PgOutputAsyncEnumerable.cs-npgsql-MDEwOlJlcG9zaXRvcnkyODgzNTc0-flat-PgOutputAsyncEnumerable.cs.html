
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputAsyncEnumerable.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Npgsql.BackendMessages;
7  using Npgsql.Internal;
8  using Npgsql.Internal.TypeHandlers.DateTimeHandlers;
9  using Npgsql.Replication.Internal;
10  using Npgsql.Replication.PgOutput.Messages;
11  using Npgsql.Util;
12  using NpgsqlTypes;
13  namespace Npgsql.Replication.PgOutput;
14  sealed class PgOutputAsyncEnumerable : IAsyncEnumerable<PgOutputReplicationMessage>
15  {
16      readonly LogicalReplicationConnection _connection;
17      readonly PgOutputReplicationSlot _slot;
18      readonly PgOutputReplicationOptions _options;
19      readonly CancellationToken _baseCancellationToken;
20      readonly NpgsqlLogSequenceNumber? _walLocation;
21      #region Cached logical streaming replication protocol messages
22      readonly BeginMessage _beginMessage = new();
23      readonly LogicalDecodingMessage _logicalDecodingMessage = new();
24      readonly CommitMessage _commitMessage = new();
25      readonly OriginMessage _originMessage = new();
26      readonly Dictionary<uint, RelationMessage> _relations = new();
27      readonly TypeMessage _typeMessage = new();
28      readonly InsertMessage _insertMessage;
29      readonly DefaultUpdateMessage _defaultUpdateMessage;
30      readonly FullUpdateMessage _fullUpdateMessage;
31      readonly IndexUpdateMessage _indexUpdateMessage;
32      readonly FullDeleteMessage _fullDeleteMessage;
33      readonly KeyDeleteMessage _keyDeleteMessage;
34      readonly TruncateMessage _truncateMessage = new();
35      readonly ReadOnlyArrayBuffer<RelationMessage> _truncateMessageRelations = new();
36      readonly StreamStartMessage _streamStartMessage = new();
37      readonly StreamStopMessage _streamStopMessage = new();
38      readonly StreamCommitMessage _streamCommitMessage = new();
39      readonly StreamAbortMessage _streamAbortMessage = new();
40      readonly BeginPrepareMessage _beginPrepareMessage = new();
41      readonly PrepareMessage _prepareMessage = new();
42      readonly CommitPreparedMessage _commitPreparedMessage = new();
43      readonly RollbackPreparedMessage _rollbackPreparedMessage = new();
44      readonly StreamPrepareMessage _streamPrepareMessage = new();
45      #endregion
46      internal PgOutputAsyncEnumerable(
47          LogicalReplicationConnection connection,
48          PgOutputReplicationSlot slot,
49          PgOutputReplicationOptions options,
50          CancellationToken cancellationToken,
51          NpgsqlLogSequenceNumber? walLocation = null)
52      {
53          _connection = connection;
54          _slot = slot;
55          _options = options;
56          _baseCancellationToken = cancellationToken;
57          _walLocation = walLocation;
58          var connector = _connection.Connector;
59          _insertMessage = new(connector);
60          _defaultUpdateMessage = new(connector);
61          _fullUpdateMessage = new(connector);
62          _indexUpdateMessage = new(connector);
63          _fullDeleteMessage = new(connector);
64          _keyDeleteMessage = new(connector);
65      }
66      public IAsyncEnumerator<PgOutputReplicationMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
67      {
68          using (NoSynchronizationContextScope.Enter())
69          {
70              return StartReplicationInternal(
71                  CancellationTokenSource.CreateLinkedTokenSource(_baseCancellationToken, cancellationToken).Token);
72          }
73      }
74      async IAsyncEnumerator<PgOutputReplicationMessage> StartReplicationInternal(CancellationToken cancellationToken)
75      {
76          var stream = _connection.StartLogicalReplication(
77              _slot, cancellationToken, _walLocation, _options.GetOptionPairs(), bypassingStream: true);
78          var buf = _connection.Connector!.ReadBuffer;
79          var inStreamingTransaction = false;
80          var formatCode = _options.Binary ?? false ? FormatCode.Binary : FormatCode.Text;
81          await foreach (var xLogData in stream.WithCancellation(cancellationToken))
82          {
83              await buf.EnsureAsync(1);
84              var messageCode = (BackendReplicationMessageCode)buf.ReadByte();
85              switch (messageCode)
86              {
87              case BackendReplicationMessageCode.Begin:
88              {
89                  await buf.EnsureAsync(20);
90                  yield return _beginMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
91                      transactionFinalLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
92                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
93                      transactionXid: buf.ReadUInt32());
94                  continue;
95              }
96              case BackendReplicationMessageCode.Message:
97              {
98                  uint? transactionXid;
99                  if (inStreamingTransaction)
100                  {
101                      await buf.EnsureAsync(14);
102                      transactionXid = buf.ReadUInt32();
103                  }
104                  else
105                  {
106                      await buf.EnsureAsync(10);
107                      transactionXid = null;
108                  }
109                  var flags = buf.ReadByte();
110                  var messageLsn = new NpgsqlLogSequenceNumber(buf.ReadUInt64());
111                  var prefix = await buf.ReadNullTerminatedString(async: true, cancellationToken);
112                  await buf.EnsureAsync(4);
113                  var length = buf.ReadUInt32();
114                  var data = (NpgsqlReadBuffer.ColumnStream)xLogData.Data;
115                  data.Init(checked((int)length), false);
116                  yield return _logicalDecodingMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
117                      flags, messageLsn, prefix, data);
118                  continue;
119              }
120              case BackendReplicationMessageCode.Commit:
121              {
122                  await buf.EnsureAsync(25);
123                  yield return _commitMessage.Populate(
124                      xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
125                      (CommitMessage.CommitFlags)buf.ReadByte(),
126                      commitLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
127                      transactionEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
128                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc));
129                  continue;
130              }
131              case BackendReplicationMessageCode.Origin:
132              {
133                  await buf.EnsureAsync(9);
134                  yield return _originMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
135                      originCommitLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
136                      originName: await buf.ReadNullTerminatedString(async: true, cancellationToken));
137                  continue;
138              }
139              case BackendReplicationMessageCode.Relation:
140              {
141                  uint? transactionXid;
142                  if (inStreamingTransaction)
143                  {
144                      await buf.EnsureAsync(10);
145                      transactionXid = buf.ReadUInt32();
146                  }
147                  else
148                  {
149                      await buf.EnsureAsync(6);
150                      transactionXid = null;
151                  }
152                  var relationId = buf.ReadUInt32();
153                  var ns = await buf.ReadNullTerminatedString(async: true, cancellationToken);
154                  var relationName = await buf.ReadNullTerminatedString(async: true, cancellationToken);
155                  await buf.EnsureAsync(3);
156                  var relationReplicaIdentitySetting = (RelationMessage.ReplicaIdentitySetting)buf.ReadByte();
157                  var numColumns = buf.ReadUInt16();
158                  if (!_relations.TryGetValue(relationId, out var msg))
159                      msg = _relations[relationId] = new RelationMessage();
160                  msg.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid, relationId, ns, relationName,
161                      relationReplicaIdentitySetting);
162                  var columns = msg.InternalColumns;
163                  columns.Count = numColumns;
164                  for (var i = 0; i < numColumns; i++)
165                  {
166                      await buf.EnsureAsync(2);
167                      var flags = (RelationMessage.Column.ColumnFlags)buf.ReadByte();
168                      var columnName = await buf.ReadNullTerminatedString(async: true, cancellationToken);
169                      await buf.EnsureAsync(8);
170                      var dateTypeId = buf.ReadUInt32();
171                      var typeModifier = buf.ReadInt32();
172                      columns[i] = new RelationMessage.Column(flags, columnName, dateTypeId, typeModifier);
173                  }
174                  msg.RowDescription = RowDescriptionMessage.CreateForReplication(
175                      _connection.Connector.TypeMapper, relationId, formatCode, columns);
176                  yield return msg;
177                  continue;
178              }
179              case BackendReplicationMessageCode.Type:
180              {
181                  uint? transactionXid;
182                  if (inStreamingTransaction)
183                  {
184                      await buf.EnsureAsync(9);
185                      transactionXid = buf.ReadUInt32();
186                  }
187                  else
188                  {
189                      await buf.EnsureAsync(5);
190                      transactionXid = null;
191                  }
192                  var typeId = buf.ReadUInt32();
193                  var ns = await buf.ReadNullTerminatedString(async: true, cancellationToken);
194                  var name = await buf.ReadNullTerminatedString(async: true, cancellationToken);
195                  yield return _typeMessage.Populate(
196                      xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid, typeId, ns, name);
197                  continue;
198              }
199              case BackendReplicationMessageCode.Insert:
200              {
201                  uint? transactionXid;
202                  if (inStreamingTransaction)
203                  {
204                      await buf.EnsureAsync(11);
205                      transactionXid = buf.ReadUInt32();
206                  }
207                  else
208                  {
209                      await buf.EnsureAsync(7);
210                      transactionXid = null;
211                  }
212                  var relationId = buf.ReadUInt32();
213                  var tupleDataType = (TupleType)buf.ReadByte();
214                  Debug.Assert(tupleDataType == TupleType.NewTuple);
215                  var numColumns = buf.ReadUInt16();
216                  if (!_relations.TryGetValue(relationId, out var relation))
217                  {
218                      throw new InvalidOperationException(
219                          $"Could not find previous Relation message for relation ID {relationId} when processing Insert message");
220                  }
221                  Debug.Assert(numColumns == relation.RowDescription.Count);
222                  yield return _insertMessage.Populate(
223                      xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid, relation, numColumns);
224                  await _insertMessage.Consume(cancellationToken);
225                  continue;
226              }
227              case BackendReplicationMessageCode.Update:
228              {
229                  uint? transactionXid;
230                  if (inStreamingTransaction)
231                  {
232                      await buf.EnsureAsync(11);
233                      transactionXid = buf.ReadUInt32();
234                  }
235                  else
236                  {
237                      await buf.EnsureAsync(7);
238                      transactionXid = null;
239                  }
240                  var relationId = buf.ReadUInt32();
241                  var tupleType = (TupleType)buf.ReadByte();
242                  var numColumns = buf.ReadUInt16();
243                  if (!_relations.TryGetValue(relationId, out var relation))
244                  {
245                      throw new InvalidOperationException(
246                          $"Could not find previous Relation message for relation ID {relationId} when processing Update message");
247                  }
248                  Debug.Assert(numColumns == relation.RowDescription.Count);
249                  switch (tupleType)
250                  {
251                  case TupleType.Key:
252                      yield return _indexUpdateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
253                          relation, numColumns);
254                      await _indexUpdateMessage.Consume(cancellationToken);
255                      continue;
256                  case TupleType.OldTuple:
257                      yield return _fullUpdateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
258                          relation, numColumns);
259                      await _fullUpdateMessage.Consume(cancellationToken);
260                      continue;
261                  case TupleType.NewTuple:
262                      yield return _defaultUpdateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
263                          relation, numColumns);
264                      await _defaultUpdateMessage.Consume(cancellationToken);
265                      continue;
266                  default:
267                      throw new NotSupportedException($"The tuple type '{tupleType}' is not supported.");
268                  }
269              }
270              case BackendReplicationMessageCode.Delete:
271              {
272                  uint? transactionXid;
273                  if (inStreamingTransaction)
274                  {
275                      await buf.EnsureAsync(11);
276                      transactionXid = buf.ReadUInt32();
277                  }
278                  else
279                  {
280                      await buf.EnsureAsync(7);
281                      transactionXid = null;
282                  }
283                  var relationId = buf.ReadUInt32();
284                  var tupleDataType = (TupleType)buf.ReadByte();
285                  var numColumns = buf.ReadUInt16();
286                  if (!_relations.TryGetValue(relationId, out var relation))
287                  {
288                      throw new InvalidOperationException(
289                          $"Could not find previous Relation message for relation ID {relationId} when processing Update message");
290                  }
291                  Debug.Assert(numColumns == relation.RowDescription.Count);
292                  switch (tupleDataType)
293                  {
294                  case TupleType.Key:
295                      yield return _keyDeleteMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
296                          relation, numColumns);
297                      await _keyDeleteMessage.Consume(cancellationToken);
298                      continue;
299                  case TupleType.OldTuple:
300                      yield return _fullDeleteMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
301                          relation, numColumns);
302                      await _fullDeleteMessage.Consume(cancellationToken);
303                      continue;
304                  default:
305                      throw new NotSupportedException($"The tuple type '{tupleDataType}' is not supported.");
306                  }
307              }
308              case BackendReplicationMessageCode.Truncate:
309              {
310                  uint? transactionXid;
311                  if (inStreamingTransaction)
312                  {
313                      await buf.EnsureAsync(9);
314                      transactionXid = buf.ReadUInt32();
315                  }
316                  else
317                  {
<span onclick='openModal()' class='match'>318                      await buf.EnsureAsync(5);
319                      transactionXid = null;
320                  }
321                  var numRels = checked((int)buf.ReadUInt32());
</span>322                  var truncateOptions = (TruncateMessage.TruncateOptions)buf.ReadByte();
323                  _truncateMessageRelations.Count = numRels;
324                  for (var i = 0; i < numRels; i++)
325                  {
326                      await buf.EnsureAsync(4);
327                      var relationId = buf.ReadUInt32();
328                      if (!_relations.TryGetValue(relationId, out var relation))
329                      {
330                          throw new InvalidOperationException(
331                              $"Could not find previous Relation message for relation ID {relationId} when processing Update message");
332                      }
333                      _truncateMessageRelations[i] = relation;
334                  }
335                  yield return _truncateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
336                      truncateOptions, _truncateMessageRelations);
337                  continue;
338              }
339              case BackendReplicationMessageCode.StreamStart:
340              {
341                  await buf.EnsureAsync(5);
342                  inStreamingTransaction = true;
343                  yield return _streamStartMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
344                      transactionXid: buf.ReadUInt32(), streamSegmentIndicator: buf.ReadByte());
345                  continue;
346              }
347              case BackendReplicationMessageCode.StreamStop:
348              {
349                  inStreamingTransaction = false;
350                  yield return _streamStopMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock);
351                  continue;
352              }
353              case BackendReplicationMessageCode.StreamCommit:
354              {
355                  await buf.EnsureAsync(29);
356                  yield return _streamCommitMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
357                      transactionXid: buf.ReadUInt32(), flags: buf.ReadByte(), commitLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
358                      transactionEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
359                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc));
360                  continue;
361              }
362              case BackendReplicationMessageCode.StreamAbort:
363              {
364                  await buf.EnsureAsync(8);
365                  yield return _streamAbortMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
366                      transactionXid: buf.ReadUInt32(), subtransactionXid: buf.ReadUInt32());
367                  continue;
368              }
369              case BackendReplicationMessageCode.BeginPrepare:
370              {
371                  await buf.EnsureAsync(29);
372                  yield return _beginPrepareMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
373                      prepareLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
374                      prepareEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
375                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
376                      transactionXid: buf.ReadUInt32(),
377                      transactionGid: buf.ReadNullTerminatedString());
378                  continue;
379              }
380              case BackendReplicationMessageCode.Prepare:
381              {
382                  await buf.EnsureAsync(30);
383                  yield return _prepareMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
384                      flags: (PrepareMessage.PrepareFlags)buf.ReadByte(),
385                      prepareLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
386                      prepareEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
387                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
388                      transactionXid: buf.ReadUInt32(),
389                      transactionGid: buf.ReadNullTerminatedString());
390                  continue;
391              }
392              case BackendReplicationMessageCode.CommitPrepared:
393              {
394                  await buf.EnsureAsync(30);
395                  yield return _commitPreparedMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
396                      flags: (CommitPreparedMessage.CommitPreparedFlags)buf.ReadByte(),
397                      commitPreparedLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
398                      commitPreparedEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
399                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
400                      transactionXid: buf.ReadUInt32(),
401                      transactionGid: buf.ReadNullTerminatedString());
402                  continue;
403              }
404              case BackendReplicationMessageCode.RollbackPrepared:
405              {
406                  await buf.EnsureAsync(38);
407                  yield return _rollbackPreparedMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
408                      flags: (RollbackPreparedMessage.RollbackPreparedFlags)buf.ReadByte(),
409                      preparedTransactionEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
410                      rollbackPreparedEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
411                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
412                      transactionRollbackTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
413                      transactionXid: buf.ReadUInt32(),
414                      transactionGid: buf.ReadNullTerminatedString());
415                  continue;
416              }
417              case BackendReplicationMessageCode.StreamPrepare:
418              {
419                  await buf.EnsureAsync(30);
420                  yield return _streamPrepareMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
421                      flags: (StreamPrepareMessage.StreamPrepareFlags)buf.ReadByte(),
422                      prepareLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
423                      prepareEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
424                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
425                      transactionXid: buf.ReadUInt32(),
426                      transactionGid: buf.ReadNullTerminatedString());
427                  continue;
428              }
429              default:
430                  throw new NotSupportedException(
431                      $"Invalid message code {messageCode} in Logical Replication Protocol.");
432              }
433          }
434      }
435      enum BackendReplicationMessageCode : byte
436      {
437          Begin = (byte)'B',
438          Message = (byte)'M',
439          Commit = (byte)'C',
440          Origin = (byte)'O',
441          Relation = (byte)'R',
442          Type = (byte)'Y',
443          Insert = (byte)'I',
444          Update = (byte)'U',
445          Delete = (byte)'D',
446          Truncate = (byte)'T',
447          StreamStart = (byte)'S',
448          StreamStop = (byte)'E',
449          StreamCommit = (byte)'c',
450          StreamAbort = (byte)'A',
451          BeginPrepare = (byte)'b',
452          Prepare = (byte)'P',
453          CommitPrepared = (byte)'K',
454          RollbackPrepared = (byte)'r',
455          StreamPrepare = (byte)'p',
456      }
457  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputAsyncEnumerable.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Npgsql.BackendMessages;
7  using Npgsql.Internal;
8  using Npgsql.Internal.TypeHandlers.DateTimeHandlers;
9  using Npgsql.Replication.Internal;
10  using Npgsql.Replication.PgOutput.Messages;
11  using Npgsql.Util;
12  using NpgsqlTypes;
13  namespace Npgsql.Replication.PgOutput;
14  sealed class PgOutputAsyncEnumerable : IAsyncEnumerable<PgOutputReplicationMessage>
15  {
16      readonly LogicalReplicationConnection _connection;
17      readonly PgOutputReplicationSlot _slot;
18      readonly PgOutputReplicationOptions _options;
19      readonly CancellationToken _baseCancellationToken;
20      readonly NpgsqlLogSequenceNumber? _walLocation;
21      #region Cached logical streaming replication protocol messages
22      readonly BeginMessage _beginMessage = new();
23      readonly LogicalDecodingMessage _logicalDecodingMessage = new();
24      readonly CommitMessage _commitMessage = new();
25      readonly OriginMessage _originMessage = new();
26      readonly Dictionary<uint, RelationMessage> _relations = new();
27      readonly TypeMessage _typeMessage = new();
28      readonly InsertMessage _insertMessage;
29      readonly DefaultUpdateMessage _defaultUpdateMessage;
30      readonly FullUpdateMessage _fullUpdateMessage;
31      readonly IndexUpdateMessage _indexUpdateMessage;
32      readonly FullDeleteMessage _fullDeleteMessage;
33      readonly KeyDeleteMessage _keyDeleteMessage;
34      readonly TruncateMessage _truncateMessage = new();
35      readonly ReadOnlyArrayBuffer<RelationMessage> _truncateMessageRelations = new();
36      readonly StreamStartMessage _streamStartMessage = new();
37      readonly StreamStopMessage _streamStopMessage = new();
38      readonly StreamCommitMessage _streamCommitMessage = new();
39      readonly StreamAbortMessage _streamAbortMessage = new();
40      readonly BeginPrepareMessage _beginPrepareMessage = new();
41      readonly PrepareMessage _prepareMessage = new();
42      readonly CommitPreparedMessage _commitPreparedMessage = new();
43      readonly RollbackPreparedMessage _rollbackPreparedMessage = new();
44      readonly StreamPrepareMessage _streamPrepareMessage = new();
45      #endregion
46      internal PgOutputAsyncEnumerable(
47          LogicalReplicationConnection connection,
48          PgOutputReplicationSlot slot,
49          PgOutputReplicationOptions options,
50          CancellationToken cancellationToken,
51          NpgsqlLogSequenceNumber? walLocation = null)
52      {
53          _connection = connection;
54          _slot = slot;
55          _options = options;
56          _baseCancellationToken = cancellationToken;
57          _walLocation = walLocation;
58          var connector = _connection.Connector;
59          _insertMessage = new(connector);
60          _defaultUpdateMessage = new(connector);
61          _fullUpdateMessage = new(connector);
62          _indexUpdateMessage = new(connector);
63          _fullDeleteMessage = new(connector);
64          _keyDeleteMessage = new(connector);
65      }
66      public IAsyncEnumerator<PgOutputReplicationMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
67      {
68          using (NoSynchronizationContextScope.Enter())
69          {
70              return StartReplicationInternal(
71                  CancellationTokenSource.CreateLinkedTokenSource(_baseCancellationToken, cancellationToken).Token);
72          }
73      }
74      async IAsyncEnumerator<PgOutputReplicationMessage> StartReplicationInternal(CancellationToken cancellationToken)
75      {
76          var stream = _connection.StartLogicalReplication(
77              _slot, cancellationToken, _walLocation, _options.GetOptionPairs(), bypassingStream: true);
78          var buf = _connection.Connector!.ReadBuffer;
79          var inStreamingTransaction = false;
80          var formatCode = _options.Binary ?? false ? FormatCode.Binary : FormatCode.Text;
81          await foreach (var xLogData in stream.WithCancellation(cancellationToken))
82          {
83              await buf.EnsureAsync(1);
84              var messageCode = (BackendReplicationMessageCode)buf.ReadByte();
85              switch (messageCode)
86              {
87              case BackendReplicationMessageCode.Begin:
88              {
89                  await buf.EnsureAsync(20);
90                  yield return _beginMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
91                      transactionFinalLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
92                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
93                      transactionXid: buf.ReadUInt32());
94                  continue;
95              }
96              case BackendReplicationMessageCode.Message:
97              {
98                  uint? transactionXid;
99                  if (inStreamingTransaction)
100                  {
101                      await buf.EnsureAsync(14);
102                      transactionXid = buf.ReadUInt32();
103                  }
104                  else
105                  {
106                      await buf.EnsureAsync(10);
107                      transactionXid = null;
108                  }
109                  var flags = buf.ReadByte();
110                  var messageLsn = new NpgsqlLogSequenceNumber(buf.ReadUInt64());
111                  var prefix = await buf.ReadNullTerminatedString(async: true, cancellationToken);
112                  await buf.EnsureAsync(4);
113                  var length = buf.ReadUInt32();
114                  var data = (NpgsqlReadBuffer.ColumnStream)xLogData.Data;
115                  data.Init(checked((int)length), false);
116                  yield return _logicalDecodingMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
117                      flags, messageLsn, prefix, data);
118                  continue;
119              }
120              case BackendReplicationMessageCode.Commit:
121              {
122                  await buf.EnsureAsync(25);
123                  yield return _commitMessage.Populate(
124                      xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
125                      (CommitMessage.CommitFlags)buf.ReadByte(),
126                      commitLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
127                      transactionEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
128                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc));
129                  continue;
130              }
131              case BackendReplicationMessageCode.Origin:
132              {
133                  await buf.EnsureAsync(9);
134                  yield return _originMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
135                      originCommitLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
136                      originName: await buf.ReadNullTerminatedString(async: true, cancellationToken));
137                  continue;
138              }
139              case BackendReplicationMessageCode.Relation:
140              {
141                  uint? transactionXid;
142                  if (inStreamingTransaction)
143                  {
144                      await buf.EnsureAsync(10);
145                      transactionXid = buf.ReadUInt32();
146                  }
147                  else
148                  {
149                      await buf.EnsureAsync(6);
150                      transactionXid = null;
151                  }
152                  var relationId = buf.ReadUInt32();
153                  var ns = await buf.ReadNullTerminatedString(async: true, cancellationToken);
154                  var relationName = await buf.ReadNullTerminatedString(async: true, cancellationToken);
155                  await buf.EnsureAsync(3);
156                  var relationReplicaIdentitySetting = (RelationMessage.ReplicaIdentitySetting)buf.ReadByte();
157                  var numColumns = buf.ReadUInt16();
158                  if (!_relations.TryGetValue(relationId, out var msg))
159                      msg = _relations[relationId] = new RelationMessage();
160                  msg.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid, relationId, ns, relationName,
161                      relationReplicaIdentitySetting);
162                  var columns = msg.InternalColumns;
163                  columns.Count = numColumns;
164                  for (var i = 0; i < numColumns; i++)
165                  {
166                      await buf.EnsureAsync(2);
167                      var flags = (RelationMessage.Column.ColumnFlags)buf.ReadByte();
168                      var columnName = await buf.ReadNullTerminatedString(async: true, cancellationToken);
169                      await buf.EnsureAsync(8);
170                      var dateTypeId = buf.ReadUInt32();
171                      var typeModifier = buf.ReadInt32();
172                      columns[i] = new RelationMessage.Column(flags, columnName, dateTypeId, typeModifier);
173                  }
174                  msg.RowDescription = RowDescriptionMessage.CreateForReplication(
175                      _connection.Connector.TypeMapper, relationId, formatCode, columns);
176                  yield return msg;
177                  continue;
178              }
179              case BackendReplicationMessageCode.Type:
180              {
181                  uint? transactionXid;
182                  if (inStreamingTransaction)
183                  {
184                      await buf.EnsureAsync(9);
185                      transactionXid = buf.ReadUInt32();
186                  }
187                  else
188                  {
189                      await buf.EnsureAsync(5);
190                      transactionXid = null;
191                  }
192                  var typeId = buf.ReadUInt32();
193                  var ns = await buf.ReadNullTerminatedString(async: true, cancellationToken);
194                  var name = await buf.ReadNullTerminatedString(async: true, cancellationToken);
195                  yield return _typeMessage.Populate(
196                      xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid, typeId, ns, name);
197                  continue;
198              }
199              case BackendReplicationMessageCode.Insert:
200              {
201                  uint? transactionXid;
202                  if (inStreamingTransaction)
203                  {
204                      await buf.EnsureAsync(11);
205                      transactionXid = buf.ReadUInt32();
206                  }
207                  else
208                  {
209                      await buf.EnsureAsync(7);
210                      transactionXid = null;
211                  }
212                  var relationId = buf.ReadUInt32();
213                  var tupleDataType = (TupleType)buf.ReadByte();
214                  Debug.Assert(tupleDataType == TupleType.NewTuple);
215                  var numColumns = buf.ReadUInt16();
216                  if (!_relations.TryGetValue(relationId, out var relation))
217                  {
218                      throw new InvalidOperationException(
219                          $"Could not find previous Relation message for relation ID {relationId} when processing Insert message");
220                  }
221                  Debug.Assert(numColumns == relation.RowDescription.Count);
222                  yield return _insertMessage.Populate(
223                      xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid, relation, numColumns);
224                  await _insertMessage.Consume(cancellationToken);
225                  continue;
226              }
227              case BackendReplicationMessageCode.Update:
228              {
229                  uint? transactionXid;
230                  if (inStreamingTransaction)
231                  {
232                      await buf.EnsureAsync(11);
233                      transactionXid = buf.ReadUInt32();
234                  }
235                  else
236                  {
237                      await buf.EnsureAsync(7);
238                      transactionXid = null;
239                  }
240                  var relationId = buf.ReadUInt32();
241                  var tupleType = (TupleType)buf.ReadByte();
242                  var numColumns = buf.ReadUInt16();
243                  if (!_relations.TryGetValue(relationId, out var relation))
244                  {
245                      throw new InvalidOperationException(
246                          $"Could not find previous Relation message for relation ID {relationId} when processing Update message");
247                  }
248                  Debug.Assert(numColumns == relation.RowDescription.Count);
249                  switch (tupleType)
250                  {
251                  case TupleType.Key:
252                      yield return _indexUpdateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
253                          relation, numColumns);
254                      await _indexUpdateMessage.Consume(cancellationToken);
255                      continue;
256                  case TupleType.OldTuple:
257                      yield return _fullUpdateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
258                          relation, numColumns);
259                      await _fullUpdateMessage.Consume(cancellationToken);
260                      continue;
261                  case TupleType.NewTuple:
262                      yield return _defaultUpdateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
263                          relation, numColumns);
264                      await _defaultUpdateMessage.Consume(cancellationToken);
265                      continue;
266                  default:
267                      throw new NotSupportedException($"The tuple type '{tupleType}' is not supported.");
268                  }
269              }
270              case BackendReplicationMessageCode.Delete:
271              {
272                  uint? transactionXid;
273                  if (inStreamingTransaction)
274                  {
275                      await buf.EnsureAsync(11);
276                      transactionXid = buf.ReadUInt32();
277                  }
278                  else
279                  {
<span onclick='openModal()' class='match'>280                      await buf.EnsureAsync(7);
281                      transactionXid = null;
282                  }
283                  var relationId = buf.ReadUInt32();
</span>284                  var tupleDataType = (TupleType)buf.ReadByte();
285                  var numColumns = buf.ReadUInt16();
286                  if (!_relations.TryGetValue(relationId, out var relation))
287                  {
288                      throw new InvalidOperationException(
289                          $"Could not find previous Relation message for relation ID {relationId} when processing Update message");
290                  }
291                  Debug.Assert(numColumns == relation.RowDescription.Count);
292                  switch (tupleDataType)
293                  {
294                  case TupleType.Key:
295                      yield return _keyDeleteMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
296                          relation, numColumns);
297                      await _keyDeleteMessage.Consume(cancellationToken);
298                      continue;
299                  case TupleType.OldTuple:
300                      yield return _fullDeleteMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
301                          relation, numColumns);
302                      await _fullDeleteMessage.Consume(cancellationToken);
303                      continue;
304                  default:
305                      throw new NotSupportedException($"The tuple type '{tupleDataType}' is not supported.");
306                  }
307              }
308              case BackendReplicationMessageCode.Truncate:
309              {
310                  uint? transactionXid;
311                  if (inStreamingTransaction)
312                  {
313                      await buf.EnsureAsync(9);
314                      transactionXid = buf.ReadUInt32();
315                  }
316                  else
317                  {
318                      await buf.EnsureAsync(5);
319                      transactionXid = null;
320                  }
321                  var numRels = checked((int)buf.ReadUInt32());
322                  var truncateOptions = (TruncateMessage.TruncateOptions)buf.ReadByte();
323                  _truncateMessageRelations.Count = numRels;
324                  for (var i = 0; i < numRels; i++)
325                  {
326                      await buf.EnsureAsync(4);
327                      var relationId = buf.ReadUInt32();
328                      if (!_relations.TryGetValue(relationId, out var relation))
329                      {
330                          throw new InvalidOperationException(
331                              $"Could not find previous Relation message for relation ID {relationId} when processing Update message");
332                      }
333                      _truncateMessageRelations[i] = relation;
334                  }
335                  yield return _truncateMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock, transactionXid,
336                      truncateOptions, _truncateMessageRelations);
337                  continue;
338              }
339              case BackendReplicationMessageCode.StreamStart:
340              {
341                  await buf.EnsureAsync(5);
342                  inStreamingTransaction = true;
343                  yield return _streamStartMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
344                      transactionXid: buf.ReadUInt32(), streamSegmentIndicator: buf.ReadByte());
345                  continue;
346              }
347              case BackendReplicationMessageCode.StreamStop:
348              {
349                  inStreamingTransaction = false;
350                  yield return _streamStopMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock);
351                  continue;
352              }
353              case BackendReplicationMessageCode.StreamCommit:
354              {
355                  await buf.EnsureAsync(29);
356                  yield return _streamCommitMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
357                      transactionXid: buf.ReadUInt32(), flags: buf.ReadByte(), commitLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
358                      transactionEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
359                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc));
360                  continue;
361              }
362              case BackendReplicationMessageCode.StreamAbort:
363              {
364                  await buf.EnsureAsync(8);
365                  yield return _streamAbortMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
366                      transactionXid: buf.ReadUInt32(), subtransactionXid: buf.ReadUInt32());
367                  continue;
368              }
369              case BackendReplicationMessageCode.BeginPrepare:
370              {
371                  await buf.EnsureAsync(29);
372                  yield return _beginPrepareMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
373                      prepareLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
374                      prepareEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
375                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
376                      transactionXid: buf.ReadUInt32(),
377                      transactionGid: buf.ReadNullTerminatedString());
378                  continue;
379              }
380              case BackendReplicationMessageCode.Prepare:
381              {
382                  await buf.EnsureAsync(30);
383                  yield return _prepareMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
384                      flags: (PrepareMessage.PrepareFlags)buf.ReadByte(),
385                      prepareLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
386                      prepareEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
387                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
388                      transactionXid: buf.ReadUInt32(),
389                      transactionGid: buf.ReadNullTerminatedString());
390                  continue;
391              }
392              case BackendReplicationMessageCode.CommitPrepared:
393              {
394                  await buf.EnsureAsync(30);
395                  yield return _commitPreparedMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
396                      flags: (CommitPreparedMessage.CommitPreparedFlags)buf.ReadByte(),
397                      commitPreparedLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
398                      commitPreparedEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
399                      transactionCommitTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
400                      transactionXid: buf.ReadUInt32(),
401                      transactionGid: buf.ReadNullTerminatedString());
402                  continue;
403              }
404              case BackendReplicationMessageCode.RollbackPrepared:
405              {
406                  await buf.EnsureAsync(38);
407                  yield return _rollbackPreparedMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
408                      flags: (RollbackPreparedMessage.RollbackPreparedFlags)buf.ReadByte(),
409                      preparedTransactionEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
410                      rollbackPreparedEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
411                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
412                      transactionRollbackTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
413                      transactionXid: buf.ReadUInt32(),
414                      transactionGid: buf.ReadNullTerminatedString());
415                  continue;
416              }
417              case BackendReplicationMessageCode.StreamPrepare:
418              {
419                  await buf.EnsureAsync(30);
420                  yield return _streamPrepareMessage.Populate(xLogData.WalStart, xLogData.WalEnd, xLogData.ServerClock,
421                      flags: (StreamPrepareMessage.StreamPrepareFlags)buf.ReadByte(),
422                      prepareLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
423                      prepareEndLsn: new NpgsqlLogSequenceNumber(buf.ReadUInt64()),
424                      transactionPrepareTimestamp: DateTimeUtils.DecodeTimestamp(buf.ReadInt64(), DateTimeKind.Utc),
425                      transactionXid: buf.ReadUInt32(),
426                      transactionGid: buf.ReadNullTerminatedString());
427                  continue;
428              }
429              default:
430                  throw new NotSupportedException(
431                      $"Invalid message code {messageCode} in Logical Replication Protocol.");
432              }
433          }
434      }
435      enum BackendReplicationMessageCode : byte
436      {
437          Begin = (byte)'B',
438          Message = (byte)'M',
439          Commit = (byte)'C',
440          Origin = (byte)'O',
441          Relation = (byte)'R',
442          Type = (byte)'Y',
443          Insert = (byte)'I',
444          Update = (byte)'U',
445          Delete = (byte)'D',
446          Truncate = (byte)'T',
447          StreamStart = (byte)'S',
448          StreamStop = (byte)'E',
449          StreamCommit = (byte)'c',
450          StreamAbort = (byte)'A',
451          BeginPrepare = (byte)'b',
452          Prepare = (byte)'P',
453          CommitPrepared = (byte)'K',
454          RollbackPrepared = (byte)'r',
455          StreamPrepare = (byte)'p',
456      }
457  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputAsyncEnumerable.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputAsyncEnumerable.cs</div>
                </div>
                <div class="column column_space"><pre><code>318                      await buf.EnsureAsync(5);
319                      transactionXid = null;
320                  }
321                  var numRels = checked((int)buf.ReadUInt32());
</pre></code></div>
                <div class="column column_space"><pre><code>280                      await buf.EnsureAsync(7);
281                      transactionXid = null;
282                  }
283                  var relationId = buf.ReadUInt32();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    