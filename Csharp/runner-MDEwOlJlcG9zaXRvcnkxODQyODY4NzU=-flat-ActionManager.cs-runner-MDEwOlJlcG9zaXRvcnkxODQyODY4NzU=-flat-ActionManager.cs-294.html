
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.IO.Compression;
5  using System.Linq;
6  using System.Net;
7  using System.Net.Http;
8  using System.Net.Http.Headers;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using GitHub.DistributedTask.ObjectTemplating.Tokens;
13  using GitHub.Runner.Common;
14  using GitHub.Runner.Common.Util;
15  using GitHub.Runner.Sdk;
16  using GitHub.Runner.Worker.Container;
17  using GitHub.Services.Common;
18  using WebApi = GitHub.DistributedTask.WebApi;
19  using Pipelines = GitHub.DistributedTask.Pipelines;
20  using PipelineTemplateConstants = GitHub.DistributedTask.Pipelines.ObjectTemplating.PipelineTemplateConstants;
21  using GitHub.DistributedTask.WebApi;
22  namespace GitHub.Runner.Worker
23  {
24      public class PrepareResult
25      {
26          public PrepareResult(List&lt;JobExtensionRunner&gt; containerSetupSteps, Dictionary&lt;Guid, IActionRunner&gt; preStepTracker)
27          {
28              this.ContainerSetupSteps = containerSetupSteps;
29              this.PreStepTracker = preStepTracker;
30          }
31          public List&lt;JobExtensionRunner&gt; ContainerSetupSteps { get; set; }
32          public Dictionary&lt;Guid, IActionRunner&gt; PreStepTracker { get; set; }
33      }
34      [ServiceLocator(Default = typeof(ActionManager))]
35      public interface IActionManager : IRunnerService
36      {
37          Dictionary&lt;Guid, ContainerInfo&gt; CachedActionContainers { get; }
38          Dictionary&lt;Guid, List&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPreSteps { get; }
39          Dictionary&lt;Guid, List&lt;Guid&gt;&gt; CachedEmbeddedStepIds { get; }
40          Dictionary&lt;Guid, Stack&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPostSteps { get; }
41          Task&lt;PrepareResult&gt; PrepareActionsAsync(IExecutionContext executionContext, IEnumerable&lt;Pipelines.JobStep&gt; steps, Guid rootStepId = default(Guid));
42          Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action);
43      }
44      public sealed class ActionManager : RunnerService, IActionManager
45      {
46          private const int _defaultFileStreamBufferSize = 4096;
47          private const int _defaultCopyBufferSize = 81920;
48          private const string _dotcomApiUrl = &quot;https:&amp;bsol;&amp;bsol;api.github.com&quot;;
49          private readonly Dictionary&lt;Guid, ContainerInfo&gt; _cachedActionContainers = new();
50          public Dictionary&lt;Guid, ContainerInfo&gt; CachedActionContainers =&gt; _cachedActionContainers;
51          private readonly Dictionary&lt;Guid, List&lt;Pipelines.ActionStep&gt;&gt; _cachedEmbeddedPreSteps = new();
52          public Dictionary&lt;Guid, List&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPreSteps =&gt; _cachedEmbeddedPreSteps;
53          private readonly Dictionary&lt;Guid, List&lt;Guid&gt;&gt; _cachedEmbeddedStepIds = new();
54          public Dictionary&lt;Guid, List&lt;Guid&gt;&gt; CachedEmbeddedStepIds =&gt; _cachedEmbeddedStepIds;
55          private readonly Dictionary&lt;Guid, Stack&lt;Pipelines.ActionStep&gt;&gt; _cachedEmbeddedPostSteps = new();
56          public Dictionary&lt;Guid, Stack&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPostSteps =&gt; _cachedEmbeddedPostSteps;
57          public async Task&lt;PrepareResult&gt; PrepareActionsAsync(IExecutionContext executionContext, IEnumerable&lt;Pipelines.JobStep&gt; steps, Guid rootStepId = default(Guid))
58          {
59              ArgUtil.NotNull(executionContext, nameof(executionContext));
60              ArgUtil.NotNull(steps, nameof(steps));
61              var state = new PrepareActionsState
62              {
63                  ImagesToBuild = new Dictionary&lt;string, List&lt;Guid&gt;&gt;(StringComparer.OrdinalIgnoreCase),
64                  ImagesToPull = new Dictionary&lt;string, List&lt;Guid&gt;&gt;(StringComparer.OrdinalIgnoreCase),
65                  ImagesToBuildInfo = new Dictionary&lt;string, ActionContainer&gt;(StringComparer.OrdinalIgnoreCase),
66                  PreStepTracker = new Dictionary&lt;Guid, IActionRunner&gt;()
67              };
68              var containerSetupSteps = new List&lt;JobExtensionRunner&gt;();
69              var depth = 0;
70              if (rootStepId == default(Guid))
71              {
72                  IOUtil.DeleteDirectory(HostContext.GetDirectory(WellKnownDirectory.Actions), executionContext.CancellationToken);
73              }
74              else
75              {
76                  if (!_cachedEmbeddedStepIds.ContainsKey(rootStepId))
77                  {
78                      _cachedEmbeddedStepIds[rootStepId] = new List&lt;Guid&gt;();
79                      foreach (var compositeStep in steps)
80                      {
81                          var guid = Guid.NewGuid();
82                          compositeStep.Id = guid;
83                          _cachedEmbeddedStepIds[rootStepId].Add(guid);
84                      }
85                  }
86                  depth = 1;
87              }
88              IEnumerable&lt;Pipelines.ActionStep&gt; actions = steps.OfType&lt;Pipelines.ActionStep&gt;();
89              executionContext.Output(&quot;Prepare all required actions&quot;);
90              PrepareActionsState result = new PrepareActionsState();
91              try
92              {
93                  result = await PrepareActionsRecursiveAsync(executionContext, state, actions, depth, rootStepId);
94              }
95              catch (FailedToResolveActionDownloadInfoException ex)
96              {
97                  Trace.Error($&quot;Caught exception from PrepareActionsAsync Initialization: {ex}&quot;);
98                  executionContext.InfrastructureError(ex.Message);
99                  executionContext.Result = TaskResult.Failed;
100                  throw;
101              }
102              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
103              {
104                  if (state.ImagesToPull.Count &gt; 0)
105                  {
106                      foreach (var imageToPull in result.ImagesToPull)
107                      {
108                          Trace.Info($&quot;{imageToPull.Value.Count} steps need to pull image &#x27;{imageToPull.Key}&#x27;&quot;);
109                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.PullActionContainerAsync,
110                                                                      condition: $&quot;{PipelineTemplateConstants.Success}()&quot;,
111                                                                      displayName: $&quot;Pull {imageToPull.Key}&quot;,
112                                                                      data: new ContainerSetupInfo(imageToPull.Value, imageToPull.Key)));
113                      }
114                  }
115                  if (result.ImagesToBuild.Count &gt; 0)
116                  {
117                      foreach (var imageToBuild in result.ImagesToBuild)
118                      {
119                          var setupInfo = result.ImagesToBuildInfo[imageToBuild.Key];
120                          Trace.Info($&quot;{imageToBuild.Value.Count} steps need to build image from &#x27;{setupInfo.Dockerfile}&#x27;&quot;);
121                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.BuildActionContainerAsync,
122                                                                      condition: $&quot;{PipelineTemplateConstants.Success}()&quot;,
123                                                                      displayName: $&quot;Build {setupInfo.ActionRepository}&quot;,
124                                                                      data: new ContainerSetupInfo(imageToBuild.Value, setupInfo.Dockerfile, setupInfo.WorkingDirectory)));
125                      }
126                  }
127  #if !OS_LINUX
128                  if (containerSetupSteps.Count &gt; 0)
129                  {
130                      executionContext.Output(&quot;Container action is only supported on Linux, skip pull and build docker images.&quot;);
131                      containerSetupSteps.Clear();
132                  }
133  #endif
134              }
135              return new PrepareResult(containerSetupSteps, result.PreStepTracker);
136          }
137          private async Task&lt;PrepareActionsState&gt; PrepareActionsRecursiveAsync(IExecutionContext executionContext, PrepareActionsState state, IEnumerable&lt;Pipelines.ActionStep&gt; actions, Int32 depth = 0, Guid parentStepId = default(Guid))
138          {
139              ArgUtil.NotNull(executionContext, nameof(executionContext));
140              if (depth &gt; Constants.CompositeActionsMaxDepth)
141              {
142                  throw new Exception($&quot;Composite action depth exceeded max depth {Constants.CompositeActionsMaxDepth}&quot;);
143              }
144              var repositoryActions = new List&lt;Pipelines.ActionStep&gt;();
145              foreach (var action in actions)
146              {
147                  if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
148                  {
149                      ArgUtil.NotNull(action, nameof(action));
150                      var containerReference = action.Reference as Pipelines.ContainerRegistryReference;
151                      ArgUtil.NotNull(containerReference, nameof(containerReference));
152                      ArgUtil.NotNullOrEmpty(containerReference.Image, nameof(containerReference.Image));
153                      if (!state.ImagesToPull.ContainsKey(containerReference.Image))
154                      {
155                          state.ImagesToPull[containerReference.Image] = new List&lt;Guid&gt;();
156                      }
157                      Trace.Info($&quot;Action {action.Name} ({action.Id}) needs to pull image &#x27;{containerReference.Image}&#x27;&quot;);
158                      state.ImagesToPull[containerReference.Image].Add(action.Id);
159                  }
160                  else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
161                  {
162                      repositoryActions.Add(action);
163                  }
164              }
165              if (repositoryActions.Count &gt; 0)
166              {
167                  var downloadInfos = await GetDownloadInfoAsync(executionContext, repositoryActions);
168                  foreach (var action in repositoryActions)
169                  {
170                      var lookupKey = GetDownloadInfoLookupKey(action);
171                      if (string.IsNullOrEmpty(lookupKey))
172                      {
173                          continue;
174                      }
175                      if (!downloadInfos.TryGetValue(lookupKey, out var downloadInfo))
176                      {
177                          throw new Exception($&quot;Missing download info for {lookupKey}&quot;);
178                      }
179                      await DownloadRepositoryActionAsync(executionContext, downloadInfo);
180                  }
181                  foreach (var action in repositoryActions)
182                  {
183                      var setupInfo = PrepareRepositoryActionAsync(executionContext, action);
184                      if (setupInfo != null &amp;&amp; setupInfo.Container != null)
185                      {
186                          if (!string.IsNullOrEmpty(setupInfo.Container.Image))
187                          {
188                              if (!state.ImagesToPull.ContainsKey(setupInfo.Container.Image))
189                              {
190                                  state.ImagesToPull[setupInfo.Container.Image] = new List&lt;Guid&gt;();
191                              }
192                              Trace.Info($&quot;Action {action.Name} ({action.Id}) from repository &#x27;{setupInfo.Container.ActionRepository}&#x27; needs to pull image &#x27;{setupInfo.Container.Image}&#x27;&quot;);
193                              state.ImagesToPull[setupInfo.Container.Image].Add(action.Id);
194                          }
195                          else
196                          {
197                              ArgUtil.NotNullOrEmpty(setupInfo.Container.ActionRepository, nameof(setupInfo.Container.ActionRepository));
198                              if (!state.ImagesToBuild.ContainsKey(setupInfo.Container.ActionRepository))
199                              {
200                                  state.ImagesToBuild[setupInfo.Container.ActionRepository] = new List&lt;Guid&gt;();
201                              }
202                              Trace.Info($&quot;Action {action.Name} ({action.Id}) from repository &#x27;{setupInfo.Container.ActionRepository}&#x27; needs to build image &#x27;{setupInfo.Container.Dockerfile}&#x27;&quot;);
203                              state.ImagesToBuild[setupInfo.Container.ActionRepository].Add(action.Id);
204                              state.ImagesToBuildInfo[setupInfo.Container.ActionRepository] = setupInfo.Container;
205                          }
206                      }
207                      else if (setupInfo != null &amp;&amp; setupInfo.Steps != null &amp;&amp; setupInfo.Steps.Count &gt; 0)
208                      {
209                          state = await PrepareActionsRecursiveAsync(executionContext, state, setupInfo.Steps, depth + 1, action.Id);
210                      }
211                      var repoAction = action.Reference as Pipelines.RepositoryPathReference;
212                      if (repoAction.RepositoryType != Pipelines.PipelineConstants.SelfAlias)
213                      {
214                          var definition = LoadAction(executionContext, action);
215                          if (definition.Data.Execution.HasPre)
216                          {
217                              Trace.Info($&quot;Add &#x27;pre&#x27; execution for {action.Id}&quot;);
218                              if (depth &lt; 1)
219                              {
220                                  var actionRunner = HostContext.CreateService&lt;IActionRunner&gt;();
221                                  actionRunner.Action = action;
222                                  actionRunner.Stage = ActionRunStage.Pre;
223                                  actionRunner.Condition = definition.Data.Execution.InitCondition;
224                                  state.PreStepTracker[action.Id] = actionRunner;
225                              }
226                              else
227                              {
228                                  if (!_cachedEmbeddedPreSteps.ContainsKey(parentStepId))
229                                  {
230                                      _cachedEmbeddedPreSteps[parentStepId] = new List&lt;Pipelines.ActionStep&gt;();
231                                  }
232                                  var clonedAction = action.Clone() as Pipelines.ActionStep;
233                                  clonedAction.Condition = definition.Data.Execution.InitCondition;
234                                  _cachedEmbeddedPreSteps[parentStepId].Add(clonedAction);
235                              }
236                          }
237                          if (definition.Data.Execution.HasPost &amp;&amp; depth &gt; 0)
238                          {
239                              if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
240                              {
241                                  _cachedEmbeddedPostSteps[parentStepId] = new Stack&lt;Pipelines.ActionStep&gt;();
242                              }
243                              var clonedAction = action.Clone() as Pipelines.ActionStep;
244                              clonedAction.Condition = definition.Data.Execution.CleanupCondition;
245                              _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
246                          }
247                      }
248                      else if (depth &gt; 0)
249                      {
250                          if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
251                          {
252                              _cachedEmbeddedPostSteps[parentStepId] = new Stack&lt;Pipelines.ActionStep&gt;();
253                          }
254                          var clonedAction = action.Clone() as Pipelines.ActionStep;
255                          _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
256                      }
257                  }
258              }
259              return state;
260          }
261          public Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action)
262          {
263              Trace.Entering();
264              ArgUtil.NotNull(action, nameof(action));
265              var definition = new Definition()
266              {
267                  Data = new ActionDefinitionData()
268              };
269              if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
270              {
271                  if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
272                  {
273                      Trace.Info(&quot;Load action that will run container through container hooks.&quot;);
274                      var containerAction = action.Reference as Pipelines.ContainerRegistryReference;
275                      definition.Data.Execution = new ContainerActionExecutionData()
276                      {
277                          Image = containerAction.Image,
278                      };
279                      Trace.Info($&quot;Using action container image: {containerAction.Image}.&quot;);
280                  }
281                  else
282                  {
283                      Trace.Info(&quot;Load action that reference container from registry.&quot;);
284                      CachedActionContainers.TryGetValue(action.Id, out var container);
285                      ArgUtil.NotNull(container, nameof(container));
286                      definition.Data.Execution = new ContainerActionExecutionData()
287                      {
288                          Image = container.ContainerImage
289                      };
290                      Trace.Info($&quot;Using action container image: {container.ContainerImage}.&quot;);
291                  }
292              }
293              else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
294              {
295                  string actionDirectory = null;
296                  var repoAction = action.Reference as Pipelines.RepositoryPathReference;
297                  if (string.Equals(repoAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
298                  {
299                      actionDirectory = executionContext.GetGitHubContext(&quot;workspace&quot;);
300                      if (!string.IsNullOrEmpty(repoAction.Path))
301                      {
302                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
303                      }
304                  }
305                  else
306                  {
307                      actionDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repoAction.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repoAction.Ref);
308                      if (!string.IsNullOrEmpty(repoAction.Path))
309                      {
310                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
311                      }
312                  }
313                  Trace.Info($&quot;Load action that reference repository from &#x27;{actionDirectory}&#x27;&quot;);
314                  definition.Directory = actionDirectory;
315                  string manifestFile = Path.Combine(actionDirectory, Constants.Path.ActionManifestYmlFile);
316                  string manifestFileYaml = Path.Combine(actionDirectory, Constants.Path.ActionManifestYamlFile);
317                  string dockerFile = Path.Combine(actionDirectory, &quot;Dockerfile&quot;);
318                  string dockerFileLowerCase = Path.Combine(actionDirectory, &quot;dockerfile&quot;);
319                  if (File.Exists(manifestFile) || File.Exists(manifestFileYaml))
320                  {
321                      var manifestManager = HostContext.GetService&lt;IActionManifestManager&gt;();
322                      if (File.Exists(manifestFile))
323                      {
324                          definition.Data = manifestManager.Load(executionContext, manifestFile);
325                      }
326                      else
327                      {
328                          definition.Data = manifestManager.Load(executionContext, manifestFileYaml);
329                      }
330                      Trace.Verbose($&quot;Action friendly name: &#x27;{definition.Data.Name}&#x27;&quot;);
331                      Trace.Verbose($&quot;Action description: &#x27;{definition.Data.Description}&#x27;&quot;);
332                      if (definition.Data.Inputs != null)
333                      {
334                          foreach (var input in definition.Data.Inputs)
335                          {
336                              Trace.Verbose($&quot;Action input: &#x27;{input.Key.ToString()}&#x27; default to &#x27;{input.Value.ToString()}&#x27;&quot;);
337                          }
338                      }
339                      if (definition.Data.Execution.ExecutionType == ActionExecutionType.Container)
340                      {
341                          var containerAction = definition.Data.Execution as ContainerActionExecutionData;
342                          Trace.Info($&quot;Action container Dockerfile/image: {containerAction.Image}.&quot;);
343                          if (containerAction.Arguments != null)
344                          {
345                              Trace.Info($&quot;Action container args:  {StringUtil.ConvertToJson(containerAction.Arguments)}.&quot;);
346                          }
347                          if (containerAction.Environment != null)
348                          {
349                              Trace.Info($&quot;Action container env: {StringUtil.ConvertToJson(containerAction.Environment)}.&quot;);
350                          }
351                          if (!string.IsNullOrEmpty(containerAction.Pre))
352                          {
353                              Trace.Info($&quot;Action container pre entrypoint: {containerAction.Pre}.&quot;);
354                          }
355                          if (!string.IsNullOrEmpty(containerAction.EntryPoint))
356                          {
357                              Trace.Info($&quot;Action container entrypoint: {containerAction.EntryPoint}.&quot;);
358                          }
359                          if (!string.IsNullOrEmpty(containerAction.Post))
360                          {
361                              Trace.Info($&quot;Action container post entrypoint: {containerAction.Post}.&quot;);
362                          }
363                          if (CachedActionContainers.TryGetValue(action.Id, out var container))
364                          {
365                              Trace.Info($&quot;Image &#x27;{containerAction.Image}&#x27; already built/pulled, use image: {container.ContainerImage}.&quot;);
366                              containerAction.Image = container.ContainerImage;
367                          }
368                      }
369                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.NodeJS)
370                      {
371                          var nodeAction = definition.Data.Execution as NodeJSActionExecutionData;
372                          Trace.Info($&quot;Action pre node.js file: {nodeAction.Pre ?? &quot;N/A&quot;}.&quot;);
373                          Trace.Info($&quot;Action node.js file: {nodeAction.Script}.&quot;);
374                          Trace.Info($&quot;Action post node.js file: {nodeAction.Post ?? &quot;N/A&quot;}.&quot;);
375                      }
376                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Plugin)
377                      {
378                          var pluginAction = definition.Data.Execution as PluginActionExecutionData;
379                          var pluginManager = HostContext.GetService&lt;IRunnerPluginManager&gt;();
380                          var plugin = pluginManager.GetPluginAction(pluginAction.Plugin);
381                          ArgUtil.NotNull(plugin, pluginAction.Plugin);
382                          ArgUtil.NotNullOrEmpty(plugin.PluginTypeName, pluginAction.Plugin);
383                          pluginAction.Plugin = plugin.PluginTypeName;
384                          Trace.Info($&quot;Action plugin: {plugin.PluginTypeName}.&quot;);
385                          if (!string.IsNullOrEmpty(plugin.PostPluginTypeName))
386                          {
387                              pluginAction.Post = plugin.PostPluginTypeName;
388                              Trace.Info($&quot;Action cleanup plugin: {plugin.PluginTypeName}.&quot;);
389                          }
390                      }
391                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Composite)
392                      {
393                          var compositeAction = definition.Data.Execution as CompositeActionExecutionData;
394                          Trace.Info($&quot;Load {compositeAction.Steps?.Count ?? 0} action steps.&quot;);
395                          Trace.Verbose($&quot;Details: {StringUtil.ConvertToJson(compositeAction?.Steps)}&quot;);
396                          Trace.Info($&quot;Load: {compositeAction.Outputs?.Count ?? 0} number of outputs&quot;);
397                          Trace.Info($&quot;Details: {StringUtil.ConvertToJson(compositeAction?.Outputs)}&quot;);
398                          if (CachedEmbeddedPreSteps.TryGetValue(action.Id, out var preSteps))
399                          {
400                              compositeAction.PreSteps = preSteps;
401                          }
402                          if (CachedEmbeddedPostSteps.TryGetValue(action.Id, out var postSteps))
403                          {
404                              compositeAction.PostSteps = postSteps;
405                          }
406                          if (_cachedEmbeddedStepIds.ContainsKey(action.Id))
407                          {
408                              for (var i = 0; i &lt; compositeAction.Steps.Count; i++)
409                              {
410                                  compositeAction.Steps[i].Id = _cachedEmbeddedStepIds[action.Id][i];
411                                  if (string.IsNullOrEmpty(executionContext.Global.Variables.Get(&quot;DistributedTask.EnableCompositeActions&quot;)) &amp;&amp; compositeAction.Steps[i].Reference.Type != Pipelines.ActionSourceType.Script)
412                                  {
413                                      throw new Exception(&quot;`uses:` keyword is not currently supported.&quot;);
414                                  }
415                              }
416                          }
417                          else
418                          {
419                              _cachedEmbeddedStepIds[action.Id] = new List&lt;Guid&gt;();
420                              foreach (var compositeStep in compositeAction.Steps)
421                              {
422                                  var guid = Guid.NewGuid();
423                                  compositeStep.Id = guid;
424                                  _cachedEmbeddedStepIds[action.Id].Add(guid);
425                              }
426                          }
427                      }
428                      else
429                      {
430                          throw new NotSupportedException(definition.Data.Execution.ExecutionType.ToString());
431                      }
432                  }
433                  else if (File.Exists(dockerFile))
434                  {
435                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
436                      {
437                          definition.Data.Execution = new ContainerActionExecutionData()
438                          {
439                              Image = container.ContainerImage
440                          };
441                      }
442                      else
443                      {
444                          definition.Data.Execution = new ContainerActionExecutionData()
445                          {
446                              Image = dockerFile
447                          };
448                      }
449                  }
450                  else if (File.Exists(dockerFileLowerCase))
451                  {
452                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
453                      {
454                          definition.Data.Execution = new ContainerActionExecutionData()
455                          {
456                              Image = container.ContainerImage
457                          };
458                      }
459                      else
460                      {
461                          definition.Data.Execution = new ContainerActionExecutionData()
462                          {
463                              Image = dockerFileLowerCase
464                          };
465                      }
466                  }
467                  else
468                  {
469                      var fullPath = IOUtil.ResolvePath(actionDirectory, &quot;.&quot;); 
470                      throw new NotSupportedException($&quot;Can&#x27;t find &#x27;action.yml&#x27;, &#x27;action.yaml&#x27; or &#x27;Dockerfile&#x27; under &#x27;{fullPath}&#x27;. Did you forget to run actions/checkout before running your local action?&quot;);
471                  }
472              }
473              else if (action.Reference.Type == Pipelines.ActionSourceType.Script)
474              {
475                  definition.Data.Execution = new ScriptActionExecutionData();
476                  definition.Data.Name = &quot;Run&quot;;
477                  definition.Data.Description = &quot;Execute a script&quot;;
478              }
479              else
480              {
481                  throw new NotSupportedException(action.Reference.Type.ToString());
482              }
483              return definition;
484          }
485          private async Task PullActionContainerAsync(IExecutionContext executionContext, object data)
486          {
487              var setupInfo = data as ContainerSetupInfo;
488              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
489              ArgUtil.NotNullOrEmpty(setupInfo.Container.Image, nameof(setupInfo.Container.Image));
490              executionContext.Output($&quot;##[group]Pull down action image &#x27;{setupInfo.Container.Image}&#x27;&quot;);
491              var dockerManager = HostContext.GetService&lt;IDockerCommandManager&gt;();
492              int retryCount = 0;
493              int pullExitCode = 0;
494              while (retryCount &lt; 3)
495              {
496                  pullExitCode = await dockerManager.DockerPull(executionContext, setupInfo.Container.Image);
497                  if (pullExitCode == 0)
498                  {
499                      break;
500                  }
501                  else
502                  {
503                      retryCount++;
504                      if (retryCount &lt; 3)
505                      {
506                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
507                          executionContext.Warning($&quot;Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.&quot;);
508                          await Task.Delay(backOff);
509                      }
510                  }
511              }
512              executionContext.Output(&quot;##[endgroup]&quot;);
513              if (retryCount == 3 &amp;&amp; pullExitCode != 0)
514              {
515                  throw new InvalidOperationException($&quot;Docker pull failed with exit code {pullExitCode}&quot;);
516              }
517              foreach (var stepId in setupInfo.StepIds)
518              {
519                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = setupInfo.Container.Image };
520                  Trace.Info($&quot;Prepared docker image &#x27;{setupInfo.Container.Image}&#x27; for action {stepId} ({setupInfo.Container.Image})&quot;);
521              }
522          }
523          private async Task BuildActionContainerAsync(IExecutionContext executionContext, object data)
524          {
525              var setupInfo = data as ContainerSetupInfo;
526              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
527              ArgUtil.NotNullOrEmpty(setupInfo.Container.Dockerfile, nameof(setupInfo.Container.Dockerfile));
528              executionContext.Output($&quot;##[group]Build container for action use: &#x27;{setupInfo.Container.Dockerfile}&#x27;.&quot;);
529              var dockerManager = HostContext.GetService&lt;IDockerCommandManager&gt;();
530              int retryCount = 0;
531              int buildExitCode = 0;
532              var imageName = $&quot;{dockerManager.DockerInstanceLabel}:{Guid.NewGuid().ToString(&quot;N&quot;)}&quot;;
533              while (retryCount &lt; 3)
534              {
535                  buildExitCode = await dockerManager.DockerBuild(
536                      executionContext,
537                      setupInfo.Container.WorkingDirectory,
538                      setupInfo.Container.Dockerfile,
539                      Directory.GetParent(setupInfo.Container.Dockerfile).FullName,
540                      imageName);
541                  if (buildExitCode == 0)
542                  {
543                      break;
544                  }
545                  else
546                  {
547                      retryCount++;
548                      if (retryCount &lt; 3)
549                      {
550                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
551                          executionContext.Warning($&quot;Docker build failed with exit code {buildExitCode}, back off {backOff.TotalSeconds} seconds before retry.&quot;);
552                          await Task.Delay(backOff);
553                      }
554                  }
555              }
556              executionContext.Output(&quot;##[endgroup]&quot;);
557              if (retryCount == 3 &amp;&amp; buildExitCode != 0)
558              {
559                  throw new InvalidOperationException($&quot;Docker build failed with exit code {buildExitCode}&quot;);
560              }
561              foreach (var stepId in setupInfo.StepIds)
562              {
563                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = imageName };
564                  Trace.Info($&quot;Prepared docker image &#x27;{imageName}&#x27; for action {stepId} ({setupInfo.Container.Dockerfile})&quot;);
565              }
566          }
567          private async Task&lt;IDictionary&lt;string, WebApi.ActionDownloadInfo&gt;&gt; GetDownloadInfoAsync(IExecutionContext executionContext, List&lt;Pipelines.ActionStep&gt; actions)
568          {
569              executionContext.Output(&quot;Getting action download info&quot;);
570              var actionReferences = actions
571                  .GroupBy(x =&gt; GetDownloadInfoLookupKey(x))
572                  .Where(x =&gt; !string.IsNullOrEmpty(x.Key))
573                  .Select(x =&gt;
574                  {
575                      var action = x.First();
576                      var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
577                      ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
578                      return new WebApi.ActionReference
579                      {
580                          NameWithOwner = repositoryReference.Name,
581                          Ref = repositoryReference.Ref,
582                          Path = repositoryReference.Path,
583                      };
584                  })
585                  .ToList();
586              if (actionReferences.Count == 0)
587              {
588                  return new Dictionary&lt;string, WebApi.ActionDownloadInfo&gt;();
589              }
590              var launchServer = HostContext.GetService&lt;ILaunchServer&gt;();
591              var jobServer = HostContext.GetService&lt;IJobServer&gt;();
592              var actionDownloadInfos = default(WebApi.ActionDownloadInfoCollection);
593              for (var attempt = 1; attempt &lt;= 3; attempt++)
594              {
595                  try
596                  {
597                      if (MessageUtil.IsRunServiceJob(executionContext.Global.Variables.Get(Constants.Variables.System.JobRequestType)))
598                      {
599                          actionDownloadInfos = await launchServer.ResolveActionsDownloadInfoAsync(executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
600                      }
601                      else
602                      {
603                          actionDownloadInfos = await jobServer.ResolveActionDownloadInfoAsync(executionContext.Global.Plan.ScopeIdentifier, executionContext.Global.Plan.PlanType, executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
604                      }
605                      break;
606                  }
607                  catch (Exception ex) when (!executionContext.CancellationToken.IsCancellationRequested) 
608                  {
609                      if (attempt &lt; 3 &amp;&amp; !(ex is WebApi.UnresolvableActionDownloadInfoException))
610                      {
611                          executionContext.Output($&quot;Failed to resolve action download info. Error: {ex.Message}&quot;);
612                          executionContext.Debug(ex.ToString());
613                          if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable(&quot;_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF&quot;)))
614                          {
615                              var backoff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
616                              executionContext.Output($&quot;Retrying in {backoff.TotalSeconds} seconds&quot;);
617                              await Task.Delay(backoff);
618                          }
619                      }
620                      else
621                      {
622                          if (ex is WebApi.UnresolvableActionDownloadInfoException)
623                          {
624                              throw;
625                          }
626                          else
627                          {
628                              throw new WebApi.FailedToResolveActionDownloadInfoException(&quot;Failed to resolve action download info.&quot;, ex);
629                          }
630                      }
631                  }
632              }
633              ArgUtil.NotNull(actionDownloadInfos, nameof(actionDownloadInfos));
634              ArgUtil.NotNull(actionDownloadInfos.Actions, nameof(actionDownloadInfos.Actions));
635              var apiUrl = GetApiUrl(executionContext);
636              var defaultAccessToken = executionContext.GetGitHubContext(&quot;token&quot;);
637              var configurationStore = HostContext.GetService&lt;IConfigurationStore&gt;();
638              var runnerSettings = configurationStore.GetSettings();
639              foreach (var actionDownloadInfo in actionDownloadInfos.Actions.Values)
640              {
641                  HostContext.SecretMasker.AddValue(actionDownloadInfo.Authentication?.Token);
642                  if (string.IsNullOrEmpty(actionDownloadInfo.Authentication?.Token))
643                  {
644                      actionDownloadInfo.Authentication = new WebApi.ActionDownloadAuthentication { Token = defaultAccessToken };
645                  }
646              }
647              return actionDownloadInfos.Actions;
648          }
649          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo)
650          {
651              Trace.Entering();
652              ArgUtil.NotNull(executionContext, nameof(executionContext));
653              ArgUtil.NotNull(downloadInfo, nameof(downloadInfo));
654              ArgUtil.NotNullOrEmpty(downloadInfo.NameWithOwner, nameof(downloadInfo.NameWithOwner));
655              ArgUtil.NotNullOrEmpty(downloadInfo.Ref, nameof(downloadInfo.Ref));
656              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), downloadInfo.NameWithOwner.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), downloadInfo.Ref);
657              string watermarkFile = GetWatermarkFilePath(destDirectory);
658              if (File.Exists(watermarkFile))
659              {
660                  executionContext.Debug($&quot;Action &#x27;{downloadInfo.NameWithOwner}@{downloadInfo.Ref}&#x27; already downloaded at &#x27;{destDirectory}&#x27;.&quot;);
661                  return;
662              }
663              else
664              {
665                  IOUtil.DeleteDirectory(destDirectory, executionContext.CancellationToken);
666                  Directory.CreateDirectory(destDirectory);
667                  executionContext.Output($&quot;Download action repository &#x27;{downloadInfo.NameWithOwner}@{downloadInfo.Ref}&#x27; (SHA:{downloadInfo.ResolvedSha})&quot;);
668              }
669              await DownloadRepositoryActionAsync(executionContext, downloadInfo, destDirectory);
670          }
671          private string GetApiUrl(IExecutionContext executionContext)
672          {
673              string apiUrl = executionContext.GetGitHubContext(&quot;api_url&quot;);
674              if (!string.IsNullOrEmpty(apiUrl))
675              {
676                  return apiUrl;
677              }
678              return _dotcomApiUrl;
679          }
680          private static string BuildLinkToActionArchive(string apiUrl, string repository, string @ref)
681          {
682  #if OS_WINDOWS
683              return $&quot;{apiUrl}/repos/{repository}/zipball/{@ref}&quot;;
684  #else
685              return $&quot;{apiUrl}/repos/{repository}/tarball/{@ref}&quot;;
686  #endif
687          }
688          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo, string destDirectory)
689          {
690              string tempDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), &quot;_temp_&quot; + Guid.NewGuid());
691              Directory.CreateDirectory(tempDirectory);
692  #if OS_WINDOWS
693              string archiveFile = Path.Combine(tempDirectory, $&quot;{Guid.NewGuid()}.zip&quot;);
694              string link = downloadInfo?.ZipballUrl;
695  #else
696              string archiveFile = Path.Combine(tempDirectory, $&quot;{Guid.NewGuid()}.tar.gz&quot;);
697              string link = downloadInfo?.TarballUrl;
698  #endif
699              Trace.Info($&quot;Save archive &#x27;{link}&#x27; into {archiveFile}.&quot;);
700              try
701              {
702                  int retryCount = 0;
703                  int timeoutSeconds = 20 * 60;
704                  while (retryCount &lt; 3)
705                  {
706                      using (var actionDownloadTimeout = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds)))
707                      using (var actionDownloadCancellation = CancellationTokenSource.CreateLinkedTokenSource(actionDownloadTimeout.Token, executionContext.CancellationToken))
708                      {
709                          try
710                          {
711                              using (FileStream fs = new(archiveFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: _defaultFileStreamBufferSize, useAsync: true))
712                              using (var httpClientHandler = HostContext.CreateHttpClientHandler())
713                              using (var httpClient = new HttpClient(httpClientHandler))
714                              {
715                                  httpClient.DefaultRequestHeaders.Authorization = CreateAuthHeader(downloadInfo.Authentication?.Token);
716                                  httpClient.DefaultRequestHeaders.UserAgent.AddRange(HostContext.UserAgents);
717                                  using (var response = await httpClient.GetAsync(link))
718                                  {
719                                      if (response.IsSuccessStatusCode)
720                                      {
721                                          using (var result = await response.Content.ReadAsStreamAsync())
722                                          {
723                                              await result.CopyToAsync(fs, _defaultCopyBufferSize, actionDownloadCancellation.Token);
724                                              await fs.FlushAsync(actionDownloadCancellation.Token);
725                                              break;
726                                          }
727                                      }
728                                      else if (response.StatusCode == HttpStatusCode.NotFound)
729                                      {
730                                          throw new ActionNotFoundException(new Uri(link));
731                                      }
732                                      else
733                                      {
734                                          response.EnsureSuccessStatusCode();
735                                      }
736                                  }
737                              }
738                          }
739                          catch (OperationCanceledException) when (executionContext.CancellationToken.IsCancellationRequested)
740                          {
741                              Trace.Info(&quot;Action download has been cancelled.&quot;);
742                              throw;
743                          }
744                          catch (ActionNotFoundException)
745                          {
746                              Trace.Info($&quot;The action at &#x27;{link}&#x27; does not exist&quot;);
747                              throw;
748                          }
749                          catch (Exception ex) when (retryCount &lt; 2)
750                          {
751                              retryCount++;
752                              Trace.Error($&quot;Fail to download archive &#x27;{link}&#x27; -- Attempt: {retryCount}&quot;);
753                              Trace.Error(ex);
754                              if (actionDownloadTimeout.Token.IsCancellationRequested)
755                              {
756                                  executionContext.Warning($&quot;Action &#x27;{link}&#x27; didn&#x27;t finish download within {timeoutSeconds} seconds.&quot;);
757                              }
758                              else
759                              {
760                                  executionContext.Warning($&quot;Failed to download action &#x27;{link}&#x27;. Error: {ex.Message}&quot;);
761                              }
762                          }
763                      }
764                      if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable(&quot;_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF&quot;)))
765                      {
766                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
767                          executionContext.Warning($&quot;Back off {backOff.TotalSeconds} seconds before retry.&quot;);
768                          await Task.Delay(backOff);
769                      }
770                  }
771                  ArgUtil.NotNullOrEmpty(archiveFile, nameof(archiveFile));
772                  executionContext.Debug($&quot;Download &#x27;{link}&#x27; to &#x27;{archiveFile}&#x27;&quot;);
773                  var stagingDirectory = Path.Combine(tempDirectory, &quot;_staging&quot;);
774                  Directory.CreateDirectory(stagingDirectory);
775  #if OS_WINDOWS
776                  ZipFile.ExtractToDirectory(archiveFile, stagingDirectory);
777  #else
778                  string tar = WhichUtil.Which(&quot;tar&quot;, require: true, trace: Trace);
779                  using (var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;())
780                  {
781                      processInvoker.OutputDataReceived += new EventHandler&lt;ProcessDataReceivedEventArgs&gt;((sender, args) =&gt;
782                      {
783                          if (!string.IsNullOrEmpty(args.Data))
784                          {
785                              Trace.Info(args.Data);
786                          }
787                      });
788                      processInvoker.ErrorDataReceived += new EventHandler&lt;ProcessDataReceivedEventArgs&gt;((sender, args) =&gt;
789                      {
790                          if (!string.IsNullOrEmpty(args.Data))
791                          {
792                              Trace.Error(args.Data);
793                          }
794                      });
795                      int exitCode = await processInvoker.ExecuteAsync(stagingDirectory, tar, $&quot;-xzf \&quot;{archiveFile}\&quot;&quot;, null, executionContext.CancellationToken);
796                      if (exitCode != 0)
797                      {
798                          throw new NotSupportedException($&quot;Can&#x27;t use &#x27;tar -xzf&#x27; extract archive file: {archiveFile}. return code: {exitCode}.&quot;);
799                      }
800                  }
801  #endif
802                  var subDirectories = new DirectoryInfo(stagingDirectory).GetDirectories();
803                  if (subDirectories.Length != 1)
804                  {
805                      throw new InvalidOperationException($&quot;&#x27;{archiveFile}&#x27; contains &#x27;{subDirectories.Length}&#x27; directories&quot;);
806                  }
807                  else
808                  {
809                      executionContext.Debug($&quot;Unwrap &#x27;{subDirectories[0].Name}&#x27; to &#x27;{destDirectory}&#x27;&quot;);
810                      IOUtil.CopyDirectory(subDirectories[0].FullName, destDirectory, executionContext.CancellationToken);
811                  }
812                  Trace.Verbose(&quot;Create watermark file indicate action download succeed.&quot;);
813                  string watermarkFile = GetWatermarkFilePath(destDirectory);
814                  File.WriteAllText(watermarkFile, DateTime.UtcNow.ToString());
815                  executionContext.Debug($&quot;Archive &#x27;{archiveFile}&#x27; has been unzipped into &#x27;{destDirectory}&#x27;.&quot;);
816                  Trace.Info(&quot;Finished getting action repository.&quot;);
817              }
818              finally
819              {
820                  try
821                  {
822                      if (Directory.Exists(tempDirectory))
823                      {
824                          Trace.Verbose(&quot;Deleting action temp folder: {0}&quot;, tempDirectory);
825                          IOUtil.DeleteDirectory(tempDirectory, CancellationToken.None); 
826                      }
827                  }
828                  catch (Exception ex)
829                  {
830                      Trace.Warning(&quot;Failed to delete temp folder &#x27;{0}&#x27;. Exception: {1}&quot;, tempDirectory, ex);
831                  }
832              }
833          }
834          private void ConfigureAuthorizationFromContext(IExecutionContext executionContext, HttpClient httpClient)
835          {
836              var authToken = Environment.GetEnvironmentVariable(&quot;_GITHUB_ACTION_TOKEN&quot;);
837              if (string.IsNullOrEmpty(authToken))
838              {
839                  authToken = executionContext.Global.Variables.Get(&quot;PREVIEW_ACTION_TOKEN&quot;);
840              }
841              if (!string.IsNullOrEmpty(authToken))
842              {
843                  HostContext.SecretMasker.AddValue(authToken);
844                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;PAT:{authToken}&quot;));
845                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
846              }
847              else
848              {
849                  var accessToken = executionContext.GetGitHubContext(&quot;token&quot;);
850                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{accessToken}&quot;));
851                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
852              }
853          }
854          private string GetWatermarkFilePath(string directory) =&gt; directory + &quot;.completed&quot;;
855          private ActionSetupInfo PrepareRepositoryActionAsync(IExecutionContext executionContext, Pipelines.ActionStep repositoryAction)
856          {
857              var repositoryReference = repositoryAction.Reference as Pipelines.RepositoryPathReference;
858              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
859              {
860                  Trace.Info($&quot;Repository action is in &#x27;self&#x27; repository.&quot;);
861                  return null;
862              }
863              var setupInfo = new ActionSetupInfo();
864              var actionContainer = new ActionContainer();
865              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repositoryReference.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repositoryReference.Ref);
866              string actionEntryDirectory = destDirectory;
867              string dockerFileRelativePath = repositoryReference.Name;
868              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
869              if (!string.IsNullOrEmpty(repositoryReference.Path))
870              {
871                  actionEntryDirectory = Path.Combine(destDirectory, repositoryReference.Path);
872                  dockerFileRelativePath = $&quot;{dockerFileRelativePath}/{repositoryReference.Path}&quot;;
873                  actionContainer.ActionRepository = $&quot;{repositoryReference.Name}/{repositoryReference.Path}@{repositoryReference.Ref}&quot;;
874              }
875              else
876              {
877                  actionContainer.ActionRepository = $&quot;{repositoryReference.Name}@{repositoryReference.Ref}&quot;;
878              }
879              var dockerFile = Path.Combine(actionEntryDirectory, &quot;Dockerfile&quot;);
880              var dockerFileLowerCase = Path.Combine(actionEntryDirectory, &quot;dockerfile&quot;);
881              var actionManifest = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYmlFile);
882              var actionManifestYaml = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYamlFile);
883              if (File.Exists(actionManifest) || File.Exists(actionManifestYaml))
884              {
885                  executionContext.Debug($&quot;action.yml for action: &#x27;{actionManifest}&#x27;.&quot;);
886                  var manifestManager = HostContext.GetService&lt;IActionManifestManager&gt;();
887                  ActionDefinitionData actionDefinitionData = null;
888                  if (File.Exists(actionManifest))
889                  {
890                      actionDefinitionData = manifestManager.Load(executionContext, actionManifest);
891                  }
892                  else
893                  {
894                      actionDefinitionData = manifestManager.Load(executionContext, actionManifestYaml);
895                  }
896                  if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Container)
897                  {
898                      var containerAction = actionDefinitionData.Execution as ContainerActionExecutionData;
899                      if (DockerUtil.IsDockerfile(containerAction.Image))
900                      {
901                          var dockerFileFullPath = Path.Combine(actionEntryDirectory, containerAction.Image);
902                          executionContext.Debug($&quot;Dockerfile for action: &#x27;{dockerFileFullPath}&#x27;.&quot;);
903                          actionContainer.Dockerfile = dockerFileFullPath;
904                          actionContainer.WorkingDirectory = destDirectory;
905                          setupInfo.Container = actionContainer;
906                          return setupInfo;
907                      }
908                      else if (containerAction.Image.StartsWith(&quot;docker:&amp;bsol;&amp;bsol;&quot;, StringComparison.OrdinalIgnoreCase))
909                      {
910                          var actionImage = containerAction.Image.Substring(&quot;docker:&amp;bsol;&amp;bsol;&quot;.Length);
911                          executionContext.Debug($&quot;Container image for action: &#x27;{actionImage}&#x27;.&quot;);
912                          actionContainer.Image = actionImage;
913                          setupInfo.Container = actionContainer;
914                          return setupInfo;
915                      }
916                      else
917                      {
918                          throw new NotSupportedException($&quot;&#x27;{containerAction.Image}&#x27; should be either &#x27;[path]/Dockerfile&#x27; or &#x27;docker:&amp;bsol;&amp;bsol;image[:tag]&#x27;.&quot;);
919                      }
920                  }
921                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.NodeJS)
922                  {
923                      Trace.Info($&quot;Action node.js file: {(actionDefinitionData.Execution as NodeJSActionExecutionData).Script}, no more preparation.&quot;);
924                      return null;
925                  }
926                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Plugin)
927                  {
928                      Trace.Info($&quot;Action plugin: {(actionDefinitionData.Execution as PluginActionExecutionData).Plugin}, no more preparation.&quot;);
929                      return null;
930                  }
931                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Composite)
932                  {
933                      Trace.Info($&quot;Loading Composite steps&quot;);
934                      var compositeAction = actionDefinitionData.Execution as CompositeActionExecutionData;
935                      setupInfo.Steps = compositeAction.Steps;
936                      if (!_cachedEmbeddedStepIds.ContainsKey(repositoryAction.Id))
937                      {
938                          _cachedEmbeddedStepIds[repositoryAction.Id] = new List&lt;Guid&gt;();
939                          foreach (var compositeStep in compositeAction.Steps)
940                          {
941                              var guid = Guid.NewGuid();
942                              compositeStep.Id = guid;
943                              _cachedEmbeddedStepIds[repositoryAction.Id].Add(guid);
944                          }
945                      }
946                      foreach (var step in compositeAction.Steps)
947                      {
948                          if (string.IsNullOrEmpty(executionContext.Global.Variables.Get(&quot;DistributedTask.EnableCompositeActions&quot;)) &amp;&amp; step.Reference.Type != Pipelines.ActionSourceType.Script)
949                          {
950                              throw new Exception(&quot;`uses:` keyword is not currently supported.&quot;);
951                          }
952                      }
953                      return setupInfo;
954                  }
955                  else
956                  {
957                      throw new NotSupportedException(actionDefinitionData.Execution.ExecutionType.ToString());
958                  }
959              }
960              else if (File.Exists(dockerFile))
961              {
962                  executionContext.Debug($&quot;Dockerfile for action: &#x27;{dockerFile}&#x27;.&quot;);
963                  actionContainer.Dockerfile = dockerFile;
964                  actionContainer.WorkingDirectory = destDirectory;
965                  setupInfo.Container = actionContainer;
966                  return setupInfo;
967              }
968              else if (File.Exists(dockerFileLowerCase))
969              {
970                  executionContext.Debug($&quot;Dockerfile for action: &#x27;{dockerFileLowerCase}&#x27;.&quot;);
971                  actionContainer.Dockerfile = dockerFileLowerCase;
972                  actionContainer.WorkingDirectory = destDirectory;
973                  setupInfo.Container = actionContainer;
974                  return setupInfo;
975              }
976              else
977              {
978                  var fullPath = IOUtil.ResolvePath(actionEntryDirectory, &quot;.&quot;); 
979                  throw new InvalidOperationException($&quot;Can&#x27;t find &#x27;action.yml&#x27;, &#x27;action.yaml&#x27; or &#x27;Dockerfile&#x27; under &#x27;{fullPath}&#x27;. Did you forget to run actions/checkout before running your local action?&quot;);
980              }
981          }
982          private static string GetDownloadInfoLookupKey(Pipelines.ActionStep action)
983          {
984              if (action.Reference.Type != Pipelines.ActionSourceType.Repository)
985              {
986                  return null;
987              }
988              var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
989              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
990              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
991              {
992                  return null;
993              }
994              if (!string.Equals(repositoryReference.RepositoryType, Pipelines.RepositoryTypes.GitHub, StringComparison.OrdinalIgnoreCase))
995              {
996                  throw new NotSupportedException(repositoryReference.RepositoryType);
997              }
998              ArgUtil.NotNullOrEmpty(repositoryReference.Name, nameof(repositoryReference.Name));
999              ArgUtil.NotNullOrEmpty(repositoryReference.Ref, nameof(repositoryReference.Ref));
1000              return $&quot;{repositoryReference.Name}@{repositoryReference.Ref}&quot;;
1001          }
1002          private static string GetDownloadInfoLookupKey(WebApi.ActionDownloadInfo info)
1003          {
1004              ArgUtil.NotNullOrEmpty(info.NameWithOwner, nameof(info.NameWithOwner));
1005              ArgUtil.NotNullOrEmpty(info.Ref, nameof(info.Ref));
1006              return $&quot;{info.NameWithOwner}@{info.Ref}&quot;;
1007          }
1008          private AuthenticationHeaderValue CreateAuthHeader(string token)
1009          {
1010              if (string.IsNullOrEmpty(token))
1011              {
1012                  return null;
1013              }
<span onclick='openModal()' class='match'>1014              var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{token}&quot;));
1015              HostContext.SecretMasker.AddValue(base64EncodingToken);
</span>1016              return new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
1017          }
1018      }
1019      public sealed class Definition
1020      {
1021          public ActionDefinitionData Data { get; set; }
1022          public string Directory { get; set; }
1023      }
1024      public sealed class ActionDefinitionData
1025      {
1026          public string Name { get; set; }
1027          public string Description { get; set; }
1028          public MappingToken Inputs { get; set; }
1029          public ActionExecutionData Execution { get; set; }
1030          public Dictionary&lt;String, String&gt; Deprecated { get; set; }
1031      }
1032      public enum ActionExecutionType
1033      {
1034          Container,
1035          NodeJS,
1036          Plugin,
1037          Script,
1038          Composite,
1039      }
1040      public sealed class ContainerActionExecutionData : ActionExecutionData
1041      {
1042          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Container;
1043          public override bool HasPre =&gt; !string.IsNullOrEmpty(Pre);
1044          public override bool HasPost =&gt; !string.IsNullOrEmpty(Post);
1045          public string Image { get; set; }
1046          public string EntryPoint { get; set; }
1047          public SequenceToken Arguments { get; set; }
1048          public MappingToken Environment { get; set; }
1049          public string Pre { get; set; }
1050          public string Post { get; set; }
1051      }
1052      public sealed class NodeJSActionExecutionData : ActionExecutionData
1053      {
1054          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.NodeJS;
1055          public override bool HasPre =&gt; !string.IsNullOrEmpty(Pre);
1056          public override bool HasPost =&gt; !string.IsNullOrEmpty(Post);
1057          public string Script { get; set; }
1058          public string Pre { get; set; }
1059          public string Post { get; set; }
1060          public string NodeVersion { get; set; }
1061      }
1062      public sealed class PluginActionExecutionData : ActionExecutionData
1063      {
1064          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Plugin;
1065          public override bool HasPre =&gt; false;
1066          public override bool HasPost =&gt; !string.IsNullOrEmpty(Post);
1067          public string Plugin { get; set; }
1068          public string Post { get; set; }
1069      }
1070      public sealed class ScriptActionExecutionData : ActionExecutionData
1071      {
1072          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Script;
1073          public override bool HasPre =&gt; false;
1074          public override bool HasPost =&gt; false;
1075      }
1076      public sealed class CompositeActionExecutionData : ActionExecutionData
1077      {
1078          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Composite;
1079          public override bool HasPre =&gt; PreSteps.Count &gt; 0;
1080          public override bool HasPost =&gt; PostSteps.Count &gt; 0;
1081          public List&lt;Pipelines.ActionStep&gt; PreSteps { get; set; }
1082          public List&lt;Pipelines.ActionStep&gt; Steps { get; set; }
1083          public Stack&lt;Pipelines.ActionStep&gt; PostSteps { get; set; }
1084          public MappingToken Outputs { get; set; }
1085      }
1086      public abstract class ActionExecutionData
1087      {
1088          private string _initCondition = $&quot;{Constants.Expressions.Always}()&quot;;
1089          private string _cleanupCondition = $&quot;{Constants.Expressions.Always}()&quot;;
1090          public abstract ActionExecutionType ExecutionType { get; }
1091          public abstract bool HasPre { get; }
1092          public abstract bool HasPost { get; }
1093          public string CleanupCondition
1094          {
1095              get { return _cleanupCondition; }
1096              set { _cleanupCondition = value; }
1097          }
1098          public string InitCondition
1099          {
1100              get { return _initCondition; }
1101              set { _initCondition = value; }
1102          }
1103      }
1104      public class ContainerSetupInfo
1105      {
1106          public ContainerSetupInfo(List&lt;Guid&gt; ids, string image)
1107          {
1108              StepIds = ids;
1109              Container = new ActionContainer()
1110              {
1111                  Image = image
1112              };
1113          }
1114          public ContainerSetupInfo(List&lt;Guid&gt; ids, string dockerfile, string workingDirectory)
1115          {
1116              StepIds = ids;
1117              Container = new ActionContainer()
1118              {
1119                  Dockerfile = dockerfile,
1120                  WorkingDirectory = workingDirectory
1121              };
1122          }
1123          public List&lt;Guid&gt; StepIds { get; set; }
1124          public ActionContainer Container { get; set; }
1125      }
1126      public class ActionContainer
1127      {
1128          public string Image { get; set; }
1129          public string Dockerfile { get; set; }
1130          public string WorkingDirectory { get; set; }
1131          public string ActionRepository { get; set; }
1132      }
1133      public class ActionSetupInfo
1134      {
1135          public ActionContainer Container { get; set; }
1136          public List&lt;Pipelines.ActionStep&gt; Steps { get; set; }
1137      }
1138      public class PrepareActionsState
1139      {
1140          public Dictionary&lt;string, List&lt;Guid&gt;&gt; ImagesToPull;
1141          public Dictionary&lt;string, List&lt;Guid&gt;&gt; ImagesToBuild;
1142          public Dictionary&lt;string, ActionContainer&gt; ImagesToBuildInfo;
1143          public Dictionary&lt;Guid, IActionRunner&gt; PreStepTracker;
1144      }
1145  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.IO.Compression;
5  using System.Linq;
6  using System.Net;
7  using System.Net.Http;
8  using System.Net.Http.Headers;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using GitHub.DistributedTask.ObjectTemplating.Tokens;
13  using GitHub.Runner.Common;
14  using GitHub.Runner.Common.Util;
15  using GitHub.Runner.Sdk;
16  using GitHub.Runner.Worker.Container;
17  using GitHub.Services.Common;
18  using WebApi = GitHub.DistributedTask.WebApi;
19  using Pipelines = GitHub.DistributedTask.Pipelines;
20  using PipelineTemplateConstants = GitHub.DistributedTask.Pipelines.ObjectTemplating.PipelineTemplateConstants;
21  using GitHub.DistributedTask.WebApi;
22  namespace GitHub.Runner.Worker
23  {
24      public class PrepareResult
25      {
26          public PrepareResult(List&lt;JobExtensionRunner&gt; containerSetupSteps, Dictionary&lt;Guid, IActionRunner&gt; preStepTracker)
27          {
28              this.ContainerSetupSteps = containerSetupSteps;
29              this.PreStepTracker = preStepTracker;
30          }
31          public List&lt;JobExtensionRunner&gt; ContainerSetupSteps { get; set; }
32          public Dictionary&lt;Guid, IActionRunner&gt; PreStepTracker { get; set; }
33      }
34      [ServiceLocator(Default = typeof(ActionManager))]
35      public interface IActionManager : IRunnerService
36      {
37          Dictionary&lt;Guid, ContainerInfo&gt; CachedActionContainers { get; }
38          Dictionary&lt;Guid, List&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPreSteps { get; }
39          Dictionary&lt;Guid, List&lt;Guid&gt;&gt; CachedEmbeddedStepIds { get; }
40          Dictionary&lt;Guid, Stack&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPostSteps { get; }
41          Task&lt;PrepareResult&gt; PrepareActionsAsync(IExecutionContext executionContext, IEnumerable&lt;Pipelines.JobStep&gt; steps, Guid rootStepId = default(Guid));
42          Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action);
43      }
44      public sealed class ActionManager : RunnerService, IActionManager
45      {
46          private const int _defaultFileStreamBufferSize = 4096;
47          private const int _defaultCopyBufferSize = 81920;
48          private const string _dotcomApiUrl = &quot;https:&amp;bsol;&amp;bsol;api.github.com&quot;;
49          private readonly Dictionary&lt;Guid, ContainerInfo&gt; _cachedActionContainers = new();
50          public Dictionary&lt;Guid, ContainerInfo&gt; CachedActionContainers =&gt; _cachedActionContainers;
51          private readonly Dictionary&lt;Guid, List&lt;Pipelines.ActionStep&gt;&gt; _cachedEmbeddedPreSteps = new();
52          public Dictionary&lt;Guid, List&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPreSteps =&gt; _cachedEmbeddedPreSteps;
53          private readonly Dictionary&lt;Guid, List&lt;Guid&gt;&gt; _cachedEmbeddedStepIds = new();
54          public Dictionary&lt;Guid, List&lt;Guid&gt;&gt; CachedEmbeddedStepIds =&gt; _cachedEmbeddedStepIds;
55          private readonly Dictionary&lt;Guid, Stack&lt;Pipelines.ActionStep&gt;&gt; _cachedEmbeddedPostSteps = new();
56          public Dictionary&lt;Guid, Stack&lt;Pipelines.ActionStep&gt;&gt; CachedEmbeddedPostSteps =&gt; _cachedEmbeddedPostSteps;
57          public async Task&lt;PrepareResult&gt; PrepareActionsAsync(IExecutionContext executionContext, IEnumerable&lt;Pipelines.JobStep&gt; steps, Guid rootStepId = default(Guid))
58          {
59              ArgUtil.NotNull(executionContext, nameof(executionContext));
60              ArgUtil.NotNull(steps, nameof(steps));
61              var state = new PrepareActionsState
62              {
63                  ImagesToBuild = new Dictionary&lt;string, List&lt;Guid&gt;&gt;(StringComparer.OrdinalIgnoreCase),
64                  ImagesToPull = new Dictionary&lt;string, List&lt;Guid&gt;&gt;(StringComparer.OrdinalIgnoreCase),
65                  ImagesToBuildInfo = new Dictionary&lt;string, ActionContainer&gt;(StringComparer.OrdinalIgnoreCase),
66                  PreStepTracker = new Dictionary&lt;Guid, IActionRunner&gt;()
67              };
68              var containerSetupSteps = new List&lt;JobExtensionRunner&gt;();
69              var depth = 0;
70              if (rootStepId == default(Guid))
71              {
72                  IOUtil.DeleteDirectory(HostContext.GetDirectory(WellKnownDirectory.Actions), executionContext.CancellationToken);
73              }
74              else
75              {
76                  if (!_cachedEmbeddedStepIds.ContainsKey(rootStepId))
77                  {
78                      _cachedEmbeddedStepIds[rootStepId] = new List&lt;Guid&gt;();
79                      foreach (var compositeStep in steps)
80                      {
81                          var guid = Guid.NewGuid();
82                          compositeStep.Id = guid;
83                          _cachedEmbeddedStepIds[rootStepId].Add(guid);
84                      }
85                  }
86                  depth = 1;
87              }
88              IEnumerable&lt;Pipelines.ActionStep&gt; actions = steps.OfType&lt;Pipelines.ActionStep&gt;();
89              executionContext.Output(&quot;Prepare all required actions&quot;);
90              PrepareActionsState result = new PrepareActionsState();
91              try
92              {
93                  result = await PrepareActionsRecursiveAsync(executionContext, state, actions, depth, rootStepId);
94              }
95              catch (FailedToResolveActionDownloadInfoException ex)
96              {
97                  Trace.Error($&quot;Caught exception from PrepareActionsAsync Initialization: {ex}&quot;);
98                  executionContext.InfrastructureError(ex.Message);
99                  executionContext.Result = TaskResult.Failed;
100                  throw;
101              }
102              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
103              {
104                  if (state.ImagesToPull.Count &gt; 0)
105                  {
106                      foreach (var imageToPull in result.ImagesToPull)
107                      {
108                          Trace.Info($&quot;{imageToPull.Value.Count} steps need to pull image &#x27;{imageToPull.Key}&#x27;&quot;);
109                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.PullActionContainerAsync,
110                                                                      condition: $&quot;{PipelineTemplateConstants.Success}()&quot;,
111                                                                      displayName: $&quot;Pull {imageToPull.Key}&quot;,
112                                                                      data: new ContainerSetupInfo(imageToPull.Value, imageToPull.Key)));
113                      }
114                  }
115                  if (result.ImagesToBuild.Count &gt; 0)
116                  {
117                      foreach (var imageToBuild in result.ImagesToBuild)
118                      {
119                          var setupInfo = result.ImagesToBuildInfo[imageToBuild.Key];
120                          Trace.Info($&quot;{imageToBuild.Value.Count} steps need to build image from &#x27;{setupInfo.Dockerfile}&#x27;&quot;);
121                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.BuildActionContainerAsync,
122                                                                      condition: $&quot;{PipelineTemplateConstants.Success}()&quot;,
123                                                                      displayName: $&quot;Build {setupInfo.ActionRepository}&quot;,
124                                                                      data: new ContainerSetupInfo(imageToBuild.Value, setupInfo.Dockerfile, setupInfo.WorkingDirectory)));
125                      }
126                  }
127  #if !OS_LINUX
128                  if (containerSetupSteps.Count &gt; 0)
129                  {
130                      executionContext.Output(&quot;Container action is only supported on Linux, skip pull and build docker images.&quot;);
131                      containerSetupSteps.Clear();
132                  }
133  #endif
134              }
135              return new PrepareResult(containerSetupSteps, result.PreStepTracker);
136          }
137          private async Task&lt;PrepareActionsState&gt; PrepareActionsRecursiveAsync(IExecutionContext executionContext, PrepareActionsState state, IEnumerable&lt;Pipelines.ActionStep&gt; actions, Int32 depth = 0, Guid parentStepId = default(Guid))
138          {
139              ArgUtil.NotNull(executionContext, nameof(executionContext));
140              if (depth &gt; Constants.CompositeActionsMaxDepth)
141              {
142                  throw new Exception($&quot;Composite action depth exceeded max depth {Constants.CompositeActionsMaxDepth}&quot;);
143              }
144              var repositoryActions = new List&lt;Pipelines.ActionStep&gt;();
145              foreach (var action in actions)
146              {
147                  if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
148                  {
149                      ArgUtil.NotNull(action, nameof(action));
150                      var containerReference = action.Reference as Pipelines.ContainerRegistryReference;
151                      ArgUtil.NotNull(containerReference, nameof(containerReference));
152                      ArgUtil.NotNullOrEmpty(containerReference.Image, nameof(containerReference.Image));
153                      if (!state.ImagesToPull.ContainsKey(containerReference.Image))
154                      {
155                          state.ImagesToPull[containerReference.Image] = new List&lt;Guid&gt;();
156                      }
157                      Trace.Info($&quot;Action {action.Name} ({action.Id}) needs to pull image &#x27;{containerReference.Image}&#x27;&quot;);
158                      state.ImagesToPull[containerReference.Image].Add(action.Id);
159                  }
160                  else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
161                  {
162                      repositoryActions.Add(action);
163                  }
164              }
165              if (repositoryActions.Count &gt; 0)
166              {
167                  var downloadInfos = await GetDownloadInfoAsync(executionContext, repositoryActions);
168                  foreach (var action in repositoryActions)
169                  {
170                      var lookupKey = GetDownloadInfoLookupKey(action);
171                      if (string.IsNullOrEmpty(lookupKey))
172                      {
173                          continue;
174                      }
175                      if (!downloadInfos.TryGetValue(lookupKey, out var downloadInfo))
176                      {
177                          throw new Exception($&quot;Missing download info for {lookupKey}&quot;);
178                      }
179                      await DownloadRepositoryActionAsync(executionContext, downloadInfo);
180                  }
181                  foreach (var action in repositoryActions)
182                  {
183                      var setupInfo = PrepareRepositoryActionAsync(executionContext, action);
184                      if (setupInfo != null &amp;&amp; setupInfo.Container != null)
185                      {
186                          if (!string.IsNullOrEmpty(setupInfo.Container.Image))
187                          {
188                              if (!state.ImagesToPull.ContainsKey(setupInfo.Container.Image))
189                              {
190                                  state.ImagesToPull[setupInfo.Container.Image] = new List&lt;Guid&gt;();
191                              }
192                              Trace.Info($&quot;Action {action.Name} ({action.Id}) from repository &#x27;{setupInfo.Container.ActionRepository}&#x27; needs to pull image &#x27;{setupInfo.Container.Image}&#x27;&quot;);
193                              state.ImagesToPull[setupInfo.Container.Image].Add(action.Id);
194                          }
195                          else
196                          {
197                              ArgUtil.NotNullOrEmpty(setupInfo.Container.ActionRepository, nameof(setupInfo.Container.ActionRepository));
198                              if (!state.ImagesToBuild.ContainsKey(setupInfo.Container.ActionRepository))
199                              {
200                                  state.ImagesToBuild[setupInfo.Container.ActionRepository] = new List&lt;Guid&gt;();
201                              }
202                              Trace.Info($&quot;Action {action.Name} ({action.Id}) from repository &#x27;{setupInfo.Container.ActionRepository}&#x27; needs to build image &#x27;{setupInfo.Container.Dockerfile}&#x27;&quot;);
203                              state.ImagesToBuild[setupInfo.Container.ActionRepository].Add(action.Id);
204                              state.ImagesToBuildInfo[setupInfo.Container.ActionRepository] = setupInfo.Container;
205                          }
206                      }
207                      else if (setupInfo != null &amp;&amp; setupInfo.Steps != null &amp;&amp; setupInfo.Steps.Count &gt; 0)
208                      {
209                          state = await PrepareActionsRecursiveAsync(executionContext, state, setupInfo.Steps, depth + 1, action.Id);
210                      }
211                      var repoAction = action.Reference as Pipelines.RepositoryPathReference;
212                      if (repoAction.RepositoryType != Pipelines.PipelineConstants.SelfAlias)
213                      {
214                          var definition = LoadAction(executionContext, action);
215                          if (definition.Data.Execution.HasPre)
216                          {
217                              Trace.Info($&quot;Add &#x27;pre&#x27; execution for {action.Id}&quot;);
218                              if (depth &lt; 1)
219                              {
220                                  var actionRunner = HostContext.CreateService&lt;IActionRunner&gt;();
221                                  actionRunner.Action = action;
222                                  actionRunner.Stage = ActionRunStage.Pre;
223                                  actionRunner.Condition = definition.Data.Execution.InitCondition;
224                                  state.PreStepTracker[action.Id] = actionRunner;
225                              }
226                              else
227                              {
228                                  if (!_cachedEmbeddedPreSteps.ContainsKey(parentStepId))
229                                  {
230                                      _cachedEmbeddedPreSteps[parentStepId] = new List&lt;Pipelines.ActionStep&gt;();
231                                  }
232                                  var clonedAction = action.Clone() as Pipelines.ActionStep;
233                                  clonedAction.Condition = definition.Data.Execution.InitCondition;
234                                  _cachedEmbeddedPreSteps[parentStepId].Add(clonedAction);
235                              }
236                          }
237                          if (definition.Data.Execution.HasPost &amp;&amp; depth &gt; 0)
238                          {
239                              if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
240                              {
241                                  _cachedEmbeddedPostSteps[parentStepId] = new Stack&lt;Pipelines.ActionStep&gt;();
242                              }
243                              var clonedAction = action.Clone() as Pipelines.ActionStep;
244                              clonedAction.Condition = definition.Data.Execution.CleanupCondition;
245                              _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
246                          }
247                      }
248                      else if (depth &gt; 0)
249                      {
250                          if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
251                          {
252                              _cachedEmbeddedPostSteps[parentStepId] = new Stack&lt;Pipelines.ActionStep&gt;();
253                          }
254                          var clonedAction = action.Clone() as Pipelines.ActionStep;
255                          _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
256                      }
257                  }
258              }
259              return state;
260          }
261          public Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action)
262          {
263              Trace.Entering();
264              ArgUtil.NotNull(action, nameof(action));
265              var definition = new Definition()
266              {
267                  Data = new ActionDefinitionData()
268              };
269              if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
270              {
271                  if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
272                  {
273                      Trace.Info(&quot;Load action that will run container through container hooks.&quot;);
274                      var containerAction = action.Reference as Pipelines.ContainerRegistryReference;
275                      definition.Data.Execution = new ContainerActionExecutionData()
276                      {
277                          Image = containerAction.Image,
278                      };
279                      Trace.Info($&quot;Using action container image: {containerAction.Image}.&quot;);
280                  }
281                  else
282                  {
283                      Trace.Info(&quot;Load action that reference container from registry.&quot;);
284                      CachedActionContainers.TryGetValue(action.Id, out var container);
285                      ArgUtil.NotNull(container, nameof(container));
286                      definition.Data.Execution = new ContainerActionExecutionData()
287                      {
288                          Image = container.ContainerImage
289                      };
290                      Trace.Info($&quot;Using action container image: {container.ContainerImage}.&quot;);
291                  }
292              }
293              else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
294              {
295                  string actionDirectory = null;
296                  var repoAction = action.Reference as Pipelines.RepositoryPathReference;
297                  if (string.Equals(repoAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
298                  {
299                      actionDirectory = executionContext.GetGitHubContext(&quot;workspace&quot;);
300                      if (!string.IsNullOrEmpty(repoAction.Path))
301                      {
302                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
303                      }
304                  }
305                  else
306                  {
307                      actionDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repoAction.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repoAction.Ref);
308                      if (!string.IsNullOrEmpty(repoAction.Path))
309                      {
310                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
311                      }
312                  }
313                  Trace.Info($&quot;Load action that reference repository from &#x27;{actionDirectory}&#x27;&quot;);
314                  definition.Directory = actionDirectory;
315                  string manifestFile = Path.Combine(actionDirectory, Constants.Path.ActionManifestYmlFile);
316                  string manifestFileYaml = Path.Combine(actionDirectory, Constants.Path.ActionManifestYamlFile);
317                  string dockerFile = Path.Combine(actionDirectory, &quot;Dockerfile&quot;);
318                  string dockerFileLowerCase = Path.Combine(actionDirectory, &quot;dockerfile&quot;);
319                  if (File.Exists(manifestFile) || File.Exists(manifestFileYaml))
320                  {
321                      var manifestManager = HostContext.GetService&lt;IActionManifestManager&gt;();
322                      if (File.Exists(manifestFile))
323                      {
324                          definition.Data = manifestManager.Load(executionContext, manifestFile);
325                      }
326                      else
327                      {
328                          definition.Data = manifestManager.Load(executionContext, manifestFileYaml);
329                      }
330                      Trace.Verbose($&quot;Action friendly name: &#x27;{definition.Data.Name}&#x27;&quot;);
331                      Trace.Verbose($&quot;Action description: &#x27;{definition.Data.Description}&#x27;&quot;);
332                      if (definition.Data.Inputs != null)
333                      {
334                          foreach (var input in definition.Data.Inputs)
335                          {
336                              Trace.Verbose($&quot;Action input: &#x27;{input.Key.ToString()}&#x27; default to &#x27;{input.Value.ToString()}&#x27;&quot;);
337                          }
338                      }
339                      if (definition.Data.Execution.ExecutionType == ActionExecutionType.Container)
340                      {
341                          var containerAction = definition.Data.Execution as ContainerActionExecutionData;
342                          Trace.Info($&quot;Action container Dockerfile/image: {containerAction.Image}.&quot;);
343                          if (containerAction.Arguments != null)
344                          {
345                              Trace.Info($&quot;Action container args:  {StringUtil.ConvertToJson(containerAction.Arguments)}.&quot;);
346                          }
347                          if (containerAction.Environment != null)
348                          {
349                              Trace.Info($&quot;Action container env: {StringUtil.ConvertToJson(containerAction.Environment)}.&quot;);
350                          }
351                          if (!string.IsNullOrEmpty(containerAction.Pre))
352                          {
353                              Trace.Info($&quot;Action container pre entrypoint: {containerAction.Pre}.&quot;);
354                          }
355                          if (!string.IsNullOrEmpty(containerAction.EntryPoint))
356                          {
357                              Trace.Info($&quot;Action container entrypoint: {containerAction.EntryPoint}.&quot;);
358                          }
359                          if (!string.IsNullOrEmpty(containerAction.Post))
360                          {
361                              Trace.Info($&quot;Action container post entrypoint: {containerAction.Post}.&quot;);
362                          }
363                          if (CachedActionContainers.TryGetValue(action.Id, out var container))
364                          {
365                              Trace.Info($&quot;Image &#x27;{containerAction.Image}&#x27; already built/pulled, use image: {container.ContainerImage}.&quot;);
366                              containerAction.Image = container.ContainerImage;
367                          }
368                      }
369                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.NodeJS)
370                      {
371                          var nodeAction = definition.Data.Execution as NodeJSActionExecutionData;
372                          Trace.Info($&quot;Action pre node.js file: {nodeAction.Pre ?? &quot;N/A&quot;}.&quot;);
373                          Trace.Info($&quot;Action node.js file: {nodeAction.Script}.&quot;);
374                          Trace.Info($&quot;Action post node.js file: {nodeAction.Post ?? &quot;N/A&quot;}.&quot;);
375                      }
376                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Plugin)
377                      {
378                          var pluginAction = definition.Data.Execution as PluginActionExecutionData;
379                          var pluginManager = HostContext.GetService&lt;IRunnerPluginManager&gt;();
380                          var plugin = pluginManager.GetPluginAction(pluginAction.Plugin);
381                          ArgUtil.NotNull(plugin, pluginAction.Plugin);
382                          ArgUtil.NotNullOrEmpty(plugin.PluginTypeName, pluginAction.Plugin);
383                          pluginAction.Plugin = plugin.PluginTypeName;
384                          Trace.Info($&quot;Action plugin: {plugin.PluginTypeName}.&quot;);
385                          if (!string.IsNullOrEmpty(plugin.PostPluginTypeName))
386                          {
387                              pluginAction.Post = plugin.PostPluginTypeName;
388                              Trace.Info($&quot;Action cleanup plugin: {plugin.PluginTypeName}.&quot;);
389                          }
390                      }
391                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Composite)
392                      {
393                          var compositeAction = definition.Data.Execution as CompositeActionExecutionData;
394                          Trace.Info($&quot;Load {compositeAction.Steps?.Count ?? 0} action steps.&quot;);
395                          Trace.Verbose($&quot;Details: {StringUtil.ConvertToJson(compositeAction?.Steps)}&quot;);
396                          Trace.Info($&quot;Load: {compositeAction.Outputs?.Count ?? 0} number of outputs&quot;);
397                          Trace.Info($&quot;Details: {StringUtil.ConvertToJson(compositeAction?.Outputs)}&quot;);
398                          if (CachedEmbeddedPreSteps.TryGetValue(action.Id, out var preSteps))
399                          {
400                              compositeAction.PreSteps = preSteps;
401                          }
402                          if (CachedEmbeddedPostSteps.TryGetValue(action.Id, out var postSteps))
403                          {
404                              compositeAction.PostSteps = postSteps;
405                          }
406                          if (_cachedEmbeddedStepIds.ContainsKey(action.Id))
407                          {
408                              for (var i = 0; i &lt; compositeAction.Steps.Count; i++)
409                              {
410                                  compositeAction.Steps[i].Id = _cachedEmbeddedStepIds[action.Id][i];
411                                  if (string.IsNullOrEmpty(executionContext.Global.Variables.Get(&quot;DistributedTask.EnableCompositeActions&quot;)) &amp;&amp; compositeAction.Steps[i].Reference.Type != Pipelines.ActionSourceType.Script)
412                                  {
413                                      throw new Exception(&quot;`uses:` keyword is not currently supported.&quot;);
414                                  }
415                              }
416                          }
417                          else
418                          {
419                              _cachedEmbeddedStepIds[action.Id] = new List&lt;Guid&gt;();
420                              foreach (var compositeStep in compositeAction.Steps)
421                              {
422                                  var guid = Guid.NewGuid();
423                                  compositeStep.Id = guid;
424                                  _cachedEmbeddedStepIds[action.Id].Add(guid);
425                              }
426                          }
427                      }
428                      else
429                      {
430                          throw new NotSupportedException(definition.Data.Execution.ExecutionType.ToString());
431                      }
432                  }
433                  else if (File.Exists(dockerFile))
434                  {
435                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
436                      {
437                          definition.Data.Execution = new ContainerActionExecutionData()
438                          {
439                              Image = container.ContainerImage
440                          };
441                      }
442                      else
443                      {
444                          definition.Data.Execution = new ContainerActionExecutionData()
445                          {
446                              Image = dockerFile
447                          };
448                      }
449                  }
450                  else if (File.Exists(dockerFileLowerCase))
451                  {
452                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
453                      {
454                          definition.Data.Execution = new ContainerActionExecutionData()
455                          {
456                              Image = container.ContainerImage
457                          };
458                      }
459                      else
460                      {
461                          definition.Data.Execution = new ContainerActionExecutionData()
462                          {
463                              Image = dockerFileLowerCase
464                          };
465                      }
466                  }
467                  else
468                  {
469                      var fullPath = IOUtil.ResolvePath(actionDirectory, &quot;.&quot;); 
470                      throw new NotSupportedException($&quot;Can&#x27;t find &#x27;action.yml&#x27;, &#x27;action.yaml&#x27; or &#x27;Dockerfile&#x27; under &#x27;{fullPath}&#x27;. Did you forget to run actions/checkout before running your local action?&quot;);
471                  }
472              }
473              else if (action.Reference.Type == Pipelines.ActionSourceType.Script)
474              {
475                  definition.Data.Execution = new ScriptActionExecutionData();
476                  definition.Data.Name = &quot;Run&quot;;
477                  definition.Data.Description = &quot;Execute a script&quot;;
478              }
479              else
480              {
481                  throw new NotSupportedException(action.Reference.Type.ToString());
482              }
483              return definition;
484          }
485          private async Task PullActionContainerAsync(IExecutionContext executionContext, object data)
486          {
487              var setupInfo = data as ContainerSetupInfo;
488              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
489              ArgUtil.NotNullOrEmpty(setupInfo.Container.Image, nameof(setupInfo.Container.Image));
490              executionContext.Output($&quot;##[group]Pull down action image &#x27;{setupInfo.Container.Image}&#x27;&quot;);
491              var dockerManager = HostContext.GetService&lt;IDockerCommandManager&gt;();
492              int retryCount = 0;
493              int pullExitCode = 0;
494              while (retryCount &lt; 3)
495              {
496                  pullExitCode = await dockerManager.DockerPull(executionContext, setupInfo.Container.Image);
497                  if (pullExitCode == 0)
498                  {
499                      break;
500                  }
501                  else
502                  {
503                      retryCount++;
504                      if (retryCount &lt; 3)
505                      {
506                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
507                          executionContext.Warning($&quot;Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.&quot;);
508                          await Task.Delay(backOff);
509                      }
510                  }
511              }
512              executionContext.Output(&quot;##[endgroup]&quot;);
513              if (retryCount == 3 &amp;&amp; pullExitCode != 0)
514              {
515                  throw new InvalidOperationException($&quot;Docker pull failed with exit code {pullExitCode}&quot;);
516              }
517              foreach (var stepId in setupInfo.StepIds)
518              {
519                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = setupInfo.Container.Image };
520                  Trace.Info($&quot;Prepared docker image &#x27;{setupInfo.Container.Image}&#x27; for action {stepId} ({setupInfo.Container.Image})&quot;);
521              }
522          }
523          private async Task BuildActionContainerAsync(IExecutionContext executionContext, object data)
524          {
525              var setupInfo = data as ContainerSetupInfo;
526              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
527              ArgUtil.NotNullOrEmpty(setupInfo.Container.Dockerfile, nameof(setupInfo.Container.Dockerfile));
528              executionContext.Output($&quot;##[group]Build container for action use: &#x27;{setupInfo.Container.Dockerfile}&#x27;.&quot;);
529              var dockerManager = HostContext.GetService&lt;IDockerCommandManager&gt;();
530              int retryCount = 0;
531              int buildExitCode = 0;
532              var imageName = $&quot;{dockerManager.DockerInstanceLabel}:{Guid.NewGuid().ToString(&quot;N&quot;)}&quot;;
533              while (retryCount &lt; 3)
534              {
535                  buildExitCode = await dockerManager.DockerBuild(
536                      executionContext,
537                      setupInfo.Container.WorkingDirectory,
538                      setupInfo.Container.Dockerfile,
539                      Directory.GetParent(setupInfo.Container.Dockerfile).FullName,
540                      imageName);
541                  if (buildExitCode == 0)
542                  {
543                      break;
544                  }
545                  else
546                  {
547                      retryCount++;
548                      if (retryCount &lt; 3)
549                      {
550                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
551                          executionContext.Warning($&quot;Docker build failed with exit code {buildExitCode}, back off {backOff.TotalSeconds} seconds before retry.&quot;);
552                          await Task.Delay(backOff);
553                      }
554                  }
555              }
556              executionContext.Output(&quot;##[endgroup]&quot;);
557              if (retryCount == 3 &amp;&amp; buildExitCode != 0)
558              {
559                  throw new InvalidOperationException($&quot;Docker build failed with exit code {buildExitCode}&quot;);
560              }
561              foreach (var stepId in setupInfo.StepIds)
562              {
563                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = imageName };
564                  Trace.Info($&quot;Prepared docker image &#x27;{imageName}&#x27; for action {stepId} ({setupInfo.Container.Dockerfile})&quot;);
565              }
566          }
567          private async Task&lt;IDictionary&lt;string, WebApi.ActionDownloadInfo&gt;&gt; GetDownloadInfoAsync(IExecutionContext executionContext, List&lt;Pipelines.ActionStep&gt; actions)
568          {
569              executionContext.Output(&quot;Getting action download info&quot;);
570              var actionReferences = actions
571                  .GroupBy(x =&gt; GetDownloadInfoLookupKey(x))
572                  .Where(x =&gt; !string.IsNullOrEmpty(x.Key))
573                  .Select(x =&gt;
574                  {
575                      var action = x.First();
576                      var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
577                      ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
578                      return new WebApi.ActionReference
579                      {
580                          NameWithOwner = repositoryReference.Name,
581                          Ref = repositoryReference.Ref,
582                          Path = repositoryReference.Path,
583                      };
584                  })
585                  .ToList();
586              if (actionReferences.Count == 0)
587              {
588                  return new Dictionary&lt;string, WebApi.ActionDownloadInfo&gt;();
589              }
590              var launchServer = HostContext.GetService&lt;ILaunchServer&gt;();
591              var jobServer = HostContext.GetService&lt;IJobServer&gt;();
592              var actionDownloadInfos = default(WebApi.ActionDownloadInfoCollection);
593              for (var attempt = 1; attempt &lt;= 3; attempt++)
594              {
595                  try
596                  {
597                      if (MessageUtil.IsRunServiceJob(executionContext.Global.Variables.Get(Constants.Variables.System.JobRequestType)))
598                      {
599                          actionDownloadInfos = await launchServer.ResolveActionsDownloadInfoAsync(executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
600                      }
601                      else
602                      {
603                          actionDownloadInfos = await jobServer.ResolveActionDownloadInfoAsync(executionContext.Global.Plan.ScopeIdentifier, executionContext.Global.Plan.PlanType, executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
604                      }
605                      break;
606                  }
607                  catch (Exception ex) when (!executionContext.CancellationToken.IsCancellationRequested) 
608                  {
609                      if (attempt &lt; 3 &amp;&amp; !(ex is WebApi.UnresolvableActionDownloadInfoException))
610                      {
611                          executionContext.Output($&quot;Failed to resolve action download info. Error: {ex.Message}&quot;);
612                          executionContext.Debug(ex.ToString());
613                          if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable(&quot;_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF&quot;)))
614                          {
615                              var backoff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
616                              executionContext.Output($&quot;Retrying in {backoff.TotalSeconds} seconds&quot;);
617                              await Task.Delay(backoff);
618                          }
619                      }
620                      else
621                      {
622                          if (ex is WebApi.UnresolvableActionDownloadInfoException)
623                          {
624                              throw;
625                          }
626                          else
627                          {
628                              throw new WebApi.FailedToResolveActionDownloadInfoException(&quot;Failed to resolve action download info.&quot;, ex);
629                          }
630                      }
631                  }
632              }
633              ArgUtil.NotNull(actionDownloadInfos, nameof(actionDownloadInfos));
634              ArgUtil.NotNull(actionDownloadInfos.Actions, nameof(actionDownloadInfos.Actions));
635              var apiUrl = GetApiUrl(executionContext);
636              var defaultAccessToken = executionContext.GetGitHubContext(&quot;token&quot;);
637              var configurationStore = HostContext.GetService&lt;IConfigurationStore&gt;();
638              var runnerSettings = configurationStore.GetSettings();
639              foreach (var actionDownloadInfo in actionDownloadInfos.Actions.Values)
640              {
641                  HostContext.SecretMasker.AddValue(actionDownloadInfo.Authentication?.Token);
642                  if (string.IsNullOrEmpty(actionDownloadInfo.Authentication?.Token))
643                  {
644                      actionDownloadInfo.Authentication = new WebApi.ActionDownloadAuthentication { Token = defaultAccessToken };
645                  }
646              }
647              return actionDownloadInfos.Actions;
648          }
649          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo)
650          {
651              Trace.Entering();
652              ArgUtil.NotNull(executionContext, nameof(executionContext));
653              ArgUtil.NotNull(downloadInfo, nameof(downloadInfo));
654              ArgUtil.NotNullOrEmpty(downloadInfo.NameWithOwner, nameof(downloadInfo.NameWithOwner));
655              ArgUtil.NotNullOrEmpty(downloadInfo.Ref, nameof(downloadInfo.Ref));
656              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), downloadInfo.NameWithOwner.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), downloadInfo.Ref);
657              string watermarkFile = GetWatermarkFilePath(destDirectory);
658              if (File.Exists(watermarkFile))
659              {
660                  executionContext.Debug($&quot;Action &#x27;{downloadInfo.NameWithOwner}@{downloadInfo.Ref}&#x27; already downloaded at &#x27;{destDirectory}&#x27;.&quot;);
661                  return;
662              }
663              else
664              {
665                  IOUtil.DeleteDirectory(destDirectory, executionContext.CancellationToken);
666                  Directory.CreateDirectory(destDirectory);
667                  executionContext.Output($&quot;Download action repository &#x27;{downloadInfo.NameWithOwner}@{downloadInfo.Ref}&#x27; (SHA:{downloadInfo.ResolvedSha})&quot;);
668              }
669              await DownloadRepositoryActionAsync(executionContext, downloadInfo, destDirectory);
670          }
671          private string GetApiUrl(IExecutionContext executionContext)
672          {
673              string apiUrl = executionContext.GetGitHubContext(&quot;api_url&quot;);
674              if (!string.IsNullOrEmpty(apiUrl))
675              {
676                  return apiUrl;
677              }
678              return _dotcomApiUrl;
679          }
680          private static string BuildLinkToActionArchive(string apiUrl, string repository, string @ref)
681          {
682  #if OS_WINDOWS
683              return $&quot;{apiUrl}/repos/{repository}/zipball/{@ref}&quot;;
684  #else
685              return $&quot;{apiUrl}/repos/{repository}/tarball/{@ref}&quot;;
686  #endif
687          }
688          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo, string destDirectory)
689          {
690              string tempDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), &quot;_temp_&quot; + Guid.NewGuid());
691              Directory.CreateDirectory(tempDirectory);
692  #if OS_WINDOWS
693              string archiveFile = Path.Combine(tempDirectory, $&quot;{Guid.NewGuid()}.zip&quot;);
694              string link = downloadInfo?.ZipballUrl;
695  #else
696              string archiveFile = Path.Combine(tempDirectory, $&quot;{Guid.NewGuid()}.tar.gz&quot;);
697              string link = downloadInfo?.TarballUrl;
698  #endif
699              Trace.Info($&quot;Save archive &#x27;{link}&#x27; into {archiveFile}.&quot;);
700              try
701              {
702                  int retryCount = 0;
703                  int timeoutSeconds = 20 * 60;
704                  while (retryCount &lt; 3)
705                  {
706                      using (var actionDownloadTimeout = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds)))
707                      using (var actionDownloadCancellation = CancellationTokenSource.CreateLinkedTokenSource(actionDownloadTimeout.Token, executionContext.CancellationToken))
708                      {
709                          try
710                          {
711                              using (FileStream fs = new(archiveFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: _defaultFileStreamBufferSize, useAsync: true))
712                              using (var httpClientHandler = HostContext.CreateHttpClientHandler())
713                              using (var httpClient = new HttpClient(httpClientHandler))
714                              {
715                                  httpClient.DefaultRequestHeaders.Authorization = CreateAuthHeader(downloadInfo.Authentication?.Token);
716                                  httpClient.DefaultRequestHeaders.UserAgent.AddRange(HostContext.UserAgents);
717                                  using (var response = await httpClient.GetAsync(link))
718                                  {
719                                      if (response.IsSuccessStatusCode)
720                                      {
721                                          using (var result = await response.Content.ReadAsStreamAsync())
722                                          {
723                                              await result.CopyToAsync(fs, _defaultCopyBufferSize, actionDownloadCancellation.Token);
724                                              await fs.FlushAsync(actionDownloadCancellation.Token);
725                                              break;
726                                          }
727                                      }
728                                      else if (response.StatusCode == HttpStatusCode.NotFound)
729                                      {
730                                          throw new ActionNotFoundException(new Uri(link));
731                                      }
732                                      else
733                                      {
734                                          response.EnsureSuccessStatusCode();
735                                      }
736                                  }
737                              }
738                          }
739                          catch (OperationCanceledException) when (executionContext.CancellationToken.IsCancellationRequested)
740                          {
741                              Trace.Info(&quot;Action download has been cancelled.&quot;);
742                              throw;
743                          }
744                          catch (ActionNotFoundException)
745                          {
746                              Trace.Info($&quot;The action at &#x27;{link}&#x27; does not exist&quot;);
747                              throw;
748                          }
749                          catch (Exception ex) when (retryCount &lt; 2)
750                          {
751                              retryCount++;
752                              Trace.Error($&quot;Fail to download archive &#x27;{link}&#x27; -- Attempt: {retryCount}&quot;);
753                              Trace.Error(ex);
754                              if (actionDownloadTimeout.Token.IsCancellationRequested)
755                              {
756                                  executionContext.Warning($&quot;Action &#x27;{link}&#x27; didn&#x27;t finish download within {timeoutSeconds} seconds.&quot;);
757                              }
758                              else
759                              {
760                                  executionContext.Warning($&quot;Failed to download action &#x27;{link}&#x27;. Error: {ex.Message}&quot;);
761                              }
762                          }
763                      }
764                      if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable(&quot;_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF&quot;)))
765                      {
766                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
767                          executionContext.Warning($&quot;Back off {backOff.TotalSeconds} seconds before retry.&quot;);
768                          await Task.Delay(backOff);
769                      }
770                  }
771                  ArgUtil.NotNullOrEmpty(archiveFile, nameof(archiveFile));
772                  executionContext.Debug($&quot;Download &#x27;{link}&#x27; to &#x27;{archiveFile}&#x27;&quot;);
773                  var stagingDirectory = Path.Combine(tempDirectory, &quot;_staging&quot;);
774                  Directory.CreateDirectory(stagingDirectory);
775  #if OS_WINDOWS
776                  ZipFile.ExtractToDirectory(archiveFile, stagingDirectory);
777  #else
778                  string tar = WhichUtil.Which(&quot;tar&quot;, require: true, trace: Trace);
779                  using (var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;())
780                  {
781                      processInvoker.OutputDataReceived += new EventHandler&lt;ProcessDataReceivedEventArgs&gt;((sender, args) =&gt;
782                      {
783                          if (!string.IsNullOrEmpty(args.Data))
784                          {
785                              Trace.Info(args.Data);
786                          }
787                      });
788                      processInvoker.ErrorDataReceived += new EventHandler&lt;ProcessDataReceivedEventArgs&gt;((sender, args) =&gt;
789                      {
790                          if (!string.IsNullOrEmpty(args.Data))
791                          {
792                              Trace.Error(args.Data);
793                          }
794                      });
795                      int exitCode = await processInvoker.ExecuteAsync(stagingDirectory, tar, $&quot;-xzf \&quot;{archiveFile}\&quot;&quot;, null, executionContext.CancellationToken);
796                      if (exitCode != 0)
797                      {
798                          throw new NotSupportedException($&quot;Can&#x27;t use &#x27;tar -xzf&#x27; extract archive file: {archiveFile}. return code: {exitCode}.&quot;);
799                      }
800                  }
801  #endif
802                  var subDirectories = new DirectoryInfo(stagingDirectory).GetDirectories();
803                  if (subDirectories.Length != 1)
804                  {
805                      throw new InvalidOperationException($&quot;&#x27;{archiveFile}&#x27; contains &#x27;{subDirectories.Length}&#x27; directories&quot;);
806                  }
807                  else
808                  {
809                      executionContext.Debug($&quot;Unwrap &#x27;{subDirectories[0].Name}&#x27; to &#x27;{destDirectory}&#x27;&quot;);
810                      IOUtil.CopyDirectory(subDirectories[0].FullName, destDirectory, executionContext.CancellationToken);
811                  }
812                  Trace.Verbose(&quot;Create watermark file indicate action download succeed.&quot;);
813                  string watermarkFile = GetWatermarkFilePath(destDirectory);
814                  File.WriteAllText(watermarkFile, DateTime.UtcNow.ToString());
815                  executionContext.Debug($&quot;Archive &#x27;{archiveFile}&#x27; has been unzipped into &#x27;{destDirectory}&#x27;.&quot;);
816                  Trace.Info(&quot;Finished getting action repository.&quot;);
817              }
818              finally
819              {
820                  try
821                  {
822                      if (Directory.Exists(tempDirectory))
823                      {
824                          Trace.Verbose(&quot;Deleting action temp folder: {0}&quot;, tempDirectory);
825                          IOUtil.DeleteDirectory(tempDirectory, CancellationToken.None); 
826                      }
827                  }
828                  catch (Exception ex)
829                  {
830                      Trace.Warning(&quot;Failed to delete temp folder &#x27;{0}&#x27;. Exception: {1}&quot;, tempDirectory, ex);
831                  }
832              }
833          }
834          private void ConfigureAuthorizationFromContext(IExecutionContext executionContext, HttpClient httpClient)
835          {
836              var authToken = Environment.GetEnvironmentVariable(&quot;_GITHUB_ACTION_TOKEN&quot;);
837              if (string.IsNullOrEmpty(authToken))
838              {
839                  authToken = executionContext.Global.Variables.Get(&quot;PREVIEW_ACTION_TOKEN&quot;);
840              }
841              if (!string.IsNullOrEmpty(authToken))
842              {
843                  HostContext.SecretMasker.AddValue(authToken);
<span onclick='openModal()' class='match'>844                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;PAT:{authToken}&quot;));
845                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
</span>846              }
847              else
848              {
849                  var accessToken = executionContext.GetGitHubContext(&quot;token&quot;);
850                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{accessToken}&quot;));
851                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
852              }
853          }
854          private string GetWatermarkFilePath(string directory) =&gt; directory + &quot;.completed&quot;;
855          private ActionSetupInfo PrepareRepositoryActionAsync(IExecutionContext executionContext, Pipelines.ActionStep repositoryAction)
856          {
857              var repositoryReference = repositoryAction.Reference as Pipelines.RepositoryPathReference;
858              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
859              {
860                  Trace.Info($&quot;Repository action is in &#x27;self&#x27; repository.&quot;);
861                  return null;
862              }
863              var setupInfo = new ActionSetupInfo();
864              var actionContainer = new ActionContainer();
865              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repositoryReference.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repositoryReference.Ref);
866              string actionEntryDirectory = destDirectory;
867              string dockerFileRelativePath = repositoryReference.Name;
868              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
869              if (!string.IsNullOrEmpty(repositoryReference.Path))
870              {
871                  actionEntryDirectory = Path.Combine(destDirectory, repositoryReference.Path);
872                  dockerFileRelativePath = $&quot;{dockerFileRelativePath}/{repositoryReference.Path}&quot;;
873                  actionContainer.ActionRepository = $&quot;{repositoryReference.Name}/{repositoryReference.Path}@{repositoryReference.Ref}&quot;;
874              }
875              else
876              {
877                  actionContainer.ActionRepository = $&quot;{repositoryReference.Name}@{repositoryReference.Ref}&quot;;
878              }
879              var dockerFile = Path.Combine(actionEntryDirectory, &quot;Dockerfile&quot;);
880              var dockerFileLowerCase = Path.Combine(actionEntryDirectory, &quot;dockerfile&quot;);
881              var actionManifest = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYmlFile);
882              var actionManifestYaml = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYamlFile);
883              if (File.Exists(actionManifest) || File.Exists(actionManifestYaml))
884              {
885                  executionContext.Debug($&quot;action.yml for action: &#x27;{actionManifest}&#x27;.&quot;);
886                  var manifestManager = HostContext.GetService&lt;IActionManifestManager&gt;();
887                  ActionDefinitionData actionDefinitionData = null;
888                  if (File.Exists(actionManifest))
889                  {
890                      actionDefinitionData = manifestManager.Load(executionContext, actionManifest);
891                  }
892                  else
893                  {
894                      actionDefinitionData = manifestManager.Load(executionContext, actionManifestYaml);
895                  }
896                  if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Container)
897                  {
898                      var containerAction = actionDefinitionData.Execution as ContainerActionExecutionData;
899                      if (DockerUtil.IsDockerfile(containerAction.Image))
900                      {
901                          var dockerFileFullPath = Path.Combine(actionEntryDirectory, containerAction.Image);
902                          executionContext.Debug($&quot;Dockerfile for action: &#x27;{dockerFileFullPath}&#x27;.&quot;);
903                          actionContainer.Dockerfile = dockerFileFullPath;
904                          actionContainer.WorkingDirectory = destDirectory;
905                          setupInfo.Container = actionContainer;
906                          return setupInfo;
907                      }
908                      else if (containerAction.Image.StartsWith(&quot;docker:&amp;bsol;&amp;bsol;&quot;, StringComparison.OrdinalIgnoreCase))
909                      {
910                          var actionImage = containerAction.Image.Substring(&quot;docker:&amp;bsol;&amp;bsol;&quot;.Length);
911                          executionContext.Debug($&quot;Container image for action: &#x27;{actionImage}&#x27;.&quot;);
912                          actionContainer.Image = actionImage;
913                          setupInfo.Container = actionContainer;
914                          return setupInfo;
915                      }
916                      else
917                      {
918                          throw new NotSupportedException($&quot;&#x27;{containerAction.Image}&#x27; should be either &#x27;[path]/Dockerfile&#x27; or &#x27;docker:&amp;bsol;&amp;bsol;image[:tag]&#x27;.&quot;);
919                      }
920                  }
921                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.NodeJS)
922                  {
923                      Trace.Info($&quot;Action node.js file: {(actionDefinitionData.Execution as NodeJSActionExecutionData).Script}, no more preparation.&quot;);
924                      return null;
925                  }
926                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Plugin)
927                  {
928                      Trace.Info($&quot;Action plugin: {(actionDefinitionData.Execution as PluginActionExecutionData).Plugin}, no more preparation.&quot;);
929                      return null;
930                  }
931                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Composite)
932                  {
933                      Trace.Info($&quot;Loading Composite steps&quot;);
934                      var compositeAction = actionDefinitionData.Execution as CompositeActionExecutionData;
935                      setupInfo.Steps = compositeAction.Steps;
936                      if (!_cachedEmbeddedStepIds.ContainsKey(repositoryAction.Id))
937                      {
938                          _cachedEmbeddedStepIds[repositoryAction.Id] = new List&lt;Guid&gt;();
939                          foreach (var compositeStep in compositeAction.Steps)
940                          {
941                              var guid = Guid.NewGuid();
942                              compositeStep.Id = guid;
943                              _cachedEmbeddedStepIds[repositoryAction.Id].Add(guid);
944                          }
945                      }
946                      foreach (var step in compositeAction.Steps)
947                      {
948                          if (string.IsNullOrEmpty(executionContext.Global.Variables.Get(&quot;DistributedTask.EnableCompositeActions&quot;)) &amp;&amp; step.Reference.Type != Pipelines.ActionSourceType.Script)
949                          {
950                              throw new Exception(&quot;`uses:` keyword is not currently supported.&quot;);
951                          }
952                      }
953                      return setupInfo;
954                  }
955                  else
956                  {
957                      throw new NotSupportedException(actionDefinitionData.Execution.ExecutionType.ToString());
958                  }
959              }
960              else if (File.Exists(dockerFile))
961              {
962                  executionContext.Debug($&quot;Dockerfile for action: &#x27;{dockerFile}&#x27;.&quot;);
963                  actionContainer.Dockerfile = dockerFile;
964                  actionContainer.WorkingDirectory = destDirectory;
965                  setupInfo.Container = actionContainer;
966                  return setupInfo;
967              }
968              else if (File.Exists(dockerFileLowerCase))
969              {
970                  executionContext.Debug($&quot;Dockerfile for action: &#x27;{dockerFileLowerCase}&#x27;.&quot;);
971                  actionContainer.Dockerfile = dockerFileLowerCase;
972                  actionContainer.WorkingDirectory = destDirectory;
973                  setupInfo.Container = actionContainer;
974                  return setupInfo;
975              }
976              else
977              {
978                  var fullPath = IOUtil.ResolvePath(actionEntryDirectory, &quot;.&quot;); 
979                  throw new InvalidOperationException($&quot;Can&#x27;t find &#x27;action.yml&#x27;, &#x27;action.yaml&#x27; or &#x27;Dockerfile&#x27; under &#x27;{fullPath}&#x27;. Did you forget to run actions/checkout before running your local action?&quot;);
980              }
981          }
982          private static string GetDownloadInfoLookupKey(Pipelines.ActionStep action)
983          {
984              if (action.Reference.Type != Pipelines.ActionSourceType.Repository)
985              {
986                  return null;
987              }
988              var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
989              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
990              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
991              {
992                  return null;
993              }
994              if (!string.Equals(repositoryReference.RepositoryType, Pipelines.RepositoryTypes.GitHub, StringComparison.OrdinalIgnoreCase))
995              {
996                  throw new NotSupportedException(repositoryReference.RepositoryType);
997              }
998              ArgUtil.NotNullOrEmpty(repositoryReference.Name, nameof(repositoryReference.Name));
999              ArgUtil.NotNullOrEmpty(repositoryReference.Ref, nameof(repositoryReference.Ref));
1000              return $&quot;{repositoryReference.Name}@{repositoryReference.Ref}&quot;;
1001          }
1002          private static string GetDownloadInfoLookupKey(WebApi.ActionDownloadInfo info)
1003          {
1004              ArgUtil.NotNullOrEmpty(info.NameWithOwner, nameof(info.NameWithOwner));
1005              ArgUtil.NotNullOrEmpty(info.Ref, nameof(info.Ref));
1006              return $&quot;{info.NameWithOwner}@{info.Ref}&quot;;
1007          }
1008          private AuthenticationHeaderValue CreateAuthHeader(string token)
1009          {
1010              if (string.IsNullOrEmpty(token))
1011              {
1012                  return null;
1013              }
1014              var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{token}&quot;));
1015              HostContext.SecretMasker.AddValue(base64EncodingToken);
1016              return new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
1017          }
1018      }
1019      public sealed class Definition
1020      {
1021          public ActionDefinitionData Data { get; set; }
1022          public string Directory { get; set; }
1023      }
1024      public sealed class ActionDefinitionData
1025      {
1026          public string Name { get; set; }
1027          public string Description { get; set; }
1028          public MappingToken Inputs { get; set; }
1029          public ActionExecutionData Execution { get; set; }
1030          public Dictionary&lt;String, String&gt; Deprecated { get; set; }
1031      }
1032      public enum ActionExecutionType
1033      {
1034          Container,
1035          NodeJS,
1036          Plugin,
1037          Script,
1038          Composite,
1039      }
1040      public sealed class ContainerActionExecutionData : ActionExecutionData
1041      {
1042          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Container;
1043          public override bool HasPre =&gt; !string.IsNullOrEmpty(Pre);
1044          public override bool HasPost =&gt; !string.IsNullOrEmpty(Post);
1045          public string Image { get; set; }
1046          public string EntryPoint { get; set; }
1047          public SequenceToken Arguments { get; set; }
1048          public MappingToken Environment { get; set; }
1049          public string Pre { get; set; }
1050          public string Post { get; set; }
1051      }
1052      public sealed class NodeJSActionExecutionData : ActionExecutionData
1053      {
1054          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.NodeJS;
1055          public override bool HasPre =&gt; !string.IsNullOrEmpty(Pre);
1056          public override bool HasPost =&gt; !string.IsNullOrEmpty(Post);
1057          public string Script { get; set; }
1058          public string Pre { get; set; }
1059          public string Post { get; set; }
1060          public string NodeVersion { get; set; }
1061      }
1062      public sealed class PluginActionExecutionData : ActionExecutionData
1063      {
1064          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Plugin;
1065          public override bool HasPre =&gt; false;
1066          public override bool HasPost =&gt; !string.IsNullOrEmpty(Post);
1067          public string Plugin { get; set; }
1068          public string Post { get; set; }
1069      }
1070      public sealed class ScriptActionExecutionData : ActionExecutionData
1071      {
1072          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Script;
1073          public override bool HasPre =&gt; false;
1074          public override bool HasPost =&gt; false;
1075      }
1076      public sealed class CompositeActionExecutionData : ActionExecutionData
1077      {
1078          public override ActionExecutionType ExecutionType =&gt; ActionExecutionType.Composite;
1079          public override bool HasPre =&gt; PreSteps.Count &gt; 0;
1080          public override bool HasPost =&gt; PostSteps.Count &gt; 0;
1081          public List&lt;Pipelines.ActionStep&gt; PreSteps { get; set; }
1082          public List&lt;Pipelines.ActionStep&gt; Steps { get; set; }
1083          public Stack&lt;Pipelines.ActionStep&gt; PostSteps { get; set; }
1084          public MappingToken Outputs { get; set; }
1085      }
1086      public abstract class ActionExecutionData
1087      {
1088          private string _initCondition = $&quot;{Constants.Expressions.Always}()&quot;;
1089          private string _cleanupCondition = $&quot;{Constants.Expressions.Always}()&quot;;
1090          public abstract ActionExecutionType ExecutionType { get; }
1091          public abstract bool HasPre { get; }
1092          public abstract bool HasPost { get; }
1093          public string CleanupCondition
1094          {
1095              get { return _cleanupCondition; }
1096              set { _cleanupCondition = value; }
1097          }
1098          public string InitCondition
1099          {
1100              get { return _initCondition; }
1101              set { _initCondition = value; }
1102          }
1103      }
1104      public class ContainerSetupInfo
1105      {
1106          public ContainerSetupInfo(List&lt;Guid&gt; ids, string image)
1107          {
1108              StepIds = ids;
1109              Container = new ActionContainer()
1110              {
1111                  Image = image
1112              };
1113          }
1114          public ContainerSetupInfo(List&lt;Guid&gt; ids, string dockerfile, string workingDirectory)
1115          {
1116              StepIds = ids;
1117              Container = new ActionContainer()
1118              {
1119                  Dockerfile = dockerfile,
1120                  WorkingDirectory = workingDirectory
1121              };
1122          }
1123          public List&lt;Guid&gt; StepIds { get; set; }
1124          public ActionContainer Container { get; set; }
1125      }
1126      public class ActionContainer
1127      {
1128          public string Image { get; set; }
1129          public string Dockerfile { get; set; }
1130          public string WorkingDirectory { get; set; }
1131          public string ActionRepository { get; set; }
1132      }
1133      public class ActionSetupInfo
1134      {
1135          public ActionContainer Container { get; set; }
1136          public List&lt;Pipelines.ActionStep&gt; Steps { get; set; }
1137      }
1138      public class PrepareActionsState
1139      {
1140          public Dictionary&lt;string, List&lt;Guid&gt;&gt; ImagesToPull;
1141          public Dictionary&lt;string, List&lt;Guid&gt;&gt; ImagesToBuild;
1142          public Dictionary&lt;string, ActionContainer&gt; ImagesToBuildInfo;
1143          public Dictionary&lt;Guid, IActionRunner&gt; PreStepTracker;
1144      }
1145  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>1014              var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;x-access-token:{token}&quot;));
1015              HostContext.SecretMasker.AddValue(base64EncodingToken);
</pre></code></div>
                <div class="column column_space"><pre><code>844                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($&quot;PAT:{authToken}&quot;));
845                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Basic&quot;, base64EncodingToken);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    