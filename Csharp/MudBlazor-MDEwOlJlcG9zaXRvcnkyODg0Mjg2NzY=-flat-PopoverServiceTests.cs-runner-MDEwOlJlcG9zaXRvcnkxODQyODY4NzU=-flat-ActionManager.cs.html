
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-PopoverServiceTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using FluentAssertions;
7  using Microsoft.AspNetCore.Components;
8  using Microsoft.Extensions.Logging.Abstractions;
9  using Microsoft.JSInterop;
10  using Microsoft.JSInterop.Infrastructure;
11  using Moq;
12  using MudBlazor.Interop;
13  using MudBlazor.UnitTests.Services.Popover.Mocks;
14  using MudBlazor.Utilities.Background.Batch;
15  using NUnit.Framework;
16  namespace MudBlazor.UnitTests.Services.Popover;
17  #nullable enable
18  [TestFixture]
19  public class PopoverServiceTests
20  {
21      [Test]
22      public void ActivePopovers_ShouldBeEmpty_AtInitialization()
23      {
24          var jsRuntimeMock = Mock.Of<IJSRuntime>();
25          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
26          Assert.IsEmpty(service.ActivePopovers);
27      }
28      [Test]
29      public void IsInitialized_ShouldBeFalse_AtInitialization()
30      {
31          var jsRuntimeMock = Mock.Of<IJSRuntime>();
32          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
33          Assert.IsFalse(service.IsInitialized);
34      }
35      [Test]
36      public async Task IsInitialized_ShouldConnectAutomaticallyAfterCreatePopoverAsync()
37      {
38          var jsRuntimeMock = Mock.Of<IJSRuntime>();
39          var popover = new PopoverMock();
40          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
41          Assert.IsFalse(service.IsInitialized);
42          await service.CreatePopoverAsync(popover);
43          Assert.IsTrue(service.IsInitialized);
44      }
45      [Test]
46      public async Task IsInitialized_ShouldConnectAutomaticallyAfterDestroyPopoverAsync()
47      {
48          var jsRuntimeMock = Mock.Of<IJSRuntime>();
49          var popover = new PopoverMock();
50          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
51          Assert.IsFalse(service.IsInitialized);
52          await service.DestroyPopoverAsync(popover);
53          Assert.IsTrue(service.IsInitialized);
54      }
55      [Test]
56      public async Task IsInitialized_ShouldConnectAutomaticallyAfterUpdatePopoverAsync()
57      {
58          var jsRuntimeMock = Mock.Of<IJSRuntime>();
59          var popover = new PopoverMock();
60          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
61          Assert.IsFalse(service.IsInitialized);
62          await service.UpdatePopoverAsync(popover);
63          Assert.IsTrue(service.IsInitialized);
64      }
65      [Test]
66      public async Task IsInitialized_ShouldConnectAutomaticallyAfterCountProvidersAsync()
67      {
68          var jsRuntimeMock = Mock.Of<IJSRuntime>();
69          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
70          Assert.IsFalse(service.IsInitialized);
71          await service.GetProviderCountAsync();
72          Assert.IsTrue(service.IsInitialized);
73      }
74      [Test]
75      public async Task CreatePopoverAsync_ShouldAddStateAndNotifyObservers()
76      {
77          var jsRuntimeMock = Mock.Of<IJSRuntime>();
78          var popover = new PopoverMock();
79          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
80          var observer = new PopoverObserverMock();
81          service.Subscribe(observer);
82          await service.CreatePopoverAsync(popover);
83          var activePopovers = service.ActivePopovers.Select(x => x.Id).ToList();
84          Assert.AreEqual(1, observer.PopoverNotifications.Count);
85          Assert.Contains(popover.Id, observer.PopoverNotifications);
86          Assert.Contains(popover.Id, activePopovers);
87      }
88      [Test]
89      public async Task UpdatePopoverAsync_ShouldNotUpdateWhenNotCreated()
90      {
91          var jsRuntimeMock = Mock.Of<IJSRuntime>();
92          var popover = new PopoverMock();
93          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
94          var observer = new PopoverObserverMock();
95          service.Subscribe(observer);
96          var result = await service.UpdatePopoverAsync(popover);
97          Assert.IsFalse(result);
98          Assert.IsEmpty(observer.PopoverNotifications);
99      }
100      [Test]
101      public async Task UpdatePopoverAsync_ShouldNotDestroyWhenNotCreated()
102      {
103          var jsRuntimeMock = Mock.Of<IJSRuntime>();
104          var popover = new PopoverMock();
105          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
106          var observer = new PopoverObserverMock();
107          service.Subscribe(observer);
108          var result = await service.DestroyPopoverAsync(popover);
109          Assert.IsFalse(result);
110          Assert.IsEmpty(observer.PopoverNotifications);
111      }
112      [Test]
113      public async Task UpdatePopoverAsync_ShouldUpdateState()
114      {
115          var jsRuntimeMock = Mock.Of<IJSRuntime>();
116          var popover = new PopoverMock();
117          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
118          var observer = new PopoverObserverMock();
119          service.Subscribe(observer);
120          await service.CreatePopoverAsync(popover);
121          RenderFragment newRenderFragment = _ => { };
122          popover.ChildContent = newRenderFragment;
123          popover.Open = true;
124          popover.PopoverClass = "popoverClass";
125          popover.PopoverStyles = "popoverStyle";
126          popover.Tag = "my-tag";
127          popover.UserAttributes = new Dictionary<string, object?>
128          {
129              { "key1", "value1" },
130              { "key2", false }
131          };
132          var updatedState = service.ActivePopovers.FirstOrDefault(x => x.Id == popover.Id);
133          Assert.NotNull(updatedState);
134          Assert.IsFalse(updatedState!.ShowContent);
135          Assert.IsEmpty(updatedState.Class);
136          Assert.IsEmpty(updatedState.Style);
137          Assert.IsNull(updatedState.Tag);
138          Assert.IsEmpty(updatedState.UserAttributes);
139          Assert.IsNull(updatedState.Fragment);
140          var isUpdated = await service.UpdatePopoverAsync(popover);
141          Assert.IsTrue(isUpdated);
142          Assert.AreEqual(popover.Open, updatedState.ShowContent);
143          Assert.AreEqual(popover.PopoverClass, updatedState.Class);
144          Assert.AreEqual(popover.PopoverStyles, updatedState.Style);
145          Assert.AreEqual(popover.Tag, updatedState.Tag);
146          Assert.AreEqual(popover.UserAttributes, updatedState.UserAttributes);
147          Assert.AreEqual(newRenderFragment, updatedState.Fragment);
148          Assert.AreEqual(2, observer.PopoverNotifications.Count);
149          Assert.Contains(popover.Id, observer.PopoverNotifications);
150      }
151      [Test]
152      public async Task UpdatePopoverAsync_ShouldNotUpdateStateWhenDestroyed()
153      {
154          var jsRuntimeMock = Mock.Of<IJSRuntime>();
155          var popover = new PopoverMock();
156          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
157          var observer = new PopoverObserverMock();
158          service.Subscribe(observer);
159          await service.CreatePopoverAsync(popover);
160          var updatedState = service.ActivePopovers.FirstOrDefault(x => x.Id == popover.Id);
161          var isDestroyed = await service.DestroyPopoverAsync(popover);
162          popover.Open = true;
163          popover.PopoverClass = "popoverClass";
164          popover.PopoverStyles = "popoverStyle";
165          popover.Tag = "my-tag";
166          popover.UserAttributes = new Dictionary<string, object?>
167          {
168              { "key1", "value1" },
169              { "key2", false }
170          };
171          var isUpdated = await service.UpdatePopoverAsync(popover);
172          Assert.NotNull(updatedState);
173          Assert.IsTrue(isDestroyed);
174          Assert.IsFalse(isUpdated);
175          Assert.IsFalse(updatedState!.ShowContent);
176          Assert.IsEmpty(updatedState.Class);
177          Assert.IsEmpty(updatedState.Style);
178          Assert.IsNull(updatedState.Tag);
179          Assert.IsEmpty(updatedState.UserAttributes);
180          Assert.AreEqual(2, observer.PopoverNotifications.Count);
181          Assert.Contains(popover.Id, observer.PopoverNotifications);
182      }
183      [Test]
184      public async Task DestroyPopoverAsync_ShouldRemoveStateAndNotifyObservers()
185      {
186          var jsRuntimeMock = Mock.Of<IJSRuntime>();
187          var popover = new PopoverMock();
188          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
189          var observer = new PopoverObserverMock();
190          service.Subscribe(observer);
191          await service.CreatePopoverAsync(popover);
192          var isDestroyed = await service.DestroyPopoverAsync(popover);
193          Assert.True(isDestroyed);
194          Assert.IsEmpty(service.ActivePopovers);
195          Assert.AreEqual(2, observer.PopoverNotifications.Count);
196          Assert.Contains(popover.Id, observer.PopoverNotifications);
197      }
198      [Test]
199      public async Task DestroyPopoverAsync_ShouldQueueForDisconnect()
200      {
201          var jsRuntimeMock = Mock.Of<IJSRuntime>();
202          var popoverOne = new PopoverMock();
203          var popoverTwo = new PopoverMock();
204          var popoverThree = new PopoverMock();
205          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
206          await service.CreatePopoverAsync(popoverOne);
207          await service.CreatePopoverAsync(popoverTwo);
208          await service.CreatePopoverAsync(popoverThree);
209          var isDestroyedOne = await service.DestroyPopoverAsync(popoverOne);
210          var isDestroyedTwo = await service.DestroyPopoverAsync(popoverTwo);
211          var isDestroyedThree = await service.DestroyPopoverAsync(popoverThree);
212          Assert.AreEqual(3, service.QueueCount);
213          Assert.True(isDestroyedOne);
214          Assert.True(isDestroyedTwo);
215          Assert.True(isDestroyedThree);
216      }
217      [Test]
218      public async Task CreatePopoverAsync_UpdatePopoverAsync_DestroyPopoverAsync_ShouldNotifyContainerWithCorrespondingOperation()
219      {
220          var containerNotificationList = new List<PopoverHolderContainer>();
221          var jsRuntimeMock = Mock.Of<IJSRuntime>();
222          var popover = new PopoverMock();
223          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
224          var observerMock = new Mock<IPopoverObserver>();
225          service.Subscribe(observerMock.Object);
226          observerMock
227              .Setup(h => h.PopoverCollectionUpdatedNotificationAsync(
228                  It.IsAny<PopoverHolderContainer>()))
229              .Returns(Task.CompletedTask)
230              .Callback<PopoverHolderContainer>(containerNotificationList.Add);
231          await service.CreatePopoverAsync(popover);
232          await service.UpdatePopoverAsync(popover);
233          await service.DestroyPopoverAsync(popover);
234          var firstNotification = containerNotificationList.ElementAt(0);
235          var secondNotification = containerNotificationList.ElementAt(1);
236          var thirdNotification = containerNotificationList.ElementAt(2);
237          Assert.AreEqual(3, containerNotificationList.Count);
238          Assert.AreEqual(PopoverHolderOperation.Create, firstNotification.Operation);
239          Assert.AreEqual(PopoverHolderOperation.Update, secondNotification.Operation);
240          Assert.AreEqual(PopoverHolderOperation.Remove, thirdNotification.Operation);
241      }
242      [Test]
243      public async Task MudPopoverState_ShouldIsConnected()
244      {
245          var jsRuntimeMock = Mock.Of<IJSRuntime>();
246          var popover = new PopoverMock();
247          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
248          await service.CreatePopoverAsync(popover);
249          var updatedState = service.ActivePopovers.FirstOrDefault(x => x.Id == popover.Id);
250          Assert.NotNull(updatedState);
251          Assert.IsFalse(updatedState!.IsConnected);
252          Assert.IsFalse(updatedState.IsDetached);
253          var isUpdated = await service.UpdatePopoverAsync(popover);
254          Assert.IsTrue(isUpdated);
255          Assert.IsTrue(updatedState.IsConnected);
256          Assert.IsFalse(updatedState.IsDetached);
257      }
258      [Test]
259      public async Task MudPopoverState_ShouldIsDetached()
260      {
261          var jsRuntimeMock = Mock.Of<IJSRuntime>();
262          var popover = new PopoverMock();
263          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
264          await service.CreatePopoverAsync(popover);
265          var updatedState = service.ActivePopovers.FirstOrDefault(x => x.Id == popover.Id);
266          Assert.NotNull(updatedState);
267          Assert.IsFalse(updatedState!.IsConnected);
268          Assert.IsFalse(updatedState.IsDetached);
269          var isDestroyed = await service.DestroyPopoverAsync(popover);
270          Assert.IsTrue(isDestroyed);
271          Assert.IsFalse(updatedState.IsConnected);
272          Assert.IsTrue(updatedState.IsDetached);
273      }
274      [Test]
275      public async Task CreatePopoverAsync_UpdatePopoverAsync_DestroyPopoverAsync_ShouldInvokeJS()
276      {
277          var jsRuntimeMock = new Mock<IJSRuntime>();
278          var popover = new PopoverMock();
279          var popoverTimerMock = new Mock<PopoverServiceMock.IPopoverTimerMock>();
280          var signalEvent = new ManualResetEventSlim(false);
281          var service = new PopoverServiceMock(NullLogger<PopoverService>.Instance, jsRuntimeMock.Object, popoverTimerMock.Object);
282          var observer = new PopoverObserverMock();
283          service.Subscribe(observer);
284          popoverTimerMock
285              .Setup(h => h.OnBatchTimerElapsedAfterAsync(
286                  It.IsAny<IReadOnlyCollection<MudPopoverHolder>>(),
287                  It.IsAny<CancellationToken>()))
288              .Returns(Task.CompletedTask)
289              .Callback(signalEvent.Set);
290          jsRuntimeMock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.initialize",
291                  It.Is<object[]>(y => y.Length == 2)))
292              .ReturnsAsync(Mock.Of<IJSVoidResult>())
293              .Verifiable();
294          jsRuntimeMock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.connect",
295                  It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == popover.Id)))
296              .ReturnsAsync(Mock.Of<IJSVoidResult>())
297              .Verifiable();
298          jsRuntimeMock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.disconnect",
299                  It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == popover.Id)))
300              .Returns(new ValueTask<IJSVoidResult>())
301              .Verifiable();
302          await service.CreatePopoverAsync(popover);
303          popover.ChildContent = _ => { };
304          popover.PopoverClass = "my-new-extra-class";
305          popover.PopoverStyles = "my-new-extra-style:2px";
306          popover.Open = true;
307          await service.UpdatePopoverAsync(popover);
308          await service.DestroyPopoverAsync(popover);
309          var signalEventWaitTime = service.PopoverOptions.QueueDelay.Add(TimeSpan.FromMinutes(2));
310          signalEvent.Wait(signalEventWaitTime);
311          jsRuntimeMock.Verify();
312          jsRuntimeMock.VerifyNoOtherCalls();
313      }
314      [Test]
315      [Ignore(reason:
316          $"Not used anymore and replace by {nameof(DisposeAsync_ShouldClearActivePopovers)}," +
317          $"because the {nameof(PopoverService.DisposeAsync)} doesn't trigger a guaranteed {nameof(IBatchTimerHandler<MudPopoverHolder>.OnBatchTimerElapsedAsync)} to disconnect popover," +
318          $"since the {nameof(PopoverJsInterop.Dispose)} does it.")]
319      public async Task DisposeAsync_ShouldClearActivePopoversAndFireOnBatchTimerElapsedAsync()
320      {
321          var jsRuntimeMock = Mock.Of<IJSRuntime>();
<span onclick='openModal()' class='match'>322          var popoverTimerMock = new Mock<PopoverServiceMock.IPopoverTimerMock>();
323          var signalEvent = new ManualResetEventSlim(false);
</span>324          var service = new PopoverServiceMock(NullLogger<PopoverService>.Instance, jsRuntimeMock, popoverTimerMock.Object);
325          var observer = new PopoverObserverMock();
326          service.Subscribe(observer);
327          popoverTimerMock
328              .Setup(h => h.OnBatchTimerElapsedAfterAsync(
329                  It.IsAny<IReadOnlyCollection<MudPopoverHolder>>(),
330                  It.IsAny<CancellationToken>()))
331              .Returns(Task.CompletedTask)
332              .Callback(signalEvent.Set);
333          await service.CreatePopoverAsync(new PopoverMock());
334          await service.CreatePopoverAsync(new PopoverMock());
335          await service.DisposeAsync();
336          var signalEventWaitTime = service.PopoverOptions.QueueDelay.Add(TimeSpan.FromMinutes(2));
337          var eventSignaled = signalEvent.Wait(signalEventWaitTime);
338          Assert.IsTrue(eventSignaled);
339          Assert.IsEmpty(service.ActivePopovers);
340          popoverTimerMock.Verify(
341              h => h.OnBatchTimerElapsedAfterAsync(
342                  It.Is<IReadOnlyCollection<MudPopoverHolder>>(items => items.Count == 2),
343                  It.IsAny<CancellationToken>()),
344              Times.AtLeastOnce,
345              "The periodic handler method was not called.");
346      }
347      [Test]
348      public async Task DisposeAsync_ShouldClearActivePopovers()
349      {
350          var jsRuntimeMock = Mock.Of<IJSRuntime>();
351          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
352          var observer = new PopoverObserverMock();
353          service.Subscribe(observer);
354          await service.CreatePopoverAsync(new PopoverMock());
355          await service.CreatePopoverAsync(new PopoverMock());
356          await service.DisposeAsync();
357          Assert.Zero(service.QueueCount);
358          Assert.IsEmpty(service.ActivePopovers);
359      }
360      [Test]
361      public async Task DisposeAsync_ShouldClearAllObservers()
362      {
363          var jsRuntimeMock = Mock.Of<IJSRuntime>();
364          var service = new PopoverService(NullLogger<PopoverService>.Instance, jsRuntimeMock);
365          var popover = new PopoverMock();
366          service.Subscribe(new PopoverObserverMock());
367          service.Subscribe(new PopoverObserverMock());
368          service.Subscribe(new PopoverObserverMock());
369          service.Subscribe(new PopoverObserverMock());
370          service.Subscribe(new PopoverObserverMock());
371          var beforeObserversCount = service.ObserversCount;
372          await service.CreatePopoverAsync(popover);
373          await service.DisposeAsync();
374          var afterObserversCount = service.ObserversCount;
375          Assert.AreEqual(5, beforeObserversCount);
376          Assert.Zero(afterObserversCount);
377      }
378  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.IO.Compression;
5  using System.Linq;
6  using System.Net;
7  using System.Net.Http;
8  using System.Net.Http.Headers;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using GitHub.DistributedTask.ObjectTemplating.Tokens;
13  using GitHub.Runner.Common;
14  using GitHub.Runner.Common.Util;
15  using GitHub.Runner.Sdk;
16  using GitHub.Runner.Worker.Container;
17  using GitHub.Services.Common;
18  using WebApi = GitHub.DistributedTask.WebApi;
19  using Pipelines = GitHub.DistributedTask.Pipelines;
20  using PipelineTemplateConstants = GitHub.DistributedTask.Pipelines.ObjectTemplating.PipelineTemplateConstants;
21  using GitHub.DistributedTask.WebApi;
22  namespace GitHub.Runner.Worker
23  {
24      public class PrepareResult
25      {
26          public PrepareResult(List<JobExtensionRunner> containerSetupSteps, Dictionary<Guid, IActionRunner> preStepTracker)
27          {
28              this.ContainerSetupSteps = containerSetupSteps;
29              this.PreStepTracker = preStepTracker;
30          }
31          public List<JobExtensionRunner> ContainerSetupSteps { get; set; }
32          public Dictionary<Guid, IActionRunner> PreStepTracker { get; set; }
33      }
34      [ServiceLocator(Default = typeof(ActionManager))]
35      public interface IActionManager : IRunnerService
36      {
37          Dictionary<Guid, ContainerInfo> CachedActionContainers { get; }
38          Dictionary<Guid, List<Pipelines.ActionStep>> CachedEmbeddedPreSteps { get; }
39          Dictionary<Guid, List<Guid>> CachedEmbeddedStepIds { get; }
40          Dictionary<Guid, Stack<Pipelines.ActionStep>> CachedEmbeddedPostSteps { get; }
41          Task<PrepareResult> PrepareActionsAsync(IExecutionContext executionContext, IEnumerable<Pipelines.JobStep> steps, Guid rootStepId = default(Guid));
42          Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action);
43      }
44      public sealed class ActionManager : RunnerService, IActionManager
45      {
46          private const int _defaultFileStreamBufferSize = 4096;
47          private const int _defaultCopyBufferSize = 81920;
48          private const string _dotcomApiUrl = "https:&bsol;&bsol;api.github.com";
49          private readonly Dictionary<Guid, ContainerInfo> _cachedActionContainers = new();
50          public Dictionary<Guid, ContainerInfo> CachedActionContainers => _cachedActionContainers;
51          private readonly Dictionary<Guid, List<Pipelines.ActionStep>> _cachedEmbeddedPreSteps = new();
52          public Dictionary<Guid, List<Pipelines.ActionStep>> CachedEmbeddedPreSteps => _cachedEmbeddedPreSteps;
53          private readonly Dictionary<Guid, List<Guid>> _cachedEmbeddedStepIds = new();
54          public Dictionary<Guid, List<Guid>> CachedEmbeddedStepIds => _cachedEmbeddedStepIds;
55          private readonly Dictionary<Guid, Stack<Pipelines.ActionStep>> _cachedEmbeddedPostSteps = new();
56          public Dictionary<Guid, Stack<Pipelines.ActionStep>> CachedEmbeddedPostSteps => _cachedEmbeddedPostSteps;
57          public async Task<PrepareResult> PrepareActionsAsync(IExecutionContext executionContext, IEnumerable<Pipelines.JobStep> steps, Guid rootStepId = default(Guid))
58          {
59              ArgUtil.NotNull(executionContext, nameof(executionContext));
60              ArgUtil.NotNull(steps, nameof(steps));
61              var state = new PrepareActionsState
62              {
63                  ImagesToBuild = new Dictionary<string, List<Guid>>(StringComparer.OrdinalIgnoreCase),
64                  ImagesToPull = new Dictionary<string, List<Guid>>(StringComparer.OrdinalIgnoreCase),
65                  ImagesToBuildInfo = new Dictionary<string, ActionContainer>(StringComparer.OrdinalIgnoreCase),
66                  PreStepTracker = new Dictionary<Guid, IActionRunner>()
67              };
68              var containerSetupSteps = new List<JobExtensionRunner>();
69              var depth = 0;
70              if (rootStepId == default(Guid))
71              {
72                  IOUtil.DeleteDirectory(HostContext.GetDirectory(WellKnownDirectory.Actions), executionContext.CancellationToken);
73              }
74              else
75              {
76                  if (!_cachedEmbeddedStepIds.ContainsKey(rootStepId))
77                  {
78                      _cachedEmbeddedStepIds[rootStepId] = new List<Guid>();
79                      foreach (var compositeStep in steps)
80                      {
81                          var guid = Guid.NewGuid();
82                          compositeStep.Id = guid;
83                          _cachedEmbeddedStepIds[rootStepId].Add(guid);
84                      }
85                  }
86                  depth = 1;
87              }
88              IEnumerable<Pipelines.ActionStep> actions = steps.OfType<Pipelines.ActionStep>();
89              executionContext.Output("Prepare all required actions");
90              PrepareActionsState result = new PrepareActionsState();
91              try
92              {
93                  result = await PrepareActionsRecursiveAsync(executionContext, state, actions, depth, rootStepId);
94              }
95              catch (FailedToResolveActionDownloadInfoException ex)
96              {
97                  Trace.Error($"Caught exception from PrepareActionsAsync Initialization: {ex}");
98                  executionContext.InfrastructureError(ex.Message);
99                  executionContext.Result = TaskResult.Failed;
100                  throw;
101              }
102              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
103              {
104                  if (state.ImagesToPull.Count > 0)
105                  {
106                      foreach (var imageToPull in result.ImagesToPull)
107                      {
108                          Trace.Info($"{imageToPull.Value.Count} steps need to pull image '{imageToPull.Key}'");
109                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.PullActionContainerAsync,
110                                                                      condition: $"{PipelineTemplateConstants.Success}()",
111                                                                      displayName: $"Pull {imageToPull.Key}",
112                                                                      data: new ContainerSetupInfo(imageToPull.Value, imageToPull.Key)));
113                      }
114                  }
115                  if (result.ImagesToBuild.Count > 0)
116                  {
117                      foreach (var imageToBuild in result.ImagesToBuild)
118                      {
119                          var setupInfo = result.ImagesToBuildInfo[imageToBuild.Key];
120                          Trace.Info($"{imageToBuild.Value.Count} steps need to build image from '{setupInfo.Dockerfile}'");
121                          containerSetupSteps.Add(new JobExtensionRunner(runAsync: this.BuildActionContainerAsync,
122                                                                      condition: $"{PipelineTemplateConstants.Success}()",
123                                                                      displayName: $"Build {setupInfo.ActionRepository}",
124                                                                      data: new ContainerSetupInfo(imageToBuild.Value, setupInfo.Dockerfile, setupInfo.WorkingDirectory)));
125                      }
126                  }
127  #if !OS_LINUX
128                  if (containerSetupSteps.Count > 0)
129                  {
130                      executionContext.Output("Container action is only supported on Linux, skip pull and build docker images.");
131                      containerSetupSteps.Clear();
132                  }
133  #endif
134              }
135              return new PrepareResult(containerSetupSteps, result.PreStepTracker);
136          }
137          private async Task<PrepareActionsState> PrepareActionsRecursiveAsync(IExecutionContext executionContext, PrepareActionsState state, IEnumerable<Pipelines.ActionStep> actions, Int32 depth = 0, Guid parentStepId = default(Guid))
138          {
139              ArgUtil.NotNull(executionContext, nameof(executionContext));
140              if (depth > Constants.CompositeActionsMaxDepth)
141              {
142                  throw new Exception($"Composite action depth exceeded max depth {Constants.CompositeActionsMaxDepth}");
143              }
<span onclick='openModal()' class='match'>144              var repositoryActions = new List<Pipelines.ActionStep>();
145              foreach (var action in actions)
</span>146              {
147                  if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
148                  {
149                      ArgUtil.NotNull(action, nameof(action));
150                      var containerReference = action.Reference as Pipelines.ContainerRegistryReference;
151                      ArgUtil.NotNull(containerReference, nameof(containerReference));
152                      ArgUtil.NotNullOrEmpty(containerReference.Image, nameof(containerReference.Image));
153                      if (!state.ImagesToPull.ContainsKey(containerReference.Image))
154                      {
155                          state.ImagesToPull[containerReference.Image] = new List<Guid>();
156                      }
157                      Trace.Info($"Action {action.Name} ({action.Id}) needs to pull image '{containerReference.Image}'");
158                      state.ImagesToPull[containerReference.Image].Add(action.Id);
159                  }
160                  else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
161                  {
162                      repositoryActions.Add(action);
163                  }
164              }
165              if (repositoryActions.Count > 0)
166              {
167                  var downloadInfos = await GetDownloadInfoAsync(executionContext, repositoryActions);
168                  foreach (var action in repositoryActions)
169                  {
170                      var lookupKey = GetDownloadInfoLookupKey(action);
171                      if (string.IsNullOrEmpty(lookupKey))
172                      {
173                          continue;
174                      }
175                      if (!downloadInfos.TryGetValue(lookupKey, out var downloadInfo))
176                      {
177                          throw new Exception($"Missing download info for {lookupKey}");
178                      }
179                      await DownloadRepositoryActionAsync(executionContext, downloadInfo);
180                  }
181                  foreach (var action in repositoryActions)
182                  {
183                      var setupInfo = PrepareRepositoryActionAsync(executionContext, action);
184                      if (setupInfo != null && setupInfo.Container != null)
185                      {
186                          if (!string.IsNullOrEmpty(setupInfo.Container.Image))
187                          {
188                              if (!state.ImagesToPull.ContainsKey(setupInfo.Container.Image))
189                              {
190                                  state.ImagesToPull[setupInfo.Container.Image] = new List<Guid>();
191                              }
192                              Trace.Info($"Action {action.Name} ({action.Id}) from repository '{setupInfo.Container.ActionRepository}' needs to pull image '{setupInfo.Container.Image}'");
193                              state.ImagesToPull[setupInfo.Container.Image].Add(action.Id);
194                          }
195                          else
196                          {
197                              ArgUtil.NotNullOrEmpty(setupInfo.Container.ActionRepository, nameof(setupInfo.Container.ActionRepository));
198                              if (!state.ImagesToBuild.ContainsKey(setupInfo.Container.ActionRepository))
199                              {
200                                  state.ImagesToBuild[setupInfo.Container.ActionRepository] = new List<Guid>();
201                              }
202                              Trace.Info($"Action {action.Name} ({action.Id}) from repository '{setupInfo.Container.ActionRepository}' needs to build image '{setupInfo.Container.Dockerfile}'");
203                              state.ImagesToBuild[setupInfo.Container.ActionRepository].Add(action.Id);
204                              state.ImagesToBuildInfo[setupInfo.Container.ActionRepository] = setupInfo.Container;
205                          }
206                      }
207                      else if (setupInfo != null && setupInfo.Steps != null && setupInfo.Steps.Count > 0)
208                      {
209                          state = await PrepareActionsRecursiveAsync(executionContext, state, setupInfo.Steps, depth + 1, action.Id);
210                      }
211                      var repoAction = action.Reference as Pipelines.RepositoryPathReference;
212                      if (repoAction.RepositoryType != Pipelines.PipelineConstants.SelfAlias)
213                      {
214                          var definition = LoadAction(executionContext, action);
215                          if (definition.Data.Execution.HasPre)
216                          {
217                              Trace.Info($"Add 'pre' execution for {action.Id}");
218                              if (depth < 1)
219                              {
220                                  var actionRunner = HostContext.CreateService<IActionRunner>();
221                                  actionRunner.Action = action;
222                                  actionRunner.Stage = ActionRunStage.Pre;
223                                  actionRunner.Condition = definition.Data.Execution.InitCondition;
224                                  state.PreStepTracker[action.Id] = actionRunner;
225                              }
226                              else
227                              {
228                                  if (!_cachedEmbeddedPreSteps.ContainsKey(parentStepId))
229                                  {
230                                      _cachedEmbeddedPreSteps[parentStepId] = new List<Pipelines.ActionStep>();
231                                  }
232                                  var clonedAction = action.Clone() as Pipelines.ActionStep;
233                                  clonedAction.Condition = definition.Data.Execution.InitCondition;
234                                  _cachedEmbeddedPreSteps[parentStepId].Add(clonedAction);
235                              }
236                          }
237                          if (definition.Data.Execution.HasPost && depth > 0)
238                          {
239                              if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
240                              {
241                                  _cachedEmbeddedPostSteps[parentStepId] = new Stack<Pipelines.ActionStep>();
242                              }
243                              var clonedAction = action.Clone() as Pipelines.ActionStep;
244                              clonedAction.Condition = definition.Data.Execution.CleanupCondition;
245                              _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
246                          }
247                      }
248                      else if (depth > 0)
249                      {
250                          if (!_cachedEmbeddedPostSteps.ContainsKey(parentStepId))
251                          {
252                              _cachedEmbeddedPostSteps[parentStepId] = new Stack<Pipelines.ActionStep>();
253                          }
254                          var clonedAction = action.Clone() as Pipelines.ActionStep;
255                          _cachedEmbeddedPostSteps[parentStepId].Push(clonedAction);
256                      }
257                  }
258              }
259              return state;
260          }
261          public Definition LoadAction(IExecutionContext executionContext, Pipelines.ActionStep action)
262          {
263              Trace.Entering();
264              ArgUtil.NotNull(action, nameof(action));
265              var definition = new Definition()
266              {
267                  Data = new ActionDefinitionData()
268              };
269              if (action.Reference.Type == Pipelines.ActionSourceType.ContainerRegistry)
270              {
271                  if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
272                  {
273                      Trace.Info("Load action that will run container through container hooks.");
274                      var containerAction = action.Reference as Pipelines.ContainerRegistryReference;
275                      definition.Data.Execution = new ContainerActionExecutionData()
276                      {
277                          Image = containerAction.Image,
278                      };
279                      Trace.Info($"Using action container image: {containerAction.Image}.");
280                  }
281                  else
282                  {
283                      Trace.Info("Load action that reference container from registry.");
284                      CachedActionContainers.TryGetValue(action.Id, out var container);
285                      ArgUtil.NotNull(container, nameof(container));
286                      definition.Data.Execution = new ContainerActionExecutionData()
287                      {
288                          Image = container.ContainerImage
289                      };
290                      Trace.Info($"Using action container image: {container.ContainerImage}.");
291                  }
292              }
293              else if (action.Reference.Type == Pipelines.ActionSourceType.Repository)
294              {
295                  string actionDirectory = null;
296                  var repoAction = action.Reference as Pipelines.RepositoryPathReference;
297                  if (string.Equals(repoAction.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
298                  {
299                      actionDirectory = executionContext.GetGitHubContext("workspace");
300                      if (!string.IsNullOrEmpty(repoAction.Path))
301                      {
302                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
303                      }
304                  }
305                  else
306                  {
307                      actionDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repoAction.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repoAction.Ref);
308                      if (!string.IsNullOrEmpty(repoAction.Path))
309                      {
310                          actionDirectory = Path.Combine(actionDirectory, repoAction.Path);
311                      }
312                  }
313                  Trace.Info($"Load action that reference repository from '{actionDirectory}'");
314                  definition.Directory = actionDirectory;
315                  string manifestFile = Path.Combine(actionDirectory, Constants.Path.ActionManifestYmlFile);
316                  string manifestFileYaml = Path.Combine(actionDirectory, Constants.Path.ActionManifestYamlFile);
317                  string dockerFile = Path.Combine(actionDirectory, "Dockerfile");
318                  string dockerFileLowerCase = Path.Combine(actionDirectory, "dockerfile");
319                  if (File.Exists(manifestFile) || File.Exists(manifestFileYaml))
320                  {
321                      var manifestManager = HostContext.GetService<IActionManifestManager>();
322                      if (File.Exists(manifestFile))
323                      {
324                          definition.Data = manifestManager.Load(executionContext, manifestFile);
325                      }
326                      else
327                      {
328                          definition.Data = manifestManager.Load(executionContext, manifestFileYaml);
329                      }
330                      Trace.Verbose($"Action friendly name: '{definition.Data.Name}'");
331                      Trace.Verbose($"Action description: '{definition.Data.Description}'");
332                      if (definition.Data.Inputs != null)
333                      {
334                          foreach (var input in definition.Data.Inputs)
335                          {
336                              Trace.Verbose($"Action input: '{input.Key.ToString()}' default to '{input.Value.ToString()}'");
337                          }
338                      }
339                      if (definition.Data.Execution.ExecutionType == ActionExecutionType.Container)
340                      {
341                          var containerAction = definition.Data.Execution as ContainerActionExecutionData;
342                          Trace.Info($"Action container Dockerfile/image: {containerAction.Image}.");
343                          if (containerAction.Arguments != null)
344                          {
345                              Trace.Info($"Action container args:  {StringUtil.ConvertToJson(containerAction.Arguments)}.");
346                          }
347                          if (containerAction.Environment != null)
348                          {
349                              Trace.Info($"Action container env: {StringUtil.ConvertToJson(containerAction.Environment)}.");
350                          }
351                          if (!string.IsNullOrEmpty(containerAction.Pre))
352                          {
353                              Trace.Info($"Action container pre entrypoint: {containerAction.Pre}.");
354                          }
355                          if (!string.IsNullOrEmpty(containerAction.EntryPoint))
356                          {
357                              Trace.Info($"Action container entrypoint: {containerAction.EntryPoint}.");
358                          }
359                          if (!string.IsNullOrEmpty(containerAction.Post))
360                          {
361                              Trace.Info($"Action container post entrypoint: {containerAction.Post}.");
362                          }
363                          if (CachedActionContainers.TryGetValue(action.Id, out var container))
364                          {
365                              Trace.Info($"Image '{containerAction.Image}' already built/pulled, use image: {container.ContainerImage}.");
366                              containerAction.Image = container.ContainerImage;
367                          }
368                      }
369                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.NodeJS)
370                      {
371                          var nodeAction = definition.Data.Execution as NodeJSActionExecutionData;
372                          Trace.Info($"Action pre node.js file: {nodeAction.Pre ?? "N/A"}.");
373                          Trace.Info($"Action node.js file: {nodeAction.Script}.");
374                          Trace.Info($"Action post node.js file: {nodeAction.Post ?? "N/A"}.");
375                      }
376                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Plugin)
377                      {
378                          var pluginAction = definition.Data.Execution as PluginActionExecutionData;
379                          var pluginManager = HostContext.GetService<IRunnerPluginManager>();
380                          var plugin = pluginManager.GetPluginAction(pluginAction.Plugin);
381                          ArgUtil.NotNull(plugin, pluginAction.Plugin);
382                          ArgUtil.NotNullOrEmpty(plugin.PluginTypeName, pluginAction.Plugin);
383                          pluginAction.Plugin = plugin.PluginTypeName;
384                          Trace.Info($"Action plugin: {plugin.PluginTypeName}.");
385                          if (!string.IsNullOrEmpty(plugin.PostPluginTypeName))
386                          {
387                              pluginAction.Post = plugin.PostPluginTypeName;
388                              Trace.Info($"Action cleanup plugin: {plugin.PluginTypeName}.");
389                          }
390                      }
391                      else if (definition.Data.Execution.ExecutionType == ActionExecutionType.Composite)
392                      {
393                          var compositeAction = definition.Data.Execution as CompositeActionExecutionData;
394                          Trace.Info($"Load {compositeAction.Steps?.Count ?? 0} action steps.");
395                          Trace.Verbose($"Details: {StringUtil.ConvertToJson(compositeAction?.Steps)}");
396                          Trace.Info($"Load: {compositeAction.Outputs?.Count ?? 0} number of outputs");
397                          Trace.Info($"Details: {StringUtil.ConvertToJson(compositeAction?.Outputs)}");
398                          if (CachedEmbeddedPreSteps.TryGetValue(action.Id, out var preSteps))
399                          {
400                              compositeAction.PreSteps = preSteps;
401                          }
402                          if (CachedEmbeddedPostSteps.TryGetValue(action.Id, out var postSteps))
403                          {
404                              compositeAction.PostSteps = postSteps;
405                          }
406                          if (_cachedEmbeddedStepIds.ContainsKey(action.Id))
407                          {
408                              for (var i = 0; i < compositeAction.Steps.Count; i++)
409                              {
410                                  compositeAction.Steps[i].Id = _cachedEmbeddedStepIds[action.Id][i];
411                                  if (string.IsNullOrEmpty(executionContext.Global.Variables.Get("DistributedTask.EnableCompositeActions")) && compositeAction.Steps[i].Reference.Type != Pipelines.ActionSourceType.Script)
412                                  {
413                                      throw new Exception("`uses:` keyword is not currently supported.");
414                                  }
415                              }
416                          }
417                          else
418                          {
419                              _cachedEmbeddedStepIds[action.Id] = new List<Guid>();
420                              foreach (var compositeStep in compositeAction.Steps)
421                              {
422                                  var guid = Guid.NewGuid();
423                                  compositeStep.Id = guid;
424                                  _cachedEmbeddedStepIds[action.Id].Add(guid);
425                              }
426                          }
427                      }
428                      else
429                      {
430                          throw new NotSupportedException(definition.Data.Execution.ExecutionType.ToString());
431                      }
432                  }
433                  else if (File.Exists(dockerFile))
434                  {
435                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
436                      {
437                          definition.Data.Execution = new ContainerActionExecutionData()
438                          {
439                              Image = container.ContainerImage
440                          };
441                      }
442                      else
443                      {
444                          definition.Data.Execution = new ContainerActionExecutionData()
445                          {
446                              Image = dockerFile
447                          };
448                      }
449                  }
450                  else if (File.Exists(dockerFileLowerCase))
451                  {
452                      if (CachedActionContainers.TryGetValue(action.Id, out var container))
453                      {
454                          definition.Data.Execution = new ContainerActionExecutionData()
455                          {
456                              Image = container.ContainerImage
457                          };
458                      }
459                      else
460                      {
461                          definition.Data.Execution = new ContainerActionExecutionData()
462                          {
463                              Image = dockerFileLowerCase
464                          };
465                      }
466                  }
467                  else
468                  {
469                      var fullPath = IOUtil.ResolvePath(actionDirectory, "."); 
470                      throw new NotSupportedException($"Can't find 'action.yml', 'action.yaml' or 'Dockerfile' under '{fullPath}'. Did you forget to run actions/checkout before running your local action?");
471                  }
472              }
473              else if (action.Reference.Type == Pipelines.ActionSourceType.Script)
474              {
475                  definition.Data.Execution = new ScriptActionExecutionData();
476                  definition.Data.Name = "Run";
477                  definition.Data.Description = "Execute a script";
478              }
479              else
480              {
481                  throw new NotSupportedException(action.Reference.Type.ToString());
482              }
483              return definition;
484          }
485          private async Task PullActionContainerAsync(IExecutionContext executionContext, object data)
486          {
487              var setupInfo = data as ContainerSetupInfo;
488              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
489              ArgUtil.NotNullOrEmpty(setupInfo.Container.Image, nameof(setupInfo.Container.Image));
490              executionContext.Output($"##[group]Pull down action image '{setupInfo.Container.Image}'");
491              var dockerManager = HostContext.GetService<IDockerCommandManager>();
492              int retryCount = 0;
493              int pullExitCode = 0;
494              while (retryCount < 3)
495              {
496                  pullExitCode = await dockerManager.DockerPull(executionContext, setupInfo.Container.Image);
497                  if (pullExitCode == 0)
498                  {
499                      break;
500                  }
501                  else
502                  {
503                      retryCount++;
504                      if (retryCount < 3)
505                      {
506                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
507                          executionContext.Warning($"Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
508                          await Task.Delay(backOff);
509                      }
510                  }
511              }
512              executionContext.Output("##[endgroup]");
513              if (retryCount == 3 && pullExitCode != 0)
514              {
515                  throw new InvalidOperationException($"Docker pull failed with exit code {pullExitCode}");
516              }
517              foreach (var stepId in setupInfo.StepIds)
518              {
519                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = setupInfo.Container.Image };
520                  Trace.Info($"Prepared docker image '{setupInfo.Container.Image}' for action {stepId} ({setupInfo.Container.Image})");
521              }
522          }
523          private async Task BuildActionContainerAsync(IExecutionContext executionContext, object data)
524          {
525              var setupInfo = data as ContainerSetupInfo;
526              ArgUtil.NotNull(setupInfo, nameof(setupInfo));
527              ArgUtil.NotNullOrEmpty(setupInfo.Container.Dockerfile, nameof(setupInfo.Container.Dockerfile));
528              executionContext.Output($"##[group]Build container for action use: '{setupInfo.Container.Dockerfile}'.");
529              var dockerManager = HostContext.GetService<IDockerCommandManager>();
530              int retryCount = 0;
531              int buildExitCode = 0;
532              var imageName = $"{dockerManager.DockerInstanceLabel}:{Guid.NewGuid().ToString("N")}";
533              while (retryCount < 3)
534              {
535                  buildExitCode = await dockerManager.DockerBuild(
536                      executionContext,
537                      setupInfo.Container.WorkingDirectory,
538                      setupInfo.Container.Dockerfile,
539                      Directory.GetParent(setupInfo.Container.Dockerfile).FullName,
540                      imageName);
541                  if (buildExitCode == 0)
542                  {
543                      break;
544                  }
545                  else
546                  {
547                      retryCount++;
548                      if (retryCount < 3)
549                      {
550                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
551                          executionContext.Warning($"Docker build failed with exit code {buildExitCode}, back off {backOff.TotalSeconds} seconds before retry.");
552                          await Task.Delay(backOff);
553                      }
554                  }
555              }
556              executionContext.Output("##[endgroup]");
557              if (retryCount == 3 && buildExitCode != 0)
558              {
559                  throw new InvalidOperationException($"Docker build failed with exit code {buildExitCode}");
560              }
561              foreach (var stepId in setupInfo.StepIds)
562              {
563                  CachedActionContainers[stepId] = new ContainerInfo() { ContainerImage = imageName };
564                  Trace.Info($"Prepared docker image '{imageName}' for action {stepId} ({setupInfo.Container.Dockerfile})");
565              }
566          }
567          private async Task<IDictionary<string, WebApi.ActionDownloadInfo>> GetDownloadInfoAsync(IExecutionContext executionContext, List<Pipelines.ActionStep> actions)
568          {
569              executionContext.Output("Getting action download info");
570              var actionReferences = actions
571                  .GroupBy(x => GetDownloadInfoLookupKey(x))
572                  .Where(x => !string.IsNullOrEmpty(x.Key))
573                  .Select(x =>
574                  {
575                      var action = x.First();
576                      var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
577                      ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
578                      return new WebApi.ActionReference
579                      {
580                          NameWithOwner = repositoryReference.Name,
581                          Ref = repositoryReference.Ref,
582                          Path = repositoryReference.Path,
583                      };
584                  })
585                  .ToList();
586              if (actionReferences.Count == 0)
587              {
588                  return new Dictionary<string, WebApi.ActionDownloadInfo>();
589              }
590              var launchServer = HostContext.GetService<ILaunchServer>();
591              var jobServer = HostContext.GetService<IJobServer>();
592              var actionDownloadInfos = default(WebApi.ActionDownloadInfoCollection);
593              for (var attempt = 1; attempt <= 3; attempt++)
594              {
595                  try
596                  {
597                      if (MessageUtil.IsRunServiceJob(executionContext.Global.Variables.Get(Constants.Variables.System.JobRequestType)))
598                      {
599                          actionDownloadInfos = await launchServer.ResolveActionsDownloadInfoAsync(executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
600                      }
601                      else
602                      {
603                          actionDownloadInfos = await jobServer.ResolveActionDownloadInfoAsync(executionContext.Global.Plan.ScopeIdentifier, executionContext.Global.Plan.PlanType, executionContext.Global.Plan.PlanId, executionContext.Root.Id, new WebApi.ActionReferenceList { Actions = actionReferences }, executionContext.CancellationToken);
604                      }
605                      break;
606                  }
607                  catch (Exception ex) when (!executionContext.CancellationToken.IsCancellationRequested) 
608                  {
609                      if (attempt < 3 && !(ex is WebApi.UnresolvableActionDownloadInfoException))
610                      {
611                          executionContext.Output($"Failed to resolve action download info. Error: {ex.Message}");
612                          executionContext.Debug(ex.ToString());
613                          if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF")))
614                          {
615                              var backoff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
616                              executionContext.Output($"Retrying in {backoff.TotalSeconds} seconds");
617                              await Task.Delay(backoff);
618                          }
619                      }
620                      else
621                      {
622                          if (ex is WebApi.UnresolvableActionDownloadInfoException)
623                          {
624                              throw;
625                          }
626                          else
627                          {
628                              throw new WebApi.FailedToResolveActionDownloadInfoException("Failed to resolve action download info.", ex);
629                          }
630                      }
631                  }
632              }
633              ArgUtil.NotNull(actionDownloadInfos, nameof(actionDownloadInfos));
634              ArgUtil.NotNull(actionDownloadInfos.Actions, nameof(actionDownloadInfos.Actions));
635              var apiUrl = GetApiUrl(executionContext);
636              var defaultAccessToken = executionContext.GetGitHubContext("token");
637              var configurationStore = HostContext.GetService<IConfigurationStore>();
638              var runnerSettings = configurationStore.GetSettings();
639              foreach (var actionDownloadInfo in actionDownloadInfos.Actions.Values)
640              {
641                  HostContext.SecretMasker.AddValue(actionDownloadInfo.Authentication?.Token);
642                  if (string.IsNullOrEmpty(actionDownloadInfo.Authentication?.Token))
643                  {
644                      actionDownloadInfo.Authentication = new WebApi.ActionDownloadAuthentication { Token = defaultAccessToken };
645                  }
646              }
647              return actionDownloadInfos.Actions;
648          }
649          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo)
650          {
651              Trace.Entering();
652              ArgUtil.NotNull(executionContext, nameof(executionContext));
653              ArgUtil.NotNull(downloadInfo, nameof(downloadInfo));
654              ArgUtil.NotNullOrEmpty(downloadInfo.NameWithOwner, nameof(downloadInfo.NameWithOwner));
655              ArgUtil.NotNullOrEmpty(downloadInfo.Ref, nameof(downloadInfo.Ref));
656              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), downloadInfo.NameWithOwner.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), downloadInfo.Ref);
657              string watermarkFile = GetWatermarkFilePath(destDirectory);
658              if (File.Exists(watermarkFile))
659              {
660                  executionContext.Debug($"Action '{downloadInfo.NameWithOwner}@{downloadInfo.Ref}' already downloaded at '{destDirectory}'.");
661                  return;
662              }
663              else
664              {
665                  IOUtil.DeleteDirectory(destDirectory, executionContext.CancellationToken);
666                  Directory.CreateDirectory(destDirectory);
667                  executionContext.Output($"Download action repository '{downloadInfo.NameWithOwner}@{downloadInfo.Ref}' (SHA:{downloadInfo.ResolvedSha})");
668              }
669              await DownloadRepositoryActionAsync(executionContext, downloadInfo, destDirectory);
670          }
671          private string GetApiUrl(IExecutionContext executionContext)
672          {
673              string apiUrl = executionContext.GetGitHubContext("api_url");
674              if (!string.IsNullOrEmpty(apiUrl))
675              {
676                  return apiUrl;
677              }
678              return _dotcomApiUrl;
679          }
680          private static string BuildLinkToActionArchive(string apiUrl, string repository, string @ref)
681          {
682  #if OS_WINDOWS
683              return $"{apiUrl}/repos/{repository}/zipball/{@ref}";
684  #else
685              return $"{apiUrl}/repos/{repository}/tarball/{@ref}";
686  #endif
687          }
688          private async Task DownloadRepositoryActionAsync(IExecutionContext executionContext, WebApi.ActionDownloadInfo downloadInfo, string destDirectory)
689          {
690              string tempDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), "_temp_" + Guid.NewGuid());
691              Directory.CreateDirectory(tempDirectory);
692  #if OS_WINDOWS
693              string archiveFile = Path.Combine(tempDirectory, $"{Guid.NewGuid()}.zip");
694              string link = downloadInfo?.ZipballUrl;
695  #else
696              string archiveFile = Path.Combine(tempDirectory, $"{Guid.NewGuid()}.tar.gz");
697              string link = downloadInfo?.TarballUrl;
698  #endif
699              Trace.Info($"Save archive '{link}' into {archiveFile}.");
700              try
701              {
702                  int retryCount = 0;
703                  int timeoutSeconds = 20 * 60;
704                  while (retryCount < 3)
705                  {
706                      using (var actionDownloadTimeout = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds)))
707                      using (var actionDownloadCancellation = CancellationTokenSource.CreateLinkedTokenSource(actionDownloadTimeout.Token, executionContext.CancellationToken))
708                      {
709                          try
710                          {
711                              using (FileStream fs = new(archiveFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: _defaultFileStreamBufferSize, useAsync: true))
712                              using (var httpClientHandler = HostContext.CreateHttpClientHandler())
713                              using (var httpClient = new HttpClient(httpClientHandler))
714                              {
715                                  httpClient.DefaultRequestHeaders.Authorization = CreateAuthHeader(downloadInfo.Authentication?.Token);
716                                  httpClient.DefaultRequestHeaders.UserAgent.AddRange(HostContext.UserAgents);
717                                  using (var response = await httpClient.GetAsync(link))
718                                  {
719                                      if (response.IsSuccessStatusCode)
720                                      {
721                                          using (var result = await response.Content.ReadAsStreamAsync())
722                                          {
723                                              await result.CopyToAsync(fs, _defaultCopyBufferSize, actionDownloadCancellation.Token);
724                                              await fs.FlushAsync(actionDownloadCancellation.Token);
725                                              break;
726                                          }
727                                      }
728                                      else if (response.StatusCode == HttpStatusCode.NotFound)
729                                      {
730                                          throw new ActionNotFoundException(new Uri(link));
731                                      }
732                                      else
733                                      {
734                                          response.EnsureSuccessStatusCode();
735                                      }
736                                  }
737                              }
738                          }
739                          catch (OperationCanceledException) when (executionContext.CancellationToken.IsCancellationRequested)
740                          {
741                              Trace.Info("Action download has been cancelled.");
742                              throw;
743                          }
744                          catch (ActionNotFoundException)
745                          {
746                              Trace.Info($"The action at '{link}' does not exist");
747                              throw;
748                          }
749                          catch (Exception ex) when (retryCount < 2)
750                          {
751                              retryCount++;
752                              Trace.Error($"Fail to download archive '{link}' -- Attempt: {retryCount}");
753                              Trace.Error(ex);
754                              if (actionDownloadTimeout.Token.IsCancellationRequested)
755                              {
756                                  executionContext.Warning($"Action '{link}' didn't finish download within {timeoutSeconds} seconds.");
757                              }
758                              else
759                              {
760                                  executionContext.Warning($"Failed to download action '{link}'. Error: {ex.Message}");
761                              }
762                          }
763                      }
764                      if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("_GITHUB_ACTION_DOWNLOAD_NO_BACKOFF")))
765                      {
766                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
767                          executionContext.Warning($"Back off {backOff.TotalSeconds} seconds before retry.");
768                          await Task.Delay(backOff);
769                      }
770                  }
771                  ArgUtil.NotNullOrEmpty(archiveFile, nameof(archiveFile));
772                  executionContext.Debug($"Download '{link}' to '{archiveFile}'");
773                  var stagingDirectory = Path.Combine(tempDirectory, "_staging");
774                  Directory.CreateDirectory(stagingDirectory);
775  #if OS_WINDOWS
776                  ZipFile.ExtractToDirectory(archiveFile, stagingDirectory);
777  #else
778                  string tar = WhichUtil.Which("tar", require: true, trace: Trace);
779                  using (var processInvoker = HostContext.CreateService<IProcessInvoker>())
780                  {
781                      processInvoker.OutputDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
782                      {
783                          if (!string.IsNullOrEmpty(args.Data))
784                          {
785                              Trace.Info(args.Data);
786                          }
787                      });
788                      processInvoker.ErrorDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
789                      {
790                          if (!string.IsNullOrEmpty(args.Data))
791                          {
792                              Trace.Error(args.Data);
793                          }
794                      });
795                      int exitCode = await processInvoker.ExecuteAsync(stagingDirectory, tar, $"-xzf \"{archiveFile}\"", null, executionContext.CancellationToken);
796                      if (exitCode != 0)
797                      {
798                          throw new NotSupportedException($"Can't use 'tar -xzf' extract archive file: {archiveFile}. return code: {exitCode}.");
799                      }
800                  }
801  #endif
802                  var subDirectories = new DirectoryInfo(stagingDirectory).GetDirectories();
803                  if (subDirectories.Length != 1)
804                  {
805                      throw new InvalidOperationException($"'{archiveFile}' contains '{subDirectories.Length}' directories");
806                  }
807                  else
808                  {
809                      executionContext.Debug($"Unwrap '{subDirectories[0].Name}' to '{destDirectory}'");
810                      IOUtil.CopyDirectory(subDirectories[0].FullName, destDirectory, executionContext.CancellationToken);
811                  }
812                  Trace.Verbose("Create watermark file indicate action download succeed.");
813                  string watermarkFile = GetWatermarkFilePath(destDirectory);
814                  File.WriteAllText(watermarkFile, DateTime.UtcNow.ToString());
815                  executionContext.Debug($"Archive '{archiveFile}' has been unzipped into '{destDirectory}'.");
816                  Trace.Info("Finished getting action repository.");
817              }
818              finally
819              {
820                  try
821                  {
822                      if (Directory.Exists(tempDirectory))
823                      {
824                          Trace.Verbose("Deleting action temp folder: {0}", tempDirectory);
825                          IOUtil.DeleteDirectory(tempDirectory, CancellationToken.None); 
826                      }
827                  }
828                  catch (Exception ex)
829                  {
830                      Trace.Warning("Failed to delete temp folder '{0}'. Exception: {1}", tempDirectory, ex);
831                  }
832              }
833          }
834          private void ConfigureAuthorizationFromContext(IExecutionContext executionContext, HttpClient httpClient)
835          {
836              var authToken = Environment.GetEnvironmentVariable("_GITHUB_ACTION_TOKEN");
837              if (string.IsNullOrEmpty(authToken))
838              {
839                  authToken = executionContext.Global.Variables.Get("PREVIEW_ACTION_TOKEN");
840              }
841              if (!string.IsNullOrEmpty(authToken))
842              {
843                  HostContext.SecretMasker.AddValue(authToken);
844                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($"PAT:{authToken}"));
845                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", base64EncodingToken);
846              }
847              else
848              {
849                  var accessToken = executionContext.GetGitHubContext("token");
850                  var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($"x-access-token:{accessToken}"));
851                  httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", base64EncodingToken);
852              }
853          }
854          private string GetWatermarkFilePath(string directory) => directory + ".completed";
855          private ActionSetupInfo PrepareRepositoryActionAsync(IExecutionContext executionContext, Pipelines.ActionStep repositoryAction)
856          {
857              var repositoryReference = repositoryAction.Reference as Pipelines.RepositoryPathReference;
858              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
859              {
860                  Trace.Info($"Repository action is in 'self' repository.");
861                  return null;
862              }
863              var setupInfo = new ActionSetupInfo();
864              var actionContainer = new ActionContainer();
865              string destDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Actions), repositoryReference.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar), repositoryReference.Ref);
866              string actionEntryDirectory = destDirectory;
867              string dockerFileRelativePath = repositoryReference.Name;
868              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
869              if (!string.IsNullOrEmpty(repositoryReference.Path))
870              {
871                  actionEntryDirectory = Path.Combine(destDirectory, repositoryReference.Path);
872                  dockerFileRelativePath = $"{dockerFileRelativePath}/{repositoryReference.Path}";
873                  actionContainer.ActionRepository = $"{repositoryReference.Name}/{repositoryReference.Path}@{repositoryReference.Ref}";
874              }
875              else
876              {
877                  actionContainer.ActionRepository = $"{repositoryReference.Name}@{repositoryReference.Ref}";
878              }
879              var dockerFile = Path.Combine(actionEntryDirectory, "Dockerfile");
880              var dockerFileLowerCase = Path.Combine(actionEntryDirectory, "dockerfile");
881              var actionManifest = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYmlFile);
882              var actionManifestYaml = Path.Combine(actionEntryDirectory, Constants.Path.ActionManifestYamlFile);
883              if (File.Exists(actionManifest) || File.Exists(actionManifestYaml))
884              {
885                  executionContext.Debug($"action.yml for action: '{actionManifest}'.");
886                  var manifestManager = HostContext.GetService<IActionManifestManager>();
887                  ActionDefinitionData actionDefinitionData = null;
888                  if (File.Exists(actionManifest))
889                  {
890                      actionDefinitionData = manifestManager.Load(executionContext, actionManifest);
891                  }
892                  else
893                  {
894                      actionDefinitionData = manifestManager.Load(executionContext, actionManifestYaml);
895                  }
896                  if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Container)
897                  {
898                      var containerAction = actionDefinitionData.Execution as ContainerActionExecutionData;
899                      if (DockerUtil.IsDockerfile(containerAction.Image))
900                      {
901                          var dockerFileFullPath = Path.Combine(actionEntryDirectory, containerAction.Image);
902                          executionContext.Debug($"Dockerfile for action: '{dockerFileFullPath}'.");
903                          actionContainer.Dockerfile = dockerFileFullPath;
904                          actionContainer.WorkingDirectory = destDirectory;
905                          setupInfo.Container = actionContainer;
906                          return setupInfo;
907                      }
908                      else if (containerAction.Image.StartsWith("docker:&bsol;&bsol;", StringComparison.OrdinalIgnoreCase))
909                      {
910                          var actionImage = containerAction.Image.Substring("docker:&bsol;&bsol;".Length);
911                          executionContext.Debug($"Container image for action: '{actionImage}'.");
912                          actionContainer.Image = actionImage;
913                          setupInfo.Container = actionContainer;
914                          return setupInfo;
915                      }
916                      else
917                      {
918                          throw new NotSupportedException($"'{containerAction.Image}' should be either '[path]/Dockerfile' or 'docker:&bsol;&bsol;image[:tag]'.");
919                      }
920                  }
921                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.NodeJS)
922                  {
923                      Trace.Info($"Action node.js file: {(actionDefinitionData.Execution as NodeJSActionExecutionData).Script}, no more preparation.");
924                      return null;
925                  }
926                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Plugin)
927                  {
928                      Trace.Info($"Action plugin: {(actionDefinitionData.Execution as PluginActionExecutionData).Plugin}, no more preparation.");
929                      return null;
930                  }
931                  else if (actionDefinitionData.Execution.ExecutionType == ActionExecutionType.Composite)
932                  {
933                      Trace.Info($"Loading Composite steps");
934                      var compositeAction = actionDefinitionData.Execution as CompositeActionExecutionData;
935                      setupInfo.Steps = compositeAction.Steps;
936                      if (!_cachedEmbeddedStepIds.ContainsKey(repositoryAction.Id))
937                      {
938                          _cachedEmbeddedStepIds[repositoryAction.Id] = new List<Guid>();
939                          foreach (var compositeStep in compositeAction.Steps)
940                          {
941                              var guid = Guid.NewGuid();
942                              compositeStep.Id = guid;
943                              _cachedEmbeddedStepIds[repositoryAction.Id].Add(guid);
944                          }
945                      }
946                      foreach (var step in compositeAction.Steps)
947                      {
948                          if (string.IsNullOrEmpty(executionContext.Global.Variables.Get("DistributedTask.EnableCompositeActions")) && step.Reference.Type != Pipelines.ActionSourceType.Script)
949                          {
950                              throw new Exception("`uses:` keyword is not currently supported.");
951                          }
952                      }
953                      return setupInfo;
954                  }
955                  else
956                  {
957                      throw new NotSupportedException(actionDefinitionData.Execution.ExecutionType.ToString());
958                  }
959              }
960              else if (File.Exists(dockerFile))
961              {
962                  executionContext.Debug($"Dockerfile for action: '{dockerFile}'.");
963                  actionContainer.Dockerfile = dockerFile;
964                  actionContainer.WorkingDirectory = destDirectory;
965                  setupInfo.Container = actionContainer;
966                  return setupInfo;
967              }
968              else if (File.Exists(dockerFileLowerCase))
969              {
970                  executionContext.Debug($"Dockerfile for action: '{dockerFileLowerCase}'.");
971                  actionContainer.Dockerfile = dockerFileLowerCase;
972                  actionContainer.WorkingDirectory = destDirectory;
973                  setupInfo.Container = actionContainer;
974                  return setupInfo;
975              }
976              else
977              {
978                  var fullPath = IOUtil.ResolvePath(actionEntryDirectory, "."); 
979                  throw new InvalidOperationException($"Can't find 'action.yml', 'action.yaml' or 'Dockerfile' under '{fullPath}'. Did you forget to run actions/checkout before running your local action?");
980              }
981          }
982          private static string GetDownloadInfoLookupKey(Pipelines.ActionStep action)
983          {
984              if (action.Reference.Type != Pipelines.ActionSourceType.Repository)
985              {
986                  return null;
987              }
988              var repositoryReference = action.Reference as Pipelines.RepositoryPathReference;
989              ArgUtil.NotNull(repositoryReference, nameof(repositoryReference));
990              if (string.Equals(repositoryReference.RepositoryType, Pipelines.PipelineConstants.SelfAlias, StringComparison.OrdinalIgnoreCase))
991              {
992                  return null;
993              }
994              if (!string.Equals(repositoryReference.RepositoryType, Pipelines.RepositoryTypes.GitHub, StringComparison.OrdinalIgnoreCase))
995              {
996                  throw new NotSupportedException(repositoryReference.RepositoryType);
997              }
998              ArgUtil.NotNullOrEmpty(repositoryReference.Name, nameof(repositoryReference.Name));
999              ArgUtil.NotNullOrEmpty(repositoryReference.Ref, nameof(repositoryReference.Ref));
1000              return $"{repositoryReference.Name}@{repositoryReference.Ref}";
1001          }
1002          private static string GetDownloadInfoLookupKey(WebApi.ActionDownloadInfo info)
1003          {
1004              ArgUtil.NotNullOrEmpty(info.NameWithOwner, nameof(info.NameWithOwner));
1005              ArgUtil.NotNullOrEmpty(info.Ref, nameof(info.Ref));
1006              return $"{info.NameWithOwner}@{info.Ref}";
1007          }
1008          private AuthenticationHeaderValue CreateAuthHeader(string token)
1009          {
1010              if (string.IsNullOrEmpty(token))
1011              {
1012                  return null;
1013              }
1014              var base64EncodingToken = Convert.ToBase64String(Encoding.UTF8.GetBytes($"x-access-token:{token}"));
1015              HostContext.SecretMasker.AddValue(base64EncodingToken);
1016              return new AuthenticationHeaderValue("Basic", base64EncodingToken);
1017          }
1018      }
1019      public sealed class Definition
1020      {
1021          public ActionDefinitionData Data { get; set; }
1022          public string Directory { get; set; }
1023      }
1024      public sealed class ActionDefinitionData
1025      {
1026          public string Name { get; set; }
1027          public string Description { get; set; }
1028          public MappingToken Inputs { get; set; }
1029          public ActionExecutionData Execution { get; set; }
1030          public Dictionary<String, String> Deprecated { get; set; }
1031      }
1032      public enum ActionExecutionType
1033      {
1034          Container,
1035          NodeJS,
1036          Plugin,
1037          Script,
1038          Composite,
1039      }
1040      public sealed class ContainerActionExecutionData : ActionExecutionData
1041      {
1042          public override ActionExecutionType ExecutionType => ActionExecutionType.Container;
1043          public override bool HasPre => !string.IsNullOrEmpty(Pre);
1044          public override bool HasPost => !string.IsNullOrEmpty(Post);
1045          public string Image { get; set; }
1046          public string EntryPoint { get; set; }
1047          public SequenceToken Arguments { get; set; }
1048          public MappingToken Environment { get; set; }
1049          public string Pre { get; set; }
1050          public string Post { get; set; }
1051      }
1052      public sealed class NodeJSActionExecutionData : ActionExecutionData
1053      {
1054          public override ActionExecutionType ExecutionType => ActionExecutionType.NodeJS;
1055          public override bool HasPre => !string.IsNullOrEmpty(Pre);
1056          public override bool HasPost => !string.IsNullOrEmpty(Post);
1057          public string Script { get; set; }
1058          public string Pre { get; set; }
1059          public string Post { get; set; }
1060          public string NodeVersion { get; set; }
1061      }
1062      public sealed class PluginActionExecutionData : ActionExecutionData
1063      {
1064          public override ActionExecutionType ExecutionType => ActionExecutionType.Plugin;
1065          public override bool HasPre => false;
1066          public override bool HasPost => !string.IsNullOrEmpty(Post);
1067          public string Plugin { get; set; }
1068          public string Post { get; set; }
1069      }
1070      public sealed class ScriptActionExecutionData : ActionExecutionData
1071      {
1072          public override ActionExecutionType ExecutionType => ActionExecutionType.Script;
1073          public override bool HasPre => false;
1074          public override bool HasPost => false;
1075      }
1076      public sealed class CompositeActionExecutionData : ActionExecutionData
1077      {
1078          public override ActionExecutionType ExecutionType => ActionExecutionType.Composite;
1079          public override bool HasPre => PreSteps.Count > 0;
1080          public override bool HasPost => PostSteps.Count > 0;
1081          public List<Pipelines.ActionStep> PreSteps { get; set; }
1082          public List<Pipelines.ActionStep> Steps { get; set; }
1083          public Stack<Pipelines.ActionStep> PostSteps { get; set; }
1084          public MappingToken Outputs { get; set; }
1085      }
1086      public abstract class ActionExecutionData
1087      {
1088          private string _initCondition = $"{Constants.Expressions.Always}()";
1089          private string _cleanupCondition = $"{Constants.Expressions.Always}()";
1090          public abstract ActionExecutionType ExecutionType { get; }
1091          public abstract bool HasPre { get; }
1092          public abstract bool HasPost { get; }
1093          public string CleanupCondition
1094          {
1095              get { return _cleanupCondition; }
1096              set { _cleanupCondition = value; }
1097          }
1098          public string InitCondition
1099          {
1100              get { return _initCondition; }
1101              set { _initCondition = value; }
1102          }
1103      }
1104      public class ContainerSetupInfo
1105      {
1106          public ContainerSetupInfo(List<Guid> ids, string image)
1107          {
1108              StepIds = ids;
1109              Container = new ActionContainer()
1110              {
1111                  Image = image
1112              };
1113          }
1114          public ContainerSetupInfo(List<Guid> ids, string dockerfile, string workingDirectory)
1115          {
1116              StepIds = ids;
1117              Container = new ActionContainer()
1118              {
1119                  Dockerfile = dockerfile,
1120                  WorkingDirectory = workingDirectory
1121              };
1122          }
1123          public List<Guid> StepIds { get; set; }
1124          public ActionContainer Container { get; set; }
1125      }
1126      public class ActionContainer
1127      {
1128          public string Image { get; set; }
1129          public string Dockerfile { get; set; }
1130          public string WorkingDirectory { get; set; }
1131          public string ActionRepository { get; set; }
1132      }
1133      public class ActionSetupInfo
1134      {
1135          public ActionContainer Container { get; set; }
1136          public List<Pipelines.ActionStep> Steps { get; set; }
1137      }
1138      public class PrepareActionsState
1139      {
1140          public Dictionary<string, List<Guid>> ImagesToPull;
1141          public Dictionary<string, List<Guid>> ImagesToBuild;
1142          public Dictionary<string, ActionContainer> ImagesToBuildInfo;
1143          public Dictionary<Guid, IActionRunner> PreStepTracker;
1144      }
1145  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-PopoverServiceTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>322          var popoverTimerMock = new Mock<PopoverServiceMock.IPopoverTimerMock>();
323          var signalEvent = new ManualResetEventSlim(false);
</pre></code></div>
                <div class="column column_space"><pre><code>144              var repositoryActions = new List<Pipelines.ActionStep>();
145              foreach (var action in actions)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    