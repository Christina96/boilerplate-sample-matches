
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonLogicalReplicationTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading.Tasks;
4  using NUnit.Framework;
5  using Npgsql.Replication;
6  using Npgsql.Replication.Internal;
7  using NpgsqlTypes;
8  namespace Npgsql.Tests.Replication;
9  [Platform(Exclude = "MacOsX", Reason = "Replication tests are flaky in CI on Mac")]
10  [NonParallelizable]
11  public class CommonLogicalReplicationTests : SafeReplicationTestBase<LogicalReplicationConnection>
12  {
13      const string OutputPlugin = "test_decoding";
14      [Test]
15      public Task CreateLogicalReplicationSlot([Values]bool temporary, [Values]bool twoPhase)
16          => SafeReplicationTest(
17              async (slotName, _) =>
18              {
19                  await using var c = await OpenConnectionAsync();
20                  if (twoPhase)
21                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
22                  if (temporary)
23                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
24                  await using var rc = await OpenReplicationConnectionAsync();
25                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, twoPhase: twoPhase);
26                  using var cmd =
27                      new NpgsqlCommand($"SELECT * FROM pg_replication_slots WHERE slot_name = '{options.SlotName}'",
28                          c);
29                  await using var reader = await cmd.ExecuteReaderAsync();
30                  Assert.That(reader.Read, Is.True);
31                  Assert.That(reader.GetFieldValue<string>(reader.GetOrdinal("slot_type")), Is.EqualTo("logical"));
32                  if (c.PostgreSqlVersion >= Version.Parse("15.0"))
33                      Assert.That(reader.GetFieldValue<bool>(reader.GetOrdinal("two_phase")), Is.EqualTo(twoPhase));
34                  if (c.PostgreSqlVersion >= Version.Parse("10.0"))
35                      Assert.That(reader.GetFieldValue<bool>(reader.GetOrdinal("temporary")), Is.EqualTo(temporary));
36                  Assert.That(reader.GetFieldValue<bool>(reader.GetOrdinal("active")), Is.EqualTo(temporary));
37                  if (c.PostgreSqlVersion >= Version.Parse("9.6"))
38                      Assert.That(reader.GetFieldValue<NpgsqlLogSequenceNumber>(reader.GetOrdinal("confirmed_flush_lsn")),
39                          Is.EqualTo(options.ConsistentPoint));
40                  Assert.That(reader.Read, Is.False);
41              }, nameof(CreateLogicalReplicationSlot) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : ""));
42      [Test]
43      public Task CreateLogicalReplicationSlot_NoExport([Values]bool temporary, [Values]bool twoPhase)
44          => SafeReplicationTest(
45              async (slotName, _) =>
46              {
47                  await using var c = await OpenConnectionAsync();
48                  if (temporary)
49                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
50                  if (twoPhase)
51                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
52                  TestUtil.MinimumPgVersion(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
53                  await using var rc = await OpenReplicationConnectionAsync();
54                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, LogicalSlotSnapshotInitMode.NoExport, twoPhase);
55                  Assert.That(options.SnapshotName, Is.Null);
56              }, nameof(CreateLogicalReplicationSlot_NoExport) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : ""));
57      [Test(Description = "Tests whether we throw a helpful exception about the unsupported *_SNAPSHOT syntax on old servers.")]
58      [TestCase(LogicalSlotSnapshotInitMode.Export)]
59      [TestCase(LogicalSlotSnapshotInitMode.NoExport)]
60      [TestCase(LogicalSlotSnapshotInitMode.Use)]
61      public Task CreateLogicalReplicationSlot_with_SnapshotInitMode_on_old_postgres_throws(LogicalSlotSnapshotInitMode mode)
62          => SafeReplicationTest(
63              async (slotName, _) =>
64              {
65                  await using var c = await OpenConnectionAsync();
66                  TestUtil.MaximumPgVersionExclusive(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
67                  Assert.That(async () =>
68                  {
69                      await using var rc = await OpenReplicationConnectionAsync();
70                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, slotSnapshotInitMode: mode);
71                  }, Throws.InstanceOf<NotSupportedException>()
72                      .With.Message.StartsWith("The EXPORT_SNAPSHOT, USE_SNAPSHOT and NOEXPORT_SNAPSHOT syntax was introduced in PostgreSQL")
73                      .And.InnerException.TypeOf<PostgresException>()
74                      .And.InnerException.Property("SqlState").EqualTo(PostgresErrorCodes.SyntaxError));
75              });
76      [Test(Description = "Tests whether we throw a helpful exception about unsupported temporary replication slots on old servers.")]
77      public Task CreateLogicalReplicationSlot_with_isTemporary_set_to_true_on_old_postgres_throws()
78          => SafeReplicationTest(
79              async (slotName, _) =>
80              {
81                  await using var c = await OpenConnectionAsync();
82                  TestUtil.MaximumPgVersionExclusive(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
83                  Assert.That(async () =>
84                  {
85                      await using var rc = await OpenReplicationConnectionAsync();
86                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, isTemporary: true);
87                  }, Throws.InstanceOf<NotSupportedException>()
88                      .With.Message.StartsWith("Temporary replication slots were introduced in PostgreSQL")
89                      .And.InnerException.TypeOf<PostgresException>()
90                      .And.InnerException.Property("SqlState").EqualTo(PostgresErrorCodes.SyntaxError));
91              });
92      [Test(Description = "Tests whether we throw a helpful exception about the unsupported TWO_PHASE syntax on old servers.")]
93      public Task CreateLogicalReplicationSlot_with_twoPhase_set_to_true_on_old_postgres_throws()
94          => SafeReplicationTest(
95              async (slotName, _) =>
96              {
97                  await using var c = await OpenConnectionAsync();
98                  TestUtil.MaximumPgVersionExclusive(c, "15.0",
99                      "Logical replication support for prepared transactions was  introduced in PostgreSQL 15");
100                  Assert.That(async () =>
101                  {
102                      await using var rc = await OpenReplicationConnectionAsync();
103                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, twoPhase: true);
104                  }, Throws.InstanceOf<NotSupportedException>()
105                      .With.Message.StartsWith("Logical replication support for prepared transactions was introduced in PostgreSQL")
106                      .And.InnerException.TypeOf<PostgresException>()
107                      .And.InnerException.Property("SqlState").EqualTo(PostgresErrorCodes.SyntaxError));
108              });
109      [Test(Description = "We can use the exported snapshot to query the database in the very moment the replication slot was created.")]
110      public Task CreateLogicalReplicationSlot_Export([Values]bool temporary, [Values]bool twoPhase, [Values]bool implicitInitMode)
111          => SafeReplicationTest(
112              async (slotName, tableName) =>
113              {
114                  await using var c = await OpenConnectionAsync();
115                  if (temporary)
<span onclick='openModal()' class='match'>116                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
117                  if (twoPhase)
118                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
</span>119                  if (!implicitInitMode)
120                      TestUtil.MinimumPgVersion(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
121                  await using (var transaction = c.BeginTransaction())
122                  {
123                      await c.ExecuteNonQueryAsync($"CREATE TABLE {tableName} (value text)");
124                      await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} (value) VALUES('Before snapshot')");
125                      transaction.Commit();
126                  }
127                  await using var rc = await OpenReplicationConnectionAsync();
128                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, implicitInitMode ? null : LogicalSlotSnapshotInitMode.Export, twoPhase);
129                  await using (var transaction = c.BeginTransaction())
130                  {
131                      await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} (value) VALUES('After snapshot')");
132                      transaction.Commit();
133                  }
134                  await using (var transaction = c.BeginTransaction(IsolationLevel.RepeatableRead))
135                  {
136                      await c.ExecuteScalarAsync($"SET TRANSACTION SNAPSHOT '{options.SnapshotName}';", transaction);
137                      using var cmd = new NpgsqlCommand($"SELECT value FROM {tableName}", c, transaction);
138                      await using var reader = await cmd.ExecuteReaderAsync();
139                      Assert.That(reader.Read, Is.True);
140                      Assert.That(reader.GetFieldValue<string>(0), Is.EqualTo("Before snapshot"));
141                      Assert.That(reader.Read, Is.False);
142                  }
143              }, nameof(CreateLogicalReplicationSlot_Export) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : "") + (implicitInitMode ? "_i" : ""));
144      [Test(Description = "Since we currently don't provide an API to start a transaction on a logical replication connection, " +
145                          "USE_SNAPSHOT currently doesn't work and always leads to an exception. On the other hand, starting" +
146                          "a transaction would only be useful if we'd also provide an API to issue commands.")]
147      public Task CreateLogicalReplicationSlot_Use([Values]bool temporary, [Values]bool twoPhase)
148          => SafeReplicationTest(
149              async (slotName, _) =>
150              {
151                  await using var c = await OpenConnectionAsync();
152                  if (temporary)
153                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
154                  if (twoPhase)
155                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
156                  TestUtil.MinimumPgVersion(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
157                  Assert.That(async () =>
158                  {
159                      await using var rc = await OpenReplicationConnectionAsync();
160                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, LogicalSlotSnapshotInitMode.Use, twoPhase);
161                  }, Throws.InstanceOf<PostgresException>()
162                      .With.Property("SqlState")
163                      .EqualTo("XX000")
164                      .And.Message.Contains(
165                          c.PostgreSqlVersion.Major < 15
166                              ? "USE_SNAPSHOT"
167                              : "(SNAPSHOT 'use')"
168                          ));
169              }, nameof(CreateLogicalReplicationSlot_Use) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : ""));
170      [Test]
171      public void CreateLogicalReplicationSlot_with_null_slot_throws()
172          => Assert.That(async () =>
173          {
174              await using var rc = await OpenReplicationConnectionAsync();
175              await rc.CreateLogicalReplicationSlot(null!, OutputPlugin);
176          }, Throws.ArgumentNullException
177              .With.Property("ParamName")
178              .EqualTo("slotName"));
179      [Test]
180      public Task CreateLogicalReplicationSlot_with_null_output_plugin_throws()
181          => SafeReplicationTest(
182              (slotName, _) =>
183              {
184                  Assert.That(async () =>
185                  {
186                      await using var rc = await OpenReplicationConnectionAsync();
187                      await rc.CreateLogicalReplicationSlot(slotName, null!);
188                  }, Throws.ArgumentNullException
189                      .With.Property("ParamName")
190                      .EqualTo("outputPlugin"));
191                  return Task.CompletedTask;
192              });
193      [Test]
194      public Task CreateLogicalReplicationSlot_with_cancelled_token()
195          => SafeReplicationTest(
196              (slotName, _) =>
197              {
198                  Assert.That(async () =>
199                  {
200                      await using var rc = await OpenReplicationConnectionAsync();
201                      var token = GetCancelledCancellationToken();
202                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, cancellationToken: token);
203                  }, Throws.Exception.AssignableTo<OperationCanceledException>());
204                  return Task.CompletedTask;
205              });
206      [Test]
207      public Task CreateLogicalReplicationSlot_with_invalid_SnapshotInitMode_throws()
208          => SafeReplicationTest(
209              (slotName, _) =>
210              {
211                  Assert.That(async () =>
212                  {
213                      await using var rc = await OpenReplicationConnectionAsync();
214                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, slotSnapshotInitMode: (LogicalSlotSnapshotInitMode)42);
215                  }, Throws.InstanceOf<ArgumentOutOfRangeException>()
216                      .With.Property("ParamName")
217                      .EqualTo("slotSnapshotInitMode")
218                      .And.Property("ActualValue")
219                      .EqualTo((LogicalSlotSnapshotInitMode)42));
220                  return Task.CompletedTask;
221              });
222      [Test]
223      public Task CreateLogicalReplicationSlot_with_disposed_connection_throws()
224          => SafeReplicationTest(
225              (slotName, _) =>
226              {
227                  Assert.That(async () =>
228                  {
229                      var rc = await OpenReplicationConnectionAsync();
230                      await rc.DisposeAsync();
231                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin);
232                  }, Throws.InstanceOf<ObjectDisposedException>()
233                      .With.Property(nameof(ObjectDisposedException.ObjectName))
234                      .EqualTo(nameof(LogicalReplicationConnection)));
235                  return Task.CompletedTask;
236              });
237      protected override string Postfix => "commonl_l";
238  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputReplicationTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Runtime.CompilerServices;
6  using System.Text;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using NUnit.Framework;
10  using Npgsql.Replication;
11  using Npgsql.Replication.PgOutput;
12  using Npgsql.Replication.PgOutput.Messages;
13  using TruncateOptions = Npgsql.Replication.PgOutput.Messages.TruncateMessage.TruncateOptions;
14  using ReplicaIdentitySetting = Npgsql.Replication.PgOutput.Messages.RelationMessage.ReplicaIdentitySetting;
15  using static Npgsql.Tests.TestUtil;
16  namespace Npgsql.Tests.Replication;
17  [TestFixture(ProtocolVersion.V1, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.DefaultTransactionMode)]
18  [TestFixture(ProtocolVersion.V1, ReplicationDataMode.BinaryReplicationDataMode, TransactionMode.DefaultTransactionMode)]
19  [TestFixture(ProtocolVersion.V2, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.StreamingTransactionMode)]
20  [TestFixture(ProtocolVersion.V3, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.DefaultTransactionMode)]
21  [TestFixture(ProtocolVersion.V3, ReplicationDataMode.DefaultReplicationDataMode, TransactionMode.StreamingTransactionMode)]
22  [Platform(Exclude = "MacOsX", Reason = "Replication tests are flaky in CI on Mac")]
23  [NonParallelizable] 
24  public class PgOutputReplicationTests : SafeReplicationTestBase<LogicalReplicationConnection>
25  {
26      readonly ulong _protocolVersion;
27      readonly bool? _binary;
28      readonly bool? _streaming;
29      bool IsBinary => _binary ?? false;
30      bool IsStreaming => _streaming ?? false;
31      ulong Version => _protocolVersion;
32      public PgOutputReplicationTests(ProtocolVersion protocolVersion, ReplicationDataMode dataMode, TransactionMode transactionMode)
33      {
34          _protocolVersion = (ulong)protocolVersion;
35          _binary = dataMode == ReplicationDataMode.BinaryReplicationDataMode
36              ? true
37              : dataMode == ReplicationDataMode.TextReplicationDataMode
38                  ? false
39                  : null;
40          _streaming = transactionMode == TransactionMode.StreamingTransactionMode
41              ? true
42              : transactionMode == TransactionMode.NonStreamingTransactionMode
43                  ? false
44                  : null;
45      }
46      [Test]
47      public Task CreatePgOutputReplicationSlot()
48      {
49          if (IsBinary || IsStreaming)
50              return Task.CompletedTask;
51          return SafeReplicationTest(
52              async (slotName, _) =>
53              {
54                  await using var c = await OpenConnectionAsync();
55                  await using var rc = await OpenReplicationConnectionAsync();
56                  var options = await rc.CreatePgOutputReplicationSlot(slotName);
57                  using var cmd =
58                      new NpgsqlCommand($"SELECT * FROM pg_replication_slots WHERE slot_name = '{options.Name}'",
59                          c);
60                  await using var reader = await cmd.ExecuteReaderAsync();
61                  Assert.That(reader.Read, Is.True);
62                  Assert.That(reader.GetFieldValue<string>(reader.GetOrdinal("slot_type")), Is.EqualTo("logical"));
63                  Assert.That(reader.GetFieldValue<string>(reader.GetOrdinal("plugin")), Is.EqualTo("pgoutput"));
64                  Assert.That(reader.Read, Is.False);
65              });
66      }
67      [Test(Description = "Tests whether INSERT commands get replicated as Logical Replication Protocol Messages")]
68      public Task Insert()
69          => SafePgOutputReplicationTest(
70              async (slotName, tableName, publicationName) =>
71              {
72                  await using var c = await OpenConnectionAsync();
73                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NULL);
74                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
75                  await using var rc = await OpenReplicationConnectionAsync();
76                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
77                  await using var tran = await c.BeginTransactionAsync();
78                  await c.ExecuteNonQueryAsync(@$"INSERT INTO {tableName} VALUES (1, 'val1'), (2, NULL), (3, 'ignored');
79                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(4, 15000) s(i);");
80                  await tran.CommitAsync();
81                  using var streamingCts = new CancellationTokenSource();
82                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
83                      .GetAsyncEnumerator();
84                  var transactionXid = await AssertTransactionStart(messages);
85                  var relationMsg = await NextMessage<RelationMessage>(messages);
86                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
87                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
88                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
89                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
90                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
91                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
92                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
93                  var insertMsg = await NextMessage<InsertMessage>(messages);
94                  Assert.That(insertMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
95                  Assert.That(insertMsg.Relation, Is.SameAs(relationMsg));
96                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
97                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
98                  if (IsBinary)
99                      Assert.That(await columnEnumerator.Current.Get<int>(), Is.EqualTo(1));
100                  else
101                      Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
102                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
103                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
104                  Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("val1"));
105                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
106                  insertMsg = await NextMessage<InsertMessage>(messages);
107                  Assert.That(insertMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
108                  Assert.That(insertMsg.Relation, Is.SameAs(relationMsg));
109                  columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
110                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
111                  if (IsBinary)
112                      Assert.That(await columnEnumerator.Current.Get<int>(), Is.EqualTo(2));
113                  else
114                      Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("2"));
115                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
116                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
117                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
118                  insertMsg = await NextMessage<InsertMessage>(messages);
119                  Assert.That(insertMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
120                  Assert.That(insertMsg.Relation, Is.SameAs(relationMsg));
121                  await foreach (var tuple in insertMsg.NewRow) 
122                      Assert.That(tuple.Kind, IsBinary ? Is.EqualTo(TupleDataKind.BinaryValue) : Is.EqualTo(TupleDataKind.TextValue));
123                  for (var insertCount = 0; insertCount < 14997; insertCount++)
124                  {
125                      await NextMessage<InsertMessage>(messages);
126                  }
127                  await AssertTransactionCommit(messages);
128                  streamingCts.Cancel();
129                  await AssertReplicationCancellation(messages);
130                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
131              });
132      [Test(Description = "Tests whether UPDATE commands get replicated as Logical Replication Protocol Messages for tables using the default replica identity")]
133      public Task Update_for_default_replica_identity()
134          => SafeReplicationTest(
135              async (slotName, tableName, publicationName) =>
136              {
137                  await using var c = await OpenConnectionAsync();
138                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
139                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
140                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
141                  await using var rc = await OpenReplicationConnectionAsync();
142                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
143                  await using var tran = await c.BeginTransactionAsync();
144                  await c.ExecuteNonQueryAsync(@$"UPDATE {tableName} SET name='val1_updated' WHERE id = 1;
145                                                      UPDATE {tableName} SET name = md5(name) WHERE id > 1");
146                  await tran.CommitAsync();
147                  using var streamingCts = new CancellationTokenSource();
148                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
149                      .GetAsyncEnumerator();
150                  var transactionXid = await AssertTransactionStart(messages);
151                  var relationMsg = await NextMessage<RelationMessage>(messages);
152                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
153                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
154                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
155                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
156                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
157                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
158                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
159                  var updateMsg = await NextMessage<DefaultUpdateMessage>(messages);
160                  Assert.That(updateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
161                  Assert.That(updateMsg.Relation, Is.SameAs(relationMsg));
162                  var columnEnumerator = updateMsg.NewRow.GetAsyncEnumerator();
163                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
164                  if (IsBinary)
165                      Assert.That(await columnEnumerator.Current.Get<int>(), Is.EqualTo(1));
166                  else
167                      Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
168                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
169                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
170                  Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("val1_updated"));
171                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
172                  for (var updateCount = 0; updateCount < 14999; updateCount++)
173                      await NextMessage<DefaultUpdateMessage>(messages);
174                  await AssertTransactionCommit(messages);
175                  streamingCts.Cancel();
176                  await AssertReplicationCancellation(messages);
177                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
178              });
179      [Test(Description = "Tests whether UPDATE commands get replicated as Logical Replication Protocol Messages for tables using an index as replica identity")]
180      public  Task Update_for_index_replica_identity()
181          => SafeReplicationTest(
182              async (slotName, tableName, publicationName) =>
183              {
184                  await using var c = await OpenConnectionAsync();
185                  var indexName = $"i_{tableName.Substring(2)}";
186                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
187                                                      CREATE UNIQUE INDEX {indexName} ON {tableName} (name);
188                                                      ALTER TABLE {tableName} REPLICA IDENTITY USING INDEX {indexName};
189                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
190                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
191                  await using var rc = await OpenReplicationConnectionAsync();
192                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
193                  await using var tran = await c.BeginTransactionAsync();
194                  await c.ExecuteNonQueryAsync(@$"UPDATE {tableName} SET name='val1_updated' WHERE id = 1;
195                                                      UPDATE {tableName} SET name = md5(name) WHERE id > 1");
196                  await tran.CommitAsync();
197                  using var streamingCts = new CancellationTokenSource();
198                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
199                      .GetAsyncEnumerator();
200                  var transactionXid = await AssertTransactionStart(messages);
201                  var relationMsg = await NextMessage<RelationMessage>(messages);
202                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
203                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.IndexWithIndIsReplIdent));
204                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
205                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
206                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
207                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
208                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
209                  var updateMsg = await NextMessage<IndexUpdateMessage>(messages);
210                  Assert.That(updateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
211                  Assert.That(updateMsg.Relation, Is.SameAs(relationMsg));
212                  var oldRowColumnEnumerator = updateMsg.Key.GetAsyncEnumerator();
213                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
214                  Assert.That(oldRowColumnEnumerator.Current.IsDBNull, Is.True);
215                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
216                  Assert.That(await oldRowColumnEnumerator.Current.Get<string>(), Is.EqualTo("val1"));
217                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.False);
218                  var newRowColumnEnumerator = updateMsg.NewRow.GetAsyncEnumerator();
219                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
220                  if (IsBinary)
221                      Assert.That(await newRowColumnEnumerator.Current.Get<int>(), Is.EqualTo(1));
222                  else
223                      Assert.That(await newRowColumnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
224                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
225                  Assert.That(await newRowColumnEnumerator.Current.Get<string>(), Is.EqualTo("val1_updated"));
226                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.False);
227                  for (var updateCount = 0; updateCount < 14999; updateCount++)
228                      await NextMessage<IndexUpdateMessage>(messages);
229                  await AssertTransactionCommit(messages);
230                  streamingCts.Cancel();
231                  await AssertReplicationCancellation(messages);
232                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
233              });
234      [Test(Description = "Tests whether UPDATE commands get replicated as Logical Replication Protocol Messages for tables using full replica identity")]
235      public  Task Update_for_full_replica_identity()
236          => SafeReplicationTest(
237              async (slotName, tableName, publicationName) =>
238              {
239                  await using var c = await OpenConnectionAsync();
240                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
241                                                      ALTER TABLE {tableName} REPLICA IDENTITY FULL;
242                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
243                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
244                  await using var rc = await OpenReplicationConnectionAsync();
245                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
246                  await using var tran = await c.BeginTransactionAsync();
247                  await c.ExecuteNonQueryAsync(@$"UPDATE {tableName} SET name='val1_updated' WHERE id = 1;
248                                                      UPDATE {tableName} SET name = md5(name) WHERE id > 1");
249                  await tran.CommitAsync();
250                  using var streamingCts = new CancellationTokenSource();
251                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
252                      .GetAsyncEnumerator();
253                  var transactionXid = await AssertTransactionStart(messages);
254                  var relationMsg = await NextMessage<RelationMessage>(messages);
255                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
256                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.AllColumns));
257                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
258                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
259                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
260                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
261                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
262                  var updateMsg = await NextMessage<FullUpdateMessage>(messages);
263                  Assert.That(updateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
264                  Assert.That(updateMsg.Relation, Is.SameAs(relationMsg));
265                  var oldRowColumnEnumerator = updateMsg.OldRow.GetAsyncEnumerator();
266                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
267                  if (IsBinary)
268                      Assert.That(await oldRowColumnEnumerator.Current.Get<int>(), Is.EqualTo(1));
269                  else
270                      Assert.That(await oldRowColumnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
271                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.True);
272                  Assert.That(await oldRowColumnEnumerator.Current.Get<string>(), Is.EqualTo("val1"));
273                  Assert.That(await oldRowColumnEnumerator.MoveNextAsync(), Is.False);
274                  var newRowColumnEnumerator = updateMsg.NewRow.GetAsyncEnumerator();
275                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
276                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.True);
277                  Assert.That(await newRowColumnEnumerator.Current.Get<string>(), Is.EqualTo("val1_updated"));
278                  Assert.That(await newRowColumnEnumerator.MoveNextAsync(), Is.False);
279                  for (var updateCount = 0; updateCount < 14999; updateCount++)
280                      await NextMessage<FullUpdateMessage>(messages);
281                  await AssertTransactionCommit(messages);
282                  streamingCts.Cancel();
283                  Assert.That(async () => await messages.MoveNextAsync(), Throws.Exception.AssignableTo<OperationCanceledException>()
284                      .With.InnerException.InstanceOf<PostgresException>()
285                      .And.InnerException.Property(nameof(PostgresException.SqlState))
286                      .EqualTo(PostgresErrorCodes.QueryCanceled));
287                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
288              });
289      [Test(Description = "Tests whether DELETE commands get replicated as Logical Replication Protocol Messages for tables using the default replica identity")]
290      public Task Delete_for_default_replica_identity()
291          => SafeReplicationTest(
292              async (slotName, tableName, publicationName) =>
293              {
294                  await using var c = await OpenConnectionAsync();
295                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
296                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
297                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
298                  await using var rc = await OpenReplicationConnectionAsync();
299                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
300                  await using var tran = await c.BeginTransactionAsync();
301                  await c.ExecuteNonQueryAsync(@$"DELETE FROM {tableName} WHERE id = 1;
302                                                      DELETE FROM {tableName} WHERE id > 1");
303                  await tran.CommitAsync();
304                  using var streamingCts = new CancellationTokenSource();
305                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
306                      .GetAsyncEnumerator();
307                  var transactionXid = await AssertTransactionStart(messages);
308                  var relationMsg = await NextMessage<RelationMessage>(messages);
309                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
310                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
311                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
312                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
313                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
314                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
315                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
316                  var deleteMsg = await NextMessage<KeyDeleteMessage>(messages);
317                  Assert.That(deleteMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
318                  Assert.That(deleteMsg.Relation, Is.SameAs(relationMsg));
319                  var columnEnumerator = deleteMsg.Key.GetAsyncEnumerator();
320                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
321                  if (IsBinary)
322                      Assert.That(await columnEnumerator.Current.Get<int>(), Is.EqualTo(1));
323                  else
324                      Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
325                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
326                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
327                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
328                  for (var deleteCount = 0; deleteCount < 14999; deleteCount++)
329                      await NextMessage<KeyDeleteMessage>(messages);
330                  await AssertTransactionCommit(messages);
331                  streamingCts.Cancel();
332                  await AssertReplicationCancellation(messages);
333                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
334              });
335      [Test(Description = "Tests whether DELETE commands get replicated as Logical Replication Protocol Messages for tables using an index as replica identity")]
336      public Task Delete_for_index_replica_identity()
337          => SafeReplicationTest(
338              async (slotName, tableName, publicationName) =>
339              {
340                  await using var c = await OpenConnectionAsync();
341                  var indexName = $"i_{tableName.Substring(2)}";
342                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
343                                                      CREATE UNIQUE INDEX {indexName} ON {tableName} (name);
344                                                      ALTER TABLE {tableName} REPLICA IDENTITY USING INDEX {indexName};
345                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
346                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
347                  await using var rc = await OpenReplicationConnectionAsync();
348                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
349                  await using var tran = await c.BeginTransactionAsync();
350                  await c.ExecuteNonQueryAsync(@$"DELETE FROM {tableName} WHERE id = 1;
351                                                      DELETE FROM {tableName} WHERE id > 1");
352                  await tran.CommitAsync();
353                  using var streamingCts = new CancellationTokenSource();
354                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
355                      .GetAsyncEnumerator();
356                  var transactionXid = await AssertTransactionStart(messages);
357                  var relationMsg = await NextMessage<RelationMessage>(messages);
358                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
359                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.IndexWithIndIsReplIdent));
360                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
361                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
362                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
363                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
364                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
365                  var deleteMsg = await NextMessage<KeyDeleteMessage>(messages);
366                  Assert.That(deleteMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
367                  Assert.That(deleteMsg.Relation, Is.SameAs(relationMsg));
368                  var columnEnumerator = deleteMsg.Key.GetAsyncEnumerator();
369                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
370                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
371                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
372                  Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("val1"));
373                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
374                  for (var deleteCount = 0; deleteCount < 14999; deleteCount++)
375                      await NextMessage<KeyDeleteMessage>(messages);
376                  await AssertTransactionCommit(messages);
377                  streamingCts.Cancel();
378                  await AssertReplicationCancellation(messages);
379                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
380              });
381      [Test(Description = "Tests whether DELETE commands get replicated as Logical Replication Protocol Messages for tables using full replica identity")]
382      public Task Delete_for_full_replica_identity()
383          => SafeReplicationTest(
384              async (slotName, tableName, publicationName) =>
385              {
386                  await using var c = await OpenConnectionAsync();
387                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
388                                                      ALTER TABLE {tableName} REPLICA IDENTITY FULL;
389                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
390                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
391                  await using var rc = await OpenReplicationConnectionAsync();
392                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
393                  await using var tran = await c.BeginTransactionAsync();
394                  await c.ExecuteNonQueryAsync(@$"DELETE FROM {tableName} WHERE id = 1;
395                                                      DELETE FROM {tableName} WHERE id > 1");
396                  await tran.CommitAsync();
397                  using var streamingCts = new CancellationTokenSource();
398                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
399                      .GetAsyncEnumerator();
400                  var transactionXid = await AssertTransactionStart(messages);
401                  var relationMsg = await NextMessage<RelationMessage>(messages);
402                  Assert.That(relationMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
403                  Assert.That(relationMsg.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.AllColumns));
404                  Assert.That(relationMsg.Namespace, Is.EqualTo("public"));
405                  Assert.That(relationMsg.RelationName, Is.EqualTo(tableName));
406                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(2));
407                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
408                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("name"));
409                  var deleteMsg = await NextMessage<FullDeleteMessage>(messages);
410                  Assert.That(deleteMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
411                  Assert.That(deleteMsg.Relation, Is.SameAs(relationMsg));
412                  var columnEnumerator = deleteMsg.OldRow.GetAsyncEnumerator();
413                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
414                  if (IsBinary)
415                      Assert.That(await columnEnumerator.Current.Get<int>(), Is.EqualTo(1));
416                  else
417                      Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
418                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.True);
419                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
420                  Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("val1"));
421                  Assert.That(await columnEnumerator.MoveNextAsync(), Is.False);
422                  for (var deleteCount = 0; deleteCount < 14999; deleteCount++)
423                      await NextMessage<FullDeleteMessage>(messages);
424                  await AssertTransactionCommit(messages);
425                  streamingCts.Cancel();
426                  await AssertReplicationCancellation(messages);
427                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
428              });
429      [Test(Description = "Tests whether TRUNCATE commands get replicated as Logical Replication Protocol Messages on PostgreSQL 11 and above")]
430      [TestCase(TruncateOptions.None)]
431      [TestCase(TruncateOptions.Cascade)]
432      [TestCase(TruncateOptions.RestartIdentity)]
433      [TestCase(TruncateOptions.Cascade | TruncateOptions.RestartIdentity)]
434      public Task Truncate(TruncateOptions truncateOptionFlags)
435          => SafeReplicationTest(
436              async (slotName, tableName, publicationName) =>
437              {
438                  await using var c = await OpenConnectionAsync();
439                  TestUtil.MinimumPgVersion(c, "11.0", "Replication of TRUNCATE commands was introduced in PostgreSQL 11");
440                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY, name TEXT NOT NULL);
441                                                      INSERT INTO {tableName} (name) VALUES ('val1');
442                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
443                  await using var rc = await OpenReplicationConnectionAsync();
444                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
445                  var sb = new StringBuilder("TRUNCATE TABLE ").Append(tableName);
446                  if (truncateOptionFlags.HasFlag(TruncateOptions.RestartIdentity))
447                      sb.Append(" RESTART IDENTITY");
448                  if (truncateOptionFlags.HasFlag(TruncateOptions.Cascade))
449                      sb.Append(" CASCADE");
450                  sb.Append($"; INSERT INTO {tableName} (name) SELECT 'val' || i::text FROM generate_series(1, 15000) s(i);");
451                  await using var tran = await c.BeginTransactionAsync();
452                  await c.ExecuteNonQueryAsync(sb.ToString());
453                  await tran.CommitAsync();
454                  using var streamingCts = new CancellationTokenSource();
455                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
456                      .GetAsyncEnumerator();
457                  var transactionXid = await AssertTransactionStart(messages);
458                  var relationMessage = await NextMessage<RelationMessage>(messages);
459                  Assert.That(relationMessage.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
460                  Assert.That(relationMessage.ReplicaIdentity, Is.EqualTo(ReplicaIdentitySetting.Default));
461                  Assert.That(relationMessage.Namespace, Is.EqualTo("public"));
462                  Assert.That(relationMessage.RelationName, Is.EqualTo(tableName));
463                  Assert.That(relationMessage.Columns.Count, Is.EqualTo(2));
464                  Assert.That(relationMessage.Columns[0].ColumnName, Is.EqualTo("id"));
465                  Assert.That(relationMessage.Columns[1].ColumnName, Is.EqualTo("name"));
466                  var truncateMsg = await NextMessage<TruncateMessage>(messages);
467                  Assert.That(truncateMsg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
468                  Assert.That(truncateMsg.Options, Is.EqualTo(truncateOptionFlags));
469                  Assert.That(truncateMsg.Relations.Single(), Is.SameAs(relationMessage));
470                  for (var insertCount = 0; insertCount < 15000; insertCount++)
471                      await NextMessage<InsertMessage>(messages, expectRelationMessage: true);
472                  await AssertTransactionCommit(messages);
473                  streamingCts.Cancel();
474                  await AssertReplicationCancellation(messages);
475                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
476              }, nameof(Truncate) + truncateOptionFlags.ToString("D"));
477      [Test(Description = "Tests whether disposing while replicating will get us stuck forever.")]
478      public Task Dispose_while_replicating()
479          => SafeReplicationTest(
480              async (slotName, tableName, publicationName) =>
481              {
482                  await using var c = await OpenConnectionAsync();
483                  await c.ExecuteNonQueryAsync(@$"
484  CREATE TABLE {tableName} (id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY, name TEXT NOT NULL);
485  CREATE PUBLICATION {publicationName} FOR TABLE {tableName};
486  ");
487                  await using var rc = await OpenReplicationConnectionAsync();
488                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
489                  await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} (name) VALUES ('value 1'), ('value 2');");
490                  using var streamingCts = new CancellationTokenSource();
491                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
492                      .GetAsyncEnumerator();
493                  await NextMessage<BeginMessage>(messages);
494              }, nameof(Dispose_while_replicating));
495      [TestCase(true)]
496      [TestCase(false)]
497      [Test(Description = "Tests whether logical decoding messages get replicated as Logical Replication Protocol Messages on PostgreSQL 14 and above")]
498      public Task LogicalDecodingMessage(bool writeMessages)
499          => SafeReplicationTest(
500              async (slotName, tableName, publicationName) =>
501              {
502                  const string prefix = "My test Prefix";
503                  const string transactionalMessage = "A transactional message";
504                  const string nonTransactionalMessage = "A non-transactional message";
505                  await using var c = await OpenConnectionAsync();
506                  TestUtil.MinimumPgVersion(c, "14.0", "Replication of logical decoding messages was introduced in PostgreSQL 14");
507                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NOT NULL);
508                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
509                  await using var rc = await OpenReplicationConnectionAsync();
510                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
511                  await using var tran = await c.BeginTransactionAsync();
512                  await c.ExecuteNonQueryAsync(@$"SELECT pg_logical_emit_message(true, '{prefix}', '{transactionalMessage}');
513                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);", tran);
514                  await tran.CommitAsync();
515                  await using var tran2 = await c.BeginTransactionAsync();
516                  await c.ExecuteNonQueryAsync(@$"SELECT pg_logical_emit_message(false, '{prefix}', '{nonTransactionalMessage}');
517                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(15001, 15010) s(i);
518                                                      SELECT pg_logical_emit_message(true, '{prefix}', '{transactionalMessage}');
519                                                      INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(15011, 30000) s(i);
520                                                      SELECT pg_logical_emit_message(false, '{prefix}', '{nonTransactionalMessage}');
521                                                      ", tran2);
522                  await tran2.RollbackAsync();
523                  await c.ExecuteNonQueryAsync(@$"SELECT pg_switch_wal();");
524                  using var streamingCts = new CancellationTokenSource();
525                  var messages = SkipEmptyTransactions(rc.StartReplication(slot,
526                          GetOptions(publicationName, writeMessages), streamingCts.Token))
527                      .GetAsyncEnumerator();
528                  var transactionXid = await AssertTransactionStart(messages);
529                  if (writeMessages)
530                  {
531                      var msg = await NextMessage<LogicalDecodingMessage>(messages);
532                      Assert.That(msg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
533                      Assert.That(msg.Flags, Is.EqualTo(1));
534                      Assert.That(msg.Prefix, Is.EqualTo(prefix));
535                      Assert.That(msg.Data.Length, Is.EqualTo(transactionalMessage.Length));
536                      var buffer = new MemoryStream();
537                      await msg.Data.CopyToAsync(buffer, CancellationToken.None);
538                      Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(transactionalMessage));
539                  }
540                  await NextMessage<RelationMessage>(messages);
541                  for (var insertCount = 0; insertCount < 15000; insertCount++)
542                      await NextMessage<InsertMessage>(messages);
543                  await AssertTransactionCommit(messages);
544                  if (writeMessages)
545                  {
546                      var msg = await NextMessage<LogicalDecodingMessage>(messages);
547                      Assert.That(msg.TransactionXid, Is.Null);
548                      Assert.That(msg.Flags, Is.EqualTo(0));
549                      Assert.That(msg.Prefix, Is.EqualTo(prefix));
550                      Assert.That(msg.Data.Length, Is.EqualTo(nonTransactionalMessage.Length));
551                      var buffer = new MemoryStream();
552                      await msg.Data.CopyToAsync(buffer, CancellationToken.None);
553                      Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(nonTransactionalMessage));
554                  }
555                  if (IsStreaming)
556                  {
557                      transactionXid = await AssertTransactionStart(messages);
558                      await NextMessage<RelationMessage>(messages);
559                      for (var insertCount = 0; insertCount < 10; insertCount++)
560                          await NextMessage<InsertMessage>(messages);
561                      if (writeMessages)
562                      {
563                          var msg = await NextMessage<LogicalDecodingMessage>(messages);
564                          Assert.That(msg.TransactionXid, IsStreaming ? Is.EqualTo(transactionXid) : Is.Null);
565                          Assert.That(msg.Flags, Is.EqualTo(1));
566                          Assert.That(msg.Prefix, Is.EqualTo(prefix));
567                          Assert.That(msg.Data.Length, Is.EqualTo(transactionalMessage.Length));
568                          var buffer = new MemoryStream();
569                          await msg.Data.CopyToAsync(buffer, CancellationToken.None);
570                          Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(transactionalMessage));
571                      }
572                      while (await messages.MoveNextAsync() && messages.Current is InsertMessage
573                             || messages.Current is StreamStopMessage
574                             && await messages.MoveNextAsync()
575                             && messages.Current is StreamStartMessage
576                             && await messages.MoveNextAsync()
577                             && messages.Current is InsertMessage)
578                      {
579                      }
580                  }
581                  else if (writeMessages)
582                      await messages.MoveNextAsync();
583                  if (writeMessages)
584                  {
585                      var msg = (LogicalDecodingMessage)messages.Current;
586                      Assert.That(msg.TransactionXid, Is.Null);
587                      Assert.That(msg.Flags, Is.EqualTo(0));
588                      Assert.That(msg.Prefix, Is.EqualTo(prefix));
589                      Assert.That(msg.Data.Length, Is.EqualTo(nonTransactionalMessage.Length));
590                      var buffer = new MemoryStream();
591                      await msg.Data.CopyToAsync(buffer, CancellationToken.None);
592                      Assert.That(rc.Encoding.GetString(buffer.ToArray()), Is.EqualTo(nonTransactionalMessage));
593                      if (IsStreaming)
594                          await messages.MoveNextAsync();
595                  }
596                  if (IsStreaming)
597                      Assert.That(messages.Current, Is.TypeOf<StreamAbortMessage>());
598                  streamingCts.Cancel();
599                  await AssertReplicationCancellation(messages);
600                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
601              }, $"{GetObjectName(nameof(LogicalDecodingMessage))}_m_{BoolToChar(writeMessages)}");
602      [Test]
603      public Task Stream()
604      {
605          if (IsStreaming)
606              return Task.CompletedTask;
607          return SafePgOutputReplicationTest(
608              async (slotName, tableName, publicationName) =>
609              {
610                  await using var c = await OpenConnectionAsync();
611                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (bytes bytea);
612                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
613                  var rc = await OpenReplicationConnectionAsync();
614                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
615                  var bytes = new byte[16384];
616                  for (var i = 0; i < 10; i++)
617                      bytes[i] = (byte)i;
618                  using (var command = new NpgsqlCommand($"INSERT INTO {tableName} VALUES ($1)", c))
619                  {
620                      command.Parameters.Add(new() { Value = bytes });
621                      await command.ExecuteNonQueryAsync();
622                  }
623                  using var streamingCts = new CancellationTokenSource();
624                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
625                      .GetAsyncEnumerator();
626                  await AssertTransactionStart(messages);
627                  await NextMessage<RelationMessage>(messages);
628                  var insertMsg = await NextMessage<InsertMessage>(messages);
629                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
630                  await columnEnumerator.MoveNextAsync();
631                  var stream = columnEnumerator.Current.GetStream();
632                  Assert.That(() => columnEnumerator.Current.GetStream(), Throws.Exception.TypeOf<InvalidOperationException>());
633                  Assert.That(() => columnEnumerator.Current.Get(), Throws.Exception.TypeOf<InvalidOperationException>());
634                  Assert.That(() => columnEnumerator.Current.Get<byte[]>(), Throws.Exception.TypeOf<InvalidOperationException>());
635                  if (IsBinary)
636                  {
637                      var someBytes = new byte[10];
638                      Assert.That(await stream.ReadAsync(someBytes, 0, 10), Is.EqualTo(10));
639                      Assert.That(someBytes, Is.EquivalentTo(bytes[..10]));
640                  }
641                  else
642                  {
643                      var hexString = "\\x" + BitConverter.ToString(bytes[..10]).Replace("-", string.Empty);
644                      var expected = Encoding.ASCII.GetBytes(hexString);
645                      var someBytes = new byte[expected.Length];
646                      Assert.That(await stream.ReadAsync(someBytes, 0, someBytes.Length), Is.EqualTo(someBytes.Length));
647                      Assert.That(someBytes, Is.EquivalentTo(expected));
648                  }
649                  await AssertTransactionCommit(messages);
650                  streamingCts.Cancel();
651                  await AssertReplicationCancellation(messages);
652                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
653              });
654      }
655      [Test]
656      public Task TextReader()
657      {
658          if (IsStreaming)
659              return Task.CompletedTask;
660          return SafePgOutputReplicationTest(
661              async (slotName, tableName, publicationName) =>
662              {
663                  await using var c = await OpenConnectionAsync();
664                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NULL);
665                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
666                  var rc = await OpenReplicationConnectionAsync();
667                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
668                  var expectedText = "val1";
669                  await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} VALUES (1, '{expectedText}')");
670                  using var streamingCts = new CancellationTokenSource();
671                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
672                      .GetAsyncEnumerator();
673                  await AssertTransactionStart(messages);
674                  await NextMessage<RelationMessage>(messages);
675                  var insertMsg = await NextMessage<InsertMessage>(messages);
676                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
677                  await columnEnumerator.MoveNextAsync(); 
678                  await columnEnumerator.MoveNextAsync();
679                  using var reader = columnEnumerator.Current.GetTextReader();
680                  Assert.That(await reader.ReadToEndAsync(), Is.EqualTo(expectedText));
681                  await AssertTransactionCommit(messages);
682                  streamingCts.Cancel();
683                  await AssertReplicationCancellation(messages);
684                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
685              });
686      }
687      [Test]
688      public Task ValueMetadata()
689      {
690          if (IsStreaming)
691              return Task.CompletedTask;
692          return SafePgOutputReplicationTest(
693              async (slotName, tableName, publicationName) =>
694              {
695                  await using var c = await OpenConnectionAsync();
696                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (id INT PRIMARY KEY, name TEXT NULL);
697                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
698                  var rc = await OpenReplicationConnectionAsync();
699                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
700                  await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} VALUES (1, 'val1')");
701                  using var streamingCts = new CancellationTokenSource();
702                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
703                      .GetAsyncEnumerator();
704                  await AssertTransactionStart(messages);
705                  await NextMessage<RelationMessage>(messages);
706                  var insertMsg = await NextMessage<InsertMessage>(messages);
707                  var columnEnumerator = insertMsg.NewRow.GetAsyncEnumerator();
708                  await columnEnumerator.MoveNextAsync();
709                  Assert.That(columnEnumerator.Current.GetFieldType(), Is.SameAs(IsBinary ? typeof(int) : typeof(string)));
710                  Assert.That(columnEnumerator.Current.GetPostgresType().Name, Is.EqualTo("integer"));
711                  Assert.That(columnEnumerator.Current.GetDataTypeName(), Is.EqualTo("integer"));
712                  Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
713                  await AssertTransactionCommit(messages);
714                  streamingCts.Cancel();
715                  await AssertReplicationCancellation(messages);
716                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
717              });
718      }
719      [Test]
720      public Task Null()
721      {
722          if (IsStreaming)
723              return Task.CompletedTask;
724          return SafePgOutputReplicationTest(
725              async (slotName, tableName, publicationName) =>
726              {
727                  await using var c = await OpenConnectionAsync();
728                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (int1 INT, int2 INT);
729                                                      CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
730                  var rc = await OpenReplicationConnectionAsync();
731                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
732                  await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} VALUES (1, 1), (NULL, NULL)");
733                  using var streamingCts = new CancellationTokenSource();
734                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
735                      .GetAsyncEnumerator();
736                  await AssertTransactionStart(messages);
737                  await NextMessage<RelationMessage>(messages);
738                  var columnEnumerator = (await NextMessage<InsertMessage>(messages)).NewRow.GetAsyncEnumerator();
739                  await columnEnumerator.MoveNextAsync();
740                  Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
741                  Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
742                  if (IsBinary)
743                      Assert.That(await columnEnumerator.Current.Get<int>(), Is.EqualTo(1));
744                  else
745                      Assert.That(await columnEnumerator.Current.Get<string>(), Is.EqualTo("1"));
746                  await columnEnumerator.MoveNextAsync();
747                  Assert.That(await columnEnumerator.Current.Get(), Is.EqualTo(IsBinary ? 1 : "1"));
748                  columnEnumerator = (await NextMessage<InsertMessage>(messages)).NewRow.GetAsyncEnumerator();
749                  await columnEnumerator.MoveNextAsync();
750                  Assert.That(columnEnumerator.Current.IsDBNull, Is.True);
751                  Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
752                  if (IsBinary)
753                      Assert.That(() => columnEnumerator.Current.Get<int>(), Throws.Exception.TypeOf<InvalidCastException>());
754                  else
755                      Assert.That(() => columnEnumerator.Current.Get<string>(), Throws.Exception.TypeOf<InvalidCastException>());
756                  await columnEnumerator.MoveNextAsync();
757                  Assert.That(await columnEnumerator.Current.Get(), Is.SameAs(DBNull.Value));
758                  await AssertTransactionCommit(messages);
759                  streamingCts.Cancel();
760                  await AssertReplicationCancellation(messages);
761                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
762              });
763      }
764      [NpgsqlTypes.PgName("descriptor")]
765      public class Descriptor
766      {
767          [NpgsqlTypes.PgName("id")]
768          public long Id { get; set; }
769          [NpgsqlTypes.PgName("name")]
770          public string Name { get; set; } = string.Empty;
771      }
772  #pragma warning disable CS0618 
773      [Test, NonParallelizable]
774      public Task CompositeType()
775      {
776          if (IsStreaming)
777              return Task.CompletedTask;
778          return SafePgOutputReplicationTest(
779              async (slotName, tableName, publicationName) =>
780              {
781                  await using var adminConnection = await OpenConnectionAsync();
782                  await adminConnection.ExecuteNonQueryAsync(@$"
783  DROP TYPE IF EXISTS descriptor CASCADE;
784  CREATE TYPE descriptor AS (id bigint, name text);
785  CREATE TABLE {tableName} (descriptor_field descriptor);
786  CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
787                  NpgsqlConnection.GlobalTypeMapper.MapComposite<Descriptor>("descriptor");
788                  try
789                  {
790                      using var _ = CreateTempPool(ConnectionString, out var connString);
791                      var rc = await OpenReplicationConnectionAsync(connString);
792                      var slot = await rc.CreatePgOutputReplicationSlot(slotName);
793                      var expected = new Descriptor { Id = 1248, Name = "My Descriptor" };
794                      var stringValue = $"({expected.Id},\"{expected.Name}\")";
795                      await using var c = await OpenConnectionAsync();
796                      await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} VALUES ('{stringValue}')");
797                      using var streamingCts = new CancellationTokenSource();
798                      var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
799                          .GetAsyncEnumerator();
800                      await AssertTransactionStart(messages);
801                      await NextMessage<TypeMessage>(messages);
802                      await NextMessage<RelationMessage>(messages);
803                      var columnEnumerator = (await NextMessage<InsertMessage>(messages)).NewRow.GetAsyncEnumerator();
804                      await columnEnumerator.MoveNextAsync();
805                      Assert.That(columnEnumerator.Current.IsDBNull, Is.False);
806                      Assert.That(columnEnumerator.Current.IsUnchangedToastedValue, Is.False);
807                      if (IsBinary)
808                      {
809                          var result = await columnEnumerator.Current.Get<Descriptor>();
810                          Assert.That(result.Id, Is.EqualTo(expected.Id));
811                          Assert.That(result.Name, Is.EqualTo(expected.Name));
812                      }
813                      else
814                          Assert.That(await columnEnumerator.Current.Get(), Is.EqualTo(stringValue));
815                      await columnEnumerator.MoveNextAsync();
816                      await AssertTransactionCommit(messages);
817                      streamingCts.Cancel();
818                      await AssertReplicationCancellation(messages);
819                      await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
820                  }
821                  finally
822                  {
823                      await adminConnection.ExecuteNonQueryAsync("DROP TYPE IF EXISTS descriptor CASCADE;");
824                      NpgsqlConnection.GlobalTypeMapper.Reset();
825                  }
826              });
827      }
828  #pragma warning restore CS0618 
829      [Test]
830      public Task TwoPhase([Values]bool commit)
831      {
832          if (_protocolVersion < 3UL)
833              return Task.CompletedTask;
834          return SafePgOutputReplicationTest(
835              async (slotName, tableName, publicationName) =>
836              {
837                  var gid = Guid.NewGuid().ToString();
838                  await using var c = await OpenConnectionAsync();
839                  await c.ExecuteNonQueryAsync(@$"CREATE TABLE {tableName} (a int primary key, b varchar);
840                                                  CREATE PUBLICATION {publicationName} FOR TABLE {tableName};");
841                  await using var rc = await OpenReplicationConnectionAsync();
842                  var slot = await rc.CreatePgOutputReplicationSlot(slotName, twoPhase: true);
843                  await using var tran = await c.BeginTransactionAsync();
844                  await c.ExecuteNonQueryAsync(@$"INSERT INTO {tableName} SELECT i, 'val' || i::text FROM generate_series(1, 15000) s(i);
845  	                                            PREPARE TRANSACTION '{gid}';");
846                  try
847                  {
848                      using var streamingCts = new CancellationTokenSource();
849                      var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
850                          .GetAsyncEnumerator();
851                      var transactionXid = await AssertTransactionStart(messages);
852                      await NextMessage<RelationMessage>(messages);
853                      for (var insertCount = 0; insertCount < 15000; insertCount++)
854                      {
855                          await NextMessage<InsertMessage>(messages);
856                      }
857                      var prepareMessageBase = await AssertPrepare(messages);
858                      Assert.That(prepareMessageBase.TransactionXid, Is.EqualTo(transactionXid));
859                      Assert.That(prepareMessageBase.TransactionGid, Is.EqualTo(gid));
860                      if (commit)
861                      {
862                          await c.ExecuteNonQueryAsync(@$"COMMIT PREPARED '{gid}';");
863                          var commitPreparedMessage = await NextMessage<CommitPreparedMessage>(messages);
864                          Assert.That(commitPreparedMessage.TransactionXid, Is.EqualTo(transactionXid));
865                          Assert.That(commitPreparedMessage.TransactionGid, Is.EqualTo(gid));
866                      }
867                      else
868                      {
869                          await c.ExecuteNonQueryAsync(@$"ROLLBACK PREPARED '{gid}';");
870                          var rollbackPreparedMessage = await NextMessage<RollbackPreparedMessage>(messages);
871                          Assert.That(rollbackPreparedMessage.TransactionXid, Is.EqualTo(transactionXid));
872                          Assert.That(rollbackPreparedMessage.TransactionGid, Is.EqualTo(gid));
873                      }
874                      streamingCts.Cancel();
875                      await AssertReplicationCancellation(messages);
876                      await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
877                  }
878                  finally
879                  {
880                      try
881                      {
882                          await using var cx = await OpenConnectionAsync();
883                          await cx.ExecuteNonQueryAsync(@$"ROLLBACK PREPARED '{gid}';");
884                      }
885                      catch
886                      {
887                      }
888                  }
889              }, $"{GetObjectName(nameof(TwoPhase))}_{(commit ? "commit" : "rollback")}");
890      }
891      [Test(Description = "Tests whether columns of internally cached RelationMessage instances are accidentally overwritten.")]
892      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4633")]
893      public Task Bug4633()
894      {
895          if (IsStreaming || IsBinary || Version > 1)
896              return Task.CompletedTask;
897          return SafePgOutputReplicationTest(
898              async (slotName, tableNames, publicationName) =>
899              {
900                  await using var c = await OpenConnectionAsync();
901                  await c.ExecuteNonQueryAsync(@$"
902  CREATE TABLE {tableNames[0]}
903  (
904      id uuid NOT NULL,
905      text text NOT NULL,
906      created_at timestamp with time zone NOT NULL,
907      CONSTRAINT pk_{tableNames[0]} PRIMARY KEY (id)
908  );
909  CREATE TABLE {tableNames[1]}
910  (
911      id uuid NOT NULL,
912      message_id uuid NOT NULL,
913      created_at timestamp with time zone NOT NULL,
914      CONSTRAINT pk_{tableNames[1]} PRIMARY KEY (id),
915      CONSTRAINT fk_{tableNames[1]}_message_id FOREIGN KEY (message_id) REFERENCES {tableNames[0]} (id)
916  );
917  CREATE PUBLICATION {publicationName} FOR TABLE {tableNames[0]}, {tableNames[1]} WITH (PUBLISH = 'insert');");
918                  await using var rc = await OpenReplicationConnectionAsync();
919                  var slot = await rc.CreatePgOutputReplicationSlot(slotName);
920                  await using var tran = await c.BeginTransactionAsync();
921                  await c.ExecuteNonQueryAsync(@$"
922  INSERT INTO {tableNames[0]} VALUES ('B6CB5293-F65E-4F48-A74B-06D5355DAA74', 'random', now());
923  INSERT INTO {tableNames[1]} VALUES ('55870BEC-C42E-4AB0-83BA-225BB7777B37', 'B6CB5293-F65E-4F48-A74B-06D5355DAA74', now());
924  INSERT INTO {tableNames[0]} VALUES ('5F89F5FE-6F4F-465F-BB87-716B1413F88D', 'another random', now());");
925                  await tran.CommitAsync();
926                  using var streamingCts = new CancellationTokenSource();
927                  var messages = SkipEmptyTransactions(rc.StartReplication(slot, GetOptions(publicationName), streamingCts.Token))
928                      .GetAsyncEnumerator();
929                  var transactionXid = await AssertTransactionStart(messages);
930                  var relationMsg = await NextMessage<RelationMessage>(messages);
931                  var relation1Name = relationMsg.RelationName;
932                  var relation1Id = relationMsg.RelationId;
933                  Assert.That(relation1Name, Is.EqualTo(tableNames[0]));
934                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(3));
935                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
936                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("text"));
937                  Assert.That(relationMsg.Columns[2].ColumnName, Is.EqualTo("created_at"));
938                  var insertMsg = await NextMessage<InsertMessage>(messages);
939                  Assert.That(insertMsg.Relation.RelationName, Is.EqualTo(relation1Name));
940                  Assert.That(insertMsg.Relation.RelationId, Is.EqualTo(relation1Id));
941                  Assert.That(insertMsg.Relation.Columns.Count, Is.EqualTo(3));
942                  Assert.That(insertMsg.Relation.Columns[0].ColumnName, Is.EqualTo("id"));
943                  Assert.That(insertMsg.Relation.Columns[1].ColumnName, Is.EqualTo("text"));
944                  Assert.That(insertMsg.Relation.Columns[2].ColumnName, Is.EqualTo("created_at"));
945                  relationMsg = await NextMessage<RelationMessage>(messages);
946                  var relation2Name = relationMsg.RelationName;
947                  var relation2Id = relationMsg.RelationId;
948                  Assert.That(relation2Name, Is.EqualTo(tableNames[1]));
949                  Assert.That(relationMsg.Columns.Count, Is.EqualTo(3));
950                  Assert.That(relationMsg.Columns[0].ColumnName, Is.EqualTo("id"));
951                  Assert.That(relationMsg.Columns[1].ColumnName, Is.EqualTo("message_id"));
952                  Assert.That(relationMsg.Columns[2].ColumnName, Is.EqualTo("created_at"));
953                  insertMsg = await NextMessage<InsertMessage>(messages);
954                  Assert.That(insertMsg.Relation.RelationName, Is.EqualTo(relation2Name));
955                  Assert.That(insertMsg.Relation.RelationId, Is.EqualTo(relation2Id));
956                  Assert.That(insertMsg.Relation.Columns.Count, Is.EqualTo(3));
957                  Assert.That(insertMsg.Relation.Columns[0].ColumnName, Is.EqualTo("id"));
958                  Assert.That(insertMsg.Relation.Columns[1].ColumnName, Is.EqualTo("message_id"));
959                  Assert.That(insertMsg.Relation.Columns[2].ColumnName, Is.EqualTo("created_at"));
960                  insertMsg = await NextMessage<InsertMessage>(messages);
961                  Assert.That(insertMsg.Relation.RelationName, Is.EqualTo(relation1Name));
962                  Assert.That(insertMsg.Relation.RelationId, Is.EqualTo(relation1Id));
963                  Assert.That(insertMsg.Relation.Columns.Count, Is.EqualTo(3));
964                  Assert.That(insertMsg.Relation.Columns[0].ColumnName, Is.EqualTo("id"));
965                  Assert.That(insertMsg.Relation.Columns[1].ColumnName, Is.EqualTo("text"));
966                  Assert.That(insertMsg.Relation.Columns[2].ColumnName, Is.EqualTo("created_at"));
967                  await AssertTransactionCommit(messages);
968                  streamingCts.Cancel();
969                  await AssertReplicationCancellation(messages);
970                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
971              }, 2);
972      }
973      #region Non-Test stuff (helper methods, initialization, enums, ...)
974      async Task<uint?> AssertTransactionStart(IAsyncEnumerator<PgOutputReplicationMessage> messages)
975      {
976          Assert.True(await messages.MoveNextAsync());
977          switch (messages.Current)
978          {
979          case StreamStartMessage streamStartMessage:
980              Assert.That(IsStreaming);
981              return streamStartMessage.TransactionXid;
982          case BeginMessage beginMessage:
983              Assert.That(!IsStreaming);
984              return beginMessage.TransactionXid;
985          case BeginPrepareMessage beginPrepareMessage:
986              Assert.That(!IsStreaming);
987              return beginPrepareMessage.TransactionXid;
988          default:
989              Assert.Fail("Expected transaction start message but got: " + messages.Current);
990              throw new Exception();
991          }
992      }
993      async Task AssertTransactionCommit(IAsyncEnumerator<PgOutputReplicationMessage> messages)
994      {
995          Assert.True(await messages.MoveNextAsync());
996          switch (messages.Current)
997          {
998          case StreamStopMessage:
999              Assert.That(IsStreaming);
1000              Assert.True(await messages.MoveNextAsync());
1001              Assert.That(messages.Current, Is.TypeOf<StreamCommitMessage>());
1002              return;
1003          case CommitMessage:
1004              return;
1005          default:
1006              Assert.Fail("Expected transaction end message but got: " + messages.Current);
1007              throw new Exception();
1008          }
1009      }
1010      async Task<PrepareMessageBase> AssertPrepare(IAsyncEnumerator<PgOutputReplicationMessage> enumerator)
1011      {
1012          Assert.True(await enumerator.MoveNextAsync());
1013          if (IsStreaming && enumerator.Current is StreamStopMessage)
1014          {
1015              Assert.True(await enumerator.MoveNextAsync());
1016              Assert.That(enumerator.Current, Is.TypeOf<StreamPrepareMessage>());
1017              return (PrepareMessageBase)enumerator.Current!;
1018          }
1019          Assert.That(enumerator.Current, Is.TypeOf<PrepareMessage>());
1020          return (PrepareMessageBase)enumerator.Current!;
1021      }
1022      async ValueTask<TExpected> NextMessage<TExpected>(IAsyncEnumerator<PgOutputReplicationMessage> enumerator, bool expectRelationMessage = false)
1023          where TExpected : PgOutputReplicationMessage
1024      {
1025          Assert.True(await enumerator.MoveNextAsync());
1026          if (IsStreaming && enumerator.Current is StreamStopMessage)
1027          {
1028              Assert.True(await enumerator.MoveNextAsync());
1029              Assert.That(enumerator.Current, Is.TypeOf<StreamStartMessage>());
1030              Assert.True(await enumerator.MoveNextAsync());
1031              if (expectRelationMessage)
1032              {
1033                  Assert.That(enumerator.Current, Is.TypeOf<RelationMessage>());
1034                  Assert.True(await enumerator.MoveNextAsync());
1035              }
1036          }
1037          Assert.That(enumerator.Current, Is.TypeOf<TExpected>());
1038          return (TExpected)enumerator.Current!;
1039      }
1040      async IAsyncEnumerable<PgOutputReplicationMessage> SkipEmptyTransactions(IAsyncEnumerable<PgOutputReplicationMessage> messages)
1041      {
1042          var enumerator = messages.GetAsyncEnumerator();
1043          while (await enumerator.MoveNextAsync())
1044          {
1045              if (enumerator.Current is BeginMessage)
1046              {
1047                  var current = enumerator.Current;
1048                  if (!await enumerator.MoveNextAsync())
1049                  {
1050                      yield return current;
1051                      yield break;
1052                  }
1053                  var next = enumerator.Current;
1054                  if (next is CommitMessage)
1055                      continue;
1056                  yield return current;
1057                  yield return next;
1058                  continue;
1059              }
1060              yield return enumerator.Current;
1061          }
1062      }
1063      PgOutputReplicationOptions GetOptions(string publicationName, bool? messages = null)
1064          => new(publicationName, _protocolVersion, _binary, _streaming, messages);
1065      Task SafePgOutputReplicationTest(Func<string, string, string, Task> testAction, [CallerMemberName] string memberName = "")
1066          => SafeReplicationTest(testAction, GetObjectName(memberName));
1067      Task SafePgOutputReplicationTest(Func<string, string[], string, Task> testAction, int tableCount, [CallerMemberName] string memberName = "")
1068          => SafeReplicationTest(testAction, tableCount, GetObjectName(memberName));
1069      string GetObjectName(string memberName)
1070      {
1071          var sb = new StringBuilder(memberName)
1072              .Append("_v").Append(_protocolVersion);
1073          if (_binary.HasValue)
1074              sb.Append("_b_").Append(BoolToChar(_binary.Value));
1075          if (_streaming.HasValue)
1076              sb.Append("_s_").Append(BoolToChar(_streaming.Value));
1077          return sb.ToString();
1078      }
1079      static char BoolToChar(bool value)
1080          => value ? 't' : 'f';
1081      protected override string Postfix => "pgoutput_l";
1082      [OneTimeSetUp]
1083      public async Task SetUp()
1084      {
1085          await using var c = await OpenConnectionAsync();
1086          TestUtil.MinimumPgVersion(c, "10.0", "The Logical Replication Protocol (via pgoutput plugin) was introduced in PostgreSQL 10");
1087          if (_protocolVersion > 2)
1088              TestUtil.MinimumPgVersion(c, "15.0", "Logical Streaming Replication Protocol version 3 was introduced in PostgreSQL 15");
1089          if (_protocolVersion > 1)
1090              TestUtil.MinimumPgVersion(c, "14.0", "Logical Streaming Replication Protocol version 2 was introduced in PostgreSQL 14");
1091          if (IsBinary)
<span onclick='openModal()' class='match'>1092              TestUtil.MinimumPgVersion(c, "14.0", "Sending replication values in binary representation was introduced in PostgreSQL 14");
1093          if (IsStreaming)
1094          {
</span>1095              TestUtil.MinimumPgVersion(c, "14.0", "Streaming of in-progress transactions was introduced in PostgreSQL 14");
1096              var logicalDecodingWorkMem = (string)(await c.ExecuteScalarAsync("SHOW logical_decoding_work_mem"))!;
1097              if (logicalDecodingWorkMem != "64kB")
1098              {
1099                  TestUtil.IgnoreExceptOnBuildServer(
1100                      $"logical_decoding_work_mem is set to '{logicalDecodingWorkMem}', but must be set to '64kB' in order for the " +
1101                      "streaming replication tests to work correctly. Skipping replication tests");
1102              }
1103          }
1104      }
1105      public enum ProtocolVersion : ulong
1106      {
1107          V1 = 1UL,
1108          V2 = 2UL,
1109          V3 = 3UL,
1110      }
1111      public enum ReplicationDataMode
1112      {
1113          DefaultReplicationDataMode,
1114          TextReplicationDataMode,
1115          BinaryReplicationDataMode,
1116      }
1117      public enum TransactionMode
1118      {
1119          DefaultTransactionMode,
1120          NonStreamingTransactionMode,
1121          StreamingTransactionMode,
1122      }
1123      #endregion Non-Test stuff (helper methods, initialization, ennums, ...)
1124  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonLogicalReplicationTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PgOutputReplicationTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>116                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
117                  if (twoPhase)
118                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
</pre></code></div>
                <div class="column column_space"><pre><code>1092              TestUtil.MinimumPgVersion(c, "14.0", "Sending replication values in binary representation was introduced in PostgreSQL 14");
1093          if (IsStreaming)
1094          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    