
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.68284789644013%, Tokens: 11</h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DOTweenModuleUnityVersion.cs</h3>
            <pre><code>1  using System;
2  using UnityEngine;
3  using DG.Tweening.Core;
4  using DG.Tweening.Plugins.Options;
5  #pragma warning disable 1591
6  namespace DG.Tweening
7  {
8  	public static class DOTweenModuleUnityVersion
9      {
10  #if UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1_OR_NEWER
11          #region Unity 4.3 or Newer
12          #region Material
13          public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
14          {
15              Sequence s = DOTween.Sequence();
16              GradientColorKey[] colors = gradient.colorKeys;
17              int len = colors.Length;
18              for (int i = 0; i < len; ++i) {
19                  GradientColorKey c = colors[i];
20                  if (i == 0 && c.time <= 0) {
21                      target.color = c.color;
22                      continue;
23                  }
24                  float colorDuration = i == len - 1
25                      ? duration - s.Duration(false) 
26                      : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
27                  s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
28              }
29              s.SetTarget(target);
30              return s;
31          }
32          public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
33          {
34              Sequence s = DOTween.Sequence();
35              GradientColorKey[] colors = gradient.colorKeys;
36              int len = colors.Length;
37              for (int i = 0; i < len; ++i) {
38                  GradientColorKey c = colors[i];
39                  if (i == 0 && c.time <= 0) {
40                      target.SetColor(property, c.color);
41                      continue;
42                  }
43                  float colorDuration = i == len - 1
44                      ? duration - s.Duration(false) 
45                      : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
46                  s.Append(target.DOColor(c.color, property, colorDuration).SetEase(Ease.Linear));
47              }
48              s.SetTarget(target);
49              return s;
50          }
51          #endregion
52          #endregion
53  #endif
54  #if UNITY_5_3_OR_NEWER || UNITY_2017_1_OR_NEWER
55          #region Unity 5.3 or Newer
56          #region CustomYieldInstructions
57          public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
58          {
59              if (!t.active) {
60                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
61                  return null;
62              }
63              return new DOTweenCYInstruction.WaitForCompletion(t);
64          }
65          public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
66          {
67              if (!t.active) {
68                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
69                  return null;
70              }
71              return new DOTweenCYInstruction.WaitForRewind(t);
72          }
73          public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
74          {
75              if (!t.active) {
76                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
77                  return null;
78              }
79              return new DOTweenCYInstruction.WaitForKill(t);
<span onclick='openModal()' class='match'>80          }
81          public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
82          {
83              if (!t.active) {
84                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
85                  return null;
86              }
87              return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
</span>88          }
89          public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
90          {
91              if (!t.active) {
92                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
93                  return null;
94              }
95              return new DOTweenCYInstruction.WaitForPosition(t, position);
96          }
97          public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
98          {
99              if (!t.active) {
100                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
101                  return null;
102              }
103              return new DOTweenCYInstruction.WaitForStart(t);
104          }
105          #endregion
106          #endregion
107  #endif
108  #if UNITY_2018_1_OR_NEWER
109          #region Unity 2018.1 or Newer
110          #region Material
111          public static TweenerCore<Vector2, Vector2, VectorOptions> DOOffset(this Material target, Vector2 endValue, int propertyID, float duration)
112          {
113              if (!target.HasProperty(propertyID)) {
114                  if (Debugger.logPriority > 0) Debugger.LogMissingMaterialProperty(propertyID);
115                  return null;
116              }
117              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.GetTextureOffset(propertyID), x => target.SetTextureOffset(propertyID, x), endValue, duration);
118              t.SetTarget(target);
119              return t;
120          }
121          public static TweenerCore<Vector2, Vector2, VectorOptions> DOTiling(this Material target, Vector2 endValue, int propertyID, float duration)
122          {
123              if (!target.HasProperty(propertyID)) {
124                  if (Debugger.logPriority > 0) Debugger.LogMissingMaterialProperty(propertyID);
125                  return null;
126              }
127              TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.GetTextureScale(propertyID), x => target.SetTextureScale(propertyID, x), endValue, duration);
128              t.SetTarget(target);
129              return t;
130          }
131          #endregion
132          #region .NET 4.6 or Newer
133  #if UNITY_2018_1_OR_NEWER && (NET_4_6 || NET_STANDARD_2_0)
134          #region Async Instructions
135          public static async System.Threading.Tasks.Task AsyncWaitForCompletion(this Tween t)
136          {
137              if (!t.active) {
138                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
139                  return;
140              }
141              while (t.active && !t.IsComplete()) await System.Threading.Tasks.Task.Yield();
142          }
143          public static async System.Threading.Tasks.Task AsyncWaitForRewind(this Tween t)
144          {
145              if (!t.active) {
146                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
147                  return;
148              }
149              while (t.active && (!t.playedOnce || t.position * (t.CompletedLoops() + 1) > 0)) await System.Threading.Tasks.Task.Yield();
150          }
151          public static async System.Threading.Tasks.Task AsyncWaitForKill(this Tween t)
152          {
153              if (!t.active) {
154                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
155                  return;
156              }
157              while (t.active) await System.Threading.Tasks.Task.Yield();
158          }
159          public static async System.Threading.Tasks.Task AsyncWaitForElapsedLoops(this Tween t, int elapsedLoops)
160          {
161              if (!t.active) {
162                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
163                  return;
164              }
165              while (t.active && t.CompletedLoops() < elapsedLoops) await System.Threading.Tasks.Task.Yield();
166          }
167          public static async System.Threading.Tasks.Task AsyncWaitForPosition(this Tween t, float position)
168          {
169              if (!t.active) {
170                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
171                  return;
172              }
173              while (t.active && t.position * (t.CompletedLoops() + 1) < position) await System.Threading.Tasks.Task.Yield();
174          }
175          public static async System.Threading.Tasks.Task AsyncWaitForStart(this Tween t)
176          {
177              if (!t.active) {
178                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
179                  return;
180              }
181              while (t.active && !t.playedOnce) await System.Threading.Tasks.Task.Yield();
182          }
183          #endregion
184  #endif
185          #endregion
186          #endregion
187  #endif
188      }
189  #if UNITY_5_3_OR_NEWER || UNITY_2017_1_OR_NEWER
190      public static class DOTweenCYInstruction
191      {
192          public class WaitForCompletion : CustomYieldInstruction
193          {
194              public override bool keepWaiting { get {
195                  return t.active && !t.IsComplete();
196              }}
197              readonly Tween t;
198              public WaitForCompletion(Tween tween)
199              {
200                  t = tween;
201              }
202          }
203          public class WaitForRewind : CustomYieldInstruction
204          {
205              public override bool keepWaiting { get {
206                  return t.active && (!t.playedOnce || t.position * (t.CompletedLoops() + 1) > 0);
207              }}
208              readonly Tween t;
209              public WaitForRewind(Tween tween)
210              {
211                  t = tween;
212              }
213          }
214          public class WaitForKill : CustomYieldInstruction
215          {
216              public override bool keepWaiting { get {
217                  return t.active;
218              }}
219              readonly Tween t;
220              public WaitForKill(Tween tween)
221              {
222                  t = tween;
223              }
224          }
225          public class WaitForElapsedLoops : CustomYieldInstruction
226          {
227              public override bool keepWaiting { get {
228                  return t.active && t.CompletedLoops() < elapsedLoops;
229              }}
230              readonly Tween t;
231              readonly int elapsedLoops;
232              public WaitForElapsedLoops(Tween tween, int elapsedLoops)
233              {
234                  t = tween;
235                  this.elapsedLoops = elapsedLoops;
236              }
237          }
238          public class WaitForPosition : CustomYieldInstruction
239          {
240              public override bool keepWaiting { get {
241                  return t.active && t.position * (t.CompletedLoops() + 1) < position;
242              }}
243              readonly Tween t;
244              readonly float position;
245              public WaitForPosition(Tween tween, float position)
246              {
247                  t = tween;
248                  this.position = position;
249              }
250          }
251          public class WaitForStart : CustomYieldInstruction
252          {
253              public override bool keepWaiting { get {
254                  return t.active && !t.playedOnce;
255              }}
256              readonly Tween t;
257              public WaitForStart(Tween tween)
258              {
259                  t = tween;
260              }
261          }
262      }
263  #endif
264  }
</code></pre>
        </div>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-TweenExtensions.cs</h3>
            <pre><code>1  using DG.Tweening.Core;
2  using DG.Tweening.Core.Easing;
3  using DG.Tweening.Core.Enums;
4  using DG.Tweening.Plugins.Core.PathCore;
5  using DG.Tweening.Plugins.Options;
6  using UnityEngine;
7  #pragma warning disable 1573
8  namespace DG.Tweening
9  {
10      public static class TweenExtensions
11      {
12          #region Runtime Operations
13          public static void Complete(this Tween t)
14          { Complete(t, false); }
15          public static void Complete(this Tween t, bool withCallbacks)
16          {
17              if (t == null) {
18                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
19              } else if (!t.active) {
20                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
21              } else if (t.isSequenced) {
22                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
23              }
24              TweenManager.Complete(t, true, withCallbacks ? UpdateMode.Update : UpdateMode.Goto);
25          }
26          public static void Flip(this Tween t)
27          {
28              if (t == null) {
29                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
30              } else if (!t.active) {
31                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
32              } else if (t.isSequenced) {
33                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
34              }
35              TweenManager.Flip(t);
36          }
37          public static void ForceInit(this Tween t)
38          {
39              if (t == null) {
40                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
41              } else if (!t.active) {
42                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
43              } else if (t.isSequenced) {
44                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
45              }
46              TweenManager.ForceInit(t);
47          }
48          public static void Goto(this Tween t, float to, bool andPlay = false)
49          { DoGoto(t, to, andPlay, false); }
50          public static void GotoWithCallbacks(this Tween t, float to, bool andPlay = false)
51          { DoGoto(t, to, andPlay, true); }
52          static void DoGoto(Tween t, float to, bool andPlay, bool withCallbacks)
53          {
54              if (t == null) {
55                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
56              } else if (!t.active) {
57                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
58              } else if (t.isSequenced) {
59                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
60              }
61              if (to < 0) to = 0;
62              if (!t.startupDone) TweenManager.ForceInit(t); 
63              TweenManager.Goto(t, to, andPlay, withCallbacks ? UpdateMode.Update : UpdateMode.Goto);
64          }
65          public static void Kill(this Tween t, bool complete = false)
66          {
67              if (!DOTween.initialized) return;
68              if (t == null || !t.active) {
69                  return;
70              } else if (t.isSequenced) {
71                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
72              }
73              if (complete) {
74                  TweenManager.Complete(t);
75                  if (t.autoKill && t.loops >= 0) return; 
76              }
77              if (TweenManager.isUpdateLoop) {
78                  t.active = false;
79              } else TweenManager.Despawn(t);
80          }
81          public static void ManualUpdate(this Tween t, float deltaTime, float unscaledDeltaTime)
82          {
83              if (t == null) {
84                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
85              } else if (!t.active) {
86                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
87              } else if (t.isSequenced) {
88                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
89              }
90              TweenManager.Update(t, deltaTime, unscaledDeltaTime, true);
91          }
92          public static T Pause<T>(this T t) where T : Tween
93          {
94              if (t == null) {
95                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return t;
96              } else if (!t.active) {
97                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return t;
98              } else if (t.isSequenced) {
99                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return t;
100              }
101              TweenManager.Pause(t);
102              return t;
103          }
104          public static T Play<T>(this T t) where T : Tween
105          {
106              if (t == null) {
107                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return t;
108              } else if (!t.active) {
109                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return t;
110              } else if (t.isSequenced) {
111                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return t;
112              }
113              TweenManager.Play(t);
114              return t;
115          }
116          public static void PlayBackwards(this Tween t)
117          {
118              if (t == null) {
119                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
120              } else if (!t.active) {
121                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
122              } else if (t.isSequenced) {
123                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
124              }
125              TweenManager.PlayBackwards(t);
126          }
127          public static void PlayForward(this Tween t)
128          {
129              if (t == null) {
130                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
131              } else if (!t.active) {
132                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
133              } else if (t.isSequenced) {
134                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
135              }
136              TweenManager.PlayForward(t);
137          }
138          public static void Restart(this Tween t, bool includeDelay = true, float changeDelayTo = -1)
139          {
140              if (t == null) {
141                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
142              } else if (!t.active) {
143                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
144              } else if (t.isSequenced) {
145                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
146              }
147              TweenManager.Restart(t, includeDelay, changeDelayTo);
148          }
149          public static void Rewind(this Tween t, bool includeDelay = true)
150          {
151              if (t == null) {
152                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
153              } else if (!t.active) {
154                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
155              } else if (t.isSequenced) {
156                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
157              }
158              TweenManager.Rewind(t, includeDelay);
159          }
160          public static void SmoothRewind(this Tween t)
161          {
162              if (t == null) {
163                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
164              } else if (!t.active) {
165                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
166              } else if (t.isSequenced) {
167                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
168              }
169              TweenManager.SmoothRewind(t);
170          }
171          public static void TogglePause(this Tween t)
172          {
173              if (t == null) {
174                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
175              } else if (!t.active) {
176                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
177              } else if (t.isSequenced) {
178                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
179              }
180              TweenManager.TogglePause(t);
181          }
182          #region Path Tweens
183          public static void GotoWaypoint(this Tween t, int waypointIndex, bool andPlay = false)
184          {
185              if (t == null) {
186                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return;
187              } else if (!t.active) {
188                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return;
189              } else if (t.isSequenced) {
190                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return;
191              }
192              TweenerCore<Vector3, Path, PathOptions> pathTween = t as TweenerCore<Vector3, Path, PathOptions>;
193              if (pathTween == null) {
194                  if (Debugger.logPriority > 1) Debugger.LogNonPathTween(t); return;
195              }
196              if (!t.startupDone) TweenManager.ForceInit(t); 
197              if (waypointIndex < 0) waypointIndex = 0;
198              else if (waypointIndex > pathTween.changeValue.wps.Length - 1) waypointIndex = pathTween.changeValue.wps.Length - 1;
199              float wpLength = 0; 
200              for (int i = 0; i < waypointIndex + 1; i++) wpLength += pathTween.changeValue.wpLengths[i];
201              float wpPerc = wpLength / pathTween.changeValue.length;
202              bool useInversePosition = t.hasLoops && t.loopType == LoopType.Yoyo
203                  && (t.position < t.duration ? t.completedLoops % 2 != 0 : t.completedLoops % 2 == 0);
204              if (useInversePosition) wpPerc = 1 - wpPerc;
205              float to = (t.isComplete ? t.completedLoops - 1 : t.completedLoops) * t.duration + wpPerc * t.duration;
206              TweenManager.Goto(t, to, andPlay);
207          }
208          #endregion
209          #endregion
210          #region Yield Coroutines
211          public static YieldInstruction WaitForCompletion(this Tween t)
212          {
213              if (!t.active) {
214                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
215                  return null;
216              }
217              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForCompletion(t));
218          }
219          public static YieldInstruction WaitForRewind(this Tween t)
220          {
221              if (!t.active) {
222                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
223                  return null;
224              }
225              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForRewind(t));
<span onclick='openModal()' class='match'>226          }
227          public static YieldInstruction WaitForKill(this Tween t)
228          {
229              if (!t.active) {
230                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
231                  return null;
232              }
233              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForKill(t));
</span>234          }
235          public static YieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops)
236          {
237              if (!t.active) {
238                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
239                  return null;
240              }
241              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForElapsedLoops(t, elapsedLoops));
242          }
243          public static YieldInstruction WaitForPosition(this Tween t, float position)
244          {
245              if (!t.active) {
246                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
247                  return null;
248              }
249              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForPosition(t, position));
250          }
251          public static Coroutine WaitForStart(this Tween t)
252          {
253              if (!t.active) {
254                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
255                  return null;
256              }
257              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForStart(t));
258          }
259          #endregion
260          #region Info Getters
261          public static int CompletedLoops(this Tween t)
262          {
263              if (!t.active) {
264                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
265                  return 0;
266              }
267              return t.completedLoops;
268          }
269          public static float Delay(this Tween t)
270          {
271              if (!t.active) {
272                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
273                  return 0;
274              }
275              return t.delay;
276          }
277          public static float ElapsedDelay(this Tween t)
278          {
279              if (!t.active) {
280                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
281                  return 0;
282              }
283              return t.elapsedDelay;
284          }
285          public static float Duration(this Tween t, bool includeLoops = true)
286          {
287              if (!t.active) {
288                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
289                  return 0;
290              }
291              if (includeLoops) return t.loops == -1 ? Mathf.Infinity : t.duration * t.loops;
292              return t.duration;
293          }
294          public static float Elapsed(this Tween t, bool includeLoops = true)
295          {
296              if (!t.active) {
297                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
298                  return 0;
299              }
300              if (includeLoops) {
301                  int loopsToCount = t.position >= t.duration ? t.completedLoops - 1 : t.completedLoops;
302                  return (loopsToCount * t.duration) + t.position;
303              }
304              return t.position;
305          }
306          public static float ElapsedPercentage(this Tween t, bool includeLoops = true)
307          {
308              if (!t.active) {
309                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
310                  return 0;
311              }
312              if (includeLoops) {
313                  if (t.fullDuration <= 0) return 0;
314                  int loopsToCount = t.position >= t.duration ? t.completedLoops - 1 : t.completedLoops;
315                  return ((loopsToCount * t.duration) + t.position) / t.fullDuration;
316              }
317              return t.position / t.duration;
318          }
319          public static float ElapsedDirectionalPercentage(this Tween t)
320          {
321              if (!t.active) {
322                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
323                  return 0;
324              }
325              float perc = t.position / t.duration;
326              bool isInverse = t.completedLoops > 0 && t.hasLoops && t.loopType == LoopType.Yoyo
327                               && (!t.isComplete && t.completedLoops % 2 != 0 || t.isComplete && t.completedLoops % 2 == 0);
328              return isInverse ? 1 - perc : perc;
329          }
330          public static bool IsActive(this Tween t)
331          {
332              return t != null && t.active;
333          }
334          public static bool IsBackwards(this Tween t)
335          {
336              if (!t.active) {
337                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
338                  return false;
339              }
340              return t.isBackwards;
341          }
342          public static bool IsLoopingOrExecutingBackwards(this Tween t)
343          {
344              if (!t.active) {
345                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
346                  return false;
347              }
348              if (t.isBackwards) {
349                  return t.completedLoops < 1 || t.loopType != LoopType.Yoyo || t.completedLoops % 2 == 0;
350              } else {
351                  return t.completedLoops >= 1 && t.loopType == LoopType.Yoyo && t.completedLoops % 2 != 0;
352              }
353          }
354          public static bool IsComplete(this Tween t)
355          {
356              if (!t.active) {
357                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
358                  return false;
359              }
360              return t.isComplete;
361          }
362          public static bool IsInitialized(this Tween t)
363          {
364              if (!t.active) {
365                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
366                  return false;
367              }
368              return t.startupDone;
369          }
370          public static bool IsPlaying(this Tween t)
371          {
372              if (!t.active) {
373                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
374                  return false;
375              }
376              return t.isPlaying;
377          }
378          public static int Loops(this Tween t)
379          {
380              if (!t.active) {
381                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
382                  return 0;
383              }
384              return t.loops;
385          }
386          #region Path Tweens
387          public static Vector3 PathGetPoint(this Tween t, float pathPercentage)
388          {
389              if (pathPercentage > 1) pathPercentage = 1;
390              else if (pathPercentage < 0) pathPercentage = 0;
391              if (t == null) {
392                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return Vector3.zero;
393              } else if (!t.active) {
394                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return Vector3.zero;
395              } else if (t.isSequenced) {
396                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return Vector3.zero;
397              }
398              TweenerCore<Vector3, Path, PathOptions> pathTween = t as TweenerCore<Vector3, Path, PathOptions>;
399              if (pathTween == null) {
400                  if (Debugger.logPriority > 1) Debugger.LogNonPathTween(t); return Vector3.zero;
401              } else if (!pathTween.endValue.isFinalized) {
402                  if (Debugger.logPriority > 1) Debugger.LogWarning("The path is not finalized yet", t); return Vector3.zero;
403              }
404              return pathTween.endValue.GetPoint(pathPercentage, true);
405          }
406          public static Vector3[] PathGetDrawPoints(this Tween t, int subdivisionsXSegment = 10)
407          {
408              if (t == null) {
409                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return null;
410              } else if (!t.active) {
411                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return null;
412              } else if (t.isSequenced) {
413                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return null;
414              }
415              TweenerCore<Vector3, Path, PathOptions> pathTween = t as TweenerCore<Vector3, Path, PathOptions>;
416              if (pathTween == null) {
417                  if (Debugger.logPriority > 1) Debugger.LogNonPathTween(t); return null;
418              } else if (!pathTween.endValue.isFinalized) {
419                  if (Debugger.logPriority > 1) Debugger.LogWarning("The path is not finalized yet", t); return null;
420              }
421              return Path.GetDrawPoints(pathTween.endValue, subdivisionsXSegment);
422          }
423          public static float PathLength(this Tween t)
424          {
425              if (t == null) {
426                  if (Debugger.logPriority > 1) Debugger.LogNullTween(t); return -1;
427              } else if (!t.active) {
428                  if (Debugger.logPriority > 1) Debugger.LogInvalidTween(t); return -1;
429              } else if (t.isSequenced) {
430                  if (Debugger.logPriority > 1) Debugger.LogNestedTween(t); return -1;
431              }
432              TweenerCore<Vector3, Path, PathOptions> pathTween = t as TweenerCore<Vector3, Path, PathOptions>;
433              if (pathTween == null) {
434                  if (Debugger.logPriority > 1) Debugger.LogNonPathTween(t); return -1;
435              } else if (!pathTween.endValue.isFinalized) {
436                  if (Debugger.logPriority > 1) Debugger.LogWarning("The path is not finalized yet", t); return -1;
437              }
438              return pathTween.endValue.length;
439          }
440          #endregion
441          #endregion
442      }
443  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-DOTweenModuleUnityVersion.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-TweenExtensions.cs</div>
                <div class="column column_space"><pre><code>80          }
81          public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
82          {
83              if (!t.active) {
84                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
85                  return null;
86              }
87              return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
</pre></code></div>
                <div class="column column_space"><pre><code>226          }
227          public static YieldInstruction WaitForKill(this Tween t)
228          {
229              if (!t.active) {
230                  if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
231                  return null;
232              }
233              return DOTween.instance.StartCoroutine(DOTween.instance.WaitForKill(t));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    