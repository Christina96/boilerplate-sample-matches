
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 1759, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WssClient.cs</h3>
            <pre><code>1  using System;
2  using System.Net;
3  using System.Net.Sockets;
4  using System.Text;
5  namespace NetCoreServer
6  {
7      public class WssClient : HttpsClient, IWebSocket
8      {
9          internal readonly WebSocket WebSocket;
10          public WssClient(SslContext context, IPAddress address, int port) : base(context, address, port) { WebSocket = new WebSocket(this); }
11          public WssClient(SslContext context, string address, int port) : base(context, address, port) { WebSocket = new WebSocket(this); }
12          public WssClient(SslContext context, DnsEndPoint endpoint) : base(context, endpoint) { WebSocket = new WebSocket(this); }
13          public WssClient(SslContext context, IPEndPoint endpoint) : base(context, endpoint) { WebSocket = new WebSocket(this); }
14          public byte[] WsNonce => WebSocket.WsNonce;
15          #region WebSocket connection methods
<span onclick='openModal()' class='match'>16          public override bool Connect() { _syncConnect = true; return base.Connect(); }
17          public override bool ConnectAsync() { _syncConnect = false; return base.ConnectAsync(); }
18          public virtual bool Close(int status) { SendClose(status, Span<byte>.Empty); base.Disconnect(); return true; }
19          public virtual bool CloseAsync(int status) { SendCloseAsync(status, Span<byte>.Empty); base.DisconnectAsync(); return true; }
20          #endregion
21          #region WebSocket send text methods
22          public long SendText(string text) => SendText(Encoding.UTF8.GetBytes(text));
23          public long SendText(ReadOnlySpan<char> text) => SendText(Encoding.UTF8.GetBytes(text.ToArray()));
24          public long SendText(byte[] buffer) => SendText(buffer.AsSpan());
25          public long SendText(byte[] buffer, long offset, long size) => SendText(buffer.AsSpan((int)offset, (int)size));
26          public long SendText(ReadOnlySpan<byte> buffer)
27          {
28              lock (WebSocket.WsSendLock)
29              {
30                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
31                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
32              }
33          }
34          public bool SendTextAsync(string text) => SendTextAsync(Encoding.UTF8.GetBytes(text));
35          public bool SendTextAsync(ReadOnlySpan<char> text) => SendTextAsync(Encoding.UTF8.GetBytes(text.ToArray()));
36          public bool SendTextAsync(byte[] buffer) => SendTextAsync(buffer.AsSpan());
37          public bool SendTextAsync(byte[] buffer, long offset, long size) => SendTextAsync(buffer.AsSpan((int)offset, (int)size));
38          public bool SendTextAsync(ReadOnlySpan<byte> buffer)
39          {
40              lock (WebSocket.WsSendLock)
41              {
42                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
43                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
44              }
45          }
46          #endregion
47          #region WebSocket send binary methods
48          public long SendBinary(string text) => SendBinary(Encoding.UTF8.GetBytes(text));
49          public long SendBinary(ReadOnlySpan<char> text) => SendBinary(Encoding.UTF8.GetBytes(text.ToArray()));
50          public long SendBinary(byte[] buffer) => SendBinary(buffer.AsSpan());
51          public long SendBinary(byte[] buffer, long offset, long size) => SendBinary(buffer.AsSpan((int)offset, (int)size));
52          public long SendBinary(ReadOnlySpan<byte> buffer)
53          {
54              lock (WebSocket.WsSendLock)
55              {
56                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
57                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
58              }
59          }
60          public bool SendBinaryAsync(string text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text));
61          public bool SendBinaryAsync(ReadOnlySpan<char> text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text.ToArray()));
62          public bool SendBinaryAsync(byte[] buffer) => SendBinaryAsync(buffer.AsSpan());
63          public bool SendBinaryAsync(byte[] buffer, long offset, long size) => SendBinaryAsync(buffer.AsSpan((int)offset, (int)size));
64          public bool SendBinaryAsync(ReadOnlySpan<byte> buffer)
65          {
66              lock (WebSocket.WsSendLock)
67              {
68                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
69                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
70              }
71          }
72          #endregion
73          #region WebSocket send close methods
74          public long SendClose(int status, string text) => SendClose(status, Encoding.UTF8.GetBytes(text));
75          public long SendClose(int status, ReadOnlySpan<char> text) => SendClose(status, Encoding.UTF8.GetBytes(text.ToArray()));
76          public long SendClose(int status, byte[] buffer) => SendClose(status, buffer.AsSpan());
77          public long SendClose(int status, byte[] buffer, long offset, long size) => SendClose(status, buffer.AsSpan((int)offset, (int)size));
78          public long SendClose(int status, ReadOnlySpan<byte> buffer)
79          {
80              lock (WebSocket.WsSendLock)
81              {
82                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
83                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
84              }
85          }
86          public bool SendCloseAsync(int status, string text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text));
87          public bool SendCloseAsync(int status, ReadOnlySpan<char> text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text.ToArray()));
88          public bool SendCloseAsync(int status, byte[] buffer) => SendCloseAsync(status, buffer.AsSpan());
89          public bool SendCloseAsync(int status, byte[] buffer, long offset, long size) => SendCloseAsync(status, buffer.AsSpan((int)offset, (int)size));
90          public bool SendCloseAsync(int status, ReadOnlySpan<byte> buffer)
91          {
92              lock (WebSocket.WsSendLock)
93              {
94                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
95                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
96              }
97          }
98          #endregion
99          #region WebSocket send ping methods
100          public long SendPing(string text) => SendPing(Encoding.UTF8.GetBytes(text));
101          public long SendPing(ReadOnlySpan<char> text) => SendPing(Encoding.UTF8.GetBytes(text.ToArray()));
102          public long SendPing(byte[] buffer) => SendPing(buffer.AsSpan());
103          public long SendPing(byte[] buffer, long offset, long size) => SendPing(buffer.AsSpan((int)offset, (int)size));
104          public long SendPing(ReadOnlySpan<byte> buffer)
105          {
106              lock (WebSocket.WsSendLock)
107              {
108                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
109                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
110              }
111          }
112          public bool SendPingAsync(string text) => SendPingAsync(Encoding.UTF8.GetBytes(text));
113          public bool SendPingAsync(ReadOnlySpan<char> text) => SendPingAsync(Encoding.UTF8.GetBytes(text.ToArray()));
114          public bool SendPingAsync(byte[] buffer) => SendPingAsync(buffer.AsSpan());
115          public bool SendPingAsync(byte[] buffer, long offset, long size) => SendPingAsync(buffer.AsSpan((int)offset, (int)size));
116          public bool SendPingAsync(ReadOnlySpan<byte> buffer)
117          {
118              lock (WebSocket.WsSendLock)
119              {
120                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
121                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
122              }
123          }
124          #endregion
125          #region WebSocket send pong methods
126          public long SendPong(string text) => SendPong(Encoding.UTF8.GetBytes(text));
127          public long SendPong(ReadOnlySpan<char> text) => SendPong(Encoding.UTF8.GetBytes(text.ToArray()));
128          public long SendPong(byte[] buffer) => SendPong(buffer.AsSpan());
129          public long SendPong(byte[] buffer, long offset, long size) => SendPong(buffer.AsSpan((int)offset, (int)size));
130          public long SendPong(ReadOnlySpan<byte> buffer)
131          {
132              lock (WebSocket.WsSendLock)
133              {
134                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
135                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
136              }
137          }
138          public bool SendPongAsync(string text) => SendPongAsync(Encoding.UTF8.GetBytes(text));
139          public bool SendPongAsync(ReadOnlySpan<char> text) => SendPongAsync(Encoding.UTF8.GetBytes(text.ToArray()));
140          public bool SendPongAsync(byte[] buffer) => SendPongAsync(buffer.AsSpan());
141          public bool SendPongAsync(byte[] buffer, long offset, long size) => SendPongAsync(buffer.AsSpan((int)offset, (int)size));
142          public bool SendPongAsync(ReadOnlySpan<byte> buffer)
143          {
144              lock (WebSocket.WsSendLock)
145              {
146                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
147                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
148              }
149          }
150          #endregion
151          #region WebSocket receive methods
152          public string ReceiveText()
153          {
154              var result = new Buffer();
155              if (!WebSocket.WsHandshaked)
156                  return result.ExtractString(0, result.Data.Length);
157              var cache = new Buffer();
158              while (!WebSocket.WsFinalReceived)
159              {
160                  while (!WebSocket.WsFrameReceived)
161                  {
162                      long required = WebSocket.RequiredReceiveFrameSize();
163                      cache.Resize(required);
164                      long received = (int)base.Receive(cache.Data, 0, required);
</span>165                      if (received != required)
166                          return result.ExtractString(0, result.Data.Length);
167                      WebSocket.PrepareReceiveFrame(cache.Data, 0, received);
168                  }
169                  if (!WebSocket.WsFinalReceived)
170                      WebSocket.PrepareReceiveFrame(null, 0, 0);
171              }
172              result.Append(WebSocket.WsReceiveFinalBuffer);
173              WebSocket.PrepareReceiveFrame(null, 0, 0);
174              return result.ExtractString(0, result.Data.Length);
175          }
176          public Buffer ReceiveBinary()
177          {
178              var result = new Buffer();
179              if (!WebSocket.WsHandshaked)
180                  return result;
181              var cache = new Buffer();
182              while (!WebSocket.WsFinalReceived)
183              {
184                  while (!WebSocket.WsFrameReceived)
185                  {
186                      long required = WebSocket.RequiredReceiveFrameSize();
187                      cache.Resize(required);
188                      long received = (int)base.Receive(cache.Data, 0, required);
189                      if (received != required)
190                          return result;
191                      WebSocket.PrepareReceiveFrame(cache.Data, 0, received);
192                  }
193                  if (!WebSocket.WsFinalReceived)
194                      WebSocket.PrepareReceiveFrame(null, 0, 0);
195              }
196              result.Append(WebSocket.WsReceiveFinalBuffer);
197              WebSocket.PrepareReceiveFrame(null, 0, 0);
198              return result;
199          }
200          #endregion
201          #region Session handlers
202          protected override void OnHandshaked()
203          {
204              WebSocket.ClearWsBuffers();
205              OnWsConnecting(Request);
206              if (_syncConnect)
207                  SendRequest(Request);
208              else
209                  SendRequestAsync(Request);
210          }
211          protected override void OnDisconnecting()
212          {
213              if (WebSocket.WsHandshaked)
214                  OnWsDisconnecting();
215          }
216          protected override void OnDisconnected()
217          {
218              if (WebSocket.WsHandshaked)
219              {
220                  WebSocket.WsHandshaked = false;
221                  OnWsDisconnected();
222              }
223              Request.Clear();
224              Response.Clear();
225              WebSocket.ClearWsBuffers();
226              WebSocket.InitWsNonce();
227          }
228          protected override void OnReceived(byte[] buffer, long offset, long size)
229          {
230              if (WebSocket.WsHandshaked)
231              {
232                  WebSocket.PrepareReceiveFrame(buffer, offset, size);
233                  return;
234              }
235              base.OnReceived(buffer, offset, size);
236          }
237          protected override void OnReceivedResponseHeader(HttpResponse response)
238          {
239              if (WebSocket.WsHandshaked)
240                  return;
241              if (!WebSocket.PerformClientUpgrade(response, Id))
242              {
243                  base.OnReceivedResponseHeader(response);
244                  return;
245              }
246          }
247          protected override void OnReceivedResponse(HttpResponse response)
248          {
249              if (WebSocket.WsHandshaked)
250              {
251                  var body = Response.Body;
252                  var data = Encoding.UTF8.GetBytes(body);
253                  WebSocket.PrepareReceiveFrame(data, 0, data.Length);
254                  return;
255              }
256              base.OnReceivedResponse(response);
257          }
258          protected override void OnReceivedResponseError(HttpResponse response, string error)
259          {
260              if (WebSocket.WsHandshaked)
261              {
262                  OnError(new SocketError());
263                  return;
264              }
265              base.OnReceivedResponseError(response, error);
266          }
267          #endregion
268          #region Web socket handlers
269          public virtual void OnWsConnecting(HttpRequest request) {}
270          public virtual void OnWsConnected(HttpResponse response) {}
271          public virtual bool OnWsConnecting(HttpRequest request, HttpResponse response) { return true; }
272          public virtual void OnWsConnected(HttpRequest request) {}
273          public virtual void OnWsDisconnecting() {}
274          public virtual void OnWsDisconnected() {}
275          public virtual void OnWsReceived(byte[] buffer, long offset, long size) {}
276          public virtual void OnWsClose(byte[] buffer, long offset, long size, int status = 1000) { CloseAsync(status); }
277          public virtual void OnWsPing(byte[] buffer, long offset, long size) { SendPongAsync(buffer, offset, size); }
278          public virtual void OnWsPong(byte[] buffer, long offset, long size) {}
279          public virtual void OnWsError(string error) { OnError(SocketError.SocketError); }
280          public virtual void OnWsError(SocketError error) { OnError(error); }
281          #endregion
282          private bool _syncConnect;
283      }
284  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WsClient.cs</h3>
            <pre><code>1  using System;
2  using System.Net;
3  using System.Net.Sockets;
4  using System.Text;
5  namespace NetCoreServer
6  {
7      public class WsClient : HttpClient, IWebSocket
8      {
9          internal readonly WebSocket WebSocket;
10          public WsClient(IPAddress address, int port) : base(address, port) { WebSocket = new WebSocket(this); }
11          public WsClient(string address, int port) : base(address, port) { WebSocket = new WebSocket(this); }
12          public WsClient(DnsEndPoint endpoint) : base(endpoint) { WebSocket = new WebSocket(this); }
13          public WsClient(IPEndPoint endpoint) : base(endpoint) { WebSocket = new WebSocket(this); }
14          public byte[] WsNonce => WebSocket.WsNonce;
15          #region WebSocket connection methods
<span onclick='openModal()' class='match'>16          public override bool Connect() { _syncConnect = true; return base.Connect(); }
17          public override bool ConnectAsync() { _syncConnect = false; return base.ConnectAsync(); }
18          public virtual bool Close(int status) { SendClose(status, Span<byte>.Empty); base.Disconnect(); return true; }
19          public virtual bool CloseAsync(int status) { SendCloseAsync(status, Span<byte>.Empty); base.DisconnectAsync(); return true; }
20          #endregion
21          #region WebSocket send text methods
22          public long SendText(string text) => SendText(Encoding.UTF8.GetBytes(text));
23          public long SendText(ReadOnlySpan<char> text) => SendText(Encoding.UTF8.GetBytes(text.ToArray()));
24          public long SendText(byte[] buffer) => SendText(buffer.AsSpan());
25          public long SendText(byte[] buffer, long offset, long size) => SendText(buffer.AsSpan((int)offset, (int)size));
26          public long SendText(ReadOnlySpan<byte> buffer)
27          {
28              lock (WebSocket.WsSendLock)
29              {
30                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
31                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
32              }
33          }
34          public bool SendTextAsync(string text) => SendTextAsync(Encoding.UTF8.GetBytes(text));
35          public bool SendTextAsync(ReadOnlySpan<char> text) => SendTextAsync(Encoding.UTF8.GetBytes(text.ToArray()));
36          public bool SendTextAsync(byte[] buffer) => SendTextAsync(buffer.AsSpan());
37          public bool SendTextAsync(byte[] buffer, long offset, long size) => SendTextAsync(buffer.AsSpan((int)offset, (int)size));
38          public bool SendTextAsync(ReadOnlySpan<byte> buffer)
39          {
40              lock (WebSocket.WsSendLock)
41              {
42                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
43                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
44              }
45          }
46          #endregion
47          #region WebSocket send binary methods
48          public long SendBinary(string text) => SendBinary(Encoding.UTF8.GetBytes(text));
49          public long SendBinary(ReadOnlySpan<char> text) => SendBinary(Encoding.UTF8.GetBytes(text.ToArray()));
50          public long SendBinary(byte[] buffer) => SendBinary(buffer.AsSpan());
51          public long SendBinary(byte[] buffer, long offset, long size) => SendBinary(buffer.AsSpan((int)offset, (int)size));
52          public long SendBinary(ReadOnlySpan<byte> buffer)
53          {
54              lock (WebSocket.WsSendLock)
55              {
56                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
57                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
58              }
59          }
60          public bool SendBinaryAsync(string text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text));
61          public bool SendBinaryAsync(ReadOnlySpan<char> text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text.ToArray()));
62          public bool SendBinaryAsync(byte[] buffer) => SendBinaryAsync(buffer.AsSpan());
63          public bool SendBinaryAsync(byte[] buffer, long offset, long size) => SendBinaryAsync(buffer.AsSpan((int)offset, (int)size));
64          public bool SendBinaryAsync(ReadOnlySpan<byte> buffer)
65          {
66              lock (WebSocket.WsSendLock)
67              {
68                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
69                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
70              }
71          }
72          #endregion
73          #region WebSocket send close methods
74          public long SendClose(int status, string text) => SendClose(status, Encoding.UTF8.GetBytes(text));
75          public long SendClose(int status, ReadOnlySpan<char> text) => SendClose(status, Encoding.UTF8.GetBytes(text.ToArray()));
76          public long SendClose(int status, byte[] buffer) => SendClose(status, buffer.AsSpan());
77          public long SendClose(int status, byte[] buffer, long offset, long size) => SendClose(status, buffer.AsSpan((int)offset, (int)size));
78          public long SendClose(int status, ReadOnlySpan<byte> buffer)
79          {
80              lock (WebSocket.WsSendLock)
81              {
82                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
83                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
84              }
85          }
86          public bool SendCloseAsync(int status, string text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text));
87          public bool SendCloseAsync(int status, ReadOnlySpan<char> text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text.ToArray()));
88          public bool SendCloseAsync(int status, byte[] buffer) => SendCloseAsync(status, buffer.AsSpan());
89          public bool SendCloseAsync(int status, byte[] buffer, long offset, long size) => SendCloseAsync(status, buffer.AsSpan((int)offset, (int)size));
90          public bool SendCloseAsync(int status, ReadOnlySpan<byte> buffer)
91          {
92              lock (WebSocket.WsSendLock)
93              {
94                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
95                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
96              }
97          }
98          #endregion
99          #region WebSocket send ping methods
100          public long SendPing(string text) => SendPing(Encoding.UTF8.GetBytes(text));
101          public long SendPing(ReadOnlySpan<char> text) => SendPing(Encoding.UTF8.GetBytes(text.ToArray()));
102          public long SendPing(byte[] buffer) => SendPing(buffer.AsSpan());
103          public long SendPing(byte[] buffer, long offset, long size) => SendPing(buffer.AsSpan((int)offset, (int)size));
104          public long SendPing(ReadOnlySpan<byte> buffer)
105          {
106              lock (WebSocket.WsSendLock)
107              {
108                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
109                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
110              }
111          }
112          public bool SendPingAsync(string text) => SendPingAsync(Encoding.UTF8.GetBytes(text));
113          public bool SendPingAsync(ReadOnlySpan<char> text) => SendPingAsync(Encoding.UTF8.GetBytes(text.ToArray()));
114          public bool SendPingAsync(byte[] buffer) => SendPingAsync(buffer.AsSpan());
115          public bool SendPingAsync(byte[] buffer, long offset, long size) => SendPingAsync(buffer.AsSpan((int)offset, (int)size));
116          public bool SendPingAsync(ReadOnlySpan<byte> buffer)
117          {
118              lock (WebSocket.WsSendLock)
119              {
120                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
121                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
122              }
123          }
124          #endregion
125          #region WebSocket send pong methods
126          public long SendPong(string text) => SendPong(Encoding.UTF8.GetBytes(text));
127          public long SendPong(ReadOnlySpan<char> text) => SendPong(Encoding.UTF8.GetBytes(text.ToArray()));
128          public long SendPong(byte[] buffer) => SendPong(buffer.AsSpan());
129          public long SendPong(byte[] buffer, long offset, long size) => SendPong(buffer.AsSpan((int)offset, (int)size));
130          public long SendPong(ReadOnlySpan<byte> buffer)
131          {
132              lock (WebSocket.WsSendLock)
133              {
134                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
135                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
136              }
137          }
138          public bool SendPongAsync(string text) => SendPongAsync(Encoding.UTF8.GetBytes(text));
139          public bool SendPongAsync(ReadOnlySpan<char> text) => SendPongAsync(Encoding.UTF8.GetBytes(text.ToArray()));
140          public bool SendPongAsync(byte[] buffer) => SendPongAsync(buffer.AsSpan());
141          public bool SendPongAsync(byte[] buffer, long offset, long size) => SendPongAsync(buffer.AsSpan((int)offset, (int)size));
142          public bool SendPongAsync(ReadOnlySpan<byte> buffer)
143          {
144              lock (WebSocket.WsSendLock)
145              {
146                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
147                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
148              }
149          }
150          #endregion
151          #region WebSocket receive methods
152          public string ReceiveText()
153          {
154              var result = new Buffer();
155              if (!WebSocket.WsHandshaked)
156                  return result.ExtractString(0, result.Data.Length);
157              var cache = new Buffer();
158              while (!WebSocket.WsFinalReceived)
159              {
160                  while (!WebSocket.WsFrameReceived)
161                  {
162                      long required = WebSocket.RequiredReceiveFrameSize();
163                      cache.Resize(required);
164                      long received = base.Receive(cache.Data, 0, required);
</span>165                      if (received != required)
166                          return result.ExtractString(0, result.Data.Length);
167                      WebSocket.PrepareReceiveFrame(cache.Data, 0, received);
168                  }
169                  if (!WebSocket.WsFinalReceived)
170                      WebSocket.PrepareReceiveFrame(null, 0, 0);
171              }
172              result.Append(WebSocket.WsReceiveFinalBuffer);
173              WebSocket.PrepareReceiveFrame(null, 0, 0);
174              return result.ExtractString(0, result.Data.Length);
175          }
176          public Buffer ReceiveBinary()
177          {
178              var result = new Buffer();
179              if (!WebSocket.WsHandshaked)
180                  return result;
181              var cache = new Buffer();
182              while (!WebSocket.WsFinalReceived)
183              {
184                  while (!WebSocket.WsFrameReceived)
185                  {
186                      long required = WebSocket.RequiredReceiveFrameSize();
187                      cache.Resize(required);
188                      long received = base.Receive(cache.Data, 0, required);
189                      if (received != required)
190                          return result;
191                      WebSocket.PrepareReceiveFrame(cache.Data, 0, received);
192                  }
193                  if (!WebSocket.WsFinalReceived)
194                      WebSocket.PrepareReceiveFrame(null, 0, 0);
195              }
196              result.Append(WebSocket.WsReceiveFinalBuffer);
197              WebSocket.PrepareReceiveFrame(null, 0, 0);
198              return result;
199          }
200          #endregion
201          #region Session handlers
202          protected override void OnConnected()
203          {
204              WebSocket.ClearWsBuffers();
205              OnWsConnecting(Request);
206              if (_syncConnect)
207                  SendRequest(Request);
208              else
209                  SendRequestAsync(Request);
210          }
211          protected override void OnDisconnecting()
212          {
213              if (WebSocket.WsHandshaked)
214                  OnWsDisconnecting();
215          }
216          protected override void OnDisconnected()
217          {
218              if (WebSocket.WsHandshaked)
219              {
220                  WebSocket.WsHandshaked = false;
221                  OnWsDisconnected();
222              }
223              Request.Clear();
224              Response.Clear();
225              WebSocket.ClearWsBuffers();
226              WebSocket.InitWsNonce();
227          }
228          protected override void OnReceived(byte[] buffer, long offset, long size)
229          {
230              if (WebSocket.WsHandshaked)
231              {
232                  WebSocket.PrepareReceiveFrame(buffer, offset, size);
233                  return;
234              }
235              base.OnReceived(buffer, offset, size);
236          }
237          protected override void OnReceivedResponseHeader(HttpResponse response)
238          {
239              if (WebSocket.WsHandshaked)
240                  return;
241              if (!WebSocket.PerformClientUpgrade(response, Id))
242              {
243                  base.OnReceivedResponseHeader(response);
244                  return;
245              }
246          }
247          protected override void OnReceivedResponse(HttpResponse response)
248          {
249              if (WebSocket.WsHandshaked)
250              {
251                  var body = Response.Body;
252                  var data = Encoding.UTF8.GetBytes(body);
253                  WebSocket.PrepareReceiveFrame(data, 0, data.Length);
254                  return;
255              }
256              base.OnReceivedResponse(response);
257          }
258          protected override void OnReceivedResponseError(HttpResponse response, string error)
259          {
260              if (WebSocket.WsHandshaked)
261              {
262                  OnError(new SocketError());
263                  return;
264              }
265              base.OnReceivedResponseError(response, error);
266          }
267          #endregion
268          #region Web socket handlers
269          public virtual void OnWsConnecting(HttpRequest request) {}
270          public virtual void OnWsConnected(HttpResponse response) {}
271          public virtual bool OnWsConnecting(HttpRequest request, HttpResponse response) { return true; }
272          public virtual void OnWsConnected(HttpRequest request) {}
273          public virtual void OnWsDisconnecting() {}
274          public virtual void OnWsDisconnected() {}
275          public virtual void OnWsReceived(byte[] buffer, long offset, long size) {}
276          public virtual void OnWsClose(byte[] buffer, long offset, long size, int status = 1000) { CloseAsync(status); }
277          public virtual void OnWsPing(byte[] buffer, long offset, long size) { SendPongAsync(buffer, offset, size); }
278          public virtual void OnWsPong(byte[] buffer, long offset, long size) {}
279          public virtual void OnWsError(string error) { OnError(SocketError.SocketError); }
280          public virtual void OnWsError(SocketError error) { OnError(error); }
281          #endregion
282          private bool _syncConnect;
283      }
284  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WssClient.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WsClient.cs</div>
                </div>
                <div class="column column_space"><pre><code>16          public override bool Connect() { _syncConnect = true; return base.Connect(); }
17          public override bool ConnectAsync() { _syncConnect = false; return base.ConnectAsync(); }
18          public virtual bool Close(int status) { SendClose(status, Span<byte>.Empty); base.Disconnect(); return true; }
19          public virtual bool CloseAsync(int status) { SendCloseAsync(status, Span<byte>.Empty); base.DisconnectAsync(); return true; }
20          #endregion
21          #region WebSocket send text methods
22          public long SendText(string text) => SendText(Encoding.UTF8.GetBytes(text));
23          public long SendText(ReadOnlySpan<char> text) => SendText(Encoding.UTF8.GetBytes(text.ToArray()));
24          public long SendText(byte[] buffer) => SendText(buffer.AsSpan());
25          public long SendText(byte[] buffer, long offset, long size) => SendText(buffer.AsSpan((int)offset, (int)size));
26          public long SendText(ReadOnlySpan<byte> buffer)
27          {
28              lock (WebSocket.WsSendLock)
29              {
30                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
31                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
32              }
33          }
34          public bool SendTextAsync(string text) => SendTextAsync(Encoding.UTF8.GetBytes(text));
35          public bool SendTextAsync(ReadOnlySpan<char> text) => SendTextAsync(Encoding.UTF8.GetBytes(text.ToArray()));
36          public bool SendTextAsync(byte[] buffer) => SendTextAsync(buffer.AsSpan());
37          public bool SendTextAsync(byte[] buffer, long offset, long size) => SendTextAsync(buffer.AsSpan((int)offset, (int)size));
38          public bool SendTextAsync(ReadOnlySpan<byte> buffer)
39          {
40              lock (WebSocket.WsSendLock)
41              {
42                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
43                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
44              }
45          }
46          #endregion
47          #region WebSocket send binary methods
48          public long SendBinary(string text) => SendBinary(Encoding.UTF8.GetBytes(text));
49          public long SendBinary(ReadOnlySpan<char> text) => SendBinary(Encoding.UTF8.GetBytes(text.ToArray()));
50          public long SendBinary(byte[] buffer) => SendBinary(buffer.AsSpan());
51          public long SendBinary(byte[] buffer, long offset, long size) => SendBinary(buffer.AsSpan((int)offset, (int)size));
52          public long SendBinary(ReadOnlySpan<byte> buffer)
53          {
54              lock (WebSocket.WsSendLock)
55              {
56                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
57                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
58              }
59          }
60          public bool SendBinaryAsync(string text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text));
61          public bool SendBinaryAsync(ReadOnlySpan<char> text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text.ToArray()));
62          public bool SendBinaryAsync(byte[] buffer) => SendBinaryAsync(buffer.AsSpan());
63          public bool SendBinaryAsync(byte[] buffer, long offset, long size) => SendBinaryAsync(buffer.AsSpan((int)offset, (int)size));
64          public bool SendBinaryAsync(ReadOnlySpan<byte> buffer)
65          {
66              lock (WebSocket.WsSendLock)
67              {
68                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
69                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
70              }
71          }
72          #endregion
73          #region WebSocket send close methods
74          public long SendClose(int status, string text) => SendClose(status, Encoding.UTF8.GetBytes(text));
75          public long SendClose(int status, ReadOnlySpan<char> text) => SendClose(status, Encoding.UTF8.GetBytes(text.ToArray()));
76          public long SendClose(int status, byte[] buffer) => SendClose(status, buffer.AsSpan());
77          public long SendClose(int status, byte[] buffer, long offset, long size) => SendClose(status, buffer.AsSpan((int)offset, (int)size));
78          public long SendClose(int status, ReadOnlySpan<byte> buffer)
79          {
80              lock (WebSocket.WsSendLock)
81              {
82                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
83                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
84              }
85          }
86          public bool SendCloseAsync(int status, string text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text));
87          public bool SendCloseAsync(int status, ReadOnlySpan<char> text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text.ToArray()));
88          public bool SendCloseAsync(int status, byte[] buffer) => SendCloseAsync(status, buffer.AsSpan());
89          public bool SendCloseAsync(int status, byte[] buffer, long offset, long size) => SendCloseAsync(status, buffer.AsSpan((int)offset, (int)size));
90          public bool SendCloseAsync(int status, ReadOnlySpan<byte> buffer)
91          {
92              lock (WebSocket.WsSendLock)
93              {
94                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
95                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
96              }
97          }
98          #endregion
99          #region WebSocket send ping methods
100          public long SendPing(string text) => SendPing(Encoding.UTF8.GetBytes(text));
101          public long SendPing(ReadOnlySpan<char> text) => SendPing(Encoding.UTF8.GetBytes(text.ToArray()));
102          public long SendPing(byte[] buffer) => SendPing(buffer.AsSpan());
103          public long SendPing(byte[] buffer, long offset, long size) => SendPing(buffer.AsSpan((int)offset, (int)size));
104          public long SendPing(ReadOnlySpan<byte> buffer)
105          {
106              lock (WebSocket.WsSendLock)
107              {
108                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
109                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
110              }
111          }
112          public bool SendPingAsync(string text) => SendPingAsync(Encoding.UTF8.GetBytes(text));
113          public bool SendPingAsync(ReadOnlySpan<char> text) => SendPingAsync(Encoding.UTF8.GetBytes(text.ToArray()));
114          public bool SendPingAsync(byte[] buffer) => SendPingAsync(buffer.AsSpan());
115          public bool SendPingAsync(byte[] buffer, long offset, long size) => SendPingAsync(buffer.AsSpan((int)offset, (int)size));
116          public bool SendPingAsync(ReadOnlySpan<byte> buffer)
117          {
118              lock (WebSocket.WsSendLock)
119              {
120                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
121                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
122              }
123          }
124          #endregion
125          #region WebSocket send pong methods
126          public long SendPong(string text) => SendPong(Encoding.UTF8.GetBytes(text));
127          public long SendPong(ReadOnlySpan<char> text) => SendPong(Encoding.UTF8.GetBytes(text.ToArray()));
128          public long SendPong(byte[] buffer) => SendPong(buffer.AsSpan());
129          public long SendPong(byte[] buffer, long offset, long size) => SendPong(buffer.AsSpan((int)offset, (int)size));
130          public long SendPong(ReadOnlySpan<byte> buffer)
131          {
132              lock (WebSocket.WsSendLock)
133              {
134                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
135                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
136              }
137          }
138          public bool SendPongAsync(string text) => SendPongAsync(Encoding.UTF8.GetBytes(text));
139          public bool SendPongAsync(ReadOnlySpan<char> text) => SendPongAsync(Encoding.UTF8.GetBytes(text.ToArray()));
140          public bool SendPongAsync(byte[] buffer) => SendPongAsync(buffer.AsSpan());
141          public bool SendPongAsync(byte[] buffer, long offset, long size) => SendPongAsync(buffer.AsSpan((int)offset, (int)size));
142          public bool SendPongAsync(ReadOnlySpan<byte> buffer)
143          {
144              lock (WebSocket.WsSendLock)
145              {
146                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
147                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
148              }
149          }
150          #endregion
151          #region WebSocket receive methods
152          public string ReceiveText()
153          {
154              var result = new Buffer();
155              if (!WebSocket.WsHandshaked)
156                  return result.ExtractString(0, result.Data.Length);
157              var cache = new Buffer();
158              while (!WebSocket.WsFinalReceived)
159              {
160                  while (!WebSocket.WsFrameReceived)
161                  {
162                      long required = WebSocket.RequiredReceiveFrameSize();
163                      cache.Resize(required);
164                      long received = (int)base.Receive(cache.Data, 0, required);
</pre></code></div>
                <div class="column column_space"><pre><code>16          public override bool Connect() { _syncConnect = true; return base.Connect(); }
17          public override bool ConnectAsync() { _syncConnect = false; return base.ConnectAsync(); }
18          public virtual bool Close(int status) { SendClose(status, Span<byte>.Empty); base.Disconnect(); return true; }
19          public virtual bool CloseAsync(int status) { SendCloseAsync(status, Span<byte>.Empty); base.DisconnectAsync(); return true; }
20          #endregion
21          #region WebSocket send text methods
22          public long SendText(string text) => SendText(Encoding.UTF8.GetBytes(text));
23          public long SendText(ReadOnlySpan<char> text) => SendText(Encoding.UTF8.GetBytes(text.ToArray()));
24          public long SendText(byte[] buffer) => SendText(buffer.AsSpan());
25          public long SendText(byte[] buffer, long offset, long size) => SendText(buffer.AsSpan((int)offset, (int)size));
26          public long SendText(ReadOnlySpan<byte> buffer)
27          {
28              lock (WebSocket.WsSendLock)
29              {
30                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
31                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
32              }
33          }
34          public bool SendTextAsync(string text) => SendTextAsync(Encoding.UTF8.GetBytes(text));
35          public bool SendTextAsync(ReadOnlySpan<char> text) => SendTextAsync(Encoding.UTF8.GetBytes(text.ToArray()));
36          public bool SendTextAsync(byte[] buffer) => SendTextAsync(buffer.AsSpan());
37          public bool SendTextAsync(byte[] buffer, long offset, long size) => SendTextAsync(buffer.AsSpan((int)offset, (int)size));
38          public bool SendTextAsync(ReadOnlySpan<byte> buffer)
39          {
40              lock (WebSocket.WsSendLock)
41              {
42                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_TEXT, true, buffer);
43                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
44              }
45          }
46          #endregion
47          #region WebSocket send binary methods
48          public long SendBinary(string text) => SendBinary(Encoding.UTF8.GetBytes(text));
49          public long SendBinary(ReadOnlySpan<char> text) => SendBinary(Encoding.UTF8.GetBytes(text.ToArray()));
50          public long SendBinary(byte[] buffer) => SendBinary(buffer.AsSpan());
51          public long SendBinary(byte[] buffer, long offset, long size) => SendBinary(buffer.AsSpan((int)offset, (int)size));
52          public long SendBinary(ReadOnlySpan<byte> buffer)
53          {
54              lock (WebSocket.WsSendLock)
55              {
56                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
57                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
58              }
59          }
60          public bool SendBinaryAsync(string text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text));
61          public bool SendBinaryAsync(ReadOnlySpan<char> text) => SendBinaryAsync(Encoding.UTF8.GetBytes(text.ToArray()));
62          public bool SendBinaryAsync(byte[] buffer) => SendBinaryAsync(buffer.AsSpan());
63          public bool SendBinaryAsync(byte[] buffer, long offset, long size) => SendBinaryAsync(buffer.AsSpan((int)offset, (int)size));
64          public bool SendBinaryAsync(ReadOnlySpan<byte> buffer)
65          {
66              lock (WebSocket.WsSendLock)
67              {
68                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_BINARY, true, buffer);
69                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
70              }
71          }
72          #endregion
73          #region WebSocket send close methods
74          public long SendClose(int status, string text) => SendClose(status, Encoding.UTF8.GetBytes(text));
75          public long SendClose(int status, ReadOnlySpan<char> text) => SendClose(status, Encoding.UTF8.GetBytes(text.ToArray()));
76          public long SendClose(int status, byte[] buffer) => SendClose(status, buffer.AsSpan());
77          public long SendClose(int status, byte[] buffer, long offset, long size) => SendClose(status, buffer.AsSpan((int)offset, (int)size));
78          public long SendClose(int status, ReadOnlySpan<byte> buffer)
79          {
80              lock (WebSocket.WsSendLock)
81              {
82                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
83                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
84              }
85          }
86          public bool SendCloseAsync(int status, string text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text));
87          public bool SendCloseAsync(int status, ReadOnlySpan<char> text) => SendCloseAsync(status, Encoding.UTF8.GetBytes(text.ToArray()));
88          public bool SendCloseAsync(int status, byte[] buffer) => SendCloseAsync(status, buffer.AsSpan());
89          public bool SendCloseAsync(int status, byte[] buffer, long offset, long size) => SendCloseAsync(status, buffer.AsSpan((int)offset, (int)size));
90          public bool SendCloseAsync(int status, ReadOnlySpan<byte> buffer)
91          {
92              lock (WebSocket.WsSendLock)
93              {
94                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_CLOSE, true, buffer, status);
95                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
96              }
97          }
98          #endregion
99          #region WebSocket send ping methods
100          public long SendPing(string text) => SendPing(Encoding.UTF8.GetBytes(text));
101          public long SendPing(ReadOnlySpan<char> text) => SendPing(Encoding.UTF8.GetBytes(text.ToArray()));
102          public long SendPing(byte[] buffer) => SendPing(buffer.AsSpan());
103          public long SendPing(byte[] buffer, long offset, long size) => SendPing(buffer.AsSpan((int)offset, (int)size));
104          public long SendPing(ReadOnlySpan<byte> buffer)
105          {
106              lock (WebSocket.WsSendLock)
107              {
108                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
109                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
110              }
111          }
112          public bool SendPingAsync(string text) => SendPingAsync(Encoding.UTF8.GetBytes(text));
113          public bool SendPingAsync(ReadOnlySpan<char> text) => SendPingAsync(Encoding.UTF8.GetBytes(text.ToArray()));
114          public bool SendPingAsync(byte[] buffer) => SendPingAsync(buffer.AsSpan());
115          public bool SendPingAsync(byte[] buffer, long offset, long size) => SendPingAsync(buffer.AsSpan((int)offset, (int)size));
116          public bool SendPingAsync(ReadOnlySpan<byte> buffer)
117          {
118              lock (WebSocket.WsSendLock)
119              {
120                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PING, true, buffer);
121                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
122              }
123          }
124          #endregion
125          #region WebSocket send pong methods
126          public long SendPong(string text) => SendPong(Encoding.UTF8.GetBytes(text));
127          public long SendPong(ReadOnlySpan<char> text) => SendPong(Encoding.UTF8.GetBytes(text.ToArray()));
128          public long SendPong(byte[] buffer) => SendPong(buffer.AsSpan());
129          public long SendPong(byte[] buffer, long offset, long size) => SendPong(buffer.AsSpan((int)offset, (int)size));
130          public long SendPong(ReadOnlySpan<byte> buffer)
131          {
132              lock (WebSocket.WsSendLock)
133              {
134                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
135                  return base.Send(WebSocket.WsSendBuffer.AsSpan());
136              }
137          }
138          public bool SendPongAsync(string text) => SendPongAsync(Encoding.UTF8.GetBytes(text));
139          public bool SendPongAsync(ReadOnlySpan<char> text) => SendPongAsync(Encoding.UTF8.GetBytes(text.ToArray()));
140          public bool SendPongAsync(byte[] buffer) => SendPongAsync(buffer.AsSpan());
141          public bool SendPongAsync(byte[] buffer, long offset, long size) => SendPongAsync(buffer.AsSpan((int)offset, (int)size));
142          public bool SendPongAsync(ReadOnlySpan<byte> buffer)
143          {
144              lock (WebSocket.WsSendLock)
145              {
146                  WebSocket.PrepareSendFrame(WebSocket.WS_FIN | WebSocket.WS_PONG, true, buffer);
147                  return base.SendAsync(WebSocket.WsSendBuffer.AsSpan());
148              }
149          }
150          #endregion
151          #region WebSocket receive methods
152          public string ReceiveText()
153          {
154              var result = new Buffer();
155              if (!WebSocket.WsHandshaked)
156                  return result.ExtractString(0, result.Data.Length);
157              var cache = new Buffer();
158              while (!WebSocket.WsFinalReceived)
159              {
160                  while (!WebSocket.WsFrameReceived)
161                  {
162                      long required = WebSocket.RequiredReceiveFrameSize();
163                      cache.Resize(required);
164                      long received = base.Receive(cache.Data, 0, required);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    