
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CompositeHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics.CodeAnalysis;
3  using System.Linq;
4  using System.Linq.Expressions;
5  using System.Reflection;
6  using System.Runtime.CompilerServices;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using Npgsql.BackendMessages;
10  using Npgsql.Internal.TypeHandling;
11  using Npgsql.Internal.TypeMapping;
12  using Npgsql.PostgresTypes;
13  using Npgsql.TypeMapping;
14  using NpgsqlTypes;
15  #region Trimming warning suppressions
16  [module: UnconditionalSuppressMessage(
17      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
18      "IL2046", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
19  [module: UnconditionalSuppressMessage(
20      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
21      "IL2080", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
22  [module: UnconditionalSuppressMessage(
23      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
24      "IL2026", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
25  [module: UnconditionalSuppressMessage(
26      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
27      "IL2090", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
28  [module: UnconditionalSuppressMessage(
29      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
30      "IL2087", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
31  [module: UnconditionalSuppressMessage(
32      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
33      "IL2055", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
34  [module: UnconditionalSuppressMessage(
35      "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.",
36      "IL2077", Scope = "type", Target = "Npgsql.Internal.TypeHandlers.CompositeHandlers.CompositeHandler")]
37  #endregion
38  namespace Npgsql.Internal.TypeHandlers.CompositeHandlers;
39  sealed partial class CompositeHandler<T> : NpgsqlTypeHandler<T>, ICompositeHandler
40  {
41      readonly TypeMapper _typeMapper;
42      readonly INpgsqlNameTranslator _nameTranslator;
43      Func<T>? _constructor;
44      CompositeConstructorHandler<T>? _constructorHandler;
45      CompositeMemberHandler<T>[] _memberHandlers = null!;
46      public Type CompositeType => typeof(T);
47      public CompositeHandler(PostgresCompositeType postgresType, TypeMapper typeMapper, INpgsqlNameTranslator nameTranslator)
48          : base(postgresType)
49      {
50          _typeMapper = typeMapper;
51          _nameTranslator = nameTranslator;
52      }
53      public override ValueTask<T> Read(NpgsqlReadBuffer buffer, int length, bool async, FieldDescription? fieldDescription = null)
54      {
55          Initialize();
56          return _constructorHandler is null
57              ? ReadUsingMemberHandlers(buffer, async)
58              : _constructorHandler.Read(buffer, async);
<span onclick='openModal()' class='match'>59          async ValueTask<T> ReadUsingMemberHandlers(NpgsqlReadBuffer buffer, bool async)
60          {
61              await buffer.Ensure(sizeof(int), async);
</span>62              var fieldCount = buffer.ReadInt32();
63              if (fieldCount != _memberHandlers.Length)
64                  throw new InvalidOperationException($"pg_attributes contains {_memberHandlers.Length} fields for type {PgDisplayName}, but {fieldCount} fields were received.");
65              if (IsValueType<T>.Value)
66              {
67                  var composite = new ByReference<T> { Value = _constructor!() };
68                  foreach (var member in _memberHandlers)
69                      await member.Read(composite, buffer, async);
70                  return composite.Value;
71              }
72              else
73              {
74                  var composite = _constructor!();
75                  foreach (var member in _memberHandlers)
76                      await member.Read(composite, buffer, async);
77                  return composite;
78              }
79          }
80      }
81      public override async Task Write(T value, NpgsqlWriteBuffer buffer, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
82      {
83          Initialize();
84          if (buffer.WriteSpaceLeft < sizeof(int))
85              await buffer.Flush(async, cancellationToken);
86          buffer.WriteInt32(_memberHandlers.Length);
87          foreach (var member in _memberHandlers)
88              await member.Write(value, buffer, lengthCache, async, cancellationToken);
89      }
90      public override int ValidateAndGetLength(T value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
91      {
92          Initialize();
93          lengthCache ??= new NpgsqlLengthCache(1);
94          if (lengthCache.IsPopulated)
95              return lengthCache.Get();
96          var position = lengthCache.Position;
97          lengthCache.Set(0);
98          var length = sizeof(int) + sizeof(int) * 2 * _memberHandlers.Length;
99          foreach (var member in _memberHandlers)
100              length += member.ValidateAndGetLength(value, ref lengthCache);
101          return lengthCache.Lengths[position] = length;
102      }
103      [MethodImpl(MethodImplOptions.AggressiveInlining)]
104      void Initialize()
105      {
106          if (_memberHandlers is null)
107              InitializeCore();
108          void InitializeCore()
109          {
110              var pgType = (PostgresCompositeType)PostgresType;
111              _memberHandlers = CreateMemberHandlers(pgType, _typeMapper, _nameTranslator);
112              _constructorHandler = CreateConstructorHandler(pgType, _typeMapper, _nameTranslator);
113              _constructor = _constructorHandler is null
114                  ? Expression
115                      .Lambda<Func<T>>(Expression.New(typeof(T)))
116                      .Compile()
117                  : null;
118          }
119      }
120      static CompositeConstructorHandler<T>? CreateConstructorHandler(PostgresCompositeType pgType, TypeMapper typeMapper, INpgsqlNameTranslator nameTranslator)
121      {
122          var pgFields = pgType.Fields;
123          var clrType = typeof(T);
124          ConstructorInfo? clrDefaultConstructor = null;
125          foreach (var clrConstructor in clrType.GetConstructors())
126          {
127              var clrParameters = clrConstructor.GetParameters();
128              if (clrParameters.Length != pgFields.Count)
129              {
130                  if (clrParameters.Length == 0)
131                      clrDefaultConstructor = clrConstructor;
132                  continue;
133              }
134              var clrParameterHandlerCount = 0;
135              var clrParametersMapped = new ParameterInfo[pgFields.Count];
136              foreach (var clrParameter in clrParameters)
137              {
138                  var attr = clrParameter.GetCustomAttribute<PgNameAttribute>();
139                  var name = attr?.PgName ?? (clrParameter.Name is string clrName ? nameTranslator.TranslateMemberName(clrName) : null);
140                  if (name is null)
141                      break;
142                  for (var pgFieldIndex = pgFields.Count - 1; pgFieldIndex >= 0; --pgFieldIndex)
143                  {
144                      var pgField = pgFields[pgFieldIndex];
145                      if (pgField.Name != name)
146                          continue;
147                      if (clrParametersMapped[pgFieldIndex] != null)
148                          throw new AmbiguousMatchException($"Multiple constructor parameters are mapped to the '{pgField.Name}' field.");
149                      clrParameterHandlerCount++;
150                      clrParametersMapped[pgFieldIndex] = clrParameter;
151                      break;
152                  }
153              }
154              if (clrParameterHandlerCount < pgFields.Count)
155                  continue;
156              var clrParameterHandlers = new CompositeParameterHandler[pgFields.Count];
157              for (var pgFieldIndex = 0; pgFieldIndex < pgFields.Count; ++pgFieldIndex)
158              {
159                  var pgField = pgFields[pgFieldIndex];
160                  if (!typeMapper.TryResolveByOID(pgField.Type.OID, out var handler))
161                      throw new NpgsqlException($"PostgreSQL composite type {pgType.DisplayName} has field {pgField.Type.DisplayName} with an unknown type (OID = {pgField.Type.OID}).");
162                  var clrParameter = clrParametersMapped[pgFieldIndex];
163                  var clrParameterHandlerType = typeof(CompositeParameterHandler<>)
164                      .MakeGenericType(clrParameter.ParameterType);
165                  clrParameterHandlers[pgFieldIndex] = (CompositeParameterHandler)Activator.CreateInstance(
166                      clrParameterHandlerType,
167                      BindingFlags.Instance | BindingFlags.Public,
168                      binder: null,
169                      args: new object[] { handler, clrParameter },
170                      culture: null)!;
171              }
172              return CompositeConstructorHandler<T>.Create(pgType, clrConstructor, clrParameterHandlers);
173          }
174          if (clrDefaultConstructor is null && !clrType.IsValueType)
175              throw new InvalidOperationException($"No parameterless constructor defined for type '{clrType}'.");
176          return null;
177      }
178      static CompositeMemberHandler<T>[] CreateMemberHandlers(PostgresCompositeType pgType, TypeMapper typeMapper, INpgsqlNameTranslator nameTranslator)
179      {
180          var pgFields = pgType.Fields;
181          var clrType = typeof(T);
182          var clrMemberHandlers = new CompositeMemberHandler<T>[pgFields.Count];
183          var clrMemberHandlerCount = 0;
184          var clrMemberHandlerType = IsValueType<T>.Value
185              ? typeof(CompositeStructMemberHandler<,>)
186              : typeof(CompositeClassMemberHandler<,>);
187          foreach (var clrProperty in clrType.GetProperties(BindingFlags.Instance | BindingFlags.Public))
188              CreateMemberHandler(clrProperty, clrProperty.PropertyType);
189          foreach (var clrField in clrType.GetFields(BindingFlags.Instance | BindingFlags.Public))
190              CreateMemberHandler(clrField, clrField.FieldType);
191          if (clrMemberHandlerCount != pgFields.Count)
192          {
193              var notMappedFields = string.Join(", ", clrMemberHandlers
194                  .Select((member, memberIndex) => member == null ? $"'{pgFields[memberIndex].Name}'" : null)
195                  .Where(member => member != null));
196              throw new InvalidOperationException($"PostgreSQL composite type {pgType.DisplayName} contains fields {notMappedFields} which could not match any on CLR type {clrType.Name}");
197          }
198          return clrMemberHandlers;
199          void CreateMemberHandler(MemberInfo clrMember, Type clrMemberType)
200          {
201              var attr = clrMember.GetCustomAttribute<PgNameAttribute>();
202              var name = attr?.PgName ?? nameTranslator.TranslateMemberName(clrMember.Name);
203              for (var pgFieldIndex = pgFields.Count - 1; pgFieldIndex >= 0; --pgFieldIndex)
204              {
205                  var pgField = pgFields[pgFieldIndex];
206                  if (pgField.Name != name)
207                      continue;
208                  if (clrMemberHandlers[pgFieldIndex] != null)
209                      throw new AmbiguousMatchException($"Multiple class members are mapped to the '{pgField.Name}' field.");
210                  if (!typeMapper.TryResolveByOID(pgField.Type.OID, out var handler))
211                      throw new NpgsqlException($"PostgreSQL composite type {pgType.DisplayName} has field {pgField.Type.DisplayName} with an unknown type (OID = {pgField.Type.OID}).");
212                  clrMemberHandlerCount++;
213                  clrMemberHandlers[pgFieldIndex] = (CompositeMemberHandler<T>)Activator.CreateInstance(
214                      clrMemberHandlerType.MakeGenericType(clrType, clrMemberType),
215                      BindingFlags.Instance | BindingFlags.Public,
216                      binder: null,
217                      args: new object[] { clrMember, pgField.Type, handler },
218                      culture: null)!;
219                  break;
220              }
221          }
222      }
223  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GeoJSONHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.ObjectModel;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GeoJSON.Net;
7  using GeoJSON.Net.CoordinateReferenceSystem;
8  using GeoJSON.Net.Geometry;
9  using Npgsql.BackendMessages;
10  using Npgsql.Internal;
11  using Npgsql.Internal.TypeHandling;
12  using Npgsql.PostgresTypes;
13  namespace Npgsql.GeoJSON.Internal;
14  sealed partial class GeoJsonHandler : NpgsqlTypeHandler<GeoJSONObject>,
15      INpgsqlTypeHandler<Point>, INpgsqlTypeHandler<MultiPoint>,
16      INpgsqlTypeHandler<Polygon>, INpgsqlTypeHandler<MultiPolygon>,
17      INpgsqlTypeHandler<LineString>, INpgsqlTypeHandler<MultiLineString>,
18      INpgsqlTypeHandler<GeometryCollection>,
19      INpgsqlTypeHandler<IGeoJSONObject>,
20      INpgsqlTypeHandler<IGeometryObject>
21  {
22      readonly GeoJSONOptions _options;
23      readonly CrsMap _crsMap;
24      readonly ConcurrentDictionary<int, NamedCRS> _cachedCrs = new();
25      internal GeoJsonHandler(PostgresType postgresType, GeoJSONOptions options, CrsMap crsMap)
26          : base(postgresType)
27      {
28          _options = options;
29          _crsMap = crsMap;
30      }
31      GeoJSONOptions CrsType => _options & (GeoJSONOptions.ShortCRS | GeoJSONOptions.LongCRS);
32      bool BoundingBox => (_options & GeoJSONOptions.BoundingBox) != 0;
33      static bool HasSrid(EwkbGeometryType type)
34          => (type & EwkbGeometryType.HasSrid) != 0;
35      static bool HasZ(EwkbGeometryType type)
36          => (type & EwkbGeometryType.HasZ) != 0;
37      static bool HasM(EwkbGeometryType type)
38          => (type & EwkbGeometryType.HasM) != 0;
39      static bool HasZ(IPosition coordinates)
40          => coordinates.Altitude.HasValue;
41      const int SizeOfLength = sizeof(int);
42      const int SizeOfHeader = sizeof(byte) + sizeof(EwkbGeometryType);
43      const int SizeOfHeaderWithLength = SizeOfHeader + SizeOfLength;
44      const int SizeOfPoint2D = 2 * sizeof(double);
45      const int SizeOfPoint3D = 3 * sizeof(double);
46      static int SizeOfPoint(bool hasZ)
47          => hasZ ? SizeOfPoint3D : SizeOfPoint2D;
48      static int SizeOfPoint(EwkbGeometryType type)
49      {
50          var size = SizeOfPoint2D;
51          if (HasZ(type))
52              size += sizeof(double);
53          if (HasM(type))
54              size += sizeof(double);
55          return size;
56      }
57      #region Throw
58      static Exception UnknownPostGisType()
59          => throw new InvalidOperationException("Invalid PostGIS type");
60      static Exception AllOrNoneCoordiantesMustHaveZ(NpgsqlParameter? parameter, string typeName)
61          => parameter is null
62              ? new ArgumentException($"The Z coordinate must be specified for all or none elements of {typeName}")
63              : new ArgumentException($"The Z coordinate must be specified for all or none elements of {typeName} in the {parameter.ParameterName} parameter", parameter.ParameterName);
64      #endregion
65      #region Read
66      public override ValueTask<GeoJSONObject> Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription = null)
67          => ReadGeometry(buf, async);
68      async ValueTask<Point> INpgsqlTypeHandler<Point>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
69          => (Point)await ReadGeometry(buf, async);
70      async ValueTask<LineString> INpgsqlTypeHandler<LineString>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
71          => (LineString)await ReadGeometry(buf, async);
72      async ValueTask<Polygon> INpgsqlTypeHandler<Polygon>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
73          => (Polygon)await ReadGeometry(buf, async);
74      async ValueTask<MultiPoint> INpgsqlTypeHandler<MultiPoint>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
75          => (MultiPoint)await ReadGeometry(buf, async);
76      async ValueTask<MultiLineString> INpgsqlTypeHandler<MultiLineString>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
77          => (MultiLineString)await ReadGeometry(buf, async);
78      async ValueTask<MultiPolygon> INpgsqlTypeHandler<MultiPolygon>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
79          => (MultiPolygon)await ReadGeometry(buf, async);
80      async ValueTask<GeometryCollection> INpgsqlTypeHandler<GeometryCollection>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
81          => (GeometryCollection)await ReadGeometry(buf, async);
82      async ValueTask<IGeoJSONObject> INpgsqlTypeHandler<IGeoJSONObject>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
83          => await ReadGeometry(buf, async);
84      async ValueTask<IGeometryObject> INpgsqlTypeHandler<IGeometryObject>.Read(NpgsqlReadBuffer buf, int len, bool async, FieldDescription? fieldDescription)
85          => (IGeometryObject)await ReadGeometry(buf, async);
<span onclick='openModal()' class='match'>86      async ValueTask<GeoJSONObject> ReadGeometry(NpgsqlReadBuffer buf, bool async)
87      {
88          var boundingBox = BoundingBox ? new BoundingBoxBuilder() : null;
</span>89          var geometry = await ReadGeometryCore(buf, async, boundingBox);
90          geometry.BoundingBoxes = boundingBox?.Build();
91          return geometry;
92      }
93      async ValueTask<GeoJSONObject> ReadGeometryCore(NpgsqlReadBuffer buf, bool async, BoundingBoxBuilder? boundingBox)
94      {
95          await buf.Ensure(SizeOfHeader, async);
96          var littleEndian = buf.ReadByte() > 0;
97          var type = (EwkbGeometryType)buf.ReadUInt32(littleEndian);
98          GeoJSONObject geometry;
99          NamedCRS? crs = null;
100          if (HasSrid(type))
101          {
102              await buf.Ensure(4, async);
103              crs = GetCrs(buf.ReadInt32(littleEndian));
104          }
105          switch (type & EwkbGeometryType.BaseType)
106          {
107          case EwkbGeometryType.Point:
108          {
109              await buf.Ensure(SizeOfPoint(type), async);
110              var position = ReadPosition(buf, type, littleEndian);
111              boundingBox?.Accumulate(position);
112              geometry = new Point(position);
113              break;
114          }
115          case EwkbGeometryType.LineString:
116          {
117              await buf.Ensure(SizeOfLength, async);
118              var coordinates = new Position[buf.ReadInt32(littleEndian)];
119              for (var i = 0; i < coordinates.Length; ++i)
120              {
121                  await buf.Ensure(SizeOfPoint(type), async);
122                  var position = ReadPosition(buf, type, littleEndian);
123                  boundingBox?.Accumulate(position);
124                  coordinates[i] = position;
125              }
126              geometry = new LineString(coordinates);
127              break;
128          }
129          case EwkbGeometryType.Polygon:
130          {
131              await buf.Ensure(SizeOfLength, async);
132              var lines = new LineString[buf.ReadInt32(littleEndian)];
133              for (var i = 0; i < lines.Length; ++i)
134              {
135                  await buf.Ensure(SizeOfLength, async);
136                  var coordinates = new Position[buf.ReadInt32(littleEndian)];
137                  for (var j = 0; j < coordinates.Length; ++j)
138                  {
139                      await buf.Ensure(SizeOfPoint(type), async);
140                      var position = ReadPosition(buf, type, littleEndian);
141                      boundingBox?.Accumulate(position);
142                      coordinates[j] = position;
143                  }
144                  lines[i] = new LineString(coordinates);
145              }
146              geometry = new Polygon(lines);
147              break;
148          }
149          case EwkbGeometryType.MultiPoint:
150          {
151              await buf.Ensure(SizeOfLength, async);
152              var points = new Point[buf.ReadInt32(littleEndian)];
153              for (var i = 0; i < points.Length; ++i)
154              {
155                  await buf.Ensure(SizeOfHeader + SizeOfPoint(type), async);
156                  await buf.Skip(SizeOfHeader, async);
157                  var position = ReadPosition(buf, type, littleEndian);
158                  boundingBox?.Accumulate(position);
159                  points[i] = new Point(position);
160              }
161              geometry = new MultiPoint(points);
162              break;
163          }
164          case EwkbGeometryType.MultiLineString:
165          {
166              await buf.Ensure(SizeOfLength, async);
167              var lines = new LineString[buf.ReadInt32(littleEndian)];
168              for (var i = 0; i < lines.Length; ++i)
169              {
170                  await buf.Ensure(SizeOfHeaderWithLength, async);
171                  await buf.Skip(SizeOfHeader, async);
172                  var coordinates = new Position[buf.ReadInt32(littleEndian)];
173                  for (var j = 0; j < coordinates.Length; ++j)
174                  {
175                      await buf.Ensure(SizeOfPoint(type), async);
176                      var position = ReadPosition(buf, type, littleEndian);
177                      boundingBox?.Accumulate(position);
178                      coordinates[j] = position;
179                  }
180                  lines[i] = new LineString(coordinates);
181              }
182              geometry = new MultiLineString(lines);
183              break;
184          }
185          case EwkbGeometryType.MultiPolygon:
186          {
187              await buf.Ensure(SizeOfLength, async);
188              var polygons = new Polygon[buf.ReadInt32(littleEndian)];
189              for (var i = 0; i < polygons.Length; ++i)
190              {
191                  await buf.Ensure(SizeOfHeaderWithLength, async);
192                  await buf.Skip(SizeOfHeader, async);
193                  var lines = new LineString[buf.ReadInt32(littleEndian)];
194                  for (var j = 0; j < lines.Length; ++j)
195                  {
196                      await buf.Ensure(SizeOfLength, async);
197                      var coordinates = new Position[buf.ReadInt32(littleEndian)];
198                      for (var k = 0; k < coordinates.Length; ++k)
199                      {
200                          await buf.Ensure(SizeOfPoint(type), async);
201                          var position = ReadPosition(buf, type, littleEndian);
202                          boundingBox?.Accumulate(position);
203                          coordinates[k] = position;
204                      }
205                      lines[j] = new LineString(coordinates);
206                  }
207                  polygons[i] = new Polygon(lines);
208              }
209              geometry = new MultiPolygon(polygons);
210              break;
211          }
212          case EwkbGeometryType.GeometryCollection:
213          {
214              await buf.Ensure(SizeOfLength, async);
215              var elements = new IGeometryObject[buf.ReadInt32(littleEndian)];
216              for (var i = 0; i < elements.Length; ++i)
217                  elements[i] = (IGeometryObject)await ReadGeometryCore(buf, async, boundingBox);
218              geometry = new GeometryCollection(elements);
219              break;
220          }
221          default:
222              throw UnknownPostGisType();
223          }
224          geometry.CRS = crs;
225          return geometry;
226      }
227      static Position ReadPosition(NpgsqlReadBuffer buf, EwkbGeometryType type, bool littleEndian)
228      {
229          var position = new Position(
230              longitude: buf.ReadDouble(littleEndian),
231              latitude: buf.ReadDouble(littleEndian),
232              altitude: HasZ(type) ? buf.ReadDouble() : (double?)null);
233          if (HasM(type)) buf.ReadDouble(littleEndian);
234          return position;
235      }
236      #endregion
237      #region Write
238      public override int ValidateAndGetLength(GeoJSONObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
239          => value.Type switch
240          {
241              GeoJSONObjectType.Point              => ValidateAndGetLength((Point)value, ref lengthCache, parameter),
242              GeoJSONObjectType.LineString         => ValidateAndGetLength((LineString)value, ref lengthCache, parameter),
243              GeoJSONObjectType.Polygon            => ValidateAndGetLength((Polygon)value, ref lengthCache, parameter),
244              GeoJSONObjectType.MultiPoint         => ValidateAndGetLength((MultiPoint)value, ref lengthCache, parameter),
245              GeoJSONObjectType.MultiLineString    => ValidateAndGetLength((MultiLineString)value, ref lengthCache, parameter),
246              GeoJSONObjectType.MultiPolygon       => ValidateAndGetLength((MultiPolygon)value, ref lengthCache, parameter),
247              GeoJSONObjectType.GeometryCollection => ValidateAndGetLength((GeometryCollection)value, ref lengthCache, parameter),
248              _                                    => throw UnknownPostGisType()
249          };
250      public int ValidateAndGetLength(Point value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
251      {
252          var length = SizeOfHeader + SizeOfPoint(HasZ(value.Coordinates));
253          if (GetSrid(value.CRS) != 0)
254              length += sizeof(int);
255          return length;
256      }
257      public int ValidateAndGetLength(LineString value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
258      {
259          var coordinates = value.Coordinates;
260          if (NotValid(coordinates, out var hasZ))
261              throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(LineString));
262          var length = SizeOfHeaderWithLength + coordinates.Count * SizeOfPoint(hasZ);
263          if (GetSrid(value.CRS) != 0)
264              length += sizeof(int);
265          return length;
266      }
267      public int ValidateAndGetLength(Polygon value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
268      {
269          var lines = value.Coordinates;
270          var length = SizeOfHeaderWithLength + SizeOfLength * lines.Count;
271          if (GetSrid(value.CRS) != 0)
272              length += sizeof(int);
273          var hasZ = false;
274          for (var i = 0; i < lines.Count; ++i)
275          {
276              var coordinates = lines[i].Coordinates;
277              if (NotValid(coordinates, out var lineHasZ))
278                  throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(Polygon));
279              if (hasZ != lineHasZ)
280              {
281                  if (i == 0) hasZ = lineHasZ;
282                  else throw AllOrNoneCoordiantesMustHaveZ(parameter, nameof(LineString));
283              }
284              length += coordinates.Count * SizeOfPoint(hasZ);
285          }
286          return length;
287      }
288      static bool NotValid(ReadOnlyCollection<IPosition> coordinates, out bool hasZ)
289      {
290          if (coordinates.Count == 0)
291              hasZ = false;
292          else
293          {
294              hasZ = HasZ(coordinates[0]);
295              for (var i = 1; i < coordinates.Count; ++i)
296                  if (HasZ(coordinates[i]) != hasZ) return true;
297          }
298          return false;
299      }
300      public int ValidateAndGetLength(MultiPoint value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
301      {
302          var length = SizeOfHeaderWithLength;
303          if (GetSrid(value.CRS) != 0)
304              length += sizeof(int);
305          var coordinates = value.Coordinates;
306          for (var i = 0; i < coordinates.Count; ++i)
307              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
308          return length;
309      }
310      public int ValidateAndGetLength(MultiLineString value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
311      {
312          var length = SizeOfHeaderWithLength;
313          if (GetSrid(value.CRS) != 0)
314              length += sizeof(int);
315          var coordinates = value.Coordinates;
316          for (var i = 0; i < coordinates.Count; ++i)
317              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
318          return length;
319      }
320      public int ValidateAndGetLength(MultiPolygon value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
321      {
322          var length = SizeOfHeaderWithLength;
323          if (GetSrid(value.CRS) != 0)
324              length += sizeof(int);
325          var coordinates = value.Coordinates;
326          for (var i = 0; i < coordinates.Count; ++i)
327              length += ValidateAndGetLength(coordinates[i], ref lengthCache, parameter);
328          return length;
329      }
330      public int ValidateAndGetLength(GeometryCollection value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
331      {
332          var length = SizeOfHeaderWithLength;
333          if (GetSrid(value.CRS) != 0)
334              length += sizeof(int);
335          var geometries = value.Geometries;
336          for (var i = 0; i < geometries.Count; ++i)
337              length += ValidateAndGetLength((GeoJSONObject)geometries[i], ref lengthCache, parameter);
338          return length;
339      }
340      int INpgsqlTypeHandler<IGeoJSONObject>.ValidateAndGetLength(IGeoJSONObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
341          => ValidateAndGetLength((GeoJSONObject)value, ref lengthCache, parameter);
342      int INpgsqlTypeHandler<IGeometryObject>.ValidateAndGetLength(IGeometryObject value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
343          => ValidateAndGetLength((GeoJSONObject)value, ref lengthCache, parameter);
344      public override Task Write(GeoJSONObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
345          => value.Type switch
346          {
347              GeoJSONObjectType.Point              => Write((Point)value, buf, lengthCache, parameter, async, cancellationToken),
348              GeoJSONObjectType.LineString         => Write((LineString)value, buf, lengthCache, parameter, async, cancellationToken),
349              GeoJSONObjectType.Polygon            => Write((Polygon)value, buf, lengthCache, parameter, async, cancellationToken),
350              GeoJSONObjectType.MultiPoint         => Write((MultiPoint)value, buf, lengthCache, parameter, async, cancellationToken),
351              GeoJSONObjectType.MultiLineString    => Write((MultiLineString)value, buf, lengthCache, parameter, async, cancellationToken),
352              GeoJSONObjectType.MultiPolygon       => Write((MultiPolygon)value, buf, lengthCache, parameter, async, cancellationToken),
353              GeoJSONObjectType.GeometryCollection => Write((GeometryCollection)value, buf, lengthCache, parameter, async, cancellationToken),
354              _                                    => throw UnknownPostGisType()
355          };
356      public async Task Write(Point value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
357      {
358          var type = EwkbGeometryType.Point;
359          var size = SizeOfHeader;
360          var srid = GetSrid(value.CRS);
361          if (srid != 0)
362          {
363              size += sizeof(int);
364              type |= EwkbGeometryType.HasSrid;
365          }
366          if (buf.WriteSpaceLeft < size)
367              await buf.Flush(async, cancellationToken);
368          buf.WriteByte(0); 
369          buf.WriteInt32((int)type);
370          if (srid != 0)
371              buf.WriteInt32(srid);
372          await WritePosition(value.Coordinates, buf, async, cancellationToken);
373      }
374      public async Task Write(LineString value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
375      {
376          var type = EwkbGeometryType.LineString;
377          var size = SizeOfHeaderWithLength;
378          var srid = GetSrid(value.CRS);
379          if (srid != 0)
380          {
381              size += sizeof(int);
382              type |= EwkbGeometryType.HasSrid;
383          }
384          if (buf.WriteSpaceLeft < size)
385              await buf.Flush(async, cancellationToken);
386          var coordinates = value.Coordinates;
387          buf.WriteByte(0); 
388          buf.WriteInt32((int)type);
389          buf.WriteInt32(coordinates.Count);
390          if (srid != 0)
391              buf.WriteInt32(srid);
392          for (var i = 0; i < coordinates.Count; ++i)
393              await WritePosition(coordinates[i], buf, async, cancellationToken);
394      }
395      public async Task Write(Polygon value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
396      {
397          var type = EwkbGeometryType.Polygon;
398          var size = SizeOfHeaderWithLength;
399          var srid = GetSrid(value.CRS);
400          if (srid != 0)
401          {
402              size += sizeof(int);
403              type |= EwkbGeometryType.HasSrid;
404          }
405          if (buf.WriteSpaceLeft < size)
406              await buf.Flush(async, cancellationToken);
407          var lines = value.Coordinates;
408          buf.WriteByte(0); 
409          buf.WriteInt32((int)type);
410          buf.WriteInt32(lines.Count);
411          if (srid != 0)
412              buf.WriteInt32(srid);
413          for (var i = 0; i < lines.Count; ++i)
414          {
415              if (buf.WriteSpaceLeft < SizeOfLength)
416                  await buf.Flush(async, cancellationToken);
417              var coordinates = lines[i].Coordinates;
418              buf.WriteInt32(coordinates.Count);
419              for (var j = 0; j < coordinates.Count; ++j)
420                  await WritePosition(coordinates[j], buf, async, cancellationToken);
421          }
422      }
423      public async Task Write(MultiPoint value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
424      {
425          var type = EwkbGeometryType.MultiPoint;
426          var size = SizeOfHeaderWithLength;
427          var srid = GetSrid(value.CRS);
428          if (srid != 0)
429          {
430              size += sizeof(int);
431              type |= EwkbGeometryType.HasSrid;
432          }
433          if (buf.WriteSpaceLeft < size)
434              await buf.Flush(async, cancellationToken);
435          var coordinates = value.Coordinates;
436          buf.WriteByte(0); 
437          buf.WriteInt32((int)type);
438          buf.WriteInt32(coordinates.Count);
439          if (srid != 0)
440              buf.WriteInt32(srid);
441          for (var i = 0; i < coordinates.Count; ++i)
442              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
443      }
444      public async Task Write(MultiLineString value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
445      {
446          var type = EwkbGeometryType.MultiLineString;
447          var size = SizeOfHeaderWithLength;
448          var srid = GetSrid(value.CRS);
449          if (srid != 0)
450          {
451              size += sizeof(int);
452              type |= EwkbGeometryType.HasSrid;
453          }
454          if (buf.WriteSpaceLeft < size)
455              await buf.Flush(async, cancellationToken);
456          var coordinates = value.Coordinates;
457          buf.WriteByte(0); 
458          buf.WriteInt32((int)type);
459          buf.WriteInt32(coordinates.Count);
460          if (srid != 0)
461              buf.WriteInt32(srid);
462          for (var i = 0; i < coordinates.Count; ++i)
463              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
464      }
465      public async Task Write(MultiPolygon value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
466      {
467          var type = EwkbGeometryType.MultiPolygon;
468          var size = SizeOfHeaderWithLength;
469          var srid = GetSrid(value.CRS);
470          if (srid != 0)
471          {
472              size += sizeof(int);
473              type |= EwkbGeometryType.HasSrid;
474          }
475          if (buf.WriteSpaceLeft < size)
476              await buf.Flush(async, cancellationToken);
477          var coordinates = value.Coordinates;
478          buf.WriteByte(0); 
479          buf.WriteInt32((int)type);
480          buf.WriteInt32(coordinates.Count);
481          if (srid != 0)
482              buf.WriteInt32(srid);
483          for (var i = 0; i < coordinates.Count; ++i)
484              await Write(coordinates[i], buf, lengthCache, parameter, async, cancellationToken);
485      }
486      public async Task Write(GeometryCollection value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
487      {
488          var type = EwkbGeometryType.GeometryCollection;
489          var size = SizeOfHeaderWithLength;
490          var srid = GetSrid(value.CRS);
491          if (srid != 0)
492          {
493              size += sizeof(int);
494              type |= EwkbGeometryType.HasSrid;
495          }
496          if (buf.WriteSpaceLeft < size)
497              await buf.Flush(async, cancellationToken);
498          var geometries = value.Geometries;
499          buf.WriteByte(0); 
500          buf.WriteInt32((int)type);
501          buf.WriteInt32(geometries.Count);
502          if (srid != 0)
503              buf.WriteInt32(srid);
504          for (var i = 0; i < geometries.Count; ++i)
505              await Write((GeoJSONObject) geometries[i], buf, lengthCache, parameter, async, cancellationToken);
506      }
507      Task INpgsqlTypeHandler<IGeoJSONObject>.Write(IGeoJSONObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
508          => Write((GeoJSONObject)value, buf, lengthCache, parameter, async, cancellationToken);
509      Task INpgsqlTypeHandler<IGeometryObject>.Write(IGeometryObject value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
510          => Write((GeoJSONObject)value, buf, lengthCache, parameter, async, cancellationToken);
511      static async Task WritePosition(IPosition coordinate, NpgsqlWriteBuffer buf, bool async, CancellationToken cancellationToken = default)
512      {
513          var altitude = coordinate.Altitude;
514          if (buf.WriteSpaceLeft < SizeOfPoint(altitude.HasValue))
515              await buf.Flush(async, cancellationToken);
516          buf.WriteDouble(coordinate.Longitude);
517          buf.WriteDouble(coordinate.Latitude);
518          if (altitude.HasValue)
519              buf.WriteDouble(altitude.Value);
520      }
521      #endregion
522      #region Crs
523      NamedCRS? GetCrs(int srid)
524      {
525          var crsType = CrsType;
526          if (crsType == GeoJSONOptions.None)
527              return null;
528  #if NETSTANDARD2_0
529          return _cachedCrs.GetOrAdd(srid, srid =>
530          {
531              var authority = _crsMap.GetAuthority(srid);
532              return authority is null
533                  ? throw new InvalidOperationException($"SRID {srid} unknown in spatial_ref_sys table")
534                  : new NamedCRS(crsType == GeoJSONOptions.LongCRS
535                      ? "urn:ogc:def:crs:" + authority + "::" + srid
536                      : authority + ":" + srid);
537          });
538  #else
539          return _cachedCrs.GetOrAdd(srid, static (srid, me) =>
540          {
541              var authority = me._crsMap.GetAuthority(srid);
542              return authority is null
543                  ? throw new InvalidOperationException($"SRID {srid} unknown in spatial_ref_sys table")
544                  : new NamedCRS(me.CrsType == GeoJSONOptions.LongCRS
545                      ? "urn:ogc:def:crs:" + authority + "::" + srid
546                      : authority + ":" + srid);
547          }, this);
548  #endif
549      }
550      static int GetSrid(ICRSObject crs)
551      {
552          if (crs == null || crs is UnspecifiedCRS)
553              return 0;
554          var namedCrs = crs as NamedCRS;
555          if (namedCrs == null)
556              throw new NotSupportedException("The LinkedCRS class isn't supported");
557          if (namedCrs.Properties.TryGetValue("name", out var value) && value != null)
558          {
559              var name = value.ToString()!;
560              if (string.Equals(name, "urn:ogc:def:crs:OGC::CRS84", StringComparison.Ordinal))
561                  return 4326;
562              var index = name.LastIndexOf(':');
563              if (index != -1 && int.TryParse(name.Substring(index + 1), out var srid))
564                  return srid;
565              throw new FormatException("The specified CRS isn't properly named");
566          }
567          return 0;
568      }
569      #endregion
570  }
571  [Flags]
572  enum EwkbGeometryType : uint
573  {
574      Point = 1,
575      LineString = 2,
576      Polygon = 3,
577      MultiPoint = 4,
578      MultiLineString = 5,
579      MultiPolygon = 6,
580      GeometryCollection = 7,
581      BaseType = Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection,
582      HasSrid = 0x20000000,
583      HasM = 0x40000000,
584      HasZ = 0x80000000
585  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CompositeHandler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GeoJSONHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>59          async ValueTask<T> ReadUsingMemberHandlers(NpgsqlReadBuffer buffer, bool async)
60          {
61              await buffer.Ensure(sizeof(int), async);
</pre></code></div>
                <div class="column column_space"><pre><code>86      async ValueTask<GeoJSONObject> ReadGeometry(NpgsqlReadBuffer buf, bool async)
87      {
88          var boundingBox = BoundingBox ? new BoundingBoxBuilder() : null;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    