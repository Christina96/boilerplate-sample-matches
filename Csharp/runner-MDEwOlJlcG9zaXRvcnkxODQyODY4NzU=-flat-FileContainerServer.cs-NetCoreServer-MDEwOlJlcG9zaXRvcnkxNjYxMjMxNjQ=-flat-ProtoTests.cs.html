
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.556313993174061%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-FileContainerServer.cs</h3>
            <pre><code>1  using GitHub.Services.FileContainer.Client;
2  using System;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.IO;
6  using System.Linq;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using System.Diagnostics;
10  using GitHub.Services.WebApi;
11  using System.Net.Http;
12  using System.Net;
13  using GitHub.Runner.Sdk;
14  using GitHub.Services.FileContainer;
15  using GitHub.Services.Common;
16  namespace GitHub.Runner.Plugins.Artifact
17  {
18      public class FileContainerServer
19      {
20          private const int _defaultFileStreamBufferSize = 4096;
21          private const int _defaultCopyBufferSize = 81920;
22          private readonly ConcurrentQueue<string> _fileUploadQueue = new();
23          private readonly ConcurrentQueue<DownloadInfo> _fileDownloadQueue = new();
24          private readonly ConcurrentDictionary<string, ConcurrentQueue<string>> _fileUploadTraceLog = new();
25          private readonly ConcurrentDictionary<string, ConcurrentQueue<string>> _fileUploadProgressLog = new();
26          private readonly FileContainerHttpClient _fileContainerHttpClient;
27          private CancellationTokenSource _uploadCancellationTokenSource;
28          private CancellationTokenSource _downloadCancellationTokenSource;
29          private TaskCompletionSource<int> _uploadFinished;
30          private TaskCompletionSource<int> _downloadFinished;
31          private Guid _projectId;
32          private long _containerId;
33          private string _containerPath;
34          private int _uploadFilesProcessed = 0;
35          private int _downloadFilesProcessed = 0;
36          private string _sourceParentDirectory;
37          public FileContainerServer(
38              VssConnection connection,
39              Guid projectId,
40              long containerId,
41              string containerPath)
42          {
43              _projectId = projectId;
44              _containerId = containerId;
45              _containerPath = containerPath;
46              var fileContainerClientConnectionSetting = connection.Settings.Clone();
47              if (fileContainerClientConnectionSetting.SendTimeout < TimeSpan.FromSeconds(600))
48              {
49                  fileContainerClientConnectionSetting.SendTimeout = TimeSpan.FromSeconds(600);
50              }
51              var fileContainerClientConnection = new VssConnection(connection.Uri, connection.Credentials, fileContainerClientConnectionSetting);
52              _fileContainerHttpClient = fileContainerClientConnection.GetClient<FileContainerHttpClient>();
53          }
54          public async Task DownloadFromContainerAsync(
55              RunnerActionPluginExecutionContext context,
56              String destination,
57              CancellationToken cancellationToken)
58          {
59              List<FileContainerItem> containerItems = new();
60              int retryCount = 0;
61              while (retryCount < 3)
62              {
63                  try
64                  {
65                      containerItems = await _fileContainerHttpClient.QueryContainerItemsAsync(_containerId,
66                                                                                               _projectId,
67                                                                                               _containerPath,
68                                                                                               cancellationToken: cancellationToken);
69                      break;
70                  }
71                  catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
72                  {
73                      context.Debug($"Container query has been cancelled.");
74                      throw;
75                  }
76                  catch (Exception ex) when (retryCount < 2)
77                  {
78                      retryCount++;
79                      context.Warning($"Fail to query container items under #/{_containerId}/{_containerPath}, Error: {ex.Message}");
80                      context.Debug(ex.ToString());
81                  }
82                  var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(15));
83                  context.Warning($"Back off {backOff.TotalSeconds} seconds before retry.");
84                  await Task.Delay(backOff);
85              }
86              if (containerItems.Count == 0)
87              {
88                  context.Output($"There is nothing under #/{_containerId}/{_containerPath}");
89                  return;
90              }
91              int foldersCreated = 0;
92              int emptryFilesCreated = 0;
93              List<DownloadInfo> downloadFiles = new();
94              foreach (var item in containerItems.OrderBy(x => x.Path))
95              {
96                  if (!item.Path.StartsWith(_containerPath, StringComparison.OrdinalIgnoreCase))
97                  {
98                      throw new ArgumentOutOfRangeException($"Item {item.Path} is not under #/{_containerId}/{_containerPath}");
99                  }
100                  var localRelativePath = item.Path.Substring(_containerPath.Length).TrimStart('/');
101                  var localPath = Path.Combine(destination, localRelativePath);
102                  if (item.ItemType == ContainerItemType.Folder)
103                  {
104                      context.Debug($"Ensure folder exists: {localPath}");
105                      Directory.CreateDirectory(localPath);
106                      foldersCreated++;
107                  }
108                  else if (item.ItemType == ContainerItemType.File)
109                  {
110                      if (item.FileLength == 0)
111                      {
112                          context.Debug($"Create empty file at: {localPath}");
113                          var parentDirectory = Path.GetDirectoryName(localPath);
114                          Directory.CreateDirectory(parentDirectory);
115                          IOUtil.DeleteFile(localPath);
116                          using (new FileStream(localPath, FileMode.Create))
117                          {
118                          }
119                          emptryFilesCreated++;
120                      }
121                      else
122                      {
123                          context.Debug($"Prepare download {item.Path} to {localPath}");
124                          downloadFiles.Add(new DownloadInfo(item.Path, localPath));
125                      }
126                  }
127                  else
128                  {
129                      throw new NotSupportedException(item.ItemType.ToString());
130                  }
131              }
132              if (foldersCreated > 0)
133              {
134                  context.Output($"{foldersCreated} folders created.");
135              }
136              if (emptryFilesCreated > 0)
137              {
138                  context.Output($"{emptryFilesCreated} empty files created.");
139              }
140              if (downloadFiles.Count == 0)
141              {
142                  context.Output($"There is nothing to download");
143                  return;
144              }
145              using (_downloadCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
146              {
147                  DownloadResult downloadResult = await ParallelDownloadAsync(context, downloadFiles.AsReadOnly(), Math.Min(downloadFiles.Count, Environment.ProcessorCount), _downloadCancellationTokenSource.Token);
148                  if (downloadResult.FailedFiles.Count == 0)
149                  {
150                      context.Output($"{downloadFiles.Count} files download succeed.");
151                      return;
152                  }
153                  else
154                  {
155                      context.Output($"{downloadResult.FailedFiles.Count} files failed to download, retry these files after a minute.");
156                  }
157                  for (int timer = 60; timer > 0; timer -= 5)
158                  {
159                      context.Output($"Retry file download after {timer} seconds.");
160                      await Task.Delay(TimeSpan.FromSeconds(5), _uploadCancellationTokenSource.Token);
161                  }
162                  context.Output($"Start retry {downloadResult.FailedFiles.Count} failed files upload.");
163                  DownloadResult retryDownloadResult = await ParallelDownloadAsync(context, downloadResult.FailedFiles.AsReadOnly(), Math.Min(downloadResult.FailedFiles.Count, Environment.ProcessorCount), _downloadCancellationTokenSource.Token);
164                  if (retryDownloadResult.FailedFiles.Count == 0)
165                  {
166                      context.Output($"{downloadResult.FailedFiles} files download succeed after retry.");
167                      return;
168                  }
169                  else
170                  {
171                      throw new Exception($"{retryDownloadResult.FailedFiles.Count} files failed to download even after retry.");
172                  }
173              }
174          }
175          public async Task<long> CopyToContainerAsync(
176              RunnerActionPluginExecutionContext context,
177              String source,
178              CancellationToken cancellationToken)
179          {
180              int maxConcurrentUploads = Math.Min(Environment.ProcessorCount, 2);
181              List<String> files;
182              if (File.Exists(source))
183              {
184                  files = new List<String>() { source };
185                  _sourceParentDirectory = Path.GetDirectoryName(source);
186              }
187              else
188              {
189                  files = Directory.EnumerateFiles(source, "*", SearchOption.AllDirectories).ToList();
190                  _sourceParentDirectory = source.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
191              }
192              context.Output($"Uploading {files.Count()} files");
193              using (_uploadCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
194              {
195                  _fileContainerHttpClient.UploadFileReportTrace += UploadFileTraceReportReceived;
196                  _fileContainerHttpClient.UploadFileReportProgress += UploadFileProgressReportReceived;
197                  try
198                  {
199                      UploadResult uploadResult = await ParallelUploadAsync(context, files, maxConcurrentUploads, _uploadCancellationTokenSource.Token);
200                      if (uploadResult.RetryFiles.Count == 0)
201                      {
202                          context.Output("File upload complete.");
203                          return uploadResult.TotalFileSizeUploaded;
204                      }
205                      else
206                      {
207                          context.Output($"{uploadResult.RetryFiles.Count} files failed to upload, retry these files after a minute.");
208                      }
209                      for (int timer = 60; timer > 0; timer -= 5)
210                      {
211                          context.Output($"Retry file upload after {timer} seconds.");
212                          await Task.Delay(TimeSpan.FromSeconds(5), _uploadCancellationTokenSource.Token);
213                      }
214                      context.Output($"Start retry {uploadResult.RetryFiles.Count} failed files upload.");
215                      UploadResult retryUploadResult = await ParallelUploadAsync(context, uploadResult.RetryFiles, maxConcurrentUploads, _uploadCancellationTokenSource.Token);
216                      if (retryUploadResult.RetryFiles.Count == 0)
217                      {
218                          context.Output("File upload complete after retry.");
219                          return uploadResult.TotalFileSizeUploaded + retryUploadResult.TotalFileSizeUploaded;
220                      }
221                      else
222                      {
223                          throw new Exception("File upload failed even after retry.");
224                      }
225                  }
226                  finally
227                  {
228                      _fileContainerHttpClient.UploadFileReportTrace -= UploadFileTraceReportReceived;
229                      _fileContainerHttpClient.UploadFileReportProgress -= UploadFileProgressReportReceived;
230                  }
231              }
232          }
233          private async Task<DownloadResult> ParallelDownloadAsync(RunnerActionPluginExecutionContext context, IReadOnlyList<DownloadInfo> files, int concurrentDownloads, CancellationToken token)
234          {
235              var downloadResult = new DownloadResult();
236              if (files.Count == 0)
237              {
238                  return downloadResult;
239              }
240              if (!_fileDownloadQueue.IsEmpty)
241              {
242                  throw new ArgumentOutOfRangeException(nameof(_fileDownloadQueue));
243              }
244              foreach (var file in files)
245              {
246                  _fileDownloadQueue.Enqueue(file);
247              }
248              _downloadFilesProcessed = 0;
249              _downloadFinished = new TaskCompletionSource<int>();
250              Task downloadMonitor = DownloadReportingAsync(context, files.Count(), token);
251              List<Task<DownloadResult>> parallelDownloadingTasks = new();
252              for (int downloader = 0; downloader < concurrentDownloads; downloader++)
253              {
254                  parallelDownloadingTasks.Add(DownloadAsync(context, downloader, token));
255              }
256              await Task.WhenAll(parallelDownloadingTasks);
257              foreach (var downloadTask in parallelDownloadingTasks)
258              {
259                  downloadResult.AddDownloadResult(await downloadTask);
260              }
261              _downloadFinished.TrySetResult(0);
262              await downloadMonitor;
263              return downloadResult;
264          }
265          private async Task<UploadResult> ParallelUploadAsync(RunnerActionPluginExecutionContext context, IReadOnlyList<string> files, int concurrentUploads, CancellationToken token)
266          {
267              var uploadResult = new UploadResult();
268              if (files.Count == 0)
269              {
270                  return uploadResult;
271              }
272              if (!_fileUploadQueue.IsEmpty)
273              {
274                  throw new ArgumentOutOfRangeException(nameof(_fileUploadQueue));
275              }
276              foreach (var file in files)
277              {
278                  _fileUploadQueue.Enqueue(file);
279              }
280              _uploadFilesProcessed = 0;
281              _uploadFinished = new TaskCompletionSource<int>();
282              _fileUploadTraceLog.Clear();
283              _fileUploadProgressLog.Clear();
284              Task uploadMonitor = UploadReportingAsync(context, files.Count(), _uploadCancellationTokenSource.Token);
285              List<Task<UploadResult>> parallelUploadingTasks = new();
286              for (int uploader = 0; uploader < concurrentUploads; uploader++)
287              {
288                  parallelUploadingTasks.Add(UploadAsync(context, uploader, _uploadCancellationTokenSource.Token));
289              }
290              await Task.WhenAll(parallelUploadingTasks);
291              foreach (var uploadTask in parallelUploadingTasks)
292              {
293                  uploadResult.AddUploadResult(await uploadTask);
294              }
295              _uploadFinished.TrySetResult(0);
296              await uploadMonitor;
297              return uploadResult;
298          }
299          private async Task<DownloadResult> DownloadAsync(RunnerActionPluginExecutionContext context, int downloaderId, CancellationToken token)
300          {
301              List<DownloadInfo> failedFiles = new();
302              Stopwatch downloadTimer = new();
303              while (_fileDownloadQueue.TryDequeue(out DownloadInfo fileToDownload))
304              {
305                  token.ThrowIfCancellationRequested();
306                  try
307                  {
308                      int retryCount = 0;
309                      bool downloadFailed = false;
310                      while (true)
311                      {
312                          try
313                          {
314                              context.Debug($"Start downloading file: '{fileToDownload.ItemPath}' (Downloader {downloaderId})");
315                              downloadTimer.Restart();
316                              using (FileStream fs = new(fileToDownload.LocalPath, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: _defaultFileStreamBufferSize, useAsync: true))
317                              using (var downloadStream = await _fileContainerHttpClient.DownloadFileAsync(_containerId, fileToDownload.ItemPath, token, _projectId))
318                              {
319                                  await downloadStream.CopyToAsync(fs, _defaultCopyBufferSize, token);
320                                  await fs.FlushAsync(token);
321                                  downloadTimer.Stop();
322                                  context.Debug($"File: '{fileToDownload.LocalPath}' took {downloadTimer.ElapsedMilliseconds} milliseconds to finish download (Downloader {downloaderId})");
323                                  break;
324                              }
325                          }
326                          catch (OperationCanceledException) when (token.IsCancellationRequested)
327                          {
328                              context.Debug($"Download has been cancelled while downloading {fileToDownload.ItemPath}. (Downloader {downloaderId})");
329                              throw;
330                          }
331                          catch (Exception ex)
332                          {
333                              retryCount++;
334                              context.Warning($"Fail to download '{fileToDownload.ItemPath}', error: {ex.Message} (Downloader {downloaderId})");
335                              context.Debug(ex.ToString());
336                          }
337                          if (retryCount < 3)
338                          {
339                              var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
340                              context.Warning($"Back off {backOff.TotalSeconds} seconds before retry. (Downloader {downloaderId})");
341                              await Task.Delay(backOff);
342                          }
343                          else
344                          {
345                              downloadFailed = true;
346                              break;
347                          }
348                      }
349                      if (downloadFailed)
350                      {
351                          failedFiles.Add(fileToDownload);
352                      }
353                      Interlocked.Increment(ref _downloadFilesProcessed);
354                  }
355                  catch (Exception ex)
356                  {
357                      context.Error($"Error '{ex.Message}' when downloading file '{fileToDownload}'. (Downloader {downloaderId})");
358                      throw;
359                  }
360              }
361              return new DownloadResult(failedFiles);
362          }
363          private async Task<UploadResult> UploadAsync(RunnerActionPluginExecutionContext context, int uploaderId, CancellationToken token)
364          {
365              List<string> failedFiles = new();
366              long uploadedSize = 0;
367              string fileToUpload;
368              Stopwatch uploadTimer = new();
369              while (_fileUploadQueue.TryDequeue(out fileToUpload))
370              {
371                  token.ThrowIfCancellationRequested();
372                  try
373                  {
374                      using (FileStream fs = File.Open(fileToUpload, FileMode.Open, FileAccess.Read, FileShare.Read))
375                      {
376                          string itemPath = (_containerPath.TrimEnd('/') + "/" + fileToUpload.Remove(0, _sourceParentDirectory.Length + 1)).Replace('\\', '/');
377                          bool failAndExit = false;
378                          try
379                          {
380                              uploadTimer.Restart();
381                              using (HttpResponseMessage response = await _fileContainerHttpClient.UploadFileAsync(_containerId, itemPath, fs, _projectId, cancellationToken: token))
382                              {
383                                  if (response == null || response.StatusCode != HttpStatusCode.Created)
384                                  {
385                                      context.Output($"Unable to copy file to server StatusCode={response?.StatusCode}: {response?.ReasonPhrase}. Source file path: {fileToUpload}. Target server path: {itemPath}");
386                                      if (response?.StatusCode == HttpStatusCode.Conflict)
387                                      {
388                                          context.Error($"Error '{fileToUpload}' has already been uploaded.");
389                                      }
390                                      else if (_fileContainerHttpClient.IsFastFailResponse(response))
391                                      {
392                                          context.Output($"Cannot continue uploading files, so draining upload queue of {_fileUploadQueue.Count} items.");
393                                          DrainUploadQueue(context);
394                                          failedFiles.Clear();
395                                          failAndExit = true;
396                                          throw new UploadFailedException($"Critical failure uploading '{fileToUpload}'");
397                                      }
398                                      else
399                                      {
400                                          context.Debug($"Adding '{fileToUpload}' to retry list.");
401                                          failedFiles.Add(fileToUpload);
402                                      }
403                                      throw new UploadFailedException($"Http failure response '{response?.StatusCode}': '{response?.ReasonPhrase}' while uploading '{fileToUpload}'");
404                                  }
405                                  uploadTimer.Stop();
406                                  context.Debug($"File: '{fileToUpload}' took {uploadTimer.ElapsedMilliseconds} milliseconds to finish upload");
407                                  uploadedSize += fs.Length;
408                                  OutputLogForFile(context, fileToUpload, $"Detail upload trace for file: {itemPath}", context.Debug);
409                              }
410                          }
411                          catch (OperationCanceledException) when (token.IsCancellationRequested)
412                          {
413                              context.Output($"File upload has been cancelled during upload file: '{fileToUpload}'.");
414                              throw;
415                          }
416                          catch (Exception ex)
417                          {
418                              context.Output($"Fail to upload '{fileToUpload}' due to '{ex.Message}'.");
419                              context.Output(ex.ToString());
420                              OutputLogForFile(context, fileToUpload, $"Detail upload trace for file that fail to upload: {itemPath}", context.Output);
421                              if (failAndExit)
422                              {
423                                  context.Debug("Exiting upload.");
424                                  throw;
425                              }
426                          }
427                      }
428                      Interlocked.Increment(ref _uploadFilesProcessed);
429                  }
430                  catch (Exception ex)
431                  {
432                      context.Output($"File error '{ex.Message}' when uploading file '{fileToUpload}'.");
433                      throw;
434                  }
435              }
436              return new UploadResult(failedFiles, uploadedSize);
437          }
438          private async Task UploadReportingAsync(RunnerActionPluginExecutionContext context, int totalFiles, CancellationToken token)
439          {
440              int traceInterval = 0;
441              while (!_uploadFinished.Task.IsCompleted && !token.IsCancellationRequested)
442              {
443                  bool hasDetailProgress = false;
444                  foreach (var file in _fileUploadProgressLog)
445                  {
446                      string message;
447                      while (file.Value.TryDequeue(out message))
448                      {
449                          hasDetailProgress = true;
450                          context.Output(message);
451                      }
452                  }
453                  if (++traceInterval % 2 == 0 && !hasDetailProgress)
454                  {
455                      context.Output($"Total file: {totalFiles} ---- Processed file: {_uploadFilesProcessed} ({(_uploadFilesProcessed * 100) / totalFiles}%)");
456                  }
457                  await Task.WhenAny(_uploadFinished.Task, Task.Delay(5000, token));
458              }
459          }
460          private async Task DownloadReportingAsync(RunnerActionPluginExecutionContext context, int totalFiles, CancellationToken token)
461          {
462              int traceInterval = 0;
463              while (!_downloadFinished.Task.IsCompleted && !token.IsCancellationRequested)
464              {
465                  if (++traceInterval % 2 == 0)
466                  {
467                      context.Output($"Total file: {totalFiles} ---- Downloaded file: {_downloadFilesProcessed} ({(_downloadFilesProcessed * 100) / totalFiles}%)");
468                  }
469                  await Task.WhenAny(_downloadFinished.Task, Task.Delay(5000, token));
470              }
471          }
472          private void DrainUploadQueue(RunnerActionPluginExecutionContext context)
473          {
474              while (_fileUploadQueue.TryDequeue(out string fileToUpload))
475              {
476                  context.Debug($"Clearing upload queue: '{fileToUpload}'");
477                  Interlocked.Increment(ref _uploadFilesProcessed);
478              }
479          }
480          private void OutputLogForFile(RunnerActionPluginExecutionContext context, string itemPath, string logDescription, Action<string> log)
481          {
482              ConcurrentQueue<string> logQueue;
483              if (_fileUploadTraceLog.TryGetValue(itemPath, out logQueue))
484              {
485                  log(logDescription);
486                  string message;
487                  while (logQueue.TryDequeue(out message))
488                  {
489                      log(message);
490                  }
491              }
492          }
493          private void UploadFileTraceReportReceived(object sender, ReportTraceEventArgs e)
494          {
495              ConcurrentQueue<string> logQueue = _fileUploadTraceLog.GetOrAdd(e.File, new ConcurrentQueue<string>());
496              logQueue.Enqueue(e.Message);
497          }
498          private void UploadFileProgressReportReceived(object sender, ReportProgressEventArgs e)
499          {
500              ConcurrentQueue<string> progressQueue = _fileUploadProgressLog.GetOrAdd(e.File, new ConcurrentQueue<string>());
501              progressQueue.Enqueue($"Uploading '{e.File}' ({(e.CurrentChunk * 100) / e.TotalChunks}%)");
502          }
503      }
504      public class UploadResult
505      {
506          public UploadResult()
507          {
508              RetryFiles = new List<string>();
509              TotalFileSizeUploaded = 0;
510          }
511          public UploadResult(List<string> retryFiles, long totalFileSizeUploaded)
512          {
513              RetryFiles = retryFiles ?? new List<string>();
514              TotalFileSizeUploaded = totalFileSizeUploaded;
515          }
516          public List<string> RetryFiles { get; set; }
517          public long TotalFileSizeUploaded { get; set; }
518          public void AddUploadResult(UploadResult resultToAdd)
519          {
520              this.RetryFiles.AddRange(resultToAdd.RetryFiles);
521              this.TotalFileSizeUploaded += resultToAdd.TotalFileSizeUploaded;
522          }
523      }
524      public class DownloadInfo
525      {
526          public DownloadInfo(string itemPath, string localPath)
527          {
528              this.ItemPath = itemPath;
529              this.LocalPath = localPath;
530          }
<span onclick='openModal()' class='match'>531          public string ItemPath { get; set; }
532          public string LocalPath { get; set; }
</span>533      }
534      public class DownloadResult
535      {
536          public DownloadResult()
537          {
538              FailedFiles = new List<DownloadInfo>();
539          }
540          public DownloadResult(List<DownloadInfo> failedFiles)
541          {
542              FailedFiles = failedFiles;
543          }
544          public List<DownloadInfo> FailedFiles { get; set; }
545          public void AddDownloadResult(DownloadResult resultToAdd)
546          {
547              this.FailedFiles.AddRange(resultToAdd.FailedFiles);
548          }
549      }
550      public class UploadFailedException : Exception
551      {
552          public UploadFailedException()
553              : base()
554          { }
555          public UploadFailedException(string message)
556              : base(message)
557          { }
558          public UploadFailedException(string message, Exception inner)
559              : base(message, inner)
560          { }
561      }
562  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-ProtoTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Net;
4  using System.Net.Sockets;
5  using System.Threading;
6  using NetCoreServer;
7  using Xunit;
8  using com.chronoxor.simple;
9  using com.chronoxor.simple.FBE;
10  namespace tests
11  {
12      class TcpProtoClient : NetCoreServer.TcpClient
13      {
14          public bool Conected { get; set; }
15          public bool Disconected { get; set; }
16          public bool Errors { get; set; }
17          public TcpProtoClient(string address, int port) : base(address, port) {}
18          public delegate void ConnectedHandler();
19          public event ConnectedHandler Connected = () => {};
20          protected override void OnConnected()
21          {
22              Conected = true;
23              Connected?.Invoke();
24          }
25          public delegate void DisconnectedHandler();
26          public event DisconnectedHandler Disconnected = () => {};
27          protected override void OnDisconnected()
28          {
29              Disconected = true;
30              Disconnected?.Invoke();
31          }
32          public delegate void ReceivedHandler(byte[] buffer, long offset, long size);
33          public event ReceivedHandler Received = (buffer, offset, size) => {};
34          protected override void OnReceived(byte[] buffer, long offset, long size)
35          {
36              Received?.Invoke(buffer, offset, size);
37          }
38          protected override void OnError(SocketError error) { Errors = true; }
39      }
40      class ProtoClient : Client, ISenderListener, IReceiverListener, IDisposable
41      {
42          private readonly TcpProtoClient _tcpProtoClient;
43          public Guid Id => _tcpProtoClient.Id;
44          public bool IsConnected => _tcpProtoClient.IsConnected;
45          public TcpProtoClient TcpClient => _tcpProtoClient;
46          public ProtoClient(string address, int port)
47          {
48              _tcpProtoClient = new TcpProtoClient(address, port);
49              _tcpProtoClient.Connected += OnConnected;
50              _tcpProtoClient.Disconnected += OnDisconnected;
51              _tcpProtoClient.Received += OnReceived;
52              ReceivedResponse_DisconnectRequest += HandleDisconnectRequest;
53              ReceivedResponse_SimpleResponse += HandleSimpleResponse;
54              ReceivedResponse_SimpleReject += HandleSimpleReject;
55              ReceivedResponse_SimpleNotify += HandleSimpleNotify;
56          }
57          private void DisposeClient()
58          {
59              _tcpProtoClient.Connected -= OnConnected;
60              _tcpProtoClient.Connected -= OnDisconnected;
61              _tcpProtoClient.Received -= OnReceived;
62              ReceivedResponse_DisconnectRequest -= HandleDisconnectRequest;
63              ReceivedResponse_SimpleResponse -= HandleSimpleResponse;
64              ReceivedResponse_SimpleReject -= HandleSimpleReject;
65              ReceivedResponse_SimpleNotify -= HandleSimpleNotify;
66              _tcpProtoClient.Dispose();
67          }
68          public bool ConnectAsync() { return _tcpProtoClient.ConnectAsync(); }
69          public bool DisconnectAsync() { return _tcpProtoClient.DisconnectAsync(); }
70          public bool ReconnectAsync() { return _tcpProtoClient.ReconnectAsync(); }
71          #region Connection handlers
72          public delegate void ConnectedHandler();
73          public event ConnectedHandler Connected = () => {};
74          private void OnConnected()
75          {
76              Reset();
77              Connected?.Invoke();
78          }
79          public delegate void DisconnectedHandler();
80          public event DisconnectedHandler Disconnected = () => {};
81          private void OnDisconnected()
82          {
83              Disconnected?.Invoke();
84          }
85          public long OnSend(byte[] buffer, long offset, long size)
86          {
87              return _tcpProtoClient.SendAsync(buffer, offset, size) ? size : 0;
88          }
89          public void OnReceived(byte[] buffer, long offset, long size)
90          {
91              Receive(buffer, offset, size);
92          }
93          #endregion
94          #region Protocol handlers
95          private void HandleDisconnectRequest(DisconnectRequest request) { _tcpProtoClient.DisconnectAsync(); }
96          private void HandleSimpleResponse(SimpleResponse response) {}
97          private void HandleSimpleReject(SimpleReject reject) {}
98          private void HandleSimpleNotify(SimpleNotify notify) {}
99          #endregion
100          #region IDisposable implementation
101          private bool _disposed;
102          public void Dispose()
103          {
104              Dispose(true);
105              GC.SuppressFinalize(this);
106          }
107          protected virtual void Dispose(bool disposingManagedResources)
108          {
109              if (!_disposed)
110              {
111                  if (disposingManagedResources)
112                  {
113                      DisposeClient();
114                  }
115                  _disposed = true;
116              }
117          }
118          #endregion
119      }
120      class ProtoSessionSender : Sender, ISenderListener
121      {
122          public ProtoSession Session { get; }
123          public ProtoSessionSender(ProtoSession session) { Session = session; }
124          public long OnSend(byte[] buffer, long offset, long size)
125          {
126              return Session.SendAsync(buffer, offset, size) ? size : 0;
127          }
128      }
129      class ProtoSessionReceiver : Receiver, IReceiverListener
130      {
131          public ProtoSession Session { get; }
132          public ProtoSessionReceiver(ProtoSession session) { Session = session; }
133          public void OnReceive(SimpleRequest request) { Session.OnReceive(request); }
134      }
135      class ProtoSession : TcpSession
136      {
137          public ProtoSessionSender Sender { get; }
138          public ProtoSessionReceiver Receiver { get; }
139          public ProtoSession(TcpServer server) : base(server)
140          {
141              Sender = new ProtoSessionSender(this);
142              Receiver = new ProtoSessionReceiver(this);
143          }
144          protected override void OnReceived(byte[] buffer, long offset, long size)
145          {
146              Receiver.Receive(buffer, offset, size);
147          }
148          public void OnReceive(SimpleRequest request)
149          {
150              SimpleResponse response = SimpleResponse.Default;
151              response.id = request.id;
152              response.Hash = 0;
153              response.Length = (uint)request.Message.Length;
154              Sender.Send(response);
155          }
156      }
157      class ProtoSender : Sender, ISenderListener
158      {
159          public ProtoServer Server { get; }
160          public ProtoSender(ProtoServer server) { Server = server; }
161          public long OnSend(byte[] buffer, long offset, long size)
162          {
163              Server.Multicast(buffer, offset, size);
164              return size;
165          }
166      }
167      class ProtoServer : TcpServer
168      {
<span onclick='openModal()' class='match'>169          public bool Started { get; set; }
170          public bool Stopped { get; set; }
</span>171          public bool Connected { get; set; }
172          public bool Disconnected { get; set; }
173          public int Clients { get; set; }
174          public bool Errors { get; set; }
175          public ProtoSender Sender { get; }
176          public ProtoServer(IPAddress address, int port) : base(address, port)
177          {
178              Sender = new ProtoSender(this);
179          }
180          protected override TcpSession CreateSession() { return new ProtoSession(this); }
181          protected override void OnStarted() { Started = true; }
182          protected override void OnStopped() { Stopped = true; }
183          protected override void OnConnected(TcpSession session) { Connected = true; Clients++; }
184          protected override void OnDisconnected(TcpSession session) { Disconnected = true; Clients--; }
185          protected override void OnError(SocketError error) { Errors = true; }
186      }
187      public class ProtoTests
188      {
189          [Fact(DisplayName = "Protocol server test")]
190          public void ProtoServerTest()
191          {
192              string address = "127.0.0.1";
193              int port = 4444;
194              var server = new ProtoServer(IPAddress.Any, port);
195              Assert.True(server.Start());
196              while (!server.IsStarted)
197                  Thread.Yield();
198              var client = new ProtoClient(address, port);
199              Assert.True(client.ConnectAsync());
200              while (!client.IsConnected || (server.Clients != 1))
201                  Thread.Yield();
202              SimpleRequest request = SimpleRequest.Default;
203              request.Message = "test";
204              var response = client.Request(request).Result;
205              Assert.Equal(request.id, response.id);
206              Assert.Equal(0u, response.Hash);
207              Assert.Equal(4u, response.Length);
208              Assert.True(client.DisconnectAsync());
209              while (client.IsConnected || (server.Clients != 0))
210                  Thread.Yield();
211              Assert.True(server.Stop());
212              while (server.IsStarted)
213                  Thread.Yield();
214              Assert.True(server.Started);
215              Assert.True(server.Stopped);
216              Assert.True(server.Connected);
217              Assert.True(server.Disconnected);
218              Assert.True(server.BytesSent > 0);
219              Assert.True(server.BytesReceived > 0);
220              Assert.True(!server.Errors);
221              Assert.True(client.TcpClient.Conected);
222              Assert.True(client.TcpClient.Disconected);
223              Assert.True(client.TcpClient.BytesSent > 0);
224              Assert.True(client.TcpClient.BytesReceived > 0);
225              Assert.True(!client.TcpClient.Errors);
226          }
227          [Fact(DisplayName = "Protocol multicast test")]
228          public void ProtoServerMulticastTest()
229          {
230              string address = "127.0.0.1";
231              int port = 4442;
232              var server = new ProtoServer(IPAddress.Any, port);
233              Assert.True(server.Start());
234              while (!server.IsStarted)
235                  Thread.Yield();
236              var client1 = new ProtoClient(address, port);
237              Assert.True(client1.ConnectAsync());
238              while (!client1.IsConnected || (server.Clients != 1))
239                  Thread.Yield();
240              SimpleNotify notify = SimpleNotify.Default;
241              notify.Notification = "test";
242              server.Sender.Send(notify);
243              while (client1.TcpClient.BytesReceived == 0)
244                  Thread.Yield();
245              var client2 = new ProtoClient(address, port);
246              Assert.True(client2.ConnectAsync());
247              while (!client2.IsConnected || (server.Clients != 2))
248                  Thread.Yield();
249              server.Sender.Send(notify);
250              while (client2.TcpClient.BytesReceived == 0)
251                  Thread.Yield();
252              var client3 = new ProtoClient(address, port);
253              Assert.True(client3.ConnectAsync());
254              while (!client3.IsConnected || (server.Clients != 3))
255                  Thread.Yield();
256              server.Sender.Send(notify);
257              while (client3.TcpClient.BytesReceived == 0)
258                  Thread.Yield();
259              Assert.True(client1.DisconnectAsync());
260              while (client1.IsConnected || (server.Clients != 2))
261                  Thread.Yield();
262              Assert.True(client2.DisconnectAsync());
263              while (client2.IsConnected || (server.Clients != 1))
264                  Thread.Yield();
265              Assert.True(client3.DisconnectAsync());
266              while (client3.IsConnected || (server.Clients != 0))
267                  Thread.Yield();
268              Assert.True(server.Stop());
269              while (server.IsStarted)
270                  Thread.Yield();
271              Assert.True(server.Started);
272              Assert.True(server.Stopped);
273              Assert.True(server.Connected);
274              Assert.True(server.Disconnected);
275              Assert.True(server.BytesSent > 0);
276              Assert.True(server.BytesReceived == 0);
277              Assert.True(!server.Errors);
278              Assert.True(client1.TcpClient.BytesSent == 0);
279              Assert.True(client2.TcpClient.BytesSent == 0);
280              Assert.True(client3.TcpClient.BytesSent == 0);
281              Assert.True(client1.TcpClient.BytesReceived > 0);
282              Assert.True(client2.TcpClient.BytesReceived > 0);
283              Assert.True(client3.TcpClient.BytesReceived > 0);
284              Assert.True(!client1.TcpClient.Errors);
285              Assert.True(!client2.TcpClient.Errors);
286              Assert.True(!client3.TcpClient.Errors);
287          }
288          [Fact(DisplayName = "Protocol server random test")]
289          public void TcpServerRandomTest()
290          {
291              string address = "127.0.0.1";
292              int port = 4443;
293              var server = new ProtoServer(IPAddress.Any, port);
294              Assert.True(server.Start());
295              while (!server.IsStarted)
296                  Thread.Yield();
297              int duration = 10;
298              var clients = new List<ProtoClient>();
299              var rand = new Random();
300              var start = DateTime.UtcNow;
301              while ((DateTime.UtcNow - start).TotalSeconds < duration)
302              {
303                  if ((rand.Next() % 1000) == 0)
304                  {
305                      server.DisconnectAll();
306                  }
307                  else if ((rand.Next() % 100) == 0)
308                  {
309                      if (clients.Count < 100)
310                      {
311                          var client = new ProtoClient(address, port);
312                          clients.Add(client);
313                          client.ConnectAsync();
314                          while (!client.IsConnected)
315                              Thread.Yield();
316                      }
317                  }
318                  else if ((rand.Next() % 100) == 0)
319                  {
320                      if (clients.Count > 0)
321                      {
322                          int index = rand.Next() % clients.Count;
323                          var client = clients[index];
324                          if (client.IsConnected)
325                          {
326                              client.DisconnectAsync();
327                              while (client.IsConnected)
328                                  Thread.Yield();
329                          }
330                          else
331                          {
332                              client.ConnectAsync();
333                              while (!client.IsConnected)
334                                  Thread.Yield();
335                          }
336                      }
337                  }
338                  else if ((rand.Next() % 100) == 0)
339                  {
340                      if (clients.Count > 0)
341                      {
342                          int index = rand.Next() % clients.Count;
343                          var client = clients[index];
344                          if (client.IsConnected)
345                          {
346                              client.ReconnectAsync();
347                              while (!client.IsConnected)
348                                  Thread.Yield();
349                          }
350                      }
351                  }
352                  else if ((rand.Next() % 10) == 0)
353                  {
354                      SimpleNotify notify = SimpleNotify.Default;
355                      notify.Notification = "test";
356                      server.Sender.Send(notify);
357                  }
358                  else if ((rand.Next() % 1) == 0)
359                  {
360                      if (clients.Count > 0)
361                      {
362                          int index = rand.Next() % clients.Count;
363                          var client = clients[index];
364                          if (client.IsConnected)
365                          {
366                              SimpleRequest request = SimpleRequest.Default;
367                              request.Message = "test";
368                              client.Request(request);
369                          }
370                      }
371                  }
372                  Thread.Sleep(1);
373              }
374              foreach (var client in clients)
375              {
376                  client.DisconnectAsync();
377                  while (client.IsConnected)
378                      Thread.Yield();
379              }
380              Assert.True(server.Stop());
381              while (server.IsStarted)
382                  Thread.Yield();
383              Assert.True(server.Started);
384              Assert.True(server.Stopped);
385              Assert.True(server.Connected);
386              Assert.True(server.Disconnected);
387              Assert.True(server.BytesSent > 0);
388              Assert.True(server.BytesReceived > 0);
389              Assert.True(!server.Errors);
390          }
391      }
392  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-FileContainerServer.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-ProtoTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>531          public string ItemPath { get; set; }
532          public string LocalPath { get; set; }
</pre></code></div>
                <div class="column column_space"><pre><code>169          public bool Started { get; set; }
170          public bool Stopped { get; set; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    