
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-TimelineTests.cs</h3>
            <pre><code>1  using System;
2  using System.Threading.Tasks;
3  using AngleSharp.Css.Dom;
4  using AngleSharp.Html.Dom;
5  using Bunit;
6  using FluentAssertions;
7  using MudBlazor.UnitTests.TestComponents;
8  using NUnit.Framework;
9  namespace MudBlazor.UnitTests.Components
10  {
11      [TestFixture]
12      public class TimelineTests : BunitTest
13      {
14          [Test]
15          public void TimelineTest_DefaultValues()
16          {
17              var comp = Context.RenderComponent&lt;MudTimeline&gt;();
18              comp.Instance.TimelineOrientation.Should().Be(TimelineOrientation.Vertical);
19              comp.Instance.TimelinePosition.Should().Be(TimelinePosition.Alternate);
20              comp.Instance.TimelineAlign.Should().Be(TimelineAlign.Default);
21              comp.Instance.Reverse.Should().Be(false);
22              comp.Instance.DisableModifiers.Should().Be(false);
23          }
24          [Test]
25          public async Task TimelineTest()
26          {
27              var comp = Context.RenderComponent&lt;TimelineTest&gt;();
28              var timeline = comp.FindComponent&lt;MudTimeline&gt;().Instance;
29              timeline.Should().NotBeNull();
30              comp.WaitForAssertion(() =&gt; comp.FindAll(&quot;div.mud-timeline&quot;).Count.Should().Be(1));
31              comp.FindAll(&quot;div.mud-timeline-item&quot;).Count.Should().Be(5);
32              var items = comp.FindComponents&lt;MudTimelineItem&gt;();
33              items.Count.Should().Be(5);
<span onclick='openModal()' class='match'>34              for (var i = 1; i &lt;= 4; i++)
35              {
</span>36                  await comp.InvokeAsync(() =&gt; timeline.MoveTo(i));
37                  timeline.SelectedIndex.Should().Be(i);
38                  timeline.SelectedContainer.Should().Be(items[i].Instance);
39              }
40              await comp.InvokeAsync(() =&gt; timeline.MoveTo(0));
41              timeline.SelectedIndex.Should().Be(0);
42              timeline.SelectedContainer.Should().Be(items[0].Instance);
43          }
44          [Test]
45          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Alternate, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
46          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Start, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
47          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Left, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
48          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Right, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
49          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.End, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
50          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Top, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-top&quot; })]
51          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Bottom, false, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-bottom&quot; })]
52          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Alternate, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-alternate&quot; })]
53          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Top, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-alternate&quot; })]
54          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Bottom, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-alternate&quot; })]
55          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Start, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-start&quot; })]
56          [TestCase(TimelineOrientation.Vertical, TimelinePosition.End, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-end&quot; })]
57          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Left, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-start&quot; })]
58          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Right, false, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-end&quot; })]
59          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Alternate, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
60          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Start, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
61          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Left, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
62          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Right, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
63          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.End, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-alternate&quot; })]
64          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Top, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-top&quot; })]
65          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Bottom, true, new[] { &quot;mud-timeline-horizontal&quot;, &quot;mud-timeline-position-bottom&quot; })]
66          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Alternate, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-alternate&quot; })]
67          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Top, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-alternate&quot; })]
68          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Bottom, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-alternate&quot; })]
69          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Start, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-start&quot; })]
70          [TestCase(TimelineOrientation.Vertical, TimelinePosition.End, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-end&quot; })]
71          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Left, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-end&quot; })]
72          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Right, true, new[] { &quot;mud-timeline-vertical&quot;, &quot;mud-timeline-position-start&quot; })]
73          public void TimelineTest_Position(TimelineOrientation orientation, TimelinePosition position, bool rtl, string[] expectedClass)
74          {
75              var comp = Context.RenderComponent&lt;TimelineTest&gt;(p =&gt; p.AddCascadingValue(&quot;RightToLeft&quot;, rtl));
76              var timeline = comp.FindComponent&lt;MudTimeline&gt;();
77              timeline.SetParametersAndRender(p =&gt;
78              {
79                  p.Add(x =&gt; x.TimelineOrientation, orientation);
80                  p.Add(x =&gt; x.TimelinePosition, position);
81              });
82              timeline.Nodes.Should().ContainSingle();
83              timeline.Nodes[0].Should().BeAssignableTo&lt;IHtmlDivElement&gt;();
84              (timeline.Nodes[0] as IHtmlDivElement).ClassList.Should().Contain(expectedClass);
85          }
86          [Test]
87          public void TimelineTest_SelectItem()
88          {
89              var comp = Context.RenderComponent&lt;TimelineTest&gt;();
90              var itemsDiv = comp.FindAll(&quot;.mud-timeline-item&quot;);
91              itemsDiv.Should().HaveCount(5);
92              for (int i = 0; i &lt; 5; i++)
93              {
94                  itemsDiv[i].Click();
95                  comp.Instance.SelectedIndex.Should().Be(i);
96              }
97          }
98          [Test]
99          public void TimelineTest_DotStyles()
100          {
101              var comp = Context.RenderComponent&lt;TimelineTest&gt;();
102              var firstItem = comp.FindComponent&lt;MudTimelineItem&gt;();
103              comp.Find(&quot;div.mud-timeline-item-dot-inner&quot;).GetStyle()[&quot;background-color&quot;].Should().Be(&quot;&quot;);
104              firstItem.SetParametersAndRender(p =&gt;
105              {
106                  p.Add(t =&gt; t.DotStyle, &quot;background-color: #ff0000&quot;);
107              });
108              comp.Find(&quot;div.mud-timeline-item-dot-inner&quot;).GetStyle()[&quot;background-color&quot;].Should().Be(&quot;rgba(255, 0, 0, 1)&quot;);
109          }
110      }
111  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</h3>
            <pre><code>1  #if NET7_0_OR_GREATER
2  using System;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.Runtime.InteropServices;
6  using System.Text;
7  using System.Threading;
8  using System.Transactions;
9  using NUnit.Framework;
10  using static Npgsql.Tests.TestUtil;
11  namespace Npgsql.Tests;
12  [NonParallelizable]
13  public class DistributedTransactionTests : TestBase
14  {
15      [Test]
16      public void Two_connections_rollback_implicit_enlistment()
17      {
18          using var adminConn = OpenConnection();
19          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
20          var dataSource = EnlistOnDataSource;
21          using (new TransactionScope())
22          using (var conn1 = dataSource.OpenConnection())
23          using (var conn2 = dataSource.OpenConnection())
24          {
25              conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
26              conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;);
27          }
28          Retry(() =&gt;
29          {
30              AssertNoDistributedIdentifier();
31              AssertNoPreparedTransactions();
32              AssertNumberOfRows(adminConn, table, 0);
33          });
34      }
35      [Test]
36      public void Two_connections_rollback_explicit_enlistment()
37      {
38          using var adminConn = OpenConnection();
39          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
40          var dataSource = EnlistOffDataSource;
41          using (var conn1 = dataSource.OpenConnection())
42          using (var conn2 = dataSource.OpenConnection())
43          using (new TransactionScope())
44          {
45              conn1.EnlistTransaction(Transaction.Current);
46              conn2.EnlistTransaction(Transaction.Current);
47              Assert.That(conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected first insert rowcount&quot;);
48              Assert.That(conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;), Is.EqualTo(1), &quot;Unexpected second insert rowcount&quot;);
49          }
50          Retry(() =&gt;
51          {
52              AssertNoDistributedIdentifier();
53              AssertNoPreparedTransactions();
54              AssertNumberOfRows(adminConn, table, 0);
55          });
56      }
57      [Test]
58      public void Two_connections_commit()
59      {
60          using var adminConn = OpenConnection();
61          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
62          var dataSource = EnlistOnDataSource;
63          using (var scope = new TransactionScope())
64          using (var conn1 = dataSource.OpenConnection())
65          using (var conn2 = dataSource.OpenConnection())
66          {
67              conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
68              conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;);
69              scope.Complete();
70          }
71          Retry(() =&gt;
72          {
73              AssertNoDistributedIdentifier();
74              AssertNoPreparedTransactions();
75              AssertNumberOfRows(adminConn, table, 2);
76          });
77      }
78      [Test]
79      public void Two_connections_with_failure()
80      {
81          using var dataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
82          using var adminConn = dataSource.OpenConnection();
83          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
84          using var scope = new TransactionScope();
85          using var conn1 = dataSource.OpenConnection();
86          using var conn2 = dataSource.OpenConnection();
87          conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
88          conn2.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test2&#x27;)&quot;);
89          conn1.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn2.ProcessID})&quot;);
90          scope.Complete();
91          Assert.That(() =&gt; scope.Dispose(), Throws.Exception.TypeOf&lt;TransactionAbortedException&gt;());
92          AssertNoDistributedIdentifier();
93          AssertNoPreparedTransactions();
94          AssertNumberOfRows(adminConn, table, 0);
95      }
96      [Test(Description = &quot;Transaction race, bool distributed&quot;)]
97      [Explicit(&quot;Fails on Appveyor (https:&amp;bsol;&amp;bsol;ci.appveyor.com/project/roji/npgsql/build/3.3.0-250)&quot;)]
98      public void Transaction_race([Values(false, true)] bool distributed)
99      {
100          using var adminConn = OpenConnection();
101          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
102          var dataSource = EnlistOnDataSource;
103          for (var i = 1; i &lt;= 100; i++)
104          {
105              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
106              try
107              {
108                  using (var tx = new TransactionScope())
109                  using (var conn1 = dataSource.OpenConnection())
110                  {
111                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope started, connection enlisted&quot;));
112                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
113                      eventQueue.Enqueue(new TransactionEvent(&quot;Insert done&quot;));
114                      if (distributed)
115                      {
116                          EnlistResource.EscalateToDistributed(eventQueue);
117                          AssertHasDistributedIdentifier();
118                      }
119                      else
120                      {
121                          EnlistResource.EnlistVolatile(eventQueue);
122                          AssertNoDistributedIdentifier();
123                      }
124                      tx.Complete();
125                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope completed&quot;));
126                  }
127                  eventQueue.Enqueue(new TransactionEvent(&quot;Scope disposed&quot;));
128                  AssertNoDistributedIdentifier();
129                  if (distributed)
130                  {
131                      const int maxLoop = 20;
132                      for (var j = 0; j &lt; maxLoop; j++)
133                      {
134                          Thread.Sleep(10);
135                          try
136                          {
137                              AssertNumberOfRows(adminConn, table, i);
138                              break;
139                          }
140                          catch
141                          {
142                              if (j == maxLoop - 1)
143                                  throw;
144                          }
145                      }
146                  }
147                  else
148                      AssertNumberOfRows(adminConn, table, i);
149              }
150              catch (Exception ex)
151              {
152                  Assert.Fail(
153                      @&quot;Failed at iteration {0}.
154  Events:
155  {1}
156  Exception {2}&quot;,
157                      i, FormatEventQueue(eventQueue), ex);
158              }
159          }
160      }
161      [Test(Description = &quot;Connection reuse race after transaction, bool distributed&quot;), Explicit]
162      public void Connection_reuse_race_after_transaction([Values(false, true)] bool distributed)
163      {
164          using var adminConn = OpenConnection();
165          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
166          var dataSource = EnlistOffDataSource;
167          for (var i = 1; i &lt;= 100; i++)
168          {
169              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
170              try
171              {
172                  using var conn1 = dataSource.OpenConnection();
173                  using (var scope = new TransactionScope())
174                  {
175                      conn1.EnlistTransaction(Transaction.Current);
176                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope started, connection enlisted&quot;));
177                      if (distributed)
178                      {
179                          EnlistResource.EscalateToDistributed(eventQueue);
180                          AssertHasDistributedIdentifier();
181                      }
182                      else
183                      {
184                          EnlistResource.EnlistVolatile(eventQueue);
185                          AssertNoDistributedIdentifier();
186                      }
187                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
188                      eventQueue.Enqueue(new TransactionEvent(&quot;Insert done&quot;));
189                      scope.Complete();
190                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope completed&quot;));
191                  }
192                  eventQueue.Enqueue(new TransactionEvent(&quot;Scope disposed&quot;));
193                  Assert.DoesNotThrow(() =&gt; conn1.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;));
194              }
195              catch (Exception ex)
196              {
197                  Assert.Fail(
198                      @&quot;Failed at iteration {0}.
199  Events:
200  {1}
201  Exception {2}&quot;,
202                      i, FormatEventQueue(eventQueue), ex);
203              }
204          }
205      }
206      [Test(Description = &quot;Connection reuse race after rollback, bool distributed&quot;), Explicit(&quot;Currently failing.&quot;)]
207      public void Connection_reuse_race_after_rollback([Values(false, true)] bool distributed)
208      {
209          using var adminConn = OpenConnection();
210          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
211          var dataSource = EnlistOffDataSource;
212          for (var i = 1; i &lt;= 100; i++)
213          {
214              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
215              try
216              {
217                  using var conn1 = dataSource.OpenConnection();
218                  using (new TransactionScope())
219                  {
220                      conn1.EnlistTransaction(Transaction.Current);
221                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope started, connection enlisted&quot;));
222                      if (distributed)
223                      {
224                          EnlistResource.EscalateToDistributed(eventQueue);
225                          AssertHasDistributedIdentifier();
226                      }
227                      else
228                      {
229                          EnlistResource.EnlistVolatile(eventQueue);
230                          AssertNoDistributedIdentifier();
231                      }
232                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
233                      eventQueue.Enqueue(new TransactionEvent(&quot;Insert done&quot;));
234                      eventQueue.Enqueue(new TransactionEvent(&quot;Scope not completed&quot;));
235                  }
236                  eventQueue.Enqueue(new TransactionEvent(&quot;Scope disposed&quot;));
237                  conn1.EnlistTransaction(null);
238                  eventQueue.Enqueue(new TransactionEvent(&quot;Connection enlisted with null&quot;));
239                  Assert.DoesNotThrow(() =&gt; conn1.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;));
240              }
241              catch (Exception ex)
242              {
243                  Assert.Fail(
244                      @&quot;Failed at iteration {0}.
245  Events:
246  {1}
247  Exception {2}&quot;,
248                      i, FormatEventQueue(eventQueue), ex);
249              }
250          }
251      }
252      [Test(Description = &quot;Connection reuse race chaining transactions, bool distributed&quot;)]
253      [Explicit]
254      public void Connection_reuse_race_chaining_transaction([Values(false, true)] bool distributed)
255      {
256          using var adminConn = OpenConnection();
257          var table = CreateTempTable(adminConn, &quot;name TEXT&quot;);
258          var dataSource = EnlistOffDataSource;
<span onclick='openModal()' class='match'>259          for (var i = 1; i &lt;= 100; i++)
260          {
</span>261              var eventQueue = new ConcurrentQueue&lt;TransactionEvent&gt;();
262              try
263              {
264                  using var conn1 = dataSource.OpenConnection();
265                  using (var scope = new TransactionScope())
266                  {
267                      eventQueue.Enqueue(new TransactionEvent(&quot;First scope started&quot;));
268                      conn1.EnlistTransaction(Transaction.Current);
269                      eventQueue.Enqueue(new TransactionEvent(&quot;First scope, connection enlisted&quot;));
270                      if (distributed)
271                      {
272                          EnlistResource.EscalateToDistributed(eventQueue);
273                          AssertHasDistributedIdentifier();
274                      }
275                      else
276                      {
277                          EnlistResource.EnlistVolatile(eventQueue);
278                          AssertNoDistributedIdentifier();
279                      }
280                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
281                      eventQueue.Enqueue(new TransactionEvent(&quot;First insert done&quot;));
282                      scope.Complete();
283                      eventQueue.Enqueue(new TransactionEvent(&quot;First scope completed&quot;));
284                  }
285                  eventQueue.Enqueue(new TransactionEvent(&quot;First scope disposed&quot;));
286                  using (var scope = new TransactionScope())
287                  {
288                      eventQueue.Enqueue(new TransactionEvent(&quot;Second scope started&quot;));
289                      conn1.EnlistTransaction(Transaction.Current);
290                      eventQueue.Enqueue(new TransactionEvent(&quot;Second scope, connection enlisted&quot;));
291                      if (distributed)
292                      {
293                          EnlistResource.EscalateToDistributed(eventQueue);
294                          AssertHasDistributedIdentifier();
295                      }
296                      else
297                      {
298                          EnlistResource.EnlistVolatile(eventQueue);
299                          AssertNoDistributedIdentifier();
300                      }
301                      conn1.ExecuteNonQuery($&quot;INSERT INTO {table} (name) VALUES (&#x27;test1&#x27;)&quot;);
302                      eventQueue.Enqueue(new TransactionEvent(&quot;Second insert done&quot;));
303                      scope.Complete();
304                      eventQueue.Enqueue(new TransactionEvent(&quot;Second scope completed&quot;));
305                  }
306                  eventQueue.Enqueue(new TransactionEvent(&quot;Second scope disposed&quot;));
307              }
308              catch (Exception ex)
309              {
310                  Assert.Fail(
311                      @&quot;Failed at iteration {0}.
312  Events:
313  {1}
314  Exception {2}&quot;,
315                      i, FormatEventQueue(eventQueue), ex);
316              }
317          }
318      }
319      #region Utilities
320      static void Retry(Action action)
321      {
322          const int Retries = 50;
323          for (var i = 0; i &lt; Retries; i++)
324          {
325              try
326              {
327                  action();
328                  return;
329              }
330              catch (AssertionException)
331              {
332                  if (i == Retries - 1)
333                  {
334                      throw;
335                  }
336                  Thread.Sleep(100);
337              }
338          }
339      }
340      void AssertNoPreparedTransactions()
341          =&gt; Assert.That(GetNumberOfPreparedTransactions(), Is.EqualTo(0), &quot;Prepared transactions found&quot;);
342      int GetNumberOfPreparedTransactions()
343      {
344          var dataSource = EnlistOffDataSource;
345          using (var conn = dataSource.OpenConnection())
346          using (var cmd = new NpgsqlCommand(&quot;SELECT COUNT(*) FROM pg_prepared_xacts WHERE database = @database&quot;, conn))
347          {
348              cmd.Parameters.Add(new NpgsqlParameter(&quot;database&quot;, conn.Database));
349              return (int)(long)cmd.ExecuteScalar()!;
350          }
351      }
352      void AssertNumberOfRows(NpgsqlConnection connection, string table, int expected)
353          =&gt; Assert.That(connection.ExecuteScalar($&quot;SELECT COUNT(*) FROM {table}&quot;), Is.EqualTo(expected), &quot;Unexpected data count&quot;);
354      static void AssertNoDistributedIdentifier()
355          =&gt; Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.EqualTo(Guid.Empty), &quot;Distributed identifier found&quot;);
356      static void AssertHasDistributedIdentifier()
357          =&gt; Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.Not.EqualTo(Guid.Empty), &quot;Distributed identifier not found&quot;);
358      NpgsqlDataSource EnlistOnDataSource { get; set; } = default!;
359      NpgsqlDataSource EnlistOffDataSource { get; set; } = default!;
360      static string FormatEventQueue(ConcurrentQueue&lt;TransactionEvent&gt; eventQueue)
361      {
362          eventQueue.Enqueue(new TransactionEvent(@&quot;-------------
363  Start formatting event queue, going to sleep a bit for late events
364  -------------&quot;));
365          Thread.Sleep(20);
366          var eventsMessage = new StringBuilder();
367          foreach (var evt in eventQueue)
368          {
369              eventsMessage.AppendLine(evt.Message);
370          }
371          return eventsMessage.ToString();
372      }
373      public class EnlistResource : IEnlistmentNotification
374      {
375          public static int Counter { get; set; }
376          readonly bool _shouldRollBack;
377          readonly string _name;
378          readonly ConcurrentQueue&lt;TransactionEvent&gt;? _eventQueue;
379          public static void EnlistVolatile(ConcurrentQueue&lt;TransactionEvent&gt; eventQueue)
380              =&gt; EnlistVolatile(false, eventQueue);
381          public static void EnlistVolatile(bool shouldRollBack = false, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue = null)
382              =&gt; Enlist(false, shouldRollBack, eventQueue);
383          public static void EscalateToDistributed(ConcurrentQueue&lt;TransactionEvent&gt; eventQueue)
384              =&gt; EscalateToDistributed(false, eventQueue);
385          public static void EscalateToDistributed(bool shouldRollBack = false, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue = null)
386              =&gt; Enlist(true, shouldRollBack, eventQueue);
387          static void Enlist(bool durable, bool shouldRollBack, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue)
388          {
389              Counter++;
390              var name = $&quot;{(durable ? &quot;Durable&quot; : &quot;Volatile&quot;)} resource {Counter}&quot;;
391              var resource = new EnlistResource(shouldRollBack, name, eventQueue);
392              if (durable)
393                  Transaction.Current!.EnlistDurable(Guid.NewGuid(), resource, EnlistmentOptions.None);
394              else
395                  Transaction.Current!.EnlistVolatile(resource, EnlistmentOptions.None);
396              Transaction.Current.TransactionCompleted += resource.Current_TransactionCompleted!;
397              eventQueue?.Enqueue(new TransactionEvent(name + &quot;: enlisted&quot;));
398          }
399          EnlistResource(bool shouldRollBack, string name, ConcurrentQueue&lt;TransactionEvent&gt;? eventQueue)
400          {
401              _shouldRollBack = shouldRollBack;
402              _name = name;
403              _eventQueue = eventQueue;
404          }
405          public void Prepare(PreparingEnlistment preparingEnlistment)
406          {
407              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase start&quot;));
408              Thread.Sleep(1);
409              if (_shouldRollBack)
410              {
411                  _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase, calling rollback-ed&quot;));
412                  preparingEnlistment.ForceRollback();
413              }
414              else
415              {
416                  _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase, calling prepared&quot;));
417                  preparingEnlistment.Prepared();
418              }
419              Thread.Sleep(1);
420              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: prepare phase end&quot;));
421          }
422          public void Commit(Enlistment enlistment)
423          {
424              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: commit phase start&quot;));
425              Thread.Sleep(1);
426              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: commit phase, calling done&quot;));
427              enlistment.Done();
428              Thread.Sleep(1);
429              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: commit phase end&quot;));
430          }
431          public void Rollback(Enlistment enlistment)
432          {
433              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: rollback phase start&quot;));
434              Thread.Sleep(1);
435              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: rollback phase, calling done&quot;));
436              enlistment.Done();
437              Thread.Sleep(1);
438              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: rollback phase end&quot;));
439          }
440          public void InDoubt(Enlistment enlistment)
441          {
442              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: in-doubt phase start&quot;));
443              Thread.Sleep(1);
444              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: in-doubt phase, calling done&quot;));
445              enlistment.Done();
446              Thread.Sleep(1);
447              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: in-doubt phase end&quot;));
448          }
449          void Current_TransactionCompleted(object sender, TransactionEventArgs e)
450          {
451              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: transaction completed start&quot;));
452              Thread.Sleep(1);
453              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: transaction completed middle&quot;));
454              Thread.Sleep(1);
455              _eventQueue?.Enqueue(new TransactionEvent(_name + &quot;: transaction completed end&quot;));
456          }
457      }
458      public class TransactionEvent
459      {
460          public TransactionEvent(string message)
461              =&gt; Message = $&quot;{message} (TId {Thread.CurrentThread.ManagedThreadId})&quot;;
462          public string Message { get; }
463      }
464      #endregion Utilities
465      #region Setup
466      [OneTimeSetUp]
467      public void OneTimeSetUp()
468      {
469          if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
470          {
471              Assert.Ignore(&quot;Distributed transactions are only supported on Windows&quot;);
472              return;
473          }
474          using var connection = OpenConnection();
475          if (int.Parse((string)connection.ExecuteScalar(&quot;SHOW max_prepared_transactions&quot;)!) == 0)
476          {
477              IgnoreExceptOnBuildServer(&quot;max_prepared_transactions is set to 0 in your postgresql.conf&quot;);
478              return;
479          }
480          var lingeringTransactions = new List&lt;string&gt;();
481          using (var cmd = new NpgsqlCommand(&quot;SELECT gid FROM pg_prepared_xacts WHERE database=@database&quot;, connection))
482          {
483              cmd.Parameters.AddWithValue(&quot;database&quot;, new NpgsqlConnectionStringBuilder(ConnectionString).Database!);
484              using var reader = cmd.ExecuteReader();
485              while (reader.Read())
486                  lingeringTransactions.Add(reader.GetString(0));
487          }
488          foreach (var xactGid in lingeringTransactions)
489              connection.ExecuteNonQuery($&quot;ROLLBACK PREPARED &#x27;{xactGid}&#x27;&quot;);
490          EnlistOnDataSource = CreateDataSource(csb =&gt; csb.Enlist = true);
491          EnlistOffDataSource = CreateDataSource(csb =&gt; csb.Enlist = false);
492      }
493      [OneTimeTearDown]
494      public void OnTimeTearDown()
495      {
496          EnlistOnDataSource?.Dispose();
497          EnlistOnDataSource = null!;
498          EnlistOffDataSource?.Dispose();
499          EnlistOffDataSource = null!;
500      }
501      [SetUp]
502      public void SetUp()
503          =&gt; EnlistResource.Counter = 0;
504      internal static string CreateTempTable(NpgsqlConnection conn, string columns)
505      {
506          var tableName = &quot;temp_table&quot; + Interlocked.Increment(ref _tempTableCounter);
507          conn.ExecuteNonQuery(@$&quot;
508  START TRANSACTION; SELECT pg_advisory_xact_lock(0);
509  DROP TABLE IF EXISTS {tableName} CASCADE;
510  COMMIT;
511  CREATE TABLE {tableName} ({columns})&quot;);
512          return tableName;
513      }
514      #endregion
515  }
516  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-TimelineTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>34              for (var i = 1; i &lt;= 4; i++)
35              {
</pre></code></div>
                <div class="column column_space"><pre><code>259          for (var i = 1; i &lt;= 100; i++)
260          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    