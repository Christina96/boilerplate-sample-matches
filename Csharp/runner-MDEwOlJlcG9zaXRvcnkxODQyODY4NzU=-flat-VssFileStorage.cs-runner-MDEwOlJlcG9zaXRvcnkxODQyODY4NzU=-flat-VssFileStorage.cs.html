
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssFileStorage.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.ComponentModel;
5  using System.Diagnostics;
6  using System.IO;
7  using System.Linq;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using GitHub.Services.Common.Internal;
12  using Newtonsoft.Json;
13  using Newtonsoft.Json.Linq;
14  namespace GitHub.Services.Common.ClientStorage
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)] 
17      public class VssFileStorage : IVssClientStorage, IDisposable
18      {
19          private readonly string m_filePath;
20          private readonly VssFileStorageReader m_reader;
21          private readonly IVssClientStorageWriter m_writer;
22          private const char c_defaultPathSeparator = '\\';
23          private const bool c_defaultIgnoreCaseInPaths = false;
24          public char PathSeparator { get; }
25          public StringComparer PathComparer { get; }
26          private VssFileStorage(string filePath, char pathSeparatorForKeys = c_defaultPathSeparator, bool ignoreCaseInPaths = c_defaultIgnoreCaseInPaths) 
27          {
28              PathSeparator = pathSeparatorForKeys;
29              PathComparer = GetAppropriateStringComparer(ignoreCaseInPaths);
30              m_filePath = filePath;
31              m_reader = new VssFileStorageReader(m_filePath, pathSeparatorForKeys, PathComparer);
32              m_writer = new VssFileStorageWriter(m_filePath, pathSeparatorForKeys, PathComparer);
33          }
34          public T ReadEntry<T>(string path)
35          {
36              return m_reader.ReadEntry<T>(path);
37          }
38          public T ReadEntry<T>(string path, T defaultValue)
39          {
40              return m_reader.ReadEntry<T>(path, defaultValue);
41          }
42          public IDictionary<string, T> ReadEntries<T>(string pathPrefix)
43          {
44              return m_reader.ReadEntries<T>(pathPrefix);
45          }
46          public void WriteEntries(IEnumerable<KeyValuePair<string, object>> entries)
47          {
48              m_writer.WriteEntries(entries);
49              m_reader.NotifyChanged();
50          }
51          public void WriteEntry(string key, object value)
52          {
53              m_writer.WriteEntry(key, value);
54              m_reader.NotifyChanged();
55          }
56          public void Dispose()
57          {
58              m_reader.Dispose();
59          }
60          public string PathKeyCombine(params string[] paths)
61          {
62              StringBuilder combinedPath = new StringBuilder();
63              foreach (string segment in paths)
64              {
65                  if (segment != null)
66                  {
67                      string trimmedSegment = segment.TrimEnd(PathSeparator);
68                      if (trimmedSegment.Length > 0)
69                      {
70                          if (combinedPath.Length > 0)
71                          {
72                              combinedPath.Append(PathSeparator);
73                          }
74                          combinedPath.Append(trimmedSegment);
75                      }
76                  }
77              }
78              return combinedPath.ToString();
79          }
80          private static ConcurrentDictionary<string, VssFileStorage> s_storages = new ConcurrentDictionary<string, VssFileStorage>(StringComparer.OrdinalIgnoreCase);
81          public static IVssClientStorage GetVssLocalFileStorage(string fullPath, char pathSeparatorForKeys = c_defaultPathSeparator, bool ignoreCaseInPaths = c_defaultIgnoreCaseInPaths)
82          {
83              string normalizedFullPath = Path.GetFullPath(fullPath);
84              VssFileStorage storage = s_storages.GetOrAdd(normalizedFullPath, (key) => new VssFileStorage(key, pathSeparatorForKeys, ignoreCaseInPaths));
85              if (storage.PathSeparator != pathSeparatorForKeys)
86              {
87                  throw new ArgumentException(CommonResources.ConflictingPathSeparatorForVssFileStorage(pathSeparatorForKeys, normalizedFullPath, storage.PathSeparator));
88              }
89              StringComparer pathComparer = GetAppropriateStringComparer(ignoreCaseInPaths);
90              {
91                  if (storage.PathComparer != pathComparer)
92                  {
93                      string caseSensitive = "Ordinal";
94                      string caseInsensitive = "OrdinalIgnoreCase";
95                      string requested = ignoreCaseInPaths ? caseInsensitive : caseSensitive;
96                      string previous = ignoreCaseInPaths ? caseSensitive : caseInsensitive;
97                      throw new ArgumentException(CommonResources.ConflictingStringComparerForVssFileStorage(requested, normalizedFullPath, previous));
98                  }
99              }
100  #if DEBUG
101              Debug.Assert(fullPath.Equals(storage.m_filePath), string.Format("The same storage file is being referenced with different casing.  This will cause issues when running in cross patform environments where the file system may be case sensitive.  {0} != {1}", storage.m_filePath, normalizedFullPath));
102  #endif
103              return storage;
104          }
105          private static StringComparer GetAppropriateStringComparer(bool ignoreCase)
106          {
107              return ignoreCase ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal;
108          }
109          public static IVssClientStorage GetCurrentUserVssFileStorage(string pathSuffix, bool storeByVssVersion, char pathSeparatorForKeys = c_defaultPathSeparator, bool ignoreCaseInPaths = c_defaultIgnoreCaseInPaths)
110          {
111              return GetVssLocalFileStorage(Path.Combine(storeByVssVersion ? ClientSettingsDirectoryByVersion : ClientSettingsDirectory, pathSuffix), pathSeparatorForKeys, ignoreCaseInPaths);
112          }
113          internal static string ClientSettingsDirectoryByVersion
114          {
115              get
116              {
117                  return Path.Combine(ClientSettingsDirectory, "v" + GeneratedVersionInfo.ProductVersion);
118              }
119          }
120          internal static string ClientSettingsDirectory
121          {
122              get
123              {
124                  string subDir = Path.Combine("GitHub", "ActionsService");
125                  string path = Environment.GetEnvironmentVariable("localappdata");
126                  SafeGetFolderPath(Environment.SpecialFolder.LocalApplicationData);
127                  if (string.IsNullOrEmpty(path))
128                  {
129                      path = SafeGetFolderPath(Environment.SpecialFolder.ApplicationData);
130                      if (string.IsNullOrEmpty(path))
131                      {
132                          path = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);
133                          subDir = "GitHubActionsService";
134                      }
135                  }
136                  Debug.Assert(path != null, "folder path cannot be null");
137                  return Path.Combine(path, subDir);
138              }
139          }
140          private static string SafeGetFolderPath(Environment.SpecialFolder specialFolder)
141          {
142              try
143              {
144                  return Environment.GetFolderPath(specialFolder);
145              }
146              catch (ArgumentException)
147              {
148                  return null;
149              }
150          }
151          private class VssFileStorageReader : VssLocalFile, IVssClientStorageReader, IDisposable
152          {
153              private readonly string m_path;
154              private Dictionary<string, JRaw> m_settings;
155              private readonly FileSystemWatcher m_watcher;
156              private readonly ReaderWriterLockSlim m_lock;
157              private long m_completedRefreshId;
158              private long m_outstandingRefreshId;
159              public VssFileStorageReader(string fullPath, char pathSeparator, StringComparer comparer)
160                  : base(fullPath, pathSeparator, comparer)
161              {
162                  m_path = fullPath;
163                  m_lock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
164                  m_completedRefreshId = 0;
165                  m_outstandingRefreshId = 1;
166                  {
167                      string directoryToWatch = Path.GetDirectoryName(m_path);
168                      if (!Directory.Exists(directoryToWatch))
169                      {
170                          Directory.CreateDirectory(directoryToWatch);
171                      }
172                      m_watcher = new FileSystemWatcher(directoryToWatch, Path.GetFileName(m_path));
173                      m_watcher.IncludeSubdirectories = false;
174                      m_watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime;
175                      m_watcher.Changed += OnCacheFileChanged;
176                      m_watcher.EnableRaisingEvents = true;
177                  }
178              }
179              public T ReadEntry<T>(string path)
180              {
181                  return ReadEntry<T>(path, default(T));
182              }
183              public T ReadEntry<T>(string path, T defaultValue)
184              {
185                  path = NormalizePath(path);
186                  RefreshIfNeeded();
187                  Dictionary<string, JRaw> settings = m_settings;  
188                  JRaw value;
189                  if (settings.TryGetValue(path, out value) && value != null)
190                  {
191                      return JsonConvert.DeserializeObject<T>(value.ToString());
192                  }
193                  return defaultValue;
194              }
195              public IDictionary<string, T> ReadEntries<T>(string pathPrefix)
196              {
197                  string prefix = NormalizePath(pathPrefix, true);
198                  RefreshIfNeeded();
199                  Dictionary<string, JRaw> settings = m_settings;  
200                  Dictionary<string, T> matchingEntries = new Dictionary<string, T>();
201                  foreach (KeyValuePair<string, JRaw> kvp in settings.Where(kvp => kvp.Key == prefix || kvp.Key.StartsWith(prefix + PathSeparator)))
202                  {
203                      try
204                      {
205                          matchingEntries[kvp.Key] = JsonConvert.DeserializeObject<T>(kvp.Value.ToString());
206                      }
207                      catch (JsonSerializationException) { }
208                      catch (JsonReaderException) { }
209                  }
210                  return matchingEntries;
211              }
212              private void OnCacheFileChanged(object sender, FileSystemEventArgs e)
213              {
214                  NotifyChanged();
215              }
216              public void Dispose()
217              {
218                  m_watcher.Dispose();
219              }
<span onclick='openModal()' class='match'>220              public void NotifyChanged()
221              {
222                  using (new ReadLockScope(m_lock))
223                  {
224                      Interlocked.Increment(ref m_outstandingRefreshId);
</span>225                  }
226              }
227              private void RefreshIfNeeded()
228              {
229                  long requestedRefreshId;
230                  using (new ReadLockScope(m_lock))
231                  {
232                      requestedRefreshId = Interlocked.Read(ref m_outstandingRefreshId);
233                      if (m_completedRefreshId >= requestedRefreshId)
234                      {
235                          return;
236                      }
237                  }
238                  Dictionary<string, JRaw> newSettings;
239                  using (GetNewMutexScope())
240                  {
241                      if (m_completedRefreshId >= requestedRefreshId)
242                      {
243                          return;
244                      }
245                      newSettings = LoadFile();
246                  }
247                  using (new ReadLockScope(m_lock))
248                  {
249                      if (m_completedRefreshId >= requestedRefreshId)
250                      {
251                          return;
252                      }
253                  }
254                  using (new WriteLockScope(m_lock))
255                  {
256                      if (m_completedRefreshId >= requestedRefreshId)
257                      {
258                          return;
259                      }
260                      m_completedRefreshId = requestedRefreshId;
261                      m_settings = newSettings;
262                  }
263              }
264              private struct ReadLockScope : IDisposable
265              {
266                  public ReadLockScope(ReaderWriterLockSlim @lock)
267                  {
268                      m_lock = @lock;
269                      m_lock.EnterReadLock();
270                  }
271                  public void Dispose()
272                  {
273                      m_lock.ExitReadLock();
274                  }
275                  private readonly ReaderWriterLockSlim m_lock;
276              }
277              private struct WriteLockScope : IDisposable
278              {
279                  public WriteLockScope(ReaderWriterLockSlim @lock)
280                  {
281                      m_lock = @lock;
282                      m_lock.EnterWriteLock();
283                  }
284                  public void Dispose()
285                  {
286                      m_lock.ExitWriteLock();
287                  }
288                  private readonly ReaderWriterLockSlim m_lock;
289              }
290          }
291          private class VssFileStorageWriter : VssLocalFile, IVssClientStorageWriter
292          {
293              public VssFileStorageWriter(string fullPath, char pathSeparator, StringComparer comparer)
294                  : base(fullPath, pathSeparator, comparer)
295              {
296              }
297              public void WriteEntries(IEnumerable<KeyValuePair<string, object>> entries)
298              {
299                  if (entries.Any())
300                  {
301                      using (GetNewMutexScope())
302                      {
303                          bool changesMade = false;
304                          Dictionary<string, JRaw> originalSettings = LoadFile();
305                          Dictionary<string, JRaw> newSettings = new Dictionary<string, JRaw>(PathComparer);
306                          if (originalSettings.Any())
307                          {
308                              originalSettings.Copy(newSettings);
309                          }
310                          foreach (KeyValuePair<string, object> kvp in entries)
311                          {
312                              string path = NormalizePath(kvp.Key);
313                              if (kvp.Value != null)
314                              {
315                                  JRaw jRawValue = new JRaw(JsonConvert.SerializeObject(kvp.Value));
316                                  if (!newSettings.ContainsKey(path) || !newSettings[path].Equals(jRawValue))
317                                  {
318                                      newSettings[path] = jRawValue;
319                                      changesMade = true;
320                                  }
321                              }
322                              else
323                              {
324                                  if (newSettings.Remove(path))
325                                  {
326                                      changesMade = true;
327                                  }
328                              }
329                          }
330                          if (changesMade)
331                          {
332                              SaveFile(originalSettings, newSettings);
333                          }
334                      }
335                  }
336              }
337              public void WriteEntry(string path, object value)
338              {
339                  WriteEntries(new KeyValuePair<string, object>[] { new KeyValuePair<string, object>(path, value) });
340              }
341          }
342          private class VssLocalFile
343          {
344              private readonly string m_filePath;
345              private readonly string m_bckUpFilePath;
346              private readonly string m_emptyPathSegment;
347              public VssLocalFile(string filePath, char pathSeparator, StringComparer comparer)
348              {
349                  m_filePath = filePath;
350                  PathComparer = comparer;
351                  PathSeparator = pathSeparator;
352                  m_emptyPathSegment = new string(pathSeparator, 2);
353                  FileInfo fileInfo = new FileInfo(m_filePath);
354                  m_bckUpFilePath = Path.Combine(fileInfo.Directory.FullName, "~" + fileInfo.Name);
355              }
356              protected char PathSeparator { get; }
357              protected string NormalizePath(string path, bool allowRootPath = false)
358              {
359                  if (string.IsNullOrEmpty(path) || path[0] != PathSeparator || path.IndexOf(m_emptyPathSegment, StringComparison.Ordinal) >= 0 || (!allowRootPath && path.Length == 1))
360                  {
361                      throw new ArgumentException(CommonResources.InvalidClientStoragePath(path, PathSeparator), "path");
362                  }
363                  if (path[path.Length - 1] == PathSeparator)
364                  {
365                      path = path.Substring(0, path.Length - 1);
366                  }
367                  return path;
368              }
369              protected StringComparer PathComparer { get; }
370              protected Dictionary<string, JRaw> LoadFile()
371              {
372                  Dictionary<string, JRaw> settings = null;
373                  if (File.Exists(m_filePath))
374                  {
375                      settings = LoadFile(m_filePath);
376                  }
377                  if ((settings == null || !settings.Any()) && File.Exists(m_bckUpFilePath))
378                  {
379                      settings = LoadFile(m_bckUpFilePath);
380                  }
381                  return settings ?? new Dictionary<string, JRaw>(PathComparer);
382              }
383              private Dictionary<string, JRaw> LoadFile(string path)
384              {
385                  Dictionary<string, JRaw> settings = new Dictionary<string, JRaw>(PathComparer);
386                  try
387                  {
388                      string fileContent;
389                      using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete))
390                      {
391                          using (var sr = new StreamReader(fs, Encoding.UTF8))
392                          {
393                              fileContent = sr.ReadToEnd();
394                          }
395                      }
396                      IReadOnlyDictionary<string, JRaw> loadedSettings = JsonConvert.DeserializeObject<IReadOnlyDictionary<string, JRaw>>(fileContent);
397                      if (loadedSettings != null)
398                      {
399                          foreach (KeyValuePair<string, JRaw> setting in loadedSettings)
400                          {
401                              settings[setting.Key] = setting.Value;
402                          }
403                      }
404                  }
405                  catch (DirectoryNotFoundException) { }
406                  catch (FileNotFoundException) { }
407                  catch (JsonReaderException) { }
408                  catch (JsonSerializationException) { }
409                  catch (InvalidCastException) { }
410                  return settings;
411              }
412              protected void SaveFile(IDictionary<string, JRaw> originalSettings, IDictionary<string, JRaw> newSettings)
413              {
414                  string newContent = JValue.Parse(JsonConvert.SerializeObject(newSettings)).ToString(Formatting.Indented);
415                  if (originalSettings.Any())
416                  {
417                      string originalContent = JValue.Parse(JsonConvert.SerializeObject(originalSettings)).ToString(Formatting.Indented);
418                      SaveFile(m_bckUpFilePath, originalContent);
419                  }
420                  SaveFile(m_filePath, newContent);
421                  if (File.Exists(m_bckUpFilePath))
422                  {
423                      File.Delete(m_bckUpFilePath);
424                  }
425              }
426              private void SaveFile(string path, string content)
427              {
428                  bool success = false;
429                  int tries = 0;
430                  int retryDelayMilliseconds = 10;
431                  const int maxNumberOfRetries = 6;
432                  do
433                  {
434                      try
435                      {
436                          using (var fs = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.Delete))
437                          {
438                              using (var sw = new StreamWriter(fs, Encoding.UTF8))
439                              {
440                                  sw.Write(content);
441                              }
442                          }
443                          success = true;
444                      }
445                      catch (IOException)
446                      {
447                          if (++tries > maxNumberOfRetries)
448                          {
449                              throw;
450                          }
451                          Task.Delay(retryDelayMilliseconds).Wait();
452                          retryDelayMilliseconds *= 2;
453                      }
454                  }
455                  while (!success);
456              }
457              protected MutexScope GetNewMutexScope()
458              {
459                  return new MutexScope(m_filePath.Replace(Path.DirectorySeparatorChar, '_'));
460              }
461              protected struct MutexScope : IDisposable
462              {
463                  public MutexScope(string name)
464                  {
465                      m_mutex = new Mutex(false, name);
466                      try
467                      {
468                          if (!m_mutex.WaitOne(s_mutexTimeout))
469                          {
470                              throw new TimeoutException();
471                          }
472                      }
473                      catch (AbandonedMutexException)
474                      {
475                      }
476                  }
477                  public void Dispose()
478                  {
479                      m_mutex.ReleaseMutex();
480                  }
481                  private readonly Mutex m_mutex;
482                  private static readonly TimeSpan s_mutexTimeout = TimeSpan.FromSeconds(10);
483              }
484          }
485      }
486  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssFileStorage.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.ComponentModel;
5  using System.Diagnostics;
6  using System.IO;
7  using System.Linq;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using GitHub.Services.Common.Internal;
12  using Newtonsoft.Json;
13  using Newtonsoft.Json.Linq;
14  namespace GitHub.Services.Common.ClientStorage
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)] 
17      public class VssFileStorage : IVssClientStorage, IDisposable
18      {
19          private readonly string m_filePath;
20          private readonly VssFileStorageReader m_reader;
21          private readonly IVssClientStorageWriter m_writer;
22          private const char c_defaultPathSeparator = '\\';
23          private const bool c_defaultIgnoreCaseInPaths = false;
24          public char PathSeparator { get; }
25          public StringComparer PathComparer { get; }
26          private VssFileStorage(string filePath, char pathSeparatorForKeys = c_defaultPathSeparator, bool ignoreCaseInPaths = c_defaultIgnoreCaseInPaths) 
27          {
28              PathSeparator = pathSeparatorForKeys;
29              PathComparer = GetAppropriateStringComparer(ignoreCaseInPaths);
30              m_filePath = filePath;
31              m_reader = new VssFileStorageReader(m_filePath, pathSeparatorForKeys, PathComparer);
32              m_writer = new VssFileStorageWriter(m_filePath, pathSeparatorForKeys, PathComparer);
33          }
34          public T ReadEntry<T>(string path)
35          {
36              return m_reader.ReadEntry<T>(path);
37          }
38          public T ReadEntry<T>(string path, T defaultValue)
39          {
40              return m_reader.ReadEntry<T>(path, defaultValue);
41          }
42          public IDictionary<string, T> ReadEntries<T>(string pathPrefix)
43          {
44              return m_reader.ReadEntries<T>(pathPrefix);
45          }
46          public void WriteEntries(IEnumerable<KeyValuePair<string, object>> entries)
47          {
48              m_writer.WriteEntries(entries);
49              m_reader.NotifyChanged();
50          }
51          public void WriteEntry(string key, object value)
52          {
53              m_writer.WriteEntry(key, value);
54              m_reader.NotifyChanged();
55          }
56          public void Dispose()
57          {
58              m_reader.Dispose();
59          }
60          public string PathKeyCombine(params string[] paths)
61          {
62              StringBuilder combinedPath = new StringBuilder();
63              foreach (string segment in paths)
64              {
65                  if (segment != null)
66                  {
67                      string trimmedSegment = segment.TrimEnd(PathSeparator);
68                      if (trimmedSegment.Length > 0)
69                      {
70                          if (combinedPath.Length > 0)
71                          {
72                              combinedPath.Append(PathSeparator);
73                          }
74                          combinedPath.Append(trimmedSegment);
75                      }
76                  }
77              }
78              return combinedPath.ToString();
79          }
80          private static ConcurrentDictionary<string, VssFileStorage> s_storages = new ConcurrentDictionary<string, VssFileStorage>(StringComparer.OrdinalIgnoreCase);
81          public static IVssClientStorage GetVssLocalFileStorage(string fullPath, char pathSeparatorForKeys = c_defaultPathSeparator, bool ignoreCaseInPaths = c_defaultIgnoreCaseInPaths)
82          {
83              string normalizedFullPath = Path.GetFullPath(fullPath);
84              VssFileStorage storage = s_storages.GetOrAdd(normalizedFullPath, (key) => new VssFileStorage(key, pathSeparatorForKeys, ignoreCaseInPaths));
85              if (storage.PathSeparator != pathSeparatorForKeys)
86              {
87                  throw new ArgumentException(CommonResources.ConflictingPathSeparatorForVssFileStorage(pathSeparatorForKeys, normalizedFullPath, storage.PathSeparator));
88              }
89              StringComparer pathComparer = GetAppropriateStringComparer(ignoreCaseInPaths);
90              {
91                  if (storage.PathComparer != pathComparer)
92                  {
93                      string caseSensitive = "Ordinal";
94                      string caseInsensitive = "OrdinalIgnoreCase";
95                      string requested = ignoreCaseInPaths ? caseInsensitive : caseSensitive;
96                      string previous = ignoreCaseInPaths ? caseSensitive : caseInsensitive;
97                      throw new ArgumentException(CommonResources.ConflictingStringComparerForVssFileStorage(requested, normalizedFullPath, previous));
98                  }
99              }
100  #if DEBUG
101              Debug.Assert(fullPath.Equals(storage.m_filePath), string.Format("The same storage file is being referenced with different casing.  This will cause issues when running in cross patform environments where the file system may be case sensitive.  {0} != {1}", storage.m_filePath, normalizedFullPath));
102  #endif
103              return storage;
104          }
105          private static StringComparer GetAppropriateStringComparer(bool ignoreCase)
106          {
107              return ignoreCase ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal;
108          }
109          public static IVssClientStorage GetCurrentUserVssFileStorage(string pathSuffix, bool storeByVssVersion, char pathSeparatorForKeys = c_defaultPathSeparator, bool ignoreCaseInPaths = c_defaultIgnoreCaseInPaths)
110          {
111              return GetVssLocalFileStorage(Path.Combine(storeByVssVersion ? ClientSettingsDirectoryByVersion : ClientSettingsDirectory, pathSuffix), pathSeparatorForKeys, ignoreCaseInPaths);
112          }
113          internal static string ClientSettingsDirectoryByVersion
114          {
115              get
116              {
117                  return Path.Combine(ClientSettingsDirectory, "v" + GeneratedVersionInfo.ProductVersion);
118              }
119          }
120          internal static string ClientSettingsDirectory
121          {
122              get
123              {
124                  string subDir = Path.Combine("GitHub", "ActionsService");
125                  string path = Environment.GetEnvironmentVariable("localappdata");
126                  SafeGetFolderPath(Environment.SpecialFolder.LocalApplicationData);
127                  if (string.IsNullOrEmpty(path))
128                  {
129                      path = SafeGetFolderPath(Environment.SpecialFolder.ApplicationData);
130                      if (string.IsNullOrEmpty(path))
131                      {
132                          path = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);
133                          subDir = "GitHubActionsService";
134                      }
135                  }
136                  Debug.Assert(path != null, "folder path cannot be null");
137                  return Path.Combine(path, subDir);
138              }
139          }
140          private static string SafeGetFolderPath(Environment.SpecialFolder specialFolder)
141          {
142              try
143              {
144                  return Environment.GetFolderPath(specialFolder);
145              }
146              catch (ArgumentException)
147              {
148                  return null;
149              }
150          }
151          private class VssFileStorageReader : VssLocalFile, IVssClientStorageReader, IDisposable
152          {
153              private readonly string m_path;
154              private Dictionary<string, JRaw> m_settings;
155              private readonly FileSystemWatcher m_watcher;
156              private readonly ReaderWriterLockSlim m_lock;
157              private long m_completedRefreshId;
158              private long m_outstandingRefreshId;
159              public VssFileStorageReader(string fullPath, char pathSeparator, StringComparer comparer)
160                  : base(fullPath, pathSeparator, comparer)
161              {
162                  m_path = fullPath;
163                  m_lock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
164                  m_completedRefreshId = 0;
165                  m_outstandingRefreshId = 1;
166                  {
167                      string directoryToWatch = Path.GetDirectoryName(m_path);
168                      if (!Directory.Exists(directoryToWatch))
169                      {
170                          Directory.CreateDirectory(directoryToWatch);
171                      }
172                      m_watcher = new FileSystemWatcher(directoryToWatch, Path.GetFileName(m_path));
173                      m_watcher.IncludeSubdirectories = false;
174                      m_watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime;
175                      m_watcher.Changed += OnCacheFileChanged;
176                      m_watcher.EnableRaisingEvents = true;
177                  }
178              }
179              public T ReadEntry<T>(string path)
180              {
181                  return ReadEntry<T>(path, default(T));
182              }
183              public T ReadEntry<T>(string path, T defaultValue)
184              {
185                  path = NormalizePath(path);
186                  RefreshIfNeeded();
187                  Dictionary<string, JRaw> settings = m_settings;  
188                  JRaw value;
189                  if (settings.TryGetValue(path, out value) && value != null)
190                  {
191                      return JsonConvert.DeserializeObject<T>(value.ToString());
192                  }
193                  return defaultValue;
194              }
195              public IDictionary<string, T> ReadEntries<T>(string pathPrefix)
196              {
197                  string prefix = NormalizePath(pathPrefix, true);
198                  RefreshIfNeeded();
199                  Dictionary<string, JRaw> settings = m_settings;  
200                  Dictionary<string, T> matchingEntries = new Dictionary<string, T>();
201                  foreach (KeyValuePair<string, JRaw> kvp in settings.Where(kvp => kvp.Key == prefix || kvp.Key.StartsWith(prefix + PathSeparator)))
202                  {
203                      try
204                      {
205                          matchingEntries[kvp.Key] = JsonConvert.DeserializeObject<T>(kvp.Value.ToString());
206                      }
207                      catch (JsonSerializationException) { }
208                      catch (JsonReaderException) { }
209                  }
210                  return matchingEntries;
211              }
212              private void OnCacheFileChanged(object sender, FileSystemEventArgs e)
213              {
214                  NotifyChanged();
215              }
216              public void Dispose()
217              {
218                  m_watcher.Dispose();
219              }
<span onclick='openModal()' class='match'>220              public void NotifyChanged()
221              {
222                  using (new ReadLockScope(m_lock))
223                  {
224                      Interlocked.Increment(ref m_outstandingRefreshId);
</span>225                  }
226              }
227              private void RefreshIfNeeded()
228              {
229                  long requestedRefreshId;
230                  using (new ReadLockScope(m_lock))
231                  {
232                      requestedRefreshId = Interlocked.Read(ref m_outstandingRefreshId);
233                      if (m_completedRefreshId >= requestedRefreshId)
234                      {
235                          return;
236                      }
237                  }
238                  Dictionary<string, JRaw> newSettings;
239                  using (GetNewMutexScope())
240                  {
241                      if (m_completedRefreshId >= requestedRefreshId)
242                      {
243                          return;
244                      }
245                      newSettings = LoadFile();
246                  }
247                  using (new ReadLockScope(m_lock))
248                  {
249                      if (m_completedRefreshId >= requestedRefreshId)
250                      {
251                          return;
252                      }
253                  }
254                  using (new WriteLockScope(m_lock))
255                  {
256                      if (m_completedRefreshId >= requestedRefreshId)
257                      {
258                          return;
259                      }
260                      m_completedRefreshId = requestedRefreshId;
261                      m_settings = newSettings;
262                  }
263              }
264              private struct ReadLockScope : IDisposable
265              {
266                  public ReadLockScope(ReaderWriterLockSlim @lock)
267                  {
268                      m_lock = @lock;
269                      m_lock.EnterReadLock();
270                  }
271                  public void Dispose()
272                  {
273                      m_lock.ExitReadLock();
274                  }
275                  private readonly ReaderWriterLockSlim m_lock;
276              }
277              private struct WriteLockScope : IDisposable
278              {
279                  public WriteLockScope(ReaderWriterLockSlim @lock)
280                  {
281                      m_lock = @lock;
282                      m_lock.EnterWriteLock();
283                  }
284                  public void Dispose()
285                  {
286                      m_lock.ExitWriteLock();
287                  }
288                  private readonly ReaderWriterLockSlim m_lock;
289              }
290          }
291          private class VssFileStorageWriter : VssLocalFile, IVssClientStorageWriter
292          {
293              public VssFileStorageWriter(string fullPath, char pathSeparator, StringComparer comparer)
294                  : base(fullPath, pathSeparator, comparer)
295              {
296              }
297              public void WriteEntries(IEnumerable<KeyValuePair<string, object>> entries)
298              {
299                  if (entries.Any())
300                  {
301                      using (GetNewMutexScope())
302                      {
303                          bool changesMade = false;
304                          Dictionary<string, JRaw> originalSettings = LoadFile();
305                          Dictionary<string, JRaw> newSettings = new Dictionary<string, JRaw>(PathComparer);
306                          if (originalSettings.Any())
307                          {
308                              originalSettings.Copy(newSettings);
309                          }
310                          foreach (KeyValuePair<string, object> kvp in entries)
311                          {
312                              string path = NormalizePath(kvp.Key);
313                              if (kvp.Value != null)
314                              {
315                                  JRaw jRawValue = new JRaw(JsonConvert.SerializeObject(kvp.Value));
316                                  if (!newSettings.ContainsKey(path) || !newSettings[path].Equals(jRawValue))
317                                  {
318                                      newSettings[path] = jRawValue;
319                                      changesMade = true;
320                                  }
321                              }
322                              else
323                              {
324                                  if (newSettings.Remove(path))
325                                  {
326                                      changesMade = true;
327                                  }
328                              }
329                          }
330                          if (changesMade)
331                          {
332                              SaveFile(originalSettings, newSettings);
333                          }
334                      }
335                  }
336              }
337              public void WriteEntry(string path, object value)
338              {
339                  WriteEntries(new KeyValuePair<string, object>[] { new KeyValuePair<string, object>(path, value) });
340              }
341          }
342          private class VssLocalFile
343          {
344              private readonly string m_filePath;
345              private readonly string m_bckUpFilePath;
346              private readonly string m_emptyPathSegment;
347              public VssLocalFile(string filePath, char pathSeparator, StringComparer comparer)
348              {
349                  m_filePath = filePath;
350                  PathComparer = comparer;
351                  PathSeparator = pathSeparator;
352                  m_emptyPathSegment = new string(pathSeparator, 2);
353                  FileInfo fileInfo = new FileInfo(m_filePath);
354                  m_bckUpFilePath = Path.Combine(fileInfo.Directory.FullName, "~" + fileInfo.Name);
355              }
356              protected char PathSeparator { get; }
357              protected string NormalizePath(string path, bool allowRootPath = false)
358              {
359                  if (string.IsNullOrEmpty(path) || path[0] != PathSeparator || path.IndexOf(m_emptyPathSegment, StringComparison.Ordinal) >= 0 || (!allowRootPath && path.Length == 1))
360                  {
361                      throw new ArgumentException(CommonResources.InvalidClientStoragePath(path, PathSeparator), "path");
362                  }
363                  if (path[path.Length - 1] == PathSeparator)
364                  {
365                      path = path.Substring(0, path.Length - 1);
366                  }
367                  return path;
368              }
369              protected StringComparer PathComparer { get; }
370              protected Dictionary<string, JRaw> LoadFile()
371              {
372                  Dictionary<string, JRaw> settings = null;
373                  if (File.Exists(m_filePath))
374                  {
375                      settings = LoadFile(m_filePath);
376                  }
377                  if ((settings == null || !settings.Any()) && File.Exists(m_bckUpFilePath))
378                  {
379                      settings = LoadFile(m_bckUpFilePath);
380                  }
381                  return settings ?? new Dictionary<string, JRaw>(PathComparer);
382              }
383              private Dictionary<string, JRaw> LoadFile(string path)
384              {
385                  Dictionary<string, JRaw> settings = new Dictionary<string, JRaw>(PathComparer);
386                  try
387                  {
388                      string fileContent;
389                      using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete))
390                      {
391                          using (var sr = new StreamReader(fs, Encoding.UTF8))
392                          {
393                              fileContent = sr.ReadToEnd();
394                          }
395                      }
396                      IReadOnlyDictionary<string, JRaw> loadedSettings = JsonConvert.DeserializeObject<IReadOnlyDictionary<string, JRaw>>(fileContent);
397                      if (loadedSettings != null)
398                      {
399                          foreach (KeyValuePair<string, JRaw> setting in loadedSettings)
400                          {
401                              settings[setting.Key] = setting.Value;
402                          }
403                      }
404                  }
405                  catch (DirectoryNotFoundException) { }
406                  catch (FileNotFoundException) { }
407                  catch (JsonReaderException) { }
408                  catch (JsonSerializationException) { }
409                  catch (InvalidCastException) { }
410                  return settings;
411              }
412              protected void SaveFile(IDictionary<string, JRaw> originalSettings, IDictionary<string, JRaw> newSettings)
413              {
414                  string newContent = JValue.Parse(JsonConvert.SerializeObject(newSettings)).ToString(Formatting.Indented);
415                  if (originalSettings.Any())
416                  {
417                      string originalContent = JValue.Parse(JsonConvert.SerializeObject(originalSettings)).ToString(Formatting.Indented);
418                      SaveFile(m_bckUpFilePath, originalContent);
419                  }
420                  SaveFile(m_filePath, newContent);
421                  if (File.Exists(m_bckUpFilePath))
422                  {
423                      File.Delete(m_bckUpFilePath);
424                  }
425              }
426              private void SaveFile(string path, string content)
427              {
428                  bool success = false;
429                  int tries = 0;
430                  int retryDelayMilliseconds = 10;
431                  const int maxNumberOfRetries = 6;
432                  do
433                  {
434                      try
435                      {
436                          using (var fs = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.Delete))
437                          {
438                              using (var sw = new StreamWriter(fs, Encoding.UTF8))
439                              {
440                                  sw.Write(content);
441                              }
442                          }
443                          success = true;
444                      }
445                      catch (IOException)
446                      {
447                          if (++tries > maxNumberOfRetries)
448                          {
449                              throw;
450                          }
451                          Task.Delay(retryDelayMilliseconds).Wait();
452                          retryDelayMilliseconds *= 2;
453                      }
454                  }
455                  while (!success);
456              }
457              protected MutexScope GetNewMutexScope()
458              {
459                  return new MutexScope(m_filePath.Replace(Path.DirectorySeparatorChar, '_'));
460              }
461              protected struct MutexScope : IDisposable
462              {
463                  public MutexScope(string name)
464                  {
465                      m_mutex = new Mutex(false, name);
466                      try
467                      {
468                          if (!m_mutex.WaitOne(s_mutexTimeout))
469                          {
470                              throw new TimeoutException();
471                          }
472                      }
473                      catch (AbandonedMutexException)
474                      {
475                      }
476                  }
477                  public void Dispose()
478                  {
479                      m_mutex.ReleaseMutex();
480                  }
481                  private readonly Mutex m_mutex;
482                  private static readonly TimeSpan s_mutexTimeout = TimeSpan.FromSeconds(10);
483              }
484          }
485      }
486  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssFileStorage.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssFileStorage.cs</div>
                </div>
                <div class="column column_space"><pre><code>220              public void NotifyChanged()
221              {
222                  using (new ReadLockScope(m_lock))
223                  {
224                      Interlocked.Increment(ref m_outstandingRefreshId);
</pre></code></div>
                <div class="column column_space"><pre><code>220              public void NotifyChanged()
221              {
222                  using (new ReadLockScope(m_lock))
223                  {
224                      Interlocked.Increment(ref m_outstandingRefreshId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    