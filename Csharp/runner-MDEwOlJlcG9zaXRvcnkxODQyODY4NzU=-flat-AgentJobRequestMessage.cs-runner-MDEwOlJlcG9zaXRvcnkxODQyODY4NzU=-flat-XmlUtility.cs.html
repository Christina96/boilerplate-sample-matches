
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-AgentJobRequestMessage.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Linq;
5  using System.Runtime.Serialization;
6  using GitHub.DistributedTask.ObjectTemplating.Tokens;
7  using GitHub.DistributedTask.Pipelines.ContextData;
8  using GitHub.DistributedTask.WebApi;
9  using GitHub.Services.WebApi;
10  using Newtonsoft.Json;
11  namespace GitHub.DistributedTask.Pipelines
12  {
13      [DataContract]
14      [EditorBrowsable(EditorBrowsableState.Never)]
15      public sealed class AgentJobRequestMessage
16      {
17          [JsonConstructor]
18          internal AgentJobRequestMessage()
19          {
20          }
21          public AgentJobRequestMessage(
22              TaskOrchestrationPlanReference plan,
23              TimelineReference timeline,
24              Guid jobId,
25              String jobDisplayName,
26              String jobName,
27              TemplateToken jobContainer,
28              TemplateToken jobServiceContainers,
29              IList<TemplateToken> environmentVariables,
30              IDictionary<String, VariableValue> variables,
31              IList<MaskHint> maskHints,
32              JobResources jobResources,
33              DictionaryContextData contextData,
34              WorkspaceOptions workspaceOptions,
35              IEnumerable<JobStep> steps,
36              IList<String> fileTable,
<span onclick='openModal()' class='match'>37              TemplateToken jobOutputs,
38              IList<TemplateToken> defaults,
39              ActionsEnvironmentReference actionsEnvironment,
40              String messageType = JobRequestMessageTypes.PipelineAgentJobRequest)
</span>41          {
42              this.MessageType = messageType;
43              this.Plan = plan;
44              this.JobId = jobId;
45              this.JobDisplayName = jobDisplayName;
46              this.JobName = jobName;
47              this.JobContainer = jobContainer;
48              this.JobServiceContainers = jobServiceContainers;
49              this.Timeline = timeline;
50              this.Resources = jobResources;
51              this.Workspace = workspaceOptions;
52              this.JobOutputs = jobOutputs;
53              this.ActionsEnvironment = actionsEnvironment;
54              m_variables = new Dictionary<String, VariableValue>(variables, StringComparer.OrdinalIgnoreCase);
55              m_maskHints = new List<MaskHint>(maskHints);
56              m_steps = new List<JobStep>(steps);
57              if (environmentVariables?.Count > 0)
58              {
59                  m_environmentVariables = new List<TemplateToken>(environmentVariables);
60              }
61              if (defaults?.Count > 0)
62              {
63                  m_defaults = new List<TemplateToken>(defaults);
64              }
65              this.ContextData = new Dictionary<String, PipelineContextData>(StringComparer.OrdinalIgnoreCase);
66              if (contextData?.Count > 0)
67              {
68                  foreach (var pair in contextData)
69                  {
70                      this.ContextData[pair.Key] = pair.Value;
71                  }
72              }
73              if (fileTable?.Count > 0)
74              {
75                  m_fileTable = new List<String>(fileTable);
76              }
77          }
78          [DataMember]
79          public String MessageType
80          {
81              get;
82              private set;
83          }
84          [DataMember]
85          public TaskOrchestrationPlanReference Plan
86          {
87              get;
88              private set;
89          }
90          [DataMember]
91          public TimelineReference Timeline
92          {
93              get;
94              private set;
95          }
96          [DataMember]
97          public Guid JobId
98          {
99              get;
100              private set;
101          }
102          [DataMember]
103          public String JobDisplayName
104          {
105              get;
106              private set;
107          }
108          [DataMember]
109          public String JobName
110          {
111              get;
112              private set;
113          }
114          [DataMember(EmitDefaultValue = false)]
115          public TemplateToken JobContainer
116          {
117              get;
118              private set;
119          }
120          [DataMember(EmitDefaultValue = false)]
121          public TemplateToken JobServiceContainers
122          {
123              get;
124              private set;
125          }
126          [DataMember(EmitDefaultValue = false)]
127          public TemplateToken JobOutputs
128          {
129              get;
130              private set;
131          }
132          [DataMember]
133          public Int64 RequestId
134          {
135              get;
136              internal set;
137          }
138          [DataMember]
139          public DateTime LockedUntil
140          {
141              get;
142              internal set;
143          }
144          [DataMember]
145          public JobResources Resources
146          {
147              get;
148              private set;
149          }
150          [DataMember(EmitDefaultValue = false)]
151          [EditorBrowsable(EditorBrowsableState.Never)]
152          public IDictionary<String, PipelineContextData> ContextData
153          {
154              get;
155              private set;
156          }
157          [DataMember(EmitDefaultValue = false)]
158          public WorkspaceOptions Workspace
159          {
160              get;
161              private set;
162          }
163          public List<MaskHint> MaskHints
164          {
165              get
166              {
167                  if (m_maskHints == null)
168                  {
169                      m_maskHints = new List<MaskHint>();
170                  }
171                  return m_maskHints;
172              }
173          }
174          public IList<TemplateToken> EnvironmentVariables
175          {
176              get
177              {
178                  if (m_environmentVariables == null)
179                  {
180                      m_environmentVariables = new List<TemplateToken>();
181                  }
182                  return m_environmentVariables;
183              }
184          }
185          public IList<TemplateToken> Defaults
186          {
187              get
188              {
189                  if (m_defaults == null)
190                  {
191                      m_defaults = new List<TemplateToken>();
192                  }
193                  return m_defaults;
194              }
195          }
196          [DataMember(EmitDefaultValue = false)]
197          public ActionsEnvironmentReference ActionsEnvironment
198          {
199              get;
200              set;
201          }
202          public IDictionary<String, VariableValue> Variables
203          {
204              get
205              {
206                  if (m_variables == null)
207                  {
208                      m_variables = new Dictionary<String, VariableValue>(StringComparer.OrdinalIgnoreCase);
209                  }
210                  return m_variables;
211              }
212          }
213          public IList<JobStep> Steps
214          {
215              get
216              {
217                  if (m_steps == null)
218                  {
219                      m_steps = new List<JobStep>();
220                  }
221                  return m_steps;
222              }
223          }
224          public IList<String> FileTable
225          {
226              get
227              {
228                  if (m_fileTable == null)
229                  {
230                      m_fileTable = new List<String>();
231                  }
232                  return m_fileTable;
233              }
234          }
235          public void SetJobSidecarContainers(IDictionary<String, String> value)
236          {
237              m_jobSidecarContainers = value;
238          }
239          public TaskAgentMessage GetAgentMessage()
240          {
241              var body = JsonUtility.ToString(this);
242              return new TaskAgentMessage
243              {
244                  Body = body,
245                  MessageType = JobRequestMessageTypes.PipelineAgentJobRequest
246              };
247          }
248          internal static TemplateToken ConvertToTemplateToken(ContainerResource resource)
249          {
250              var result = new MappingToken(null, null, null);
251              var image = resource.Image;
252              if (!string.IsNullOrEmpty(image))
253              {
254                  result.Add(new StringToken(null, null, null, "image"), new StringToken(null, null, null, image));
255              }
256              var options = resource.Options;
257              if (!string.IsNullOrEmpty(options))
258              {
259                  result.Add(new StringToken(null, null, null, "options"), new StringToken(null, null, null, options));
260              }
261              var environment = resource.Environment;
262              if (environment?.Count > 0)
263              {
264                  var mapping = new MappingToken(null, null, null);
265                  foreach (var pair in environment)
266                  {
267                      mapping.Add(new StringToken(null, null, null, pair.Key), new StringToken(null, null, null, pair.Value));
268                  }
269                  result.Add(new StringToken(null, null, null, "env"), mapping);
270              }
271              var ports = resource.Ports;
272              if (ports?.Count > 0)
273              {
274                  var sequence = new SequenceToken(null, null, null);
275                  foreach (var item in ports)
276                  {
277                      sequence.Add(new StringToken(null, null, null, item));
278                  }
279                  result.Add(new StringToken(null, null, null, "ports"), sequence);
280              }
281              var volumes = resource.Volumes;
282              if (volumes?.Count > 0)
283              {
284                  var sequence = new SequenceToken(null, null, null);
285                  foreach (var item in volumes)
286                  {
287                      sequence.Add(new StringToken(null, null, null, item));
288                  }
289                  result.Add(new StringToken(null, null, null, "volumes"), sequence);
290              }
291              return result;
292          }
293          [OnDeserialized]
294          private void OnDeserialized(StreamingContext context)
295          {
296              if (JobContainer is StringToken jobContainerStringToken)
297              {
298                  var resourceAlias = jobContainerStringToken.Value;
299                  var resource = Resources?.Containers.SingleOrDefault(x => string.Equals(x.Alias, resourceAlias, StringComparison.OrdinalIgnoreCase));
300                  if (resource != null)
301                  {
302                      JobContainer = ConvertToTemplateToken(resource);
303                      m_jobContainerResourceAlias = resourceAlias;
304                  }
305              }
306              if (m_jobSidecarContainers?.Count > 0 && (JobServiceContainers == null || JobServiceContainers.Type == TokenType.Null))
307              {
308                  var services = new MappingToken(null, null, null);
309                  foreach (var pair in m_jobSidecarContainers)
310                  {
311                      var networkAlias = pair.Key;
312                      var serviceResourceAlias = pair.Value;
313                      var serviceResource = Resources.Containers.Single(x => string.Equals(x.Alias, serviceResourceAlias, StringComparison.OrdinalIgnoreCase));
314                      services.Add(new StringToken(null, null, null, networkAlias), ConvertToTemplateToken(serviceResource));
315                  }
316                  JobServiceContainers = services;
317              }
318          }
319          [OnSerializing]
320          private void OnSerializing(StreamingContext context)
321          {
322              if (m_environmentVariables?.Count == 0)
323              {
324                  m_environmentVariables = null;
325              }
326              if (m_defaults?.Count == 0)
327              {
328                  m_defaults = null;
329              }
330              if (m_fileTable?.Count == 0)
331              {
332                  m_fileTable = null;
333              }
334              if (m_maskHints?.Count == 0)
335              {
336                  m_maskHints = null;
337              }
338              else if (m_maskHints != null)
339              {
340                  m_maskHints = new List<MaskHint>(this.m_maskHints.Distinct());
341              }
342              if (m_variables?.Count == 0)
343              {
344                  m_variables = null;
345              }
346              if (!string.IsNullOrEmpty(m_jobContainerResourceAlias))
347              {
348                  JobContainer = new StringToken(null, null, null, m_jobContainerResourceAlias);
349              }
350          }
351          [DataMember(Name = "EnvironmentVariables", EmitDefaultValue = false)]
352          private List<TemplateToken> m_environmentVariables;
353          [DataMember(Name = "Defaults", EmitDefaultValue = false)]
354          private List<TemplateToken> m_defaults;
355          [DataMember(Name = "FileTable", EmitDefaultValue = false)]
356          private List<String> m_fileTable;
357          [DataMember(Name = "Mask", EmitDefaultValue = false)]
358          private List<MaskHint> m_maskHints;
359          [DataMember(Name = "Steps", EmitDefaultValue = false)]
360          private List<JobStep> m_steps;
361          [DataMember(Name = "Variables", EmitDefaultValue = false)]
362          private IDictionary<String, VariableValue> m_variables;
363          [DataMember(Name = "JobSidecarContainers", EmitDefaultValue = false)]
364          private IDictionary<String, String> m_jobSidecarContainers;
365          [IgnoreDataMember]
366          private string m_jobContainerResourceAlias;
367      }
368  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-XmlUtility.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Diagnostics;
5  using System.Globalization;
6  using System.IO;
7  using System.Linq;
8  using System.Threading.Tasks;
9  using System.Xml;
10  using System.Xml.Linq;
11  namespace GitHub.Services.Common.Internal
12  {
13      [EditorBrowsable(EditorBrowsableState.Never)]
14      public static class XmlUtility
15      {
16          internal static FileStream OpenFile(String path, FileShare sharing, Boolean saveFile)
17          {
18              XmlDocument noXmlDocument;
19              return OpenFileHelper(path, sharing, saveFile, false, out noXmlDocument);
20          }
21          internal static XmlDocument OpenXmlFile(out FileStream file, String path, FileShare sharing, Boolean saveFile)
22          {
23              XmlDocument xmlDocument;
24              file = OpenFileHelper(path, sharing, saveFile, true, out xmlDocument);
25              return xmlDocument;
26          }
27          private static FileStream OpenFileHelper(String path, FileShare sharing, Boolean saveFile, Boolean loadAsXmlDocument, out XmlDocument xmlDocument)
28          {
29              const int RetryCount = 10;
30              FileStream file = null;
31              xmlDocument = null;
32              if (String.IsNullOrEmpty(path))
33              {
34                  return null;
35              }
36              if (!saveFile && !File.Exists(path))
37              {
38                  return null;
39              }
40              int retries = 0;
41              Random random = null;
42              while (retries <= RetryCount)
43              {
44                  try
45                  {
46                      FileAccess fileAccess = FileAccess.Read;
47                      FileMode fileMode = FileMode.Open;
48                      if (saveFile)
49                      {
50                          fileAccess = FileAccess.ReadWrite;
51                          fileMode = FileMode.OpenOrCreate;
52                      }
53                      file = new FileStream(path, fileMode, fileAccess, sharing);
54                      if (loadAsXmlDocument)
55                      {
56                          XmlReaderSettings settings = new XmlReaderSettings()
57                          {
58                              DtdProcessing = DtdProcessing.Prohibit,
59                              XmlResolver = null,
60                          };
61                          using (XmlReader xmlReader = XmlReader.Create(file, settings))
62                          {
63                              xmlDocument = new XmlDocument();
64                              xmlDocument.Load(xmlReader);
65                          }
66                      }
67                      return file;
68                  }
69                  catch (Exception exception)
70                  {
71                      if (file != null)
72                      {
73                          file.Dispose();
74                          file = null;
75                      }
76                      if (exception is OperationCanceledException)
77                      {
78                          throw;
79                      }
80                      else if (exception is IOException || exception is UnauthorizedAccessException || exception is XmlException)
81                      {
82                          if (saveFile)
83                          {
84                              try
85                              {
86                                  if (exception is DirectoryNotFoundException)
87                                  {
88                                      String dir = Path.GetDirectoryName(path);
89                                      Directory.CreateDirectory(dir);
90                                  }
91                                  if (exception is UnauthorizedAccessException)
92                                  {
93                                      File.SetAttributes(path, FileAttributes.Normal);
94                                  }
95                                  xmlDocument = null;
96                                  return new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None);
97                              }
98                              catch (Exception newException) when (newException is IOException || newException is UnauthorizedAccessException)
99                              {
100                                  if (retries >= RetryCount)
101                                  {
102                                      throw new AggregateException(exception, newException);
103                                  }
104                              }
105                          }
106                          else
107                          {
108                              return null;
109                          }
110                      }
111                      else if (retries >= RetryCount)
112                      {
113                          throw new VssServiceException(CommonResources.ErrorReadingFile(Path.GetFileName(path), exception.Message), exception);
114                      }
115                  }
116                  if (random == null)
117                  {
118                      random = new Random();
119                  }
120                  int sleepTime = random.Next(1, 150);
121                  Task.Delay(sleepTime).Wait();
122                  retries++;
123              }
124              Debug.Fail("Code should be unreachable.");
125              return null;
126          }
127          internal static void AddXmlAttribute(XmlNode node, String attrName, String value)
128          {
129              if (value != null)
130              {
131                  XmlAttribute attr = node.OwnerDocument.CreateAttribute(null, attrName, null);
132                  node.Attributes.Append(attr);
133                  attr.InnerText = value;
134              }
135          }
136          public static XmlReaderSettings SecureReaderSettings
137          {
138              get
139              {
140                  if (s_safeSettings == null)
141                  {
142                      XmlReaderSettings settings = new XmlReaderSettings()
143                      {
144                          DtdProcessing = DtdProcessing.Prohibit,
145                          XmlResolver = null,
146                      };
147                      s_safeSettings = settings;
148                  }
149                  return s_safeSettings;
150              }
151          }
152          public static XmlDocument GetDocument(Stream input)
153          {
154              XmlDocument doc = new XmlDocument();
155              using (XmlReader xmlReader = XmlReader.Create(input, SecureReaderSettings))
156              {
157                  doc.Load(xmlReader);
158              }
159              return doc;
160          }
161          public static XmlDocument GetDocument(string xml)
162          {
163              XmlDocument doc = new XmlDocument();
164              using (StringReader stringReader = new StringReader(xml))
165              using (XmlReader xmlReader = XmlReader.Create(stringReader, SecureReaderSettings))
166              {
167                  doc.Load(xmlReader);
168              }
169              return doc;
170          }
171          public static XmlDocument GetDocumentFromPath(string path)
172          {
173              XmlDocument doc = new XmlDocument();
174              using (XmlReader xmlReader = XmlReader.Create(path, SecureReaderSettings))
175              {
176                  doc.Load(xmlReader);
177              }
178              return doc;
179          }
180          public static DateTime ToDateTime(String s)
181          {
182              DateTime time = XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
183              if (time.Kind == DateTimeKind.Unspecified &&
184                  time != DateTime.MinValue &&
185                  time != DateTime.MaxValue)
186              {
187                  time = DateTime.SpecifyKind(time, DateTimeKind.Utc);
188              }
189              if (time.Year == 1)
190              {
191                  time = DateTime.MinValue;
192              }
193              else
194              {
195                  time = time.ToLocalTime();
196              }
197              return time;
198          }
199          public static DateTime ToDateOnly(String s)
200          {
201              return XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
202          }
203          public static String ToStringDateOnly(DateTime d)
204          {
205              return d.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
206          }
207          public static String ToString(DateTime d)
208          {
209              Debug.Assert(d == DateTime.MinValue || d == DateTime.MaxValue || d.Kind != DateTimeKind.Unspecified, "DateTime kind is unspecified instead of Local or Utc.");
210              return XmlConvert.ToString(d, XmlDateTimeSerializationMode.RoundtripKind);
211          }
212          public static void ObjectToXmlElement(XmlWriter writer, String element, Object o)
213          {
214              if (o == null)
215              {
216                  writer.WriteStartElement(element);
217                  writer.WriteAttributeString("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance", "true");
218                  writer.WriteEndElement();
219              }
220              else
221              {
222                  String clrTypeName = o.GetType().FullName;
223                  String soapType = null, soapValue = null, soapNamespaceUri = null;
224                  switch (clrTypeName)
225                  {
226                      case "System.Boolean":
227                          soapType = "boolean";
228                          soapValue = XmlConvert.ToString((Boolean)o);
229                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
230                          break;
231                      case "System.Byte":
232                          soapType = "unsignedByte";
233                          soapValue = XmlConvert.ToString((Byte)o);
234                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
235                          break;
236                      case "System.Byte[]":
237                          soapType = "base64Binary";
238                          byte[] array = (byte[])o;
239                          soapValue = Convert.ToBase64String(array, 0, array.Length);
240                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
241                          break;
242                      case "System.Char":
243                          soapType = "char";
244                          soapValue = XmlConvert.ToString((UInt16)((Char)o));
245                          soapNamespaceUri = "http:&bsol;&bsol;microsoft.com/wsdl/types/";
246                          break;
247                      case "System.DateTime":
248                          soapType = "dateTime";
249                          soapValue = ToString((DateTime)o);
250                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
251                          break;
252                      case "System.Decimal":
253                          soapType = "decimal";
254                          soapValue = XmlConvert.ToString((Decimal)o);
255                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
256                          break;
257                      case "System.Double":
258                          soapType = "double";
259                          soapValue = XmlConvert.ToString((Double)o);
260                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
261                          break;
262                      case "System.Guid":
263                          soapType = "guid";
264                          soapValue = XmlConvert.ToString((Guid)o);
265                          soapNamespaceUri = "http:&bsol;&bsol;microsoft.com/wsdl/types/";
266                          break;
267                      case "System.Int16":
268                          soapType = "short";
269                          soapValue = XmlConvert.ToString((Int16)o);
270                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
271                          break;
272                      case "System.Int32":
273                          soapType = "int";
274                          soapValue = XmlConvert.ToString((Int32)o);
275                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
276                          break;
277                      case "System.Int64":
278                          soapType = "long";
279                          soapValue = XmlConvert.ToString((Int64)o);
280                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
281                          break;
282                      case "System.Single":
283                          soapType = "float";
284                          soapValue = XmlConvert.ToString((Single)o);
285                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
286                          break;
287                      case "System.String":
288                          soapType = "string";
289                          soapValue = (String)o;
290                          soapNamespaceUri = "http:&bsol;&bsol;www.w3.org/2001/XMLSchema";
291                          break;
292                      default:
293                          if (o.GetType().IsArray)
294                          {
295                              Debug.Assert(o.GetType().GetArrayRank() == 1, "ERROR: Cannot serialize multi-dimensional arrays");
296                              writer.WriteStartElement(element);
297                              writer.WriteAttributeString("type", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance", "ArrayOfAnyType");
298                              ArrayOfObjectToXml<Object>(writer, (Object[])o, null, "anyType", true, false, ObjectToXmlElement);
299                              writer.WriteEndElement();
300                              return;
301                          }
302                          else
303                          {
304                              Debug.Fail("Unknown object type for serialization " + clrTypeName);
305                              throw new ArgumentException(CommonResources.UnknownTypeForSerialization(clrTypeName));
306                          }
307                  }
308                  writer.WriteStartElement(element);
309                  writer.WriteStartAttribute("type", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance");
310                  writer.WriteQualifiedName(soapType, soapNamespaceUri);
311                  writer.WriteEndAttribute();
312                  writer.WriteValue(soapValue);
313                  writer.WriteEndElement();
314              }
315          }
316          public static Object ObjectFromXmlElement(XmlReader reader)
317          {
318              String soapTypeName = reader.GetAttribute("type", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance");
319              if (!String.IsNullOrEmpty(soapTypeName))
320              {
321                  String[] components = soapTypeName.Split(new char[] { ':' }, StringSplitOptions.None);
322                  if (components.Length == 2)
323                  {
324                      soapTypeName = components[1];
325  #if DEBUG
326                      String ns = reader.LookupNamespace(components[0]);
327                      if (!String.IsNullOrEmpty(ns) &&
328                          !ns.Equals("http:&bsol;&bsol;www.w3.org/2001/XMLSchema", StringComparison.OrdinalIgnoreCase) &&
329                          !ns.Equals("http:&bsol;&bsol;microsoft.com/wsdl/types/", StringComparison.OrdinalIgnoreCase))
330                      {
331                          Debug.Fail("Unknown namespace encountered for object type " + ns);
332                          reader.ReadOuterXml();
333                          return null;
334                      }
335  #endif
336                  }
337                  switch (soapTypeName)
338                  {
339                      case "base64Binary":
340                          String str = StringFromXmlElement(reader);
341                          if (str != null)
342                          {
343                              return Convert.FromBase64String(str);
344                          }
345                          return ZeroLengthArrayOfByte;
346                      case "boolean":
347                          return XmlConvert.ToBoolean(StringFromXmlElement(reader));
348                      case "char":
349                          return (Char)XmlConvert.ToInt16(StringFromXmlElement(reader));  
350                      case "dateTime":
351                          return ToDateTime(StringFromXmlElement(reader));
352                      case "decimal":
353                          return XmlConvert.ToDecimal(StringFromXmlElement(reader));
354                      case "double":
355                          return XmlConvert.ToDouble(StringFromXmlElement(reader));
356                      case "float":
357                          return XmlConvert.ToSingle(StringFromXmlElement(reader));
358                      case "int":
359                          return XmlConvert.ToInt32(StringFromXmlElement(reader));
360                      case "guid":
361                          return XmlConvert.ToGuid(StringFromXmlElement(reader));
362                      case "long":
363                          return XmlConvert.ToInt64(StringFromXmlElement(reader));
364                      case "short":
365                          return XmlConvert.ToInt16(StringFromXmlElement(reader));
366                      case "string":
367                          return StringFromXmlElement(reader);
368                      case "unsignedByte":
369                          return XmlConvert.ToByte(StringFromXmlElement(reader));
370                      case "ArrayOfAnyType":
371                          return ArrayOfObjectFromXml(reader);
372                      default:
373                          Debug.Fail("Unknown object type encountered " + soapTypeName);
374                          throw new ArgumentException(CommonResources.UnknownTypeForSerialization(soapTypeName));
375                  }
376              }
377              else if (reader.GetAttribute("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance") == "true")
378              {
379                  reader.ReadInnerXml();
380                  return null;
381              }
382              return null;
383          }
384          public static void ToXml(XmlWriter writer, String element, Object[] array)
385          {
386              if (array == null || array.Length == 0)
387              {
388                  return;
389              }
390              if (!String.IsNullOrEmpty(element))
391              {
392                  writer.WriteStartElement(element);
393              }
394              for (int i = 0; i < array.Length; i++)
395              {
396                  if (array[i] == null)
397                  {
398                      throw new ArgumentNullException("array[" + i + "]");
399                  }
400                  ObjectToXmlElement(writer, "anyType", array[i]);
401              }
402              if (!String.IsNullOrEmpty(element))
403              {
404                  writer.WriteEndElement();
405              }
406          }
407          public static Object[] ArrayOfObjectFromXml(XmlReader reader)
408          {
409              List<Object> list = new List<Object>();
410              bool empty = reader.IsEmptyElement;
411              Debug.Assert(reader.NodeType == XmlNodeType.Element, "Expected a node.");
412              reader.Read();
413              if (!empty)
414              {
415                  while (reader.NodeType == XmlNodeType.Element)
416                  {
417                      if (reader.HasAttributes &&
418                          reader.GetAttribute("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance") == "true")
419                      {
420                          list.Add(null);
421                          reader.Read();
422                      }
423                      else
424                      {
425                          list.Add(ObjectFromXmlElement(reader));
426                      }
427                  }
428                  reader.ReadEndElement();
429              }
430              return list.ToArray();
431          }
432          public static void ToXmlElement(XmlWriter writer, String elementName, XmlNode node)
433          {
434              if (node == null)
435              {
436                  return;
437              }
438              writer.WriteStartElement(elementName);
439              node.WriteTo(writer);
440              writer.WriteEndElement();
441          }
442          public static XmlNode XmlNodeFromXmlElement(XmlReader reader)
443          {
444              reader.Read();
445              XmlDocument document = new XmlDocument
446              {
447                  PreserveWhitespace = false
448              };
449              document.Load(reader);
450              document.Normalize();
451              reader.ReadEndElement();
452              return document.DocumentElement;
453          }
454          public static DateTime DateFromXmlAttribute(XmlReader reader)
455          {
456              return ToDateOnly(StringFromXmlAttribute(reader));
457          }
458          public static DateTime DateFromXmlElement(XmlReader reader)
459          {
460              return ToDateOnly(StringFromXmlElement(reader));
461          }
462          public static void DateToXmlAttribute(XmlWriter writer, String name, DateTime value)
463          {
464              StringToXmlAttribute(writer, name, ToStringDateOnly(value));
465          }
466          public static void DateToXmlElement(XmlWriter writer, String name, DateTime value)
467          {
468              StringToXmlElement(writer, name, ToStringDateOnly(value));
469          }
470          public static Boolean BooleanFromXmlAttribute(XmlReader reader)
471          {
472              return XmlConvert.ToBoolean(StringFromXmlAttribute(reader));
473          }
474          public static DateTime DateTimeFromXmlAttribute(XmlReader reader)
475          {
476              return ToDateTime(StringFromXmlAttribute(reader));
477          }
478          public static DateTime DateTimeFromXmlElement(XmlReader reader)
479          {
480              return ToDateTime(StringFromXmlElement(reader));
481          }
482          public static void ToXmlAttribute(XmlWriter writer, String name, DateTime value)
483          {
484              StringToXmlAttribute(writer, name, ToString(value));
485          }
486          public static void ToXmlElement(XmlWriter writer, String name, DateTime value)
487          {
488              StringToXmlElement(writer, name, ToString(value));
489          }
490          public static void ToXml(XmlWriter writer, String element, byte[] array)
491          {
492              if (array == null || array.Length == 0)
493              {
494                  return;
495              }
496              writer.WriteElementString(element, Convert.ToBase64String(array, 0, array.Length));
497          }
498          public static void ToXmlAttribute(XmlWriter writer, String attr, byte[] array)
499          {
500              if (array == null || array.Length == 0)
501              {
502                  return;
503              }
504              writer.WriteAttributeString(attr, Convert.ToBase64String(array, 0, array.Length));
505          }
506          private static XmlReaderSettings s_safeSettings;
507          public static String ToString(Uri uri)
508          {
509              return uri.AbsoluteUri;
510          }
511          public static Uri ToUri(String s)
512          {
513              if (String.IsNullOrEmpty(s))
514              {
515                  return null;
516              }
517              else
518              {
519                  return new Uri(s);
520              }
521          }
522          public static T EnumFromXmlText<T>(XmlReader reader)
523          {
524              String s = StringFromXmlText(reader);
525              s = s.Replace(' ', ',');
526              return (T)Enum.Parse(typeof(T), s, true);
527          }
528          public static void EnumToXmlText<T>(XmlWriter writer, String ignored, T value)
529          {
530              String s = Enum.Format(typeof(T), value, "G");
531              s = s.Replace(",", "");
532              writer.WriteString(s);
533          }
534          public static void EnumToXmlAttribute<T>(XmlWriter writer, String attr, T value)
535          {
536              String s = Enum.Format(typeof(T), value, "G");
537              s = s.Replace(",", "");
538              writer.WriteAttributeString(attr, s);
539          }
540          public static T EnumFromXmlAttribute<T>(XmlReader reader)
541          {
542              String s = StringFromXmlAttribute(reader);
543              s = s.Replace(' ', ',');
544              return (T)Enum.Parse(typeof(T), s, true);
545          }
546          public static void EnumToXmlElement<T>(XmlWriter writer, String element, T value)
547          {
548              String s = Enum.Format(typeof(T), value, "G");
549              s = s.Replace(",", "");
550              writer.WriteElementString(element, s);
551          }
552          public static T EnumFromXmlElement<T>(XmlReader reader)
553          {
554              String s = StringFromXmlElement(reader);
555              s = s.Replace(' ', ',');
556              return (T)Enum.Parse(typeof(T), s, true);
557          }
558          public static T[] ArrayOfObjectFromXml<T>(
559              XmlReader reader,
560              String arrayElementName,
561              Boolean inline,
562              Func<XmlReader, T> objectFromXmlElement)
563          {
564              return ArrayOfObjectFromXml<T>(null, reader, arrayElementName, inline, (x, y) => objectFromXmlElement(y));
565          }
566          public static T[] ArrayOfObjectFromXml<T>(
567              IServiceProvider serviceProvider,
568              XmlReader reader,
569              String arrayElementName,
570              Boolean inline,
571              Func<IServiceProvider, XmlReader, T> objectFromXmlElement)
572          {
573              List<T> list = new List<T>();
574              bool empty = reader.IsEmptyElement;
575              Debug.Assert(reader.NodeType == XmlNodeType.Element, "Expected a node.");
576              if (!inline)
577              {
578                  reader.Read();
579              }
580              if (!empty)
581              {
582                  while (reader.NodeType == XmlNodeType.Element && (!inline || reader.Name == arrayElementName))
583                  {
584                      if (reader.HasAttributes && reader.GetAttribute("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance") == "true")
585                      {
586                          list.Add(default(T));
587                          reader.Read();
588                      }
589                      else
590                      {
591                          list.Add(objectFromXmlElement(serviceProvider, reader));
592                      }
593                  }
594                  reader.ReadEndElement();
595              }
596              return list.ToArray();
597          }
598          public static void ArrayOfObjectToXml<T>(
599              XmlWriter writer,
600              T[] array,
601              String arrayName,
602              String arrayElementName,
603              Boolean inline,
604              Boolean allowEmptyArrays,
605              Action<XmlWriter, String, T> objectToXmlElement)
606          {
607              if (array == null)
608              {
609                  return;
610              }
611              if (array.Length == 0)
612              {
613                  if (allowEmptyArrays && !String.IsNullOrEmpty(arrayName))
614                  {
615                      writer.WriteStartElement(arrayName);
616                      writer.WriteEndElement();
617                  }
618                  return;
619              }
620              if (!inline)
621              {
622                  writer.WriteStartElement(arrayName);
623                  for (Int32 i = 0; i < array.Length; i = i + 1)
624                  {
625                      if (array[i] == null)
626                      {
627                          writer.WriteStartElement(arrayElementName);
628                          writer.WriteAttributeString("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance", "true");
629                          writer.WriteEndElement();
630                      }
631                      else
632                      {
633                          objectToXmlElement(writer, arrayElementName, array[i]);
634                      }
635                  }
636                  writer.WriteEndElement();
637              }
638              else
639              {
640                  for (Int32 i = 0; i < array.Length; i = i + 1)
641                  {
642                      if (array[i] == null)
643                      {
644                          writer.WriteStartElement(arrayElementName);
645                          writer.WriteAttributeString("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance", "true");
646                          writer.WriteEndElement();
647                      }
648                      else
649                      {
650                          objectToXmlElement(writer, arrayElementName, array[i]);
651                      }
652                  }
653              }
654          }
655          public static void EnumerableOfObjectToXml<T>(
<span onclick='openModal()' class='match'>656              XmlWriter writer,
657              IEnumerable<T> enumerable,
658              String arrayName,
659              String arrayElementName,
</span>660              Boolean inline,
661              Boolean allowEmptyArrays,
662              Action<XmlWriter, String, T> objectToXmlElement)
663          {
664              if (enumerable == null)
665              {
666                  return;
667              }
668              if (!enumerable.Any())
669              {
670                  if (allowEmptyArrays && !String.IsNullOrEmpty(arrayName))
671                  {
672                      writer.WriteStartElement(arrayName);
673                      writer.WriteEndElement();
674                  }
675                  return;
676              }
677              if (!inline)
678              {
679                  writer.WriteStartElement(arrayName);
680                  foreach (T item in enumerable)
681                  {
682                      if (item == null)
683                      {
684                          writer.WriteStartElement(arrayElementName);
685                          writer.WriteAttributeString("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance", "true");
686                          writer.WriteEndElement();
687                      }
688                      else
689                      {
690                          objectToXmlElement(writer, arrayElementName, item);
691                      }
692                  }
693                  writer.WriteEndElement();
694              }
695              else
696              {
697                  foreach (T item in enumerable)
698                  {
699                      if (item == null)
700                      {
701                          writer.WriteStartElement(arrayElementName);
702                          writer.WriteAttributeString("nil", "http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance", "true");
703                          writer.WriteEndElement();
704                      }
705                      else
706                      {
707                          objectToXmlElement(writer, arrayElementName, item);
708                      }
709                  }
710              }
711          }
712          public static Boolean BooleanFromXmlElement(XmlReader reader)
713          {
714              return XmlConvert.ToBoolean(StringFromXmlElement(reader));
715          }
716          public static Byte ByteFromXmlAttribute(XmlReader reader)
717          {
718              return XmlConvert.ToByte(StringFromXmlAttribute(reader));
719          }
720          public static Byte ByteFromXmlElement(XmlReader reader)
721          {
722              return XmlConvert.ToByte(StringFromXmlElement(reader));
723          }
724          public static Char CharFromXmlAttribute(XmlReader reader)
725          {
726              return (Char)XmlConvert.ToInt32(StringFromXmlAttribute(reader));
727          }
728          public static Char CharFromXmlElement(XmlReader reader)
729          {
730              return (Char)XmlConvert.ToInt32(StringFromXmlElement(reader));
731          }
732          public static Double DoubleFromXmlAttribute(XmlReader reader)
733          {
734              return XmlConvert.ToDouble(StringFromXmlAttribute(reader));
735          }
736          public static Double DoubleFromXmlElement(XmlReader reader)
737          {
738              return XmlConvert.ToDouble(StringFromXmlElement(reader));
739          }
740          public static Guid GuidFromXmlAttribute(XmlReader reader)
741          {
742              return XmlConvert.ToGuid(StringFromXmlAttribute(reader));
743          }
744          public static Guid GuidFromXmlElement(XmlReader reader)
745          {
746              return XmlConvert.ToGuid(StringFromXmlElement(reader));
747          }
748          public static Int16 Int16FromXmlAttribute(XmlReader reader)
749          {
750              return XmlConvert.ToInt16(StringFromXmlAttribute(reader));
751          }
752          public static Int16 Int16FromXmlElement(XmlReader reader)
753          {
754              return XmlConvert.ToInt16(StringFromXmlElement(reader));
755          }
756          public static Int32 Int32FromXmlAttribute(XmlReader reader)
757          {
758              return XmlConvert.ToInt32(StringFromXmlAttribute(reader));
759          }
760          public static Int32 Int32FromXmlElement(XmlReader reader)
761          {
762              return XmlConvert.ToInt32(StringFromXmlElement(reader));
763          }
764          public static Int64 Int64FromXmlAttribute(XmlReader reader)
765          {
766              return XmlConvert.ToInt64(StringFromXmlAttribute(reader));
767          }
768          public static Int64 Int64FromXmlElement(XmlReader reader)
769          {
770              return XmlConvert.ToInt64(StringFromXmlElement(reader));
771          }
772          public static Single SingleFromXmlAttribute(XmlReader reader)
773          {
774              return XmlConvert.ToSingle(StringFromXmlAttribute(reader));
775          }
776          public static Single SingleFromXmlElement(XmlReader reader)
777          {
778              return XmlConvert.ToSingle(StringFromXmlElement(reader));
779          }
780          public static String StringFromXmlAttribute(XmlReader reader)
781          {
782              return GetCachedString(reader.Value);
783          }
784          public static String StringFromXmlElement(XmlReader reader)
785          {
786              String str = String.Empty;
787              Boolean isEmpty = reader.IsEmptyElement;
788              Debug.Assert(reader.NodeType == XmlNodeType.Element, "Expected a node.");
789              reader.Read();
790              if (!isEmpty)
791              {
792                  if (reader.NodeType == XmlNodeType.CDATA ||
793                      reader.NodeType == XmlNodeType.Text ||
794                      reader.NodeType == XmlNodeType.Whitespace)
795                  {
796                      str = GetCachedString(reader.ReadContentAsString().Replace("\n", "\r\n"));
797                      reader.ReadEndElement();
798                  }
799                  else if (reader.NodeType == XmlNodeType.EndElement)
800                  {
801                      reader.ReadEndElement();
802                  }
803              }
804              return str;
805          }
806          public static String StringFromXmlText(XmlReader reader)
807          {
808              String str = String.Empty;
809              if (reader.NodeType == XmlNodeType.CDATA ||
810                  reader.NodeType == XmlNodeType.Text ||
811                  reader.NodeType == XmlNodeType.Whitespace)
812              {
813                  str = GetCachedString(reader.ReadContentAsString().Replace("\n", "\r\n"));
814              }
815              return str;
816          }
817          public static TimeSpan TimeSpanFromXmlAttribute(XmlReader reader)
818          {
819              return XmlConvert.ToTimeSpan(StringFromXmlAttribute(reader));
820          }
821          public static TimeSpan TimeSpanFromXmlElement(XmlReader reader)
822          {
823              return XmlConvert.ToTimeSpan(StringFromXmlElement(reader));
824          }
825          public static UInt16 UInt16FromXmlAttribute(XmlReader reader)
826          {
827              return XmlConvert.ToUInt16(StringFromXmlAttribute(reader));
828          }
829          public static UInt16 UInt16FromXmlElement(XmlReader reader)
830          {
831              return XmlConvert.ToUInt16(StringFromXmlElement(reader));
832          }
833          public static UInt32 UInt32FromXmlAttribute(XmlReader reader)
834          {
835              return XmlConvert.ToUInt32(StringFromXmlAttribute(reader));
836          }
837          public static UInt32 UInt32FromXmlElement(XmlReader reader)
838          {
839              return XmlConvert.ToUInt32(StringFromXmlElement(reader));
840          }
841          public static UInt64 UInt64FromXmlAttribute(XmlReader reader)
842          {
843              return XmlConvert.ToUInt64(StringFromXmlAttribute(reader));
844          }
845          public static UInt64 UInt64FromXmlElement(XmlReader reader)
846          {
847              return XmlConvert.ToUInt64(StringFromXmlElement(reader));
848          }
849          public static Uri UriFromXmlAttribute(XmlReader reader)
850          {
851              return ToUri(StringFromXmlAttribute(reader));
852          }
853          public static Uri UriFromXmlElement(XmlReader reader)
854          {
855              return ToUri(StringFromXmlElement(reader));
856          }
857          public static void ToXmlAttribute(XmlWriter writer, String name, Boolean value)
858          {
859              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
860          }
861          public static void ToXmlAttribute(XmlWriter writer, String name, Byte value)
862          {
863              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
864          }
865          public static void ToXmlAttribute(XmlWriter writer, String name, Char value)
866          {
867              StringToXmlAttribute(writer, name, XmlConvert.ToString((Int32)value));
868          }
869          public static void ToXmlAttribute(XmlWriter writer, String name, Double value)
870          {
871              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
872          }
873          public static void ToXmlAttribute(XmlWriter writer, String name, Guid value)
874          {
875              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
876          }
877          public static void ToXmlAttribute(XmlWriter writer, String name, Int16 value)
878          {
879              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
880          }
881          public static void ToXmlAttribute(XmlWriter writer, String name, Int32 value)
882          {
883              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
884          }
885          public static void ToXmlAttribute(XmlWriter writer, String name, Int64 value)
886          {
887              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
888          }
889          public static void ToXmlAttribute(XmlWriter writer, String name, Single value)
890          {
891              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
892          }
893          public static void ToXmlAttribute(XmlWriter writer, String name, String value)
894          {
895              StringToXmlAttribute(writer, name, value);
896          }
897          public static void ToXmlAttribute(XmlWriter writer, String name, TimeSpan value)
898          {
899              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
900          }
901          public static void ToXmlAttribute(XmlWriter writer, String name, UInt16 value)
902          {
903              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
904          }
905          public static void ToXmlAttribute(XmlWriter writer, String name, UInt32 value)
906          {
907              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
908          }
909          public static void ToXmlAttribute(XmlWriter writer, String name, UInt64 value)
910          {
911              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
912          }
913          public static void ToXmlAttribute(XmlWriter writer, String name, Uri value)
914          {
915              StringToXmlAttribute(writer, name, ToString(value));
916          }
917          public static void ToXmlElement(XmlWriter writer, String name, Boolean value)
918          {
919              StringToXmlElement(writer, name, XmlConvert.ToString(value));
920          }
921          public static void ToXmlElement(XmlWriter writer, String name, Byte value)
922          {
923              StringToXmlElement(writer, name, XmlConvert.ToString(value));
924          }
925          public static void ToXmlElement(XmlWriter writer, String name, Char value)
926          {
927              StringToXmlElement(writer, name, XmlConvert.ToString((Int32)value));
928          }
929          public static void ToXmlElement(XmlWriter writer, String name, Double value)
930          {
931              StringToXmlElement(writer, name, XmlConvert.ToString(value));
932          }
933          public static void ToXmlElement(XmlWriter writer, String name, Guid value)
934          {
935              StringToXmlElement(writer, name, XmlConvert.ToString(value));
936          }
937          public static void ToXmlElement(XmlWriter writer, String element, Int16 value)
938          {
939              StringToXmlElement(writer, element, XmlConvert.ToString(value));
940          }
941          public static void ToXmlElement(XmlWriter writer, String element, Int32 value)
942          {
943              StringToXmlElement(writer, element, XmlConvert.ToString(value));
944          }
945          public static void ToXmlElement(XmlWriter writer, String element, Int64 value)
946          {
947              StringToXmlElement(writer, element, XmlConvert.ToString(value));
948          }
949          public static void ToXmlElement(XmlWriter writer, String name, Single value)
950          {
951              StringToXmlElement(writer, name, XmlConvert.ToString(value));
952          }
953          public static void ToXmlElement(XmlWriter writer, String name, String value)
954          {
955              StringToXmlElement(writer, name, value);
956          }
957          public static void ToXmlElement(XmlWriter writer, String name, TimeSpan value)
958          {
959              StringToXmlElement(writer, name, XmlConvert.ToString(value));
960          }
961          public static void ToXmlElement(XmlWriter writer, String element, UInt16 value)
962          {
963              StringToXmlElement(writer, element, XmlConvert.ToString(value));
964          }
965          public static void ToXmlElement(XmlWriter writer, String element, UInt32 value)
966          {
967              StringToXmlElement(writer, element, XmlConvert.ToString(value));
968          }
969          public static void ToXmlElement(XmlWriter writer, String element, UInt64 value)
970          {
971              StringToXmlElement(writer, element, XmlConvert.ToString(value));
972          }
973          public static void ToXmlElement(XmlWriter writer, String name, Uri value)
974          {
975              StringToXmlElement(writer, name, ToString(value));
976          }
977          public static void StringToXmlAttribute(XmlWriter writer, String name, String value)
978          {
979              writer.WriteAttributeString(name, value);
980          }
981          public static void StringToXmlElement(XmlWriter writer, String name, String value)
982          {
983              try
984              {
985                  writer.WriteElementString(name, value);
986              }
987              catch (ArgumentException e)
988              {
989                  Debug.Assert(e.Message.IndexOf("invalid character", StringComparison.OrdinalIgnoreCase) > 0, "Unexpected exception: " + e.ToString());
990                  throw new VssServiceException(CommonResources.StringContainsIllegalChars(), e);
991              }
992          }
993          public static void StringToXmlText(XmlWriter writer, String str)
994          {
995              if (str == null)
996              {
997                  return;
998              }
999              try
1000              {
1001                  writer.WriteString(str);
1002              }
1003              catch (ArgumentException e)
1004              {
1005                  Debug.Assert(e.Message.IndexOf("invalid character", StringComparison.OrdinalIgnoreCase) > 0, "Unexpected exception: " + e.ToString());
1006                  throw new VssServiceException(CommonResources.StringContainsIllegalChars(), e);
1007              }
1008          }
1009          public static byte[] ArrayOfByteFromXml(XmlReader reader)
1010          {
1011              String str = StringFromXmlElement(reader);
1012              if (str != null)
1013              {
1014                  return Convert.FromBase64String(str);
1015              }
1016              return ZeroLengthArrayOfByte;
1017          }
1018          public static byte[] ArrayOfByteFromXmlAttribute(XmlReader reader)
1019          {
1020              if (reader.Value.Length != 0)
1021              {
1022                  return Convert.FromBase64String(reader.Value);
1023              }
1024              return ZeroLengthArrayOfByte;
1025          }
1026          public static byte[] ZeroLengthArrayOfByte
1027          {
1028              get
1029              {
1030                  if (s_zeroLengthArrayOfByte == null)
1031                  {
1032                      s_zeroLengthArrayOfByte = new byte[0];
1033                  }
1034                  return s_zeroLengthArrayOfByte;
1035              }
1036          }
1037          public static bool CompareXmlDocuments(string xml1, string xml2)
1038          {
1039              if (xml1 == xml2)
1040              {
1041                  return true;
1042              }
1043              else if (string.IsNullOrEmpty(xml1) || string.IsNullOrEmpty(xml2))
1044              {
1045                  return false;
1046              }
1047              XDocument x1 = XDocument.Parse(xml1);
1048              XDocument x2 = XDocument.Parse(xml2);
1049              return Compare(x1?.Root, x2?.Root);
1050          }
1051          private static bool Compare(XContainer x1, XContainer x2)
1052          {
1053              if (object.ReferenceEquals(x1, x2))
1054              {
1055                  return true;
1056              }
1057              XElement e1 = x1 as XElement;
1058              XElement e2 = x2 as XElement;
1059              if (e1 != null && e2 != null)
1060              {
1061                  if (!VssStringComparer.XmlNodeName.Equals(e1.Name.ToString(), e2.Name.ToString()) ||
1062                      !e1.Attributes().OrderBy(a => a.Name.ToString()).SequenceEqual(e2.Attributes().OrderBy(a => a.Name.ToString()), s_xmlAttributeComparer) ||
1063                      !VssStringComparer.XmlElement.Equals(e1.Value, e2.Value))
1064                  {
1065                      return false;
1066                  }
1067                  return x1.Elements().OrderBy(xe => xe.Name.ToString()).SequenceEqual(x2.Elements().OrderBy(xe => xe.Name.ToString()), s_xmlElementComparer);
1068              }
1069              return false;
1070          }
1071          #region GetCachedString
1072          private static String GetCachedString(String fromXml)
1073          {
1074              if (null == fromXml)
1075              {
1076                  return null;
1077              }
1078              int fromXmlLength = fromXml.Length;
1079              if (fromXmlLength > 256)
1080              {
1081                  return fromXml;
1082              }
1083              if (fromXmlLength == 0)
1084              {
1085                  return String.Empty;
1086              }
1087              String[] stringList = ts_stringList;
1088              if (null == stringList)
1089              {
1090                  stringList = new String[c_stringCacheSize];
1091                  ts_stringList = stringList;
1092              }
1093              for (int i = 0; i < c_stringCacheSize; i++)
1094              {
1095                  String cachedString = stringList[i];
1096                  if (null == cachedString)
1097                  {
1098                      break;
1099                  }
1100                  if (cachedString.Length != fromXmlLength ||
1101                      fromXml[0] != cachedString[0])
1102                  {
1103                      continue;
1104                  }
1105                  if (fromXmlLength > 5 &&
1106                      fromXml[fromXmlLength - 5] != cachedString[fromXmlLength - 5])
1107                  {
1108                      continue;
1109                  }
1110                  if (String.Equals(fromXml, cachedString, StringComparison.Ordinal))
1111                  {
1112                      for (int j = i - 1; j >= 0; j--)
1113                      {
1114                          stringList[j + 1] = stringList[j];
1115                      }
1116                      stringList[0] = cachedString;
1117                      return cachedString;
1118                  }
1119              }
1120              for (int i = c_stringCacheSize - 2; i >= 0; i--)
1121              {
1122                  stringList[i + 1] = stringList[i];
1123              }
1124              stringList[0] = fromXml;
1125              return fromXml;
1126          }
1127          [ThreadStatic]
1128          private static String[] ts_stringList;
1129          private const int c_stringCacheSize = 16;
1130          #endregion GetCachedString
1131          private class AttributeComparer : IEqualityComparer<XAttribute>
1132          {
1133              public bool Equals(XAttribute x, XAttribute y)
1134              {
1135                  if (x == y)
1136                  {
1137                      return true;
1138                  }
1139                  if (x == null || y == null)
1140                  {
1141                      return false;
1142                  }
1143                  return VssStringComparer.XmlAttributeName.Equals(x.Name.ToString(), y.Name.ToString()) &&
1144                      VssStringComparer.XmlAttributeValue.Equals(x.Value, y.Value);
1145              }
1146              public int GetHashCode(XAttribute obj)
1147              {
1148                  if (obj == null)
1149                  {
1150                      return 0;
1151                  }
1152                  return obj.GetHashCode();
1153              }
1154          }
1155          private class ElementComparer : IEqualityComparer<XElement>
1156          {
1157              public bool Equals(XElement x, XElement y)
1158              {
1159                  if (x == y)
1160                  {
1161                      return true;
1162                  }
1163                  if (x == null || y == null)
1164                  {
1165                      return false;
1166                  }
1167                  return XmlUtility.Compare(x, y);
1168              }
1169              public int GetHashCode(XElement obj)
1170              {
1171                  if (obj == null)
1172                  {
1173                      return 0;
1174                  }
1175                  return obj.GetHashCode();
1176              }
1177          }
1178          private static byte[] s_zeroLengthArrayOfByte;
1179          private static readonly AttributeComparer s_xmlAttributeComparer = new AttributeComparer();
1180          private static readonly ElementComparer s_xmlElementComparer = new ElementComparer();
1181      }
1182      [EditorBrowsable(EditorBrowsableState.Never)]
1183      public class XmlElementWriterUtility : IDisposable
1184      {
1185          private XmlWriter m_xmlWriter;
1186          public XmlElementWriterUtility(string elementName, XmlWriter xmlWriter)
1187          {
1188              m_xmlWriter = xmlWriter;
1189              m_xmlWriter.WriteStartElement(elementName);
1190          }
1191          public void Dispose()
1192          {
1193              m_xmlWriter.WriteEndElement();
1194          }
1195      }
1196  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-AgentJobRequestMessage.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-XmlUtility.cs</div>
                </div>
                <div class="column column_space"><pre><code>37              TemplateToken jobOutputs,
38              IList<TemplateToken> defaults,
39              ActionsEnvironmentReference actionsEnvironment,
40              String messageType = JobRequestMessageTypes.PipelineAgentJobRequest)
</pre></code></div>
                <div class="column column_space"><pre><code>656              XmlWriter writer,
657              IEnumerable<T> enumerable,
658              String arrayName,
659              String arrayElementName,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    