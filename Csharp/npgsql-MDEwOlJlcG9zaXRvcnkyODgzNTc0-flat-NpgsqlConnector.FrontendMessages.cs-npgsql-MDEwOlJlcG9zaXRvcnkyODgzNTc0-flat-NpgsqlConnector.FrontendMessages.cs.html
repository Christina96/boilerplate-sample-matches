
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 51, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnector.FrontendMessages.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Linq;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Npgsql.Util;
8  namespace Npgsql.Internal;
9  partial class NpgsqlConnector
10  {
11      internal Task WriteDescribe(StatementOrPortal statementOrPortal, string name, bool async, CancellationToken cancellationToken = default)
12      {
13          Debug.Assert(name.All(c => c < 128));
14          var len = sizeof(byte) +       
15                    sizeof(int)  +       
16                    sizeof(byte) +       
17                    (name.Length + 1);   
18          if (WriteBuffer.WriteSpaceLeft < len)
19              return FlushAndWrite(len, statementOrPortal, name, async, cancellationToken);
20          Write(len, statementOrPortal, name);
21          return Task.CompletedTask;
22          async Task FlushAndWrite(int len, StatementOrPortal statementOrPortal, string name, bool async, CancellationToken cancellationToken)
23          {
24              await Flush(async, cancellationToken);
25              Debug.Assert(len <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length {len} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
26              Write(len, statementOrPortal, name);
<span onclick='openModal()' class='match'>27          }
28          void Write(int len, StatementOrPortal statementOrPortal, string name)
29          {
30              WriteBuffer.WriteByte(FrontendMessageCode.Describe);
31              WriteBuffer.WriteInt32(len - 1);
32              WriteBuffer.WriteByte((byte)statementOrPortal);
33              WriteBuffer.WriteNullTerminatedString(name);
34          }
35      }
36      internal Task WriteSync(bool async, CancellationToken cancellationToken = default)
</span>37      {
38          const int len = sizeof(byte) +  
39                          sizeof(int);    
40          if (WriteBuffer.WriteSpaceLeft < len)
41              return FlushAndWrite(async, cancellationToken);
42          Write();
43          return Task.CompletedTask;
44          async Task FlushAndWrite(bool async, CancellationToken cancellationToken)
45          {
46              await Flush(async, cancellationToken);
47              Debug.Assert(len <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length {len} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
48              Write();
49          }
50          void Write()
51          {
52              WriteBuffer.WriteByte(FrontendMessageCode.Sync);
53              WriteBuffer.WriteInt32(len - 1);
54          }
55      }
56      internal Task WriteExecute(int maxRows, bool async, CancellationToken cancellationToken = default)
57      {
58          const int len = sizeof(byte) +       
59                          sizeof(int)  +       
60                          sizeof(byte) +       
61                          sizeof(int);         
62          if (WriteBuffer.WriteSpaceLeft < len)
63              return FlushAndWrite(maxRows, async, cancellationToken);
64          Write(maxRows);
65          return Task.CompletedTask;
66          async Task FlushAndWrite(int maxRows, bool async, CancellationToken cancellationToken)
67          {
68              await Flush(async, cancellationToken);
69              Debug.Assert(10 <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length 10 which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
70              Write(maxRows);
71          }
72          void Write(int maxRows)
73          {
74              WriteBuffer.WriteByte(FrontendMessageCode.Execute);
75              WriteBuffer.WriteInt32(len - 1);
76              WriteBuffer.WriteByte(0);   
77              WriteBuffer.WriteInt32(maxRows);
78          }
79      }
80      internal async Task WriteParse(string sql, string statementName, List<NpgsqlParameter> inputParameters, bool async, CancellationToken cancellationToken = default)
81      {
82          Debug.Assert(statementName.All(c => c < 128));
83          int queryByteLen;
84          try
85          {
86              queryByteLen = TextEncoding.GetByteCount(sql);
87          }
88          catch (Exception e)
89          {
90              Break(e);
91              throw;
92          }
93          if (WriteBuffer.WriteSpaceLeft < 1 + 4 + statementName.Length + 1)
94              await Flush(async, cancellationToken);
95          var messageLength =
96              sizeof(byte)                +         
97              sizeof(int)                 +         
98              statementName.Length        +         
99              sizeof(byte)                +         
100              queryByteLen + sizeof(byte) +         
101              sizeof(ushort)              +         
102              inputParameters.Count * sizeof(int);  
103          WriteBuffer.WriteByte(FrontendMessageCode.Parse);
104          WriteBuffer.WriteInt32(messageLength - 1);
105          WriteBuffer.WriteNullTerminatedString(statementName);
106          await WriteBuffer.WriteString(sql, queryByteLen, async, cancellationToken);
107          if (WriteBuffer.WriteSpaceLeft < 1 + 2)
108              await Flush(async, cancellationToken);
109          WriteBuffer.WriteByte(0); 
110          WriteBuffer.WriteUInt16((ushort)inputParameters.Count);
111          foreach (var p in inputParameters)
112          {
113              if (WriteBuffer.WriteSpaceLeft < 4)
114                  await Flush(async, cancellationToken);
115              WriteBuffer.WriteInt32((int)p.Handler!.PostgresType.OID);
116          }
117      }
118      internal async Task WriteBind(
119          List<NpgsqlParameter> parameters,
120          string portal,
121          string statement,
122          bool allResultTypesAreUnknown,
123          bool[]? unknownResultTypeList,
124          bool async,
125          CancellationToken cancellationToken = default)
126      {
127          Debug.Assert(statement.All(c => c < 128));
128          Debug.Assert(portal.All(c => c < 128));
129          var headerLength =
130              sizeof(byte)                    +     
131              sizeof(int)                     +     
132              sizeof(byte)                    +     
133              statement.Length + sizeof(byte) +     
134              sizeof(ushort);                       
135          if (WriteBuffer.WriteSpaceLeft < headerLength)
136          {
137              Debug.Assert(WriteBuffer.Size >= headerLength, "Write buffer too small for Bind header");
138              await Flush(async, cancellationToken);
139          }
140          var formatCodesSum = 0;
141          var paramsLength = 0;
142          for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)
143          {
144              var param = parameters[paramIndex];
145              formatCodesSum += (int)param.FormatCode;
146              param.LengthCache?.Rewind();
147              paramsLength += param.ValidateAndGetLength();
148          }
149          var formatCodeListLength = formatCodesSum == 0 ? 0 : formatCodesSum == parameters.Count ? 1 : parameters.Count;
150          var messageLength = headerLength         +
151                              sizeof(short) * formatCodeListLength +                  
152                              sizeof(short)                        +                  
153                              sizeof(int) * parameters.Count  +                       
154                              paramsLength                         +                  
155                              sizeof(short)                        +                  
156                              sizeof(short) * (unknownResultTypeList?.Length ?? 1);   
157          WriteBuffer.WriteByte(FrontendMessageCode.Bind);
158          WriteBuffer.WriteInt32(messageLength - 1);
159          Debug.Assert(portal == string.Empty);
160          WriteBuffer.WriteByte(0);  
161          WriteBuffer.WriteNullTerminatedString(statement);
162          WriteBuffer.WriteInt16(formatCodeListLength);
163          if (formatCodeListLength == 1)
164          {
165              if (WriteBuffer.WriteSpaceLeft < 2)
166                  await Flush(async, cancellationToken);
167              WriteBuffer.WriteInt16((short)FormatCode.Binary);
168          }
169          else if (formatCodeListLength > 1)
170          {
171              for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)
172              {
173                  if (WriteBuffer.WriteSpaceLeft < 2)
174                      await Flush(async, cancellationToken);
175                  WriteBuffer.WriteInt16((short)parameters[paramIndex].FormatCode);
176              }
177          }
178          if (WriteBuffer.WriteSpaceLeft < 2)
179              await Flush(async, cancellationToken);
180          WriteBuffer.WriteUInt16((ushort)parameters.Count);
181          for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)
182          {
183              var param = parameters[paramIndex];
184              param.LengthCache?.Rewind();
185              await param.WriteWithLength(WriteBuffer, async, cancellationToken);
186          }
187          if (unknownResultTypeList != null)
188          {
189              if (WriteBuffer.WriteSpaceLeft < 2 + unknownResultTypeList.Length * 2)
190                  await Flush(async, cancellationToken);
191              WriteBuffer.WriteInt16(unknownResultTypeList.Length);
192              foreach (var t in unknownResultTypeList)
193                  WriteBuffer.WriteInt16(t ? 0 : 1);
194          }
195          else
196          {
197              if (WriteBuffer.WriteSpaceLeft < 4)
198                  await Flush(async, cancellationToken);
199              WriteBuffer.WriteInt16(1);
200              WriteBuffer.WriteInt16(allResultTypesAreUnknown ? 0 : 1);
201          }
202      }
203      internal Task WriteClose(StatementOrPortal type, string name, bool async, CancellationToken cancellationToken = default)
204      {
205          var len = sizeof(byte) +               
206                    sizeof(int)  +               
207                    sizeof(byte) +               
208                    name.Length + sizeof(byte);  
209          if (WriteBuffer.WriteSpaceLeft < len)
210              return FlushAndWrite(len, type, name, async, cancellationToken);
211          Write(len, type, name);
212          return Task.CompletedTask;
213          async Task FlushAndWrite(int len, StatementOrPortal type, string name, bool async, CancellationToken cancellationToken)
214          {
215              await Flush(async, cancellationToken);
216              Debug.Assert(len <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length {len} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
217              Write(len, type, name);
218          }
219          void Write(int len, StatementOrPortal type, string name)
220          {
221              WriteBuffer.WriteByte(FrontendMessageCode.Close);
222              WriteBuffer.WriteInt32(len - 1);
223              WriteBuffer.WriteByte((byte)type);
224              WriteBuffer.WriteNullTerminatedString(name);
225          }
226      }
227      internal void WriteQuery(string sql) => WriteQuery(sql, false).GetAwaiter().GetResult();
228      internal async Task WriteQuery(string sql, bool async, CancellationToken cancellationToken = default)
229      {
230          var queryByteLen = TextEncoding.GetByteCount(sql);
231          if (WriteBuffer.WriteSpaceLeft < 1 + 4)
232              await Flush(async, cancellationToken);
233          WriteBuffer.WriteByte(FrontendMessageCode.Query);
234          WriteBuffer.WriteInt32(
235              sizeof(int)  +        
236              queryByteLen +        
237              sizeof(byte));        
238          await WriteBuffer.WriteString(sql, queryByteLen, async, cancellationToken);
239          if (WriteBuffer.WriteSpaceLeft < 1)
240              await Flush(async, cancellationToken);
241          WriteBuffer.WriteByte(0);  
242      }
243      internal void WriteCopyDone() => WriteCopyDone(false).GetAwaiter().GetResult();
244      internal async Task WriteCopyDone(bool async, CancellationToken cancellationToken = default)
245      {
246          const int len = sizeof(byte) +   
247                          sizeof(int);     
248          if (WriteBuffer.WriteSpaceLeft < len)
249              await Flush(async, cancellationToken);
250          WriteBuffer.WriteByte(FrontendMessageCode.CopyDone);
251          WriteBuffer.WriteInt32(len - 1);
252      }
253      internal async Task WriteCopyFail(bool async, CancellationToken cancellationToken = default)
254      {
255          const int len = sizeof(byte) +  
256                          sizeof(int) +   
257                          sizeof(byte);   
258          if (WriteBuffer.WriteSpaceLeft < len)
259              await Flush(async, cancellationToken);
260          WriteBuffer.WriteByte(FrontendMessageCode.CopyFail);
261          WriteBuffer.WriteInt32(len - 1);
262          WriteBuffer.WriteByte(0);   
263      }
264      internal void WriteCancelRequest(int backendProcessId, int backendSecretKey)
265      {
266          const int len = sizeof(int) +  
267                          sizeof(int) +  
268                          sizeof(int) +  
269                          sizeof(int);   
270          Debug.Assert(backendProcessId != 0);
271          if (WriteBuffer.WriteSpaceLeft < len)
272              Flush(false).GetAwaiter().GetResult();
273          WriteBuffer.WriteInt32(len);
274          WriteBuffer.WriteInt32(1234 << 16 | 5678);
275          WriteBuffer.WriteInt32(backendProcessId);
276          WriteBuffer.WriteInt32(backendSecretKey);
277      }
278      internal void WriteTerminate()
279      {
280          const int len = sizeof(byte) +  
281                          sizeof(int);    
282          if (WriteBuffer.WriteSpaceLeft < len)
283              Flush(false).GetAwaiter().GetResult();
284          WriteBuffer.WriteByte(FrontendMessageCode.Terminate);
285          WriteBuffer.WriteInt32(len - 1);
286      }
287      internal void WriteSslRequest()
288      {
289          const int len = sizeof(int) +  
290                          sizeof(int);   
291          if (WriteBuffer.WriteSpaceLeft < len)
292              Flush(false).GetAwaiter().GetResult();
293          WriteBuffer.WriteInt32(len);
294          WriteBuffer.WriteInt32(80877103);
295      }
296      internal void WriteStartup(Dictionary<string, string> parameters)
297      {
298          const int protocolVersion3 = 3 << 16; 
299          var len = sizeof(int) +  
300                    sizeof(int) +  
301                    sizeof(byte);  
302          foreach (var kvp in parameters)
303              len += PGUtil.UTF8Encoding.GetByteCount(kvp.Key) + 1 +
304                     PGUtil.UTF8Encoding.GetByteCount(kvp.Value) + 1;
305          if (len > WriteBuffer.Size)
306              throw new Exception("Startup message bigger than buffer");
307          WriteBuffer.WriteInt32(len);
308          WriteBuffer.WriteInt32(protocolVersion3);
309          foreach (var kv in parameters)
310          {
311              WriteBuffer.WriteString(kv.Key);
312              WriteBuffer.WriteByte(0);
313              WriteBuffer.WriteString(kv.Value);
314              WriteBuffer.WriteByte(0);
315          }
316          WriteBuffer.WriteByte(0);
317      }
318      #region Authentication
319      internal Task WritePassword(byte[] payload, bool async, CancellationToken cancellationToken = default) => WritePassword(payload, 0, payload.Length, async, cancellationToken);
320      internal async Task WritePassword(byte[] payload, int offset, int count, bool async, CancellationToken cancellationToken = default)
321      {
322          if (WriteBuffer.WriteSpaceLeft < sizeof(byte) + sizeof(int))
323              await WriteBuffer.Flush(async, cancellationToken);
324          WriteBuffer.WriteByte(FrontendMessageCode.Password);
325          WriteBuffer.WriteInt32(sizeof(int) + count);
326          if (count <= WriteBuffer.WriteSpaceLeft)
327          {
328              WriteBuffer.WriteBytes(payload, offset, count);
329              return;
330          }
331          await WriteBuffer.Flush(async, cancellationToken);
332          await WriteBuffer.DirectWrite(new ReadOnlyMemory<byte>(payload, offset, count), async, cancellationToken);
333      }
334      internal async Task WriteSASLInitialResponse(string mechanism, byte[] initialResponse, bool async, CancellationToken cancellationToken = default)
335      {
336          var len = sizeof(byte)                                               +  
337                    sizeof(int)                                                +  
338                    PGUtil.UTF8Encoding.GetByteCount(mechanism) + sizeof(byte) +  
339                    sizeof(int)                                                +  
340                    (initialResponse?.Length ?? 0);                               
341          if (WriteBuffer.WriteSpaceLeft < len)
342              await WriteBuffer.Flush(async, cancellationToken);
343          WriteBuffer.WriteByte(FrontendMessageCode.Password);
344          WriteBuffer.WriteInt32(len - 1);
345          WriteBuffer.WriteString(mechanism);
346          WriteBuffer.WriteByte(0);   
347          if (initialResponse == null)
348              WriteBuffer.WriteInt32(-1);
349          else
350          {
351              WriteBuffer.WriteInt32(initialResponse.Length);
352              WriteBuffer.WriteBytes(initialResponse);
353          }
354      }
355      internal Task WriteSASLResponse(byte[] payload, bool async, CancellationToken cancellationToken = default) => WritePassword(payload, async, cancellationToken);
356      #endregion Authentication
357      internal Task WritePregenerated(byte[] data, bool async = false, CancellationToken cancellationToken = default)
358      {
359          if (WriteBuffer.WriteSpaceLeft < data.Length)
360              return FlushAndWrite(data, async, cancellationToken);
361          WriteBuffer.WriteBytes(data, 0, data.Length);
362          return Task.CompletedTask;
363          async Task FlushAndWrite(byte[] data, bool async, CancellationToken cancellationToken)
364          {
365              await Flush(async, cancellationToken);
366              Debug.Assert(data.Length <= WriteBuffer.WriteSpaceLeft, $"Pregenerated message has length {data.Length} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
367              WriteBuffer.WriteBytes(data, 0, data.Length);
368          }
369      }
370      internal void Flush() => WriteBuffer.Flush(false).GetAwaiter().GetResult();
371      internal Task Flush(bool async, CancellationToken cancellationToken = default) => WriteBuffer.Flush(async, cancellationToken);
372  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnector.FrontendMessages.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Linq;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Npgsql.Util;
8  namespace Npgsql.Internal;
9  partial class NpgsqlConnector
10  {
11      internal Task WriteDescribe(StatementOrPortal statementOrPortal, string name, bool async, CancellationToken cancellationToken = default)
12      {
13          Debug.Assert(name.All(c => c < 128));
14          var len = sizeof(byte) +       
15                    sizeof(int)  +       
16                    sizeof(byte) +       
17                    (name.Length + 1);   
18          if (WriteBuffer.WriteSpaceLeft < len)
19              return FlushAndWrite(len, statementOrPortal, name, async, cancellationToken);
20          Write(len, statementOrPortal, name);
21          return Task.CompletedTask;
22          async Task FlushAndWrite(int len, StatementOrPortal statementOrPortal, string name, bool async, CancellationToken cancellationToken)
23          {
24              await Flush(async, cancellationToken);
25              Debug.Assert(len <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length {len} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
26              Write(len, statementOrPortal, name);
<span onclick='openModal()' class='match'>27          }
28          void Write(int len, StatementOrPortal statementOrPortal, string name)
29          {
30              WriteBuffer.WriteByte(FrontendMessageCode.Describe);
31              WriteBuffer.WriteInt32(len - 1);
32              WriteBuffer.WriteByte((byte)statementOrPortal);
33              WriteBuffer.WriteNullTerminatedString(name);
34          }
35      }
36      internal Task WriteSync(bool async, CancellationToken cancellationToken = default)
</span>37      {
38          const int len = sizeof(byte) +  
39                          sizeof(int);    
40          if (WriteBuffer.WriteSpaceLeft < len)
41              return FlushAndWrite(async, cancellationToken);
42          Write();
43          return Task.CompletedTask;
44          async Task FlushAndWrite(bool async, CancellationToken cancellationToken)
45          {
46              await Flush(async, cancellationToken);
47              Debug.Assert(len <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length {len} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
48              Write();
49          }
50          void Write()
51          {
52              WriteBuffer.WriteByte(FrontendMessageCode.Sync);
53              WriteBuffer.WriteInt32(len - 1);
54          }
55      }
56      internal Task WriteExecute(int maxRows, bool async, CancellationToken cancellationToken = default)
57      {
58          const int len = sizeof(byte) +       
59                          sizeof(int)  +       
60                          sizeof(byte) +       
61                          sizeof(int);         
62          if (WriteBuffer.WriteSpaceLeft < len)
63              return FlushAndWrite(maxRows, async, cancellationToken);
64          Write(maxRows);
65          return Task.CompletedTask;
66          async Task FlushAndWrite(int maxRows, bool async, CancellationToken cancellationToken)
67          {
68              await Flush(async, cancellationToken);
69              Debug.Assert(10 <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length 10 which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
70              Write(maxRows);
71          }
72          void Write(int maxRows)
73          {
74              WriteBuffer.WriteByte(FrontendMessageCode.Execute);
75              WriteBuffer.WriteInt32(len - 1);
76              WriteBuffer.WriteByte(0);   
77              WriteBuffer.WriteInt32(maxRows);
78          }
79      }
80      internal async Task WriteParse(string sql, string statementName, List<NpgsqlParameter> inputParameters, bool async, CancellationToken cancellationToken = default)
81      {
82          Debug.Assert(statementName.All(c => c < 128));
83          int queryByteLen;
84          try
85          {
86              queryByteLen = TextEncoding.GetByteCount(sql);
87          }
88          catch (Exception e)
89          {
90              Break(e);
91              throw;
92          }
93          if (WriteBuffer.WriteSpaceLeft < 1 + 4 + statementName.Length + 1)
94              await Flush(async, cancellationToken);
95          var messageLength =
96              sizeof(byte)                +         
97              sizeof(int)                 +         
98              statementName.Length        +         
99              sizeof(byte)                +         
100              queryByteLen + sizeof(byte) +         
101              sizeof(ushort)              +         
102              inputParameters.Count * sizeof(int);  
103          WriteBuffer.WriteByte(FrontendMessageCode.Parse);
104          WriteBuffer.WriteInt32(messageLength - 1);
105          WriteBuffer.WriteNullTerminatedString(statementName);
106          await WriteBuffer.WriteString(sql, queryByteLen, async, cancellationToken);
107          if (WriteBuffer.WriteSpaceLeft < 1 + 2)
108              await Flush(async, cancellationToken);
109          WriteBuffer.WriteByte(0); 
110          WriteBuffer.WriteUInt16((ushort)inputParameters.Count);
111          foreach (var p in inputParameters)
112          {
113              if (WriteBuffer.WriteSpaceLeft < 4)
114                  await Flush(async, cancellationToken);
115              WriteBuffer.WriteInt32((int)p.Handler!.PostgresType.OID);
116          }
117      }
118      internal async Task WriteBind(
119          List<NpgsqlParameter> parameters,
120          string portal,
121          string statement,
122          bool allResultTypesAreUnknown,
123          bool[]? unknownResultTypeList,
124          bool async,
125          CancellationToken cancellationToken = default)
126      {
127          Debug.Assert(statement.All(c => c < 128));
128          Debug.Assert(portal.All(c => c < 128));
129          var headerLength =
130              sizeof(byte)                    +     
131              sizeof(int)                     +     
132              sizeof(byte)                    +     
133              statement.Length + sizeof(byte) +     
134              sizeof(ushort);                       
135          if (WriteBuffer.WriteSpaceLeft < headerLength)
136          {
137              Debug.Assert(WriteBuffer.Size >= headerLength, "Write buffer too small for Bind header");
138              await Flush(async, cancellationToken);
139          }
140          var formatCodesSum = 0;
141          var paramsLength = 0;
142          for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)
143          {
144              var param = parameters[paramIndex];
145              formatCodesSum += (int)param.FormatCode;
146              param.LengthCache?.Rewind();
147              paramsLength += param.ValidateAndGetLength();
148          }
149          var formatCodeListLength = formatCodesSum == 0 ? 0 : formatCodesSum == parameters.Count ? 1 : parameters.Count;
150          var messageLength = headerLength         +
151                              sizeof(short) * formatCodeListLength +                  
152                              sizeof(short)                        +                  
153                              sizeof(int) * parameters.Count  +                       
154                              paramsLength                         +                  
155                              sizeof(short)                        +                  
156                              sizeof(short) * (unknownResultTypeList?.Length ?? 1);   
157          WriteBuffer.WriteByte(FrontendMessageCode.Bind);
158          WriteBuffer.WriteInt32(messageLength - 1);
159          Debug.Assert(portal == string.Empty);
160          WriteBuffer.WriteByte(0);  
161          WriteBuffer.WriteNullTerminatedString(statement);
162          WriteBuffer.WriteInt16(formatCodeListLength);
163          if (formatCodeListLength == 1)
164          {
165              if (WriteBuffer.WriteSpaceLeft < 2)
166                  await Flush(async, cancellationToken);
167              WriteBuffer.WriteInt16((short)FormatCode.Binary);
168          }
169          else if (formatCodeListLength > 1)
170          {
171              for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)
172              {
173                  if (WriteBuffer.WriteSpaceLeft < 2)
174                      await Flush(async, cancellationToken);
175                  WriteBuffer.WriteInt16((short)parameters[paramIndex].FormatCode);
176              }
177          }
178          if (WriteBuffer.WriteSpaceLeft < 2)
179              await Flush(async, cancellationToken);
180          WriteBuffer.WriteUInt16((ushort)parameters.Count);
181          for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)
182          {
183              var param = parameters[paramIndex];
184              param.LengthCache?.Rewind();
185              await param.WriteWithLength(WriteBuffer, async, cancellationToken);
186          }
187          if (unknownResultTypeList != null)
188          {
189              if (WriteBuffer.WriteSpaceLeft < 2 + unknownResultTypeList.Length * 2)
190                  await Flush(async, cancellationToken);
191              WriteBuffer.WriteInt16(unknownResultTypeList.Length);
192              foreach (var t in unknownResultTypeList)
193                  WriteBuffer.WriteInt16(t ? 0 : 1);
194          }
195          else
196          {
197              if (WriteBuffer.WriteSpaceLeft < 4)
198                  await Flush(async, cancellationToken);
199              WriteBuffer.WriteInt16(1);
200              WriteBuffer.WriteInt16(allResultTypesAreUnknown ? 0 : 1);
201          }
202      }
203      internal Task WriteClose(StatementOrPortal type, string name, bool async, CancellationToken cancellationToken = default)
204      {
205          var len = sizeof(byte) +               
206                    sizeof(int)  +               
207                    sizeof(byte) +               
208                    name.Length + sizeof(byte);  
209          if (WriteBuffer.WriteSpaceLeft < len)
210              return FlushAndWrite(len, type, name, async, cancellationToken);
211          Write(len, type, name);
212          return Task.CompletedTask;
213          async Task FlushAndWrite(int len, StatementOrPortal type, string name, bool async, CancellationToken cancellationToken)
214          {
215              await Flush(async, cancellationToken);
216              Debug.Assert(len <= WriteBuffer.WriteSpaceLeft, $"Message of type {GetType().Name} has length {len} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
217              Write(len, type, name);
218          }
219          void Write(int len, StatementOrPortal type, string name)
220          {
221              WriteBuffer.WriteByte(FrontendMessageCode.Close);
222              WriteBuffer.WriteInt32(len - 1);
223              WriteBuffer.WriteByte((byte)type);
224              WriteBuffer.WriteNullTerminatedString(name);
225          }
226      }
227      internal void WriteQuery(string sql) => WriteQuery(sql, false).GetAwaiter().GetResult();
228      internal async Task WriteQuery(string sql, bool async, CancellationToken cancellationToken = default)
229      {
230          var queryByteLen = TextEncoding.GetByteCount(sql);
231          if (WriteBuffer.WriteSpaceLeft < 1 + 4)
232              await Flush(async, cancellationToken);
233          WriteBuffer.WriteByte(FrontendMessageCode.Query);
234          WriteBuffer.WriteInt32(
235              sizeof(int)  +        
236              queryByteLen +        
237              sizeof(byte));        
238          await WriteBuffer.WriteString(sql, queryByteLen, async, cancellationToken);
239          if (WriteBuffer.WriteSpaceLeft < 1)
240              await Flush(async, cancellationToken);
241          WriteBuffer.WriteByte(0);  
242      }
243      internal void WriteCopyDone() => WriteCopyDone(false).GetAwaiter().GetResult();
244      internal async Task WriteCopyDone(bool async, CancellationToken cancellationToken = default)
245      {
246          const int len = sizeof(byte) +   
247                          sizeof(int);     
248          if (WriteBuffer.WriteSpaceLeft < len)
249              await Flush(async, cancellationToken);
250          WriteBuffer.WriteByte(FrontendMessageCode.CopyDone);
251          WriteBuffer.WriteInt32(len - 1);
252      }
253      internal async Task WriteCopyFail(bool async, CancellationToken cancellationToken = default)
254      {
255          const int len = sizeof(byte) +  
256                          sizeof(int) +   
257                          sizeof(byte);   
258          if (WriteBuffer.WriteSpaceLeft < len)
259              await Flush(async, cancellationToken);
260          WriteBuffer.WriteByte(FrontendMessageCode.CopyFail);
261          WriteBuffer.WriteInt32(len - 1);
262          WriteBuffer.WriteByte(0);   
263      }
264      internal void WriteCancelRequest(int backendProcessId, int backendSecretKey)
265      {
266          const int len = sizeof(int) +  
267                          sizeof(int) +  
268                          sizeof(int) +  
269                          sizeof(int);   
270          Debug.Assert(backendProcessId != 0);
271          if (WriteBuffer.WriteSpaceLeft < len)
272              Flush(false).GetAwaiter().GetResult();
273          WriteBuffer.WriteInt32(len);
274          WriteBuffer.WriteInt32(1234 << 16 | 5678);
275          WriteBuffer.WriteInt32(backendProcessId);
276          WriteBuffer.WriteInt32(backendSecretKey);
277      }
278      internal void WriteTerminate()
279      {
280          const int len = sizeof(byte) +  
281                          sizeof(int);    
282          if (WriteBuffer.WriteSpaceLeft < len)
283              Flush(false).GetAwaiter().GetResult();
284          WriteBuffer.WriteByte(FrontendMessageCode.Terminate);
285          WriteBuffer.WriteInt32(len - 1);
286      }
287      internal void WriteSslRequest()
288      {
289          const int len = sizeof(int) +  
290                          sizeof(int);   
291          if (WriteBuffer.WriteSpaceLeft < len)
292              Flush(false).GetAwaiter().GetResult();
293          WriteBuffer.WriteInt32(len);
294          WriteBuffer.WriteInt32(80877103);
295      }
296      internal void WriteStartup(Dictionary<string, string> parameters)
297      {
298          const int protocolVersion3 = 3 << 16; 
299          var len = sizeof(int) +  
300                    sizeof(int) +  
301                    sizeof(byte);  
302          foreach (var kvp in parameters)
303              len += PGUtil.UTF8Encoding.GetByteCount(kvp.Key) + 1 +
304                     PGUtil.UTF8Encoding.GetByteCount(kvp.Value) + 1;
305          if (len > WriteBuffer.Size)
306              throw new Exception("Startup message bigger than buffer");
307          WriteBuffer.WriteInt32(len);
308          WriteBuffer.WriteInt32(protocolVersion3);
309          foreach (var kv in parameters)
310          {
311              WriteBuffer.WriteString(kv.Key);
312              WriteBuffer.WriteByte(0);
313              WriteBuffer.WriteString(kv.Value);
314              WriteBuffer.WriteByte(0);
315          }
316          WriteBuffer.WriteByte(0);
317      }
318      #region Authentication
319      internal Task WritePassword(byte[] payload, bool async, CancellationToken cancellationToken = default) => WritePassword(payload, 0, payload.Length, async, cancellationToken);
320      internal async Task WritePassword(byte[] payload, int offset, int count, bool async, CancellationToken cancellationToken = default)
321      {
322          if (WriteBuffer.WriteSpaceLeft < sizeof(byte) + sizeof(int))
323              await WriteBuffer.Flush(async, cancellationToken);
324          WriteBuffer.WriteByte(FrontendMessageCode.Password);
325          WriteBuffer.WriteInt32(sizeof(int) + count);
326          if (count <= WriteBuffer.WriteSpaceLeft)
327          {
328              WriteBuffer.WriteBytes(payload, offset, count);
329              return;
330          }
331          await WriteBuffer.Flush(async, cancellationToken);
332          await WriteBuffer.DirectWrite(new ReadOnlyMemory<byte>(payload, offset, count), async, cancellationToken);
333      }
334      internal async Task WriteSASLInitialResponse(string mechanism, byte[] initialResponse, bool async, CancellationToken cancellationToken = default)
335      {
336          var len = sizeof(byte)                                               +  
337                    sizeof(int)                                                +  
338                    PGUtil.UTF8Encoding.GetByteCount(mechanism) + sizeof(byte) +  
339                    sizeof(int)                                                +  
340                    (initialResponse?.Length ?? 0);                               
341          if (WriteBuffer.WriteSpaceLeft < len)
342              await WriteBuffer.Flush(async, cancellationToken);
343          WriteBuffer.WriteByte(FrontendMessageCode.Password);
344          WriteBuffer.WriteInt32(len - 1);
345          WriteBuffer.WriteString(mechanism);
346          WriteBuffer.WriteByte(0);   
347          if (initialResponse == null)
348              WriteBuffer.WriteInt32(-1);
349          else
350          {
351              WriteBuffer.WriteInt32(initialResponse.Length);
352              WriteBuffer.WriteBytes(initialResponse);
353          }
354      }
355      internal Task WriteSASLResponse(byte[] payload, bool async, CancellationToken cancellationToken = default) => WritePassword(payload, async, cancellationToken);
356      #endregion Authentication
357      internal Task WritePregenerated(byte[] data, bool async = false, CancellationToken cancellationToken = default)
358      {
359          if (WriteBuffer.WriteSpaceLeft < data.Length)
360              return FlushAndWrite(data, async, cancellationToken);
361          WriteBuffer.WriteBytes(data, 0, data.Length);
362          return Task.CompletedTask;
363          async Task FlushAndWrite(byte[] data, bool async, CancellationToken cancellationToken)
364          {
365              await Flush(async, cancellationToken);
366              Debug.Assert(data.Length <= WriteBuffer.WriteSpaceLeft, $"Pregenerated message has length {data.Length} which is bigger than the buffer ({WriteBuffer.WriteSpaceLeft})");
367              WriteBuffer.WriteBytes(data, 0, data.Length);
368          }
369      }
370      internal void Flush() => WriteBuffer.Flush(false).GetAwaiter().GetResult();
371      internal Task Flush(bool async, CancellationToken cancellationToken = default) => WriteBuffer.Flush(async, cancellationToken);
372  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnector.FrontendMessages.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnector.FrontendMessages.cs</div>
                </div>
                <div class="column column_space"><pre><code>27          }
28          void Write(int len, StatementOrPortal statementOrPortal, string name)
29          {
30              WriteBuffer.WriteByte(FrontendMessageCode.Describe);
31              WriteBuffer.WriteInt32(len - 1);
32              WriteBuffer.WriteByte((byte)statementOrPortal);
33              WriteBuffer.WriteNullTerminatedString(name);
34          }
35      }
36      internal Task WriteSync(bool async, CancellationToken cancellationToken = default)
</pre></code></div>
                <div class="column column_space"><pre><code>27          }
28          void Write(int len, StatementOrPortal statementOrPortal, string name)
29          {
30              WriteBuffer.WriteByte(FrontendMessageCode.Describe);
31              WriteBuffer.WriteInt32(len - 1);
32              WriteBuffer.WriteByte((byte)statementOrPortal);
33              WriteBuffer.WriteNullTerminatedString(name);
34          }
35      }
36      internal Task WriteSync(bool async, CancellationToken cancellationToken = default)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    