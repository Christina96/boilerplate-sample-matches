
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.762935089369708%, Tokens: 10</h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-Pooling.cs</h3>
            <pre><code>1  using DG.Tweening;
2  using UnityEngine;
3  public class Pooling : BrainBase
4  {
5  	public GameObject prefab;
6  	bool recycle;
7  	Transform spawnsParent;
8  	void Start()
9  	{
10  		DOTween.Init(true, false, LogBehaviour.Verbose);
11  		spawnsParent = new GameObject("Spawn Container").transform;
12  	}
13  	void OnGUI()
14  	{
15  		GUILayout.BeginArea(new Rect(10, 10, Screen.width - 20, Screen.height - 20));
16  		GUILayout.BeginHorizontal();
17  		GUILayout.FlexibleSpace();
18  		GUILayout.BeginVertical();
19  		GUILayout.Label("Position Tweens");
20  		GUILayout.BeginHorizontal();
21  	    if (GUILayout.Button("Spawn 1")) SpawnPosition(1);
22  	    if (GUILayout.Button("Spawn 10")) SpawnPosition(10);
<span onclick='openModal()' class='match'>23  	    if (GUILayout.Button("Spawn 100")) SpawnPosition(100);
24  	    if (GUILayout.Button("Spawn 300")) SpawnPosition(300);
</span>25  	    GUILayout.EndHorizontal();
26  	    GUILayout.Space(5);
27  	    GUILayout.Label("PositionX Tweens");
28  		GUILayout.BeginHorizontal();
29  	    if (GUILayout.Button("Spawn 1")) SpawnPositionX(1);
30  	    if (GUILayout.Button("Spawn 10")) SpawnPositionX(10);
31  	    if (GUILayout.Button("Spawn 100")) SpawnPositionX(100);
32  	    if (GUILayout.Button("Spawn 300")) SpawnPositionX(300);
33  	    GUILayout.EndHorizontal();
34  	    GUILayout.Space(5);
35  	    GUILayout.Label("PositionX Tweens with snapping");
36  		GUILayout.BeginHorizontal();
37  	    if (GUILayout.Button("Spawn 1")) SpawnPositionX(1, true);
38  	    if (GUILayout.Button("Spawn 10")) SpawnPositionX(10, true);
39  	    if (GUILayout.Button("Spawn 100")) SpawnPositionX(100, true);
40  	    if (GUILayout.Button("Spawn 300")) SpawnPositionX(300, true);
41  	    GUILayout.EndHorizontal();
42  	    GUILayout.Space(5);
43  	    GUILayout.Label("PositionY Tweens");
44  		GUILayout.BeginHorizontal();
45  	    if (GUILayout.Button("Spawn 1")) SpawnPositionY(1);
46  	    if (GUILayout.Button("Spawn 10")) SpawnPositionY(10);
47  	    if (GUILayout.Button("Spawn 100")) SpawnPositionY(100);
48  	    if (GUILayout.Button("Spawn 300")) SpawnPositionY(300);
49  	    GUILayout.EndHorizontal();
50  	    GUILayout.Space(5);
51  	    GUILayout.Label("Rotation Tweens");
52  		GUILayout.BeginHorizontal();
53  	    if (GUILayout.Button("Spawn 1")) SpawnRotation(1);
54  	    if (GUILayout.Button("Spawn 10")) SpawnRotation(10);
55  	    if (GUILayout.Button("Spawn 100")) SpawnRotation(100);
56  	    if (GUILayout.Button("Spawn 300")) SpawnRotation(300);
57  	    GUILayout.EndHorizontal();
58  	    GUILayout.Space(5);
59  	    GUILayout.Label("Emit Particles Tweens");
60  		GUILayout.BeginHorizontal();
61  	    if (GUILayout.Button("Spawn 1")) SpawnParticles(1);
62  	    if (GUILayout.Button("Spawn 10")) SpawnParticles(10);
63  	    if (GUILayout.Button("Spawn 100")) SpawnParticles(100);
64  	    if (GUILayout.Button("Spawn 300")) SpawnParticles(300);
65  	    if (GUILayout.Button("Spawn 1000")) SpawnParticles(1000);
66  	    GUILayout.EndHorizontal();
67  	    GUILayout.Space(5);
68  	    GUILayout.BeginHorizontal();
69  	    if (GUILayout.Button("Toggle Pause")) DOTween.TogglePauseAll();
70  	    if (GUILayout.Button("Kill")) DOTween.KillAll();
71  	    if (GUILayout.Button("Clear")) Clear();
72  	    if (GUILayout.Button("Clear FULL")) Clear(true);
73  	    GUILayout.EndHorizontal();
74  	    recycle = GUILayout.Toggle(recycle, "Recycle");
75  	    GUILayout.EndVertical();
76  		GUILayout.FlexibleSpace();
77  		GUILayout.EndHorizontal();
78  		GUILayout.EndArea();
79  	}
80  	void SpawnPosition(int tot)
81  	{
82  		for (int i = 0; i < tot; i++) {
83          	GameObject go = Instantiate(prefab) as GameObject;
84          	go.name += i;
85              Transform t = go.transform;
86              t.parent = spawnsParent;
87              t.position = RandomVector3();
88              DOTween.To(() => t.position, x => t.position = x, RandomVector3(), 1f)
89              	.SetRecyclable(recycle)
90              	.OnComplete(() => Destroy(go));
91          }
92          fpsGadget.ResetFps();
93  	}
94  	void SpawnPositionX(int tot, bool snapping = false)
95  	{
96  		for (int i = 0; i < tot; i++) {
97          	GameObject go = Instantiate(prefab) as GameObject;
98          	go.name += i;
99              Transform t = go.transform;
100              t.parent = spawnsParent;
101              t.position = RandomVector3();
102              DOTween.ToAxis(() => t.position, x => t.position = x, RandomFloat(), 1f)
103              	.SetOptions(snapping)
104              	.SetRecyclable(recycle)
105              	.OnComplete(() => Destroy(go));
106          }
107          fpsGadget.ResetFps();
108  	}
109  	void SpawnPositionY(int tot, bool snapping = false)
110  	{
111  		for (int i = 0; i < tot; i++) {
112          	GameObject go = Instantiate(prefab) as GameObject;
113          	go.name += i;
114              Transform t = go.transform;
115              t.parent = spawnsParent;
116              t.position = RandomVector3();
117              if (snapping) {
118              	DOTween.ToAxis(() => t.position, x => t.position = x, RandomFloat(), 1f)
119              		.SetOptions(AxisConstraint.Y, true)
120              		.SetRecyclable(recycle)
121              		.OnComplete(() => Destroy(go));
122          	} else {
123          		DOTween.ToAxis(() => t.position, x => t.position = x, RandomFloat(), 1f)
124          			.SetOptions(AxisConstraint.Y)
125          			.SetRecyclable(recycle)
126          			.OnComplete(() => Destroy(go));
127          	}
128          }
129          fpsGadget.ResetFps();
130  	}
131  	void SpawnRotation(int tot)
132  	{
133  		for (int i = 0; i < tot; i++) {
134          	GameObject go = Instantiate(prefab) as GameObject;
135          	go.name += i;
136              Transform t = go.transform;
137              t.parent = spawnsParent;
138              t.position = RandomVector3();
139              DOTween.To(() => t.rotation, x => t.rotation = x, RandomVector3(720), 1f)
140              	.SetRecyclable(recycle)
141              	.OnComplete(() => Destroy(go));
142          }
143          fpsGadget.ResetFps();
144  	}
145  	void SpawnParticles(int tot)
146  	{
147  		for (int i = 0; i < tot; i++) {
148  			GameObject go = Instantiate(prefab) as GameObject;
149  	    	go.name += i;
150  	        Transform t = go.transform;
151  	        t.parent = spawnsParent;
152  	        Material m = t.gameObject.renderer.material;
153  			ResetParticleAndAssignTween(t, m);
154  		}
155  		fpsGadget.ResetFps();
156  	}
157  	void ResetParticleAndAssignTween(Transform t, Material m)
158  	{
159  		t.position = Vector3.zero;
160  		Color col = m.color;
161  		col.a = 1;
162  		m.color = col;
163  		float duration = Random.Range(0.2f, 2f);
164          m.DOFade(0, duration).SetRecyclable(recycle);
165          t.DOMove(RandomVector3(), duration)
166          	.SetRecyclable(recycle)
167          	.OnComplete(()=> ResetParticleAndAssignTween(t, m));
168  	}
169  	void Clear(bool fullDOTweenClear = false)
170  	{
171  		DOTween.Clear(fullDOTweenClear);
172  		Transform[] ts = spawnsParent.GetComponentsInChildren<Transform>();
173  		foreach (Transform t in ts) {
174  			if (t != spawnsParent) Destroy(t.gameObject);
175  		}
176  	}
177  	Vector3 RandomVector3(float limit = 10)
178  	{
179  		return new Vector3(Random.Range(-limit, limit), Random.Range(-limit, limit), Random.Range(-limit, limit));
180  	}
181  	float RandomFloat(float limit = 10)
182  	{
183  		return Random.Range(-limit, limit);
184  	}
185  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</h3>
            <pre><code>1  using GitHub.Runner.Sdk;
2  using System;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Xunit;
7  namespace GitHub.Runner.Common.Tests.Util
8  {
9      public sealed class IOUtilL0
10      {
11          [Fact]
12          [Trait("Level", "L0")]
13          [Trait("Category", "Common")]
14          public void Delete_DeletesDirectory()
15          {
16              using (TestHostContext hc = new(this))
17              {
18                  Tracing trace = hc.GetTrace();
19                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
20                  string file = Path.Combine(directory, "some file");
21                  try
22                  {
23                      Directory.CreateDirectory(directory);
24                      File.WriteAllText(path: file, contents: "some contents");
25                      IOUtil.Delete(directory, CancellationToken.None);
26                      Assert.False(Directory.Exists(directory));
27                  }
28                  finally
29                  {
30                      if (Directory.Exists(directory))
31                      {
32                          Directory.Delete(directory, recursive: true);
33                      }
34                  }
35              }
36          }
37          [Fact]
38          [Trait("Level", "L0")]
39          [Trait("Category", "Common")]
40          public void Delete_DeletesFile()
41          {
42              using (TestHostContext hc = new(this))
43              {
44                  Tracing trace = hc.GetTrace();
45                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
46                  string file = Path.Combine(directory, "some file");
47                  try
48                  {
49                      Directory.CreateDirectory(directory);
50                      File.WriteAllText(path: file, contents: "some contents");
51                      IOUtil.Delete(file, CancellationToken.None);
52                      Assert.False(File.Exists(file));
53                  }
54                  finally
55                  {
56                      if (Directory.Exists(directory))
57                      {
58                          Directory.Delete(directory, recursive: true);
59                      }
60                  }
61              }
62          }
63          [Fact]
64          [Trait("Level", "L0")]
65          [Trait("Category", "Common")]
66          public void DeleteDirectory_DeletesDirectoriesRecursively()
67          {
68              using (TestHostContext hc = new(this))
69              {
70                  Tracing trace = hc.GetTrace();
71                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
72                  try
73                  {
74                      Directory.CreateDirectory(Path.Combine(directory, "some child directory", "some grandchild directory"));
75                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
76                      Assert.False(Directory.Exists(directory));
77                  }
78                  finally
79                  {
80                      if (Directory.Exists(directory))
81                      {
82                          Directory.Delete(directory, recursive: true);
83                      }
84                  }
85              }
86          }
87          [Fact]
88          [Trait("Level", "L0")]
89          [Trait("Category", "Common")]
90          public async Task DeleteDirectory_DeletesDirectoryReparsePointChain()
91          {
92              using (TestHostContext hc = new(this))
93              {
94                  Tracing trace = hc.GetTrace();
95                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
96                  try
97                  {
98                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
99                      string file = Path.Combine(targetDir, "file.txt");
100                      File.WriteAllText(path: file, contents: "some contents");
101                      string linkDir1 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir1");
102                      string linkDir2 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir2");
103                      string linkDir3 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir3");
104                      string linkDir4 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir4");
105                      string linkDir5 = Path.Combine(randomDir, $"{Guid.NewGuid()}_linkDir5");
106                      await CreateDirectoryReparsePoint(context: hc, link: linkDir1, target: linkDir2);
107                      await CreateDirectoryReparsePoint(context: hc, link: linkDir2, target: linkDir3);
108                      await CreateDirectoryReparsePoint(context: hc, link: linkDir3, target: linkDir4);
109                      await CreateDirectoryReparsePoint(context: hc, link: linkDir4, target: linkDir5);
110                      await CreateDirectoryReparsePoint(context: hc, link: linkDir5, target: targetDir);
111                      Assert.True(Directory.Exists(linkDir1));
112                      Assert.True(new DirectoryInfo(linkDir1).Attributes.HasFlag(FileAttributes.ReparsePoint));
113                      Assert.True(File.Exists(Path.Combine(linkDir1, "file.txt")));
114                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
115                      Assert.False(Directory.Exists(linkDir1));
116                      Assert.False(Directory.Exists(targetDir));
117                      Assert.False(File.Exists(file));
118                      Assert.False(Directory.Exists(randomDir));
119                  }
120                  finally
121                  {
122                      if (Directory.Exists(randomDir))
123                      {
124                          Directory.Delete(randomDir, recursive: true);
125                      }
126                  }
127              }
128          }
129          [Fact]
130          [Trait("Level", "L0")]
131          [Trait("Category", "Common")]
132          public async Task DeleteDirectory_DeletesDirectoryReparsePointsBeforeDirectories()
133          {
134              using (TestHostContext hc = new(this))
135              {
136                  Tracing trace = hc.GetTrace();
137                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
138                  try
139                  {
140                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
141                      string file = Path.Combine(targetDir, "file.txt");
142                      File.WriteAllText(path: file, contents: "some contents");
143                      string linkDir = Path.Combine(randomDir, "linkDir");
144                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
145                      Assert.True(Directory.Exists(linkDir));
146                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
147                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
148                      IOUtil.DeleteDirectory(randomDir, CancellationToken.None);
149                      Assert.False(Directory.Exists(linkDir));
150                      Assert.False(Directory.Exists(targetDir));
151                      Assert.False(File.Exists(file));
152                      Assert.False(Directory.Exists(randomDir));
153                  }
154                  finally
155                  {
156                      if (Directory.Exists(randomDir))
157                      {
158                          Directory.Delete(randomDir, recursive: true);
159                      }
160                  }
161              }
162          }
163          [Fact]
164          [Trait("Level", "L0")]
165          [Trait("Category", "Common")]
166          public void DeleteDirectory_DeletesFilesRecursively()
167          {
168              using (TestHostContext hc = new(this))
169              {
170                  Tracing trace = hc.GetTrace();
171                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
172                  try
173                  {
174                      string file = Path.Combine(directory, "some subdirectory", "some file");
175                      Directory.CreateDirectory(Path.GetDirectoryName(file));
176                      File.WriteAllText(path: file, contents: "some contents");
177                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
178                      Assert.False(Directory.Exists(directory));
179                  }
180                  finally
181                  {
182                      if (Directory.Exists(directory))
183                      {
184                          Directory.Delete(directory, recursive: true);
185                      }
186                  }
187              }
188          }
189          [Fact]
190          [Trait("Level", "L0")]
191          [Trait("Category", "Common")]
192          public void DeleteDirectory_DeletesReadOnlyDirectories()
193          {
194              using (TestHostContext hc = new(this))
195              {
196                  Tracing trace = hc.GetTrace();
197                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
198                  string subdirectory = Path.Combine(directory, "some subdirectory");
199                  try
200                  {
201                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
202                      subdirectoryInfo.Create();
203                      subdirectoryInfo.Attributes = subdirectoryInfo.Attributes | FileAttributes.ReadOnly;
204                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
205                      Assert.False(Directory.Exists(directory));
206                  }
207                  finally
208                  {
209                      var subdirectoryInfo = new DirectoryInfo(subdirectory);
210                      if (subdirectoryInfo.Exists)
211                      {
212                          subdirectoryInfo.Attributes = subdirectoryInfo.Attributes & ~FileAttributes.ReadOnly;
213                      }
214                      if (Directory.Exists(directory))
215                      {
216                          Directory.Delete(directory, recursive: true);
217                      }
218                  }
219              }
220          }
221          [Fact]
222          [Trait("Level", "L0")]
223          [Trait("Category", "Common")]
224          public void DeleteDirectory_DeletesReadOnlyRootDirectory()
225          {
226              using (TestHostContext hc = new(this))
227              {
228                  Tracing trace = hc.GetTrace();
229                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
230                  try
231                  {
232                      var directoryInfo = new DirectoryInfo(directory);
233                      directoryInfo.Create();
234                      directoryInfo.Attributes = directoryInfo.Attributes | FileAttributes.ReadOnly;
235                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
236                      Assert.False(Directory.Exists(directory));
237                  }
238                  finally
239                  {
240                      var directoryInfo = new DirectoryInfo(directory);
241                      if (directoryInfo.Exists)
242                      {
243                          directoryInfo.Attributes = directoryInfo.Attributes & ~FileAttributes.ReadOnly;
244                          directoryInfo.Delete();
245                      }
246                  }
247              }
248          }
249          [Fact]
250          [Trait("Level", "L0")]
251          [Trait("Category", "Common")]
252          public void DeleteDirectory_DeletesReadOnlyFiles()
253          {
254              using (TestHostContext hc = new(this))
255              {
256                  Tracing trace = hc.GetTrace();
257                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
258                  string file = Path.Combine(directory, "some file");
259                  try
260                  {
261                      Directory.CreateDirectory(directory);
262                      File.WriteAllText(path: file, contents: "some contents");
263                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
264                      IOUtil.DeleteDirectory(directory, CancellationToken.None);
265                      Assert.False(Directory.Exists(directory));
266                  }
267                  finally
268                  {
269                      if (File.Exists(file))
270                      {
271                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
272                      }
273                      if (Directory.Exists(directory))
274                      {
275                          Directory.Delete(directory, recursive: true);
276                      }
277                  }
278              }
279          }
280          [Fact]
281          [Trait("Level", "L0")]
282          [Trait("Category", "Common")]
283          public async Task DeleteDirectory_DoesNotFollowDirectoryReparsePoint()
284          {
285              using (TestHostContext hc = new(this))
286              {
287                  Tracing trace = hc.GetTrace();
288                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
289                  try
290                  {
291                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
292                      string file = Path.Combine(targetDir, "file.txt");
293                      File.WriteAllText(path: file, contents: "some contents");
294                      string linkDir = Path.Combine(randomDir, "linkDir");
295                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
296                      Assert.True(Directory.Exists(linkDir));
297                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
298                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
299                      IOUtil.DeleteDirectory(linkDir, CancellationToken.None);
300                      Assert.False(Directory.Exists(linkDir));
301                      Assert.True(Directory.Exists(targetDir));
302                      Assert.True(File.Exists(file));
303                  }
304                  finally
305                  {
306                      if (Directory.Exists(randomDir))
307                      {
308                          Directory.Delete(randomDir, recursive: true);
309                      }
310                  }
311              }
312          }
313          [Fact]
314          [Trait("Level", "L0")]
315          [Trait("Category", "Common")]
316          public async Task DeleteDirectory_DoesNotFollowNestLevel1DirectoryReparsePoint()
317          {
318              using (TestHostContext hc = new(this))
319              {
320                  Tracing trace = hc.GetTrace();
321                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
322                  try
323                  {
324                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
325                      string file = Path.Combine(targetDir, "file.txt");
326                      File.WriteAllText(path: file, contents: "some contents");
327                      string subDir = Directory.CreateDirectory(Path.Combine(randomDir, "subDir")).FullName;
328                      string linkDir = Path.Combine(subDir, "linkDir");
329                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
330                      Assert.True(Directory.Exists(linkDir));
331                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
332                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
333                      IOUtil.DeleteDirectory(subDir, CancellationToken.None);
334                      Assert.False(Directory.Exists(subDir));
335                      Assert.True(Directory.Exists(targetDir));
336                      Assert.True(File.Exists(file));
337                  }
338                  finally
339                  {
340                      if (Directory.Exists(randomDir))
341                      {
342                          Directory.Delete(randomDir, recursive: true);
343                      }
344                  }
345              }
346          }
347          [Fact]
348          [Trait("Level", "L0")]
349          [Trait("Category", "Common")]
350          public async Task DeleteDirectory_DoesNotFollowNestLevel2DirectoryReparsePoint()
351          {
352              using (TestHostContext hc = new(this))
353              {
354                  Tracing trace = hc.GetTrace();
355                  string randomDir = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
356                  try
357                  {
358                      string targetDir = Directory.CreateDirectory(Path.Combine(randomDir, "targetDir")).FullName;
359                      string file = Path.Combine(targetDir, "file.txt");
360                      File.WriteAllText(path: file, contents: "some contents");
361                      string subDir1 = Directory.CreateDirectory(Path.Combine(randomDir, "subDir1")).FullName;
362                      string subDir2 = Directory.CreateDirectory(Path.Combine(subDir1, "subDir2")).FullName;
363                      string linkDir = Path.Combine(subDir2, "linkDir");
364                      await CreateDirectoryReparsePoint(context: hc, link: linkDir, target: targetDir);
365                      Assert.True(Directory.Exists(linkDir));
366                      Assert.True(new DirectoryInfo(linkDir).Attributes.HasFlag(FileAttributes.ReparsePoint));
367                      Assert.True(File.Exists(Path.Combine(linkDir, "file.txt")));
368                      IOUtil.DeleteDirectory(subDir1, CancellationToken.None);
369                      Assert.False(Directory.Exists(subDir1));
370                      Assert.True(Directory.Exists(targetDir));
371                      Assert.True(File.Exists(file));
372                  }
373                  finally
374                  {
375                      if (Directory.Exists(randomDir))
376                      {
377                          Directory.Delete(randomDir, recursive: true);
378                      }
379                  }
380              }
381          }
382          [Fact]
383          [Trait("Level", "L0")]
384          [Trait("Category", "Common")]
385          public void DeleteDirectory_IgnoresFile()
386          {
387              using (TestHostContext hc = new(this))
388              {
389                  Tracing trace = hc.GetTrace();
390                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
391                  string file = Path.Combine(directory, "some file");
392                  try
393                  {
394                      Directory.CreateDirectory(directory);
395                      File.WriteAllText(path: file, contents: "some contents");
396                      IOUtil.DeleteDirectory(file, CancellationToken.None);
397                      Assert.True(File.Exists(file));
398                  }
399                  finally
400                  {
401                      if (Directory.Exists(directory))
402                      {
403                          Directory.Delete(directory, recursive: true);
404                      }
405                  }
406              }
407          }
408          [Fact]
409          [Trait("Level", "L0")]
410          [Trait("Category", "Common")]
411          public void DeleteFile_DeletesFile()
412          {
413              using (TestHostContext hc = new(this))
414              {
415                  Tracing trace = hc.GetTrace();
416                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
417                  string file = Path.Combine(directory, "some file");
418                  try
419                  {
420                      Directory.CreateDirectory(directory);
421                      File.WriteAllText(path: file, contents: "some contents");
422                      IOUtil.DeleteFile(file);
423                      Assert.False(File.Exists(file));
424                  }
425                  finally
426                  {
427                      if (Directory.Exists(directory))
428                      {
429                          Directory.Delete(directory, recursive: true);
430                      }
431                  }
432              }
433          }
434          [Fact]
435          [Trait("Level", "L0")]
436          [Trait("Category", "Common")]
437          public void DeleteFile_DeletesReadOnlyFile()
438          {
439              using (TestHostContext hc = new(this))
440              {
441                  Tracing trace = hc.GetTrace();
442                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
443                  string file = Path.Combine(directory, "some file");
444                  try
445                  {
446                      Directory.CreateDirectory(directory);
447                      File.WriteAllText(path: file, contents: "some contents");
448                      File.SetAttributes(file, File.GetAttributes(file) | FileAttributes.ReadOnly);
449                      IOUtil.DeleteFile(file);
450                      Assert.False(File.Exists(file));
451                  }
452                  finally
453                  {
<span onclick='openModal()' class='match'>454                      if (File.Exists(file))
455                      {
456                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
457                      }
458                      if (Directory.Exists(directory))
459                      {
460                          Directory.Delete(directory, recursive: true);
461                      }
</span>462                  }
463              }
464          }
465          [Fact]
466          [Trait("Level", "L0")]
467          [Trait("Category", "Common")]
468          public void DeleteFile_IgnoresDirectory()
469          {
470              using (TestHostContext hc = new(this))
471              {
472                  Tracing trace = hc.GetTrace();
473                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
474                  try
475                  {
476                      Directory.CreateDirectory(directory);
477                      IOUtil.DeleteFile(directory);
478                      Assert.True(Directory.Exists(directory));
479                  }
480                  finally
481                  {
482                      if (Directory.Exists(directory))
483                      {
484                          Directory.Delete(directory, recursive: true);
485                      }
486                  }
487              }
488          }
489          [Fact]
490          [Trait("Level", "L0")]
491          [Trait("Category", "Common")]
492          public void GetRelativePath()
493          {
494              using (TestHostContext hc = new(this))
495              {
496                  Tracing trace = hc.GetTrace();
497                  string relativePath;
498  #if OS_WINDOWS
499                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src");
500                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
501                  relativePath = IOUtil.MakeRelative(@"d:\", @"d:\specs");
502                  Assert.True(string.Equals(relativePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
503                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo.cpp", @"d:\src\proj");
504                  Assert.True(string.Equals(relativePath, @"d:\src\project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
505                  relativePath = IOUtil.MakeRelative(@"d:\src\project\foo", @"d:\src");
506                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
507                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:\src\project");
508                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
509                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
510                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
511                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo.cpp", @"d:/src");
512                  Assert.True(string.Equals(relativePath, @"project\foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
513                  relativePath = IOUtil.MakeRelative(@"d:/src/project/foo", @"d:/src");
514                  Assert.True(string.Equals(relativePath, @"project\foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
515                  relativePath = IOUtil.MakeRelative(@"d:\src\project", @"d:/src/project");
516                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
517  #else
518                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src");
519                  Assert.True(string.Equals(relativePath, @"project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
520                  relativePath = IOUtil.MakeRelative(@"/user", @"/user/specs");
521                  Assert.True(string.Equals(relativePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
522                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo.cpp", @"/user/src/proj");
523                  Assert.True(string.Equals(relativePath, @"/user/src/project/foo.cpp", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
524                  relativePath = IOUtil.MakeRelative(@"/user/src/project/foo", @"/user/src");
525                  Assert.True(string.Equals(relativePath, @"project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
526                  relativePath = IOUtil.MakeRelative(@"/user/src/project", @"/user/src/project");
527                  Assert.True(string.Equals(relativePath, string.Empty, StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {relativePath}");
528  #endif
529              }
530          }
531          [Fact]
532          [Trait("Level", "L0")]
533          [Trait("Category", "Common")]
534          public void ResolvePath()
535          {
536              using (TestHostContext hc = new(this))
537              {
538                  Tracing trace = hc.GetTrace();
539                  string resolvePath;
540  #if OS_WINDOWS
541                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"foo");
542                  Assert.True(string.Equals(resolvePath, @"d:\src\project\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
543                  resolvePath = IOUtil.ResolvePath(@"d:\", @"specs");
544                  Assert.True(string.Equals(resolvePath, @"d:\specs", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
545                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\", @"src\proj");
546                  Assert.True(string.Equals(resolvePath, @"d:\src\project\src\proj", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
547                  resolvePath = IOUtil.ResolvePath(@"d:\src\project\foo", @"..");
548                  Assert.True(string.Equals(resolvePath, @"d:\src\project", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
549                  resolvePath = IOUtil.ResolvePath(@"d:\src\project", @"..\..\");
550                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
551                  resolvePath = IOUtil.ResolvePath(@"d:/src/project", @"../.");
552                  Assert.True(string.Equals(resolvePath, @"d:\src", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
553                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/", @"../../foo");
554                  Assert.True(string.Equals(resolvePath, @"d:\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
555                  resolvePath = IOUtil.ResolvePath(@"d:/src/project/foo", @".././bar/.././../foo");
556                  Assert.True(string.Equals(resolvePath, @"d:\src\foo", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
557                  resolvePath = IOUtil.ResolvePath(@"d:\", @".");
558                  Assert.True(string.Equals(resolvePath, @"d:\", StringComparison.OrdinalIgnoreCase), $"resolvePath does not expected: {resolvePath}");
559  #else
560                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"foo");
561                  Assert.True(string.Equals(resolvePath, @"/user/src/project/foo", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
562                  resolvePath = IOUtil.ResolvePath(@"/root", @"./user/./specs");
563                  Assert.True(string.Equals(resolvePath, @"/root/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
564                  resolvePath = IOUtil.ResolvePath(@"/", @"user/specs/.");
565                  Assert.True(string.Equals(resolvePath, @"/user/specs", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
566                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../");
567                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
568                  resolvePath = IOUtil.ResolvePath(@"/user/src/project", @"../../");
569                  Assert.True(string.Equals(resolvePath, @"/user", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
570                  resolvePath = IOUtil.ResolvePath(@"/user/src/project/foo", @"../../../../user/./src");
571                  Assert.True(string.Equals(resolvePath, @"/user/src", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
572                  resolvePath = IOUtil.ResolvePath(@"/user/src", @"../../.");
573                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
574                  resolvePath = IOUtil.ResolvePath(@"/", @"./");
575                  Assert.True(string.Equals(resolvePath, @"/", StringComparison.OrdinalIgnoreCase), $"RelativePath does not expected: {resolvePath}");
576  #endif
577              }
578          }
579          [Fact]
580          [Trait("Level", "L0")]
581          [Trait("Category", "Common")]
582          public void ValidateExecutePermission_DoesNotExceedFailsafe()
583          {
584              using (TestHostContext hc = new(this))
585              {
586                  Tracing trace = hc.GetTrace();
587                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
588                  try
589                  {
590                      Directory.CreateDirectory(directory);
591                      IOUtil.ValidateExecutePermission(directory);
592                  }
593                  finally
594                  {
595                      if (Directory.Exists(directory))
596                      {
597                          Directory.Delete(directory, recursive: true);
598                      }
599                  }
600              }
601          }
602          [Fact]
603          [Trait("Level", "L0")]
604          [Trait("Category", "Common")]
605          public void ValidateExecutePermission_ExceedsFailsafe()
606          {
607              using (TestHostContext hc = new(this))
608              {
609                  Tracing trace = hc.GetTrace();
610                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName(), "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20");
611                  try
612                  {
613                      Directory.CreateDirectory(directory);
614                      Environment.SetEnvironmentVariable("AGENT_TEST_VALIDATE_EXECUTE_PERMISSIONS_FAILSAFE", "20");
615                      try
616                      {
617                          IOUtil.ValidateExecutePermission(directory);
618                          throw new Exception("Should have thrown not supported exception.");
619                      }
620                      catch (NotSupportedException)
621                      {
622                      }
623                  }
624                  finally
625                  {
626                      if (Directory.Exists(directory))
627                      {
628                          Directory.Delete(directory, recursive: true);
629                      }
630                  }
631              }
632          }
633          [Fact]
634          [Trait("Level", "L0")]
635          [Trait("Category", "Common")]
636          public void LoadObject_ThrowsOnRequiredLoadObject()
637          {
638              using (TestHostContext hc = new(this))
639              {
640                  Tracing trace = hc.GetTrace();
641                  string directory = Path.Combine(hc.GetDirectory(WellKnownDirectory.Bin), Path.GetRandomFileName());
642                  string file = Path.Combine(directory, "empty file");
643                  Directory.CreateDirectory(directory);
644                  File.WriteAllText(path: file, contents: "");
645                  Assert.Throws<ArgumentNullException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
646                  file = Path.Combine(directory, "invalid type file");
647                  File.WriteAllText(path: file, contents: " ");
648                  Assert.Throws<ArgumentException>(() => IOUtil.LoadObject<RunnerSettings>(file, true));
649                  if (Directory.Exists(directory))
650                  {
651                      Directory.Delete(directory, recursive: true);
652                  }
653              }
654          }
655          private static async Task CreateDirectoryReparsePoint(IHostContext context, string link, string target)
656          {
657  #if OS_WINDOWS
658              string fileName = Environment.GetEnvironmentVariable("ComSpec");
659              string arguments = $@"/c ""mklink /J ""{link}"" {target}""""";
660  #else
661              string fileName = "/bin/ln";
662              string arguments = $@"-s ""{target}"" ""{link}""";
663  #endif
664              ArgUtil.File(fileName, nameof(fileName));
665              using (var processInvoker = new ProcessInvokerWrapper())
666              {
667                  processInvoker.Initialize(context);
668                  await processInvoker.ExecuteAsync(
669                      workingDirectory: context.GetDirectory(WellKnownDirectory.Bin),
670                      fileName: fileName,
671                      arguments: arguments,
672                      environment: null,
673                      requireExitCodeZero: true,
674                      cancellationToken: CancellationToken.None);
675              }
676          }
677      }
678  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-Pooling.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtilL0.cs</div>
                <div class="column column_space"><pre><code>23  	    if (GUILayout.Button("Spawn 100")) SpawnPosition(100);
24  	    if (GUILayout.Button("Spawn 300")) SpawnPosition(300);
</pre></code></div>
                <div class="column column_space"><pre><code>454                      if (File.Exists(file))
455                      {
456                          File.SetAttributes(file, File.GetAttributes(file) & ~FileAttributes.ReadOnly);
457                      }
458                      if (Directory.Exists(directory))
459                      {
460                          Directory.Delete(directory, recursive: true);
461                      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    