
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ServerDataProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Linq;
5  using System.Net.Http;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.Services.Common;
9  using GitHub.Services.Identity;
10  using GitHub.Services.Location;
11  using GitHub.Services.Location.Client;
12  using GitHub.Services.WebApi.Utilities;
13  namespace GitHub.Services.WebApi.Location
14  {
15      public interface IVssServerDataProvider : ILocationDataProvider
16      {
17          Boolean HasConnected { get; }
18          Task<Identity.Identity> GetAuthorizedIdentityAsync(CancellationToken cancellationToken = default(CancellationToken));
19          Task<Identity.Identity> GetAuthenticatedIdentityAsync(CancellationToken cancellationToken = default(CancellationToken));
20          Task ConnectAsync(ConnectOptions connectOptions, CancellationToken cancellationToken = default(CancellationToken));
21          Task DisconnectAsync(CancellationToken cancellationToken = default(CancellationToken));
22      }
23      internal class VssServerDataProvider : IVssServerDataProvider
24      {
25          public VssServerDataProvider(
26              VssConnection connection,
27              HttpMessageHandler pipeline,
28              String fullyQualifiedUrl)
29          {
30              m_connection = connection;
31              m_baseUri = connection.Uri;
32              m_fullyQualifiedUrl = fullyQualifiedUrl;
33              m_locationClient = new LocationHttpClient(m_baseUri, pipeline, false);
34              ServerMapData serverData = LocationServerMapCache.ReadServerData(m_fullyQualifiedUrl);
35              m_locationDataCacheManager = new LocationCacheManager(serverData.ServerId, serverData.ServiceOwner, m_baseUri);
36          }
37          internal VssConnection Connection
38          {
39              get { return m_connection; }
40          }
41          public bool HasConnected
42          {
43              get
44              {
45                  return m_connectionMade == true;
46              }
47          }
48          public async Task<Identity.Identity> GetAuthorizedIdentityAsync(
49              CancellationToken cancellationToken = default(CancellationToken))
50          {
51              await EnsureConnectedAsync(ConnectOptions.None).ConfigureAwait(false);
52              Debug.Assert(m_authorizedIdentity != null);
53              return m_authorizedIdentity;
54          }
55          public async Task<Identity.Identity> GetAuthenticatedIdentityAsync(
56              CancellationToken cancellationToken = default(CancellationToken))
57          {
58              await EnsureConnectedAsync(ConnectOptions.None).ConfigureAwait(false);
<span onclick='openModal()' class='match'>59              Debug.Assert(m_authenticatedIdentity != null);
60              return m_authenticatedIdentity;
61          }
62          public Guid InstanceId
63          {
</span>64              get
65              {
66                  return GetInstanceIdAsync().SyncResult();
67              }
68          }
69          public Guid InstanceType
70          {
71              get
72              {
73                  return GetInstanceTypeAsync().SyncResult();
74              }
75          }
76          public async Task<Guid> GetInstanceIdAsync(
77              CancellationToken cancellationToken = default(CancellationToken))
78          {
79              if (!NeedToConnect(ConnectOptions.None))
80              {
81                  return m_instanceId;
82              }
83              else
84              {
85                  ServerMapData serverData = LocationServerMapCache.ReadServerData(m_fullyQualifiedUrl);
86                  Guid toReturn = serverData.ServerId;
87                  if (Guid.Empty != toReturn)
88                  {
89                      return toReturn;
90                  }
91                  await EnsureConnectedAsync(ConnectOptions.None, cancellationToken).ConfigureAwait(false);
92                  return m_instanceId;
93              }
94          }
95          public async Task<Guid> GetInstanceTypeAsync(
96              CancellationToken cancellationToken = default(CancellationToken))
97          {
98              if (!NeedToConnect(ConnectOptions.None))
99              {
100                  return m_serviceOwner;
101              }
102              else
103              {
104                  ServerMapData serverData = LocationServerMapCache.ReadServerData(m_fullyQualifiedUrl);
105                  Guid toReturn = serverData.ServiceOwner;
106                  if (Guid.Empty != toReturn)
107                  {
108                      return toReturn;
109                  }
110                  await EnsureConnectedAsync(ConnectOptions.None, cancellationToken).ConfigureAwait(false);
111                  return m_serviceOwner;
112              }
113          }
114          public AccessMapping DefaultAccessMapping
115          {
116              get
117              {
118                  return GetDefaultAccessMappingAsync().SyncResult();
119              }
120          }
121          public async Task<AccessMapping> GetDefaultAccessMappingAsync(
122              CancellationToken cancellationToken = default(CancellationToken))
123          {
124              AccessMapping defaultAccessMapping = m_locationDataCacheManager.DefaultAccessMapping;
125              if (defaultAccessMapping == null)
126              {
127                  await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
128                  defaultAccessMapping = m_locationDataCacheManager.DefaultAccessMapping;
129                  Debug.Assert(defaultAccessMapping != null, "defaultAccessMapping should never be null");
130              }
131              return defaultAccessMapping;
132          }
133          public AccessMapping ClientAccessMapping
134          {
135              get
136              {
137                  return GetClientAccessMappingAsync().SyncResult();
138              }
139          }
140          public async Task<AccessMapping> GetClientAccessMappingAsync(
141              CancellationToken cancellationToken = default(CancellationToken))
142          {
143              AccessMapping clientAccessMapping = m_locationDataCacheManager.ClientAccessMapping;
144              if (clientAccessMapping == null)
145              {
146                  await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
147                  clientAccessMapping = m_locationDataCacheManager.ClientAccessMapping;
148                  Debug.Assert(clientAccessMapping != null, "clientAccessMapping should never be null");
149              }
150              return clientAccessMapping;
151          }
152          public IEnumerable<AccessMapping> ConfiguredAccessMappings
153          {
154              get
155              {
156                  return GetConfiguredAccessMappingsAsync().SyncResult();
157              }
158          }
159          public async Task<IEnumerable<AccessMapping>> GetConfiguredAccessMappingsAsync(
160              CancellationToken cancellationToken = default(CancellationToken))
161          {
162              await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
163              return m_locationDataCacheManager.AccessMappings;
164          }
165          public AccessMapping GetAccessMapping(String moniker)
166          {
167              return GetAccessMappingAsync(moniker).SyncResult();
168          }
169          public async Task<AccessMapping> GetAccessMappingAsync(
170              String moniker,
171              CancellationToken cancellationToken = default(CancellationToken))
172          {
173              ArgumentUtility.CheckForNull(moniker, "moniker");
174              await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
175              return m_locationDataCacheManager.GetAccessMapping(moniker);
176          }
177          public String LocationForAccessMapping(String serviceType, Guid serviceIdentifier, AccessMapping accessMapping)
178          {
179              return LocationForAccessMappingAsync(serviceType, serviceIdentifier, accessMapping).SyncResult();
180          }
181          public async Task<String> LocationForAccessMappingAsync(
182              String serviceType,
183              Guid serviceIdentifier,
184              AccessMapping accessMapping,
185              CancellationToken cancellationToken = default(CancellationToken))
186          {
187              ServiceDefinition serviceDefinition = await FindServiceDefinitionAsync(serviceType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
188              if (serviceDefinition == null)
189              {
190                  throw new ServiceDefinitionDoesNotExistException(WebApiResources.ServiceDefinitionDoesNotExist(serviceType, serviceIdentifier));
191              }
192              return await LocationForAccessMappingAsync(serviceDefinition, accessMapping, cancellationToken).ConfigureAwait(false);
193          }
194          public String LocationForAccessMapping(
195              ServiceDefinition serviceDefinition,
196              AccessMapping accessMapping)
197          {
198              return LocationForAccessMappingAsync(serviceDefinition, accessMapping).SyncResult();
199          }
200          public Task<String> LocationForAccessMappingAsync(
201              ServiceDefinition serviceDefinition,
202              AccessMapping accessMapping,
203              CancellationToken cancellationToken = default(CancellationToken))
204          {
205              ArgumentUtility.CheckForNull(serviceDefinition, "serviceDefinition");
206              ArgumentUtility.CheckForNull(accessMapping, "accessMapping");
207              if (serviceDefinition.RelativeToSetting == RelativeToSetting.FullyQualified)
208              {
209                  LocationMapping locationMapping = serviceDefinition.GetLocationMapping(accessMapping);
210                  if (locationMapping != null)
211                  {
212                      return Task.FromResult<String>(locationMapping.Location);
213                  }
214                  return Task.FromResult<String>(null);
215              }
216              else
217              {
218                  if (String.IsNullOrEmpty(accessMapping.AccessPoint))
219                  {
220                      throw new InvalidAccessPointException(WebApiResources.InvalidAccessMappingLocationServiceUrl());
221                  }
222                  String webApplicationRelativeDirectory = m_locationDataCacheManager.WebApplicationRelativeDirectory;
223                  if (accessMapping.VirtualDirectory != null)
224                  {
225                      webApplicationRelativeDirectory = accessMapping.VirtualDirectory;
226                  }
227                  Uri uri = new Uri(accessMapping.AccessPoint);
228                  String properRoot = String.Empty;
229                  switch (serviceDefinition.RelativeToSetting)
230                  {
231                      case RelativeToSetting.Context:
232                          properRoot = PathUtility.Combine(uri.AbsoluteUri, webApplicationRelativeDirectory);
233                          break;
234                      case RelativeToSetting.WebApplication:
235                          properRoot = accessMapping.AccessPoint;
236                          break;
237                      default:
238                          Debug.Assert(true, "Found an unknown RelativeToSetting");
239                          break;
240                  }
241                  return Task.FromResult<String>(PathUtility.Combine(properRoot, serviceDefinition.RelativePath));
242              }
243          }
244          public String LocationForCurrentConnection(
245              String serviceType,
246              Guid serviceIdentifier)
247          {
248              return LocationForCurrentConnectionAsync(serviceType, serviceIdentifier).SyncResult();
249          }
250          public async Task<String> LocationForCurrentConnectionAsync(
251              String serviceType,
252              Guid serviceIdentifier,
253              CancellationToken cancellationToken = default(CancellationToken))
254          {
255              if (StringComparer.CurrentCultureIgnoreCase.Equals(serviceType, ServiceInterfaces.LocationService2) &&
256                  serviceIdentifier == LocationServiceConstants.SelfReferenceIdentifier)
257              {
258                  return m_baseUri.AbsoluteUri;
259              }
260              ServiceDefinition serviceDefinition = await FindServiceDefinitionAsync(serviceType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
261              if (serviceDefinition == null)
262              {
263                  return null;
264              }
265              return await LocationForCurrentConnectionAsync(serviceDefinition, cancellationToken).ConfigureAwait(false);
266          }
267          public String LocationForCurrentConnection(ServiceDefinition serviceDefinition)
268          {
269              return LocationForCurrentConnectionAsync(serviceDefinition).SyncResult();
270          }
271          public async Task<String> LocationForCurrentConnectionAsync(
272              ServiceDefinition serviceDefinition,
273              CancellationToken cancellationToken = default(CancellationToken))
274          {
275              AccessMapping clientAccessMapping = await GetClientAccessMappingAsync(cancellationToken).ConfigureAwait(false);
276              String location = await LocationForAccessMappingAsync(serviceDefinition, clientAccessMapping, cancellationToken).ConfigureAwait(false);
277              if (location == null)
278              {
279                  AccessMapping defaultAccessMapping = await GetDefaultAccessMappingAsync(cancellationToken).ConfigureAwait(false);
280                  location = await LocationForAccessMappingAsync(serviceDefinition, defaultAccessMapping, cancellationToken).ConfigureAwait(false);
281                  if (location == null)
282                  {
283                      LocationMapping firstLocationMapping = serviceDefinition.LocationMappings.FirstOrDefault();
284                      if (firstLocationMapping == null)
285                      {
286                          throw new InvalidServiceDefinitionException(WebApiResources.ServiceDefinitionWithNoLocations(serviceDefinition.ServiceType));
287                      }
288                      location = firstLocationMapping.Location;
289                  }
290              }
291              return location;
292          }
293          public IEnumerable<ServiceDefinition> FindServiceDefinitions(String serviceType)
294          {
295              return FindServiceDefinitionsAsync(serviceType).SyncResult();
296          }
297          public async Task<IEnumerable<ServiceDefinition>> FindServiceDefinitionsAsync(
298              String serviceType,
299              CancellationToken cancellationToken = default(CancellationToken))
300          {
301              IEnumerable<ServiceDefinition> definitions = null;
302              if (m_locationDataCacheManager != null)
303              {
304                  definitions = m_locationDataCacheManager.FindServices(serviceType);
305              }
306              if (definitions == null)
307              {
308                  await CheckForServerUpdatesAsync(cancellationToken).ConfigureAwait(false);
309                  return m_locationDataCacheManager.FindServices(serviceType);
310              }
311              return definitions;
312          }
313          public ServiceDefinition FindServiceDefinition(String serviceType, Guid serviceIdentifier)
314          {
315              return FindServiceDefinitionAsync(serviceType, serviceIdentifier).SyncResult();
316          }
317          public async Task<ServiceDefinition> FindServiceDefinitionAsync(
318              String serviceType,
319              Guid serviceIdentifier,
320              CancellationToken cancellationToken = default(CancellationToken))
321          {
322              ArgumentUtility.CheckForNull(serviceType, "serviceType");
323              int lastChangeId = m_locationDataCacheManager.GetLastChangeId();
324              ServiceDefinition definition;
325              if (m_locationDataCacheManager.TryFindService(serviceType, serviceIdentifier, out definition))
326              {
327                  return definition;
328              }
329              await CheckForServerUpdatesAsync(cancellationToken).ConfigureAwait(false);
330              if (!m_locationDataCacheManager.TryFindService(serviceType, serviceIdentifier, out definition))
331              {
332                  if (String.Equals(serviceType, ServiceInterfaces.LocationService2, StringComparison.OrdinalIgnoreCase) &&
333                      serviceIdentifier != LocationServiceConstants.RootIdentifier &&
334                      serviceIdentifier != LocationServiceConstants.ApplicationIdentifier &&
335                      await GetInstanceTypeAsync(cancellationToken).ConfigureAwait(false) == LocationServiceConstants.RootIdentifier)
336                  {
337                      definition = await m_locationClient.GetServiceDefinitionAsync(serviceType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
338                  }
339                  else
340                  {
341                      m_locationDataCacheManager.AddCachedMiss(serviceType, serviceIdentifier, lastChangeId);
342                      return null;
343                  }
344              }
345              return definition;
346          }
347          public ApiResourceLocationCollection GetResourceLocations()
348          {
349              return GetResourceLocationsAsync().SyncResult();
350          }
351          public async Task<ApiResourceLocationCollection> GetResourceLocationsAsync(CancellationToken cancellationToken = default(CancellationToken))
352          {
353              if (m_resourceLocations == null)
354              {
355                  IEnumerable<ServiceDefinition> definitions = await FindServiceDefinitionsAsync(null).ConfigureAwait(false);
356                  if (definitions != null)
357                  {
358                      IEnumerable<ServiceDefinition> resourceLocationDefinitions = definitions.Where(x => x.ResourceVersion > 0);
359                      if (resourceLocationDefinitions.Any())
360                      {
361                          ApiResourceLocationCollection resourceLocations = new ApiResourceLocationCollection();
362                          foreach (ServiceDefinition definition in resourceLocationDefinitions)
363                          {
364                              resourceLocations.AddResourceLocation(ApiResourceLocation.FromServiceDefinition(definition));
365                          }
366                          m_resourceLocations = resourceLocations;
367                      }
368                  }
369              }
370              return m_resourceLocations;
371          }
372          private async Task CheckForServerUpdatesAsync(CancellationToken cancellationToken = default(CancellationToken))
373          {
374              Boolean checkedForUpdates = await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
375              if (!checkedForUpdates)
376              {
377                  Int32 lastChangeId = m_locationDataCacheManager.GetLastChangeId();
378                  if (lastChangeId == -1)
379                  {
380                      await ConnectAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
381                  }
382              }
383          }
384          private async Task<Boolean> EnsureConnectedAsync(
385              ConnectOptions optionsNeeded,
386              CancellationToken cancellationToken = default(CancellationToken))
387          {
388              if (NeedToConnect(optionsNeeded))
389              {
390                  using (await m_connectionLock.LockAsync(cancellationToken).ConfigureAwait(false))
391                  {
392                      if (NeedToConnect(optionsNeeded))
393                      {
394                          await ConnectAsync(optionsNeeded, cancellationToken).ConfigureAwait(false);
395                          return true;
396                      }
397                  }
398              }
399              return false;
400          }
401          private Boolean NeedToConnect(ConnectOptions optionsNeeded)
402          {
403              if (m_locationDataCacheManager.CacheDataExpired)
404              {
405                  m_connectionMade = false;
406                  m_validConnectionData = ConnectOptions.None;
407              }
408              return !m_connectionMade || ((optionsNeeded & m_validConnectionData) != optionsNeeded);
409          }
410          public async Task ConnectAsync(ConnectOptions connectOptions, CancellationToken cancellationToken = default(CancellationToken))
411          {
412              if (!m_locationDataCacheManager.AccessMappings.Any())
413              {
414                  connectOptions |= ConnectOptions.IncludeServices;
415              }
416              Int32 lastChangeId = m_locationDataCacheManager.GetLastChangeId();
417              if (lastChangeId == -1)
418              {
419                  connectOptions |= ConnectOptions.IncludeServices;
420              }
421              Boolean includeServices = (connectOptions & ConnectOptions.IncludeServices) == ConnectOptions.IncludeServices;
422              ConnectionData connectionData = await GetConnectionDataAsync(connectOptions, lastChangeId, cancellationToken).ConfigureAwait(false);
423              LocationServiceData locationServiceData = connectionData.LocationServiceData;
424              if (m_authenticatedIdentity != null)
425              {
426                  if (!IdentityDescriptorComparer.Instance.Equals(m_authenticatedIdentity.Descriptor, connectionData.AuthenticatedUser.Descriptor))
427                  {
428                      throw new VssAuthenticationException(WebApiResources.CannotAuthenticateAsAnotherUser(m_authenticatedIdentity.DisplayName, connectionData.AuthenticatedUser.DisplayName));
429                  }
430              }
431              m_authenticatedIdentity = connectionData.AuthenticatedUser;
432              m_authorizedIdentity = connectionData.AuthorizedUser;
433              m_instanceId = connectionData.InstanceId;
434              if (locationServiceData != null)
435              {
436                  Guid serviceOwner = connectionData.LocationServiceData.ServiceOwner;
437                  if (Guid.Empty == serviceOwner)
438                  {
439                      serviceOwner = ServiceInstanceTypes.TFSOnPremises;
440                  }
441                  m_serviceOwner = serviceOwner;
442              }
443              Boolean wroteMapping = LocationServerMapCache.EnsureServerMappingExists(m_fullyQualifiedUrl, m_instanceId, m_serviceOwner);
444              if (wroteMapping)
445              {
446                  if (includeServices &&
447                      (connectionData.LocationServiceData.ServiceDefinitions == null ||
448                      connectionData.LocationServiceData.ServiceDefinitions.Count == 0))
449                  {
450                      ConnectionData updatedConnectionData = await GetConnectionDataAsync(ConnectOptions.IncludeServices, -1, cancellationToken).ConfigureAwait(false);
451                      locationServiceData = updatedConnectionData.LocationServiceData;
452                  }
453                  m_locationDataCacheManager = new LocationCacheManager(m_instanceId, m_serviceOwner, m_baseUri);
454              }
455              m_locationDataCacheManager.WebApplicationRelativeDirectory = connectionData.WebApplicationRelativeDirectory;
456              if (locationServiceData != null)
457              {
458                  m_locationDataCacheManager.LoadServicesData(locationServiceData, includeServices);
459              }
460              m_validConnectionData |= connectOptions;
461              m_connectionMade = true;
462          }
463          public Task DisconnectAsync(
464              CancellationToken cancellationToken = default(CancellationToken))
465          {
466              m_connectionMade = false;
467              m_authenticatedIdentity = null;
468              m_authorizedIdentity = null;
469              return Task.FromResult<Object>(null);
470          }
471          private VssConnection m_connection;
472          private Uri m_baseUri;
473          private String m_fullyQualifiedUrl;
474          private Identity.Identity m_authenticatedIdentity;
475          private Identity.Identity m_authorizedIdentity;
476          private Guid m_instanceId;
477          private Guid m_serviceOwner;
478          private LocationHttpClient m_locationClient;
479          private ConnectOptions m_validConnectionData;
480          private Boolean m_connectionMade;
481          private LocationCacheManager m_locationDataCacheManager;
482          private ApiResourceLocationCollection m_resourceLocations;
483          private readonly AsyncLock m_connectionLock = new AsyncLock();
484          private async Task<ConnectionData> GetConnectionDataAsync(ConnectOptions connectOptions, int lastChangeId, CancellationToken cancellationToken)
485          {
486              int timeoutRetries = 1;
487              while (true)
488              {
489                  try
490                  {
491                      return await m_locationClient.GetConnectionDataAsync(connectOptions, lastChangeId, cancellationToken).ConfigureAwait(false);
492                  }
493                  catch (TimeoutException) when (timeoutRetries-- > 0) { } 
494              }
495          }
496      }
497  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ServerDataProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Linq;
5  using System.Net.Http;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.Services.Common;
9  using GitHub.Services.Identity;
10  using GitHub.Services.Location;
11  using GitHub.Services.Location.Client;
12  using GitHub.Services.WebApi.Utilities;
13  namespace GitHub.Services.WebApi.Location
14  {
15      public interface IVssServerDataProvider : ILocationDataProvider
16      {
17          Boolean HasConnected { get; }
18          Task<Identity.Identity> GetAuthorizedIdentityAsync(CancellationToken cancellationToken = default(CancellationToken));
19          Task<Identity.Identity> GetAuthenticatedIdentityAsync(CancellationToken cancellationToken = default(CancellationToken));
20          Task ConnectAsync(ConnectOptions connectOptions, CancellationToken cancellationToken = default(CancellationToken));
21          Task DisconnectAsync(CancellationToken cancellationToken = default(CancellationToken));
22      }
23      internal class VssServerDataProvider : IVssServerDataProvider
24      {
25          public VssServerDataProvider(
26              VssConnection connection,
27              HttpMessageHandler pipeline,
28              String fullyQualifiedUrl)
29          {
30              m_connection = connection;
31              m_baseUri = connection.Uri;
32              m_fullyQualifiedUrl = fullyQualifiedUrl;
33              m_locationClient = new LocationHttpClient(m_baseUri, pipeline, false);
34              ServerMapData serverData = LocationServerMapCache.ReadServerData(m_fullyQualifiedUrl);
35              m_locationDataCacheManager = new LocationCacheManager(serverData.ServerId, serverData.ServiceOwner, m_baseUri);
36          }
37          internal VssConnection Connection
38          {
39              get { return m_connection; }
40          }
41          public bool HasConnected
42          {
43              get
44              {
45                  return m_connectionMade == true;
46              }
47          }
48          public async Task<Identity.Identity> GetAuthorizedIdentityAsync(
49              CancellationToken cancellationToken = default(CancellationToken))
50          {
51              await EnsureConnectedAsync(ConnectOptions.None).ConfigureAwait(false);
<span onclick='openModal()' class='match'>52              Debug.Assert(m_authorizedIdentity != null);
53              return m_authorizedIdentity;
54          }
55          public async Task<Identity.Identity> GetAuthenticatedIdentityAsync(
</span>56              CancellationToken cancellationToken = default(CancellationToken))
57          {
58              await EnsureConnectedAsync(ConnectOptions.None).ConfigureAwait(false);
59              Debug.Assert(m_authenticatedIdentity != null);
60              return m_authenticatedIdentity;
61          }
62          public Guid InstanceId
63          {
64              get
65              {
66                  return GetInstanceIdAsync().SyncResult();
67              }
68          }
69          public Guid InstanceType
70          {
71              get
72              {
73                  return GetInstanceTypeAsync().SyncResult();
74              }
75          }
76          public async Task<Guid> GetInstanceIdAsync(
77              CancellationToken cancellationToken = default(CancellationToken))
78          {
79              if (!NeedToConnect(ConnectOptions.None))
80              {
81                  return m_instanceId;
82              }
83              else
84              {
85                  ServerMapData serverData = LocationServerMapCache.ReadServerData(m_fullyQualifiedUrl);
86                  Guid toReturn = serverData.ServerId;
87                  if (Guid.Empty != toReturn)
88                  {
89                      return toReturn;
90                  }
91                  await EnsureConnectedAsync(ConnectOptions.None, cancellationToken).ConfigureAwait(false);
92                  return m_instanceId;
93              }
94          }
95          public async Task<Guid> GetInstanceTypeAsync(
96              CancellationToken cancellationToken = default(CancellationToken))
97          {
98              if (!NeedToConnect(ConnectOptions.None))
99              {
100                  return m_serviceOwner;
101              }
102              else
103              {
104                  ServerMapData serverData = LocationServerMapCache.ReadServerData(m_fullyQualifiedUrl);
105                  Guid toReturn = serverData.ServiceOwner;
106                  if (Guid.Empty != toReturn)
107                  {
108                      return toReturn;
109                  }
110                  await EnsureConnectedAsync(ConnectOptions.None, cancellationToken).ConfigureAwait(false);
111                  return m_serviceOwner;
112              }
113          }
114          public AccessMapping DefaultAccessMapping
115          {
116              get
117              {
118                  return GetDefaultAccessMappingAsync().SyncResult();
119              }
120          }
121          public async Task<AccessMapping> GetDefaultAccessMappingAsync(
122              CancellationToken cancellationToken = default(CancellationToken))
123          {
124              AccessMapping defaultAccessMapping = m_locationDataCacheManager.DefaultAccessMapping;
125              if (defaultAccessMapping == null)
126              {
127                  await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
128                  defaultAccessMapping = m_locationDataCacheManager.DefaultAccessMapping;
129                  Debug.Assert(defaultAccessMapping != null, "defaultAccessMapping should never be null");
130              }
131              return defaultAccessMapping;
132          }
133          public AccessMapping ClientAccessMapping
134          {
135              get
136              {
137                  return GetClientAccessMappingAsync().SyncResult();
138              }
139          }
140          public async Task<AccessMapping> GetClientAccessMappingAsync(
141              CancellationToken cancellationToken = default(CancellationToken))
142          {
143              AccessMapping clientAccessMapping = m_locationDataCacheManager.ClientAccessMapping;
144              if (clientAccessMapping == null)
145              {
146                  await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
147                  clientAccessMapping = m_locationDataCacheManager.ClientAccessMapping;
148                  Debug.Assert(clientAccessMapping != null, "clientAccessMapping should never be null");
149              }
150              return clientAccessMapping;
151          }
152          public IEnumerable<AccessMapping> ConfiguredAccessMappings
153          {
154              get
155              {
156                  return GetConfiguredAccessMappingsAsync().SyncResult();
157              }
158          }
159          public async Task<IEnumerable<AccessMapping>> GetConfiguredAccessMappingsAsync(
160              CancellationToken cancellationToken = default(CancellationToken))
161          {
162              await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
163              return m_locationDataCacheManager.AccessMappings;
164          }
165          public AccessMapping GetAccessMapping(String moniker)
166          {
167              return GetAccessMappingAsync(moniker).SyncResult();
168          }
169          public async Task<AccessMapping> GetAccessMappingAsync(
170              String moniker,
171              CancellationToken cancellationToken = default(CancellationToken))
172          {
173              ArgumentUtility.CheckForNull(moniker, "moniker");
174              await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
175              return m_locationDataCacheManager.GetAccessMapping(moniker);
176          }
177          public String LocationForAccessMapping(String serviceType, Guid serviceIdentifier, AccessMapping accessMapping)
178          {
179              return LocationForAccessMappingAsync(serviceType, serviceIdentifier, accessMapping).SyncResult();
180          }
181          public async Task<String> LocationForAccessMappingAsync(
182              String serviceType,
183              Guid serviceIdentifier,
184              AccessMapping accessMapping,
185              CancellationToken cancellationToken = default(CancellationToken))
186          {
187              ServiceDefinition serviceDefinition = await FindServiceDefinitionAsync(serviceType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
188              if (serviceDefinition == null)
189              {
190                  throw new ServiceDefinitionDoesNotExistException(WebApiResources.ServiceDefinitionDoesNotExist(serviceType, serviceIdentifier));
191              }
192              return await LocationForAccessMappingAsync(serviceDefinition, accessMapping, cancellationToken).ConfigureAwait(false);
193          }
194          public String LocationForAccessMapping(
195              ServiceDefinition serviceDefinition,
196              AccessMapping accessMapping)
197          {
198              return LocationForAccessMappingAsync(serviceDefinition, accessMapping).SyncResult();
199          }
200          public Task<String> LocationForAccessMappingAsync(
201              ServiceDefinition serviceDefinition,
202              AccessMapping accessMapping,
203              CancellationToken cancellationToken = default(CancellationToken))
204          {
205              ArgumentUtility.CheckForNull(serviceDefinition, "serviceDefinition");
206              ArgumentUtility.CheckForNull(accessMapping, "accessMapping");
207              if (serviceDefinition.RelativeToSetting == RelativeToSetting.FullyQualified)
208              {
209                  LocationMapping locationMapping = serviceDefinition.GetLocationMapping(accessMapping);
210                  if (locationMapping != null)
211                  {
212                      return Task.FromResult<String>(locationMapping.Location);
213                  }
214                  return Task.FromResult<String>(null);
215              }
216              else
217              {
218                  if (String.IsNullOrEmpty(accessMapping.AccessPoint))
219                  {
220                      throw new InvalidAccessPointException(WebApiResources.InvalidAccessMappingLocationServiceUrl());
221                  }
222                  String webApplicationRelativeDirectory = m_locationDataCacheManager.WebApplicationRelativeDirectory;
223                  if (accessMapping.VirtualDirectory != null)
224                  {
225                      webApplicationRelativeDirectory = accessMapping.VirtualDirectory;
226                  }
227                  Uri uri = new Uri(accessMapping.AccessPoint);
228                  String properRoot = String.Empty;
229                  switch (serviceDefinition.RelativeToSetting)
230                  {
231                      case RelativeToSetting.Context:
232                          properRoot = PathUtility.Combine(uri.AbsoluteUri, webApplicationRelativeDirectory);
233                          break;
234                      case RelativeToSetting.WebApplication:
235                          properRoot = accessMapping.AccessPoint;
236                          break;
237                      default:
238                          Debug.Assert(true, "Found an unknown RelativeToSetting");
239                          break;
240                  }
241                  return Task.FromResult<String>(PathUtility.Combine(properRoot, serviceDefinition.RelativePath));
242              }
243          }
244          public String LocationForCurrentConnection(
245              String serviceType,
246              Guid serviceIdentifier)
247          {
248              return LocationForCurrentConnectionAsync(serviceType, serviceIdentifier).SyncResult();
249          }
250          public async Task<String> LocationForCurrentConnectionAsync(
251              String serviceType,
252              Guid serviceIdentifier,
253              CancellationToken cancellationToken = default(CancellationToken))
254          {
255              if (StringComparer.CurrentCultureIgnoreCase.Equals(serviceType, ServiceInterfaces.LocationService2) &&
256                  serviceIdentifier == LocationServiceConstants.SelfReferenceIdentifier)
257              {
258                  return m_baseUri.AbsoluteUri;
259              }
260              ServiceDefinition serviceDefinition = await FindServiceDefinitionAsync(serviceType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
261              if (serviceDefinition == null)
262              {
263                  return null;
264              }
265              return await LocationForCurrentConnectionAsync(serviceDefinition, cancellationToken).ConfigureAwait(false);
266          }
267          public String LocationForCurrentConnection(ServiceDefinition serviceDefinition)
268          {
269              return LocationForCurrentConnectionAsync(serviceDefinition).SyncResult();
270          }
271          public async Task<String> LocationForCurrentConnectionAsync(
272              ServiceDefinition serviceDefinition,
273              CancellationToken cancellationToken = default(CancellationToken))
274          {
275              AccessMapping clientAccessMapping = await GetClientAccessMappingAsync(cancellationToken).ConfigureAwait(false);
276              String location = await LocationForAccessMappingAsync(serviceDefinition, clientAccessMapping, cancellationToken).ConfigureAwait(false);
277              if (location == null)
278              {
279                  AccessMapping defaultAccessMapping = await GetDefaultAccessMappingAsync(cancellationToken).ConfigureAwait(false);
280                  location = await LocationForAccessMappingAsync(serviceDefinition, defaultAccessMapping, cancellationToken).ConfigureAwait(false);
281                  if (location == null)
282                  {
283                      LocationMapping firstLocationMapping = serviceDefinition.LocationMappings.FirstOrDefault();
284                      if (firstLocationMapping == null)
285                      {
286                          throw new InvalidServiceDefinitionException(WebApiResources.ServiceDefinitionWithNoLocations(serviceDefinition.ServiceType));
287                      }
288                      location = firstLocationMapping.Location;
289                  }
290              }
291              return location;
292          }
293          public IEnumerable<ServiceDefinition> FindServiceDefinitions(String serviceType)
294          {
295              return FindServiceDefinitionsAsync(serviceType).SyncResult();
296          }
297          public async Task<IEnumerable<ServiceDefinition>> FindServiceDefinitionsAsync(
298              String serviceType,
299              CancellationToken cancellationToken = default(CancellationToken))
300          {
301              IEnumerable<ServiceDefinition> definitions = null;
302              if (m_locationDataCacheManager != null)
303              {
304                  definitions = m_locationDataCacheManager.FindServices(serviceType);
305              }
306              if (definitions == null)
307              {
308                  await CheckForServerUpdatesAsync(cancellationToken).ConfigureAwait(false);
309                  return m_locationDataCacheManager.FindServices(serviceType);
310              }
311              return definitions;
312          }
313          public ServiceDefinition FindServiceDefinition(String serviceType, Guid serviceIdentifier)
314          {
315              return FindServiceDefinitionAsync(serviceType, serviceIdentifier).SyncResult();
316          }
317          public async Task<ServiceDefinition> FindServiceDefinitionAsync(
318              String serviceType,
319              Guid serviceIdentifier,
320              CancellationToken cancellationToken = default(CancellationToken))
321          {
322              ArgumentUtility.CheckForNull(serviceType, "serviceType");
323              int lastChangeId = m_locationDataCacheManager.GetLastChangeId();
324              ServiceDefinition definition;
325              if (m_locationDataCacheManager.TryFindService(serviceType, serviceIdentifier, out definition))
326              {
327                  return definition;
328              }
329              await CheckForServerUpdatesAsync(cancellationToken).ConfigureAwait(false);
330              if (!m_locationDataCacheManager.TryFindService(serviceType, serviceIdentifier, out definition))
331              {
332                  if (String.Equals(serviceType, ServiceInterfaces.LocationService2, StringComparison.OrdinalIgnoreCase) &&
333                      serviceIdentifier != LocationServiceConstants.RootIdentifier &&
334                      serviceIdentifier != LocationServiceConstants.ApplicationIdentifier &&
335                      await GetInstanceTypeAsync(cancellationToken).ConfigureAwait(false) == LocationServiceConstants.RootIdentifier)
336                  {
337                      definition = await m_locationClient.GetServiceDefinitionAsync(serviceType, serviceIdentifier, cancellationToken).ConfigureAwait(false);
338                  }
339                  else
340                  {
341                      m_locationDataCacheManager.AddCachedMiss(serviceType, serviceIdentifier, lastChangeId);
342                      return null;
343                  }
344              }
345              return definition;
346          }
347          public ApiResourceLocationCollection GetResourceLocations()
348          {
349              return GetResourceLocationsAsync().SyncResult();
350          }
351          public async Task<ApiResourceLocationCollection> GetResourceLocationsAsync(CancellationToken cancellationToken = default(CancellationToken))
352          {
353              if (m_resourceLocations == null)
354              {
355                  IEnumerable<ServiceDefinition> definitions = await FindServiceDefinitionsAsync(null).ConfigureAwait(false);
356                  if (definitions != null)
357                  {
358                      IEnumerable<ServiceDefinition> resourceLocationDefinitions = definitions.Where(x => x.ResourceVersion > 0);
359                      if (resourceLocationDefinitions.Any())
360                      {
361                          ApiResourceLocationCollection resourceLocations = new ApiResourceLocationCollection();
362                          foreach (ServiceDefinition definition in resourceLocationDefinitions)
363                          {
364                              resourceLocations.AddResourceLocation(ApiResourceLocation.FromServiceDefinition(definition));
365                          }
366                          m_resourceLocations = resourceLocations;
367                      }
368                  }
369              }
370              return m_resourceLocations;
371          }
372          private async Task CheckForServerUpdatesAsync(CancellationToken cancellationToken = default(CancellationToken))
373          {
374              Boolean checkedForUpdates = await EnsureConnectedAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
375              if (!checkedForUpdates)
376              {
377                  Int32 lastChangeId = m_locationDataCacheManager.GetLastChangeId();
378                  if (lastChangeId == -1)
379                  {
380                      await ConnectAsync(ConnectOptions.IncludeServices, cancellationToken).ConfigureAwait(false);
381                  }
382              }
383          }
384          private async Task<Boolean> EnsureConnectedAsync(
385              ConnectOptions optionsNeeded,
386              CancellationToken cancellationToken = default(CancellationToken))
387          {
388              if (NeedToConnect(optionsNeeded))
389              {
390                  using (await m_connectionLock.LockAsync(cancellationToken).ConfigureAwait(false))
391                  {
392                      if (NeedToConnect(optionsNeeded))
393                      {
394                          await ConnectAsync(optionsNeeded, cancellationToken).ConfigureAwait(false);
395                          return true;
396                      }
397                  }
398              }
399              return false;
400          }
401          private Boolean NeedToConnect(ConnectOptions optionsNeeded)
402          {
403              if (m_locationDataCacheManager.CacheDataExpired)
404              {
405                  m_connectionMade = false;
406                  m_validConnectionData = ConnectOptions.None;
407              }
408              return !m_connectionMade || ((optionsNeeded & m_validConnectionData) != optionsNeeded);
409          }
410          public async Task ConnectAsync(ConnectOptions connectOptions, CancellationToken cancellationToken = default(CancellationToken))
411          {
412              if (!m_locationDataCacheManager.AccessMappings.Any())
413              {
414                  connectOptions |= ConnectOptions.IncludeServices;
415              }
416              Int32 lastChangeId = m_locationDataCacheManager.GetLastChangeId();
417              if (lastChangeId == -1)
418              {
419                  connectOptions |= ConnectOptions.IncludeServices;
420              }
421              Boolean includeServices = (connectOptions & ConnectOptions.IncludeServices) == ConnectOptions.IncludeServices;
422              ConnectionData connectionData = await GetConnectionDataAsync(connectOptions, lastChangeId, cancellationToken).ConfigureAwait(false);
423              LocationServiceData locationServiceData = connectionData.LocationServiceData;
424              if (m_authenticatedIdentity != null)
425              {
426                  if (!IdentityDescriptorComparer.Instance.Equals(m_authenticatedIdentity.Descriptor, connectionData.AuthenticatedUser.Descriptor))
427                  {
428                      throw new VssAuthenticationException(WebApiResources.CannotAuthenticateAsAnotherUser(m_authenticatedIdentity.DisplayName, connectionData.AuthenticatedUser.DisplayName));
429                  }
430              }
431              m_authenticatedIdentity = connectionData.AuthenticatedUser;
432              m_authorizedIdentity = connectionData.AuthorizedUser;
433              m_instanceId = connectionData.InstanceId;
434              if (locationServiceData != null)
435              {
436                  Guid serviceOwner = connectionData.LocationServiceData.ServiceOwner;
437                  if (Guid.Empty == serviceOwner)
438                  {
439                      serviceOwner = ServiceInstanceTypes.TFSOnPremises;
440                  }
441                  m_serviceOwner = serviceOwner;
442              }
443              Boolean wroteMapping = LocationServerMapCache.EnsureServerMappingExists(m_fullyQualifiedUrl, m_instanceId, m_serviceOwner);
444              if (wroteMapping)
445              {
446                  if (includeServices &&
447                      (connectionData.LocationServiceData.ServiceDefinitions == null ||
448                      connectionData.LocationServiceData.ServiceDefinitions.Count == 0))
449                  {
450                      ConnectionData updatedConnectionData = await GetConnectionDataAsync(ConnectOptions.IncludeServices, -1, cancellationToken).ConfigureAwait(false);
451                      locationServiceData = updatedConnectionData.LocationServiceData;
452                  }
453                  m_locationDataCacheManager = new LocationCacheManager(m_instanceId, m_serviceOwner, m_baseUri);
454              }
455              m_locationDataCacheManager.WebApplicationRelativeDirectory = connectionData.WebApplicationRelativeDirectory;
456              if (locationServiceData != null)
457              {
458                  m_locationDataCacheManager.LoadServicesData(locationServiceData, includeServices);
459              }
460              m_validConnectionData |= connectOptions;
461              m_connectionMade = true;
462          }
463          public Task DisconnectAsync(
464              CancellationToken cancellationToken = default(CancellationToken))
465          {
466              m_connectionMade = false;
467              m_authenticatedIdentity = null;
468              m_authorizedIdentity = null;
469              return Task.FromResult<Object>(null);
470          }
471          private VssConnection m_connection;
472          private Uri m_baseUri;
473          private String m_fullyQualifiedUrl;
474          private Identity.Identity m_authenticatedIdentity;
475          private Identity.Identity m_authorizedIdentity;
476          private Guid m_instanceId;
477          private Guid m_serviceOwner;
478          private LocationHttpClient m_locationClient;
479          private ConnectOptions m_validConnectionData;
480          private Boolean m_connectionMade;
481          private LocationCacheManager m_locationDataCacheManager;
482          private ApiResourceLocationCollection m_resourceLocations;
483          private readonly AsyncLock m_connectionLock = new AsyncLock();
484          private async Task<ConnectionData> GetConnectionDataAsync(ConnectOptions connectOptions, int lastChangeId, CancellationToken cancellationToken)
485          {
486              int timeoutRetries = 1;
487              while (true)
488              {
489                  try
490                  {
491                      return await m_locationClient.GetConnectionDataAsync(connectOptions, lastChangeId, cancellationToken).ConfigureAwait(false);
492                  }
493                  catch (TimeoutException) when (timeoutRetries-- > 0) { } 
494              }
495          }
496      }
497  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ServerDataProvider.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ServerDataProvider.cs</div>
                </div>
                <div class="column column_space"><pre><code>59              Debug.Assert(m_authenticatedIdentity != null);
60              return m_authenticatedIdentity;
61          }
62          public Guid InstanceId
63          {
</pre></code></div>
                <div class="column column_space"><pre><code>52              Debug.Assert(m_authorizedIdentity != null);
53              return m_authorizedIdentity;
54          }
55          public async Task<Identity.Identity> GetAuthenticatedIdentityAsync(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    