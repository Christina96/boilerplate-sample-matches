
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 114, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-XmlDocumentation_5.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Reflection;
6  using System.Text.RegularExpressions;
7  using System.Xml;
8  namespace MudBlazor.Docs.Models
9  {
10      public static class XmlDocumentation
11      {
12          #region System.Reflection.Assembly
13          public static IEnumerable<EventInfo> GetEventInfosWithAttribute<AttributeType>(this Assembly assembly)
14              where AttributeType : Attribute
15          {
16              foreach (var type in assembly.GetTypes())
17              {
18                  foreach (var eventInfo in type.GetEvents(
19                      BindingFlags.Instance |
20                      BindingFlags.Static |
21                      BindingFlags.Public |
22                      BindingFlags.NonPublic))
23                  {
24                      if (eventInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
25                      {
26                          yield return eventInfo;
27                      }
28                  }
29              }
30          }
31          public static IEnumerable<ConstructorInfo> GetConstructorInfosWithAttribute<AttributeType>(this Assembly assembly)
32              where AttributeType : Attribute
33          {
34              foreach (var type in assembly.GetTypes())
35              {
36                  foreach (var constructorInfo in type.GetConstructors(
37                      BindingFlags.Instance |
38                      BindingFlags.Public |
39                      BindingFlags.NonPublic))
40                  {
41                      if (constructorInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
42                      {
43                          yield return constructorInfo;
44                      }
45                  }
46              }
47          }
48          public static IEnumerable<PropertyInfo> GetPropertyInfosWithAttribute<AttributeType>(this Assembly assembly)
49              where AttributeType : Attribute
50          {
51              foreach (var type in assembly.GetTypes())
52              {
53                  foreach (var propertyInfo in type.GetProperties(
54                      BindingFlags.Instance |
55                      BindingFlags.Static |
56                      BindingFlags.Public |
57                      BindingFlags.NonPublic))
58                  {
59                      if (propertyInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
60                      {
61                          yield return propertyInfo;
62                      }
63                  }
64              }
65          }
66          public static IEnumerable<PropertyInfo> GetPropertyInfosWithAttribute<AttributeType>(this Type type)
67              where AttributeType : Attribute
68          {
69              foreach (var propertyInfo in type.GetProperties(
70                  BindingFlags.Instance |
71                  BindingFlags.Static |
72                  BindingFlags.Public |
73                  BindingFlags.NonPublic))
74              {
75                  if (propertyInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
76                  {
77                      yield return propertyInfo;
78                  }
79              }
80          }
81          public static IEnumerable<FieldInfo> GetFieldInfosWithAttribute<AttributeType>(this Assembly assembly)
82              where AttributeType : Attribute
83          {
84              foreach (var type in assembly.GetTypes())
85              {
86                  foreach (var fieldInfo in type.GetFields(
87                      BindingFlags.Instance |
88                      BindingFlags.Static |
89                      BindingFlags.Public |
90                      BindingFlags.NonPublic))
91                  {
92                      if (fieldInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
93                      {
94                          yield return fieldInfo;
95                      }
96                  }
97              }
98          }
99          public static IEnumerable<MethodInfo> GetMethodInfosWithAttribute<AttributeType>(this Assembly assembly)
100              where AttributeType : Attribute
101          {
102              foreach (var type in assembly.GetTypes())
103              {
104                  foreach (var methodInfo in type.GetMethods(
105                      BindingFlags.Instance |
106                      BindingFlags.Static |
107                      BindingFlags.Public |
108                      BindingFlags.NonPublic))
109                  {
110                      if (methodInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
111                      {
112                          yield return methodInfo;
113                      }
114                  }
115              }
116          }
117          public static IEnumerable<Type> GetTypesWithAttribute<AttributeType>(this Assembly assembly)
118              where AttributeType : Attribute
119          {
120              foreach (var type in assembly.GetTypes())
121              {
122                  if (type.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
123                  {
124                      yield return type;
125                  }
126              }
127          }
128          public static IEnumerable<Type> GetDerivedTypes<Base>(this Assembly assembly)
129          {
130              var @base = typeof(Base);
131              return assembly.GetTypes().Where(type =>
132                  type != @base &&
133                  @base.IsAssignableFrom(type));
134          }
135          public static string GetDirectoryPath(this Assembly assembly)
136          {
137              var codeBase = "file:&bsol;&bsol;" + assembly.Location;
138              var uri = new UriBuilder(codeBase);
139              var path = Uri.UnescapeDataString(uri.Path);
140              return Path.GetDirectoryName(path);
141          }
142          #endregion
143          #region System.Type.ConvertToCSharpSource
144          public static string ConvertToCSharpSource(this Type type, bool showGenericParameters = false)
145          {
146              var genericParameters = new Queue<Type>();
147              foreach (var x in type.GetGenericArguments())
148                  genericParameters.Enqueue(x);
149              return ConvertToCsharpSource(type);
150              string ConvertToCsharpSource(Type type)
151              {
152                  _ = type ?? throw new ArgumentNullException(nameof(type));
153                  var result = type.IsNested
154                      ? ConvertToCsharpSource(type.DeclaringType) + "."
155                      : ""; 
156                  result += Regex.Replace(type.Name, "`.*", string.Empty);
157                  if (type.IsGenericType)
158                  {
159                      result += "<";
160                      var firstIteration = true;
161                      foreach (var generic in type.GetGenericArguments())
162                      {
163                          if (genericParameters.Count <= 0)
164                          {
165                              break;
166                          }
167                          var correctGeneric = genericParameters.Dequeue();
168                          result += (firstIteration ? string.Empty : ",") +
169                                    (correctGeneric.IsGenericParameter
170                                        ? (showGenericParameters ? (firstIteration ? string.Empty : " ") + correctGeneric.Name : string.Empty)
171                                        : (firstIteration ? string.Empty : " ") + ConvertToCSharpSource(correctGeneric));
172                          firstIteration = false;
173                      }
174                      result += ">";
175                  }
176                  return result;
177              }
178          }
179          #endregion
180          #region XML Code Documentation
181          public static HashSet<Assembly> LoadedAssemblies = new();
182          public static Dictionary<string, string> LoadedXmlDocumentation = new();
183          public static void LoadXmlDocumentation(Assembly assembly)
184          {
185              string xmlFilePath;
186              if (LoadedAssemblies.Contains(assembly))
187              {
188                  return;
189              }
190              var directoryPath = assembly.GetDirectoryPath();
191              if (!string.IsNullOrEmpty(directoryPath))
192              {
193                  xmlFilePath = Path.Combine(directoryPath, assembly.GetName().Name + ".xml");
194              }
195              else
196              {
197                  xmlFilePath = assembly.GetName().Name + ".xml";
198              }
199              if (File.Exists(xmlFilePath))
200              {
201                  using var streamReader = new StreamReader(xmlFilePath);
202                  LoadXmlDocumentation(streamReader);
203              }
204              LoadedAssemblies.Add(assembly);
205          }
206          public static void LoadXmlDocumentation(string xmlDocumentation)
207          {
208              using var stringReader = new StringReader(xmlDocumentation);
209              LoadXmlDocumentation(stringReader);
210          }
211          public static void LoadXmlDocumentation(TextReader textReader)
212          {
213              using var xmlReader = XmlReader.Create(textReader);
214              while (xmlReader.Read())
215              {
216                  if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.Name == "member")
217                  {
218                      var raw_name = xmlReader["name"];
219                      LoadedXmlDocumentation[raw_name] = xmlReader.ReadInnerXml();
220                  }
221              }
222          }
223          public static void ClearXmlDocumentation()
224          {
225              LoadedAssemblies.Clear();
226              LoadedXmlDocumentation.Clear();
227          }
228          public static string GetDocumentation(this Type type)
229          {
230              LoadXmlDocumentation(type.Assembly);
231              var key = "T:" + XmlDocumentationKeyHelper(type.FullName, null);
232              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
233              return documentation;
234          }
235          public static string GetDocumentation(this MethodInfo methodInfo)
236          {
237              LoadXmlDocumentation(methodInfo.DeclaringType.Assembly);
238              var typeGenericMap = new Dictionary<string, int>();
239              var tempTypeGeneric = 0;
240              Array.ForEach(methodInfo.DeclaringType.GetGenericArguments(), x => typeGenericMap[x.Name] = tempTypeGeneric++);
241              var methodGenericMap = new Dictionary<string, int>();
242              var tempMethodGeneric = 0;
243              Array.ForEach(methodInfo.GetGenericArguments(), x => methodGenericMap.Add(x.Name, tempMethodGeneric++));
244              var parameterInfos = methodInfo.GetParameters();
245              var memberTypePrefix = "M:";
246              var declarationTypeString = GetXmlDocumentationFormattedString(methodInfo.DeclaringType, false, typeGenericMap, methodGenericMap);
247              var memberNameString = methodInfo.Name;
248              var methodGenericArgumentsString =
249                  methodGenericMap.Count > 0 ?
250                  "``" + methodGenericMap.Count :
251                  string.Empty;
252              var parametersString =
253                  parameterInfos.Length > 0 ?
254                  "(" + string.Join(",", methodInfo.GetParameters().Select(x => GetXmlDocumentationFormattedString(x.ParameterType, true, typeGenericMap, methodGenericMap))).Replace("MudBlazor.Docs.Models.T", "`0") + ")" :
255                  string.Empty;
256              var key =
257                  memberTypePrefix +
258                  declarationTypeString +
259                  "." +
260                  memberNameString +
261                  methodGenericArgumentsString +
262                  parametersString;
263              if (methodInfo.Name is "op_Implicit" or "op_Explicit")
264              {
265                  key += "~" + GetXmlDocumentationFormattedString(methodInfo.ReturnType, true, typeGenericMap, methodGenericMap);
266              }
267              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
268              return documentation;
269          }
270          public static string GetDocumentation(this ConstructorInfo constructorInfo)
271          {
272              LoadXmlDocumentation(constructorInfo.DeclaringType.Assembly);
273              var typeGenericMap = new Dictionary<string, int>();
274              var tempTypeGeneric = 0;
275              Array.ForEach(constructorInfo.DeclaringType.GetGenericArguments(), x => typeGenericMap[x.Name] = tempTypeGeneric++);
276              var methodGenericMap = new Dictionary<string, int>();
277              var parameterInfos = constructorInfo.GetParameters();
278              var memberTypePrefix = "M:";
279              var declarationTypeString = GetXmlDocumentationFormattedString(constructorInfo.DeclaringType, false, typeGenericMap, methodGenericMap);
280              var memberNameString = "#ctor";
281              var parametersString =
282                  parameterInfos.Length > 0 ?
283                  "(" + string.Join(",", constructorInfo.GetParameters().Select(x => GetXmlDocumentationFormattedString(x.ParameterType, true, typeGenericMap, methodGenericMap))) + ")" :
284                  string.Empty;
285              var key =
286                  memberTypePrefix +
287                  declarationTypeString +
288                  "." +
289                  memberNameString +
290                  parametersString;
291              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
292              return documentation;
293          }
294          public static string GetXmlDocumentationFormattedString(
295              Type type,
296              bool isMethodParameter,
297              Dictionary<string, int> typeGenericMap,
298              Dictionary<string, int> methodGenericMap)
299          {
300              if (type.IsGenericParameter)
301              {
302                  return methodGenericMap.TryGetValue(type.Name, out var methodIndex)
303                      ? "``" + methodIndex
304                      : "`" + typeGenericMap[type.Name];
305              }
306              else if (type.HasElementType)
307              {
308                  var elementTypeString = GetXmlDocumentationFormattedString(
309                      type.GetElementType(),
310                      isMethodParameter,
311                      typeGenericMap,
312                      methodGenericMap);
313                  if (type.IsPointer)
314                  {
315                      return elementTypeString + "*";
316                  }
317                  else if (type.IsArray)
318                  {
319                      var rank = type.GetArrayRank();
320                      var arrayDimensionsString = rank > 1
321                          ? "[" + string.Join(",", Enumerable.Repeat("0:", rank)) + "]"
322                          : "[]";
323                      return elementTypeString + arrayDimensionsString;
324                  }
325                  else if (type.IsByRef)
326                  {
327                      return elementTypeString + "@";
328                  }
329                  else
330                  {
331                      throw new Exception(nameof(GetXmlDocumentationFormattedString) +
332                          " encountered an unhandled element type. " +
333                          "Please submit this issue to the Towel GitHub repository. " +
334                          "https:&bsol;&bsol;github.com/ZacharyPatten/Towel/issues/new/choose");
335                  }
336              }
337              else
338              {
339                  var prefaceString = type.IsNested
340                      ? GetXmlDocumentationFormattedString(
341                          type.DeclaringType,
342                          isMethodParameter,
343                          typeGenericMap,
<span onclick='openModal()' class='match'>344                          methodGenericMap) + "."
345                      : type.Namespace + ".";
346                  string typeNameString = isMethodParameter
347                      ? typeNameString = Regex.Replace(type.Name, @"`\d+", string.Empty)
348                      : typeNameString = type.Name;
349                  var genericArgumentsString = type.IsGenericType && isMethodParameter
350                      ? "{" + string.Join(",",
351                          type.GetGenericArguments().Select(argument =>
352                              GetXmlDocumentationFormattedString(
353                                  argument,
354                                  isMethodParameter,
355                                  typeGenericMap,
356                                  methodGenericMap))
357                          ) + "}"
358                      : string.Empty;
359                  return prefaceString + typeNameString + genericArgumentsString;
360              }
361          }
362          public static string GetDocumentation(this PropertyInfo propertyInfo)
363          {
364              LoadXmlDocumentation(propertyInfo.DeclaringType.Assembly);
365              var key = "P:" + XmlDocumentationKeyHelper(propertyInfo.DeclaringType.FullName, propertyInfo.Name);
</span>366              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
367              return documentation;
368          }
369          public static string GetDocumentation(this FieldInfo fieldInfo)
370          {
371              LoadXmlDocumentation(fieldInfo.DeclaringType.Assembly);
372              var key = "F:" + XmlDocumentationKeyHelper(fieldInfo.DeclaringType.FullName, fieldInfo.Name);
373              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
374              return documentation;
375          }
376          public static string GetDocumentation(this EventInfo eventInfo)
377          {
378              LoadXmlDocumentation(eventInfo.DeclaringType.Assembly);
379              var key = "E:" + XmlDocumentationKeyHelper(eventInfo.DeclaringType.FullName, eventInfo.Name);
380              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
381              return documentation;
382          }
383          public static string XmlDocumentationKeyHelper(string typeFullNameString, string memberNameString)
384          {
385              var key = Regex.Replace(typeFullNameString, @"\[.*\]", string.Empty).Replace('+', '.');
386              if (!(memberNameString is null))
387              {
388                  key += "." + memberNameString;
389              }
390              return key;
391          }
392          public static string GetDocumentation(this MemberInfo memberInfo)
393          {
394              if (memberInfo is FieldInfo fieldInfo)
395              {
396                  return fieldInfo.GetDocumentation();
397              }
398              else if (memberInfo is PropertyInfo propertyInfo)
399              {
400                  return propertyInfo.GetDocumentation();
401              }
402              else if (memberInfo is EventInfo eventInfo)
403              {
404                  return eventInfo.GetDocumentation();
405              }
406              else if (memberInfo is ConstructorInfo constructorInfo)
407              {
408                  return constructorInfo.GetDocumentation();
409              }
410              else if (memberInfo is MethodInfo methodInfo)
411              {
412                  return methodInfo.GetDocumentation();
413              }
414              else if (memberInfo is Type type) 
415              {
416                  return type.GetDocumentation();
417              }
418              else if (memberInfo.MemberType.HasFlag(MemberTypes.Custom))
419              {
420                  return null;
421              }
422              else
423              {
424                  throw new Exception(nameof(GetDocumentation) +
425                      " encountered an unhandled type [" + memberInfo.GetType().FullName + "]. " +
426                      "Please submit this issue to the Towel GitHub repository. " +
427                      "https:&bsol;&bsol;github.com/ZacharyPatten/Towel/issues/new/choose");
428              }
429          }
430          public static string GetDocumentation(this ParameterInfo parameterInfo)
431          {
432              var memberDocumentation = parameterInfo.Member.GetDocumentation();
433              if (!(memberDocumentation is null))
434              {
435                  var regexPattern =
436                      Regex.Escape(@"<param name=" + "\"" + parameterInfo.Name + "\"" + @">") +
437                      ".*?" +
438                      Regex.Escape(@"</param>");
439                  var match = Regex.Match(memberDocumentation, regexPattern);
440                  if (match.Success)
441                  {
442                      return match.Value;
443                  }
444              }
445              return null;
446          }
447          #endregion
448      }
449  }
</code></pre>
        </div>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-XmlDocumentation_5.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Reflection;
6  using System.Text.RegularExpressions;
7  using System.Xml;
8  namespace MudBlazor.Docs.Models
9  {
10      public static class XmlDocumentation
11      {
12          #region System.Reflection.Assembly
13          public static IEnumerable<EventInfo> GetEventInfosWithAttribute<AttributeType>(this Assembly assembly)
14              where AttributeType : Attribute
15          {
16              foreach (var type in assembly.GetTypes())
17              {
18                  foreach (var eventInfo in type.GetEvents(
19                      BindingFlags.Instance |
20                      BindingFlags.Static |
21                      BindingFlags.Public |
22                      BindingFlags.NonPublic))
23                  {
24                      if (eventInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
25                      {
26                          yield return eventInfo;
27                      }
28                  }
29              }
30          }
31          public static IEnumerable<ConstructorInfo> GetConstructorInfosWithAttribute<AttributeType>(this Assembly assembly)
32              where AttributeType : Attribute
33          {
34              foreach (var type in assembly.GetTypes())
35              {
36                  foreach (var constructorInfo in type.GetConstructors(
37                      BindingFlags.Instance |
38                      BindingFlags.Public |
39                      BindingFlags.NonPublic))
40                  {
41                      if (constructorInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
42                      {
43                          yield return constructorInfo;
44                      }
45                  }
46              }
47          }
48          public static IEnumerable<PropertyInfo> GetPropertyInfosWithAttribute<AttributeType>(this Assembly assembly)
49              where AttributeType : Attribute
50          {
51              foreach (var type in assembly.GetTypes())
52              {
53                  foreach (var propertyInfo in type.GetProperties(
54                      BindingFlags.Instance |
55                      BindingFlags.Static |
56                      BindingFlags.Public |
57                      BindingFlags.NonPublic))
58                  {
59                      if (propertyInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
60                      {
61                          yield return propertyInfo;
62                      }
63                  }
64              }
65          }
66          public static IEnumerable<PropertyInfo> GetPropertyInfosWithAttribute<AttributeType>(this Type type)
67              where AttributeType : Attribute
68          {
69              foreach (var propertyInfo in type.GetProperties(
70                  BindingFlags.Instance |
71                  BindingFlags.Static |
72                  BindingFlags.Public |
73                  BindingFlags.NonPublic))
74              {
75                  if (propertyInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
76                  {
77                      yield return propertyInfo;
78                  }
79              }
80          }
81          public static IEnumerable<FieldInfo> GetFieldInfosWithAttribute<AttributeType>(this Assembly assembly)
82              where AttributeType : Attribute
83          {
84              foreach (var type in assembly.GetTypes())
85              {
86                  foreach (var fieldInfo in type.GetFields(
87                      BindingFlags.Instance |
88                      BindingFlags.Static |
89                      BindingFlags.Public |
90                      BindingFlags.NonPublic))
91                  {
92                      if (fieldInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
93                      {
94                          yield return fieldInfo;
95                      }
96                  }
97              }
98          }
99          public static IEnumerable<MethodInfo> GetMethodInfosWithAttribute<AttributeType>(this Assembly assembly)
100              where AttributeType : Attribute
101          {
102              foreach (var type in assembly.GetTypes())
103              {
104                  foreach (var methodInfo in type.GetMethods(
105                      BindingFlags.Instance |
106                      BindingFlags.Static |
107                      BindingFlags.Public |
108                      BindingFlags.NonPublic))
109                  {
110                      if (methodInfo.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
111                      {
112                          yield return methodInfo;
113                      }
114                  }
115              }
116          }
117          public static IEnumerable<Type> GetTypesWithAttribute<AttributeType>(this Assembly assembly)
118              where AttributeType : Attribute
119          {
120              foreach (var type in assembly.GetTypes())
121              {
122                  if (type.GetCustomAttributes(typeof(AttributeType), true).Length > 0)
123                  {
124                      yield return type;
125                  }
126              }
127          }
128          public static IEnumerable<Type> GetDerivedTypes<Base>(this Assembly assembly)
129          {
130              var @base = typeof(Base);
131              return assembly.GetTypes().Where(type =>
132                  type != @base &&
133                  @base.IsAssignableFrom(type));
134          }
135          public static string GetDirectoryPath(this Assembly assembly)
136          {
137              var codeBase = "file:&bsol;&bsol;" + assembly.Location;
138              var uri = new UriBuilder(codeBase);
139              var path = Uri.UnescapeDataString(uri.Path);
140              return Path.GetDirectoryName(path);
141          }
142          #endregion
143          #region System.Type.ConvertToCSharpSource
144          public static string ConvertToCSharpSource(this Type type, bool showGenericParameters = false)
145          {
146              var genericParameters = new Queue<Type>();
147              foreach (var x in type.GetGenericArguments())
148                  genericParameters.Enqueue(x);
149              return ConvertToCsharpSource(type);
150              string ConvertToCsharpSource(Type type)
151              {
152                  _ = type ?? throw new ArgumentNullException(nameof(type));
153                  var result = type.IsNested
154                      ? ConvertToCsharpSource(type.DeclaringType) + "."
155                      : ""; 
156                  result += Regex.Replace(type.Name, "`.*", string.Empty);
157                  if (type.IsGenericType)
158                  {
159                      result += "<";
160                      var firstIteration = true;
161                      foreach (var generic in type.GetGenericArguments())
162                      {
163                          if (genericParameters.Count <= 0)
164                          {
165                              break;
166                          }
167                          var correctGeneric = genericParameters.Dequeue();
168                          result += (firstIteration ? string.Empty : ",") +
169                                    (correctGeneric.IsGenericParameter
170                                        ? (showGenericParameters ? (firstIteration ? string.Empty : " ") + correctGeneric.Name : string.Empty)
171                                        : (firstIteration ? string.Empty : " ") + ConvertToCSharpSource(correctGeneric));
172                          firstIteration = false;
173                      }
174                      result += ">";
175                  }
176                  return result;
177              }
178          }
179          #endregion
180          #region XML Code Documentation
181          public static HashSet<Assembly> LoadedAssemblies = new();
182          public static Dictionary<string, string> LoadedXmlDocumentation = new();
183          public static void LoadXmlDocumentation(Assembly assembly)
184          {
185              string xmlFilePath;
186              if (LoadedAssemblies.Contains(assembly))
187              {
188                  return;
189              }
190              var directoryPath = assembly.GetDirectoryPath();
191              if (!string.IsNullOrEmpty(directoryPath))
192              {
193                  xmlFilePath = Path.Combine(directoryPath, assembly.GetName().Name + ".xml");
194              }
195              else
196              {
197                  xmlFilePath = assembly.GetName().Name + ".xml";
198              }
199              if (File.Exists(xmlFilePath))
200              {
201                  using var streamReader = new StreamReader(xmlFilePath);
202                  LoadXmlDocumentation(streamReader);
203              }
204              LoadedAssemblies.Add(assembly);
205          }
206          public static void LoadXmlDocumentation(string xmlDocumentation)
207          {
208              using var stringReader = new StringReader(xmlDocumentation);
209              LoadXmlDocumentation(stringReader);
210          }
211          public static void LoadXmlDocumentation(TextReader textReader)
212          {
213              using var xmlReader = XmlReader.Create(textReader);
214              while (xmlReader.Read())
215              {
216                  if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.Name == "member")
217                  {
218                      var raw_name = xmlReader["name"];
219                      LoadedXmlDocumentation[raw_name] = xmlReader.ReadInnerXml();
220                  }
221              }
222          }
223          public static void ClearXmlDocumentation()
224          {
225              LoadedAssemblies.Clear();
226              LoadedXmlDocumentation.Clear();
227          }
228          public static string GetDocumentation(this Type type)
229          {
230              LoadXmlDocumentation(type.Assembly);
231              var key = "T:" + XmlDocumentationKeyHelper(type.FullName, null);
232              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
233              return documentation;
234          }
235          public static string GetDocumentation(this MethodInfo methodInfo)
236          {
237              LoadXmlDocumentation(methodInfo.DeclaringType.Assembly);
238              var typeGenericMap = new Dictionary<string, int>();
239              var tempTypeGeneric = 0;
240              Array.ForEach(methodInfo.DeclaringType.GetGenericArguments(), x => typeGenericMap[x.Name] = tempTypeGeneric++);
241              var methodGenericMap = new Dictionary<string, int>();
242              var tempMethodGeneric = 0;
243              Array.ForEach(methodInfo.GetGenericArguments(), x => methodGenericMap.Add(x.Name, tempMethodGeneric++));
244              var parameterInfos = methodInfo.GetParameters();
245              var memberTypePrefix = "M:";
246              var declarationTypeString = GetXmlDocumentationFormattedString(methodInfo.DeclaringType, false, typeGenericMap, methodGenericMap);
247              var memberNameString = methodInfo.Name;
248              var methodGenericArgumentsString =
249                  methodGenericMap.Count > 0 ?
250                  "``" + methodGenericMap.Count :
251                  string.Empty;
252              var parametersString =
253                  parameterInfos.Length > 0 ?
254                  "(" + string.Join(",", methodInfo.GetParameters().Select(x => GetXmlDocumentationFormattedString(x.ParameterType, true, typeGenericMap, methodGenericMap))).Replace("MudBlazor.Docs.Models.T", "`0") + ")" :
255                  string.Empty;
256              var key =
257                  memberTypePrefix +
258                  declarationTypeString +
259                  "." +
260                  memberNameString +
261                  methodGenericArgumentsString +
262                  parametersString;
263              if (methodInfo.Name is "op_Implicit" or "op_Explicit")
264              {
265                  key += "~" + GetXmlDocumentationFormattedString(methodInfo.ReturnType, true, typeGenericMap, methodGenericMap);
266              }
267              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
268              return documentation;
269          }
270          public static string GetDocumentation(this ConstructorInfo constructorInfo)
271          {
272              LoadXmlDocumentation(constructorInfo.DeclaringType.Assembly);
273              var typeGenericMap = new Dictionary<string, int>();
274              var tempTypeGeneric = 0;
275              Array.ForEach(constructorInfo.DeclaringType.GetGenericArguments(), x => typeGenericMap[x.Name] = tempTypeGeneric++);
276              var methodGenericMap = new Dictionary<string, int>();
277              var parameterInfos = constructorInfo.GetParameters();
278              var memberTypePrefix = "M:";
279              var declarationTypeString = GetXmlDocumentationFormattedString(constructorInfo.DeclaringType, false, typeGenericMap, methodGenericMap);
280              var memberNameString = "#ctor";
281              var parametersString =
282                  parameterInfos.Length > 0 ?
283                  "(" + string.Join(",", constructorInfo.GetParameters().Select(x => GetXmlDocumentationFormattedString(x.ParameterType, true, typeGenericMap, methodGenericMap))) + ")" :
284                  string.Empty;
285              var key =
286                  memberTypePrefix +
287                  declarationTypeString +
288                  "." +
289                  memberNameString +
290                  parametersString;
291              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
292              return documentation;
293          }
294          public static string GetXmlDocumentationFormattedString(
295              Type type,
296              bool isMethodParameter,
297              Dictionary<string, int> typeGenericMap,
298              Dictionary<string, int> methodGenericMap)
299          {
300              if (type.IsGenericParameter)
301              {
302                  return methodGenericMap.TryGetValue(type.Name, out var methodIndex)
303                      ? "``" + methodIndex
304                      : "`" + typeGenericMap[type.Name];
305              }
306              else if (type.HasElementType)
307              {
308                  var elementTypeString = GetXmlDocumentationFormattedString(
309                      type.GetElementType(),
310                      isMethodParameter,
311                      typeGenericMap,
312                      methodGenericMap);
313                  if (type.IsPointer)
314                  {
315                      return elementTypeString + "*";
316                  }
317                  else if (type.IsArray)
318                  {
319                      var rank = type.GetArrayRank();
320                      var arrayDimensionsString = rank > 1
321                          ? "[" + string.Join(",", Enumerable.Repeat("0:", rank)) + "]"
322                          : "[]";
323                      return elementTypeString + arrayDimensionsString;
324                  }
325                  else if (type.IsByRef)
326                  {
327                      return elementTypeString + "@";
328                  }
329                  else
330                  {
331                      throw new Exception(nameof(GetXmlDocumentationFormattedString) +
332                          " encountered an unhandled element type. " +
333                          "Please submit this issue to the Towel GitHub repository. " +
334                          "https:&bsol;&bsol;github.com/ZacharyPatten/Towel/issues/new/choose");
335                  }
336              }
337              else
338              {
339                  var prefaceString = type.IsNested
340                      ? GetXmlDocumentationFormattedString(
341                          type.DeclaringType,
342                          isMethodParameter,
343                          typeGenericMap,
<span onclick='openModal()' class='match'>344                          methodGenericMap) + "."
345                      : type.Namespace + ".";
346                  string typeNameString = isMethodParameter
347                      ? typeNameString = Regex.Replace(type.Name, @"`\d+", string.Empty)
348                      : typeNameString = type.Name;
349                  var genericArgumentsString = type.IsGenericType && isMethodParameter
350                      ? "{" + string.Join(",",
351                          type.GetGenericArguments().Select(argument =>
352                              GetXmlDocumentationFormattedString(
353                                  argument,
354                                  isMethodParameter,
355                                  typeGenericMap,
356                                  methodGenericMap))
357                          ) + "}"
358                      : string.Empty;
359                  return prefaceString + typeNameString + genericArgumentsString;
360              }
361          }
362          public static string GetDocumentation(this PropertyInfo propertyInfo)
363          {
364              LoadXmlDocumentation(propertyInfo.DeclaringType.Assembly);
365              var key = "P:" + XmlDocumentationKeyHelper(propertyInfo.DeclaringType.FullName, propertyInfo.Name);
</span>366              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
367              return documentation;
368          }
369          public static string GetDocumentation(this FieldInfo fieldInfo)
370          {
371              LoadXmlDocumentation(fieldInfo.DeclaringType.Assembly);
372              var key = "F:" + XmlDocumentationKeyHelper(fieldInfo.DeclaringType.FullName, fieldInfo.Name);
373              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
374              return documentation;
375          }
376          public static string GetDocumentation(this EventInfo eventInfo)
377          {
378              LoadXmlDocumentation(eventInfo.DeclaringType.Assembly);
379              var key = "E:" + XmlDocumentationKeyHelper(eventInfo.DeclaringType.FullName, eventInfo.Name);
380              LoadedXmlDocumentation.TryGetValue(key, out var documentation);
381              return documentation;
382          }
383          public static string XmlDocumentationKeyHelper(string typeFullNameString, string memberNameString)
384          {
385              var key = Regex.Replace(typeFullNameString, @"\[.*\]", string.Empty).Replace('+', '.');
386              if (!(memberNameString is null))
387              {
388                  key += "." + memberNameString;
389              }
390              return key;
391          }
392          public static string GetDocumentation(this MemberInfo memberInfo)
393          {
394              if (memberInfo is FieldInfo fieldInfo)
395              {
396                  return fieldInfo.GetDocumentation();
397              }
398              else if (memberInfo is PropertyInfo propertyInfo)
399              {
400                  return propertyInfo.GetDocumentation();
401              }
402              else if (memberInfo is EventInfo eventInfo)
403              {
404                  return eventInfo.GetDocumentation();
405              }
406              else if (memberInfo is ConstructorInfo constructorInfo)
407              {
408                  return constructorInfo.GetDocumentation();
409              }
410              else if (memberInfo is MethodInfo methodInfo)
411              {
412                  return methodInfo.GetDocumentation();
413              }
414              else if (memberInfo is Type type) 
415              {
416                  return type.GetDocumentation();
417              }
418              else if (memberInfo.MemberType.HasFlag(MemberTypes.Custom))
419              {
420                  return null;
421              }
422              else
423              {
424                  throw new Exception(nameof(GetDocumentation) +
425                      " encountered an unhandled type [" + memberInfo.GetType().FullName + "]. " +
426                      "Please submit this issue to the Towel GitHub repository. " +
427                      "https:&bsol;&bsol;github.com/ZacharyPatten/Towel/issues/new/choose");
428              }
429          }
430          public static string GetDocumentation(this ParameterInfo parameterInfo)
431          {
432              var memberDocumentation = parameterInfo.Member.GetDocumentation();
433              if (!(memberDocumentation is null))
434              {
435                  var regexPattern =
436                      Regex.Escape(@"<param name=" + "\"" + parameterInfo.Name + "\"" + @">") +
437                      ".*?" +
438                      Regex.Escape(@"</param>");
439                  var match = Regex.Match(memberDocumentation, regexPattern);
440                  if (match.Success)
441                  {
442                      return match.Value;
443                  }
444              }
445              return null;
446          }
447          #endregion
448      }
449  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-XmlDocumentation_5.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-XmlDocumentation_5.cs</div>
                </div>
                <div class="column column_space"><pre><code>344                          methodGenericMap) + "."
345                      : type.Namespace + ".";
346                  string typeNameString = isMethodParameter
347                      ? typeNameString = Regex.Replace(type.Name, @"`\d+", string.Empty)
348                      : typeNameString = type.Name;
349                  var genericArgumentsString = type.IsGenericType && isMethodParameter
350                      ? "{" + string.Join(",",
351                          type.GetGenericArguments().Select(argument =>
352                              GetXmlDocumentationFormattedString(
353                                  argument,
354                                  isMethodParameter,
355                                  typeGenericMap,
356                                  methodGenericMap))
357                          ) + "}"
358                      : string.Empty;
359                  return prefaceString + typeNameString + genericArgumentsString;
360              }
361          }
362          public static string GetDocumentation(this PropertyInfo propertyInfo)
363          {
364              LoadXmlDocumentation(propertyInfo.DeclaringType.Assembly);
365              var key = "P:" + XmlDocumentationKeyHelper(propertyInfo.DeclaringType.FullName, propertyInfo.Name);
</pre></code></div>
                <div class="column column_space"><pre><code>344                          methodGenericMap) + "."
345                      : type.Namespace + ".";
346                  string typeNameString = isMethodParameter
347                      ? typeNameString = Regex.Replace(type.Name, @"`\d+", string.Empty)
348                      : typeNameString = type.Name;
349                  var genericArgumentsString = type.IsGenericType && isMethodParameter
350                      ? "{" + string.Join(",",
351                          type.GetGenericArguments().Select(argument =>
352                              GetXmlDocumentationFormattedString(
353                                  argument,
354                                  isMethodParameter,
355                                  typeGenericMap,
356                                  methodGenericMap))
357                          ) + "}"
358                      : string.Empty;
359                  return prefaceString + typeNameString + genericArgumentsString;
360              }
361          }
362          public static string GetDocumentation(this PropertyInfo propertyInfo)
363          {
364              LoadXmlDocumentation(propertyInfo.DeclaringType.Assembly);
365              var key = "P:" + XmlDocumentationKeyHelper(propertyInfo.DeclaringType.FullName, propertyInfo.Name);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    