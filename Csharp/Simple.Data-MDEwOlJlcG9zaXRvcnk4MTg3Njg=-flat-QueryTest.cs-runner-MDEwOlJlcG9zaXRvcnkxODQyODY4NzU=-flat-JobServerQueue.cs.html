
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-QueryTest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Linq;
5  using NUnit.Framework;
6  namespace Simple.Data.SqlTest
7  {
8      using System.Collections;
9      [TestFixture]
10      public class QueryTest
11      {
12          [TestFixtureSetUp]
13          public void Setup()
14          {
15              DatabaseHelper.Reset();
16          }
17          [Test]
18          public void CountWithNoCriteriaShouldSelectThree()
19          {
20              var db = DatabaseHelper.Open();
21              var count = db.Users.GetCount();
22              Assert.AreEqual(3, count);
23          }
24          [Test]
25          public void CountWithCriteriaShouldSelectTwo()
26          {
27              var db = DatabaseHelper.Open();
28              int count = db.Users.GetCount(db.Users.Age > 30);
29              Assert.AreEqual(2, count);
30          }
31          [Test]
32          public void CountByShouldSelectOne()
33          {
34              var db = DatabaseHelper.Open();
35              Assert.AreEqual(1, db.Users.GetCountByName("Bob"));
36          }
37         [Test]
38          public void ExistsWithNoCriteriaShouldReturnTrue()
39          {
40              var db = DatabaseHelper.Open();
41              Assert.AreEqual(true, db.Users.Exists());
42          }
43          [Test]
44          public void ExistsWithValidCriteriaShouldReturnTrue()
45          {
46              var db = DatabaseHelper.Open();
47              Assert.AreEqual(true, db.Users.Exists(db.Users.Age > 30));
48          }
49          [Test]
50          public void ExistsWithInvalidCriteriaShouldReturnFalse()
51          {
52              var db = DatabaseHelper.Open();
53              Assert.AreEqual(false, db.Users.Exists(db.Users.Age == -1));
54          }
55          [Test]
56          public void ExistsByValidValueShouldReturnTrue()
57          {
58              var db = DatabaseHelper.Open();
59              Assert.AreEqual(true, db.Users.ExistsByName("Bob"));
60          }
61          [Test]
62          public void ExistsByInvalidValueShouldReturnFalse()
63          {
64              var db = DatabaseHelper.Open();
65              Assert.AreEqual(false, db.Users.ExistsByName("Peter Kay"));
66          }
67          [Test]
68          public void ColumnAliasShouldChangeDynamicPropertyName()
69          {
70              var db = DatabaseHelper.Open();
71              var actual = db.Users.QueryById(1).Select(db.Users.Name.As("Alias")).First();
72              Assert.AreEqual("Bob", actual.Alias);
73          }
74          [Test]
75          public void MissingColumnShouldHaveColumnNotFoundMessage()
76          {
77              var db = DatabaseHelper.Open();
78              var actual = db.Users.QueryById(1).Select(db.Users.Name).First();
79              Assert.Throws<UnresolvableObjectException>(() => Console.WriteLine(actual.Bobbins), "Column not found.");
80          }
81          [Test]
82          public void ShouldSelectFromOneToTen()
83          {
84              var db = DatabaseHelper.Open();
85              var query = db.PagingTest.QueryById(1.to(100)).Take(10);
<span onclick='openModal()' class='match'>86              int index = 1;
87              foreach (var row in query)
88              {
89                  Assert.AreEqual(index, row.Id);
</span>90                  index++;
91              }
92          }
93          [Test]
94          public void ShouldSelectFromElevenToTwenty()
95          {
96              var db = DatabaseHelper.Open();
97              var query = db.PagingTest.QueryById(1.to(100)).Skip(10).Take(10);
98              int index = 11;
99              foreach (var row in query)
100              {
101                  Assert.AreEqual(index, row.Id);
102                  index++;
103              }
104          }
105          [Test]
106          public void ShouldSelectFromOneHundredToNinetyOne()
107          {
108              var db = DatabaseHelper.Open();
109              var query = db.PagingTest.QueryById(1.to(100)).OrderByDescending(db.PagingTest.Id).Skip(0).Take(10);
110              int index = 100;
111              foreach (var row in query)
112              {
113                  Assert.AreEqual(index, row.Id);
114                  index--;
115              }
116          }
117          [Test]
118          public void WithTotalCountShouldGiveCount()
119          {
120              Promise<int> count;
121              var db = DatabaseHelper.Open();
122              var list = db.PagingTest.QueryById(1.to(50))
123                  .Take(10)
124                  .WithTotalCount(out count)
125                  .ToList();
126              Assert.AreEqual(10, list.Count);
127              Assert.IsTrue(count.HasValue);
128              Assert.AreEqual(50, count);
129          }
130          [Test]
131          public void WithTotalCountWithExplicitSelectShouldGiveCount()
132          {
133              Promise<int> count;
134              var db = DatabaseHelper.Open();
135              List<dynamic> list = db.PagingTest.QueryById(1.to(50))
136                  .Select(db.PagingTest.Id)
137                  .WithTotalCount(out count)
138                  .Take(10)
139                  .ToList();
140              Assert.IsTrue(count.HasValue);
141              Assert.AreEqual(50, count);
142              Assert.AreEqual(10, list.Count);
143              foreach (var dictionary in list.Cast<IDictionary<string,object>>())
144              {
145                  Assert.AreEqual(1, dictionary.Count);
146              }
147          }
148          [Test]
149          public void WithTotalCountWithExplicitSelectAndOrderByShouldGiveCount()
150          {
151              Promise<int> count;
152              var db = DatabaseHelper.Open();
153              List<dynamic> list = db.PagingTest.QueryById(1.to(50))
154                  .Select(db.PagingTest.Id)
155                  .OrderByDescending(db.PagingTest.Id)
156                  .WithTotalCount(out count)
157                  .Take(10)
158                  .ToList();
159              Assert.IsTrue(count.HasValue);
160              Assert.AreEqual(50, count);
161              Assert.AreEqual(10, list.Count);
162              foreach (var dictionary in list.Cast<IDictionary<string, object>>())
163              {
164                  Assert.AreEqual(1, dictionary.Count);
165              }
166          }
167          [Test]
168          public void WithTotalCountShouldGiveCount_ObsoleteFutureVersion()
169          {
170              Future<int> count;
171              var db = DatabaseHelper.Open();
172              var list = db.PagingTest.QueryById(1.to(50))
173                  .WithTotalCount(out count)
174                  .Take(10)
175                  .ToList();
176              Assert.AreEqual(10, list.Count);
177              Assert.IsTrue(count.HasValue);
178              Assert.AreEqual(50, count);
179          }
180          [Test]
181          public void ShouldDirectlyQueryDetailTable()
182          {
183              var db = DatabaseHelper.Open();
184              var order = db.Customers.QueryByNameAndAddress("Test", "100 Road").Orders.FirstOrDefault();
185              Assert.IsNotNull(order);
186              Assert.AreEqual(1, order.OrderId);
187          }
188          [Test]
189          public void ShouldReturnNullWhenNoRowFound()
190          {
191              var db = DatabaseHelper.Open();
192              string name = db.Customers
193                          .Query()
194                          .Select(db.Customers.Name)
195                          .Where(db.Customers.CustomerId == 0) 
196                          .OrderByName()
197                          .Take(1) 
198                          .ToScalarOrDefault<string>();
199              Assert.IsNull(name);
200          }
201          [Test]
202          public void ToScalarListShouldReturnStringList()
203          {
204              var db = DatabaseHelper.Open();
205              List<string> name = db.Customers
206                          .Query()
207                          .Select(db.Customers.Name)
208                          .OrderByName()
209                          .ToScalarList<string>();
210              Assert.IsNotNull(name);
211              Assert.AreNotEqual(0, name.Count);
212          }
213          [Test]
214          public void ToScalarArrayShouldReturnStringArray()
215          {
216              var db = DatabaseHelper.Open();
217              string[] name = db.Customers
218                          .Query()
219                          .Select(db.Customers.Name)
220                          .OrderByName()
221                          .ToScalarArray<string>();
222              Assert.IsNotNull(name);
223              Assert.AreNotEqual(0, name.Length);
224          }
225          [Test]
226          public void HavingWithMinDateShouldReturnCorrectRow()
227          {
228              var db = DatabaseHelper.Open();
229              var row =
230                  db.GroupTestMaster.Query().Having(db.GroupTestMaster.GroupTestDetail.Date.Min() >=
231                                                    new DateTime(2000, 1, 1))
232                                                    .FirstOrDefault();
233              Assert.IsNotNull(row);
234              Assert.AreEqual("Two", row.Name);
235          }
236          [Test]
237          public void HavingWithMaxDateShouldReturnCorrectRow()
238          {
239              var db = DatabaseHelper.Open();
240              var row =
241                  db.GroupTestMaster.Query().Having(db.GroupTestMaster.GroupTestDetail.Date.Max() <
242                                                    new DateTime(2009, 1, 1))
243                                                    .FirstOrDefault();
244              Assert.IsNotNull(row);
245              Assert.AreEqual("One", row.Name);
246          }
247          [Test]
248          public void HavingWithCountShouldReturnCorrectRow()
249          {
250              var db = DatabaseHelper.Open();
251              var row = db.GroupTestMaster.Query()
252                  .Having(db.GroupTestMaster.GroupTestDetail.Id.Count() == 2)
253                  .FirstOrDefault();
254              Assert.IsNotNull(row);
255              Assert.AreEqual("Two", row.Name);
256          }
257          [Test]
258          public void HavingWithAverageShouldReturnCorrectRow()
259          {
260              var db = DatabaseHelper.Open();
261              var row = db.GroupTestMaster.Query()
262                  .Having(db.GroupTestMaster.GroupTestDetail.Number.Average() == 2)
263                  .FirstOrDefault();
264              Assert.IsNotNull(row);
265              Assert.AreEqual("One", row.Name);
266          }
267          [Test]
268          public void ToScalarOrDefault()
269          {
270              var db = DatabaseHelper.Open();
271              int max = db.Users.FindAllByName("ZXCVBNM").Select(db.Users.Age.Max()).ToScalarOrDefault<int>();
272              Assert.AreEqual(0, max);
273          }
274          [Test]
275          public void WithClauseShouldPreselectDetailTableAsCollection()
276          {
277              var db = DatabaseHelper.Open();
278              var result = db.Customers.FindAllByCustomerId(1).WithOrders().FirstOrDefault() as IDictionary<string, object>;
279              Assert.IsNotNull(result);
280              Assert.Contains("Orders", (ICollection)result.Keys);
281              var orders = result["Orders"] as IList<IDictionary<string, object>>;
282              Assert.IsNotNull(orders);
283              Assert.AreEqual(1, orders.Count);
284          }
285          [Test]
286          public void WithClauseShouldPreselectDetailTablesAsCollections()
287          {
288              var db = DatabaseHelper.Open();
289              var result = db.Customers.FindAllByCustomerId(1).WithOrders().WithNotes().FirstOrDefault() as IDictionary<string, object>;
290              Assert.IsNotNull(result);
291              Assert.Contains("Orders", (ICollection)result.Keys);
292              var orders = result["Orders"] as IList<IDictionary<string, object>>;
293              Assert.IsNotNull(orders);
294              Assert.AreEqual(1, orders.Count);
295              Assert.Contains("Notes", (ICollection)result.Keys);
296              var notes = result["Notes"] as IList<IDictionary<string, object>>;
297              Assert.IsNotNull(notes);
298              Assert.AreEqual(2, notes.Count);
299          }
300          [Test]
301          public void FindAllWithClauseWithJoinCriteriaShouldPreselectDetailTableAsCollection()
302          {
303              var db = DatabaseHelper.Open();
304              var result = db.Customers.FindAllByCustomerId(1).With(db.Customers.Orders.OrderItems).FirstOrDefault() as IDictionary<string, object>;
305              Assert.IsNotNull(result);
306              Assert.Contains("OrderItems", (ICollection)result.Keys);
307              var orderItems = result["OrderItems"] as IList<IDictionary<string, object>>;
308              Assert.IsNotNull(orderItems);
309              Assert.AreEqual(1, orderItems.Count);
310          }
311          [Test, Ignore]
312          public void FindAllWithClauseWithNestedDetailTable()
313          {
314              var db = DatabaseHelper.Open();
315              var result = db.Customers.FindAllByCustomerId(1).With(db.Customers.Orders).With(db.Customers.Orders.OrderItems).FirstOrDefault() as IDictionary<string, object>;
316              Assert.IsNotNull(result);
317              Assert.Contains("Orders", result.Keys.ToArray());
318              var orders = result["Orders"] as IList<IDictionary<string, object>>;
319              Assert.IsNotNull(orders);
320              Assert.AreEqual(1, orders.Count);
321              var order = orders[0];
322              Assert.Contains("OrderItems", order.Keys.ToArray());
323          }
324          [Test]
325          public void GetWithClauseWithJoinCriteriaShouldPreselectDetailTableAsCollection()
326          {
327              var db = DatabaseHelper.Open();
328              var result = db.Customers.With(db.Customers.Orders.OrderItems).Get(1) as IDictionary<string, object>;
329              Assert.IsNotNull(result);
330              Assert.Contains("OrderItems", (ICollection)result.Keys);
331              var orderItems = result["OrderItems"] as IList<IDictionary<string, object>>;
332              Assert.IsNotNull(orderItems);
333              Assert.AreEqual(1, orderItems.Count);
334          }
335          [Test]
336          public void WithClauseWithTwoStepShouldPreselectManyToManyTableAsCollection()
337          {
338              var db = DatabaseHelper.Open();
339              var result = db.Customers.FindAll(db.Customers.Order.OrderId == 1).WithOrders().FirstOrDefault() as IDictionary<string, object>;
340              Assert.IsNotNull(result);
341              Assert.Contains("Orders", (ICollection)result.Keys);
342              var orders = result["Orders"] as IList<IDictionary<string, object>>;
343              Assert.IsNotNull(orders);
344              Assert.AreEqual(1, orders.Count);
345          }
346          [Test]
347          public void WithClauseShouldPreselectMasterTableAsDictionary()
348          {
349              var db = DatabaseHelper.Open();
350              var result = db.Orders.FindAllByOrderId(1).WithCustomer().FirstOrDefault() as IDictionary<string,object>;
351              Assert.IsNotNull(result);
352              Assert.Contains("Customer", (ICollection)result.Keys);
353              var customer = result["Customer"] as IDictionary<string, object>;
354              Assert.IsNotNull(customer);
355          }
356          [Test]
357          public void WithClauseShouldCastToStaticTypeWithComplexProperty()
358          {
359              var db = DatabaseHelper.Open();
360              Order actual = db.Orders.FindAllByOrderId(1).WithCustomer().FirstOrDefault();
361              Assert.IsNotNull(actual);
362              Assert.IsNotNull(actual.Customer);
363              Assert.AreEqual("Test", actual.Customer.Name);
364              Assert.AreEqual("100 Road", actual.Customer.Address);
365          }
366          [Test]
367          public void WithClauseShouldCastToStaticTypeWithCollection()
368          {
369              var db = DatabaseHelper.Open();
370              Customer actual = db.Customers.FindAllByCustomerId(1).WithOrders().FirstOrDefault();
371              Assert.IsNotNull(actual);
372              Assert.AreEqual(1, actual.Orders.Single().OrderId);
373              Assert.AreEqual(new DateTime(2010,10,10), actual.Orders.Single().OrderDate);
374          }
375          [Test]
376          public void WithClauseShouldCastToStaticTypeWithEmptyCollection()
377          {
378              var db = DatabaseHelper.Open();
379              var newCustomer = db.Customers.Insert(Name: "No Orders");
380              Customer actual = db.Customers.FindAllByCustomerId(newCustomer.CustomerId).WithOrders().FirstOrDefault();
381              Assert.IsNotNull(actual);
382              Assert.IsNotNull(actual.Orders);
383              Assert.AreEqual(0, actual.Orders.Count);
384          }
385          [Test]
386          public void WithClauseContainingAliasShouldReturnResults()
387          {
388              var db = DatabaseHelper.Open();
389              var actual = db.Customers
390                             .With(db.Customers.Orders.As("Orders_1"))
391                             .With(db.Customers.Orders.As("Orders_2"))
392                             .FirstOrDefault();
393              Assert.IsNotNull(actual);
394              Assert.AreEqual(1, actual.Orders_1.Single().OrderId);
395              Assert.AreEqual(1, actual.Orders_2.Single().OrderId);
396              Assert.AreEqual(new DateTime(2010, 10, 10), actual.Orders_1.Single().OrderDate);
397              Assert.AreEqual(new DateTime(2010, 10, 10), actual.Orders_2.Single().OrderDate);
398          }
399          [Test]
400          public void SelfJoinShouldNotThrowException()
401          {
402              var db = DatabaseHelper.Open();
403              var q = db.Employees.Query().LeftJoin(db.Employees.As("Manager"), Id: db.Employees.ManagerId);
404              q = q.Select(db.Employees.Name, q.Manager.Name.As("Manager"));
405              List<dynamic> employees = q.ToList();
406              Assert.AreEqual(3, employees.Count); 
407              var kingsSubordinates = employees.Where(e => e.Manager == "Alice").ToList();
408              Assert.AreEqual(1, kingsSubordinates.Count);
409          }
410          [Test]
411          public void OrderByOnJoinedColumnShouldUseJoinedColumn()
412          {
413              SimpleDataTraceSources.TraceSource.Switch.Level = SourceLevels.All;
414              var traceListener = new TestTraceListener();
415              SimpleDataTraceSources.TraceSource.Listeners.Add(traceListener);
416              Trace.Listeners.Add(traceListener);
417              var db = DatabaseHelper.Open();
418              var q = db.Employees.Query().LeftJoin(db.Employees.As("Manager"), Id: db.Employees.ManagerId);
419              q = q.Select(db.Employees.Name, q.Manager.Name.As("Manager"));
420              List<dynamic> employees = q.OrderBy(q.Manager.Name).ToList();
421              SimpleDataTraceSources.TraceSource.Listeners.Remove(traceListener);
422              Assert.Greater(traceListener.Output.IndexOf("order by [manager].[name]", StringComparison.OrdinalIgnoreCase), 0);
423          }
424          [Test]
425          public void CanFetchMoreThanOneHundredRows()
426          {
427              var db = DatabaseHelper.Open();
428              db.Customers.Insert(Enumerable.Range(0, 200).Select(n => new Customer {Name = "Customer " + n}));
429              List<dynamic> customers = db.Customers.All().ToList();
430              Assert.GreaterOrEqual(customers.Count, 200);
431          }
432          [Test]
433          public void QueryWithForUpdateFalseShouldReturnCorrectResult()
434          {
435              var db = DatabaseHelper.Open();
436              var actual = db.Users.QueryById(1).Select(db.Users.Name).ForUpdate(false).First();
437              Assert.AreEqual("Bob", actual.Name);
438          }
439          [Test]
440          public void QueryWithForUpdateTrueShouldReturnCorrectResult()
441          {
442              var db = DatabaseHelper.Open();
443              var actual = db.Users.QueryById(1).Select(db.Users.Name).ForUpdate(true).First();
444              Assert.AreEqual("Bob", actual.Name);
445          }
446      }
447  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobServerQueue.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.IO;
5  using System.Linq;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.DistributedTask.WebApi;
9  using GitHub.Runner.Sdk;
10  using Pipelines = GitHub.DistributedTask.Pipelines;
11  namespace GitHub.Runner.Common
12  {
13      [ServiceLocator(Default = typeof(JobServerQueue))]
14      public interface IJobServerQueue : IRunnerService, IThrottlingReporter
15      {
16          TaskCompletionSource<int> JobRecordUpdated { get; }
17          event EventHandler<ThrottlingEventArgs> JobServerQueueThrottling;
18          Task ShutdownAsync();
19          void Start(Pipelines.AgentJobRequestMessage jobRequest, bool resultServiceOnly = false);
20          void QueueWebConsoleLine(Guid stepRecordId, string line, long? lineNumber = null);
21          void QueueFileUpload(Guid timelineId, Guid timelineRecordId, string type, string name, string path, bool deleteSource);
22          void QueueResultsUpload(Guid timelineRecordId, string name, string path, string type, bool deleteSource, bool finalize, bool firstBlock, long totalLines);
23          void QueueTimelineRecordUpdate(Guid timelineId, TimelineRecord timelineRecord);
24      }
25      public sealed class JobServerQueue : RunnerService, IJobServerQueue
26      {
27          private static readonly TimeSpan _aggressiveDelayForWebConsoleLineDequeue = TimeSpan.FromMilliseconds(250);
28          private static readonly TimeSpan _delayForWebConsoleLineDequeue = TimeSpan.FromMilliseconds(500);
29          private static readonly TimeSpan _delayForTimelineUpdateDequeue = TimeSpan.FromMilliseconds(500);
30          private static readonly TimeSpan _delayForFileUploadDequeue = TimeSpan.FromMilliseconds(1000);
31          private static readonly TimeSpan _delayForResultsUploadDequeue = TimeSpan.FromMilliseconds(1000);
32          private Guid _scopeIdentifier;
33          private string _hubName;
34          private Guid _planId;
35          private Guid _jobTimelineId;
36          private Guid _jobTimelineRecordId;
37          private readonly ConcurrentQueue<ConsoleLineInfo> _webConsoleLineQueue = new();
38          private readonly ConcurrentQueue<UploadFileInfo> _fileUploadQueue = new();
39          private readonly ConcurrentQueue<ResultsUploadFileInfo> _resultsFileUploadQueue = new();
40          private readonly ConcurrentDictionary<Guid, ConcurrentQueue<TimelineRecord>> _timelineUpdateQueue = new();
41          private readonly List<Guid> _allTimelines = new();
42          private readonly Dictionary<Guid, List<TimelineRecord>> _bufferedRetryRecords = new();
43          private Task _webConsoleLineDequeueTask;
44          private Task _fileUploadDequeueTask;
45          private Task _resultsUploadDequeueTask;
46          private Task _timelineUpdateDequeueTask;
47          private IJobServer _jobServer;
48          private IResultsServer _resultsServer;
49          private Task[] _allDequeueTasks;
50          private readonly TaskCompletionSource<int> _jobCompletionSource = new();
51          private readonly TaskCompletionSource<int> _jobRecordUpdated = new();
52          private bool _queueInProcess = false;
53          private bool _resultsServiceOnly = false;
54          public TaskCompletionSource<int> JobRecordUpdated => _jobRecordUpdated;
55          public event EventHandler<ThrottlingEventArgs> JobServerQueueThrottling;
56          private int _webConsoleLineAggressiveDequeueCount = 0;
57          private const int _webConsoleLineAggressiveDequeueLimit = 4 * 60;
58          private const int _webConsoleLineQueueSizeLimit = 1024;
59          private bool _webConsoleLineAggressiveDequeue = true;
60          private bool _firstConsoleOutputs = true;
61          private bool _resultsClientInitiated = false;
62          private delegate Task ResultsFileUploadHandler(ResultsUploadFileInfo file);
63          public override void Initialize(IHostContext hostContext)
64          {
65              base.Initialize(hostContext);
66              _jobServer = hostContext.GetService<IJobServer>();
67              _resultsServer = hostContext.GetService<IResultsServer>();
68          }
69          public void Start(Pipelines.AgentJobRequestMessage jobRequest, bool resultServiceOnly = false)
70          {
71              Trace.Entering();
72              _resultsServiceOnly = resultServiceOnly;
73              var serviceEndPoint = jobRequest.Resources.Endpoints.Single(x => string.Equals(x.Name, WellKnownServiceEndpointNames.SystemVssConnection, StringComparison.OrdinalIgnoreCase));
74              if (!resultServiceOnly)
75              {
76                  _jobServer.InitializeWebsocketClient(serviceEndPoint);
77              }
78              jobRequest.Variables.TryGetValue("system.github.results_endpoint", out VariableValue resultsEndpointVariable);
79              var resultsReceiverEndpoint = resultsEndpointVariable?.Value;
80              if (serviceEndPoint?.Authorization != null &&
81                  serviceEndPoint.Authorization.Parameters.TryGetValue("AccessToken", out var accessToken) &&
82                  !string.IsNullOrEmpty(accessToken) &&
83                  !string.IsNullOrEmpty(resultsReceiverEndpoint))
84              {
85                  string liveConsoleFeedUrl = null;
86                  Trace.Info("Initializing results client");
87                  if (resultServiceOnly
88                      && serviceEndPoint.Data.TryGetValue("FeedStreamUrl", out var feedStreamUrl)
89                      && !string.IsNullOrEmpty(feedStreamUrl))
90                  {
91                      liveConsoleFeedUrl = feedStreamUrl;
92                  }
93                  _resultsServer.InitializeResultsClient(new Uri(resultsReceiverEndpoint), liveConsoleFeedUrl, accessToken);
94                  _resultsClientInitiated = true;
95              }
96              if (_queueInProcess)
97              {
98                  Trace.Info("No-opt, all queue process tasks are running.");
99                  return;
100              }
101              ArgUtil.NotNull(jobRequest, nameof(jobRequest));
102              ArgUtil.NotNull(jobRequest.Plan, nameof(jobRequest.Plan));
103              ArgUtil.NotNull(jobRequest.Timeline, nameof(jobRequest.Timeline));
104              _scopeIdentifier = jobRequest.Plan.ScopeIdentifier;
105              _hubName = jobRequest.Plan.PlanType;
106              _planId = jobRequest.Plan.PlanId;
107              _jobTimelineId = jobRequest.Timeline.Id;
108              _jobTimelineRecordId = jobRequest.JobId;
109              _timelineUpdateQueue[_jobTimelineId] = new ConcurrentQueue<TimelineRecord>();
110              _allTimelines.Add(_jobTimelineId);
111              Trace.Info("Start process web console line queue.");
112              _webConsoleLineDequeueTask = ProcessWebConsoleLinesQueueAsync();
113              Trace.Info("Start process file upload queue.");
114              _fileUploadDequeueTask = ProcessFilesUploadQueueAsync();
115              Trace.Info("Start results file upload queue.");
116              _resultsUploadDequeueTask = ProcessResultsUploadQueueAsync();
117              Trace.Info("Start process timeline update queue.");
118              _timelineUpdateDequeueTask = ProcessTimelinesUpdateQueueAsync();
119              _allDequeueTasks = new Task[] { _webConsoleLineDequeueTask, _fileUploadDequeueTask, _timelineUpdateDequeueTask, _resultsUploadDequeueTask };
120              _queueInProcess = true;
121          }
122          public async Task ShutdownAsync()
123          {
124              if (!_queueInProcess)
125              {
126                  Trace.Info("No-op, all queue process tasks have been stopped.");
127              }
128              Trace.Info("Fire signal to shutdown all queues.");
129              _jobCompletionSource.TrySetResult(0);
130              await Task.WhenAll(_allDequeueTasks);
131              _queueInProcess = false;
132              Trace.Info("All queue process task stopped.");
133              Trace.Verbose("Draining web console line queue.");
134              await ProcessWebConsoleLinesQueueAsync(runOnce: true);
135              Trace.Info("Web console line queue drained.");
136              Trace.Verbose("Draining file upload queue.");
137              await ProcessFilesUploadQueueAsync(runOnce: true);
138              Trace.Info("File upload queue drained.");
139              Trace.Verbose("Draining results upload queue.");
140              await ProcessResultsUploadQueueAsync(runOnce: true);
141              Trace.Info("Results upload queue drained.");
142              Trace.Verbose("Draining timeline update queue.");
143              await ProcessTimelinesUpdateQueueAsync(runOnce: true);
144              Trace.Info("Timeline update queue drained.");
145              Trace.Info($"Disposing job server ...");
146              await _jobServer.DisposeAsync();
147              Trace.Info($"Disposing results server ...");
148              await _resultsServer.DisposeAsync();
149              Trace.Info("All queue process tasks have been stopped, and all queues are drained.");
150          }
151          public void QueueWebConsoleLine(Guid stepRecordId, string line, long? lineNumber)
152          {
153              if (!string.IsNullOrEmpty(line) && _webConsoleLineQueue.Count < _webConsoleLineQueueSizeLimit)
154              {
155                  Trace.Verbose("Enqueue web console line queue: {0}", line);
156                  if (line.Length > 1024)
157                  {
158                      Trace.Verbose("Web console line is more than 1024 chars, truncate to first 1024 chars");
159                      line = $"{line.Substring(0, 1024)}...";
160                  }
161                  _webConsoleLineQueue.Enqueue(new ConsoleLineInfo(stepRecordId, line, lineNumber));
162              }
163          }
164          public void QueueFileUpload(Guid timelineId, Guid timelineRecordId, string type, string name, string path, bool deleteSource)
165          {
166              ArgUtil.NotEmpty(timelineId, nameof(timelineId));
167              ArgUtil.NotEmpty(timelineRecordId, nameof(timelineRecordId));
168              var newFile = new UploadFileInfo()
169              {
170                  TimelineId = timelineId,
171                  TimelineRecordId = timelineRecordId,
172                  Type = type,
173                  Name = name,
174                  Path = path,
175                  DeleteSource = deleteSource
176              };
177              Trace.Verbose("Enqueue file upload queue: file '{0}' attach to record {1}", newFile.Path, timelineRecordId);
178              _fileUploadQueue.Enqueue(newFile);
179          }
180          public void QueueResultsUpload(Guid timelineRecordId, string name, string path, string type, bool deleteSource, bool finalize, bool firstBlock, long totalLines)
181          {
182              if (!_resultsClientInitiated)
183              {
184                  Trace.Verbose("Skipping results upload");
185                  try
186                  {
187                      if (deleteSource)
188                      {
189                          File.Delete(path);
190                      }
191                  }
192                  catch (Exception ex)
193                  {
194                      Trace.Info("Catch exception during delete skipped results upload file.");
195                      Trace.Error(ex);
196                  }
197                  return;
198              }
199              var newFile = new ResultsUploadFileInfo()
200              {
201                  Name = name,
202                  Path = path,
203                  Type = type,
204                  PlanId = _planId.ToString(),
205                  JobId = _jobTimelineRecordId.ToString(),
206                  RecordId = timelineRecordId,
207                  DeleteSource = deleteSource,
208                  Finalize = finalize,
209                  FirstBlock = firstBlock,
210                  TotalLines = totalLines,
211              };
212              Trace.Verbose("Enqueue results file upload queue: file '{0}' attach to job {1} step {2}", newFile.Path, _jobTimelineRecordId, timelineRecordId);
213              _resultsFileUploadQueue.Enqueue(newFile);
214          }
215          public void QueueTimelineRecordUpdate(Guid timelineId, TimelineRecord timelineRecord)
216          {
217              ArgUtil.NotEmpty(timelineId, nameof(timelineId));
218              ArgUtil.NotNull(timelineRecord, nameof(timelineRecord));
219              ArgUtil.NotEmpty(timelineRecord.Id, nameof(timelineRecord.Id));
220              _timelineUpdateQueue.TryAdd(timelineId, new ConcurrentQueue<TimelineRecord>());
221              Trace.Verbose("Enqueue timeline {0} update queue: {1}", timelineId, timelineRecord.Id);
222              _timelineUpdateQueue[timelineId].Enqueue(timelineRecord.Clone());
223          }
224          public void ReportThrottling(TimeSpan delay, DateTime expiration)
225          {
226              Trace.Info($"Receive server throttling report, expect delay {delay} milliseconds till {expiration}");
227              var throttlingEvent = JobServerQueueThrottling;
228              if (throttlingEvent != null)
229              {
230                  throttlingEvent(this, new ThrottlingEventArgs(delay, expiration));
231              }
232          }
233          private async Task ProcessWebConsoleLinesQueueAsync(bool runOnce = false)
234          {
235              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
236              {
237                  if (_webConsoleLineAggressiveDequeue && ++_webConsoleLineAggressiveDequeueCount > _webConsoleLineAggressiveDequeueLimit)
238                  {
239                      Trace.Info("Stop aggressive process web console line queue.");
240                      _webConsoleLineAggressiveDequeue = false;
241                  }
242                  Dictionary<Guid, List<TimelineRecordLogLine>> stepsConsoleLines = new();
243                  List<Guid> stepRecordIds = new(); 
244                  int linesCounter = 0;
245                  ConsoleLineInfo lineInfo;
246                  while (_webConsoleLineQueue.TryDequeue(out lineInfo))
247                  {
248                      if (!stepsConsoleLines.ContainsKey(lineInfo.StepRecordId))
249                      {
250                          stepsConsoleLines[lineInfo.StepRecordId] = new List<TimelineRecordLogLine>();
251                          stepRecordIds.Add(lineInfo.StepRecordId);
252                      }
253                      stepsConsoleLines[lineInfo.StepRecordId].Add(new TimelineRecordLogLine(lineInfo.Line, lineInfo.LineNumber));
254                      linesCounter++;
255                      if (!runOnce && linesCounter > 500)
256                      {
257                          break;
258                      }
259                  }
260                  foreach (var stepRecordId in stepRecordIds)
261                  {
262                      int batchCounter = 0;
263                      List<List<TimelineRecordLogLine>> batchedLines = new();
264                      foreach (var line in stepsConsoleLines[stepRecordId])
265                      {
266                          var currentBatch = batchedLines.ElementAtOrDefault(batchCounter);
267                          if (currentBatch == null)
268                          {
269                              batchedLines.Add(new List<TimelineRecordLogLine>());
270                              currentBatch = batchedLines.ElementAt(batchCounter);
271                          }
272                          currentBatch.Add(line);
273                          if (currentBatch.Count >= 100)
274                          {
275                              batchCounter++;
276                          }
277                      }
278                      if (batchedLines.Count > 0)
279                      {
280                          if (runOnce && batchedLines.Count > 2)
281                          {
282                              Trace.Info($"Skip {batchedLines.Count - 2} batches web console lines for last run");
283                              batchedLines = batchedLines.TakeLast(2).ToList();
284                          }
<span onclick='openModal()' class='match'>285                          int errorCount = 0;
286                          foreach (var batch in batchedLines)
287                          {
288                              try
</span>289                              {
290                                  using (var timeoutTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(60)))
291                                  {
292                                      if (_resultsServiceOnly)
293                                      {
294                                          await _resultsServer.AppendLiveConsoleFeedAsync(_scopeIdentifier, _hubName, _planId, _jobTimelineId, _jobTimelineRecordId, stepRecordId, batch.Select(logLine => logLine.Line).ToList(), batch[0].LineNumber, timeoutTokenSource.Token);
295                                      }
296                                      else
297                                      {
298                                          await _jobServer.AppendTimelineRecordFeedAsync(_scopeIdentifier, _hubName, _planId, _jobTimelineId, _jobTimelineRecordId, stepRecordId, batch.Select(logLine => logLine.Line).ToList(), batch[0].LineNumber, timeoutTokenSource.Token);
299                                      }
300                                  }
301                                  if (_firstConsoleOutputs)
302                                  {
303                                      HostContext.WritePerfCounter($"WorkerJobServerQueueAppendFirstConsoleOutput_{_planId.ToString()}");
304                                      _firstConsoleOutputs = false;
305                                  }
306                              }
307                              catch (Exception ex)
308                              {
309                                  Trace.Info("Catch exception during append web console line, keep going since the process is best effort.");
310                                  Trace.Error(ex);
311                                  errorCount++;
312                              }
313                          }
314                          Trace.Info("Try to append {0} batches web console lines for record '{2}', success rate: {1}/{0}.", batchedLines.Count, batchedLines.Count - errorCount, stepRecordId);
315                      }
316                  }
317                  if (runOnce)
318                  {
319                      break;
320                  }
321                  else
322                  {
323                      await Task.Delay(_webConsoleLineAggressiveDequeue ? _aggressiveDelayForWebConsoleLineDequeue : _delayForWebConsoleLineDequeue);
324                  }
325              }
326          }
327          private async Task ProcessFilesUploadQueueAsync(bool runOnce = false)
328          {
329              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
330              {
331                  List<UploadFileInfo> filesToUpload = new();
332                  UploadFileInfo dequeueFile;
333                  while (_fileUploadQueue.TryDequeue(out dequeueFile))
334                  {
335                      filesToUpload.Add(dequeueFile);
336                      if (!runOnce && filesToUpload.Count > 10)
337                      {
338                          break;
339                      }
340                  }
341                  if (filesToUpload.Count > 0)
342                  {
343                      if (runOnce)
344                      {
345                          Trace.Info($"Uploading {filesToUpload.Count} files in one shot.");
346                      }
347                      int errorCount = 0;
348                      foreach (var file in filesToUpload)
349                      {
350                          try
351                          {
352                              await UploadFile(file);
353                          }
354                          catch (Exception ex)
355                          {
356                              Trace.Info("Catch exception during log or attachment file upload, keep going since the process is best effort.");
357                              Trace.Error(ex);
358                              errorCount++;
359                          }
360                      }
361                      Trace.Info("Try to upload {0} log files or attachments, success rate: {1}/{0}.", filesToUpload.Count, filesToUpload.Count - errorCount);
362                  }
363                  if (runOnce)
364                  {
365                      break;
366                  }
367                  else
368                  {
369                      await Task.Delay(_delayForFileUploadDequeue);
370                  }
371              }
372          }
373          private async Task ProcessResultsUploadQueueAsync(bool runOnce = false)
374          {
375              Trace.Info("Starting results-based upload queue...");
376              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
377              {
378                  List<ResultsUploadFileInfo> filesToUpload = new();
379                  ResultsUploadFileInfo dequeueFile;
380                  while (_resultsFileUploadQueue.TryDequeue(out dequeueFile))
381                  {
382                      filesToUpload.Add(dequeueFile);
383                      if (!runOnce && filesToUpload.Count > 10)
384                      {
385                          break;
386                      }
387                  }
388                  if (filesToUpload.Count > 0)
389                  {
390                      if (runOnce)
391                      {
392                          Trace.Info($"Uploading {filesToUpload.Count} file(s) in one shot through results service.");
393                      }
394                      int errorCount = 0;
395                      foreach (var file in filesToUpload)
396                      {
397                          try
398                          {
399                              if (String.Equals(file.Type, ChecksAttachmentType.StepSummary, StringComparison.OrdinalIgnoreCase))
400                              {
401                                  await UploadSummaryFile(file);
402                              }
403                              else if (String.Equals(file.Type, CoreAttachmentType.ResultsLog, StringComparison.OrdinalIgnoreCase))
404                              {
405                                  if (file.RecordId != _jobTimelineRecordId)
406                                  {
407                                      Trace.Info($"Got a step log file to send to results service.");
408                                      await UploadResultsStepLogFile(file);
409                                  }
410                                  else if (file.RecordId == _jobTimelineRecordId)
411                                  {
412                                      Trace.Info($"Got a job log file to send to results service.");
413                                      await UploadResultsJobLogFile(file);
414                                  }
415                              }
416                          }
417                          catch (Exception ex)
418                          {
419                              Trace.Info("Catch exception during file upload to results, keep going since the process is best effort.");
420                              Trace.Error(ex);
421                              errorCount++;
422                              _resultsClientInitiated = false;
423                              SendResultsTelemetry(ex);
424                          }
425                      }
426                      Trace.Info("Tried to upload {0} file(s) to results, success rate: {1}/{0}.", filesToUpload.Count, filesToUpload.Count - errorCount);
427                  }
428                  if (runOnce)
429                  {
430                      break;
431                  }
432                  else
433                  {
434                      await Task.Delay(_delayForResultsUploadDequeue);
435                  }
436              }
437          }
438          private void SendResultsTelemetry(Exception ex)
439          {
440              var issue = new Issue() { Type = IssueType.Warning, Message = $"Caught exception with results. {ex.Message}" };
441              issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = Constants.Runner.ResultsUploadFailure;
442              var telemetryRecord = new TimelineRecord()
443              {
444                  Id = Constants.Runner.TelemetryRecordId,
445              };
446              telemetryRecord.Issues.Add(issue);
447              QueueTimelineRecordUpdate(_jobTimelineId, telemetryRecord);
448          }
449          private async Task ProcessTimelinesUpdateQueueAsync(bool runOnce = false)
450          {
451              while (!_jobCompletionSource.Task.IsCompleted || runOnce)
452              {
453                  List<PendingTimelineRecord> pendingUpdates = new();
454                  foreach (var timeline in _allTimelines)
455                  {
456                      ConcurrentQueue<TimelineRecord> recordQueue;
457                      if (_timelineUpdateQueue.TryGetValue(timeline, out recordQueue))
458                      {
459                          List<TimelineRecord> records = new();
460                          TimelineRecord record;
461                          while (recordQueue.TryDequeue(out record))
462                          {
463                              records.Add(record);
464                              if (!runOnce && records.Count > 25)
465                              {
466                                  break;
467                              }
468                          }
469                          if (records.Count > 0)
470                          {
471                              pendingUpdates.Add(new PendingTimelineRecord() { TimelineId = timeline, PendingRecords = records.ToList() });
472                          }
473                      }
474                  }
475                  bool pendingSubtimelineUpdate = false;
476                  List<Exception> mainTimelineRecordsUpdateErrors = new();
477                  if (pendingUpdates.Count > 0)
478                  {
479                      foreach (var update in pendingUpdates)
480                      {
481                          List<TimelineRecord> bufferedRecords;
482                          if (_bufferedRetryRecords.TryGetValue(update.TimelineId, out bufferedRecords))
483                          {
484                              update.PendingRecords.InsertRange(0, bufferedRecords);
485                          }
486                          update.PendingRecords = MergeTimelineRecords(update.PendingRecords);
487                          foreach (var detailTimeline in update.PendingRecords.Where(r => r.Details != null))
488                          {
489                              if (!_resultsServiceOnly && !_allTimelines.Contains(detailTimeline.Details.Id))
490                              {
491                                  try
492                                  {
493                                      Timeline newTimeline = await _jobServer.CreateTimelineAsync(_scopeIdentifier, _hubName, _planId, detailTimeline.Details.Id, default(CancellationToken));
494                                      _allTimelines.Add(newTimeline.Id);
495                                      pendingSubtimelineUpdate = true;
496                                  }
497                                  catch (TimelineExistsException)
498                                  {
499                                      Trace.Info("Catch TimelineExistsException during timeline creation. Ignore the error since server already had this timeline.");
500                                      _allTimelines.Add(detailTimeline.Details.Id);
501                                  }
502                                  catch (Exception ex)
503                                  {
504                                      Trace.Error(ex);
505                                  }
506                              }
507                          }
508                          try
509                          {
510                              if (!_resultsServiceOnly)
511                              {
512                                  await _jobServer.UpdateTimelineRecordsAsync(_scopeIdentifier, _hubName, _planId, update.TimelineId, update.PendingRecords, default(CancellationToken));
513                              }
514                              try
515                              {
516                                  if (_resultsClientInitiated)
517                                  {
518                                      await _resultsServer.UpdateResultsWorkflowStepsAsync(_scopeIdentifier, _hubName, _planId, update.TimelineId, update.PendingRecords, default(CancellationToken));
519                                  }
520                              }
521                              catch (Exception e)
522                              {
523                                  Trace.Info("Catch exception during update steps, skip update Results.");
524                                  Trace.Error(e);
525                                  _resultsClientInitiated = false;
526                                  SendResultsTelemetry(e);
527                              }
528                              if (_bufferedRetryRecords.Remove(update.TimelineId))
529                              {
530                                  Trace.Verbose("Cleanup buffered timeline record for timeline: {0}.", update.TimelineId);
531                              }
532                              if (!_jobRecordUpdated.Task.IsCompleted &&
533                                  update.PendingRecords.Any(x => x.Id == _jobTimelineRecordId && x.State != null))
534                              {
535                                  Trace.Info("Job timeline record has been updated for the first time.");
536                                  _jobRecordUpdated.TrySetResult(0);
537                              }
538                          }
539                          catch (Exception ex)
540                          {
541                              Trace.Info("Catch exception during update timeline records, try to update these timeline records next time.");
542                              Trace.Error(ex);
543                              _bufferedRetryRecords[update.TimelineId] = update.PendingRecords.ToList();
544                              if (update.TimelineId == _jobTimelineId)
545                              {
546                                  mainTimelineRecordsUpdateErrors.Add(ex);
547                              }
548                          }
549                      }
550                  }
551                  if (runOnce)
552                  {
553                      if (pendingSubtimelineUpdate)
554                      {
555                          continue;
556                      }
557                      else
558                      {
559                          if (mainTimelineRecordsUpdateErrors.Count > 0 &&
560                              _bufferedRetryRecords.ContainsKey(_jobTimelineId) &&
561                              _bufferedRetryRecords[_jobTimelineId] != null &&
562                              _bufferedRetryRecords[_jobTimelineId].Any(r => r.Variables.Count > 0))
563                          {
564                              Trace.Info("Fail to update timeline records with output variables. Throw exception to fail the job since output variables are critical to downstream jobs.");
565                              throw new AggregateException("Failed to publish output variables.", mainTimelineRecordsUpdateErrors);
566                          }
567                          else
568                          {
569                              break;
570                          }
571                      }
572                  }
573                  else
574                  {
575                      await Task.Delay(_delayForTimelineUpdateDequeue);
576                  }
577              }
578          }
579          private List<TimelineRecord> MergeTimelineRecords(List<TimelineRecord> timelineRecords)
580          {
581              if (timelineRecords == null || timelineRecords.Count <= 1)
582              {
583                  return timelineRecords;
584              }
585              Dictionary<Guid, TimelineRecord> dict = new();
586              foreach (TimelineRecord rec in timelineRecords)
587              {
588                  if (rec == null)
589                  {
590                      continue;
591                  }
592                  TimelineRecord timelineRecord;
593                  if (dict.TryGetValue(rec.Id, out timelineRecord))
594                  {
595                      timelineRecord.CurrentOperation = rec.CurrentOperation ?? timelineRecord.CurrentOperation;
596                      timelineRecord.Details = rec.Details ?? timelineRecord.Details;
597                      timelineRecord.FinishTime = rec.FinishTime ?? timelineRecord.FinishTime;
598                      timelineRecord.Log = rec.Log ?? timelineRecord.Log;
599                      timelineRecord.Name = rec.Name ?? timelineRecord.Name;
600                      timelineRecord.RefName = rec.RefName ?? timelineRecord.RefName;
601                      timelineRecord.PercentComplete = rec.PercentComplete ?? timelineRecord.PercentComplete;
602                      timelineRecord.RecordType = rec.RecordType ?? timelineRecord.RecordType;
603                      timelineRecord.Result = rec.Result ?? timelineRecord.Result;
604                      timelineRecord.ResultCode = rec.ResultCode ?? timelineRecord.ResultCode;
605                      timelineRecord.StartTime = rec.StartTime ?? timelineRecord.StartTime;
606                      timelineRecord.State = rec.State ?? timelineRecord.State;
607                      timelineRecord.WorkerName = rec.WorkerName ?? timelineRecord.WorkerName;
608                      if (rec.ErrorCount > 0)
609                      {
610                          timelineRecord.ErrorCount = rec.ErrorCount;
611                      }
612                      if (rec.WarningCount > 0)
613                      {
614                          timelineRecord.WarningCount = rec.WarningCount;
615                      }
616                      if (rec.NoticeCount > 0)
617                      {
618                          timelineRecord.NoticeCount = rec.NoticeCount;
619                      }
620                      if (rec.Issues.Count > 0)
621                      {
622                          timelineRecord.Issues.Clear();
623                          timelineRecord.Issues.AddRange(rec.Issues.Select(i => i.Clone()));
624                      }
625                      if (rec.Variables.Count > 0)
626                      {
627                          foreach (var variable in rec.Variables)
628                          {
629                              timelineRecord.Variables[variable.Key] = variable.Value.Clone();
630                          }
631                      }
632                  }
633                  else
634                  {
635                      dict.Add(rec.Id, rec);
636                  }
637              }
638              var mergedRecords = dict.Values.ToList();
639              Trace.Verbose("Merged Timeline records");
640              foreach (var record in mergedRecords)
641              {
642                  Trace.Verbose($"    Record: t={record.RecordType}, n={record.Name}, s={record.State}, st={record.StartTime}, {record.PercentComplete}%, ft={record.FinishTime}, r={record.Result}: {record.CurrentOperation}");
643                  if (record.Issues != null)
644                  {
645                      foreach (var issue in record.Issues)
646                      {
647                          String source;
648                          issue.Data.TryGetValue("sourcepath", out source);
649                          Trace.Verbose($"        Issue: c={issue.Category}, t={issue.Type}, s={source ?? string.Empty}, m={issue.Message}");
650                      }
651                  }
652                  if (record.Variables != null)
653                  {
654                      foreach (var variable in record.Variables)
655                      {
656                          Trace.Verbose($"        Variable: n={variable.Key}, secret={variable.Value.IsSecret}");
657                      }
658                  }
659              }
660              return mergedRecords;
661          }
662          private async Task UploadFile(UploadFileInfo file)
663          {
664              bool uploadSucceed = false;
665              try
666              {
667                  if (!_resultsServiceOnly)
668                  {
669                      if (String.Equals(file.Type, CoreAttachmentType.Log, StringComparison.OrdinalIgnoreCase))
670                      {
671                          var taskLog = await _jobServer.CreateLogAsync(_scopeIdentifier, _hubName, _planId, new TaskLog(String.Format(@"logs\{0:D}", file.TimelineRecordId)), default(CancellationToken));
672                          using (FileStream fs = File.Open(file.Path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
673                          {
674                              var logUploaded = await _jobServer.AppendLogContentAsync(_scopeIdentifier, _hubName, _planId, taskLog.Id, fs, default(CancellationToken));
675                          }
676                          var attachmentUpdataRecord = new TimelineRecord() { Id = file.TimelineRecordId, Log = taskLog };
677                          QueueTimelineRecordUpdate(file.TimelineId, attachmentUpdataRecord);
678                      }
679                      else
680                      {
681                          using (FileStream fs = File.Open(file.Path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
682                          {
683                              var result = await _jobServer.CreateAttachmentAsync(_scopeIdentifier, _hubName, _planId, file.TimelineId, file.TimelineRecordId, file.Type, file.Name, fs, default(CancellationToken));
684                          }
685                      }
686                  }
687                  uploadSucceed = true;
688              }
689              finally
690              {
691                  if (uploadSucceed && file.DeleteSource)
692                  {
693                      try
694                      {
695                          File.Delete(file.Path);
696                      }
697                      catch (Exception ex)
698                      {
699                          Trace.Info("Catch exception during delete success uploaded file.");
700                          Trace.Error(ex);
701                      }
702                  }
703              }
704          }
705          private async Task UploadSummaryFile(ResultsUploadFileInfo file)
706          {
707              Trace.Info($"Starting to upload summary file to results service {file.Name}, {file.Path}");
708              ResultsFileUploadHandler summaryHandler = async (file) =>
709              {
710                  await _resultsServer.CreateResultsStepSummaryAsync(file.PlanId, file.JobId, file.RecordId, file.Path, CancellationToken.None);
711              };
712              await UploadResultsFile(file, summaryHandler);
713          }
714          private async Task UploadResultsStepLogFile(ResultsUploadFileInfo file)
715          {
716              Trace.Info($"Starting upload of step log file to results service {file.Name}, {file.Path}");
717              ResultsFileUploadHandler stepLogHandler = async (file) =>
718              {
719                  await _resultsServer.CreateResultsStepLogAsync(file.PlanId, file.JobId, file.RecordId, file.Path, file.Finalize, file.FirstBlock, file.TotalLines, CancellationToken.None);
720              };
721              await UploadResultsFile(file, stepLogHandler);
722          }
723          private async Task UploadResultsJobLogFile(ResultsUploadFileInfo file)
724          {
725              Trace.Info($"Starting upload of job log file to results service {file.Name}, {file.Path}");
726              ResultsFileUploadHandler jobLogHandler = async (file) =>
727              {
728                  await _resultsServer.CreateResultsJobLogAsync(file.PlanId, file.JobId, file.Path, file.Finalize, file.FirstBlock, file.TotalLines, CancellationToken.None);
729              };
730              await UploadResultsFile(file, jobLogHandler);
731          }
732          private async Task UploadResultsFile(ResultsUploadFileInfo file, ResultsFileUploadHandler uploadHandler)
733          {
734              if (!_resultsClientInitiated)
735              {
736                  return;
737              }
738              bool uploadSucceed = false;
739              try
740              {
741                  await uploadHandler(file);
742                  uploadSucceed = true;
743              }
744              finally
745              {
746                  if (uploadSucceed && file.DeleteSource)
747                  {
748                      try
749                      {
750                          File.Delete(file.Path);
751                      }
752                      catch (Exception ex)
753                      {
754                          Trace.Info("Exception encountered during deletion of a temporary file that was already successfully uploaded to results.");
755                          Trace.Error(ex);
756                      }
757                  }
758              }
759          }
760      }
761      internal class PendingTimelineRecord
762      {
763          public Guid TimelineId { get; set; }
764          public List<TimelineRecord> PendingRecords { get; set; }
765      }
766      internal class UploadFileInfo
767      {
768          public Guid TimelineId { get; set; }
769          public Guid TimelineRecordId { get; set; }
770          public string Type { get; set; }
771          public string Name { get; set; }
772          public string Path { get; set; }
773          public bool DeleteSource { get; set; }
774      }
775      internal class ResultsUploadFileInfo
776      {
777          public string Name { get; set; }
778          public string Type { get; set; }
779          public string Path { get; set; }
780          public string PlanId { get; set; }
781          public string JobId { get; set; }
782          public Guid RecordId { get; set; }
783          public bool DeleteSource { get; set; }
784          public bool Finalize { get; set; }
785          public bool FirstBlock { get; set; }
786          public long TotalLines { get; set; }
787      }
788      internal class ConsoleLineInfo
789      {
790          public ConsoleLineInfo(Guid recordId, string line, long? lineNumber)
791          {
792              this.StepRecordId = recordId;
793              this.Line = line;
794              this.LineNumber = lineNumber;
795          }
796          public Guid StepRecordId { get; set; }
797          public string Line { get; set; }
798          public long? LineNumber { get; set; }
799      }
800  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-QueryTest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobServerQueue.cs</div>
                </div>
                <div class="column column_space"><pre><code>86              int index = 1;
87              foreach (var row in query)
88              {
89                  Assert.AreEqual(index, row.Id);
</pre></code></div>
                <div class="column column_space"><pre><code>285                          int errorCount = 0;
286                          foreach (var batch in batchedLines)
287                          {
288                              try
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    