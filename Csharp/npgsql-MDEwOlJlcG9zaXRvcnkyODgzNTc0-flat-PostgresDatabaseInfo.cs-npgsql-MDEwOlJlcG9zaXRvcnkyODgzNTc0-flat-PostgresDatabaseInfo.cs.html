
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PostgresDatabaseInfo.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.Linq;
6  using System.Runtime.CompilerServices;
7  using System.Text;
8  using System.Threading.Tasks;
9  using Microsoft.Extensions.Logging;
10  using Npgsql.BackendMessages;
11  using Npgsql.Internal;
12  using Npgsql.PostgresTypes;
13  using Npgsql.TypeMapping;
14  using Npgsql.Util;
15  using static Npgsql.Util.Statics;
16  namespace Npgsql;
17  sealed class PostgresDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
18  {
19      public async Task<NpgsqlDatabaseInfo?> Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
20      {
21          var db = new PostgresDatabaseInfo(conn);
22          await db.LoadPostgresInfo(conn, timeout, async);
23          Debug.Assert(db.LongVersion != null);
24          return db;
25      }
26  }
27  class PostgresDatabaseInfo : NpgsqlDatabaseInfo
28  {
29      readonly ILogger _connectionLogger;
30      List<PostgresType>? _types;
31      protected override IEnumerable<PostgresType> GetTypes() => _types ?? Enumerable.Empty<PostgresType>();
32      public string LongVersion { get; set; } = default!;
33      public bool IsRedshift { get; private set; }
34      public override bool SupportsUnlisten => Version.IsGreaterOrEqual(6, 4) && !IsRedshift;
35      public virtual bool HasEnumSortOrder => Version.IsGreaterOrEqual(9, 1);
36      public virtual bool HasTypeCategory => Version.IsGreaterOrEqual(8, 4);
37      internal PostgresDatabaseInfo(NpgsqlConnector conn)
38          : base(conn.Host!, conn.Port, conn.Database!, conn.PostgresParameters["server_version"])
39          => _connectionLogger = conn.LoggingConfiguration.ConnectionLogger;
40      internal async Task LoadPostgresInfo(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
41      {
42          HasIntegerDateTimes =
43              conn.PostgresParameters.TryGetValue("integer_datetimes", out var intDateTimes) &&
44              intDateTimes == "on";
45          IsRedshift = conn.Settings.ServerCompatibilityMode == ServerCompatibilityMode.Redshift;
46          _types = await LoadBackendTypes(conn, timeout, async);
47      }
48      static string GenerateLoadTypesQuery(bool withRange, bool withMultirange, bool loadTableComposites)
49          => $@"
50  SELECT ns.nspname, t.oid, t.typname, t.typtype, t.typnotnull, t.elemtypoid
51  FROM (
52      -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a
53      -- We first do this for the type (innerest-most subquery), and then for its element type
54      -- This also returns the array element, range subtype and domain base type as elemtypoid
55      SELECT
56          typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,
57          elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,
58          CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype
59      FROM (
60          SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,
61              CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,
62              CASE
63                  WHEN proc.proname='array_recv' THEN typ.typelem
64                  {(withRange ? "WHEN typ.typtype='r' THEN rngsubtype" : "")}
65                  {(withMultirange ? "WHEN typ.typtype='m' THEN (SELECT rngtypid FROM pg_range WHERE rngmultitypid = typ.oid)" : "")}
66                  WHEN typ.typtype='d' THEN typ.typbasetype
67              END AS elemtypoid
68          FROM pg_type AS typ
69          LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)
70          LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive
71          {(withRange ? "LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)" : "")}
72      ) AS typ
73      LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid
74      LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)
75      LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive
76  ) AS t
77  JOIN pg_namespace AS ns ON (ns.oid = typnamespace)
78  WHERE
79      typtype IN ('b', 'r', 'm', 'e', 'd') OR -- Base, range, multirange, enum, domain
<span onclick='openModal()' class='match'>80      (typtype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "relkind='c'")}) OR -- User-defined free-standing composites (not table composites) by default
81      (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types
82      (typtype = 'a' AND (  -- Array of...
83          elemtyptype IN ('b', 'r', 'm', 'e', 'd') OR -- Array of base, range, multirange, enum, domain
84          (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types
85          (elemtyptype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "elemrelkind='c'")}) -- Array of user-defined free-standing composites (not table composites) by default
</span>86      ))
87  ORDER BY CASE
88         WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types
89         WHEN typtype = 'r' THEN 1                        -- Ranges after
90         WHEN typtype = 'm' THEN 2                        -- Multiranges after
91         WHEN typtype = 'c' THEN 3                        -- Composites after
92         WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 4 -- Domains over non-arrays after
93         WHEN typtype = 'a' THEN 5                        -- Arrays after
94         WHEN typtype = 'd' AND elemtyptype = 'a' THEN 6  -- Domains over arrays last
95  END;";
96      static string GenerateLoadCompositeTypesQuery(bool loadTableComposites)
97          => $@"
98  -- Load field definitions for (free-standing) composite types
99  SELECT typ.oid, att.attname, att.atttypid
100  FROM pg_type AS typ
101  JOIN pg_namespace AS ns ON (ns.oid = typ.typnamespace)
102  JOIN pg_class AS cls ON (cls.oid = typ.typrelid)
103  JOIN pg_attribute AS att ON (att.attrelid = typ.typrelid)
104  WHERE
105    (typ.typtype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "cls.relkind='c'")}) AND
106    attnum > 0 AND     -- Don't load system attributes
107    NOT attisdropped
108  ORDER BY typ.oid, att.attnum;";
109      static string GenerateLoadEnumFieldsQuery(bool withEnumSortOrder)
110          => $@"
111  -- Load enum fields
112  SELECT pg_type.oid, enumlabel
113  FROM pg_enum
114  JOIN pg_type ON pg_type.oid=enumtypid
115  ORDER BY oid{(withEnumSortOrder ? ", enumsortorder" : "")};";
116      internal async Task<List<PostgresType>> LoadBackendTypes(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
117      {
118          var versionQuery = "SELECT version();";
119          var loadTypesQuery = GenerateLoadTypesQuery(SupportsRangeTypes, SupportsMultirangeTypes, conn.Settings.LoadTableComposites);
120          var loadCompositeTypesQuery = GenerateLoadCompositeTypesQuery(conn.Settings.LoadTableComposites);
121          var loadEnumFieldsQuery = SupportsEnumTypes
122              ? GenerateLoadEnumFieldsQuery(HasEnumSortOrder)
123              : string.Empty;
124          timeout.CheckAndApply(conn);
125          var isReplicationConnection = conn.Settings.ReplicationMode != ReplicationMode.Off;
126          if (isReplicationConnection)
127          {
128              await conn.WriteQuery(versionQuery, async);
129              await conn.WriteQuery(SanitizeForReplicationConnection(loadTypesQuery), async);
130              await conn.WriteQuery(SanitizeForReplicationConnection(loadCompositeTypesQuery), async);
131              if (SupportsEnumTypes)
132                  await conn.WriteQuery(SanitizeForReplicationConnection(loadEnumFieldsQuery), async);
133              static string SanitizeForReplicationConnection(string str)
134              {
135                  var sb = new StringBuilder(str.Length);
136                  using var c = str.GetEnumerator();
137                  while (c.MoveNext())
138                  {
139                      switch (c.Current)
140                      {
141                      case '\r':
142                          sb.Append('\n');
143                          if (c.MoveNext())
144                          {
145                              if (c.Current == '-')
146                                  goto case '-';
147                              if (c.Current != '\n')
148                                  sb.Append(c.Current);
149                          }
150                          break;
151                      case '-':
152                          if (c.MoveNext())
153                          {
154                              if (c.Current == '\r')
155                              {
156                                  sb.Append('-');
157                                  goto case '\r';
158                              }
159                              if (c.Current != '-')
160                              {
161                                  sb.Append('-');
162                                  sb.Append(c.Current);
163                                  break;
164                              }
165                              while (c.MoveNext())
166                              {
167                                  if (c.Current == '\r')
168                                      goto case '\r';
169                                  if (c.Current == '\n')
170                                  {
171                                      sb.Append('\n');
172                                      break;
173                                  }
174                              }
175                          }
176                          break;
177                      default:
178                          sb.Append(c.Current);
179                          break;
180                      }
181                  }
182                  return sb.ToString();
183              }
184          }
185          else
186          {
187              var batchQuery = new StringBuilder(
188                      versionQuery.Length +
189                      loadTypesQuery.Length +
190                      loadCompositeTypesQuery.Length +
191                      (SupportsEnumTypes
192                          ? loadEnumFieldsQuery.Length
193                          : 0))
194                  .AppendLine(versionQuery)
195                  .AppendLine(loadTypesQuery)
196                  .AppendLine(loadCompositeTypesQuery);
197              if (SupportsEnumTypes)
198                  batchQuery.AppendLine(loadEnumFieldsQuery);
199              await conn.WriteQuery(batchQuery.ToString(), async);
200          }
201          await conn.Flush(async);
202          var byOID = new Dictionary<uint, PostgresType>();
203          Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
204          Expect<DataRowMessage>(await conn.ReadMessage(async), conn);
205          conn.ReadBuffer.Skip(2); 
206          LongVersion = ReadNonNullableString(conn.ReadBuffer);
207          Expect<CommandCompleteMessage>(await conn.ReadMessage(async), conn);
208          if (isReplicationConnection)
209              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
210          Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
211          IBackendMessage msg;
212          while (true)
213          {
214              msg = await conn.ReadMessage(async);
215              if (msg is not DataRowMessage)
216                  break;
217              conn.ReadBuffer.Skip(2); 
218              var nspname = ReadNonNullableString(conn.ReadBuffer);
219              var oid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
220              Debug.Assert(oid != 0);
221              var typname = ReadNonNullableString(conn.ReadBuffer);
222              var typtype = ReadNonNullableString(conn.ReadBuffer)[0];
223              var typnotnull = ReadNonNullableString(conn.ReadBuffer)[0] == 't';
224              var len = conn.ReadBuffer.ReadInt32();
225              var elemtypoid = len == -1 ? 0 : uint.Parse(conn.ReadBuffer.ReadString(len), NumberFormatInfo.InvariantInfo);
226              switch (typtype)
227              {
228              case 'b': 
229                  var baseType = new PostgresBaseType(nspname, typname, oid);
230                  byOID[baseType.OID] = baseType;
231                  continue;
232              case 'a': 
233              {
234                  Debug.Assert(elemtypoid > 0);
235                  if (!byOID.TryGetValue(elemtypoid, out var elementPostgresType))
236                  {
237                      _connectionLogger.LogTrace("Array type '{ArrayTypeName}' refers to unknown element with OID {ElementTypeOID}, skipping",
238                          typname, elemtypoid);
239                      continue;
240                  }
241                  var arrayType = new PostgresArrayType(nspname, typname, oid, elementPostgresType);
242                  byOID[arrayType.OID] = arrayType;
243                  continue;
244              }
245              case 'r': 
246              {
247                  Debug.Assert(elemtypoid > 0);
248                  if (!byOID.TryGetValue(elemtypoid, out var subtypePostgresType))
249                  {
250                      _connectionLogger.LogTrace("Range type '{RangeTypeName}' refers to unknown subtype with OID {ElementTypeOID}, skipping",
251                          typname, elemtypoid);
252                      continue;
253                  }
254                  var rangeType = new PostgresRangeType(nspname, typname, oid, subtypePostgresType);
255                  byOID[rangeType.OID] = rangeType;
256                  continue;
257              }
258              case 'm': 
259                  Debug.Assert(elemtypoid > 0);
260                  if (!byOID.TryGetValue(elemtypoid, out var type))
261                  {
262                      _connectionLogger.LogTrace("Multirange type '{MultirangeTypeName}' refers to unknown range with OID {ElementTypeOID}, skipping",
263                          typname, elemtypoid);
264                      continue;
265                  }
266                  if (type is not PostgresRangeType rangePostgresType)
267                  {
268                      _connectionLogger.LogTrace("Multirange type '{MultirangeTypeName}' refers to non-range type '{TypeName}', skipping",
269                          typname, type.Name);
270                      continue;
271                  }
272                  var multirangeType = new PostgresMultirangeType(nspname, typname, oid, rangePostgresType);
273                  byOID[multirangeType.OID] = multirangeType;
274                  continue;
275              case 'e': 
276                  var enumType = new PostgresEnumType(nspname, typname, oid);
277                  byOID[enumType.OID] = enumType;
278                  continue;
279              case 'c': 
280                  var compositeType = new PostgresCompositeType(nspname, typname, oid);
281                  byOID[compositeType.OID] = compositeType;
282                  continue;
283              case 'd': 
284                  Debug.Assert(elemtypoid > 0);
285                  if (!byOID.TryGetValue(elemtypoid, out var basePostgresType))
286                  {
287                      _connectionLogger.LogTrace("Domain type '{DomainTypeName}' refers to unknown base type with OID {ElementTypeOID}, skipping",
288                          typname, elemtypoid);
289                      continue;
290                  }
291                  var domainType = new PostgresDomainType(nspname, typname, oid, basePostgresType, typnotnull);
292                  byOID[domainType.OID] = domainType;
293                  continue;
294              case 'p': 
295                  goto case 'b'; 
296              default:
297                  throw new ArgumentOutOfRangeException($"Unknown typtype for type '{typname}' in pg_type: {typtype}");
298              }
299          }
300          Expect<CommandCompleteMessage>(msg, conn);
301          if (isReplicationConnection)
302              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
303          Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
304          var currentOID = uint.MaxValue;
305          PostgresCompositeType? currentComposite = null;
306          var skipCurrent = false;
307          while (true)
308          {
309              msg = await conn.ReadMessage(async);
310              if (msg is not DataRowMessage)
311                  break;
312              conn.ReadBuffer.Skip(2); 
313              var oid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
314              var attname = ReadNonNullableString(conn.ReadBuffer);
315              var atttypid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
316              if (oid != currentOID)
317              {
318                  currentOID = oid;
319                  if (!byOID.TryGetValue(oid, out var type))  
320                  {
321                      _connectionLogger.LogWarning("Skipping composite type with OID {CompositeTypeOID} which was not found in pg_type", oid);
322                      byOID.Remove(oid);
323                      skipCurrent = true;
324                      continue;
325                  }
326                  currentComposite = type as PostgresCompositeType;
327                  if (currentComposite == null)
328                  {
329                      _connectionLogger.LogWarning("Type {TypeName} was referenced as a composite type but is a {type}", type.Name, type.GetType());
330                      byOID.Remove(oid);
331                      skipCurrent = true;
332                      continue;
333                  }
334                  skipCurrent = false;
335              }
336              if (skipCurrent)
337                  continue;
338              if (!byOID.TryGetValue(atttypid, out var fieldType))  
339              {
340                  _connectionLogger.LogWarning("Skipping composite type '{CompositeTypeName}' with field '{fieldName}' with type OID '{FieldTypeOID}', which could not be resolved to a PostgreSQL type.",
341                      currentComposite!.DisplayName, attname, atttypid);
342                  byOID.Remove(oid);
343                  skipCurrent = true;
344                  continue;
345              }
346              currentComposite!.MutableFields.Add(new PostgresCompositeType.Field(attname, fieldType));
347          }
348          Expect<CommandCompleteMessage>(msg, conn);
349          if (isReplicationConnection)
350              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
351          if (SupportsEnumTypes)
352          {
353              Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
354              currentOID = uint.MaxValue;
355              PostgresEnumType? currentEnum = null;
356              skipCurrent = false;
357              while (true)
358              {
359                  msg = await conn.ReadMessage(async);
360                  if (msg is not DataRowMessage)
361                      break;
362                  conn.ReadBuffer.Skip(2); 
363                  var oid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
364                  var enumlabel = ReadNonNullableString(conn.ReadBuffer);
365                  if (oid != currentOID)
366                  {
367                      currentOID = oid;
368                      if (!byOID.TryGetValue(oid, out var type))  
369                      {
370                          _connectionLogger.LogWarning("Skipping enum type with OID {OID} which was not found in pg_type", oid);
371                          byOID.Remove(oid);
372                          skipCurrent = true;
373                          continue;
374                      }
375                      currentEnum = type as PostgresEnumType;
376                      if (currentEnum == null)
377                      {
378                          _connectionLogger.LogWarning("Type type '{TypeName}' was referenced as an enum type but is a {Type}", type.Name, type.GetType());
379                          byOID.Remove(oid);
380                          skipCurrent = true;
381                          continue;
382                      }
383                      skipCurrent = false;
384                  }
385                  if (skipCurrent)
386                      continue;
387                  currentEnum!.MutableLabels.Add(enumlabel);
388              }
389              Expect<CommandCompleteMessage>(msg, conn);
390              if (isReplicationConnection)
391                  Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
392          }
393          if (!isReplicationConnection)
394              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
395          return byOID.Values.ToList();
396          static string ReadNonNullableString(NpgsqlReadBuffer buffer)
397              => buffer.ReadString(buffer.ReadInt32());
398      }
399  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PostgresDatabaseInfo.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.Linq;
6  using System.Runtime.CompilerServices;
7  using System.Text;
8  using System.Threading.Tasks;
9  using Microsoft.Extensions.Logging;
10  using Npgsql.BackendMessages;
11  using Npgsql.Internal;
12  using Npgsql.PostgresTypes;
13  using Npgsql.TypeMapping;
14  using Npgsql.Util;
15  using static Npgsql.Util.Statics;
16  namespace Npgsql;
17  sealed class PostgresDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
18  {
19      public async Task<NpgsqlDatabaseInfo?> Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
20      {
21          var db = new PostgresDatabaseInfo(conn);
22          await db.LoadPostgresInfo(conn, timeout, async);
23          Debug.Assert(db.LongVersion != null);
24          return db;
25      }
26  }
27  class PostgresDatabaseInfo : NpgsqlDatabaseInfo
28  {
29      readonly ILogger _connectionLogger;
30      List<PostgresType>? _types;
31      protected override IEnumerable<PostgresType> GetTypes() => _types ?? Enumerable.Empty<PostgresType>();
32      public string LongVersion { get; set; } = default!;
33      public bool IsRedshift { get; private set; }
34      public override bool SupportsUnlisten => Version.IsGreaterOrEqual(6, 4) && !IsRedshift;
35      public virtual bool HasEnumSortOrder => Version.IsGreaterOrEqual(9, 1);
36      public virtual bool HasTypeCategory => Version.IsGreaterOrEqual(8, 4);
37      internal PostgresDatabaseInfo(NpgsqlConnector conn)
38          : base(conn.Host!, conn.Port, conn.Database!, conn.PostgresParameters["server_version"])
39          => _connectionLogger = conn.LoggingConfiguration.ConnectionLogger;
40      internal async Task LoadPostgresInfo(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
41      {
42          HasIntegerDateTimes =
43              conn.PostgresParameters.TryGetValue("integer_datetimes", out var intDateTimes) &&
44              intDateTimes == "on";
45          IsRedshift = conn.Settings.ServerCompatibilityMode == ServerCompatibilityMode.Redshift;
46          _types = await LoadBackendTypes(conn, timeout, async);
47      }
48      static string GenerateLoadTypesQuery(bool withRange, bool withMultirange, bool loadTableComposites)
49          => $@"
50  SELECT ns.nspname, t.oid, t.typname, t.typtype, t.typnotnull, t.elemtypoid
51  FROM (
52      -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a
53      -- We first do this for the type (innerest-most subquery), and then for its element type
54      -- This also returns the array element, range subtype and domain base type as elemtypoid
55      SELECT
56          typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,
57          elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,
58          CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype
59      FROM (
60          SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,
61              CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,
62              CASE
63                  WHEN proc.proname='array_recv' THEN typ.typelem
64                  {(withRange ? "WHEN typ.typtype='r' THEN rngsubtype" : "")}
65                  {(withMultirange ? "WHEN typ.typtype='m' THEN (SELECT rngtypid FROM pg_range WHERE rngmultitypid = typ.oid)" : "")}
66                  WHEN typ.typtype='d' THEN typ.typbasetype
67              END AS elemtypoid
68          FROM pg_type AS typ
69          LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)
70          LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive
71          {(withRange ? "LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)" : "")}
72      ) AS typ
73      LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid
74      LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)
75      LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive
76  ) AS t
77  JOIN pg_namespace AS ns ON (ns.oid = typnamespace)
78  WHERE
79      typtype IN ('b', 'r', 'm', 'e', 'd') OR -- Base, range, multirange, enum, domain
80      (typtype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "relkind='c'")}) OR -- User-defined free-standing composites (not table composites) by default
81      (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types
82      (typtype = 'a' AND (  -- Array of...
83          elemtyptype IN ('b', 'r', 'm', 'e', 'd') OR -- Array of base, range, multirange, enum, domain
84          (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types
<span onclick='openModal()' class='match'>85          (elemtyptype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "elemrelkind='c'")}) -- Array of user-defined free-standing composites (not table composites) by default
86      ))
87  ORDER BY CASE
88         WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types
89         WHEN typtype = 'r' THEN 1                        -- Ranges after
90         WHEN typtype = 'm' THEN 2                        -- Multiranges after
91         WHEN typtype = 'c' THEN 3                        -- Composites after
92         WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 4 -- Domains over non-arrays after
93         WHEN typtype = 'a' THEN 5                        -- Arrays after
94         WHEN typtype = 'd' AND elemtyptype = 'a' THEN 6  -- Domains over arrays last
95  END;";
</span>96      static string GenerateLoadCompositeTypesQuery(bool loadTableComposites)
97          => $@"
98  -- Load field definitions for (free-standing) composite types
99  SELECT typ.oid, att.attname, att.atttypid
100  FROM pg_type AS typ
101  JOIN pg_namespace AS ns ON (ns.oid = typ.typnamespace)
102  JOIN pg_class AS cls ON (cls.oid = typ.typrelid)
103  JOIN pg_attribute AS att ON (att.attrelid = typ.typrelid)
104  WHERE
105    (typ.typtype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "cls.relkind='c'")}) AND
106    attnum > 0 AND     -- Don't load system attributes
107    NOT attisdropped
108  ORDER BY typ.oid, att.attnum;";
109      static string GenerateLoadEnumFieldsQuery(bool withEnumSortOrder)
110          => $@"
111  -- Load enum fields
112  SELECT pg_type.oid, enumlabel
113  FROM pg_enum
114  JOIN pg_type ON pg_type.oid=enumtypid
115  ORDER BY oid{(withEnumSortOrder ? ", enumsortorder" : "")};";
116      internal async Task<List<PostgresType>> LoadBackendTypes(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
117      {
118          var versionQuery = "SELECT version();";
119          var loadTypesQuery = GenerateLoadTypesQuery(SupportsRangeTypes, SupportsMultirangeTypes, conn.Settings.LoadTableComposites);
120          var loadCompositeTypesQuery = GenerateLoadCompositeTypesQuery(conn.Settings.LoadTableComposites);
121          var loadEnumFieldsQuery = SupportsEnumTypes
122              ? GenerateLoadEnumFieldsQuery(HasEnumSortOrder)
123              : string.Empty;
124          timeout.CheckAndApply(conn);
125          var isReplicationConnection = conn.Settings.ReplicationMode != ReplicationMode.Off;
126          if (isReplicationConnection)
127          {
128              await conn.WriteQuery(versionQuery, async);
129              await conn.WriteQuery(SanitizeForReplicationConnection(loadTypesQuery), async);
130              await conn.WriteQuery(SanitizeForReplicationConnection(loadCompositeTypesQuery), async);
131              if (SupportsEnumTypes)
132                  await conn.WriteQuery(SanitizeForReplicationConnection(loadEnumFieldsQuery), async);
133              static string SanitizeForReplicationConnection(string str)
134              {
135                  var sb = new StringBuilder(str.Length);
136                  using var c = str.GetEnumerator();
137                  while (c.MoveNext())
138                  {
139                      switch (c.Current)
140                      {
141                      case '\r':
142                          sb.Append('\n');
143                          if (c.MoveNext())
144                          {
145                              if (c.Current == '-')
146                                  goto case '-';
147                              if (c.Current != '\n')
148                                  sb.Append(c.Current);
149                          }
150                          break;
151                      case '-':
152                          if (c.MoveNext())
153                          {
154                              if (c.Current == '\r')
155                              {
156                                  sb.Append('-');
157                                  goto case '\r';
158                              }
159                              if (c.Current != '-')
160                              {
161                                  sb.Append('-');
162                                  sb.Append(c.Current);
163                                  break;
164                              }
165                              while (c.MoveNext())
166                              {
167                                  if (c.Current == '\r')
168                                      goto case '\r';
169                                  if (c.Current == '\n')
170                                  {
171                                      sb.Append('\n');
172                                      break;
173                                  }
174                              }
175                          }
176                          break;
177                      default:
178                          sb.Append(c.Current);
179                          break;
180                      }
181                  }
182                  return sb.ToString();
183              }
184          }
185          else
186          {
187              var batchQuery = new StringBuilder(
188                      versionQuery.Length +
189                      loadTypesQuery.Length +
190                      loadCompositeTypesQuery.Length +
191                      (SupportsEnumTypes
192                          ? loadEnumFieldsQuery.Length
193                          : 0))
194                  .AppendLine(versionQuery)
195                  .AppendLine(loadTypesQuery)
196                  .AppendLine(loadCompositeTypesQuery);
197              if (SupportsEnumTypes)
198                  batchQuery.AppendLine(loadEnumFieldsQuery);
199              await conn.WriteQuery(batchQuery.ToString(), async);
200          }
201          await conn.Flush(async);
202          var byOID = new Dictionary<uint, PostgresType>();
203          Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
204          Expect<DataRowMessage>(await conn.ReadMessage(async), conn);
205          conn.ReadBuffer.Skip(2); 
206          LongVersion = ReadNonNullableString(conn.ReadBuffer);
207          Expect<CommandCompleteMessage>(await conn.ReadMessage(async), conn);
208          if (isReplicationConnection)
209              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
210          Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
211          IBackendMessage msg;
212          while (true)
213          {
214              msg = await conn.ReadMessage(async);
215              if (msg is not DataRowMessage)
216                  break;
217              conn.ReadBuffer.Skip(2); 
218              var nspname = ReadNonNullableString(conn.ReadBuffer);
219              var oid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
220              Debug.Assert(oid != 0);
221              var typname = ReadNonNullableString(conn.ReadBuffer);
222              var typtype = ReadNonNullableString(conn.ReadBuffer)[0];
223              var typnotnull = ReadNonNullableString(conn.ReadBuffer)[0] == 't';
224              var len = conn.ReadBuffer.ReadInt32();
225              var elemtypoid = len == -1 ? 0 : uint.Parse(conn.ReadBuffer.ReadString(len), NumberFormatInfo.InvariantInfo);
226              switch (typtype)
227              {
228              case 'b': 
229                  var baseType = new PostgresBaseType(nspname, typname, oid);
230                  byOID[baseType.OID] = baseType;
231                  continue;
232              case 'a': 
233              {
234                  Debug.Assert(elemtypoid > 0);
235                  if (!byOID.TryGetValue(elemtypoid, out var elementPostgresType))
236                  {
237                      _connectionLogger.LogTrace("Array type '{ArrayTypeName}' refers to unknown element with OID {ElementTypeOID}, skipping",
238                          typname, elemtypoid);
239                      continue;
240                  }
241                  var arrayType = new PostgresArrayType(nspname, typname, oid, elementPostgresType);
242                  byOID[arrayType.OID] = arrayType;
243                  continue;
244              }
245              case 'r': 
246              {
247                  Debug.Assert(elemtypoid > 0);
248                  if (!byOID.TryGetValue(elemtypoid, out var subtypePostgresType))
249                  {
250                      _connectionLogger.LogTrace("Range type '{RangeTypeName}' refers to unknown subtype with OID {ElementTypeOID}, skipping",
251                          typname, elemtypoid);
252                      continue;
253                  }
254                  var rangeType = new PostgresRangeType(nspname, typname, oid, subtypePostgresType);
255                  byOID[rangeType.OID] = rangeType;
256                  continue;
257              }
258              case 'm': 
259                  Debug.Assert(elemtypoid > 0);
260                  if (!byOID.TryGetValue(elemtypoid, out var type))
261                  {
262                      _connectionLogger.LogTrace("Multirange type '{MultirangeTypeName}' refers to unknown range with OID {ElementTypeOID}, skipping",
263                          typname, elemtypoid);
264                      continue;
265                  }
266                  if (type is not PostgresRangeType rangePostgresType)
267                  {
268                      _connectionLogger.LogTrace("Multirange type '{MultirangeTypeName}' refers to non-range type '{TypeName}', skipping",
269                          typname, type.Name);
270                      continue;
271                  }
272                  var multirangeType = new PostgresMultirangeType(nspname, typname, oid, rangePostgresType);
273                  byOID[multirangeType.OID] = multirangeType;
274                  continue;
275              case 'e': 
276                  var enumType = new PostgresEnumType(nspname, typname, oid);
277                  byOID[enumType.OID] = enumType;
278                  continue;
279              case 'c': 
280                  var compositeType = new PostgresCompositeType(nspname, typname, oid);
281                  byOID[compositeType.OID] = compositeType;
282                  continue;
283              case 'd': 
284                  Debug.Assert(elemtypoid > 0);
285                  if (!byOID.TryGetValue(elemtypoid, out var basePostgresType))
286                  {
287                      _connectionLogger.LogTrace("Domain type '{DomainTypeName}' refers to unknown base type with OID {ElementTypeOID}, skipping",
288                          typname, elemtypoid);
289                      continue;
290                  }
291                  var domainType = new PostgresDomainType(nspname, typname, oid, basePostgresType, typnotnull);
292                  byOID[domainType.OID] = domainType;
293                  continue;
294              case 'p': 
295                  goto case 'b'; 
296              default:
297                  throw new ArgumentOutOfRangeException($"Unknown typtype for type '{typname}' in pg_type: {typtype}");
298              }
299          }
300          Expect<CommandCompleteMessage>(msg, conn);
301          if (isReplicationConnection)
302              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
303          Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
304          var currentOID = uint.MaxValue;
305          PostgresCompositeType? currentComposite = null;
306          var skipCurrent = false;
307          while (true)
308          {
309              msg = await conn.ReadMessage(async);
310              if (msg is not DataRowMessage)
311                  break;
312              conn.ReadBuffer.Skip(2); 
313              var oid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
314              var attname = ReadNonNullableString(conn.ReadBuffer);
315              var atttypid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
316              if (oid != currentOID)
317              {
318                  currentOID = oid;
319                  if (!byOID.TryGetValue(oid, out var type))  
320                  {
321                      _connectionLogger.LogWarning("Skipping composite type with OID {CompositeTypeOID} which was not found in pg_type", oid);
322                      byOID.Remove(oid);
323                      skipCurrent = true;
324                      continue;
325                  }
326                  currentComposite = type as PostgresCompositeType;
327                  if (currentComposite == null)
328                  {
329                      _connectionLogger.LogWarning("Type {TypeName} was referenced as a composite type but is a {type}", type.Name, type.GetType());
330                      byOID.Remove(oid);
331                      skipCurrent = true;
332                      continue;
333                  }
334                  skipCurrent = false;
335              }
336              if (skipCurrent)
337                  continue;
338              if (!byOID.TryGetValue(atttypid, out var fieldType))  
339              {
340                  _connectionLogger.LogWarning("Skipping composite type '{CompositeTypeName}' with field '{fieldName}' with type OID '{FieldTypeOID}', which could not be resolved to a PostgreSQL type.",
341                      currentComposite!.DisplayName, attname, atttypid);
342                  byOID.Remove(oid);
343                  skipCurrent = true;
344                  continue;
345              }
346              currentComposite!.MutableFields.Add(new PostgresCompositeType.Field(attname, fieldType));
347          }
348          Expect<CommandCompleteMessage>(msg, conn);
349          if (isReplicationConnection)
350              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
351          if (SupportsEnumTypes)
352          {
353              Expect<RowDescriptionMessage>(await conn.ReadMessage(async), conn);
354              currentOID = uint.MaxValue;
355              PostgresEnumType? currentEnum = null;
356              skipCurrent = false;
357              while (true)
358              {
359                  msg = await conn.ReadMessage(async);
360                  if (msg is not DataRowMessage)
361                      break;
362                  conn.ReadBuffer.Skip(2); 
363                  var oid = uint.Parse(ReadNonNullableString(conn.ReadBuffer), NumberFormatInfo.InvariantInfo);
364                  var enumlabel = ReadNonNullableString(conn.ReadBuffer);
365                  if (oid != currentOID)
366                  {
367                      currentOID = oid;
368                      if (!byOID.TryGetValue(oid, out var type))  
369                      {
370                          _connectionLogger.LogWarning("Skipping enum type with OID {OID} which was not found in pg_type", oid);
371                          byOID.Remove(oid);
372                          skipCurrent = true;
373                          continue;
374                      }
375                      currentEnum = type as PostgresEnumType;
376                      if (currentEnum == null)
377                      {
378                          _connectionLogger.LogWarning("Type type '{TypeName}' was referenced as an enum type but is a {Type}", type.Name, type.GetType());
379                          byOID.Remove(oid);
380                          skipCurrent = true;
381                          continue;
382                      }
383                      skipCurrent = false;
384                  }
385                  if (skipCurrent)
386                      continue;
387                  currentEnum!.MutableLabels.Add(enumlabel);
388              }
389              Expect<CommandCompleteMessage>(msg, conn);
390              if (isReplicationConnection)
391                  Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
392          }
393          if (!isReplicationConnection)
394              Expect<ReadyForQueryMessage>(await conn.ReadMessage(async), conn);
395          return byOID.Values.ToList();
396          static string ReadNonNullableString(NpgsqlReadBuffer buffer)
397              => buffer.ReadString(buffer.ReadInt32());
398      }
399  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PostgresDatabaseInfo.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-PostgresDatabaseInfo.cs</div>
                </div>
                <div class="column column_space"><pre><code>80      (typtype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "relkind='c'")}) OR -- User-defined free-standing composites (not table composites) by default
81      (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types
82      (typtype = 'a' AND (  -- Array of...
83          elemtyptype IN ('b', 'r', 'm', 'e', 'd') OR -- Array of base, range, multirange, enum, domain
84          (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types
85          (elemtyptype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "elemrelkind='c'")}) -- Array of user-defined free-standing composites (not table composites) by default
</pre></code></div>
                <div class="column column_space"><pre><code>85          (elemtyptype = 'c' AND {(loadTableComposites ? "ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')" : "elemrelkind='c'")}) -- Array of user-defined free-standing composites (not table composites) by default
86      ))
87  ORDER BY CASE
88         WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types
89         WHEN typtype = 'r' THEN 1                        -- Ranges after
90         WHEN typtype = 'm' THEN 2                        -- Multiranges after
91         WHEN typtype = 'c' THEN 3                        -- Composites after
92         WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 4 -- Domains over non-arrays after
93         WHEN typtype = 'a' THEN 5                        -- Arrays after
94         WHEN typtype = 'd' AND elemtyptype = 'a' THEN 6  -- Domains over arrays last
95  END;";
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    