
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 32, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ConnectionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Data;
4  using System.Diagnostics;
5  using System.IO;
6  using System.Linq;
7  using System.Net;
8  using System.Net.Security;
9  using System.Runtime.InteropServices;
10  using System.Security.Cryptography.X509Certificates;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using Npgsql.Internal;
15  using Npgsql.PostgresTypes;
16  using Npgsql.Properties;
17  using Npgsql.Util;
18  using NpgsqlTypes;
19  using NUnit.Framework;
20  using static Npgsql.Tests.TestUtil;
21  namespace Npgsql.Tests;
22  public class ConnectionTests : MultiplexingTestBase
23  {
24      [Test, Description(&quot;Makes sure the connection goes through the proper state lifecycle&quot;)]
25      public async Task Basic_lifecycle()
26      {
27          await using var conn = CreateConnection();
28          var eventOpen = false;
29          var eventClosed = false;
30          conn.StateChange += (s, e) =&gt;
31          {
32              if (e.OriginalState == ConnectionState.Closed &amp;&amp;
33                  e.CurrentState == ConnectionState.Open)
34                  eventOpen = true;
35              if (e.OriginalState == ConnectionState.Open &amp;&amp;
36                  e.CurrentState == ConnectionState.Closed)
37                  eventClosed = true;
38          };
39          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
40          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
41          await conn.OpenAsync();
42          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
43          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
44          Assert.That(eventOpen, Is.True);
45          await using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
46          await using (var reader = await cmd.ExecuteReaderAsync())
47          {
48              await reader.ReadAsync();
49              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
50              Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
51          }
52          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
53          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
54          await conn.CloseAsync();
55          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
56          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
57          Assert.That(eventClosed, Is.True);
58      }
59      [Test, Description(&quot;Makes sure the connection goes through the proper state lifecycle&quot;)]
60      public async Task Broken_lifecycle([Values] bool openFromClose)
61      {
62          if (IsMultiplexing)
63              return;
64          await using var dataSource = CreateDataSource();
65          await using var conn = dataSource.CreateConnection();
66          var eventOpen = false;
67          var eventClosed = false;
68          conn.StateChange += (s, e) =&gt;
69          {
70              if (e.OriginalState == ConnectionState.Closed &amp;&amp;
71                  e.CurrentState == ConnectionState.Open)
72                  eventOpen = true;
73              if (e.OriginalState == ConnectionState.Open &amp;&amp;
74                  e.CurrentState == ConnectionState.Closed)
75                  eventClosed = true;
76          };
77          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
78          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
79          await conn.OpenAsync();
80          await using var transaction = await conn.BeginTransactionAsync();
81          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
82          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
83          Assert.That(eventOpen, Is.True);
84          var sleep = conn.ExecuteNonQueryAsync(&quot;SELECT pg_sleep(5)&quot;);
85          await Task.Delay(1000);
86          await using (var killingConn = await OpenConnectionAsync())
87              killingConn.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
88          Assert.ThrowsAsync&lt;PostgresException&gt;(() =&gt; sleep);
89          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
90          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
91          Assert.That(eventClosed, Is.True);
92          Assert.That(conn.Connector is null);
93          Assert.AreEqual(0, conn.NpgsqlDataSource.Statistics.Total);
94          if (openFromClose)
95          {
96              await conn.CloseAsync();
97              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
98              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
99              Assert.That(eventClosed, Is.True);
100          }
101          Assert.DoesNotThrowAsync(conn.OpenAsync);
102          Assert.AreEqual(1, await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;));
103          Assert.AreEqual(1, conn.NpgsqlDataSource.Statistics.Total);
104          Assert.DoesNotThrowAsync(conn.CloseAsync);
105      }
106      [Test]
107      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Flaky on MacOS&quot;)]
108      public async Task Break_while_open()
109      {
110          if (IsMultiplexing)
111              return;
112          await using var dataSource = CreateDataSource();
113          await using var conn = await dataSource.OpenConnectionAsync();
114          using (var conn2 = await OpenConnectionAsync())
115              conn2.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
116          using (var cmd = CreateSleepCommand(conn, 10))
117              Assert.That(() =&gt; cmd.ExecuteNonQuery(), Throws.Exception
118                  .AssignableTo&lt;NpgsqlException&gt;());
119          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
120          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
121      }
122      #region Connection Errors
123  #if IGNORE
124      [Test]
125      [TestCase(true)]
126      [TestCase(false)]
127      public async Task Connection_refused(bool pooled)
128      {
129          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Port = 44444, Pooling = pooled };
130          using (var conn = new NpgsqlConnection(csb)) {
131              Assert.That(() =&gt; conn.Open(), Throws.Exception
132                  .TypeOf&lt;SocketException&gt;()
133                  .With.Property(nameof(SocketException.SocketErrorCode)).EqualTo(SocketError.ConnectionRefused)
134              );
135              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
136          }
137      }
138      [Test]
139      [TestCase(true)]
140      [TestCase(false)]
141      public async Task Connection_refused_async(bool pooled)
142      {
143          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Port = 44444, Pooling = pooled };
144          using (var conn = new NpgsqlConnection(csb))
145          {
146              Assert.That(async () =&gt; await conn.OpenAsync(), Throws.Exception
147                  .TypeOf&lt;SocketException&gt;()
148                  .With.Property(nameof(SocketException.SocketErrorCode)).EqualTo(SocketError.ConnectionRefused)
149              );
150              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
151          }
152      }
153  #endif
154      [Test]
155      [Ignore(&quot;Fails in a non-determinstic manner and only on the build server... investigate...&quot;)]
156      public void Invalid_Username()
157      {
158          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
159          {
160              Username = &quot;unknown&quot;, Pooling = false
161          }.ToString();
162          using var conn = new NpgsqlConnection(connString);
163          Assert.That(conn.Open, Throws.Exception
164              .TypeOf&lt;PostgresException&gt;()
165              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.InvalidPassword)
166          );
167          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
168      }
169      [Test]
170      public void Bad_database()
171      {
172          using var dataSource = CreateDataSource(csb =&gt; csb.Database = &quot;does_not_exist&quot;);
173          using var conn = dataSource.CreateConnection();
174          Assert.That(() =&gt; conn.Open(),
175              Throws.Exception.TypeOf&lt;PostgresException&gt;()
176                  .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.InvalidCatalogName)
177          );
178      }
179      [Test, Description(&quot;Tests that mandatory connection string parameters are indeed mandatory&quot;)]
180      public void Mandatory_connection_string_params()
181          =&gt; Assert.Throws&lt;ArgumentException&gt;(() =&gt;
182              new NpgsqlConnection(&quot;User ID=npgsql_tests;Password=npgsql_tests;Database=npgsql_tests&quot;));
183      [Test, Description(&quot;Reuses the same connection instance for a failed connection, then a successful one&quot;)]
184      public async Task Fail_connect_then_succeed([Values] bool pooling)
185      {
186          if (IsMultiplexing &amp;&amp; !pooling) 
187              return;
188          var dbName = GetUniqueIdentifier(nameof(Fail_connect_then_succeed));
189          await using var conn1 = await OpenConnectionAsync();
190          await conn1.ExecuteNonQueryAsync($&quot;DROP DATABASE IF EXISTS \&quot;{dbName}\&quot;&quot;);
191          try
192          {
193              await using var dataSource = CreateDataSource(csb =&gt;
194              {
195                  csb.Database = dbName;
196                  csb.Pooling = pooling;
197              });
198              await using var conn2 = dataSource.CreateConnection();
199              var pgEx = Assert.ThrowsAsync&lt;PostgresException&gt;(conn2.OpenAsync)!;
200              Assert.That(pgEx.SqlState, Is.EqualTo(PostgresErrorCodes.InvalidCatalogName)); 
201              Assert.That(conn2.FullState, Is.EqualTo(ConnectionState.Closed));
202              await conn1.ExecuteNonQueryAsync($&quot;CREATE DATABASE \&quot;{dbName}\&quot; TEMPLATE template0&quot;);
203              Assert.DoesNotThrowAsync(conn2.OpenAsync);
204              Assert.DoesNotThrowAsync(conn2.CloseAsync);
205          }
206          finally
207          {
208              await conn1.ExecuteNonQueryAsync($&quot;DROP DATABASE IF EXISTS \&quot;{dbName}\&quot;&quot;);
209          }
210      }
211      [Test]
212      public void Open_timeout_unknown_ip([Values(true, false)] bool async)
213      {
214          const int timeoutSeconds = 2;
215          var unknownIp = Environment.GetEnvironmentVariable(&quot;NPGSQL_UNKNOWN_IP&quot;);
216          if (unknownIp is null)
217          {
218              Assert.Ignore(&quot;NPGSQL_UNKNOWN_IP isn&#x27;t defined and is required for connection timeout tests&quot;);
219              return;
220          }
221          using var dataSource = CreateDataSource(csb =&gt;
222          {
223              csb.Host = unknownIp;
224              csb.Timeout = timeoutSeconds;
225          });
226          using var conn = dataSource.CreateConnection();
227          var sw = Stopwatch.StartNew();
228          if (async)
229          {
230              Assert.That(async () =&gt; await conn.OpenAsync(), Throws.Exception
231                  .TypeOf&lt;NpgsqlException&gt;()
232                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
233          }
234          else
235          {
236              Assert.That(() =&gt; conn.Open(), Throws.Exception
237                  .TypeOf&lt;NpgsqlException&gt;()
238                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
239          }
240          Assert.That(sw.Elapsed.TotalMilliseconds, Is.GreaterThanOrEqualTo(timeoutSeconds * 1000 - 100),
241              $&quot;Timeout was supposed to happen after {timeoutSeconds} seconds, but fired after {sw.Elapsed.TotalSeconds}&quot;);
242          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
243      }
244      [Test]
245      public void Connect_timeout_cancel()
246      {
247          var unknownIp = Environment.GetEnvironmentVariable(&quot;NPGSQL_UNKNOWN_IP&quot;);
248          if (unknownIp is null)
249          {
250              Assert.Ignore(&quot;NPGSQL_UNKNOWN_IP isn&#x27;t defined and is required for connection cancellation tests&quot;);
251              return;
252          }
253          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
254          {
255              Host = unknownIp,
256              Pooling = false,
257              Timeout = 30
258          }.ToString();
259          using var conn = new NpgsqlConnection(connString);
260          var cts = new CancellationTokenSource(1000);
261          Assert.That(async () =&gt; await conn.OpenAsync(cts.Token), Throws.Exception.TypeOf&lt;OperationCanceledException&gt;());
262          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
263      }
264      #endregion
265      #region Client Encoding
266      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1065&quot;)]
267      public async Task Client_encoding_is_UTF8_by_default()
268      {
269          using var conn = await OpenConnectionAsync();
270          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.EqualTo(&quot;UTF8&quot;));
271      }
272      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1065&quot;)]
273      [NonParallelizable] 
274      public async Task Client_encoding_env_var()
275      {
276          using (var testConn = await OpenConnectionAsync())
277              Assert.That(await testConn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.Not.EqualTo(&quot;SQL_ASCII&quot;));
278          using var _ = SetEnvironmentVariable(&quot;PGCLIENTENCODING&quot;, &quot;SQL_ASCII&quot;);
279          await using var dataSource = CreateDataSource();
280          await using var conn = await dataSource.OpenConnectionAsync();
281          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.EqualTo(&quot;SQL_ASCII&quot;));
282      }
283      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1065&quot;)]
284      public async Task Client_encoding_connection_param()
285      {
286          using (var conn = await OpenConnectionAsync())
287              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.Not.EqualTo(&quot;SQL_ASCII&quot;));
288          await using var dataSource = CreateDataSource(csb =&gt; csb.ClientEncoding = &quot;SQL_ASCII&quot;);
289          using (var conn = await dataSource.OpenConnectionAsync())
290              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.EqualTo(&quot;SQL_ASCII&quot;));
291      }
292      #endregion Client Encoding
293      #region Timezone
294      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1634&quot;)]
295      [NonParallelizable] 
296      public async Task Timezone_env_var()
297      {
298          string newTimezone;
<span onclick='openModal()' class='match'>299          using (var conn1 = await OpenConnectionAsync())
300          {
301              newTimezone = (string?)await conn1.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;) == &quot;Africa/Bamako&quot;
302                  ? &quot;Africa/Lagos&quot;
303                  : &quot;Africa/Bamako&quot;;
304          }
305          using var _ = SetEnvironmentVariable(&quot;PGTZ&quot;, newTimezone);
</span>306          await using var dataSource = CreateDataSource();
307          using var conn2 = await dataSource.OpenConnectionAsync();
308          Assert.That(await conn2.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;), Is.EqualTo(newTimezone));
309      }
310      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1634&quot;)]
311      public async Task Timezone_connection_param()
312      {
313          string newTimezone;
314          using (var conn = await OpenConnectionAsync())
315          {
316              newTimezone = (string?)await conn.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;) == &quot;Africa/Bamako&quot;
317                  ? &quot;Africa/Lagos&quot;
318                  : &quot;Africa/Bamako&quot;;
319          }
320          await using var dataSource = CreateDataSource(csb =&gt; csb.Timezone = newTimezone);
321          using (var conn = await dataSource.OpenConnectionAsync())
322              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;), Is.EqualTo(newTimezone));
323      }
324      #endregion Timezone
325      #region ConnectionString - Host
326      [TestCase(&quot;127.0.0.1&quot;, ExpectedResult = new [] { &quot;127.0.0.1:5432&quot; })]
327      [TestCase(&quot;127.0.0.1:5432&quot;, ExpectedResult = new [] { &quot;127.0.0.1:5432&quot; })]
328      [TestCase(&quot;::1&quot;, ExpectedResult = new [] { &quot;::1:5432&quot; })]
329      [TestCase(&quot;[::1]&quot;, ExpectedResult = new [] { &quot;[::1]:5432&quot; })]
330      [TestCase(&quot;[::1]:5432&quot;, ExpectedResult = new [] { &quot;[::1]:5432&quot; })]
331      [TestCase(&quot;localhost&quot;, ExpectedResult = new [] { &quot;localhost:5432&quot; })]
332      [TestCase(&quot;localhost:5432&quot;, ExpectedResult = new [] { &quot;localhost:5432&quot; })]
333      [TestCase(&quot;127.0.0.1,127.0.0.1:5432,::1,[::1],[::1]:5432,localhost,localhost:5432&quot;,
334          ExpectedResult = new []
335          {
336              &quot;127.0.0.1:5432&quot;,
337              &quot;127.0.0.1:5432&quot;,
338              &quot;::1:5432&quot;,
339              &quot;[::1]:5432&quot;,
340              &quot;[::1]:5432&quot;,
341              &quot;localhost:5432&quot;,
342              &quot;localhost:5432&quot;
343          })]
344      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3802&quot;)]
345      public string[] ConnectionString_Host(string host)
346      {
347          var dataSourceBuilder = new NpgsqlDataSourceBuilder
348          {
349              ConnectionStringBuilder = { Host = host }
350          };
351          using var dataSource = dataSourceBuilder.BuildMultiHost();
352          return dataSource.Pools.Select(ds =&gt; $&quot;{ds.Settings.Host}:{ds.Settings.Port}&quot;).ToArray()!;
353      }
354      #endregion ConnectionString - Host
355      [Test]
356      public async Task Unix_domain_socket()
357      {
358          if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
359          {
360              if (Environment.OSVersion.Version.Major &lt; 10 || Environment.OSVersion.Version.Build &lt; 17093)
361                  Assert.Ignore(&quot;Unix-domain sockets support was introduced in Windows build 17093&quot;);
362              using var versionConnection = await OpenConnectionAsync();
363              MinimumPgVersion(versionConnection, &quot;13.0&quot;, &quot;Unix-domain sockets support on Windows was introduced in PostgreSQL 13&quot;);
364          }
365          var port = new NpgsqlConnectionStringBuilder(ConnectionString).Port;
366          var candidateDirectories = new[] { &quot;/var/run/postgresql&quot;, &quot;/tmp&quot;, Environment.GetEnvironmentVariable(&quot;TMP&quot;) ?? &quot;C:\\&quot; };
367          var dir = candidateDirectories.FirstOrDefault(d =&gt; File.Exists(Path.Combine(d, $&quot;.s.PGSQL.{port}&quot;)));
368          if (dir == null)
369          {
370              IgnoreExceptOnBuildServer(&quot;No PostgreSQL unix domain socket was found&quot;);
371              return;
372          }
373          try
374          {
375              await using var dataSource = CreateDataSource(csb =&gt; csb.Host = dir);
376              await using var conn = await dataSource.OpenConnectionAsync();
377              await using var tx = await conn.BeginTransactionAsync();
378              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;, tx), Is.EqualTo(1));
379              Assert.That(conn.DataSource, Is.EqualTo(Path.Combine(dir, $&quot;.s.PGSQL.{port}&quot;)));
380          }
381          catch (Exception ex)
382          {
383              IgnoreExceptOnBuildServer($&quot;Connection via unix domain socket failed: {ex}&quot;);
384          }
385      }
386      [Test]
387      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Fails only on mac, needs to be investigated&quot;)]
388      public async Task Unix_abstract_domain_socket()
389      {
390          if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
391          {
392              Assert.Ignore(&quot;Abstract unix-domain sockets are not supported on windows&quot;);
393          }
394          using var versionConnection = await OpenConnectionAsync();
395          MinimumPgVersion(versionConnection, &quot;14.0&quot;, &quot;Abstract unix-domain sockets support was introduced in PostgreSQL 14&quot;);
396          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
397          {
398              Host = &quot;@/npgsql_unix&quot;
399          };
400          try
401          {
402              await using var dataSource = CreateDataSource(csb.ToString());
403              await using var conn = await dataSource.OpenConnectionAsync();
404              await using var tx = await conn.BeginTransactionAsync();
405              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;, tx), Is.EqualTo(1));
406              Assert.That(conn.DataSource, Is.EqualTo(Path.Combine(csb.Host, $&quot;.s.PGSQL.{csb.Port}&quot;)));
407          }
408          catch (Exception ex)
409          {
410              IgnoreExceptOnBuildServer($&quot;Connection via abstract unix domain socket failed: {ex}&quot;);
411          }
412      }
413      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/903&quot;)]
414      public void DataSource_property()
415      {
416          using var conn = new NpgsqlConnection();
417          Assert.That(conn.DataSource, Is.EqualTo(string.Empty));
418          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
419          conn.ConnectionString = csb.ConnectionString;
420          Assert.That(conn.DataSource, Is.EqualTo($&quot;tcp:&amp;bsol;&amp;bsol;{csb.Host}:{csb.Port}&quot;));
421          if (IsMultiplexing)
422              return;
423          csb.Host = &quot;127.0.0.1, 127.0.0.2&quot;;
424          conn.ConnectionString = csb.ConnectionString;
425          Assert.That(conn.DataSource, Is.EqualTo(string.Empty));
426      }
427      #region Server version
428      [Test]
429      public async Task PostgreSqlVersion_ServerVersion()
430      {
431          await using var c = new NpgsqlConnection(ConnectionString);
432          Assert.That(() =&gt; c.PostgreSqlVersion, Throws.InvalidOperationException
433              .With.Message.EqualTo(&quot;Connection is not open&quot;));
434          Assert.That(() =&gt; c.ServerVersion, Throws.InvalidOperationException
435              .With.Message.EqualTo(&quot;Connection is not open&quot;));
436          await c.OpenAsync();
437          var backendVersionString = (string)(await c.ExecuteScalarAsync(&quot;SHOW server_version&quot;))!;
438          Assert.That(backendVersionString, Is.EqualTo(c.ServerVersion));
439          Assert.That(backendVersionString, Does.Contain(
440              new[] { &quot;rc&quot;, &quot;beta&quot;, &quot;devel&quot; }.Any(x =&gt; backendVersionString.Contains(x))
441                  ? c.PostgreSqlVersion.Major.ToString()
442                  : c.PostgreSqlVersion.ToString()));
443      }
444      [TestCase(&quot;X13.0&quot;)]
445      [TestCase(&quot;13.&quot;)]
446      [TestCase(&quot;13.1.&quot;)]
447      [TestCase(&quot;13.1.1.&quot;)]
448      [TestCase(&quot;13.1.1.1.&quot;)]
449      [TestCase(&quot;13.1.1.1.1&quot;)]
450      public void ParseVersion_fails(string versionString)
451          =&gt; Assert.That(() =&gt; TestDbInfo.ParseServerVersion(versionString), Throws.Exception);
452      [TestCase(&quot;13.3&quot;, ExpectedResult = &quot;13.3&quot;)]
453      [TestCase(&quot;13.3X&quot;, ExpectedResult = &quot;13.3&quot;)]
454      [TestCase(&quot;9.6.4&quot;, ExpectedResult = &quot;9.6.4&quot;)]
455      [TestCase(&quot;9.6.4X&quot;, ExpectedResult = &quot;9.6.4&quot;)]
456      [TestCase(&quot;9.5alpha2&quot;, ExpectedResult = &quot;9.5&quot;)]
457      [TestCase(&quot;9.5alpha2X&quot;, ExpectedResult = &quot;9.5&quot;)]
458      [TestCase(&quot;9.5devel&quot;, ExpectedResult = &quot;9.5&quot;)]
459      [TestCase(&quot;9.5develX&quot;, ExpectedResult = &quot;9.5&quot;)]
460      [TestCase(&quot;9.5deveX&quot;, ExpectedResult = &quot;9.5&quot;)]
461      [TestCase(&quot;9.4beta3&quot;, ExpectedResult = &quot;9.4&quot;)]
462      [TestCase(&quot;9.4rc1&quot;, ExpectedResult = &quot;9.4&quot;)]
463      [TestCase(&quot;9.4rc1X&quot;, ExpectedResult = &quot;9.4&quot;)]
464      [TestCase(&quot;13devel&quot;, ExpectedResult = &quot;13.0&quot;)]
465      [TestCase(&quot;13beta1&quot;, ExpectedResult = &quot;13.0&quot;)]
466      [TestCase(&quot;13&quot;, ExpectedResult = &quot;13.0&quot;)]
467      [TestCase(&quot;13X&quot;, ExpectedResult = &quot;13.0&quot;)]
468      [TestCase(&quot;13alpha1&quot;, ExpectedResult = &quot;13.0&quot;)]
469      [TestCase(&quot;13alpha&quot;, ExpectedResult = &quot;13.0&quot;)]
470      [TestCase(&quot;13alphX&quot;, ExpectedResult = &quot;13.0&quot;)]
471      [TestCase(&quot;13beta&quot;, ExpectedResult = &quot;13.0&quot;)]
472      [TestCase(&quot;13betX&quot;, ExpectedResult = &quot;13.0&quot;)]
473      [TestCase(&quot;13rc1&quot;, ExpectedResult = &quot;13.0&quot;)]
474      [TestCase(&quot;13rc&quot;, ExpectedResult = &quot;13.0&quot;)]
475      [TestCase(&quot;13rX&quot;, ExpectedResult = &quot;13.0&quot;)]
476      [TestCase(&quot;99999.99999.99999.99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
477      [TestCase(&quot;99999.99999.99999.99999X&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
478      [TestCase(&quot;99999.99999.99999.99999devel&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
479      [TestCase(&quot;99999.99999.99999.99999alpha99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
480      [TestCase(&quot;99999.99999.99999alpha99999&quot;, ExpectedResult = &quot;99999.99999.99999&quot;)]
481      [TestCase(&quot;99999.99999.99999.99999beta99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
482      [TestCase(&quot;99999.99999.99999beta99999&quot;, ExpectedResult = &quot;99999.99999.99999&quot;)]
483      [TestCase(&quot;99999.99999.99999.99999rc99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
484      [TestCase(&quot;99999.99999.99999rc99999&quot;, ExpectedResult = &quot;99999.99999.99999&quot;)]
485      public string ParseVersion_succeeds(string versionString)
486          =&gt; TestDbInfo.ParseServerVersion(versionString).ToString();
487      class TestDbInfo : NpgsqlDatabaseInfo
488      {
489          public TestDbInfo(string host, int port, string databaseName, Version version) : base(host, port, databaseName, version)
490              =&gt; throw new NotImplementedException();
491          protected override IEnumerable&lt;PostgresType&gt; GetTypes()
492              =&gt; throw new NotImplementedException();
493          public new static Version ParseServerVersion(string versionString)
494              =&gt; NpgsqlDatabaseInfo.ParseServerVersion(versionString);
495      }
496      #endregion Server version
497      [Test]
498      public void Setting_connection_string_while_open_throws()
499      {
500          using var conn = new NpgsqlConnection();
501          conn.ConnectionString = ConnectionString;
502          conn.Open();
503          Assert.That(() =&gt; conn.ConnectionString = &quot;&quot;, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
504      }
505      [Test]
506      public void Empty_constructor()
507      {
508          var conn = new NpgsqlConnection();
509          Assert.That(conn.ConnectionTimeout, Is.EqualTo(NpgsqlConnectionStringBuilder.DefaultTimeout));
510          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
511          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
512      }
513      [Test]
514      public void Constructor_with_null_connection_string()
515      {
516          var conn = new NpgsqlConnection(null);
517          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
518          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
519      }
520      [Test]
521      public void Constructor_with_empty_connection_string()
522      {
523          var conn = new NpgsqlConnection(&quot;&quot;);
524          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
525          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
526      }
527      [Test]
528      public void Set_connection_string_to_null()
529      {
530          var conn = new NpgsqlConnection(ConnectionString);
531          conn.ConnectionString = null;
532          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
533          Assert.That(conn.Settings.Host, Is.Null);
534          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
535      }
536      [Test]
537      public void Set_connection_string_to_empty()
538      {
539          var conn = new NpgsqlConnection(ConnectionString);
540          conn.ConnectionString = &quot;&quot;;
541          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
542          Assert.That(conn.Settings.Host, Is.Null);
543          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
544      }
545      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/703&quot;)]
546      public async Task No_database_defaults_to_username()
547      {
548          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Database = null };
549          using var conn = new NpgsqlConnection(csb.ToString());
550          Assert.That(conn.Database, Is.EqualTo(csb.Username));
551          conn.Open();
552          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT current_database()&quot;), Is.EqualTo(csb.Username));
553          Assert.That(conn.Database, Is.EqualTo(csb.Username));
554      }
555      [Test, Description(&quot;Breaks a connector while it&#x27;s in the pool, with a keepalive and without&quot;)]
556      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Fails only on mac, needs to be investigated&quot;)]
557      [TestCase(false, TestName = nameof(Break_connector_in_pool) + &quot;_without_keep_alive&quot;)]
558      [TestCase(true, TestName = nameof(Break_connector_in_pool) + &quot;_with_keep_alive&quot;)]
559      public async Task Break_connector_in_pool(bool keepAlive)
560      {
561          if (IsMultiplexing)
562              Assert.Ignore(&quot;Multiplexing, hanging&quot;);
563          var dataSourceBuilder = CreateDataSourceBuilder();
564          dataSourceBuilder.ConnectionStringBuilder.MaxPoolSize = 1;
565          if (keepAlive)
566              dataSourceBuilder.ConnectionStringBuilder.KeepAlive = 1;
567          await using var dataSource = dataSourceBuilder.Build();
568          await using var conn = await dataSource.OpenConnectionAsync();
569          var connector = conn.Connector;
570          Assert.That(connector, Is.Not.Null);
571          await conn.CloseAsync();
572          await using (var conn2 = await OpenConnectionAsync())
573              await conn2.ExecuteNonQueryAsync($&quot;SELECT pg_terminate_backend({connector!.BackendProcessId})&quot;);
574          await Task.Delay(3000);
575          await conn.OpenAsync();
576          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
577          if (keepAlive)
578          {
579              Assert.That(conn.Connector, Is.Not.SameAs(connector));
580              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
581          }
582          else
583          {
584              Assert.That(conn.Connector, Is.SameAs(connector));
585              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Throws.Exception
586                  .AssignableTo&lt;NpgsqlException&gt;());
587          }
588      }
589      [Test]
590      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4603&quot;)]
591      public async Task Reload_types_keepalive_concurrent()
592      {
593          if (IsMultiplexing)
594              Assert.Ignore(&quot;Multiplexing doesn&#x27;t support keepalive&quot;);
595          await using var dataSource = CreateDataSource(csb =&gt; csb.KeepAlive = 1);
596          await using var conn = await dataSource.OpenConnectionAsync();
597          var startTimestamp = Stopwatch.GetTimestamp();
598          while (GetElapsedTime(startTimestamp).TotalSeconds &lt; 2)
599              Assert.DoesNotThrow(conn.ReloadTypes);
600          static TimeSpan GetElapsedTime(long startingTimestamp) =&gt;
601              new((long)((Stopwatch.GetTimestamp() - startingTimestamp) * ((double)10000000 / Stopwatch.Frequency)));
602      }
603      #region ChangeDatabase
604      [Test]
605      public async Task ChangeDatabase()
606      {
607          using var conn = await OpenConnectionAsync();
608          conn.ChangeDatabase(&quot;template1&quot;);
609          using var cmd = new NpgsqlCommand(&quot;select current_database()&quot;, conn);
610          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(&quot;template1&quot;));
611      }
612      [Test]
613      public async Task ChangeDatabase_does_not_affect_other_connections()
614      {
615          using var conn1 = new NpgsqlConnection(ConnectionString);
616          using var conn2 = new NpgsqlConnection(ConnectionString);
617          conn1.Open();
618          conn1.ChangeDatabase(&quot;template1&quot;);
619          Assert.That(await conn1.ExecuteScalarAsync(&quot;SELECT current_database()&quot;), Is.EqualTo(&quot;template1&quot;));
620          conn2.Open();
621          Assert.That(await conn2.ExecuteScalarAsync(&quot;SELECT current_database()&quot;), Is.Not.EqualTo(conn1.Database));
622      }
623      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1331&quot;)]
624      public void ChangeDatabase_connection_on_closed_connection_throws()
625      {
626          using var conn = new NpgsqlConnection(ConnectionString);
627          Assert.That(() =&gt; conn.ChangeDatabase(&quot;template1&quot;), Throws.Exception
628              .TypeOf&lt;InvalidOperationException&gt;()
629              .With.Message.EqualTo(&quot;Connection is not open&quot;));
630      }
631      #endregion
632      [Test, Description(&quot;Tests closing a connector while a reader is open&quot;)]
633      public async Task Close_during_read([Values(PooledOrNot.Pooled, PooledOrNot.Unpooled)] PooledOrNot pooled)
634      {
635          if (IsMultiplexing &amp;&amp; pooled == PooledOrNot.Unpooled)
636              return; 
637          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = pooled == PooledOrNot.Pooled);
638          await using var conn = await dataSource.OpenConnectionAsync();
639          await using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
640          await using (var reader = await cmd.ExecuteReaderAsync())
641          {
642              reader.Read();
643              conn.Close();
644              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
645              Assert.That(reader.IsClosed);
646          }
647          conn.Open();
648          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
649          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
650      }
651      [Test]
652      public async Task Search_path()
653      {
654          await using var dataSource = CreateDataSource(csb =&gt; csb.SearchPath = &quot;foo&quot;);
655          await using var conn = await dataSource.OpenConnectionAsync();
656          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW search_path&quot;), Contains.Substring(&quot;foo&quot;));
657      }
658      [Test]
659      public async Task Set_options()
660      {
661          await using var dataSource = CreateDataSource(csb =&gt;
662              csb.Options =
663                  &quot;-c default_transaction_isolation=serializable -c default_transaction_deferrable=on -c foo.bar=My\\ Famous\\\\Thing&quot;);
664          await using var conn = await dataSource.OpenConnectionAsync();
665          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_isolation&quot;), Is.EqualTo(&quot;serializable&quot;));
666          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_deferrable&quot;), Is.EqualTo(&quot;on&quot;));
667          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW foo.bar&quot;), Is.EqualTo(&quot;My Famous\\Thing&quot;));
668      }
669      [Test]
670      public async Task Connector_not_initialized_exception()
671      {
672          var command = new NpgsqlCommand();
673          command.CommandText = @&quot;SELECT 123&quot;;
674          for (var i = 0; i &lt; 2; i++)
675          {
676              await using var connection = await OpenConnectionAsync();
677              command.Connection = connection;
678              await using var tx = await connection.BeginTransactionAsync();
679              await command.ExecuteScalarAsync();
680              await tx.CommitAsync();
681          }
682      }
683      [Test]
684      public void Bug1011001()
685      {
686          var csb1 = new NpgsqlConnectionStringBuilder(@&quot;Server=server;Port=5432;User Id=user;Password=passwor;Database=database;&quot;);
687          var cs1 = csb1.ToString();
688          var csb2 = new NpgsqlConnectionStringBuilder(cs1);
689          var cs2 = csb2.ToString();
690          Assert.IsTrue(cs1 == cs2);
691      }
692      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/pull/164&quot;)]
693      public void Connection_State_is_Closed_when_disposed()
694      {
695          var c = new NpgsqlConnection();
696          c.Dispose();
697          Assert.AreEqual(ConnectionState.Closed, c.State);
698      }
699      [Test]
700      public void Change_ApplicationName_with_connection_string_builder()
701      {
702          var builder = new NpgsqlConnectionStringBuilder();
703          builder.ApplicationName = &quot;test&quot;;
704      }
705      [Test, Description(&quot;Makes sure notices are probably received and emitted as events&quot;)]
706      public async Task Notice()
707      {
708          await using var dataSource = CreateDataSource(csb =&gt; csb.Options = &quot;-c lc_messages=en_US.UTF-8&quot;);
709          await using var conn = await dataSource.OpenConnectionAsync();
710          var function = await GetTempFunctionName(conn);
711          await conn.ExecuteNonQueryAsync($@&quot;
712  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
713  &#x27;BEGIN RAISE NOTICE &#x27;&#x27;testnotice&#x27;&#x27;; END;&#x27;
714  LANGUAGE &#x27;plpgsql&#x27;&quot;);
715          var mre = new ManualResetEvent(false);
716          PostgresNotice? notice = null;
717          NoticeEventHandler action = (sender, args) =&gt;
718          {
719              notice = args.Notice;
720              mre.Set();
721          };
722          conn.Notice += action;
723          try
724          {
725              await conn.ExecuteNonQueryAsync($&quot;SELECT {function}()::TEXT&quot;);
726              mre.WaitOne(5000);
727              Assert.That(notice, Is.Not.Null, &quot;No notice was emitted&quot;);
728              Assert.That(notice!.MessageText, Is.EqualTo(&quot;testnotice&quot;));
729              Assert.That(notice.Severity, Is.EqualTo(&quot;NOTICE&quot;));
730          }
731          finally
732          {
733              conn.Notice -= action;
734          }
735      }
736      [Test, Description(&quot;Makes sure that concurrent use of the connection throws an exception&quot;)]
737      public async Task Concurrent_use_throws()
738      {
739          if (IsMultiplexing)
740              Assert.Ignore(&quot;Multiplexing: fails&quot;);
741          using var conn = await OpenConnectionAsync();
742          using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
743          using (await cmd.ExecuteReaderAsync())
744              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 2&quot;),
745                  Throws.Exception.TypeOf&lt;NpgsqlOperationInProgressException&gt;()
746                      .With.Property(nameof(NpgsqlOperationInProgressException.CommandInProgress)).SameAs(cmd));
747          await conn.ExecuteNonQueryAsync(&quot;CREATE TEMP TABLE foo (bar INT)&quot;);
748          using (conn.BeginBinaryImport(&quot;COPY foo (bar) FROM STDIN BINARY&quot;))
749          {
750              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 2&quot;),
751                  Throws.Exception.TypeOf&lt;NpgsqlOperationInProgressException&gt;()
752                      .With.Message.Contains(&quot;Copy&quot;));
753          }
754      }
755      #region PersistSecurityInfo
756      [Test]
757      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/783&quot;)]
758      public void PersistSecurityInfo_is_true([Values(true, false)] bool pooling)
759      {
760          if (IsMultiplexing &amp;&amp; !pooling)
761              return;
762          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
763          {
764              PersistSecurityInfo = true,
765              Pooling = pooling
766          }.ToString();
767          using var conn = new NpgsqlConnection(connString);
768          var passwd = new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password;
769          Assert.That(passwd, Is.Not.Null);
770          conn.Open();
771          Assert.That(new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password, Is.EqualTo(passwd));
772      }
773      [Test]
774      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/783&quot;)]
775      public void No_password_without_PersistSecurityInfo([Values(true, false)] bool pooling)
776      {
777          if (IsMultiplexing &amp;&amp; !pooling)
778              return;
779          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
780          {
781              Pooling = pooling
782          }.ToString();
783          using var conn = new NpgsqlConnection(connString);
784          var csb = new NpgsqlConnectionStringBuilder(conn.ConnectionString);
785          Assert.That(csb.PersistSecurityInfo, Is.False);
786          Assert.That(csb.Password, Is.Not.Null);
787          conn.Open();
788          Assert.That(new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password, Is.Null);
789      }
790      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2725&quot;)]
791      public void Clone_with_PersistSecurityInfo()
792      {
793          var builder = new NpgsqlConnectionStringBuilder(ConnectionString)
794          {
795              PersistSecurityInfo = true
796          };
797          using var _ = CreateTempPool(builder, out var connStringWithPersist);
798          using var connWithPersist = new NpgsqlConnection(connStringWithPersist);
799          builder.PersistSecurityInfo = false;
800          var connStringWithoutPersist = builder.ToString();
801          using var clonedWithoutPersist = connWithPersist.CloneWith(connStringWithoutPersist);
802          clonedWithoutPersist.Open();
803          Assert.That(clonedWithoutPersist.ConnectionString, Does.Not.Contain(&quot;Password=&quot;));
804          using var clonedConn = clonedWithoutPersist.CloneWith(connStringWithPersist);
805          clonedConn.Open();
806          Assert.That(clonedConn.ConnectionString, Does.Not.Contain(&quot;Password=&quot;));
807      }
808      [Test]
809      public async Task CloneWith_and_data_source_with_password()
810      {
811          var dataSourceBuilder = new NpgsqlDataSourceBuilder(ConnectionString);
812          var password = dataSourceBuilder.ConnectionStringBuilder.Password!;
813          dataSourceBuilder.ConnectionStringBuilder.Password = null;
814          await using var dataSource = dataSourceBuilder.Build();
815          await using var connection = dataSource.CreateConnection();
816          dataSource.Password = password;
817          using var _ = CreateTempPool(new NpgsqlConnectionStringBuilder(ConnectionString) { Password = null }, out var tempConnectionString);
818          await using var clonedConnection = connection.CloneWith(tempConnectionString);
819          await clonedConnection.OpenAsync();
820      }
821      [Test]
822      public async Task CloneWith_and_data_source_with_auth_callbacks()
823      {
824          var (userCertificateValidationCallbackCalled, clientCertificatesCallbackCalled) = (false, false);
825          var dataSourceBuilder = CreateDataSourceBuilder();
826          dataSourceBuilder.UseUserCertificateValidationCallback(UserCertificateValidationCallback);
827          dataSourceBuilder.UseClientCertificatesCallback(ClientCertificatesCallback);
828          await using var dataSource = dataSourceBuilder.Build();
829          await using var connection = dataSource.CreateConnection();
830          using var _ = CreateTempPool(ConnectionString, out var tempConnectionString);
831          await using var clonedConnection = connection.CloneWith(tempConnectionString);
832          clonedConnection.UserCertificateValidationCallback!(null!, null, null, SslPolicyErrors.None);
833          Assert.True(userCertificateValidationCallbackCalled);
834          clonedConnection.ProvideClientCertificatesCallback!(null!);
835          Assert.True(clientCertificatesCallbackCalled);
836          bool UserCertificateValidationCallback(object sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors errors)
837              =&gt; userCertificateValidationCallbackCalled = true;
838          void ClientCertificatesCallback(X509CertificateCollection certs)
839              =&gt; clientCertificatesCallbackCalled = true;
840      }
841      #endregion PersistSecurityInfo
842      [Test]
843      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/743&quot;)]
844      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/783&quot;)]
845      public void Clone()
846      {
847          using var pool = CreateTempPool(ConnectionString, out var connectionString);
848          using var conn = new NpgsqlConnection(connectionString);
849          ProvideClientCertificatesCallback callback1 = certificates =&gt; { };
850          conn.ProvideClientCertificatesCallback = callback1;
851          RemoteCertificateValidationCallback callback2 = (sender, certificate, chain, errors) =&gt; true;
852          conn.UserCertificateValidationCallback = callback2;
853          conn.Open();
854          Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
855          using var conn2 = (NpgsqlConnection)((ICloneable)conn).Clone();
856          Assert.That(conn2.ConnectionString, Is.EqualTo(conn.ConnectionString));
857          Assert.That(conn2.ProvideClientCertificatesCallback, Is.SameAs(callback1));
858          Assert.That(conn2.UserCertificateValidationCallback, Is.SameAs(callback2));
859          conn2.Open();
860          Assert.That(async () =&gt; await conn2.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
861      }
862      [Test]
863      public async Task Clone_with_data_source()
864      {
865          await using var connection = await SharedDataSource.OpenConnectionAsync();
866          await using var clonedConnection = (NpgsqlConnection)((ICloneable)connection).Clone();
867          Assert.That(clonedConnection.NpgsqlDataSource, Is.SameAs(SharedDataSource));
868          Assert.DoesNotThrowAsync(() =&gt; clonedConnection.OpenAsync());
869      }
870      [Test]
871      public async Task DatabaseInfo_is_shared()
872      {
873          if (IsMultiplexing)
874              return;
875          await using var dataSource = CreateDataSource();
876          await using var conn1 = await dataSource.OpenConnectionAsync();
877          conn1.ReloadTypes();
878          await using var conn2 = await dataSource.OpenConnectionAsync();
879          Assert.That(conn1.Connector!.DatabaseInfo, Is.SameAs(conn2.Connector!.DatabaseInfo));
880      }
881      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/736&quot;)]
882      public async Task ManyOpenClose()
883      {
884          await using var dataSource = CreateDataSource();
885          for (var i = 0; i &lt; 255; i++)
886          {
887              await using var conn = await dataSource.OpenConnectionAsync();
888          }
889          await using (var conn = dataSource.CreateConnection())
890          {
891              await conn.OpenAsync();
892          }
893          await using (var conn = dataSource.CreateConnection())
894          {
895              await conn.OpenAsync();
896              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
897          }
898      }
899      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/736&quot;)]
900      public async Task Many_open_close_with_transaction()
901      {
902          await using var dataSource = CreateDataSource();
903          for (var i = 0; i &lt; 255; i++)
904          {
905              await using var conn = await dataSource.OpenConnectionAsync();
906              await conn.BeginTransactionAsync();
907          }
908          await using (var conn = await dataSource.OpenConnectionAsync())
909              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
910      }
911      [Test]
912      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/927&quot;)]
913      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/736&quot;)]
914      [Ignore(&quot;Fails when running the entire test suite but not on its own...&quot;)]
915      public async Task Rollback_on_close()
916      {
917          await using var dataSource = CreateDataSource();
918          int processId;
919          await using (var conn = await dataSource.OpenConnectionAsync())
920          {
921              processId = conn.Connector!.BackendProcessId;
922              await conn.BeginTransactionAsync();
923              await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;);
924              Assert.That(conn.Connector.TransactionStatus, Is.EqualTo(TransactionStatus.InTransactionBlock));
925          }
926          await using (var conn = await dataSource.OpenConnectionAsync())
927          {
928              Assert.That(conn.Connector!.BackendProcessId, Is.EqualTo(processId));
929              Assert.That(conn.Connector.TransactionStatus, Is.EqualTo(TransactionStatus.Idle));
930          }
931      }
932      [Test, Description(&quot;Tests an exception happening when sending the Terminate message while closing a ready connector&quot;)]
933      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/777&quot;)]
934      public async Task Exception_during_close()
935      {
936          if (IsMultiplexing)
937              return;
938          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = false);
939          await using var conn = await dataSource.OpenConnectionAsync();
940          var connectorId = conn.ProcessID;
941          using (var conn2 = await OpenConnectionAsync())
942              await conn2.ExecuteNonQueryAsync($&quot;SELECT pg_terminate_backend({connectorId})&quot;);
943          conn.Close();
944      }
945      [Test, Description(&quot;Some pseudo-PG database don&#x27;t support pg_type loading, we have a minimal DatabaseInfo for this&quot;)]
946      public async Task NoTypeLoading()
947      {
948          await using var dataSource = CreateDataSource(csb =&gt; csb.ServerCompatibilityMode = ServerCompatibilityMode.NoTypeLoading);
949          await using var conn = await dataSource.OpenConnectionAsync();
950          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 8&quot;), Is.EqualTo(8));
951          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;foo&#x27;&quot;), Is.EqualTo(&quot;foo&quot;));
952          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT TRUE&quot;), Is.EqualTo(true));
953          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT INET &#x27;192.168.1.1&#x27;&quot;), Is.EqualTo(IPAddress.Parse(&quot;192.168.1.1&quot;)));
954          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;{1,2,3}&#x27;::int[]&quot;), Is.EqualTo(new[] { 1, 2, 3 }));
955          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;[1,10)&#x27;::int4range&quot;), Is.EqualTo(new NpgsqlRange&lt;int&gt;(1, true, 10, false)));
956          if (conn.PostgreSqlVersion &gt;= new Version(14, 0))
957          {
958              var multirangeArray = (NpgsqlRange&lt;int&gt;[])(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;{[3,7), (8,]}&#x27;::int4multirange&quot;))!;
959              Assert.That(multirangeArray.Length, Is.EqualTo(2));
960              Assert.That(multirangeArray[0], Is.EqualTo(new NpgsqlRange&lt;int&gt;(3, true, false, 7, false, false)));
961              Assert.That(multirangeArray[1], Is.EqualTo(new NpgsqlRange&lt;int&gt;(9, true, false, 0, false, true)));
962          }
963          else
964          {
965              using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn)
966              {
967                  Parameters = { new() { Value = DBNull.Value, NpgsqlDbType = NpgsqlDbType.IntegerMultirange } }
968              };
969              Assert.That(async () =&gt; await cmd.ExecuteScalarAsync(),
970                  Throws.Exception.TypeOf&lt;NpgsqlException&gt;()
971                      .With.Message.EqualTo(&quot;The NpgsqlDbType &#x27;IntegerMultirange&#x27; isn&#x27;t present in your database. You may need to install an extension or upgrade to a newer version.&quot;));
972          }
973      }
974      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1158&quot;)]
975      public async Task Table_named_record()
976      {
977          if (IsMultiplexing)
978              Assert.Ignore(&quot;Multiplexing, ReloadTypes&quot;);
979          using var conn = await OpenConnectionAsync();
980          await conn.ExecuteNonQueryAsync(@&quot;
981  DROP TABLE IF EXISTS record;
982  CREATE TABLE record ()&quot;);
983          try
984          {
985              conn.ReloadTypes();
986              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT COUNT(*) FROM record&quot;), Is.Zero);
987          }
988          finally
989          {
990              await conn.ExecuteNonQueryAsync(&quot;DROP TABLE record&quot;);
991          }
992      }
993      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/392&quot;)]
994      [NonParallelizable]
995      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Flaky in CI on Mac&quot;)]
996      public async Task Non_UTF8_Encoding()
997      {
998          Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
999          await using var adminConn = await OpenConnectionAsync();
1000          await adminConn.ExecuteNonQueryAsync(&quot;DROP DATABASE IF EXISTS sqlascii&quot;);
1001          await adminConn.ExecuteNonQueryAsync(
1002              adminConn.PostgreSqlVersion &gt;= new Version(15, 0)
1003                  ? &quot;CREATE DATABASE sqlascii ENCODING &#x27;sql_ascii&#x27; LOCALE_PROVIDER libc TEMPLATE template0&quot;
1004                  : &quot;CREATE DATABASE sqlascii ENCODING &#x27;sql_ascii&#x27; TEMPLATE template0&quot;);
1005          try
1006          {
1007              await using var goodDataSource = CreateDataSource(csb =&gt;
1008              {
1009                  csb.Database = &quot;sqlascii&quot;;
1010                  csb.Encoding = &quot;windows-1252&quot;;
1011                  csb.ClientEncoding = &quot;sql-ascii&quot;;
1012              });
1013              await using (var conn = await goodDataSource.OpenConnectionAsync())
1014              {
1015                  const string value = &quot;&quot;;
1016                  await conn.ExecuteNonQueryAsync(&quot;CREATE TABLE foo (bar TEXT)&quot;);
1017                  await conn.ExecuteNonQueryAsync($&quot;INSERT INTO foo (bar) VALUES (&#x27;{value}&#x27;)&quot;);
1018                  await using var cmd = conn.CreateCommand();
1019                  cmd.CommandText = &quot;SELECT * FROM foo&quot;;
1020                  await using var reader = await cmd.ExecuteReaderAsync();
1021                  Assert.IsTrue(await reader.ReadAsync());
1022                  using (var textReader = await reader.GetTextReaderAsync(0))
1023                      Assert.That(textReader.ReadToEnd(), Is.EqualTo(value));
1024                  Assert.That(reader.GetString(0), Is.EqualTo(value));
1025              }
1026              await using var badDataSource = CreateDataSource(csb =&gt; csb.Database = &quot;sqlascii&quot;);
1027              await using (var conn = await badDataSource.OpenConnectionAsync())
1028              {
1029                  Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT * FROM foo&quot;),
1030                      Throws.Exception.TypeOf&lt;PostgresException&gt;()
1031                          .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.CharacterNotInRepertoire)
1032                          .Or.TypeOf&lt;DecoderFallbackException&gt;()
1033                  );
1034              }
1035          }
1036          finally
1037          {
1038              await adminConn.ExecuteNonQueryAsync(&quot;DROP DATABASE IF EXISTS sqlascii&quot;);
1039          }
1040      }
1041      [Test]
1042      public async Task Oversize_buffer()
1043      {
1044          if (IsMultiplexing)
1045              return;
1046          await using var dataSource = CreateDataSource();
1047          await using var conn = await dataSource.OpenConnectionAsync();
1048          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
1049          Assert.That(conn.Connector!.ReadBuffer.Size, Is.EqualTo(csb.ReadBufferSize));
1050          var bigString1 = new string(&#x27;x&#x27;, conn.Connector.ReadBuffer.Size + 1);
1051          using (var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{bigString1}&#x27;&quot;, conn))
1052          using (var reader = await cmd.ExecuteReaderAsync())
1053          {
1054              reader.Read();
1055              Assert.That(reader.GetString(0), Is.EqualTo(bigString1));
1056          }
1057          var size1 = conn.Connector.ReadBuffer.Size;
1058          Assert.That(conn.Connector.ReadBuffer.Size, Is.GreaterThan(csb.ReadBufferSize));
1059          var bigString2 = new string(&#x27;x&#x27;, conn.Connector.ReadBuffer.Size + 1);
1060          using (var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{bigString2}&#x27;&quot;, conn))
1061          using (var reader = await cmd.ExecuteReaderAsync())
1062          {
1063              reader.Read();
1064              Assert.That(reader.GetString(0), Is.EqualTo(bigString2));
1065          }
1066          Assert.That(conn.Connector.ReadBuffer.Size, Is.GreaterThan(size1));
1067          var processId = conn.ProcessID;
1068          conn.Close();
1069          conn.Open();
1070          Assert.That(conn.ProcessID, Is.EqualTo(processId));
1071          Assert.That(conn.Connector.ReadBuffer.Size, Is.EqualTo(csb.ReadBufferSize));
1072      }
1073      #region Keepalive
1074      [Test, Explicit, Description(&quot;Turns on TCP keepalive and sleeps forever, good for wiresharking&quot;)]
1075      public async Task TcpKeepaliveTime()
1076      {
1077          await using var dataSource = CreateDataSource(csb =&gt; csb.TcpKeepAliveTime = 2);
1078          using (await dataSource.OpenConnectionAsync())
1079              Thread.Sleep(Timeout.Infinite);
1080      }
1081      [Test, Explicit, Description(&quot;Turns on TCP keepalive and sleeps forever, good for wiresharking&quot;)]
1082      public async Task TcpKeepalive()
1083      {
1084          await using var dataSource = CreateDataSource(csb =&gt; csb.TcpKeepAlive = true);
1085          await using (await dataSource.OpenConnectionAsync())
1086              Thread.Sleep(Timeout.Infinite);
1087      }
1088      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3511&quot;)]
1089      public async Task Keepalive_with_failed_transaction()
1090      {
1091          if (IsMultiplexing)
1092              return;
1093          await using var dataSource = CreateDataSource(csb =&gt; csb.KeepAlive = 1);
1094          await using var conn = await dataSource.OpenConnectionAsync();
1095          await using var tx = await conn.BeginTransactionAsync();
1096          Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT non_existent_table&quot;));
1097          Thread.Sleep(3000);
1098          await tx.RollbackAsync();
1099          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
1100      }
1101      #endregion Keepalive
1102      [Test]
1103      public async Task Change_parameter()
1104      {
1105          if (IsMultiplexing)
1106              return;
1107          using var conn = await OpenConnectionAsync();
1108          var defaultApplicationName = conn.PostgresParameters[&quot;application_name&quot;];
1109          await conn.ExecuteNonQueryAsync(&quot;SET application_name = &#x27;some_test_value&#x27;&quot;);
1110          Assert.That(conn.PostgresParameters[&quot;application_name&quot;], Is.EqualTo(&quot;some_test_value&quot;));
1111          await conn.ExecuteNonQueryAsync(&quot;SET application_name = &#x27;some_test_value2&#x27;&quot;);
1112          Assert.That(conn.PostgresParameters[&quot;application_name&quot;], Is.EqualTo(&quot;some_test_value2&quot;));
1113          await conn.ExecuteNonQueryAsync($&quot;SET application_name = &#x27;{defaultApplicationName}&#x27;&quot;);
1114          Assert.That(conn.PostgresParameters[&quot;application_name&quot;], Is.EqualTo(defaultApplicationName));
1115      }
1116      [Test]
1117      [NonParallelizable] 
1118      public async Task Connect_OptionsFromEnvironment_Succeeds()
1119      {
1120          using (SetEnvironmentVariable(&quot;PGOPTIONS&quot;, &quot;-c default_transaction_isolation=serializable -c default_transaction_deferrable=on -c foo.bar=My\\ Famous\\\\Thing&quot;))
1121          {
1122              await using var dataSource = CreateDataSource();
1123              await using var conn = await dataSource.OpenConnectionAsync();
1124              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_isolation&quot;), Is.EqualTo(&quot;serializable&quot;));
1125              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_deferrable&quot;), Is.EqualTo(&quot;on&quot;));
1126              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW foo.bar&quot;), Is.EqualTo(&quot;My Famous\\Thing&quot;));
1127          }
1128      }
1129      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3030&quot;)]
1130      [TestCase(true, TestName = &quot;NoResetOnClose&quot;)]
1131      [TestCase(false, TestName = &quot;NoNoResetOnClose&quot;)]
1132      public async Task NoResetOnClose(bool noResetOnClose)
1133      {
1134          var originalApplicationName = new NpgsqlConnectionStringBuilder(ConnectionString).ApplicationName ?? &quot;&quot;;
1135          await using var dataSource = CreateDataSource(csb =&gt;
1136          {
1137              csb.MaxPoolSize = 1;
1138              csb.NoResetOnClose = noResetOnClose;
1139          });
1140          await using var conn = await dataSource.OpenConnectionAsync();
1141          await conn.ExecuteNonQueryAsync(&quot;SET application_name = &#x27;modified&#x27;&quot;);
1142          await conn.CloseAsync();
1143          await conn.OpenAsync();
1144          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW application_name&quot;), Is.EqualTo(
1145              noResetOnClose || IsMultiplexing
1146                  ? &quot;modified&quot;
1147                  : originalApplicationName));
1148      }
1149      #region Physical connection initialization
1150      [Test]
1151      public async Task PhysicalConnectionInitializer_sync()
1152      {
1153          if (IsMultiplexing) 
1154              return;
1155          await using var adminConn = await OpenConnectionAsync();
1156          var table = await CreateTempTable(adminConn, &quot;ID INTEGER&quot;);
1157          var dataSourceBuilder = CreateDataSourceBuilder();
1158          dataSourceBuilder.UsePhysicalConnectionInitializer(
1159              conn =&gt; conn.ExecuteNonQuery($&quot;INSERT INTO {table} VALUES (1)&quot;),
1160              _ =&gt; throw new NotSupportedException());
1161          await using var dataSource = dataSourceBuilder.Build();
1162          await using (var conn = dataSource.OpenConnection())
1163          {
1164              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1165          }
1166          await using (var conn = dataSource.OpenConnection())
1167          {
1168              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1169          }
1170      }
1171      [Test]
1172      public async Task PhysicalConnectionInitializer_async()
1173      {
1174          if (IsMultiplexing)
1175              return;
1176          await using var adminConn = await OpenConnectionAsync();
1177          var table = await CreateTempTable(adminConn, &quot;ID INTEGER&quot;);
1178          var dataSourceBuilder = CreateDataSourceBuilder();
1179          dataSourceBuilder.UsePhysicalConnectionInitializer(
1180              _ =&gt; throw new NotSupportedException(),
1181              async conn =&gt; await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} VALUES (1)&quot;));
1182          await using var dataSource = dataSourceBuilder.Build();
1183          await using (var conn = await dataSource.OpenConnectionAsync())
1184          {
1185              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1186          }
1187          await using (var conn = await dataSource.OpenConnectionAsync())
1188          {
1189              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1190          }
1191      }
1192      [Test]
1193      public async Task PhysicalConnectionInitializer_sync_with_break()
1194      {
1195          if (IsMultiplexing) 
1196              return;
1197          var dataSourceBuilder = CreateDataSourceBuilder();
1198          dataSourceBuilder.UsePhysicalConnectionInitializer(
1199              conn =&gt;
1200              {
1201                  using (var conn2 = OpenConnection())
1202                      conn2.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
1203                  conn.ExecuteScalar(&quot;SELECT 1&quot;);
1204              },
1205              _ =&gt; throw new NotSupportedException());
1206          await using var dataSource = dataSourceBuilder.Build();
1207          Assert.That(() =&gt; dataSource.OpenConnection(), Throws.Exception.InstanceOf&lt;NpgsqlException&gt;());
1208          Assert.That(dataSource.Statistics, Is.EqualTo((0, 0, 0)));
1209      }
1210      [Test]
1211      public async Task PhysicalConnectionInitializer_async_with_break()
1212      {
1213          var dataSourceBuilder = CreateDataSourceBuilder();
1214          dataSourceBuilder.UsePhysicalConnectionInitializer(
1215              _ =&gt; throw new NotSupportedException(),
1216              async conn =&gt;
1217              {
1218                  await using (var conn2 = await OpenConnectionAsync())
1219                      await conn2.ExecuteNonQueryAsync($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
1220                  await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;);
1221              });
1222          await using var dataSource = dataSourceBuilder.Build();
1223          Assert.That(async () =&gt; await dataSource.OpenConnectionAsync(), Throws.Exception.InstanceOf&lt;NpgsqlException&gt;());
1224          Assert.That(dataSource.Statistics, Is.EqualTo((0, 0, 0)));
1225      }
1226      [Test]
1227      public async Task PhysicalConnectionInitializer_async_throws_on_second_open()
1228      {
1229          var count = 0;
1230          var dataSourceBuilder = CreateDataSourceBuilder();
1231          dataSourceBuilder.UsePhysicalConnectionInitializer(
1232              _ =&gt; throw new NotSupportedException(),
1233              _ =&gt;
1234              {
1235                  if (++count == 1)
1236                      return Task.CompletedTask;
1237                  throw new Exception(&quot;INTENTIONAL FAILURE&quot;);
1238              });
1239          await using var dataSource = dataSourceBuilder.Build();
1240          await using var conn1 = dataSource.CreateConnection();
1241          Assert.DoesNotThrowAsync(async () =&gt; await conn1.OpenAsync());
1242          await using var tx = await conn1.BeginTransactionAsync();
1243          await using var conn2 = dataSource.CreateConnection();
1244          Exception exception;
1245          if (IsMultiplexing)
1246          {
1247              await conn2.OpenAsync();
1248              exception = Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await conn2.BeginTransactionAsync())!;
1249          }
1250          else
1251              exception = Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await conn2.OpenAsync())!;
1252          Assert.That(exception.Message, Is.EqualTo(&quot;INTENTIONAL FAILURE&quot;));
1253      }
1254      [Test]
1255      public async Task PhysicalConnectionInitializer_disposes_connection()
1256      {
1257          NpgsqlConnection? initializerConnection = null;
1258          var dataSourceBuilder = CreateDataSourceBuilder();
1259          dataSourceBuilder.UsePhysicalConnectionInitializer(
1260              _ =&gt; throw new NotSupportedException(),
1261              conn =&gt;
1262              {
1263                  initializerConnection = conn;
1264                  return Task.CompletedTask;
1265              });
1266          await using var dataSource = dataSourceBuilder.Build();
1267          await using var conn = await dataSource.OpenConnectionAsync();
1268          Assert.That(initializerConnection, Is.Not.Null);
1269          Assert.That(conn, Is.Not.SameAs(initializerConnection));
1270          Assert.That(() =&gt; initializerConnection!.Open(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
1271      }
1272      #endregion Physical connection initialization
1273      [Test]
1274      [NonParallelizable] 
1275      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4425&quot;)]
1276      public async Task Breaking_connection_while_loading_database_info()
1277      {
1278          if (IsMultiplexing)
1279              return;
1280          await using var dataSource = CreateDataSource();
1281          await using var firstConn = dataSource.CreateConnection();
1282          NpgsqlDatabaseInfo.RegisterFactory(new BreakingDatabaseInfoFactory());
1283          try
1284          {
1285              Assert.ThrowsAsync&lt;IOException&gt;(firstConn.OpenAsync);
1286          }
1287          finally
1288          {
1289              NpgsqlDatabaseInfo.ResetFactories();
1290          }
1291          await firstConn.OpenAsync();
1292          await using var secondConn = await dataSource.OpenConnectionAsync();
1293          await secondConn.CloseAsync();
1294          await firstConn.ReloadTypesAsync();
1295          NpgsqlDatabaseInfo.RegisterFactory(new BreakingDatabaseInfoFactory());
1296          try
1297          {
1298              Assert.DoesNotThrowAsync(secondConn.OpenAsync);
1299          }
1300          finally
1301          {
1302              NpgsqlDatabaseInfo.ResetFactories();
1303          }
1304      }
1305      class BreakingDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
1306      {
1307          public Task&lt;NpgsqlDatabaseInfo?&gt; Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
1308              =&gt; throw conn.Break(new IOException());
1309      }
1310      #region Logging tests
1311      [Test]
1312      public async Task Log_Open_Close_pooled()
1313      {
1314          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1315          await using var conn = dataSource.CreateConnection();
1316          await conn.OpenAsync();
1317          await conn.CloseAsync();
1318          int processId, port;
1319          string host, database;
1320          using (listLoggerProvider.Record())
1321          {
1322              await conn.OpenAsync();
1323              var tx = await conn.BeginTransactionAsync();
1324              (processId, host, port, database) = (conn.ProcessID, conn.Host!, conn.Port, conn.Database);
1325              await tx.CommitAsync();
1326              await conn.CloseAsync();
1327          }
1328          var openingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpeningConnection);
1329          AssertLoggingConnectionString(conn, openingConnectionEvent.State);
1330          AssertLoggingStateContains(openingConnectionEvent, &quot;Host&quot;, host);
1331          AssertLoggingStateContains(openingConnectionEvent, &quot;Port&quot;, port);
1332          AssertLoggingStateContains(openingConnectionEvent, &quot;Database&quot;, database);
1333          var openedConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpenedConnection);
1334          AssertLoggingConnectionString(conn, openedConnectionEvent.State);
1335          AssertLoggingStateContains(openedConnectionEvent, &quot;Host&quot;, host);
1336          AssertLoggingStateContains(openedConnectionEvent, &quot;Port&quot;, port);
1337          AssertLoggingStateContains(openedConnectionEvent, &quot;Database&quot;, database);
1338          var closingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosingConnection);
1339          AssertLoggingConnectionString(conn, closingConnectionEvent.State);
1340          AssertLoggingStateContains(closingConnectionEvent, &quot;Host&quot;, host);
1341          AssertLoggingStateContains(closingConnectionEvent, &quot;Port&quot;, port);
1342          AssertLoggingStateContains(closingConnectionEvent, &quot;Database&quot;, database);
1343          var closedConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosedConnection);
1344          AssertLoggingConnectionString(conn, closedConnectionEvent.State);
1345          AssertLoggingStateContains(closedConnectionEvent, &quot;Host&quot;, host);
1346          AssertLoggingStateContains(closedConnectionEvent, &quot;Port&quot;, port);
1347          AssertLoggingStateContains(closedConnectionEvent, &quot;Database&quot;, database);
1348          if (!IsMultiplexing)
1349          {
1350              AssertLoggingStateContains(openedConnectionEvent, &quot;ConnectorId&quot;, processId);
1351              AssertLoggingStateContains(closingConnectionEvent, &quot;ConnectorId&quot;, processId);
1352              AssertLoggingStateContains(closedConnectionEvent, &quot;ConnectorId&quot;, processId);
1353          }
1354          var ids = new[]
1355          {
1356              NpgsqlEventId.OpeningPhysicalConnection,
1357              NpgsqlEventId.OpenedPhysicalConnection,
1358              NpgsqlEventId.ClosingPhysicalConnection,
1359              NpgsqlEventId.ClosedPhysicalConnection
1360          };
1361          foreach (var id in ids)
1362              Assert.That(listLoggerProvider.Log.Count(l =&gt; l.Id == id), Is.Zero);
1363      }
1364      [Test]
1365      public async Task Log_Open_Close_physical()
1366      {
1367          if (IsMultiplexing)
1368              return;
1369          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Pooling = false };
1370          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, csb.ToString());
1371          await using var conn = dataSource.CreateConnection();
1372          int processId, port;
1373          string host, database;
1374          using (listLoggerProvider.Record())
1375          {
1376              await conn.OpenAsync();
1377              (processId, host, port, database) = (conn.ProcessID, conn.Host!, conn.Port, conn.Database);
1378              await conn.CloseAsync();
1379          }
1380          var openingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpeningPhysicalConnection);
1381          AssertLoggingConnectionString(conn, openingConnectionEvent.State);
1382          AssertLoggingStateContains(openingConnectionEvent, &quot;Host&quot;, host);
1383          AssertLoggingStateContains(openingConnectionEvent, &quot;Port&quot;, port);
1384          AssertLoggingStateContains(openingConnectionEvent, &quot;Database&quot;, database);
1385          var openedConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpenedPhysicalConnection);
1386          AssertLoggingConnectionString(conn, openedConnectionEvent.State);
1387          AssertLoggingStateContains(openedConnectionEvent, &quot;ConnectorId&quot;, processId);
1388          AssertLoggingStateContains(openingConnectionEvent, &quot;Host&quot;, host);
1389          AssertLoggingStateContains(openingConnectionEvent, &quot;Port&quot;, port);
1390          AssertLoggingStateContains(openingConnectionEvent, &quot;Database&quot;, database);
1391          AssertLoggingStateContains(openedConnectionEvent, &quot;DurationMs&quot;);
1392          var closingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosingPhysicalConnection);
1393          AssertLoggingConnectionString(conn, closingConnectionEvent.State);
1394          AssertLoggingStateContains(closingConnectionEvent, &quot;ConnectorId&quot;, processId);
1395          AssertLoggingStateContains(closingConnectionEvent, &quot;Host&quot;, host);
1396          AssertLoggingStateContains(closingConnectionEvent, &quot;Port&quot;, port);
1397          AssertLoggingStateContains(closingConnectionEvent, &quot;Database&quot;, database);
1398          var closededConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosedPhysicalConnection);
1399          AssertLoggingConnectionString(conn, closededConnectionEvent.State);
1400          AssertLoggingStateContains(closededConnectionEvent, &quot;ConnectorId&quot;, processId);
1401          AssertLoggingStateContains(closededConnectionEvent, &quot;Host&quot;, host);
1402          AssertLoggingStateContains(closededConnectionEvent, &quot;Port&quot;, port);
1403          AssertLoggingStateContains(closededConnectionEvent, &quot;Database&quot;, database);
1404      }
1405      void AssertLoggingConnectionString(NpgsqlConnection connection, object? logState)
1406      {
1407          var keyValuePairs = (IEnumerable&lt;KeyValuePair&lt;string, object?&gt;&gt;)logState!;
1408          var connectionString = keyValuePairs.Single(kvp =&gt; kvp.Key == &quot;ConnectionString&quot;).Value;
1409          Assert.That(connectionString, Is.EqualTo(connection.ConnectionString));
1410          Assert.That(connectionString, Does.Not.Contain(&quot;Password&quot;));
1411      }
1412      #endregion Logging tests
1413      public ConnectionTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1414  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ConnectionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Data;
4  using System.Diagnostics;
5  using System.IO;
6  using System.Linq;
7  using System.Net;
8  using System.Net.Security;
9  using System.Runtime.InteropServices;
10  using System.Security.Cryptography.X509Certificates;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using Npgsql.Internal;
15  using Npgsql.PostgresTypes;
16  using Npgsql.Properties;
17  using Npgsql.Util;
18  using NpgsqlTypes;
19  using NUnit.Framework;
20  using static Npgsql.Tests.TestUtil;
21  namespace Npgsql.Tests;
22  public class ConnectionTests : MultiplexingTestBase
23  {
24      [Test, Description(&quot;Makes sure the connection goes through the proper state lifecycle&quot;)]
25      public async Task Basic_lifecycle()
26      {
27          await using var conn = CreateConnection();
28          var eventOpen = false;
29          var eventClosed = false;
30          conn.StateChange += (s, e) =&gt;
31          {
32              if (e.OriginalState == ConnectionState.Closed &amp;&amp;
33                  e.CurrentState == ConnectionState.Open)
34                  eventOpen = true;
35              if (e.OriginalState == ConnectionState.Open &amp;&amp;
36                  e.CurrentState == ConnectionState.Closed)
37                  eventClosed = true;
38          };
39          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
40          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
41          await conn.OpenAsync();
42          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
43          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
44          Assert.That(eventOpen, Is.True);
45          await using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
46          await using (var reader = await cmd.ExecuteReaderAsync())
47          {
48              await reader.ReadAsync();
49              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
50              Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
51          }
52          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
53          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
54          await conn.CloseAsync();
55          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
56          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
57          Assert.That(eventClosed, Is.True);
58      }
59      [Test, Description(&quot;Makes sure the connection goes through the proper state lifecycle&quot;)]
60      public async Task Broken_lifecycle([Values] bool openFromClose)
61      {
62          if (IsMultiplexing)
63              return;
64          await using var dataSource = CreateDataSource();
65          await using var conn = dataSource.CreateConnection();
66          var eventOpen = false;
67          var eventClosed = false;
68          conn.StateChange += (s, e) =&gt;
69          {
70              if (e.OriginalState == ConnectionState.Closed &amp;&amp;
71                  e.CurrentState == ConnectionState.Open)
72                  eventOpen = true;
73              if (e.OriginalState == ConnectionState.Open &amp;&amp;
74                  e.CurrentState == ConnectionState.Closed)
75                  eventClosed = true;
76          };
77          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
78          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
79          await conn.OpenAsync();
80          await using var transaction = await conn.BeginTransactionAsync();
81          Assert.That(conn.State, Is.EqualTo(ConnectionState.Open));
82          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
83          Assert.That(eventOpen, Is.True);
84          var sleep = conn.ExecuteNonQueryAsync(&quot;SELECT pg_sleep(5)&quot;);
85          await Task.Delay(1000);
86          await using (var killingConn = await OpenConnectionAsync())
87              killingConn.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
88          Assert.ThrowsAsync&lt;PostgresException&gt;(() =&gt; sleep);
89          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
90          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
91          Assert.That(eventClosed, Is.True);
92          Assert.That(conn.Connector is null);
93          Assert.AreEqual(0, conn.NpgsqlDataSource.Statistics.Total);
94          if (openFromClose)
95          {
96              await conn.CloseAsync();
97              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
98              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
99              Assert.That(eventClosed, Is.True);
100          }
101          Assert.DoesNotThrowAsync(conn.OpenAsync);
102          Assert.AreEqual(1, await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;));
103          Assert.AreEqual(1, conn.NpgsqlDataSource.Statistics.Total);
104          Assert.DoesNotThrowAsync(conn.CloseAsync);
105      }
106      [Test]
107      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Flaky on MacOS&quot;)]
108      public async Task Break_while_open()
109      {
110          if (IsMultiplexing)
111              return;
112          await using var dataSource = CreateDataSource();
113          await using var conn = await dataSource.OpenConnectionAsync();
114          using (var conn2 = await OpenConnectionAsync())
115              conn2.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
116          using (var cmd = CreateSleepCommand(conn, 10))
117              Assert.That(() =&gt; cmd.ExecuteNonQuery(), Throws.Exception
118                  .AssignableTo&lt;NpgsqlException&gt;());
119          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
120          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
121      }
122      #region Connection Errors
123  #if IGNORE
124      [Test]
125      [TestCase(true)]
126      [TestCase(false)]
127      public async Task Connection_refused(bool pooled)
128      {
129          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Port = 44444, Pooling = pooled };
130          using (var conn = new NpgsqlConnection(csb)) {
131              Assert.That(() =&gt; conn.Open(), Throws.Exception
132                  .TypeOf&lt;SocketException&gt;()
133                  .With.Property(nameof(SocketException.SocketErrorCode)).EqualTo(SocketError.ConnectionRefused)
134              );
135              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
136          }
137      }
138      [Test]
139      [TestCase(true)]
140      [TestCase(false)]
141      public async Task Connection_refused_async(bool pooled)
142      {
143          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Port = 44444, Pooling = pooled };
144          using (var conn = new NpgsqlConnection(csb))
145          {
146              Assert.That(async () =&gt; await conn.OpenAsync(), Throws.Exception
147                  .TypeOf&lt;SocketException&gt;()
148                  .With.Property(nameof(SocketException.SocketErrorCode)).EqualTo(SocketError.ConnectionRefused)
149              );
150              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
151          }
152      }
153  #endif
154      [Test]
155      [Ignore(&quot;Fails in a non-determinstic manner and only on the build server... investigate...&quot;)]
156      public void Invalid_Username()
157      {
158          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
159          {
160              Username = &quot;unknown&quot;, Pooling = false
161          }.ToString();
162          using var conn = new NpgsqlConnection(connString);
163          Assert.That(conn.Open, Throws.Exception
164              .TypeOf&lt;PostgresException&gt;()
165              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.InvalidPassword)
166          );
167          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Closed));
168      }
169      [Test]
170      public void Bad_database()
171      {
172          using var dataSource = CreateDataSource(csb =&gt; csb.Database = &quot;does_not_exist&quot;);
173          using var conn = dataSource.CreateConnection();
174          Assert.That(() =&gt; conn.Open(),
175              Throws.Exception.TypeOf&lt;PostgresException&gt;()
176                  .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.InvalidCatalogName)
177          );
178      }
179      [Test, Description(&quot;Tests that mandatory connection string parameters are indeed mandatory&quot;)]
180      public void Mandatory_connection_string_params()
181          =&gt; Assert.Throws&lt;ArgumentException&gt;(() =&gt;
182              new NpgsqlConnection(&quot;User ID=npgsql_tests;Password=npgsql_tests;Database=npgsql_tests&quot;));
183      [Test, Description(&quot;Reuses the same connection instance for a failed connection, then a successful one&quot;)]
184      public async Task Fail_connect_then_succeed([Values] bool pooling)
185      {
186          if (IsMultiplexing &amp;&amp; !pooling) 
187              return;
188          var dbName = GetUniqueIdentifier(nameof(Fail_connect_then_succeed));
189          await using var conn1 = await OpenConnectionAsync();
190          await conn1.ExecuteNonQueryAsync($&quot;DROP DATABASE IF EXISTS \&quot;{dbName}\&quot;&quot;);
191          try
192          {
193              await using var dataSource = CreateDataSource(csb =&gt;
194              {
195                  csb.Database = dbName;
196                  csb.Pooling = pooling;
197              });
198              await using var conn2 = dataSource.CreateConnection();
199              var pgEx = Assert.ThrowsAsync&lt;PostgresException&gt;(conn2.OpenAsync)!;
200              Assert.That(pgEx.SqlState, Is.EqualTo(PostgresErrorCodes.InvalidCatalogName)); 
201              Assert.That(conn2.FullState, Is.EqualTo(ConnectionState.Closed));
202              await conn1.ExecuteNonQueryAsync($&quot;CREATE DATABASE \&quot;{dbName}\&quot; TEMPLATE template0&quot;);
203              Assert.DoesNotThrowAsync(conn2.OpenAsync);
204              Assert.DoesNotThrowAsync(conn2.CloseAsync);
205          }
206          finally
207          {
208              await conn1.ExecuteNonQueryAsync($&quot;DROP DATABASE IF EXISTS \&quot;{dbName}\&quot;&quot;);
209          }
210      }
211      [Test]
212      public void Open_timeout_unknown_ip([Values(true, false)] bool async)
213      {
214          const int timeoutSeconds = 2;
215          var unknownIp = Environment.GetEnvironmentVariable(&quot;NPGSQL_UNKNOWN_IP&quot;);
216          if (unknownIp is null)
217          {
218              Assert.Ignore(&quot;NPGSQL_UNKNOWN_IP isn&#x27;t defined and is required for connection timeout tests&quot;);
219              return;
220          }
221          using var dataSource = CreateDataSource(csb =&gt;
222          {
223              csb.Host = unknownIp;
224              csb.Timeout = timeoutSeconds;
225          });
226          using var conn = dataSource.CreateConnection();
227          var sw = Stopwatch.StartNew();
228          if (async)
229          {
230              Assert.That(async () =&gt; await conn.OpenAsync(), Throws.Exception
231                  .TypeOf&lt;NpgsqlException&gt;()
232                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
233          }
234          else
235          {
236              Assert.That(() =&gt; conn.Open(), Throws.Exception
237                  .TypeOf&lt;NpgsqlException&gt;()
238                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
239          }
240          Assert.That(sw.Elapsed.TotalMilliseconds, Is.GreaterThanOrEqualTo(timeoutSeconds * 1000 - 100),
241              $&quot;Timeout was supposed to happen after {timeoutSeconds} seconds, but fired after {sw.Elapsed.TotalSeconds}&quot;);
242          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
243      }
244      [Test]
245      public void Connect_timeout_cancel()
246      {
247          var unknownIp = Environment.GetEnvironmentVariable(&quot;NPGSQL_UNKNOWN_IP&quot;);
248          if (unknownIp is null)
249          {
250              Assert.Ignore(&quot;NPGSQL_UNKNOWN_IP isn&#x27;t defined and is required for connection cancellation tests&quot;);
251              return;
252          }
253          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
254          {
255              Host = unknownIp,
256              Pooling = false,
257              Timeout = 30
258          }.ToString();
259          using var conn = new NpgsqlConnection(connString);
260          var cts = new CancellationTokenSource(1000);
261          Assert.That(async () =&gt; await conn.OpenAsync(cts.Token), Throws.Exception.TypeOf&lt;OperationCanceledException&gt;());
262          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
263      }
264      #endregion
265      #region Client Encoding
266      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1065&quot;)]
267      public async Task Client_encoding_is_UTF8_by_default()
268      {
269          using var conn = await OpenConnectionAsync();
270          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.EqualTo(&quot;UTF8&quot;));
271      }
272      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1065&quot;)]
273      [NonParallelizable] 
274      public async Task Client_encoding_env_var()
275      {
276          using (var testConn = await OpenConnectionAsync())
277              Assert.That(await testConn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.Not.EqualTo(&quot;SQL_ASCII&quot;));
278          using var _ = SetEnvironmentVariable(&quot;PGCLIENTENCODING&quot;, &quot;SQL_ASCII&quot;);
279          await using var dataSource = CreateDataSource();
280          await using var conn = await dataSource.OpenConnectionAsync();
281          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.EqualTo(&quot;SQL_ASCII&quot;));
282      }
283      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1065&quot;)]
284      public async Task Client_encoding_connection_param()
285      {
286          using (var conn = await OpenConnectionAsync())
287              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.Not.EqualTo(&quot;SQL_ASCII&quot;));
288          await using var dataSource = CreateDataSource(csb =&gt; csb.ClientEncoding = &quot;SQL_ASCII&quot;);
289          using (var conn = await dataSource.OpenConnectionAsync())
290              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW client_encoding&quot;), Is.EqualTo(&quot;SQL_ASCII&quot;));
291      }
292      #endregion Client Encoding
293      #region Timezone
294      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1634&quot;)]
295      [NonParallelizable] 
296      public async Task Timezone_env_var()
297      {
298          string newTimezone;
299          using (var conn1 = await OpenConnectionAsync())
300          {
301              newTimezone = (string?)await conn1.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;) == &quot;Africa/Bamako&quot;
302                  ? &quot;Africa/Lagos&quot;
303                  : &quot;Africa/Bamako&quot;;
304          }
305          using var _ = SetEnvironmentVariable(&quot;PGTZ&quot;, newTimezone);
306          await using var dataSource = CreateDataSource();
307          using var conn2 = await dataSource.OpenConnectionAsync();
308          Assert.That(await conn2.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;), Is.EqualTo(newTimezone));
309      }
310      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1634&quot;)]
311      public async Task Timezone_connection_param()
312      {
313          string newTimezone;
<span onclick='openModal()' class='match'>314          using (var conn = await OpenConnectionAsync())
315          {
316              newTimezone = (string?)await conn.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;) == &quot;Africa/Bamako&quot;
317                  ? &quot;Africa/Lagos&quot;
318                  : &quot;Africa/Bamako&quot;;
319          }
320          await using var dataSource = CreateDataSource(csb =&gt; csb.Timezone = newTimezone);
</span>321          using (var conn = await dataSource.OpenConnectionAsync())
322              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;), Is.EqualTo(newTimezone));
323      }
324      #endregion Timezone
325      #region ConnectionString - Host
326      [TestCase(&quot;127.0.0.1&quot;, ExpectedResult = new [] { &quot;127.0.0.1:5432&quot; })]
327      [TestCase(&quot;127.0.0.1:5432&quot;, ExpectedResult = new [] { &quot;127.0.0.1:5432&quot; })]
328      [TestCase(&quot;::1&quot;, ExpectedResult = new [] { &quot;::1:5432&quot; })]
329      [TestCase(&quot;[::1]&quot;, ExpectedResult = new [] { &quot;[::1]:5432&quot; })]
330      [TestCase(&quot;[::1]:5432&quot;, ExpectedResult = new [] { &quot;[::1]:5432&quot; })]
331      [TestCase(&quot;localhost&quot;, ExpectedResult = new [] { &quot;localhost:5432&quot; })]
332      [TestCase(&quot;localhost:5432&quot;, ExpectedResult = new [] { &quot;localhost:5432&quot; })]
333      [TestCase(&quot;127.0.0.1,127.0.0.1:5432,::1,[::1],[::1]:5432,localhost,localhost:5432&quot;,
334          ExpectedResult = new []
335          {
336              &quot;127.0.0.1:5432&quot;,
337              &quot;127.0.0.1:5432&quot;,
338              &quot;::1:5432&quot;,
339              &quot;[::1]:5432&quot;,
340              &quot;[::1]:5432&quot;,
341              &quot;localhost:5432&quot;,
342              &quot;localhost:5432&quot;
343          })]
344      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3802&quot;)]
345      public string[] ConnectionString_Host(string host)
346      {
347          var dataSourceBuilder = new NpgsqlDataSourceBuilder
348          {
349              ConnectionStringBuilder = { Host = host }
350          };
351          using var dataSource = dataSourceBuilder.BuildMultiHost();
352          return dataSource.Pools.Select(ds =&gt; $&quot;{ds.Settings.Host}:{ds.Settings.Port}&quot;).ToArray()!;
353      }
354      #endregion ConnectionString - Host
355      [Test]
356      public async Task Unix_domain_socket()
357      {
358          if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
359          {
360              if (Environment.OSVersion.Version.Major &lt; 10 || Environment.OSVersion.Version.Build &lt; 17093)
361                  Assert.Ignore(&quot;Unix-domain sockets support was introduced in Windows build 17093&quot;);
362              using var versionConnection = await OpenConnectionAsync();
363              MinimumPgVersion(versionConnection, &quot;13.0&quot;, &quot;Unix-domain sockets support on Windows was introduced in PostgreSQL 13&quot;);
364          }
365          var port = new NpgsqlConnectionStringBuilder(ConnectionString).Port;
366          var candidateDirectories = new[] { &quot;/var/run/postgresql&quot;, &quot;/tmp&quot;, Environment.GetEnvironmentVariable(&quot;TMP&quot;) ?? &quot;C:\\&quot; };
367          var dir = candidateDirectories.FirstOrDefault(d =&gt; File.Exists(Path.Combine(d, $&quot;.s.PGSQL.{port}&quot;)));
368          if (dir == null)
369          {
370              IgnoreExceptOnBuildServer(&quot;No PostgreSQL unix domain socket was found&quot;);
371              return;
372          }
373          try
374          {
375              await using var dataSource = CreateDataSource(csb =&gt; csb.Host = dir);
376              await using var conn = await dataSource.OpenConnectionAsync();
377              await using var tx = await conn.BeginTransactionAsync();
378              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;, tx), Is.EqualTo(1));
379              Assert.That(conn.DataSource, Is.EqualTo(Path.Combine(dir, $&quot;.s.PGSQL.{port}&quot;)));
380          }
381          catch (Exception ex)
382          {
383              IgnoreExceptOnBuildServer($&quot;Connection via unix domain socket failed: {ex}&quot;);
384          }
385      }
386      [Test]
387      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Fails only on mac, needs to be investigated&quot;)]
388      public async Task Unix_abstract_domain_socket()
389      {
390          if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
391          {
392              Assert.Ignore(&quot;Abstract unix-domain sockets are not supported on windows&quot;);
393          }
394          using var versionConnection = await OpenConnectionAsync();
395          MinimumPgVersion(versionConnection, &quot;14.0&quot;, &quot;Abstract unix-domain sockets support was introduced in PostgreSQL 14&quot;);
396          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
397          {
398              Host = &quot;@/npgsql_unix&quot;
399          };
400          try
401          {
402              await using var dataSource = CreateDataSource(csb.ToString());
403              await using var conn = await dataSource.OpenConnectionAsync();
404              await using var tx = await conn.BeginTransactionAsync();
405              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;, tx), Is.EqualTo(1));
406              Assert.That(conn.DataSource, Is.EqualTo(Path.Combine(csb.Host, $&quot;.s.PGSQL.{csb.Port}&quot;)));
407          }
408          catch (Exception ex)
409          {
410              IgnoreExceptOnBuildServer($&quot;Connection via abstract unix domain socket failed: {ex}&quot;);
411          }
412      }
413      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/903&quot;)]
414      public void DataSource_property()
415      {
416          using var conn = new NpgsqlConnection();
417          Assert.That(conn.DataSource, Is.EqualTo(string.Empty));
418          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
419          conn.ConnectionString = csb.ConnectionString;
420          Assert.That(conn.DataSource, Is.EqualTo($&quot;tcp:&amp;bsol;&amp;bsol;{csb.Host}:{csb.Port}&quot;));
421          if (IsMultiplexing)
422              return;
423          csb.Host = &quot;127.0.0.1, 127.0.0.2&quot;;
424          conn.ConnectionString = csb.ConnectionString;
425          Assert.That(conn.DataSource, Is.EqualTo(string.Empty));
426      }
427      #region Server version
428      [Test]
429      public async Task PostgreSqlVersion_ServerVersion()
430      {
431          await using var c = new NpgsqlConnection(ConnectionString);
432          Assert.That(() =&gt; c.PostgreSqlVersion, Throws.InvalidOperationException
433              .With.Message.EqualTo(&quot;Connection is not open&quot;));
434          Assert.That(() =&gt; c.ServerVersion, Throws.InvalidOperationException
435              .With.Message.EqualTo(&quot;Connection is not open&quot;));
436          await c.OpenAsync();
437          var backendVersionString = (string)(await c.ExecuteScalarAsync(&quot;SHOW server_version&quot;))!;
438          Assert.That(backendVersionString, Is.EqualTo(c.ServerVersion));
439          Assert.That(backendVersionString, Does.Contain(
440              new[] { &quot;rc&quot;, &quot;beta&quot;, &quot;devel&quot; }.Any(x =&gt; backendVersionString.Contains(x))
441                  ? c.PostgreSqlVersion.Major.ToString()
442                  : c.PostgreSqlVersion.ToString()));
443      }
444      [TestCase(&quot;X13.0&quot;)]
445      [TestCase(&quot;13.&quot;)]
446      [TestCase(&quot;13.1.&quot;)]
447      [TestCase(&quot;13.1.1.&quot;)]
448      [TestCase(&quot;13.1.1.1.&quot;)]
449      [TestCase(&quot;13.1.1.1.1&quot;)]
450      public void ParseVersion_fails(string versionString)
451          =&gt; Assert.That(() =&gt; TestDbInfo.ParseServerVersion(versionString), Throws.Exception);
452      [TestCase(&quot;13.3&quot;, ExpectedResult = &quot;13.3&quot;)]
453      [TestCase(&quot;13.3X&quot;, ExpectedResult = &quot;13.3&quot;)]
454      [TestCase(&quot;9.6.4&quot;, ExpectedResult = &quot;9.6.4&quot;)]
455      [TestCase(&quot;9.6.4X&quot;, ExpectedResult = &quot;9.6.4&quot;)]
456      [TestCase(&quot;9.5alpha2&quot;, ExpectedResult = &quot;9.5&quot;)]
457      [TestCase(&quot;9.5alpha2X&quot;, ExpectedResult = &quot;9.5&quot;)]
458      [TestCase(&quot;9.5devel&quot;, ExpectedResult = &quot;9.5&quot;)]
459      [TestCase(&quot;9.5develX&quot;, ExpectedResult = &quot;9.5&quot;)]
460      [TestCase(&quot;9.5deveX&quot;, ExpectedResult = &quot;9.5&quot;)]
461      [TestCase(&quot;9.4beta3&quot;, ExpectedResult = &quot;9.4&quot;)]
462      [TestCase(&quot;9.4rc1&quot;, ExpectedResult = &quot;9.4&quot;)]
463      [TestCase(&quot;9.4rc1X&quot;, ExpectedResult = &quot;9.4&quot;)]
464      [TestCase(&quot;13devel&quot;, ExpectedResult = &quot;13.0&quot;)]
465      [TestCase(&quot;13beta1&quot;, ExpectedResult = &quot;13.0&quot;)]
466      [TestCase(&quot;13&quot;, ExpectedResult = &quot;13.0&quot;)]
467      [TestCase(&quot;13X&quot;, ExpectedResult = &quot;13.0&quot;)]
468      [TestCase(&quot;13alpha1&quot;, ExpectedResult = &quot;13.0&quot;)]
469      [TestCase(&quot;13alpha&quot;, ExpectedResult = &quot;13.0&quot;)]
470      [TestCase(&quot;13alphX&quot;, ExpectedResult = &quot;13.0&quot;)]
471      [TestCase(&quot;13beta&quot;, ExpectedResult = &quot;13.0&quot;)]
472      [TestCase(&quot;13betX&quot;, ExpectedResult = &quot;13.0&quot;)]
473      [TestCase(&quot;13rc1&quot;, ExpectedResult = &quot;13.0&quot;)]
474      [TestCase(&quot;13rc&quot;, ExpectedResult = &quot;13.0&quot;)]
475      [TestCase(&quot;13rX&quot;, ExpectedResult = &quot;13.0&quot;)]
476      [TestCase(&quot;99999.99999.99999.99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
477      [TestCase(&quot;99999.99999.99999.99999X&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
478      [TestCase(&quot;99999.99999.99999.99999devel&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
479      [TestCase(&quot;99999.99999.99999.99999alpha99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
480      [TestCase(&quot;99999.99999.99999alpha99999&quot;, ExpectedResult = &quot;99999.99999.99999&quot;)]
481      [TestCase(&quot;99999.99999.99999.99999beta99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
482      [TestCase(&quot;99999.99999.99999beta99999&quot;, ExpectedResult = &quot;99999.99999.99999&quot;)]
483      [TestCase(&quot;99999.99999.99999.99999rc99999&quot;, ExpectedResult = &quot;99999.99999.99999.99999&quot;)]
484      [TestCase(&quot;99999.99999.99999rc99999&quot;, ExpectedResult = &quot;99999.99999.99999&quot;)]
485      public string ParseVersion_succeeds(string versionString)
486          =&gt; TestDbInfo.ParseServerVersion(versionString).ToString();
487      class TestDbInfo : NpgsqlDatabaseInfo
488      {
489          public TestDbInfo(string host, int port, string databaseName, Version version) : base(host, port, databaseName, version)
490              =&gt; throw new NotImplementedException();
491          protected override IEnumerable&lt;PostgresType&gt; GetTypes()
492              =&gt; throw new NotImplementedException();
493          public new static Version ParseServerVersion(string versionString)
494              =&gt; NpgsqlDatabaseInfo.ParseServerVersion(versionString);
495      }
496      #endregion Server version
497      [Test]
498      public void Setting_connection_string_while_open_throws()
499      {
500          using var conn = new NpgsqlConnection();
501          conn.ConnectionString = ConnectionString;
502          conn.Open();
503          Assert.That(() =&gt; conn.ConnectionString = &quot;&quot;, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
504      }
505      [Test]
506      public void Empty_constructor()
507      {
508          var conn = new NpgsqlConnection();
509          Assert.That(conn.ConnectionTimeout, Is.EqualTo(NpgsqlConnectionStringBuilder.DefaultTimeout));
510          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
511          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
512      }
513      [Test]
514      public void Constructor_with_null_connection_string()
515      {
516          var conn = new NpgsqlConnection(null);
517          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
518          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
519      }
520      [Test]
521      public void Constructor_with_empty_connection_string()
522      {
523          var conn = new NpgsqlConnection(&quot;&quot;);
524          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
525          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
526      }
527      [Test]
528      public void Set_connection_string_to_null()
529      {
530          var conn = new NpgsqlConnection(ConnectionString);
531          conn.ConnectionString = null;
532          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
533          Assert.That(conn.Settings.Host, Is.Null);
534          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
535      }
536      [Test]
537      public void Set_connection_string_to_empty()
538      {
539          var conn = new NpgsqlConnection(ConnectionString);
540          conn.ConnectionString = &quot;&quot;;
541          Assert.That(conn.ConnectionString, Is.SameAs(string.Empty));
542          Assert.That(conn.Settings.Host, Is.Null);
543          Assert.That(() =&gt; conn.Open(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
544      }
545      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/703&quot;)]
546      public async Task No_database_defaults_to_username()
547      {
548          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Database = null };
549          using var conn = new NpgsqlConnection(csb.ToString());
550          Assert.That(conn.Database, Is.EqualTo(csb.Username));
551          conn.Open();
552          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT current_database()&quot;), Is.EqualTo(csb.Username));
553          Assert.That(conn.Database, Is.EqualTo(csb.Username));
554      }
555      [Test, Description(&quot;Breaks a connector while it&#x27;s in the pool, with a keepalive and without&quot;)]
556      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Fails only on mac, needs to be investigated&quot;)]
557      [TestCase(false, TestName = nameof(Break_connector_in_pool) + &quot;_without_keep_alive&quot;)]
558      [TestCase(true, TestName = nameof(Break_connector_in_pool) + &quot;_with_keep_alive&quot;)]
559      public async Task Break_connector_in_pool(bool keepAlive)
560      {
561          if (IsMultiplexing)
562              Assert.Ignore(&quot;Multiplexing, hanging&quot;);
563          var dataSourceBuilder = CreateDataSourceBuilder();
564          dataSourceBuilder.ConnectionStringBuilder.MaxPoolSize = 1;
565          if (keepAlive)
566              dataSourceBuilder.ConnectionStringBuilder.KeepAlive = 1;
567          await using var dataSource = dataSourceBuilder.Build();
568          await using var conn = await dataSource.OpenConnectionAsync();
569          var connector = conn.Connector;
570          Assert.That(connector, Is.Not.Null);
571          await conn.CloseAsync();
572          await using (var conn2 = await OpenConnectionAsync())
573              await conn2.ExecuteNonQueryAsync($&quot;SELECT pg_terminate_backend({connector!.BackendProcessId})&quot;);
574          await Task.Delay(3000);
575          await conn.OpenAsync();
576          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
577          if (keepAlive)
578          {
579              Assert.That(conn.Connector, Is.Not.SameAs(connector));
580              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
581          }
582          else
583          {
584              Assert.That(conn.Connector, Is.SameAs(connector));
585              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Throws.Exception
586                  .AssignableTo&lt;NpgsqlException&gt;());
587          }
588      }
589      [Test]
590      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4603&quot;)]
591      public async Task Reload_types_keepalive_concurrent()
592      {
593          if (IsMultiplexing)
594              Assert.Ignore(&quot;Multiplexing doesn&#x27;t support keepalive&quot;);
595          await using var dataSource = CreateDataSource(csb =&gt; csb.KeepAlive = 1);
596          await using var conn = await dataSource.OpenConnectionAsync();
597          var startTimestamp = Stopwatch.GetTimestamp();
598          while (GetElapsedTime(startTimestamp).TotalSeconds &lt; 2)
599              Assert.DoesNotThrow(conn.ReloadTypes);
600          static TimeSpan GetElapsedTime(long startingTimestamp) =&gt;
601              new((long)((Stopwatch.GetTimestamp() - startingTimestamp) * ((double)10000000 / Stopwatch.Frequency)));
602      }
603      #region ChangeDatabase
604      [Test]
605      public async Task ChangeDatabase()
606      {
607          using var conn = await OpenConnectionAsync();
608          conn.ChangeDatabase(&quot;template1&quot;);
609          using var cmd = new NpgsqlCommand(&quot;select current_database()&quot;, conn);
610          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(&quot;template1&quot;));
611      }
612      [Test]
613      public async Task ChangeDatabase_does_not_affect_other_connections()
614      {
615          using var conn1 = new NpgsqlConnection(ConnectionString);
616          using var conn2 = new NpgsqlConnection(ConnectionString);
617          conn1.Open();
618          conn1.ChangeDatabase(&quot;template1&quot;);
619          Assert.That(await conn1.ExecuteScalarAsync(&quot;SELECT current_database()&quot;), Is.EqualTo(&quot;template1&quot;));
620          conn2.Open();
621          Assert.That(await conn2.ExecuteScalarAsync(&quot;SELECT current_database()&quot;), Is.Not.EqualTo(conn1.Database));
622      }
623      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1331&quot;)]
624      public void ChangeDatabase_connection_on_closed_connection_throws()
625      {
626          using var conn = new NpgsqlConnection(ConnectionString);
627          Assert.That(() =&gt; conn.ChangeDatabase(&quot;template1&quot;), Throws.Exception
628              .TypeOf&lt;InvalidOperationException&gt;()
629              .With.Message.EqualTo(&quot;Connection is not open&quot;));
630      }
631      #endregion
632      [Test, Description(&quot;Tests closing a connector while a reader is open&quot;)]
633      public async Task Close_during_read([Values(PooledOrNot.Pooled, PooledOrNot.Unpooled)] PooledOrNot pooled)
634      {
635          if (IsMultiplexing &amp;&amp; pooled == PooledOrNot.Unpooled)
636              return; 
637          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = pooled == PooledOrNot.Pooled);
638          await using var conn = await dataSource.OpenConnectionAsync();
639          await using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
640          await using (var reader = await cmd.ExecuteReaderAsync())
641          {
642              reader.Read();
643              conn.Close();
644              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
645              Assert.That(reader.IsClosed);
646          }
647          conn.Open();
648          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
649          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
650      }
651      [Test]
652      public async Task Search_path()
653      {
654          await using var dataSource = CreateDataSource(csb =&gt; csb.SearchPath = &quot;foo&quot;);
655          await using var conn = await dataSource.OpenConnectionAsync();
656          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW search_path&quot;), Contains.Substring(&quot;foo&quot;));
657      }
658      [Test]
659      public async Task Set_options()
660      {
661          await using var dataSource = CreateDataSource(csb =&gt;
662              csb.Options =
663                  &quot;-c default_transaction_isolation=serializable -c default_transaction_deferrable=on -c foo.bar=My\\ Famous\\\\Thing&quot;);
664          await using var conn = await dataSource.OpenConnectionAsync();
665          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_isolation&quot;), Is.EqualTo(&quot;serializable&quot;));
666          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_deferrable&quot;), Is.EqualTo(&quot;on&quot;));
667          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW foo.bar&quot;), Is.EqualTo(&quot;My Famous\\Thing&quot;));
668      }
669      [Test]
670      public async Task Connector_not_initialized_exception()
671      {
672          var command = new NpgsqlCommand();
673          command.CommandText = @&quot;SELECT 123&quot;;
674          for (var i = 0; i &lt; 2; i++)
675          {
676              await using var connection = await OpenConnectionAsync();
677              command.Connection = connection;
678              await using var tx = await connection.BeginTransactionAsync();
679              await command.ExecuteScalarAsync();
680              await tx.CommitAsync();
681          }
682      }
683      [Test]
684      public void Bug1011001()
685      {
686          var csb1 = new NpgsqlConnectionStringBuilder(@&quot;Server=server;Port=5432;User Id=user;Password=passwor;Database=database;&quot;);
687          var cs1 = csb1.ToString();
688          var csb2 = new NpgsqlConnectionStringBuilder(cs1);
689          var cs2 = csb2.ToString();
690          Assert.IsTrue(cs1 == cs2);
691      }
692      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/pull/164&quot;)]
693      public void Connection_State_is_Closed_when_disposed()
694      {
695          var c = new NpgsqlConnection();
696          c.Dispose();
697          Assert.AreEqual(ConnectionState.Closed, c.State);
698      }
699      [Test]
700      public void Change_ApplicationName_with_connection_string_builder()
701      {
702          var builder = new NpgsqlConnectionStringBuilder();
703          builder.ApplicationName = &quot;test&quot;;
704      }
705      [Test, Description(&quot;Makes sure notices are probably received and emitted as events&quot;)]
706      public async Task Notice()
707      {
708          await using var dataSource = CreateDataSource(csb =&gt; csb.Options = &quot;-c lc_messages=en_US.UTF-8&quot;);
709          await using var conn = await dataSource.OpenConnectionAsync();
710          var function = await GetTempFunctionName(conn);
711          await conn.ExecuteNonQueryAsync($@&quot;
712  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
713  &#x27;BEGIN RAISE NOTICE &#x27;&#x27;testnotice&#x27;&#x27;; END;&#x27;
714  LANGUAGE &#x27;plpgsql&#x27;&quot;);
715          var mre = new ManualResetEvent(false);
716          PostgresNotice? notice = null;
717          NoticeEventHandler action = (sender, args) =&gt;
718          {
719              notice = args.Notice;
720              mre.Set();
721          };
722          conn.Notice += action;
723          try
724          {
725              await conn.ExecuteNonQueryAsync($&quot;SELECT {function}()::TEXT&quot;);
726              mre.WaitOne(5000);
727              Assert.That(notice, Is.Not.Null, &quot;No notice was emitted&quot;);
728              Assert.That(notice!.MessageText, Is.EqualTo(&quot;testnotice&quot;));
729              Assert.That(notice.Severity, Is.EqualTo(&quot;NOTICE&quot;));
730          }
731          finally
732          {
733              conn.Notice -= action;
734          }
735      }
736      [Test, Description(&quot;Makes sure that concurrent use of the connection throws an exception&quot;)]
737      public async Task Concurrent_use_throws()
738      {
739          if (IsMultiplexing)
740              Assert.Ignore(&quot;Multiplexing: fails&quot;);
741          using var conn = await OpenConnectionAsync();
742          using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
743          using (await cmd.ExecuteReaderAsync())
744              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 2&quot;),
745                  Throws.Exception.TypeOf&lt;NpgsqlOperationInProgressException&gt;()
746                      .With.Property(nameof(NpgsqlOperationInProgressException.CommandInProgress)).SameAs(cmd));
747          await conn.ExecuteNonQueryAsync(&quot;CREATE TEMP TABLE foo (bar INT)&quot;);
748          using (conn.BeginBinaryImport(&quot;COPY foo (bar) FROM STDIN BINARY&quot;))
749          {
750              Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 2&quot;),
751                  Throws.Exception.TypeOf&lt;NpgsqlOperationInProgressException&gt;()
752                      .With.Message.Contains(&quot;Copy&quot;));
753          }
754      }
755      #region PersistSecurityInfo
756      [Test]
757      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/783&quot;)]
758      public void PersistSecurityInfo_is_true([Values(true, false)] bool pooling)
759      {
760          if (IsMultiplexing &amp;&amp; !pooling)
761              return;
762          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
763          {
764              PersistSecurityInfo = true,
765              Pooling = pooling
766          }.ToString();
767          using var conn = new NpgsqlConnection(connString);
768          var passwd = new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password;
769          Assert.That(passwd, Is.Not.Null);
770          conn.Open();
771          Assert.That(new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password, Is.EqualTo(passwd));
772      }
773      [Test]
774      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/783&quot;)]
775      public void No_password_without_PersistSecurityInfo([Values(true, false)] bool pooling)
776      {
777          if (IsMultiplexing &amp;&amp; !pooling)
778              return;
779          var connString = new NpgsqlConnectionStringBuilder(ConnectionString)
780          {
781              Pooling = pooling
782          }.ToString();
783          using var conn = new NpgsqlConnection(connString);
784          var csb = new NpgsqlConnectionStringBuilder(conn.ConnectionString);
785          Assert.That(csb.PersistSecurityInfo, Is.False);
786          Assert.That(csb.Password, Is.Not.Null);
787          conn.Open();
788          Assert.That(new NpgsqlConnectionStringBuilder(conn.ConnectionString).Password, Is.Null);
789      }
790      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2725&quot;)]
791      public void Clone_with_PersistSecurityInfo()
792      {
793          var builder = new NpgsqlConnectionStringBuilder(ConnectionString)
794          {
795              PersistSecurityInfo = true
796          };
797          using var _ = CreateTempPool(builder, out var connStringWithPersist);
798          using var connWithPersist = new NpgsqlConnection(connStringWithPersist);
799          builder.PersistSecurityInfo = false;
800          var connStringWithoutPersist = builder.ToString();
801          using var clonedWithoutPersist = connWithPersist.CloneWith(connStringWithoutPersist);
802          clonedWithoutPersist.Open();
803          Assert.That(clonedWithoutPersist.ConnectionString, Does.Not.Contain(&quot;Password=&quot;));
804          using var clonedConn = clonedWithoutPersist.CloneWith(connStringWithPersist);
805          clonedConn.Open();
806          Assert.That(clonedConn.ConnectionString, Does.Not.Contain(&quot;Password=&quot;));
807      }
808      [Test]
809      public async Task CloneWith_and_data_source_with_password()
810      {
811          var dataSourceBuilder = new NpgsqlDataSourceBuilder(ConnectionString);
812          var password = dataSourceBuilder.ConnectionStringBuilder.Password!;
813          dataSourceBuilder.ConnectionStringBuilder.Password = null;
814          await using var dataSource = dataSourceBuilder.Build();
815          await using var connection = dataSource.CreateConnection();
816          dataSource.Password = password;
817          using var _ = CreateTempPool(new NpgsqlConnectionStringBuilder(ConnectionString) { Password = null }, out var tempConnectionString);
818          await using var clonedConnection = connection.CloneWith(tempConnectionString);
819          await clonedConnection.OpenAsync();
820      }
821      [Test]
822      public async Task CloneWith_and_data_source_with_auth_callbacks()
823      {
824          var (userCertificateValidationCallbackCalled, clientCertificatesCallbackCalled) = (false, false);
825          var dataSourceBuilder = CreateDataSourceBuilder();
826          dataSourceBuilder.UseUserCertificateValidationCallback(UserCertificateValidationCallback);
827          dataSourceBuilder.UseClientCertificatesCallback(ClientCertificatesCallback);
828          await using var dataSource = dataSourceBuilder.Build();
829          await using var connection = dataSource.CreateConnection();
830          using var _ = CreateTempPool(ConnectionString, out var tempConnectionString);
831          await using var clonedConnection = connection.CloneWith(tempConnectionString);
832          clonedConnection.UserCertificateValidationCallback!(null!, null, null, SslPolicyErrors.None);
833          Assert.True(userCertificateValidationCallbackCalled);
834          clonedConnection.ProvideClientCertificatesCallback!(null!);
835          Assert.True(clientCertificatesCallbackCalled);
836          bool UserCertificateValidationCallback(object sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors errors)
837              =&gt; userCertificateValidationCallbackCalled = true;
838          void ClientCertificatesCallback(X509CertificateCollection certs)
839              =&gt; clientCertificatesCallbackCalled = true;
840      }
841      #endregion PersistSecurityInfo
842      [Test]
843      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/743&quot;)]
844      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/783&quot;)]
845      public void Clone()
846      {
847          using var pool = CreateTempPool(ConnectionString, out var connectionString);
848          using var conn = new NpgsqlConnection(connectionString);
849          ProvideClientCertificatesCallback callback1 = certificates =&gt; { };
850          conn.ProvideClientCertificatesCallback = callback1;
851          RemoteCertificateValidationCallback callback2 = (sender, certificate, chain, errors) =&gt; true;
852          conn.UserCertificateValidationCallback = callback2;
853          conn.Open();
854          Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
855          using var conn2 = (NpgsqlConnection)((ICloneable)conn).Clone();
856          Assert.That(conn2.ConnectionString, Is.EqualTo(conn.ConnectionString));
857          Assert.That(conn2.ProvideClientCertificatesCallback, Is.SameAs(callback1));
858          Assert.That(conn2.UserCertificateValidationCallback, Is.SameAs(callback2));
859          conn2.Open();
860          Assert.That(async () =&gt; await conn2.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
861      }
862      [Test]
863      public async Task Clone_with_data_source()
864      {
865          await using var connection = await SharedDataSource.OpenConnectionAsync();
866          await using var clonedConnection = (NpgsqlConnection)((ICloneable)connection).Clone();
867          Assert.That(clonedConnection.NpgsqlDataSource, Is.SameAs(SharedDataSource));
868          Assert.DoesNotThrowAsync(() =&gt; clonedConnection.OpenAsync());
869      }
870      [Test]
871      public async Task DatabaseInfo_is_shared()
872      {
873          if (IsMultiplexing)
874              return;
875          await using var dataSource = CreateDataSource();
876          await using var conn1 = await dataSource.OpenConnectionAsync();
877          conn1.ReloadTypes();
878          await using var conn2 = await dataSource.OpenConnectionAsync();
879          Assert.That(conn1.Connector!.DatabaseInfo, Is.SameAs(conn2.Connector!.DatabaseInfo));
880      }
881      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/736&quot;)]
882      public async Task ManyOpenClose()
883      {
884          await using var dataSource = CreateDataSource();
885          for (var i = 0; i &lt; 255; i++)
886          {
887              await using var conn = await dataSource.OpenConnectionAsync();
888          }
889          await using (var conn = dataSource.CreateConnection())
890          {
891              await conn.OpenAsync();
892          }
893          await using (var conn = dataSource.CreateConnection())
894          {
895              await conn.OpenAsync();
896              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
897          }
898      }
899      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/736&quot;)]
900      public async Task Many_open_close_with_transaction()
901      {
902          await using var dataSource = CreateDataSource();
903          for (var i = 0; i &lt; 255; i++)
904          {
905              await using var conn = await dataSource.OpenConnectionAsync();
906              await conn.BeginTransactionAsync();
907          }
908          await using (var conn = await dataSource.OpenConnectionAsync())
909              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
910      }
911      [Test]
912      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/927&quot;)]
913      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/736&quot;)]
914      [Ignore(&quot;Fails when running the entire test suite but not on its own...&quot;)]
915      public async Task Rollback_on_close()
916      {
917          await using var dataSource = CreateDataSource();
918          int processId;
919          await using (var conn = await dataSource.OpenConnectionAsync())
920          {
921              processId = conn.Connector!.BackendProcessId;
922              await conn.BeginTransactionAsync();
923              await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;);
924              Assert.That(conn.Connector.TransactionStatus, Is.EqualTo(TransactionStatus.InTransactionBlock));
925          }
926          await using (var conn = await dataSource.OpenConnectionAsync())
927          {
928              Assert.That(conn.Connector!.BackendProcessId, Is.EqualTo(processId));
929              Assert.That(conn.Connector.TransactionStatus, Is.EqualTo(TransactionStatus.Idle));
930          }
931      }
932      [Test, Description(&quot;Tests an exception happening when sending the Terminate message while closing a ready connector&quot;)]
933      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/777&quot;)]
934      public async Task Exception_during_close()
935      {
936          if (IsMultiplexing)
937              return;
938          await using var dataSource = CreateDataSource(csb =&gt; csb.Pooling = false);
939          await using var conn = await dataSource.OpenConnectionAsync();
940          var connectorId = conn.ProcessID;
941          using (var conn2 = await OpenConnectionAsync())
942              await conn2.ExecuteNonQueryAsync($&quot;SELECT pg_terminate_backend({connectorId})&quot;);
943          conn.Close();
944      }
945      [Test, Description(&quot;Some pseudo-PG database don&#x27;t support pg_type loading, we have a minimal DatabaseInfo for this&quot;)]
946      public async Task NoTypeLoading()
947      {
948          await using var dataSource = CreateDataSource(csb =&gt; csb.ServerCompatibilityMode = ServerCompatibilityMode.NoTypeLoading);
949          await using var conn = await dataSource.OpenConnectionAsync();
950          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 8&quot;), Is.EqualTo(8));
951          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;foo&#x27;&quot;), Is.EqualTo(&quot;foo&quot;));
952          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT TRUE&quot;), Is.EqualTo(true));
953          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT INET &#x27;192.168.1.1&#x27;&quot;), Is.EqualTo(IPAddress.Parse(&quot;192.168.1.1&quot;)));
954          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;{1,2,3}&#x27;::int[]&quot;), Is.EqualTo(new[] { 1, 2, 3 }));
955          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;[1,10)&#x27;::int4range&quot;), Is.EqualTo(new NpgsqlRange&lt;int&gt;(1, true, 10, false)));
956          if (conn.PostgreSqlVersion &gt;= new Version(14, 0))
957          {
958              var multirangeArray = (NpgsqlRange&lt;int&gt;[])(await conn.ExecuteScalarAsync(&quot;SELECT &#x27;{[3,7), (8,]}&#x27;::int4multirange&quot;))!;
959              Assert.That(multirangeArray.Length, Is.EqualTo(2));
960              Assert.That(multirangeArray[0], Is.EqualTo(new NpgsqlRange&lt;int&gt;(3, true, false, 7, false, false)));
961              Assert.That(multirangeArray[1], Is.EqualTo(new NpgsqlRange&lt;int&gt;(9, true, false, 0, false, true)));
962          }
963          else
964          {
965              using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn)
966              {
967                  Parameters = { new() { Value = DBNull.Value, NpgsqlDbType = NpgsqlDbType.IntegerMultirange } }
968              };
969              Assert.That(async () =&gt; await cmd.ExecuteScalarAsync(),
970                  Throws.Exception.TypeOf&lt;NpgsqlException&gt;()
971                      .With.Message.EqualTo(&quot;The NpgsqlDbType &#x27;IntegerMultirange&#x27; isn&#x27;t present in your database. You may need to install an extension or upgrade to a newer version.&quot;));
972          }
973      }
974      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1158&quot;)]
975      public async Task Table_named_record()
976      {
977          if (IsMultiplexing)
978              Assert.Ignore(&quot;Multiplexing, ReloadTypes&quot;);
979          using var conn = await OpenConnectionAsync();
980          await conn.ExecuteNonQueryAsync(@&quot;
981  DROP TABLE IF EXISTS record;
982  CREATE TABLE record ()&quot;);
983          try
984          {
985              conn.ReloadTypes();
986              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT COUNT(*) FROM record&quot;), Is.Zero);
987          }
988          finally
989          {
990              await conn.ExecuteNonQueryAsync(&quot;DROP TABLE record&quot;);
991          }
992      }
993      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/392&quot;)]
994      [NonParallelizable]
995      [Platform(Exclude = &quot;MacOsX&quot;, Reason = &quot;Flaky in CI on Mac&quot;)]
996      public async Task Non_UTF8_Encoding()
997      {
998          Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
999          await using var adminConn = await OpenConnectionAsync();
1000          await adminConn.ExecuteNonQueryAsync(&quot;DROP DATABASE IF EXISTS sqlascii&quot;);
1001          await adminConn.ExecuteNonQueryAsync(
1002              adminConn.PostgreSqlVersion &gt;= new Version(15, 0)
1003                  ? &quot;CREATE DATABASE sqlascii ENCODING &#x27;sql_ascii&#x27; LOCALE_PROVIDER libc TEMPLATE template0&quot;
1004                  : &quot;CREATE DATABASE sqlascii ENCODING &#x27;sql_ascii&#x27; TEMPLATE template0&quot;);
1005          try
1006          {
1007              await using var goodDataSource = CreateDataSource(csb =&gt;
1008              {
1009                  csb.Database = &quot;sqlascii&quot;;
1010                  csb.Encoding = &quot;windows-1252&quot;;
1011                  csb.ClientEncoding = &quot;sql-ascii&quot;;
1012              });
1013              await using (var conn = await goodDataSource.OpenConnectionAsync())
1014              {
1015                  const string value = &quot;&quot;;
1016                  await conn.ExecuteNonQueryAsync(&quot;CREATE TABLE foo (bar TEXT)&quot;);
1017                  await conn.ExecuteNonQueryAsync($&quot;INSERT INTO foo (bar) VALUES (&#x27;{value}&#x27;)&quot;);
1018                  await using var cmd = conn.CreateCommand();
1019                  cmd.CommandText = &quot;SELECT * FROM foo&quot;;
1020                  await using var reader = await cmd.ExecuteReaderAsync();
1021                  Assert.IsTrue(await reader.ReadAsync());
1022                  using (var textReader = await reader.GetTextReaderAsync(0))
1023                      Assert.That(textReader.ReadToEnd(), Is.EqualTo(value));
1024                  Assert.That(reader.GetString(0), Is.EqualTo(value));
1025              }
1026              await using var badDataSource = CreateDataSource(csb =&gt; csb.Database = &quot;sqlascii&quot;);
1027              await using (var conn = await badDataSource.OpenConnectionAsync())
1028              {
1029                  Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT * FROM foo&quot;),
1030                      Throws.Exception.TypeOf&lt;PostgresException&gt;()
1031                          .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.CharacterNotInRepertoire)
1032                          .Or.TypeOf&lt;DecoderFallbackException&gt;()
1033                  );
1034              }
1035          }
1036          finally
1037          {
1038              await adminConn.ExecuteNonQueryAsync(&quot;DROP DATABASE IF EXISTS sqlascii&quot;);
1039          }
1040      }
1041      [Test]
1042      public async Task Oversize_buffer()
1043      {
1044          if (IsMultiplexing)
1045              return;
1046          await using var dataSource = CreateDataSource();
1047          await using var conn = await dataSource.OpenConnectionAsync();
1048          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
1049          Assert.That(conn.Connector!.ReadBuffer.Size, Is.EqualTo(csb.ReadBufferSize));
1050          var bigString1 = new string(&#x27;x&#x27;, conn.Connector.ReadBuffer.Size + 1);
1051          using (var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{bigString1}&#x27;&quot;, conn))
1052          using (var reader = await cmd.ExecuteReaderAsync())
1053          {
1054              reader.Read();
1055              Assert.That(reader.GetString(0), Is.EqualTo(bigString1));
1056          }
1057          var size1 = conn.Connector.ReadBuffer.Size;
1058          Assert.That(conn.Connector.ReadBuffer.Size, Is.GreaterThan(csb.ReadBufferSize));
1059          var bigString2 = new string(&#x27;x&#x27;, conn.Connector.ReadBuffer.Size + 1);
1060          using (var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{bigString2}&#x27;&quot;, conn))
1061          using (var reader = await cmd.ExecuteReaderAsync())
1062          {
1063              reader.Read();
1064              Assert.That(reader.GetString(0), Is.EqualTo(bigString2));
1065          }
1066          Assert.That(conn.Connector.ReadBuffer.Size, Is.GreaterThan(size1));
1067          var processId = conn.ProcessID;
1068          conn.Close();
1069          conn.Open();
1070          Assert.That(conn.ProcessID, Is.EqualTo(processId));
1071          Assert.That(conn.Connector.ReadBuffer.Size, Is.EqualTo(csb.ReadBufferSize));
1072      }
1073      #region Keepalive
1074      [Test, Explicit, Description(&quot;Turns on TCP keepalive and sleeps forever, good for wiresharking&quot;)]
1075      public async Task TcpKeepaliveTime()
1076      {
1077          await using var dataSource = CreateDataSource(csb =&gt; csb.TcpKeepAliveTime = 2);
1078          using (await dataSource.OpenConnectionAsync())
1079              Thread.Sleep(Timeout.Infinite);
1080      }
1081      [Test, Explicit, Description(&quot;Turns on TCP keepalive and sleeps forever, good for wiresharking&quot;)]
1082      public async Task TcpKeepalive()
1083      {
1084          await using var dataSource = CreateDataSource(csb =&gt; csb.TcpKeepAlive = true);
1085          await using (await dataSource.OpenConnectionAsync())
1086              Thread.Sleep(Timeout.Infinite);
1087      }
1088      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3511&quot;)]
1089      public async Task Keepalive_with_failed_transaction()
1090      {
1091          if (IsMultiplexing)
1092              return;
1093          await using var dataSource = CreateDataSource(csb =&gt; csb.KeepAlive = 1);
1094          await using var conn = await dataSource.OpenConnectionAsync();
1095          await using var tx = await conn.BeginTransactionAsync();
1096          Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT non_existent_table&quot;));
1097          Thread.Sleep(3000);
1098          await tx.RollbackAsync();
1099          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
1100      }
1101      #endregion Keepalive
1102      [Test]
1103      public async Task Change_parameter()
1104      {
1105          if (IsMultiplexing)
1106              return;
1107          using var conn = await OpenConnectionAsync();
1108          var defaultApplicationName = conn.PostgresParameters[&quot;application_name&quot;];
1109          await conn.ExecuteNonQueryAsync(&quot;SET application_name = &#x27;some_test_value&#x27;&quot;);
1110          Assert.That(conn.PostgresParameters[&quot;application_name&quot;], Is.EqualTo(&quot;some_test_value&quot;));
1111          await conn.ExecuteNonQueryAsync(&quot;SET application_name = &#x27;some_test_value2&#x27;&quot;);
1112          Assert.That(conn.PostgresParameters[&quot;application_name&quot;], Is.EqualTo(&quot;some_test_value2&quot;));
1113          await conn.ExecuteNonQueryAsync($&quot;SET application_name = &#x27;{defaultApplicationName}&#x27;&quot;);
1114          Assert.That(conn.PostgresParameters[&quot;application_name&quot;], Is.EqualTo(defaultApplicationName));
1115      }
1116      [Test]
1117      [NonParallelizable] 
1118      public async Task Connect_OptionsFromEnvironment_Succeeds()
1119      {
1120          using (SetEnvironmentVariable(&quot;PGOPTIONS&quot;, &quot;-c default_transaction_isolation=serializable -c default_transaction_deferrable=on -c foo.bar=My\\ Famous\\\\Thing&quot;))
1121          {
1122              await using var dataSource = CreateDataSource();
1123              await using var conn = await dataSource.OpenConnectionAsync();
1124              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_isolation&quot;), Is.EqualTo(&quot;serializable&quot;));
1125              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW default_transaction_deferrable&quot;), Is.EqualTo(&quot;on&quot;));
1126              Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW foo.bar&quot;), Is.EqualTo(&quot;My Famous\\Thing&quot;));
1127          }
1128      }
1129      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3030&quot;)]
1130      [TestCase(true, TestName = &quot;NoResetOnClose&quot;)]
1131      [TestCase(false, TestName = &quot;NoNoResetOnClose&quot;)]
1132      public async Task NoResetOnClose(bool noResetOnClose)
1133      {
1134          var originalApplicationName = new NpgsqlConnectionStringBuilder(ConnectionString).ApplicationName ?? &quot;&quot;;
1135          await using var dataSource = CreateDataSource(csb =&gt;
1136          {
1137              csb.MaxPoolSize = 1;
1138              csb.NoResetOnClose = noResetOnClose;
1139          });
1140          await using var conn = await dataSource.OpenConnectionAsync();
1141          await conn.ExecuteNonQueryAsync(&quot;SET application_name = &#x27;modified&#x27;&quot;);
1142          await conn.CloseAsync();
1143          await conn.OpenAsync();
1144          Assert.That(await conn.ExecuteScalarAsync(&quot;SHOW application_name&quot;), Is.EqualTo(
1145              noResetOnClose || IsMultiplexing
1146                  ? &quot;modified&quot;
1147                  : originalApplicationName));
1148      }
1149      #region Physical connection initialization
1150      [Test]
1151      public async Task PhysicalConnectionInitializer_sync()
1152      {
1153          if (IsMultiplexing) 
1154              return;
1155          await using var adminConn = await OpenConnectionAsync();
1156          var table = await CreateTempTable(adminConn, &quot;ID INTEGER&quot;);
1157          var dataSourceBuilder = CreateDataSourceBuilder();
1158          dataSourceBuilder.UsePhysicalConnectionInitializer(
1159              conn =&gt; conn.ExecuteNonQuery($&quot;INSERT INTO {table} VALUES (1)&quot;),
1160              _ =&gt; throw new NotSupportedException());
1161          await using var dataSource = dataSourceBuilder.Build();
1162          await using (var conn = dataSource.OpenConnection())
1163          {
1164              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1165          }
1166          await using (var conn = dataSource.OpenConnection())
1167          {
1168              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1169          }
1170      }
1171      [Test]
1172      public async Task PhysicalConnectionInitializer_async()
1173      {
1174          if (IsMultiplexing)
1175              return;
1176          await using var adminConn = await OpenConnectionAsync();
1177          var table = await CreateTempTable(adminConn, &quot;ID INTEGER&quot;);
1178          var dataSourceBuilder = CreateDataSourceBuilder();
1179          dataSourceBuilder.UsePhysicalConnectionInitializer(
1180              _ =&gt; throw new NotSupportedException(),
1181              async conn =&gt; await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} VALUES (1)&quot;));
1182          await using var dataSource = dataSourceBuilder.Build();
1183          await using (var conn = await dataSource.OpenConnectionAsync())
1184          {
1185              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1186          }
1187          await using (var conn = await dataSource.OpenConnectionAsync())
1188          {
1189              Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT COUNT(*) FROM \&quot;{table}\&quot;&quot;), Is.EqualTo(1));
1190          }
1191      }
1192      [Test]
1193      public async Task PhysicalConnectionInitializer_sync_with_break()
1194      {
1195          if (IsMultiplexing) 
1196              return;
1197          var dataSourceBuilder = CreateDataSourceBuilder();
1198          dataSourceBuilder.UsePhysicalConnectionInitializer(
1199              conn =&gt;
1200              {
1201                  using (var conn2 = OpenConnection())
1202                      conn2.ExecuteNonQuery($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
1203                  conn.ExecuteScalar(&quot;SELECT 1&quot;);
1204              },
1205              _ =&gt; throw new NotSupportedException());
1206          await using var dataSource = dataSourceBuilder.Build();
1207          Assert.That(() =&gt; dataSource.OpenConnection(), Throws.Exception.InstanceOf&lt;NpgsqlException&gt;());
1208          Assert.That(dataSource.Statistics, Is.EqualTo((0, 0, 0)));
1209      }
1210      [Test]
1211      public async Task PhysicalConnectionInitializer_async_with_break()
1212      {
1213          var dataSourceBuilder = CreateDataSourceBuilder();
1214          dataSourceBuilder.UsePhysicalConnectionInitializer(
1215              _ =&gt; throw new NotSupportedException(),
1216              async conn =&gt;
1217              {
1218                  await using (var conn2 = await OpenConnectionAsync())
1219                      await conn2.ExecuteNonQueryAsync($&quot;SELECT pg_terminate_backend({conn.ProcessID})&quot;);
1220                  await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;);
1221              });
1222          await using var dataSource = dataSourceBuilder.Build();
1223          Assert.That(async () =&gt; await dataSource.OpenConnectionAsync(), Throws.Exception.InstanceOf&lt;NpgsqlException&gt;());
1224          Assert.That(dataSource.Statistics, Is.EqualTo((0, 0, 0)));
1225      }
1226      [Test]
1227      public async Task PhysicalConnectionInitializer_async_throws_on_second_open()
1228      {
1229          var count = 0;
1230          var dataSourceBuilder = CreateDataSourceBuilder();
1231          dataSourceBuilder.UsePhysicalConnectionInitializer(
1232              _ =&gt; throw new NotSupportedException(),
1233              _ =&gt;
1234              {
1235                  if (++count == 1)
1236                      return Task.CompletedTask;
1237                  throw new Exception(&quot;INTENTIONAL FAILURE&quot;);
1238              });
1239          await using var dataSource = dataSourceBuilder.Build();
1240          await using var conn1 = dataSource.CreateConnection();
1241          Assert.DoesNotThrowAsync(async () =&gt; await conn1.OpenAsync());
1242          await using var tx = await conn1.BeginTransactionAsync();
1243          await using var conn2 = dataSource.CreateConnection();
1244          Exception exception;
1245          if (IsMultiplexing)
1246          {
1247              await conn2.OpenAsync();
1248              exception = Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await conn2.BeginTransactionAsync())!;
1249          }
1250          else
1251              exception = Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt; await conn2.OpenAsync())!;
1252          Assert.That(exception.Message, Is.EqualTo(&quot;INTENTIONAL FAILURE&quot;));
1253      }
1254      [Test]
1255      public async Task PhysicalConnectionInitializer_disposes_connection()
1256      {
1257          NpgsqlConnection? initializerConnection = null;
1258          var dataSourceBuilder = CreateDataSourceBuilder();
1259          dataSourceBuilder.UsePhysicalConnectionInitializer(
1260              _ =&gt; throw new NotSupportedException(),
1261              conn =&gt;
1262              {
1263                  initializerConnection = conn;
1264                  return Task.CompletedTask;
1265              });
1266          await using var dataSource = dataSourceBuilder.Build();
1267          await using var conn = await dataSource.OpenConnectionAsync();
1268          Assert.That(initializerConnection, Is.Not.Null);
1269          Assert.That(conn, Is.Not.SameAs(initializerConnection));
1270          Assert.That(() =&gt; initializerConnection!.Open(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
1271      }
1272      #endregion Physical connection initialization
1273      [Test]
1274      [NonParallelizable] 
1275      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4425&quot;)]
1276      public async Task Breaking_connection_while_loading_database_info()
1277      {
1278          if (IsMultiplexing)
1279              return;
1280          await using var dataSource = CreateDataSource();
1281          await using var firstConn = dataSource.CreateConnection();
1282          NpgsqlDatabaseInfo.RegisterFactory(new BreakingDatabaseInfoFactory());
1283          try
1284          {
1285              Assert.ThrowsAsync&lt;IOException&gt;(firstConn.OpenAsync);
1286          }
1287          finally
1288          {
1289              NpgsqlDatabaseInfo.ResetFactories();
1290          }
1291          await firstConn.OpenAsync();
1292          await using var secondConn = await dataSource.OpenConnectionAsync();
1293          await secondConn.CloseAsync();
1294          await firstConn.ReloadTypesAsync();
1295          NpgsqlDatabaseInfo.RegisterFactory(new BreakingDatabaseInfoFactory());
1296          try
1297          {
1298              Assert.DoesNotThrowAsync(secondConn.OpenAsync);
1299          }
1300          finally
1301          {
1302              NpgsqlDatabaseInfo.ResetFactories();
1303          }
1304      }
1305      class BreakingDatabaseInfoFactory : INpgsqlDatabaseInfoFactory
1306      {
1307          public Task&lt;NpgsqlDatabaseInfo?&gt; Load(NpgsqlConnector conn, NpgsqlTimeout timeout, bool async)
1308              =&gt; throw conn.Break(new IOException());
1309      }
1310      #region Logging tests
1311      [Test]
1312      public async Task Log_Open_Close_pooled()
1313      {
1314          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1315          await using var conn = dataSource.CreateConnection();
1316          await conn.OpenAsync();
1317          await conn.CloseAsync();
1318          int processId, port;
1319          string host, database;
1320          using (listLoggerProvider.Record())
1321          {
1322              await conn.OpenAsync();
1323              var tx = await conn.BeginTransactionAsync();
1324              (processId, host, port, database) = (conn.ProcessID, conn.Host!, conn.Port, conn.Database);
1325              await tx.CommitAsync();
1326              await conn.CloseAsync();
1327          }
1328          var openingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpeningConnection);
1329          AssertLoggingConnectionString(conn, openingConnectionEvent.State);
1330          AssertLoggingStateContains(openingConnectionEvent, &quot;Host&quot;, host);
1331          AssertLoggingStateContains(openingConnectionEvent, &quot;Port&quot;, port);
1332          AssertLoggingStateContains(openingConnectionEvent, &quot;Database&quot;, database);
1333          var openedConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpenedConnection);
1334          AssertLoggingConnectionString(conn, openedConnectionEvent.State);
1335          AssertLoggingStateContains(openedConnectionEvent, &quot;Host&quot;, host);
1336          AssertLoggingStateContains(openedConnectionEvent, &quot;Port&quot;, port);
1337          AssertLoggingStateContains(openedConnectionEvent, &quot;Database&quot;, database);
1338          var closingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosingConnection);
1339          AssertLoggingConnectionString(conn, closingConnectionEvent.State);
1340          AssertLoggingStateContains(closingConnectionEvent, &quot;Host&quot;, host);
1341          AssertLoggingStateContains(closingConnectionEvent, &quot;Port&quot;, port);
1342          AssertLoggingStateContains(closingConnectionEvent, &quot;Database&quot;, database);
1343          var closedConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosedConnection);
1344          AssertLoggingConnectionString(conn, closedConnectionEvent.State);
1345          AssertLoggingStateContains(closedConnectionEvent, &quot;Host&quot;, host);
1346          AssertLoggingStateContains(closedConnectionEvent, &quot;Port&quot;, port);
1347          AssertLoggingStateContains(closedConnectionEvent, &quot;Database&quot;, database);
1348          if (!IsMultiplexing)
1349          {
1350              AssertLoggingStateContains(openedConnectionEvent, &quot;ConnectorId&quot;, processId);
1351              AssertLoggingStateContains(closingConnectionEvent, &quot;ConnectorId&quot;, processId);
1352              AssertLoggingStateContains(closedConnectionEvent, &quot;ConnectorId&quot;, processId);
1353          }
1354          var ids = new[]
1355          {
1356              NpgsqlEventId.OpeningPhysicalConnection,
1357              NpgsqlEventId.OpenedPhysicalConnection,
1358              NpgsqlEventId.ClosingPhysicalConnection,
1359              NpgsqlEventId.ClosedPhysicalConnection
1360          };
1361          foreach (var id in ids)
1362              Assert.That(listLoggerProvider.Log.Count(l =&gt; l.Id == id), Is.Zero);
1363      }
1364      [Test]
1365      public async Task Log_Open_Close_physical()
1366      {
1367          if (IsMultiplexing)
1368              return;
1369          var csb = new NpgsqlConnectionStringBuilder(ConnectionString) { Pooling = false };
1370          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, csb.ToString());
1371          await using var conn = dataSource.CreateConnection();
1372          int processId, port;
1373          string host, database;
1374          using (listLoggerProvider.Record())
1375          {
1376              await conn.OpenAsync();
1377              (processId, host, port, database) = (conn.ProcessID, conn.Host!, conn.Port, conn.Database);
1378              await conn.CloseAsync();
1379          }
1380          var openingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpeningPhysicalConnection);
1381          AssertLoggingConnectionString(conn, openingConnectionEvent.State);
1382          AssertLoggingStateContains(openingConnectionEvent, &quot;Host&quot;, host);
1383          AssertLoggingStateContains(openingConnectionEvent, &quot;Port&quot;, port);
1384          AssertLoggingStateContains(openingConnectionEvent, &quot;Database&quot;, database);
1385          var openedConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.OpenedPhysicalConnection);
1386          AssertLoggingConnectionString(conn, openedConnectionEvent.State);
1387          AssertLoggingStateContains(openedConnectionEvent, &quot;ConnectorId&quot;, processId);
1388          AssertLoggingStateContains(openingConnectionEvent, &quot;Host&quot;, host);
1389          AssertLoggingStateContains(openingConnectionEvent, &quot;Port&quot;, port);
1390          AssertLoggingStateContains(openingConnectionEvent, &quot;Database&quot;, database);
1391          AssertLoggingStateContains(openedConnectionEvent, &quot;DurationMs&quot;);
1392          var closingConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosingPhysicalConnection);
1393          AssertLoggingConnectionString(conn, closingConnectionEvent.State);
1394          AssertLoggingStateContains(closingConnectionEvent, &quot;ConnectorId&quot;, processId);
1395          AssertLoggingStateContains(closingConnectionEvent, &quot;Host&quot;, host);
1396          AssertLoggingStateContains(closingConnectionEvent, &quot;Port&quot;, port);
1397          AssertLoggingStateContains(closingConnectionEvent, &quot;Database&quot;, database);
1398          var closededConnectionEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.ClosedPhysicalConnection);
1399          AssertLoggingConnectionString(conn, closededConnectionEvent.State);
1400          AssertLoggingStateContains(closededConnectionEvent, &quot;ConnectorId&quot;, processId);
1401          AssertLoggingStateContains(closededConnectionEvent, &quot;Host&quot;, host);
1402          AssertLoggingStateContains(closededConnectionEvent, &quot;Port&quot;, port);
1403          AssertLoggingStateContains(closededConnectionEvent, &quot;Database&quot;, database);
1404      }
1405      void AssertLoggingConnectionString(NpgsqlConnection connection, object? logState)
1406      {
1407          var keyValuePairs = (IEnumerable&lt;KeyValuePair&lt;string, object?&gt;&gt;)logState!;
1408          var connectionString = keyValuePairs.Single(kvp =&gt; kvp.Key == &quot;ConnectionString&quot;).Value;
1409          Assert.That(connectionString, Is.EqualTo(connection.ConnectionString));
1410          Assert.That(connectionString, Does.Not.Contain(&quot;Password&quot;));
1411      }
1412      #endregion Logging tests
1413      public ConnectionTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1414  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ConnectionTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ConnectionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>299          using (var conn1 = await OpenConnectionAsync())
300          {
301              newTimezone = (string?)await conn1.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;) == &quot;Africa/Bamako&quot;
302                  ? &quot;Africa/Lagos&quot;
303                  : &quot;Africa/Bamako&quot;;
304          }
305          using var _ = SetEnvironmentVariable(&quot;PGTZ&quot;, newTimezone);
</pre></code></div>
                <div class="column column_space"><pre><code>314          using (var conn = await OpenConnectionAsync())
315          {
316              newTimezone = (string?)await conn.ExecuteScalarAsync(&quot;SHOW TIMEZONE&quot;) == &quot;Africa/Bamako&quot;
317                  ? &quot;Africa/Lagos&quot;
318                  : &quot;Africa/Bamako&quot;;
319          }
320          await using var dataSource = CreateDataSource(csb =&gt; csb.Timezone = newTimezone);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    