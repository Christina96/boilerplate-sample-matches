
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 28.769497400346623%, Tokens: 11</h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudDataGrid.razor.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Collections.Specialized;
4  using System.Diagnostics.CodeAnalysis;
5  using System.Globalization;
6  using System.Linq;
7  using System.Reflection;
8  using System.Text.Json;
9  using System.Threading.Tasks;
10  using Microsoft.AspNetCore.Components;
11  using Microsoft.AspNetCore.Components.Web;
12  using MudBlazor.Utilities;
13  namespace MudBlazor
14  {
15      [CascadingTypeParameter(nameof(T))]
16      public partial class MudDataGrid<T> : MudComponentBase
17      {
18          private int _currentPage = 0;
19          internal int? _rowsPerPage;
20          private bool _isFirstRendered = false;
21          private bool _filtersMenuVisible = false;
22          private bool _columnsPanelVisible = false;
23          private IEnumerable<T> _items;
24          private T _selectedItem;
25          internal HashSet<object> _groupExpansions = new HashSet<object>();
26          private List<GroupDefinition<T>> _currentPageGroups = new List<GroupDefinition<T>>();
27          private List<GroupDefinition<T>> _allGroups = new List<GroupDefinition<T>>();
28          internal HashSet<T> _openHierarchies = new HashSet<T>();
29          private PropertyInfo[] _properties = typeof(T).GetProperties();
30          private MudDropContainer<Column<T>> _dropContainer;
31          protected string _classname =>
32              new CssBuilder("mud-table")
33                 .AddClass("mud-data-grid")
34                 .AddClass("mud-xs-table", Breakpoint == Breakpoint.Xs)
35                 .AddClass("mud-sm-table", Breakpoint == Breakpoint.Sm)
36                 .AddClass("mud-md-table", Breakpoint == Breakpoint.Md)
37                 .AddClass("mud-lg-table", Breakpoint == Breakpoint.Lg || Breakpoint == Breakpoint.Always)
38                 .AddClass("mud-xl-table", Breakpoint == Breakpoint.Xl || Breakpoint == Breakpoint.Always)
39                 .AddClass("mud-table-dense", Dense)
40                 .AddClass("mud-table-hover", Hover)
41                 .AddClass("mud-table-bordered", Bordered)
42                 .AddClass("mud-table-striped", Striped)
43                 .AddClass("mud-table-outlined", Outlined)
44                 .AddClass("mud-table-square", Square)
45                 .AddClass("mud-table-sticky-header", FixedHeader)
46                 .AddClass("mud-table-sticky-footer", FixedFooter)
47                 .AddClass($"mud-elevation-{Elevation}", !Outlined)
48                .AddClass(Class)
49              .Build();
50          protected string _style =>
51              new StyleBuilder()
52                  .AddStyle("overflow-x", "auto", when: HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container)
53                  .AddStyle("position", "relative", when: hasStickyColumns)
54                  .AddStyle(Style)
55              .Build();
56          protected string _tableStyle =>
57              new StyleBuilder()
58                  .AddStyle("height", Height, !string.IsNullOrWhiteSpace(Height))
<span onclick='openModal()' class='match'>59                  .AddStyle("width", "max-content", when: (HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container) && !hasStickyColumns)
60                  .AddStyle("display", "block", when: HorizontalScrollbar)
61              .Build();
62          protected string _tableClass =>
63              new CssBuilder("mud-table-container")
64                  .AddClass("cursor-col-resize", when: IsResizing)
65              .Build();
66          protected string _headClassname => new CssBuilder("mud-table-head")
67              .AddClass(HeaderClass).Build();
</span>68          protected string _footClassname => new CssBuilder("mud-table-foot")
69              .AddClass(FooterClass).Build();
70          internal SortDirection GetColumnSortDirection(string columnName)
71          {
72              if (columnName == null)
73              {
74                  return SortDirection.None;
75              }
76              else
77              {
78                  SortDefinition<T> sortDefinition = null;
79                  var ok = SortDefinitions.TryGetValue(columnName, out sortDefinition);
80                  if (ok)
81                  {
82                      return sortDefinition.Descending ? SortDirection.Descending : SortDirection.Ascending;
83                  }
84                  else
85                  {
86                      return SortDirection.None;
87                  }
88              }
89          }
90          protected int numPages
91          {
92              get
93              {
94                  if (ServerData != null)
95                      return (int)Math.Ceiling(_server_data.TotalItems / (double)RowsPerPage);
96                  return (int)Math.Ceiling(FilteredItems.Count() / (double)RowsPerPage);
97              }
98          }
99          internal static bool RenderedColumnsItemsSelector(Column<T> item, string dropZone) => item?.PropertyName == dropZone;
100          private static void Swap<TItem>(List<TItem> list, int indexA, int indexB)
101          {
102              TItem tmp = list[indexA];
103              list[indexA] = list[indexB];
104              list[indexB] = tmp;
105          }
106          private Task ItemUpdatedAsync(MudItemDropInfo<Column<T>> dropItem)
107          {
108              dropItem.Item.Identifier = dropItem.DropzoneIdentifier;
109              var dragAndDropSource = RenderedColumns.Where(rc => rc.PropertyName == dropItem.Item.PropertyName).SingleOrDefault();
110              var dragAndDropDestination = RenderedColumns.Where(rc => rc.PropertyName == dropItem.DropzoneIdentifier).SingleOrDefault();
111              if (dragAndDropSource != null && dragAndDropDestination != null)
112              {
113                  var dragAndDropSourceIndex = RenderedColumns.IndexOf(dragAndDropSource);
114                  var dragAndDropDestinationIndex = RenderedColumns.IndexOf(dragAndDropDestination);
115                  Swap<Column<T>>(RenderedColumns, dragAndDropSourceIndex, dragAndDropDestinationIndex);
116                  var dest = dragAndDropDestination.HeaderCell.Width;
117                  var src = dragAndDropSource.HeaderCell.Width;
118                  dragAndDropSource.HeaderCell.Width = dest;
119                  dragAndDropDestination.HeaderCell.Width = src;
120                  StateHasChanged();
121              }
122              return Task.CompletedTask;
123          }
124          public readonly List<Column<T>> RenderedColumns = new List<Column<T>>();
125          internal T _editingItem;
126          internal T editingSourceItem;
127          internal T _previousEditingItem;
128          internal bool isEditFormOpen;
129          private Converter<bool, bool?> _oppositeBoolConverter = new Converter<bool, bool?>
130          {
131              SetFunc = value => value ? false : true,
132              GetFunc = value => value.HasValue ? !value.Value : true,
133          };
134          #region Notify Children Delegates
135          internal Action<Dictionary<string, SortDefinition<T>>, HashSet<string>> SortChangedEvent { get; set; }
136          internal Action<HashSet<T>> SelectedItemsChangedEvent { get; set; }
137          internal Action<bool> SelectedAllItemsChangedEvent { get; set; }
138          internal Action StartedEditingItemEvent { get; set; }
139          internal Action EditingCanceledEvent { get; set; }
140          public Action PagerStateHasChangedEvent { get; set; }
141          #endregion
142          #region EventCallbacks
143          [Parameter] public EventCallback<T> SelectedItemChanged { get; set; }
144          [Parameter] public EventCallback<HashSet<T>> SelectedItemsChanged { get; set; }
145          [Parameter] public EventCallback<DataGridRowClickEventArgs<T>> RowClick { get; set; }
146          [Parameter] public EventCallback<T> StartedEditingItem { get; set; }
147          [Parameter] public EventCallback<T> CanceledEditingItem { get; set; }
148          [Obsolete("Use CanceledEditingItem instead", false)]
149          [Parameter] public EventCallback<T> CancelledEditingItem { get => CanceledEditingItem; set => CanceledEditingItem = value; }
150          [Parameter] public EventCallback<T> CommittedItemChanges { get; set; }
151          [Parameter] public EventCallback<FormFieldChangedEventArgs> FormFieldChanged { get; set; }
152          #endregion
153          #region Parameters
154          [Parameter] public bool DragDropColumnReordering { get; set; } = false;
155          [Parameter] public string DragIndicatorIcon { get; set; } = Icons.Material.Filled.DragIndicator;
156          [Parameter] public Size DragIndicatorSize { get; set; } = Size.Small;
157          [Parameter] public string DropAllowedClass { get; set; } = "drop-allowed";
158          [Parameter] public string DropNotAllowedClass { get; set; } = "drop-not-allowed";
159          [Parameter] public bool ApplyDropClassesOnDragStarted { get; set; } = false;
160          [Parameter] public SortMode SortMode { get; set; } = SortMode.Multiple;
161          [Parameter] public bool Filterable { get; set; } = false;
162          [Parameter] public bool Hideable { get; set; } = false;
163          [Parameter] public bool ShowColumnOptions { get; set; } = true;
164          [Parameter] public Breakpoint Breakpoint { get; set; } = Breakpoint.Xs;
165          [Parameter] public int Elevation { set; get; } = 1;
166          [Parameter] public bool Square { get; set; }
167          [Parameter] public bool Outlined { get; set; }
168          [Parameter] public bool Bordered { get; set; }
169          [Parameter] public RenderFragment ColGroup { get; set; }
170          [Parameter] public bool Dense { get; set; }
171          [Parameter] public bool Hover { get; set; }
172          [Parameter] public bool Striped { get; set; }
173          [Parameter] public bool FixedHeader { get; set; }
174          [Parameter] public bool FixedFooter { get; set; }
175          [Parameter] public bool ShowFilterIcons { get; set; } = true;
176          [Parameter] public DataGridFilterMode FilterMode { get; set; }
177          [Parameter] public DataGridFilterCaseSensitivity FilterCaseSensitivity { get; set; }
178          [Parameter] public RenderFragment<MudDataGrid<T>> FilterTemplate { get; set; }
179          [Parameter] public List<IFilterDefinition<T>> FilterDefinitions { get; set; } = new List<IFilterDefinition<T>>();
180          [Parameter] public Dictionary<string, SortDefinition<T>> SortDefinitions { get; set; } = new Dictionary<string, SortDefinition<T>>();
181          [Parameter] public bool Virtualize { get; set; }
182          [Parameter] public int OverscanCount { get; set; } = 3;
183          [Parameter] public string RowClass { get; set; }
184          [Parameter] public string RowStyle { get; set; }
185          [Parameter] public Func<T, int, string> RowClassFunc { get; set; }
186          [Parameter] public Func<T, int, string> RowStyleFunc { get; set; }
187          [Parameter] public bool MultiSelection { get; set; }
188          [Parameter] public DataGridEditMode? EditMode { get; set; }
189          [Parameter] public DataGridEditTrigger? EditTrigger { get; set; } = DataGridEditTrigger.Manual;
190          [Parameter] public DialogOptions EditDialogOptions { get; set; }
191          [Parameter]
192          public IEnumerable<T> Items
193          {
194              get => _items;
195              set
196              {
197                  if (_items == value)
198                      return;
199                  _items = value;
200                  if (PagerStateHasChangedEvent != null)
201                      InvokeAsync(PagerStateHasChangedEvent);
202                  if (Groupable)
203                  {
204                      GroupItems();
205                  }
206                  if (_items is INotifyCollectionChanged)
207                  {
208                      (_items as INotifyCollectionChanged).CollectionChanged += (s, e) =>
209                      {
210                          _currentRenderFilteredItemsCache = null;
211                          if (Groupable)
212                              GroupItems();
213                      };
214                  }
215              }
216          }
217          [Parameter] public bool Loading { get; set; }
218          [Parameter] public bool CanCancelEdit { get; set; } = true;
219          [Parameter] public Color LoadingProgressColor { get; set; } = Color.Info;
220          [Parameter] public RenderFragment ToolBarContent { get; set; }
221          [Parameter] public bool HorizontalScrollbar { get; set; }
222          [Parameter] public ResizeMode ColumnResizeMode { get; set; }
223          [Parameter] public string HeaderClass { get; set; }
224          [Parameter] public string Height { get; set; }
225          [Parameter] public string FooterClass { get; set; }
226          [Parameter] public Func<T, bool> QuickFilter { get; set; } = null;
227          [Parameter] public RenderFragment Header { get; set; }
228          [Parameter] public RenderFragment Columns { get; set; }
229          [Parameter]
230          public CultureInfo Culture { get; set; }
231          [Parameter] public RenderFragment<CellContext<T>> ChildRowContent { get; set; }
232          [Parameter] public RenderFragment NoRecordsContent { get; set; }
233          [Parameter] public RenderFragment LoadingContent { get; set; }
234          [Parameter] public RenderFragment PagerContent { get; set; }
235          [Parameter] public Func<GridState<T>, Task<GridData<T>>> ServerData { get; set; }
236          [Parameter]
237          public int RowsPerPage
238          {
239              get => _rowsPerPage ?? 10;
240              set
241              {
242                  if (_rowsPerPage == null)
243                      InvokeAsync(() => SetRowsPerPageAsync(value));
244              }
245          }
246          [Parameter]
247          public int CurrentPage
248          {
249              get => _currentPage;
250              set
251              {
252                  if (_currentPage == value)
253                      return;
254                  _currentPage = value;
255                  InvokeAsync(StateHasChanged);
256                  if (_isFirstRendered)
257                      InvokeAsync(InvokeServerLoadFunc);
258              }
259          }
260          [Parameter] public bool ReadOnly { get; set; } = true;
261          [Parameter]
262          public HashSet<T> SelectedItems
263          {
264              get
265              {
266                  if (!MultiSelection)
267                      if (_selectedItem is null)
268                          return new HashSet<T>(Array.Empty<T>());
269                      else
270                          return new HashSet<T>(new T[] { _selectedItem });
271                  else
272                      return Selection;
273              }
274              set
275              {
276                  if (value == Selection)
277                      return;
278                  if (value == null)
279                  {
280                      if (Selection.Count == 0)
281                          return;
282                      Selection = new HashSet<T>();
283                  }
284                  else
285                      Selection = value;
286                  SelectedItemsChangedEvent?.Invoke(Selection);
287                  SelectedItemsChanged.InvokeAsync(Selection);
288                  InvokeAsync(StateHasChanged);
289              }
290          }
291          [Parameter]
292          public T SelectedItem
293          {
294              get => _selectedItem;
295              set
296              {
297                  if (EqualityComparer<T>.Default.Equals(SelectedItem, value))
298                      return;
299                  _selectedItem = value;
300                  SelectedItemChanged.InvokeAsync(value);
301              }
302          }
303          [Parameter]
304          public bool Groupable
305          {
306              get { return _groupable; }
307              set
308              {
309                  if (_groupable != value)
310                  {
311                      _groupable = value;
312                      if (!_groupable)
313                      {
314                          _currentPageGroups.Clear();
315                          _allGroups.Clear();
316                          _groupExpansions.Clear();
317                          _groupExpansions.Add("__initial__");
318                          foreach (var column in RenderedColumns)
319                              column.RemoveGrouping();
320                      }
321                  }
322              }
323          }
324          private bool _groupable = false;
325          [Parameter] public bool GroupExpanded { get; set; }
326          [Parameter] public string GroupClass { get; set; }
327          [Parameter] public string GroupStyle { get; set; }
328          [Parameter] public Func<GroupDefinition<T>, string> GroupClassFunc { get; set; }
329          [Parameter] public Func<GroupDefinition<T>, string> GroupStyleFunc { get; set; }
330          [Parameter] public bool ShowMenuIcon { get; set; } = false;
331          #endregion
332          #region Properties
333          internal IEnumerable<T> CurrentPageItems
334          {
335              get
336              {
337                  if (@PagerContent == null)
338                  {
339                      return FilteredItems; 
340                  }
341                  if (ServerData == null)
342                  {
343                      var filteredItemCount = GetFilteredItemsCount();
344                      int lastPageNo;
345                      if (filteredItemCount == 0)
346                          lastPageNo = 0;
347                      else
348                          lastPageNo = (filteredItemCount / RowsPerPage) - (filteredItemCount % RowsPerPage == 0 ? 1 : 0);
349                      CurrentPage = lastPageNo < CurrentPage ? lastPageNo : CurrentPage;
350                  }
351                  return GetItemsOfPage(CurrentPage, RowsPerPage);
352              }
353          }
354          public HashSet<T> Selection { get; set; } = new HashSet<T>();
355          public bool HasPager { get; set; }
356          public IEnumerable<T> ServerItems => _server_data.Items;
357          private GridData<T> _server_data = new GridData<T>() { TotalItems = 0, Items = Array.Empty<T>() };
358          private IEnumerable<T> _currentRenderFilteredItemsCache = null;
359          internal uint FilteringRunCount { get; private set; }
360          public IEnumerable<T> FilteredItems
361          {
362              get
363              {
364                  if (_currentRenderFilteredItemsCache != null) return _currentRenderFilteredItemsCache;
365                  var items = ServerData != null
366                      ? _server_data.Items
367                      : Items;
368                  if (QuickFilter != null)
369                  {
370                      items = items.Where(QuickFilter);
371                  }
372                  if (ServerData is null)
373                  {
374                      foreach (var filterDefinition in FilterDefinitions)
375                      {
376                          var filterFunc = filterDefinition.GenerateFilterFunction(new FilterOptions
377                          {
378                              FilterCaseSensitivity = FilterCaseSensitivity
379                          });
380                          items = items.Where(filterFunc);
381                      }
382                  }
383                  _currentRenderFilteredItemsCache = Sort(items).ToList(); 
384                  unchecked { FilteringRunCount++; }
385                  GroupItems(noStateChange: true);
386                  return _currentRenderFilteredItemsCache;
387              }
388          }
389          public Interfaces.IForm Validator { get; set; } = new DataGridRowValidator();
390          internal Column<T> GroupedColumn
391          {
392              get
393              {
394                  return RenderedColumns.FirstOrDefault(x => x.grouping);
395              }
396          }
397          #endregion
398          #region Computed Properties
399          private bool hasFooter
400          {
401              get
402              {
403                  return RenderedColumns.Any(x => !x.Hidden && (x.FooterTemplate != null || x.AggregateDefinition != null));
404              }
405          }
406          private bool hasStickyColumns
407          {
408              get
409              {
410                  return RenderedColumns.Any(x => x.StickyLeft || x.StickyRight);
411              }
412          }
413          private bool hasHierarchyColumn
414          {
415              get
416              {
417                  return RenderedColumns.Any(x => x.Tag?.ToString() == "hierarchy-column");
418              }
419          }
420          #endregion
421          [UnconditionalSuppressMessage("Trimming", "IL2046: 'RequiresUnreferencedCodeAttribute' annotations must match across all interface implementations or overrides.", Justification = "Suppressing because we annotating the whole component with RequiresUnreferencedCodeAttribute for information that generic type must be preserved.")]
422          protected override async Task OnAfterRenderAsync(bool firstRender)
423          {
424              if (firstRender)
425              {
426                  await InvokeServerLoadFunc();
427                  if (ServerData == null)
428                      StateHasChanged();
429                  _isFirstRendered = true;
430              }
431              else
432              {
433                  PagerStateHasChangedEvent?.Invoke();
434              }
435              await base.OnAfterRenderAsync(firstRender);
436          }
437          [UnconditionalSuppressMessage("Trimming", "IL2046: 'RequiresUnreferencedCodeAttribute' annotations must match across all interface implementations or overrides.", Justification = "Suppressing because we annotating the whole component with RequiresUnreferencedCodeAttribute for information that generic type must be preserved.")]
438          public override async Task SetParametersAsync(ParameterView parameters)
439          {
440              var sortModeBefore = SortMode;
441              await base.SetParametersAsync(parameters);
442              if (parameters.TryGetValue(nameof(SortMode), out SortMode sortMode) && sortMode != sortModeBefore)
443                  await ClearCurrentSortings();
444          }
445          #region Methods
446          protected IEnumerable<T> GetItemsOfPage(int page, int pageSize)
447          {
448              if (page < 0 || pageSize <= 0)
449                  return Array.Empty<T>();
450              if (ServerData != null)
451              {
452                  return QuickFilter != null
453                      ? _server_data.Items.Where(QuickFilter)
454                      : _server_data.Items;
455              }
456              return FilteredItems.Skip(page * pageSize).Take(pageSize);
457          }
458          internal async Task InvokeServerLoadFunc()
459          {
460              if (ServerData == null)
461                  return;
462              Loading = true;
463              StateHasChanged();
464              var state = new GridState<T>
465              {
466                  Page = CurrentPage,
467                  PageSize = RowsPerPage,
468                  SortDefinitions = SortDefinitions.Values.OrderBy(sd => sd.Index).ToList(),
469                  FilterDefinitions = FilterDefinitions.ToList()
470              };
471              _server_data = await ServerData(state);
472              _currentRenderFilteredItemsCache = null;
473              if (CurrentPage * RowsPerPage > _server_data.TotalItems)
474                  CurrentPage = 0;
475              Loading = false;
476              StateHasChanged();
477              PagerStateHasChangedEvent?.Invoke();
478          }
479          internal void AddColumn(Column<T> column)
480          {
481              if (column.Tag?.ToString() == "hierarchy-column")
482              {
483                  RenderedColumns.Insert(0, column);
484              }
485              else if (column.Tag?.ToString() == "select-column")
486              {
487                  if (RenderedColumns.Select(x => x.Tag).Contains("hierarchy-column"))
488                  {
489                      RenderedColumns.Insert(1, column);
490                  }
491                  else
492                  {
493                      RenderedColumns.Insert(0, column);
494                  }
495              }
496              else
497              {
498                  RenderedColumns.Add(column);
499              }
500          }
501          public void AddFilter()
502          {
503              var column = RenderedColumns.FirstOrDefault(x => x.filterable);
504              FilterDefinitions.Add(new FilterDefinition<T>
505              {
506                  Id = Guid.NewGuid(),
507                  DataGrid = this,
508                  Title = column?.Title,
509                  Column = column,
510              });
511              _filtersMenuVisible = true;
512              StateHasChanged();
513          }
514          internal Task ApplyFiltersAsync()
515          {
516              _filtersMenuVisible = false;
517              return InvokeServerLoadFunc();
518          }
519          public Task ClearFiltersAsync()
520          {
521              FilterDefinitions.Clear();
522              return InvokeServerLoadFunc();
523          }
524          public async Task AddFilterAsync(IFilterDefinition<T> definition)
525          {
526              FilterDefinitions.Add(definition);
527              _filtersMenuVisible = true;
528              await InvokeServerLoadFunc();
529              if (ServerData is null) StateHasChanged();
530          }
531          internal async Task RemoveFilterAsync(Guid id)
532          {
533              FilterDefinitions.RemoveAll(x => x.Id == id);
534              await InvokeServerLoadFunc();
535              GroupItems();
536          }
537          internal async Task SetSelectedItemAsync(bool value, T item)
538          {
539              if (value)
540                  Selection.Add(item);
541              else
542                  Selection.Remove(item);
543              await InvokeAsync(() => SelectedItemsChangedEvent.Invoke(SelectedItems));
544              await SelectedItemsChanged.InvokeAsync(SelectedItems);
545              await InvokeAsync(StateHasChanged);
546          }
547          internal async Task SetSelectAllAsync(bool value)
548          {
549              var items = ServerData != null
550                      ? ServerItems
551                      : Items;
552              if (value)
553                  Selection = new HashSet<T>(items);
554              else
555                  Selection.Clear();
556              SelectedItemsChangedEvent?.Invoke(SelectedItems);
557              SelectedAllItemsChangedEvent?.Invoke(value);
558              await SelectedItemsChanged.InvokeAsync(SelectedItems);
559              StateHasChanged();
560          }
561          internal IEnumerable<T> Sort(IEnumerable<T> items)
562          {
563              if (null == items || !items.Any())
564                  return items;
565              if (null == SortDefinitions || 0 == SortDefinitions.Count)
566                  return items;
567              IOrderedEnumerable<T> orderedEnumerable = null;
568              foreach (var sortDefinition in SortDefinitions.Values.Where(sd => null != sd.SortFunc).OrderBy(sd => sd.Index))
569              {
570                  if (null == orderedEnumerable)
571                      orderedEnumerable = sortDefinition.Descending ? items.OrderByDescending(item => sortDefinition.SortFunc(item), sortDefinition.Comparer)
572                          : items.OrderBy(item => sortDefinition.SortFunc(item), sortDefinition.Comparer);
573                  else
574                      orderedEnumerable = sortDefinition.Descending ? orderedEnumerable.ThenByDescending(item => sortDefinition.SortFunc(item), sortDefinition.Comparer)
575                          : orderedEnumerable.ThenBy(item => sortDefinition.SortFunc(item), sortDefinition.Comparer);
576              }
577              return orderedEnumerable ?? items;
578          }
579          internal void ClearEditingItem()
580          {
581              _editingItem = default;
582              editingSourceItem = default;
583          }
584          internal async Task CommitItemChangesAsync(T item)
585          {
586              await CommittedItemChanges.InvokeAsync(item);
587          }
588          internal async Task CommitItemChangesAsync()
589          {
590              if (editingSourceItem != null)
591              {
592                  foreach (var property in _properties)
593                  {
594                      if (property.CanWrite)
595                          property.SetValue(editingSourceItem, property.GetValue(_editingItem));
596                  }
597                  await CommittedItemChanges.InvokeAsync(editingSourceItem);
598                  ClearEditingItem();
599                  isEditFormOpen = false;
600              }
601          }
602          internal async Task OnRowClickedAsync(MouseEventArgs args, T item, int rowIndex)
603          {
604              await RowClick.InvokeAsync(new DataGridRowClickEventArgs<T>(args, item, rowIndex));
605              if (EditMode != DataGridEditMode.Cell && EditTrigger == DataGridEditTrigger.OnRowClick)
606                  await SetEditingItemAsync(item);
607              await SetSelectedItemAsync(item);
608          }
609          public int GetFilteredItemsCount()
610          {
611              if (ServerData != null)
612                  return _server_data.TotalItems;
613              return FilteredItems.Count();
614          }
615          public void NavigateTo(Page page)
616          {
617              switch (page)
618              {
619                  case Page.First:
620                      CurrentPage = 0;
621                      break;
622                  case Page.Last:
623                      CurrentPage = Math.Max(0, numPages - 1);
624                      break;
625                  case Page.Next:
626                      CurrentPage = Math.Min(numPages - 1, CurrentPage + 1);
627                      break;
628                  case Page.Previous:
629                      CurrentPage = Math.Max(0, CurrentPage - 1);
630                      break;
631              }
632              GroupItems();
633          }
634          public async Task SetRowsPerPageAsync(int size)
635          {
636              if (_rowsPerPage == size)
637                  return;
638              _rowsPerPage = size;
639              CurrentPage = 0;
640              StateHasChanged();
641              if (_isFirstRendered)
642                  await InvokeAsync(InvokeServerLoadFunc);
643          }
644          public async Task SetSortAsync(string field, SortDirection direction, Func<T, object> sortFunc, IComparer<object> comparer = null)
645          {
646              var removedSortDefinitions = new HashSet<string>(SortDefinitions.Keys);
647              SortDefinitions.Clear();
648              var newDefinition = new SortDefinition<T>(field, direction == SortDirection.Descending, 0, sortFunc, comparer);
649              SortDefinitions[field] = newDefinition;
650              removedSortDefinitions.Remove(field);
651              await InvokeSortUpdates(SortDefinitions, removedSortDefinitions);
652          }
653          public async Task ExtendSortAsync(string field, SortDirection direction, Func<T, object> sortFunc, IComparer<object> comparer = null)
654          {
655              if (SortMode != SortMode.Multiple)
656              {
657                  await SetSortAsync(field, direction, sortFunc, comparer);
658                  return;
659              }
660              if (SortDefinitions.TryGetValue(field, out var sortDefinition))
661                  SortDefinitions[field] = sortDefinition with { Descending = direction == SortDirection.Descending, SortFunc = sortFunc, Comparer = comparer };
662              else
663              {
664                  var newDefinition = new SortDefinition<T>(field, direction == SortDirection.Descending, SortDefinitions.Count, sortFunc, comparer);
665                  SortDefinitions[field] = newDefinition;
666              }
667              await InvokeSortUpdates(SortDefinitions, null);
668          }
669          public async Task RemoveSortAsync(string field)
670          {
671              if (!string.IsNullOrWhiteSpace(field) && SortDefinitions.TryGetValue(field, out var definition))
672              {
673                  SortDefinitions.Remove(field);
674                  foreach (var defToUpdate in SortDefinitions.Where(kvp => kvp.Value.Index > definition.Index).ToList())
675                      SortDefinitions[defToUpdate.Key] = defToUpdate.Value with { Index = defToUpdate.Value.Index - 1 };
676                  await InvokeSortUpdates(SortDefinitions, new HashSet<string>() { field });
677              }
678          }
679          private async Task ClearCurrentSortings()
680          {
681              var removedSortDefinitions = new HashSet<string>(SortDefinitions.Keys);
682              SortDefinitions.Clear();
683              await InvokeSortUpdates(SortDefinitions, removedSortDefinitions);
684          }
685          private async Task InvokeSortUpdates(Dictionary<string, SortDefinition<T>> activeSortDefinitions, HashSet<string> removedSortDefinitions)
686          {
687              SortChangedEvent?.Invoke(activeSortDefinitions, removedSortDefinitions);
688              if (_isFirstRendered)
689              {
690                  await InvokeServerLoadFunc();
691                  if (ServerData == null)
692                      StateHasChanged();
693              }
694          }
695          public async Task SetSelectedItemAsync(T item)
696          {
697              if (MultiSelection)
698              {
699                  if (Selection.Contains(item))
700                  {
701                      Selection.Remove(item);
702                  }
703                  else
704                  {
705                      Selection.Add(item);
706                  }
707                  SelectedItemsChangedEvent?.Invoke(SelectedItems);
708                  await SelectedItemsChanged.InvokeAsync(SelectedItems);
709              }
710              SelectedItem = item;
711          }
712          [UnconditionalSuppressMessage("Trimming", "IL2026: Using member 'System.Text.Json.JsonSerializer.Deserialize<T>(string, System.Text.Json.JsonSerializerOptions?)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code. JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.", Justification = "Suppressing because T is a type supplied by the user and it is unlikely that it is not referenced by their code.")]
713          public async Task SetEditingItemAsync(T item)
714          {
715              if (ReadOnly) return;
716              editingSourceItem = item;
717              EditingCanceledEvent?.Invoke();
718              _previousEditingItem = _editingItem;
719              _editingItem = JsonSerializer.Deserialize<T>(JsonSerializer.Serialize(item));
720              StartedEditingItemEvent?.Invoke();
721              await StartedEditingItem.InvokeAsync(_editingItem);
722              isEditFormOpen = true;
723          }
724          public async Task CancelEditingItemAsync()
725          {
726              EditingCanceledEvent?.Invoke();
727              await CanceledEditingItem.InvokeAsync(_editingItem);
728              ClearEditingItem();
729              isEditFormOpen = false;
730          }
731          public void ToggleFiltersMenu()
732          {
733              _filtersMenuVisible = !_filtersMenuVisible;
734              StateHasChanged();
735          }
736          public Task ReloadServerData()
737          {
738              return InvokeServerLoadFunc();
739          }
740          public void OpenFilters()
741          {
742              _filtersMenuVisible = true;
743              StateHasChanged();
744          }
745          internal async Task HideAllColumnsAsync()
746          {
747              foreach (var column in RenderedColumns)
748              {
749                  if (column.Hideable ?? false)
750                      await column.HideAsync();
751              }
752              StateHasChanged();
753          }
754          internal async Task ShowAllColumnsAsync()
755          {
756              foreach (var column in RenderedColumns)
757              {
758                  if (column.Hideable ?? false)
759                      await column.ShowAsync();
760              }
761              StateHasChanged();
762          }
763          public void ShowColumnsPanel()
764          {
765              _columnsPanelVisible = true;
766              StateHasChanged();
767          }
768          public void HideColumnsPanel()
769          {
770              _columnsPanelVisible = false;
771              StateHasChanged();
772          }
773          internal void DropContainerHasChanged()
774          {
775              _dropContainer?.Refresh();
776          }
777          public void GroupItems(bool noStateChange = false)
778          {
779              if (GroupedColumn == null)
780              {
781                  _currentPageGroups = new List<GroupDefinition<T>>();
782                  _allGroups = new List<GroupDefinition<T>>();
783                  if (_isFirstRendered && !noStateChange)
784                      StateHasChanged();
785                  return;
786              }
787              var currentPageGroupings = CurrentPageItems.GroupBy(GroupedColumn.groupBy);
788              var allGroupings = FilteredItems.GroupBy(GroupedColumn.groupBy);
789              if (GetFilteredItemsCount() > 0 && _groupExpansions.Count == 0 && GroupExpanded)
790              {
791                  _groupExpansions.Add("__initial__");
792                  foreach (var group in allGroupings)
793                  {
794                      _groupExpansions.Add(group.Key);
795                  }
796              }
797              _currentPageGroups = currentPageGroupings.Select(x => new GroupDefinition<T>(x,
798                  _groupExpansions.Contains(x.Key))).ToList();
799              _allGroups = allGroupings.Select(x => new GroupDefinition<T>(x,
800                  _groupExpansions.Contains(x.Key))).ToList();                
801              if ((_isFirstRendered || ServerData != null) && !noStateChange)
802                  StateHasChanged();
803          }
804          internal void ChangedGrouping(Column<T> column)
805          {
806              foreach (var c in RenderedColumns)
807              {
808                  if (c.PropertyName != column.PropertyName)
809                      c.RemoveGrouping();
810              }
811              GroupItems();
812          }
813          internal void ToggleGroupExpansion(GroupDefinition<T> g)
814          {
815              if (_groupExpansions.Contains(g.Grouping.Key))
816              {
817                  _groupExpansions.Remove(g.Grouping.Key);
818              }
819              else
820              {
821                  _groupExpansions.Add(g.Grouping.Key);
822              }
823              GroupItems();
824          }
825          public void ExpandAllGroups()
826          {
827              foreach (var group in _allGroups)
828              {
829                  group.IsExpanded = true;
830                  _groupExpansions.Add(group.Grouping.Key);
831              }
832          }
833          public void CollapseAllGroups()
834          {
835              _groupExpansions.Clear();
836              _groupExpansions.Add("__initial__");
837              foreach (var group in _allGroups)
838                  group.IsExpanded = false;
839          }
840          #endregion
841          internal async Task ToggleHierarchyVisibilityAsync(T item)
842          {
843              if (_openHierarchies.Contains(item))
844              {
845                  _openHierarchies.Remove(item);
846              }
847              else
848              {
849                  _openHierarchies.Add(item);
850              }
851              await InvokeAsync(StateHasChanged);
852          }
853          #region Resize feature
854          [Inject] private IEventListener EventListener { get; set; }
855          internal bool IsResizing { get; set; }
856          private ElementReference _gridElement;
857          private DataGridColumnResizeService<T> _resizeService;
858          internal DataGridColumnResizeService<T> ResizeService
859          {
860              get
861              {
862                  return _resizeService ??= new DataGridColumnResizeService<T>(this, EventListener);
863              }
864          }
865          internal async Task<bool> StartResizeColumn(HeaderCell<T> headerCell, double clientX)
866              => await ResizeService.StartResizeColumn(headerCell, clientX, RenderedColumns, ColumnResizeMode);
867          internal async Task<double> GetActualHeight()
868          {
869              var gridRect = await _gridElement.MudGetBoundingClientRectAsync();
870              var gridHeight = gridRect.Height;
871              return gridHeight;
872          }
873          #endregion
874      }
875  }
</code></pre>
        </div>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudPicker.razor.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics.CodeAnalysis;
3  using System.Text.RegularExpressions;
4  using System.Threading.Tasks;
5  using Microsoft.AspNetCore.Components;
6  using Microsoft.AspNetCore.Components.Web;
7  using MudBlazor.Interfaces;
8  using MudBlazor.Services;
9  using MudBlazor.Utilities;
10  namespace MudBlazor
11  {
12      public partial class MudPicker<T> : MudFormComponent<T, string>
13      {
14          protected IKeyInterceptor _keyInterceptor;
15          public MudPicker() : base(new Converter<T, string>()) { }
16          protected MudPicker(Converter<T, string> converter) : base(converter) { }
17          [Inject] private IKeyInterceptorFactory _keyInterceptorFactory { get; set; }
18          private string _elementId = "picker" + Guid.NewGuid().ToString().Substring(0, 8);
19          [Inject] private IBrowserWindowSizeProvider WindowSizeListener { get; set; }
20          protected string PickerClass =>
21              new CssBuilder("mud-picker")
22                  .AddClass($"mud-picker-inline", PickerVariant != PickerVariant.Static)
23                  .AddClass($"mud-picker-static", PickerVariant == PickerVariant.Static)
24                  .AddClass($"mud-rounded", PickerVariant == PickerVariant.Static && !_pickerSquare)
25                  .AddClass($"mud-elevation-{_pickerElevation}", PickerVariant == PickerVariant.Static)
26                  .AddClass($"mud-picker-input-button", !Editable && PickerVariant != PickerVariant.Static)
27                  .AddClass($"mud-picker-input-text", Editable && PickerVariant != PickerVariant.Static)
28                  .AddClass($"mud-disabled", GetDisabledState() && PickerVariant != PickerVariant.Static)
29                  .AddClass(Class)
30                  .Build();
31          protected string PickerPaperClass =>
32              new CssBuilder("mud-picker")
33                  .AddClass("mud-picker-paper")
34                  .AddClass("mud-picker-view", PickerVariant == PickerVariant.Inline)
35                  .AddClass("mud-picker-open", IsOpen && PickerVariant == PickerVariant.Inline)
36                  .AddClass("mud-picker-popover-paper", PickerVariant == PickerVariant.Inline)
37                  .AddClass("mud-dialog", PickerVariant == PickerVariant.Dialog)
38                  .Build();
39          protected string PickerInlineClass =>
40              new CssBuilder("mud-picker-inline-paper")
41                  .Build();
42          protected string PickerContainerClass =>
43              new CssBuilder("mud-picker-container")
<span onclick='openModal()' class='match'>44                  .AddClass("mud-paper-square", _pickerSquare)
45                  .AddClass("mud-picker-container-landscape",
46                      Orientation == Orientation.Landscape && PickerVariant == PickerVariant.Static)
47                  .Build();
48          protected string PickerInputClass =>
49              new CssBuilder("mud-input-input-control").AddClass(Class)
50                  .Build();
51          protected string ActionClass => new CssBuilder("mud-picker-actions")
52              .AddClass(ClassActions)
53              .Build();
</span>54          [ExcludeFromCodeCoverage]
55          [Parameter]
56          [Obsolete("Use AdornmentIcon instead.", true)]
57          public string InputIcon
58          {
59              get { return AdornmentIcon; }
60              set { AdornmentIcon = value; }
61          }
62          [Parameter]
63          [Category(CategoryTypes.FormComponent.Appearance)]
64          public Color AdornmentColor { get; set; } = Color.Default;
65          [Parameter]
66          [Category(CategoryTypes.FormComponent.Behavior)]
67          public string AdornmentIcon { get; set; } = Icons.Material.Filled.Event;
68          [Parameter]
69          [Category(CategoryTypes.FormComponent.Appearance)]
70          public string AdornmentAriaLabel { get; set; } = string.Empty;
71          [Parameter]
72          [Category(CategoryTypes.FormComponent.Behavior)]
73          public string Placeholder { get; set; }
74          [Parameter]
75          public EventCallback PickerOpened { get; set; }
76          [Parameter]
77          public EventCallback PickerClosed { get; set; }
78          [Parameter]
79          [Category(CategoryTypes.FormComponent.PickerAppearance)]
80          public int Elevation { set; get; } = 8;
81          [Parameter]
82          [Category(CategoryTypes.FormComponent.PickerAppearance)]
83          public bool Square { get; set; }
84          [Parameter]
85          [Category(CategoryTypes.FormComponent.PickerAppearance)]
86          public bool Rounded { get; set; }
87          [Parameter]
88          [Category(CategoryTypes.FormComponent.Behavior)]
89          public string HelperText { get; set; }
90          [Parameter]
91          [Category(CategoryTypes.FormComponent.Behavior)]
92          public bool HelperTextOnFocus { get; set; }
93          [Parameter]
94          [Category(CategoryTypes.FormComponent.Behavior)]
95          public string Label { get; set; }
96          [Parameter]
97          [Category(CategoryTypes.FormComponent.Behavior)]
98          public bool Clearable { get; set; } = false;
99          [Parameter]
100          [Category(CategoryTypes.FormComponent.Behavior)]
101          public bool Disabled { get; set; }
102          [CascadingParameter(Name = "ParentDisabled")] private bool ParentDisabled { get; set; }
103          protected bool GetDisabledState() => Disabled || ParentDisabled;
104          [Parameter]
105          [Category(CategoryTypes.FormComponent.Behavior)]
106          public bool ReadOnly { get; set; }
107          [CascadingParameter(Name = "ParentReadOnly")] private bool ParentReadOnly { get; set; }
108          protected bool GetReadOnlyState() => ReadOnly || ParentReadOnly;
109          [Parameter]
110          [Category(CategoryTypes.FormComponent.Behavior)]
111          public bool Editable { get; set; } = false;
112          [Parameter]
113          [Category(CategoryTypes.FormComponent.PickerAppearance)]
114          public bool DisableToolbar { get; set; }
115          [Parameter]
116          [Category(CategoryTypes.FormComponent.PickerAppearance)]
117          public string ToolBarClass { get; set; }
118          [Parameter]
119          [Category(CategoryTypes.FormComponent.Behavior)]
120          public PickerVariant PickerVariant { get; set; } = PickerVariant.Inline;
121          [ExcludeFromCodeCoverage]
122          [Parameter]
123          [Obsolete("Use Variant instead.", true)]
124          public Variant InputVariant
125          {
126              get { return Variant; }
127              set { Variant = value; }
128          }
129          [Parameter]
130          [Category(CategoryTypes.FormComponent.Appearance)]
131          public Variant Variant { get; set; } = Variant.Text;
132          [Parameter]
133          [Category(CategoryTypes.FormComponent.Behavior)]
134          public Adornment Adornment { get; set; } = Adornment.End;
135          [Parameter]
136          [Category(CategoryTypes.FormComponent.PickerAppearance)]
137          public Orientation Orientation { get; set; } = Orientation.Portrait;
138          [Parameter]
139          [Category(CategoryTypes.FormComponent.Appearance)]
140          public Size IconSize { get; set; } = Size.Medium;
141          [Parameter]
142          [Category(CategoryTypes.FormComponent.PickerAppearance)]
143          public Color Color { get; set; } = Color.Primary;
144          [Obsolete("This is enabled now by default when you use Editable=true. You can remove the parameter.", false)]
145          [Parameter]
146          public bool AllowKeyboardInput { get; set; }
147          [Parameter]
148          public EventCallback<string> TextChanged { get; set; }
149          [Parameter]
150          public EventCallback<MouseEventArgs> OnClick { get; set; }
151          [Parameter]
152          [Category(CategoryTypes.FormComponent.Data)]
153          public string Text
154          {
155              get => _text;
156              set => SetTextAsync(value, true).AndForget();
157          }
158          private string _text;
159          [Parameter]
160          [Category(CategoryTypes.FormComponent.PickerAppearance)]
161          public string ClassActions { get; set; }
162          [Parameter]
163          [Category(CategoryTypes.FormComponent.PickerBehavior)]
164          public RenderFragment<MudPicker<T>> PickerActions { get; set; }
165          [Parameter]
166          [Category(CategoryTypes.FormComponent.Appearance)]
167          public Margin Margin { get; set; } = Margin.None;
168          [Parameter]
169          [Category(CategoryTypes.FormComponent.Behavior)]
170          public IMask Mask
171          {
172              get => _mask;
173              set => _mask = value;
174          }
175          [Parameter]
176          [Category(CategoryTypes.Popover.Appearance)]
177          public Origin AnchorOrigin { get; set; } = Origin.TopLeft;
178          [Parameter]
179          [Category(CategoryTypes.Popover.Appearance)]
180          public Origin TransformOrigin { get; set; } = Origin.TopLeft;
181          protected IMask _mask = null;
182          protected async Task SetTextAsync(string value, bool callback)
183          {
184              if (_text != value)
185              {
186                  _text = value;
187                  if (callback)
188                      await StringValueChanged(_text);
189                  await TextChanged.InvokeAsync(_text);
190              }
191          }
192          protected virtual Task StringValueChanged(string value)
193          {
194              return Task.CompletedTask;
195          }
196          protected bool IsOpen { get; set; }
197          public void ToggleOpen()
198          {
199              if (IsOpen)
200                  Close();
201              else
202                  Open();
203          }
204          public void Close(bool submit = true)
205          {
206              IsOpen = false;
207              if (submit)
208              {
209                  Submit();
210              }
211              OnClosed();
212              StateHasChanged();
213          }
214          public void Open()
215          {
216              IsOpen = true;
217              StateHasChanged();
218              OnOpened();
219          }
220          private void CloseOverlay() => Close(PickerActions == null);
221          protected internal virtual void Submit() { }
222          public virtual void Clear(bool close = true)
223          {
224              if (close && PickerVariant != PickerVariant.Static)
225              {
226                  Close(false);
227              }
228          }
229          [Obsolete($"Use {nameof(ResetValueAsync)} instead. This will be removed in v7")]
230          [ExcludeFromCodeCoverage]
231          protected override void ResetValue()
232          {
233              _inputReference?.Reset();
234              base.ResetValue();
235          }
236          protected override async Task ResetValueAsync()
237          {
238              if (_inputReference is not null)
239              {
240                  await _inputReference.ResetAsync();
241              }
242              await base.ResetValueAsync();
243          }
244          protected internal MudTextField<string> _inputReference;
245          public virtual ValueTask FocusAsync() => _inputReference?.FocusAsync() ?? ValueTask.CompletedTask;
246          public virtual ValueTask BlurAsync() => _inputReference?.BlurAsync() ?? ValueTask.CompletedTask;
247          public virtual ValueTask SelectAsync() => _inputReference?.SelectAsync() ?? ValueTask.CompletedTask;
248          public virtual ValueTask SelectRangeAsync(int pos1, int pos2) =>
249              _inputReference?.SelectRangeAsync(pos1, pos2) ?? ValueTask.CompletedTask;
250          private bool _pickerSquare;
251          private int _pickerElevation;
252          private ElementReference _pickerInlineRef;
253          protected override void OnInitialized()
254          {
255              if (PickerVariant == PickerVariant.Static)
256              {
257                  IsOpen = true;
258                  if (Elevation == 8)
259                  {
260                      _pickerElevation = 0;
261                  }
262                  else
263                  {
264                      _pickerElevation = Elevation;
265                  }
266                  if (!Rounded)
267                  {
268                      _pickerSquare = true;
269                  }
270              }
271              else
272              {
273                  _pickerSquare = Square;
274                  _pickerElevation = Elevation;
275              }
276              if (Label == null && For != null)
277                  Label = For.GetLabelString();
278          }
279          private async Task EnsureKeyInterceptor()
280          {
281              if (_keyInterceptor == null)
282              {
283                  _keyInterceptor = _keyInterceptorFactory.Create();
284                  await _keyInterceptor.Connect(_elementId, new KeyInterceptorOptions()
285                  {
286                      TargetClass = "mud-input-slot",
287                      Keys =
288                      {
289                          new KeyOptions { Key = " ", PreventDown = "key+none" },
290                          new KeyOptions { Key = "ArrowUp", PreventDown = "key+none" },
291                          new KeyOptions { Key = "ArrowDown", PreventDown = "key+none" },
292                          new KeyOptions { Key = "Enter", PreventDown = "key+none" },
293                          new KeyOptions { Key = "NumpadEnter", PreventDown = "key+none" },
294                          new KeyOptions { Key = "/./", SubscribeDown = true, SubscribeUp = true }, 
295                      },
296                  });
297                  _keyInterceptor.KeyDown += HandleKeyDown;
298              }
299          }
300          private async Task OnClickAsync(MouseEventArgs args)
301          {
302              if (!Editable)
303                  ToggleState();
304              if (OnClick.HasDelegate)
305                  await OnClick.InvokeAsync(args);
306          }
307          protected override async Task OnAfterRenderAsync(bool firstRender)
308          {
309              if (firstRender == true)
310              {
311                  await EnsureKeyInterceptor();
312              }
313              await base.OnAfterRenderAsync(firstRender);
314          }
315          protected internal void ToggleState()
316          {
317              if (GetDisabledState() || GetReadOnlyState())
318                  return;
319              if (IsOpen)
320              {
321                  IsOpen = false;
322                  OnClosed();
323              }
324              else
325              {
326                  IsOpen = true;
327                  OnOpened();
328                  FocusAsync();
329              }
330          }
331          protected virtual async void OnOpened()
332          {
333              OnPickerOpened();
334              if (PickerVariant == PickerVariant.Inline)
335              {
336                  await _pickerInlineRef.MudChangeCssAsync(PickerInlineClass);
337              }
338              await EnsureKeyInterceptor();
339              await _keyInterceptor.UpdateKey(new() { Key = "Escape", StopDown = "key+none" });
340          }
341          protected virtual async void OnClosed()
342          {
343              OnPickerClosed();
344              await EnsureKeyInterceptor();
345              await _keyInterceptor.UpdateKey(new() { Key = "Escape", StopDown = "none" });
346          }
347          protected virtual void OnPickerOpened()
348          {
349              PickerOpened.InvokeAsync(this);
350          }
351          protected virtual void OnPickerClosed()
352          {
353              PickerClosed.InvokeAsync(this);
354          }
355          protected internal virtual void HandleKeyDown(KeyboardEventArgs obj)
356          {
357              if (GetDisabledState() || GetReadOnlyState())
358                  return;
359              switch (obj.Key)
360              {
361                  case "Backspace":
362                      if (obj.CtrlKey == true && obj.ShiftKey == true)
363                      {
364                          Clear();
365                          _value = default(T);
366                          Reset();
367                      }
368                      break;
369                  case "Escape":
370                  case "Tab":
371                      Close(false);
372                      break;
373              }
374          }
375          protected override void Dispose(bool disposing)
376          {
377              base.Dispose(disposing);
378              if (disposing == true)
379              {
380                  if (_keyInterceptor != null)
381                  {
382                      _keyInterceptor.KeyDown -= HandleKeyDown;
383                      _keyInterceptor.Dispose();
384                  }
385              }
386          }
387      }
388  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudDataGrid.razor.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudPicker.razor.cs</div>
                </div>
                <div class="column column_space"><pre><code>59                  .AddStyle("width", "max-content", when: (HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container) && !hasStickyColumns)
60                  .AddStyle("display", "block", when: HorizontalScrollbar)
61              .Build();
62          protected string _tableClass =>
63              new CssBuilder("mud-table-container")
64                  .AddClass("cursor-col-resize", when: IsResizing)
65              .Build();
66          protected string _headClassname => new CssBuilder("mud-table-head")
67              .AddClass(HeaderClass).Build();
</pre></code></div>
                <div class="column column_space"><pre><code>44                  .AddClass("mud-paper-square", _pickerSquare)
45                  .AddClass("mud-picker-container-landscape",
46                      Orientation == Orientation.Landscape && PickerVariant == PickerVariant.Static)
47                  .Build();
48          protected string PickerInputClass =>
49              new CssBuilder("mud-input-input-control").AddClass(Class)
50                  .Build();
51          protected string ActionClass => new CssBuilder("mud-picker-actions")
52              .AddClass(ClassActions)
53              .Build();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    