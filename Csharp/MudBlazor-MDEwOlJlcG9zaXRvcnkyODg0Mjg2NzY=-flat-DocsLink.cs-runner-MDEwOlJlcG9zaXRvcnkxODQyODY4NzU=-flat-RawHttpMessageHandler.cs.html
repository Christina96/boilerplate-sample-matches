
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.79020979020979%, Tokens: 14</h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-DocsLink.cs</h3>
            <pre><code>1  namespace MudBlazor.Docs.Models
2  {
3      public class DocsLink
4      {
<span onclick='openModal()' class='match'>5          public string Href { get; set; }
6          public string Title { get; set; }
</span>7          public string Group { get; set; }
8      }
9  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-RawHttpMessageHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Net;
3  using System.Net.Http;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GitHub.Services.Common.Diagnostics;
7  using GitHub.Services.Common.Internal;
8  using GitHub.Services.OAuth;
9  namespace GitHub.Services.Common
10  {
11      public class RawHttpMessageHandler : HttpMessageHandler
12      {
13          public RawHttpMessageHandler(
14              FederatedCredential credentials)
15              : this(credentials, new RawClientHttpRequestSettings())
16          {
17          }
18          public RawHttpMessageHandler(
19              FederatedCredential credentials,
20              RawClientHttpRequestSettings settings)
21              : this(credentials, settings, new HttpClientHandler())
22          {
23          }
24          public RawHttpMessageHandler(
25              FederatedCredential credentials,
26              RawClientHttpRequestSettings settings,
27              HttpMessageHandler innerHandler)
28          {
29              this.Credentials = credentials;
30              this.Settings = settings;
31              m_messageInvoker = new HttpMessageInvoker(innerHandler);
32              m_credentialWrapper = new CredentialWrapper();
33              {
34                  HttpMessageHandler transportHandler = innerHandler;
35                  DelegatingHandler delegatingHandler = transportHandler as DelegatingHandler;
36                  while (delegatingHandler != null)
37                  {
38                      transportHandler = delegatingHandler.InnerHandler;
39                      delegatingHandler = transportHandler as DelegatingHandler;
40                  }
41                  m_transportHandler = transportHandler;
42              }
43              ApplySettings(m_transportHandler, m_credentialWrapper, this.Settings);
44              m_thisLock = new Object();
45          }
<span onclick='openModal()' class='match'>46          public FederatedCredential Credentials
47          {
48              get;
49              private set;
50          }
51          public RawClientHttpRequestSettings Settings
52          {
53              get;
54              private set;
</span>55          }
56          private static IWebProxy s_defaultWebProxy = null;
57          public static IWebProxy DefaultWebProxy
58          {
59              get
60              {
61                  var toReturn = WebProxyWrapper.Wrap(s_defaultWebProxy);
62                  if (null != toReturn &&
63                      toReturn.Credentials == null)
64                  {
65                      toReturn.Credentials = CredentialCache.DefaultCredentials;
66                  }
67                  return toReturn;
68              }
69              set
70              {
71                  s_defaultWebProxy = value;
72              }
73          }
74          protected override async Task<HttpResponseMessage> SendAsync(
75              HttpRequestMessage request,
76              CancellationToken cancellationToken)
77          {
78              VssTraceActivity traceActivity = VssTraceActivity.Current;
79              lock (m_thisLock)
80              {
81                  if (m_tokenProvider == null)
82                  {
83                      m_tokenProvider = this.Credentials.CreateTokenProvider(request.RequestUri, null, null);
84                  }
85              }
86              CancellationTokenSource tokenSource = null;
87              HttpResponseMessage response = null;
88              Boolean succeeded = false;
89              HttpResponseMessageWrapper responseWrapper;
90              Boolean lastResponseDemandedProxyAuth = false;
91              Int32 retries = m_maxAuthRetries;
92              try
93              {
94                  tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
95                  if (this.Settings.SendTimeout > TimeSpan.Zero)
96                  {
97                      tokenSource.CancelAfter(this.Settings.SendTimeout);
98                  }
99                  do
100                  {
101                      if (response != null)
102                      {
103                          response.Dispose();
104                      }
105                      IssuedToken token = await m_tokenProvider.GetTokenAsync(null, tokenSource.Token).ConfigureAwait(false);
106                      ApplyToken(request, token, applyICredentialsToWebProxy: lastResponseDemandedProxyAuth);
107                      await BufferRequestContentAsync(request, tokenSource.Token).ConfigureAwait(false);
108                      response = await m_messageInvoker.SendAsync(request, tokenSource.Token).ConfigureAwait(false);
109                      responseWrapper = new HttpResponseMessageWrapper(response);
110                      var isUnAuthorized = responseWrapper.StatusCode == HttpStatusCode.Unauthorized;
111                      lastResponseDemandedProxyAuth = responseWrapper.StatusCode == HttpStatusCode.ProxyAuthenticationRequired;
112                      if (!isUnAuthorized && !lastResponseDemandedProxyAuth)
113                      {
114                          m_tokenProvider?.ValidateToken(token, responseWrapper);
115                          succeeded = true;
116                          break;
117                      }
118                      else
119                      {
120                          m_tokenProvider?.InvalidateToken(token);
121                          if (retries == 0 || retries < m_maxAuthRetries)
122                          {
123                              break;
124                          }
125                          token = await m_tokenProvider.GetTokenAsync(token, tokenSource.Token).ConfigureAwait(false);
126                          retries--;
127                      }
128                  }
129                  while (retries >= 0);
130                  if (!succeeded && response != null && responseWrapper.StatusCode == HttpStatusCode.Unauthorized)
131                  {
132                      if (response != null)
133                      {
134                          response.Dispose();
135                      }
136                      var message = CommonResources.VssUnauthorized(request.RequestUri.GetLeftPart(UriPartial.Authority));
137                      VssHttpEventSource.Log.HttpRequestUnauthorized(traceActivity, request, message);
138                      VssUnauthorizedException unauthorizedException = new VssUnauthorizedException(message);
139                      throw unauthorizedException;
140                  }
141                  return response;
142              }
143              catch (OperationCanceledException ex)
144              {
145                  if (cancellationToken.IsCancellationRequested)
146                  {
147                      VssHttpEventSource.Log.HttpRequestCancelled(traceActivity, request);
148                      throw;
149                  }
150                  else
151                  {
152                      VssHttpEventSource.Log.HttpRequestTimedOut(traceActivity, request, this.Settings.SendTimeout);
153                      throw new TimeoutException(CommonResources.HttpRequestTimeout(this.Settings.SendTimeout), ex);
154                  }
155              }
156              finally
157              {
158                  if (tokenSource != null)
159                  {
160                      tokenSource.Dispose();
161                  }
162              }
163          }
164          private static async Task BufferRequestContentAsync(
165               HttpRequestMessage request,
166               CancellationToken cancellationToken)
167          {
168              if (request.Content != null &&
169                  request.Headers.TransferEncodingChunked != true)
170              {
171                  Int64? contentLength = request.Content.Headers.ContentLength;
172                  if (contentLength == null)
173                  {
174                      await request.Content.LoadIntoBufferAsync().EnforceCancellation(cancellationToken).ConfigureAwait(false);
175                  }
176                  request.Headers.TransferEncodingChunked = false;
177              }
178          }
179          private void ApplyToken(
180              HttpRequestMessage request,
181              IssuedToken token,
182              bool applyICredentialsToWebProxy = false)
183          {
184              switch (token)
185              {
186                  case null:
187                      return;
188                  case ICredentials credentialsToken:
189                      if (applyICredentialsToWebProxy)
190                      {
191                          HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
192                          if (httpClientHandler != null && httpClientHandler.Proxy != null)
193                          {
194                              httpClientHandler.Proxy.Credentials = credentialsToken;
195                          }
196                      }
197                      m_credentialWrapper.InnerCredentials = credentialsToken;
198                      break;
199                  default:
200                      token.ApplyTo(new HttpRequestMessageWrapper(request));
201                      break;
202              }
203          }
204          private static void ApplySettings(
205              HttpMessageHandler handler,
206              ICredentials defaultCredentials,
207              RawClientHttpRequestSettings settings)
208          {
209              HttpClientHandler httpClientHandler = handler as HttpClientHandler;
210              if (httpClientHandler != null)
211              {
212                  httpClientHandler.ClientCertificateOptions = ClientCertificateOption.Manual;
213                  httpClientHandler.UseDefaultCredentials = false;
214                  httpClientHandler.Credentials = defaultCredentials;
215                  httpClientHandler.PreAuthenticate = false;
216                  httpClientHandler.Proxy = DefaultWebProxy;
217                  httpClientHandler.UseCookies = false;
218                  httpClientHandler.UseProxy = true;
219              }
220          }
221          private readonly HttpMessageHandler m_transportHandler;
222          private HttpMessageInvoker m_messageInvoker;
223          private CredentialWrapper m_credentialWrapper;
224          private object m_thisLock;
225          private const Int32 m_maxAuthRetries = 3;
226          private IssuedTokenProvider m_tokenProvider;
227          private sealed class CredentialWrapper : CredentialCache, ICredentials
228          {
229              public ICredentials InnerCredentials
230              {
231                  get;
232                  set;
233              }
234              NetworkCredential ICredentials.GetCredential(
235                  Uri uri,
236                  String authType)
237              {
238                  return InnerCredentials != null ? InnerCredentials.GetCredential(uri, authType) : null;
239              }
240          }
241          private sealed class WebProxyWrapper : IWebProxy
242          {
243              private WebProxyWrapper(IWebProxy toWrap)
244              {
245                  m_wrapped = toWrap;
246                  m_credentials = null;
247              }
248              public static WebProxyWrapper Wrap(IWebProxy toWrap)
249              {
250                  if (null == toWrap)
251                  {
252                      return null;
253                  }
254                  return new WebProxyWrapper(toWrap);
255              }
256              public ICredentials Credentials
257              {
258                  get
259                  {
260                      ICredentials credentials = m_credentials;
261                      if (null == credentials)
262                      {
263                          credentials = m_wrapped.Credentials;
264                      }
265                      else if (Object.ReferenceEquals(credentials, m_nullCredentials))
266                      {
267                          credentials = null;
268                      }
269                      return credentials;
270                  }
271                  set
272                  {
273                      if (null == value)
274                      {
275                          m_credentials = m_nullCredentials;
276                      }
277                      else
278                      {
279                          m_credentials = value;
280                      }
281                  }
282              }
283              public Uri GetProxy(Uri destination)
284              {
285                  return m_wrapped.GetProxy(destination);
286              }
287              public bool IsBypassed(Uri host)
288              {
289                  return m_wrapped.IsBypassed(host);
290              }
291              private readonly IWebProxy m_wrapped;
292              private ICredentials m_credentials;
293              private static readonly ICredentials m_nullCredentials = new CredentialWrapper();
294          }
295      }
296  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-DocsLink.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-RawHttpMessageHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>5          public string Href { get; set; }
6          public string Title { get; set; }
</pre></code></div>
                <div class="column column_space"><pre><code>46          public FederatedCredential Credentials
47          {
48              get;
49              private set;
50          }
51          public RawClientHttpRequestSettings Settings
52          {
53              get;
54              private set;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    