
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.979062811565304%, Tokens: 12</h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ToggleIconButtonTest.cs</h3>
            <pre><code>1  using System;
2  using Bunit;
3  using FluentAssertions;
4  using MudBlazor.UnitTests.TestComponents;
5  using NUnit.Framework;
6  using static Bunit.ComponentParameterFactory;
7  namespace MudBlazor.UnitTests.Components
8  {
9      [TestFixture]
10      public class ToggleIconButtonTest : BunitTest
11      {
12          [Test]
13          public void DefaultValueTest()
14          {
15              var comp = Context.RenderComponent<MudToggleIconButton>();
16              comp.Instance.Toggled.Should().BeFalse();
17          }
18          [Test]
19          public void ToggleTest()
20          {
21              var boundValue = false;
22              var comp = Context.RenderComponent<MudToggleIconButton>(parameters => parameters
23                  .Add(p => p.Toggled, boundValue)
24                  .Add(p => p.ToggledChanged, (toggleValue) => boundValue = toggleValue)
25                  );
<span onclick='openModal()' class='match'>26              comp.Find("button").Click();
27              boundValue.Should().BeTrue();
28              comp.Find("button").Click();
29              boundValue.Should().BeFalse();
30              comp.RenderCount.Should().Be(3);
31          }
32          [Test]
</span>33          public void ShouldSynchronizeStateWithOtherComponent()
34          {
35              var comp = Context.RenderComponent<ToggleIconButtonTest1>();
36              var group = comp.FindComponents<MudToggleIconButton>();
37              var comp1 = group[0];
38              var comp2 = group[1];
39              comp1.Instance.Toggled.Should().BeFalse();
40              comp2.Instance.Toggled.Should().BeFalse();
41              comp1.Find("button").Click();
42              comp1.Instance.Toggled.Should().BeTrue();
43              comp2.Instance.Toggled.Should().BeTrue();
44          }
45          [Test]
46          public void ShouldRenderToggledTitle()
47          {
48              var title = "Title and tooltip";
49              var toggledTitle = "toggled!";
50              var icon = Parameter(nameof(MudToggleIconButton.Icon), Icons.Material.Filled.Add);
51              var toggledIcon = Parameter(nameof(MudToggleIconButton.ToggledIcon), Icons.Material.Filled.Remove);
52              var titleParam = Parameter(nameof(MudToggleIconButton.Title), title);
53              var toggledTitleParam = Parameter(nameof(MudToggleIconButton.ToggledTitle), toggledTitle);
54              var comp = Context.RenderComponent<MudToggleIconButton>(icon, toggledIcon, titleParam, toggledTitleParam);
55              comp.Find($"button[title=\"{title}\"]");
56              comp.Find("button").Click();
57              comp.Find($"button[title=\"{toggledTitle}\"]");
58              comp.Find("button").Click();
59              comp.Find($"button[title=\"{title}\"]");
60          }
61      }
62  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobDispatcherL0.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Reflection;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GitHub.DistributedTask.ObjectTemplating.Tokens;
7  using GitHub.DistributedTask.Pipelines;
8  using GitHub.DistributedTask.Pipelines.ContextData;
9  using GitHub.DistributedTask.WebApi;
10  using GitHub.Runner.Listener;
11  using GitHub.Runner.Listener.Configuration;
12  using GitHub.Services.WebApi;
13  using Moq;
14  using Sdk.RSWebApi.Contracts;
15  using Xunit;
16  using Pipelines = GitHub.DistributedTask.Pipelines;
17  namespace GitHub.Runner.Common.Tests.Listener
18  {
19      public sealed class JobDispatcherL0
20      {
21          private Mock<IProcessChannel> _processChannel;
22          private Mock<IProcessInvoker> _processInvoker;
23          private Mock<IRunnerServer> _runnerServer;
24          private Mock<IRunServer> _runServer;
25          private Mock<IConfigurationStore> _configurationStore;
26          public JobDispatcherL0()
27          {
28              _processChannel = new Mock<IProcessChannel>();
29              _processInvoker = new Mock<IProcessInvoker>();
30              _runnerServer = new Mock<IRunnerServer>();
31              _runServer = new Mock<IRunServer>();
32              _configurationStore = new Mock<IConfigurationStore>();
33          }
34          private Pipelines.AgentJobRequestMessage CreateJobRequestMessage()
35          {
36              TaskOrchestrationPlanReference plan = new();
37              TimelineReference timeline = null;
38              Guid jobId = Guid.NewGuid();
39              var result = new Pipelines.AgentJobRequestMessage(plan, timeline, jobId, "someJob", "someJob", null, null, null, new Dictionary<string, VariableValue>(), new List<MaskHint>(), new Pipelines.JobResources(), new Pipelines.ContextData.DictionaryContextData(), new Pipelines.WorkspaceOptions(), new List<Pipelines.ActionStep>(), null, null, null, null);
40              result.ContextData["github"] = new Pipelines.ContextData.DictionaryContextData();
41              return result;
42          }
43          [Fact]
44          [Trait("Level", "L0")]
45          [Trait("Category", "Runner")]
46          public async void DispatchesJobRequest()
47          {
48              using (var hc = new TestHostContext(this))
49              {
50                  var jobDispatcher = new JobDispatcher();
51                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
52                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
53                  hc.EnqueueInstance<IProcessChannel>(_processChannel.Object);
54                  hc.EnqueueInstance<IProcessInvoker>(_processInvoker.Object);
55                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
56                  jobDispatcher.Initialize(hc);
57                  var ts = new CancellationTokenSource();
58                  Pipelines.AgentJobRequestMessage message = CreateJobRequestMessage();
59                  string strMessage = JsonUtility.ToString(message);
60                  _processInvoker.Setup(x => x.ExecuteAsync(It.IsAny<String>(), It.IsAny<String>(), "spawnclient 1 2", null, It.IsAny<CancellationToken>()))
61                      .Returns(Task.FromResult<int>(56));
62                  _processChannel.Setup(x => x.StartServer(It.IsAny<StartProcessDelegate>()))
63                      .Callback((StartProcessDelegate startDel) => { startDel("1", "2"); });
64                  _processChannel.Setup(x => x.SendAsync(MessageType.NewJobRequest, It.Is<string>(s => s.Equals(strMessage)), It.IsAny<CancellationToken>()))
65                      .Returns(Task.CompletedTask);
66                  var request = new TaskAgentJobRequest();
67                  PropertyInfo sessionIdProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
68                  Assert.NotNull(sessionIdProperty);
69                  sessionIdProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
70                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>())).Returns(Task.FromResult<TaskAgentJobRequest>(request));
71                  _runnerServer.Setup(x => x.FinishAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<DateTime>(), It.IsAny<TaskResult>(), It.IsAny<CancellationToken>())).Returns(Task.FromResult<TaskAgentJobRequest>(new TaskAgentJobRequest()));
72                  jobDispatcher.Run(message);
73                  await jobDispatcher.WaitAsync(CancellationToken.None);
74                  Assert.False(jobDispatcher.RunOnceJobCompleted.Task.IsCompleted, "JobDispatcher should not set task complete token for regular agent.");
75              }
76          }
77          [Fact]
78          [Trait("Level", "L0")]
79          [Trait("Category", "Runner")]
80          public async void DispatcherRenewJobRequest()
81          {
82              using (var hc = new TestHostContext(this))
83              {
84                  int poolId = 1;
85                  Int64 requestId = 1000;
86                  int count = 0;
87                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequest));
88                  TaskCompletionSource<int> firstJobRequestRenewed = new();
89                  CancellationTokenSource cancellationTokenSource = new();
90                  TaskAgentJobRequest request = new();
91                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
92                  Assert.NotNull(lockUntilProperty);
93                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
94                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
95                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
96                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
97                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
98                              .Returns(() =>
99                              {
100                                  count++;
101                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
102                                  {
103                                      trace.Info("First renew happens.");
104                                  }
105                                  if (count < 5)
106                                  {
107                                      return Task.FromResult<TaskAgentJobRequest>(request);
108                                  }
109                                  else if (count == 5)
110                                  {
111                                      cancellationTokenSource.Cancel();
112                                      return Task.FromResult<TaskAgentJobRequest>(request);
113                                  }
114                                  else
115                                  {
116                                      throw new InvalidOperationException("Should not reach here.");
117                                  }
118                              });
119                  var jobDispatcher = new JobDispatcher();
120                  jobDispatcher.Initialize(hc);
<span onclick='openModal()' class='match'>121                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
122                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully);
123                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(5));
124              }
125          }
126          [Fact]
</span>127          [Trait("Level", "L0")]
128          [Trait("Category", "Runner")]
129          public async void DispatcherRenewJobRequestStopOnJobNotFoundExceptions()
130          {
131              using (var hc = new TestHostContext(this))
132              {
133                  int poolId = 1;
134                  Int64 requestId = 1000;
135                  int count = 0;
136                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestStopOnJobNotFoundExceptions));
137                  TaskCompletionSource<int> firstJobRequestRenewed = new();
138                  CancellationTokenSource cancellationTokenSource = new();
139                  TaskAgentJobRequest request = new();
140                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
141                  Assert.NotNull(lockUntilProperty);
142                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
143                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
144                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
145                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
146                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
147                              .Returns(() =>
148                              {
149                                  count++;
150                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
151                                  {
152                                      trace.Info("First renew happens.");
153                                  }
154                                  if (count < 5)
155                                  {
156                                      return Task.FromResult<TaskAgentJobRequest>(request);
157                                  }
158                                  else if (count == 5)
159                                  {
160                                      cancellationTokenSource.CancelAfter(10000);
161                                      throw new TaskAgentJobNotFoundException("");
162                                  }
163                                  else
164                                  {
165                                      throw new InvalidOperationException("Should not reach here.");
166                                  }
167                              });
168                  var jobDispatcher = new JobDispatcher();
169                  jobDispatcher.Initialize(hc);
170                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
171                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully, "First renew should succeed.");
172                  Assert.False(cancellationTokenSource.IsCancellationRequested);
173                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(5));
174              }
175          }
176          [Fact]
177          [Trait("Level", "L0")]
178          [Trait("Category", "Runner")]
179          public async void DispatcherRenewJobOnRunServiceStopOnJobNotFoundExceptions()
180          {
181              using (var hc = new TestHostContext(this))
182              {
183                  int poolId = 1;
184                  Int64 requestId = 1000;
185                  int count = 0;
186                  var trace = hc.GetTrace(nameof(DispatcherRenewJobOnRunServiceStopOnJobNotFoundExceptions));
187                  TaskCompletionSource<int> firstJobRequestRenewed = new();
188                  CancellationTokenSource cancellationTokenSource = new();
189                  TaskAgentJobRequest request = new();
190                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
191                  Assert.NotNull(lockUntilProperty);
192                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
193                  hc.SetSingleton<IRunServer>(_runServer.Object);
194                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
195                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
196                  _ = _runServer.Setup(x => x.RenewJobAsync(It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
197                              .Returns(() =>
198                              {
199                                  count++;
200                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
201                                  {
202                                      trace.Info("First renew happens.");
203                                  }
204                                  if (count < 5)
205                                  {
206                                      var response = new RenewJobResponse()
207                                      {
208                                          LockedUntil = request.LockedUntil.Value
209                                      };
210                                      return Task.FromResult<RenewJobResponse>(response);
211                                  }
212                                  else if (count == 5)
213                                  {
214                                      cancellationTokenSource.CancelAfter(10000);
215                                      throw new TaskOrchestrationJobNotFoundException("");
216                                  }
217                                  else
218                                  {
219                                      throw new InvalidOperationException("Should not reach here.");
220                                  }
221                              });
222                  var jobDispatcher = new JobDispatcher();
223                  jobDispatcher.Initialize(hc);
224                  EnableRunServiceJobForJobDispatcher(jobDispatcher);
225                  var isRunServiceJobField = typeof(JobDispatcher).GetField("_isRunServiceJob", BindingFlags.NonPublic | BindingFlags.Instance);
226                  isRunServiceJobField.SetValue(jobDispatcher, true);
227                  await jobDispatcher.RenewJobRequestAsync(GetAgentJobRequestMessage(), GetServiceEndpoint(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
228                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully, "First renew should succeed.");
229                  Assert.False(cancellationTokenSource.IsCancellationRequested);
230                  _runServer.Verify(x => x.RenewJobAsync(It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<CancellationToken>()), Times.Exactly(5));
231              }
232          }
233          [Fact]
234          [Trait("Level", "L0")]
235          [Trait("Category", "Runner")]
236          public async void DispatcherRenewJobRequestStopOnJobTokenExpiredExceptions()
237          {
238              using (var hc = new TestHostContext(this))
239              {
240                  int poolId = 1;
241                  Int64 requestId = 1000;
242                  int count = 0;
243                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestStopOnJobTokenExpiredExceptions));
244                  TaskCompletionSource<int> firstJobRequestRenewed = new();
245                  CancellationTokenSource cancellationTokenSource = new();
246                  TaskAgentJobRequest request = new();
247                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
248                  Assert.NotNull(lockUntilProperty);
249                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
250                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
251                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
252                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
253                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
254                              .Returns(() =>
255                              {
256                                  count++;
257                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
258                                  {
259                                      trace.Info("First renew happens.");
260                                  }
261                                  if (count < 5)
262                                  {
263                                      return Task.FromResult<TaskAgentJobRequest>(request);
264                                  }
265                                  else if (count == 5)
266                                  {
267                                      cancellationTokenSource.CancelAfter(10000);
268                                      throw new TaskAgentJobTokenExpiredException("");
269                                  }
270                                  else
271                                  {
272                                      throw new InvalidOperationException("Should not reach here.");
273                                  }
274                              });
275                  var jobDispatcher = new JobDispatcher();
276                  jobDispatcher.Initialize(hc);
277                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
278                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully, "First renew should succeed.");
279                  Assert.False(cancellationTokenSource.IsCancellationRequested);
280                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(5));
281              }
282          }
283          [Fact]
284          [Trait("Level", "L0")]
285          [Trait("Category", "Runner")]
286          public async void RenewJobRequestNewAgentNameUpdatesSettings()
287          {
288              using (var hc = new TestHostContext(this))
289              {
290                  var count = 0;
291                  var oldName = "OldName";
292                  var newName = "NewName";
293                  var oldSettings = new RunnerSettings { AgentName = oldName };
294                  var reservedAgent = new TaskAgentReference { Name = newName };
295                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestStopOnJobTokenExpiredExceptions));
296                  TaskCompletionSource<int> firstJobRequestRenewed = new();
297                  CancellationTokenSource cancellationTokenSource = new();
298                  var request = new Mock<TaskAgentJobRequest>();
299                  request.Object.ReservedAgent = reservedAgent;
300                  PropertyInfo lockUntilProperty = request.Object.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
301                  Assert.NotNull(lockUntilProperty);
302                  lockUntilProperty.SetValue(request.Object, DateTime.UtcNow.AddMinutes(5));
303                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
304                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
305                  _configurationStore.Setup(x => x.GetSettings()).Returns(oldSettings);
306                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
307                              .Returns(() =>
308                              {
309                                  count++;
310                                  if (count < 5)
311                                  {
312                                      return Task.FromResult<TaskAgentJobRequest>(request.Object);
313                                  }
314                                  else if (count == 5 || count == 6 || count == 7)
315                                  {
316                                      throw new TimeoutException("");
317                                  }
318                                  else
319                                  {
320                                      cancellationTokenSource.Cancel();
321                                      return Task.FromResult<TaskAgentJobRequest>(request.Object);
322                                  }
323                              });
324                  var jobDispatcher = new JobDispatcher();
325                  jobDispatcher.Initialize(hc);
326                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), 0, 0, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
327                  _configurationStore.Verify(x => x.SaveSettings(It.Is<RunnerSettings>(settings => settings.AgentName == newName)), Times.Once);
328              }
329          }
330          [Fact]
331          [Trait("Level", "L0")]
332          [Trait("Category", "Runner")]
333          public async void RenewJobRequestSameAgentNameIgnored()
334          {
335              using (var hc = new TestHostContext(this))
336              {
337                  var count = 0;
338                  var oldName = "OldName";
339                  var newName = "OldName";
340                  var oldSettings = new RunnerSettings { AgentName = oldName };
341                  var reservedAgent = new TaskAgentReference { Name = newName };
342                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestStopOnJobTokenExpiredExceptions));
343                  TaskCompletionSource<int> firstJobRequestRenewed = new();
344                  CancellationTokenSource cancellationTokenSource = new();
345                  var request = new Mock<TaskAgentJobRequest>();
346                  request.Object.ReservedAgent = reservedAgent;
347                  PropertyInfo lockUntilProperty = request.Object.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
348                  Assert.NotNull(lockUntilProperty);
349                  lockUntilProperty.SetValue(request.Object, DateTime.UtcNow.AddMinutes(5));
350                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
351                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
352                  _configurationStore.Setup(x => x.GetSettings()).Returns(oldSettings);
353                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
354                              .Returns(() =>
355                              {
356                                  count++;
357                                  if (count < 5)
358                                  {
359                                      return Task.FromResult<TaskAgentJobRequest>(request.Object);
360                                  }
361                                  else if (count == 5 || count == 6 || count == 7)
362                                  {
363                                      throw new TimeoutException("");
364                                  }
365                                  else
366                                  {
367                                      cancellationTokenSource.Cancel();
368                                      return Task.FromResult<TaskAgentJobRequest>(request.Object);
369                                  }
370                              });
371                  var jobDispatcher = new JobDispatcher();
372                  jobDispatcher.Initialize(hc);
373                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), 0, 0, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
374                  _configurationStore.Verify(x => x.SaveSettings(It.IsAny<RunnerSettings>()), Times.Never);
375              }
376          }
377          [Fact]
378          [Trait("Level", "L0")]
379          [Trait("Category", "Runner")]
380          public async void RenewJobRequestNullAgentNameIgnored()
381          {
382              using (var hc = new TestHostContext(this))
383              {
384                  var count = 0;
385                  var oldName = "OldName";
386                  var oldSettings = new RunnerSettings { AgentName = oldName };
387                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestStopOnJobTokenExpiredExceptions));
388                  TaskCompletionSource<int> firstJobRequestRenewed = new();
389                  CancellationTokenSource cancellationTokenSource = new();
390                  var request = new Mock<TaskAgentJobRequest>();
391                  PropertyInfo lockUntilProperty = request.Object.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
392                  Assert.NotNull(lockUntilProperty);
393                  lockUntilProperty.SetValue(request.Object, DateTime.UtcNow.AddMinutes(5));
394                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
395                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
396                  _configurationStore.Setup(x => x.GetSettings()).Returns(oldSettings);
397                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
398                              .Returns(() =>
399                              {
400                                  count++;
401                                  if (count < 5)
402                                  {
403                                      return Task.FromResult<TaskAgentJobRequest>(request.Object);
404                                  }
405                                  else if (count == 5 || count == 6 || count == 7)
406                                  {
407                                      throw new TimeoutException("");
408                                  }
409                                  else
410                                  {
411                                      cancellationTokenSource.Cancel();
412                                      return Task.FromResult<TaskAgentJobRequest>(request.Object);
413                                  }
414                              });
415                  var jobDispatcher = new JobDispatcher();
416                  jobDispatcher.Initialize(hc);
417                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), 0, 0, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
418                  _configurationStore.Verify(x => x.SaveSettings(It.IsAny<RunnerSettings>()), Times.Never);
419              }
420          }
421          [Fact]
422          [Trait("Level", "L0")]
423          [Trait("Category", "Runner")]
424          public async void DispatcherRenewJobRequestRecoverFromExceptions()
425          {
426              using (var hc = new TestHostContext(this))
427              {
428                  int poolId = 1;
429                  Int64 requestId = 1000;
430                  int count = 0;
431                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestRecoverFromExceptions));
432                  TaskCompletionSource<int> firstJobRequestRenewed = new();
433                  CancellationTokenSource cancellationTokenSource = new();
434                  TaskAgentJobRequest request = new();
435                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
436                  Assert.NotNull(lockUntilProperty);
437                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
438                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
439                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
440                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
441                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
442                              .Returns(() =>
443                              {
444                                  count++;
445                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
446                                  {
447                                      trace.Info("First renew happens.");
448                                  }
449                                  if (count < 5)
450                                  {
451                                      return Task.FromResult<TaskAgentJobRequest>(request);
452                                  }
453                                  else if (count == 5 || count == 6 || count == 7)
454                                  {
455                                      throw new TimeoutException("");
456                                  }
457                                  else
458                                  {
459                                      cancellationTokenSource.Cancel();
460                                      return Task.FromResult<TaskAgentJobRequest>(request);
461                                  }
462                              });
463                  var jobDispatcher = new JobDispatcher();
464                  jobDispatcher.Initialize(hc);
465                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
466                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully, "First renew should succeed.");
467                  Assert.True(cancellationTokenSource.IsCancellationRequested);
468                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(8));
469                  _runnerServer.Verify(x => x.RefreshConnectionAsync(RunnerConnectionType.JobRequest, It.IsAny<TimeSpan>()), Times.Exactly(3));
470                  _runnerServer.Verify(x => x.SetConnectionTimeout(RunnerConnectionType.JobRequest, It.IsAny<TimeSpan>()), Times.Once);
471              }
472          }
473          [Fact]
474          [Trait("Level", "L0")]
475          [Trait("Category", "Runner")]
476          public async void DispatcherRenewJobRequestFirstRenewRetrySixTimes()
477          {
478              using (var hc = new TestHostContext(this))
479              {
480                  int poolId = 1;
481                  Int64 requestId = 1000;
482                  int count = 0;
483                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestFirstRenewRetrySixTimes));
484                  TaskCompletionSource<int> firstJobRequestRenewed = new();
485                  CancellationTokenSource cancellationTokenSource = new();
486                  TaskAgentJobRequest request = new();
487                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
488                  Assert.NotNull(lockUntilProperty);
489                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
490                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
491                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
492                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
493                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
494                              .Returns(() =>
495                              {
496                                  count++;
497                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
498                                  {
499                                      trace.Info("First renew happens.");
500                                  }
501                                  if (count <= 5)
502                                  {
503                                      throw new TimeoutException("");
504                                  }
505                                  else
506                                  {
507                                      cancellationTokenSource.CancelAfter(10000);
508                                      throw new InvalidOperationException("Should not reach here.");
509                                  }
510                              });
511                  var jobDispatcher = new JobDispatcher();
512                  jobDispatcher.Initialize(hc);
513                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
514                  Assert.False(firstJobRequestRenewed.Task.IsCompletedSuccessfully, "First renew should failed.");
515                  Assert.False(cancellationTokenSource.IsCancellationRequested);
516                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(6));
517              }
518          }
519          [Fact]
520          [Trait("Level", "L0")]
521          [Trait("Category", "Runner")]
522          public async void DispatcherRenewJobRequestStopOnExpiredRequest()
523          {
524              using (var hc = new TestHostContext(this))
525              {
526                  int poolId = 1;
527                  Int64 requestId = 1000;
528                  int count = 0;
529                  var trace = hc.GetTrace(nameof(DispatcherRenewJobRequestStopOnExpiredRequest));
530                  TaskCompletionSource<int> firstJobRequestRenewed = new();
531                  CancellationTokenSource cancellationTokenSource = new();
532                  TaskAgentJobRequest request = new();
533                  PropertyInfo lockUntilProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
534                  Assert.NotNull(lockUntilProperty);
535                  lockUntilProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
536                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
537                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
538                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
539                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
540                              .Returns(() =>
541                              {
542                                  count++;
543                                  if (!firstJobRequestRenewed.Task.IsCompletedSuccessfully)
544                                  {
545                                      trace.Info("First renew happens.");
546                                  }
547                                  if (count == 1)
548                                  {
549                                      return Task.FromResult<TaskAgentJobRequest>(request);
550                                  }
551                                  else if (count < 5)
552                                  {
553                                      throw new TimeoutException("");
554                                  }
555                                  else if (count == 5)
556                                  {
557                                      lockUntilProperty.SetValue(request, DateTime.UtcNow.Subtract(TimeSpan.FromMinutes(11)));
558                                      throw new TimeoutException("");
559                                  }
560                                  else
561                                  {
562                                      cancellationTokenSource.CancelAfter(10000);
563                                      throw new InvalidOperationException("Should not reach here.");
564                                  }
565                              });
566                  var jobDispatcher = new JobDispatcher();
567                  jobDispatcher.Initialize(hc);
568                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
569                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully, "First renew should succeed.");
570                  Assert.False(cancellationTokenSource.IsCancellationRequested);
571                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(5));
572                  _runnerServer.Verify(x => x.RefreshConnectionAsync(RunnerConnectionType.JobRequest, It.IsAny<TimeSpan>()), Times.Exactly(3));
573                  _runnerServer.Verify(x => x.SetConnectionTimeout(RunnerConnectionType.JobRequest, It.IsAny<TimeSpan>()), Times.Never);
574              }
575          }
576          [Fact]
577          [Trait("Level", "L0")]
578          [Trait("Category", "Runner")]
579          public async void DispatchesOneTimeJobRequest()
580          {
581              using (var hc = new TestHostContext(this))
582              {
583                  var jobDispatcher = new JobDispatcher();
584                  hc.SetSingleton<IConfigurationStore>(_configurationStore.Object);
585                  hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
586                  hc.EnqueueInstance<IProcessChannel>(_processChannel.Object);
587                  hc.EnqueueInstance<IProcessInvoker>(_processInvoker.Object);
588                  _configurationStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1 });
589                  jobDispatcher.Initialize(hc);
590                  var ts = new CancellationTokenSource();
591                  Pipelines.AgentJobRequestMessage message = CreateJobRequestMessage();
592                  string strMessage = JsonUtility.ToString(message);
593                  _processInvoker.Setup(x => x.ExecuteAsync(It.IsAny<String>(), It.IsAny<String>(), "spawnclient 1 2", null, It.IsAny<CancellationToken>()))
594                      .Returns(Task.FromResult<int>(56));
595                  _processChannel.Setup(x => x.StartServer(It.IsAny<StartProcessDelegate>()))
596                      .Callback((StartProcessDelegate startDel) => { startDel("1", "2"); });
597                  _processChannel.Setup(x => x.SendAsync(MessageType.NewJobRequest, It.Is<string>(s => s.Equals(strMessage)), It.IsAny<CancellationToken>()))
598                      .Returns(Task.CompletedTask);
599                  var request = new TaskAgentJobRequest();
600                  PropertyInfo sessionIdProperty = request.GetType().GetProperty("LockedUntil", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
601                  Assert.NotNull(sessionIdProperty);
602                  sessionIdProperty.SetValue(request, DateTime.UtcNow.AddMinutes(5));
603                  _runnerServer.Setup(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>())).Returns(Task.FromResult<TaskAgentJobRequest>(request));
604                  _runnerServer.Setup(x => x.FinishAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<DateTime>(), It.IsAny<TaskResult>(), It.IsAny<CancellationToken>())).Returns(Task.FromResult<TaskAgentJobRequest>(new TaskAgentJobRequest()));
605                  jobDispatcher.Run(message, true);
606                  await jobDispatcher.WaitAsync(CancellationToken.None);
607                  Assert.True(jobDispatcher.RunOnceJobCompleted.Task.IsCompleted, "JobDispatcher should set task complete token for one time agent.");
608                  Assert.True(jobDispatcher.RunOnceJobCompleted.Task.Result, "JobDispatcher should set task complete token to 'TRUE' for one time agent.");
609              }
610          }
611          private static void EnableRunServiceJobForJobDispatcher(JobDispatcher jobDispatcher)
612          {
613              var isRunServiceJobField = typeof(JobDispatcher).GetField("_isRunServiceJob", BindingFlags.NonPublic | BindingFlags.Instance);
614              isRunServiceJobField.SetValue(jobDispatcher, true);
615          }
616          private static ServiceEndpoint GetServiceEndpoint()
617          {
618              var serviceEndpoint = new ServiceEndpoint
619              {
620                  Authorization = new EndpointAuthorization
621                  {
622                      Scheme = EndpointAuthorizationSchemes.OAuth
623                  }
624              };
625              serviceEndpoint.Authorization.Parameters.Add("AccessToken", "token");
626              return serviceEndpoint;
627          }
628          private static AgentJobRequestMessage GetAgentJobRequestMessage()
629          {
630              var message = new AgentJobRequestMessage(
631                  new TaskOrchestrationPlanReference()
632                  {
633                      PlanType = "Build",
634                      PlanId = Guid.NewGuid(),
635                      Version = 1
636                  },
637                  new TimelineReference()
638                  {
639                      Id = Guid.NewGuid()
640                  },
641                  Guid.NewGuid(),
642                  "jobDisplayName",
643                  "jobName",
644                  null,
645                  null,
646                  new List<TemplateToken>(),
647                  new Dictionary<string, VariableValue>()
648                  {
649                      {
650                          "variables",
651                          new VariableValue()
652                          {
653                              IsSecret = false,
654                              Value = "variables"
655                          }
656                      }
657                  },
658                  new List<MaskHint>()
659                  {
660                      new MaskHint()
661                      {
662                          Type = MaskType.Variable,
663                          Value = "maskHints"
664                      }
665                  },
666                  new JobResources(),
667                  new DictionaryContextData(),
668                  new WorkspaceOptions(),
669                  new List<JobStep>(),
670                  new List<string>()
671                  {
672                      "fileTable"
673                  },
674                  null,
675                  new List<TemplateToken>(),
676                  new ActionsEnvironmentReference("env")
677              );
678              return message;
679          }
680      }
681  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ToggleIconButtonTest.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobDispatcherL0.cs</div>
                <div class="column column_space"><pre><code>26              comp.Find("button").Click();
27              boundValue.Should().BeTrue();
28              comp.Find("button").Click();
29              boundValue.Should().BeFalse();
30              comp.RenderCount.Should().Be(3);
31          }
32          [Test]
</pre></code></div>
                <div class="column column_space"><pre><code>121                  await jobDispatcher.RenewJobRequestAsync(It.IsAny<AgentJobRequestMessage>(), It.IsAny<ServiceEndpoint>(), poolId, requestId, Guid.Empty, Guid.NewGuid().ToString(), firstJobRequestRenewed, cancellationTokenSource.Token);
122                  Assert.True(firstJobRequestRenewed.Task.IsCompletedSuccessfully);
123                  _runnerServer.Verify(x => x.RenewAgentRequestAsync(It.IsAny<int>(), It.IsAny<long>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Exactly(5));
124              }
125          }
126          [Fact]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    