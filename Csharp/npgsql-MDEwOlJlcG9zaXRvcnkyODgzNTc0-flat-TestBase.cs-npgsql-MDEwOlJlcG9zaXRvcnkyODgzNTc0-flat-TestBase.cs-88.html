
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics;
6  using System.Linq;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using Microsoft.Extensions.Logging;
10  using Npgsql.Tests.Support;
11  using NpgsqlTypes;
12  using NUnit.Framework;
13  namespace Npgsql.Tests;
14  public abstract class TestBase
15  {
16      public virtual string ConnectionString =&gt; TestUtil.ConnectionString;
17      static readonly SemaphoreSlim DatabaseCreationLock = new(1);
18      static readonly object dataSourceLockObject = new();
19      static ConcurrentDictionary&lt;string, NpgsqlDataSource&gt; DataSources = new(StringComparer.Ordinal);
20      #region Type testing
21      public async Task&lt;T&gt; AssertType&lt;T&gt;(
22          T value,
23          string sqlLiteral,
24          string pgTypeName,
25          NpgsqlDbType? npgsqlDbType,
26          DbType? dbType = null,
27          DbType? inferredDbType = null,
28          bool isDefaultForReading = true,
29          bool isDefaultForWriting = true,
30          bool? isDefault = null,
31          bool isNpgsqlDbTypeInferredFromClrType = true,
32          Func&lt;T, T, bool&gt;? comparer = null)
33      {
34          await using var connection = await OpenConnectionAsync();
35          return await AssertType(
36              connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading, isDefaultForWriting,
37              isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
38      }
39      public async Task&lt;T&gt; AssertType&lt;T&gt;(
40          NpgsqlDataSource dataSource,
41          T value,
42          string sqlLiteral,
43          string pgTypeName,
44          NpgsqlDbType? npgsqlDbType,
45          DbType? dbType = null,
46          DbType? inferredDbType = null,
47          bool isDefaultForReading = true,
48          bool isDefaultForWriting = true,
49          bool? isDefault = null,
50          bool isNpgsqlDbTypeInferredFromClrType = true,
51          Func&lt;T, T, bool&gt;? comparer = null)
52      {
53          await using var connection = await dataSource.OpenConnectionAsync();
54          return await AssertType(connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading,
55              isDefaultForWriting, isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
56      }
57      public async Task&lt;T&gt; AssertType&lt;T&gt;(
58          NpgsqlConnection connection,
59          T value,
60          string sqlLiteral,
<span onclick='openModal()' class='match'>61          string pgTypeName,
62          NpgsqlDbType? npgsqlDbType,
63          DbType? dbType = null,
64          DbType? inferredDbType = null,
65          bool isDefaultForReading = true,
66          bool isDefaultForWriting = true,
</span>67          bool? isDefault = null,
68          bool isNpgsqlDbTypeInferredFromClrType = true,
69          Func&lt;T, T, bool&gt;? comparer = null)
70      {
71          if (isDefault is not null)
72              isDefaultForReading = isDefaultForWriting = isDefault.Value;
73          await AssertTypeWrite(connection, () =&gt; value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForWriting, isNpgsqlDbTypeInferredFromClrType);
74          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, value, isDefaultForReading, comparer);
75      }
76      public async Task&lt;T&gt; AssertTypeRead&lt;T&gt;(string sqlLiteral, string pgTypeName, T expected, bool isDefault = true)
77      {
78          await using var connection = await OpenConnectionAsync();
79          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, expected, isDefault);
80      }
81      public async Task AssertTypeWrite&lt;T&gt;(
82          NpgsqlDataSource dataSource,
83          T value,
84          string expectedSqlLiteral,
85          string pgTypeName,
86          NpgsqlDbType npgsqlDbType,
87          DbType? dbType = null,
88          DbType? inferredDbType = null,
89          bool isDefault = true,
90          bool isNpgsqlDbTypeInferredFromClrType = true)
91      {
92          await using var connection = await dataSource.OpenConnectionAsync();
93          await AssertTypeWrite(connection, () =&gt; value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
94              isNpgsqlDbTypeInferredFromClrType);
95      }
96      public Task AssertTypeWrite&lt;T&gt;(
97          T value,
98          string expectedSqlLiteral,
99          string pgTypeName,
100          NpgsqlDbType npgsqlDbType,
101          DbType? dbType = null,
102          DbType? inferredDbType = null,
103          bool isDefault = true,
104          bool isNpgsqlDbTypeInferredFromClrType = true)
105          =&gt; AssertTypeWrite(() =&gt; value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
106              isNpgsqlDbTypeInferredFromClrType);
107      public async Task AssertTypeWrite&lt;T&gt;(
108          Func&lt;T&gt; valueFactory,
109          string expectedSqlLiteral,
110          string pgTypeName,
111          NpgsqlDbType npgsqlDbType,
112          DbType? dbType = null,
113          DbType? inferredDbType = null,
114          bool isDefault = true,
115          bool isNpgsqlDbTypeInferredFromClrType = true)
116      {
117          await using var connection = await OpenConnectionAsync();
118          await AssertTypeWrite(connection, valueFactory, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault, isNpgsqlDbTypeInferredFromClrType);
119      }
120      internal static async Task&lt;T&gt; AssertTypeRead&lt;T&gt;(
121          NpgsqlConnection connection,
122          string sqlLiteral,
123          string pgTypeName,
124          T expected,
125          bool isDefault = true,
126          Func&lt;T, T, bool&gt;? comparer = null)
127      {
128          if (sqlLiteral.Contains(&#x27;\&#x27;&#x27;))
129              sqlLiteral = sqlLiteral.Replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;);
130          await using var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{sqlLiteral}&#x27;::{pgTypeName}&quot;, connection);
131          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
132          await reader.ReadAsync();
133          var truncatedSqlLiteral = sqlLiteral.Length &gt; 40 ? sqlLiteral[..40] + &quot;...&quot; : sqlLiteral;
134          var dataTypeName = reader.GetDataTypeName(0);
135          var dotIndex = dataTypeName.IndexOf(&#x27;.&#x27;);
136          if (dotIndex &gt; -1 &amp;&amp; dataTypeName.Substring(0, dotIndex) is &quot;pg_catalog&quot; or &quot;public&quot;)
137              dataTypeName = dataTypeName.Substring(dotIndex + 1);
138          Assert.That(dataTypeName, Is.EqualTo(pgTypeName),
139              $&quot;Got wrong result from GetDataTypeName when reading &#x27;{truncatedSqlLiteral}&#x27;&quot;);
140          if (isDefault)
141          {
142              Assert.That(reader.GetFieldType(0), Is.EqualTo(dataTypeName.EndsWith(&quot;[]&quot;) ? typeof(Array) : typeof(T)),
143                  $&quot;Got wrong result from GetFieldType when reading &#x27;{truncatedSqlLiteral}&#x27;&quot;);
144          }
145          var actual = isDefault ? (T)reader.GetValue(0) : reader.GetFieldValue&lt;T&gt;(0);
146          Assert.That(actual, comparer is null ? Is.EqualTo(expected) : Is.EqualTo(expected).Using(new SimpleComparer&lt;T&gt;(comparer)),
147              $&quot;Got wrong result from GetFieldValue value when reading &#x27;{truncatedSqlLiteral}&#x27;&quot;);
148          return actual;
149      }
150      internal static async Task AssertTypeWrite&lt;T&gt;(
151          NpgsqlConnection connection,
152          Func&lt;T&gt; valueFactory,
153          string expectedSqlLiteral,
154          string pgTypeName,
155          NpgsqlDbType? npgsqlDbType,
156          DbType? dbType = null,
157          DbType? inferredDbType = null,
158          bool isDefault = true,
159          bool isNpgsqlDbTypeInferredFromClrType = true)
160      {
161          if (npgsqlDbType is null)
162              isNpgsqlDbTypeInferredFromClrType = false;
163          var parenIndex = pgTypeName.IndexOf(&#x27;(&#x27;);
164          var pgTypeNameWithoutFacets = parenIndex &gt; -1 ? pgTypeName[..parenIndex] : pgTypeName;
165          var errorIdentifierIndex = -1;
166          var errorIdentifier = new Dictionary&lt;int, string&gt;();
167          await using var cmd = new NpgsqlCommand { Connection = connection };
168          NpgsqlParameter p;
169          if (npgsqlDbType is not null)
170          {
171              p = new NpgsqlParameter { Value = valueFactory(), NpgsqlDbType = npgsqlDbType.Value };
172              cmd.Parameters.Add(p);
173              errorIdentifier[++errorIdentifierIndex] = $&quot;NpgsqlDbType={npgsqlDbType}&quot;;
174              CheckInference();
175          }
176          p = new NpgsqlParameter { Value = valueFactory(), DataTypeName = pgTypeNameWithoutFacets };
177          cmd.Parameters.Add(p);
178          errorIdentifier[++errorIdentifierIndex] = $&quot;DataTypeName={pgTypeNameWithoutFacets}&quot;;
179          CheckInference();
180          if (dbType is not null)
181          {
182              p = new NpgsqlParameter { Value = valueFactory(), DbType = dbType.Value };
183              cmd.Parameters.Add(p);
184              errorIdentifier[++errorIdentifierIndex] = $&quot;DbType={dbType}&quot;;
185              CheckInference();
186          }
187          if (isDefault)
188          {
189              p = new NpgsqlParameter { Value = valueFactory() };
190              cmd.Parameters.Add(p);
191              errorIdentifier[++errorIdentifierIndex] = &quot;Value only (non-generic)&quot;;
192              if (isNpgsqlDbTypeInferredFromClrType)
193                  CheckInference();
194              p = new NpgsqlParameter&lt;T&gt; { TypedValue = valueFactory() };
195              cmd.Parameters.Add(p);
196              errorIdentifier[++errorIdentifierIndex] = &quot;Value only (generic)&quot;;
197              if (isNpgsqlDbTypeInferredFromClrType)
198                  CheckInference();
199          }
200          Debug.Assert(cmd.Parameters.Count == errorIdentifierIndex + 1);
201          cmd.CommandText = &quot;SELECT &quot; + string.Join(&quot;, &quot;, Enumerable.Range(1, cmd.Parameters.Count).Select(i =&gt;
202              &quot;pg_typeof($1)::text, $1::text&quot;.Replace(&quot;$1&quot;, $&quot;${i}&quot;)));
203          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
204          await reader.ReadAsync();
205          for (var i = 0; i &lt; cmd.Parameters.Count * 2; i += 2)
206          {
207              Assert.That(reader[i], Is.EqualTo(pgTypeNameWithoutFacets), $&quot;Got wrong PG type name when writing with {errorIdentifier[i / 2]}&quot;);
208              Assert.That(reader[i+1], Is.EqualTo(expectedSqlLiteral), $&quot;Got wrong SQL literal when writing with {errorIdentifier[i / 2]}&quot;);
209          }
210          void CheckInference()
211          {
212              if (npgsqlDbType is not null)
213              {
214                  Assert.That(p.NpgsqlDbType, Is.EqualTo(npgsqlDbType),
215                      () =&gt; $&quot;Got wrong inferred NpgsqlDbType when inferring with {errorIdentifier[errorIdentifierIndex]}&quot;);
216              }
217              Assert.That(p.DbType, Is.EqualTo(inferredDbType ?? dbType ?? DbType.Object),
218                  () =&gt; $&quot;Got wrong inferred DbType when inferring with {errorIdentifier[errorIdentifierIndex]}&quot;);
219              Assert.That(p.DataTypeName, Is.EqualTo(pgTypeNameWithoutFacets),
220                  () =&gt; $&quot;Got wrong inferred DataTypeName when inferring with {errorIdentifier[errorIdentifierIndex]}&quot;);
221          }
222      }
223      public async Task AssertTypeUnsupported&lt;T&gt;(T value, string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
224      {
225          await AssertTypeUnsupportedRead&lt;T&gt;(sqlLiteral, pgTypeName, dataSource);
226          await AssertTypeUnsupportedWrite(value, pgTypeName, dataSource);
227      }
228      public async Task AssertTypeUnsupportedRead(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
229      {
230          dataSource ??= DefaultDataSource;
231          await using var conn = await dataSource.OpenConnectionAsync();
232          await using var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{sqlLiteral}&#x27;::{pgTypeName}&quot;, conn);
233          await using var reader = await cmd.ExecuteReaderAsync();
234          await reader.ReadAsync();
235          Assert.That(() =&gt; reader.GetValue(0), Throws.Exception.TypeOf&lt;InvalidCastException&gt;());
236      }
237      public Task&lt;InvalidCastException&gt; AssertTypeUnsupportedRead&lt;T&gt;(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
238          =&gt; AssertTypeUnsupportedRead&lt;T, InvalidCastException&gt;(sqlLiteral, pgTypeName, dataSource);
239      public async Task&lt;TException&gt; AssertTypeUnsupportedRead&lt;T, TException&gt;(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
240          where TException : Exception
241      {
242          dataSource ??= DefaultDataSource;
243          await using var conn = await dataSource.OpenConnectionAsync();
244          await using var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{sqlLiteral}&#x27;::{pgTypeName}&quot;, conn);
245          await using var reader = await cmd.ExecuteReaderAsync();
246          await reader.ReadAsync();
247          return Assert.Throws&lt;TException&gt;(() =&gt; reader.GetFieldValue&lt;T&gt;(0))!;
248      }
249      public Task&lt;InvalidCastException&gt; AssertTypeUnsupportedWrite&lt;T&gt;(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
250          =&gt; AssertTypeUnsupportedWrite&lt;T, InvalidCastException&gt;(value, pgTypeName, dataSource);
251      public async Task&lt;TException&gt; AssertTypeUnsupportedWrite&lt;T, TException&gt;(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
252          where TException : Exception
253      {
254          dataSource ??= DefaultDataSource;
255          await using var conn = await dataSource.OpenConnectionAsync();
256          await using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn)
257          {
258              Parameters = { new() { Value = value } }
259          };
260          if (pgTypeName is not null)
261              cmd.Parameters[0].DataTypeName = pgTypeName;
262          return Assert.ThrowsAsync&lt;TException&gt;(() =&gt; cmd.ExecuteReaderAsync())!;
263      }
264      class SimpleComparer&lt;T&gt; : IEqualityComparer&lt;T&gt;
265      {
266          readonly Func&lt;T, T, bool&gt; _comparerDelegate;
267          public SimpleComparer(Func&lt;T, T, bool&gt; comparerDelegate)
268              =&gt; _comparerDelegate = comparerDelegate;
269          public bool Equals(T? x, T? y)
270              =&gt; x is null
271                  ? y is null
272                  : y is not null &amp;&amp; _comparerDelegate(x, y);
273          public int GetHashCode(T obj) =&gt; throw new NotSupportedException();
274      }
275      #endregion Type testing
276      #region Utilities for use by tests
277      protected static readonly NpgsqlDataSource SharedDataSource = NpgsqlDataSource.Create(TestUtil.ConnectionString);
278      protected virtual NpgsqlDataSourceBuilder CreateDataSourceBuilder()
279          =&gt; new(ConnectionString);
280      protected virtual NpgsqlDataSource CreateDataSource()
281          =&gt; CreateDataSource(ConnectionString);
282      protected virtual NpgsqlDataSource CreateDataSource(string connectionString)
283          =&gt; NpgsqlDataSource.Create(connectionString);
284      protected virtual NpgsqlDataSource CreateDataSource(Action&lt;NpgsqlConnectionStringBuilder&gt; connectionStringBuilderAction)
285      {
286          var connectionStringBuilder = new NpgsqlConnectionStringBuilder(ConnectionString);
287          connectionStringBuilderAction(connectionStringBuilder);
288          return NpgsqlDataSource.Create(connectionStringBuilder);
289      }
290      protected static NpgsqlDataSource GetDataSource(string connectionString)
291      {
292          if (!DataSources.TryGetValue(connectionString, out var dataSource))
293          {
294              lock (dataSourceLockObject)
295              {
296                  if (!DataSources.TryGetValue(connectionString, out dataSource))
297                  {
298                      DataSources[connectionString] = dataSource = NpgsqlDataSource.Create(connectionString);
299                  }
300              }
301          }
302          return dataSource;
303      }
304      protected virtual NpgsqlDataSource CreateLoggingDataSource(
305          out ListLoggerProvider listLoggerProvider,
306          string? connectionString = null,
307          bool sensitiveDataLoggingEnabled = true)
308      {
309          var builder = new NpgsqlDataSourceBuilder(connectionString ?? ConnectionString);
310          var provider = listLoggerProvider = new ListLoggerProvider();
311          builder.UseLoggerFactory(LoggerFactory.Create(loggerFactoryBuilder =&gt;
312          {
313              loggerFactoryBuilder.SetMinimumLevel(LogLevel.Trace);
314              loggerFactoryBuilder.AddProvider(provider);
315          }));
316          builder.EnableParameterLogging(sensitiveDataLoggingEnabled);
317          return builder.Build();
318      }
319      protected NpgsqlDataSource DefaultDataSource
320          =&gt; GetDataSource(ConnectionString);
321      protected virtual NpgsqlConnection CreateConnection()
322          =&gt; DefaultDataSource.CreateConnection();
323      protected virtual NpgsqlConnection OpenConnection()
324      {
325          var connection = CreateConnection();
326          try
327          {
328              OpenConnection(connection, async: false).GetAwaiter().GetResult();
329              return connection;
330          }
331          catch
332          {
333              connection.Dispose();
334              throw;
335          }
336      }
337      protected virtual async ValueTask&lt;NpgsqlConnection&gt; OpenConnectionAsync()
338      {
339          var connection = CreateConnection();
340          try
341          {
342              await OpenConnection(connection, async: true);
343              return connection;
344          }
345          catch
346          {
347              await connection.DisposeAsync();
348              throw;
349          }
350      }
351      static Task OpenConnection(NpgsqlConnection conn, bool async)
352      {
353          return OpenConnectionInternal(hasLock: false);
354          async Task OpenConnectionInternal(bool hasLock)
355          {
356              try
357              {
358                  if (async)
359                      await conn.OpenAsync();
360                  else
361                      conn.Open();
362              }
363              catch (PostgresException e)
364              {
365                  if (e.SqlState == PostgresErrorCodes.InvalidPassword)
366                      throw new Exception(&quot;Please create a user npgsql_tests as follows: CREATE USER npgsql_tests PASSWORD &#x27;npgsql_tests&#x27; SUPERUSER&quot;);
367                  if (e.SqlState == PostgresErrorCodes.InvalidCatalogName)
368                  {
369                      if (!hasLock)
370                      {
371                          DatabaseCreationLock.Wait();
372                          try
373                          {
374                              await OpenConnectionInternal(hasLock: true);
375                          }
376                          finally
377                          {
378                              DatabaseCreationLock.Release();
379                          }
380                      }
381                      var builder = new NpgsqlConnectionStringBuilder(TestUtil.ConnectionString)
382                      {
383                          Pooling = false,
384                          Multiplexing = false,
385                          Database = &quot;postgres&quot;
386                      };
387                      using var adminConn = new NpgsqlConnection(builder.ConnectionString);
388                      adminConn.Open();
389                      adminConn.ExecuteNonQuery(&quot;CREATE DATABASE &quot; + conn.Database);
390                      adminConn.Close();
391                      Thread.Sleep(1000);
392                      if (async)
393                          await conn.OpenAsync();
394                      else
395                          conn.Open();
396                      return;
397                  }
398                  throw;
399              }
400          }
401      }
402      protected static NpgsqlCommand CreateSleepCommand(NpgsqlConnection conn, int seconds = 1000)
403          =&gt; new($&quot;SELECT pg_sleep({seconds}){(conn.PostgreSqlVersion &lt; new Version(9, 1, 0) ? &quot;::TEXT&quot; : &quot;&quot;)}&quot;, conn);
404      #endregion
405  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics;
6  using System.Linq;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using Microsoft.Extensions.Logging;
10  using Npgsql.Tests.Support;
11  using NpgsqlTypes;
12  using NUnit.Framework;
13  namespace Npgsql.Tests;
14  public abstract class TestBase
15  {
16      public virtual string ConnectionString =&gt; TestUtil.ConnectionString;
17      static readonly SemaphoreSlim DatabaseCreationLock = new(1);
18      static readonly object dataSourceLockObject = new();
19      static ConcurrentDictionary&lt;string, NpgsqlDataSource&gt; DataSources = new(StringComparer.Ordinal);
20      #region Type testing
21      public async Task&lt;T&gt; AssertType&lt;T&gt;(
22          T value,
23          string sqlLiteral,
24          string pgTypeName,
25          NpgsqlDbType? npgsqlDbType,
26          DbType? dbType = null,
27          DbType? inferredDbType = null,
28          bool isDefaultForReading = true,
29          bool isDefaultForWriting = true,
30          bool? isDefault = null,
31          bool isNpgsqlDbTypeInferredFromClrType = true,
32          Func&lt;T, T, bool&gt;? comparer = null)
33      {
34          await using var connection = await OpenConnectionAsync();
35          return await AssertType(
36              connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading, isDefaultForWriting,
37              isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
38      }
39      public async Task&lt;T&gt; AssertType&lt;T&gt;(
40          NpgsqlDataSource dataSource,
41          T value,
42          string sqlLiteral,
<span onclick='openModal()' class='match'>43          string pgTypeName,
44          NpgsqlDbType? npgsqlDbType,
45          DbType? dbType = null,
46          DbType? inferredDbType = null,
47          bool isDefaultForReading = true,
48          bool isDefaultForWriting = true,
</span>49          bool? isDefault = null,
50          bool isNpgsqlDbTypeInferredFromClrType = true,
51          Func&lt;T, T, bool&gt;? comparer = null)
52      {
53          await using var connection = await dataSource.OpenConnectionAsync();
54          return await AssertType(connection, value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForReading,
55              isDefaultForWriting, isDefault, isNpgsqlDbTypeInferredFromClrType, comparer);
56      }
57      public async Task&lt;T&gt; AssertType&lt;T&gt;(
58          NpgsqlConnection connection,
59          T value,
60          string sqlLiteral,
61          string pgTypeName,
62          NpgsqlDbType? npgsqlDbType,
63          DbType? dbType = null,
64          DbType? inferredDbType = null,
65          bool isDefaultForReading = true,
66          bool isDefaultForWriting = true,
67          bool? isDefault = null,
68          bool isNpgsqlDbTypeInferredFromClrType = true,
69          Func&lt;T, T, bool&gt;? comparer = null)
70      {
71          if (isDefault is not null)
72              isDefaultForReading = isDefaultForWriting = isDefault.Value;
73          await AssertTypeWrite(connection, () =&gt; value, sqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefaultForWriting, isNpgsqlDbTypeInferredFromClrType);
74          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, value, isDefaultForReading, comparer);
75      }
76      public async Task&lt;T&gt; AssertTypeRead&lt;T&gt;(string sqlLiteral, string pgTypeName, T expected, bool isDefault = true)
77      {
78          await using var connection = await OpenConnectionAsync();
79          return await AssertTypeRead(connection, sqlLiteral, pgTypeName, expected, isDefault);
80      }
81      public async Task AssertTypeWrite&lt;T&gt;(
82          NpgsqlDataSource dataSource,
83          T value,
84          string expectedSqlLiteral,
85          string pgTypeName,
86          NpgsqlDbType npgsqlDbType,
87          DbType? dbType = null,
88          DbType? inferredDbType = null,
89          bool isDefault = true,
90          bool isNpgsqlDbTypeInferredFromClrType = true)
91      {
92          await using var connection = await dataSource.OpenConnectionAsync();
93          await AssertTypeWrite(connection, () =&gt; value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
94              isNpgsqlDbTypeInferredFromClrType);
95      }
96      public Task AssertTypeWrite&lt;T&gt;(
97          T value,
98          string expectedSqlLiteral,
99          string pgTypeName,
100          NpgsqlDbType npgsqlDbType,
101          DbType? dbType = null,
102          DbType? inferredDbType = null,
103          bool isDefault = true,
104          bool isNpgsqlDbTypeInferredFromClrType = true)
105          =&gt; AssertTypeWrite(() =&gt; value, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault,
106              isNpgsqlDbTypeInferredFromClrType);
107      public async Task AssertTypeWrite&lt;T&gt;(
108          Func&lt;T&gt; valueFactory,
109          string expectedSqlLiteral,
110          string pgTypeName,
111          NpgsqlDbType npgsqlDbType,
112          DbType? dbType = null,
113          DbType? inferredDbType = null,
114          bool isDefault = true,
115          bool isNpgsqlDbTypeInferredFromClrType = true)
116      {
117          await using var connection = await OpenConnectionAsync();
118          await AssertTypeWrite(connection, valueFactory, expectedSqlLiteral, pgTypeName, npgsqlDbType, dbType, inferredDbType, isDefault, isNpgsqlDbTypeInferredFromClrType);
119      }
120      internal static async Task&lt;T&gt; AssertTypeRead&lt;T&gt;(
121          NpgsqlConnection connection,
122          string sqlLiteral,
123          string pgTypeName,
124          T expected,
125          bool isDefault = true,
126          Func&lt;T, T, bool&gt;? comparer = null)
127      {
128          if (sqlLiteral.Contains(&#x27;\&#x27;&#x27;))
129              sqlLiteral = sqlLiteral.Replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;);
130          await using var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{sqlLiteral}&#x27;::{pgTypeName}&quot;, connection);
131          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
132          await reader.ReadAsync();
133          var truncatedSqlLiteral = sqlLiteral.Length &gt; 40 ? sqlLiteral[..40] + &quot;...&quot; : sqlLiteral;
134          var dataTypeName = reader.GetDataTypeName(0);
135          var dotIndex = dataTypeName.IndexOf(&#x27;.&#x27;);
136          if (dotIndex &gt; -1 &amp;&amp; dataTypeName.Substring(0, dotIndex) is &quot;pg_catalog&quot; or &quot;public&quot;)
137              dataTypeName = dataTypeName.Substring(dotIndex + 1);
138          Assert.That(dataTypeName, Is.EqualTo(pgTypeName),
139              $&quot;Got wrong result from GetDataTypeName when reading &#x27;{truncatedSqlLiteral}&#x27;&quot;);
140          if (isDefault)
141          {
142              Assert.That(reader.GetFieldType(0), Is.EqualTo(dataTypeName.EndsWith(&quot;[]&quot;) ? typeof(Array) : typeof(T)),
143                  $&quot;Got wrong result from GetFieldType when reading &#x27;{truncatedSqlLiteral}&#x27;&quot;);
144          }
145          var actual = isDefault ? (T)reader.GetValue(0) : reader.GetFieldValue&lt;T&gt;(0);
146          Assert.That(actual, comparer is null ? Is.EqualTo(expected) : Is.EqualTo(expected).Using(new SimpleComparer&lt;T&gt;(comparer)),
147              $&quot;Got wrong result from GetFieldValue value when reading &#x27;{truncatedSqlLiteral}&#x27;&quot;);
148          return actual;
149      }
150      internal static async Task AssertTypeWrite&lt;T&gt;(
151          NpgsqlConnection connection,
152          Func&lt;T&gt; valueFactory,
153          string expectedSqlLiteral,
154          string pgTypeName,
155          NpgsqlDbType? npgsqlDbType,
156          DbType? dbType = null,
157          DbType? inferredDbType = null,
158          bool isDefault = true,
159          bool isNpgsqlDbTypeInferredFromClrType = true)
160      {
161          if (npgsqlDbType is null)
162              isNpgsqlDbTypeInferredFromClrType = false;
163          var parenIndex = pgTypeName.IndexOf(&#x27;(&#x27;);
164          var pgTypeNameWithoutFacets = parenIndex &gt; -1 ? pgTypeName[..parenIndex] : pgTypeName;
165          var errorIdentifierIndex = -1;
166          var errorIdentifier = new Dictionary&lt;int, string&gt;();
167          await using var cmd = new NpgsqlCommand { Connection = connection };
168          NpgsqlParameter p;
169          if (npgsqlDbType is not null)
170          {
171              p = new NpgsqlParameter { Value = valueFactory(), NpgsqlDbType = npgsqlDbType.Value };
172              cmd.Parameters.Add(p);
173              errorIdentifier[++errorIdentifierIndex] = $&quot;NpgsqlDbType={npgsqlDbType}&quot;;
174              CheckInference();
175          }
176          p = new NpgsqlParameter { Value = valueFactory(), DataTypeName = pgTypeNameWithoutFacets };
177          cmd.Parameters.Add(p);
178          errorIdentifier[++errorIdentifierIndex] = $&quot;DataTypeName={pgTypeNameWithoutFacets}&quot;;
179          CheckInference();
180          if (dbType is not null)
181          {
182              p = new NpgsqlParameter { Value = valueFactory(), DbType = dbType.Value };
183              cmd.Parameters.Add(p);
184              errorIdentifier[++errorIdentifierIndex] = $&quot;DbType={dbType}&quot;;
185              CheckInference();
186          }
187          if (isDefault)
188          {
189              p = new NpgsqlParameter { Value = valueFactory() };
190              cmd.Parameters.Add(p);
191              errorIdentifier[++errorIdentifierIndex] = &quot;Value only (non-generic)&quot;;
192              if (isNpgsqlDbTypeInferredFromClrType)
193                  CheckInference();
194              p = new NpgsqlParameter&lt;T&gt; { TypedValue = valueFactory() };
195              cmd.Parameters.Add(p);
196              errorIdentifier[++errorIdentifierIndex] = &quot;Value only (generic)&quot;;
197              if (isNpgsqlDbTypeInferredFromClrType)
198                  CheckInference();
199          }
200          Debug.Assert(cmd.Parameters.Count == errorIdentifierIndex + 1);
201          cmd.CommandText = &quot;SELECT &quot; + string.Join(&quot;, &quot;, Enumerable.Range(1, cmd.Parameters.Count).Select(i =&gt;
202              &quot;pg_typeof($1)::text, $1::text&quot;.Replace(&quot;$1&quot;, $&quot;${i}&quot;)));
203          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
204          await reader.ReadAsync();
205          for (var i = 0; i &lt; cmd.Parameters.Count * 2; i += 2)
206          {
207              Assert.That(reader[i], Is.EqualTo(pgTypeNameWithoutFacets), $&quot;Got wrong PG type name when writing with {errorIdentifier[i / 2]}&quot;);
208              Assert.That(reader[i+1], Is.EqualTo(expectedSqlLiteral), $&quot;Got wrong SQL literal when writing with {errorIdentifier[i / 2]}&quot;);
209          }
210          void CheckInference()
211          {
212              if (npgsqlDbType is not null)
213              {
214                  Assert.That(p.NpgsqlDbType, Is.EqualTo(npgsqlDbType),
215                      () =&gt; $&quot;Got wrong inferred NpgsqlDbType when inferring with {errorIdentifier[errorIdentifierIndex]}&quot;);
216              }
217              Assert.That(p.DbType, Is.EqualTo(inferredDbType ?? dbType ?? DbType.Object),
218                  () =&gt; $&quot;Got wrong inferred DbType when inferring with {errorIdentifier[errorIdentifierIndex]}&quot;);
219              Assert.That(p.DataTypeName, Is.EqualTo(pgTypeNameWithoutFacets),
220                  () =&gt; $&quot;Got wrong inferred DataTypeName when inferring with {errorIdentifier[errorIdentifierIndex]}&quot;);
221          }
222      }
223      public async Task AssertTypeUnsupported&lt;T&gt;(T value, string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
224      {
225          await AssertTypeUnsupportedRead&lt;T&gt;(sqlLiteral, pgTypeName, dataSource);
226          await AssertTypeUnsupportedWrite(value, pgTypeName, dataSource);
227      }
228      public async Task AssertTypeUnsupportedRead(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
229      {
230          dataSource ??= DefaultDataSource;
231          await using var conn = await dataSource.OpenConnectionAsync();
232          await using var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{sqlLiteral}&#x27;::{pgTypeName}&quot;, conn);
233          await using var reader = await cmd.ExecuteReaderAsync();
234          await reader.ReadAsync();
235          Assert.That(() =&gt; reader.GetValue(0), Throws.Exception.TypeOf&lt;InvalidCastException&gt;());
236      }
237      public Task&lt;InvalidCastException&gt; AssertTypeUnsupportedRead&lt;T&gt;(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
238          =&gt; AssertTypeUnsupportedRead&lt;T, InvalidCastException&gt;(sqlLiteral, pgTypeName, dataSource);
239      public async Task&lt;TException&gt; AssertTypeUnsupportedRead&lt;T, TException&gt;(string sqlLiteral, string pgTypeName, NpgsqlDataSource? dataSource = null)
240          where TException : Exception
241      {
242          dataSource ??= DefaultDataSource;
243          await using var conn = await dataSource.OpenConnectionAsync();
244          await using var cmd = new NpgsqlCommand($&quot;SELECT &#x27;{sqlLiteral}&#x27;::{pgTypeName}&quot;, conn);
245          await using var reader = await cmd.ExecuteReaderAsync();
246          await reader.ReadAsync();
247          return Assert.Throws&lt;TException&gt;(() =&gt; reader.GetFieldValue&lt;T&gt;(0))!;
248      }
249      public Task&lt;InvalidCastException&gt; AssertTypeUnsupportedWrite&lt;T&gt;(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
250          =&gt; AssertTypeUnsupportedWrite&lt;T, InvalidCastException&gt;(value, pgTypeName, dataSource);
251      public async Task&lt;TException&gt; AssertTypeUnsupportedWrite&lt;T, TException&gt;(T value, string? pgTypeName = null, NpgsqlDataSource? dataSource = null)
252          where TException : Exception
253      {
254          dataSource ??= DefaultDataSource;
255          await using var conn = await dataSource.OpenConnectionAsync();
256          await using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn)
257          {
258              Parameters = { new() { Value = value } }
259          };
260          if (pgTypeName is not null)
261              cmd.Parameters[0].DataTypeName = pgTypeName;
262          return Assert.ThrowsAsync&lt;TException&gt;(() =&gt; cmd.ExecuteReaderAsync())!;
263      }
264      class SimpleComparer&lt;T&gt; : IEqualityComparer&lt;T&gt;
265      {
266          readonly Func&lt;T, T, bool&gt; _comparerDelegate;
267          public SimpleComparer(Func&lt;T, T, bool&gt; comparerDelegate)
268              =&gt; _comparerDelegate = comparerDelegate;
269          public bool Equals(T? x, T? y)
270              =&gt; x is null
271                  ? y is null
272                  : y is not null &amp;&amp; _comparerDelegate(x, y);
273          public int GetHashCode(T obj) =&gt; throw new NotSupportedException();
274      }
275      #endregion Type testing
276      #region Utilities for use by tests
277      protected static readonly NpgsqlDataSource SharedDataSource = NpgsqlDataSource.Create(TestUtil.ConnectionString);
278      protected virtual NpgsqlDataSourceBuilder CreateDataSourceBuilder()
279          =&gt; new(ConnectionString);
280      protected virtual NpgsqlDataSource CreateDataSource()
281          =&gt; CreateDataSource(ConnectionString);
282      protected virtual NpgsqlDataSource CreateDataSource(string connectionString)
283          =&gt; NpgsqlDataSource.Create(connectionString);
284      protected virtual NpgsqlDataSource CreateDataSource(Action&lt;NpgsqlConnectionStringBuilder&gt; connectionStringBuilderAction)
285      {
286          var connectionStringBuilder = new NpgsqlConnectionStringBuilder(ConnectionString);
287          connectionStringBuilderAction(connectionStringBuilder);
288          return NpgsqlDataSource.Create(connectionStringBuilder);
289      }
290      protected static NpgsqlDataSource GetDataSource(string connectionString)
291      {
292          if (!DataSources.TryGetValue(connectionString, out var dataSource))
293          {
294              lock (dataSourceLockObject)
295              {
296                  if (!DataSources.TryGetValue(connectionString, out dataSource))
297                  {
298                      DataSources[connectionString] = dataSource = NpgsqlDataSource.Create(connectionString);
299                  }
300              }
301          }
302          return dataSource;
303      }
304      protected virtual NpgsqlDataSource CreateLoggingDataSource(
305          out ListLoggerProvider listLoggerProvider,
306          string? connectionString = null,
307          bool sensitiveDataLoggingEnabled = true)
308      {
309          var builder = new NpgsqlDataSourceBuilder(connectionString ?? ConnectionString);
310          var provider = listLoggerProvider = new ListLoggerProvider();
311          builder.UseLoggerFactory(LoggerFactory.Create(loggerFactoryBuilder =&gt;
312          {
313              loggerFactoryBuilder.SetMinimumLevel(LogLevel.Trace);
314              loggerFactoryBuilder.AddProvider(provider);
315          }));
316          builder.EnableParameterLogging(sensitiveDataLoggingEnabled);
317          return builder.Build();
318      }
319      protected NpgsqlDataSource DefaultDataSource
320          =&gt; GetDataSource(ConnectionString);
321      protected virtual NpgsqlConnection CreateConnection()
322          =&gt; DefaultDataSource.CreateConnection();
323      protected virtual NpgsqlConnection OpenConnection()
324      {
325          var connection = CreateConnection();
326          try
327          {
328              OpenConnection(connection, async: false).GetAwaiter().GetResult();
329              return connection;
330          }
331          catch
332          {
333              connection.Dispose();
334              throw;
335          }
336      }
337      protected virtual async ValueTask&lt;NpgsqlConnection&gt; OpenConnectionAsync()
338      {
339          var connection = CreateConnection();
340          try
341          {
342              await OpenConnection(connection, async: true);
343              return connection;
344          }
345          catch
346          {
347              await connection.DisposeAsync();
348              throw;
349          }
350      }
351      static Task OpenConnection(NpgsqlConnection conn, bool async)
352      {
353          return OpenConnectionInternal(hasLock: false);
354          async Task OpenConnectionInternal(bool hasLock)
355          {
356              try
357              {
358                  if (async)
359                      await conn.OpenAsync();
360                  else
361                      conn.Open();
362              }
363              catch (PostgresException e)
364              {
365                  if (e.SqlState == PostgresErrorCodes.InvalidPassword)
366                      throw new Exception(&quot;Please create a user npgsql_tests as follows: CREATE USER npgsql_tests PASSWORD &#x27;npgsql_tests&#x27; SUPERUSER&quot;);
367                  if (e.SqlState == PostgresErrorCodes.InvalidCatalogName)
368                  {
369                      if (!hasLock)
370                      {
371                          DatabaseCreationLock.Wait();
372                          try
373                          {
374                              await OpenConnectionInternal(hasLock: true);
375                          }
376                          finally
377                          {
378                              DatabaseCreationLock.Release();
379                          }
380                      }
381                      var builder = new NpgsqlConnectionStringBuilder(TestUtil.ConnectionString)
382                      {
383                          Pooling = false,
384                          Multiplexing = false,
385                          Database = &quot;postgres&quot;
386                      };
387                      using var adminConn = new NpgsqlConnection(builder.ConnectionString);
388                      adminConn.Open();
389                      adminConn.ExecuteNonQuery(&quot;CREATE DATABASE &quot; + conn.Database);
390                      adminConn.Close();
391                      Thread.Sleep(1000);
392                      if (async)
393                          await conn.OpenAsync();
394                      else
395                          conn.Open();
396                      return;
397                  }
398                  throw;
399              }
400          }
401      }
402      protected static NpgsqlCommand CreateSleepCommand(NpgsqlConnection conn, int seconds = 1000)
403          =&gt; new($&quot;SELECT pg_sleep({seconds}){(conn.PostgreSqlVersion &lt; new Version(9, 1, 0) ? &quot;::TEXT&quot; : &quot;&quot;)}&quot;, conn);
404      #endregion
405  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TestBase.cs</div>
                </div>
                <div class="column column_space"><pre><code>61          string pgTypeName,
62          NpgsqlDbType? npgsqlDbType,
63          DbType? dbType = null,
64          DbType? inferredDbType = null,
65          bool isDefaultForReading = true,
66          bool isDefaultForWriting = true,
</pre></code></div>
                <div class="column column_space"><pre><code>43          string pgTypeName,
44          NpgsqlDbType? npgsqlDbType,
45          DbType? dbType = null,
46          DbType? inferredDbType = null,
47          bool isDefaultForReading = true,
48          bool isDefaultForWriting = true,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    