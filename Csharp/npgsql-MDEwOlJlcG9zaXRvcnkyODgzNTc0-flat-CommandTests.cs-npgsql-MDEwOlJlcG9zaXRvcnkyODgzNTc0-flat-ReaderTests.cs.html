
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</h3>
            <pre><code>1  using Npgsql.BackendMessages;
2  using Npgsql.Internal;
3  using Npgsql.Tests.Support;
4  using Npgsql.TypeMapping;
5  using NpgsqlTypes;
6  using NUnit.Framework;
7  using System;
8  using System.Buffers.Binary;
9  using System.Data;
10  using System.Linq;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using static Npgsql.Tests.TestUtil;
15  namespace Npgsql.Tests;
16  public class CommandTests : MultiplexingTestBase
17  {
18      #region Legacy batching
19      [Test]
20      [TestCase(new[] { true }, TestName = "SingleQuery")]
21      [TestCase(new[] { false }, TestName = "SingleNonQuery")]
22      [TestCase(new[] { true, true }, TestName = "TwoQueries")]
23      [TestCase(new[] { false, false }, TestName = "TwoNonQueries")]
24      [TestCase(new[] { false, true }, TestName = "NonQueryQuery")]
25      [TestCase(new[] { true, false }, TestName = "QueryNonQuery")]
26      public async Task Multiple_statements(bool[] queries)
27      {
28          await using var conn = await OpenConnectionAsync();
29          var table = await CreateTempTable(conn, "name TEXT");
30          var sb = new StringBuilder();
31          foreach (var query in queries)
32              sb.Append(query ? "SELECT 1;" : $"UPDATE {table} SET name='yo' WHERE 1=0;");
33          var sql = sb.ToString();
34          foreach (var prepare in new[] { false, true })
35          {
36              await using var cmd = conn.CreateCommand();
37              cmd.CommandText = sql;
38              if (prepare && !IsMultiplexing)
39                  await cmd.PrepareAsync();
40              await using var reader = await cmd.ExecuteReaderAsync();
41              var numResultSets = queries.Count(q => q);
42              for (var i = 0; i < numResultSets; i++)
43              {
44                  Assert.That(await reader.ReadAsync(), Is.True);
45                  Assert.That(reader[0], Is.EqualTo(1));
46                  Assert.That(await reader.NextResultAsync(), Is.EqualTo(i != numResultSets - 1));
47              }
48          }
49      }
50      [Test]
51      public async Task Multiple_statements_with_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
52      {
53          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
54              return;
55          await using var conn = await OpenConnectionAsync();
56          await using var cmd = conn.CreateCommand();
57          cmd.CommandText = "SELECT @p1; SELECT @p2";
58          var p1 = new NpgsqlParameter("p1", NpgsqlDbType.Integer);
59          var p2 = new NpgsqlParameter("p2", NpgsqlDbType.Text);
60          cmd.Parameters.Add(p1);
61          cmd.Parameters.Add(p2);
62          if (prepare == PrepareOrNot.Prepared)
63              cmd.Prepare();
64          p1.Value = 8;
65          p2.Value = "foo";
66          await using var reader = await cmd.ExecuteReaderAsync();
67          Assert.That(await reader.ReadAsync(), Is.True);
68          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
69          Assert.That(await reader.NextResultAsync(), Is.True);
70          Assert.That(await reader.ReadAsync(), Is.True);
71          Assert.That(reader.GetString(0), Is.EqualTo("foo"));
72          Assert.That(await reader.NextResultAsync(), Is.False);
73      }
74      [Test]
75      public async Task SingleRow_legacy_batching([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
76      {
77          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
78              return;
79          using var conn = await OpenConnectionAsync();
80          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2", conn);
81          if (prepare == PrepareOrNot.Prepared)
82              cmd.Prepare();
83          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
84          Assert.That(reader.Read(), Is.True);
85          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
86          Assert.That(reader.Read(), Is.False);
87          Assert.That(reader.NextResult(), Is.False);
88      }
89      [Test, Description("Makes sure a later command can depend on an earlier one")]
90      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/641")]
91      public async Task Multiple_statements_with_dependencies()
92      {
93          using var conn = await OpenConnectionAsync();
94          var table = await CreateTempTable(conn, "a INT");
95          await conn.ExecuteNonQueryAsync($"ALTER TABLE {table} ADD COLUMN b INT; INSERT INTO {table} (b) VALUES (8)");
96          Assert.That(await conn.ExecuteScalarAsync($"SELECT b FROM {table}"), Is.EqualTo(8));
97      }
98      [Test, Description("Forces async write mode when the first statement in a multi-statement command is big")]
99      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/641")]
100      public async Task Multiple_statements_large_first_command()
101      {
102          using var conn = await OpenConnectionAsync();
103          using var cmd = new NpgsqlCommand($"SELECT repeat('X', {conn.Settings.WriteBufferSize}); SELECT @p", conn);
104          var expected1 = new string('X', conn.Settings.WriteBufferSize);
105          var expected2 = new string('Y', conn.Settings.WriteBufferSize);
106          cmd.Parameters.AddWithValue("p", expected2);
107          using var reader = await cmd.ExecuteReaderAsync();
108          reader.Read();
109          Assert.That(reader.GetString(0), Is.EqualTo(expected1));
110          reader.NextResult();
111          reader.Read();
112          Assert.That(reader.GetString(0), Is.EqualTo(expected2));
113      }
114      [Test]
115      [NonParallelizable] 
116      public async Task Legacy_batching_is_not_supported_when_EnableSqlParsing_is_disabled()
117      {
118          using var _ = DisableSqlRewriting();
119          using var conn = await OpenConnectionAsync();
120          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2", conn);
121          Assert.That(async () => await cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf<PostgresException>()
122              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
123      }
124      #endregion
125      #region Timeout
126      [Test, Description("Checks that CommandTimeout gets enforced as a socket timeout")]
127      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/327")]
128      public async Task Timeout()
129      {
130          if (IsMultiplexing)
131              return; 
132          await using var dataSource = CreateDataSource(csb => csb.CommandTimeout = 1);
133          await using var conn = await dataSource.OpenConnectionAsync();
134          await using var cmd = CreateSleepCommand(conn, 10);
135          Assert.That(() => cmd.ExecuteNonQuery(), Throws.Exception
136              .TypeOf<NpgsqlException>()
137              .With.InnerException.TypeOf<TimeoutException>()
138          );
139          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
140      }
141      [Test, Description("Times out an async operation, testing that cancellation occurs successfully")]
142      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/607")]
143      public async Task Timeout_async_soft()
144      {
145          if (IsMultiplexing)
146              return; 
147          await using var dataSource = CreateDataSource(csb => csb.CommandTimeout = 1);
148          await using var conn = await dataSource.OpenConnectionAsync();
149          await using var cmd = CreateSleepCommand(conn, 10);
150          Assert.That(async () => await cmd.ExecuteNonQueryAsync(),
151              Throws.Exception
152                  .TypeOf<NpgsqlException>()
153                  .With.InnerException.TypeOf<TimeoutException>());
154          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
155      }
156      [Test, Description("Times out an async operation, with unsuccessful cancellation (socket break)")]
157      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/607")]
158      public async Task Timeout_async_hard()
159      {
160          if (IsMultiplexing)
161              return; 
162          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
163          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
165          await using var conn = await dataSource.OpenConnectionAsync();
166          await postmasterMock.WaitForServerConnection();
167          var processId = conn.ProcessID;
168          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"),
169              Throws.Exception
170                  .TypeOf<NpgsqlException>()
171                  .With.InnerException.TypeOf<TimeoutException>());
172          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
173          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
174              Is.EqualTo(processId));
175      }
176      [Test]
177      public async Task Timeout_from_connection_string()
178      {
179          Assert.That(NpgsqlConnector.MinimumInternalCommandTimeout, Is.Not.EqualTo(NpgsqlCommand.DefaultTimeout));
180          var timeout = NpgsqlConnector.MinimumInternalCommandTimeout;
181          await using var dataSource = CreateDataSource(csb => csb.CommandTimeout = timeout);
182          await using var conn = await dataSource.OpenConnectionAsync();
183          await using var command = new NpgsqlCommand("SELECT 1", conn);
184          Assert.That(command.CommandTimeout, Is.EqualTo(timeout));
185          command.CommandTimeout = 10;
186          await command.ExecuteScalarAsync();
187          Assert.That(command.CommandTimeout, Is.EqualTo(10));
188      }
189      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/395")]
190      public async Task Timeout_switch_connection()
191      {
192          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
193          if (csb.CommandTimeout >= 100 && csb.CommandTimeout < 105)
194              IgnoreExceptOnBuildServer("Bad default command timeout");
195          await using var dataSource1 = CreateDataSource(ConnectionString + ";CommandTimeout=100");
196          await using var c1 = dataSource1.CreateConnection();
197          await using var cmd = c1.CreateCommand();
198          Assert.That(cmd.CommandTimeout, Is.EqualTo(100));
199          await using var dataSource2 = CreateDataSource(ConnectionString + ";CommandTimeout=101");
200          await using (var c2 = dataSource2.CreateConnection())
201          {
202              cmd.Connection = c2;
203              Assert.That(cmd.CommandTimeout, Is.EqualTo(101));
204          }
205          cmd.CommandTimeout = 102;
206          await using (var c2 = dataSource2.CreateConnection())
207          {
208              cmd.Connection = c2;
209              Assert.That(cmd.CommandTimeout, Is.EqualTo(102));
210          }
211      }
212      [Test]
213      public async Task Prepare_timeout_hard([Values] SyncOrAsync async)
214      {
215          if (IsMultiplexing)
216              return; 
217          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
218          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
219          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
220          await using var conn = await dataSource.OpenConnectionAsync();
221          await postmasterMock.WaitForServerConnection();
222          var processId = conn.ProcessID;
223          var cmd = new NpgsqlCommand("SELECT 1", conn);
224          Assert.That(async () =>
225              {
226                  if (async == SyncOrAsync.Sync)
227                      cmd.Prepare();
228                  else
229                      await cmd.PrepareAsync();
230              },
231              Throws.Exception
232                  .TypeOf<NpgsqlException>()
233                  .With.InnerException.TypeOf<TimeoutException>());
234          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
235          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
236              Is.EqualTo(processId));
237      }
238      #endregion
239      #region Cancel
240      [Test, Description("Basic cancellation scenario")]
241      [Ignore("Flaky, see https:&bsol;&bsol;github.com/npgsql/npgsql/issues/5070")]
242      public async Task Cancel()
243      {
244          if (IsMultiplexing)
245              return;
246          await using var conn = await OpenConnectionAsync();
247          await using var cmd = CreateSleepCommand(conn, 5);
248          var queryTask = Task.Run(() => cmd.ExecuteNonQuery());
249          cmd.WaitUntilCommandIsInProgress();
250          cmd.Cancel();
251          Assert.That(async () => await queryTask, Throws
252              .TypeOf<OperationCanceledException>()
253              .With.InnerException.TypeOf<PostgresException>()
254              .With.InnerException.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled)
255          );
256      }
257      [Test]
258      public async Task Cancel_async_immediately()
259      {
260          if (IsMultiplexing)
261              return; 
262          await using var conn = await OpenConnectionAsync();
263          await using var cmd = conn.CreateCommand();
264          cmd.CommandText = "SELECT 1";
265          var t = cmd.ExecuteScalarAsync(new(canceled: true));
266          Assert.That(t.IsCompleted, Is.True); 
267          Assert.That(t.Status, Is.EqualTo(TaskStatus.Canceled));
268          Assert.ThrowsAsync<OperationCanceledException>(async () => await t);
269          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
270          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
271      }
272      [Test, Description("Cancels an async query with the cancellation token, with successful PG cancellation")]
273      [Explicit("Flaky due to #5033")]
274      public async Task Cancel_async_soft()
275      {
276          if (IsMultiplexing)
277              return; 
278          await using var conn = await OpenConnectionAsync();
279          await using var cmd = CreateSleepCommand(conn);
280          using var cancellationSource = new CancellationTokenSource();
281          var t = cmd.ExecuteNonQueryAsync(cancellationSource.Token);
282          cancellationSource.Cancel();
283          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await t)!;
284          Assert.That(exception.InnerException,
285              Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
286          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
287          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
288          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
289      }
290      [Test, Description("Cancels an async query with the cancellation token, with unsuccessful PG cancellation (socket break)")]
291      public async Task Cancel_async_hard()
292      {
293          if (IsMultiplexing)
294              return; 
295          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
296          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
297          await using var conn = await dataSource.OpenConnectionAsync();
298          await postmasterMock.WaitForServerConnection();
299          var processId = conn.ProcessID;
300          using var cancellationSource = new CancellationTokenSource();
301          using var cmd = new NpgsqlCommand("SELECT 1", conn);
302          var t = cmd.ExecuteScalarAsync(cancellationSource.Token);
303          cancellationSource.Cancel();
304          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await t)!;
305          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
306          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
307          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
308          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
309              Is.EqualTo(processId));
310      }
311      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3466")]
312      [Ignore("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4668")]
313      public async Task Bug3466([Values(false, true)] bool isBroken)
314      {
315          if (IsMultiplexing)
316              return; 
317          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
318          {
319              Pooling = false
320          };
321          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString(), completeCancellationImmediately: false);
322          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
323          await using var conn = await dataSource.OpenConnectionAsync();
324          var serverMock = await postmasterMock.WaitForServerConnection();
325          var processId = conn.ProcessID;
326          using var cancellationSource = new CancellationTokenSource();
327          await using var cmd = new NpgsqlCommand("SELECT 1", conn)
328          {
329              CommandTimeout = 4
330          };
331          var t = Task.Run(() => cmd.ExecuteScalar());
332          cmd.WaitUntilCommandIsInProgress();
333          var cancelTask = Task.Run(() => cmd.Cancel());
334          var cancellationRequest = await postmasterMock.WaitForCancellationRequest();
335          if (isBroken)
336          {
337              Assert.ThrowsAsync<OperationCanceledException>(async () => await t);
338              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
339          }
340          else
341          {
342              await serverMock
343                  .WriteParseComplete()
344                  .WriteBindComplete()
345                  .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
346                  .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
347                  .WriteCommandComplete()
348                  .WriteReadyForQuery()
349                  .FlushAsync();
350              Assert.DoesNotThrowAsync(async () => await t);
351              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
352              await conn.CloseAsync();
353          }
354          cancellationRequest.Complete();
355          Assert.DoesNotThrowAsync(async () => await cancelTask);
356      }
357      [Test, Description("Check that cancel only affects the command on which its was invoked")]
358      [Explicit("Timing-sensitive")]
359      public async Task Cancel_cross_command()
360      {
361          await using var conn = await OpenConnectionAsync();
362          await using var cmd1 = CreateSleepCommand(conn, 2);
363          await using var cmd2 = new NpgsqlCommand("SELECT 1", conn);
364          var cancelTask = Task.Factory.StartNew(() =>
365          {
366              Thread.Sleep(300);
367              cmd2.Cancel();
368          });
369          Assert.That(() => cmd1.ExecuteNonQueryAsync(), Throws.Nothing);
370          cancelTask.Wait();
371      }
372      #endregion
373      #region Cursors
374      [Test]
375      public async Task Cursor_statement()
376      {
377          using var conn = await OpenConnectionAsync();
378          var table = await CreateTempTable(conn, "name TEXT");
379          using var t = conn.BeginTransaction();
380          for (var x = 0; x < 5; x++)
381              await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES ('X')");
382          var i = 0;
383          var command = new NpgsqlCommand($"DECLARE TE CURSOR FOR SELECT * FROM {table}", conn);
384          command.ExecuteNonQuery();
385          command.CommandText = "FETCH FORWARD 3 IN TE";
386          var dr = command.ExecuteReader();
387          while (dr.Read())
388              i++;
389          Assert.AreEqual(3, i);
390          dr.Close();
391          i = 0;
392          command.CommandText = "FETCH BACKWARD 1 IN TE";
393          var dr2 = command.ExecuteReader();
394          while (dr2.Read())
395              i++;
396          Assert.AreEqual(1, i);
397          dr2.Close();
398          command.CommandText = "close te;";
399          command.ExecuteNonQuery();
400      }
401      [Test]
402      public async Task Cursor_move_RecordsAffected()
403      {
404          using var connection = await OpenConnectionAsync();
405          using var transaction = connection.BeginTransaction();
406          var command = new NpgsqlCommand("DECLARE curs CURSOR FOR SELECT * FROM (VALUES (1), (2), (3)) as t", connection);
407          command.ExecuteNonQuery();
408          command.CommandText = "MOVE FORWARD ALL IN curs";
409          var count = command.ExecuteNonQuery();
410          Assert.AreEqual(3, count);
411      }
412      #endregion
413      #region CommandBehavior.CloseConnection
414      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/693")]
415      public async Task CloseConnection()
416      {
417          using var conn = await OpenConnectionAsync();
418          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
419          using (var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection))
420              while (reader.Read()) {}
421          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
422      }
423      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1194")]
424      public async Task CloseConnection_with_open_reader_with_CloseConnection()
425      {
426          using var conn = await OpenConnectionAsync();
427          var cmd = new NpgsqlCommand("SELECT 1", conn);
428          var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection);
429          var wasClosed = false;
430          reader.ReaderClosed += (sender, args) => { wasClosed = true; };
431          conn.Close();
432          Assert.That(wasClosed, Is.True);
433      }
434      [Test]
435      public async Task CloseConnection_with_exception()
436      {
437          using var conn = await OpenConnectionAsync();
438          using (var cmd = new NpgsqlCommand("SE", conn))
439              Assert.That(() => cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection), Throws.Exception.TypeOf<PostgresException>());
440          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
441      }
442      #endregion
443      [Test]
444      public async Task SingleRow([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
445      {
446          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
447              return;
448          await using var conn = await OpenConnectionAsync();
449          await using var cmd = new NpgsqlCommand("SELECT 1, 2 UNION SELECT 3, 4", conn);
450          if (prepare == PrepareOrNot.Prepared)
451              cmd.Prepare();
452          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
453          Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidOperationException>());
454          Assert.That(reader.Read(), Is.True);
455          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
456          Assert.That(reader.Read(), Is.False);
457      }
458      #region Parameters
459      [Test]
460      public async Task Positional_parameter()
461      {
462          await using var conn = await OpenConnectionAsync();
463          await using var cmd = new NpgsqlCommand("SELECT $1", conn);
464          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
465          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
466      }
467      [Test]
468      public async Task Positional_parameters_are_not_supported_with_legacy_batching()
469      {
470          await using var conn = await OpenConnectionAsync();
471          await using var cmd = new NpgsqlCommand("SELECT $1; SELECT $1", conn);
472          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
473          Assert.That(async () => await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<PostgresException>()
474              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
475      }
476      [Test]
477      [NonParallelizable] 
478      public async Task Positional_parameters_are_supported_when_EnableSqlParsing_is_disabled()
479      {
480          using var _ = DisableSqlRewriting();
481          using var conn = await OpenConnectionAsync();
482          using var cmd = new NpgsqlCommand("SELECT $1", conn);
483          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
484          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
485      }
486      [Test]
487      [NonParallelizable] 
488      public async Task Named_parameters_are_not_supported_when_EnableSqlParsing_is_disabled()
489      {
490          using var _ = DisableSqlRewriting();
491          using var conn = await OpenConnectionAsync();
492          using var cmd = new NpgsqlCommand("SELECT @p", conn);
493          cmd.Parameters.Add(new NpgsqlParameter("p", 8));
494          Assert.That(async () => await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<NotSupportedException>());
495      }
496      [Test, Description("Makes sure writing an unset parameter isn't allowed")]
497      public async Task Parameter_without_Value()
498      {
499          using var conn = await OpenConnectionAsync();
500          using var cmd = new NpgsqlCommand("SELECT @p", conn);
501          cmd.Parameters.Add(new NpgsqlParameter("@p", NpgsqlDbType.Integer));
502          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<InvalidCastException>());
503      }
504      [Test]
505      public async Task Unreferenced_named_parameter_works()
506      {
507          await using var conn = await OpenConnectionAsync();
508          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
509          cmd.Parameters.AddWithValue("not_used", 8);
510          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
511      }
512      [Test]
513      public async Task Unreferenced_positional_parameter_works()
514      {
515          await using var conn = await OpenConnectionAsync();
516          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
517          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
518          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
519      }
520      [Test]
521      public async Task Mixing_positional_and_named_parameters_is_not_supported()
522      {
523          await using var conn = await OpenConnectionAsync();
524          await using var cmd = new NpgsqlCommand("SELECT $1, @p", conn);
525          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
526          cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p", Value = 9 });
527          Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf<NotSupportedException>());
528      }
529      [Test]
530      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4171")]
531      public async Task Cached_command_clears_parameters_placeholder_type()
532      {
533          await using var conn = await OpenConnectionAsync();
534          await using (var cmd1 = conn.CreateCommand())
535          {
536              cmd1.CommandText = "SELECT @p1";
537              cmd1.Parameters.AddWithValue("@p1", 8);
538              await using var reader1 = await cmd1.ExecuteReaderAsync();
539              reader1.Read();
540              Assert.That(reader1[0], Is.EqualTo(8));
541          }
542          await using (var cmd2 = conn.CreateCommand())
543          {
544              cmd2.CommandText = "SELECT $1";
545              cmd2.Parameters.AddWithValue(8);
546              await using var reader2 = await cmd2.ExecuteReaderAsync();
547              reader2.Read();
548              Assert.That(reader2[0], Is.EqualTo(8));
549          }
550      }
551      [Test]
552      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4171")]
553      public async Task Reuse_command_with_different_parameter_placeholder_types()
554      {
555          await using var conn = await OpenConnectionAsync();
556          await using var cmd = conn.CreateCommand();
557          cmd.CommandText = "SELECT @p1";
558          cmd.Parameters.AddWithValue("@p1", 8);
559          _ = await cmd.ExecuteScalarAsync();
560          cmd.CommandText = "SELECT $1";
561          cmd.Parameters[0].ParameterName = null;
562          _ = await cmd.ExecuteScalarAsync();
563      }
564      [Test]
565      public async Task Positional_output_parameters_are_not_supported()
566      {
567          await using var conn = await OpenConnectionAsync();
568          await using var cmd = new NpgsqlCommand("SELECT $1", conn);
569          cmd.Parameters.Add(new NpgsqlParameter { Value = 8, Direction = ParameterDirection.InputOutput });
570          Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf<NotSupportedException>());
571      }
572      [Test]
573      public void Parameters_get_name()
574      {
575          var command = new NpgsqlCommand();
576          command.Parameters.Add(new NpgsqlParameter(":Parameter1", DbType.Boolean));
577          command.Parameters.Add(new NpgsqlParameter(":Parameter2", DbType.Int32));
578          command.Parameters.Add(new NpgsqlParameter(":Parameter3", DbType.DateTime));
579          command.Parameters.Add(new NpgsqlParameter("Parameter4", DbType.DateTime));
580          var idbPrmtr = command.Parameters["Parameter1"];
581          Assert.IsNotNull(idbPrmtr);
582          command.Parameters[0].Value = 1;
583          Assert.AreEqual(":Parameter1", command.Parameters["Parameter1"].ParameterName);
584          Assert.AreEqual(":Parameter2", command.Parameters["Parameter2"].ParameterName);
585          Assert.AreEqual(":Parameter3", command.Parameters["Parameter3"].ParameterName);
586          Assert.AreEqual("Parameter4", command.Parameters["Parameter4"].ParameterName); 
587          Assert.AreEqual(":Parameter1", command.Parameters[0].ParameterName);
588          Assert.AreEqual(":Parameter2", command.Parameters[1].ParameterName);
589          Assert.AreEqual(":Parameter3", command.Parameters[2].ParameterName);
590          Assert.AreEqual("Parameter4", command.Parameters[3].ParameterName);
591      }
592      [Test]
593      public async Task Same_param_multiple_times()
594      {
595          using var conn = await OpenConnectionAsync();
596          using var cmd = new NpgsqlCommand("SELECT @p1, @p1", conn);
597          cmd.Parameters.AddWithValue("@p1", 8);
598          using var reader = await cmd.ExecuteReaderAsync();
599          reader.Read();
600          Assert.That(reader[0], Is.EqualTo(8));
601          Assert.That(reader[1], Is.EqualTo(8));
602      }
603      [Test]
604      public async Task Generic_parameter()
605      {
606          using var conn = await OpenConnectionAsync();
607          using var cmd = new NpgsqlCommand("SELECT @p1, @p2, @p3, @p4", conn);
608          cmd.Parameters.Add(new NpgsqlParameter<int>("p1", 8));
609          cmd.Parameters.Add(new NpgsqlParameter<short>("p2", 8) { NpgsqlDbType = NpgsqlDbType.Integer });
610          cmd.Parameters.Add(new NpgsqlParameter<string>("p3", "hello"));
611          cmd.Parameters.Add(new NpgsqlParameter<char[]>("p4", new[] { 'f', 'o', 'o' }));
612          using var reader = await cmd.ExecuteReaderAsync();
613          reader.Read();
614          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
615          Assert.That(reader.GetInt32(1), Is.EqualTo(8));
616          Assert.That(reader.GetString(2), Is.EqualTo("hello"));
617          Assert.That(reader.GetString(3), Is.EqualTo("foo"));
618      }
619      #endregion Parameters
620      [Test]
621      public async Task CommandText_not_set()
622      {
623          await using var conn = await OpenConnectionAsync();
624          await using (var cmd = new NpgsqlCommand())
625          {
626              cmd.Connection = conn;
627              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf<InvalidOperationException>());
628              cmd.CommandText = null;
629              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf<InvalidOperationException>());
630              cmd.CommandText = "";
631          }
632          await using (var cmd = conn.CreateCommand())
633              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf<InvalidOperationException>());
634      }
635      [Test]
636      public async Task ExecuteScalar()
637      {
638          await using var conn = await OpenConnectionAsync();
639          var table = await CreateTempTable(conn, "name TEXT");
640          await using var command = new NpgsqlCommand($"SELECT name FROM {table}", conn);
641          Assert.That(command.ExecuteScalarAsync, Is.Null);
642          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES (NULL)");
643          Assert.That(command.ExecuteScalarAsync, Is.EqualTo(DBNull.Value));
644          await conn.ExecuteNonQueryAsync($"TRUNCATE {table}");
645          for (var i = 0; i < 2; i++)
646              await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES ('X')");
647          Assert.That(command.ExecuteScalarAsync, Is.EqualTo("X"));
648      }
649      [Test]
650      public async Task ExecuteNonQuery()
651      {
652          await using var conn = await OpenConnectionAsync();
653          await using var cmd = new NpgsqlCommand { Connection = conn };
654          var table = await CreateTempTable(conn, "name TEXT");
655          cmd.CommandText = $"INSERT INTO {table} (name) VALUES ('John')";
656          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
657          cmd.CommandText = $"INSERT INTO {table} (name) VALUES ('John'); INSERT INTO {table} (name) VALUES ('John')";
658          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(2));
659          cmd.CommandText = $"INSERT INTO {table} (name) VALUES ('{new string('x', conn.Settings.WriteBufferSize)}')";
660          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
661      }
662      [Test, Description("Makes sure a command is unusable after it is disposed")]
663      public async Task Dispose()
664      {
665          await using var conn = await OpenConnectionAsync();
666          var cmd = new NpgsqlCommand("SELECT 1", conn);
667          cmd.Dispose();
668          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
669          Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
670          Assert.That(() => cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
671          Assert.That(() => cmd.PrepareAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
672      }
673      [Test, Description("Disposing a command with an open reader does not close the reader. This is the SqlClient behavior.")]
674      public async Task Command_Dispose_does_not_close_reader()
675      {
676          await using var conn = await OpenConnectionAsync();
677          var cmd = new NpgsqlCommand("SELECT 1, 2", conn);
678          await cmd.ExecuteReaderAsync();
679          cmd.Dispose();
680          cmd = new NpgsqlCommand("SELECT 3", conn);
681          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
682      }
683      [Test]
684      public async Task Non_standards_conforming_strings()
685      {
686          await using var dataSource = CreateDataSource();
687          await using var conn = await dataSource.OpenConnectionAsync();
688          if (IsMultiplexing)
689          {
690              Assert.That(async () => await conn.ExecuteNonQueryAsync("set standard_conforming_strings=off"),
691                  Throws.Exception.TypeOf<NotSupportedException>());
692          }
693          else
694          {
695              await conn.ExecuteNonQueryAsync("set standard_conforming_strings=off");
696              Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
697              await conn.ExecuteNonQueryAsync("set standard_conforming_strings=on");
698          }
699      }
700      [Test]
701      public async Task Parameter_and_operator_unclear()
702      {
703          await using var conn = await OpenConnectionAsync();
704          await using var command = new NpgsqlCommand("select :arr[2]", conn);
705          command.Parameters.AddWithValue(":arr", new int[] {5, 4, 3, 2, 1});
706          await using var rdr = await command.ExecuteReaderAsync();
707          rdr.Read();
708          Assert.AreEqual(rdr.GetInt32(0), 4);
709      }
710      [Test]
711      [TestCase(CommandBehavior.Default)]
712      [TestCase(CommandBehavior.SequentialAccess)]
713      public async Task Statement_mapped_output_parameters(CommandBehavior behavior)
714      {
715          await using var conn = await OpenConnectionAsync();
716          var command = new NpgsqlCommand("select 3, 4 as param1, 5 as param2, 6;", conn);
717          var p = new NpgsqlParameter("param2", NpgsqlDbType.Integer);
718          p.Direction = ParameterDirection.Output;
719          p.Value = -1;
720          command.Parameters.Add(p);
721          p = new NpgsqlParameter("param1", NpgsqlDbType.Integer);
722          p.Direction = ParameterDirection.Output;
723          p.Value = -1;
724          command.Parameters.Add(p);
725          p = new NpgsqlParameter("p", NpgsqlDbType.Integer);
726          p.Direction = ParameterDirection.Output;
727          p.Value = -1;
728          command.Parameters.Add(p);
729          await using var reader = await command.ExecuteReaderAsync(behavior);
730          Assert.AreEqual(4, command.Parameters["param1"].Value);
731          Assert.AreEqual(5, command.Parameters["param2"].Value);
732          reader.Read();
733          Assert.AreEqual(3, reader.GetInt32(0));
734          Assert.AreEqual(4, reader.GetInt32(1));
735          Assert.AreEqual(5, reader.GetInt32(2));
736          Assert.AreEqual(6, reader.GetInt32(3));
737      }
738      [Test]
739      public async Task Bug1006158_output_parameters()
740      {
741          await using var conn = await OpenConnectionAsync();
742          MinimumPgVersion(conn, "14.0", "Stored procedure OUT parameters are only support starting with version 14");
<span onclick='openModal()' class='match'>743          var sproc = await GetTempProcedureName(conn);
744          var createFunction = $@"
745  CREATE PROCEDURE {sproc}(OUT a integer, OUT b boolean) AS $$
746  BEGIN
747      a := 3;
748      b := true;
749  END
750  $$ LANGUAGE plpgsql;";
751          var command = new NpgsqlCommand(createFunction, conn);
</span>752          await command.ExecuteNonQueryAsync();
753          command = new NpgsqlCommand(sproc, conn);
754          command.CommandType = CommandType.StoredProcedure;
755          command.Parameters.Add(new NpgsqlParameter("a", DbType.Int32));
756          command.Parameters[0].Direction = ParameterDirection.Output;
757          command.Parameters.Add(new NpgsqlParameter("b", DbType.Boolean));
758          command.Parameters[1].Direction = ParameterDirection.Output;
759          _ = await command.ExecuteScalarAsync();
760          Assert.AreEqual(3, command.Parameters[0].Value);
761          Assert.AreEqual(true, command.Parameters[1].Value);
762      }
763      [Test]
764      public async Task Bug1010788_UpdateRowSource()
765      {
766          if (IsMultiplexing)
767              return;
768          using var conn = await OpenConnectionAsync();
769          var table = await CreateTempTable(conn, "id SERIAL PRIMARY KEY, name TEXT");
770          var command = new NpgsqlCommand($"SELECT * FROM {table}", conn);
771          Assert.AreEqual(UpdateRowSource.Both, command.UpdatedRowSource);
772          var cmdBuilder = new NpgsqlCommandBuilder();
773          var da = new NpgsqlDataAdapter(command);
774          cmdBuilder.DataAdapter = da;
775          Assert.IsNotNull(da.SelectCommand);
776          Assert.IsNotNull(cmdBuilder.DataAdapter);
777          var updateCommand = cmdBuilder.GetUpdateCommand();
778          Assert.AreEqual(UpdateRowSource.None, updateCommand.UpdatedRowSource);
779      }
780      [Test]
781      public async Task TableDirect()
782      {
783          using var conn = await OpenConnectionAsync();
784          var table = await CreateTempTable(conn, "name TEXT");
785          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES ('foo')");
786          using var cmd = new NpgsqlCommand(table, conn) { CommandType = CommandType.TableDirect };
787          using var rdr = await cmd.ExecuteReaderAsync();
788          Assert.That(rdr.Read(), Is.True);
789          Assert.That(rdr["name"], Is.EqualTo("foo"));
790      }
791      [Test]
792      [TestCase(CommandBehavior.Default)]
793      [TestCase(CommandBehavior.SequentialAccess)]
794      public async Task Input_and_output_parameters(CommandBehavior behavior)
795      {
796          using var conn = await OpenConnectionAsync();
797          using var cmd = new NpgsqlCommand("SELECT @c-1 AS c, @a+2 AS b", conn);
798          cmd.Parameters.Add(new NpgsqlParameter("a", 3));
799          var b = new NpgsqlParameter { ParameterName = "b", Direction = ParameterDirection.Output };
800          cmd.Parameters.Add(b);
801          var c = new NpgsqlParameter { ParameterName = "c", Direction = ParameterDirection.InputOutput, Value = 4 };
802          cmd.Parameters.Add(c);
803          using (await cmd.ExecuteReaderAsync(behavior))
804          {
805              Assert.AreEqual(5, b.Value);
806              Assert.AreEqual(3, c.Value);
807          }
808      }
809      [Test]
810      public async Task Send_NpgsqlDbType_Unknown([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
811      {
812          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
813              return;
814          using var conn = await OpenConnectionAsync();
815          using var cmd = new NpgsqlCommand("SELECT @p::TIMESTAMP", conn);
816          cmd.CommandText = "SELECT @p::TIMESTAMP";
817          cmd.Parameters.Add(new NpgsqlParameter("p", NpgsqlDbType.Unknown) { Value = "2008-1-1" });
818          if (prepare == PrepareOrNot.Prepared)
819              cmd.Prepare();
820          using var reader = await cmd.ExecuteReaderAsync();
821          reader.Read();
822          Assert.That(reader.GetValue(0), Is.EqualTo(new DateTime(2008, 1, 1)));
823      }
824      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/503")]
825      public async Task Invalid_UTF8()
826      {
827          const string badString = "SELECT 'abc\uD801\uD802d'";
828          await using var dataSource = CreateDataSource();
829          using var conn = await dataSource.OpenConnectionAsync();
830          Assert.That(() => conn.ExecuteScalarAsync(badString), Throws.Exception.TypeOf<EncoderFallbackException>());
831      }
832      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/395")]
833      public async Task Use_across_connection_change([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
834      {
835          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
836              return;
837          using var conn1 = await OpenConnectionAsync();
838          using var conn2 = await OpenConnectionAsync();
839          using var cmd = new NpgsqlCommand("SELECT 1", conn1);
840          if (prepare == PrepareOrNot.Prepared)
841              cmd.Prepare();
842          cmd.Connection = conn2;
843          Assert.That(cmd.IsPrepared, Is.False);
844          if (prepare == PrepareOrNot.Prepared)
845              cmd.Prepare();
846          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
847      }
848      [Test, Description("CreateCommand before connection open")]
849      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/565")]
850      public async Task Create_command_before_connection_open()
851      {
852          using var conn = new NpgsqlConnection(ConnectionString);
853          var cmd = new NpgsqlCommand("SELECT 1", conn);
854          conn.Open();
855          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
856      }
857      [Test]
858      public void Connection_not_set_throws()
859      {
860          var cmd = new NpgsqlCommand("SELECT 1");
861          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<InvalidOperationException>());
862      }
863      [Test]
864      public void Connection_not_open_throws()
865      {
866          using var conn = CreateConnection();
867          var cmd = new NpgsqlCommand("SELECT 1", conn);
868          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<InvalidOperationException>());
869      }
870      [Test]
871      public async Task ExecuteNonQuery_Throws_PostgresException([Values] bool async)
872      {
873          if (!async && IsMultiplexing)
874              return;
875          await using var conn = await OpenConnectionAsync();
876          var table1 = await CreateTempTable(conn, "id integer PRIMARY key, t varchar(40)");
877          var table2 = await CreateTempTable(conn, $"id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED");
878          var sql = $"insert into {table2} ({table1}_id) values (1) returning id";
879          var ex = async
880              ? Assert.ThrowsAsync<PostgresException>(async () => await conn.ExecuteNonQueryAsync(sql))
881              : Assert.Throws<PostgresException>(() => conn.ExecuteNonQuery(sql));
882          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
883      }
884      [Test]
885      public async Task ExecuteScalar_Throws_PostgresException([Values] bool async)
886      {
887          if (!async && IsMultiplexing)
888              return;
889          await using var conn = await OpenConnectionAsync();
890          var table1 = await CreateTempTable(conn, "id integer PRIMARY key, t varchar(40)");
891          var table2 = await CreateTempTable(conn, $"id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED");
892          var sql = $"insert into {table2} ({table1}_id) values (1) returning id";
893          var ex = async
894              ? Assert.ThrowsAsync<PostgresException>(async () => await conn.ExecuteScalarAsync(sql))
895              : Assert.Throws<PostgresException>(() => conn.ExecuteScalar(sql));
896          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
897      }
898      [Test]
899      public async Task ExecuteReader_Throws_PostgresException([Values] bool async)
900      {
901          if (!async && IsMultiplexing)
902              return;
903          await using var conn = await OpenConnectionAsync();
904          var table1 = await CreateTempTable(conn, "id integer PRIMARY key, t varchar(40)");
905          var table2 = await CreateTempTable(conn, $"id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED");
906          await using var cmd = conn.CreateCommand();
907          cmd.CommandText = $"insert into {table2} ({table1}_id) values (1) returning id";
908          await using var reader = async
909              ? await cmd.ExecuteReaderAsync()
910              : cmd.ExecuteReader();
911          Assert.IsTrue(async ? await reader.ReadAsync() : reader.Read());
912          var value = reader.GetInt32(0);
913          Assert.That(value, Is.EqualTo(1));
914          Assert.IsFalse(async ? await reader.ReadAsync() : reader.Read());
915          var ex = async
916              ? Assert.ThrowsAsync<PostgresException>(async () => await reader.NextResultAsync())
917              : Assert.Throws<PostgresException>(() => reader.NextResult());
918          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
919      }
920      [Test]
921      public void Command_is_recycled()
922      {
923          using var conn = OpenConnection();
924          var cmd1 = conn.CreateCommand();
925          cmd1.CommandText = "SELECT @p1";
926          var tx = conn.BeginTransaction();
927          cmd1.Transaction = tx;
928          cmd1.Parameters.AddWithValue("p1", 8);
929          _ = cmd1.ExecuteScalar();
930          cmd1.Dispose();
931          var cmd2 = conn.CreateCommand();
932          Assert.That(cmd2, Is.SameAs(cmd1));
933          Assert.That(cmd2.CommandText, Is.Empty);
934          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
935          Assert.That(cmd2.Transaction, Is.Null);
936          Assert.That(cmd2.Parameters, Is.Empty);
937      }
938      [Test]
939      public void Command_recycled_resets_CommandType()
940      {
941          using var conn = CreateConnection();
942          var cmd1 = conn.CreateCommand();
943          cmd1.CommandType = CommandType.StoredProcedure;
944          cmd1.Dispose();
945          var cmd2 = conn.CreateCommand();
946          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
947      }
948      [Test]
949      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/831")]
950      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2795")]
951      public async Task Many_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
952      {
953          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
954              return;
955          using var conn = await OpenConnectionAsync();
956          var table = await CreateTempTable(conn, "some_column INT");
957          using var cmd = new NpgsqlCommand { Connection = conn };
958          var sb = new StringBuilder($"INSERT INTO {table} (some_column) VALUES ");
959          for (var i = 0; i < ushort.MaxValue; i++)
960          {
961              var paramName = "p" + i;
962              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
963              if (i > 0)
964                  sb.Append(", ");
965              sb.Append($"(@{paramName})");
966          }
967          cmd.CommandText = sb.ToString();
968          if (prepare == PrepareOrNot.Prepared)
969              cmd.Prepare();
970          await cmd.ExecuteNonQueryAsync();
971      }
972      [Test, Description("Bypasses PostgreSQL's uint16 limitation on the number of parameters")]
973      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/831")]
974      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/858")]
975      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2703")]
976      public async Task Too_many_parameters_throws([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
977      {
978          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
979              return;
980          using var conn = await OpenConnectionAsync();
981          using var cmd = new NpgsqlCommand { Connection = conn };
982          var sb = new StringBuilder("SOME RANDOM SQL ");
983          for (var i = 0; i < ushort.MaxValue + 1; i++)
984          {
985              var paramName = "p" + i;
986              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
987              if (i > 0)
988                  sb.Append(", ");
989              sb.Append('@');
990              sb.Append(paramName);
991          }
992          cmd.CommandText = sb.ToString();
993          if (prepare == PrepareOrNot.Prepared)
994          {
995              Assert.That(() => cmd.Prepare(), Throws.Exception
996                  .InstanceOf<NpgsqlException>()
997                  .With.Message.EqualTo("A statement cannot have more than 65535 parameters"));
998          }
999          else
1000          {
1001              Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception
1002                  .InstanceOf<NpgsqlException>()
1003                  .With.Message.EqualTo("A statement cannot have more than 65535 parameters"));
1004          }
1005      }
1006      [Test, Description("An individual statement cannot have more than 65535 parameters, but a command can (across multiple statements).")]
1007      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1199")]
1008      public async Task Many_parameters_across_statements()
1009      {
1010          using var conn = await OpenConnectionAsync();
1011          using var cmd = new NpgsqlCommand { Connection = conn };
1012          var paramIndex = 0;
1013          var sb = new StringBuilder();
1014          for (var statementIndex = 0; statementIndex < 1000; statementIndex++)
1015          {
1016              if (statementIndex > 0)
1017                  sb.Append("; ");
1018              sb.Append("SELECT ");
1019              var startIndex = paramIndex;
1020              var endIndex = paramIndex + 70;
1021              for (; paramIndex < endIndex; paramIndex++)
1022              {
1023                  var paramName = "p" + paramIndex;
1024                  cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
1025                  if (paramIndex > startIndex)
1026                      sb.Append(", ");
1027                  sb.Append('@');
1028                  sb.Append(paramName);
1029              }
1030          }
1031          cmd.CommandText = sb.ToString();
1032          await cmd.ExecuteNonQueryAsync();
1033      }
1034      [Test, Description("Makes sure that Npgsql doesn't attempt to send all data before the user can start reading. That would cause a deadlock.")]
1035      public async Task Batched_big_statements_do_not_deadlock()
1036      {
1037          var data = new string('x', 1024);
1038          using var conn = await OpenConnectionAsync();
1039          var sb = new StringBuilder();
1040          for (var i = 0; i < 500; i++)
1041              sb.Append("SELECT @p;");
1042          using var cmd = new NpgsqlCommand(sb.ToString(), conn);
1043          cmd.Parameters.AddWithValue("p", NpgsqlDbType.Text, data);
1044          using var reader = await cmd.ExecuteReaderAsync();
1045          for (var i = 0; i < 500; i++)
1046          {
1047              reader.Read();
1048              Assert.That(reader.GetString(0), Is.EqualTo(data));
1049              reader.NextResult();
1050          }
1051      }
1052      [Test]
1053      public void Batched_small_then_big_statements_do_not_deadlock_in_sync_io()
1054      {
1055          if (IsMultiplexing)
1056              return; 
1057          using var conn = OpenConnection();
1058          var data = new string('x', 5_000_000);
1059          using var cmd = new NpgsqlCommand("SELECT generate_series(1, 500000); SELECT @p", conn);
1060          cmd.Parameters.AddWithValue("p", NpgsqlDbType.Text, data);
1061          cmd.ExecuteNonQuery();
1062      }
1063      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1429")]
1064      public async Task Same_command_different_param_values()
1065      {
1066          using var conn = await OpenConnectionAsync();
1067          using var cmd = new NpgsqlCommand("SELECT @p", conn);
1068          cmd.Parameters.AddWithValue("p", 8);
1069          await cmd.ExecuteNonQueryAsync();
1070          cmd.Parameters[0].Value = 9;
1071          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1072      }
1073      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1429")]
1074      public async Task Same_command_different_param_instances()
1075      {
1076          using var conn = await OpenConnectionAsync();
1077          using var cmd = new NpgsqlCommand("SELECT @p", conn);
1078          cmd.Parameters.AddWithValue("p", 8);
1079          await cmd.ExecuteNonQueryAsync();
1080          cmd.Parameters.RemoveAt(0);
1081          cmd.Parameters.AddWithValue("p", 9);
1082          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1083      }
1084      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3509"), Ignore("Flaky")]
1085      public async Task Bug3509()
1086      {
1087          if (IsMultiplexing)
1088              return;
1089          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1090          {
1091              KeepAlive = 1,
1092          };
1093          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1094          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1095          await using var conn = await dataSource.OpenConnectionAsync();
1096          var serverMock = await postmasterMock.WaitForServerConnection();
1097          await serverMock.WaitForData();
1098          var queryTask = Task.Run(async () => await conn.ExecuteNonQueryAsync("SELECT 1"));
1099          await Task.Delay(300);
1100          await serverMock
1101              .WriteErrorResponse("42")
1102              .WriteReadyForQuery()
1103              .FlushAsync();
1104          await serverMock
1105              .WriteScalarResponseAndFlush(1);
1106          var ex = Assert.ThrowsAsync<NpgsqlException>(async () => await queryTask)!;
1107          Assert.That(ex.InnerException, Is.TypeOf<NpgsqlException>()
1108              .With.InnerException.TypeOf<PostgresException>());
1109      }
1110      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4134")]
1111      public async Task Cached_command_double_dispose()
1112      {
1113          await using var conn = await OpenConnectionAsync();
1114          var cmd1 = conn.CreateCommand();
1115          cmd1.Dispose();
1116          cmd1.Dispose();
1117          var cmd2 = conn.CreateCommand();
1118          Assert.That(cmd2, Is.SameAs(cmd1));
1119          cmd2.CommandText = "SELECT 1";
1120          Assert.That(await cmd2.ExecuteScalarAsync(), Is.EqualTo(1));
1121      }
1122      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4330")]
1123      public async Task Prepare_with_positional_placeholders_after_named()
1124      {
1125          if (IsMultiplexing)
1126              return; 
1127          await using var conn = await OpenConnectionAsync();
1128          await using var command = new NpgsqlCommand("SELECT @p", conn);
1129          command.Parameters.AddWithValue("p", 10);
1130          await command.ExecuteNonQueryAsync();
1131          command.Parameters.Clear();
1132          command.CommandText = "SELECT $1";
1133          command.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer });
1134          Assert.DoesNotThrowAsync(() => command.PrepareAsync());
1135      }
1136      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4621")]
1137      [Description("Most of 08* errors are coming whenever there was an error while connecting to a remote server from a cluster, so the connection to the cluster is still OK")]
1138      public async Task Postgres_connection_errors_not_break_connection()
1139      {
1140          if (IsMultiplexing)
1141              return;
1142          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1143          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1144          await using var conn = await dataSource.OpenConnectionAsync();
1145          await using var cmd = conn.CreateCommand();
1146          cmd.CommandText = "SELECT 1";
1147          var queryTask = cmd.ExecuteNonQueryAsync();
1148          var server = await postmasterMock.WaitForServerConnection();
1149          await server
1150              .WriteErrorResponse(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection)
1151              .WriteReadyForQuery()
1152              .FlushAsync();
1153          var ex = Assert.ThrowsAsync<PostgresException>(async () => await queryTask)!;
1154          Assert.That(ex.SqlState, Is.EqualTo(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection));
1155          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
1156      }
1157      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4804")]
1158      [Description("Concurrent write and read failure can lead to deadlocks while cleaning up the connector.")]
1159      public async Task Concurrent_read_write_failure_deadlock()
1160      {
1161          if (IsMultiplexing)
1162              return;
1163          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1165          await using var conn = await dataSource.OpenConnectionAsync();
1166          await using var cmd = conn.CreateCommand();
1167          cmd.CommandText = new string('a', 8_000_000);
1168          var queryTask = cmd.ExecuteNonQueryAsync();
1169          var server = await postmasterMock.WaitForServerConnection();
1170          server.Close();
1171          Assert.ThrowsAsync<NpgsqlException>(async () => await queryTask);
1172      }
1173      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4906")]
1174      [Description("Make sure we don't cancel a prepended query (and do not deadlock in case of a failure)")]
1175      [Explicit("Flaky due to #5033")]
1176      public async Task Not_cancel_prepended_query([Values] bool failPrependedQuery)
1177      {
1178          if (IsMultiplexing)
1179              return;
1180          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1181          var csb = new NpgsqlConnectionStringBuilder(postmasterMock.ConnectionString)
1182          {
1183              NoResetOnClose = false
1184          };
1185          await using var dataSource = CreateDataSource(csb.ConnectionString);
1186          await using var conn = await dataSource.OpenConnectionAsync();
1187          await conn.CloseAsync();
1188          await conn.OpenAsync();
1189          using var cts = new CancellationTokenSource();
1190          var queryTask = conn.ExecuteNonQueryAsync("SELECT 1", cancellationToken: cts.Token);
1191          var server = await postmasterMock.WaitForServerConnection();
1192          await server.ExpectSimpleQuery("DISCARD ALL");
1193          await server.ExpectExtendedQuery();
1194          var cancelTask = Task.Run(cts.Cancel);
1195          var cancellationRequestTask = postmasterMock.WaitForCancellationRequest().AsTask();
1196          await Task.Delay(1000);
1197          Assert.IsFalse(cancelTask.IsCompleted);
1198          Assert.IsFalse(cancellationRequestTask.IsCompleted);
1199          if (failPrependedQuery)
1200          {
1201              await server
1202                  .WriteErrorResponse(PostgresErrorCodes.SyntaxError)
1203                  .WriteReadyForQuery()
1204                  .FlushAsync();
1205              await cancelTask;
1206              await cancellationRequestTask;
1207              Assert.ThrowsAsync<PostgresException>(async () => await queryTask);
1208              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
1209              return;
1210          }
1211          await server
1212              .WriteCommandComplete()
1213              .WriteReadyForQuery()
1214              .FlushAsync();
1215          await cancelTask;
1216          await cancellationRequestTask;
1217          await server
1218              .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1219              .WriteReadyForQuery()
1220              .FlushAsync();
1221          Assert.ThrowsAsync<OperationCanceledException>(async () => await queryTask);
1222          queryTask = conn.ExecuteNonQueryAsync("SELECT 1");
1223          await server.ExpectExtendedQuery();
1224          await server
1225              .WriteParseComplete()
1226              .WriteBindComplete()
1227              .WriteNoData()
1228              .WriteCommandComplete()
1229              .WriteReadyForQuery()
1230              .FlushAsync();
1231          await queryTask;
1232      }
1233      #region Logging
1234      [Test]
1235      public async Task Log_ExecuteScalar_single_statement_without_parameters()
1236      {
1237          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1238          await using var conn = await dataSource.OpenConnectionAsync();
1239          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
1240          using (listLoggerProvider.Record())
1241          {
1242              await cmd.ExecuteScalarAsync();
1243          }
1244          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1245          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains("SELECT 1"));
1246          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT 1");
1247          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
1248          if (!IsMultiplexing)
1249              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
1250      }
1251      [Test]
1252      public async Task Log_ExecuteScalar_single_statement_with_positional_parameters()
1253      {
1254          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1255          await using var conn = await dataSource.OpenConnectionAsync();
1256          await using var cmd = new NpgsqlCommand("SELECT $1, $2", conn);
1257          cmd.Parameters.Add(new() { Value = 8 });
1258          cmd.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1259          using (listLoggerProvider.Record())
1260          {
1261              await cmd.ExecuteScalarAsync();
1262          }
1263          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1264          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed")
1265              .And.Contains("SELECT $1, $2")
1266              .And.Contains("Parameters: [8, NULL]"));
1267          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT $1, $2");
1268          AssertLoggingStateContains(executingCommandEvent, "Parameters", new object[] { 8, "NULL" });
1269          if (!IsMultiplexing)
1270              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
1271      }
1272      [Test]
1273      public async Task Log_ExecuteScalar_single_statement_with_named_parameters()
1274      {
1275          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1276          await using var conn = await dataSource.OpenConnectionAsync();
1277          await using var cmd = new NpgsqlCommand("SELECT @p1, @p2", conn);
1278          cmd.Parameters.Add(new() { ParameterName = "p1", Value = 8 });
1279          cmd.Parameters.Add(new() { ParameterName = "p2", NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1280          using (listLoggerProvider.Record())
1281          {
1282              await cmd.ExecuteScalarAsync();
1283          }
1284          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1285          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed")
1286              .And.Contains("SELECT $1, $2")
1287              .And.Contains("Parameters: [8, NULL]"));
1288          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT $1, $2");
1289          AssertLoggingStateContains(executingCommandEvent, "Parameters", new object[] { 8, "NULL" });
1290          if (!IsMultiplexing)
1291              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
1292      }
1293      [Test]
1294      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
1295      {
1296          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
1297          await using var conn = await dataSource.OpenConnectionAsync();
1298          await using var cmd = new NpgsqlCommand("SELECT $1, $2", conn);
1299          cmd.Parameters.Add(new() { Value = 8 });
1300          cmd.Parameters.Add(new() { Value = 9 });
1301          using (listLoggerProvider.Record())
1302          {
1303              await cmd.ExecuteScalarAsync();
1304          }
1305          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1306          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains($"SELECT $1, $2"));
1307          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT $1, $2");
1308          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
1309      }
1310      #endregion Logging
1311      public CommandTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1312  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ReaderTests.cs</h3>
            <pre><code>1  using System;
2  using System.Buffers.Binary;
3  using System.Collections;
4  using System.Data;
5  using System.IO;
6  using System.Linq;
7  using System.Runtime.InteropServices;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using Npgsql.BackendMessages;
12  using Npgsql.Internal;
13  using Npgsql.Internal.TypeHandling;
14  using Npgsql.Internal.TypeMapping;
15  using Npgsql.PostgresTypes;
16  using Npgsql.Tests.Support;
17  using Npgsql.TypeMapping;
18  using Npgsql.Util;
19  using NpgsqlTypes;
20  using NUnit.Framework;
21  using static Npgsql.Tests.TestUtil;
22  namespace Npgsql.Tests;
23  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.Default)]
24  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.Default)]
25  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.SequentialAccess)]
26  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.SequentialAccess)]
27  public class ReaderTests : MultiplexingTestBase
28  {
29      [Test]
30      public async Task Seek_columns()
31      {
32          using var conn = await OpenConnectionAsync();
33          using var cmd = new NpgsqlCommand("SELECT 1,2,3", conn);
34          using var reader = await cmd.ExecuteReaderAsync(Behavior);
35          Assert.That(reader.Read(), Is.True);
36          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
37          if (IsSequential)
38              Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidOperationException>());
39          else
40              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
41          Assert.That(reader.GetInt32(1), Is.EqualTo(2));
42          if (IsSequential)
43              Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidOperationException>());
44          else
45              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
46      }
47      [Test]
48      public async Task No_resultset()
49      {
50          using var conn = await OpenConnectionAsync();
51          var table = await CreateTempTable(conn, "id INT");
52          using (var cmd = new NpgsqlCommand($"INSERT INTO {table} VALUES (8)", conn))
53          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
54          {
55              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
56              Assert.That(reader.Read(), Is.False);
57              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
58              Assert.That(reader.FieldCount, Is.EqualTo(0));
59              Assert.That(reader.NextResult(), Is.False);
60              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
61          }
62          using (var cmd = new NpgsqlCommand($"SELECT 1; INSERT INTO {table} VALUES (8)", conn))
63          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
64          {
65              await reader.NextResultAsync();
66              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
67              Assert.That(reader.Read(), Is.False);
68              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
69              Assert.That(reader.FieldCount, Is.EqualTo(0));
70          }
71      }
72      [Test]
73      public async Task Empty_resultset()
74      {
75          using var conn = await OpenConnectionAsync();
76          using var cmd = new NpgsqlCommand("SELECT 1 AS foo WHERE FALSE", conn);
77          using var reader = await cmd.ExecuteReaderAsync(Behavior);
78          Assert.That(reader.Read(), Is.False);
79          Assert.That(reader.FieldCount, Is.EqualTo(1));
80          Assert.That(reader.GetOrdinal("foo"), Is.EqualTo(0));
81          Assert.That(() => reader[0], Throws.Exception.TypeOf<InvalidOperationException>());
82      }
83      [Test]
84      public async Task FieldCount()
85      {
86          using var conn = await OpenConnectionAsync();
87          var table = await CreateTempTable(conn, "int INT");
88          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2,3", conn);
89          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
90          {
91              Assert.That(reader.FieldCount, Is.EqualTo(1));
92              Assert.That(reader.Read(), Is.True);
93              Assert.That(reader.FieldCount, Is.EqualTo(1));
94              Assert.That(reader.Read(), Is.False);
95              Assert.That(reader.FieldCount, Is.EqualTo(1));
96              Assert.That(reader.NextResult(), Is.True);
97              Assert.That(reader.FieldCount, Is.EqualTo(2));
98              Assert.That(reader.NextResult(), Is.False);
99              Assert.That(reader.FieldCount, Is.EqualTo(0));
100          }
101          cmd.CommandText = $"INSERT INTO {table} (int) VALUES (1)";
102          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
103          {
104              Assert.That(() => reader.FieldCount, Is.EqualTo(0));
105          }
106      }
107      [Test]
108      public async Task RecordsAffected()
109      {
110          using var conn = await OpenConnectionAsync();
111          var table = await CreateTempTable(conn, "int INT");
112          var sb = new StringBuilder();
113          for (var i = 0; i < 10; i++)
114              sb.Append($"INSERT INTO {table} (int) VALUES ({i});");
115          sb.Append("SELECT 1;"); 
116          for (var i = 10; i < 15; i++)
117              sb.Append($"INSERT INTO {table} (int) VALUES ({i});");
118          var cmd = new NpgsqlCommand(sb.ToString(), conn);
119          var reader = await cmd.ExecuteReaderAsync(Behavior);
120          reader.Close();
121          Assert.That(reader.RecordsAffected, Is.EqualTo(15));
122          cmd = new NpgsqlCommand($"SELECT * FROM {table}", conn);
123          reader = await cmd.ExecuteReaderAsync(Behavior);
124          reader.Close();
125          Assert.That(reader.RecordsAffected, Is.EqualTo(-1));
126          cmd = new NpgsqlCommand($"UPDATE {table} SET int=int+1 WHERE int > 10", conn);
127          reader = await cmd.ExecuteReaderAsync(Behavior);
128          reader.Close();
129          Assert.That(reader.RecordsAffected, Is.EqualTo(4));
130          cmd = new NpgsqlCommand($"UPDATE {table} SET int=8 WHERE int=666", conn);
131          reader = await cmd.ExecuteReaderAsync(Behavior);
132          reader.Close();
133          Assert.That(reader.RecordsAffected, Is.EqualTo(0));
134          cmd = new NpgsqlCommand($"DELETE FROM {table} WHERE int > 10", conn);
135          reader = await cmd.ExecuteReaderAsync(Behavior);
136          reader.Close();
137          Assert.That(reader.RecordsAffected, Is.EqualTo(4));
138          if (conn.PostgreSqlVersion.IsGreaterOrEqual(15))
139          {
140              cmd = new NpgsqlCommand($"MERGE INTO {table} S USING (SELECT 2 as int) T ON T.int = S.int WHEN MATCHED THEN UPDATE SET int = S.int", conn);
141              reader = await cmd.ExecuteReaderAsync(Behavior);
142              reader.Close();
143              Assert.That(reader.RecordsAffected, Is.EqualTo(1));
144          }
145      }
146  #pragma warning disable CS0618
147      [Test]
148      public async Task StatementOID_legacy_batching()
149      {
150          using var conn = await OpenConnectionAsync();
151          MaximumPgVersionExclusive(conn, "12.0",
152              "Support for 'CREATE TABLE ... WITH OIDS' has been removed in 12.0. See https:&bsol;&bsol;www.postgresql.org/docs/12/release-12.html#id-1.11.6.5.4");
153          var table = await GetTempTableName(conn);
154          var query = $@"
155  CREATE TABLE {table} (name TEXT) WITH OIDS;
156  INSERT INTO {table} (name) VALUES ('a');
157  UPDATE {table} SET name='b' WHERE name='doesnt_exist';";
158          using (var cmd = new NpgsqlCommand(query,conn))
159          {
160              using var reader = await cmd.ExecuteReaderAsync(Behavior);
161              Assert.That(reader.Statements[0].OID, Is.EqualTo(0));
162              Assert.That(reader.Statements[1].OID, Is.Not.EqualTo(0));
163              Assert.That(reader.Statements[0].OID, Is.EqualTo(0));
164          }
165          using (var cmd = new NpgsqlCommand($"SELECT name FROM {table}; DELETE FROM {table}", conn))
166          {
167              using var reader = await cmd.ExecuteReaderAsync(Behavior);
168              await reader.NextResultAsync(); 
169              Assert.That(reader.Statements[0].OID, Is.EqualTo(0));
170              Assert.That(reader.Statements[1].OID, Is.EqualTo(0));
171          }
172      }
173  #pragma warning restore CS0618
174      [Test]
175      public async Task Get_string_with_parameter()
176      {
177          using var conn = await OpenConnectionAsync();
178          var table = await CreateTempTable(conn, "name TEXT");
179          const string text = "Random text";
180          await conn.ExecuteNonQueryAsync($@"INSERT INTO {table} (name) VALUES ('{text}')");
181          var command = new NpgsqlCommand($"SELECT name FROM {table} WHERE name = :value;", conn);
182          var param = new NpgsqlParameter
183          {
184              ParameterName = "value",
185              DbType = DbType.String,
186              Size = text.Length,
187              Value = text
188          };
189          command.Parameters.Add(param);
190          using var dr = await command.ExecuteReaderAsync(Behavior);
191          dr.Read();
192          var result = dr.GetString(0);
193          Assert.AreEqual(text, result);
194      }
195      [Test]
196      public async Task Get_string_with_quote_with_parameter()
197      {
198          using var conn = await OpenConnectionAsync();
199          var table = await GetTempTableName(conn);
200          await conn.ExecuteNonQueryAsync($@"
201  CREATE TABLE {table} (name TEXT);
202  INSERT INTO {table} (name) VALUES ('Text with '' single quote');");
203          const string test = "Text with ' single quote";
204          var command = new NpgsqlCommand($"SELECT name FROM {table} WHERE name = :value;", conn);
205          var param = new NpgsqlParameter();
206          param.ParameterName = "value";
207          param.DbType = DbType.String;
208          param.Size = test.Length;
209          param.Value = test;
210          command.Parameters.Add(param);
211          using var dr = await command.ExecuteReaderAsync(Behavior);
212          dr.Read();
213          var result = dr.GetString(0);
214          Assert.AreEqual(test, result);
215      }
216      [Test]
217      public async Task Get_value_by_name()
218      {
219          using var conn = await OpenConnectionAsync();
220          using var command = new NpgsqlCommand(@"SELECT 'Random text' AS real_column", conn);
221          using var dr = await command.ExecuteReaderAsync(Behavior);
222          dr.Read();
223          Assert.That(dr["real_column"], Is.EqualTo("Random text"));
224          Assert.That(() => dr["non_existing"], Throws.Exception.TypeOf<IndexOutOfRangeException>());
225      }
226      [Test]
227      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/794")]
228      public async Task GetFieldType()
229      {
230          using var conn = await OpenConnectionAsync();
231          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
232          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
233          {
234              reader.Read();
235              Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
236          }
237          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
238          {
239              cmd.AllResultTypesAreUnknown = true;
240              using (var reader = await cmd.ExecuteReaderAsync(Behavior))
241              {
242                  reader.Read();
243                  Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(string)));
244              }
245          }
246      }
247      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1096")]
248      public async Task GetFieldType_SchemaOnly()
249      {
250          await using var conn = await OpenConnectionAsync();
251          await using var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn);
252          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
253          reader.Read();
254          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
255      }
256      [Test]
257      public async Task GetPostgresType()
258      {
259          if (IsMultiplexing)
260              Assert.Ignore("Multiplexing: Fails");
261          using var conn = await OpenConnectionAsync();
262          PostgresType intType;
263          using (var cmd = new NpgsqlCommand(@"SELECT 1::INTEGER AS some_column", conn))
264          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
265          {
266              reader.Read();
267              intType = (PostgresBaseType)reader.GetPostgresType(0);
268              Assert.That(intType.Namespace, Is.EqualTo("pg_catalog"));
269              Assert.That(intType.Name, Is.EqualTo("integer"));
270              Assert.That(intType.FullName, Is.EqualTo("pg_catalog.integer"));
271              Assert.That(intType.DisplayName, Is.EqualTo("integer"));
272              Assert.That(intType.InternalName, Is.EqualTo("int4"));
273          }
274          using (var cmd = new NpgsqlCommand(@"SELECT '{1}'::INTEGER[] AS some_column", conn))
275          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
276          {
277              reader.Read();
278              var intArrayType = (PostgresArrayType)reader.GetPostgresType(0);
279              Assert.That(intArrayType.Name, Is.EqualTo("integer[]"));
280              Assert.That(intArrayType.Element, Is.SameAs(intType));
281              Assert.That(intArrayType.DisplayName, Is.EqualTo("integer[]"));
282              Assert.That(intArrayType.InternalName, Is.EqualTo("_int4"));
283              Assert.That(intType.Array, Is.SameAs(intArrayType));
284          }
285      }
286      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/787")]
287      [TestCase("integer")]
288      [TestCase("real")]
289      [TestCase("integer[]")]
290      [TestCase("character varying(10)")]
291      [TestCase("character varying")]
292      [TestCase("character varying(10)[]")]
293      [TestCase("character(10)")]
294      [TestCase("character")]
295      [TestCase("character(1)", "character")]
296      [TestCase("numeric(1000, 2)")]
297      [TestCase("numeric(1000)")]
298      [TestCase("numeric")]
299      [TestCase("timestamp without time zone")]
300      [TestCase("timestamp(2) without time zone")]
301      [TestCase("timestamp(2) with time zone")]
302      [TestCase("time without time zone")]
303      [TestCase("time(2) without time zone")]
304      [TestCase("time(2) with time zone")]
305      [TestCase("interval")]
306      [TestCase("interval(2)")]
307      [TestCase("bit", "bit(1)")]
308      [TestCase("bit(3)")]
309      [TestCase("bit varying")]
310      [TestCase("bit varying(3)")]
311      public async Task GetDataTypeName(string typeName, string? normalizedName = null)
312      {
313          if (normalizedName == null)
314              normalizedName = typeName;
315          using var conn = await OpenConnectionAsync();
316          using var cmd = new NpgsqlCommand($"SELECT NULL::{typeName} AS some_column", conn);
317          using var reader = await cmd.ExecuteReaderAsync(Behavior);
318          reader.Read();
319          Assert.That(reader.GetDataTypeName(0), Is.EqualTo(normalizedName));
320      }
321      [Test]
322      public async Task GetDataTypeName_enum()
323      {
324          await using var dataSource = CreateDataSource(csb => csb.MaxPoolSize = 1);
325          await using var conn = await dataSource.OpenConnectionAsync();
326          var typeName = await GetTempTypeName(conn);
327          await conn.ExecuteNonQueryAsync($"CREATE TYPE {typeName} AS ENUM ('one')");
328          await Task.Yield(); 
329          conn.ReloadTypes();
330          await using var cmd = new NpgsqlCommand($"SELECT 'one'::{typeName}", conn);
331          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
332          await reader.ReadAsync();
333          Assert.That(reader.GetDataTypeName(0), Is.EqualTo($"public.{typeName}"));
334      }
335      [Test]
336      public async Task GetDataTypeName_domain()
337      {
338          await using var dataSource = CreateDataSource(csb => csb.MaxPoolSize = 1);
339          await using var conn = await dataSource.OpenConnectionAsync();
340          var typeName = await GetTempTypeName(conn);
341          await conn.ExecuteNonQueryAsync($"CREATE DOMAIN {typeName} AS VARCHAR(10)");
342          await Task.Yield(); 
343          conn.ReloadTypes();
344          await using var cmd = new NpgsqlCommand($"SELECT 'one'::{typeName}", conn);
345          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
346          await reader.ReadAsync();
347          Assert.That(reader.GetDataTypeName(0), Is.EqualTo("character varying(10)"));
348      }
349      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/794")]
350      public async Task GetDataTypeNameTypes_unknown()
351      {
352          using var conn = await OpenConnectionAsync();
353          using var cmd = new NpgsqlCommand(@"SELECT 1::INTEGER AS some_column", conn);
354          cmd.AllResultTypesAreUnknown = true;
355          using var reader = await cmd.ExecuteReaderAsync(Behavior);
356          reader.Read();
357          Assert.That(reader.GetDataTypeName(0), Is.EqualTo("integer"));
358      }
359      [Test]
360      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/791")]
361      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/794")]
362      public async Task GetDataTypeOID()
363      {
364          using var conn = await OpenConnectionAsync();
365          var int4OID = await conn.ExecuteScalarAsync("SELECT oid FROM pg_type WHERE typname = 'int4'");
366          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
367          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
368          {
369              reader.Read();
370              Assert.That(reader.GetDataTypeOID(0), Is.EqualTo(int4OID));
371          }
372          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
373          {
374              cmd.AllResultTypesAreUnknown = true;
375              using (var reader = await cmd.ExecuteReaderAsync(Behavior))
376              {
377                  reader.Read();
378                  Assert.That(reader.GetDataTypeOID(0), Is.EqualTo(int4OID));
379              }
380          }
381      }
382      [Test]
383      public async Task GetName()
384      {
385          using var conn = await OpenConnectionAsync();
386          using var command = new NpgsqlCommand(@"SELECT 1 AS some_column", conn);
387          using var dr = await command.ExecuteReaderAsync(Behavior);
388          dr.Read();
389          Assert.That(dr.GetName(0), Is.EqualTo("some_column"));
390      }
391      [Test]
392      public async Task GetFieldValue_as_object()
393      {
394          using var conn = await OpenConnectionAsync();
395          using var cmd = new NpgsqlCommand("SELECT 'foo'::TEXT", conn);
396          using var reader = await cmd.ExecuteReaderAsync(Behavior);
397          reader.Read();
398          Assert.That(reader.GetFieldValue<object>(0), Is.EqualTo("foo"));
399      }
400      [Test]
401      public async Task GetValues()
402      {
403          using var conn = await OpenConnectionAsync();
404          using var command = new NpgsqlCommand(@"SELECT 'hello', 1, '2014-01-01'::DATE", conn);
405          using (var dr = await command.ExecuteReaderAsync(Behavior))
406          {
407              dr.Read();
408              var values = new object[4];
409              Assert.That(dr.GetValues(values), Is.EqualTo(3));
410              Assert.That(values, Is.EqualTo(new object?[] { "hello", 1, new DateTime(2014, 1, 1), null }));
411          }
412          using (var dr = await command.ExecuteReaderAsync(Behavior))
413          {
414              dr.Read();
415              var values = new object[2];
416              Assert.That(dr.GetValues(values), Is.EqualTo(2));
417              Assert.That(values, Is.EqualTo(new object[] { "hello", 1 }));
418          }
419      }
420      [Test]
421      public async Task ExecuteReader_getting_empty_resultset_with_output_parameter()
422      {
423          using var conn = await OpenConnectionAsync();
424          var table = await CreateTempTable(conn, "name TEXT");
425          var command = new NpgsqlCommand($"SELECT * FROM {table} WHERE name = NULL;", conn);
426          var param = new NpgsqlParameter("some_param", NpgsqlDbType.Varchar);
427          param.Direction = ParameterDirection.Output;
428          command.Parameters.Add(param);
429          using var dr = await command.ExecuteReaderAsync(Behavior);
430          Assert.IsFalse(dr.NextResult());
431      }
432      [Test]
433      public async Task Get_value_from_empty_resultset()
434      {
435          using var conn = await OpenConnectionAsync();
436          var table = await CreateTempTable(conn, "name TEXT");
437          using var command = new NpgsqlCommand($"SELECT * FROM {table} WHERE name = :value;", conn);
438          const string test = "Text single quote";
439          var param = new NpgsqlParameter();
440          param.ParameterName = "value";
441          param.DbType = DbType.String;
442          param.Size = test.Length;
443          param.Value = test;
444          command.Parameters.Add(param);
445          using var dr = await command.ExecuteReaderAsync(Behavior);
446          dr.Read();
447          Assert.That(() => Console.WriteLine(dr.IsDBNull(1)),
448              Throws.Exception.TypeOf<InvalidOperationException>());
449      }
450      [Test]
451      public async Task Read_past_reader_end()
452      {
453          using var conn = await OpenConnectionAsync();
454          var command = new NpgsqlCommand("SELECT 1", conn);
455          using var dr = await command.ExecuteReaderAsync(Behavior);
456          while (dr.Read()) {}
457          Assert.That(() => dr[0], Throws.Exception.TypeOf<InvalidOperationException>());
458      }
459      [Test]
460      public async Task Reader_dispose_state_does_not_leak()
461      {
462          if (IsMultiplexing || Behavior != CommandBehavior.Default)
463              return;
464          var startReaderClosedTcs = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);
465          var continueReaderClosedTcs = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);
466          await using var dataSource = CreateDataSource();
467          await using var conn1 = await dataSource.OpenConnectionAsync();
468          var connID = conn1.Connector!.Id;
469          var readerCloseTask = Task.Run(async () =>
470          {
471              using var cmd = conn1.CreateCommand();
472              cmd.CommandText = "SELECT 1";
473              await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection);
474              reader.ReaderClosed += (s, e) =>
475              {
476                  startReaderClosedTcs.SetResult(new());
477                  continueReaderClosedTcs.Task.GetAwaiter().GetResult();
478              };
479          });
480          await startReaderClosedTcs.Task;
481          await using var conn2 = await dataSource.OpenConnectionAsync();
482          Assert.That(conn2.Connector!.Id, Is.EqualTo(connID));
483          using var cmd = conn2.CreateCommand();
484          cmd.CommandText = "SELECT 1";
485          await using var reader = await cmd.ExecuteReaderAsync();
486          Assert.That(reader.State, Is.EqualTo(ReaderState.BeforeResult));
487          continueReaderClosedTcs.SetResult(new());
488          await readerCloseTask;
489          Assert.That(reader.State, Is.EqualTo(ReaderState.BeforeResult));
490      }
491      [Test]
492      public async Task SingleResult()
493      {
494          await using var conn = await OpenConnectionAsync();
495          await using var command = new NpgsqlCommand(@"SELECT 1; SELECT 2", conn);
496          var reader = await command.ExecuteReaderAsync(CommandBehavior.SingleResult | Behavior);
497          Assert.That(reader.Read(), Is.True);
498          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
499          Assert.That(reader.NextResult(), Is.False);
500      }
501      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/400")]
502      public async Task Exception_thrown_from_ExecuteReaderAsync([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
503      {
504          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
505              return;
506          using var conn = await OpenConnectionAsync();
507          var function = await GetTempFunctionName(conn);
508          await conn.ExecuteNonQueryAsync($@"
509  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
510     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
511  LANGUAGE 'plpgsql';
512                  ");
513          using var cmd = new NpgsqlCommand($"SELECT {function}()", conn);
514          if (prepare == PrepareOrNot.Prepared)
515              cmd.Prepare();
516          Assert.That(async () => await cmd.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<PostgresException>());
517      }
518      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1032")]
519      public async Task Exception_thrown_from_NextResult([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
520      {
521          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
522              return;
523          using var conn = await OpenConnectionAsync();
524          var function = await GetTempFunctionName(conn);
525          await conn.ExecuteNonQueryAsync($@"
526  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
527     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
528  LANGUAGE 'plpgsql';
529                  ");
530          using var cmd = new NpgsqlCommand($"SELECT 1; SELECT {function}()", conn);
531          if (prepare == PrepareOrNot.Prepared)
532              cmd.Prepare();
533          using var reader = await cmd.ExecuteReaderAsync(Behavior);
534          Assert.That(() => reader.NextResult(), Throws.Exception.TypeOf<PostgresException>());
535      }
536      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
537      public async Task NpgsqlException_references_BatchCommand_with_single_command()
538      {
539          await using var conn = await OpenConnectionAsync();
540          var function = await GetTempFunctionName(conn);
541          await conn.ExecuteNonQueryAsync($@"
542  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
543     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
544  LANGUAGE 'plpgsql'");
545          var cmd = conn.CreateCommand();
546          cmd.CommandText = $"SELECT {function}()";
547          var exception = Assert.ThrowsAsync<PostgresException>(() => cmd.ExecuteReaderAsync(Behavior))!;
548          Assert.That(exception.BatchCommand, Is.SameAs(cmd.InternalBatchCommands[0]));
549          cmd.Dispose();
550          var cmd2 = conn.CreateCommand();
551          Assert.AreNotSame(cmd2, cmd);
552      }
553      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
554      public async Task NpgsqlException_references_BatchCommand_with_multiple_commands()
555      {
556          await using var conn = await OpenConnectionAsync();
557          var function = await GetTempFunctionName(conn);
558          await conn.ExecuteNonQueryAsync($@"
559  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
560     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
561  LANGUAGE 'plpgsql'");
562          var cmd = conn.CreateCommand();
563          cmd.CommandText = $"SELECT 1; {function}()";
564          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
565          {
566              var exception = Assert.ThrowsAsync<PostgresException>(() => reader.NextResultAsync())!;
567              Assert.That(exception.BatchCommand, Is.SameAs(cmd.InternalBatchCommands[1]));
568          }
569          cmd.Dispose();
570          var cmd2 = conn.CreateCommand();
571          Assert.AreNotSame(cmd2, cmd);
572      }
573      #region SchemaOnly
574      [Test]
575      public async Task SchemaOnly_returns_no_data()
576      {
577          await using var conn = await OpenConnectionAsync();
578          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
579          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
580          Assert.That(reader.Read(), Is.False);
581      }
582      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2827")]
583      public async Task SchemaOnly_next_result_beyond_end()
584      {
585          using var conn = await OpenConnectionAsync();
586          var table = await CreateTempTable(conn, "id INT");
587          using var cmd = new NpgsqlCommand($"SELECT * FROM {table}", conn);
588          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
589          Assert.False(reader.NextResult());
590          Assert.False(reader.NextResult());
591      }
592      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4124")]
593      public async Task SchemaOnly_GetDataTypeName_with_unsupported_type()
594      {
595          using var conn = await OpenConnectionAsync();
596          using var cmd = new NpgsqlCommand(@"select aggfnoid from pg_aggregate", conn);
597          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
598          Assert.That(reader.GetDataTypeName(0), Is.EqualTo("regproc"));
599      }
600      #endregion SchemaOnly
601      #region GetOrdinal
602      [Test]
603      public async Task GetOrdinal()
604      {
605          using var conn = await OpenConnectionAsync();
606          using var command = new NpgsqlCommand(@"SELECT 0, 1 AS some_column WHERE 1=0", conn);
607          using var reader = await command.ExecuteReaderAsync(Behavior);
608          Assert.That(reader.GetOrdinal("some_column"), Is.EqualTo(1));
609          Assert.That(() => reader.GetOrdinal("doesn't_exist"), Throws.Exception.TypeOf<IndexOutOfRangeException>());
610      }
611      [Test]
612      public async Task GetOrdinal_case_insensitive()
613      {
614          using var conn = await OpenConnectionAsync();
615          using var command = new NpgsqlCommand("select 123 as FIELD1", conn);
616          using var reader = await command.ExecuteReaderAsync(Behavior);
617          reader.Read();
618          Assert.That(reader.GetOrdinal("fieLd1"), Is.EqualTo(0));
619      }
620      [Test]
621      public async Task GetOrdinal_kana_insensitive()
622      {
623          using var conn = await OpenConnectionAsync();
624          using var command = new NpgsqlCommand("select 123 as ｦｧｨｩｪｫｬ", conn);
625          using var reader = await command.ExecuteReaderAsync(Behavior);
626          reader.Read();
627          Assert.That(reader["ヲァィゥェォャ"], Is.EqualTo(123));
628      }
629      #endregion GetOrdinal
630      [Test]
631      public async Task Field_index_does_not_exist()
632      {
633          using var conn = await OpenConnectionAsync();
634          using var command = new NpgsqlCommand("SELECT 1", conn);
635          using var dr = await command.ExecuteReaderAsync(Behavior);
636          dr.Read();
637          Assert.That(() => dr[5], Throws.Exception.TypeOf<IndexOutOfRangeException>());
638      }
639      [Test, Description("Performs some operations while a reader is still open and checks for exceptions")]
640      public async Task Reader_is_still_open()
641      {
642          await using var conn = await OpenConnectionAsync();
643          if (!IsMultiplexing)
644              conn.UnprepareAll();
645          using var cmd1 = new NpgsqlCommand("SELECT 1", conn);
646          await using var reader1 = await cmd1.ExecuteReaderAsync(Behavior);
647          Assert.That(() => conn.ExecuteNonQuery("SELECT 1"), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
648          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
649          using var cmd2 = new NpgsqlCommand("SELECT 2", conn);
650          Assert.That(() => cmd2.ExecuteReader(Behavior), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
651          if (!IsMultiplexing)
652              Assert.That(() => cmd2.Prepare(), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
653      }
654      [Test]
655      public async Task Cleans_up_ok_with_dispose_calls([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
656      {
657          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
658              return;
659          using var conn = await OpenConnectionAsync();
660          using var command = new NpgsqlCommand("SELECT 1", conn);
661          using var dr = await command.ExecuteReaderAsync(Behavior);
662          dr.Read();
663          dr.Close();
664          using var upd = conn.CreateCommand();
665          upd.CommandText = "SELECT 1";
666          if (prepare == PrepareOrNot.Prepared)
667              upd.Prepare();
668      }
669      [Test]
670      public async Task Null()
671      {
672          using var conn = await OpenConnectionAsync();
673          using var cmd = new NpgsqlCommand("SELECT @p1, @p2::TEXT", conn);
674          cmd.Parameters.Add(new NpgsqlParameter("p1", DbType.String) { Value = DBNull.Value });
675          cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p2", Value = DBNull.Value });
676          using var reader = await cmd.ExecuteReaderAsync(Behavior);
677          reader.Read();
678          for (var i = 0; i < cmd.Parameters.Count; i++)
679          {
680              Assert.That(reader.IsDBNull(i), Is.True);
681              Assert.That(reader.IsDBNullAsync(i).Result, Is.True);
682              Assert.That(reader.GetValue(i), Is.EqualTo(DBNull.Value));
683              Assert.That(reader.GetFieldValue<object>(i), Is.EqualTo(DBNull.Value));
684              Assert.That(reader.GetProviderSpecificValue(i), Is.EqualTo(DBNull.Value));
685              Assert.That(() => reader.GetString(i), Throws.Exception.TypeOf<InvalidCastException>());
686          }
687      }
688      [Test]
689      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/742")]
690      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/800")]
691      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1234")]
692      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1898")]
693      public async Task HasRows([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
694      {
695          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
696              return;
697          using var conn = await OpenConnectionAsync();
698          var table = await CreateTempTable(conn, "name TEXT");
699          var command = new NpgsqlCommand($"SELECT 1; SELECT * FROM {table} WHERE name='does_not_exist'", conn);
700          if (prepare == PrepareOrNot.Prepared)
701              command.Prepare();
702          using (var reader = await command.ExecuteReaderAsync(Behavior))
703          {
704              Assert.That(reader.HasRows, Is.True);
705              Assert.That(reader.HasRows, Is.True);
706              Assert.That(reader.Read(), Is.True);
707              Assert.That(reader.HasRows, Is.True);
708              Assert.That(reader.Read(), Is.False);
709              Assert.That(reader.HasRows, Is.True);
710              await reader.NextResultAsync();
711              Assert.That(reader.HasRows, Is.False);
712          }
713          command.CommandText = $"SELECT * FROM {table}";
714          if (prepare == PrepareOrNot.Prepared)
715              command.Prepare();
716          using (var reader = await command.ExecuteReaderAsync(Behavior))
717          {
718              reader.Read();
719              Assert.That(reader.HasRows, Is.False);
720          }
721          command.CommandText = "SELECT 1";
722          if (prepare == PrepareOrNot.Prepared)
723              command.Prepare();
724          using (var reader = await command.ExecuteReaderAsync(Behavior))
725          {
726              reader.Read();
727              reader.Close();
728              Assert.That(() => reader.HasRows, Throws.Exception.TypeOf<InvalidOperationException>());
729          }
730          command.CommandText = $"INSERT INTO {table} (name) VALUES ('foo'); SELECT * FROM {table}";
731          if (prepare == PrepareOrNot.Prepared)
732              command.Prepare();
733          using (var reader = await command.ExecuteReaderAsync(Behavior))
734          {
735              Assert.That(reader.HasRows, Is.True);
736              reader.Read();
737              Assert.That(reader.GetString(0), Is.EqualTo("foo"));
738          }
739          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
740      }
741      [Test]
742      public async Task HasRows_without_resultset()
743      {
744          using var conn = await OpenConnectionAsync();
745          var table = await CreateTempTable(conn, "name TEXT");
746          using var command = new NpgsqlCommand($"DELETE FROM {table} WHERE name = 'unknown'", conn);
747          using var reader = await command.ExecuteReaderAsync(Behavior);
748          Assert.IsFalse(reader.HasRows);
749      }
750      [Test]
751      public async Task Interval_as_TimeSpan()
752      {
753          using var conn = await OpenConnectionAsync();
754          using var command = new NpgsqlCommand("SELECT CAST('1 hour' AS interval) AS dauer", conn);
755          using var dr = await command.ExecuteReaderAsync(Behavior);
756          Assert.IsTrue(dr.HasRows);
757          Assert.IsTrue(dr.Read());
758          Assert.IsTrue(dr.HasRows);
759          var ts = dr.GetTimeSpan(0);
760      }
761      [Test]
762      public async Task Close_connection_in_middle_of_row()
763      {
764          using var conn = await OpenConnectionAsync();
765          using var cmd = new NpgsqlCommand("SELECT 1, 2", conn);
766          using var reader = await cmd.ExecuteReaderAsync(Behavior);
767          reader.Read();
768      }
769      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/pull/1266")]
770      [Description("NextResult was throwing an ArgumentOutOfRangeException when trying to determine the statement to associate with the PostgresException")]
771      public async Task Reader_next_result_exception_handling()
772      {
773          using var conn = await OpenConnectionAsync();
774          var table1 = await GetTempTableName(conn);
775          var table2 = await GetTempTableName(conn);
<span onclick='openModal()' class='match'>776          var function = await GetTempFunctionName(conn);
777          var initializeTablesSql = $@"
778  CREATE TABLE {table1} (value int NOT NULL);
779  CREATE TABLE {table2} (value int UNIQUE);
780  ALTER TABLE ONLY {table1} ADD CONSTRAINT {table1}_{table2}_fk FOREIGN KEY (value) REFERENCES {table2}(value) DEFERRABLE INITIALLY DEFERRED;
781  CREATE OR REPLACE FUNCTION {function}(_value int) RETURNS int AS $BODY$
782  BEGIN
783      INSERT INTO {table1}(value) VALUES(_value);
784      RETURN _value;
785  END;
786  $BODY$
787  LANGUAGE plpgsql VOLATILE";
788          await conn.ExecuteNonQueryAsync(initializeTablesSql);
</span>789          using var cmd = new NpgsqlCommand($"SELECT {function}(1)", conn);
790          using var reader = await cmd.ExecuteReaderAsync(Behavior);
791          Assert.That(() => reader.NextResult(),
792              Throws.Exception.TypeOf<PostgresException>()
793                  .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.ForeignKeyViolation));
794      }
795      [Test]
796      public async Task Invalid_cast()
797      {
798          using var conn = await OpenConnectionAsync();
799          using (var cmd = new NpgsqlCommand("SELECT 'foo'", conn))
800          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
801          {
802              reader.Read();
803              Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidCastException>());
804          }
805          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
806          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
807          {
808              reader.Read();
809              Assert.That(() => reader.GetDateTime(0), Throws.Exception.TypeOf<InvalidCastException>());
810          }
811          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
812      }
813      [Test, Description("Reads a lot of rows to make sure the long unoptimized path for Read() works")]
814      public async Task Many_reads()
815      {
816          using var conn = await OpenConnectionAsync();
817          using var cmd = new NpgsqlCommand($"SELECT generate_series(1, {conn.Settings.ReadBufferSize})", conn);
818          using var reader = await cmd.ExecuteReaderAsync(Behavior);
819          for (var i = 1; i <= conn.Settings.ReadBufferSize; i++)
820          {
821              Assert.That(reader.Read(), Is.True);
822              Assert.That(reader.GetInt32(0), Is.EqualTo(i));
823          }
824          Assert.That(reader.Read(), Is.False);
825      }
826      [Test]
827      public async Task Nullable_scalar()
828      {
829          if (IsSequential)
830              return;
831          using var conn = await OpenConnectionAsync();
832          using var cmd = new NpgsqlCommand("SELECT @p1, @p2", conn);
833          var p1 = new NpgsqlParameter { ParameterName = "p1", Value = DBNull.Value, NpgsqlDbType = NpgsqlDbType.Smallint };
834          var p2 = new NpgsqlParameter { ParameterName = "p2", Value = (short)8 };
835          Assert.That(p2.NpgsqlDbType, Is.EqualTo(NpgsqlDbType.Smallint));
836          Assert.That(p2.DbType, Is.EqualTo(DbType.Int16));
837          cmd.Parameters.Add(p1);
838          cmd.Parameters.Add(p2);
839          using var reader = await cmd.ExecuteReaderAsync(Behavior);
840          reader.Read();
841          for (var i = 0; i < cmd.Parameters.Count; i++)
842          {
843              Assert.That(reader.GetFieldType(i), Is.EqualTo(typeof(short)));
844              Assert.That(reader.GetDataTypeName(i), Is.EqualTo("smallint"));
845          }
846          Assert.That(() => reader.GetFieldValue<object>(0), Is.EqualTo(DBNull.Value));
847          Assert.That(() => reader.GetFieldValue<int>(0), Throws.TypeOf<InvalidCastException>());
848          Assert.That(() => reader.GetFieldValue<int?>(0), Throws.Nothing);
849          Assert.That(reader.GetFieldValue<int?>(0), Is.Null);
850          Assert.That(() => reader.GetFieldValue<object>(1), Throws.Nothing);
851          Assert.That(() => reader.GetFieldValue<int>(1), Throws.Nothing);
852          Assert.That(() => reader.GetFieldValue<int?>(1), Throws.Nothing);
853          Assert.That(reader.GetFieldValue<object>(1), Is.EqualTo(8));
854          Assert.That(reader.GetFieldValue<int>(1), Is.EqualTo(8));
855          Assert.That(reader.GetFieldValue<int?>(1), Is.EqualTo(8));
856      }
857      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2913")]
858      public async Task Bug2913_reading_previous_query_messages()
859      {
860          if (IsMultiplexing)
861              return;
862          var firstMrs = new ManualResetEventSlim(false);
863          var secondMrs = new ManualResetEventSlim(false);
864          var secondQuery = Task.Run(async () =>
865          {
866              firstMrs.Wait();
867              await using var secondConn = await OpenConnectionAsync();
868              using var secondCmd = new NpgsqlCommand(@"SELECT 1; SELECT 2;", secondConn);
869              await using var secondReader = await secondCmd.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
870              Assert.That(secondReader.StatementIndex, Is.EqualTo(0));
871              secondMrs.Wait();
872              Assert.That(secondReader.StatementIndex, Is.EqualTo(0));
873          });
874          await using (var firstConn = await OpenConnectionAsync())
875          {
876              using var firstCmd = new NpgsqlCommand(@"SELECT 1; SELECT * FROM NotExistingTable;", firstConn);
877              await using var firstReader = await firstCmd.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
878              Assert.That(firstReader.StatementIndex, Is.EqualTo(0));
879              firstReader.ReaderClosed += (s, e) =>
880              {
881                  firstMrs.Set();
882                  Thread.Sleep(100);
883              };
884              Assert.ThrowsAsync<PostgresException>(firstReader.NextResultAsync);
885              secondMrs.Set();
886          }
887          await secondQuery;
888          await using var thirdConn = OpenConnection();
889          using var thirdCmd = new NpgsqlCommand(@"SELECT 1; SELECT 2;", thirdConn);
890          await using var thirdReader = await thirdCmd.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
891      }
892      [Test]
893      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2913")]
894      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3289")]
895      public async Task Reader_close_and_dispose()
896      {
897          await using var conn = await OpenConnectionAsync();
898          using var cmd1 = conn.CreateCommand();
899          cmd1.CommandText = "SELECT 1";
900          var reader1 = await cmd1.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
901          await reader1.CloseAsync();
902          await conn.OpenAsync();
903          cmd1.Connection = conn;
904          var reader2 = await cmd1.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
905          Assert.That(reader1, Is.Not.SameAs(reader2));
906          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
907          await reader1.DisposeAsync();
908          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
909      }
910      [Test]
911      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2964")]
912      public async Task Bug2964_connection_close_and_reader_dispose()
913      {
914          await using var conn = await OpenConnectionAsync();
915          using var cmd1 = conn.CreateCommand();
916          cmd1.CommandText = "SELECT 1";
917          var reader1 = await cmd1.ExecuteReaderAsync(Behavior);
918          await conn.CloseAsync();
919          await conn.OpenAsync();
920          var reader2 = await cmd1.ExecuteReaderAsync(Behavior);
921          Assert.That(reader1, Is.Not.SameAs(reader2));
922          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
923          await reader1.DisposeAsync();
924          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
925      }
926      [Test]
927      public async Task Reader_reuse_on_dispose()
928      {
929          await using var conn = await OpenConnectionAsync();
930          await using var tx = await conn.BeginTransactionAsync();
931          using var cmd = conn.CreateCommand();
932          cmd.CommandText = "SELECT 1";
933          var reader1 = await cmd.ExecuteReaderAsync(Behavior);
934          await reader1.ReadAsync();
935          await reader1.DisposeAsync();
936          var reader2 = await cmd.ExecuteReaderAsync(Behavior);
937          Assert.That(reader1, Is.SameAs(reader2));
938          await reader2.DisposeAsync();
939      }
940      [Test]
941      public async Task Unbound_reader_reuse()
942      {
943          await using var dataSource = CreateDataSource(csb =>
944          {
945              csb.MinPoolSize = 1;
946              csb.MaxPoolSize = 1;
947          });
948          await using var conn1 = await dataSource.OpenConnectionAsync();
949          using var cmd1 = conn1.CreateCommand();
950          cmd1.CommandText = "SELECT 1";
951          var reader1 = await cmd1.ExecuteReaderAsync(Behavior);
952          await using (var __ = reader1)
953          {
954              Assert.That(async () => await reader1.ReadAsync(), Is.EqualTo(true));
955              Assert.That(() => reader1.GetInt32(0), Is.EqualTo(1));
956              await reader1.CloseAsync();
957              await conn1.CloseAsync();
958          }
959          await using var conn2 = await dataSource.OpenConnectionAsync();
960          using var cmd2 = conn2.CreateCommand();
961          cmd2.CommandText = "SELECT 2";
962          var reader2 = await cmd2.ExecuteReaderAsync(Behavior);
963          await using (var __ = reader2)
964          {
965              Assert.That(async () => await reader2.ReadAsync(), Is.EqualTo(true));
966              Assert.That(() => reader2.GetInt32(0), Is.EqualTo(2));
967              Assert.That(reader1, Is.Not.SameAs(reader2));
968              await reader2.CloseAsync();
969              await conn2.CloseAsync();
970          }
971          await using var conn3 = await dataSource.OpenConnectionAsync();
972          using var cmd3 = conn3.CreateCommand();
973          cmd3.CommandText = "SELECT 3";
974          var reader3 = await cmd3.ExecuteReaderAsync(Behavior);
975          await using (var __ = reader3)
976          {
977              Assert.That(async () => await reader3.ReadAsync(), Is.EqualTo(true));
978              Assert.That(() => reader3.GetInt32(0), Is.EqualTo(3));
979              Assert.That(reader1, Is.SameAs(reader3));
980              await reader3.CloseAsync();
981              await conn3.CloseAsync();
982          }
983      }
984      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3772")]
985      public async Task Bug3772()
986      {
987          if (!IsSequential)
988              return;
989          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
990          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
991          await using var conn = await dataSource.OpenConnectionAsync();
992          var pgMock = await postmasterMock.WaitForServerConnection();
993          pgMock
994              .WriteParseComplete()
995              .WriteBindComplete()
996              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4), new FieldDescription(PostgresTypeOIDs.Bytea));
997          var intValue = new byte[] { 0, 0, 0, 1 };
998          var byteValue = new byte[] { 1, 2, 3, 4 };
999          var writeBuffer = pgMock.WriteBuffer;
1000          writeBuffer.WriteByte((byte)BackendMessageCode.DataRow);
1001          writeBuffer.WriteInt32(4 + 2 + intValue.Length + byteValue.Length + 8);
1002          writeBuffer.WriteInt16(2);
1003          writeBuffer.WriteInt32(intValue.Length);
1004          writeBuffer.WriteBytes(intValue);
1005          await pgMock.FlushAsync();
1006          using var cmd = new NpgsqlCommand("SELECT some_int, some_byte FROM some_table", conn);
1007          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1008          await reader.ReadAsync();
1009          reader.GetInt32(0);
1010          Assert.Zero(reader.Connector.ReadBuffer.ReadBytesLeft);
1011          Assert.NotZero(reader.Connector.ReadBuffer.ReadPosition);
1012          writeBuffer.WriteInt32(byteValue.Length);
1013          writeBuffer.WriteBytes(byteValue);
1014          await pgMock
1015              .WriteDataRow(intValue, Enumerable.Range(1, 100).Select(x => (byte)x).ToArray())
1016              .WriteCommandComplete()
1017              .WriteReadyForQuery()
1018              .FlushAsync();
1019          await reader.GetFieldValueAsync<byte[]>(1);
1020          Assert.DoesNotThrowAsync(reader.ReadAsync);
1021      }
1022      [Test] 
1023      public async Task Dispose_does_not_swallow_exceptions([Values(true, false)] bool async)
1024      {
1025          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1026          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1027          await using var conn = await dataSource.OpenConnectionAsync();
1028          var pgMock = await postmasterMock.WaitForServerConnection();
1029          await pgMock
1030              .WriteParseComplete()
1031              .WriteBindComplete()
1032              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1033              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1034              .FlushAsync();
1035          using var cmd = new NpgsqlCommand("SELECT 1", conn);
1036          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1037          await reader.ReadAsync();
1038          pgMock.Close();
1039          if (async)
1040              Assert.Throws<NpgsqlException>(() => reader.Dispose());
1041          else
1042              Assert.ThrowsAsync<NpgsqlException>(async () => await reader.DisposeAsync());
1043      }
1044      [Test]
1045      public async Task Read_string_as_char()
1046      {
1047          await using var conn = await OpenConnectionAsync();
1048          await using var cmd = conn.CreateCommand();
1049          cmd.CommandText = "SELECT 'abcdefgh', 'ijklmnop'";
1050          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1051          Assert.IsTrue(await reader.ReadAsync());
1052          Assert.That(reader.GetChar(0), Is.EqualTo('a'));
1053          if (Behavior == CommandBehavior.SequentialAccess)
1054              Assert.Throws<InvalidOperationException>(() => reader.GetChar(0));
1055          else
1056              Assert.That(reader.GetChar(0), Is.EqualTo('a'));
1057          Assert.That(reader.GetChar(1), Is.EqualTo('i'));
1058      }
1059      #region GetBytes / GetStream
1060      [Test]
1061      public async Task GetBytes()
1062      {
1063          using var conn = await OpenConnectionAsync();
1064          var table = await CreateTempTable(conn, "bytes BYTEA");
1065          byte[] expected = { 1, 2, 3, 4, 5 };
1066          var actual = new byte[expected.Length];
1067          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (bytes) VALUES ({EncodeByteaHex(expected)})");
1068          var query = $"SELECT bytes, 'foo', bytes, 'bar', bytes, bytes FROM {table}";
1069          using var cmd = new NpgsqlCommand(query, conn);
1070          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1071          reader.Read();
1072          Assert.That(reader.GetBytes(0, 0, actual, 0, 2), Is.EqualTo(2));
1073          Assert.That(actual[0], Is.EqualTo(expected[0]));
1074          Assert.That(actual[1], Is.EqualTo(expected[1]));
1075          Assert.That(reader.GetBytes(0, 0, null, 0, 0), Is.EqualTo(expected.Length), "Bad column length");
1076          if (IsSequential)
1077              Assert.That(() => reader.GetBytes(0, 0, actual, 4, 1),
1078                  Throws.Exception.TypeOf<InvalidOperationException>(), "Seek back sequential");
1079          else
1080          {
1081              Assert.That(reader.GetBytes(0, 0, actual, 4, 1), Is.EqualTo(1));
1082              Assert.That(actual[4], Is.EqualTo(expected[0]));
1083          }
1084          Assert.That(reader.GetBytes(0, 2, actual, 2, 3), Is.EqualTo(3));
1085          Assert.That(actual, Is.EqualTo(expected));
1086          Assert.That(reader.GetBytes(0, 0, null, 0, 0), Is.EqualTo(expected.Length), "Bad column length");
1087          Assert.That(() => reader.GetBytes(1, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(),
1088              "GetBytes on non-bytea");
1089          Assert.That(() => reader.GetBytes(1, 0, actual, 0, 1),
1090              Throws.Exception.TypeOf<InvalidCastException>(),
1091              "GetBytes on non-bytea");
1092          Assert.That(reader.GetString(1), Is.EqualTo("foo"));
1093          reader.GetBytes(2, 0, actual, 0, 2);
1094          reader.GetBytes(4, 0, actual, 0, 2);
1095          Assert.That(reader.GetBytes(4, expected.Length - 1, actual, 0, 2), Is.EqualTo(1),
1096              "Length greater than data length");
1097          Assert.That(actual[0], Is.EqualTo(expected[expected.Length - 1]), "Length greater than data length");
1098          Assert.That(() => reader.GetBytes(4, 0, actual, 0, actual.Length + 1),
1099              Throws.Exception.TypeOf<IndexOutOfRangeException>(), "Length great than output buffer length");
1100          reader.GetBytes(5, 0, actual, 0, 2);
1101      }
1102      [Test]
1103      public async Task GetStream_second_time_throws([Values(true, false)] bool isAsync)
1104      {
1105          var expected = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
1106          var streamGetter = BuildStreamGetter(isAsync);
1107          using var conn = await OpenConnectionAsync();
1108          using var cmd = new NpgsqlCommand($"SELECT {EncodeByteaHex(expected)}::bytea", conn);
1109          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1110          await reader.ReadAsync();
1111          using var stream = await streamGetter(reader, 0);
1112          Assert.That(async () => await streamGetter(reader, 0),
1113              Throws.Exception.TypeOf<InvalidOperationException>());
1114      }
1115      public static IEnumerable GetStreamCases()
1116      {
1117          var binary = MemoryMarshal
1118              .AsBytes<int>(Enumerable.Range(0, 1024).ToArray())
1119              .ToArray();
1120          yield return (binary, binary);
1121          var bigBinary = MemoryMarshal
1122              .AsBytes<int>(Enumerable.Range(0, 8193).ToArray())
1123              .ToArray();
1124          yield return (bigBinary, bigBinary);
1125          var bigint = 0xDEADBEEFL;
1126          var bigintBinary = BitConverter.GetBytes(
1127              BitConverter.IsLittleEndian
1128                  ? BinaryPrimitives.ReverseEndianness(bigint)
1129                  : bigint);
1130          yield return (bigint, bigintBinary);
1131      }
1132      [Test]
1133      public async Task GetStream<T>(
1134          [Values] bool isAsync,
1135          [ValueSource(nameof(GetStreamCases))] (T Generic, byte[] Binary) value)
1136      {
1137          var streamGetter = BuildStreamGetter(isAsync);
1138          var expected = value.Binary;
1139          var actual = new byte[expected.Length];
1140          using var conn = await OpenConnectionAsync();
1141          using var cmd = new NpgsqlCommand("SELECT @p, @p", conn) { Parameters = { new NpgsqlParameter("p", value.Generic) } };
1142          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1143          await reader.ReadAsync();
1144          using var stream = await streamGetter(reader, 0);
1145          Assert.That(stream.CanSeek, Is.EqualTo(Behavior == CommandBehavior.Default));
1146          Assert.That(stream.Length, Is.EqualTo(expected.Length));
1147          var position = 0;
1148          while (position < actual.Length)
1149          {
1150              if (isAsync)
1151                  position += await stream.ReadAsync(actual, position, actual.Length - position);
1152              else
1153                  position += stream.Read(actual, position, actual.Length - position);
1154          }
1155          Assert.That(actual, Is.EqualTo(expected));
1156      }
1157      [Test]
1158      public async Task Open_stream_when_changing_columns([Values(true, false)] bool isAsync)
1159      {
1160          var streamGetter = BuildStreamGetter(isAsync);
1161          using var conn = await OpenConnectionAsync();
1162          using var cmd = new NpgsqlCommand(@"SELECT @p, @p", conn);
1163          var data = new byte[] { 1, 2, 3 };
1164          cmd.Parameters.Add(new NpgsqlParameter("p", data));
1165          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1166          reader.Read();
1167          var stream = await streamGetter(reader, 0);
1168          var v = reader.GetValue(1);
1169          Assert.That(() => stream.ReadByte(), Throws.Exception.TypeOf<ObjectDisposedException>());
1170      }
1171      [Test]
1172      public async Task Open_stream_when_changing_rows([Values(true, false)] bool isAsync)
1173      {
1174          var streamGetter = BuildStreamGetter(isAsync);
1175          using var conn = await OpenConnectionAsync();
1176          using var cmd = new NpgsqlCommand(@"SELECT @p", conn);
1177          var data = new byte[] { 1, 2, 3 };
1178          cmd.Parameters.Add(new NpgsqlParameter("p", data));
1179          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1180          reader.Read();
1181          var s1 = await streamGetter(reader, 0);
1182          reader.Read();
1183          Assert.That(() => s1.ReadByte(), Throws.Exception.TypeOf<ObjectDisposedException>());
1184      }
1185      [Test]
1186      public async Task GetBytes_with_null([Values(true, false)] bool isAsync)
1187      {
1188          var streamGetter = BuildStreamGetter(isAsync);
1189          using var conn = await OpenConnectionAsync();
1190          var table = await CreateTempTable(conn, "bytes BYTEA");
1191          var buf = new byte[8];
1192          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (bytes) VALUES (NULL)");
1193          using var cmd = new NpgsqlCommand($"SELECT bytes FROM {table}", conn);
1194          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1195          reader.Read();
1196          Assert.That(reader.IsDBNull(0), Is.True);
1197          Assert.That(() => reader.GetBytes(0, 0, buf, 0, 1), Throws.Exception.TypeOf<InvalidCastException>(), "GetBytes");
1198          Assert.That(async () => await streamGetter(reader, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetStream");
1199          Assert.That(() => reader.GetBytes(0, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetBytes with null buffer");
1200      }
1201      static Func<NpgsqlDataReader, int, Task<Stream>> BuildStreamGetter(bool isAsync)
1202          => isAsync
1203              ? (r, index) => r.GetStreamAsync(index)
1204              : (r, index) => Task.FromResult(r.GetStream(index));
1205      [Test]
1206      public async Task GetStream_after_consuming_column_throws([Values] bool async)
1207      {
1208          if (!IsSequential)
1209              return;
1210          await using var conn = await OpenConnectionAsync();
1211          await using var cmd = new NpgsqlCommand(@"SELECT '\xDEADBEEF'::bytea", conn);
1212          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1213          await reader.ReadAsync();
1214          _ = reader.GetFieldValue<byte[]>(0);
1215          if (async)
1216              Assert.That(() => reader.GetStreamAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1217          else
1218              Assert.That(() => reader.GetStream(0), Throws.Exception.TypeOf<InvalidOperationException>());
1219      }
1220      [Test]
1221      public async Task GetStream_in_middle_of_column_throws([Values] bool async)
1222      {
1223          if (!IsSequential)
1224              return;
1225          await using var conn = await OpenConnectionAsync();
1226          await using var cmd = new NpgsqlCommand(@"SELECT '\xDEADBEEF'::bytea", conn);
1227          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1228          await reader.ReadAsync();
1229          _ = reader.GetBytes(0, 0, new byte[2], 0, 2);
1230          if (async)
1231              Assert.That(() => reader.GetStreamAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1232          else
1233              Assert.That(() => reader.GetStream(0), Throws.Exception.TypeOf<InvalidOperationException>());
1234      }
1235      #endregion GetBytes / GetStream
1236      #region GetChars / GetTextReader
1237      [Test]
1238      public async Task GetChars()
1239      {
1240          using var conn = await OpenConnectionAsync();
1241          const string str = "ABCDE";
1242          var expected = str.ToCharArray();
1243          var actual = new char[expected.Length];
1244          var queryText = $@"SELECT '{str}', 3, '{str}', 4, '{str}', '{str}', '{str}'";
1245          using var cmd = new NpgsqlCommand(queryText, conn);
1246          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1247          reader.Read();
1248          Assert.That(reader.GetChars(0, 0, actual, 0, 2), Is.EqualTo(2));
1249          Assert.That(actual[0], Is.EqualTo(expected[0]));
1250          Assert.That(actual[1], Is.EqualTo(expected[1]));
1251          Assert.That(reader.GetChars(0, 0, null, 0, 0), Is.EqualTo(expected.Length), "Bad column length");
1252          Assert.That(reader.GetChars(2, 0, actual, 0, 2), Is.EqualTo(2));
1253          if (IsSequential)
1254              Assert.That(() => reader.GetChars(2, 0, actual, 4, 1), Throws.Exception.TypeOf<InvalidOperationException>(), "Seek back sequential");
1255          else
1256          {
1257              Assert.That(reader.GetChars(2, 0, actual, 4, 1), Is.EqualTo(1));
1258              Assert.That(actual[4], Is.EqualTo(expected[0]));
1259          }
1260          Assert.That(reader.GetChars(2, 2, actual, 2, 3), Is.EqualTo(3));
1261          Assert.That(actual, Is.EqualTo(expected));
1262          Assert.That(() => reader.GetChars(3, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars on non-text");
1263          Assert.That(() => reader.GetChars(3, 0, actual, 0, 1), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars on non-text");
1264          Assert.That(reader.GetInt32(3), Is.EqualTo(4));
1265          reader.GetChars(4, 0, actual, 0, 2);
1266          reader.GetChars(5, 0, actual, 0, 2);
1267          Assert.That(reader.GetChars(5, expected.Length - 1, actual, 0, 2), Is.EqualTo(1), "Length greater than data length");
1268          Assert.That(actual[0], Is.EqualTo(expected[expected.Length - 1]), "Length greater than data length");
1269          Assert.That(() => reader.GetChars(5, 0, actual, 0, actual.Length + 1), Throws.Exception.TypeOf<IndexOutOfRangeException>(), "Length great than output buffer length");
1270          reader.GetChars(6, 0, actual, 0, 2);
1271      }
1272      [Test]
1273      public async Task GetTextReader([Values(true, false)] bool isAsync)
1274      {
1275          Func<NpgsqlDataReader, int, Task<TextReader>> textReaderGetter;
1276          if (isAsync)
1277              textReaderGetter = (r, index) => r.GetTextReaderAsync(index);
1278          else
1279              textReaderGetter = (r, index) => Task.FromResult(r.GetTextReader(index));
1280          using var conn = await OpenConnectionAsync();
1281          const string str = "ABCDE";
1282          var expected = str.ToCharArray();
1283          var actual = new char[expected.Length];
1284          var queryText = $@"SELECT '{str}', 'foo'";
1285          using var cmd = new NpgsqlCommand(queryText, conn);
1286          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1287          reader.Read();
1288          var textReader = await textReaderGetter(reader, 0);
1289          textReader.Read(actual, 0, 2);
1290          Assert.That(actual[0], Is.EqualTo(expected[0]));
1291          Assert.That(actual[1], Is.EqualTo(expected[1]));
1292          Assert.That(async () => await textReaderGetter(reader, 0),
1293              Throws.Exception.TypeOf<InvalidOperationException>(),
1294              "Sequential text reader twice on same column");
1295          textReader.Read(actual, 2, 1);
1296          Assert.That(actual[2], Is.EqualTo(expected[2]));
1297          textReader.Dispose();
1298          if (IsSequential)
1299              Assert.That(() => reader.GetChars(0, 0, actual, 4, 1),
1300                  Throws.Exception.TypeOf<InvalidOperationException>(), "Seek back sequential");
1301          else
1302          {
1303              Assert.That(reader.GetChars(0, 0, actual, 4, 1), Is.EqualTo(1));
1304              Assert.That(actual[4], Is.EqualTo(expected[0]));
1305          }
1306          Assert.That(reader.GetString(1), Is.EqualTo("foo"));
1307      }
1308      [Test]
1309      public async Task TextReader_zero_length_column()
1310      {
1311          await using var conn = await OpenConnectionAsync();
1312          await using var cmd = conn.CreateCommand();
1313          cmd.CommandText = "SELECT ''";
1314          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1315          Assert.IsTrue(await reader.ReadAsync());
1316          using var textReader = reader.GetTextReader(0);
1317          Assert.That(textReader.Peek(), Is.EqualTo(-1));
1318          Assert.That(textReader.ReadToEnd(), Is.EqualTo(string.Empty));
1319      }
1320      [Test]
1321      public async Task Open_TextReader_when_changing_columns()
1322      {
1323          using var conn = await OpenConnectionAsync();
1324          using var cmd = new NpgsqlCommand(@"SELECT 'some_text', 'some_text'", conn);
1325          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1326          reader.Read();
1327          var textReader = reader.GetTextReader(0);
1328          var v = reader.GetValue(1);
1329          Assert.That(() => textReader.Peek(), Throws.Exception.TypeOf<ObjectDisposedException>());
1330      }
1331      [Test]
1332      public async Task Open_TextReader_when_changing_rows()
1333      {
1334          using var conn = await OpenConnectionAsync();
1335          using var cmd = new NpgsqlCommand(@"SELECT 'some_text', 'some_text'", conn);
1336          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1337          reader.Read();
1338          var tr1 = reader.GetTextReader(0);
1339          reader.Read();
1340          Assert.That(() => tr1.Peek(), Throws.Exception.TypeOf<ObjectDisposedException>());
1341      }
1342      [Test]
1343      public async Task GetChars_when_null()
1344      {
1345          var buf = new char[8];
1346          using var conn = await OpenConnectionAsync();
1347          using var cmd = new NpgsqlCommand("SELECT NULL::TEXT", conn);
1348          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1349          reader.Read();
1350          Assert.That(reader.IsDBNull(0), Is.True);
1351          Assert.That(() => reader.GetChars(0, 0, buf, 0, 1), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars");
1352          Assert.That(() => reader.GetTextReader(0), Throws.Exception.TypeOf<InvalidCastException>(), "GetTextReader");
1353          Assert.That(() => reader.GetChars(0, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars with null buffer");
1354      }
1355      [Test]
1356      public async Task Reader_is_reused()
1357      {
1358          if (IsMultiplexing)
1359              Assert.Ignore("Multiplexing: Fails");
1360          using var conn = await OpenConnectionAsync();
1361          NpgsqlDataReader reader1;
1362          using (var cmd = new NpgsqlCommand("SELECT 8", conn))
1363          using (reader1 = await cmd.ExecuteReaderAsync(Behavior))
1364          {
1365              reader1.Read();
1366              Assert.That(reader1.GetInt32(0), Is.EqualTo(8));
1367          }
1368          using (var cmd = new NpgsqlCommand("SELECT 9", conn))
1369          using (var reader2 = await cmd.ExecuteReaderAsync(Behavior))
1370          {
1371              Assert.That(reader2, Is.SameAs(reader1));
1372              reader2.Read();
1373              Assert.That(reader2.GetInt32(0), Is.EqualTo(9));
1374          }
1375      }
1376      [Test]
1377      public async Task GetTextReader_after_consuming_column_throws([Values] bool async)
1378      {
1379          if (!IsSequential)
1380              return;
1381          await using var conn = await OpenConnectionAsync();
1382          await using var cmd = new NpgsqlCommand("SELECT 'foo'", conn);
1383          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1384          await reader.ReadAsync();
1385          _ = reader.GetString(0);
1386          if (async)
1387              Assert.That(() => reader.GetTextReaderAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1388          else
1389              Assert.That(() => reader.GetTextReader(0), Throws.Exception.TypeOf<InvalidOperationException>());
1390      }
1391      [Test]
1392      public async Task GetTextReader_in_middle_of_column_throws([Values] bool async)
1393      {
1394          if (!IsSequential)
1395              return;
1396          await using var conn = await OpenConnectionAsync();
1397          await using var cmd = new NpgsqlCommand("SELECT 'foo'", conn);
1398          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1399          await reader.ReadAsync();
1400          _ = reader.GetChars(0, 0, new char[2], 0, 2);
1401          if (async)
1402              Assert.That(() => reader.GetTextReaderAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1403          else
1404              Assert.That(() => reader.GetTextReader(0), Throws.Exception.TypeOf<InvalidOperationException>());
1405      }
1406      #endregion GetChars / GetTextReader
1407      [Test, Description("Tests that everything goes well when a type handler generates a NpgsqlSafeReadException")]
1408      public async Task SafeReadException()
1409      {
1410          var dataSourceBuilder = CreateDataSourceBuilder();
1411          dataSourceBuilder.AddTypeResolverFactory(new ExplodingTypeHandlerResolverFactory(safe: true));
1412          await using var dataSource = dataSourceBuilder.Build();
1413          await using var connection = await dataSource.OpenConnectionAsync();
1414          await using var cmd = new NpgsqlCommand(@"SELECT 1, 'hello'", connection);
1415          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1416          await reader.ReadAsync();
1417          Assert.That(() => reader.GetInt32(0),
1418              Throws.Exception.With.Message.EqualTo("Safe read exception as requested"));
1419          Assert.That(reader.GetString(1), Is.EqualTo("hello"));
1420      }
1421      [Test, Description("Tests that when a type handler generates an exception that isn't a NpgsqlSafeReadException, the connection is properly broken")]
1422      public async Task Non_SafeReadException()
1423      {
1424          var dataSourceBuilder = CreateDataSourceBuilder();
1425          dataSourceBuilder.AddTypeResolverFactory(new ExplodingTypeHandlerResolverFactory(safe: false));
1426          await using var dataSource = dataSourceBuilder.Build();
1427          await using var connection = await dataSource.OpenConnectionAsync();
1428          await using var cmd = new NpgsqlCommand(@"SELECT 1, 'hello'", connection);
1429          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1430          await reader.ReadAsync();
1431          Assert.That(() => reader.GetInt32(0), Throws.Exception.With.Message.EqualTo("Non-safe read exception as requested"));
1432          Assert.That(connection.FullState, Is.EqualTo(ConnectionState.Broken));
1433          Assert.That(connection.State, Is.EqualTo(ConnectionState.Closed));
1434      }
1435      #region Cancellation
1436      [Test, Description("Cancels ReadAsync via the NpgsqlCommand.Cancel, with successful PG cancellation")]
1437      public async Task ReadAsync_cancel_command_soft()
1438      {
1439          if (IsMultiplexing)
1440              return; 
1441          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1442          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1443          await using var conn = await dataSource.OpenConnectionAsync();
1444          var pgMock = await postmasterMock.WaitForServerConnection();
1445          await pgMock
1446              .WriteParseComplete()
1447              .WriteBindComplete()
1448              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1449              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1450              .FlushAsync();
1451          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1452          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1453          {
1454              Assert.True(await reader.ReadAsync());
1455              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1456              var task = reader.ReadAsync();
1457              cmd.Cancel();
1458              var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1459              Assert.That(processId, Is.EqualTo(conn.ProcessID));
1460              await pgMock
1461                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1462                  .WriteReadyForQuery()
1463                  .FlushAsync();
1464              var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1465              Assert.That(exception.InnerException,
1466                  Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
1467              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
1468          }
1469          await pgMock.WriteScalarResponseAndFlush(1);
1470          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1471      }
1472      [Test, Description("Cancels ReadAsync via the cancellation token, with successful PG cancellation")]
1473      public async Task ReadAsync_cancel_soft()
1474      {
1475          if (IsMultiplexing)
1476              return; 
1477          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1478          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1479          await using var conn = await dataSource.OpenConnectionAsync();
1480          var pgMock = await postmasterMock.WaitForServerConnection();
1481          await pgMock
1482              .WriteParseComplete()
1483              .WriteBindComplete()
1484              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1485              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1486              .FlushAsync();
1487          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1488          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1489          {
1490              Assert.True(await reader.ReadAsync());
1491              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1492              var cancellationSource = new CancellationTokenSource();
1493              var task = reader.ReadAsync(cancellationSource.Token);
1494              cancellationSource.Cancel();
1495              var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1496              Assert.That(processId, Is.EqualTo(conn.ProcessID));
1497              await pgMock
1498                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1499                  .WriteReadyForQuery()
1500                  .FlushAsync();
1501              var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1502              Assert.That(exception.InnerException,
1503                  Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
1504              Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1505              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
1506          }
1507          await pgMock.WriteScalarResponseAndFlush(1);
1508          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1509      }
1510      [Test, Description("Cancels NextResultAsync via the cancellation token, with successful PG cancellation")]
1511      public async Task NextResult_cancel_soft()
1512      {
1513          if (IsMultiplexing)
1514              return; 
1515          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1516          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1517          await using var conn = await dataSource.OpenConnectionAsync();
1518          var pgMock = await postmasterMock.WaitForServerConnection();
1519          await pgMock
1520              .WriteParseComplete()
1521              .WriteBindComplete()
1522              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1523              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1524              .WriteCommandComplete()
1525              .FlushAsync();
1526          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2", conn);
1527          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1528          {
1529              Assert.True(await reader.ReadAsync());
1530              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1531              var cancellationSource = new CancellationTokenSource();
1532              var task = reader.NextResultAsync(cancellationSource.Token);
1533              cancellationSource.Cancel();
1534              var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1535              Assert.That(processId, Is.EqualTo(conn.ProcessID));
1536              await pgMock
1537                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1538                  .WriteReadyForQuery()
1539                  .FlushAsync();
1540              var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1541              Assert.That(exception.InnerException,
1542                  Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
1543              Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1544              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
1545          }
1546          await pgMock.WriteScalarResponseAndFlush(1);
1547          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1548      }
1549      [Test, Description("Cancels ReadAsync via the cancellation token, with unsuccessful PG cancellation (socket break)")]
1550      public async Task ReadAsync_cancel_hard([Values(true, false)] bool passCancelledToken)
1551      {
1552          if (IsMultiplexing)
1553              return; 
1554          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1555          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1556          await using var conn = await dataSource.OpenConnectionAsync();
1557          var pgMock = await postmasterMock.WaitForServerConnection();
1558          await pgMock
1559              .WriteParseComplete()
1560              .WriteBindComplete()
1561              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1562              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1563              .FlushAsync();
1564          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1565          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1566          Assert.True(await reader.ReadAsync());
1567          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1568          var cancellationSource = new CancellationTokenSource();
1569          if (passCancelledToken)
1570              cancellationSource.Cancel();
1571          var task = reader.ReadAsync(cancellationSource.Token);
1572          cancellationSource.Cancel();
1573          var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1574          Assert.That(processId, Is.EqualTo(conn.ProcessID));
1575          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1576          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1577          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1578          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1579      }
1580      [Test, Description("Cancels NextResultAsync via the cancellation token, with unsuccessful PG cancellation (socket break)")]
1581      public async Task NextResultAsync_cancel_hard([Values(true, false)] bool passCancelledToken)
1582      {
1583          if (IsMultiplexing)
1584              return; 
1585          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1586          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1587          await using var conn = await dataSource.OpenConnectionAsync();
1588          var pgMock = await postmasterMock.WaitForServerConnection();
1589          await pgMock
1590              .WriteParseComplete()
1591              .WriteBindComplete()
1592              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1593              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1594              .WriteCommandComplete()
1595              .FlushAsync();
1596          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1597          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1598          Assert.True(await reader.ReadAsync());
1599          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1600          var cancellationSource = new CancellationTokenSource();
1601          if (passCancelledToken)
1602              cancellationSource.Cancel();
1603          var task = reader.NextResultAsync(cancellationSource.Token);
1604          cancellationSource.Cancel();
1605          var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1606          Assert.That(processId, Is.EqualTo(conn.ProcessID));
1607          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1608          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1609          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1610          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1611      }
1612      [Test, Description("Cancels sequential ReadAsGetFieldValueAsync")]
1613      public async Task GetFieldValueAsync_sequential_cancel([Values(true, false)] bool passCancelledToken)
1614      {
1615          if (IsMultiplexing)
1616              return; 
1617          if (!IsSequential)
1618              return;
1619          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1620          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1621          await using var conn = await dataSource.OpenConnectionAsync();
1622          var pgMock = await postmasterMock.WaitForServerConnection();
1623          await pgMock
1624              .WriteParseComplete()
1625              .WriteBindComplete()
1626              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea))
1627              .WriteDataRowWithFlush(new byte[10000]);
1628          using var cmd = new NpgsqlCommand("SELECT some_bytea FROM some_table", conn);
1629          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1630          await reader.ReadAsync();
1631          using var cts = new CancellationTokenSource();
1632          if (passCancelledToken)
1633              cts.Cancel();
1634          var task = reader.GetFieldValueAsync<byte[]>(0, cts.Token);
1635          cts.Cancel();
1636          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1637          Assert.That(exception.InnerException, Is.Null);
1638          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1639      }
1640      [Test, Description("Cancels sequential ReadAsGetFieldValueAsync")]
1641      public async Task IsDBNullAsync_sequential_cancel([Values(true, false)] bool passCancelledToken)
1642      {
1643          if (IsMultiplexing)
1644              return; 
1645          if (!IsSequential)
1646              return;
1647          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1648          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1649          await using var conn = await dataSource.OpenConnectionAsync();
1650          var pgMock = await postmasterMock.WaitForServerConnection();
1651          await pgMock
1652              .WriteParseComplete()
1653              .WriteBindComplete()
1654              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea), new FieldDescription(PostgresTypeOIDs.Int4))
1655              .WriteDataRowWithFlush(new byte[10000], new byte[4]);
1656          using var cmd = new NpgsqlCommand("SELECT some_bytea, some_int FROM some_table", conn);
1657          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1658          await reader.ReadAsync();
1659          using var cts = new CancellationTokenSource();
1660          if (passCancelledToken)
1661              cts.Cancel();
1662          var task = reader.IsDBNullAsync(1, cts.Token);
1663          cts.Cancel();
1664          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1665          Assert.That(exception.InnerException, Is.Null);
1666          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1667      }
1668      [Test, Description("Cancellation does not work with the multiplexing")]
1669      public async Task Cancel_multiplexing_disabled()
1670      {
1671          if (!IsMultiplexing)
1672              return;
1673          await using var dataSource = CreateDataSource();
1674          await using var conn = await dataSource.OpenConnectionAsync();
1675          await using var cmd = new NpgsqlCommand("SELECT generate_series(1, 100); SELECT generate_series(1, 100)", conn);
1676          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1677          var cancelledToken = new CancellationToken(canceled: true);
1678          Assert.IsTrue(await reader.ReadAsync());
1679          while (await reader.ReadAsync(cancelledToken)) { }
1680          Assert.IsTrue(await reader.NextResultAsync(cancelledToken));
1681          while (await reader.ReadAsync(cancelledToken)) { }
1682          Assert.IsFalse(conn.Connector!.UserCancellationRequested);
1683      }
1684      #endregion Cancellation
1685      #region Timeout
1686      [Test, Description("Timeouts sequential ReadAsGetFieldValueAsync")]
1687      public async Task GetFieldValueAsync_sequential_timeout()
1688      {
1689          if (IsMultiplexing)
1690              return; 
1691          if (!IsSequential)
1692              return;
1693          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1694          {
1695              CommandTimeout = 3,
1696              CancellationTimeout = 15000
1697          };
1698          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1699          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1700          await using var conn = await dataSource.OpenConnectionAsync();
1701          var pgMock = await postmasterMock.WaitForServerConnection();
1702          await pgMock
1703              .WriteParseComplete()
1704              .WriteBindComplete()
1705              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea))
1706              .WriteDataRowWithFlush(new byte[10000]);
1707          using var cmd = new NpgsqlCommand("SELECT some_bytea FROM some_table", conn);
1708          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1709          await reader.ReadAsync();
1710          var task = reader.GetFieldValueAsync<byte[]>(0);
1711          var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await task)!;
1712          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1713          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1714      }
1715      [Test, Description("Timeouts sequential IsDBNullAsync")]
1716      public async Task IsDBNullAsync_sequential_timeout()
1717      {
1718          if (IsMultiplexing)
1719              return; 
1720          if (!IsSequential)
1721              return;
1722          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1723          {
1724              CommandTimeout = 3,
1725              CancellationTimeout = 15000
1726          };
1727          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1728          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1729          await using var conn = await dataSource.OpenConnectionAsync();
1730          var pgMock = await postmasterMock.WaitForServerConnection();
1731          await pgMock
1732              .WriteParseComplete()
1733              .WriteBindComplete()
1734              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea), new FieldDescription(PostgresTypeOIDs.Int4))
1735              .WriteDataRowWithFlush(new byte[10000], new byte[4]);
1736          using var cmd = new NpgsqlCommand("SELECT some_bytea, some_int FROM some_table", conn);
1737          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1738          await reader.ReadAsync();
1739          var task = reader.GetFieldValueAsync<byte[]>(0);
1740          var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await task)!;
1741          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1742          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1743      }
1744      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3446")]
1745      public async Task Bug3446()
1746      {
1747          if (IsMultiplexing)
1748              return; 
1749          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1750          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1751          await using var conn = await dataSource.OpenConnectionAsync();
1752          var pgMock = await postmasterMock.WaitForServerConnection();
1753          await pgMock
1754              .WriteParseComplete()
1755              .WriteBindComplete()
1756              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1757              .WriteDataRow(new byte[4])
1758              .FlushAsync();
1759          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1760          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1761          {
1762              await reader.ReadAsync();
1763              cmd.Cancel();
1764              await postmasterMock.WaitForCancellationRequest();
1765              await pgMock
1766                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1767                  .WriteReadyForQuery()
1768                  .FlushAsync();
1769          }
1770          Assert.That(conn.Connector!.State, Is.EqualTo(ConnectorState.Ready));
1771      }
1772      #endregion
1773      #region Initialization / setup / teardown
1774      readonly bool IsSequential;
1775      readonly CommandBehavior Behavior;
1776      public ReaderTests(MultiplexingMode multiplexingMode, CommandBehavior behavior) : base(multiplexingMode)
1777      {
1778          Behavior = behavior;
1779          IsSequential = (Behavior & CommandBehavior.SequentialAccess) != 0;
1780      }
1781      #endregion
1782  }
1783  #region Mock Type Handlers
1784  class ExplodingTypeHandlerResolverFactory : TypeHandlerResolverFactory
1785  {
1786      readonly bool _safe;
1787      public ExplodingTypeHandlerResolverFactory(bool safe) => _safe = safe;
1788      public override TypeHandlerResolver Create(TypeMapper typeMapper, NpgsqlConnector connector) => new ExplodingTypeHandlerResolver(_safe);
1789      class ExplodingTypeHandlerResolver : TypeHandlerResolver
1790      {
1791          readonly bool _safe;
1792          public ExplodingTypeHandlerResolver(bool safe) => _safe = safe;
1793          public override NpgsqlTypeHandler? ResolveByDataTypeName(string typeName) =>
1794              typeName == "integer" ? new ExplodingTypeHandler(null!, _safe) : null;
1795          public override NpgsqlTypeHandler? ResolveByClrType(Type type) => null;
1796      }
1797  }
1798  class ExplodingTypeHandler : NpgsqlSimpleTypeHandler<int>
1799  {
1800      readonly bool _safe;
1801      internal ExplodingTypeHandler(PostgresType postgresType, bool safe) : base(postgresType) => _safe = safe;
1802      public override int Read(NpgsqlReadBuffer buf, int len, FieldDescription? fieldDescription = null)
1803      {
1804          buf.ReadInt32();
1805          throw _safe
1806              ? new Exception("Safe read exception as requested")
1807              : buf.Connector.Break(new Exception("Non-safe read exception as requested"));
1808      }
1809      public override int ValidateAndGetLength(int value, NpgsqlParameter? parameter) => throw new NotSupportedException();
1810      public override int ValidateObjectAndGetLength(object? value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
1811          => throw new NotSupportedException();
1812      public override void Write(int value, NpgsqlWriteBuffer buf, NpgsqlParameter? parameter) => throw new NotSupportedException();
1813      public override Task WriteObjectWithLength(
1814          object? value,
1815          NpgsqlWriteBuffer buf,
1816          NpgsqlLengthCache? lengthCache,
1817          NpgsqlParameter? parameter,
1818          bool async,
1819          CancellationToken cancellationToken = default)
1820          => throw new NotSupportedException();
1821  }
1822  #endregion
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ReaderTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>743          var sproc = await GetTempProcedureName(conn);
744          var createFunction = $@"
745  CREATE PROCEDURE {sproc}(OUT a integer, OUT b boolean) AS $$
746  BEGIN
747      a := 3;
748      b := true;
749  END
750  $$ LANGUAGE plpgsql;";
751          var command = new NpgsqlCommand(createFunction, conn);
</pre></code></div>
                <div class="column column_space"><pre><code>776          var function = await GetTempFunctionName(conn);
777          var initializeTablesSql = $@"
778  CREATE TABLE {table1} (value int NOT NULL);
779  CREATE TABLE {table2} (value int UNIQUE);
780  ALTER TABLE ONLY {table1} ADD CONSTRAINT {table1}_{table2}_fk FOREIGN KEY (value) REFERENCES {table2}(value) DEFERRABLE INITIALLY DEFERRED;
781  CREATE OR REPLACE FUNCTION {function}(_value int) RETURNS int AS $BODY$
782  BEGIN
783      INSERT INTO {table1}(value) VALUES(_value);
784      RETURN _value;
785  END;
786  $BODY$
787  LANGUAGE plpgsql VOLATILE";
788          await conn.ExecuteNonQueryAsync(initializeTablesSql);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    