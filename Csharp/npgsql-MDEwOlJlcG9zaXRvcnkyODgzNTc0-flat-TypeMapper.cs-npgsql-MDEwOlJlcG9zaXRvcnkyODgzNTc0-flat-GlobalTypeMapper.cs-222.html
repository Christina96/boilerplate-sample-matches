
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using Microsoft.Extensions.Logging;
9  using Npgsql.Internal.TypeHandlers;
10  using Npgsql.Internal.TypeHandling;
11  using Npgsql.PostgresTypes;
12  using Npgsql.TypeMapping;
13  using NpgsqlTypes;
14  namespace Npgsql.Internal.TypeMapping;
15  public sealed class TypeMapper
16  {
17      internal NpgsqlConnector Connector { get; }
18      readonly object _writeLock = new();
19      NpgsqlDatabaseInfo? _databaseInfo;
20      internal NpgsqlDatabaseInfo DatabaseInfo
21      {
22          get
23          {
24              var databaseInfo = _databaseInfo;
25              if (databaseInfo is null)
26                  ThrowHelper.ThrowInvalidOperationException(&quot;Internal error: this type mapper hasn&#x27;t yet been bound to a database info object&quot;);
27              return databaseInfo;
28          }
29      }
30      volatile TypeHandlerResolver[] _handlerResolvers;
31      volatile TypeMappingResolver[] _mappingResolvers;
32      internal NpgsqlTypeHandler UnrecognizedTypeHandler { get; }
33      readonly ConcurrentDictionary&lt;uint, NpgsqlTypeHandler&gt; _handlersByOID = new();
34      readonly ConcurrentDictionary&lt;NpgsqlDbType, NpgsqlTypeHandler&gt; _handlersByNpgsqlDbType = new();
35      readonly ConcurrentDictionary&lt;Type, NpgsqlTypeHandler&gt; _handlersByClrType = new();
36      readonly ConcurrentDictionary&lt;string, NpgsqlTypeHandler&gt; _handlersByDataTypeName = new();
37      readonly Dictionary&lt;uint, TypeMappingInfo&gt; _userTypeMappings = new();
38      readonly INpgsqlNameTranslator _defaultNameTranslator;
39      readonly ILogger _commandLogger;
40      #region Construction
41      internal TypeMapper(NpgsqlConnector connector, INpgsqlNameTranslator defaultNameTranslator)
42      {
43          Connector = connector;
44          _defaultNameTranslator = defaultNameTranslator;
45          UnrecognizedTypeHandler = new UnknownTypeHandler(Connector.TextEncoding);
46          _handlerResolvers = Array.Empty&lt;TypeHandlerResolver&gt;();
47          _mappingResolvers = Array.Empty&lt;TypeMappingResolver&gt;();
48          _commandLogger = connector.LoggingConfiguration.CommandLogger;
49      }
50      #endregion Constructors
51      internal void Initialize(
52          NpgsqlDatabaseInfo databaseInfo,
53          List&lt;TypeHandlerResolverFactory&gt; resolverFactories,
54          Dictionary&lt;string, IUserTypeMapping&gt; userTypeMappings)
55      {
56          _databaseInfo = databaseInfo;
57          var handlerResolvers = new TypeHandlerResolver[resolverFactories.Count];
58          var mappingResolvers = new List&lt;TypeMappingResolver&gt;(resolverFactories.Count);
59          for (var i = 0; i &lt; resolverFactories.Count; i++)
60          {
61              handlerResolvers[i] = resolverFactories[i].Create(this, Connector);
62              var mappingResolver = resolverFactories[i].CreateMappingResolver();
63              if (mappingResolver is not null)
64                  mappingResolvers.Add(mappingResolver);
65          }
66          for (var i = resolverFactories.Count - 1; i &gt;= 0; i--)
67          {
68              var globalMappingResolver = resolverFactories[i].CreateGlobalMappingResolver();
69              if (globalMappingResolver is not null)
70                  GlobalTypeMapper.Instance.TryAddMappingResolver(globalMappingResolver);
71          }
72          _handlerResolvers = handlerResolvers;
73          _mappingResolvers = mappingResolvers.ToArray();
74          foreach (var userTypeMapping in userTypeMappings.Values)
75          {
76              if (DatabaseInfo.TryGetPostgresTypeByName(userTypeMapping.PgTypeName, out var pgType))
77              {
78                  _handlersByOID[pgType.OID] =
79                      _handlersByDataTypeName[pgType.FullName] =
80                          _handlersByDataTypeName[pgType.Name] =
81                              _handlersByClrType[userTypeMapping.ClrType] = userTypeMapping.CreateHandler(pgType, Connector);
82                  _userTypeMappings[pgType.OID] = new(npgsqlDbType: null, pgType.Name, userTypeMapping.ClrType);
83              }
84          }
85      }
86      #region Type handler lookup
87      public NpgsqlTypeHandler ResolveByOID(uint oid)
88          =&gt; TryResolveByOID(oid, out var result) ? result : UnrecognizedTypeHandler;
89      internal bool TryResolveByOID(uint oid, [NotNullWhen(true)] out NpgsqlTypeHandler? handler)
90      {
91          if (_handlersByOID.TryGetValue(oid, out handler))
92              return true;
93          return TryResolveLong(oid, out handler);
94          bool TryResolveLong(uint oid, [NotNullWhen(true)] out NpgsqlTypeHandler? handler)
95          {
96              if (!DatabaseInfo.ByOID.TryGetValue(oid, out var pgType))
97              {
98                  handler = null;
99                  return false;
100              }
101              lock (_writeLock)
102              {
103                  if ((handler = ResolveByPostgresType(pgType)) is not null)
104                  {
105                      _handlersByOID[oid] = handler;
106                      return true;
107                  }
108                  if ((handler = ResolveComplexTypeByDataTypeName(pgType.FullName, throwOnError: false)) is not null)
109                  {
110                      _handlersByOID[oid] = handler;
111                      return true;
112                  }
113                  handler = null;
114                  return false;
115              }
116          }
117      }
118      public NpgsqlTypeHandler ResolveByNpgsqlDbType(NpgsqlDbType npgsqlDbType)
119      {
120          if (_handlersByNpgsqlDbType.TryGetValue(npgsqlDbType, out var handler))
121              return handler;
122          return ResolveLong(npgsqlDbType);
123          NpgsqlTypeHandler ResolveLong(NpgsqlDbType npgsqlDbType)
124          {
125              lock (_writeLock)
126              {
127                  if (GlobalTypeMapper.NpgsqlDbTypeToDataTypeName(npgsqlDbType) is { } dataTypeName)
128                  {
129                      foreach (var resolver in _handlerResolvers)
130                      {
131                          try
132                          {
133                              if (resolver.ResolveByDataTypeName(dataTypeName) is { } handler)
134                                  return _handlersByNpgsqlDbType[npgsqlDbType] = handler;
135                          }
136                          catch (Exception e)
137                          {
138                              _commandLogger.LogError(e,
139                                  $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving NpgsqlDbType {npgsqlDbType}&quot;);
140                          }
141                      }
142                  }
143                  foreach (var resolver in _handlerResolvers)
144                  {
145                      try
146                      {
147                          if (resolver.ResolveByNpgsqlDbType(npgsqlDbType) is { } handler)
148                              return _handlersByNpgsqlDbType[npgsqlDbType] = handler;
149                      }
150                      catch (Exception e)
151                      {
152                          _commandLogger.LogError(e,
153                              $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving NpgsqlDbType {npgsqlDbType}&quot;);
154                      }
155                  }
156                  if (npgsqlDbType.HasFlag(NpgsqlDbType.Array))
157                  {
158                      var elementHandler = ResolveByNpgsqlDbType(npgsqlDbType &amp; ~NpgsqlDbType.Array);
159                      if (elementHandler.PostgresType.Array is not { } pgArrayType)
160                          throw new ArgumentException(
161                              $&quot;No array type could be found in the database for element {elementHandler.PostgresType}&quot;);
162                      return _handlersByNpgsqlDbType[npgsqlDbType] =
163                          elementHandler.CreateArrayHandler(pgArrayType, Connector.Settings.ArrayNullabilityMode);
164                  }
165                  throw new NpgsqlException($&quot;The NpgsqlDbType &#x27;{npgsqlDbType}&#x27; isn&#x27;t present in your database. &quot; +
166                                            &quot;You may need to install an extension or upgrade to a newer version.&quot;);
167              }
168          }
169      }
170      internal NpgsqlTypeHandler ResolveByDataTypeName(string typeName)
171          =&gt; ResolveByDataTypeNameCore(typeName) ?? ResolveComplexTypeByDataTypeName(typeName, throwOnError: true)!;
172      NpgsqlTypeHandler? ResolveByDataTypeNameCore(string typeName)
173      {
174          if (_handlersByDataTypeName.TryGetValue(typeName, out var handler))
175              return handler;
176          return ResolveLong(typeName);
177          NpgsqlTypeHandler? ResolveLong(string typeName)
178          {
179              lock (_writeLock)
180              {
181                  foreach (var resolver in _handlerResolvers)
182                  {
183                      try
184                      {
185                          if (resolver.ResolveByDataTypeName(typeName) is { } handler)
186                              return _handlersByDataTypeName[typeName] = handler;
187                      }
188                      catch (Exception e)
189                      {
190                          _commandLogger.LogError(e, $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving data type name {typeName}&quot;);
191                      }
192                  }
193                  return null;
194              }
195          }
196      }
197      NpgsqlTypeHandler? ResolveByPostgresType(PostgresType type)
198      {
199          if (_handlersByDataTypeName.TryGetValue(type.FullName, out var handler))
200              return handler;
201          return ResolveLong(type);
202          NpgsqlTypeHandler? ResolveLong(PostgresType type)
203          {
204              lock (_writeLock)
205              {
206                  foreach (var resolver in _handlerResolvers)
207                  {
208                      try
209                      {
210                          if (resolver.ResolveByPostgresType(type) is { } handler)
211                              return _handlersByDataTypeName[type.FullName] = handler;
212                      }
213                      catch (Exception e)
214                      {
215                          _commandLogger.LogError(e, $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving data type name {type.FullName}&quot;);
216                      }
217                  }
218                  return null;
219              }
220          }
221      }
222      NpgsqlTypeHandler? ResolveComplexTypeByDataTypeName(string typeName, bool throwOnError)
223      {
224          lock (_writeLock)
225          {
226              var pgType = DatabaseInfo.GetPostgresTypeByName(typeName);
227              switch (pgType)
228              {
229              case PostgresArrayType pgArrayType:
230              {
231                  var elementHandler = ResolveByOID(pgArrayType.Element.OID);
232                  return _handlersByDataTypeName[typeName] =
233                      elementHandler.CreateArrayHandler(pgArrayType, Connector.Settings.ArrayNullabilityMode);
234              }
235              case PostgresEnumType pgEnumType:
236              {
237                  return _handlersByDataTypeName[typeName] =
238                      new UnmappedEnumHandler(pgEnumType, _defaultNameTranslator, Connector.TextEncoding);
239              }
240              case PostgresDomainType pgDomainType:
241                  return _handlersByDataTypeName[typeName] = ResolveByOID(pgDomainType.BaseType.OID);
242              case PostgresBaseType pgBaseType:
243                  return throwOnError
244                      ? throw new NotSupportedException($&quot;PostgreSQL type &#x27;{pgBaseType}&#x27; isn&#x27;t supported by Npgsql&quot;)
245                      : null;
246              case PostgresCompositeType pgCompositeType:
247                  return throwOnError
248                      ? throw new NotSupportedException(
249                          $&quot;Composite type &#x27;{pgCompositeType}&#x27; must be mapped with Npgsql before being used, see the docs.&quot;)
250                      : null;
251  #pragma warning disable CS0618
252              case PostgresRangeType:
253              case PostgresMultirangeType:
254                  return throwOnError
255                      ? throw new NotSupportedException(
256                          $&quot;&#x27;{pgType}&#x27; is a range type; please call {nameof(NpgsqlSlimDataSourceBuilder.EnableRanges)} on {nameof(NpgsqlSlimDataSourceBuilder)} to enable ranges. &quot; +
257                          &quot;See https:&amp;bsol;&amp;bsol;www.npgsql.org/doc/types/ranges.html for more information.&quot;)
258                      : null;
259  #pragma warning restore CS0618
260              default:
261                  throw new ArgumentOutOfRangeException($&quot;Unhandled PostgreSQL type type: {pgType.GetType()}&quot;);
262              }
263          }
264      }
265      internal NpgsqlTypeHandler ResolveByValue&lt;T&gt;(T value)
266      {
267          if (value is null)
268              return ResolveByClrType(typeof(T));
269          if (typeof(T).IsValueType)
270          {
271              NpgsqlTypeHandler? handler;
272              foreach (var resolver in _handlerResolvers)
273              {
274                  try
275                  {
276                      if ((handler = resolver.ResolveValueTypeGenerically(value)) is not null)
277                          return handler;
278                  }
279                  catch (Exception e)
280                  {
281                      _commandLogger.LogError(e, $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving value with type {typeof(T)}&quot;);
282                  }
283              }
284          }
285          return ResolveByValue((object)value);
286      }
287      internal NpgsqlTypeHandler ResolveByValue(object value)
288      {
289          var type = value.GetType();
290          if (_handlersByClrType.TryGetValue(type, out var handler))
291              return handler;
292          return ResolveLong(value, type);
293          NpgsqlTypeHandler ResolveLong(object value, Type type)
294          {
295              foreach (var resolver in _handlerResolvers)
296              {
297                  try
298                  {
299                      if (resolver.ResolveValueDependentValue(value) is { } handler)
300                          return handler;
301                  }
302                  catch (Exception e)
303                  {
304                      _commandLogger.LogError(e, $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving value with type {type}&quot;);
305                  }
306              }
307              return ResolveByClrType(type);
308          }
309      }
310      public NpgsqlTypeHandler ResolveByClrType(Type type)
311      {
312          if (_handlersByClrType.TryGetValue(type, out var handler))
313              return handler;
314          return ResolveLong(type);
315          NpgsqlTypeHandler ResolveLong(Type type)
316          {
317              lock (_writeLock)
318              {
319                  foreach (var resolver in _handlerResolvers)
320                  {
321                      try
322                      {
323                          if (resolver.ResolveByClrType(type) is { } handler)
324                              return _handlersByClrType[type] = handler;
325                      }
326                      catch (Exception e)
327                      {
328                          _commandLogger.LogError(e, $&quot;Type resolver {resolver.GetType().Name} threw exception while resolving value with type {type}&quot;);
329                      }
330                  }
331                  var arrayElementType = GetArrayListElementType(type);
332                  if (arrayElementType is not null)
333                  {
334                      if (ResolveByClrType(arrayElementType) is not { } elementHandler)
335                          throw new ArgumentException($&quot;Array type over CLR type {arrayElementType.Name} isn&#x27;t supported by Npgsql&quot;);
336                      if (elementHandler.PostgresType.Array is not { } pgArrayType)
337                          throw new ArgumentException(
338                              $&quot;No array type could be found in the database for element {elementHandler.PostgresType}&quot;);
339                      return _handlersByClrType[type] =
340                          elementHandler.CreateArrayHandler(pgArrayType, Connector.Settings.ArrayNullabilityMode);
341                  }
342                  if (Nullable.GetUnderlyingType(type) is { } underlyingType &amp;&amp; ResolveByClrType(underlyingType) is { } underlyingHandler)
343                      return _handlersByClrType[type] = underlyingHandler;
344                  if (type.IsEnum)
345                  {
346                      return DatabaseInfo.TryGetPostgresTypeByName(GetPgName(type, _defaultNameTranslator), out var pgType)
347                             &amp;&amp; pgType is PostgresEnumType pgEnumType
348                          ? _handlersByClrType[type] = new UnmappedEnumHandler(pgEnumType, _defaultNameTranslator, Connector.TextEncoding)
349                          : throw new NotSupportedException(
350                              $&quot;Could not find a PostgreSQL enum type corresponding to {type.Name}. &quot; +
351                              &quot;Consider mapping the enum before usage, refer to the documentation for more details.&quot;);
352                  }
353                  if (typeof(IEnumerable).IsAssignableFrom(type))
354                      throw new NotSupportedException(&quot;IEnumerable parameters are not supported, pass an array or List instead&quot;);
355                  throw new NotSupportedException($&quot;The CLR type {type} isn&#x27;t natively supported by Npgsql or your PostgreSQL. &quot; +
356                                                  $&quot;To use it with a PostgreSQL composite you need to specify {nameof(NpgsqlParameter.DataTypeName)} or to map it, please refer to the documentation.&quot;);
357              }
358              static Type? GetArrayListElementType(Type type)
359              {
360                  var typeInfo = type.GetTypeInfo();
361                  if (typeInfo.IsArray)
362                      return GetUnderlyingType(type.GetElementType()!); 
363                  var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =&gt; x.GetTypeInfo().IsGenericType &amp;&amp; x.GetGenericTypeDefinition() == typeof(IList&lt;&gt;));
364                  if (ilist != null)
365                      return GetUnderlyingType(ilist.GetGenericArguments()[0]);
366                  if (typeof(IList).IsAssignableFrom(type))
367                      throw new NotSupportedException(&quot;Non-generic IList is a supported parameter, but the NpgsqlDbType parameter must be set on the parameter&quot;);
368                  return null;
369                  Type GetUnderlyingType(Type t)
370                      =&gt; Nullable.GetUnderlyingType(t) ?? t;
371              }   
372          }
373      }
374      #endregion Type handler lookup
375      internal bool TryGetMapping(PostgresType pgType, [NotNullWhen(true)] out TypeMappingInfo? mapping)
376      {
377          foreach (var resolver in _mappingResolvers)
378              if ((mapping = resolver.GetMappingByPostgresType(this, pgType)) is not null)
379                  return true;
380          switch (pgType)
381          {
382          case PostgresArrayType pgArrayType:
383              if (TryGetMapping(pgArrayType.Element, out var elementMapping))
384              {
385                  mapping = new(elementMapping.NpgsqlDbType | NpgsqlDbType.Array, pgType.DisplayName);
386                  return true;
387              }
388              break;
389          case PostgresDomainType pgDomainType:
390              if (TryGetMapping(pgDomainType.BaseType, out var baseMapping))
391              {
392                  mapping = new(baseMapping.NpgsqlDbType, pgType.DisplayName, baseMapping.ClrTypes);
393                  return true;
394              }
395              break;
396          case PostgresEnumType or PostgresCompositeType:
397              return _userTypeMappings.TryGetValue(pgType.OID, out mapping);
398          }
399          mapping = null;
400          return false;
401      }
402      internal (NpgsqlDbType? npgsqlDbType, PostgresType postgresType) GetTypeInfoByOid(uint oid)
403      {
404          if (!DatabaseInfo.ByOID.TryGetValue(oid, out var pgType))
405              ThrowHelper.ThrowInvalidOperationException($&quot;Couldn&#x27;t find PostgreSQL type with OID {oid}&quot;);
406          if (TryGetMapping(pgType, out var mapping))
407              return (mapping.NpgsqlDbType, pgType);
408          return (null, pgType);
409      }
<span onclick='openModal()' class='match'>410      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
411          =&gt; clrType.GetCustomAttribute&lt;PgNameAttribute&gt;()?.PgName
412             ?? nameTranslator.TranslateTypeName(clrType.Name);
413  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using System.Threading;
9  using Npgsql.Internal.TypeHandling;
10  using Npgsql.Internal.TypeMapping;
11  using Npgsql.NameTranslation;
12  using NpgsqlTypes;
13  using static Npgsql.Util.Statics;
14  namespace Npgsql.TypeMapping;
15  sealed class GlobalTypeMapper : INpgsqlTypeMapper
16  {
17      public static GlobalTypeMapper Instance { get; }
18      public INpgsqlNameTranslator DefaultNameTranslator { get; set; } = new NpgsqlSnakeCaseNameTranslator();
19      internal List&lt;TypeHandlerResolverFactory&gt; HandlerResolverFactories { get; } = new();
20      List&lt;TypeMappingResolver&gt; MappingResolvers { get; } = new();
21      public ConcurrentDictionary&lt;string, IUserTypeMapping&gt; UserTypeMappings { get; } = new();
22      readonly ConcurrentDictionary&lt;Type, TypeMappingInfo&gt; _mappingsByClrType = new();
23      internal ReaderWriterLockSlim Lock { get; }
24          = new(LockRecursionPolicy.SupportsRecursion);
25      static GlobalTypeMapper()
26          =&gt; Instance = new GlobalTypeMapper();
27      GlobalTypeMapper()
28          =&gt; Reset();
29      #region Mapping management
30      public INpgsqlTypeMapper MapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
31          where TEnum : struct, Enum
32      {
33          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
34              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
35          nameTranslator ??= DefaultNameTranslator;
36          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
37          Lock.EnterWriteLock();
38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping&lt;TEnum&gt;(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum&lt;TEnum&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
50          where TEnum : struct, Enum
51      {
52          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
53              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
54          nameTranslator ??= DefaultNameTranslator;
55          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
56          Lock.EnterWriteLock();
57          try
58          {
59              if (UserTypeMappings.TryRemove(pgName, out _))
60              {
61                  RecordChange();
62                  return true;
63              }
64              return false;
65          }
66          finally
67          {
68              Lock.ExitWriteLock();
69          }
70      }
71      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
72      public INpgsqlTypeMapper MapComposite&lt;T&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
73      {
74          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
75              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
76          nameTranslator ??= DefaultNameTranslator;
77          pgName ??= GetPgName(typeof(T), nameTranslator);
78          Lock.EnterWriteLock();
79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping&lt;T&gt;(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
91      public INpgsqlTypeMapper MapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
92      {
93          var openMethod = typeof(GlobalTypeMapper).GetMethod(nameof(MapComposite), new[] { typeof(string), typeof(INpgsqlNameTranslator) })!;
94          var method = openMethod.MakeGenericMethod(clrType);
95          method.Invoke(this, new object?[] { pgName, nameTranslator });
96          return this;
97      }
98      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
99      public bool UnmapComposite&lt;T&gt;(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
100          =&gt; UnmapComposite(typeof(T), pgName, nameTranslator);
101      [RequiresUnreferencedCode(&quot;Composite type mapping currently isn&#x27;t trimming-safe.&quot;)]
102      public bool UnmapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
103      {
104          if (pgName != null &amp;&amp; pgName.Trim() == &quot;&quot;)
105              throw new ArgumentException(&quot;pgName can&#x27;t be empty&quot;, nameof(pgName));
106          nameTranslator ??= DefaultNameTranslator;
107          pgName ??= GetPgName(clrType, nameTranslator);
108          Lock.EnterWriteLock();
109          try
110          {
111              if (UserTypeMappings.TryRemove(pgName, out _))
112              {
113                  RecordChange();
114                  return true;
115              }
116              return false;
117          }
118          finally
119          {
120              Lock.ExitWriteLock();
121          }
122      }
123      public void AddTypeResolverFactory(TypeHandlerResolverFactory resolverFactory)
124      {
125          Lock.EnterWriteLock();
126          try
127          {
128              var type = resolverFactory.GetType();
129              if (HandlerResolverFactories[0].GetType() == type)
130                  HandlerResolverFactories[0] = resolverFactory;
131              else
132              {
133                  for (var i = 0; i &lt; HandlerResolverFactories.Count; i++)
134                      if (HandlerResolverFactories[i].GetType() == type)
135                          HandlerResolverFactories.RemoveAt(i);
136                  HandlerResolverFactories.Insert(0, resolverFactory);
137              }
138              var mappingResolver = resolverFactory.CreateMappingResolver();
139              if (mappingResolver is not null)
140                  AddMappingResolver(mappingResolver, overwrite: true);
141              RecordChange();
142          }
143          finally
144          {
145              Lock.ExitWriteLock();
146          }
147      }
148      internal void TryAddMappingResolver(TypeMappingResolver resolver)
149      {
150          Lock.EnterWriteLock();
151          try
152          {
153              if (AddMappingResolver(resolver, overwrite: false))
154                  RecordChange();
155          }
156          finally
157          {
158              Lock.ExitWriteLock();
159          }
160      }
161      bool AddMappingResolver(TypeMappingResolver resolver, bool overwrite)
162      {
163          var type = resolver.GetType();
164          if (MappingResolvers[0].GetType() == type)
165          {
166              if (!overwrite)
167                  return false;
168              MappingResolvers[0] = resolver;
169          }
170          else
171          {
172              for (var i = 0; i &lt; MappingResolvers.Count; i++)
173              {
174                  if (MappingResolvers[i].GetType() == type)
175                  {
176                      if (!overwrite)
177                          return false;
178                      MappingResolvers.RemoveAt(i);
179                      break;
180                  }
181              }
182              MappingResolvers.Insert(0, resolver);
183          }
184          return true;
185      }
186      public void Reset()
187      {
188          Lock.EnterWriteLock();
189          try
190          {
191              HandlerResolverFactories.Clear();
192              HandlerResolverFactories.Add(new BuiltInTypeHandlerResolverFactory());
193              MappingResolvers.Clear();
194              MappingResolvers.Add(new BuiltInTypeMappingResolver());
195              UserTypeMappings.Clear();
196              RecordChange();
197          }
198          finally
199          {
200              Lock.ExitWriteLock();
201          }
202      }
203      internal void RecordChange()
204          =&gt; _mappingsByClrType.Clear();
<span onclick='openModal()' class='match'>205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          =&gt; clrType.GetCustomAttribute&lt;PgNameAttribute&gt;()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
</span>209      #region NpgsqlDbType/DbType inference for NpgsqlParameter
210      [RequiresUnreferencedCode(&quot;ToNpgsqlDbType uses interface-based reflection and isn&#x27;t trimming-safe&quot;)]
211      internal bool TryResolveMappingByValue(object value, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
212      {
213          Lock.EnterReadLock();
214          try
215          {
216              var type = value.GetType();
217              if (_mappingsByClrType.TryGetValue(type, out typeMapping))
218                  return true;
219              foreach (var resolver in MappingResolvers)
220                  if ((typeMapping = resolver.GetMappingByValueDependentValue(value)) is not null)
221                      return true;
222              return TryResolveMappingByClrType(type, out typeMapping);
223          }
224          finally
225          {
226              Lock.ExitReadLock();
227          }
228          bool TryResolveMappingByClrType(Type clrType, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
229          {
230              if (_mappingsByClrType.TryGetValue(clrType, out typeMapping))
231                  return true;
232              foreach (var resolver in MappingResolvers)
233              {
234                  if ((typeMapping = resolver.GetMappingByClrType(clrType)) is not null)
235                  {
236                      _mappingsByClrType[clrType] = typeMapping;
237                      return true;
238                  }
239              }
240              if (clrType.IsArray)
241              {
242                  if (TryResolveMappingByClrType(clrType.GetElementType()!, out var elementMapping))
243                  {
244                      _mappingsByClrType[clrType] = typeMapping = new(
245                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
246                          elementMapping.DataTypeName + &quot;[]&quot;);
247                      return true;
248                  }
249                  typeMapping = null;
250                  return false;
251              }
252              var typeInfo = clrType.GetTypeInfo();
253              var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =&gt;
254                  x.GetTypeInfo().IsGenericType &amp;&amp; x.GetGenericTypeDefinition() == typeof(IList&lt;&gt;));
255              if (ilist != null)
256              {
257                  if (TryResolveMappingByClrType(ilist.GetGenericArguments()[0], out var elementMapping))
258                  {
259                      _mappingsByClrType[clrType] = typeMapping = new(
260                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
261                          elementMapping.DataTypeName + &quot;[]&quot;);
262                      return true;
263                  }
264                  typeMapping = null;
265                  return false;
266              }
267              if (typeInfo.IsGenericType &amp;&amp; clrType.GetGenericTypeDefinition() == typeof(NpgsqlRange&lt;&gt;))
268              {
269                  if (TryResolveMappingByClrType(clrType.GetGenericArguments()[0], out var elementMapping))
270                  {
271                      _mappingsByClrType[clrType] = typeMapping = new(
272                          NpgsqlDbType.Range | elementMapping.NpgsqlDbType,
273                          dataTypeName: null);
274                      return true;
275                  }
276                  typeMapping = null;
277                  return false;
278              }
279              typeMapping = null;
280              return false;
281          }
282      }
283      #endregion NpgsqlDbType/DbType inference for NpgsqlParameter
284      #region Static translation tables
285      public static string? NpgsqlDbTypeToDataTypeName(NpgsqlDbType npgsqlDbType)
286          =&gt; npgsqlDbType switch
287          {
288              NpgsqlDbType.Smallint =&gt; &quot;smallint&quot;,
289              NpgsqlDbType.Integer  =&gt; &quot;integer&quot;,
290              NpgsqlDbType.Bigint   =&gt; &quot;bigint&quot;,
291              NpgsqlDbType.Real     =&gt; &quot;real&quot;,
292              NpgsqlDbType.Double   =&gt; &quot;double precision&quot;,
293              NpgsqlDbType.Numeric  =&gt; &quot;numeric&quot;,
294              NpgsqlDbType.Money    =&gt; &quot;money&quot;,
295              NpgsqlDbType.Text      =&gt; &quot;text&quot;,
296              NpgsqlDbType.Xml       =&gt; &quot;xml&quot;,
297              NpgsqlDbType.Varchar   =&gt; &quot;character varying&quot;,
298              NpgsqlDbType.Char      =&gt; &quot;character&quot;,
299              NpgsqlDbType.Name      =&gt; &quot;name&quot;,
300              NpgsqlDbType.Refcursor =&gt; &quot;refcursor&quot;,
301              NpgsqlDbType.Citext    =&gt; &quot;citext&quot;,
302              NpgsqlDbType.Jsonb     =&gt; &quot;jsonb&quot;,
303              NpgsqlDbType.Json      =&gt; &quot;json&quot;,
304              NpgsqlDbType.JsonPath  =&gt; &quot;jsonpath&quot;,
305              NpgsqlDbType.Timestamp   =&gt; &quot;timestamp without time zone&quot;,
306              NpgsqlDbType.TimestampTz =&gt; &quot;timestamp with time zone&quot;,
307              NpgsqlDbType.Date        =&gt; &quot;date&quot;,
308              NpgsqlDbType.Time        =&gt; &quot;time without time zone&quot;,
309              NpgsqlDbType.TimeTz      =&gt; &quot;time with time zone&quot;,
310              NpgsqlDbType.Interval    =&gt; &quot;interval&quot;,
311              NpgsqlDbType.Cidr     =&gt; &quot;cidr&quot;,
312              NpgsqlDbType.Inet     =&gt; &quot;inet&quot;,
313              NpgsqlDbType.MacAddr  =&gt; &quot;macaddr&quot;,
314              NpgsqlDbType.MacAddr8 =&gt; &quot;macaddr8&quot;,
315              NpgsqlDbType.TsQuery   =&gt; &quot;tsquery&quot;,
316              NpgsqlDbType.TsVector  =&gt; &quot;tsvector&quot;,
317              NpgsqlDbType.Box     =&gt; &quot;box&quot;,
318              NpgsqlDbType.Circle  =&gt; &quot;circle&quot;,
319              NpgsqlDbType.Line    =&gt; &quot;line&quot;,
320              NpgsqlDbType.LSeg    =&gt; &quot;lseg&quot;,
321              NpgsqlDbType.Path    =&gt; &quot;path&quot;,
322              NpgsqlDbType.Point   =&gt; &quot;point&quot;,
323              NpgsqlDbType.Polygon =&gt; &quot;polygon&quot;,
324              NpgsqlDbType.LQuery    =&gt; &quot;lquery&quot;,
325              NpgsqlDbType.LTree     =&gt; &quot;ltree&quot;,
326              NpgsqlDbType.LTxtQuery =&gt; &quot;ltxtquery&quot;,
327              NpgsqlDbType.Oid       =&gt; &quot;oid&quot;,
328              NpgsqlDbType.Xid       =&gt; &quot;xid&quot;,
329              NpgsqlDbType.Xid8      =&gt; &quot;xid8&quot;,
330              NpgsqlDbType.Cid       =&gt; &quot;cid&quot;,
331              NpgsqlDbType.Regtype   =&gt; &quot;regtype&quot;,
332              NpgsqlDbType.Regconfig =&gt; &quot;regconfig&quot;,
333              NpgsqlDbType.Boolean =&gt; &quot;boolean&quot;,
334              NpgsqlDbType.Bytea   =&gt; &quot;bytea&quot;,
335              NpgsqlDbType.Uuid    =&gt; &quot;uuid&quot;,
336              NpgsqlDbType.Varbit  =&gt; &quot;bit varying&quot;,
337              NpgsqlDbType.Bit     =&gt; &quot;bit&quot;,
338              NpgsqlDbType.Hstore  =&gt; &quot;hstore&quot;,
339              NpgsqlDbType.Geometry  =&gt; &quot;geometry&quot;,
340              NpgsqlDbType.Geography =&gt; &quot;geography&quot;,
341              NpgsqlDbType.IntegerRange     =&gt; &quot;int4range&quot;,
342              NpgsqlDbType.BigIntRange      =&gt; &quot;int8range&quot;,
343              NpgsqlDbType.NumericRange     =&gt; &quot;numrange&quot;,
344              NpgsqlDbType.TimestampRange   =&gt; &quot;tsrange&quot;,
345              NpgsqlDbType.TimestampTzRange =&gt; &quot;tstzrange&quot;,
346              NpgsqlDbType.DateRange        =&gt; &quot;daterange&quot;,
347              NpgsqlDbType.IntegerMultirange     =&gt; &quot;int4multirange&quot;,
348              NpgsqlDbType.BigIntMultirange      =&gt; &quot;int8multirange&quot;,
349              NpgsqlDbType.NumericMultirange     =&gt; &quot;nummultirange&quot;,
350              NpgsqlDbType.TimestampMultirange   =&gt; &quot;tsmultirange&quot;,
351              NpgsqlDbType.TimestampTzMultirange =&gt; &quot;tstzmultirange&quot;,
352              NpgsqlDbType.DateMultirange        =&gt; &quot;datemultirange&quot;,
353              NpgsqlDbType.Int2Vector   =&gt; &quot;int2vector&quot;,
354              NpgsqlDbType.Oidvector    =&gt; &quot;oidvector&quot;,
355              NpgsqlDbType.PgLsn        =&gt; &quot;pg_lsn&quot;,
356              NpgsqlDbType.Tid          =&gt; &quot;tid&quot;,
357              NpgsqlDbType.InternalChar =&gt; &quot;char&quot;,
358              NpgsqlDbType.Unknown =&gt; &quot;unknown&quot;,
359              _ =&gt; npgsqlDbType.HasFlag(NpgsqlDbType.Array)
360                  ? NpgsqlDbTypeToDataTypeName(npgsqlDbType &amp; ~NpgsqlDbType.Array) + &quot;[]&quot;
361                  : null 
362          };
363      public static NpgsqlDbType DataTypeNameToNpgsqlDbType(string typeName)
364      {
365          var parenIndex = typeName.IndexOf(&#x27;(&#x27;);
366          if (parenIndex &gt; -1)
367              typeName = typeName.Substring(0, parenIndex);
368          return typeName switch
369          {
370              &quot;smallint&quot; =&gt; NpgsqlDbType.Smallint,
371              &quot;integer&quot; or &quot;int&quot; =&gt; NpgsqlDbType.Integer,
372              &quot;bigint&quot; =&gt; NpgsqlDbType.Bigint,
373              &quot;real&quot; =&gt; NpgsqlDbType.Real,
374              &quot;double precision&quot; =&gt; NpgsqlDbType.Double,
375              &quot;numeric&quot; =&gt; NpgsqlDbType.Numeric,
376              &quot;money&quot; =&gt; NpgsqlDbType.Money,
377              &quot;text&quot; =&gt; NpgsqlDbType.Text,
378              &quot;xml&quot; =&gt; NpgsqlDbType.Xml,
379              &quot;character varying&quot; or &quot;varchar&quot; =&gt; NpgsqlDbType.Varchar,
380              &quot;character&quot; =&gt; NpgsqlDbType.Char,
381              &quot;name&quot; =&gt; NpgsqlDbType.Name,
382              &quot;refcursor&quot; =&gt; NpgsqlDbType.Refcursor,
383              &quot;citext&quot; =&gt; NpgsqlDbType.Citext,
384              &quot;jsonb&quot; =&gt; NpgsqlDbType.Jsonb,
385              &quot;json&quot; =&gt; NpgsqlDbType.Json,
386              &quot;jsonpath&quot; =&gt; NpgsqlDbType.JsonPath,
387              &quot;timestamp without time zone&quot; or &quot;timestamp&quot; =&gt; NpgsqlDbType.Timestamp,
388              &quot;timestamp with time zone&quot; or &quot;timestamptz&quot; =&gt; NpgsqlDbType.TimestampTz,
389              &quot;date&quot; =&gt; NpgsqlDbType.Date,
390              &quot;time without time zone&quot; or &quot;timetz&quot; =&gt; NpgsqlDbType.Time,
391              &quot;time with time zone&quot; or &quot;time&quot; =&gt; NpgsqlDbType.TimeTz,
392              &quot;interval&quot; =&gt; NpgsqlDbType.Interval,
393              &quot;cidr&quot; =&gt; NpgsqlDbType.Cidr,
394              &quot;inet&quot; =&gt; NpgsqlDbType.Inet,
395              &quot;macaddr&quot; =&gt; NpgsqlDbType.MacAddr,
396              &quot;macaddr8&quot; =&gt; NpgsqlDbType.MacAddr8,
397              &quot;tsquery&quot; =&gt; NpgsqlDbType.TsQuery,
398              &quot;tsvector&quot; =&gt; NpgsqlDbType.TsVector,
399              &quot;box&quot; =&gt; NpgsqlDbType.Box,
400              &quot;circle&quot; =&gt; NpgsqlDbType.Circle,
401              &quot;line&quot; =&gt; NpgsqlDbType.Line,
402              &quot;lseg&quot; =&gt; NpgsqlDbType.LSeg,
403              &quot;path&quot; =&gt; NpgsqlDbType.Path,
404              &quot;point&quot; =&gt; NpgsqlDbType.Point,
405              &quot;polygon&quot; =&gt; NpgsqlDbType.Polygon,
406              &quot;lquery&quot; =&gt; NpgsqlDbType.LQuery,
407              &quot;ltree&quot; =&gt; NpgsqlDbType.LTree,
408              &quot;ltxtquery&quot; =&gt; NpgsqlDbType.LTxtQuery,
409              &quot;oid&quot; =&gt; NpgsqlDbType.Oid,
410              &quot;xid&quot; =&gt; NpgsqlDbType.Xid,
411              &quot;xid8&quot; =&gt; NpgsqlDbType.Xid8,
412              &quot;cid&quot; =&gt; NpgsqlDbType.Cid,
413              &quot;regtype&quot; =&gt; NpgsqlDbType.Regtype,
414              &quot;regconfig&quot; =&gt; NpgsqlDbType.Regconfig,
415              &quot;boolean&quot; or &quot;bool&quot; =&gt; NpgsqlDbType.Boolean,
416              &quot;bytea&quot; =&gt; NpgsqlDbType.Bytea,
417              &quot;uuid&quot; =&gt; NpgsqlDbType.Uuid,
418              &quot;bit varying&quot; or &quot;varbit&quot; =&gt; NpgsqlDbType.Varbit,
419              &quot;bit&quot; =&gt; NpgsqlDbType.Bit,
420              &quot;hstore&quot; =&gt; NpgsqlDbType.Hstore,
421              &quot;geometry&quot; =&gt; NpgsqlDbType.Geometry,
422              &quot;geography&quot; =&gt; NpgsqlDbType.Geography,
423              &quot;int4range&quot; =&gt; NpgsqlDbType.IntegerRange,
424              &quot;int8range&quot; =&gt; NpgsqlDbType.BigIntRange,
425              &quot;numrange&quot; =&gt; NpgsqlDbType.NumericRange,
426              &quot;tsrange&quot; =&gt; NpgsqlDbType.TimestampRange,
427              &quot;tstzrange&quot; =&gt; NpgsqlDbType.TimestampTzRange,
428              &quot;daterange&quot; =&gt; NpgsqlDbType.DateRange,
429              &quot;int4multirange&quot; =&gt; NpgsqlDbType.IntegerMultirange,
430              &quot;int8multirange&quot; =&gt; NpgsqlDbType.BigIntMultirange,
431              &quot;nummultirange&quot; =&gt; NpgsqlDbType.NumericMultirange,
432              &quot;tsmultirange&quot; =&gt; NpgsqlDbType.TimestampMultirange,
433              &quot;tstzmultirange&quot; =&gt; NpgsqlDbType.TimestampTzMultirange,
434              &quot;datemultirange&quot; =&gt; NpgsqlDbType.DateMultirange,
435              &quot;int2vector&quot; =&gt; NpgsqlDbType.Int2Vector,
436              &quot;oidvector&quot; =&gt; NpgsqlDbType.Oidvector,
437              &quot;pg_lsn&quot; =&gt; NpgsqlDbType.PgLsn,
438              &quot;tid&quot; =&gt; NpgsqlDbType.Tid,
439              &quot;char&quot; =&gt; NpgsqlDbType.InternalChar,
440              _ =&gt; typeName.EndsWith(&quot;[]&quot;, StringComparison.Ordinal) &amp;&amp;
441                   DataTypeNameToNpgsqlDbType(typeName.Substring(0, typeName.Length - 2)) is { } elementNpgsqlDbType &amp;&amp;
442                   elementNpgsqlDbType != NpgsqlDbType.Unknown
443                  ? elementNpgsqlDbType | NpgsqlDbType.Array
444                  : NpgsqlDbType.Unknown 
445          };
446      }
447      internal static NpgsqlDbType? DbTypeToNpgsqlDbType(DbType dbType)
448          =&gt; dbType switch
449          {
450              DbType.AnsiString            =&gt; NpgsqlDbType.Text,
451              DbType.Binary                =&gt; NpgsqlDbType.Bytea,
452              DbType.Byte                  =&gt; NpgsqlDbType.Smallint,
453              DbType.Boolean               =&gt; NpgsqlDbType.Boolean,
454              DbType.Currency              =&gt; NpgsqlDbType.Money,
455              DbType.Date                  =&gt; NpgsqlDbType.Date,
456              DbType.DateTime              =&gt; LegacyTimestampBehavior ? NpgsqlDbType.Timestamp : NpgsqlDbType.TimestampTz,
457              DbType.Decimal               =&gt; NpgsqlDbType.Numeric,
458              DbType.VarNumeric            =&gt; NpgsqlDbType.Numeric,
459              DbType.Double                =&gt; NpgsqlDbType.Double,
460              DbType.Guid                  =&gt; NpgsqlDbType.Uuid,
461              DbType.Int16                 =&gt; NpgsqlDbType.Smallint,
462              DbType.Int32                 =&gt; NpgsqlDbType.Integer,
463              DbType.Int64                 =&gt; NpgsqlDbType.Bigint,
464              DbType.Single                =&gt; NpgsqlDbType.Real,
465              DbType.String                =&gt; NpgsqlDbType.Text,
466              DbType.Time                  =&gt; NpgsqlDbType.Time,
467              DbType.AnsiStringFixedLength =&gt; NpgsqlDbType.Text,
468              DbType.StringFixedLength     =&gt; NpgsqlDbType.Text,
469              DbType.Xml                   =&gt; NpgsqlDbType.Xml,
470              DbType.DateTime2             =&gt; NpgsqlDbType.Timestamp,
471              DbType.DateTimeOffset        =&gt; NpgsqlDbType.TimestampTz,
472              DbType.Object                =&gt; null,
473              DbType.SByte                 =&gt; null,
474              DbType.UInt16                =&gt; null,
475              DbType.UInt32                =&gt; null,
476              DbType.UInt64                =&gt; null,
477              _ =&gt; throw new ArgumentOutOfRangeException(nameof(dbType), dbType, null)
478          };
479      internal static DbType NpgsqlDbTypeToDbType(NpgsqlDbType npgsqlDbType)
480          =&gt; npgsqlDbType switch
481          {
482              NpgsqlDbType.Smallint    =&gt; DbType.Int16,
483              NpgsqlDbType.Integer     =&gt; DbType.Int32,
484              NpgsqlDbType.Bigint      =&gt; DbType.Int64,
485              NpgsqlDbType.Real        =&gt; DbType.Single,
486              NpgsqlDbType.Double      =&gt; DbType.Double,
487              NpgsqlDbType.Numeric     =&gt; DbType.Decimal,
488              NpgsqlDbType.Money       =&gt; DbType.Currency,
489              NpgsqlDbType.Text        =&gt; DbType.String,
490              NpgsqlDbType.Xml         =&gt; DbType.Xml,
491              NpgsqlDbType.Varchar     =&gt; DbType.String,
492              NpgsqlDbType.Char        =&gt; DbType.String,
493              NpgsqlDbType.Name        =&gt; DbType.String,
494              NpgsqlDbType.Refcursor   =&gt; DbType.String,
495              NpgsqlDbType.Citext      =&gt; DbType.String,
496              NpgsqlDbType.Jsonb       =&gt; DbType.Object,
497              NpgsqlDbType.Json        =&gt; DbType.Object,
498              NpgsqlDbType.JsonPath    =&gt; DbType.String,
499              NpgsqlDbType.Timestamp   =&gt; LegacyTimestampBehavior ? DbType.DateTime : DbType.DateTime2,
500              NpgsqlDbType.TimestampTz =&gt; LegacyTimestampBehavior ? DbType.DateTimeOffset : DbType.DateTime,
501              NpgsqlDbType.Date        =&gt; DbType.Date,
502              NpgsqlDbType.Time        =&gt; DbType.Time,
503              NpgsqlDbType.Bytea       =&gt; DbType.Binary,
504              NpgsqlDbType.Boolean     =&gt; DbType.Boolean,
505              NpgsqlDbType.Uuid        =&gt; DbType.Guid,
506              NpgsqlDbType.Unknown     =&gt; DbType.Object,
507              _ =&gt; DbType.Object
508          };
509      #endregion Static translation tables
510  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TypeMapper.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</div>
                </div>
                <div class="column column_space"><pre><code>410      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
411          =&gt; clrType.GetCustomAttribute&lt;PgNameAttribute&gt;()?.PgName
412             ?? nameTranslator.TranslateTypeName(clrType.Name);
413  }
</pre></code></div>
                <div class="column column_space"><pre><code>205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          =&gt; clrType.GetCustomAttribute&lt;PgNameAttribute&gt;()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    