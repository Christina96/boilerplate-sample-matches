
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 224, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-com.chronoxor.fbe.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Linq;
7  using System.Numerics;
8  using System.Runtime.Serialization;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  namespace com.chronoxor.FBE {
13      public static class UuidGenerator
14      {
15          private static readonly DateTime GregorianEpoch = new DateTime(1582, 10, 15, 0, 0, 0, DateTimeKind.Utc);
16          private static readonly object Lock = new object();
17          private static readonly Random Generator = new Random();
18          private static readonly byte[] NodeBytes;
19          private static readonly byte[] ClockSequenceBytes;
20          private static DateTime _last = DateTime.UtcNow;
21          static UuidGenerator()
22          {
23              NodeBytes = new byte[6];
24              Generator.NextBytes(NodeBytes);
25              ClockSequenceBytes = new byte[2];
26              Generator.NextBytes(ClockSequenceBytes);
27          }
28          public static Guid Nil() { return new Guid(); }
29          public static Guid Sequential()
30          {
31              var now = DateTime.UtcNow;
32              lock (Lock)
33              {
34                  if (now <= _last)
35                      Generator.NextBytes(ClockSequenceBytes);
36                  _last = now;
37              }
38              long ticks = (now - GregorianEpoch).Ticks;
39              Span<byte> guid = stackalloc byte[16];
40              byte[] timestamp = BitConverter.GetBytes(ticks);
41              for (int i = 0; i < Math.Min(6, NodeBytes.Length); i++)
42                  guid[10 + i] = NodeBytes[i];
43              for (int i = 0; i < Math.Min(2, ClockSequenceBytes.Length); i++)
44                  guid[8 + i] = ClockSequenceBytes[i];
45              for (int i = 0; i < Math.Min(8, timestamp.Length); i++)
46                  guid[i] = timestamp[i];
47              guid[8] &= 0x3F;
48              guid[8] |= 0x80;
49              guid[7] &= 0x0F;
50              guid[7] |= 0x10;
51              return new Guid(guid);
52          }
53          public static Guid Random() { return Guid.NewGuid(); }
54      }
55      public class Buffer
56      {
57          private byte[] _data;
58          private long _size;
59          private long _offset;
60          public bool IsEmpty => (_data == null) || (_size == 0);
61          public byte[] Data => _data;
62          public long Capacity => _data.Length;
63          public long Size => _size;
64          public long Offset => _offset;
65          public Buffer() { Attach(); }
66          public Buffer(long capacity) { Attach(capacity); }
67          public Buffer(byte[] buffer) { Attach(buffer); }
68          public Buffer(byte[] buffer, long offset) { Attach(buffer, offset); }
69          public Buffer(byte[] buffer, long size, long offset) { Attach(buffer, size, offset); }
70          #region Attach memory buffer methods
71          public void Attach() { _data = new byte[0]; _size = 0; _offset = 0; }
72          public void Attach(long capacity) { _data = new byte[capacity]; _size = 0; _offset = 0; }
73          public void Attach(byte[] buffer) { _data = buffer; _size = buffer.Length; _offset = 0; }
74          public void Attach(byte[] buffer, long offset) { _data = buffer; _size = buffer.Length; _offset = offset; }
75          public void Attach(byte[] buffer, long size, long offset) { _data = buffer; _size = size; _offset = offset; }
76          #endregion
77          #region Memory buffer methods
78          public long Allocate(long size)
79          {
80              Debug.Assert((size >= 0), "Invalid allocation size!");
81              if (size < 0)
82                  throw new ArgumentException("Invalid allocation size!", nameof(size));
83              long offset = Size;
84              long total = _size + size;
85              if (total <= Capacity)
86              {
87                  _size = total;
88                  return offset;
89              }
90              byte[] data = new byte[Math.Max(total, 2 * Capacity)];
91              Array.Copy(_data, 0, data, 0, _size);
92              _data = data;
93              _size = total;
94              return offset;
95          }
96          public void Remove(long offset, long size)
97          {
98              Debug.Assert(((offset + size) <= Size), "Invalid offset & size!");
99              if ((offset + size) > Size)
100                  throw new ArgumentException("Invalid offset & size!", nameof(offset));
101              Array.Copy(_data, offset + size, _data, offset, _size - size - offset);
102              _size -= size;
103              if (_offset >= (offset + size))
104                  _offset -= size;
105              else if (_offset >= offset)
106              {
107                  _offset -= _offset - offset;
108                  if (_offset > Size)
109                      _offset = Size;
110              }
111          }
112          public void Reserve(long capacity)
113          {
114              Debug.Assert((capacity >= 0), "Invalid reserve capacity!");
115              if (capacity < 0)
116                  throw new ArgumentException("Invalid reserve capacity!", nameof(capacity));
117              if (capacity > Capacity)
118              {
119                  byte[] data = new byte[Math.Max(capacity, 2 * Capacity)];
120                  Array.Copy(_data, 0, data, 0, _size);
121                  _data = data;
122              }
123          }
124          public void Resize(long size)
125          {
126              Reserve(size);
127              _size = size;
128              if (_offset > _size)
129                  _offset = _size;
130          }
131          public void Reset()
132          {
133              _size = 0;
134              _offset = 0;
135          }
136          public void Shift(long offset) { _offset += offset; }
137          public void Unshift(long offset) { _offset -= offset; }
138          #endregion
139          #region Buffer I/O methods
140          public static bool ReadBool(byte[] buffer, long offset)
141          {
142              return buffer[offset] != 0;
143          }
144          public static byte ReadByte(byte[] buffer, long offset)
145          {
146              return buffer[offset];
147          }
148          public static char ReadChar(byte[] buffer, long offset)
149          {
150              return (char)ReadUInt8(buffer, offset);
151          }
152          public static char ReadWChar(byte[] buffer, long offset)
153          {
154              return (char)ReadUInt32(buffer, offset);
155          }
156          public static sbyte ReadInt8(byte[] buffer, long offset)
157          {
158              return (sbyte)buffer[offset];
159          }
160          public static byte ReadUInt8(byte[] buffer, long offset)
161          {
162              return buffer[offset];
163          }
164          public static short ReadInt16(byte[] buffer, long offset)
165          {
166              return (short)(buffer[offset + 0] | (buffer[offset + 1] << 8));
167          }
168          public static ushort ReadUInt16(byte[] buffer, long offset)
169          {
170              return (ushort)(buffer[offset + 0] | (buffer[offset + 1] << 8));
171          }
172          public static int ReadInt32(byte[] buffer, long offset)
173          {
174              return (buffer[offset + 0] <<  0)|
175                     (buffer[offset + 1] <<  8)|
176                     (buffer[offset + 2] << 16)|
177                     (buffer[offset + 3] << 24);
178          }
179          public static uint ReadUInt32(byte[] buffer, long offset)
180          {
181              return ((uint)buffer[offset + 0] <<  0)|
182                     ((uint)buffer[offset + 1] <<  8)|
183                     ((uint)buffer[offset + 2] << 16)|
184                     ((uint)buffer[offset + 3] << 24);
185          }
186          public static long ReadInt64(byte[] buffer, long offset)
187          {
188              return ((long)buffer[offset + 0] <<  0)|
189                     ((long)buffer[offset + 1] <<  8)|
190                     ((long)buffer[offset + 2] << 16)|
191                     ((long)buffer[offset + 3] << 24)|
192                     ((long)buffer[offset + 4] << 32)|
193                     ((long)buffer[offset + 5] << 40)|
194                     ((long)buffer[offset + 6] << 48)|
195                     ((long)buffer[offset + 7] << 56);
196          }
197          public static ulong ReadUInt64(byte[] buffer, long offset)
198          {
199              return ((ulong)buffer[offset + 0] <<  0)|
200                     ((ulong)buffer[offset + 1] <<  8)|
201                     ((ulong)buffer[offset + 2] << 16)|
202                     ((ulong)buffer[offset + 3] << 24)|
203                     ((ulong)buffer[offset + 4] << 32)|
204                     ((ulong)buffer[offset + 5] << 40)|
205                     ((ulong)buffer[offset + 6] << 48)|
206                     ((ulong)buffer[offset + 7] << 56);
207          }
208          public static ulong ReadUInt64Guid(byte[] buffer, long offset)
209          {
210              return ((ulong)buffer[offset + 0] << 24)|
211                     ((ulong)buffer[offset + 1] << 16)|
212                     ((ulong)buffer[offset + 2] <<  8)|
213                     ((ulong)buffer[offset + 3] <<  0)|
214                     ((ulong)buffer[offset + 4] << 40)|
215                     ((ulong)buffer[offset + 5] << 32)|
216                     ((ulong)buffer[offset + 6] << 56)|
217                     ((ulong)buffer[offset + 7] << 48);
218          }
219          public static float ReadFloat(byte[] buffer, long offset)
220          {
221              var bits = default(FloatUnion);
222              bits.UIntData = ReadUInt32(buffer, offset);
223              return bits.FloatData;
224          }
225          public static double ReadDouble(byte[] buffer, long offset)
226          {
227              var bits = default(DoubleUnion);
228              bits.ULongData = ReadUInt64(buffer, offset);
229              return bits.DoubleData;
230          }
231          public static decimal ReadDecimal(byte[] buffer, long offset)
232          {
233              var bits = default(DecimalUnion);
234              bits.UIntLow = ReadUInt32(buffer, offset);
235              bits.UIntMid = ReadUInt32(buffer, offset + 4);
236              bits.UIntHigh = ReadUInt32(buffer, offset + 8);
237              bits.UIntFlags = ReadUInt32(buffer, offset + 12);
238              return bits.DecimalData;
239          }
240          public static byte[] ReadBytes(byte[] buffer, long offset, long size)
241          {
242              byte[] result = new byte[size];
243              Array.Copy(buffer, offset, result, 0, (int)size);
244              return result;
245          }
246          public static string ReadString(byte[] buffer, long offset, long size)
247          {
248              return Encoding.UTF8.GetString(buffer, (int)offset, (int)size);
249          }
250          public static Guid ReadUUID(byte[] buffer, long offset)
251          {
252              var bits = default(GuidUnion);
253              bits.ULongHigh = ReadUInt64Guid(buffer, offset);
254              bits.ULongLow = ReadUInt64(buffer, offset + 8);
255              return bits.GuidData;
256          }
257          public static void Write(byte[] buffer, long offset, bool value)
258          {
259              buffer[offset] = (byte)(value ? 1 : 0);
260          }
261          public static void Write(byte[] buffer, long offset, sbyte value)
262          {
263              buffer[offset] = (byte)value;
264          }
265          public static void Write(byte[] buffer, long offset, byte value)
266          {
267              buffer[offset] = value;
268          }
269          public static void Write(byte[] buffer, long offset, short value)
270          {
271              buffer[offset + 0] = (byte)(value >>  0);
272              buffer[offset + 1] = (byte)(value >>  8);
273          }
274          public static void Write(byte[] buffer, long offset, ushort value)
275          {
276              buffer[offset + 0] = (byte)(value >>  0);
277              buffer[offset + 1] = (byte)(value >>  8);
278          }
279          public static void Write(byte[] buffer, long offset, int value)
280          {
281              buffer[offset + 0] = (byte)(value >>  0);
282              buffer[offset + 1] = (byte)(value >>  8);
283              buffer[offset + 2] = (byte)(value >> 16);
284              buffer[offset + 3] = (byte)(value >> 24);
285          }
286          public static void Write(byte[] buffer, long offset, uint value)
287          {
288              buffer[offset + 0] = (byte)(value >>  0);
289              buffer[offset + 1] = (byte)(value >>  8);
290              buffer[offset + 2] = (byte)(value >> 16);
291              buffer[offset + 3] = (byte)(value >> 24);
292          }
293          public static void Write(byte[] buffer, long offset, long value)
294          {
295              buffer[offset + 0] = (byte)(value >>  0);
296              buffer[offset + 1] = (byte)(value >>  8);
297              buffer[offset + 2] = (byte)(value >> 16);
298              buffer[offset + 3] = (byte)(value >> 24);
299              buffer[offset + 4] = (byte)(value >> 32);
300              buffer[offset + 5] = (byte)(value >> 40);
301              buffer[offset + 6] = (byte)(value >> 48);
302              buffer[offset + 7] = (byte)(value >> 56);
303          }
304          public static void Write(byte[] buffer, long offset, ulong value)
305          {
306              buffer[offset + 0] = (byte)(value >>  0);
307              buffer[offset + 1] = (byte)(value >>  8);
308              buffer[offset + 2] = (byte)(value >> 16);
309              buffer[offset + 3] = (byte)(value >> 24);
310              buffer[offset + 4] = (byte)(value >> 32);
311              buffer[offset + 5] = (byte)(value >> 40);
312              buffer[offset + 6] = (byte)(value >> 48);
313              buffer[offset + 7] = (byte)(value >> 56);
314          }
315          public static void WriteGuid(byte[] buffer, long offset, ulong value)
316          {
317              buffer[offset + 0] = (byte)(value >> 24);
318              buffer[offset + 1] = (byte)(value >> 16);
319              buffer[offset + 2] = (byte)(value >>  8);
320              buffer[offset + 3] = (byte)(value >>  0);
321              buffer[offset + 4] = (byte)(value >> 40);
322              buffer[offset + 5] = (byte)(value >> 32);
323              buffer[offset + 6] = (byte)(value >> 56);
324              buffer[offset + 7] = (byte)(value >> 48);
325          }
326          public static void Write(byte[] buffer, long offset, float value)
327          {
328              var bits = default(FloatUnion);
329              bits.FloatData = value;
330              Write(buffer, offset, bits.UIntData);
331          }
332          public static void Write(byte[] buffer, long offset, double value)
333          {
334              var bits = default(DoubleUnion);
335              bits.DoubleData = value;
336              Write(buffer, offset, bits.ULongData);
337          }
338          public static void Write(byte[] buffer, long offset, decimal value)
339          {
340              var bits = default(DecimalUnion);
341              bits.DecimalData = value;
342              Write(buffer, offset, bits.UIntLow);
343              Write(buffer, offset + 4, bits.UIntMid);
344              Write(buffer, offset + 8, bits.UIntHigh);
345              Write(buffer, offset + 12, bits.UIntFlags);
346          }
347          public static void Write(byte[] buffer, long offset, byte[] value)
348          {
349              Array.Copy(value, 0, buffer, offset, value.Length);
350          }
351          public static void Write(byte[] buffer, long offset, byte[] value, long valueOffset, long valueSize)
352          {
353              Array.Copy(value, valueOffset, buffer, offset, valueSize);
354          }
355          public static void Write(byte[] buffer, long offset, byte value, long valueCount)
356          {
357              for (long i = 0; i < valueCount; i++)
358                  buffer[offset + i] = value;
359          }
360          public static long Write(byte[] buffer, long offset, string value)
361          {
362              return Encoding.UTF8.GetBytes(value, 0, value.Length, buffer, (int)offset);
363          }
364          public static void Write(byte[] buffer, long offset, Guid value)
365          {
366              var bits = default(GuidUnion);
367              bits.GuidData = value;
368              WriteGuid(buffer, offset, bits.ULongHigh);
369              Write(buffer, offset + 8, bits.ULongLow);
370          }
371          #endregion
372          #region Utilities
373          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
374          private struct FloatUnion
375          {
376              [System.Runtime.InteropServices.FieldOffset(0)]
377              public uint UIntData;
378              [System.Runtime.InteropServices.FieldOffset(0)]
379              public float FloatData;
380          }
381          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
382          private struct DoubleUnion
383          {
384              [System.Runtime.InteropServices.FieldOffset(0)]
385              public ulong ULongData;
386              [System.Runtime.InteropServices.FieldOffset(0)]
387              public double DoubleData;
388          }
389          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
390          private struct DecimalUnion
391          {
392              [System.Runtime.InteropServices.FieldOffset(0)]
393              public uint UIntFlags;
394              [System.Runtime.InteropServices.FieldOffset(4)]
395              public uint UIntHigh;
396              [System.Runtime.InteropServices.FieldOffset(8)]
397              public uint UIntLow;
398              [System.Runtime.InteropServices.FieldOffset(12)]
399              public uint UIntMid;
400              [System.Runtime.InteropServices.FieldOffset(0)]
401              public decimal DecimalData;
402          }
403          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
404          private struct GuidUnion
405          {
406              [System.Runtime.InteropServices.FieldOffset(0)]
407              public ulong ULongHigh;
408              [System.Runtime.InteropServices.FieldOffset(8)]
409              public ulong ULongLow;
410              [System.Runtime.InteropServices.FieldOffset(0)]
411              public Guid GuidData;
412          }
413          #endregion
414      }
415      public class Model
416      {
417          public Buffer Buffer { get; }
418          protected Model() { Buffer = new Buffer(); }
419          protected Model(Buffer buffer) { Buffer = buffer; }
420          #region Attach memory buffer methods
421          public void Attach() { Buffer.Attach(); }
422          public void Attach(long capacity) { Buffer.Attach(capacity); }
423          public void Attach(byte[] buffer) { Buffer.Attach(buffer); }
424          public void Attach(byte[] buffer, long offset) { Buffer.Attach(buffer, offset); }
425          public void Attach(byte[] buffer, long size, long offset) { Buffer.Attach(buffer, size, offset); }
426          public void Attach(Buffer buffer) { Buffer.Attach(buffer.Data, buffer.Size, buffer.Offset); }
427          public void Attach(Buffer buffer, long offset) { Buffer.Attach(buffer.Data, buffer.Size, offset); }
428          #endregion
429          #region Memory buffer methods
430          public long Allocate(long size) { return Buffer.Allocate(size); }
431          public void Remove(long offset, long size) { Buffer.Remove(offset, size); }
432          public void Reserve(long capacity) { Buffer.Reserve(capacity); }
433          public void Resize(long size) { Buffer.Resize(size); }
434          public void Reset() { Buffer.Reset(); }
435          public void Shift(long offset) { Buffer.Shift(offset); }
436          public void Unshift(long offset) { Buffer.Unshift(offset); }
437          #endregion
438          #region Buffer I/O methods
439          protected uint ReadUInt32(long offset) { return Buffer.ReadUInt32(Buffer.Data, Buffer.Offset + offset); }
440          protected void Write(long offset, uint value) { Buffer.Write(Buffer.Data, Buffer.Offset + offset, value); }
441          #endregion
442      }
443      public enum BaseTypes
444      {
445          BOOL,
446          BYTE,
447          BYTES,
448          CHAR,
449          WCHAR,
450          INT8,
451          UINT8,
452          INT16,
453          UINT16,
454          INT32,
455          UINT32,
456          INT64,
457          UINT64,
458          FLOAT,
459          DOUBLE,
460          DECIMAL,
461          UUID,
462          STRING,
463          TIMESTAMP
464      }
465      public abstract class FieldModelBase
466      {
467          protected Buffer _buffer;
468          protected long _offset;
469          protected FieldModelBase(Buffer buffer, long offset)
470          {
471              _buffer = buffer;
472              _offset = offset;
473          }
474          public long FBEOffset { get => _offset; set => _offset = value; }
475          public virtual long FBESize => 0;
476          public virtual long FBEExtra => 0;
477          public void FBEShift(long size) { _offset += size; }
478          public void FBEUnshift(long size) { _offset -= size; }
479          #region Buffer I/O methods
480          protected bool ReadBool(long offset) { return Buffer.ReadBool(_buffer.Data, _buffer.Offset + offset); }
481          protected byte ReadByte(long offset) { return Buffer.ReadByte(_buffer.Data, _buffer.Offset + offset); }
482          protected char ReadChar(long offset) { return Buffer.ReadChar(_buffer.Data, _buffer.Offset + offset); }
483          protected char ReadWChar(long offset) { return Buffer.ReadWChar(_buffer.Data, _buffer.Offset + offset); }
484          protected sbyte ReadInt8(long offset) { return Buffer.ReadInt8(_buffer.Data, _buffer.Offset + offset); }
485          protected byte ReadUInt8(long offset) { return Buffer.ReadUInt8(_buffer.Data, _buffer.Offset + offset); }
486          protected short ReadInt16(long offset) { return Buffer.ReadInt16(_buffer.Data, _buffer.Offset + offset); }
487          protected ushort ReadUInt16(long offset) { return Buffer.ReadUInt16(_buffer.Data, _buffer.Offset + offset); }
488          protected int ReadInt32(long offset) { return Buffer.ReadInt32(_buffer.Data, _buffer.Offset + offset); }
489          protected uint ReadUInt32(long offset) { return Buffer.ReadUInt32(_buffer.Data, _buffer.Offset + offset); }
490          protected long ReadInt64(long offset) { return Buffer.ReadInt64(_buffer.Data, _buffer.Offset + offset); }
491          protected ulong ReadUInt64(long offset) { return Buffer.ReadUInt64(_buffer.Data, _buffer.Offset + offset); }
492          protected float ReadFloat(long offset) { return Buffer.ReadFloat(_buffer.Data, _buffer.Offset + offset); }
493          protected double ReadDouble(long offset) { return Buffer.ReadDouble(_buffer.Data, _buffer.Offset + offset); }
494          protected decimal ReadDecimal(long offset) { return Buffer.ReadDecimal(_buffer.Data, _buffer.Offset + offset); }
495          protected byte[] ReadBytes(long offset, long size) { return Buffer.ReadBytes(_buffer.Data, _buffer.Offset + offset, size); }
496          protected string ReadString(long offset, long size) { return Buffer.ReadString(_buffer.Data, _buffer.Offset + offset, size); }
497          protected Guid ReadUUID(long offset) { return Buffer.ReadUUID(_buffer.Data, _buffer.Offset + offset); }
498          protected void Write(long offset, bool value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
499          protected void Write(long offset, sbyte value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
500          protected void Write(long offset, byte value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
501          protected void Write(long offset, short value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
502          protected void Write(long offset, ushort value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
503          protected void Write(long offset, int value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
504          protected void Write(long offset, uint value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
505          protected void Write(long offset, long value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
506          protected void Write(long offset, ulong value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
507          protected void Write(long offset, float value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
508          protected void Write(long offset, double value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
509          protected void Write(long offset, decimal value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
510          protected void Write(long offset, byte[] value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
511          protected void Write(long offset, byte[] value, long valueOffset, long valueSize) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value, valueOffset, valueSize); }
512          protected void Write(long offset, byte value, long valueCount) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value, valueCount); }
513          protected long Write(long offset, string value) { return Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
514          protected void Write(long offset, Guid value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
515          #endregion
516      }
517      public abstract class FieldModelValueType<T> : FieldModelBase
518          where T : struct
519      {
520          protected FieldModelValueType(Buffer buffer, long offset) : base(buffer, offset) {}
521          public abstract FieldModelValueType<T> Clone();
522          public virtual bool Verify() { return true; }
523          public abstract void Get(out T value);
524          public abstract void Get(out T value, T defaults);
525          public abstract void Set(T value);
526          public static FieldModelValueType<T> CreateFieldModel(BaseTypes type, Buffer buffer, long offset)
527          {
528              switch (type)
529              {
530                  case BaseTypes.BOOL:
531                      return new FieldModelBool(buffer, offset) as FieldModelValueType<T>;
532                  case BaseTypes.BYTE:
533                      return new FieldModelByte(buffer, offset) as FieldModelValueType<T>;
534                  case BaseTypes.CHAR:
535                      return new FieldModelChar(buffer, offset) as FieldModelValueType<T>;
536                  case BaseTypes.WCHAR:
537                      return new FieldModelWChar(buffer, offset) as FieldModelValueType<T>;
538                  case BaseTypes.INT8:
539                      return new FieldModelInt8(buffer, offset) as FieldModelValueType<T>;
540                  case BaseTypes.UINT8:
541                      return new FieldModelUInt8(buffer, offset) as FieldModelValueType<T>;
542                  case BaseTypes.INT16:
543                      return new FieldModelInt16(buffer, offset) as FieldModelValueType<T>;
544                  case BaseTypes.UINT16:
545                      return new FieldModelUInt16(buffer, offset) as FieldModelValueType<T>;
546                  case BaseTypes.INT32:
547                      return new FieldModelInt32(buffer, offset) as FieldModelValueType<T>;
548                  case BaseTypes.UINT32:
549                      return new FieldModelUInt32(buffer, offset) as FieldModelValueType<T>;
550                  case BaseTypes.INT64:
551                      return new FieldModelInt64(buffer, offset) as FieldModelValueType<T>;
552                  case BaseTypes.UINT64:
553                      return new FieldModelUInt64(buffer, offset) as FieldModelValueType<T>;
554                  case BaseTypes.FLOAT:
555                      return new FieldModelFloat(buffer, offset) as FieldModelValueType<T>;
556                  case BaseTypes.DOUBLE:
557                      return new FieldModelDouble(buffer, offset) as FieldModelValueType<T>;
558                  case BaseTypes.DECIMAL:
559                      return new FieldModelDecimal(buffer, offset) as FieldModelValueType<T>;
560                  case BaseTypes.UUID:
561                      return new FieldModelUUID(buffer, offset) as FieldModelValueType<T>;
562                  case BaseTypes.TIMESTAMP:
563                      return new FieldModelTimestamp(buffer, offset) as FieldModelValueType<T>;
564                  default:
565                      Debug.Assert(false, "Unknown type!");
566                      return null;
567              }
568          }
569      }
570      public abstract class FieldModelReferenceType<T> : FieldModelBase
571          where T : class
572      {
573          protected FieldModelReferenceType(Buffer buffer, long offset) : base(buffer, offset) {}
574          public abstract FieldModelReferenceType<T> Clone();
575          public virtual bool Verify() { return true; }
576          public abstract void Get(out T value);
577          public abstract void Get(out T value, T defaults);
578          public abstract void Set(T value);
579          public static FieldModelReferenceType<T> CreateFieldModel(BaseTypes type, Buffer buffer, long offset)
580          {
581              switch (type)
582              {
583                  case BaseTypes.BYTES:
584                      return new FieldModelBytes(buffer, offset) as FieldModelReferenceType<T>;
585                  case BaseTypes.STRING:
586                      return new FieldModelString(buffer, offset) as FieldModelReferenceType<T>;
587                  default:
588                      Debug.Assert(false, "Unknown type!");
589                      return null;
590              }
591          }
592      }
593      public class FieldModelBool : FieldModelValueType<bool>
594      {
595          public FieldModelBool(Buffer buffer, long offset) : base(buffer, offset) {}
596          public override long FBESize => 1;
597          public override FieldModelValueType<bool> Clone() { return new FieldModelBool(_buffer, _offset); }
598          public override void Get(out bool value) { Get(out value, false); }
599          public override void Get(out bool value, bool defaults)
600          {
601              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
602              {
603                  value = defaults;
604                  return;
605              }
606              value = ReadBool(FBEOffset);
607          }
608          public override void Set(bool value)
609          {
610              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
611              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
612                  return;
613              Write(FBEOffset, value);
614          }
615      }
616      public class FieldModelByte : FieldModelValueType<byte>
617      {
618          public FieldModelByte(Buffer buffer, long offset) : base(buffer, offset) {}
619          public override long FBESize => 1;
620          public override FieldModelValueType<byte> Clone() { return new FieldModelByte(_buffer, _offset); }
621          public override void Get(out byte value) { Get(out value, (byte)0); }
622          public override void Get(out byte value, byte defaults)
623          {
624              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
625              {
626                  value = defaults;
627                  return;
628              }
629              value = ReadByte(FBEOffset);
630          }
631          public override void Set(byte value)
632          {
633              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
634              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
635                  return;
636              Write(FBEOffset, value);
637          }
638      }
639      public class FieldModelChar : FieldModelValueType<char>
640      {
641          public FieldModelChar(Buffer buffer, long offset) : base(buffer, offset) {}
642          public override long FBESize => 1;
643          public override FieldModelValueType<char> Clone() { return new FieldModelChar(_buffer, _offset); }
644          public override void Get(out char value) { Get(out value, '\0'); }
645          public override void Get(out char value, char defaults)
646          {
647              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
648              {
649                  value = defaults;
650                  return;
651              }
652              value = ReadChar(FBEOffset);
653          }
654          public override void Set(char value)
655          {
656              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
657              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
658                  return;
659              Write(FBEOffset, (byte)value);
660          }
661      }
662      public class FieldModelWChar : FieldModelValueType<char>
663      {
664          public FieldModelWChar(Buffer buffer, long offset) : base(buffer, offset) {}
665          public override long FBESize => 4;
666          public override FieldModelValueType<char> Clone() { return new FieldModelWChar(_buffer, _offset); }
667          public override void Get(out char value) { Get(out value, '\0'); }
668          public override void Get(out char value, char defaults)
669          {
670              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
671              {
672                  value = defaults;
673                  return;
674              }
675              value = ReadWChar(FBEOffset);
676          }
677          public override void Set(char value)
678          {
679              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
680              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
681                  return;
682              Write(FBEOffset, (uint)value);
683          }
684      }
685      public class FieldModelInt8 : FieldModelValueType<sbyte>
686      {
687          public FieldModelInt8(Buffer buffer, long offset) : base(buffer, offset) {}
688          public override long FBESize => 1;
689          public override FieldModelValueType<sbyte> Clone() { return new FieldModelInt8(_buffer, _offset); }
690          public override void Get(out sbyte value) { Get(out value, 0); }
691          public override void Get(out sbyte value, sbyte defaults)
692          {
693              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
694              {
695                  value = defaults;
696                  return;
697              }
698              value = ReadInt8(FBEOffset);
699          }
700          public override void Set(sbyte value)
701          {
702              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
703              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
704                  return;
705              Write(FBEOffset, value);
706          }
707      }
708      public class FieldModelUInt8 : FieldModelValueType<byte>
709      {
710          public FieldModelUInt8(Buffer buffer, long offset) : base(buffer, offset) {}
711          public override long FBESize => 1;
712          public override FieldModelValueType<byte> Clone() { return new FieldModelUInt8(_buffer, _offset); }
713          public override void Get(out byte value) { Get(out value, (byte)0); }
714          public override void Get(out byte value, byte defaults)
715          {
716              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
717              {
718                  value = defaults;
719                  return;
720              }
721              value = ReadUInt8(FBEOffset);
722          }
723          public override void Set(byte value)
724          {
725              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
726              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
727                  return;
728              Write(FBEOffset, value);
729          }
730      }
731      public class FieldModelInt16 : FieldModelValueType<short>
732      {
733          public FieldModelInt16(Buffer buffer, long offset) : base(buffer, offset) {}
734          public override long FBESize => 2;
735          public override FieldModelValueType<short> Clone() { return new FieldModelInt16(_buffer, _offset); }
736          public override void Get(out short value) { Get(out value, 0); }
737          public override void Get(out short value, short defaults)
738          {
739              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
740              {
741                  value = defaults;
742                  return;
743              }
744              value = ReadInt16(FBEOffset);
745          }
746          public override void Set(short value)
747          {
748              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
749              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
750                  return;
751              Write(FBEOffset, value);
752          }
753      }
754      public class FieldModelUInt16 : FieldModelValueType<ushort>
755      {
756          public FieldModelUInt16(Buffer buffer, long offset) : base(buffer, offset) {}
757          public override long FBESize => 2;
758          public override FieldModelValueType<ushort> Clone() { return new FieldModelUInt16(_buffer, _offset); }
759          public override void Get(out ushort value) { Get(out value, (ushort)0); }
760          public override void Get(out ushort value, ushort defaults)
761          {
762              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
763              {
764                  value = defaults;
765                  return;
766              }
767              value = ReadUInt16(FBEOffset);
768          }
769          public override void Set(ushort value)
770          {
771              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
772              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
773                  return;
774              Write(FBEOffset, value);
775          }
776      }
777      public class FieldModelInt32 : FieldModelValueType<int>
778      {
779          public FieldModelInt32(Buffer buffer, long offset) : base(buffer, offset) {}
780          public override long FBESize => 4;
781          public override FieldModelValueType<int> Clone() { return new FieldModelInt32(_buffer, _offset); }
782          public override void Get(out int value) { Get(out value, 0); }
783          public override void Get(out int value, int defaults)
784          {
785              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
786              {
787                  value = defaults;
788                  return;
789              }
790              value = ReadInt32(FBEOffset);
791          }
792          public override void Set(int value)
793          {
794              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
795              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
796                  return;
797              Write(FBEOffset, value);
798          }
799      }
800      public class FieldModelUInt32 : FieldModelValueType<uint>
801      {
802          public FieldModelUInt32(Buffer buffer, long offset) : base(buffer, offset) {}
803          public override long FBESize => 4;
804          public override FieldModelValueType<uint> Clone() { return new FieldModelUInt32(_buffer, _offset); }
805          public override void Get(out uint value) { Get(out value, 0U); }
806          public override void Get(out uint value, uint defaults)
807          {
808              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
809              {
810                  value = defaults;
811                  return;
812              }
813              value = ReadUInt32(FBEOffset);
814          }
815          public override void Set(uint value)
816          {
817              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
818              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
819                  return;
820              Write(FBEOffset, value);
821          }
822      }
823      public class FieldModelInt64 : FieldModelValueType<long>
824      {
825          public FieldModelInt64(Buffer buffer, long offset) : base(buffer, offset) {}
826          public override long FBESize => 8;
827          public override FieldModelValueType<long> Clone() { return new FieldModelInt64(_buffer, _offset); }
828          public override void Get(out long value) { Get(out value, 0L); }
829          public override void Get(out long value, long defaults)
830          {
831              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
832              {
833                  value = defaults;
834                  return;
835              }
836              value = ReadInt64(FBEOffset);
837          }
838          public override void Set(long value)
839          {
840              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
841              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
842                  return;
843              Write(FBEOffset, value);
844          }
845      }
846      public class FieldModelUInt64 : FieldModelValueType<ulong>
847      {
848          public FieldModelUInt64(Buffer buffer, long offset) : base(buffer, offset) {}
849          public override long FBESize => 8;
850          public override FieldModelValueType<ulong> Clone() { return new FieldModelUInt64(_buffer, _offset); }
851          public override void Get(out ulong value) { Get(out value, 0UL); }
852          public override void Get(out ulong value, ulong defaults)
853          {
854              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
855              {
856                  value = defaults;
857                  return;
858              }
859              value = ReadUInt64(FBEOffset);
860          }
861          public override void Set(ulong value)
862          {
863              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
864              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
865                  return;
866              Write(FBEOffset, value);
867          }
868      }
869      public class FieldModelFloat : FieldModelValueType<float>
870      {
871          public FieldModelFloat(Buffer buffer, long offset) : base(buffer, offset) {}
872          public override long FBESize => 4;
873          public override FieldModelValueType<float> Clone() { return new FieldModelFloat(_buffer, _offset); }
874          public override void Get(out float value) { Get(out value, 0.0F); }
875          public override void Get(out float value, float defaults)
876          {
877              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
878              {
879                  value = defaults;
880                  return;
881              }
882              value = ReadFloat(FBEOffset);
883          }
884          public override void Set(float value)
885          {
886              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
887              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
888                  return;
889              Write(FBEOffset, value);
890          }
891      }
892      public class FieldModelDouble : FieldModelValueType<double>
893      {
894          public FieldModelDouble(Buffer buffer, long offset) : base(buffer, offset) {}
895          public override long FBESize => 8;
896          public override FieldModelValueType<double> Clone() { return new FieldModelDouble(_buffer, _offset); }
897          public override void Get(out double value) { Get(out value, 0.0D); }
898          public override void Get(out double value, double defaults)
899          {
900              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
901              {
902                  value = defaults;
903                  return;
904              }
905              value = ReadDouble(FBEOffset);
906          }
907          public override void Set(double value)
908          {
909              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
910              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
911                  return;
912              Write(FBEOffset, value);
913          }
914      }
915      public class FieldModelDecimal : FieldModelValueType<decimal>
916      {
917          public FieldModelDecimal(Buffer buffer, long offset) : base(buffer, offset) {}
918          public override long FBESize => 16;
919          public override FieldModelValueType<decimal> Clone() { return new FieldModelDecimal(_buffer, _offset); }
920          public override void Get(out decimal value) { Get(out value, 0.0M); }
921          public override void Get(out decimal value, decimal defaults)
922          {
923              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
924              {
925                  value = defaults;
926                  return;
927              }
928              value = ReadDecimal(FBEOffset);
929          }
930          public override void Set(decimal value)
931          {
932              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
933              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
934                  return;
935              Write(FBEOffset, value);
936          }
937      }
938      public class FieldModelUUID : FieldModelValueType<Guid>
939      {
940          public FieldModelUUID(Buffer buffer, long offset) : base(buffer, offset) {}
941          public override long FBESize => 16;
942          public override FieldModelValueType<Guid> Clone() { return new FieldModelUUID(_buffer, _offset); }
943          public override void Get(out Guid value) { Get(out value, UuidGenerator.Nil()); }
944          public override void Get(out Guid value, Guid defaults)
945          {
946              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
947              {
948                  value = defaults;
949                  return;
950              }
951              value = ReadUUID(FBEOffset);
952          }
953          public override void Set(Guid value)
954          {
955              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
956              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
957                  return;
958              Write(FBEOffset, value);
959          }
960      }
961      public class FieldModelTimestamp : FieldModelValueType<DateTime>
962      {
963          private const long UnixEpoch = 621355968000000000;
964          public FieldModelTimestamp(Buffer buffer, long offset) : base(buffer, offset) {}
965          public override long FBESize => 8;
966          public override FieldModelValueType<DateTime> Clone() { return new FieldModelTimestamp(_buffer, _offset); }
967          public override void Get(out DateTime value) { Get(out value, new DateTime(UnixEpoch, DateTimeKind.Utc)); }
968          public override void Get(out DateTime value, DateTime defaults)
969          {
970              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
971              {
972                  value = defaults;
973                  return;
974              }
975              ulong ticks = ReadUInt64(FBEOffset) / 100;
976              value = new DateTime((long)(UnixEpoch + ticks), DateTimeKind.Utc);
977          }
978          public override void Set(DateTime value)
979          {
980              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
981              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
982                  return;
983              ulong nanoseconds = (ulong)((value.Ticks - UnixEpoch) * 100);
984              Write(FBEOffset, nanoseconds);
985          }
986      }
987      public class FieldModelBytes : FieldModelReferenceType<MemoryStream>
988      {
989          public FieldModelBytes(Buffer buffer, long offset) : base(buffer, offset) {}
990          public override long FBESize => 4;
991          public override long FBEExtra
992          {
993              get
994              {
995                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
996                      return 0;
997                  uint fbeBytesOffset = ReadUInt32(FBEOffset);
998                  if ((fbeBytesOffset == 0) || ((_buffer.Offset + fbeBytesOffset + 4) > _buffer.Size))
999                      return 0;
1000                  uint fbeBytesSize = ReadUInt32(fbeBytesOffset);
1001                  return 4 + fbeBytesSize;
1002              }
1003          }
1004          public override FieldModelReferenceType<MemoryStream> Clone() { return new FieldModelBytes(_buffer, _offset); }
1005          public override bool Verify()
1006          {
1007              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1008                  return true;
1009              uint fbeBytesOffset = ReadUInt32(FBEOffset);
1010              if (fbeBytesOffset == 0)
1011                  return true;
1012              if ((_buffer.Offset + fbeBytesOffset + 4) > _buffer.Size)
1013                  return false;
1014              uint fbeBytesSize = ReadUInt32(fbeBytesOffset);
1015              if ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.Size)
1016                  return false;
1017              return true;
1018          }
1019          public override void Get(out MemoryStream value) { Get(out value, new MemoryStream()); }
1020          public override void Get(out MemoryStream value, MemoryStream defaults)
1021          {
1022              Debug.Assert((defaults != null), "Invalid default bytes value!");
1023              if (defaults == null)
1024                  throw new ArgumentNullException(nameof(defaults), "Invalid default bytes value!");
1025              value = defaults;
1026              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1027                  return;
1028              uint fbeBytesOffset = ReadUInt32(FBEOffset);
1029              if (fbeBytesOffset == 0)
1030                  return;
1031              Debug.Assert(((_buffer.Offset + fbeBytesOffset + 4) <= _buffer.Size), "Model is broken!");
1032              if ((_buffer.Offset + fbeBytesOffset + 4) > _buffer.Size)
1033                  return;
1034              uint fbeBytesSize = ReadUInt32(fbeBytesOffset);
1035              Debug.Assert(((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.Size), "Model is broken!");
1036              if ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.Size)
1037                  return;
1038              var buffer = ReadBytes(fbeBytesOffset + 4, fbeBytesSize);
1039              value.Write(buffer, 0, buffer.Length);
1040          }
1041          public override void Set(MemoryStream value)
1042          {
1043              Debug.Assert((value != null), "Invalid bytes value!");
1044              if (value == null)
1045                  throw new ArgumentNullException(nameof(value), "Invalid bytes value!");
1046              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1047              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1048                  return;
1049              uint fbeBytesSize = (uint)value.Length;
1050              uint fbeBytesOffset = (uint)(_buffer.Allocate(4 + fbeBytesSize) - _buffer.Offset);
1051              Debug.Assert(((fbeBytesOffset > 0) && ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.Size)), "Model is broken!");
1052              if ((fbeBytesOffset == 0) || ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.Size))
1053                  return;
1054              Write(FBEOffset, fbeBytesOffset);
1055              Write(fbeBytesOffset, fbeBytesSize);
1056              Write(fbeBytesOffset + 4, value.GetBuffer(), 0, fbeBytesSize);
1057          }
1058      }
1059      public class FieldModelString : FieldModelReferenceType<string>
1060      {
1061          public FieldModelString(Buffer buffer, long offset) : base(buffer, offset) {}
1062          public override long FBESize => 4;
1063          public override long FBEExtra
1064          {
1065              get
1066              {
1067                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1068                      return 0;
1069                  uint fbeStringOffset = ReadUInt32(FBEOffset);
1070                  if ((fbeStringOffset == 0) || ((_buffer.Offset + fbeStringOffset + 4) > _buffer.Size))
1071                      return 0;
1072                  uint fbeStringSize = ReadUInt32(fbeStringOffset);
1073                  return 4 + fbeStringSize;
1074              }
1075          }
1076          public override FieldModelReferenceType<string> Clone() { return new FieldModelString(_buffer, _offset); }
1077          public override bool Verify()
1078          {
1079              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1080                  return true;
1081              uint fbeStringOffset = ReadUInt32(FBEOffset);
1082              if (fbeStringOffset == 0)
1083                  return true;
1084              if ((_buffer.Offset + fbeStringOffset + 4) > _buffer.Size)
1085                  return false;
1086              uint fbeStringSize = ReadUInt32(fbeStringOffset);
1087              if ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.Size)
1088                  return false;
1089              return true;
1090          }
1091          public override void Get(out string value) { Get(out value, ""); }
1092          public override void Get(out string value, string defaults)
1093          {
1094              Debug.Assert((defaults != null), "Invalid default string value!");
1095              if (defaults == null)
1096                  throw new ArgumentNullException(nameof(defaults), "Invalid default string value!");
1097              value = defaults;
1098              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1099                  return;
1100              uint fbeStringOffset = ReadUInt32(FBEOffset);
1101              if (fbeStringOffset == 0)
1102                  return;
1103              Debug.Assert(((_buffer.Offset + fbeStringOffset + 4) <= _buffer.Size), "Model is broken!");
1104              if ((_buffer.Offset + fbeStringOffset + 4) > _buffer.Size)
1105                  return;
1106              uint fbeStringSize = ReadUInt32(fbeStringOffset);
1107              Debug.Assert(((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) <= _buffer.Size), "Model is broken!");
1108              if ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.Size)
1109                  return;
1110              value = ReadString(fbeStringOffset + 4, fbeStringSize);
1111          }
1112          public override void Set(string value)
1113          {
1114              Debug.Assert((value != null), "Invalid string value!");
1115              if (value == null)
1116                  throw new ArgumentNullException(nameof(value), "Invalid string value!");
1117              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1118              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1119                  return;
1120              uint fbeStringSize = (uint)Encoding.UTF8.GetByteCount(value);
1121              uint fbeStringOffset = (uint)(_buffer.Allocate(4 + fbeStringSize) - _buffer.Offset);
1122              Debug.Assert(((fbeStringOffset > 0) && ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) <= _buffer.Size)), "Model is broken!");
1123              if ((fbeStringOffset == 0) || ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.Size))
1124                  return;
1125              Write(FBEOffset, fbeStringOffset);
1126              Write(fbeStringOffset, fbeStringSize);
1127              Write(fbeStringOffset + 4, value);
1128          }
1129      }
1130      public class FieldModelOptionalValueType<T, TModel> : FieldModelBase
1131          where T : struct
1132          where TModel : FieldModelValueType<T>
1133      {
1134          public FieldModelOptionalValueType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1135          {
1136              Value = model.Clone() as TModel;
1137              if (Value != null)
1138                  Value.FBEOffset = 0;
1139          }
1140          public override long FBESize => 1 + 4;
1141          public override long FBEExtra
1142          {
1143              get
1144              {
1145                  if (!HasValue)
1146                      return 0;
1147                  uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1148                  if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + 4) > _buffer.Size))
1149                      return 0;
1150                  _buffer.Shift(fbeOptionalOffset);
1151                  long fbeResult = Value.FBESize + Value.FBEExtra;
1152                  _buffer.Unshift(fbeOptionalOffset);
1153                  return fbeResult;
1154              }
1155          }
1156          public FieldModelOptionalValueType<T, TModel> Clone() { return new FieldModelOptionalValueType<T, TModel>(Value, _buffer, _offset); }
1157          public static implicit operator bool(FieldModelOptionalValueType<T, TModel> optional) { return !ReferenceEquals(optional, null) && optional.HasValue; }
1158          public bool HasValue
1159          {
1160              get
1161              {
1162                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1163                      return false;
1164                  byte fbeHasValue = ReadUInt8(FBEOffset);
1165                  return (fbeHasValue != 0);
1166              }
1167          }
1168          public TModel Value { get; }
1169          public virtual bool Verify()
1170          {
1171              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1172                  return true;
1173              byte fbeHasValue = ReadUInt8(FBEOffset);
1174              if (fbeHasValue == 0)
1175                  return true;
1176              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1177              if (fbeOptionalOffset == 0)
1178                  return false;
1179              _buffer.Shift(fbeOptionalOffset);
1180              bool fbeResult = Value.Verify();
1181              _buffer.Unshift(fbeOptionalOffset);
1182              return fbeResult;
1183          }
1184          public long GetBegin()
1185          {
1186              if (!HasValue)
1187                  return 0;
1188              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1189              Debug.Assert((fbeOptionalOffset > 0), "Model is broken!");
1190              if (fbeOptionalOffset == 0)
1191                  return 0;
1192              _buffer.Shift(fbeOptionalOffset);
1193              return fbeOptionalOffset;
1194          }
1195          public void GetEnd(long fbeBegin)
1196          {
1197              _buffer.Unshift(fbeBegin);
1198          }
1199          public void Get(out T? optional, T? defaults = null)
1200          {
1201              optional = defaults;
1202              long fbeBegin = GetBegin();
1203              if (fbeBegin == 0)
<span onclick='openModal()' class='match'>1204                  return;
1205              Value.Get(out var temp);
1206              optional = temp;
1207              GetEnd(fbeBegin);
1208          }
1209          public long SetBegin(bool hasValue)
1210          {
1211              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1212              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1213                  return 0;
1214              byte fbeHasValue = (byte)(hasValue ? 1 : 0);
1215              Write(FBEOffset, fbeHasValue);
1216              if (fbeHasValue == 0)
1217                  return 0;
1218              uint fbeOptionalSize = (uint)Value.FBESize;
1219              uint fbeOptionalOffset = (uint)(_buffer.Allocate(fbeOptionalSize) - _buffer.Offset);
1220              Debug.Assert(((fbeOptionalOffset > 0) && ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.Size)), "Model is broken!");
1221              if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.Size))
1222                  return 0;
1223              Write(FBEOffset + 1, fbeOptionalOffset);
1224              _buffer.Shift(fbeOptionalOffset);
1225              return fbeOptionalOffset;
1226          }
1227          public void SetEnd(long fbeBegin)
1228          {
1229              _buffer.Unshift(fbeBegin);
1230          }
1231          public void Set(T? optional)
</span>1232          {
1233              long fbeBegin = SetBegin(optional.HasValue);
1234              if (fbeBegin == 0)
1235                  return;
1236              if (optional.HasValue)
1237                  Value.Set(optional.Value);
1238              SetEnd(fbeBegin);
1239          }
1240      }
1241      public class FieldModelOptionalReferenceType<T, TModel> : FieldModelBase
1242          where T : class
1243          where TModel : FieldModelReferenceType<T>
1244      {
1245          public FieldModelOptionalReferenceType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1246          {
1247              Value = model.Clone() as TModel;
1248              if (Value != null)
1249                  Value.FBEOffset = 0;
1250          }
1251          public override long FBESize => 1 + 4;
1252          public override long FBEExtra
1253          {
1254              get
1255              {
1256                  if (!HasValue)
1257                      return 0;
1258                  uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1259                  if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + 4) > _buffer.Size))
1260                      return 0;
1261                  _buffer.Shift(fbeOptionalOffset);
1262                  long fbeResult = Value.FBESize + Value.FBEExtra;
1263                  _buffer.Unshift(fbeOptionalOffset);
1264                  return fbeResult;
1265              }
1266          }
1267          public FieldModelOptionalReferenceType<T, TModel> Clone() { return new FieldModelOptionalReferenceType<T, TModel>(Value, _buffer, _offset); }
1268          public static implicit operator bool(FieldModelOptionalReferenceType<T, TModel> optional) { return !ReferenceEquals(optional, null) && optional.HasValue; }
1269          public bool HasValue
1270          {
1271              get
1272              {
1273                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1274                      return false;
1275                  byte fbeHasValue = ReadUInt8(FBEOffset);
1276                  return (fbeHasValue != 0);
1277              }
1278          }
1279          public TModel Value { get; }
1280          public virtual bool Verify()
1281          {
1282              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1283                  return true;
1284              byte fbeHasValue = ReadUInt8(FBEOffset);
1285              if (fbeHasValue == 0)
1286                  return true;
1287              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1288              if (fbeOptionalOffset == 0)
1289                  return false;
1290              _buffer.Shift(fbeOptionalOffset);
1291              bool fbeResult = Value.Verify();
1292              _buffer.Unshift(fbeOptionalOffset);
1293              return fbeResult;
1294          }
1295          public long GetBegin()
1296          {
1297              if (!HasValue)
1298                  return 0;
1299              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1300              Debug.Assert((fbeOptionalOffset > 0), "Model is broken!");
1301              if (fbeOptionalOffset == 0)
1302                  return 0;
1303              _buffer.Shift(fbeOptionalOffset);
1304              return fbeOptionalOffset;
1305          }
1306          public void GetEnd(long fbeBegin)
1307          {
1308              _buffer.Unshift(fbeBegin);
1309          }
1310          public void Get(out T optional, T defaults = null)
1311          {
1312              optional = defaults;
1313              long fbeBegin = GetBegin();
1314              if (fbeBegin == 0)
1315                  return;
1316              Value.Get(out var temp);
1317              optional = temp;
1318              GetEnd(fbeBegin);
1319          }
1320          public long SetBegin(bool hasValue)
1321          {
1322              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1323              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1324                  return 0;
1325              byte fbeHasValue = (byte)(hasValue ? 1 : 0);
1326              Write(FBEOffset, fbeHasValue);
1327              if (fbeHasValue == 0)
1328                  return 0;
1329              uint fbeOptionalSize = (uint)Value.FBESize;
1330              uint fbeOptionalOffset = (uint)(_buffer.Allocate(fbeOptionalSize) - _buffer.Offset);
1331              Debug.Assert(((fbeOptionalOffset > 0) && ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.Size)), "Model is broken!");
1332              if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.Size))
1333                  return 0;
1334              Write(FBEOffset + 1, fbeOptionalOffset);
1335              _buffer.Shift(fbeOptionalOffset);
1336              return fbeOptionalOffset;
1337          }
1338          public void SetEnd(long fbeBegin)
1339          {
1340              _buffer.Unshift(fbeBegin);
1341          }
1342          public void Set(T optional)
1343          {
1344              long fbeBegin = SetBegin(optional != null);
1345              if (fbeBegin == 0)
1346                  return;
1347              if (optional != null)
1348                  Value.Set(optional);
1349              SetEnd(fbeBegin);
1350          }
1351      }
1352      public class FieldModelArrayValueType<T, TModel> : FieldModelBase
1353          where T : struct
1354          where TModel : FieldModelValueType<T>
1355      {
1356          private readonly TModel _model;
1357          private readonly long _size;
1358          public FieldModelArrayValueType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1359          {
1360              _model = model.Clone() as TModel;
1361              _size = size;
1362          }
1363          public override long FBESize => _size * _model.FBESize;
1364          public override long FBEExtra => 0;
1365          public FieldModelArrayValueType<T, TModel> Clone() { return new FieldModelArrayValueType<T, TModel>(_model, _buffer, _offset, _size); }
1366          public long Offset => 0;
1367          public long Size => _size;
1368          public TModel this[long index]
1369          {
1370              get
1371              {
1372                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1373                  Debug.Assert((index < _size), "Index is out of bounds!");
1374                  _model.FBEOffset = FBEOffset;
1375                  _model.FBEShift(index * _model.FBESize);
1376                  return _model;
1377              }
1378          }
1379          public virtual bool Verify()
1380          {
1381              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1382                  return false;
1383              _model.FBEOffset = FBEOffset;
1384              for (long i = _size; i-- > 0;)
1385              {
1386                  if (!_model.Verify())
1387                      return false;
1388                  _model.FBEShift(_model.FBESize);
1389              }
1390              return true;
1391          }
1392          public void Get(ref T[] values)
1393          {
1394              Debug.Assert((values != null), "Invalid values parameter!");
1395              if (values == null)
1396                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1397              values = new T[_size];
1398              var fbeModel = this[0];
1399              for (long i = 0; i < _size; i++)
1400              {
1401                  fbeModel.Get(out values[i]);
1402                  fbeModel.FBEShift(fbeModel.FBESize);
1403              }
1404          }
1405          public void Get(ref List<T> values)
1406          {
1407              Debug.Assert((values != null), "Invalid values parameter!");
1408              if (values == null)
1409                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1410              values.Clear();
1411              values.Capacity = (int)_size;
1412              var fbeModel = this[0];
1413              for (long i = _size; i-- > 0;)
1414              {
1415                  fbeModel.Get(out var value);
1416                  values.Add(value);
1417                  fbeModel.FBEShift(fbeModel.FBESize);
1418              }
1419          }
1420          public void Set(T[] values)
1421          {
1422              Debug.Assert((values != null), "Invalid values parameter!");
1423              if (values == null)
1424                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1425              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1426              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1427                  return;
1428              var fbeModel = this[0];
1429              for (long i = 0; (i < values.Length) && (i < _size); i++)
1430              {
1431                  fbeModel.Set(values[i]);
1432                  fbeModel.FBEShift(fbeModel.FBESize);
1433              }
1434          }
1435          public void Set(List<T> values)
1436          {
1437              Debug.Assert((values != null), "Invalid values parameter!");
1438              if (values == null)
1439                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1440              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1441              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1442                  return;
1443              var fbeModel = this[0];
1444              for (long i = 0; (i < values.Count) && (i < _size); i++)
1445              {
1446                  fbeModel.Set(values[(int)i]);
1447                  fbeModel.FBEShift(fbeModel.FBESize);
1448              }
1449          }
1450      }
1451      public class FieldModelArrayReferenceType<T, TModel> : FieldModelBase
1452          where T : class
1453          where TModel : FieldModelReferenceType<T>
1454      {
1455          private readonly TModel _model;
1456          private readonly long _size;
1457          public FieldModelArrayReferenceType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1458          {
1459              _model = model.Clone() as TModel;
1460              _size = size;
1461          }
1462          public override long FBESize => _size * _model.FBESize;
1463          public override long FBEExtra => 0;
1464          public FieldModelArrayReferenceType<T, TModel> Clone() { return new FieldModelArrayReferenceType<T, TModel>(_model, _buffer, _offset, _size); }
1465          public long Offset => 0;
1466          public long Size => _size;
1467          public TModel this[long index]
1468          {
1469              get
1470              {
1471                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1472                  Debug.Assert((index < _size), "Index is out of bounds!");
1473                  _model.FBEOffset = FBEOffset;
1474                  _model.FBEShift(index * _model.FBESize);
1475                  return _model;
1476              }
1477          }
1478          public virtual bool Verify()
1479          {
1480              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1481                  return false;
1482              _model.FBEOffset = FBEOffset;
1483              for (long i = _size; i-- > 0;)
1484              {
1485                  if (!_model.Verify())
1486                      return false;
1487                  _model.FBEShift(_model.FBESize);
1488              }
1489              return true;
1490          }
1491          public void Get(ref T[] values)
1492          {
1493              Debug.Assert((values != null), "Invalid values parameter!");
1494              if (values == null)
1495                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1496              values = new T[_size];
1497              var fbeModel = this[0];
1498              for (long i = 0; i < _size; i++)
1499              {
1500                  fbeModel.Get(out values[i]);
1501                  fbeModel.FBEShift(fbeModel.FBESize);
1502              }
1503          }
1504          public void Get(ref List<T> values)
1505          {
1506              Debug.Assert((values != null), "Invalid values parameter!");
1507              if (values == null)
1508                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1509              values.Clear();
1510              values.Capacity = (int)_size;
1511              var fbeModel = this[0];
1512              for (long i = _size; i-- > 0;)
1513              {
1514                  fbeModel.Get(out var value);
1515                  values.Add(value);
1516                  fbeModel.FBEShift(fbeModel.FBESize);
1517              }
1518          }
1519          public void Set(T[] values)
1520          {
1521              Debug.Assert((values != null), "Invalid values parameter!");
1522              if (values == null)
1523                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1524              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1525              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1526                  return;
1527              var fbeModel = this[0];
1528              for (long i = 0; (i < values.Length) && (i < _size); i++)
1529              {
1530                  fbeModel.Set(values[i]);
1531                  fbeModel.FBEShift(fbeModel.FBESize);
1532              }
1533          }
1534          public void Set(List<T> values)
1535          {
1536              Debug.Assert((values != null), "Invalid values parameter!");
1537              if (values == null)
1538                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1539              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1540              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1541                  return;
1542              var fbeModel = this[0];
1543              for (long i = 0; (i < values.Count) && (i < _size); i++)
1544              {
1545                  fbeModel.Set(values[(int)i]);
1546                  fbeModel.FBEShift(fbeModel.FBESize);
1547              }
1548          }
1549      }
1550      public class FieldModelArrayOptionalValueType<T, TModel> : FieldModelBase
1551          where T : struct
1552          where TModel : FieldModelValueType<T>
1553      {
1554          private readonly FieldModelOptionalValueType<T, TModel> _model;
1555          private readonly long _size;
1556          public FieldModelArrayOptionalValueType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1557          {
1558              _model = new FieldModelOptionalValueType<T, TModel>(model, buffer, offset);
1559              _size = size;
1560          }
1561          public override long FBESize => _size * _model.FBESize;
1562          public override long FBEExtra => 0;
1563          public FieldModelArrayOptionalValueType<T, TModel> Clone() { return new FieldModelArrayOptionalValueType<T, TModel>(_model.Value, _buffer, _offset, _size); }
1564          public long Offset => 0;
1565          public long Size => _size;
1566          public FieldModelOptionalValueType<T, TModel> this[long index]
1567          {
1568              get
1569              {
1570                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1571                  Debug.Assert((index < _size), "Index is out of bounds!");
1572                  _model.FBEOffset = FBEOffset;
1573                  _model.FBEShift(index * _model.FBESize);
1574                  return _model;
1575              }
1576          }
1577          public virtual bool Verify()
1578          {
1579              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1580                  return false;
1581              _model.FBEOffset = FBEOffset;
1582              for (long i = _size; i-- > 0;)
1583              {
1584                  if (!_model.Verify())
1585                      return false;
1586                  _model.FBEShift(_model.FBESize);
1587              }
1588              return true;
1589          }
1590          public void Get(ref T?[] values)
1591          {
1592              Debug.Assert((values != null), "Invalid values parameter!");
1593              if (values == null)
1594                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1595              values = new T?[_size];
1596              var fbeModel = this[0];
1597              for (long i = 0; i < _size; i++)
1598              {
1599                  fbeModel.Get(out values[i]);
1600                  fbeModel.FBEShift(fbeModel.FBESize);
1601              }
1602          }
1603          public void Get(ref List<T?> values)
1604          {
1605              Debug.Assert((values != null), "Invalid values parameter!");
1606              if (values == null)
1607                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1608              values.Clear();
1609              values.Capacity = (int)_size;
1610              var fbeModel = this[0];
1611              for (long i = _size; i-- > 0;)
1612              {
1613                  fbeModel.Get(out var value);
1614                  values.Add(value);
1615                  fbeModel.FBEShift(fbeModel.FBESize);
1616              }
1617          }
1618          public void Set(T?[] values)
1619          {
1620              Debug.Assert((values != null), "Invalid values parameter!");
1621              if (values == null)
1622                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1623              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1624              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1625                  return;
1626              var fbeModel = this[0];
1627              for (long i = 0; (i < values.Length) && (i < _size); i++)
1628              {
1629                  fbeModel.Set(values[i]);
1630                  fbeModel.FBEShift(fbeModel.FBESize);
1631              }
1632          }
1633          public void Set(List<T?> values)
1634          {
1635              Debug.Assert((values != null), "Invalid values parameter!");
1636              if (values == null)
1637                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1638              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1639              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1640                  return;
1641              var fbeModel = this[0];
1642              for (long i = 0; (i < values.Count) && (i < _size); i++)
1643              {
1644                  fbeModel.Set(values[(int)i]);
1645                  fbeModel.FBEShift(fbeModel.FBESize);
1646              }
1647          }
1648      }
1649      public class FieldModelArrayOptionalReferenceType<T, TModel> : FieldModelBase
1650          where T : class
1651          where TModel : FieldModelReferenceType<T>
1652      {
1653          private readonly FieldModelOptionalReferenceType<T, TModel> _model;
1654          private readonly long _size;
1655          public FieldModelArrayOptionalReferenceType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1656          {
1657              _model = new FieldModelOptionalReferenceType<T, TModel>(model, buffer, offset);
1658              _size = size;
1659          }
1660          public override long FBESize => _size * _model.FBESize;
1661          public override long FBEExtra => 0;
1662          public FieldModelArrayOptionalReferenceType<T, TModel> Clone() { return new FieldModelArrayOptionalReferenceType<T, TModel>(_model.Value, _buffer, _offset, _size); }
1663          public long Offset => 0;
1664          public long Size => _size;
1665          public FieldModelOptionalReferenceType<T, TModel> this[long index]
1666          {
1667              get
1668              {
1669                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1670                  Debug.Assert((index < _size), "Index is out of bounds!");
1671                  _model.FBEOffset = FBEOffset;
1672                  _model.FBEShift(index * _model.FBESize);
1673                  return _model;
1674              }
1675          }
1676          public virtual bool Verify()
1677          {
1678              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1679                  return false;
1680              _model.FBEOffset = FBEOffset;
1681              for (long i = _size; i-- > 0;)
1682              {
1683                  if (!_model.Verify())
1684                      return false;
1685                  _model.FBEShift(_model.FBESize);
1686              }
1687              return true;
1688          }
1689          public void Get(ref T[] values)
1690          {
1691              Debug.Assert((values != null), "Invalid values parameter!");
1692              if (values == null)
1693                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1694              values = new T[_size];
1695              var fbeModel = this[0];
1696              for (long i = 0; i < _size; i++)
1697              {
1698                  fbeModel.Get(out values[i]);
1699                  fbeModel.FBEShift(fbeModel.FBESize);
1700              }
1701          }
1702          public void Get(ref List<T> values)
1703          {
1704              Debug.Assert((values != null), "Invalid values parameter!");
1705              if (values == null)
1706                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1707              values.Clear();
1708              values.Capacity = (int)_size;
1709              var fbeModel = this[0];
1710              for (long i = _size; i-- > 0;)
1711              {
1712                  fbeModel.Get(out var value);
1713                  values.Add(value);
1714                  fbeModel.FBEShift(fbeModel.FBESize);
1715              }
1716          }
1717          public void Set(T[] values)
1718          {
1719              Debug.Assert((values != null), "Invalid values parameter!");
1720              if (values == null)
1721                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1722              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1723              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1724                  return;
1725              var fbeModel = this[0];
1726              for (long i = 0; (i < values.Length) && (i < _size); i++)
1727              {
1728                  fbeModel.Set(values[i]);
1729                  fbeModel.FBEShift(fbeModel.FBESize);
1730              }
1731          }
1732          public void Set(List<T> values)
1733          {
1734              Debug.Assert((values != null), "Invalid values parameter!");
1735              if (values == null)
1736                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1737              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1738              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1739                  return;
1740              var fbeModel = this[0];
1741              for (long i = 0; (i < values.Count) && (i < _size); i++)
1742              {
1743                  fbeModel.Set(values[(int)i]);
1744                  fbeModel.FBEShift(fbeModel.FBESize);
1745              }
1746          }
1747      }
1748      public class FieldModelVectorValueType<T, TModel> : FieldModelBase
1749          where T : struct
1750          where TModel : FieldModelValueType<T>
1751      {
1752          private readonly TModel _model;
1753          public FieldModelVectorValueType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1754          {
1755              _model = model.Clone() as TModel;
1756          }
1757          public override long FBESize => 4;
1758          public override long FBEExtra
1759          {
1760              get
1761              {
1762                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1763                      return 0;
1764                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1765                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1766                      return 0;
1767                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1768                  long fbeResult = 4;
1769                  _model.FBEOffset = fbeVectorOffset + 4;
1770                  for (uint i = fbeVectorSize; i-- > 0;)
1771                  {
1772                      fbeResult += _model.FBESize + _model.FBEExtra;
1773                      _model.FBEShift(_model.FBESize);
1774                  }
1775                  return fbeResult;
1776              }
1777          }
1778          public FieldModelVectorValueType<T, TModel> Clone() { return new FieldModelVectorValueType<T, TModel>(_model, _buffer, _offset); }
1779          public long Offset
1780          {
1781              get
1782              {
1783                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1784                      return 0;
1785                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1786                  return fbeVectorOffset;
1787              }
1788          }
1789          public long Size
1790          {
1791              get
1792              {
1793                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1794                      return 0;
1795                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1796                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1797                      return 0;
1798                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1799                  return fbeVectorSize;
1800              }
1801          }
1802          public TModel this[long index]
1803          {
1804              get
1805              {
1806                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1807                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1808                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
1809                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1810                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
1811                  _model.FBEOffset = fbeVectorOffset + 4;
1812                  _model.FBEShift(index * _model.FBESize);
1813                  return _model;
1814              }
1815          }
1816          public TModel Resize(long size)
1817          {
1818              uint fbeVectorSize = (uint)(size * _model.FBESize);
1819              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
1820              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
1821              Write(FBEOffset, fbeVectorOffset);
1822              Write(fbeVectorOffset, (uint)size);
1823              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
1824              _model.FBEOffset = fbeVectorOffset + 4;
1825              return _model;
1826          }
1827          public virtual bool Verify()
1828          {
1829              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1830                  return true;
1831              uint fbeVectorOffset = ReadUInt32(FBEOffset);
1832              if (fbeVectorOffset == 0)
1833                  return true;
1834              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
1835                  return false;
1836              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1837              _model.FBEOffset = fbeVectorOffset + 4;
1838              for (uint i = fbeVectorSize; i-- > 0;)
1839              {
1840                  if (!_model.Verify())
1841                      return false;
1842                  _model.FBEShift(_model.FBESize);
1843              }
1844              return true;
1845          }
1846          public void Get(ref List<T> values)
1847          {
1848              Debug.Assert((values != null), "Invalid values parameter!");
1849              if (values == null)
1850                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1851              values.Clear();
1852              long fbeVectorSize = Size;
1853              if (fbeVectorSize == 0)
1854                  return;
1855              values.Capacity = (int)fbeVectorSize;
1856              var fbeModel = this[0];
1857              for (long i = fbeVectorSize; i-- > 0;)
1858              {
1859                  fbeModel.Get(out var value);
1860                  values.Add(value);
1861                  fbeModel.FBEShift(fbeModel.FBESize);
1862              }
1863          }
1864          public void Get(ref LinkedList<T> values)
1865          {
1866              Debug.Assert((values != null), "Invalid values parameter!");
1867              if (values == null)
1868                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1869              values.Clear();
1870              long fbeVectorSize = Size;
1871              if (fbeVectorSize == 0)
1872                  return;
1873              var fbeModel = this[0];
1874              for (long i = fbeVectorSize; i-- > 0;)
1875              {
1876                  fbeModel.Get(out var value);
1877                  values.AddLast(value);
1878                  fbeModel.FBEShift(fbeModel.FBESize);
1879              }
1880          }
1881          public void Get(ref HashSet<T> values)
1882          {
1883              Debug.Assert((values != null), "Invalid values parameter!");
1884              if (values == null)
1885                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1886              values.Clear();
1887              long fbeVectorSize = Size;
1888              if (fbeVectorSize == 0)
1889                  return;
1890              var fbeModel = this[0];
1891              for (long i = fbeVectorSize; i-- > 0;)
1892              {
1893                  fbeModel.Get(out var value);
1894                  values.Add(value);
1895                  fbeModel.FBEShift(fbeModel.FBESize);
1896              }
1897          }
1898          public void Set(List<T> values)
1899          {
1900              Debug.Assert((values != null), "Invalid values parameter!");
1901              if (values == null)
1902                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1903              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1904              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1905                  return;
1906              var fbeModel = Resize(values.Count);
1907              foreach (var value in values)
1908              {
1909                  fbeModel.Set(value);
1910                  fbeModel.FBEShift(fbeModel.FBESize);
1911              }
1912          }
1913          public void Set(LinkedList<T> values)
1914          {
1915              Debug.Assert((values != null), "Invalid values parameter!");
1916              if (values == null)
1917                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1918              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1919              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1920                  return;
1921              var fbeModel = Resize(values.Count);
1922              foreach (var value in values)
1923              {
1924                  fbeModel.Set(value);
1925                  fbeModel.FBEShift(fbeModel.FBESize);
1926              }
1927          }
1928          public void Set(HashSet<T> values)
1929          {
1930              Debug.Assert((values != null), "Invalid values parameter!");
1931              if (values == null)
1932                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1933              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1934              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1935                  return;
1936              var fbeModel = Resize(values.Count);
1937              foreach (var value in values)
1938              {
1939                  fbeModel.Set(value);
1940                  fbeModel.FBEShift(fbeModel.FBESize);
1941              }
1942          }
1943      }
1944      public class FieldModelVectorReferenceType<T, TModel> : FieldModelBase
1945          where T : class
1946          where TModel : FieldModelReferenceType<T>
1947      {
1948          private readonly TModel _model;
1949          public FieldModelVectorReferenceType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1950          {
1951              _model = model.Clone() as TModel;
1952          }
1953          public override long FBESize => 4;
1954          public override long FBEExtra
1955          {
1956              get
1957              {
1958                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1959                      return 0;
1960                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1961                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1962                      return 0;
1963                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1964                  long fbeResult = 4;
1965                  _model.FBEOffset = fbeVectorOffset + 4;
1966                  for (uint i = fbeVectorSize; i-- > 0;)
1967                  {
1968                      fbeResult += _model.FBESize + _model.FBEExtra;
1969                      _model.FBEShift(_model.FBESize);
1970                  }
1971                  return fbeResult;
1972              }
1973          }
1974          public FieldModelVectorReferenceType<T, TModel> Clone() { return new FieldModelVectorReferenceType<T, TModel>(_model, _buffer, _offset); }
1975          public long Offset
1976          {
1977              get
1978              {
1979                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1980                      return 0;
1981                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1982                  return fbeVectorOffset;
1983              }
1984          }
1985          public long Size
1986          {
1987              get
1988              {
1989                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1990                      return 0;
1991                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1992                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1993                      return 0;
1994                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1995                  return fbeVectorSize;
1996              }
1997          }
1998          public TModel this[long index]
1999          {
2000              get
2001              {
2002                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2003                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2004                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2005                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2006                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
2007                  _model.FBEOffset = fbeVectorOffset + 4;
2008                  _model.FBEShift(index * _model.FBESize);
2009                  return _model;
2010              }
2011          }
2012          public TModel Resize(long size)
2013          {
2014              uint fbeVectorSize = (uint)(size * _model.FBESize);
2015              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
2016              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2017              Write(FBEOffset, fbeVectorOffset);
2018              Write(fbeVectorOffset, (uint)size);
2019              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
2020              _model.FBEOffset = fbeVectorOffset + 4;
2021              return _model;
2022          }
2023          public virtual bool Verify()
2024          {
2025              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2026                  return true;
2027              uint fbeVectorOffset = ReadUInt32(FBEOffset);
2028              if (fbeVectorOffset == 0)
2029                  return true;
2030              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
2031                  return false;
2032              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2033              _model.FBEOffset = fbeVectorOffset + 4;
2034              for (uint i = fbeVectorSize; i-- > 0;)
2035              {
2036                  if (!_model.Verify())
2037                      return false;
2038                  _model.FBEShift(_model.FBESize);
2039              }
2040              return true;
2041          }
2042          public void Get(ref List<T> values)
2043          {
2044              Debug.Assert((values != null), "Invalid values parameter!");
2045              if (values == null)
2046                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2047              values.Clear();
2048              long fbeVectorSize = Size;
2049              if (fbeVectorSize == 0)
2050                  return;
2051              values.Capacity = (int)fbeVectorSize;
2052              var fbeModel = this[0];
2053              for (long i = fbeVectorSize; i-- > 0;)
2054              {
2055                  fbeModel.Get(out var value);
2056                  values.Add(value);
2057                  fbeModel.FBEShift(fbeModel.FBESize);
2058              }
2059          }
2060          public void Get(ref LinkedList<T> values)
2061          {
2062              Debug.Assert((values != null), "Invalid values parameter!");
2063              if (values == null)
2064                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2065              values.Clear();
2066              long fbeVectorSize = Size;
2067              if (fbeVectorSize == 0)
2068                  return;
2069              var fbeModel = this[0];
2070              for (long i = fbeVectorSize; i-- > 0;)
2071              {
2072                  fbeModel.Get(out var value);
2073                  values.AddLast(value);
2074                  fbeModel.FBEShift(fbeModel.FBESize);
2075              }
2076          }
2077          public void Get(ref HashSet<T> values)
2078          {
2079              Debug.Assert((values != null), "Invalid values parameter!");
2080              if (values == null)
2081                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2082              values.Clear();
2083              long fbeVectorSize = Size;
2084              if (fbeVectorSize == 0)
2085                  return;
2086              var fbeModel = this[0];
2087              for (long i = fbeVectorSize; i-- > 0;)
2088              {
2089                  fbeModel.Get(out var value);
2090                  values.Add(value);
2091                  fbeModel.FBEShift(fbeModel.FBESize);
2092              }
2093          }
2094          public void Set(List<T> values)
2095          {
2096              Debug.Assert((values != null), "Invalid values parameter!");
2097              if (values == null)
2098                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2099              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2100              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2101                  return;
2102              var fbeModel = Resize(values.Count);
2103              foreach (var value in values)
2104              {
2105                  fbeModel.Set(value);
2106                  fbeModel.FBEShift(fbeModel.FBESize);
2107              }
2108          }
2109          public void Set(LinkedList<T> values)
2110          {
2111              Debug.Assert((values != null), "Invalid values parameter!");
2112              if (values == null)
2113                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2114              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2115              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2116                  return;
2117              var fbeModel = Resize(values.Count);
2118              foreach (var value in values)
2119              {
2120                  fbeModel.Set(value);
2121                  fbeModel.FBEShift(fbeModel.FBESize);
2122              }
2123          }
2124          public void Set(HashSet<T> values)
2125          {
2126              Debug.Assert((values != null), "Invalid values parameter!");
2127              if (values == null)
2128                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2129              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2130              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2131                  return;
2132              var fbeModel = Resize(values.Count);
2133              foreach (var value in values)
2134              {
2135                  fbeModel.Set(value);
2136                  fbeModel.FBEShift(fbeModel.FBESize);
2137              }
2138          }
2139      }
2140      public class FieldModelVectorOptionalValueType<T, TModel> : FieldModelBase
2141          where T : struct
2142          where TModel : FieldModelValueType<T>
2143      {
2144          private readonly FieldModelOptionalValueType<T, TModel> _model;
2145          public FieldModelVectorOptionalValueType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
2146          {
2147              _model = new FieldModelOptionalValueType<T, TModel>(model, buffer, offset);
2148          }
2149          public override long FBESize => 4;
2150          public override long FBEExtra
2151          {
2152              get
2153              {
2154                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2155                      return 0;
2156                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2157                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2158                      return 0;
2159                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2160                  long fbeResult = 4;
2161                  _model.FBEOffset = fbeVectorOffset + 4;
2162                  for (uint i = fbeVectorSize; i-- > 0;)
2163                  {
2164                      fbeResult += _model.FBESize + _model.FBEExtra;
2165                      _model.FBEShift(_model.FBESize);
2166                  }
2167                  return fbeResult;
2168              }
2169          }
2170          public FieldModelVectorOptionalValueType<T, TModel> Clone() { return new FieldModelVectorOptionalValueType<T, TModel>(_model.Value, _buffer, _offset); }
2171          public long Offset
2172          {
2173              get
2174              {
2175                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2176                      return 0;
2177                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2178                  return fbeVectorOffset;
2179              }
2180          }
2181          public long Size
2182          {
2183              get
2184              {
2185                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2186                      return 0;
2187                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2188                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2189                      return 0;
2190                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2191                  return fbeVectorSize;
2192              }
2193          }
2194          public FieldModelOptionalValueType<T, TModel> this[long index]
2195          {
2196              get
2197              {
2198                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2199                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2200                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2201                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2202                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
2203                  _model.FBEOffset = fbeVectorOffset + 4;
2204                  _model.FBEShift(index * _model.FBESize);
2205                  return _model;
2206              }
2207          }
2208          public FieldModelOptionalValueType<T, TModel> Resize(long size)
2209          {
2210              uint fbeVectorSize = (uint)(size * _model.FBESize);
2211              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
2212              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2213              Write(FBEOffset, fbeVectorOffset);
2214              Write(fbeVectorOffset, (uint)size);
2215              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
2216              _model.FBEOffset = fbeVectorOffset + 4;
2217              return _model;
2218          }
2219          public virtual bool Verify()
2220          {
2221              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2222                  return true;
2223              uint fbeVectorOffset = ReadUInt32(FBEOffset);
2224              if (fbeVectorOffset == 0)
2225                  return true;
2226              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
2227                  return false;
2228              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2229              _model.FBEOffset = fbeVectorOffset + 4;
2230              for (uint i = fbeVectorSize; i-- > 0;)
2231              {
2232                  if (!_model.Verify())
2233                      return false;
2234                  _model.FBEShift(_model.FBESize);
2235              }
2236              return true;
2237          }
2238          public void Get(ref List<T?> values)
2239          {
2240              Debug.Assert((values != null), "Invalid values parameter!");
2241              if (values == null)
2242                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2243              values.Clear();
2244              long fbeVectorSize = Size;
2245              if (fbeVectorSize == 0)
2246                  return;
2247              values.Capacity = (int)fbeVectorSize;
2248              var fbeModel = this[0];
2249              for (long i = fbeVectorSize; i-- > 0;)
2250              {
2251                  fbeModel.Get(out var value);
2252                  values.Add(value);
2253                  fbeModel.FBEShift(fbeModel.FBESize);
2254              }
2255          }
2256          public void Get(ref LinkedList<T?> values)
2257          {
2258              Debug.Assert((values != null), "Invalid values parameter!");
2259              if (values == null)
2260                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2261              values.Clear();
2262              long fbeVectorSize = Size;
2263              if (fbeVectorSize == 0)
2264                  return;
2265              var fbeModel = this[0];
2266              for (long i = fbeVectorSize; i-- > 0;)
2267              {
2268                  fbeModel.Get(out var value);
2269                  values.AddLast(value);
2270                  fbeModel.FBEShift(fbeModel.FBESize);
2271              }
2272          }
2273          public void Get(ref HashSet<T?> values)
2274          {
2275              Debug.Assert((values != null), "Invalid values parameter!");
2276              if (values == null)
2277                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2278              values.Clear();
2279              long fbeVectorSize = Size;
2280              if (fbeVectorSize == 0)
2281                  return;
2282              var fbeModel = this[0];
2283              for (long i = fbeVectorSize; i-- > 0;)
2284              {
2285                  fbeModel.Get(out var value);
2286                  values.Add(value);
2287                  fbeModel.FBEShift(fbeModel.FBESize);
2288              }
2289          }
2290          public void Set(List<T?> values)
2291          {
2292              Debug.Assert((values != null), "Invalid values parameter!");
2293              if (values == null)
2294                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2295              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2296              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2297                  return;
2298              var fbeModel = Resize(values.Count);
2299              foreach (var value in values)
2300              {
2301                  fbeModel.Set(value);
2302                  fbeModel.FBEShift(fbeModel.FBESize);
2303              }
2304          }
2305          public void Set(LinkedList<T?> values)
2306          {
2307              Debug.Assert((values != null), "Invalid values parameter!");
2308              if (values == null)
2309                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2310              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2311              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2312                  return;
2313              var fbeModel = Resize(values.Count);
2314              foreach (var value in values)
2315              {
2316                  fbeModel.Set(value);
2317                  fbeModel.FBEShift(fbeModel.FBESize);
2318              }
2319          }
2320          public void Set(HashSet<T?> values)
2321          {
2322              Debug.Assert((values != null), "Invalid values parameter!");
2323              if (values == null)
2324                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2325              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2326              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2327                  return;
2328              var fbeModel = Resize(values.Count);
2329              foreach (var value in values)
2330              {
2331                  fbeModel.Set(value);
2332                  fbeModel.FBEShift(fbeModel.FBESize);
2333              }
2334          }
2335      }
2336      public class FieldModelVectorOptionalReferenceType<T, TModel> : FieldModelBase
2337          where T : class
2338          where TModel : FieldModelReferenceType<T>
2339      {
2340          private readonly FieldModelOptionalReferenceType<T, TModel> _model;
2341          public FieldModelVectorOptionalReferenceType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
2342          {
2343              _model = new FieldModelOptionalReferenceType<T, TModel>(model, buffer, offset);
2344          }
2345          public override long FBESize => 4;
2346          public override long FBEExtra
2347          {
2348              get
2349              {
2350                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2351                      return 0;
2352                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2353                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2354                      return 0;
2355                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2356                  long fbeResult = 4;
2357                  _model.FBEOffset = fbeVectorOffset + 4;
2358                  for (uint i = fbeVectorSize; i-- > 0;)
2359                  {
2360                      fbeResult += _model.FBESize + _model.FBEExtra;
2361                      _model.FBEShift(_model.FBESize);
2362                  }
2363                  return fbeResult;
2364              }
2365          }
2366          public FieldModelVectorOptionalReferenceType<T, TModel> Clone() { return new FieldModelVectorOptionalReferenceType<T, TModel>(_model.Value, _buffer, _offset); }
2367          public long Offset
2368          {
2369              get
2370              {
2371                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2372                      return 0;
2373                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2374                  return fbeVectorOffset;
2375              }
2376          }
2377          public long Size
2378          {
2379              get
2380              {
2381                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2382                      return 0;
2383                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2384                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2385                      return 0;
2386                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2387                  return fbeVectorSize;
2388              }
2389          }
2390          public FieldModelOptionalReferenceType<T, TModel> this[long index]
2391          {
2392              get
2393              {
2394                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2395                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2396                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2397                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2398                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
2399                  _model.FBEOffset = fbeVectorOffset + 4;
2400                  _model.FBEShift(index * _model.FBESize);
2401                  return _model;
2402              }
2403          }
2404          public FieldModelOptionalReferenceType<T, TModel> Resize(long size)
2405          {
2406              uint fbeVectorSize = (uint)(size * _model.FBESize);
2407              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
2408              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2409              Write(FBEOffset, fbeVectorOffset);
2410              Write(fbeVectorOffset, (uint)size);
2411              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
2412              _model.FBEOffset = fbeVectorOffset + 4;
2413              return _model;
2414          }
2415          public virtual bool Verify()
2416          {
2417              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2418                  return true;
2419              uint fbeVectorOffset = ReadUInt32(FBEOffset);
2420              if (fbeVectorOffset == 0)
2421                  return true;
2422              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
2423                  return false;
2424              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2425              _model.FBEOffset = fbeVectorOffset + 4;
2426              for (uint i = fbeVectorSize; i-- > 0;)
2427              {
2428                  if (!_model.Verify())
2429                      return false;
2430                  _model.FBEShift(_model.FBESize);
2431              }
2432              return true;
2433          }
2434          public void Get(ref List<T> values)
2435          {
2436              Debug.Assert((values != null), "Invalid values parameter!");
2437              if (values == null)
2438                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2439              values.Clear();
2440              long fbeVectorSize = Size;
2441              if (fbeVectorSize == 0)
2442                  return;
2443              values.Capacity = (int)fbeVectorSize;
2444              var fbeModel = this[0];
2445              for (long i = fbeVectorSize; i-- > 0;)
2446              {
2447                  fbeModel.Get(out var value);
2448                  values.Add(value);
2449                  fbeModel.FBEShift(fbeModel.FBESize);
2450              }
2451          }
2452          public void Get(ref LinkedList<T> values)
2453          {
2454              Debug.Assert((values != null), "Invalid values parameter!");
2455              if (values == null)
2456                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2457              values.Clear();
2458              long fbeVectorSize = Size;
2459              if (fbeVectorSize == 0)
2460                  return;
2461              var fbeModel = this[0];
2462              for (long i = fbeVectorSize; i-- > 0;)
2463              {
2464                  fbeModel.Get(out var value);
2465                  values.AddLast(value);
2466                  fbeModel.FBEShift(fbeModel.FBESize);
2467              }
2468          }
2469          public void Get(ref HashSet<T> values)
2470          {
2471              Debug.Assert((values != null), "Invalid values parameter!");
2472              if (values == null)
2473                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2474              values.Clear();
2475              long fbeVectorSize = Size;
2476              if (fbeVectorSize == 0)
2477                  return;
2478              var fbeModel = this[0];
2479              for (long i = fbeVectorSize; i-- > 0;)
2480              {
2481                  fbeModel.Get(out var value);
2482                  values.Add(value);
2483                  fbeModel.FBEShift(fbeModel.FBESize);
2484              }
2485          }
2486          public void Set(List<T> values)
2487          {
2488              Debug.Assert((values != null), "Invalid values parameter!");
2489              if (values == null)
2490                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2491              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2492              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2493                  return;
2494              var fbeModel = Resize(values.Count);
2495              foreach (var value in values)
2496              {
2497                  fbeModel.Set(value);
2498                  fbeModel.FBEShift(fbeModel.FBESize);
2499              }
2500          }
2501          public void Set(LinkedList<T> values)
2502          {
2503              Debug.Assert((values != null), "Invalid values parameter!");
2504              if (values == null)
2505                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2506              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2507              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2508                  return;
2509              var fbeModel = Resize(values.Count);
2510              foreach (var value in values)
2511              {
2512                  fbeModel.Set(value);
2513                  fbeModel.FBEShift(fbeModel.FBESize);
2514              }
2515          }
2516          public void Set(HashSet<T> values)
2517          {
2518              Debug.Assert((values != null), "Invalid values parameter!");
2519              if (values == null)
2520                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2521              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2522              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2523                  return;
2524              var fbeModel = Resize(values.Count);
2525              foreach (var value in values)
2526              {
2527                  fbeModel.Set(value);
2528                  fbeModel.FBEShift(fbeModel.FBESize);
2529              }
2530          }
2531      }
2532      public class FieldModelMapValueTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
2533          where TKey : struct
2534          where TKeyModel : FieldModelValueType<TKey>
2535          where TValue : struct
2536          where TValueModel : FieldModelValueType<TValue>
2537      {
2538          private readonly TKeyModel _modelKey;
2539          private readonly TValueModel _modelValue;
2540          public FieldModelMapValueTypeKeyValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
2541          {
2542              _modelKey = modelKey.Clone() as TKeyModel;
2543              _modelValue = modelValue.Clone() as TValueModel;
2544          }
2545          public override long FBESize => 4;
2546          public override long FBEExtra
2547          {
2548              get
2549              {
2550                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2551                      return 0;
2552                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2553                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2554                      return 0;
2555                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2556                  long fbeResult = 4;
2557                  _modelKey.FBEOffset = fbeMapOffset + 4;
2558                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2559                  for (uint i = fbeMapSize; i-- > 0;)
2560                  {
2561                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
2562                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2563                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
2564                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2565                  }
2566                  return fbeResult;
2567              }
2568          }
2569          public FieldModelMapValueTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
2570          public long Offset
2571          {
2572              get
2573              {
2574                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2575                      return 0;
2576                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2577                  return fbeMapOffset;
2578              }
2579          }
2580          public long Size
2581          {
2582              get
2583              {
2584                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2585                      return 0;
2586                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2587                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2588                      return 0;
2589                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2590                  return fbeMapSize;
2591              }
2592          }
2593          public KeyValuePair<TKeyModel, TValueModel> this[long index]
2594          {
2595              get
2596              {
2597                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2598                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2599                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2600                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2601                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
2602                  _modelKey.FBEOffset = fbeMapOffset + 4;
2603                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2604                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2605                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2606                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2607              }
2608          }
2609          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
2610          {
2611              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
2612              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
2613              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2614              Write(FBEOffset, fbeMapOffset);
2615              Write(fbeMapOffset, (uint)size);
2616              Write(fbeMapOffset + 4, 0, fbeMapSize);
2617              _modelKey.FBEOffset = fbeMapOffset + 4;
2618              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2619              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2620          }
2621          public virtual bool Verify()
2622          {
2623              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2624                  return true;
2625              uint fbeMapOffset = ReadUInt32(FBEOffset);
2626              if (fbeMapOffset == 0)
2627                  return true;
2628              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
2629                  return false;
2630              uint fbeMapSize = ReadUInt32(fbeMapOffset);
2631              _modelKey.FBEOffset = fbeMapOffset + 4;
2632              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2633              for (uint i = fbeMapSize; i-- > 0;)
2634              {
2635                  if (!_modelKey.Verify())
2636                      return false;
2637                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2638                  if (!_modelValue.Verify())
2639                      return false;
2640                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2641              }
2642              return true;
2643          }
2644          public void Get(ref Dictionary<TKey, TValue> values)
2645          {
2646              Debug.Assert((values != null), "Invalid values parameter!");
2647              if (values == null)
2648                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2649              values.Clear();
2650              long fbeMapSize = Size;
2651              if (fbeMapSize == 0)
2652                  return;
2653              var fbeModel = this[0];
2654              for (long i = fbeMapSize; i-- > 0;)
2655              {
2656                  fbeModel.Key.Get(out var key);
2657                  fbeModel.Value.Get(out var value);
2658                  values.Add(key, value);
2659                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2660                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2661              }
2662          }
2663          public void Get(ref SortedDictionary<TKey, TValue> values)
2664          {
2665              Debug.Assert((values != null), "Invalid values parameter!");
2666              if (values == null)
2667                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2668              values.Clear();
2669              long fbeMapSize = Size;
2670              if (fbeMapSize == 0)
2671                  return;
2672              var fbeModel = this[0];
2673              for (long i = fbeMapSize; i-- > 0;)
2674              {
2675                  fbeModel.Key.Get(out var key);
2676                  fbeModel.Value.Get(out var value);
2677                  values.Add(key, value);
2678                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2679                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2680              }
2681          }
2682          public void Set(Dictionary<TKey, TValue> values)
2683          {
2684              Debug.Assert((values != null), "Invalid values parameter!");
2685              if (values == null)
2686                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2687              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2688              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2689                  return;
2690              var fbeModel = Resize(values.Count);
2691              foreach (var value in values)
2692              {
2693                  fbeModel.Key.Set(value.Key);
2694                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2695                  fbeModel.Value.Set(value.Value);
2696                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2697              }
2698          }
2699          public void Set(SortedDictionary<TKey, TValue> values)
2700          {
2701              Debug.Assert((values != null), "Invalid values parameter!");
2702              if (values == null)
2703                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2704              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2705              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2706                  return;
2707              var fbeModel = Resize(values.Count);
2708              foreach (var value in values)
2709              {
2710                  fbeModel.Key.Set(value.Key);
2711                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2712                  fbeModel.Value.Set(value.Value);
2713                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2714              }
2715          }
2716      }
2717      public class FieldModelMapValueTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
2718          where TKey : struct
2719          where TKeyModel : FieldModelValueType<TKey>
2720          where TValue : class
2721          where TValueModel : FieldModelReferenceType<TValue>
2722      {
2723          private readonly TKeyModel _modelKey;
2724          private readonly TValueModel _modelValue;
2725          public FieldModelMapValueTypeKeyReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
2726          {
2727              _modelKey = modelKey.Clone() as TKeyModel;
2728              _modelValue = modelValue.Clone() as TValueModel;
2729          }
2730          public override long FBESize => 4;
2731          public override long FBEExtra
2732          {
2733              get
2734              {
2735                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2736                      return 0;
2737                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2738                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2739                      return 0;
2740                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2741                  long fbeResult = 4;
2742                  _modelKey.FBEOffset = fbeMapOffset + 4;
2743                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2744                  for (uint i = fbeMapSize; i-- > 0;)
2745                  {
2746                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
2747                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2748                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
2749                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2750                  }
2751                  return fbeResult;
2752              }
2753          }
2754          public FieldModelMapValueTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
2755          public long Offset
2756          {
2757              get
2758              {
2759                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2760                      return 0;
2761                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2762                  return fbeMapOffset;
2763              }
2764          }
2765          public long Size
2766          {
2767              get
2768              {
2769                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2770                      return 0;
2771                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2772                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2773                      return 0;
2774                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2775                  return fbeMapSize;
2776              }
2777          }
2778          public KeyValuePair<TKeyModel, TValueModel> this[long index]
2779          {
2780              get
2781              {
2782                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2783                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2784                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2785                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2786                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
2787                  _modelKey.FBEOffset = fbeMapOffset + 4;
2788                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2789                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2790                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2791                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2792              }
2793          }
2794          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
2795          {
2796              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
2797              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
2798              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2799              Write(FBEOffset, fbeMapOffset);
2800              Write(fbeMapOffset, (uint)size);
2801              Write(fbeMapOffset + 4, 0, fbeMapSize);
2802              _modelKey.FBEOffset = fbeMapOffset + 4;
2803              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2804              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2805          }
2806          public virtual bool Verify()
2807          {
2808              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2809                  return true;
2810              uint fbeMapOffset = ReadUInt32(FBEOffset);
2811              if (fbeMapOffset == 0)
2812                  return true;
2813              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
2814                  return false;
2815              uint fbeMapSize = ReadUInt32(fbeMapOffset);
2816              _modelKey.FBEOffset = fbeMapOffset + 4;
2817              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2818              for (uint i = fbeMapSize; i-- > 0;)
2819              {
2820                  if (!_modelKey.Verify())
2821                      return false;
2822                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2823                  if (!_modelValue.Verify())
2824                      return false;
2825                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2826              }
2827              return true;
2828          }
2829          public void Get(ref Dictionary<TKey, TValue> values)
2830          {
2831              Debug.Assert((values != null), "Invalid values parameter!");
2832              if (values == null)
2833                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2834              values.Clear();
2835              long fbeMapSize = Size;
2836              if (fbeMapSize == 0)
2837                  return;
2838              var fbeModel = this[0];
2839              for (long i = fbeMapSize; i-- > 0;)
2840              {
2841                  fbeModel.Key.Get(out var key);
2842                  fbeModel.Value.Get(out var value);
2843                  values.Add(key, value);
2844                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2845                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2846              }
2847          }
2848          public void Get(ref SortedDictionary<TKey, TValue> values)
2849          {
2850              Debug.Assert((values != null), "Invalid values parameter!");
2851              if (values == null)
2852                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2853              values.Clear();
2854              long fbeMapSize = Size;
2855              if (fbeMapSize == 0)
2856                  return;
2857              var fbeModel = this[0];
2858              for (long i = fbeMapSize; i-- > 0;)
2859              {
2860                  fbeModel.Key.Get(out var key);
2861                  fbeModel.Value.Get(out var value);
2862                  values.Add(key, value);
2863                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2864                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2865              }
2866          }
2867          public void Set(Dictionary<TKey, TValue> values)
2868          {
2869              Debug.Assert((values != null), "Invalid values parameter!");
2870              if (values == null)
2871                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2872              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2873              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2874                  return;
2875              var fbeModel = Resize(values.Count);
2876              foreach (var value in values)
2877              {
2878                  fbeModel.Key.Set(value.Key);
2879                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2880                  fbeModel.Value.Set(value.Value);
2881                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2882              }
2883          }
2884          public void Set(SortedDictionary<TKey, TValue> values)
2885          {
2886              Debug.Assert((values != null), "Invalid values parameter!");
2887              if (values == null)
2888                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2889              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2890              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2891                  return;
2892              var fbeModel = Resize(values.Count);
2893              foreach (var value in values)
2894              {
2895                  fbeModel.Key.Set(value.Key);
2896                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2897                  fbeModel.Value.Set(value.Value);
2898                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2899              }
2900          }
2901      }
2902      public class FieldModelMapValueTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
2903          where TKey : struct
2904          where TKeyModel : FieldModelValueType<TKey>
2905          where TValue : struct
2906          where TValueModel : FieldModelValueType<TValue>
2907      {
2908          private readonly TKeyModel _modelKey;
2909          private readonly FieldModelOptionalValueType<TValue, TValueModel> _modelValue;
2910          public FieldModelMapValueTypeKeyOptionalValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
2911          {
2912              _modelKey = modelKey.Clone() as TKeyModel;
2913              _modelValue = new FieldModelOptionalValueType<TValue, TValueModel>(modelValue, buffer, offset);
2914          }
2915          public override long FBESize => 4;
2916          public override long FBEExtra
2917          {
2918              get
2919              {
2920                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2921                      return 0;
2922                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2923                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2924                      return 0;
2925                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2926                  long fbeResult = 4;
2927                  _modelKey.FBEOffset = fbeMapOffset + 4;
2928                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2929                  for (uint i = fbeMapSize; i-- > 0;)
2930                  {
2931                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
2932                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2933                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
2934                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2935                  }
2936                  return fbeResult;
2937              }
2938          }
2939          public FieldModelMapValueTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
2940          public long Offset
2941          {
2942              get
2943              {
2944                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2945                      return 0;
2946                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2947                  return fbeMapOffset;
2948              }
2949          }
2950          public long Size
2951          {
2952              get
2953              {
2954                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2955                      return 0;
2956                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2957                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2958                      return 0;
2959                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2960                  return fbeMapSize;
2961              }
2962          }
2963          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> this[long index]
2964          {
2965              get
2966              {
2967                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2968                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2969                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2970                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2971                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
2972                  _modelKey.FBEOffset = fbeMapOffset + 4;
2973                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2974                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2975                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2976                  return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
2977              }
2978          }
2979          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> Resize(long size)
2980          {
2981              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
2982              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
2983              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2984              Write(FBEOffset, fbeMapOffset);
2985              Write(fbeMapOffset, (uint)size);
2986              Write(fbeMapOffset + 4, 0, fbeMapSize);
2987              _modelKey.FBEOffset = fbeMapOffset + 4;
2988              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2989              return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
2990          }
2991          public virtual bool Verify()
2992          {
2993              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2994                  return true;
2995              uint fbeMapOffset = ReadUInt32(FBEOffset);
2996              if (fbeMapOffset == 0)
2997                  return true;
2998              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
2999                  return false;
3000              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3001              _modelKey.FBEOffset = fbeMapOffset + 4;
3002              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3003              for (uint i = fbeMapSize; i-- > 0;)
3004              {
3005                  if (!_modelKey.Verify())
3006                      return false;
3007                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3008                  if (!_modelValue.Verify())
3009                      return false;
3010                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3011              }
3012              return true;
3013          }
3014          public void Get(ref Dictionary<TKey, TValue?> values)
3015          {
3016              Debug.Assert((values != null), "Invalid values parameter!");
3017              if (values == null)
3018                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3019              values.Clear();
3020              long fbeMapSize = Size;
3021              if (fbeMapSize == 0)
3022                  return;
3023              var fbeModel = this[0];
3024              for (long i = fbeMapSize; i-- > 0;)
3025              {
3026                  fbeModel.Key.Get(out var key);
3027                  fbeModel.Value.Get(out var value);
3028                  values.Add(key, value);
3029                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3030                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3031              }
3032          }
3033          public void Get(ref SortedDictionary<TKey, TValue?> values)
3034          {
3035              Debug.Assert((values != null), "Invalid values parameter!");
3036              if (values == null)
3037                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3038              values.Clear();
3039              long fbeMapSize = Size;
3040              if (fbeMapSize == 0)
3041                  return;
3042              var fbeModel = this[0];
3043              for (long i = fbeMapSize; i-- > 0;)
3044              {
3045                  fbeModel.Key.Get(out var key);
3046                  fbeModel.Value.Get(out var value);
3047                  values.Add(key, value);
3048                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3049                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3050              }
3051          }
3052          public void Set(Dictionary<TKey, TValue?> values)
3053          {
3054              Debug.Assert((values != null), "Invalid values parameter!");
3055              if (values == null)
3056                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3057              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3058              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3059                  return;
3060              var fbeModel = Resize(values.Count);
3061              foreach (var value in values)
3062              {
3063                  fbeModel.Key.Set(value.Key);
3064                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3065                  fbeModel.Value.Set(value.Value);
3066                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3067              }
3068          }
3069          public void Set(SortedDictionary<TKey, TValue?> values)
3070          {
3071              Debug.Assert((values != null), "Invalid values parameter!");
3072              if (values == null)
3073                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3074              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3075              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3076                  return;
3077              var fbeModel = Resize(values.Count);
3078              foreach (var value in values)
3079              {
3080                  fbeModel.Key.Set(value.Key);
3081                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3082                  fbeModel.Value.Set(value.Value);
3083                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3084              }
3085          }
3086      }
3087      public class FieldModelMapValueTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3088          where TKey : struct
3089          where TKeyModel : FieldModelValueType<TKey>
3090          where TValue : class
3091          where TValueModel : FieldModelReferenceType<TValue>
3092      {
3093          private readonly TKeyModel _modelKey;
3094          private readonly FieldModelOptionalReferenceType<TValue, TValueModel> _modelValue;
3095          public FieldModelMapValueTypeKeyOptionalReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3096          {
3097              _modelKey = modelKey.Clone() as TKeyModel;
3098              _modelValue = new FieldModelOptionalReferenceType<TValue, TValueModel>(modelValue, buffer, offset);
3099          }
3100          public override long FBESize => 4;
3101          public override long FBEExtra
3102          {
3103              get
3104              {
3105                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3106                      return 0;
3107                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3108                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3109                      return 0;
3110                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3111                  long fbeResult = 4;
3112                  _modelKey.FBEOffset = fbeMapOffset + 4;
3113                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3114                  for (uint i = fbeMapSize; i-- > 0;)
3115                  {
3116                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3117                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3118                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3119                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3120                  }
3121                  return fbeResult;
3122              }
3123          }
3124          public FieldModelMapValueTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
3125          public long Offset
3126          {
3127              get
3128              {
3129                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3130                      return 0;
3131                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3132                  return fbeMapOffset;
3133              }
3134          }
3135          public long Size
3136          {
3137              get
3138              {
3139                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3140                      return 0;
3141                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3142                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3143                      return 0;
3144                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3145                  return fbeMapSize;
3146              }
3147          }
3148          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> this[long index]
3149          {
3150              get
3151              {
3152                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3153                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3154                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3155                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3156                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3157                  _modelKey.FBEOffset = fbeMapOffset + 4;
3158                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3159                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3160                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3161                  return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3162              }
3163          }
3164          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> Resize(long size)
3165          {
3166              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3167              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3168              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3169              Write(FBEOffset, fbeMapOffset);
3170              Write(fbeMapOffset, (uint)size);
3171              Write(fbeMapOffset + 4, 0, fbeMapSize);
3172              _modelKey.FBEOffset = fbeMapOffset + 4;
3173              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3174              return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3175          }
3176          public virtual bool Verify()
3177          {
3178              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3179                  return true;
3180              uint fbeMapOffset = ReadUInt32(FBEOffset);
3181              if (fbeMapOffset == 0)
3182                  return true;
3183              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3184                  return false;
3185              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3186              _modelKey.FBEOffset = fbeMapOffset + 4;
3187              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3188              for (uint i = fbeMapSize; i-- > 0;)
3189              {
3190                  if (!_modelKey.Verify())
3191                      return false;
3192                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3193                  if (!_modelValue.Verify())
3194                      return false;
3195                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3196              }
3197              return true;
3198          }
3199          public void Get(ref Dictionary<TKey, TValue> values)
3200          {
3201              Debug.Assert((values != null), "Invalid values parameter!");
3202              if (values == null)
3203                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3204              values.Clear();
3205              long fbeMapSize = Size;
3206              if (fbeMapSize == 0)
3207                  return;
3208              var fbeModel = this[0];
3209              for (long i = fbeMapSize; i-- > 0;)
3210              {
3211                  fbeModel.Key.Get(out var key);
3212                  fbeModel.Value.Get(out var value);
3213                  values.Add(key, value);
3214                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3215                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3216              }
3217          }
3218          public void Get(ref SortedDictionary<TKey, TValue> values)
3219          {
3220              Debug.Assert((values != null), "Invalid values parameter!");
3221              if (values == null)
3222                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3223              values.Clear();
3224              long fbeMapSize = Size;
3225              if (fbeMapSize == 0)
3226                  return;
3227              var fbeModel = this[0];
3228              for (long i = fbeMapSize; i-- > 0;)
3229              {
3230                  fbeModel.Key.Get(out var key);
3231                  fbeModel.Value.Get(out var value);
3232                  values.Add(key, value);
3233                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3234                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3235              }
3236          }
3237          public void Set(Dictionary<TKey, TValue> values)
3238          {
3239              Debug.Assert((values != null), "Invalid values parameter!");
3240              if (values == null)
3241                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3242              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3243              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3244                  return;
3245              var fbeModel = Resize(values.Count);
3246              foreach (var value in values)
3247              {
3248                  fbeModel.Key.Set(value.Key);
3249                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3250                  fbeModel.Value.Set(value.Value);
3251                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3252              }
3253          }
3254          public void Set(SortedDictionary<TKey, TValue> values)
3255          {
3256              Debug.Assert((values != null), "Invalid values parameter!");
3257              if (values == null)
3258                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3259              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3260              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3261                  return;
3262              var fbeModel = Resize(values.Count);
3263              foreach (var value in values)
3264              {
3265                  fbeModel.Key.Set(value.Key);
3266                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3267                  fbeModel.Value.Set(value.Value);
3268                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3269              }
3270          }
3271      }
3272      public class FieldModelMapReferenceTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3273          where TKey : class
3274          where TKeyModel : FieldModelReferenceType<TKey>
3275          where TValue : struct
3276          where TValueModel : FieldModelValueType<TValue>
3277      {
3278          private readonly TKeyModel _modelKey;
3279          private readonly TValueModel _modelValue;
3280          public FieldModelMapReferenceTypeKeyValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3281          {
3282              _modelKey = modelKey.Clone() as TKeyModel;
3283              _modelValue = modelValue.Clone() as TValueModel;
3284          }
3285          public override long FBESize => 4;
3286          public override long FBEExtra
3287          {
3288              get
3289              {
3290                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3291                      return 0;
3292                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3293                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3294                      return 0;
3295                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3296                  long fbeResult = 4;
3297                  _modelKey.FBEOffset = fbeMapOffset + 4;
3298                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3299                  for (uint i = fbeMapSize; i-- > 0;)
3300                  {
3301                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3302                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3303                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3304                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3305                  }
3306                  return fbeResult;
3307              }
3308          }
3309          public FieldModelMapReferenceTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
3310          public long Offset
3311          {
3312              get
3313              {
3314                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3315                      return 0;
3316                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3317                  return fbeMapOffset;
3318              }
3319          }
3320          public long Size
3321          {
3322              get
3323              {
3324                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3325                      return 0;
3326                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3327                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3328                      return 0;
3329                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3330                  return fbeMapSize;
3331              }
3332          }
3333          public KeyValuePair<TKeyModel, TValueModel> this[long index]
3334          {
3335              get
3336              {
3337                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3338                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3339                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3340                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3341                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3342                  _modelKey.FBEOffset = fbeMapOffset + 4;
3343                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3344                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3345                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3346                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3347              }
3348          }
3349          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
3350          {
3351              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3352              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3353              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3354              Write(FBEOffset, fbeMapOffset);
3355              Write(fbeMapOffset, (uint)size);
3356              Write(fbeMapOffset + 4, 0, fbeMapSize);
3357              _modelKey.FBEOffset = fbeMapOffset + 4;
3358              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3359              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3360          }
3361          public virtual bool Verify()
3362          {
3363              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3364                  return true;
3365              uint fbeMapOffset = ReadUInt32(FBEOffset);
3366              if (fbeMapOffset == 0)
3367                  return true;
3368              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3369                  return false;
3370              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3371              _modelKey.FBEOffset = fbeMapOffset + 4;
3372              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3373              for (uint i = fbeMapSize; i-- > 0;)
3374              {
3375                  if (!_modelKey.Verify())
3376                      return false;
3377                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3378                  if (!_modelValue.Verify())
3379                      return false;
3380                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3381              }
3382              return true;
3383          }
3384          public void Get(ref Dictionary<TKey, TValue> values)
3385          {
3386              Debug.Assert((values != null), "Invalid values parameter!");
3387              if (values == null)
3388                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3389              values.Clear();
3390              long fbeMapSize = Size;
3391              if (fbeMapSize == 0)
3392                  return;
3393              var fbeModel = this[0];
3394              for (long i = fbeMapSize; i-- > 0;)
3395              {
3396                  fbeModel.Key.Get(out var key);
3397                  fbeModel.Value.Get(out var value);
3398                  values.Add(key, value);
3399                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3400                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3401              }
3402          }
3403          public void Get(ref SortedDictionary<TKey, TValue> values)
3404          {
3405              Debug.Assert((values != null), "Invalid values parameter!");
3406              if (values == null)
3407                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3408              values.Clear();
3409              long fbeMapSize = Size;
3410              if (fbeMapSize == 0)
3411                  return;
3412              var fbeModel = this[0];
3413              for (long i = fbeMapSize; i-- > 0;)
3414              {
3415                  fbeModel.Key.Get(out var key);
3416                  fbeModel.Value.Get(out var value);
3417                  values.Add(key, value);
3418                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3419                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3420              }
3421          }
3422          public void Set(Dictionary<TKey, TValue> values)
3423          {
3424              Debug.Assert((values != null), "Invalid values parameter!");
3425              if (values == null)
3426                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3427              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3428              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3429                  return;
3430              var fbeModel = Resize(values.Count);
3431              foreach (var value in values)
3432              {
3433                  fbeModel.Key.Set(value.Key);
3434                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3435                  fbeModel.Value.Set(value.Value);
3436                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3437              }
3438          }
3439          public void Set(SortedDictionary<TKey, TValue> values)
3440          {
3441              Debug.Assert((values != null), "Invalid values parameter!");
3442              if (values == null)
3443                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3444              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3445              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3446                  return;
3447              var fbeModel = Resize(values.Count);
3448              foreach (var value in values)
3449              {
3450                  fbeModel.Key.Set(value.Key);
3451                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3452                  fbeModel.Value.Set(value.Value);
3453                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3454              }
3455          }
3456      }
3457      public class FieldModelMapReferenceTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3458          where TKey : class
3459          where TKeyModel : FieldModelReferenceType<TKey>
3460          where TValue : class
3461          where TValueModel : FieldModelReferenceType<TValue>
3462      {
3463          private readonly TKeyModel _modelKey;
3464          private readonly TValueModel _modelValue;
3465          public FieldModelMapReferenceTypeKeyReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3466          {
3467              _modelKey = modelKey.Clone() as TKeyModel;
3468              _modelValue = modelValue.Clone() as TValueModel;
3469          }
3470          public override long FBESize => 4;
3471          public override long FBEExtra
3472          {
3473              get
3474              {
3475                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3476                      return 0;
3477                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3478                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3479                      return 0;
3480                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3481                  long fbeResult = 4;
3482                  _modelKey.FBEOffset = fbeMapOffset + 4;
3483                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3484                  for (uint i = fbeMapSize; i-- > 0;)
3485                  {
3486                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3487                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3488                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3489                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3490                  }
3491                  return fbeResult;
3492              }
3493          }
3494          public FieldModelMapReferenceTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
3495          public long Offset
3496          {
3497              get
3498              {
3499                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3500                      return 0;
3501                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3502                  return fbeMapOffset;
3503              }
3504          }
3505          public long Size
3506          {
3507              get
3508              {
3509                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3510                      return 0;
3511                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3512                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3513                      return 0;
3514                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3515                  return fbeMapSize;
3516              }
3517          }
3518          public KeyValuePair<TKeyModel, TValueModel> this[long index]
3519          {
3520              get
3521              {
3522                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3523                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3524                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3525                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3526                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3527                  _modelKey.FBEOffset = fbeMapOffset + 4;
3528                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3529                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3530                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3531                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3532              }
3533          }
3534          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
3535          {
3536              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3537              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3538              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3539              Write(FBEOffset, fbeMapOffset);
3540              Write(fbeMapOffset, (uint)size);
3541              Write(fbeMapOffset + 4, 0, fbeMapSize);
3542              _modelKey.FBEOffset = fbeMapOffset + 4;
3543              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3544              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3545          }
3546          public virtual bool Verify()
3547          {
3548              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3549                  return true;
3550              uint fbeMapOffset = ReadUInt32(FBEOffset);
3551              if (fbeMapOffset == 0)
3552                  return true;
3553              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3554                  return false;
3555              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3556              _modelKey.FBEOffset = fbeMapOffset + 4;
3557              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3558              for (uint i = fbeMapSize; i-- > 0;)
3559              {
3560                  if (!_modelKey.Verify())
3561                      return false;
3562                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3563                  if (!_modelValue.Verify())
3564                      return false;
3565                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3566              }
3567              return true;
3568          }
3569          public void Get(ref Dictionary<TKey, TValue> values)
3570          {
3571              Debug.Assert((values != null), "Invalid values parameter!");
3572              if (values == null)
3573                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3574              values.Clear();
3575              long fbeMapSize = Size;
3576              if (fbeMapSize == 0)
3577                  return;
3578              var fbeModel = this[0];
3579              for (long i = fbeMapSize; i-- > 0;)
3580              {
3581                  fbeModel.Key.Get(out var key);
3582                  fbeModel.Value.Get(out var value);
3583                  values.Add(key, value);
3584                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3585                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3586              }
3587          }
3588          public void Get(ref SortedDictionary<TKey, TValue> values)
3589          {
3590              Debug.Assert((values != null), "Invalid values parameter!");
3591              if (values == null)
3592                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3593              values.Clear();
3594              long fbeMapSize = Size;
3595              if (fbeMapSize == 0)
3596                  return;
3597              var fbeModel = this[0];
3598              for (long i = fbeMapSize; i-- > 0;)
3599              {
3600                  fbeModel.Key.Get(out var key);
3601                  fbeModel.Value.Get(out var value);
3602                  values.Add(key, value);
3603                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3604                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3605              }
3606          }
3607          public void Set(Dictionary<TKey, TValue> values)
3608          {
3609              Debug.Assert((values != null), "Invalid values parameter!");
3610              if (values == null)
3611                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3612              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3613              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3614                  return;
3615              var fbeModel = Resize(values.Count);
3616              foreach (var value in values)
3617              {
3618                  fbeModel.Key.Set(value.Key);
3619                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3620                  fbeModel.Value.Set(value.Value);
3621                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3622              }
3623          }
3624          public void Set(SortedDictionary<TKey, TValue> values)
3625          {
3626              Debug.Assert((values != null), "Invalid values parameter!");
3627              if (values == null)
3628                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3629              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3630              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3631                  return;
3632              var fbeModel = Resize(values.Count);
3633              foreach (var value in values)
3634              {
3635                  fbeModel.Key.Set(value.Key);
3636                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3637                  fbeModel.Value.Set(value.Value);
3638                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3639              }
3640          }
3641      }
3642      public class FieldModelMapReferenceTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3643          where TKey : class
3644          where TKeyModel : FieldModelReferenceType<TKey>
3645          where TValue : struct
3646          where TValueModel : FieldModelValueType<TValue>
3647      {
3648          private readonly TKeyModel _modelKey;
3649          private readonly FieldModelOptionalValueType<TValue, TValueModel> _modelValue;
3650          public FieldModelMapReferenceTypeKeyOptionalValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3651          {
3652              _modelKey = modelKey.Clone() as TKeyModel;
3653              _modelValue = new FieldModelOptionalValueType<TValue, TValueModel>(modelValue, buffer, offset);
3654          }
3655          public override long FBESize => 4;
3656          public override long FBEExtra
3657          {
3658              get
3659              {
3660                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3661                      return 0;
3662                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3663                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3664                      return 0;
3665                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3666                  long fbeResult = 4;
3667                  _modelKey.FBEOffset = fbeMapOffset + 4;
3668                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3669                  for (uint i = fbeMapSize; i-- > 0;)
3670                  {
3671                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3672                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3673                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3674                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3675                  }
3676                  return fbeResult;
3677              }
3678          }
3679          public FieldModelMapReferenceTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
3680          public long Offset
3681          {
3682              get
3683              {
3684                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3685                      return 0;
3686                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3687                  return fbeMapOffset;
3688              }
3689          }
3690          public long Size
3691          {
3692              get
3693              {
3694                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3695                      return 0;
3696                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3697                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3698                      return 0;
3699                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3700                  return fbeMapSize;
3701              }
3702          }
3703          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> this[long index]
3704          {
3705              get
3706              {
3707                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3708                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3709                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3710                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3711                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3712                  _modelKey.FBEOffset = fbeMapOffset + 4;
3713                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3714                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3715                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3716                  return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
3717              }
3718          }
3719          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> Resize(long size)
3720          {
3721              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3722              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3723              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3724              Write(FBEOffset, fbeMapOffset);
3725              Write(fbeMapOffset, (uint)size);
3726              Write(fbeMapOffset + 4, 0, fbeMapSize);
3727              _modelKey.FBEOffset = fbeMapOffset + 4;
3728              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3729              return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
3730          }
3731          public virtual bool Verify()
3732          {
3733              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3734                  return true;
3735              uint fbeMapOffset = ReadUInt32(FBEOffset);
3736              if (fbeMapOffset == 0)
3737                  return true;
3738              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3739                  return false;
3740              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3741              _modelKey.FBEOffset = fbeMapOffset + 4;
3742              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3743              for (uint i = fbeMapSize; i-- > 0;)
3744              {
3745                  if (!_modelKey.Verify())
3746                      return false;
3747                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3748                  if (!_modelValue.Verify())
3749                      return false;
3750                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3751              }
3752              return true;
3753          }
3754          public void Get(ref Dictionary<TKey, TValue?> values)
3755          {
3756              Debug.Assert((values != null), "Invalid values parameter!");
3757              if (values == null)
3758                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3759              values.Clear();
3760              long fbeMapSize = Size;
3761              if (fbeMapSize == 0)
3762                  return;
3763              var fbeModel = this[0];
3764              for (long i = fbeMapSize; i-- > 0;)
3765              {
3766                  fbeModel.Key.Get(out var key);
3767                  fbeModel.Value.Get(out var value);
3768                  values.Add(key, value);
3769                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3770                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3771              }
3772          }
3773          public void Get(ref SortedDictionary<TKey, TValue?> values)
3774          {
3775              Debug.Assert((values != null), "Invalid values parameter!");
3776              if (values == null)
3777                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3778              values.Clear();
3779              long fbeMapSize = Size;
3780              if (fbeMapSize == 0)
3781                  return;
3782              var fbeModel = this[0];
3783              for (long i = fbeMapSize; i-- > 0;)
3784              {
3785                  fbeModel.Key.Get(out var key);
3786                  fbeModel.Value.Get(out var value);
3787                  values.Add(key, value);
3788                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3789                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3790              }
3791          }
3792          public void Set(Dictionary<TKey, TValue?> values)
3793          {
3794              Debug.Assert((values != null), "Invalid values parameter!");
3795              if (values == null)
3796                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3797              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3798              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3799                  return;
3800              var fbeModel = Resize(values.Count);
3801              foreach (var value in values)
3802              {
3803                  fbeModel.Key.Set(value.Key);
3804                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3805                  fbeModel.Value.Set(value.Value);
3806                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3807              }
3808          }
3809          public void Set(SortedDictionary<TKey, TValue?> values)
3810          {
3811              Debug.Assert((values != null), "Invalid values parameter!");
3812              if (values == null)
3813                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3814              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3815              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3816                  return;
3817              var fbeModel = Resize(values.Count);
3818              foreach (var value in values)
3819              {
3820                  fbeModel.Key.Set(value.Key);
3821                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3822                  fbeModel.Value.Set(value.Value);
3823                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3824              }
3825          }
3826      }
3827      public class FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3828          where TKey : class
3829          where TKeyModel : FieldModelReferenceType<TKey>
3830          where TValue : class
3831          where TValueModel : FieldModelReferenceType<TValue>
3832      {
3833          private readonly TKeyModel _modelKey;
3834          private readonly FieldModelOptionalReferenceType<TValue, TValueModel> _modelValue;
3835          public FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3836          {
3837              _modelKey = modelKey.Clone() as TKeyModel;
3838              _modelValue = new FieldModelOptionalReferenceType<TValue, TValueModel>(modelValue, buffer, offset);
3839          }
3840          public override long FBESize => 4;
3841          public override long FBEExtra
3842          {
3843              get
3844              {
3845                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3846                      return 0;
3847                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3848                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3849                      return 0;
3850                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3851                  long fbeResult = 4;
3852                  _modelKey.FBEOffset = fbeMapOffset + 4;
3853                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3854                  for (uint i = fbeMapSize; i-- > 0;)
3855                  {
3856                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3857                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3858                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3859                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3860                  }
3861                  return fbeResult;
3862              }
3863          }
3864          public FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
3865          public long Offset
3866          {
3867              get
3868              {
3869                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3870                      return 0;
3871                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3872                  return fbeMapOffset;
3873              }
3874          }
3875          public long Size
3876          {
3877              get
3878              {
3879                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3880                      return 0;
3881                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3882                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3883                      return 0;
3884                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3885                  return fbeMapSize;
3886              }
3887          }
3888          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> this[long index]
3889          {
3890              get
3891              {
3892                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3893                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3894                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3895                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3896                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3897                  _modelKey.FBEOffset = fbeMapOffset + 4;
3898                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3899                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3900                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3901                  return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3902              }
3903          }
3904          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> Resize(long size)
3905          {
3906              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3907              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3908              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3909              Write(FBEOffset, fbeMapOffset);
3910              Write(fbeMapOffset, (uint)size);
3911              Write(fbeMapOffset + 4, 0, fbeMapSize);
3912              _modelKey.FBEOffset = fbeMapOffset + 4;
3913              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3914              return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3915          }
3916          public virtual bool Verify()
3917          {
3918              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3919                  return true;
3920              uint fbeMapOffset = ReadUInt32(FBEOffset);
3921              if (fbeMapOffset == 0)
3922                  return true;
3923              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3924                  return false;
3925              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3926              _modelKey.FBEOffset = fbeMapOffset + 4;
3927              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3928              for (uint i = fbeMapSize; i-- > 0;)
3929              {
3930                  if (!_modelKey.Verify())
3931                      return false;
3932                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3933                  if (!_modelValue.Verify())
3934                      return false;
3935                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3936              }
3937              return true;
3938          }
3939          public void Get(ref Dictionary<TKey, TValue> values)
3940          {
3941              Debug.Assert((values != null), "Invalid values parameter!");
3942              if (values == null)
3943                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3944              values.Clear();
3945              long fbeMapSize = Size;
3946              if (fbeMapSize == 0)
3947                  return;
3948              var fbeModel = this[0];
3949              for (long i = fbeMapSize; i-- > 0;)
3950              {
3951                  fbeModel.Key.Get(out var key);
3952                  fbeModel.Value.Get(out var value);
3953                  values.Add(key, value);
3954                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3955                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3956              }
3957          }
3958          public void Get(ref SortedDictionary<TKey, TValue> values)
3959          {
3960              Debug.Assert((values != null), "Invalid values parameter!");
3961              if (values == null)
3962                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3963              values.Clear();
3964              long fbeMapSize = Size;
3965              if (fbeMapSize == 0)
3966                  return;
3967              var fbeModel = this[0];
3968              for (long i = fbeMapSize; i-- > 0;)
3969              {
3970                  fbeModel.Key.Get(out var key);
3971                  fbeModel.Value.Get(out var value);
3972                  values.Add(key, value);
3973                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3974                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3975              }
3976          }
3977          public void Set(Dictionary<TKey, TValue> values)
3978          {
3979              Debug.Assert((values != null), "Invalid values parameter!");
3980              if (values == null)
3981                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3982              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3983              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3984                  return;
3985              var fbeModel = Resize(values.Count);
3986              foreach (var value in values)
3987              {
3988                  fbeModel.Key.Set(value.Key);
3989                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3990                  fbeModel.Value.Set(value.Value);
3991                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3992              }
3993          }
3994          public void Set(SortedDictionary<TKey, TValue> values)
3995          {
3996              Debug.Assert((values != null), "Invalid values parameter!");
3997              if (values == null)
3998                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3999              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
4000              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
4001                  return;
4002              var fbeModel = Resize(values.Count);
4003              foreach (var value in values)
4004              {
4005                  fbeModel.Key.Set(value.Key);
4006                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
4007                  fbeModel.Value.Set(value.Value);
4008                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
4009              }
4010          }
4011      }
4012      public interface ISenderListener
4013      {
4014          long OnSend(byte[] buffer, long offset, long size) { return size; }
4015          void OnSendLog(string message) {}
4016      }
4017      public abstract class Sender : ISenderListener
4018      {
4019          public Buffer Buffer { get; }
4020          public bool Logging { get; set; }
4021          public bool Final { get; }
4022          protected Sender(bool final) { Buffer = new Buffer(); Final = final; }
4023          protected Sender(Buffer buffer, bool final) { Buffer = buffer; Final = final; }
4024          public void Reset() { Buffer.Reset(); }
4025          public long SendSerialized(ISenderListener listener, long serialized)
4026          {
4027              Debug.Assert((serialized > 0), "Invalid size of the serialized buffer!");
4028              if (serialized == 0)
4029                  return 0;
4030              Buffer.Shift(serialized);
4031              long sent = listener.OnSend(Buffer.Data, 0, Buffer.Size);
4032              Buffer.Remove(0, sent);
4033              return sent;
4034          }
4035      }
4036      public interface IReceiverListener
4037      {
4038          void OnReceiveLog(string message) {}
4039      }
4040      public abstract class Receiver : IReceiverListener
4041      {
4042          public Buffer Buffer { get; private set; }
4043          public bool Logging { get; set; }
4044          public bool Final { get; }
4045          protected Receiver(bool final) { Buffer = new Buffer(); Final = final; }
4046          protected Receiver(Buffer buffer, bool final) { Buffer = buffer; Final = final; }
4047          public void Reset() { Buffer.Reset(); }
4048          public void Receive(Buffer buffer) { Receive(buffer.Data, 0, buffer.Size); }
4049          public void Receive(byte[] buffer) { Receive(buffer, 0, buffer.Length); }
4050          public void Receive(byte[] buffer, long offset, long size)
4051          {
4052              Debug.Assert((buffer != null), "Invalid buffer!");
4053              if (buffer == null)
4054                  throw new ArgumentException("Invalid buffer!", nameof(buffer));
4055              Debug.Assert(((offset + size) <= buffer.Length), "Invalid offset & size!");
4056              if ((offset + size) > buffer.Length)
4057                  throw new ArgumentException("Invalid offset & size!", nameof(offset));
4058              if (size == 0)
4059                  return;
4060              long offset0 = Buffer.Offset;
4061              long offset1 = Buffer.Size;
4062              long size1 = Buffer.Size;
4063              long offset2 = 0;
4064              long size2 = size;
4065              while (offset2 < size2)
4066              {
4067                  byte[] messageBuffer = null;
4068                  long messageOffset = 0;
4069                  long messageSize = 0;
4070                  bool messageSizeCopied = false;
4071                  bool messageSizeFound = false;
4072                  while (!messageSizeFound)
4073                  {
4074                      if (offset0 < size1)
4075                      {
4076                          long count = Math.Min(size1 - offset0, 4);
4077                          if (count == 4)
4078                          {
4079                              messageSizeCopied = true;
4080                              messageSizeFound = true;
4081                              messageSize = Buffer.ReadUInt32(Buffer.Data, offset0);
4082                              offset0 += 4;
4083                              break;
4084                          }
4085                          else
4086                          {
4087                              if (offset2 < size2)
4088                              {
4089                                  count = Math.Min(size2 - offset2, 4 - count);
4090                                  Buffer.Allocate(count);
4091                                  size1 += count;
4092                                  Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4093                                  offset1 += count;
4094                                  offset2 += count;
4095                                  continue;
4096                              }
4097                              else
4098                                  break;
4099                          }
4100                      }
4101                      if (offset2 < size2)
4102                      {
4103                          long count = Math.Min(size2 - offset2, 4);
4104                          if (count == 4)
4105                          {
4106                              messageSizeFound = true;
4107                              messageSize = Buffer.ReadUInt32(buffer, offset + offset2);
4108                              offset2 += 4;
4109                              break;
4110                          }
4111                          else
4112                          {
4113                              Buffer.Allocate(count);
4114                              size1 += count;
4115                              Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4116                              offset1 += count;
4117                              offset2 += count;
4118                              continue;
4119                          }
4120                      }
4121                      else
4122                          break;
4123                  }
4124                  if (!messageSizeFound)
4125                      return;
4126                  long minSize = Final ? (4 + 4) : (4 + 4 + 4 + 4);
4127                  Debug.Assert((messageSize >= minSize), "Invalid receive data!");
4128                  if (messageSize < minSize)
4129                      return;
4130                  bool messageFound = false;
4131                  while (!messageFound)
4132                  {
4133                      if (offset0 < size1)
4134                      {
4135                          long count = Math.Min(size1 - offset0, messageSize - 4);
4136                          if (count == (messageSize - 4))
4137                          {
4138                              messageFound = true;
4139                              messageBuffer = Buffer.Data;
4140                              messageOffset = offset0 - 4;
4141                              offset0 += messageSize - 4;
4142                              break;
4143                          }
4144                          else
4145                          {
4146                              if (offset2 < size2)
4147                              {
4148                                  if (!messageSizeCopied)
4149                                  {
4150                                      Buffer.Allocate(4);
4151                                      size1 += 4;
4152                                      Buffer.Write(Buffer.Data, offset0, (uint)messageSize);
4153                                      offset0 += 4;
4154                                      offset1 += 4;
4155                                      messageSizeCopied = true;
4156                                  }
4157                                  count = Math.Min(size2 - offset2, messageSize - 4 - count);
4158                                  Buffer.Allocate(count);
4159                                  size1 += count;
4160                                  Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4161                                  offset1 += count;
4162                                  offset2 += count;
4163                                  continue;
4164                              }
4165                              else
4166                                  break;
4167                          }
4168                      }
4169                      if (offset2 < size2)
4170                      {
4171                          long count = Math.Min(size2 - offset2, messageSize - 4);
4172                          if (!messageSizeCopied && (count == (messageSize - 4)))
4173                          {
4174                              messageFound = true;
4175                              messageBuffer = buffer;
4176                              messageOffset = offset + offset2 - 4;
4177                              offset2 += messageSize - 4;
4178                              break;
4179                          }
4180                          else
4181                          {
4182                              if (!messageSizeCopied)
4183                              {
4184                                  Buffer.Allocate(4);
4185                                  size1 += 4;
4186                                  Buffer.Write(Buffer.Data, offset0, (uint)messageSize);
4187                                  offset0 += 4;
4188                                  offset1 += 4;
4189                                  messageSizeCopied = true;
4190                              }
4191                              Buffer.Allocate(count);
4192                              size1 += count;
4193                              Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4194                              offset1 += count;
4195                              offset2 += count;
4196                              continue;
4197                          }
4198                      }
4199                      else
4200                          break;
4201                  }
4202                  if (!messageFound)
4203                  {
4204                      if (!messageSizeCopied)
4205                      {
4206                          Buffer.Allocate(4);
4207                          size1 += 4;
4208                          Buffer.Write(Buffer.Data, offset0, (uint)messageSize);
4209                          offset0 += 4;
4210                          offset1 += 4;
4211                          messageSizeCopied = true;
4212                      }
4213                      return;
4214                  }
4215                  uint fbeStructSize;
4216                  uint fbeStructType;
4217                  if (Final)
4218                  {
4219                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset);
4220                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4221                  }
4222                  else
4223                  {
4224                      uint fbeStructOffset = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4225                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset);
4226                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset + 4);
4227                  }
4228                  OnReceive(fbeStructType, messageBuffer, messageOffset, messageSize);
4229                  Buffer.Reset();
4230                  offset0 = Buffer.Offset;
4231                  offset1 = Buffer.Size;
4232                  size1 = Buffer.Size;
4233              }
4234          }
4235          internal abstract bool OnReceive(long type, byte[] buffer, long offset, long size);
4236      }
4237      public interface IClientListener : ISenderListener, IReceiverListener
4238      {
4239      }
4240      public abstract class Client : IClientListener
4241      {
4242          public Buffer SendBuffer { get; }
4243          public Buffer ReceiveBuffer { get; }
4244          public bool Logging { get; set; }
4245          public bool Final { get; }
4246          protected Mutex Lock { get; }
4247          protected DateTime Timestamp { get; set; }
4248          protected Client(bool final) : this(new Buffer(), new Buffer(), final) {}
4249          protected Client(Buffer sendBuffer, Buffer receiveBuffer, bool final) { SendBuffer = sendBuffer; ReceiveBuffer = receiveBuffer; Final = final; Lock = new Mutex(); Timestamp = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc); }
4250          public void Reset()
4251          {
4252              lock (Lock)
4253              {
4254                  ResetRequests();
4255              }
4256          }
4257          internal virtual void ResetRequests()
4258          {
4259              SendBuffer.Reset();
4260              ReceiveBuffer.Reset();
4261          }
4262          public void Watchdog(DateTime utc)
4263          {
4264              lock (Lock)
4265              {
4266                  WatchdogRequests(utc);
4267              }
4268          }
4269          internal virtual void WatchdogRequests(DateTime utc)
4270          {
4271          }
4272          public long SendSerialized(ISenderListener listener, long serialized)
4273          {
4274              Debug.Assert((serialized > 0), "Invalid size of the serialized buffer!");
4275              if (serialized == 0)
4276                  return 0;
4277              SendBuffer.Shift(serialized);
4278              long sent = listener.OnSend(SendBuffer.Data, 0, SendBuffer.Size);
4279              SendBuffer.Remove(0, sent);
4280              return sent;
4281          }
4282          public void Receive(Buffer buffer) { Receive(buffer.Data, 0, buffer.Size); }
4283          public void Receive(byte[] buffer) { Receive(buffer, 0, buffer.Length); }
4284          public void Receive(byte[] buffer, long offset, long size)
4285          {
4286              Debug.Assert((buffer != null), "Invalid buffer!");
4287              if (buffer == null)
4288                  throw new ArgumentException("Invalid buffer!", nameof(buffer));
4289              Debug.Assert(((offset + size) <= buffer.Length), "Invalid offset & size!");
4290              if ((offset + size) > buffer.Length)
4291                  throw new ArgumentException("Invalid offset & size!", nameof(offset));
4292              if (size == 0)
4293                  return;
4294              long offset0 = ReceiveBuffer.Offset;
4295              long offset1 = ReceiveBuffer.Size;
4296              long size1 = ReceiveBuffer.Size;
4297              long offset2 = 0;
4298              long size2 = size;
4299              while (offset2 < size2)
4300              {
4301                  byte[] messageBuffer = null;
4302                  long messageOffset = 0;
4303                  long messageSize = 0;
4304                  bool messageSizeCopied = false;
4305                  bool messageSizeFound = false;
4306                  while (!messageSizeFound)
4307                  {
4308                      if (offset0 < size1)
4309                      {
4310                          long count = Math.Min(size1 - offset0, 4);
4311                          if (count == 4)
4312                          {
4313                              messageSizeCopied = true;
4314                              messageSizeFound = true;
4315                              messageSize = Buffer.ReadUInt32(ReceiveBuffer.Data, offset0);
4316                              offset0 += 4;
4317                              break;
4318                          }
4319                          else
4320                          {
4321                              if (offset2 < size2)
4322                              {
4323                                  count = Math.Min(size2 - offset2, 4 - count);
4324                                  ReceiveBuffer.Allocate(count);
4325                                  size1 += count;
4326                                  Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4327                                  offset1 += count;
4328                                  offset2 += count;
4329                                  continue;
4330                              }
4331                              else
4332                                  break;
4333                          }
4334                      }
4335                      if (offset2 < size2)
4336                      {
4337                          long count = Math.Min(size2 - offset2, 4);
4338                          if (count == 4)
4339                          {
4340                              messageSizeFound = true;
4341                              messageSize = Buffer.ReadUInt32(buffer, offset + offset2);
4342                              offset2 += 4;
4343                              break;
4344                          }
4345                          else
4346                          {
4347                              ReceiveBuffer.Allocate(count);
4348                              size1 += count;
4349                              Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4350                              offset1 += count;
4351                              offset2 += count;
4352                              continue;
4353                          }
4354                      }
4355                      else
4356                          break;
4357                  }
4358                  if (!messageSizeFound)
4359                      return;
4360                  long minSize = Final ? (4 + 4) : (4 + 4 + 4 + 4);
4361                  Debug.Assert((messageSize >= minSize), "Invalid receive data!");
4362                  if (messageSize < minSize)
4363                      return;
4364                  bool messageFound = false;
4365                  while (!messageFound)
4366                  {
4367                      if (offset0 < size1)
4368                      {
4369                          long count = Math.Min(size1 - offset0, messageSize - 4);
4370                          if (count == (messageSize - 4))
4371                          {
4372                              messageFound = true;
4373                              messageBuffer = ReceiveBuffer.Data;
4374                              messageOffset = offset0 - 4;
4375                              offset0 += messageSize - 4;
4376                              break;
4377                          }
4378                          else
4379                          {
4380                              if (offset2 < size2)
4381                              {
4382                                  if (!messageSizeCopied)
4383                                  {
4384                                      ReceiveBuffer.Allocate(4);
4385                                      size1 += 4;
4386                                      Buffer.Write(ReceiveBuffer.Data, offset0, (uint)messageSize);
4387                                      offset0 += 4;
4388                                      offset1 += 4;
4389                                      messageSizeCopied = true;
4390                                  }
4391                                  count = Math.Min(size2 - offset2, messageSize - 4 - count);
4392                                  ReceiveBuffer.Allocate(count);
4393                                  size1 += count;
4394                                  Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4395                                  offset1 += count;
4396                                  offset2 += count;
4397                                  continue;
4398                              }
4399                              else
4400                                  break;
4401                          }
4402                      }
4403                      if (offset2 < size2)
4404                      {
4405                          long count = Math.Min(size2 - offset2, messageSize - 4);
4406                          if (!messageSizeCopied && (count == (messageSize - 4)))
4407                          {
4408                              messageFound = true;
4409                              messageBuffer = buffer;
4410                              messageOffset = offset + offset2 - 4;
4411                              offset2 += messageSize - 4;
4412                              break;
4413                          }
4414                          else
4415                          {
4416                              if (!messageSizeCopied)
4417                              {
4418                                  ReceiveBuffer.Allocate(4);
4419                                  size1 += 4;
4420                                  Buffer.Write(ReceiveBuffer.Data, offset0, (uint)messageSize);
4421                                  offset0 += 4;
4422                                  offset1 += 4;
4423                                  messageSizeCopied = true;
4424                              }
4425                              ReceiveBuffer.Allocate(count);
4426                              size1 += count;
4427                              Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4428                              offset1 += count;
4429                              offset2 += count;
4430                              continue;
4431                          }
4432                      }
4433                      else
4434                          break;
4435                  }
4436                  if (!messageFound)
4437                  {
4438                      if (!messageSizeCopied)
4439                      {
4440                          ReceiveBuffer.Allocate(4);
4441                          size1 += 4;
4442                          Buffer.Write(ReceiveBuffer.Data, offset0, (uint)messageSize);
4443                          offset0 += 4;
4444                          offset1 += 4;
4445                          messageSizeCopied = true;
4446                      }
4447                      return;
4448                  }
4449                  uint fbeStructSize;
4450                  uint fbeStructType;
4451                  if (Final)
4452                  {
4453                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset);
4454                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4455                  }
4456                  else
4457                  {
4458                      uint fbeStructOffset = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4459                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset);
4460                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset + 4);
4461                  }
4462                  OnReceive(fbeStructType, messageBuffer, messageOffset, messageSize);
4463                  ReceiveBuffer.Reset();
4464                  offset0 = ReceiveBuffer.Offset;
4465                  offset1 = ReceiveBuffer.Size;
4466                  size1 = ReceiveBuffer.Size;
4467              }
4468          }
4469          internal abstract bool OnReceive(long type, byte[] buffer, long offset, long size);
4470      }
4471  } 
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-com.chronoxor.fbe.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Linq;
7  using System.Numerics;
8  using System.Runtime.Serialization;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  namespace com.chronoxor.FBE {
13      public static class UuidGenerator
14      {
15          private static readonly DateTime GregorianEpoch = new DateTime(1582, 10, 15, 0, 0, 0, DateTimeKind.Utc);
16          private static readonly object Lock = new object();
17          private static readonly Random Generator = new Random();
18          private static readonly byte[] NodeBytes;
19          private static readonly byte[] ClockSequenceBytes;
20          private static DateTime _last = DateTime.UtcNow;
21          static UuidGenerator()
22          {
23              NodeBytes = new byte[6];
24              Generator.NextBytes(NodeBytes);
25              ClockSequenceBytes = new byte[2];
26              Generator.NextBytes(ClockSequenceBytes);
27          }
28          public static Guid Nil() { return new Guid(); }
29          public static Guid Sequential()
30          {
31              var now = DateTime.UtcNow;
32              lock (Lock)
33              {
34                  if (now <= _last)
35                      Generator.NextBytes(ClockSequenceBytes);
36                  _last = now;
37              }
38              long ticks = (now - GregorianEpoch).Ticks;
39              Span<byte> guid = stackalloc byte[16];
40              byte[] timestamp = BitConverter.GetBytes(ticks);
41              for (int i = 0; i < Math.Min(6, NodeBytes.Length); i++)
42                  guid[10 + i] = NodeBytes[i];
43              for (int i = 0; i < Math.Min(2, ClockSequenceBytes.Length); i++)
44                  guid[8 + i] = ClockSequenceBytes[i];
45              for (int i = 0; i < Math.Min(8, timestamp.Length); i++)
46                  guid[i] = timestamp[i];
47              guid[8] &= 0x3F;
48              guid[8] |= 0x80;
49              guid[7] &= 0x0F;
50              guid[7] |= 0x10;
51              return new Guid(guid);
52          }
53          public static Guid Random() { return Guid.NewGuid(); }
54      }
55      public class Buffer
56      {
57          private byte[] _data;
58          private long _size;
59          private long _offset;
60          public bool IsEmpty => (_data == null) || (_size == 0);
61          public byte[] Data => _data;
62          public long Capacity => _data.Length;
63          public long Size => _size;
64          public long Offset => _offset;
65          public Buffer() { Attach(); }
66          public Buffer(long capacity) { Attach(capacity); }
67          public Buffer(byte[] buffer) { Attach(buffer); }
68          public Buffer(byte[] buffer, long offset) { Attach(buffer, offset); }
69          public Buffer(byte[] buffer, long size, long offset) { Attach(buffer, size, offset); }
70          #region Attach memory buffer methods
71          public void Attach() { _data = new byte[0]; _size = 0; _offset = 0; }
72          public void Attach(long capacity) { _data = new byte[capacity]; _size = 0; _offset = 0; }
73          public void Attach(byte[] buffer) { _data = buffer; _size = buffer.Length; _offset = 0; }
74          public void Attach(byte[] buffer, long offset) { _data = buffer; _size = buffer.Length; _offset = offset; }
75          public void Attach(byte[] buffer, long size, long offset) { _data = buffer; _size = size; _offset = offset; }
76          #endregion
77          #region Memory buffer methods
78          public long Allocate(long size)
79          {
80              Debug.Assert((size >= 0), "Invalid allocation size!");
81              if (size < 0)
82                  throw new ArgumentException("Invalid allocation size!", nameof(size));
83              long offset = Size;
84              long total = _size + size;
85              if (total <= Capacity)
86              {
87                  _size = total;
88                  return offset;
89              }
90              byte[] data = new byte[Math.Max(total, 2 * Capacity)];
91              Array.Copy(_data, 0, data, 0, _size);
92              _data = data;
93              _size = total;
94              return offset;
95          }
96          public void Remove(long offset, long size)
97          {
98              Debug.Assert(((offset + size) <= Size), "Invalid offset & size!");
99              if ((offset + size) > Size)
100                  throw new ArgumentException("Invalid offset & size!", nameof(offset));
101              Array.Copy(_data, offset + size, _data, offset, _size - size - offset);
102              _size -= size;
103              if (_offset >= (offset + size))
104                  _offset -= size;
105              else if (_offset >= offset)
106              {
107                  _offset -= _offset - offset;
108                  if (_offset > Size)
109                      _offset = Size;
110              }
111          }
112          public void Reserve(long capacity)
113          {
114              Debug.Assert((capacity >= 0), "Invalid reserve capacity!");
115              if (capacity < 0)
116                  throw new ArgumentException("Invalid reserve capacity!", nameof(capacity));
117              if (capacity > Capacity)
118              {
119                  byte[] data = new byte[Math.Max(capacity, 2 * Capacity)];
120                  Array.Copy(_data, 0, data, 0, _size);
121                  _data = data;
122              }
123          }
124          public void Resize(long size)
125          {
126              Reserve(size);
127              _size = size;
128              if (_offset > _size)
129                  _offset = _size;
130          }
131          public void Reset()
132          {
133              _size = 0;
134              _offset = 0;
135          }
136          public void Shift(long offset) { _offset += offset; }
137          public void Unshift(long offset) { _offset -= offset; }
138          #endregion
139          #region Buffer I/O methods
140          public static bool ReadBool(byte[] buffer, long offset)
141          {
142              return buffer[offset] != 0;
143          }
144          public static byte ReadByte(byte[] buffer, long offset)
145          {
146              return buffer[offset];
147          }
148          public static char ReadChar(byte[] buffer, long offset)
149          {
150              return (char)ReadUInt8(buffer, offset);
151          }
152          public static char ReadWChar(byte[] buffer, long offset)
153          {
154              return (char)ReadUInt32(buffer, offset);
155          }
156          public static sbyte ReadInt8(byte[] buffer, long offset)
157          {
158              return (sbyte)buffer[offset];
159          }
160          public static byte ReadUInt8(byte[] buffer, long offset)
161          {
162              return buffer[offset];
163          }
164          public static short ReadInt16(byte[] buffer, long offset)
165          {
166              return (short)(buffer[offset + 0] | (buffer[offset + 1] << 8));
167          }
168          public static ushort ReadUInt16(byte[] buffer, long offset)
169          {
170              return (ushort)(buffer[offset + 0] | (buffer[offset + 1] << 8));
171          }
172          public static int ReadInt32(byte[] buffer, long offset)
173          {
174              return (buffer[offset + 0] <<  0)|
175                     (buffer[offset + 1] <<  8)|
176                     (buffer[offset + 2] << 16)|
177                     (buffer[offset + 3] << 24);
178          }
179          public static uint ReadUInt32(byte[] buffer, long offset)
180          {
181              return ((uint)buffer[offset + 0] <<  0)|
182                     ((uint)buffer[offset + 1] <<  8)|
183                     ((uint)buffer[offset + 2] << 16)|
184                     ((uint)buffer[offset + 3] << 24);
185          }
186          public static long ReadInt64(byte[] buffer, long offset)
187          {
188              return ((long)buffer[offset + 0] <<  0)|
189                     ((long)buffer[offset + 1] <<  8)|
190                     ((long)buffer[offset + 2] << 16)|
191                     ((long)buffer[offset + 3] << 24)|
192                     ((long)buffer[offset + 4] << 32)|
193                     ((long)buffer[offset + 5] << 40)|
194                     ((long)buffer[offset + 6] << 48)|
195                     ((long)buffer[offset + 7] << 56);
196          }
197          public static ulong ReadUInt64(byte[] buffer, long offset)
198          {
199              return ((ulong)buffer[offset + 0] <<  0)|
200                     ((ulong)buffer[offset + 1] <<  8)|
201                     ((ulong)buffer[offset + 2] << 16)|
202                     ((ulong)buffer[offset + 3] << 24)|
203                     ((ulong)buffer[offset + 4] << 32)|
204                     ((ulong)buffer[offset + 5] << 40)|
205                     ((ulong)buffer[offset + 6] << 48)|
206                     ((ulong)buffer[offset + 7] << 56);
207          }
208          public static ulong ReadUInt64Guid(byte[] buffer, long offset)
209          {
210              return ((ulong)buffer[offset + 0] << 24)|
211                     ((ulong)buffer[offset + 1] << 16)|
212                     ((ulong)buffer[offset + 2] <<  8)|
213                     ((ulong)buffer[offset + 3] <<  0)|
214                     ((ulong)buffer[offset + 4] << 40)|
215                     ((ulong)buffer[offset + 5] << 32)|
216                     ((ulong)buffer[offset + 6] << 56)|
217                     ((ulong)buffer[offset + 7] << 48);
218          }
219          public static float ReadFloat(byte[] buffer, long offset)
220          {
221              var bits = default(FloatUnion);
222              bits.UIntData = ReadUInt32(buffer, offset);
223              return bits.FloatData;
224          }
225          public static double ReadDouble(byte[] buffer, long offset)
226          {
227              var bits = default(DoubleUnion);
228              bits.ULongData = ReadUInt64(buffer, offset);
229              return bits.DoubleData;
230          }
231          public static decimal ReadDecimal(byte[] buffer, long offset)
232          {
233              var bits = default(DecimalUnion);
234              bits.UIntLow = ReadUInt32(buffer, offset);
235              bits.UIntMid = ReadUInt32(buffer, offset + 4);
236              bits.UIntHigh = ReadUInt32(buffer, offset + 8);
237              bits.UIntFlags = ReadUInt32(buffer, offset + 12);
238              return bits.DecimalData;
239          }
240          public static byte[] ReadBytes(byte[] buffer, long offset, long size)
241          {
242              byte[] result = new byte[size];
243              Array.Copy(buffer, offset, result, 0, (int)size);
244              return result;
245          }
246          public static string ReadString(byte[] buffer, long offset, long size)
247          {
248              return Encoding.UTF8.GetString(buffer, (int)offset, (int)size);
249          }
250          public static Guid ReadUUID(byte[] buffer, long offset)
251          {
252              var bits = default(GuidUnion);
253              bits.ULongHigh = ReadUInt64Guid(buffer, offset);
254              bits.ULongLow = ReadUInt64(buffer, offset + 8);
255              return bits.GuidData;
256          }
257          public static void Write(byte[] buffer, long offset, bool value)
258          {
259              buffer[offset] = (byte)(value ? 1 : 0);
260          }
261          public static void Write(byte[] buffer, long offset, sbyte value)
262          {
263              buffer[offset] = (byte)value;
264          }
265          public static void Write(byte[] buffer, long offset, byte value)
266          {
267              buffer[offset] = value;
268          }
269          public static void Write(byte[] buffer, long offset, short value)
270          {
271              buffer[offset + 0] = (byte)(value >>  0);
272              buffer[offset + 1] = (byte)(value >>  8);
273          }
274          public static void Write(byte[] buffer, long offset, ushort value)
275          {
276              buffer[offset + 0] = (byte)(value >>  0);
277              buffer[offset + 1] = (byte)(value >>  8);
278          }
279          public static void Write(byte[] buffer, long offset, int value)
280          {
281              buffer[offset + 0] = (byte)(value >>  0);
282              buffer[offset + 1] = (byte)(value >>  8);
283              buffer[offset + 2] = (byte)(value >> 16);
284              buffer[offset + 3] = (byte)(value >> 24);
285          }
286          public static void Write(byte[] buffer, long offset, uint value)
287          {
288              buffer[offset + 0] = (byte)(value >>  0);
289              buffer[offset + 1] = (byte)(value >>  8);
290              buffer[offset + 2] = (byte)(value >> 16);
291              buffer[offset + 3] = (byte)(value >> 24);
292          }
293          public static void Write(byte[] buffer, long offset, long value)
294          {
295              buffer[offset + 0] = (byte)(value >>  0);
296              buffer[offset + 1] = (byte)(value >>  8);
297              buffer[offset + 2] = (byte)(value >> 16);
298              buffer[offset + 3] = (byte)(value >> 24);
299              buffer[offset + 4] = (byte)(value >> 32);
300              buffer[offset + 5] = (byte)(value >> 40);
301              buffer[offset + 6] = (byte)(value >> 48);
302              buffer[offset + 7] = (byte)(value >> 56);
303          }
304          public static void Write(byte[] buffer, long offset, ulong value)
305          {
306              buffer[offset + 0] = (byte)(value >>  0);
307              buffer[offset + 1] = (byte)(value >>  8);
308              buffer[offset + 2] = (byte)(value >> 16);
309              buffer[offset + 3] = (byte)(value >> 24);
310              buffer[offset + 4] = (byte)(value >> 32);
311              buffer[offset + 5] = (byte)(value >> 40);
312              buffer[offset + 6] = (byte)(value >> 48);
313              buffer[offset + 7] = (byte)(value >> 56);
314          }
315          public static void WriteGuid(byte[] buffer, long offset, ulong value)
316          {
317              buffer[offset + 0] = (byte)(value >> 24);
318              buffer[offset + 1] = (byte)(value >> 16);
319              buffer[offset + 2] = (byte)(value >>  8);
320              buffer[offset + 3] = (byte)(value >>  0);
321              buffer[offset + 4] = (byte)(value >> 40);
322              buffer[offset + 5] = (byte)(value >> 32);
323              buffer[offset + 6] = (byte)(value >> 56);
324              buffer[offset + 7] = (byte)(value >> 48);
325          }
326          public static void Write(byte[] buffer, long offset, float value)
327          {
328              var bits = default(FloatUnion);
329              bits.FloatData = value;
330              Write(buffer, offset, bits.UIntData);
331          }
332          public static void Write(byte[] buffer, long offset, double value)
333          {
334              var bits = default(DoubleUnion);
335              bits.DoubleData = value;
336              Write(buffer, offset, bits.ULongData);
337          }
338          public static void Write(byte[] buffer, long offset, decimal value)
339          {
340              var bits = default(DecimalUnion);
341              bits.DecimalData = value;
342              Write(buffer, offset, bits.UIntLow);
343              Write(buffer, offset + 4, bits.UIntMid);
344              Write(buffer, offset + 8, bits.UIntHigh);
345              Write(buffer, offset + 12, bits.UIntFlags);
346          }
347          public static void Write(byte[] buffer, long offset, byte[] value)
348          {
349              Array.Copy(value, 0, buffer, offset, value.Length);
350          }
351          public static void Write(byte[] buffer, long offset, byte[] value, long valueOffset, long valueSize)
352          {
353              Array.Copy(value, valueOffset, buffer, offset, valueSize);
354          }
355          public static void Write(byte[] buffer, long offset, byte value, long valueCount)
356          {
357              for (long i = 0; i < valueCount; i++)
358                  buffer[offset + i] = value;
359          }
360          public static long Write(byte[] buffer, long offset, string value)
361          {
362              return Encoding.UTF8.GetBytes(value, 0, value.Length, buffer, (int)offset);
363          }
364          public static void Write(byte[] buffer, long offset, Guid value)
365          {
366              var bits = default(GuidUnion);
367              bits.GuidData = value;
368              WriteGuid(buffer, offset, bits.ULongHigh);
369              Write(buffer, offset + 8, bits.ULongLow);
370          }
371          #endregion
372          #region Utilities
373          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
374          private struct FloatUnion
375          {
376              [System.Runtime.InteropServices.FieldOffset(0)]
377              public uint UIntData;
378              [System.Runtime.InteropServices.FieldOffset(0)]
379              public float FloatData;
380          }
381          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
382          private struct DoubleUnion
383          {
384              [System.Runtime.InteropServices.FieldOffset(0)]
385              public ulong ULongData;
386              [System.Runtime.InteropServices.FieldOffset(0)]
387              public double DoubleData;
388          }
389          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
390          private struct DecimalUnion
391          {
392              [System.Runtime.InteropServices.FieldOffset(0)]
393              public uint UIntFlags;
394              [System.Runtime.InteropServices.FieldOffset(4)]
395              public uint UIntHigh;
396              [System.Runtime.InteropServices.FieldOffset(8)]
397              public uint UIntLow;
398              [System.Runtime.InteropServices.FieldOffset(12)]
399              public uint UIntMid;
400              [System.Runtime.InteropServices.FieldOffset(0)]
401              public decimal DecimalData;
402          }
403          [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
404          private struct GuidUnion
405          {
406              [System.Runtime.InteropServices.FieldOffset(0)]
407              public ulong ULongHigh;
408              [System.Runtime.InteropServices.FieldOffset(8)]
409              public ulong ULongLow;
410              [System.Runtime.InteropServices.FieldOffset(0)]
411              public Guid GuidData;
412          }
413          #endregion
414      }
415      public class Model
416      {
417          public Buffer Buffer { get; }
418          protected Model() { Buffer = new Buffer(); }
419          protected Model(Buffer buffer) { Buffer = buffer; }
420          #region Attach memory buffer methods
421          public void Attach() { Buffer.Attach(); }
422          public void Attach(long capacity) { Buffer.Attach(capacity); }
423          public void Attach(byte[] buffer) { Buffer.Attach(buffer); }
424          public void Attach(byte[] buffer, long offset) { Buffer.Attach(buffer, offset); }
425          public void Attach(byte[] buffer, long size, long offset) { Buffer.Attach(buffer, size, offset); }
426          public void Attach(Buffer buffer) { Buffer.Attach(buffer.Data, buffer.Size, buffer.Offset); }
427          public void Attach(Buffer buffer, long offset) { Buffer.Attach(buffer.Data, buffer.Size, offset); }
428          #endregion
429          #region Memory buffer methods
430          public long Allocate(long size) { return Buffer.Allocate(size); }
431          public void Remove(long offset, long size) { Buffer.Remove(offset, size); }
432          public void Reserve(long capacity) { Buffer.Reserve(capacity); }
433          public void Resize(long size) { Buffer.Resize(size); }
434          public void Reset() { Buffer.Reset(); }
435          public void Shift(long offset) { Buffer.Shift(offset); }
436          public void Unshift(long offset) { Buffer.Unshift(offset); }
437          #endregion
438          #region Buffer I/O methods
439          protected uint ReadUInt32(long offset) { return Buffer.ReadUInt32(Buffer.Data, Buffer.Offset + offset); }
440          protected void Write(long offset, uint value) { Buffer.Write(Buffer.Data, Buffer.Offset + offset, value); }
441          #endregion
442      }
443      public enum BaseTypes
444      {
445          BOOL,
446          BYTE,
447          BYTES,
448          CHAR,
449          WCHAR,
450          INT8,
451          UINT8,
452          INT16,
453          UINT16,
454          INT32,
455          UINT32,
456          INT64,
457          UINT64,
458          FLOAT,
459          DOUBLE,
460          DECIMAL,
461          UUID,
462          STRING,
463          TIMESTAMP
464      }
465      public abstract class FieldModelBase
466      {
467          protected Buffer _buffer;
468          protected long _offset;
469          protected FieldModelBase(Buffer buffer, long offset)
470          {
471              _buffer = buffer;
472              _offset = offset;
473          }
474          public long FBEOffset { get => _offset; set => _offset = value; }
475          public virtual long FBESize => 0;
476          public virtual long FBEExtra => 0;
477          public void FBEShift(long size) { _offset += size; }
478          public void FBEUnshift(long size) { _offset -= size; }
479          #region Buffer I/O methods
480          protected bool ReadBool(long offset) { return Buffer.ReadBool(_buffer.Data, _buffer.Offset + offset); }
481          protected byte ReadByte(long offset) { return Buffer.ReadByte(_buffer.Data, _buffer.Offset + offset); }
482          protected char ReadChar(long offset) { return Buffer.ReadChar(_buffer.Data, _buffer.Offset + offset); }
483          protected char ReadWChar(long offset) { return Buffer.ReadWChar(_buffer.Data, _buffer.Offset + offset); }
484          protected sbyte ReadInt8(long offset) { return Buffer.ReadInt8(_buffer.Data, _buffer.Offset + offset); }
485          protected byte ReadUInt8(long offset) { return Buffer.ReadUInt8(_buffer.Data, _buffer.Offset + offset); }
486          protected short ReadInt16(long offset) { return Buffer.ReadInt16(_buffer.Data, _buffer.Offset + offset); }
487          protected ushort ReadUInt16(long offset) { return Buffer.ReadUInt16(_buffer.Data, _buffer.Offset + offset); }
488          protected int ReadInt32(long offset) { return Buffer.ReadInt32(_buffer.Data, _buffer.Offset + offset); }
489          protected uint ReadUInt32(long offset) { return Buffer.ReadUInt32(_buffer.Data, _buffer.Offset + offset); }
490          protected long ReadInt64(long offset) { return Buffer.ReadInt64(_buffer.Data, _buffer.Offset + offset); }
491          protected ulong ReadUInt64(long offset) { return Buffer.ReadUInt64(_buffer.Data, _buffer.Offset + offset); }
492          protected float ReadFloat(long offset) { return Buffer.ReadFloat(_buffer.Data, _buffer.Offset + offset); }
493          protected double ReadDouble(long offset) { return Buffer.ReadDouble(_buffer.Data, _buffer.Offset + offset); }
494          protected decimal ReadDecimal(long offset) { return Buffer.ReadDecimal(_buffer.Data, _buffer.Offset + offset); }
495          protected byte[] ReadBytes(long offset, long size) { return Buffer.ReadBytes(_buffer.Data, _buffer.Offset + offset, size); }
496          protected string ReadString(long offset, long size) { return Buffer.ReadString(_buffer.Data, _buffer.Offset + offset, size); }
497          protected Guid ReadUUID(long offset) { return Buffer.ReadUUID(_buffer.Data, _buffer.Offset + offset); }
498          protected void Write(long offset, bool value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
499          protected void Write(long offset, sbyte value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
500          protected void Write(long offset, byte value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
501          protected void Write(long offset, short value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
502          protected void Write(long offset, ushort value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
503          protected void Write(long offset, int value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
504          protected void Write(long offset, uint value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
505          protected void Write(long offset, long value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
506          protected void Write(long offset, ulong value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
507          protected void Write(long offset, float value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
508          protected void Write(long offset, double value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
509          protected void Write(long offset, decimal value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
510          protected void Write(long offset, byte[] value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
511          protected void Write(long offset, byte[] value, long valueOffset, long valueSize) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value, valueOffset, valueSize); }
512          protected void Write(long offset, byte value, long valueCount) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value, valueCount); }
513          protected long Write(long offset, string value) { return Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
514          protected void Write(long offset, Guid value) { Buffer.Write(_buffer.Data, _buffer.Offset + offset, value); }
515          #endregion
516      }
517      public abstract class FieldModelValueType<T> : FieldModelBase
518          where T : struct
519      {
520          protected FieldModelValueType(Buffer buffer, long offset) : base(buffer, offset) {}
521          public abstract FieldModelValueType<T> Clone();
522          public virtual bool Verify() { return true; }
523          public abstract void Get(out T value);
524          public abstract void Get(out T value, T defaults);
525          public abstract void Set(T value);
526          public static FieldModelValueType<T> CreateFieldModel(BaseTypes type, Buffer buffer, long offset)
527          {
528              switch (type)
529              {
530                  case BaseTypes.BOOL:
531                      return new FieldModelBool(buffer, offset) as FieldModelValueType<T>;
532                  case BaseTypes.BYTE:
533                      return new FieldModelByte(buffer, offset) as FieldModelValueType<T>;
534                  case BaseTypes.CHAR:
535                      return new FieldModelChar(buffer, offset) as FieldModelValueType<T>;
536                  case BaseTypes.WCHAR:
537                      return new FieldModelWChar(buffer, offset) as FieldModelValueType<T>;
538                  case BaseTypes.INT8:
539                      return new FieldModelInt8(buffer, offset) as FieldModelValueType<T>;
540                  case BaseTypes.UINT8:
541                      return new FieldModelUInt8(buffer, offset) as FieldModelValueType<T>;
542                  case BaseTypes.INT16:
543                      return new FieldModelInt16(buffer, offset) as FieldModelValueType<T>;
544                  case BaseTypes.UINT16:
545                      return new FieldModelUInt16(buffer, offset) as FieldModelValueType<T>;
546                  case BaseTypes.INT32:
547                      return new FieldModelInt32(buffer, offset) as FieldModelValueType<T>;
548                  case BaseTypes.UINT32:
549                      return new FieldModelUInt32(buffer, offset) as FieldModelValueType<T>;
550                  case BaseTypes.INT64:
551                      return new FieldModelInt64(buffer, offset) as FieldModelValueType<T>;
552                  case BaseTypes.UINT64:
553                      return new FieldModelUInt64(buffer, offset) as FieldModelValueType<T>;
554                  case BaseTypes.FLOAT:
555                      return new FieldModelFloat(buffer, offset) as FieldModelValueType<T>;
556                  case BaseTypes.DOUBLE:
557                      return new FieldModelDouble(buffer, offset) as FieldModelValueType<T>;
558                  case BaseTypes.DECIMAL:
559                      return new FieldModelDecimal(buffer, offset) as FieldModelValueType<T>;
560                  case BaseTypes.UUID:
561                      return new FieldModelUUID(buffer, offset) as FieldModelValueType<T>;
562                  case BaseTypes.TIMESTAMP:
563                      return new FieldModelTimestamp(buffer, offset) as FieldModelValueType<T>;
564                  default:
565                      Debug.Assert(false, "Unknown type!");
566                      return null;
567              }
568          }
569      }
570      public abstract class FieldModelReferenceType<T> : FieldModelBase
571          where T : class
572      {
573          protected FieldModelReferenceType(Buffer buffer, long offset) : base(buffer, offset) {}
574          public abstract FieldModelReferenceType<T> Clone();
575          public virtual bool Verify() { return true; }
576          public abstract void Get(out T value);
577          public abstract void Get(out T value, T defaults);
578          public abstract void Set(T value);
579          public static FieldModelReferenceType<T> CreateFieldModel(BaseTypes type, Buffer buffer, long offset)
580          {
581              switch (type)
582              {
583                  case BaseTypes.BYTES:
584                      return new FieldModelBytes(buffer, offset) as FieldModelReferenceType<T>;
585                  case BaseTypes.STRING:
586                      return new FieldModelString(buffer, offset) as FieldModelReferenceType<T>;
587                  default:
588                      Debug.Assert(false, "Unknown type!");
589                      return null;
590              }
591          }
592      }
593      public class FieldModelBool : FieldModelValueType<bool>
594      {
595          public FieldModelBool(Buffer buffer, long offset) : base(buffer, offset) {}
596          public override long FBESize => 1;
597          public override FieldModelValueType<bool> Clone() { return new FieldModelBool(_buffer, _offset); }
598          public override void Get(out bool value) { Get(out value, false); }
599          public override void Get(out bool value, bool defaults)
600          {
601              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
602              {
603                  value = defaults;
604                  return;
605              }
606              value = ReadBool(FBEOffset);
607          }
608          public override void Set(bool value)
609          {
610              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
611              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
612                  return;
613              Write(FBEOffset, value);
614          }
615      }
616      public class FieldModelByte : FieldModelValueType<byte>
617      {
618          public FieldModelByte(Buffer buffer, long offset) : base(buffer, offset) {}
619          public override long FBESize => 1;
620          public override FieldModelValueType<byte> Clone() { return new FieldModelByte(_buffer, _offset); }
621          public override void Get(out byte value) { Get(out value, (byte)0); }
622          public override void Get(out byte value, byte defaults)
623          {
624              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
625              {
626                  value = defaults;
627                  return;
628              }
629              value = ReadByte(FBEOffset);
630          }
631          public override void Set(byte value)
632          {
633              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
634              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
635                  return;
636              Write(FBEOffset, value);
637          }
638      }
639      public class FieldModelChar : FieldModelValueType<char>
640      {
641          public FieldModelChar(Buffer buffer, long offset) : base(buffer, offset) {}
642          public override long FBESize => 1;
643          public override FieldModelValueType<char> Clone() { return new FieldModelChar(_buffer, _offset); }
644          public override void Get(out char value) { Get(out value, '\0'); }
645          public override void Get(out char value, char defaults)
646          {
647              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
648              {
649                  value = defaults;
650                  return;
651              }
652              value = ReadChar(FBEOffset);
653          }
654          public override void Set(char value)
655          {
656              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
657              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
658                  return;
659              Write(FBEOffset, (byte)value);
660          }
661      }
662      public class FieldModelWChar : FieldModelValueType<char>
663      {
664          public FieldModelWChar(Buffer buffer, long offset) : base(buffer, offset) {}
665          public override long FBESize => 4;
666          public override FieldModelValueType<char> Clone() { return new FieldModelWChar(_buffer, _offset); }
667          public override void Get(out char value) { Get(out value, '\0'); }
668          public override void Get(out char value, char defaults)
669          {
670              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
671              {
672                  value = defaults;
673                  return;
674              }
675              value = ReadWChar(FBEOffset);
676          }
677          public override void Set(char value)
678          {
679              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
680              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
681                  return;
682              Write(FBEOffset, (uint)value);
683          }
684      }
685      public class FieldModelInt8 : FieldModelValueType<sbyte>
686      {
687          public FieldModelInt8(Buffer buffer, long offset) : base(buffer, offset) {}
688          public override long FBESize => 1;
689          public override FieldModelValueType<sbyte> Clone() { return new FieldModelInt8(_buffer, _offset); }
690          public override void Get(out sbyte value) { Get(out value, 0); }
691          public override void Get(out sbyte value, sbyte defaults)
692          {
693              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
694              {
695                  value = defaults;
696                  return;
697              }
698              value = ReadInt8(FBEOffset);
699          }
700          public override void Set(sbyte value)
701          {
702              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
703              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
704                  return;
705              Write(FBEOffset, value);
706          }
707      }
708      public class FieldModelUInt8 : FieldModelValueType<byte>
709      {
710          public FieldModelUInt8(Buffer buffer, long offset) : base(buffer, offset) {}
711          public override long FBESize => 1;
712          public override FieldModelValueType<byte> Clone() { return new FieldModelUInt8(_buffer, _offset); }
713          public override void Get(out byte value) { Get(out value, (byte)0); }
714          public override void Get(out byte value, byte defaults)
715          {
716              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
717              {
718                  value = defaults;
719                  return;
720              }
721              value = ReadUInt8(FBEOffset);
722          }
723          public override void Set(byte value)
724          {
725              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
726              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
727                  return;
728              Write(FBEOffset, value);
729          }
730      }
731      public class FieldModelInt16 : FieldModelValueType<short>
732      {
733          public FieldModelInt16(Buffer buffer, long offset) : base(buffer, offset) {}
734          public override long FBESize => 2;
735          public override FieldModelValueType<short> Clone() { return new FieldModelInt16(_buffer, _offset); }
736          public override void Get(out short value) { Get(out value, 0); }
737          public override void Get(out short value, short defaults)
738          {
739              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
740              {
741                  value = defaults;
742                  return;
743              }
744              value = ReadInt16(FBEOffset);
745          }
746          public override void Set(short value)
747          {
748              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
749              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
750                  return;
751              Write(FBEOffset, value);
752          }
753      }
754      public class FieldModelUInt16 : FieldModelValueType<ushort>
755      {
756          public FieldModelUInt16(Buffer buffer, long offset) : base(buffer, offset) {}
757          public override long FBESize => 2;
758          public override FieldModelValueType<ushort> Clone() { return new FieldModelUInt16(_buffer, _offset); }
759          public override void Get(out ushort value) { Get(out value, (ushort)0); }
760          public override void Get(out ushort value, ushort defaults)
761          {
762              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
763              {
764                  value = defaults;
765                  return;
766              }
767              value = ReadUInt16(FBEOffset);
768          }
769          public override void Set(ushort value)
770          {
771              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
772              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
773                  return;
774              Write(FBEOffset, value);
775          }
776      }
777      public class FieldModelInt32 : FieldModelValueType<int>
778      {
779          public FieldModelInt32(Buffer buffer, long offset) : base(buffer, offset) {}
780          public override long FBESize => 4;
781          public override FieldModelValueType<int> Clone() { return new FieldModelInt32(_buffer, _offset); }
782          public override void Get(out int value) { Get(out value, 0); }
783          public override void Get(out int value, int defaults)
784          {
785              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
786              {
787                  value = defaults;
788                  return;
789              }
790              value = ReadInt32(FBEOffset);
791          }
792          public override void Set(int value)
793          {
794              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
795              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
796                  return;
797              Write(FBEOffset, value);
798          }
799      }
800      public class FieldModelUInt32 : FieldModelValueType<uint>
801      {
802          public FieldModelUInt32(Buffer buffer, long offset) : base(buffer, offset) {}
803          public override long FBESize => 4;
804          public override FieldModelValueType<uint> Clone() { return new FieldModelUInt32(_buffer, _offset); }
805          public override void Get(out uint value) { Get(out value, 0U); }
806          public override void Get(out uint value, uint defaults)
807          {
808              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
809              {
810                  value = defaults;
811                  return;
812              }
813              value = ReadUInt32(FBEOffset);
814          }
815          public override void Set(uint value)
816          {
817              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
818              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
819                  return;
820              Write(FBEOffset, value);
821          }
822      }
823      public class FieldModelInt64 : FieldModelValueType<long>
824      {
825          public FieldModelInt64(Buffer buffer, long offset) : base(buffer, offset) {}
826          public override long FBESize => 8;
827          public override FieldModelValueType<long> Clone() { return new FieldModelInt64(_buffer, _offset); }
828          public override void Get(out long value) { Get(out value, 0L); }
829          public override void Get(out long value, long defaults)
830          {
831              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
832              {
833                  value = defaults;
834                  return;
835              }
836              value = ReadInt64(FBEOffset);
837          }
838          public override void Set(long value)
839          {
840              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
841              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
842                  return;
843              Write(FBEOffset, value);
844          }
845      }
846      public class FieldModelUInt64 : FieldModelValueType<ulong>
847      {
848          public FieldModelUInt64(Buffer buffer, long offset) : base(buffer, offset) {}
849          public override long FBESize => 8;
850          public override FieldModelValueType<ulong> Clone() { return new FieldModelUInt64(_buffer, _offset); }
851          public override void Get(out ulong value) { Get(out value, 0UL); }
852          public override void Get(out ulong value, ulong defaults)
853          {
854              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
855              {
856                  value = defaults;
857                  return;
858              }
859              value = ReadUInt64(FBEOffset);
860          }
861          public override void Set(ulong value)
862          {
863              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
864              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
865                  return;
866              Write(FBEOffset, value);
867          }
868      }
869      public class FieldModelFloat : FieldModelValueType<float>
870      {
871          public FieldModelFloat(Buffer buffer, long offset) : base(buffer, offset) {}
872          public override long FBESize => 4;
873          public override FieldModelValueType<float> Clone() { return new FieldModelFloat(_buffer, _offset); }
874          public override void Get(out float value) { Get(out value, 0.0F); }
875          public override void Get(out float value, float defaults)
876          {
877              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
878              {
879                  value = defaults;
880                  return;
881              }
882              value = ReadFloat(FBEOffset);
883          }
884          public override void Set(float value)
885          {
886              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
887              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
888                  return;
889              Write(FBEOffset, value);
890          }
891      }
892      public class FieldModelDouble : FieldModelValueType<double>
893      {
894          public FieldModelDouble(Buffer buffer, long offset) : base(buffer, offset) {}
895          public override long FBESize => 8;
896          public override FieldModelValueType<double> Clone() { return new FieldModelDouble(_buffer, _offset); }
897          public override void Get(out double value) { Get(out value, 0.0D); }
898          public override void Get(out double value, double defaults)
899          {
900              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
901              {
902                  value = defaults;
903                  return;
904              }
905              value = ReadDouble(FBEOffset);
906          }
907          public override void Set(double value)
908          {
909              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
910              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
911                  return;
912              Write(FBEOffset, value);
913          }
914      }
915      public class FieldModelDecimal : FieldModelValueType<decimal>
916      {
917          public FieldModelDecimal(Buffer buffer, long offset) : base(buffer, offset) {}
918          public override long FBESize => 16;
919          public override FieldModelValueType<decimal> Clone() { return new FieldModelDecimal(_buffer, _offset); }
920          public override void Get(out decimal value) { Get(out value, 0.0M); }
921          public override void Get(out decimal value, decimal defaults)
922          {
923              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
924              {
925                  value = defaults;
926                  return;
927              }
928              value = ReadDecimal(FBEOffset);
929          }
930          public override void Set(decimal value)
931          {
932              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
933              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
934                  return;
935              Write(FBEOffset, value);
936          }
937      }
938      public class FieldModelUUID : FieldModelValueType<Guid>
939      {
940          public FieldModelUUID(Buffer buffer, long offset) : base(buffer, offset) {}
941          public override long FBESize => 16;
942          public override FieldModelValueType<Guid> Clone() { return new FieldModelUUID(_buffer, _offset); }
943          public override void Get(out Guid value) { Get(out value, UuidGenerator.Nil()); }
944          public override void Get(out Guid value, Guid defaults)
945          {
946              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
947              {
948                  value = defaults;
949                  return;
950              }
951              value = ReadUUID(FBEOffset);
952          }
953          public override void Set(Guid value)
954          {
955              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
956              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
957                  return;
958              Write(FBEOffset, value);
959          }
960      }
961      public class FieldModelTimestamp : FieldModelValueType<DateTime>
962      {
963          private const long UnixEpoch = 621355968000000000;
964          public FieldModelTimestamp(Buffer buffer, long offset) : base(buffer, offset) {}
965          public override long FBESize => 8;
966          public override FieldModelValueType<DateTime> Clone() { return new FieldModelTimestamp(_buffer, _offset); }
967          public override void Get(out DateTime value) { Get(out value, new DateTime(UnixEpoch, DateTimeKind.Utc)); }
968          public override void Get(out DateTime value, DateTime defaults)
969          {
970              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
971              {
972                  value = defaults;
973                  return;
974              }
975              ulong ticks = ReadUInt64(FBEOffset) / 100;
976              value = new DateTime((long)(UnixEpoch + ticks), DateTimeKind.Utc);
977          }
978          public override void Set(DateTime value)
979          {
980              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
981              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
982                  return;
983              ulong nanoseconds = (ulong)((value.Ticks - UnixEpoch) * 100);
984              Write(FBEOffset, nanoseconds);
985          }
986      }
987      public class FieldModelBytes : FieldModelReferenceType<MemoryStream>
988      {
989          public FieldModelBytes(Buffer buffer, long offset) : base(buffer, offset) {}
990          public override long FBESize => 4;
991          public override long FBEExtra
992          {
993              get
994              {
995                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
996                      return 0;
997                  uint fbeBytesOffset = ReadUInt32(FBEOffset);
998                  if ((fbeBytesOffset == 0) || ((_buffer.Offset + fbeBytesOffset + 4) > _buffer.Size))
999                      return 0;
1000                  uint fbeBytesSize = ReadUInt32(fbeBytesOffset);
1001                  return 4 + fbeBytesSize;
1002              }
1003          }
1004          public override FieldModelReferenceType<MemoryStream> Clone() { return new FieldModelBytes(_buffer, _offset); }
1005          public override bool Verify()
1006          {
1007              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1008                  return true;
1009              uint fbeBytesOffset = ReadUInt32(FBEOffset);
1010              if (fbeBytesOffset == 0)
1011                  return true;
1012              if ((_buffer.Offset + fbeBytesOffset + 4) > _buffer.Size)
1013                  return false;
1014              uint fbeBytesSize = ReadUInt32(fbeBytesOffset);
1015              if ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.Size)
1016                  return false;
1017              return true;
1018          }
1019          public override void Get(out MemoryStream value) { Get(out value, new MemoryStream()); }
1020          public override void Get(out MemoryStream value, MemoryStream defaults)
1021          {
1022              Debug.Assert((defaults != null), "Invalid default bytes value!");
1023              if (defaults == null)
1024                  throw new ArgumentNullException(nameof(defaults), "Invalid default bytes value!");
1025              value = defaults;
1026              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1027                  return;
1028              uint fbeBytesOffset = ReadUInt32(FBEOffset);
1029              if (fbeBytesOffset == 0)
1030                  return;
1031              Debug.Assert(((_buffer.Offset + fbeBytesOffset + 4) <= _buffer.Size), "Model is broken!");
1032              if ((_buffer.Offset + fbeBytesOffset + 4) > _buffer.Size)
1033                  return;
1034              uint fbeBytesSize = ReadUInt32(fbeBytesOffset);
1035              Debug.Assert(((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.Size), "Model is broken!");
1036              if ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.Size)
1037                  return;
1038              var buffer = ReadBytes(fbeBytesOffset + 4, fbeBytesSize);
1039              value.Write(buffer, 0, buffer.Length);
1040          }
1041          public override void Set(MemoryStream value)
1042          {
1043              Debug.Assert((value != null), "Invalid bytes value!");
1044              if (value == null)
1045                  throw new ArgumentNullException(nameof(value), "Invalid bytes value!");
1046              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1047              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1048                  return;
1049              uint fbeBytesSize = (uint)value.Length;
1050              uint fbeBytesOffset = (uint)(_buffer.Allocate(4 + fbeBytesSize) - _buffer.Offset);
1051              Debug.Assert(((fbeBytesOffset > 0) && ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.Size)), "Model is broken!");
1052              if ((fbeBytesOffset == 0) || ((_buffer.Offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.Size))
1053                  return;
1054              Write(FBEOffset, fbeBytesOffset);
1055              Write(fbeBytesOffset, fbeBytesSize);
1056              Write(fbeBytesOffset + 4, value.GetBuffer(), 0, fbeBytesSize);
1057          }
1058      }
1059      public class FieldModelString : FieldModelReferenceType<string>
1060      {
1061          public FieldModelString(Buffer buffer, long offset) : base(buffer, offset) {}
1062          public override long FBESize => 4;
1063          public override long FBEExtra
1064          {
1065              get
1066              {
1067                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1068                      return 0;
1069                  uint fbeStringOffset = ReadUInt32(FBEOffset);
1070                  if ((fbeStringOffset == 0) || ((_buffer.Offset + fbeStringOffset + 4) > _buffer.Size))
1071                      return 0;
1072                  uint fbeStringSize = ReadUInt32(fbeStringOffset);
1073                  return 4 + fbeStringSize;
1074              }
1075          }
1076          public override FieldModelReferenceType<string> Clone() { return new FieldModelString(_buffer, _offset); }
1077          public override bool Verify()
1078          {
1079              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1080                  return true;
1081              uint fbeStringOffset = ReadUInt32(FBEOffset);
1082              if (fbeStringOffset == 0)
1083                  return true;
1084              if ((_buffer.Offset + fbeStringOffset + 4) > _buffer.Size)
1085                  return false;
1086              uint fbeStringSize = ReadUInt32(fbeStringOffset);
1087              if ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.Size)
1088                  return false;
1089              return true;
1090          }
1091          public override void Get(out string value) { Get(out value, ""); }
1092          public override void Get(out string value, string defaults)
1093          {
1094              Debug.Assert((defaults != null), "Invalid default string value!");
1095              if (defaults == null)
1096                  throw new ArgumentNullException(nameof(defaults), "Invalid default string value!");
1097              value = defaults;
1098              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1099                  return;
1100              uint fbeStringOffset = ReadUInt32(FBEOffset);
1101              if (fbeStringOffset == 0)
1102                  return;
1103              Debug.Assert(((_buffer.Offset + fbeStringOffset + 4) <= _buffer.Size), "Model is broken!");
1104              if ((_buffer.Offset + fbeStringOffset + 4) > _buffer.Size)
1105                  return;
1106              uint fbeStringSize = ReadUInt32(fbeStringOffset);
1107              Debug.Assert(((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) <= _buffer.Size), "Model is broken!");
1108              if ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.Size)
1109                  return;
1110              value = ReadString(fbeStringOffset + 4, fbeStringSize);
1111          }
1112          public override void Set(string value)
1113          {
1114              Debug.Assert((value != null), "Invalid string value!");
1115              if (value == null)
1116                  throw new ArgumentNullException(nameof(value), "Invalid string value!");
1117              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1118              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1119                  return;
1120              uint fbeStringSize = (uint)Encoding.UTF8.GetByteCount(value);
1121              uint fbeStringOffset = (uint)(_buffer.Allocate(4 + fbeStringSize) - _buffer.Offset);
1122              Debug.Assert(((fbeStringOffset > 0) && ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) <= _buffer.Size)), "Model is broken!");
1123              if ((fbeStringOffset == 0) || ((_buffer.Offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.Size))
1124                  return;
1125              Write(FBEOffset, fbeStringOffset);
1126              Write(fbeStringOffset, fbeStringSize);
1127              Write(fbeStringOffset + 4, value);
1128          }
1129      }
1130      public class FieldModelOptionalValueType<T, TModel> : FieldModelBase
1131          where T : struct
1132          where TModel : FieldModelValueType<T>
1133      {
1134          public FieldModelOptionalValueType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1135          {
1136              Value = model.Clone() as TModel;
1137              if (Value != null)
1138                  Value.FBEOffset = 0;
1139          }
1140          public override long FBESize => 1 + 4;
1141          public override long FBEExtra
1142          {
1143              get
1144              {
1145                  if (!HasValue)
1146                      return 0;
1147                  uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1148                  if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + 4) > _buffer.Size))
1149                      return 0;
1150                  _buffer.Shift(fbeOptionalOffset);
1151                  long fbeResult = Value.FBESize + Value.FBEExtra;
1152                  _buffer.Unshift(fbeOptionalOffset);
1153                  return fbeResult;
1154              }
1155          }
1156          public FieldModelOptionalValueType<T, TModel> Clone() { return new FieldModelOptionalValueType<T, TModel>(Value, _buffer, _offset); }
1157          public static implicit operator bool(FieldModelOptionalValueType<T, TModel> optional) { return !ReferenceEquals(optional, null) && optional.HasValue; }
1158          public bool HasValue
1159          {
1160              get
1161              {
1162                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1163                      return false;
1164                  byte fbeHasValue = ReadUInt8(FBEOffset);
1165                  return (fbeHasValue != 0);
1166              }
1167          }
1168          public TModel Value { get; }
1169          public virtual bool Verify()
1170          {
1171              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1172                  return true;
1173              byte fbeHasValue = ReadUInt8(FBEOffset);
1174              if (fbeHasValue == 0)
1175                  return true;
1176              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1177              if (fbeOptionalOffset == 0)
1178                  return false;
1179              _buffer.Shift(fbeOptionalOffset);
1180              bool fbeResult = Value.Verify();
1181              _buffer.Unshift(fbeOptionalOffset);
1182              return fbeResult;
1183          }
1184          public long GetBegin()
1185          {
1186              if (!HasValue)
1187                  return 0;
1188              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1189              Debug.Assert((fbeOptionalOffset > 0), "Model is broken!");
1190              if (fbeOptionalOffset == 0)
1191                  return 0;
1192              _buffer.Shift(fbeOptionalOffset);
1193              return fbeOptionalOffset;
1194          }
1195          public void GetEnd(long fbeBegin)
1196          {
1197              _buffer.Unshift(fbeBegin);
1198          }
1199          public void Get(out T? optional, T? defaults = null)
1200          {
1201              optional = defaults;
1202              long fbeBegin = GetBegin();
1203              if (fbeBegin == 0)
1204                  return;
1205              Value.Get(out var temp);
1206              optional = temp;
1207              GetEnd(fbeBegin);
1208          }
1209          public long SetBegin(bool hasValue)
1210          {
1211              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1212              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1213                  return 0;
1214              byte fbeHasValue = (byte)(hasValue ? 1 : 0);
1215              Write(FBEOffset, fbeHasValue);
1216              if (fbeHasValue == 0)
1217                  return 0;
1218              uint fbeOptionalSize = (uint)Value.FBESize;
1219              uint fbeOptionalOffset = (uint)(_buffer.Allocate(fbeOptionalSize) - _buffer.Offset);
1220              Debug.Assert(((fbeOptionalOffset > 0) && ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.Size)), "Model is broken!");
1221              if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.Size))
1222                  return 0;
1223              Write(FBEOffset + 1, fbeOptionalOffset);
1224              _buffer.Shift(fbeOptionalOffset);
1225              return fbeOptionalOffset;
1226          }
1227          public void SetEnd(long fbeBegin)
1228          {
1229              _buffer.Unshift(fbeBegin);
1230          }
1231          public void Set(T? optional)
1232          {
1233              long fbeBegin = SetBegin(optional.HasValue);
1234              if (fbeBegin == 0)
1235                  return;
1236              if (optional.HasValue)
1237                  Value.Set(optional.Value);
1238              SetEnd(fbeBegin);
1239          }
1240      }
1241      public class FieldModelOptionalReferenceType<T, TModel> : FieldModelBase
1242          where T : class
1243          where TModel : FieldModelReferenceType<T>
1244      {
1245          public FieldModelOptionalReferenceType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1246          {
1247              Value = model.Clone() as TModel;
1248              if (Value != null)
1249                  Value.FBEOffset = 0;
1250          }
1251          public override long FBESize => 1 + 4;
1252          public override long FBEExtra
1253          {
1254              get
1255              {
1256                  if (!HasValue)
1257                      return 0;
1258                  uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1259                  if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + 4) > _buffer.Size))
1260                      return 0;
1261                  _buffer.Shift(fbeOptionalOffset);
1262                  long fbeResult = Value.FBESize + Value.FBEExtra;
1263                  _buffer.Unshift(fbeOptionalOffset);
1264                  return fbeResult;
1265              }
1266          }
1267          public FieldModelOptionalReferenceType<T, TModel> Clone() { return new FieldModelOptionalReferenceType<T, TModel>(Value, _buffer, _offset); }
1268          public static implicit operator bool(FieldModelOptionalReferenceType<T, TModel> optional) { return !ReferenceEquals(optional, null) && optional.HasValue; }
1269          public bool HasValue
1270          {
1271              get
1272              {
1273                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1274                      return false;
1275                  byte fbeHasValue = ReadUInt8(FBEOffset);
1276                  return (fbeHasValue != 0);
1277              }
1278          }
1279          public TModel Value { get; }
1280          public virtual bool Verify()
1281          {
1282              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1283                  return true;
1284              byte fbeHasValue = ReadUInt8(FBEOffset);
1285              if (fbeHasValue == 0)
1286                  return true;
1287              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1288              if (fbeOptionalOffset == 0)
1289                  return false;
1290              _buffer.Shift(fbeOptionalOffset);
1291              bool fbeResult = Value.Verify();
1292              _buffer.Unshift(fbeOptionalOffset);
1293              return fbeResult;
1294          }
1295          public long GetBegin()
1296          {
1297              if (!HasValue)
1298                  return 0;
1299              uint fbeOptionalOffset = ReadUInt32(FBEOffset + 1);
1300              Debug.Assert((fbeOptionalOffset > 0), "Model is broken!");
1301              if (fbeOptionalOffset == 0)
1302                  return 0;
1303              _buffer.Shift(fbeOptionalOffset);
1304              return fbeOptionalOffset;
1305          }
1306          public void GetEnd(long fbeBegin)
1307          {
1308              _buffer.Unshift(fbeBegin);
1309          }
1310          public void Get(out T optional, T defaults = null)
1311          {
1312              optional = defaults;
1313              long fbeBegin = GetBegin();
1314              if (fbeBegin == 0)
<span onclick='openModal()' class='match'>1315                  return;
1316              Value.Get(out var temp);
1317              optional = temp;
1318              GetEnd(fbeBegin);
1319          }
1320          public long SetBegin(bool hasValue)
1321          {
1322              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1323              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1324                  return 0;
1325              byte fbeHasValue = (byte)(hasValue ? 1 : 0);
1326              Write(FBEOffset, fbeHasValue);
1327              if (fbeHasValue == 0)
1328                  return 0;
1329              uint fbeOptionalSize = (uint)Value.FBESize;
1330              uint fbeOptionalOffset = (uint)(_buffer.Allocate(fbeOptionalSize) - _buffer.Offset);
1331              Debug.Assert(((fbeOptionalOffset > 0) && ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.Size)), "Model is broken!");
1332              if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.Size))
1333                  return 0;
1334              Write(FBEOffset + 1, fbeOptionalOffset);
1335              _buffer.Shift(fbeOptionalOffset);
1336              return fbeOptionalOffset;
1337          }
1338          public void SetEnd(long fbeBegin)
1339          {
1340              _buffer.Unshift(fbeBegin);
1341          }
1342          public void Set(T optional)
</span>1343          {
1344              long fbeBegin = SetBegin(optional != null);
1345              if (fbeBegin == 0)
1346                  return;
1347              if (optional != null)
1348                  Value.Set(optional);
1349              SetEnd(fbeBegin);
1350          }
1351      }
1352      public class FieldModelArrayValueType<T, TModel> : FieldModelBase
1353          where T : struct
1354          where TModel : FieldModelValueType<T>
1355      {
1356          private readonly TModel _model;
1357          private readonly long _size;
1358          public FieldModelArrayValueType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1359          {
1360              _model = model.Clone() as TModel;
1361              _size = size;
1362          }
1363          public override long FBESize => _size * _model.FBESize;
1364          public override long FBEExtra => 0;
1365          public FieldModelArrayValueType<T, TModel> Clone() { return new FieldModelArrayValueType<T, TModel>(_model, _buffer, _offset, _size); }
1366          public long Offset => 0;
1367          public long Size => _size;
1368          public TModel this[long index]
1369          {
1370              get
1371              {
1372                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1373                  Debug.Assert((index < _size), "Index is out of bounds!");
1374                  _model.FBEOffset = FBEOffset;
1375                  _model.FBEShift(index * _model.FBESize);
1376                  return _model;
1377              }
1378          }
1379          public virtual bool Verify()
1380          {
1381              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1382                  return false;
1383              _model.FBEOffset = FBEOffset;
1384              for (long i = _size; i-- > 0;)
1385              {
1386                  if (!_model.Verify())
1387                      return false;
1388                  _model.FBEShift(_model.FBESize);
1389              }
1390              return true;
1391          }
1392          public void Get(ref T[] values)
1393          {
1394              Debug.Assert((values != null), "Invalid values parameter!");
1395              if (values == null)
1396                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1397              values = new T[_size];
1398              var fbeModel = this[0];
1399              for (long i = 0; i < _size; i++)
1400              {
1401                  fbeModel.Get(out values[i]);
1402                  fbeModel.FBEShift(fbeModel.FBESize);
1403              }
1404          }
1405          public void Get(ref List<T> values)
1406          {
1407              Debug.Assert((values != null), "Invalid values parameter!");
1408              if (values == null)
1409                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1410              values.Clear();
1411              values.Capacity = (int)_size;
1412              var fbeModel = this[0];
1413              for (long i = _size; i-- > 0;)
1414              {
1415                  fbeModel.Get(out var value);
1416                  values.Add(value);
1417                  fbeModel.FBEShift(fbeModel.FBESize);
1418              }
1419          }
1420          public void Set(T[] values)
1421          {
1422              Debug.Assert((values != null), "Invalid values parameter!");
1423              if (values == null)
1424                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1425              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1426              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1427                  return;
1428              var fbeModel = this[0];
1429              for (long i = 0; (i < values.Length) && (i < _size); i++)
1430              {
1431                  fbeModel.Set(values[i]);
1432                  fbeModel.FBEShift(fbeModel.FBESize);
1433              }
1434          }
1435          public void Set(List<T> values)
1436          {
1437              Debug.Assert((values != null), "Invalid values parameter!");
1438              if (values == null)
1439                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1440              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1441              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1442                  return;
1443              var fbeModel = this[0];
1444              for (long i = 0; (i < values.Count) && (i < _size); i++)
1445              {
1446                  fbeModel.Set(values[(int)i]);
1447                  fbeModel.FBEShift(fbeModel.FBESize);
1448              }
1449          }
1450      }
1451      public class FieldModelArrayReferenceType<T, TModel> : FieldModelBase
1452          where T : class
1453          where TModel : FieldModelReferenceType<T>
1454      {
1455          private readonly TModel _model;
1456          private readonly long _size;
1457          public FieldModelArrayReferenceType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1458          {
1459              _model = model.Clone() as TModel;
1460              _size = size;
1461          }
1462          public override long FBESize => _size * _model.FBESize;
1463          public override long FBEExtra => 0;
1464          public FieldModelArrayReferenceType<T, TModel> Clone() { return new FieldModelArrayReferenceType<T, TModel>(_model, _buffer, _offset, _size); }
1465          public long Offset => 0;
1466          public long Size => _size;
1467          public TModel this[long index]
1468          {
1469              get
1470              {
1471                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1472                  Debug.Assert((index < _size), "Index is out of bounds!");
1473                  _model.FBEOffset = FBEOffset;
1474                  _model.FBEShift(index * _model.FBESize);
1475                  return _model;
1476              }
1477          }
1478          public virtual bool Verify()
1479          {
1480              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1481                  return false;
1482              _model.FBEOffset = FBEOffset;
1483              for (long i = _size; i-- > 0;)
1484              {
1485                  if (!_model.Verify())
1486                      return false;
1487                  _model.FBEShift(_model.FBESize);
1488              }
1489              return true;
1490          }
1491          public void Get(ref T[] values)
1492          {
1493              Debug.Assert((values != null), "Invalid values parameter!");
1494              if (values == null)
1495                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1496              values = new T[_size];
1497              var fbeModel = this[0];
1498              for (long i = 0; i < _size; i++)
1499              {
1500                  fbeModel.Get(out values[i]);
1501                  fbeModel.FBEShift(fbeModel.FBESize);
1502              }
1503          }
1504          public void Get(ref List<T> values)
1505          {
1506              Debug.Assert((values != null), "Invalid values parameter!");
1507              if (values == null)
1508                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1509              values.Clear();
1510              values.Capacity = (int)_size;
1511              var fbeModel = this[0];
1512              for (long i = _size; i-- > 0;)
1513              {
1514                  fbeModel.Get(out var value);
1515                  values.Add(value);
1516                  fbeModel.FBEShift(fbeModel.FBESize);
1517              }
1518          }
1519          public void Set(T[] values)
1520          {
1521              Debug.Assert((values != null), "Invalid values parameter!");
1522              if (values == null)
1523                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1524              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1525              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1526                  return;
1527              var fbeModel = this[0];
1528              for (long i = 0; (i < values.Length) && (i < _size); i++)
1529              {
1530                  fbeModel.Set(values[i]);
1531                  fbeModel.FBEShift(fbeModel.FBESize);
1532              }
1533          }
1534          public void Set(List<T> values)
1535          {
1536              Debug.Assert((values != null), "Invalid values parameter!");
1537              if (values == null)
1538                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1539              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1540              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1541                  return;
1542              var fbeModel = this[0];
1543              for (long i = 0; (i < values.Count) && (i < _size); i++)
1544              {
1545                  fbeModel.Set(values[(int)i]);
1546                  fbeModel.FBEShift(fbeModel.FBESize);
1547              }
1548          }
1549      }
1550      public class FieldModelArrayOptionalValueType<T, TModel> : FieldModelBase
1551          where T : struct
1552          where TModel : FieldModelValueType<T>
1553      {
1554          private readonly FieldModelOptionalValueType<T, TModel> _model;
1555          private readonly long _size;
1556          public FieldModelArrayOptionalValueType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1557          {
1558              _model = new FieldModelOptionalValueType<T, TModel>(model, buffer, offset);
1559              _size = size;
1560          }
1561          public override long FBESize => _size * _model.FBESize;
1562          public override long FBEExtra => 0;
1563          public FieldModelArrayOptionalValueType<T, TModel> Clone() { return new FieldModelArrayOptionalValueType<T, TModel>(_model.Value, _buffer, _offset, _size); }
1564          public long Offset => 0;
1565          public long Size => _size;
1566          public FieldModelOptionalValueType<T, TModel> this[long index]
1567          {
1568              get
1569              {
1570                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1571                  Debug.Assert((index < _size), "Index is out of bounds!");
1572                  _model.FBEOffset = FBEOffset;
1573                  _model.FBEShift(index * _model.FBESize);
1574                  return _model;
1575              }
1576          }
1577          public virtual bool Verify()
1578          {
1579              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1580                  return false;
1581              _model.FBEOffset = FBEOffset;
1582              for (long i = _size; i-- > 0;)
1583              {
1584                  if (!_model.Verify())
1585                      return false;
1586                  _model.FBEShift(_model.FBESize);
1587              }
1588              return true;
1589          }
1590          public void Get(ref T?[] values)
1591          {
1592              Debug.Assert((values != null), "Invalid values parameter!");
1593              if (values == null)
1594                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1595              values = new T?[_size];
1596              var fbeModel = this[0];
1597              for (long i = 0; i < _size; i++)
1598              {
1599                  fbeModel.Get(out values[i]);
1600                  fbeModel.FBEShift(fbeModel.FBESize);
1601              }
1602          }
1603          public void Get(ref List<T?> values)
1604          {
1605              Debug.Assert((values != null), "Invalid values parameter!");
1606              if (values == null)
1607                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1608              values.Clear();
1609              values.Capacity = (int)_size;
1610              var fbeModel = this[0];
1611              for (long i = _size; i-- > 0;)
1612              {
1613                  fbeModel.Get(out var value);
1614                  values.Add(value);
1615                  fbeModel.FBEShift(fbeModel.FBESize);
1616              }
1617          }
1618          public void Set(T?[] values)
1619          {
1620              Debug.Assert((values != null), "Invalid values parameter!");
1621              if (values == null)
1622                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1623              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1624              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1625                  return;
1626              var fbeModel = this[0];
1627              for (long i = 0; (i < values.Length) && (i < _size); i++)
1628              {
1629                  fbeModel.Set(values[i]);
1630                  fbeModel.FBEShift(fbeModel.FBESize);
1631              }
1632          }
1633          public void Set(List<T?> values)
1634          {
1635              Debug.Assert((values != null), "Invalid values parameter!");
1636              if (values == null)
1637                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1638              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1639              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1640                  return;
1641              var fbeModel = this[0];
1642              for (long i = 0; (i < values.Count) && (i < _size); i++)
1643              {
1644                  fbeModel.Set(values[(int)i]);
1645                  fbeModel.FBEShift(fbeModel.FBESize);
1646              }
1647          }
1648      }
1649      public class FieldModelArrayOptionalReferenceType<T, TModel> : FieldModelBase
1650          where T : class
1651          where TModel : FieldModelReferenceType<T>
1652      {
1653          private readonly FieldModelOptionalReferenceType<T, TModel> _model;
1654          private readonly long _size;
1655          public FieldModelArrayOptionalReferenceType(TModel model, Buffer buffer, long offset, long size) : base(buffer, offset)
1656          {
1657              _model = new FieldModelOptionalReferenceType<T, TModel>(model, buffer, offset);
1658              _size = size;
1659          }
1660          public override long FBESize => _size * _model.FBESize;
1661          public override long FBEExtra => 0;
1662          public FieldModelArrayOptionalReferenceType<T, TModel> Clone() { return new FieldModelArrayOptionalReferenceType<T, TModel>(_model.Value, _buffer, _offset, _size); }
1663          public long Offset => 0;
1664          public long Size => _size;
1665          public FieldModelOptionalReferenceType<T, TModel> this[long index]
1666          {
1667              get
1668              {
1669                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1670                  Debug.Assert((index < _size), "Index is out of bounds!");
1671                  _model.FBEOffset = FBEOffset;
1672                  _model.FBEShift(index * _model.FBESize);
1673                  return _model;
1674              }
1675          }
1676          public virtual bool Verify()
1677          {
1678              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1679                  return false;
1680              _model.FBEOffset = FBEOffset;
1681              for (long i = _size; i-- > 0;)
1682              {
1683                  if (!_model.Verify())
1684                      return false;
1685                  _model.FBEShift(_model.FBESize);
1686              }
1687              return true;
1688          }
1689          public void Get(ref T[] values)
1690          {
1691              Debug.Assert((values != null), "Invalid values parameter!");
1692              if (values == null)
1693                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1694              values = new T[_size];
1695              var fbeModel = this[0];
1696              for (long i = 0; i < _size; i++)
1697              {
1698                  fbeModel.Get(out values[i]);
1699                  fbeModel.FBEShift(fbeModel.FBESize);
1700              }
1701          }
1702          public void Get(ref List<T> values)
1703          {
1704              Debug.Assert((values != null), "Invalid values parameter!");
1705              if (values == null)
1706                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1707              values.Clear();
1708              values.Capacity = (int)_size;
1709              var fbeModel = this[0];
1710              for (long i = _size; i-- > 0;)
1711              {
1712                  fbeModel.Get(out var value);
1713                  values.Add(value);
1714                  fbeModel.FBEShift(fbeModel.FBESize);
1715              }
1716          }
1717          public void Set(T[] values)
1718          {
1719              Debug.Assert((values != null), "Invalid values parameter!");
1720              if (values == null)
1721                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1722              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1723              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1724                  return;
1725              var fbeModel = this[0];
1726              for (long i = 0; (i < values.Length) && (i < _size); i++)
1727              {
1728                  fbeModel.Set(values[i]);
1729                  fbeModel.FBEShift(fbeModel.FBESize);
1730              }
1731          }
1732          public void Set(List<T> values)
1733          {
1734              Debug.Assert((values != null), "Invalid values parameter!");
1735              if (values == null)
1736                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1737              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1738              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1739                  return;
1740              var fbeModel = this[0];
1741              for (long i = 0; (i < values.Count) && (i < _size); i++)
1742              {
1743                  fbeModel.Set(values[(int)i]);
1744                  fbeModel.FBEShift(fbeModel.FBESize);
1745              }
1746          }
1747      }
1748      public class FieldModelVectorValueType<T, TModel> : FieldModelBase
1749          where T : struct
1750          where TModel : FieldModelValueType<T>
1751      {
1752          private readonly TModel _model;
1753          public FieldModelVectorValueType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1754          {
1755              _model = model.Clone() as TModel;
1756          }
1757          public override long FBESize => 4;
1758          public override long FBEExtra
1759          {
1760              get
1761              {
1762                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1763                      return 0;
1764                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1765                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1766                      return 0;
1767                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1768                  long fbeResult = 4;
1769                  _model.FBEOffset = fbeVectorOffset + 4;
1770                  for (uint i = fbeVectorSize; i-- > 0;)
1771                  {
1772                      fbeResult += _model.FBESize + _model.FBEExtra;
1773                      _model.FBEShift(_model.FBESize);
1774                  }
1775                  return fbeResult;
1776              }
1777          }
1778          public FieldModelVectorValueType<T, TModel> Clone() { return new FieldModelVectorValueType<T, TModel>(_model, _buffer, _offset); }
1779          public long Offset
1780          {
1781              get
1782              {
1783                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1784                      return 0;
1785                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1786                  return fbeVectorOffset;
1787              }
1788          }
1789          public long Size
1790          {
1791              get
1792              {
1793                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1794                      return 0;
1795                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1796                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1797                      return 0;
1798                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1799                  return fbeVectorSize;
1800              }
1801          }
1802          public TModel this[long index]
1803          {
1804              get
1805              {
1806                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1807                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1808                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
1809                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1810                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
1811                  _model.FBEOffset = fbeVectorOffset + 4;
1812                  _model.FBEShift(index * _model.FBESize);
1813                  return _model;
1814              }
1815          }
1816          public TModel Resize(long size)
1817          {
1818              uint fbeVectorSize = (uint)(size * _model.FBESize);
1819              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
1820              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
1821              Write(FBEOffset, fbeVectorOffset);
1822              Write(fbeVectorOffset, (uint)size);
1823              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
1824              _model.FBEOffset = fbeVectorOffset + 4;
1825              return _model;
1826          }
1827          public virtual bool Verify()
1828          {
1829              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1830                  return true;
1831              uint fbeVectorOffset = ReadUInt32(FBEOffset);
1832              if (fbeVectorOffset == 0)
1833                  return true;
1834              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
1835                  return false;
1836              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1837              _model.FBEOffset = fbeVectorOffset + 4;
1838              for (uint i = fbeVectorSize; i-- > 0;)
1839              {
1840                  if (!_model.Verify())
1841                      return false;
1842                  _model.FBEShift(_model.FBESize);
1843              }
1844              return true;
1845          }
1846          public void Get(ref List<T> values)
1847          {
1848              Debug.Assert((values != null), "Invalid values parameter!");
1849              if (values == null)
1850                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1851              values.Clear();
1852              long fbeVectorSize = Size;
1853              if (fbeVectorSize == 0)
1854                  return;
1855              values.Capacity = (int)fbeVectorSize;
1856              var fbeModel = this[0];
1857              for (long i = fbeVectorSize; i-- > 0;)
1858              {
1859                  fbeModel.Get(out var value);
1860                  values.Add(value);
1861                  fbeModel.FBEShift(fbeModel.FBESize);
1862              }
1863          }
1864          public void Get(ref LinkedList<T> values)
1865          {
1866              Debug.Assert((values != null), "Invalid values parameter!");
1867              if (values == null)
1868                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1869              values.Clear();
1870              long fbeVectorSize = Size;
1871              if (fbeVectorSize == 0)
1872                  return;
1873              var fbeModel = this[0];
1874              for (long i = fbeVectorSize; i-- > 0;)
1875              {
1876                  fbeModel.Get(out var value);
1877                  values.AddLast(value);
1878                  fbeModel.FBEShift(fbeModel.FBESize);
1879              }
1880          }
1881          public void Get(ref HashSet<T> values)
1882          {
1883              Debug.Assert((values != null), "Invalid values parameter!");
1884              if (values == null)
1885                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1886              values.Clear();
1887              long fbeVectorSize = Size;
1888              if (fbeVectorSize == 0)
1889                  return;
1890              var fbeModel = this[0];
1891              for (long i = fbeVectorSize; i-- > 0;)
1892              {
1893                  fbeModel.Get(out var value);
1894                  values.Add(value);
1895                  fbeModel.FBEShift(fbeModel.FBESize);
1896              }
1897          }
1898          public void Set(List<T> values)
1899          {
1900              Debug.Assert((values != null), "Invalid values parameter!");
1901              if (values == null)
1902                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1903              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1904              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1905                  return;
1906              var fbeModel = Resize(values.Count);
1907              foreach (var value in values)
1908              {
1909                  fbeModel.Set(value);
1910                  fbeModel.FBEShift(fbeModel.FBESize);
1911              }
1912          }
1913          public void Set(LinkedList<T> values)
1914          {
1915              Debug.Assert((values != null), "Invalid values parameter!");
1916              if (values == null)
1917                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1918              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1919              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1920                  return;
1921              var fbeModel = Resize(values.Count);
1922              foreach (var value in values)
1923              {
1924                  fbeModel.Set(value);
1925                  fbeModel.FBEShift(fbeModel.FBESize);
1926              }
1927          }
1928          public void Set(HashSet<T> values)
1929          {
1930              Debug.Assert((values != null), "Invalid values parameter!");
1931              if (values == null)
1932                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
1933              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1934              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1935                  return;
1936              var fbeModel = Resize(values.Count);
1937              foreach (var value in values)
1938              {
1939                  fbeModel.Set(value);
1940                  fbeModel.FBEShift(fbeModel.FBESize);
1941              }
1942          }
1943      }
1944      public class FieldModelVectorReferenceType<T, TModel> : FieldModelBase
1945          where T : class
1946          where TModel : FieldModelReferenceType<T>
1947      {
1948          private readonly TModel _model;
1949          public FieldModelVectorReferenceType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
1950          {
1951              _model = model.Clone() as TModel;
1952          }
1953          public override long FBESize => 4;
1954          public override long FBEExtra
1955          {
1956              get
1957              {
1958                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1959                      return 0;
1960                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1961                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1962                      return 0;
1963                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1964                  long fbeResult = 4;
1965                  _model.FBEOffset = fbeVectorOffset + 4;
1966                  for (uint i = fbeVectorSize; i-- > 0;)
1967                  {
1968                      fbeResult += _model.FBESize + _model.FBEExtra;
1969                      _model.FBEShift(_model.FBESize);
1970                  }
1971                  return fbeResult;
1972              }
1973          }
1974          public FieldModelVectorReferenceType<T, TModel> Clone() { return new FieldModelVectorReferenceType<T, TModel>(_model, _buffer, _offset); }
1975          public long Offset
1976          {
1977              get
1978              {
1979                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1980                      return 0;
1981                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1982                  return fbeVectorOffset;
1983              }
1984          }
1985          public long Size
1986          {
1987              get
1988              {
1989                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1990                      return 0;
1991                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
1992                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
1993                      return 0;
1994                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
1995                  return fbeVectorSize;
1996              }
1997          }
1998          public TModel this[long index]
1999          {
2000              get
2001              {
2002                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2003                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2004                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2005                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2006                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
2007                  _model.FBEOffset = fbeVectorOffset + 4;
2008                  _model.FBEShift(index * _model.FBESize);
2009                  return _model;
2010              }
2011          }
2012          public TModel Resize(long size)
2013          {
2014              uint fbeVectorSize = (uint)(size * _model.FBESize);
2015              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
2016              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2017              Write(FBEOffset, fbeVectorOffset);
2018              Write(fbeVectorOffset, (uint)size);
2019              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
2020              _model.FBEOffset = fbeVectorOffset + 4;
2021              return _model;
2022          }
2023          public virtual bool Verify()
2024          {
2025              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2026                  return true;
2027              uint fbeVectorOffset = ReadUInt32(FBEOffset);
2028              if (fbeVectorOffset == 0)
2029                  return true;
2030              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
2031                  return false;
2032              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2033              _model.FBEOffset = fbeVectorOffset + 4;
2034              for (uint i = fbeVectorSize; i-- > 0;)
2035              {
2036                  if (!_model.Verify())
2037                      return false;
2038                  _model.FBEShift(_model.FBESize);
2039              }
2040              return true;
2041          }
2042          public void Get(ref List<T> values)
2043          {
2044              Debug.Assert((values != null), "Invalid values parameter!");
2045              if (values == null)
2046                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2047              values.Clear();
2048              long fbeVectorSize = Size;
2049              if (fbeVectorSize == 0)
2050                  return;
2051              values.Capacity = (int)fbeVectorSize;
2052              var fbeModel = this[0];
2053              for (long i = fbeVectorSize; i-- > 0;)
2054              {
2055                  fbeModel.Get(out var value);
2056                  values.Add(value);
2057                  fbeModel.FBEShift(fbeModel.FBESize);
2058              }
2059          }
2060          public void Get(ref LinkedList<T> values)
2061          {
2062              Debug.Assert((values != null), "Invalid values parameter!");
2063              if (values == null)
2064                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2065              values.Clear();
2066              long fbeVectorSize = Size;
2067              if (fbeVectorSize == 0)
2068                  return;
2069              var fbeModel = this[0];
2070              for (long i = fbeVectorSize; i-- > 0;)
2071              {
2072                  fbeModel.Get(out var value);
2073                  values.AddLast(value);
2074                  fbeModel.FBEShift(fbeModel.FBESize);
2075              }
2076          }
2077          public void Get(ref HashSet<T> values)
2078          {
2079              Debug.Assert((values != null), "Invalid values parameter!");
2080              if (values == null)
2081                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2082              values.Clear();
2083              long fbeVectorSize = Size;
2084              if (fbeVectorSize == 0)
2085                  return;
2086              var fbeModel = this[0];
2087              for (long i = fbeVectorSize; i-- > 0;)
2088              {
2089                  fbeModel.Get(out var value);
2090                  values.Add(value);
2091                  fbeModel.FBEShift(fbeModel.FBESize);
2092              }
2093          }
2094          public void Set(List<T> values)
2095          {
2096              Debug.Assert((values != null), "Invalid values parameter!");
2097              if (values == null)
2098                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2099              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2100              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2101                  return;
2102              var fbeModel = Resize(values.Count);
2103              foreach (var value in values)
2104              {
2105                  fbeModel.Set(value);
2106                  fbeModel.FBEShift(fbeModel.FBESize);
2107              }
2108          }
2109          public void Set(LinkedList<T> values)
2110          {
2111              Debug.Assert((values != null), "Invalid values parameter!");
2112              if (values == null)
2113                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2114              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2115              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2116                  return;
2117              var fbeModel = Resize(values.Count);
2118              foreach (var value in values)
2119              {
2120                  fbeModel.Set(value);
2121                  fbeModel.FBEShift(fbeModel.FBESize);
2122              }
2123          }
2124          public void Set(HashSet<T> values)
2125          {
2126              Debug.Assert((values != null), "Invalid values parameter!");
2127              if (values == null)
2128                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2129              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2130              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2131                  return;
2132              var fbeModel = Resize(values.Count);
2133              foreach (var value in values)
2134              {
2135                  fbeModel.Set(value);
2136                  fbeModel.FBEShift(fbeModel.FBESize);
2137              }
2138          }
2139      }
2140      public class FieldModelVectorOptionalValueType<T, TModel> : FieldModelBase
2141          where T : struct
2142          where TModel : FieldModelValueType<T>
2143      {
2144          private readonly FieldModelOptionalValueType<T, TModel> _model;
2145          public FieldModelVectorOptionalValueType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
2146          {
2147              _model = new FieldModelOptionalValueType<T, TModel>(model, buffer, offset);
2148          }
2149          public override long FBESize => 4;
2150          public override long FBEExtra
2151          {
2152              get
2153              {
2154                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2155                      return 0;
2156                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2157                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2158                      return 0;
2159                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2160                  long fbeResult = 4;
2161                  _model.FBEOffset = fbeVectorOffset + 4;
2162                  for (uint i = fbeVectorSize; i-- > 0;)
2163                  {
2164                      fbeResult += _model.FBESize + _model.FBEExtra;
2165                      _model.FBEShift(_model.FBESize);
2166                  }
2167                  return fbeResult;
2168              }
2169          }
2170          public FieldModelVectorOptionalValueType<T, TModel> Clone() { return new FieldModelVectorOptionalValueType<T, TModel>(_model.Value, _buffer, _offset); }
2171          public long Offset
2172          {
2173              get
2174              {
2175                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2176                      return 0;
2177                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2178                  return fbeVectorOffset;
2179              }
2180          }
2181          public long Size
2182          {
2183              get
2184              {
2185                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2186                      return 0;
2187                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2188                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2189                      return 0;
2190                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2191                  return fbeVectorSize;
2192              }
2193          }
2194          public FieldModelOptionalValueType<T, TModel> this[long index]
2195          {
2196              get
2197              {
2198                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2199                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2200                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2201                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2202                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
2203                  _model.FBEOffset = fbeVectorOffset + 4;
2204                  _model.FBEShift(index * _model.FBESize);
2205                  return _model;
2206              }
2207          }
2208          public FieldModelOptionalValueType<T, TModel> Resize(long size)
2209          {
2210              uint fbeVectorSize = (uint)(size * _model.FBESize);
2211              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
2212              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2213              Write(FBEOffset, fbeVectorOffset);
2214              Write(fbeVectorOffset, (uint)size);
2215              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
2216              _model.FBEOffset = fbeVectorOffset + 4;
2217              return _model;
2218          }
2219          public virtual bool Verify()
2220          {
2221              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2222                  return true;
2223              uint fbeVectorOffset = ReadUInt32(FBEOffset);
2224              if (fbeVectorOffset == 0)
2225                  return true;
2226              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
2227                  return false;
2228              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2229              _model.FBEOffset = fbeVectorOffset + 4;
2230              for (uint i = fbeVectorSize; i-- > 0;)
2231              {
2232                  if (!_model.Verify())
2233                      return false;
2234                  _model.FBEShift(_model.FBESize);
2235              }
2236              return true;
2237          }
2238          public void Get(ref List<T?> values)
2239          {
2240              Debug.Assert((values != null), "Invalid values parameter!");
2241              if (values == null)
2242                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2243              values.Clear();
2244              long fbeVectorSize = Size;
2245              if (fbeVectorSize == 0)
2246                  return;
2247              values.Capacity = (int)fbeVectorSize;
2248              var fbeModel = this[0];
2249              for (long i = fbeVectorSize; i-- > 0;)
2250              {
2251                  fbeModel.Get(out var value);
2252                  values.Add(value);
2253                  fbeModel.FBEShift(fbeModel.FBESize);
2254              }
2255          }
2256          public void Get(ref LinkedList<T?> values)
2257          {
2258              Debug.Assert((values != null), "Invalid values parameter!");
2259              if (values == null)
2260                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2261              values.Clear();
2262              long fbeVectorSize = Size;
2263              if (fbeVectorSize == 0)
2264                  return;
2265              var fbeModel = this[0];
2266              for (long i = fbeVectorSize; i-- > 0;)
2267              {
2268                  fbeModel.Get(out var value);
2269                  values.AddLast(value);
2270                  fbeModel.FBEShift(fbeModel.FBESize);
2271              }
2272          }
2273          public void Get(ref HashSet<T?> values)
2274          {
2275              Debug.Assert((values != null), "Invalid values parameter!");
2276              if (values == null)
2277                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2278              values.Clear();
2279              long fbeVectorSize = Size;
2280              if (fbeVectorSize == 0)
2281                  return;
2282              var fbeModel = this[0];
2283              for (long i = fbeVectorSize; i-- > 0;)
2284              {
2285                  fbeModel.Get(out var value);
2286                  values.Add(value);
2287                  fbeModel.FBEShift(fbeModel.FBESize);
2288              }
2289          }
2290          public void Set(List<T?> values)
2291          {
2292              Debug.Assert((values != null), "Invalid values parameter!");
2293              if (values == null)
2294                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2295              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2296              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2297                  return;
2298              var fbeModel = Resize(values.Count);
2299              foreach (var value in values)
2300              {
2301                  fbeModel.Set(value);
2302                  fbeModel.FBEShift(fbeModel.FBESize);
2303              }
2304          }
2305          public void Set(LinkedList<T?> values)
2306          {
2307              Debug.Assert((values != null), "Invalid values parameter!");
2308              if (values == null)
2309                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2310              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2311              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2312                  return;
2313              var fbeModel = Resize(values.Count);
2314              foreach (var value in values)
2315              {
2316                  fbeModel.Set(value);
2317                  fbeModel.FBEShift(fbeModel.FBESize);
2318              }
2319          }
2320          public void Set(HashSet<T?> values)
2321          {
2322              Debug.Assert((values != null), "Invalid values parameter!");
2323              if (values == null)
2324                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2325              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2326              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2327                  return;
2328              var fbeModel = Resize(values.Count);
2329              foreach (var value in values)
2330              {
2331                  fbeModel.Set(value);
2332                  fbeModel.FBEShift(fbeModel.FBESize);
2333              }
2334          }
2335      }
2336      public class FieldModelVectorOptionalReferenceType<T, TModel> : FieldModelBase
2337          where T : class
2338          where TModel : FieldModelReferenceType<T>
2339      {
2340          private readonly FieldModelOptionalReferenceType<T, TModel> _model;
2341          public FieldModelVectorOptionalReferenceType(TModel model, Buffer buffer, long offset) : base(buffer, offset)
2342          {
2343              _model = new FieldModelOptionalReferenceType<T, TModel>(model, buffer, offset);
2344          }
2345          public override long FBESize => 4;
2346          public override long FBEExtra
2347          {
2348              get
2349              {
2350                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2351                      return 0;
2352                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2353                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2354                      return 0;
2355                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2356                  long fbeResult = 4;
2357                  _model.FBEOffset = fbeVectorOffset + 4;
2358                  for (uint i = fbeVectorSize; i-- > 0;)
2359                  {
2360                      fbeResult += _model.FBESize + _model.FBEExtra;
2361                      _model.FBEShift(_model.FBESize);
2362                  }
2363                  return fbeResult;
2364              }
2365          }
2366          public FieldModelVectorOptionalReferenceType<T, TModel> Clone() { return new FieldModelVectorOptionalReferenceType<T, TModel>(_model.Value, _buffer, _offset); }
2367          public long Offset
2368          {
2369              get
2370              {
2371                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2372                      return 0;
2373                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2374                  return fbeVectorOffset;
2375              }
2376          }
2377          public long Size
2378          {
2379              get
2380              {
2381                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2382                      return 0;
2383                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2384                  if ((fbeVectorOffset == 0) || ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size))
2385                      return 0;
2386                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2387                  return fbeVectorSize;
2388              }
2389          }
2390          public FieldModelOptionalReferenceType<T, TModel> this[long index]
2391          {
2392              get
2393              {
2394                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2395                  uint fbeVectorOffset = ReadUInt32(FBEOffset);
2396                  Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2397                  uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2398                  Debug.Assert((index < fbeVectorSize), "Index is out of bounds!");
2399                  _model.FBEOffset = fbeVectorOffset + 4;
2400                  _model.FBEShift(index * _model.FBESize);
2401                  return _model;
2402              }
2403          }
2404          public FieldModelOptionalReferenceType<T, TModel> Resize(long size)
2405          {
2406              uint fbeVectorSize = (uint)(size * _model.FBESize);
2407              uint fbeVectorOffset = (uint)(_buffer.Allocate(4 + fbeVectorSize) - _buffer.Offset);
2408              Debug.Assert(((fbeVectorOffset > 0) && ((_buffer.Offset + fbeVectorOffset + 4) <= _buffer.Size)), "Model is broken!");
2409              Write(FBEOffset, fbeVectorOffset);
2410              Write(fbeVectorOffset, (uint)size);
2411              Write(fbeVectorOffset + 4, 0, fbeVectorSize);
2412              _model.FBEOffset = fbeVectorOffset + 4;
2413              return _model;
2414          }
2415          public virtual bool Verify()
2416          {
2417              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2418                  return true;
2419              uint fbeVectorOffset = ReadUInt32(FBEOffset);
2420              if (fbeVectorOffset == 0)
2421                  return true;
2422              if ((_buffer.Offset + fbeVectorOffset + 4) > _buffer.Size)
2423                  return false;
2424              uint fbeVectorSize = ReadUInt32(fbeVectorOffset);
2425              _model.FBEOffset = fbeVectorOffset + 4;
2426              for (uint i = fbeVectorSize; i-- > 0;)
2427              {
2428                  if (!_model.Verify())
2429                      return false;
2430                  _model.FBEShift(_model.FBESize);
2431              }
2432              return true;
2433          }
2434          public void Get(ref List<T> values)
2435          {
2436              Debug.Assert((values != null), "Invalid values parameter!");
2437              if (values == null)
2438                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2439              values.Clear();
2440              long fbeVectorSize = Size;
2441              if (fbeVectorSize == 0)
2442                  return;
2443              values.Capacity = (int)fbeVectorSize;
2444              var fbeModel = this[0];
2445              for (long i = fbeVectorSize; i-- > 0;)
2446              {
2447                  fbeModel.Get(out var value);
2448                  values.Add(value);
2449                  fbeModel.FBEShift(fbeModel.FBESize);
2450              }
2451          }
2452          public void Get(ref LinkedList<T> values)
2453          {
2454              Debug.Assert((values != null), "Invalid values parameter!");
2455              if (values == null)
2456                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2457              values.Clear();
2458              long fbeVectorSize = Size;
2459              if (fbeVectorSize == 0)
2460                  return;
2461              var fbeModel = this[0];
2462              for (long i = fbeVectorSize; i-- > 0;)
2463              {
2464                  fbeModel.Get(out var value);
2465                  values.AddLast(value);
2466                  fbeModel.FBEShift(fbeModel.FBESize);
2467              }
2468          }
2469          public void Get(ref HashSet<T> values)
2470          {
2471              Debug.Assert((values != null), "Invalid values parameter!");
2472              if (values == null)
2473                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2474              values.Clear();
2475              long fbeVectorSize = Size;
2476              if (fbeVectorSize == 0)
2477                  return;
2478              var fbeModel = this[0];
2479              for (long i = fbeVectorSize; i-- > 0;)
2480              {
2481                  fbeModel.Get(out var value);
2482                  values.Add(value);
2483                  fbeModel.FBEShift(fbeModel.FBESize);
2484              }
2485          }
2486          public void Set(List<T> values)
2487          {
2488              Debug.Assert((values != null), "Invalid values parameter!");
2489              if (values == null)
2490                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2491              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2492              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2493                  return;
2494              var fbeModel = Resize(values.Count);
2495              foreach (var value in values)
2496              {
2497                  fbeModel.Set(value);
2498                  fbeModel.FBEShift(fbeModel.FBESize);
2499              }
2500          }
2501          public void Set(LinkedList<T> values)
2502          {
2503              Debug.Assert((values != null), "Invalid values parameter!");
2504              if (values == null)
2505                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2506              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2507              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2508                  return;
2509              var fbeModel = Resize(values.Count);
2510              foreach (var value in values)
2511              {
2512                  fbeModel.Set(value);
2513                  fbeModel.FBEShift(fbeModel.FBESize);
2514              }
2515          }
2516          public void Set(HashSet<T> values)
2517          {
2518              Debug.Assert((values != null), "Invalid values parameter!");
2519              if (values == null)
2520                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2521              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2522              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2523                  return;
2524              var fbeModel = Resize(values.Count);
2525              foreach (var value in values)
2526              {
2527                  fbeModel.Set(value);
2528                  fbeModel.FBEShift(fbeModel.FBESize);
2529              }
2530          }
2531      }
2532      public class FieldModelMapValueTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
2533          where TKey : struct
2534          where TKeyModel : FieldModelValueType<TKey>
2535          where TValue : struct
2536          where TValueModel : FieldModelValueType<TValue>
2537      {
2538          private readonly TKeyModel _modelKey;
2539          private readonly TValueModel _modelValue;
2540          public FieldModelMapValueTypeKeyValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
2541          {
2542              _modelKey = modelKey.Clone() as TKeyModel;
2543              _modelValue = modelValue.Clone() as TValueModel;
2544          }
2545          public override long FBESize => 4;
2546          public override long FBEExtra
2547          {
2548              get
2549              {
2550                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2551                      return 0;
2552                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2553                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2554                      return 0;
2555                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2556                  long fbeResult = 4;
2557                  _modelKey.FBEOffset = fbeMapOffset + 4;
2558                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2559                  for (uint i = fbeMapSize; i-- > 0;)
2560                  {
2561                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
2562                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2563                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
2564                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2565                  }
2566                  return fbeResult;
2567              }
2568          }
2569          public FieldModelMapValueTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
2570          public long Offset
2571          {
2572              get
2573              {
2574                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2575                      return 0;
2576                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2577                  return fbeMapOffset;
2578              }
2579          }
2580          public long Size
2581          {
2582              get
2583              {
2584                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2585                      return 0;
2586                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2587                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2588                      return 0;
2589                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2590                  return fbeMapSize;
2591              }
2592          }
2593          public KeyValuePair<TKeyModel, TValueModel> this[long index]
2594          {
2595              get
2596              {
2597                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2598                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2599                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2600                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2601                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
2602                  _modelKey.FBEOffset = fbeMapOffset + 4;
2603                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2604                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2605                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2606                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2607              }
2608          }
2609          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
2610          {
2611              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
2612              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
2613              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2614              Write(FBEOffset, fbeMapOffset);
2615              Write(fbeMapOffset, (uint)size);
2616              Write(fbeMapOffset + 4, 0, fbeMapSize);
2617              _modelKey.FBEOffset = fbeMapOffset + 4;
2618              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2619              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2620          }
2621          public virtual bool Verify()
2622          {
2623              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2624                  return true;
2625              uint fbeMapOffset = ReadUInt32(FBEOffset);
2626              if (fbeMapOffset == 0)
2627                  return true;
2628              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
2629                  return false;
2630              uint fbeMapSize = ReadUInt32(fbeMapOffset);
2631              _modelKey.FBEOffset = fbeMapOffset + 4;
2632              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2633              for (uint i = fbeMapSize; i-- > 0;)
2634              {
2635                  if (!_modelKey.Verify())
2636                      return false;
2637                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2638                  if (!_modelValue.Verify())
2639                      return false;
2640                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2641              }
2642              return true;
2643          }
2644          public void Get(ref Dictionary<TKey, TValue> values)
2645          {
2646              Debug.Assert((values != null), "Invalid values parameter!");
2647              if (values == null)
2648                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2649              values.Clear();
2650              long fbeMapSize = Size;
2651              if (fbeMapSize == 0)
2652                  return;
2653              var fbeModel = this[0];
2654              for (long i = fbeMapSize; i-- > 0;)
2655              {
2656                  fbeModel.Key.Get(out var key);
2657                  fbeModel.Value.Get(out var value);
2658                  values.Add(key, value);
2659                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2660                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2661              }
2662          }
2663          public void Get(ref SortedDictionary<TKey, TValue> values)
2664          {
2665              Debug.Assert((values != null), "Invalid values parameter!");
2666              if (values == null)
2667                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2668              values.Clear();
2669              long fbeMapSize = Size;
2670              if (fbeMapSize == 0)
2671                  return;
2672              var fbeModel = this[0];
2673              for (long i = fbeMapSize; i-- > 0;)
2674              {
2675                  fbeModel.Key.Get(out var key);
2676                  fbeModel.Value.Get(out var value);
2677                  values.Add(key, value);
2678                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2679                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2680              }
2681          }
2682          public void Set(Dictionary<TKey, TValue> values)
2683          {
2684              Debug.Assert((values != null), "Invalid values parameter!");
2685              if (values == null)
2686                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2687              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2688              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2689                  return;
2690              var fbeModel = Resize(values.Count);
2691              foreach (var value in values)
2692              {
2693                  fbeModel.Key.Set(value.Key);
2694                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2695                  fbeModel.Value.Set(value.Value);
2696                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2697              }
2698          }
2699          public void Set(SortedDictionary<TKey, TValue> values)
2700          {
2701              Debug.Assert((values != null), "Invalid values parameter!");
2702              if (values == null)
2703                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2704              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2705              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2706                  return;
2707              var fbeModel = Resize(values.Count);
2708              foreach (var value in values)
2709              {
2710                  fbeModel.Key.Set(value.Key);
2711                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2712                  fbeModel.Value.Set(value.Value);
2713                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2714              }
2715          }
2716      }
2717      public class FieldModelMapValueTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
2718          where TKey : struct
2719          where TKeyModel : FieldModelValueType<TKey>
2720          where TValue : class
2721          where TValueModel : FieldModelReferenceType<TValue>
2722      {
2723          private readonly TKeyModel _modelKey;
2724          private readonly TValueModel _modelValue;
2725          public FieldModelMapValueTypeKeyReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
2726          {
2727              _modelKey = modelKey.Clone() as TKeyModel;
2728              _modelValue = modelValue.Clone() as TValueModel;
2729          }
2730          public override long FBESize => 4;
2731          public override long FBEExtra
2732          {
2733              get
2734              {
2735                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2736                      return 0;
2737                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2738                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2739                      return 0;
2740                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2741                  long fbeResult = 4;
2742                  _modelKey.FBEOffset = fbeMapOffset + 4;
2743                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2744                  for (uint i = fbeMapSize; i-- > 0;)
2745                  {
2746                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
2747                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2748                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
2749                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2750                  }
2751                  return fbeResult;
2752              }
2753          }
2754          public FieldModelMapValueTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
2755          public long Offset
2756          {
2757              get
2758              {
2759                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2760                      return 0;
2761                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2762                  return fbeMapOffset;
2763              }
2764          }
2765          public long Size
2766          {
2767              get
2768              {
2769                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2770                      return 0;
2771                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2772                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2773                      return 0;
2774                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2775                  return fbeMapSize;
2776              }
2777          }
2778          public KeyValuePair<TKeyModel, TValueModel> this[long index]
2779          {
2780              get
2781              {
2782                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2783                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2784                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2785                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2786                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
2787                  _modelKey.FBEOffset = fbeMapOffset + 4;
2788                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2789                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2790                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2791                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2792              }
2793          }
2794          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
2795          {
2796              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
2797              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
2798              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2799              Write(FBEOffset, fbeMapOffset);
2800              Write(fbeMapOffset, (uint)size);
2801              Write(fbeMapOffset + 4, 0, fbeMapSize);
2802              _modelKey.FBEOffset = fbeMapOffset + 4;
2803              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2804              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
2805          }
2806          public virtual bool Verify()
2807          {
2808              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2809                  return true;
2810              uint fbeMapOffset = ReadUInt32(FBEOffset);
2811              if (fbeMapOffset == 0)
2812                  return true;
2813              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
2814                  return false;
2815              uint fbeMapSize = ReadUInt32(fbeMapOffset);
2816              _modelKey.FBEOffset = fbeMapOffset + 4;
2817              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2818              for (uint i = fbeMapSize; i-- > 0;)
2819              {
2820                  if (!_modelKey.Verify())
2821                      return false;
2822                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2823                  if (!_modelValue.Verify())
2824                      return false;
2825                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2826              }
2827              return true;
2828          }
2829          public void Get(ref Dictionary<TKey, TValue> values)
2830          {
2831              Debug.Assert((values != null), "Invalid values parameter!");
2832              if (values == null)
2833                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2834              values.Clear();
2835              long fbeMapSize = Size;
2836              if (fbeMapSize == 0)
2837                  return;
2838              var fbeModel = this[0];
2839              for (long i = fbeMapSize; i-- > 0;)
2840              {
2841                  fbeModel.Key.Get(out var key);
2842                  fbeModel.Value.Get(out var value);
2843                  values.Add(key, value);
2844                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2845                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2846              }
2847          }
2848          public void Get(ref SortedDictionary<TKey, TValue> values)
2849          {
2850              Debug.Assert((values != null), "Invalid values parameter!");
2851              if (values == null)
2852                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2853              values.Clear();
2854              long fbeMapSize = Size;
2855              if (fbeMapSize == 0)
2856                  return;
2857              var fbeModel = this[0];
2858              for (long i = fbeMapSize; i-- > 0;)
2859              {
2860                  fbeModel.Key.Get(out var key);
2861                  fbeModel.Value.Get(out var value);
2862                  values.Add(key, value);
2863                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2864                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2865              }
2866          }
2867          public void Set(Dictionary<TKey, TValue> values)
2868          {
2869              Debug.Assert((values != null), "Invalid values parameter!");
2870              if (values == null)
2871                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2872              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2873              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2874                  return;
2875              var fbeModel = Resize(values.Count);
2876              foreach (var value in values)
2877              {
2878                  fbeModel.Key.Set(value.Key);
2879                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2880                  fbeModel.Value.Set(value.Value);
2881                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2882              }
2883          }
2884          public void Set(SortedDictionary<TKey, TValue> values)
2885          {
2886              Debug.Assert((values != null), "Invalid values parameter!");
2887              if (values == null)
2888                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
2889              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2890              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2891                  return;
2892              var fbeModel = Resize(values.Count);
2893              foreach (var value in values)
2894              {
2895                  fbeModel.Key.Set(value.Key);
2896                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2897                  fbeModel.Value.Set(value.Value);
2898                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
2899              }
2900          }
2901      }
2902      public class FieldModelMapValueTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
2903          where TKey : struct
2904          where TKeyModel : FieldModelValueType<TKey>
2905          where TValue : struct
2906          where TValueModel : FieldModelValueType<TValue>
2907      {
2908          private readonly TKeyModel _modelKey;
2909          private readonly FieldModelOptionalValueType<TValue, TValueModel> _modelValue;
2910          public FieldModelMapValueTypeKeyOptionalValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
2911          {
2912              _modelKey = modelKey.Clone() as TKeyModel;
2913              _modelValue = new FieldModelOptionalValueType<TValue, TValueModel>(modelValue, buffer, offset);
2914          }
2915          public override long FBESize => 4;
2916          public override long FBEExtra
2917          {
2918              get
2919              {
2920                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2921                      return 0;
2922                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2923                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2924                      return 0;
2925                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2926                  long fbeResult = 4;
2927                  _modelKey.FBEOffset = fbeMapOffset + 4;
2928                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2929                  for (uint i = fbeMapSize; i-- > 0;)
2930                  {
2931                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
2932                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2933                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
2934                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
2935                  }
2936                  return fbeResult;
2937              }
2938          }
2939          public FieldModelMapValueTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
2940          public long Offset
2941          {
2942              get
2943              {
2944                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2945                      return 0;
2946                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2947                  return fbeMapOffset;
2948              }
2949          }
2950          public long Size
2951          {
2952              get
2953              {
2954                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2955                      return 0;
2956                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2957                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
2958                      return 0;
2959                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2960                  return fbeMapSize;
2961              }
2962          }
2963          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> this[long index]
2964          {
2965              get
2966              {
2967                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
2968                  uint fbeMapOffset = ReadUInt32(FBEOffset);
2969                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2970                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
2971                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
2972                  _modelKey.FBEOffset = fbeMapOffset + 4;
2973                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2974                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2975                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
2976                  return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
2977              }
2978          }
2979          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> Resize(long size)
2980          {
2981              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
2982              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
2983              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
2984              Write(FBEOffset, fbeMapOffset);
2985              Write(fbeMapOffset, (uint)size);
2986              Write(fbeMapOffset + 4, 0, fbeMapSize);
2987              _modelKey.FBEOffset = fbeMapOffset + 4;
2988              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
2989              return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
2990          }
2991          public virtual bool Verify()
2992          {
2993              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
2994                  return true;
2995              uint fbeMapOffset = ReadUInt32(FBEOffset);
2996              if (fbeMapOffset == 0)
2997                  return true;
2998              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
2999                  return false;
3000              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3001              _modelKey.FBEOffset = fbeMapOffset + 4;
3002              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3003              for (uint i = fbeMapSize; i-- > 0;)
3004              {
3005                  if (!_modelKey.Verify())
3006                      return false;
3007                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3008                  if (!_modelValue.Verify())
3009                      return false;
3010                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3011              }
3012              return true;
3013          }
3014          public void Get(ref Dictionary<TKey, TValue?> values)
3015          {
3016              Debug.Assert((values != null), "Invalid values parameter!");
3017              if (values == null)
3018                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3019              values.Clear();
3020              long fbeMapSize = Size;
3021              if (fbeMapSize == 0)
3022                  return;
3023              var fbeModel = this[0];
3024              for (long i = fbeMapSize; i-- > 0;)
3025              {
3026                  fbeModel.Key.Get(out var key);
3027                  fbeModel.Value.Get(out var value);
3028                  values.Add(key, value);
3029                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3030                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3031              }
3032          }
3033          public void Get(ref SortedDictionary<TKey, TValue?> values)
3034          {
3035              Debug.Assert((values != null), "Invalid values parameter!");
3036              if (values == null)
3037                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3038              values.Clear();
3039              long fbeMapSize = Size;
3040              if (fbeMapSize == 0)
3041                  return;
3042              var fbeModel = this[0];
3043              for (long i = fbeMapSize; i-- > 0;)
3044              {
3045                  fbeModel.Key.Get(out var key);
3046                  fbeModel.Value.Get(out var value);
3047                  values.Add(key, value);
3048                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3049                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3050              }
3051          }
3052          public void Set(Dictionary<TKey, TValue?> values)
3053          {
3054              Debug.Assert((values != null), "Invalid values parameter!");
3055              if (values == null)
3056                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3057              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3058              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3059                  return;
3060              var fbeModel = Resize(values.Count);
3061              foreach (var value in values)
3062              {
3063                  fbeModel.Key.Set(value.Key);
3064                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3065                  fbeModel.Value.Set(value.Value);
3066                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3067              }
3068          }
3069          public void Set(SortedDictionary<TKey, TValue?> values)
3070          {
3071              Debug.Assert((values != null), "Invalid values parameter!");
3072              if (values == null)
3073                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3074              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3075              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3076                  return;
3077              var fbeModel = Resize(values.Count);
3078              foreach (var value in values)
3079              {
3080                  fbeModel.Key.Set(value.Key);
3081                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3082                  fbeModel.Value.Set(value.Value);
3083                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3084              }
3085          }
3086      }
3087      public class FieldModelMapValueTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3088          where TKey : struct
3089          where TKeyModel : FieldModelValueType<TKey>
3090          where TValue : class
3091          where TValueModel : FieldModelReferenceType<TValue>
3092      {
3093          private readonly TKeyModel _modelKey;
3094          private readonly FieldModelOptionalReferenceType<TValue, TValueModel> _modelValue;
3095          public FieldModelMapValueTypeKeyOptionalReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3096          {
3097              _modelKey = modelKey.Clone() as TKeyModel;
3098              _modelValue = new FieldModelOptionalReferenceType<TValue, TValueModel>(modelValue, buffer, offset);
3099          }
3100          public override long FBESize => 4;
3101          public override long FBEExtra
3102          {
3103              get
3104              {
3105                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3106                      return 0;
3107                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3108                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3109                      return 0;
3110                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3111                  long fbeResult = 4;
3112                  _modelKey.FBEOffset = fbeMapOffset + 4;
3113                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3114                  for (uint i = fbeMapSize; i-- > 0;)
3115                  {
3116                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3117                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3118                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3119                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3120                  }
3121                  return fbeResult;
3122              }
3123          }
3124          public FieldModelMapValueTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapValueTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
3125          public long Offset
3126          {
3127              get
3128              {
3129                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3130                      return 0;
3131                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3132                  return fbeMapOffset;
3133              }
3134          }
3135          public long Size
3136          {
3137              get
3138              {
3139                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3140                      return 0;
3141                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3142                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3143                      return 0;
3144                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3145                  return fbeMapSize;
3146              }
3147          }
3148          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> this[long index]
3149          {
3150              get
3151              {
3152                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3153                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3154                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3155                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3156                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3157                  _modelKey.FBEOffset = fbeMapOffset + 4;
3158                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3159                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3160                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3161                  return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3162              }
3163          }
3164          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> Resize(long size)
3165          {
3166              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3167              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3168              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3169              Write(FBEOffset, fbeMapOffset);
3170              Write(fbeMapOffset, (uint)size);
3171              Write(fbeMapOffset + 4, 0, fbeMapSize);
3172              _modelKey.FBEOffset = fbeMapOffset + 4;
3173              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3174              return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3175          }
3176          public virtual bool Verify()
3177          {
3178              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3179                  return true;
3180              uint fbeMapOffset = ReadUInt32(FBEOffset);
3181              if (fbeMapOffset == 0)
3182                  return true;
3183              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3184                  return false;
3185              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3186              _modelKey.FBEOffset = fbeMapOffset + 4;
3187              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3188              for (uint i = fbeMapSize; i-- > 0;)
3189              {
3190                  if (!_modelKey.Verify())
3191                      return false;
3192                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3193                  if (!_modelValue.Verify())
3194                      return false;
3195                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3196              }
3197              return true;
3198          }
3199          public void Get(ref Dictionary<TKey, TValue> values)
3200          {
3201              Debug.Assert((values != null), "Invalid values parameter!");
3202              if (values == null)
3203                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3204              values.Clear();
3205              long fbeMapSize = Size;
3206              if (fbeMapSize == 0)
3207                  return;
3208              var fbeModel = this[0];
3209              for (long i = fbeMapSize; i-- > 0;)
3210              {
3211                  fbeModel.Key.Get(out var key);
3212                  fbeModel.Value.Get(out var value);
3213                  values.Add(key, value);
3214                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3215                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3216              }
3217          }
3218          public void Get(ref SortedDictionary<TKey, TValue> values)
3219          {
3220              Debug.Assert((values != null), "Invalid values parameter!");
3221              if (values == null)
3222                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3223              values.Clear();
3224              long fbeMapSize = Size;
3225              if (fbeMapSize == 0)
3226                  return;
3227              var fbeModel = this[0];
3228              for (long i = fbeMapSize; i-- > 0;)
3229              {
3230                  fbeModel.Key.Get(out var key);
3231                  fbeModel.Value.Get(out var value);
3232                  values.Add(key, value);
3233                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3234                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3235              }
3236          }
3237          public void Set(Dictionary<TKey, TValue> values)
3238          {
3239              Debug.Assert((values != null), "Invalid values parameter!");
3240              if (values == null)
3241                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3242              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3243              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3244                  return;
3245              var fbeModel = Resize(values.Count);
3246              foreach (var value in values)
3247              {
3248                  fbeModel.Key.Set(value.Key);
3249                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3250                  fbeModel.Value.Set(value.Value);
3251                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3252              }
3253          }
3254          public void Set(SortedDictionary<TKey, TValue> values)
3255          {
3256              Debug.Assert((values != null), "Invalid values parameter!");
3257              if (values == null)
3258                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3259              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3260              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3261                  return;
3262              var fbeModel = Resize(values.Count);
3263              foreach (var value in values)
3264              {
3265                  fbeModel.Key.Set(value.Key);
3266                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3267                  fbeModel.Value.Set(value.Value);
3268                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3269              }
3270          }
3271      }
3272      public class FieldModelMapReferenceTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3273          where TKey : class
3274          where TKeyModel : FieldModelReferenceType<TKey>
3275          where TValue : struct
3276          where TValueModel : FieldModelValueType<TValue>
3277      {
3278          private readonly TKeyModel _modelKey;
3279          private readonly TValueModel _modelValue;
3280          public FieldModelMapReferenceTypeKeyValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3281          {
3282              _modelKey = modelKey.Clone() as TKeyModel;
3283              _modelValue = modelValue.Clone() as TValueModel;
3284          }
3285          public override long FBESize => 4;
3286          public override long FBEExtra
3287          {
3288              get
3289              {
3290                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3291                      return 0;
3292                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3293                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3294                      return 0;
3295                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3296                  long fbeResult = 4;
3297                  _modelKey.FBEOffset = fbeMapOffset + 4;
3298                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3299                  for (uint i = fbeMapSize; i-- > 0;)
3300                  {
3301                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3302                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3303                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3304                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3305                  }
3306                  return fbeResult;
3307              }
3308          }
3309          public FieldModelMapReferenceTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
3310          public long Offset
3311          {
3312              get
3313              {
3314                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3315                      return 0;
3316                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3317                  return fbeMapOffset;
3318              }
3319          }
3320          public long Size
3321          {
3322              get
3323              {
3324                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3325                      return 0;
3326                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3327                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3328                      return 0;
3329                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3330                  return fbeMapSize;
3331              }
3332          }
3333          public KeyValuePair<TKeyModel, TValueModel> this[long index]
3334          {
3335              get
3336              {
3337                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3338                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3339                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3340                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3341                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3342                  _modelKey.FBEOffset = fbeMapOffset + 4;
3343                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3344                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3345                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3346                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3347              }
3348          }
3349          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
3350          {
3351              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3352              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3353              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3354              Write(FBEOffset, fbeMapOffset);
3355              Write(fbeMapOffset, (uint)size);
3356              Write(fbeMapOffset + 4, 0, fbeMapSize);
3357              _modelKey.FBEOffset = fbeMapOffset + 4;
3358              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3359              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3360          }
3361          public virtual bool Verify()
3362          {
3363              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3364                  return true;
3365              uint fbeMapOffset = ReadUInt32(FBEOffset);
3366              if (fbeMapOffset == 0)
3367                  return true;
3368              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3369                  return false;
3370              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3371              _modelKey.FBEOffset = fbeMapOffset + 4;
3372              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3373              for (uint i = fbeMapSize; i-- > 0;)
3374              {
3375                  if (!_modelKey.Verify())
3376                      return false;
3377                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3378                  if (!_modelValue.Verify())
3379                      return false;
3380                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3381              }
3382              return true;
3383          }
3384          public void Get(ref Dictionary<TKey, TValue> values)
3385          {
3386              Debug.Assert((values != null), "Invalid values parameter!");
3387              if (values == null)
3388                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3389              values.Clear();
3390              long fbeMapSize = Size;
3391              if (fbeMapSize == 0)
3392                  return;
3393              var fbeModel = this[0];
3394              for (long i = fbeMapSize; i-- > 0;)
3395              {
3396                  fbeModel.Key.Get(out var key);
3397                  fbeModel.Value.Get(out var value);
3398                  values.Add(key, value);
3399                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3400                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3401              }
3402          }
3403          public void Get(ref SortedDictionary<TKey, TValue> values)
3404          {
3405              Debug.Assert((values != null), "Invalid values parameter!");
3406              if (values == null)
3407                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3408              values.Clear();
3409              long fbeMapSize = Size;
3410              if (fbeMapSize == 0)
3411                  return;
3412              var fbeModel = this[0];
3413              for (long i = fbeMapSize; i-- > 0;)
3414              {
3415                  fbeModel.Key.Get(out var key);
3416                  fbeModel.Value.Get(out var value);
3417                  values.Add(key, value);
3418                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3419                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3420              }
3421          }
3422          public void Set(Dictionary<TKey, TValue> values)
3423          {
3424              Debug.Assert((values != null), "Invalid values parameter!");
3425              if (values == null)
3426                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3427              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3428              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3429                  return;
3430              var fbeModel = Resize(values.Count);
3431              foreach (var value in values)
3432              {
3433                  fbeModel.Key.Set(value.Key);
3434                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3435                  fbeModel.Value.Set(value.Value);
3436                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3437              }
3438          }
3439          public void Set(SortedDictionary<TKey, TValue> values)
3440          {
3441              Debug.Assert((values != null), "Invalid values parameter!");
3442              if (values == null)
3443                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3444              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3445              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3446                  return;
3447              var fbeModel = Resize(values.Count);
3448              foreach (var value in values)
3449              {
3450                  fbeModel.Key.Set(value.Key);
3451                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3452                  fbeModel.Value.Set(value.Value);
3453                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3454              }
3455          }
3456      }
3457      public class FieldModelMapReferenceTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3458          where TKey : class
3459          where TKeyModel : FieldModelReferenceType<TKey>
3460          where TValue : class
3461          where TValueModel : FieldModelReferenceType<TValue>
3462      {
3463          private readonly TKeyModel _modelKey;
3464          private readonly TValueModel _modelValue;
3465          public FieldModelMapReferenceTypeKeyReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3466          {
3467              _modelKey = modelKey.Clone() as TKeyModel;
3468              _modelValue = modelValue.Clone() as TValueModel;
3469          }
3470          public override long FBESize => 4;
3471          public override long FBEExtra
3472          {
3473              get
3474              {
3475                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3476                      return 0;
3477                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3478                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3479                      return 0;
3480                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3481                  long fbeResult = 4;
3482                  _modelKey.FBEOffset = fbeMapOffset + 4;
3483                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3484                  for (uint i = fbeMapSize; i-- > 0;)
3485                  {
3486                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3487                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3488                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3489                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3490                  }
3491                  return fbeResult;
3492              }
3493          }
3494          public FieldModelMapReferenceTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue, _buffer, _offset); }
3495          public long Offset
3496          {
3497              get
3498              {
3499                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3500                      return 0;
3501                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3502                  return fbeMapOffset;
3503              }
3504          }
3505          public long Size
3506          {
3507              get
3508              {
3509                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3510                      return 0;
3511                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3512                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3513                      return 0;
3514                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3515                  return fbeMapSize;
3516              }
3517          }
3518          public KeyValuePair<TKeyModel, TValueModel> this[long index]
3519          {
3520              get
3521              {
3522                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3523                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3524                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3525                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3526                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3527                  _modelKey.FBEOffset = fbeMapOffset + 4;
3528                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3529                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3530                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3531                  return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3532              }
3533          }
3534          public KeyValuePair<TKeyModel, TValueModel> Resize(long size)
3535          {
3536              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3537              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3538              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3539              Write(FBEOffset, fbeMapOffset);
3540              Write(fbeMapOffset, (uint)size);
3541              Write(fbeMapOffset + 4, 0, fbeMapSize);
3542              _modelKey.FBEOffset = fbeMapOffset + 4;
3543              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3544              return new KeyValuePair<TKeyModel, TValueModel>(_modelKey, _modelValue);
3545          }
3546          public virtual bool Verify()
3547          {
3548              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3549                  return true;
3550              uint fbeMapOffset = ReadUInt32(FBEOffset);
3551              if (fbeMapOffset == 0)
3552                  return true;
3553              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3554                  return false;
3555              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3556              _modelKey.FBEOffset = fbeMapOffset + 4;
3557              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3558              for (uint i = fbeMapSize; i-- > 0;)
3559              {
3560                  if (!_modelKey.Verify())
3561                      return false;
3562                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3563                  if (!_modelValue.Verify())
3564                      return false;
3565                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3566              }
3567              return true;
3568          }
3569          public void Get(ref Dictionary<TKey, TValue> values)
3570          {
3571              Debug.Assert((values != null), "Invalid values parameter!");
3572              if (values == null)
3573                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3574              values.Clear();
3575              long fbeMapSize = Size;
3576              if (fbeMapSize == 0)
3577                  return;
3578              var fbeModel = this[0];
3579              for (long i = fbeMapSize; i-- > 0;)
3580              {
3581                  fbeModel.Key.Get(out var key);
3582                  fbeModel.Value.Get(out var value);
3583                  values.Add(key, value);
3584                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3585                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3586              }
3587          }
3588          public void Get(ref SortedDictionary<TKey, TValue> values)
3589          {
3590              Debug.Assert((values != null), "Invalid values parameter!");
3591              if (values == null)
3592                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3593              values.Clear();
3594              long fbeMapSize = Size;
3595              if (fbeMapSize == 0)
3596                  return;
3597              var fbeModel = this[0];
3598              for (long i = fbeMapSize; i-- > 0;)
3599              {
3600                  fbeModel.Key.Get(out var key);
3601                  fbeModel.Value.Get(out var value);
3602                  values.Add(key, value);
3603                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3604                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3605              }
3606          }
3607          public void Set(Dictionary<TKey, TValue> values)
3608          {
3609              Debug.Assert((values != null), "Invalid values parameter!");
3610              if (values == null)
3611                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3612              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3613              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3614                  return;
3615              var fbeModel = Resize(values.Count);
3616              foreach (var value in values)
3617              {
3618                  fbeModel.Key.Set(value.Key);
3619                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3620                  fbeModel.Value.Set(value.Value);
3621                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3622              }
3623          }
3624          public void Set(SortedDictionary<TKey, TValue> values)
3625          {
3626              Debug.Assert((values != null), "Invalid values parameter!");
3627              if (values == null)
3628                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3629              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3630              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3631                  return;
3632              var fbeModel = Resize(values.Count);
3633              foreach (var value in values)
3634              {
3635                  fbeModel.Key.Set(value.Key);
3636                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3637                  fbeModel.Value.Set(value.Value);
3638                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3639              }
3640          }
3641      }
3642      public class FieldModelMapReferenceTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3643          where TKey : class
3644          where TKeyModel : FieldModelReferenceType<TKey>
3645          where TValue : struct
3646          where TValueModel : FieldModelValueType<TValue>
3647      {
3648          private readonly TKeyModel _modelKey;
3649          private readonly FieldModelOptionalValueType<TValue, TValueModel> _modelValue;
3650          public FieldModelMapReferenceTypeKeyOptionalValueTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3651          {
3652              _modelKey = modelKey.Clone() as TKeyModel;
3653              _modelValue = new FieldModelOptionalValueType<TValue, TValueModel>(modelValue, buffer, offset);
3654          }
3655          public override long FBESize => 4;
3656          public override long FBEExtra
3657          {
3658              get
3659              {
3660                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3661                      return 0;
3662                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3663                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3664                      return 0;
3665                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3666                  long fbeResult = 4;
3667                  _modelKey.FBEOffset = fbeMapOffset + 4;
3668                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3669                  for (uint i = fbeMapSize; i-- > 0;)
3670                  {
3671                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3672                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3673                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3674                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3675                  }
3676                  return fbeResult;
3677              }
3678          }
3679          public FieldModelMapReferenceTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyOptionalValueTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
3680          public long Offset
3681          {
3682              get
3683              {
3684                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3685                      return 0;
3686                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3687                  return fbeMapOffset;
3688              }
3689          }
3690          public long Size
3691          {
3692              get
3693              {
3694                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3695                      return 0;
3696                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3697                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3698                      return 0;
3699                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3700                  return fbeMapSize;
3701              }
3702          }
3703          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> this[long index]
3704          {
3705              get
3706              {
3707                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3708                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3709                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3710                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3711                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3712                  _modelKey.FBEOffset = fbeMapOffset + 4;
3713                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3714                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3715                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3716                  return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
3717              }
3718          }
3719          public KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>> Resize(long size)
3720          {
3721              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3722              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3723              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3724              Write(FBEOffset, fbeMapOffset);
3725              Write(fbeMapOffset, (uint)size);
3726              Write(fbeMapOffset + 4, 0, fbeMapSize);
3727              _modelKey.FBEOffset = fbeMapOffset + 4;
3728              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3729              return new KeyValuePair<TKeyModel, FieldModelOptionalValueType<TValue, TValueModel>>(_modelKey, _modelValue);
3730          }
3731          public virtual bool Verify()
3732          {
3733              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3734                  return true;
3735              uint fbeMapOffset = ReadUInt32(FBEOffset);
3736              if (fbeMapOffset == 0)
3737                  return true;
3738              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3739                  return false;
3740              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3741              _modelKey.FBEOffset = fbeMapOffset + 4;
3742              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3743              for (uint i = fbeMapSize; i-- > 0;)
3744              {
3745                  if (!_modelKey.Verify())
3746                      return false;
3747                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3748                  if (!_modelValue.Verify())
3749                      return false;
3750                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3751              }
3752              return true;
3753          }
3754          public void Get(ref Dictionary<TKey, TValue?> values)
3755          {
3756              Debug.Assert((values != null), "Invalid values parameter!");
3757              if (values == null)
3758                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3759              values.Clear();
3760              long fbeMapSize = Size;
3761              if (fbeMapSize == 0)
3762                  return;
3763              var fbeModel = this[0];
3764              for (long i = fbeMapSize; i-- > 0;)
3765              {
3766                  fbeModel.Key.Get(out var key);
3767                  fbeModel.Value.Get(out var value);
3768                  values.Add(key, value);
3769                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3770                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3771              }
3772          }
3773          public void Get(ref SortedDictionary<TKey, TValue?> values)
3774          {
3775              Debug.Assert((values != null), "Invalid values parameter!");
3776              if (values == null)
3777                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3778              values.Clear();
3779              long fbeMapSize = Size;
3780              if (fbeMapSize == 0)
3781                  return;
3782              var fbeModel = this[0];
3783              for (long i = fbeMapSize; i-- > 0;)
3784              {
3785                  fbeModel.Key.Get(out var key);
3786                  fbeModel.Value.Get(out var value);
3787                  values.Add(key, value);
3788                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3789                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3790              }
3791          }
3792          public void Set(Dictionary<TKey, TValue?> values)
3793          {
3794              Debug.Assert((values != null), "Invalid values parameter!");
3795              if (values == null)
3796                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3797              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3798              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3799                  return;
3800              var fbeModel = Resize(values.Count);
3801              foreach (var value in values)
3802              {
3803                  fbeModel.Key.Set(value.Key);
3804                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3805                  fbeModel.Value.Set(value.Value);
3806                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3807              }
3808          }
3809          public void Set(SortedDictionary<TKey, TValue?> values)
3810          {
3811              Debug.Assert((values != null), "Invalid values parameter!");
3812              if (values == null)
3813                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3814              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3815              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3816                  return;
3817              var fbeModel = Resize(values.Count);
3818              foreach (var value in values)
3819              {
3820                  fbeModel.Key.Set(value.Key);
3821                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3822                  fbeModel.Value.Set(value.Value);
3823                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3824              }
3825          }
3826      }
3827      public class FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> : FieldModelBase
3828          where TKey : class
3829          where TKeyModel : FieldModelReferenceType<TKey>
3830          where TValue : class
3831          where TValueModel : FieldModelReferenceType<TValue>
3832      {
3833          private readonly TKeyModel _modelKey;
3834          private readonly FieldModelOptionalReferenceType<TValue, TValueModel> _modelValue;
3835          public FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue(TKeyModel modelKey, TValueModel modelValue, Buffer buffer, long offset) : base(buffer, offset)
3836          {
3837              _modelKey = modelKey.Clone() as TKeyModel;
3838              _modelValue = new FieldModelOptionalReferenceType<TValue, TValueModel>(modelValue, buffer, offset);
3839          }
3840          public override long FBESize => 4;
3841          public override long FBEExtra
3842          {
3843              get
3844              {
3845                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3846                      return 0;
3847                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3848                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3849                      return 0;
3850                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3851                  long fbeResult = 4;
3852                  _modelKey.FBEOffset = fbeMapOffset + 4;
3853                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3854                  for (uint i = fbeMapSize; i-- > 0;)
3855                  {
3856                      fbeResult += _modelKey.FBESize + _modelKey.FBEExtra;
3857                      _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3858                      fbeResult += _modelValue.FBESize + _modelValue.FBEExtra;
3859                      _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3860                  }
3861                  return fbeResult;
3862              }
3863          }
3864          public FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel> Clone() { return new FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<TKey, TKeyModel, TValue, TValueModel>(_modelKey, _modelValue.Value, _buffer, _offset); }
3865          public long Offset
3866          {
3867              get
3868              {
3869                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3870                      return 0;
3871                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3872                  return fbeMapOffset;
3873              }
3874          }
3875          public long Size
3876          {
3877              get
3878              {
3879                  if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3880                      return 0;
3881                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3882                  if ((fbeMapOffset == 0) || ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size))
3883                      return 0;
3884                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3885                  return fbeMapSize;
3886              }
3887          }
3888          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> this[long index]
3889          {
3890              get
3891              {
3892                  Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3893                  uint fbeMapOffset = ReadUInt32(FBEOffset);
3894                  Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3895                  uint fbeMapSize = ReadUInt32(fbeMapOffset);
3896                  Debug.Assert((index < fbeMapSize), "Index is out of bounds!");
3897                  _modelKey.FBEOffset = fbeMapOffset + 4;
3898                  _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3899                  _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3900                  _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize));
3901                  return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3902              }
3903          }
3904          public KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>> Resize(long size)
3905          {
3906              uint fbeMapSize = (uint)(size * (_modelKey.FBESize + _modelValue.FBESize));
3907              uint fbeMapOffset = (uint)(_buffer.Allocate(4 + fbeMapSize) - _buffer.Offset);
3908              Debug.Assert(((fbeMapOffset > 0) && ((_buffer.Offset + fbeMapOffset + 4) <= _buffer.Size)), "Model is broken!");
3909              Write(FBEOffset, fbeMapOffset);
3910              Write(fbeMapOffset, (uint)size);
3911              Write(fbeMapOffset + 4, 0, fbeMapSize);
3912              _modelKey.FBEOffset = fbeMapOffset + 4;
3913              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3914              return new KeyValuePair<TKeyModel, FieldModelOptionalReferenceType<TValue, TValueModel>>(_modelKey, _modelValue);
3915          }
3916          public virtual bool Verify()
3917          {
3918              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3919                  return true;
3920              uint fbeMapOffset = ReadUInt32(FBEOffset);
3921              if (fbeMapOffset == 0)
3922                  return true;
3923              if ((_buffer.Offset + fbeMapOffset + 4) > _buffer.Size)
3924                  return false;
3925              uint fbeMapSize = ReadUInt32(fbeMapOffset);
3926              _modelKey.FBEOffset = fbeMapOffset + 4;
3927              _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize;
3928              for (uint i = fbeMapSize; i-- > 0;)
3929              {
3930                  if (!_modelKey.Verify())
3931                      return false;
3932                  _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3933                  if (!_modelValue.Verify())
3934                      return false;
3935                  _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize);
3936              }
3937              return true;
3938          }
3939          public void Get(ref Dictionary<TKey, TValue> values)
3940          {
3941              Debug.Assert((values != null), "Invalid values parameter!");
3942              if (values == null)
3943                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3944              values.Clear();
3945              long fbeMapSize = Size;
3946              if (fbeMapSize == 0)
3947                  return;
3948              var fbeModel = this[0];
3949              for (long i = fbeMapSize; i-- > 0;)
3950              {
3951                  fbeModel.Key.Get(out var key);
3952                  fbeModel.Value.Get(out var value);
3953                  values.Add(key, value);
3954                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3955                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3956              }
3957          }
3958          public void Get(ref SortedDictionary<TKey, TValue> values)
3959          {
3960              Debug.Assert((values != null), "Invalid values parameter!");
3961              if (values == null)
3962                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3963              values.Clear();
3964              long fbeMapSize = Size;
3965              if (fbeMapSize == 0)
3966                  return;
3967              var fbeModel = this[0];
3968              for (long i = fbeMapSize; i-- > 0;)
3969              {
3970                  fbeModel.Key.Get(out var key);
3971                  fbeModel.Value.Get(out var value);
3972                  values.Add(key, value);
3973                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3974                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3975              }
3976          }
3977          public void Set(Dictionary<TKey, TValue> values)
3978          {
3979              Debug.Assert((values != null), "Invalid values parameter!");
3980              if (values == null)
3981                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3982              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
3983              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
3984                  return;
3985              var fbeModel = Resize(values.Count);
3986              foreach (var value in values)
3987              {
3988                  fbeModel.Key.Set(value.Key);
3989                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3990                  fbeModel.Value.Set(value.Value);
3991                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
3992              }
3993          }
3994          public void Set(SortedDictionary<TKey, TValue> values)
3995          {
3996              Debug.Assert((values != null), "Invalid values parameter!");
3997              if (values == null)
3998                  throw new ArgumentNullException(nameof(values), "Invalid values parameter!");
3999              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
4000              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
4001                  return;
4002              var fbeModel = Resize(values.Count);
4003              foreach (var value in values)
4004              {
4005                  fbeModel.Key.Set(value.Key);
4006                  fbeModel.Key.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
4007                  fbeModel.Value.Set(value.Value);
4008                  fbeModel.Value.FBEShift(fbeModel.Key.FBESize + fbeModel.Value.FBESize);
4009              }
4010          }
4011      }
4012      public interface ISenderListener
4013      {
4014          long OnSend(byte[] buffer, long offset, long size) { return size; }
4015          void OnSendLog(string message) {}
4016      }
4017      public abstract class Sender : ISenderListener
4018      {
4019          public Buffer Buffer { get; }
4020          public bool Logging { get; set; }
4021          public bool Final { get; }
4022          protected Sender(bool final) { Buffer = new Buffer(); Final = final; }
4023          protected Sender(Buffer buffer, bool final) { Buffer = buffer; Final = final; }
4024          public void Reset() { Buffer.Reset(); }
4025          public long SendSerialized(ISenderListener listener, long serialized)
4026          {
4027              Debug.Assert((serialized > 0), "Invalid size of the serialized buffer!");
4028              if (serialized == 0)
4029                  return 0;
4030              Buffer.Shift(serialized);
4031              long sent = listener.OnSend(Buffer.Data, 0, Buffer.Size);
4032              Buffer.Remove(0, sent);
4033              return sent;
4034          }
4035      }
4036      public interface IReceiverListener
4037      {
4038          void OnReceiveLog(string message) {}
4039      }
4040      public abstract class Receiver : IReceiverListener
4041      {
4042          public Buffer Buffer { get; private set; }
4043          public bool Logging { get; set; }
4044          public bool Final { get; }
4045          protected Receiver(bool final) { Buffer = new Buffer(); Final = final; }
4046          protected Receiver(Buffer buffer, bool final) { Buffer = buffer; Final = final; }
4047          public void Reset() { Buffer.Reset(); }
4048          public void Receive(Buffer buffer) { Receive(buffer.Data, 0, buffer.Size); }
4049          public void Receive(byte[] buffer) { Receive(buffer, 0, buffer.Length); }
4050          public void Receive(byte[] buffer, long offset, long size)
4051          {
4052              Debug.Assert((buffer != null), "Invalid buffer!");
4053              if (buffer == null)
4054                  throw new ArgumentException("Invalid buffer!", nameof(buffer));
4055              Debug.Assert(((offset + size) <= buffer.Length), "Invalid offset & size!");
4056              if ((offset + size) > buffer.Length)
4057                  throw new ArgumentException("Invalid offset & size!", nameof(offset));
4058              if (size == 0)
4059                  return;
4060              long offset0 = Buffer.Offset;
4061              long offset1 = Buffer.Size;
4062              long size1 = Buffer.Size;
4063              long offset2 = 0;
4064              long size2 = size;
4065              while (offset2 < size2)
4066              {
4067                  byte[] messageBuffer = null;
4068                  long messageOffset = 0;
4069                  long messageSize = 0;
4070                  bool messageSizeCopied = false;
4071                  bool messageSizeFound = false;
4072                  while (!messageSizeFound)
4073                  {
4074                      if (offset0 < size1)
4075                      {
4076                          long count = Math.Min(size1 - offset0, 4);
4077                          if (count == 4)
4078                          {
4079                              messageSizeCopied = true;
4080                              messageSizeFound = true;
4081                              messageSize = Buffer.ReadUInt32(Buffer.Data, offset0);
4082                              offset0 += 4;
4083                              break;
4084                          }
4085                          else
4086                          {
4087                              if (offset2 < size2)
4088                              {
4089                                  count = Math.Min(size2 - offset2, 4 - count);
4090                                  Buffer.Allocate(count);
4091                                  size1 += count;
4092                                  Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4093                                  offset1 += count;
4094                                  offset2 += count;
4095                                  continue;
4096                              }
4097                              else
4098                                  break;
4099                          }
4100                      }
4101                      if (offset2 < size2)
4102                      {
4103                          long count = Math.Min(size2 - offset2, 4);
4104                          if (count == 4)
4105                          {
4106                              messageSizeFound = true;
4107                              messageSize = Buffer.ReadUInt32(buffer, offset + offset2);
4108                              offset2 += 4;
4109                              break;
4110                          }
4111                          else
4112                          {
4113                              Buffer.Allocate(count);
4114                              size1 += count;
4115                              Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4116                              offset1 += count;
4117                              offset2 += count;
4118                              continue;
4119                          }
4120                      }
4121                      else
4122                          break;
4123                  }
4124                  if (!messageSizeFound)
4125                      return;
4126                  long minSize = Final ? (4 + 4) : (4 + 4 + 4 + 4);
4127                  Debug.Assert((messageSize >= minSize), "Invalid receive data!");
4128                  if (messageSize < minSize)
4129                      return;
4130                  bool messageFound = false;
4131                  while (!messageFound)
4132                  {
4133                      if (offset0 < size1)
4134                      {
4135                          long count = Math.Min(size1 - offset0, messageSize - 4);
4136                          if (count == (messageSize - 4))
4137                          {
4138                              messageFound = true;
4139                              messageBuffer = Buffer.Data;
4140                              messageOffset = offset0 - 4;
4141                              offset0 += messageSize - 4;
4142                              break;
4143                          }
4144                          else
4145                          {
4146                              if (offset2 < size2)
4147                              {
4148                                  if (!messageSizeCopied)
4149                                  {
4150                                      Buffer.Allocate(4);
4151                                      size1 += 4;
4152                                      Buffer.Write(Buffer.Data, offset0, (uint)messageSize);
4153                                      offset0 += 4;
4154                                      offset1 += 4;
4155                                      messageSizeCopied = true;
4156                                  }
4157                                  count = Math.Min(size2 - offset2, messageSize - 4 - count);
4158                                  Buffer.Allocate(count);
4159                                  size1 += count;
4160                                  Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4161                                  offset1 += count;
4162                                  offset2 += count;
4163                                  continue;
4164                              }
4165                              else
4166                                  break;
4167                          }
4168                      }
4169                      if (offset2 < size2)
4170                      {
4171                          long count = Math.Min(size2 - offset2, messageSize - 4);
4172                          if (!messageSizeCopied && (count == (messageSize - 4)))
4173                          {
4174                              messageFound = true;
4175                              messageBuffer = buffer;
4176                              messageOffset = offset + offset2 - 4;
4177                              offset2 += messageSize - 4;
4178                              break;
4179                          }
4180                          else
4181                          {
4182                              if (!messageSizeCopied)
4183                              {
4184                                  Buffer.Allocate(4);
4185                                  size1 += 4;
4186                                  Buffer.Write(Buffer.Data, offset0, (uint)messageSize);
4187                                  offset0 += 4;
4188                                  offset1 += 4;
4189                                  messageSizeCopied = true;
4190                              }
4191                              Buffer.Allocate(count);
4192                              size1 += count;
4193                              Array.Copy(buffer, offset + offset2, Buffer.Data, offset1, count);
4194                              offset1 += count;
4195                              offset2 += count;
4196                              continue;
4197                          }
4198                      }
4199                      else
4200                          break;
4201                  }
4202                  if (!messageFound)
4203                  {
4204                      if (!messageSizeCopied)
4205                      {
4206                          Buffer.Allocate(4);
4207                          size1 += 4;
4208                          Buffer.Write(Buffer.Data, offset0, (uint)messageSize);
4209                          offset0 += 4;
4210                          offset1 += 4;
4211                          messageSizeCopied = true;
4212                      }
4213                      return;
4214                  }
4215                  uint fbeStructSize;
4216                  uint fbeStructType;
4217                  if (Final)
4218                  {
4219                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset);
4220                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4221                  }
4222                  else
4223                  {
4224                      uint fbeStructOffset = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4225                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset);
4226                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset + 4);
4227                  }
4228                  OnReceive(fbeStructType, messageBuffer, messageOffset, messageSize);
4229                  Buffer.Reset();
4230                  offset0 = Buffer.Offset;
4231                  offset1 = Buffer.Size;
4232                  size1 = Buffer.Size;
4233              }
4234          }
4235          internal abstract bool OnReceive(long type, byte[] buffer, long offset, long size);
4236      }
4237      public interface IClientListener : ISenderListener, IReceiverListener
4238      {
4239      }
4240      public abstract class Client : IClientListener
4241      {
4242          public Buffer SendBuffer { get; }
4243          public Buffer ReceiveBuffer { get; }
4244          public bool Logging { get; set; }
4245          public bool Final { get; }
4246          protected Mutex Lock { get; }
4247          protected DateTime Timestamp { get; set; }
4248          protected Client(bool final) : this(new Buffer(), new Buffer(), final) {}
4249          protected Client(Buffer sendBuffer, Buffer receiveBuffer, bool final) { SendBuffer = sendBuffer; ReceiveBuffer = receiveBuffer; Final = final; Lock = new Mutex(); Timestamp = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc); }
4250          public void Reset()
4251          {
4252              lock (Lock)
4253              {
4254                  ResetRequests();
4255              }
4256          }
4257          internal virtual void ResetRequests()
4258          {
4259              SendBuffer.Reset();
4260              ReceiveBuffer.Reset();
4261          }
4262          public void Watchdog(DateTime utc)
4263          {
4264              lock (Lock)
4265              {
4266                  WatchdogRequests(utc);
4267              }
4268          }
4269          internal virtual void WatchdogRequests(DateTime utc)
4270          {
4271          }
4272          public long SendSerialized(ISenderListener listener, long serialized)
4273          {
4274              Debug.Assert((serialized > 0), "Invalid size of the serialized buffer!");
4275              if (serialized == 0)
4276                  return 0;
4277              SendBuffer.Shift(serialized);
4278              long sent = listener.OnSend(SendBuffer.Data, 0, SendBuffer.Size);
4279              SendBuffer.Remove(0, sent);
4280              return sent;
4281          }
4282          public void Receive(Buffer buffer) { Receive(buffer.Data, 0, buffer.Size); }
4283          public void Receive(byte[] buffer) { Receive(buffer, 0, buffer.Length); }
4284          public void Receive(byte[] buffer, long offset, long size)
4285          {
4286              Debug.Assert((buffer != null), "Invalid buffer!");
4287              if (buffer == null)
4288                  throw new ArgumentException("Invalid buffer!", nameof(buffer));
4289              Debug.Assert(((offset + size) <= buffer.Length), "Invalid offset & size!");
4290              if ((offset + size) > buffer.Length)
4291                  throw new ArgumentException("Invalid offset & size!", nameof(offset));
4292              if (size == 0)
4293                  return;
4294              long offset0 = ReceiveBuffer.Offset;
4295              long offset1 = ReceiveBuffer.Size;
4296              long size1 = ReceiveBuffer.Size;
4297              long offset2 = 0;
4298              long size2 = size;
4299              while (offset2 < size2)
4300              {
4301                  byte[] messageBuffer = null;
4302                  long messageOffset = 0;
4303                  long messageSize = 0;
4304                  bool messageSizeCopied = false;
4305                  bool messageSizeFound = false;
4306                  while (!messageSizeFound)
4307                  {
4308                      if (offset0 < size1)
4309                      {
4310                          long count = Math.Min(size1 - offset0, 4);
4311                          if (count == 4)
4312                          {
4313                              messageSizeCopied = true;
4314                              messageSizeFound = true;
4315                              messageSize = Buffer.ReadUInt32(ReceiveBuffer.Data, offset0);
4316                              offset0 += 4;
4317                              break;
4318                          }
4319                          else
4320                          {
4321                              if (offset2 < size2)
4322                              {
4323                                  count = Math.Min(size2 - offset2, 4 - count);
4324                                  ReceiveBuffer.Allocate(count);
4325                                  size1 += count;
4326                                  Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4327                                  offset1 += count;
4328                                  offset2 += count;
4329                                  continue;
4330                              }
4331                              else
4332                                  break;
4333                          }
4334                      }
4335                      if (offset2 < size2)
4336                      {
4337                          long count = Math.Min(size2 - offset2, 4);
4338                          if (count == 4)
4339                          {
4340                              messageSizeFound = true;
4341                              messageSize = Buffer.ReadUInt32(buffer, offset + offset2);
4342                              offset2 += 4;
4343                              break;
4344                          }
4345                          else
4346                          {
4347                              ReceiveBuffer.Allocate(count);
4348                              size1 += count;
4349                              Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4350                              offset1 += count;
4351                              offset2 += count;
4352                              continue;
4353                          }
4354                      }
4355                      else
4356                          break;
4357                  }
4358                  if (!messageSizeFound)
4359                      return;
4360                  long minSize = Final ? (4 + 4) : (4 + 4 + 4 + 4);
4361                  Debug.Assert((messageSize >= minSize), "Invalid receive data!");
4362                  if (messageSize < minSize)
4363                      return;
4364                  bool messageFound = false;
4365                  while (!messageFound)
4366                  {
4367                      if (offset0 < size1)
4368                      {
4369                          long count = Math.Min(size1 - offset0, messageSize - 4);
4370                          if (count == (messageSize - 4))
4371                          {
4372                              messageFound = true;
4373                              messageBuffer = ReceiveBuffer.Data;
4374                              messageOffset = offset0 - 4;
4375                              offset0 += messageSize - 4;
4376                              break;
4377                          }
4378                          else
4379                          {
4380                              if (offset2 < size2)
4381                              {
4382                                  if (!messageSizeCopied)
4383                                  {
4384                                      ReceiveBuffer.Allocate(4);
4385                                      size1 += 4;
4386                                      Buffer.Write(ReceiveBuffer.Data, offset0, (uint)messageSize);
4387                                      offset0 += 4;
4388                                      offset1 += 4;
4389                                      messageSizeCopied = true;
4390                                  }
4391                                  count = Math.Min(size2 - offset2, messageSize - 4 - count);
4392                                  ReceiveBuffer.Allocate(count);
4393                                  size1 += count;
4394                                  Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4395                                  offset1 += count;
4396                                  offset2 += count;
4397                                  continue;
4398                              }
4399                              else
4400                                  break;
4401                          }
4402                      }
4403                      if (offset2 < size2)
4404                      {
4405                          long count = Math.Min(size2 - offset2, messageSize - 4);
4406                          if (!messageSizeCopied && (count == (messageSize - 4)))
4407                          {
4408                              messageFound = true;
4409                              messageBuffer = buffer;
4410                              messageOffset = offset + offset2 - 4;
4411                              offset2 += messageSize - 4;
4412                              break;
4413                          }
4414                          else
4415                          {
4416                              if (!messageSizeCopied)
4417                              {
4418                                  ReceiveBuffer.Allocate(4);
4419                                  size1 += 4;
4420                                  Buffer.Write(ReceiveBuffer.Data, offset0, (uint)messageSize);
4421                                  offset0 += 4;
4422                                  offset1 += 4;
4423                                  messageSizeCopied = true;
4424                              }
4425                              ReceiveBuffer.Allocate(count);
4426                              size1 += count;
4427                              Array.Copy(buffer, offset + offset2, ReceiveBuffer.Data, offset1, count);
4428                              offset1 += count;
4429                              offset2 += count;
4430                              continue;
4431                          }
4432                      }
4433                      else
4434                          break;
4435                  }
4436                  if (!messageFound)
4437                  {
4438                      if (!messageSizeCopied)
4439                      {
4440                          ReceiveBuffer.Allocate(4);
4441                          size1 += 4;
4442                          Buffer.Write(ReceiveBuffer.Data, offset0, (uint)messageSize);
4443                          offset0 += 4;
4444                          offset1 += 4;
4445                          messageSizeCopied = true;
4446                      }
4447                      return;
4448                  }
4449                  uint fbeStructSize;
4450                  uint fbeStructType;
4451                  if (Final)
4452                  {
4453                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset);
4454                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4455                  }
4456                  else
4457                  {
4458                      uint fbeStructOffset = Buffer.ReadUInt32(messageBuffer, messageOffset + 4);
4459                      fbeStructSize = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset);
4460                      fbeStructType = Buffer.ReadUInt32(messageBuffer, messageOffset + fbeStructOffset + 4);
4461                  }
4462                  OnReceive(fbeStructType, messageBuffer, messageOffset, messageSize);
4463                  ReceiveBuffer.Reset();
4464                  offset0 = ReceiveBuffer.Offset;
4465                  offset1 = ReceiveBuffer.Size;
4466                  size1 = ReceiveBuffer.Size;
4467              }
4468          }
4469          internal abstract bool OnReceive(long type, byte[] buffer, long offset, long size);
4470      }
4471  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-com.chronoxor.fbe.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-com.chronoxor.fbe.cs</div>
                </div>
                <div class="column column_space"><pre><code>1204                  return;
1205              Value.Get(out var temp);
1206              optional = temp;
1207              GetEnd(fbeBegin);
1208          }
1209          public long SetBegin(bool hasValue)
1210          {
1211              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1212              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1213                  return 0;
1214              byte fbeHasValue = (byte)(hasValue ? 1 : 0);
1215              Write(FBEOffset, fbeHasValue);
1216              if (fbeHasValue == 0)
1217                  return 0;
1218              uint fbeOptionalSize = (uint)Value.FBESize;
1219              uint fbeOptionalOffset = (uint)(_buffer.Allocate(fbeOptionalSize) - _buffer.Offset);
1220              Debug.Assert(((fbeOptionalOffset > 0) && ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.Size)), "Model is broken!");
1221              if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.Size))
1222                  return 0;
1223              Write(FBEOffset + 1, fbeOptionalOffset);
1224              _buffer.Shift(fbeOptionalOffset);
1225              return fbeOptionalOffset;
1226          }
1227          public void SetEnd(long fbeBegin)
1228          {
1229              _buffer.Unshift(fbeBegin);
1230          }
1231          public void Set(T? optional)
</pre></code></div>
                <div class="column column_space"><pre><code>1315                  return;
1316              Value.Get(out var temp);
1317              optional = temp;
1318              GetEnd(fbeBegin);
1319          }
1320          public long SetBegin(bool hasValue)
1321          {
1322              Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
1323              if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
1324                  return 0;
1325              byte fbeHasValue = (byte)(hasValue ? 1 : 0);
1326              Write(FBEOffset, fbeHasValue);
1327              if (fbeHasValue == 0)
1328                  return 0;
1329              uint fbeOptionalSize = (uint)Value.FBESize;
1330              uint fbeOptionalOffset = (uint)(_buffer.Allocate(fbeOptionalSize) - _buffer.Offset);
1331              Debug.Assert(((fbeOptionalOffset > 0) && ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.Size)), "Model is broken!");
1332              if ((fbeOptionalOffset == 0) || ((_buffer.Offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.Size))
1333                  return 0;
1334              Write(FBEOffset + 1, fbeOptionalOffset);
1335              _buffer.Shift(fbeOptionalOffset);
1336              return fbeOptionalOffset;
1337          }
1338          public void SetEnd(long fbeBegin)
1339          {
1340              _buffer.Unshift(fbeBegin);
1341          }
1342          public void Set(T optional)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    