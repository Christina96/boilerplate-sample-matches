
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-WrappedException.cs</h3>
            <pre><code>1  using GitHub.Services.Common;
2  using Newtonsoft.Json;
3  using System;
4  using System.Collections.Generic;
5  using System.Diagnostics;
6  using System.IO;
7  using System.Linq;
8  using System.Reflection;
9  using System.Runtime.Serialization;
10  namespace GitHub.Services.WebApi
11  {
12      [DataContract(IsReference = true)]
13      public class WrappedException : ISecuredObject
14      {
15          public WrappedException()
16          {
17          }
18          public WrappedException(Exception exception, Boolean includeErrorDetail, Version restApiVersion)
19          {
20              if ((exception is AggregateException) &amp;&amp;
21                  (((AggregateException)exception).InnerExceptions != null) &amp;&amp;
22                  (((AggregateException)exception).Flatten().InnerExceptions.Count == 1))
23              {
24                  exception = ((AggregateException)exception).Flatten().InnerException;
25              }
26              Type type = exception.GetType();
27              String typeName, typeKey;
28              if (exception is VssServiceResponseException)
29              {
30                  type = typeof(VssServiceException);
<span onclick='openModal()' class='match'>31                  VssException.GetTypeNameAndKeyForExceptionType(type, restApiVersion, out typeName, out typeKey);
32              }
33              else if (exception is VssServiceException)
</span>34              {
35                  ((VssServiceException)exception).GetTypeNameAndKey(restApiVersion, out typeName, out typeKey);
36              }
37              else
38              {
39                  VssException.GetTypeNameAndKeyForExceptionType(type, restApiVersion, out typeName, out typeKey);
40              }
41              this.Type = type;
42              this.TypeName = typeName;
43              this.TypeKey = typeKey;
44              if (includeErrorDetail &amp;&amp; exception.InnerException != null)
45              {
46                  InnerException = new WrappedException(exception.InnerException, includeErrorDetail, restApiVersion);
47              }
48              Message = exception.Message;
49              if (includeErrorDetail)
50              {
51                  StackTrace = exception.StackTrace ?? new StackTrace(2, true).ToString();
52              }
53              if (!string.IsNullOrWhiteSpace(exception.HelpLink))
54              {
55                  HelpLink = exception.HelpLink;
56              }
57              if (exception is VssException)
58              {
59                  EventId = ((VssException)exception).EventId;
60                  ErrorCode = ((VssException)exception).ErrorCode;
61              }
62              TryWrapCustomProperties(exception);
63          }
64          [DataMember(EmitDefaultValue = false, IsRequired = false)]
65          public Dictionary&lt;string, object&gt; CustomProperties
66          {
67              get;
68              set;
69          }
70          [DataMember]
71          public WrappedException InnerException { get; set; }
72          public Exception UnwrappedInnerException { get; set; }
73          [DataMember]
74          public String Message { get; set; }
75          [DataMember(EmitDefaultValue = false, IsRequired = false)]
76          public String HelpLink { get; set; }
77          public Type Type
78          {
79              get
80              {
81                  if (m_type == null)
82                  {
83                      if (!String.IsNullOrEmpty(TypeName))
84                      {
85                          m_type = LoadType(TypeName);
86                      }
87                  }
88                  return m_type;
89              }
90              set
91              {
92                  m_type = value;
93              }
94          }
95          private Type m_type;
96          private string m_typeName;
97          [DataMember]
98          public String TypeName
99          {
100              get
101              {
102                  return m_typeName;
103              }
104              set
105              {
106                  if (value.Contains(&quot;Microsoft.VisualStudio&quot;))
107                  {
108                      m_typeName = value.Replace(&quot;Microsoft.VisualStudio&quot;, &quot;GitHub&quot;);
109                      m_typeName = m_typeName.Substring(0, m_typeName.IndexOf(&quot;,&quot;)) + &quot;, Sdk&quot;;
110                  }
111                  else if (value.Contains(&quot;Microsoft.Azure.DevOps&quot;))
112                  {
113                      m_typeName = value.Replace(&quot;Microsoft.Azure.DevOps&quot;, &quot;GitHub&quot;);
114                      m_typeName = m_typeName.Substring(0, m_typeName.IndexOf(&quot;,&quot;)) + &quot;, Sdk&quot;;
115                  }
116                  else if (value.Contains(&quot;Microsoft.TeamFoundation&quot;))
117                  {
118                      m_typeName = value.Replace(&quot;Microsoft.TeamFoundation&quot;, &quot;GitHub&quot;);
119                      m_typeName = m_typeName.Substring(0, m_typeName.IndexOf(&quot;,&quot;)) + &quot;, Sdk&quot;;
120                  }
121                  else
122                  {
123                      m_typeName = value;
124                  }
125              }
126          }
127          [DataMember]
128          public String TypeKey
129          {
130              get;
131              set;
132          }
133          [DataMember]
134          public int ErrorCode
135          {
136              get;
137              set;
138          }
139          [DataMember]
140          public int EventId
141          {
142              get;
143              set;
144          }
145          [DataMember(EmitDefaultValue = false, IsRequired = false)]
146          public string StackTrace
147          {
148              get;
149              set;
150          }
151          public Exception Unwrap(IDictionary&lt;String, Type&gt; typeMapping)
152          {
153              Exception innerException = null;
154              if (InnerException != null)
155              {
156                  innerException = InnerException.Unwrap(typeMapping);
157                  UnwrappedInnerException = innerException;
158              }
159              Exception exception = null;
160              if (!String.IsNullOrEmpty(TypeKey))
161              {
162                  Type type;
163                  if (typeMapping != null &amp;&amp; typeMapping.TryGetValue(TypeKey, out type) ||
164                      baseTranslatedExceptions.TryGetValue(TypeKey, out type))
165                  {
166                      try
167                      {
168                          this.Type = type;
169                          exception = Activator.CreateInstance(this.Type, Message, innerException) as Exception;
170                      }
171                      catch (Exception)
172                      {
173                      }
174                  }
175              }
176              if (exception == null)
177              {
178                  exception = UnWrap(innerException);
179              }
180              if (exception is VssException)
181              {
182                  ((VssException)exception).EventId = this.EventId;
183                  ((VssException)exception).ErrorCode = this.ErrorCode;
184              }
185              if (exception == null &amp;&amp; !String.IsNullOrEmpty(Message))
186              {
187                  exception = new VssServiceException(Message, innerException);
188              }
189              if (exception == null &amp;&amp; !string.IsNullOrEmpty(TypeName))
190              {
191                  Debug.Assert(false, string.Format(&quot;Server exception cannot be resolved. Type name: {0}&quot;, TypeName));
192              }
193              if (exception != null
194                  &amp;&amp; !string.IsNullOrEmpty(HelpLink))
195              {
196                  exception.HelpLink = HelpLink;
197              }
198              if (exception != null
199                  &amp;&amp; !string.IsNullOrEmpty(this.StackTrace))
200              {
201                  FieldInfo stackTraceField = typeof(Exception).GetTypeInfo().GetDeclaredField(&quot;_stackTraceString&quot;);
202                  if (stackTraceField != null &amp;&amp; !stackTraceField.Attributes.HasFlag(FieldAttributes.Public) &amp;&amp; !stackTraceField.Attributes.HasFlag(FieldAttributes.Static))
203                  {
204                      stackTraceField.SetValue(exception, this.StackTrace);
205                  }
206              }
207              if (exception != null &amp;&amp; exception.GetType() == this.Type)
208              {
209                  TryUnWrapCustomProperties(exception);
210              }
211              return exception;
212          }
213          private Exception UnWrap(Exception innerException)
214          {
215              Exception exception = null;
216              if (this.Type != null)  
217              {
218                  try
219                  {
220                      Object[] args = null;
221                      ConstructorInfo info = GetMatchingConstructor(new[] { typeof(WrappedException) });
222                      if (info != null)
223                      {
224                          args = new object[] { this };
225                      }
226                      else
227                      {
228                          info = GetMatchingConstructor(new[] { typeof(String), typeof(Exception) });
229                          if (info != null)
230                          {
231                              args = new object[] { Message, innerException };
232                          }
233                          else
234                          {
235                              info = GetMatchingConstructor(new[] { typeof(String) });
236                              if (info != null)
237                              {
238                                  args = new object[] { Message };
239                              }
240                              else
241                              {
242                                  info = GetMatchingConstructor(new Type[0]);
243                              }
244                          }
245                      }
246                      if (info != null)
247                      {
248                          exception = info.Invoke(args) as Exception;
249                          Debug.Assert(!(exception is VssException) || exception.Message == Message,
250                              &quot;The unwrapped exception message does not match the original exception message.&quot;,
251                              &quot;Type: {0}{1}Expected: {2}{1}Actual: {3}{1}{1}This can happen if the exception has a contructor that manipulates the input string.  You can work around this by creating a constructor that takes in a WrappedException which sets the message verbatim and optionally the inner exception.&quot;,
252                              exception.GetType(),
253                              Environment.NewLine,
254                              Message,
255                              exception.Message);
256                      }
257                  }
258                  catch (Exception)
259                  { }
260              }
261              return exception;
262          }
263          private ConstructorInfo GetMatchingConstructor(params Type[] parameterTypes)
264          {
265              return this.Type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, parameterTypes, null);
266          }
267          private static Type LoadType(String typeName)
268          {
269              Type ret = null;
270              try
271              {
272                  ret = Type.GetType(typeName, false, true);
273              }
274              catch (Exception)
275              {
276              }
277              if (ret == null)
278              {
279                  ret = LookupExceptionAttributeMapping(typeName);
280                  if (ret == null)
281                  {
282                      try
283                      {
284                          ret = Type.GetType(typeName,
285                                              ResolveAssembly,
286                                              null,
287                                              false,
288                                              true);
289                      }
290                      catch (Exception)
291                      {
292                      }
293                  }
294              }
295              return ret;
296          }
297          private static Assembly ResolveAssembly(AssemblyName asmName)
298          {
299              if (asmName.Version == null || asmName.Version.Major &lt;= c_backCompatVer)
300              {
301                  AssemblyName newName = new AssemblyName
302                  {
303                      Name = asmName.Name,
304                      CultureInfo = asmName.CultureInfo
305                  };
306                  newName.SetPublicKeyToken(asmName.GetPublicKeyToken());
307                  try
308                  {
309                      var ret = Assembly.Load(newName);
310                      if (ret != null)
311                      {
312                          return ret;
313                      }
314                  }
315                  catch (Exception)
316                  { }
317              }
318              string currentPath = Assembly.GetExecutingAssembly().Location;
319              if (!String.IsNullOrEmpty(currentPath))
320              {
321                  string fullPath = Path.Combine(Path.GetDirectoryName(currentPath), asmName.Name + &quot;.dll&quot;);
322                  if (File.Exists(fullPath))
323                  {
324                      return Assembly.LoadFrom(fullPath);
325                  }
326              }
327              return null;
328          }
329          private const int c_backCompatVer = 14;
330          private static Type LookupExceptionAttributeMapping(string typeName)
331          {
332              Type mappedType = null;
333              Tuple&lt;Version, Type&gt; cacheEntry = null;
334              lock (syncObject)
335              {
336                  if (!s_exceptionsWithAttributeMapping.TryGetValue(typeName, out cacheEntry))
337                  {
338                      UpdateExceptionAttributeMappingCache();
339                      s_exceptionsWithAttributeMapping.TryGetValue(typeName, out cacheEntry);
340                  }
341              }
342              if (cacheEntry != null)
343              {
344                  mappedType = cacheEntry.Item2;
345              }
346              return mappedType;
347          }
348          private static void UpdateExceptionAttributeMappingCache()
349          {
350              foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies().Where(a =&gt; !s_assembliesCheckedForExceptionMappings.Contains(a)))
351              {
352                  if (DoesAssemblyQualify(assembly)) 
353                  {
354                      try
355                      {
356                          IEnumerable&lt;Type&gt; types;
357                          try
358                          {
359                              types = assembly.GetTypes();
360                          }
361                          catch (ReflectionTypeLoadException ex)
362                          {
363                              types = ex.Types.Where&lt;Type&gt;(t =&gt; t != null);
364                          }
365                          foreach (TypeInfo typeInfo in types)
366                          {
367                              foreach (ExceptionMappingAttribute attribute in typeInfo.GetCustomAttributes&lt;ExceptionMappingAttribute&gt;())
368                              {
369                                  Tuple&lt;Version, Type&gt; cachedValue;
370                                  if (!s_exceptionsWithAttributeMapping.TryGetValue(attribute.TypeName, out cachedValue) || attribute.ExclusiveMaxApiVersion &gt; cachedValue.Item1)
371                                  {
372                                      s_exceptionsWithAttributeMapping[attribute.TypeName] = new Tuple&lt;Version, Type&gt;(attribute.ExclusiveMaxApiVersion, typeInfo.AsType());
373                                  }
374                              }
375                          }
376                      }
377                      catch (Exception)
378                      {
379                      }
380                  }
381                  s_assembliesCheckedForExceptionMappings.Add(assembly); 
382              }
383          }
384          private static bool DoesAssemblyQualify(Assembly assembly)
385          {
386              if (s_currentAssemblyPublicKeyToken == null || s_currentAssemblyVersion == null)
387              {
388                  AssemblyName thisAssemblyName = typeof(WrappedException).GetTypeInfo().Assembly.GetName();
389                  s_currentAssemblyPublicKeyToken = thisAssemblyName.GetPublicKeyToken();
390                  s_currentAssemblyVersion = thisAssemblyName.Version;
391              }
392              AssemblyName assemblyName = assembly.GetName();
393              if (assemblyName.Version.Major != s_currentAssemblyVersion.Major)
394              {
395                  return false;
396              }
397              byte[] assemblyPublicKeyToken = assemblyName.GetPublicKeyToken();
398              return ArrayUtility.Equals(s_currentAssemblyPublicKeyToken, assemblyPublicKeyToken) ||
399                     ArrayUtility.Equals(s_testCodePublicKeyToken, assemblyPublicKeyToken);
400          }
401          private static object syncObject = new Object();
402          private static byte[] s_currentAssemblyPublicKeyToken = null;
403          private static Version s_currentAssemblyVersion = null;
404          private static HashSet&lt;Assembly&gt; s_assembliesCheckedForExceptionMappings = new HashSet&lt;Assembly&gt;();
405          private static readonly byte[] s_testCodePublicKeyToken = new byte[] { 0x68, 0x9d, 0x5c, 0x3b, 0x19, 0xaa, 0xe6, 0x23 };
406          private static Dictionary&lt;string, Tuple&lt;Version, Type&gt;&gt; s_exceptionsWithAttributeMapping = new Dictionary&lt;string, Tuple&lt;Version, Type&gt;&gt;();
407          private void TryWrapCustomProperties(Exception exception)
408          {
409              var customPropertiesWithDataMemberAttribute = GetCustomPropertiesInfo();
410              if (customPropertiesWithDataMemberAttribute.Any())
411              {
412                  this.CustomProperties = new Dictionary&lt;string, object&gt;();
413              }
414              foreach (var customProperty in customPropertiesWithDataMemberAttribute)
415              {
416                  try
417                  {
418                      this.CustomProperties.Add(customProperty.Name, customProperty.GetValue(exception));
419                  }
420                  catch
421                  {
422                  }
423              }
424          }
425          private void TryUnWrapCustomProperties(Exception exception)
426          {
427              if (this.CustomProperties != null)
428              {
429                  foreach (var property in GetCustomPropertiesInfo())
430                  {
431                      if (this.CustomProperties.ContainsKey(property.Name))
432                      {
433                          try
434                          {
435                              var propertyValue = JsonConvert.DeserializeObject(JsonConvert.SerializeObject(CustomProperties[property.Name]), property.PropertyType);
436                              property.SetValue(exception, propertyValue);
437                          }
438                          catch
439                          {
440                          }
441                      }
442                  }
443              }
444          }
445          private IEnumerable&lt;PropertyInfo&gt; GetCustomPropertiesInfo()
446          {
447              return this.Type.GetTypeInfo().DeclaredProperties.Where(p =&gt; p.GetMethod.Attributes.HasFlag(MethodAttributes.Public)
448                  &amp;&amp; !p.GetMethod.Attributes.HasFlag(MethodAttributes.Static)
449                  &amp;&amp; p.CustomAttributes.Any(a =&gt; a.AttributeType.GetTypeInfo().IsAssignableFrom(typeof(DataMemberAttribute).GetTypeInfo())));
450          }
451          #region ISecuredObject
452          Guid ISecuredObject.NamespaceId =&gt; throw new NotImplementedException();
453          int ISecuredObject.RequiredPermissions =&gt; throw new NotImplementedException();
454          string ISecuredObject.GetToken() =&gt; throw new NotImplementedException();
455          #endregion  
456          private static readonly IDictionary&lt;String, Type&gt; baseTranslatedExceptions = new Dictionary&lt;string, Type&gt;()
457          {
458              { &quot;VssAccessCheckException&quot;, typeof(Security.AccessCheckException) }
459          };
460      }
461  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-WrappedException.cs</h3>
            <pre><code>1  using GitHub.Services.Common;
2  using Newtonsoft.Json;
3  using System;
4  using System.Collections.Generic;
5  using System.Diagnostics;
6  using System.IO;
7  using System.Linq;
8  using System.Reflection;
9  using System.Runtime.Serialization;
10  namespace GitHub.Services.WebApi
11  {
12      [DataContract(IsReference = true)]
13      public class WrappedException : ISecuredObject
14      {
15          public WrappedException()
16          {
17          }
18          public WrappedException(Exception exception, Boolean includeErrorDetail, Version restApiVersion)
19          {
20              if ((exception is AggregateException) &amp;&amp;
21                  (((AggregateException)exception).InnerExceptions != null) &amp;&amp;
22                  (((AggregateException)exception).Flatten().InnerExceptions.Count == 1))
23              {
24                  exception = ((AggregateException)exception).Flatten().InnerException;
25              }
26              Type type = exception.GetType();
27              String typeName, typeKey;
28              if (exception is VssServiceResponseException)
29              {
30                  type = typeof(VssServiceException);
31                  VssException.GetTypeNameAndKeyForExceptionType(type, restApiVersion, out typeName, out typeKey);
32              }
33              else if (exception is VssServiceException)
34              {
35                  ((VssServiceException)exception).GetTypeNameAndKey(restApiVersion, out typeName, out typeKey);
36              }
37              else
38              {
<span onclick='openModal()' class='match'>39                  VssException.GetTypeNameAndKeyForExceptionType(type, restApiVersion, out typeName, out typeKey);
40              }
41              this.Type = type;
</span>42              this.TypeName = typeName;
43              this.TypeKey = typeKey;
44              if (includeErrorDetail &amp;&amp; exception.InnerException != null)
45              {
46                  InnerException = new WrappedException(exception.InnerException, includeErrorDetail, restApiVersion);
47              }
48              Message = exception.Message;
49              if (includeErrorDetail)
50              {
51                  StackTrace = exception.StackTrace ?? new StackTrace(2, true).ToString();
52              }
53              if (!string.IsNullOrWhiteSpace(exception.HelpLink))
54              {
55                  HelpLink = exception.HelpLink;
56              }
57              if (exception is VssException)
58              {
59                  EventId = ((VssException)exception).EventId;
60                  ErrorCode = ((VssException)exception).ErrorCode;
61              }
62              TryWrapCustomProperties(exception);
63          }
64          [DataMember(EmitDefaultValue = false, IsRequired = false)]
65          public Dictionary&lt;string, object&gt; CustomProperties
66          {
67              get;
68              set;
69          }
70          [DataMember]
71          public WrappedException InnerException { get; set; }
72          public Exception UnwrappedInnerException { get; set; }
73          [DataMember]
74          public String Message { get; set; }
75          [DataMember(EmitDefaultValue = false, IsRequired = false)]
76          public String HelpLink { get; set; }
77          public Type Type
78          {
79              get
80              {
81                  if (m_type == null)
82                  {
83                      if (!String.IsNullOrEmpty(TypeName))
84                      {
85                          m_type = LoadType(TypeName);
86                      }
87                  }
88                  return m_type;
89              }
90              set
91              {
92                  m_type = value;
93              }
94          }
95          private Type m_type;
96          private string m_typeName;
97          [DataMember]
98          public String TypeName
99          {
100              get
101              {
102                  return m_typeName;
103              }
104              set
105              {
106                  if (value.Contains(&quot;Microsoft.VisualStudio&quot;))
107                  {
108                      m_typeName = value.Replace(&quot;Microsoft.VisualStudio&quot;, &quot;GitHub&quot;);
109                      m_typeName = m_typeName.Substring(0, m_typeName.IndexOf(&quot;,&quot;)) + &quot;, Sdk&quot;;
110                  }
111                  else if (value.Contains(&quot;Microsoft.Azure.DevOps&quot;))
112                  {
113                      m_typeName = value.Replace(&quot;Microsoft.Azure.DevOps&quot;, &quot;GitHub&quot;);
114                      m_typeName = m_typeName.Substring(0, m_typeName.IndexOf(&quot;,&quot;)) + &quot;, Sdk&quot;;
115                  }
116                  else if (value.Contains(&quot;Microsoft.TeamFoundation&quot;))
117                  {
118                      m_typeName = value.Replace(&quot;Microsoft.TeamFoundation&quot;, &quot;GitHub&quot;);
119                      m_typeName = m_typeName.Substring(0, m_typeName.IndexOf(&quot;,&quot;)) + &quot;, Sdk&quot;;
120                  }
121                  else
122                  {
123                      m_typeName = value;
124                  }
125              }
126          }
127          [DataMember]
128          public String TypeKey
129          {
130              get;
131              set;
132          }
133          [DataMember]
134          public int ErrorCode
135          {
136              get;
137              set;
138          }
139          [DataMember]
140          public int EventId
141          {
142              get;
143              set;
144          }
145          [DataMember(EmitDefaultValue = false, IsRequired = false)]
146          public string StackTrace
147          {
148              get;
149              set;
150          }
151          public Exception Unwrap(IDictionary&lt;String, Type&gt; typeMapping)
152          {
153              Exception innerException = null;
154              if (InnerException != null)
155              {
156                  innerException = InnerException.Unwrap(typeMapping);
157                  UnwrappedInnerException = innerException;
158              }
159              Exception exception = null;
160              if (!String.IsNullOrEmpty(TypeKey))
161              {
162                  Type type;
163                  if (typeMapping != null &amp;&amp; typeMapping.TryGetValue(TypeKey, out type) ||
164                      baseTranslatedExceptions.TryGetValue(TypeKey, out type))
165                  {
166                      try
167                      {
168                          this.Type = type;
169                          exception = Activator.CreateInstance(this.Type, Message, innerException) as Exception;
170                      }
171                      catch (Exception)
172                      {
173                      }
174                  }
175              }
176              if (exception == null)
177              {
178                  exception = UnWrap(innerException);
179              }
180              if (exception is VssException)
181              {
182                  ((VssException)exception).EventId = this.EventId;
183                  ((VssException)exception).ErrorCode = this.ErrorCode;
184              }
185              if (exception == null &amp;&amp; !String.IsNullOrEmpty(Message))
186              {
187                  exception = new VssServiceException(Message, innerException);
188              }
189              if (exception == null &amp;&amp; !string.IsNullOrEmpty(TypeName))
190              {
191                  Debug.Assert(false, string.Format(&quot;Server exception cannot be resolved. Type name: {0}&quot;, TypeName));
192              }
193              if (exception != null
194                  &amp;&amp; !string.IsNullOrEmpty(HelpLink))
195              {
196                  exception.HelpLink = HelpLink;
197              }
198              if (exception != null
199                  &amp;&amp; !string.IsNullOrEmpty(this.StackTrace))
200              {
201                  FieldInfo stackTraceField = typeof(Exception).GetTypeInfo().GetDeclaredField(&quot;_stackTraceString&quot;);
202                  if (stackTraceField != null &amp;&amp; !stackTraceField.Attributes.HasFlag(FieldAttributes.Public) &amp;&amp; !stackTraceField.Attributes.HasFlag(FieldAttributes.Static))
203                  {
204                      stackTraceField.SetValue(exception, this.StackTrace);
205                  }
206              }
207              if (exception != null &amp;&amp; exception.GetType() == this.Type)
208              {
209                  TryUnWrapCustomProperties(exception);
210              }
211              return exception;
212          }
213          private Exception UnWrap(Exception innerException)
214          {
215              Exception exception = null;
216              if (this.Type != null)  
217              {
218                  try
219                  {
220                      Object[] args = null;
221                      ConstructorInfo info = GetMatchingConstructor(new[] { typeof(WrappedException) });
222                      if (info != null)
223                      {
224                          args = new object[] { this };
225                      }
226                      else
227                      {
228                          info = GetMatchingConstructor(new[] { typeof(String), typeof(Exception) });
229                          if (info != null)
230                          {
231                              args = new object[] { Message, innerException };
232                          }
233                          else
234                          {
235                              info = GetMatchingConstructor(new[] { typeof(String) });
236                              if (info != null)
237                              {
238                                  args = new object[] { Message };
239                              }
240                              else
241                              {
242                                  info = GetMatchingConstructor(new Type[0]);
243                              }
244                          }
245                      }
246                      if (info != null)
247                      {
248                          exception = info.Invoke(args) as Exception;
249                          Debug.Assert(!(exception is VssException) || exception.Message == Message,
250                              &quot;The unwrapped exception message does not match the original exception message.&quot;,
251                              &quot;Type: {0}{1}Expected: {2}{1}Actual: {3}{1}{1}This can happen if the exception has a contructor that manipulates the input string.  You can work around this by creating a constructor that takes in a WrappedException which sets the message verbatim and optionally the inner exception.&quot;,
252                              exception.GetType(),
253                              Environment.NewLine,
254                              Message,
255                              exception.Message);
256                      }
257                  }
258                  catch (Exception)
259                  { }
260              }
261              return exception;
262          }
263          private ConstructorInfo GetMatchingConstructor(params Type[] parameterTypes)
264          {
265              return this.Type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, parameterTypes, null);
266          }
267          private static Type LoadType(String typeName)
268          {
269              Type ret = null;
270              try
271              {
272                  ret = Type.GetType(typeName, false, true);
273              }
274              catch (Exception)
275              {
276              }
277              if (ret == null)
278              {
279                  ret = LookupExceptionAttributeMapping(typeName);
280                  if (ret == null)
281                  {
282                      try
283                      {
284                          ret = Type.GetType(typeName,
285                                              ResolveAssembly,
286                                              null,
287                                              false,
288                                              true);
289                      }
290                      catch (Exception)
291                      {
292                      }
293                  }
294              }
295              return ret;
296          }
297          private static Assembly ResolveAssembly(AssemblyName asmName)
298          {
299              if (asmName.Version == null || asmName.Version.Major &lt;= c_backCompatVer)
300              {
301                  AssemblyName newName = new AssemblyName
302                  {
303                      Name = asmName.Name,
304                      CultureInfo = asmName.CultureInfo
305                  };
306                  newName.SetPublicKeyToken(asmName.GetPublicKeyToken());
307                  try
308                  {
309                      var ret = Assembly.Load(newName);
310                      if (ret != null)
311                      {
312                          return ret;
313                      }
314                  }
315                  catch (Exception)
316                  { }
317              }
318              string currentPath = Assembly.GetExecutingAssembly().Location;
319              if (!String.IsNullOrEmpty(currentPath))
320              {
321                  string fullPath = Path.Combine(Path.GetDirectoryName(currentPath), asmName.Name + &quot;.dll&quot;);
322                  if (File.Exists(fullPath))
323                  {
324                      return Assembly.LoadFrom(fullPath);
325                  }
326              }
327              return null;
328          }
329          private const int c_backCompatVer = 14;
330          private static Type LookupExceptionAttributeMapping(string typeName)
331          {
332              Type mappedType = null;
333              Tuple&lt;Version, Type&gt; cacheEntry = null;
334              lock (syncObject)
335              {
336                  if (!s_exceptionsWithAttributeMapping.TryGetValue(typeName, out cacheEntry))
337                  {
338                      UpdateExceptionAttributeMappingCache();
339                      s_exceptionsWithAttributeMapping.TryGetValue(typeName, out cacheEntry);
340                  }
341              }
342              if (cacheEntry != null)
343              {
344                  mappedType = cacheEntry.Item2;
345              }
346              return mappedType;
347          }
348          private static void UpdateExceptionAttributeMappingCache()
349          {
350              foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies().Where(a =&gt; !s_assembliesCheckedForExceptionMappings.Contains(a)))
351              {
352                  if (DoesAssemblyQualify(assembly)) 
353                  {
354                      try
355                      {
356                          IEnumerable&lt;Type&gt; types;
357                          try
358                          {
359                              types = assembly.GetTypes();
360                          }
361                          catch (ReflectionTypeLoadException ex)
362                          {
363                              types = ex.Types.Where&lt;Type&gt;(t =&gt; t != null);
364                          }
365                          foreach (TypeInfo typeInfo in types)
366                          {
367                              foreach (ExceptionMappingAttribute attribute in typeInfo.GetCustomAttributes&lt;ExceptionMappingAttribute&gt;())
368                              {
369                                  Tuple&lt;Version, Type&gt; cachedValue;
370                                  if (!s_exceptionsWithAttributeMapping.TryGetValue(attribute.TypeName, out cachedValue) || attribute.ExclusiveMaxApiVersion &gt; cachedValue.Item1)
371                                  {
372                                      s_exceptionsWithAttributeMapping[attribute.TypeName] = new Tuple&lt;Version, Type&gt;(attribute.ExclusiveMaxApiVersion, typeInfo.AsType());
373                                  }
374                              }
375                          }
376                      }
377                      catch (Exception)
378                      {
379                      }
380                  }
381                  s_assembliesCheckedForExceptionMappings.Add(assembly); 
382              }
383          }
384          private static bool DoesAssemblyQualify(Assembly assembly)
385          {
386              if (s_currentAssemblyPublicKeyToken == null || s_currentAssemblyVersion == null)
387              {
388                  AssemblyName thisAssemblyName = typeof(WrappedException).GetTypeInfo().Assembly.GetName();
389                  s_currentAssemblyPublicKeyToken = thisAssemblyName.GetPublicKeyToken();
390                  s_currentAssemblyVersion = thisAssemblyName.Version;
391              }
392              AssemblyName assemblyName = assembly.GetName();
393              if (assemblyName.Version.Major != s_currentAssemblyVersion.Major)
394              {
395                  return false;
396              }
397              byte[] assemblyPublicKeyToken = assemblyName.GetPublicKeyToken();
398              return ArrayUtility.Equals(s_currentAssemblyPublicKeyToken, assemblyPublicKeyToken) ||
399                     ArrayUtility.Equals(s_testCodePublicKeyToken, assemblyPublicKeyToken);
400          }
401          private static object syncObject = new Object();
402          private static byte[] s_currentAssemblyPublicKeyToken = null;
403          private static Version s_currentAssemblyVersion = null;
404          private static HashSet&lt;Assembly&gt; s_assembliesCheckedForExceptionMappings = new HashSet&lt;Assembly&gt;();
405          private static readonly byte[] s_testCodePublicKeyToken = new byte[] { 0x68, 0x9d, 0x5c, 0x3b, 0x19, 0xaa, 0xe6, 0x23 };
406          private static Dictionary&lt;string, Tuple&lt;Version, Type&gt;&gt; s_exceptionsWithAttributeMapping = new Dictionary&lt;string, Tuple&lt;Version, Type&gt;&gt;();
407          private void TryWrapCustomProperties(Exception exception)
408          {
409              var customPropertiesWithDataMemberAttribute = GetCustomPropertiesInfo();
410              if (customPropertiesWithDataMemberAttribute.Any())
411              {
412                  this.CustomProperties = new Dictionary&lt;string, object&gt;();
413              }
414              foreach (var customProperty in customPropertiesWithDataMemberAttribute)
415              {
416                  try
417                  {
418                      this.CustomProperties.Add(customProperty.Name, customProperty.GetValue(exception));
419                  }
420                  catch
421                  {
422                  }
423              }
424          }
425          private void TryUnWrapCustomProperties(Exception exception)
426          {
427              if (this.CustomProperties != null)
428              {
429                  foreach (var property in GetCustomPropertiesInfo())
430                  {
431                      if (this.CustomProperties.ContainsKey(property.Name))
432                      {
433                          try
434                          {
435                              var propertyValue = JsonConvert.DeserializeObject(JsonConvert.SerializeObject(CustomProperties[property.Name]), property.PropertyType);
436                              property.SetValue(exception, propertyValue);
437                          }
438                          catch
439                          {
440                          }
441                      }
442                  }
443              }
444          }
445          private IEnumerable&lt;PropertyInfo&gt; GetCustomPropertiesInfo()
446          {
447              return this.Type.GetTypeInfo().DeclaredProperties.Where(p =&gt; p.GetMethod.Attributes.HasFlag(MethodAttributes.Public)
448                  &amp;&amp; !p.GetMethod.Attributes.HasFlag(MethodAttributes.Static)
449                  &amp;&amp; p.CustomAttributes.Any(a =&gt; a.AttributeType.GetTypeInfo().IsAssignableFrom(typeof(DataMemberAttribute).GetTypeInfo())));
450          }
451          #region ISecuredObject
452          Guid ISecuredObject.NamespaceId =&gt; throw new NotImplementedException();
453          int ISecuredObject.RequiredPermissions =&gt; throw new NotImplementedException();
454          string ISecuredObject.GetToken() =&gt; throw new NotImplementedException();
455          #endregion  
456          private static readonly IDictionary&lt;String, Type&gt; baseTranslatedExceptions = new Dictionary&lt;string, Type&gt;()
457          {
458              { &quot;VssAccessCheckException&quot;, typeof(Security.AccessCheckException) }
459          };
460      }
461  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-WrappedException.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-WrappedException.cs</div>
                </div>
                <div class="column column_space"><pre><code>31                  VssException.GetTypeNameAndKeyForExceptionType(type, restApiVersion, out typeName, out typeKey);
32              }
33              else if (exception is VssServiceException)
</pre></code></div>
                <div class="column column_space"><pre><code>39                  VssException.GetTypeNameAndKeyForExceptionType(type, restApiVersion, out typeName, out typeKey);
40              }
41              this.Type = type;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    