
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4479804161566707%, Tokens: 10</h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Net;
6  using System.Net.Http;
7  using System.Security.Claims;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using Microsoft.AspNetCore.Authentication.Cookies;
12  using Microsoft.AspNetCore.Builder;
13  using Microsoft.AspNetCore.Hosting;
14  using Microsoft.AspNetCore.Http;
15  using Microsoft.AspNetCore.Http.Extensions;
16  using Microsoft.AspNetCore.TestHost;
17  using Microsoft.AspNetCore.WebUtilities;
18  using Microsoft.Extensions.DependencyInjection;
19  using Microsoft.IdentityModel.Tokens;
20  using Microsoft.Net.Http.Headers;
21  using Xunit;
22  namespace Microsoft.AspNetCore.Authentication.WsFederation
23  {
24      public class WsFederationTest
25      {
26          [Fact]
27          public async Task VerifySchemeDefaults()
28          {
29              var services = new ServiceCollection();
30              services.AddAuthentication().AddWsFederation();
31              var sp = services.BuildServiceProvider();
32              var schemeProvider = sp.GetRequiredService<IAuthenticationSchemeProvider>();
33              var scheme = await schemeProvider.GetSchemeAsync(WsFederationDefaults.AuthenticationScheme);
34              Assert.NotNull(scheme);
35              Assert.Equal("WsFederationHandler", scheme.HandlerType.Name);
36              Assert.Equal(WsFederationDefaults.AuthenticationScheme, scheme.DisplayName);
37          }
38          [Fact]
39          public async Task MissingConfigurationThrows()
40          {
41              var builder = new WebHostBuilder()
42                  .Configure(ConfigureApp)
43                  .ConfigureServices(services =>
44                  {
45                      services.AddAuthentication(sharedOptions =>
46                      {
47                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
48                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
49                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
50                      })
51                      .AddCookie()
52                      .AddWsFederation();
53                  });
54              var server = new TestServer(builder);
55              var httpClient = server.CreateClient();
56              var exception = await Assert.ThrowsAsync<InvalidOperationException>(() => httpClient.GetAsync("/"));
57              Assert.Equal("Provide MetadataAddress, Configuration, or ConfigurationManager to WsFederationOptions", exception.Message);
58          }
59          [Fact]
60          public async Task ChallengeRedirects()
61          {
62              var httpClient = CreateClient();
63              var response = await httpClient.GetAsync("/");
64              Assert.Equal("https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed", response.Headers.Location.GetLeftPart(System.UriPartial.Path));
65              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
66              Assert.Equal("http:&bsol;&bsol;Automation1", queryItems["wtrealm"]);
67              Assert.True(queryItems["wctx"].ToString().Equals(CustomStateDataFormat.ValidStateData), "wctx does not equal ValidStateData");
68              Assert.Equal(httpClient.BaseAddress + "signin-wsfed", queryItems["wreply"]);
69              Assert.Equal("wsignin1.0", queryItems["wa"]);
70          }
71          [Fact]
72          public async Task MapWillNotAffectRedirect()
73          {
74              var httpClient = CreateClient();
75              var response = await httpClient.GetAsync("/mapped-challenge");
76              Assert.Equal("https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed", response.Headers.Location.GetLeftPart(System.UriPartial.Path));
77              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
78              Assert.Equal("http:&bsol;&bsol;Automation1", queryItems["wtrealm"]);
79              Assert.True(queryItems["wctx"].ToString().Equals(CustomStateDataFormat.ValidStateData), "wctx does not equal ValidStateData");
80              Assert.Equal(httpClient.BaseAddress + "signin-wsfed", queryItems["wreply"]);
81              Assert.Equal("wsignin1.0", queryItems["wa"]);
82          }
83          [Fact]
84          public async Task PreMappedWillAffectRedirect()
85          {
86              var httpClient = CreateClient();
87              var response = await httpClient.GetAsync("/premapped-challenge");
88              Assert.Equal("https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed", response.Headers.Location.GetLeftPart(System.UriPartial.Path));
89              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
90              Assert.Equal("http:&bsol;&bsol;Automation1", queryItems["wtrealm"]);
91              Assert.True(queryItems["wctx"].ToString().Equals(CustomStateDataFormat.ValidStateData), "wctx does not equal ValidStateData");
92              Assert.Equal(httpClient.BaseAddress + "premapped-challenge/signin-wsfed", queryItems["wreply"]);
93              Assert.Equal("wsignin1.0", queryItems["wa"]);
94          }
95          [Fact]
96          public async Task ValidTokenIsAccepted()
97          {
98              var httpClient = CreateClient();
99              var response = await httpClient.GetAsync("/");
100              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
101              var request = new HttpRequestMessage(HttpMethod.Post, queryItems["wreply"]);
102              CopyCookies(response, request);
103              request.Content = CreateSignInContent("WsFederation/ValidToken.xml", queryItems["wctx"]);
104              response = await httpClient.SendAsync(request);
105              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
106              request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
107              CopyCookies(response, request);
108              response = await httpClient.SendAsync(request);
109              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
110          }
111          [Fact]
112          public async Task ValidUnsolicitedTokenIsRefused()
113          {
114              var httpClient = CreateClient();
115              var form = CreateSignInContent("WsFederation/ValidToken.xml", suppressWctx: true);
116              var exception = await Assert.ThrowsAsync<Exception>(() => httpClient.PostAsync(httpClient.BaseAddress + "signin-wsfed", form));
117              Assert.Contains("Unsolicited logins are not allowed.", exception.InnerException.Message);
118          }
119          [Fact]
120          public async Task ValidUnsolicitedTokenIsAcceptedWhenAllowed()
121          {
122              var httpClient = CreateClient(allowUnsolicited: true);
123              var form = CreateSignInContent("WsFederation/ValidToken.xml", suppressWctx: true);
124              var response = await httpClient.PostAsync(httpClient.BaseAddress + "signin-wsfed", form);
125              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
126              var request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
127              CopyCookies(response, request);
128              response = await httpClient.SendAsync(request);
129              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
130          }
131          [Fact]
132          public async Task InvalidTokenIsRejected()
133          {
134              var httpClient = CreateClient();
135              var response = await httpClient.GetAsync("/");
136              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
137              var request = new HttpRequestMessage(HttpMethod.Post, queryItems["wreply"]);
138              CopyCookies(response, request);
139              request.Content = CreateSignInContent("WsFederation/InvalidToken.xml", queryItems["wctx"]);
140              response = await httpClient.SendAsync(request);
141              Assert.Equal("AuthenticationFailed", await response.Content.ReadAsStringAsync());
142          }
143          [Fact]
144          public async Task RemoteSignoutRequestTriggersSignout()
145          {
146              var httpClient = CreateClient();
147              var response = await httpClient.GetAsync("/signin-wsfed?wa=wsignoutcleanup1.0");
148              response.EnsureSuccessStatusCode();
149              var cookie = response.Headers.GetValues(HeaderNames.SetCookie).Single();
150              Assert.Equal(".AspNetCore.Cookies=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; samesite=lax", cookie);
151              Assert.Equal("OnRemoteSignOut", response.Headers.GetValues("EventHeader").Single());
152              Assert.Equal("", await response.Content.ReadAsStringAsync());
153          }
154          [Fact]
155          public async Task EventsResolvedFromDI()
156          {
157              var builder = new WebHostBuilder()
158                  .ConfigureServices(services =>
159                  {
160                      services.AddSingleton<MyWsFedEvents>();
161                      services.AddAuthentication(sharedOptions =>
162                      {
163                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
164                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
165                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
166                      })
167                      .AddCookie()
168                      .AddWsFederation(options =>
169                      {
170                          options.Wtrealm = "http:&bsol;&bsol;Automation1";
171                          options.MetadataAddress = "https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml";
172                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
173                          options.EventsType = typeof(MyWsFedEvents);
174                      });
175                  })
176                  .Configure(app =>
177                  {
178                      app.Run(context => context.ChallengeAsync());
179                  });
180              var server = new TestServer(builder);
181              var result = await server.CreateClient().GetAsync("");
182              Assert.Contains("CustomKey=CustomValue", result.Headers.Location.Query);
183          }
184          private class MyWsFedEvents : WsFederationEvents
185          {
186              public override Task RedirectToIdentityProvider(RedirectContext context)
187              {
188                  context.ProtocolMessage.SetParameter("CustomKey", "CustomValue");
189                  return base.RedirectToIdentityProvider(context);
190              }
191          }
192          private FormUrlEncodedContent CreateSignInContent(string tokenFile, string wctx = null, bool suppressWctx = false)
193          {
194              var kvps = new List<KeyValuePair<string, string>>();
195              kvps.Add(new KeyValuePair<string, string>("wa", "wsignin1.0"));
196              kvps.Add(new KeyValuePair<string, string>("wresult", File.ReadAllText(tokenFile)));
197              if (!string.IsNullOrEmpty(wctx))
198              {
199                  kvps.Add(new KeyValuePair<string, string>("wctx", wctx));
200              }
201              if (suppressWctx)
202              {
203                  kvps.Add(new KeyValuePair<string, string>("suppressWctx", "true"));
204              }
205              return new FormUrlEncodedContent(kvps);
206          }
207          private void CopyCookies(HttpResponseMessage response, HttpRequestMessage request)
208          {
209              var cookies = SetCookieHeaderValue.ParseList(response.Headers.GetValues(HeaderNames.SetCookie).ToList());
210              foreach (var cookie in cookies)
211              {
212                  if (cookie.Value.HasValue)
213                  {
214                      request.Headers.Add(HeaderNames.Cookie, new CookieHeaderValue(cookie.Name, cookie.Value).ToString());
215                  }
216              }
217          }
218          private HttpClient CreateClient(bool allowUnsolicited = false)
219          {
220              var builder = new WebHostBuilder()
221                  .Configure(ConfigureApp)
222                  .ConfigureServices(services =>
223                  {
224                      services.AddAuthentication(sharedOptions =>
225                      {
226                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
227                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
228                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
229                      })
230                      .AddCookie()
231                      .AddWsFederation(options =>
232                      {
233                          options.Wtrealm = "http:&bsol;&bsol;Automation1";
234                          options.MetadataAddress = "https:&bsol;&bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml";
235                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
236                          options.StateDataFormat = new CustomStateDataFormat();
237                          options.SecurityTokenHandlers = new List<ISecurityTokenValidator>() { new TestSecurityTokenValidator() };
238                          options.UseTokenLifetime = false;
239                          options.AllowUnsolicitedLogins = allowUnsolicited;
240                          options.Events = new WsFederationEvents()
241                          {
242                              OnMessageReceived = context =>
243                              {
244                                  if (!context.ProtocolMessage.Parameters.TryGetValue("suppressWctx", out var suppress))
245                                  {
246                                      Assert.True(context.ProtocolMessage.Wctx.Equals("customValue"), "wctx is not my custom value");
247                                  }
248                                  context.HttpContext.Items["MessageReceived"] = true;
249                                  return Task.FromResult(0);
250                              },
251                              OnRedirectToIdentityProvider = context =>
252                              {
253                                  if (context.ProtocolMessage.IsSignInMessage)
254                                  {
255                                      context.ProtocolMessage.Wctx = "customValue";
256                                  }
257                                  return Task.FromResult(0);
258                              },
259                              OnSecurityTokenReceived = context =>
260                              {
261                                  context.HttpContext.Items["SecurityTokenReceived"] = true;
262                                  return Task.FromResult(0);
263                              },
264                              OnSecurityTokenValidated = context =>
265                              {
266                                  Assert.True((bool)context.HttpContext.Items["MessageReceived"], "MessageReceived notification not invoked");
267                                  Assert.True((bool)context.HttpContext.Items["SecurityTokenReceived"], "SecurityTokenReceived notification not invoked");
268                                  if (context.Principal != null)
269                                  {
270                                      var identity = context.Principal.Identities.Single();
271                                      identity.AddClaim(new Claim("ReturnEndpoint", "true"));
272                                      identity.AddClaim(new Claim("Authenticated", "true"));
273                                      identity.AddClaim(new Claim(identity.RoleClaimType, "Guest", ClaimValueTypes.String));
274                                  }
275                                  return Task.FromResult(0);
276                              },
277                              OnAuthenticationFailed = context =>
278                              {
279                                  context.HttpContext.Items["AuthenticationFailed"] = true;
280                                  context.HttpContext.Request.Path = new PathString("/AuthenticationFailed");
281                                  context.SkipHandler();
282                                  return Task.FromResult(0);
283                              },
284                              OnRemoteSignOut = context =>
285                              {
286                                  context.Response.Headers["EventHeader"] = "OnRemoteSignOut";
287                                  return Task.FromResult(0);
288                              }
289                          };
290                      });
291                  });
292              var server = new TestServer(builder);
293              return server.CreateClient();
294          }
295          private void ConfigureApp(IApplicationBuilder app)
296          {
297              app.Map("/PreMapped-Challenge", mapped =>
298              {
299                  mapped.UseAuthentication();
300                  mapped.Run(async context =>
301                  {
302                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
303                  });
304              });
305              app.UseAuthentication();
306              app.Map("/Logout", subApp =>
307                  {
308                      subApp.Run(async context =>
309                          {
310                              if (context.User.Identity.IsAuthenticated)
311                              {
312                                  var authProperties = new AuthenticationProperties() { RedirectUri = context.Request.GetEncodedUrl() };
313                                  await context.SignOutAsync(WsFederationDefaults.AuthenticationScheme, authProperties);
314                                  await context.Response.WriteAsync("Signing out...");
315                              }
316                              else
317                              {
318                                  await context.Response.WriteAsync("SignedOut");
319                              }
320                          });
321                  });
<span onclick='openModal()' class='match'>322              app.Map("/AuthenticationFailed", subApp =>
323              {
324                  subApp.Run(async context =>
325                  {
326                      await context.Response.WriteAsync("AuthenticationFailed");
327                  });
328              });
329              app.Map("/signout-wsfed", subApp =>
330              {
331                  subApp.Run(async context =>
332                  {
333                      await context.Response.WriteAsync("signout-wsfed");
334                  });
335              });
336              app.Map("/mapped-challenge", subApp =>
337              {
338                  subApp.Run(async context =>
339                  {
340                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
341                  });
342              });
343              app.Run(async context =>
</span>344              {
345                  var result = context.AuthenticateAsync();
346                  if (context.User == null || !context.User.Identity.IsAuthenticated)
347                  {
348                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
349                      await context.Response.WriteAsync("Unauthorized");
350                  }
351                  else
352                  {
353                      var identity = context.User.Identities.Single();
354                      if (identity.NameClaimType == "Name_Failed" && identity.RoleClaimType == "Role_Failed")
355                      {
356                          context.Response.StatusCode = 500;
357                          await context.Response.WriteAsync("SignIn_Failed");
358                      }
359                      else if (!identity.HasClaim("Authenticated", "true") || !identity.HasClaim("ReturnEndpoint", "true") || !identity.HasClaim(identity.RoleClaimType, "Guest"))
360                      {
361                          await context.Response.WriteAsync("Provider not invoked");
362                          return;
363                      }
364                      else
365                      {
366                          await context.Response.WriteAsync(WsFederationDefaults.AuthenticationScheme);
367                      }
368                  }
369              });
370          }
371          private class WaadMetadataDocumentHandler : HttpMessageHandler
372          {
373              protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
374              {
375                  var metadata = File.ReadAllText(@"WsFederation/federationmetadata.xml");
376                  var newResponse = new HttpResponseMessage() { Content = new StringContent(metadata, Encoding.UTF8, "text/xml") };
377                  return Task.FromResult<HttpResponseMessage>(newResponse);
378              }
379          }
380      }
381  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-SslTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Net;
4  using System.Net.Sockets;
5  using System.Security.Authentication;
6  using System.Security.Cryptography.X509Certificates;
7  using System.Threading;
8  using NetCoreServer;
9  using Xunit;
10  namespace tests
11  {
12      class EchoSslClient : SslClient
13      {
14          public bool Connected { get; set; }
15          public bool Handshaked { get; set; }
16          public bool Disconnected { get; set; }
17          public bool Errors { get; set; }
18          public EchoSslClient(SslContext context, string address, int port) : base(context, address, port) {}
19          public static SslContext CreateContext()
20          {
21              return new SslContext(SslProtocols.Tls13, new X509Certificate2("client.pfx", "qwerty"), (sender, certificate, chain, sslPolicyErrors) => true);
22          }
23          protected override void OnConnected() { Connected = true; }
24          protected override void OnHandshaked() { Handshaked = true; }
25          protected override void OnDisconnected() { Disconnected = true; }
26          protected override void OnError(SocketError error) { Errors = true; }
27      }
28      class EchoSslSession : SslSession
29      {
30          public bool Connected { get; set; }
31          public bool Handshaked { get; set; }
32          public bool Disconnected { get; set; }
33          public bool Errors { get; set; }
34          public EchoSslSession(SslServer server) : base(server) {}
35          protected override void OnConnected() { Connected = true; }
36          protected override void OnHandshaked() { Handshaked = true; }
37          protected override void OnDisconnected() { Disconnected = true; }
38          protected override void OnReceived(byte[] buffer, long offset, long size) { SendAsync(buffer, offset, size); }
39          protected override void OnError(SocketError error) { Errors = true; }
40      }
41      class EchoSslServer : SslServer
42      {
43          public bool Started { get; set; }
44          public bool Stopped { get; set; }
45          public bool Connected { get; set; }
46          public bool Handshaked { get; set; }
47          public bool Disconnected { get; set; }
48          public int Clients { get; set; }
49          public bool Errors { get; set; }
50          public EchoSslServer(SslContext context, IPAddress address, int port) : base(context, address, port) {}
51          public static SslContext CreateContext()
52          {
53              return new SslContext(SslProtocols.Tls13, new X509Certificate2("server.pfx", "qwerty"));
54          }
55          protected override SslSession CreateSession() { return new EchoSslSession(this); }
56          protected override void OnStarted() { Started = true; }
57          protected override void OnStopped() { Stopped = true; }
58          protected override void OnConnected(SslSession session) { Connected = true; }
59          protected override void OnHandshaked(SslSession session) { Handshaked = true; Clients++; }
60          protected override void OnDisconnected(SslSession session) { Disconnected = true; Clients--; }
61          protected override void OnError(SocketError error) { Errors = true; }
62      }
63      public class SslTests
64      {
65          [Fact(DisplayName = "SSL server test")]
66          public void SslServerTest()
67          {
68              string address = "127.0.0.1";
69              int port = 2222;
70              var serverContext = EchoSslServer.CreateContext();
71              var server = new EchoSslServer(serverContext, IPAddress.Any, port);
72              Assert.True(server.Start());
73              while (!server.IsStarted)
74                  Thread.Yield();
75              var clientContext = EchoSslClient.CreateContext();
76              var client = new EchoSslClient(clientContext, address, port);
77              Assert.True(client.ConnectAsync());
78              while (!client.IsConnected || !client.IsHandshaked || (server.Clients != 1))
79                  Thread.Yield();
80              client.SendAsync("test");
81              while (client.BytesReceived != 4)
82                  Thread.Yield();
83              Assert.True(client.DisconnectAsync());
84              while (client.IsConnected || client.IsHandshaked || (server.Clients != 0))
85                  Thread.Yield();
86              Assert.True(server.Stop());
87              while (server.IsStarted)
<span onclick='openModal()' class='match'>88                  Thread.Yield();
89              Assert.True(server.Started);
90              Assert.True(server.Stopped);
91              Assert.True(server.Connected);
92              Assert.True(server.Handshaked);
93              Assert.True(server.Disconnected);
94              Assert.True(server.BytesSent == 4);
95              Assert.True(server.BytesReceived == 4);
96              Assert.True(!server.Errors);
97              Assert.True(client.Connected);
</span>98              Assert.True(client.Handshaked);
99              Assert.True(client.Disconnected);
100              Assert.True(client.BytesSent == 4);
101              Assert.True(client.BytesReceived == 4);
102              Assert.True(!client.Errors);
103          }
104          [Fact(DisplayName = "SSL server multicast test")]
105          public void SslServerMulticastTest()
106          {
107              string address = "127.0.0.1";
108              int port = 2223;
109              var serverContext = EchoSslServer.CreateContext();
110              var server = new EchoSslServer(serverContext, IPAddress.Any, port);
111              Assert.True(server.Start());
112              while (!server.IsStarted)
113                  Thread.Yield();
114              var clientContext = EchoSslClient.CreateContext();
115              var client1 = new EchoSslClient(clientContext, address, port);
116              Assert.True(client1.ConnectAsync());
117              while (!client1.IsConnected || !client1.IsHandshaked || (server.Clients != 1))
118                  Thread.Yield();
119              server.Multicast("test");
120              while (client1.BytesReceived != 4)
121                  Thread.Yield();
122              var client2 = new EchoSslClient(clientContext, address, port);
123              Assert.True(client2.ConnectAsync());
124              while (!client2.IsConnected || !client2.IsHandshaked || (server.Clients != 2))
125                  Thread.Yield();
126              server.Multicast("test");
127              while ((client1.BytesReceived != 8) || (client2.BytesReceived != 4))
128                  Thread.Yield();
129              var client3 = new EchoSslClient(clientContext, address, port);
130              Assert.True(client3.ConnectAsync());
131              while (!client3.IsConnected || !client3.IsHandshaked || (server.Clients != 3))
132                  Thread.Yield();
133              server.Multicast("test");
134              while ((client1.BytesReceived != 12) || (client2.BytesReceived != 8) || (client3.BytesReceived != 4))
135                  Thread.Yield();
136              Assert.True(client1.DisconnectAsync());
137              while (client1.IsConnected || client1.IsHandshaked || (server.Clients != 2))
138                  Thread.Yield();
139              server.Multicast("test");
140              while ((client1.BytesReceived != 12) || (client2.BytesReceived != 12) || (client3.BytesReceived != 8))
141                  Thread.Yield();
142              Assert.True(client2.DisconnectAsync());
143              while (client2.IsConnected || client2.IsHandshaked || (server.Clients != 1))
144                  Thread.Yield();
145              server.Multicast("test");
146              while ((client1.BytesReceived != 12) || (client2.BytesReceived != 12) || (client3.BytesReceived != 12))
147                  Thread.Yield();
148              Assert.True(client3.DisconnectAsync());
149              while (client3.IsConnected || client3.IsHandshaked || (server.Clients != 0))
150                  Thread.Yield();
151              Assert.True(server.Stop());
152              while (server.IsStarted)
153                  Thread.Yield();
154              Assert.True(server.Started);
155              Assert.True(server.Stopped);
156              Assert.True(server.Connected);
157              Assert.True(server.Handshaked);
158              Assert.True(server.Disconnected);
159              Assert.True(server.BytesSent > 0);
160              Assert.True(server.BytesReceived == 0);
161              Assert.True(!server.Errors);
162              Assert.True(client1.BytesSent == 0);
163              Assert.True(client2.BytesSent == 0);
164              Assert.True(client3.BytesSent == 0);
165              Assert.True(client1.BytesReceived == 12);
166              Assert.True(client2.BytesReceived == 12);
167              Assert.True(client3.BytesReceived == 12);
168              Assert.True(!client1.Errors);
169              Assert.True(!client2.Errors);
170              Assert.True(!client3.Errors);
171          }
172          [Fact(DisplayName = "SSL server random test")]
173          public void SslServerRandomTest()
174          {
175              string address = "127.0.0.1";
176              int port = 2224;
177              var serverContext = EchoSslServer.CreateContext();
178              var server = new EchoSslServer(serverContext, IPAddress.Any, port);
179              Assert.True(server.Start());
180              while (!server.IsStarted)
181                  Thread.Yield();
182              int duration = 10;
183              var clientContext = EchoSslClient.CreateContext();
184              var clients = new List<EchoSslClient>();
185              var rand = new Random();
186              var start = DateTime.UtcNow;
187              while ((DateTime.UtcNow - start).TotalSeconds < duration)
188              {
189                  if ((rand.Next() % 1000) == 0)
190                  {
191                      server.DisconnectAll();
192                  }
193                  else if ((rand.Next() % 100) == 0)
194                  {
195                      if (clients.Count < 100)
196                      {
197                          var client = new EchoSslClient(clientContext, address, port);
198                          clients.Add(client);
199                          client.ConnectAsync();
200                          while (!client.IsHandshaked)
201                              Thread.Yield();
202                      }
203                  }
204                  else if ((rand.Next() % 100) == 0)
205                  {
206                      if (clients.Count > 0)
207                      {
208                          int index = rand.Next() % clients.Count;
209                          var client = clients[index];
210                          if (client.IsHandshaked)
211                          {
212                              client.DisconnectAsync();
213                              while (client.IsConnected)
214                                  Thread.Yield();
215                          }
216                          else if (!client.IsConnected)
217                          {
218                              client.ConnectAsync();
219                              while (!client.IsHandshaked)
220                                  Thread.Yield();
221                          }
222                      }
223                  }
224                  else if ((rand.Next() % 100) == 0)
225                  {
226                      if (clients.Count > 0)
227                      {
228                          int index = rand.Next() % clients.Count;
229                          var client = clients[index];
230                          if (client.IsHandshaked)
231                          {
232                              client.ReconnectAsync();
233                              while (!client.IsHandshaked)
234                                  Thread.Yield();
235                          }
236                      }
237                  }
238                  else if ((rand.Next() % 10) == 0)
239                  {
240                      server.Multicast("test");
241                  }
242                  else if ((rand.Next() % 1) == 0)
243                  {
244                      if (clients.Count > 0)
245                      {
246                          int index = rand.Next() % clients.Count;
247                          var client = clients[index];
248                          if (client.IsHandshaked)
249                              client.SendAsync("test");
250                      }
251                  }
252                  Thread.Sleep(1);
253              }
254              foreach (var client in clients)
255              {
256                  client.DisconnectAsync();
257                  while (client.IsConnected)
258                      Thread.Yield();
259              }
260              Assert.True(server.Stop());
261              while (server.IsStarted)
262                  Thread.Yield();
263              Assert.True(server.Started);
264              Assert.True(server.Stopped);
265              Assert.True(server.Connected);
266              Assert.True(server.Handshaked);
267              Assert.True(server.Disconnected);
268              Assert.True(server.BytesSent > 0);
269              Assert.True(server.BytesReceived > 0);
270              Assert.True(!server.Errors);
271          }
272      }
273  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-SslTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>322              app.Map("/AuthenticationFailed", subApp =>
323              {
324                  subApp.Run(async context =>
325                  {
326                      await context.Response.WriteAsync("AuthenticationFailed");
327                  });
328              });
329              app.Map("/signout-wsfed", subApp =>
330              {
331                  subApp.Run(async context =>
332                  {
333                      await context.Response.WriteAsync("signout-wsfed");
334                  });
335              });
336              app.Map("/mapped-challenge", subApp =>
337              {
338                  subApp.Run(async context =>
339                  {
340                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
341                  });
342              });
343              app.Run(async context =>
</pre></code></div>
                <div class="column column_space"><pre><code>88                  Thread.Yield();
89              Assert.True(server.Started);
90              Assert.True(server.Stopped);
91              Assert.True(server.Connected);
92              Assert.True(server.Handshaked);
93              Assert.True(server.Disconnected);
94              Assert.True(server.BytesSent == 4);
95              Assert.True(server.BytesReceived == 4);
96              Assert.True(!server.Errors);
97              Assert.True(client.Connected);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    