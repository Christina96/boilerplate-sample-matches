
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-EvaluationResult.cs</h3>
            <pre><code>1  using System;
2  using System.ComponentModel;
3  using System.Globalization;
4  using GitHub.DistributedTask.Expressions2.Sdk;
5  namespace GitHub.DistributedTask.Expressions2
6  {
7      [EditorBrowsable(EditorBrowsableState.Never)]
8      public sealed class EvaluationResult
9      {
10          internal EvaluationResult(
11              EvaluationContext context,
12              Int32 level,
13              Object val,
14              ValueKind kind,
15              Object raw)
16              : this(context, level, val, kind, raw, false)
17          {
18          }
19          internal EvaluationResult(
20              EvaluationContext context,
21              Int32 level,
22              Object val,
23              ValueKind kind,
24              Object raw,
25              Boolean omitTracing)
26          {
27              m_level = level;
28              Value = val;
29              Kind = kind;
30              Raw = raw;
31              m_omitTracing = omitTracing;
32              if (!omitTracing)
33              {
34                  TraceValue(context);
35              }
36          }
37          public ValueKind Kind { get; }
38          public Object Raw { get; }
39          public Object Value { get; }
40          public Boolean IsFalsy
41          {
42              get
43              {
44                  switch (Kind)
45                  {
46                      case ValueKind.Null:
47                          return true;
48                      case ValueKind.Boolean:
49                          var boolean = (Boolean)Value;
50                          return !boolean;
51                      case ValueKind.Number:
52                          var number = (Double)Value;
53                          return number == 0d || Double.IsNaN(number);
54                      case ValueKind.String:
55                          var str = (String)Value;
56                          return String.Equals(str, String.Empty, StringComparison.Ordinal);
57                      default:
58                          return false;
59                  }
60              }
61          }
62          public Boolean IsPrimitive =&gt; ExpressionUtility.IsPrimitive(Kind);
63          public Boolean IsTruthy =&gt; !IsFalsy;
64          public Boolean AbstractEqual(EvaluationResult right)
65          {
66              return AbstractEqual(Value, right.Value);
67          }
68          public Boolean AbstractGreaterThan(EvaluationResult right)
69          {
70              return AbstractGreaterThan(Value, right.Value);
71          }
72          public Boolean AbstractGreaterThanOrEqual(EvaluationResult right)
73          {
74              return AbstractEqual(Value, right.Value) || AbstractGreaterThan(Value, right.Value);
75          }
76          public Boolean AbstractLessThan(EvaluationResult right)
77          {
78              return AbstractLessThan(Value, right.Value);
79          }
80          public Boolean AbstractLessThanOrEqual(EvaluationResult right)
81          {
82              return AbstractEqual(Value, right.Value) || AbstractLessThan(Value, right.Value);
83          }
84          public Boolean AbstractNotEqual(EvaluationResult right)
85          {
86              return !AbstractEqual(Value, right.Value);
87          }
88          public Double ConvertToNumber()
89          {
90              return ConvertToNumber(Value);
91          }
92          public String ConvertToString()
93          {
94              switch (Kind)
95              {
96                  case ValueKind.Null:
97                      return String.Empty;
98                  case ValueKind.Boolean:
99                      return ((Boolean)Value) ? ExpressionConstants.True : ExpressionConstants.False;
100                  case ValueKind.Number:
101                      return ((Double)Value).ToString(ExpressionConstants.NumberFormat, CultureInfo.InvariantCulture);
102                  case ValueKind.String:
103                      return Value as String;
104                  default:
105                      return Kind.ToString();
106              }
107          }
108          public Boolean TryGetCollectionInterface(out Object collection)
109          {
110              if ((Kind == ValueKind.Object || Kind == ValueKind.Array))
111              {
112                  var obj = Value;
113                  if (obj is IReadOnlyObject)
114                  {
115                      collection = obj;
116                      return true;
117                  }
118                  else if (obj is IReadOnlyArray)
119                  {
120                      collection = obj;
121                      return true;
122                  }
123              }
124              collection = null;
125              return false;
126          }
127          public static EvaluationResult CreateIntermediateResult(
128              EvaluationContext context,
129              Object obj)
130          {
131              var val = ExpressionUtility.ConvertToCanonicalValue(obj, out ValueKind kind, out Object raw);
132              return new EvaluationResult(context, 0, val, kind, raw, omitTracing: true);
133          }
134          private void TraceValue(EvaluationContext context)
135          {
136              if (!m_omitTracing)
137              {
138                  TraceValue(context, Value, Kind);
139              }
140          }
141          private void TraceValue(
142              EvaluationContext context,
143              Object val,
144              ValueKind kind)
145          {
146              if (!m_omitTracing)
147              {
148                  TraceVerbose(context, String.Concat(&quot;=&gt; &quot;, ExpressionUtility.FormatValue(context?.SecretMasker, val, kind)));
149              }
150          }
151          private void TraceVerbose(
152              EvaluationContext context,
153              String message)
154          {
155              if (!m_omitTracing)
156              {
157                  context?.Trace.Verbose(String.Empty.PadLeft(m_level * 2, &#x27;.&#x27;) + (message ?? String.Empty));
158              }
159          }
160          private static Boolean AbstractEqual(
161              Object canonicalLeftValue,
162              Object canonicalRightValue)
163          {
164              CoerceTypes(ref canonicalLeftValue, ref canonicalRightValue, out var leftKind, out var rightKind);
165              if (leftKind == rightKind)
166              {
167                  switch (leftKind)
168                  {
169                      case ValueKind.Null:
170                          return true;
171                      case ValueKind.Number:
172                          var leftDouble = (Double)canonicalLeftValue;
173                          var rightDouble = (Double)canonicalRightValue;
174                          if (Double.IsNaN(leftDouble) || Double.IsNaN(rightDouble))
175                          {
176                              return false;
177                          }
178                          return leftDouble == rightDouble;
179                      case ValueKind.String:
180                          var leftString = (String)canonicalLeftValue;
181                          var rightString = (String)canonicalRightValue;
182                          return String.Equals(leftString, rightString, StringComparison.OrdinalIgnoreCase);
183                      case ValueKind.Boolean:
184                          var leftBoolean = (Boolean)canonicalLeftValue;
185                          var rightBoolean = (Boolean)canonicalRightValue;
186                          return leftBoolean == rightBoolean;
187                      case ValueKind.Object:
188                      case ValueKind.Array:
189                          return Object.ReferenceEquals(canonicalLeftValue, canonicalRightValue);
190                  }
191              }
192              return false;
193          }
<span onclick='openModal()' class='match'>194          private static Boolean AbstractGreaterThan(
195              Object canonicalLeftValue,
196              Object canonicalRightValue)
197          {
198              CoerceTypes(ref canonicalLeftValue, ref canonicalRightValue, out var leftKind, out var rightKind);
</span>199              if (leftKind == rightKind)
200              {
201                  switch (leftKind)
202                  {
203                      case ValueKind.Number:
204                          var leftDouble = (Double)canonicalLeftValue;
205                          var rightDouble = (Double)canonicalRightValue;
206                          if (Double.IsNaN(leftDouble) || Double.IsNaN(rightDouble))
207                          {
208                              return false;
209                          }
210                          return leftDouble &gt; rightDouble;
211                      case ValueKind.String:
212                          var leftString = (String)canonicalLeftValue;
213                          var rightString = (String)canonicalRightValue;
214                          return String.Compare(leftString, rightString, StringComparison.OrdinalIgnoreCase) &gt; 0;
215                      case ValueKind.Boolean:
216                          var leftBoolean = (Boolean)canonicalLeftValue;
217                          var rightBoolean = (Boolean)canonicalRightValue;
218                          return leftBoolean &amp;&amp; !rightBoolean;
219                  }
220              }
221              return false;
222          }
223          private static Boolean AbstractLessThan(
224              Object canonicalLeftValue,
225              Object canonicalRightValue)
226          {
227              CoerceTypes(ref canonicalLeftValue, ref canonicalRightValue, out var leftKind, out var rightKind);
228              if (leftKind == rightKind)
229              {
230                  switch (leftKind)
231                  {
232                      case ValueKind.Number:
233                          var leftDouble = (Double)canonicalLeftValue;
234                          var rightDouble = (Double)canonicalRightValue;
235                          if (Double.IsNaN(leftDouble) || Double.IsNaN(rightDouble))
236                          {
237                              return false;
238                          }
239                          return leftDouble &lt; rightDouble;
240                      case ValueKind.String:
241                          var leftString = (String)canonicalLeftValue;
242                          var rightString = (String)canonicalRightValue;
243                          return String.Compare(leftString, rightString, StringComparison.OrdinalIgnoreCase) &lt; 0;
244                      case ValueKind.Boolean:
245                          var leftBoolean = (Boolean)canonicalLeftValue;
246                          var rightBoolean = (Boolean)canonicalRightValue;
247                          return !leftBoolean &amp;&amp; rightBoolean;
248                  }
249              }
250              return false;
251          }
252          private static void CoerceTypes(
253              ref Object canonicalLeftValue,
254              ref Object canonicalRightValue,
255              out ValueKind leftKind,
256              out ValueKind rightKind)
257          {
258              leftKind = GetKind(canonicalLeftValue);
259              rightKind = GetKind(canonicalRightValue);
260              if (leftKind == rightKind)
261              {
262              }
263              else if (leftKind == ValueKind.Number &amp;&amp; rightKind == ValueKind.String)
264              {
265                  canonicalRightValue = ConvertToNumber(canonicalRightValue);
266                  rightKind = ValueKind.Number;
267              }
268              else if (leftKind == ValueKind.String &amp;&amp; rightKind == ValueKind.Number)
269              {
270                  canonicalLeftValue = ConvertToNumber(canonicalLeftValue);
271                  leftKind = ValueKind.Number;
272              }
273              else if (leftKind == ValueKind.Boolean || leftKind == ValueKind.Null)
274              {
275                  canonicalLeftValue = ConvertToNumber(canonicalLeftValue);
276                  CoerceTypes(ref canonicalLeftValue, ref canonicalRightValue, out leftKind, out rightKind);
277              }
278              else if (rightKind == ValueKind.Boolean || rightKind == ValueKind.Null)
279              {
280                  canonicalRightValue = ConvertToNumber(canonicalRightValue);
281                  CoerceTypes(ref canonicalLeftValue, ref canonicalRightValue, out leftKind, out rightKind);
282              }
283          }
284          private static Double ConvertToNumber(Object canonicalValue)
285          {
286              var kind = GetKind(canonicalValue);
287              switch (kind)
288              {
289                  case ValueKind.Null:
290                      return 0d;
291                  case ValueKind.Boolean:
292                      return (Boolean)canonicalValue ? 1d : 0d;
293                  case ValueKind.Number:
294                      return (Double)canonicalValue;
295                  case ValueKind.String:
296                      return ExpressionUtility.ParseNumber(canonicalValue as String);
297              }
298              return Double.NaN;
299          }
300          private static ValueKind GetKind(Object canonicalValue)
301          {
302              if (Object.ReferenceEquals(canonicalValue, null))
303              {
304                  return ValueKind.Null;
305              }
306              else if (canonicalValue is Boolean)
307              {
308                  return ValueKind.Boolean;
309              }
310              else if (canonicalValue is Double)
311              {
312                  return ValueKind.Number;
313              }
314              else if (canonicalValue is String)
315              {
316                  return ValueKind.String;
317              }
318              else if (canonicalValue is IReadOnlyObject)
319              {
320                  return ValueKind.Object;
321              }
322              else if (canonicalValue is IReadOnlyArray)
323              {
324                  return ValueKind.Array;
325              }
326              return ValueKind.Object;
327          }
328          private readonly Int32 m_level;
329          private readonly Boolean m_omitTracing;
330      }
331  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationCacheManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Threading;
7  using System.Xml;
8  using GitHub.Services.Common;
9  using GitHub.Services.Location;
10  using GitHub.Services.Common.Internal;
11  namespace GitHub.Services.WebApi.Location
12  {
13      internal class LocationCacheManager
14      {
15          public LocationCacheManager(Guid serverGuid, Guid serviceOwner, Uri connectionBaseUrl)
16          {
17              m_cacheAvailable = (serverGuid.Equals(Guid.Empty)) ? false : true;
18              m_lastChangeId = -1;
19              m_cacheExpirationDate = DateTime.MinValue;
20              if (serviceOwner == Guid.Empty)
21              {
22                  m_cacheFilePath = Path.Combine(Path.Combine(VssClientSettings.ClientCacheDirectory, serverGuid.ToString()),
23                                                 s_cacheFileName);
24              }
25              else
26              {
27                  m_cacheFilePath = Path.Combine(Path.Combine(Path.Combine(VssClientSettings.ClientCacheDirectory, serverGuid.ToString()), serviceOwner.ToString()),
28                                                 s_cacheFileName);
29              }
30              m_cacheLocallyFresh = false;
31              m_accessMappings = new Dictionary&lt;String, AccessMapping&gt;(VssStringComparer.AccessMappingMoniker);
32              m_services = new Dictionary&lt;String, Dictionary&lt;Guid, ServiceDefinition&gt;&gt;(VssStringComparer.ServiceType);
33              m_cachedMisses = new HashSet&lt;String&gt;(VssStringComparer.ServiceType);
34              m_connectionBaseUrl = connectionBaseUrl;
35              m_locationXmlOperator = new LocationXmlOperator(true);
36          }
37          public Boolean LocalCacheAvailable
38          {
39              get
40              {
41                  EnsureDiskCacheLoaded();
42                  return m_cacheAvailable;
43              }
44          }
45          internal Boolean CacheDataExpired
46          {
47              get
48              {
49                  return m_cacheAvailable &amp;&amp; m_cacheLocallyFresh &amp;&amp; DateTime.UtcNow &gt;= m_cacheExpirationDate;
50              }
51          }
52          public AccessMapping ClientAccessMapping
53          {
54              get
55              {
56                  m_accessLock.EnterReadLock();
57                  try
58                  {
59                      return !CacheDataExpired ? m_clientAccessMapping : null;
60                  }
61                  finally
62                  {
63                      m_accessLock.ExitReadLock();
64                  }
65              }
66          }
67          public AccessMapping DefaultAccessMapping
68          {
69              get
70              {
71                  m_accessLock.EnterReadLock();
72                  try
73                  {
74                      return !CacheDataExpired ? m_defaultAccessMapping : null;
75                  }
76                  finally
77                  {
78                      m_accessLock.ExitReadLock();
79                  }
80              }
81          }
82          public String WebApplicationRelativeDirectory
83          {
84              get
85              {
86                  return m_webApplicationRelativeDirectory;
87              }
88              set
89              {
90                  m_webApplicationRelativeDirectory = String.IsNullOrEmpty(value) ? m_webApplicationRelativeDirectory : value;
91              }
92          }
93          public void ClearIfCacheNotFresh(Int32 serverLastChangeId)
94          {
95              if (serverLastChangeId != m_lastChangeId)
96              {
97                  m_accessLock.EnterWriteLock();
98                  try
99                  {
100                      if (serverLastChangeId != m_lastChangeId)
101                      {
102                          m_accessMappings.Clear();
103                          m_services.Clear();
104                          m_cachedMisses.Clear();
105                          m_lastChangeId = -1;
106                          m_cacheExpirationDate = DateTime.MinValue;
107                      }
108                  }
109                  finally
110                  {
111                      m_accessLock.ExitWriteLock();
112                  }
113              }
114          }
115          public void RemoveServices(IEnumerable&lt;ServiceDefinition&gt; serviceDefinitions, Int32 lastChangeId)
116          {
117              EnsureDiskCacheLoaded();
118              m_accessLock.EnterWriteLock();
119              try
120              {
121                  foreach (ServiceDefinition serviceDefinition in serviceDefinitions)
122                  {
123                      Dictionary&lt;Guid, ServiceDefinition&gt; definitions = null;
124                      if (!m_services.TryGetValue(serviceDefinition.ServiceType, out definitions))
125                      {
126                          continue;
127                      }
128                      if (definitions.Remove(serviceDefinition.Identifier) &amp;&amp; definitions.Count == 0)
129                      {
130                          m_services.Remove(serviceDefinition.ServiceType);
131                      }
132                  }
133                  SetLastChangeId(lastChangeId, false);
134                  Debug.Assert(m_lastChangeId == -1 || m_services.Count &gt; 0);
135                  WriteCacheToDisk();
136              }
137              finally
138              {
139                  m_accessLock.ExitWriteLock();
140              }
141          }
142          public AccessMapping GetAccessMapping(String moniker)
143          {
144              ArgumentUtility.CheckStringForNullOrEmpty(moniker, &quot;moniker&quot;);
145              EnsureDiskCacheLoaded();
146              m_accessLock.EnterReadLock();
147              try
148              {
149                  if (CacheDataExpired)
150                  {
151                      return null;
152                  }
153                  AccessMapping accessMapping;
154                  m_accessMappings.TryGetValue(moniker, out accessMapping);
155                  return accessMapping;
156              }
157              finally
158              {
159                  m_accessLock.ExitReadLock();
160              }
161          }
162          public Boolean TryFindService(String serviceType, Guid serviceIdentifier, out ServiceDefinition serviceDefinition)
163          {
164              EnsureDiskCacheLoaded();
165              m_accessLock.EnterReadLock();
166              try
167              {
168                  Dictionary&lt;Guid, ServiceDefinition&gt; services = null;
169                  serviceDefinition = null;
170                  if (CacheDataExpired)
171                  {
172                      return false;
173                  }
174                  if (m_services.TryGetValue(serviceType, out services))
175                  {
176                      if (services.TryGetValue(serviceIdentifier, out serviceDefinition))
177                      {
178                          return true;
179                      }
180                  }
181                  if (m_cachedMisses.Contains(BuildCacheMissString(serviceType, serviceIdentifier)))
182                  {
183                      return true;
184                  }
185                  return false;
186              }
187              finally
188              {
189                  m_accessLock.ExitReadLock();
190              }
191          }
192          public IEnumerable&lt;ServiceDefinition&gt; FindServices(String serviceType)
193          {
194              EnsureDiskCacheLoaded();
195              m_accessLock.EnterReadLock();
196              try
197              {
198                  Debug.Assert(m_lastChangeId == -1 || m_services.Count &gt; 0);
199                  if (CacheDataExpired)
200                  {
201                      return null;
202                  }
203                  if (m_services.Count == 0)
204                  {
205                      return null;
206                  }
207                  IEnumerable&lt;Dictionary&lt;Guid, ServiceDefinition&gt;&gt; dictionaries;
208                  if (String.IsNullOrEmpty(serviceType))
209                  {
210                      dictionaries = m_services.Values;
211                  }
212                  else
213                  {
214                      Dictionary&lt;Guid, ServiceDefinition&gt; services = null;
215                      if (!m_services.TryGetValue(serviceType, out services))
216                      {
217                          return null;
218                      }
219                      dictionaries = new Dictionary&lt;Guid, ServiceDefinition&gt;[] { services };
220                  }
221                  List&lt;ServiceDefinition&gt; serviceDefinitions = new List&lt;ServiceDefinition&gt;();
222                  foreach (Dictionary&lt;Guid, ServiceDefinition&gt; dict in dictionaries)
223                  {
224                      foreach (ServiceDefinition definition in dict.Values)
225                      {
226                          serviceDefinitions.Add(definition.Clone());
227                      }
228                  }
229                  return serviceDefinitions;
230              }
231              finally
232              {
233                  m_accessLock.ExitReadLock();
234              }
235          }
236          public void LoadServicesData(LocationServiceData locationServiceData, Boolean allServicesIncluded)
237          {
238              m_accessLock.EnterWriteLock();
239              try
240              {
241                  if (!locationServiceData.ClientCacheFresh &amp;&amp; locationServiceData.LastChangeId != m_lastChangeId)
242                  {
243                      m_accessMappings = new Dictionary&lt;String, AccessMapping&gt;(VssStringComparer.AccessMappingMoniker);
244                      m_services = new Dictionary&lt;String, Dictionary&lt;Guid, ServiceDefinition&gt;&gt;(VssStringComparer.ServiceType);
245                      m_cachedMisses = new HashSet&lt;String&gt;(VssStringComparer.ServiceType);
246                      m_lastChangeId = -1;
247                      m_cacheExpirationDate = DateTime.MinValue;
248                  }
249                  else
250                  {
251                      EnsureDiskCacheLoadedHelper();
252                  }
253                  SetLastChangeId(locationServiceData.LastChangeId, allServicesIncluded);
254                  Int32 clientCacheTimeToLive = (ClientCacheTimeToLive != null) ? ClientCacheTimeToLive.Value : locationServiceData.ClientCacheTimeToLive;
255                  m_cacheExpirationDate = DateTime.UtcNow.AddSeconds(clientCacheTimeToLive);
256                  ICollection&lt;AccessMapping&gt; accessMappings = locationServiceData.AccessMappings;
257                  if (accessMappings != null &amp;&amp; accessMappings.Count &gt; 0)
258                  {
259                      foreach (AccessMapping accessMapping in accessMappings)
260                      {
261                          if (accessMapping.VirtualDirectory == null &amp;&amp;
262                              !String.IsNullOrEmpty(WebApplicationRelativeDirectory))
263                          {
264                              String absoluteUriTrimmed = accessMapping.AccessPoint.TrimEnd(&#x27;/&#x27;);
265                              String relativeDirectoryTrimmed = WebApplicationRelativeDirectory.TrimEnd(&#x27;/&#x27;);
266                              if (VssStringComparer.ServerUrl.EndsWith(absoluteUriTrimmed, relativeDirectoryTrimmed))
267                              {
268                                  accessMapping.AccessPoint = absoluteUriTrimmed.Substring(0, absoluteUriTrimmed.Length - relativeDirectoryTrimmed.Length);
269                              }
270                          }
271                          AccessMapping existingAccessMapping;
272                          if (m_accessMappings.TryGetValue(accessMapping.Moniker, out existingAccessMapping))
273                          {
274                              existingAccessMapping.DisplayName = accessMapping.DisplayName;
275                              existingAccessMapping.AccessPoint = accessMapping.AccessPoint;
276                              existingAccessMapping.VirtualDirectory = accessMapping.VirtualDirectory;
277                          }
278                          else
279                          {
280                              existingAccessMapping = accessMapping;
281                              m_accessMappings[accessMapping.Moniker] = accessMapping;
282                          }
283                      }
284                      DetermineClientAndDefaultZones(locationServiceData.DefaultAccessMappingMoniker);
285                  }
286                  if (locationServiceData.ServiceDefinitions != null)
287                  {
288                      foreach (ServiceDefinition definition in locationServiceData.ServiceDefinitions)
289                      {
290                          Dictionary&lt;Guid, ServiceDefinition&gt; definitions = null;
291                          if (!m_services.TryGetValue(definition.ServiceType, out definitions))
292                          {
293                              definitions = new Dictionary&lt;Guid, ServiceDefinition&gt;();
294                              m_services[definition.ServiceType] = definitions;
295                          }
296                          definitions[definition.Identifier] = definition;
297                      }
298                  }
299                  m_cacheAvailable = true;
300                  WriteCacheToDisk();
301              }
302              finally
303              {
304                  Debug.Assert(m_lastChangeId == -1 || m_services.Count &gt; 0);
305                  m_accessLock.ExitWriteLock();
306              }
307          }
308          private void DetermineClientAndDefaultZones(String defaultAccessMappingMoniker)
309          {
310              Debug.Assert(m_accessLock.IsWriteLockHeld);
311              m_defaultAccessMapping = null;
312              m_clientAccessMapping = null;
313              String relativeDirectoryTrimmed = (WebApplicationRelativeDirectory != null) ? WebApplicationRelativeDirectory.TrimEnd(&#x27;/&#x27;) : String.Empty;
314              foreach (AccessMapping accessMapping in m_accessMappings.Values)
315              {
316                  if (VssStringComparer.ServerUrl.StartsWith(m_connectionBaseUrl.ToString(), accessMapping.AccessPoint.TrimEnd(&#x27;/&#x27;)) &amp;&amp;
317                      (accessMapping.VirtualDirectory == null ||
318                      VssStringComparer.UrlPath.Equals(accessMapping.VirtualDirectory, relativeDirectoryTrimmed)))
319                  {
320                      m_clientAccessMapping = accessMapping;
321                  }
322              }
323              m_defaultAccessMapping = m_accessMappings[defaultAccessMappingMoniker];
324              if (m_clientAccessMapping == null)
325              {
326                  String accessPoint = m_connectionBaseUrl.ToString().TrimEnd(&#x27;/&#x27;);
327                  String virtualDirectory = String.Empty;
328                  if (!String.IsNullOrEmpty(WebApplicationRelativeDirectory))
329                  {
330                      if (VssStringComparer.ServerUrl.EndsWith(accessPoint, relativeDirectoryTrimmed))
331                      {
332                          accessPoint = accessPoint.Substring(0, accessPoint.Length - relativeDirectoryTrimmed.Length);
333                          virtualDirectory = relativeDirectoryTrimmed;
334                      }
335                  }
336                  m_clientAccessMapping = new AccessMapping()
337                  {
338                      Moniker = accessPoint,
339                      DisplayName = accessPoint,
340                      AccessPoint = accessPoint,
341                      VirtualDirectory = virtualDirectory
342                  };
343              }
344          }
345          public IEnumerable&lt;AccessMapping&gt; AccessMappings
346          {
347              get
348              {
349                  EnsureDiskCacheLoaded();
350                  m_accessLock.EnterReadLock();
351                  try
352                  {
353                      List&lt;AccessMapping&gt; accessMappings = new List&lt;AccessMapping&gt;();
354                      if (!CacheDataExpired)
355                      {
356                          foreach (AccessMapping accessMapping in m_accessMappings.Values)
357                          {
358                              accessMappings.Add(accessMapping);
359                          }
360                      }
361                      return accessMappings;
362                  }
363                  finally
364                  {
365                      m_accessLock.ExitReadLock();
366                  }
367              }
368          }
369          public void RemoveAccessMapping(String moniker)
370          {
371              EnsureDiskCacheLoaded();
372              m_accessLock.EnterWriteLock();
373              try
374              {
375                  m_accessMappings.Remove(moniker);
376                  foreach (Dictionary&lt;Guid, ServiceDefinition&gt; serviceGroup in m_services.Values)
377                  {
378                      foreach (ServiceDefinition definition in serviceGroup.Values)
379                      {
380                          for (int i = 0; i &lt; definition.LocationMappings.Count; i++)
381                          {
382                              if (VssStringComparer.AccessMappingMoniker.Equals(moniker, definition.LocationMappings[i].AccessMappingMoniker))
383                              {
384                                  definition.LocationMappings.RemoveAt(i);
385                                  break;
386                              }
387                          }
388                      }
389                  }
390                  WriteCacheToDisk();
391              }
392              finally
393              {
394                  m_accessLock.ExitWriteLock();
395              }
396          }
397          public void AddCachedMiss(String serviceType, Guid serviceIdentifier, int missedLastChangeId)
398          {
399              if (missedLastChangeId &lt; 0)
400              {
401                  return;
402              }
403              EnsureDiskCacheLoaded();
404              m_accessLock.EnterWriteLock();
405              try
406              {
407                  if (missedLastChangeId == m_lastChangeId &amp;&amp;
408                      m_cachedMisses.Add(BuildCacheMissString(serviceType, serviceIdentifier)))
409                  {
410                      WriteCacheToDisk();
411                  }
412              }
413              finally
414              {
415                  m_accessLock.ExitWriteLock();
416              }
417          }
418          public Int32 GetLastChangeId()
419          {
420              EnsureDiskCacheLoaded();
421              m_accessLock.EnterReadLock();
422              try
423              {
424                  return m_lastChangeId;
425              }
426              finally
427              {
428                  m_accessLock.ExitReadLock();
429              }
430          }
431          internal DateTime GetCacheExpirationDate()
432          {
433              EnsureDiskCacheLoaded();
434              m_accessLock.EnterReadLock();
435              try
436              {
437                  return m_cacheExpirationDate;
438              }
439              finally
440              {
441                  m_accessLock.ExitReadLock();
442              }
443          }
444          private void SetLastChangeId(Int32 lastChangeId, Boolean allServicesUpdated)
445          {
446              Debug.Assert(m_accessLock.IsWriteLockHeld);
447              if (m_lastChangeId != -1 || allServicesUpdated)
448              {
449                  m_lastChangeId = lastChangeId;
450              }
451          }
<span onclick='openModal()' class='match'>452          private static String BuildCacheMissString(String serviceType, Guid serviceIdentifier)
453          {
454              return String.Concat(serviceType, &quot;_&quot;, serviceIdentifier.ToString());
</span>455          }
456          internal void EnsureDiskCacheLoaded()
457          {
458              if (m_cacheLocallyFresh || !m_cacheAvailable)
459              {
460                  return;
461              }
462              m_accessLock.EnterWriteLock();
463              try
464              {
465                  EnsureDiskCacheLoadedHelper();
466              }
467              finally
468              {
469                  m_accessLock.ExitWriteLock();
470              }
471          }
472          private void EnsureDiskCacheLoadedHelper()
473          {
474              Debug.Assert(m_accessLock.IsWriteLockHeld);
475              FileStream unusedFile = null;
476              try
477              {
478                  if (m_cacheLocallyFresh || !m_cacheAvailable)
479                  {
480                      return;
481                  }
482                  XmlDocument document = XmlUtility.OpenXmlFile(out unusedFile, m_cacheFilePath, FileShare.Read, saveFile: false);
483                  if (document != null)
484                  {
485                      m_accessMappings = new Dictionary&lt;String, AccessMapping&gt;(VssStringComparer.AccessMappingMoniker);
486                      m_services = new Dictionary&lt;String, Dictionary&lt;Guid, ServiceDefinition&gt;&gt;(VssStringComparer.ServiceType);
487                      m_cachedMisses = new HashSet&lt;String&gt;(VssStringComparer.ServiceType);
488                      m_lastChangeId = m_locationXmlOperator.ReadLastChangeId(document);
489                      m_cacheExpirationDate = m_locationXmlOperator.ReadCacheExpirationDate(document);
490                      String defaultAccessMappingMoniker = m_locationXmlOperator.ReadDefaultAccessMappingMoniker(document);
491                      m_webApplicationRelativeDirectory = m_locationXmlOperator.ReadVirtualDirectory(document);
492                      List&lt;AccessMapping&gt; accessMappings = m_locationXmlOperator.ReadAccessMappings(document);
493                      foreach (AccessMapping accessMapping in accessMappings)
494                      {
495                          m_accessMappings[accessMapping.Moniker] = accessMapping;
496                      }
497                      if (accessMappings.Count &gt; 0)
498                      {
499                          DetermineClientAndDefaultZones(defaultAccessMappingMoniker);
500                      }
501                      else
502                      {
503                          m_cacheAvailable = false;
504                          m_lastChangeId = -1;
505                          return;
506                      }
507                      List&lt;ServiceDefinition&gt; serviceDefinitions = m_locationXmlOperator.ReadServices(document, m_accessMappings);
508                      foreach (ServiceDefinition definition in serviceDefinitions)
509                      {
510                          Dictionary&lt;Guid, ServiceDefinition&gt; serviceTypeSet;
511                          if (!m_services.TryGetValue(definition.ServiceType, out serviceTypeSet))
512                          {
513                              serviceTypeSet = new Dictionary&lt;Guid, ServiceDefinition&gt;();
514                              m_services.Add(definition.ServiceType, serviceTypeSet);
515                          }
516                          serviceTypeSet[definition.Identifier] = definition;
517                      }
518                      List&lt;String&gt; cachedMisses = m_locationXmlOperator.ReadCachedMisses(document);
519                      foreach (String cachedMiss in cachedMisses)
520                      {
521                          m_cachedMisses.Add(cachedMiss);
522                      }
523                  }
524                  if (m_fileSystemWatcher == null)
525                  {
526                      m_fileSystemWatcher = new FileSystemWatcher(Path.GetDirectoryName(m_cacheFilePath), s_cacheFileName);
527                      m_fileSystemWatcher.NotifyFilter = NotifyFilters.LastWrite;
528                      m_fileSystemWatcher.Changed += new FileSystemEventHandler(m_fileSystemWatcher_Changed);
529                  }
530                  Debug.Assert(m_lastChangeId == -1 || m_services.Count &gt; 0);
531              }
532              catch (Exception)
533              {
534                  m_cacheAvailable = false;
535                  m_lastChangeId = -1;
536              }
537              finally
538              {
539                  m_cacheLocallyFresh = true;
540                  if (unusedFile != null)
541                  {
542                      unusedFile.Dispose();
543                  }
544              }
545          }
546          void m_fileSystemWatcher_Changed(object sender, FileSystemEventArgs e)
547          {
548              m_cacheLocallyFresh = false;
549          }
550          private void WriteCacheToDisk()
551          {
552              Debug.Assert(m_accessLock.IsWriteLockHeld);
553              if (!m_cacheAvailable)
554              {
555                  return;
556              }
557              try
558              {
559                  Debug.Assert(m_lastChangeId == -1 || m_services.Count &gt; 0);
560                  using (FileStream file = XmlUtility.OpenFile(m_cacheFilePath, FileShare.None, true))
561                  {
562                      XmlDocument document = new XmlDocument();
563                      XmlNode documentNode = document.CreateNode(XmlNodeType.Element, s_docStartElement, null);
564                      document.AppendChild(documentNode);
565                      m_locationXmlOperator.WriteLastChangeId(documentNode, m_lastChangeId);
566                      m_locationXmlOperator.WriteCacheExpirationDate(documentNode, m_cacheExpirationDate);
567                      m_locationXmlOperator.WriteDefaultAccessMappingMoniker(documentNode, m_defaultAccessMapping.Moniker);
568                      m_locationXmlOperator.WriteVirtualDirectory(documentNode, m_webApplicationRelativeDirectory);
569                      m_locationXmlOperator.WriteAccessMappings(documentNode, m_accessMappings.Values);
570                      List&lt;ServiceDefinition&gt; serviceDefinitions = new List&lt;ServiceDefinition&gt;();
571                      foreach (Dictionary&lt;Guid, ServiceDefinition&gt; serviceTypeSet in m_services.Values)
572                      {
573                          serviceDefinitions.AddRange(serviceTypeSet.Values);
574                      }
575                      m_locationXmlOperator.WriteServices(documentNode, serviceDefinitions);
576                      m_locationXmlOperator.WriteCachedMisses(documentNode, m_cachedMisses);
577                      file.SetLength(0);
578                      file.Position = 0;
579                      document.Save(file);
580                  }
581              }
582              catch (Exception)
583              {
584                  m_cacheAvailable = false;
585              }
586          }
587          internal Int32? ClientCacheTimeToLive
588          {
589              get;
590              set;
591          }
592          private Dictionary&lt;String, Dictionary&lt;Guid, ServiceDefinition&gt;&gt; m_services;
593          private HashSet&lt;String&gt; m_cachedMisses;
594          private Dictionary&lt;String, AccessMapping&gt; m_accessMappings;
595          private Int32 m_lastChangeId;
596          private DateTime m_cacheExpirationDate;
597          private ReaderWriterLockSlim m_accessLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
598          private String m_webApplicationRelativeDirectory;
599          private static Object s_cacheMutex = new Object();
600          private Boolean m_cacheLocallyFresh;
601          private Boolean m_cacheAvailable;
602          private FileSystemWatcher m_fileSystemWatcher;
603          private Uri m_connectionBaseUrl;
604          private AccessMapping m_clientAccessMapping;
605          private AccessMapping m_defaultAccessMapping;
606          private static readonly String s_cacheFileName = &quot;LocationServiceData.config&quot;;
607          private String m_cacheFilePath;
608          private LocationXmlOperator m_locationXmlOperator;
609          private const String s_docStartElement = &quot;LocationServiceConfiguration&quot;;
610      }
611  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-EvaluationResult.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationCacheManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>194          private static Boolean AbstractGreaterThan(
195              Object canonicalLeftValue,
196              Object canonicalRightValue)
197          {
198              CoerceTypes(ref canonicalLeftValue, ref canonicalRightValue, out var leftKind, out var rightKind);
</pre></code></div>
                <div class="column column_space"><pre><code>452          private static String BuildCacheMissString(String serviceType, Guid serviceIdentifier)
453          {
454              return String.Concat(serviceType, &quot;_&quot;, serviceIdentifier.ToString());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    