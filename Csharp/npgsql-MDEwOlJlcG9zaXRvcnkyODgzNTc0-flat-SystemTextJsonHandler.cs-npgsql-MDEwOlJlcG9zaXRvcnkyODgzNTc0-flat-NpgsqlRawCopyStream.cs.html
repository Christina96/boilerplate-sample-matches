
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-SystemTextJsonHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics.CodeAnalysis;
3  using System.IO;
4  using System.Text;
5  using System.Text.Json;
6  using System.Text.Json.Nodes;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using Npgsql.BackendMessages;
10  using Npgsql.Internal.TypeHandling;
11  using Npgsql.PostgresTypes;
12  namespace Npgsql.Internal.TypeHandlers;
13  public class SystemTextJsonHandler : JsonTextHandler
14  {
15      readonly JsonSerializerOptions _serializerOptions;
16      readonly bool _isJsonb;
17      readonly int _headerLen;
18      const byte JsonbProtocolVersion = 1;
19      static readonly JsonSerializerOptions DefaultSerializerOptions = new();
20      public SystemTextJsonHandler(PostgresType postgresType, Encoding encoding, bool isJsonb, JsonSerializerOptions? serializerOptions = null)
21          : base(postgresType, encoding, isJsonb)
22      {
23          _serializerOptions = serializerOptions ?? DefaultSerializerOptions;
24          _isJsonb = isJsonb;
25          _headerLen = isJsonb ? 1 : 0;
26      }
27      protected internal override int ValidateAndGetLengthCustom<TAny>([DisallowNull] TAny value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
28      {
29          if (IsSupportedAsText<TAny>())
30              return base.ValidateAndGetLengthCustom(value, ref lengthCache, parameter);
31          if (typeof(TAny) == typeof(JsonDocument))
32          {
33              lengthCache ??= new NpgsqlLengthCache(1);
34              if (lengthCache.IsPopulated)
35                  return lengthCache.Get();
36              var data = SerializeJsonDocument((JsonDocument)(object)value);
37              if (parameter != null)
38                  parameter.ConvertedValue = data;
39              return lengthCache.Set(data.Length + _headerLen);
40          }
41          if (typeof(TAny) == typeof(JsonObject) || typeof(TAny) == typeof(JsonArray))
42          {
43              lengthCache ??= new NpgsqlLengthCache(1);
44              if (lengthCache.IsPopulated)
45                  return lengthCache.Get();
46              var data = SerializeJsonObject((JsonNode)(object)value);
47              if (parameter != null)
48                  parameter.ConvertedValue = data;
49              return lengthCache.Set(data.Length + _headerLen);
50          }
51          var s = JsonSerializer.Serialize(value, _serializerOptions);
52          if (parameter != null)
53              parameter.ConvertedValue = s;
54          return TextHandler.ValidateAndGetLength(s, ref lengthCache, parameter) + _headerLen;
55      }
56      protected override async Task WriteWithLengthCustom<TAny>([DisallowNull] TAny value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken)
57      {
58          if (IsSupportedAsText<TAny>())
59          {
60              await base.WriteWithLengthCustom(value, buf, lengthCache, parameter, async, cancellationToken);
61              return;
62          }
63          var spaceRequired = _isJsonb ? 5 : 4;
64          if (buf.WriteSpaceLeft < spaceRequired)
65              await buf.Flush(async, cancellationToken);
66          buf.WriteInt32(ValidateAndGetLength(value, ref lengthCache, parameter));
67          if (_isJsonb)
68              buf.WriteByte(JsonbProtocolVersion);
69          if (typeof(TAny) == typeof(JsonDocument))
70          {
71              var data = parameter?.ConvertedValue != null
72                  ? (byte[])parameter.ConvertedValue
73                  : SerializeJsonDocument((JsonDocument)(object)value);
<span onclick='openModal()' class='match'>74              await buf.WriteBytesRaw(data, async, cancellationToken);
75          }
</span>76          else if (typeof(TAny) == typeof(JsonObject) || typeof(TAny) == typeof(JsonArray))
77          {
78              var data = parameter?.ConvertedValue != null
79                  ? (byte[])parameter.ConvertedValue
80                  : SerializeJsonObject((JsonNode)(object)value);
81              await buf.WriteBytesRaw(data, async, cancellationToken);
82          }
83          else
84          {
85              var s = parameter?.ConvertedValue != null
86                  ? (string)parameter.ConvertedValue
87                  : JsonSerializer.Serialize(value, value.GetType(), _serializerOptions);
88              await TextHandler.Write(s, buf, lengthCache, parameter, async, cancellationToken);
89          }
90      }
91      public override int ValidateObjectAndGetLength(object value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
92          => IsSupported(value.GetType())
93              ? base.ValidateObjectAndGetLength(value, ref lengthCache, parameter)
94              : value switch
95              {
96                  JsonDocument jsonDocument => ValidateAndGetLengthCustom(jsonDocument, ref lengthCache, parameter),
97                  JsonObject jsonObject => ValidateAndGetLengthCustom(jsonObject, ref lengthCache, parameter),
98                  JsonArray jsonArray => ValidateAndGetLengthCustom(jsonArray, ref lengthCache, parameter),
99                  _ => ValidateAndGetLengthCustom(value, ref lengthCache, parameter)
100              };
101      public override Task WriteObjectWithLength(object? value, NpgsqlWriteBuffer buf, NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter, bool async, CancellationToken cancellationToken = default)
102          => value is null or DBNull || IsSupported(value.GetType())
103              ? base.WriteObjectWithLength(value, buf, lengthCache, parameter, async, cancellationToken)
104              : value switch
105              {
106                  JsonDocument jsonDocument => WriteWithLengthCustom(jsonDocument, buf, lengthCache, parameter, async, cancellationToken),
107                  JsonObject jsonObject => WriteWithLengthCustom(jsonObject, buf, lengthCache, parameter, async, cancellationToken),
108                  JsonArray jsonArray => WriteWithLengthCustom(jsonArray, buf, lengthCache, parameter, async, cancellationToken),
109                  _ => WriteWithLengthCustom(value, buf, lengthCache, parameter, async, cancellationToken),
110              };
111      protected internal override async ValueTask<T> ReadCustom<T>(NpgsqlReadBuffer buf, int byteLen, bool async, FieldDescription? fieldDescription)
112      {
113          if (IsSupportedAsText<T>())
114          {
115              return await base.ReadCustom<T>(buf, byteLen, async, fieldDescription);
116          }
117          if (_isJsonb)
118          {
119              await buf.Ensure(1, async);
120              var version = buf.ReadByte();
121              if (version != JsonbProtocolVersion)
122                  throw new NotSupportedException($"Don't know how to decode JSONB with wire format {version}, your connection is now broken");
123              byteLen--;
124          }
125          if (typeof(T) == typeof(JsonDocument))
126              return (T)(object)JsonDocument.Parse(await TextHandler.Read<string>(buf, byteLen, async, fieldDescription));
127          if (buf.ReadBytesLeft >= byteLen)
128              return JsonSerializer.Deserialize<T>(buf.ReadSpan(byteLen), _serializerOptions)!;
129  #if NET6_0_OR_GREATER
130          return (async
131              ? await JsonSerializer.DeserializeAsync<T>(buf.GetStream(byteLen, canSeek: false), _serializerOptions)
132              : JsonSerializer.Deserialize<T>(buf.GetStream(byteLen, canSeek: false), _serializerOptions))!;
133  #else
134          return JsonSerializer.Deserialize<T>(await TextHandler.Read<string>(buf, byteLen, async, fieldDescription), _serializerOptions)!;
135  #endif
136      }
137      byte[] SerializeJsonDocument(JsonDocument document)
138      {
139          using var stream = new MemoryStream();
140          using var writer = new Utf8JsonWriter(stream);
141          document.WriteTo(writer);
142          writer.Flush();
143          return stream.ToArray();
144      }
145      byte[] SerializeJsonObject(JsonNode jsonObject)
146      {
147          using var stream = new MemoryStream();
148          using var writer = new Utf8JsonWriter(stream);
149          jsonObject.WriteTo(writer);
150          writer.Flush();
151          return stream.ToArray();
152      }
153  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRawCopyStream.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Microsoft.Extensions.Logging;
7  using Npgsql.BackendMessages;
8  using Npgsql.Internal;
9  using static Npgsql.Util.Statics;
10  #pragma warning disable 1591
11  namespace Npgsql;
12  public sealed class NpgsqlRawCopyStream : Stream, ICancelable
13  {
14      #region Fields and Properties
15      NpgsqlConnector _connector;
16      NpgsqlReadBuffer _readBuf;
17      NpgsqlWriteBuffer _writeBuf;
18      int _leftToReadInDataMsg;
19      bool _isDisposed, _isConsumed;
20      bool _canRead;
21      bool _canWrite;
22      internal bool IsBinary { get; private set; }
23      public override bool CanWrite => _canWrite;
24      public override bool CanRead => _canRead;
25      public override bool CanTimeout => true;
26      public override int WriteTimeout
27      {
28          get => (int) _writeBuf.Timeout.TotalMilliseconds;
29          set => _writeBuf.Timeout = TimeSpan.FromMilliseconds(value);
30      }
31      public override int ReadTimeout
32      {
33          get => (int) _readBuf.Timeout.TotalMilliseconds;
34          set
35          {
36              _readBuf.Timeout = TimeSpan.FromMilliseconds(value);
37              _connector.UserTimeout = value;
38          }
39      }
40      internal static readonly byte[] BinarySignature =
41      {
42          (byte)'P',(byte)'G',(byte)'C',(byte)'O',(byte)'P',(byte)'Y',
43          (byte)'\n', 255, (byte)'\r', (byte)'\n', 0
44      };
45      readonly ILogger _copyLogger;
46      #endregion
47      #region Constructor / Initializer
48      internal NpgsqlRawCopyStream(NpgsqlConnector connector)
49      {
50          _connector = connector;
51          _readBuf = connector.ReadBuffer;
52          _writeBuf = connector.WriteBuffer;
53          _copyLogger = connector.LoggingConfiguration.CopyLogger;
54      }
55      internal async Task Init(string copyCommand, bool async, CancellationToken cancellationToken = default)
56      {
<span onclick='openModal()' class='match'>57          await _connector.WriteQuery(copyCommand, async, cancellationToken);
58          await _connector.Flush(async, cancellationToken);
</span>59          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
60          var msg = await _connector.ReadMessage(async);
61          switch (msg.Code)
62          {
63          case BackendMessageCode.CopyInResponse:
64              var copyInResponse = (CopyInResponseMessage) msg;
65              IsBinary = copyInResponse.IsBinary;
66              _canWrite = true;
67              _writeBuf.StartCopyMode();
68              break;
69          case BackendMessageCode.CopyOutResponse:
70              var copyOutResponse = (CopyOutResponseMessage) msg;
71              IsBinary = copyOutResponse.IsBinary;
72              _canRead = true;
73              break;
74          case BackendMessageCode.CommandComplete:
75              throw new InvalidOperationException(
76                  "This API only supports import/export from the client, i.e. COPY commands containing TO/FROM STDIN. " +
77                  "To import/export with files on your PostgreSQL machine, simply execute the command with ExecuteNonQuery. " +
78                  "Note that your data has been successfully imported/exported.");
79          default:
80              throw _connector.UnexpectedMessageReceived(msg.Code);
81          }
82      }
83      #endregion
84      #region Write
85      public override void Write(byte[] buffer, int offset, int count)
86      {
87          ValidateArguments(buffer, offset, count);
88          Write(new ReadOnlySpan<byte>(buffer, offset, count));
89      }
90      public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
91      {
92          ValidateArguments(buffer, offset, count);
93          return WriteAsync(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
94      }
95  #if NETSTANDARD2_0
96      public void Write(ReadOnlySpan<byte> buffer)
97  #else
98      public override void Write(ReadOnlySpan<byte> buffer)
99  #endif
100      {
101          CheckDisposed();
102          if (!CanWrite)
103              throw new InvalidOperationException("Stream not open for writing");
104          if (buffer.Length == 0) { return; }
105          if (buffer.Length <= _writeBuf.WriteSpaceLeft)
106          {
107              _writeBuf.WriteBytes(buffer);
108              return;
109          }
110          try
111          {
112              Flush();
113              if (buffer.Length <= _writeBuf.WriteSpaceLeft)
114              {
115                  _writeBuf.WriteBytes(buffer);
116                  return;
117              }
118              _writeBuf.DirectWrite(buffer);
119          }
120          catch (Exception e)
121          {
122              _connector.Break(e);
123              throw;
124          }
125      }
126  #if NETSTANDARD2_0
127      public ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
128  #else
129      public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
130  #endif
131      {
132          CheckDisposed();
133          if (!CanWrite)
134              throw new InvalidOperationException("Stream not open for writing");
135          cancellationToken.ThrowIfCancellationRequested();
136          using (NoSynchronizationContextScope.Enter())
137              return WriteAsyncInternal(buffer, cancellationToken);
138          async ValueTask WriteAsyncInternal(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
139          {
140              if (buffer.Length == 0)
141                  return;
142              if (buffer.Length <= _writeBuf.WriteSpaceLeft)
143              {
144                  _writeBuf.WriteBytes(buffer.Span);
145                  return;
146              }
147              try
148              {
149                  await FlushAsync(true, cancellationToken);
150                  if (buffer.Length <= _writeBuf.WriteSpaceLeft)
151                  {
152                      _writeBuf.WriteBytes(buffer.Span);
153                      return;
154                  }
155                  await _writeBuf.DirectWrite(buffer, true, cancellationToken);
156              }
157              catch (Exception e)
158              {
159                  _connector.Break(e);
160                  throw;
161              }
162          }
163      }
164      public override void Flush() => FlushAsync(false).GetAwaiter().GetResult();
165      public override Task FlushAsync(CancellationToken cancellationToken)
166      {
167          if (cancellationToken.IsCancellationRequested)
168              return Task.FromCanceled(cancellationToken);
169          using (NoSynchronizationContextScope.Enter())
170              return FlushAsync(true, cancellationToken);
171      }
172      Task FlushAsync(bool async, CancellationToken cancellationToken = default)
173      {
174          CheckDisposed();
175          return _writeBuf.Flush(async, cancellationToken);
176      }
177      #endregion
178      #region Read
179      public override int Read(byte[] buffer, int offset, int count)
180      {
181          ValidateArguments(buffer, offset, count);
182          return Read(new Span<byte>(buffer, offset, count));
183      }
184      public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
185      {
186          ValidateArguments(buffer, offset, count);
187          return ReadAsync(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
188      }
189  #if NETSTANDARD2_0
190      public int Read(Span<byte> span)
191  #else
192      public override int Read(Span<byte> span)
193  #endif
194      {
195          CheckDisposed();
196          if (!CanRead)
197              throw new InvalidOperationException("Stream not open for reading");
198          var count = ReadCore(span.Length, false).GetAwaiter().GetResult();
199          if (count > 0)
200              _readBuf.ReadBytes(span.Slice(0, count));
201          return count;
202      }
203  #if NETSTANDARD2_0
204      public ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
205  #else
206      public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
207  #endif
208      {
209          CheckDisposed();
210          if (!CanRead)
211              throw new InvalidOperationException("Stream not open for reading");
212          cancellationToken.ThrowIfCancellationRequested();
213          using (NoSynchronizationContextScope.Enter())
214              return ReadAsyncInternal();
215          async ValueTask<int> ReadAsyncInternal()
216          {
217              var count = await ReadCore(buffer.Length, true, cancellationToken);
218              if (count > 0)
219                  _readBuf.ReadBytes(buffer.Slice(0, count).Span);
220              return count;
221          }
222      }
223      async ValueTask<int> ReadCore(int count, bool async, CancellationToken cancellationToken = default)
224      {
225          if (_isConsumed)
226              return 0;
227          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
228          if (_leftToReadInDataMsg == 0)
229          {
230              IBackendMessage msg;
231              try
232              {
233                  msg = await _connector.ReadMessage(async);
234              }
235              catch
236              {
237                  if (!_isDisposed)
238                      Cleanup();
239                  throw;
240              }
241              switch (msg.Code)
242              {
243              case BackendMessageCode.CopyData:
244                  _leftToReadInDataMsg = ((CopyDataMessage)msg).Length;
245                  break;
246              case BackendMessageCode.CopyDone:
247                  Expect<CommandCompleteMessage>(await _connector.ReadMessage(async), _connector);
248                  Expect<ReadyForQueryMessage>(await _connector.ReadMessage(async), _connector);
249                  _isConsumed = true;
250                  return 0;
251              default:
252                  throw _connector.UnexpectedMessageReceived(msg.Code);
253              }
254          }
255          Debug.Assert(_leftToReadInDataMsg > 0);
256          if (_readBuf.ReadBytesLeft == 0)
257              await _readBuf.ReadMore(async);
258          Debug.Assert(_readBuf.ReadBytesLeft > 0);
259          var maxCount = Math.Min(_readBuf.ReadBytesLeft, _leftToReadInDataMsg);
260          if (count > maxCount)
261              count = maxCount;
262          _leftToReadInDataMsg -= count;
263          return count;
264      }
265      #endregion
266      #region Cancel
267      public void Cancel() => Cancel(false).GetAwaiter().GetResult();
268      public Task CancelAsync()
269      {
270          using (NoSynchronizationContextScope.Enter())
271              return Cancel(true);
272      }
273      async Task Cancel(bool async)
274      {
275          CheckDisposed();
276          if (CanWrite)
277          {
278              _writeBuf.EndCopyMode();
279              _writeBuf.Clear();
280              await _connector.WriteCopyFail(async);
281              await _connector.Flush(async);
282              try
283              {
284                  var msg = await _connector.ReadMessage(async);
285                  throw _connector.Break(
286                      new NpgsqlException("Expected ErrorResponse when cancelling COPY but got: " + msg.Code));
287              }
288              catch (PostgresException e)
289              {
290                  Cleanup();
291                  if (e.SqlState != PostgresErrorCodes.QueryCanceled)
292                      throw;
293              }
294          }
295          else
296          {
297              _connector.PerformPostgresCancellation();
298          }
299      }
300      #endregion
301      #region Dispose
302      protected override void Dispose(bool disposing) => DisposeAsync(disposing, false).GetAwaiter().GetResult();
303  #if NETSTANDARD2_0
304      public ValueTask DisposeAsync()
305  #else
306      public override ValueTask DisposeAsync()
307  #endif
308          => DisposeAsync(disposing: true, async: true);
309      async ValueTask DisposeAsync(bool disposing, bool async)
310      {
311          if (_isDisposed || !disposing)
312              return;
313          try
314          {
315              _connector.CurrentCopyOperation = null;
316              if (CanWrite)
317              {
318                  await FlushAsync(async);
319                  _writeBuf.EndCopyMode();
320                  await _connector.WriteCopyDone(async);
321                  await _connector.Flush(async);
322                  Expect<CommandCompleteMessage>(await _connector.ReadMessage(async), _connector);
323                  Expect<ReadyForQueryMessage>(await _connector.ReadMessage(async), _connector);
324              }
325              else
326              {
327                  if (!_isConsumed)
328                  {
329                      try
330                      {
331                          if (_leftToReadInDataMsg > 0)
332                          {
333                              await _readBuf.Skip(_leftToReadInDataMsg, async);
334                          }
335                          _connector.SkipUntil(BackendMessageCode.ReadyForQuery);
336                      }
337                      catch (OperationCanceledException e) when (e.InnerException is PostgresException pg && pg.SqlState == PostgresErrorCodes.QueryCanceled)
338                      {
339                          LogMessages.CopyOperationCancelled(_copyLogger, _connector.Id);
340                      }
341                      catch (Exception e)
342                      {
343                          LogMessages.ExceptionWhenDisposingCopyOperation(_copyLogger, _connector.Id, e);
344                      }
345                  }
346              }
347          }
348          finally
349          {
350              Cleanup();
351          }
352      }
353  #pragma warning disable CS8625
354      void Cleanup()
355      {
356          Debug.Assert(!_isDisposed);
357          LogMessages.CopyOperationCompleted(_copyLogger, _connector.Id);
358          _connector.EndUserAction();
359          _connector.CurrentCopyOperation = null;
360          _connector.Connection?.EndBindingScope(ConnectorBindingScope.Copy);
361          _connector = null;
362          _readBuf = null;
363          _writeBuf = null;
364          _isDisposed = true;
365      }
366  #pragma warning restore CS8625
367      void CheckDisposed()
368      {
369          if (_isDisposed) {
370              throw new ObjectDisposedException(nameof(NpgsqlRawCopyStream), "The COPY operation has already ended.");
371          }
372      }
373      #endregion
374      #region Unsupported
375      public override bool CanSeek => false;
376      public override long Seek(long offset, SeekOrigin origin)
377      {
378          throw new NotSupportedException();
379      }
380      public override void SetLength(long value)
381      {
382          throw new NotSupportedException();
383      }
384      public override long Length => throw new NotSupportedException();
385      public override long Position
386      {
387          get => throw new NotSupportedException();
388          set => throw new NotSupportedException();
389      }
390      #endregion
391      #region Input validation
392      static void ValidateArguments(byte[] buffer, int offset, int count)
393      {
394          if (buffer == null)
395              throw new ArgumentNullException(nameof(buffer));
396          if (offset < 0)
397              throw new ArgumentNullException(nameof(offset));
398          if (count < 0)
399              throw new ArgumentNullException(nameof(count));
400          if (buffer.Length - offset < count)
401              throw new ArgumentException("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
402      }
403      #endregion
404  }
405  public sealed class NpgsqlCopyTextWriter : StreamWriter, ICancelable
406  {
407      internal NpgsqlCopyTextWriter(NpgsqlConnector connector, NpgsqlRawCopyStream underlying) : base(underlying)
408      {
409          if (underlying.IsBinary)
410              throw connector.Break(new Exception("Can't use a binary copy stream for text writing"));
411      }
412      public void Cancel()
413          => ((NpgsqlRawCopyStream)BaseStream).Cancel();
414      public Task CancelAsync()
415      {
416          using (NoSynchronizationContextScope.Enter())
417              return ((NpgsqlRawCopyStream)BaseStream).CancelAsync();
418      }
419  #if NETSTANDARD2_0
420      public ValueTask DisposeAsync()
421      {
422          Dispose();
423          return default;
424      }
425  #endif
426  }
427  public sealed class NpgsqlCopyTextReader : StreamReader, ICancelable
428  {
429      internal NpgsqlCopyTextReader(NpgsqlConnector connector, NpgsqlRawCopyStream underlying) : base(underlying)
430      {
431          if (underlying.IsBinary)
432              throw connector.Break(new Exception("Can't use a binary copy stream for text reading"));
433      }
434      public void Cancel()
435          => ((NpgsqlRawCopyStream)BaseStream).Cancel();
436      public Task CancelAsync()
437      {
438          using (NoSynchronizationContextScope.Enter())
439              return ((NpgsqlRawCopyStream)BaseStream).CancelAsync();
440      }
441      public ValueTask DisposeAsync()
442      {
443          Dispose();
444          return default;
445      }
446  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-SystemTextJsonHandler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRawCopyStream.cs</div>
                </div>
                <div class="column column_space"><pre><code>74              await buf.WriteBytesRaw(data, async, cancellationToken);
75          }
</pre></code></div>
                <div class="column column_space"><pre><code>57          await _connector.WriteQuery(copyCommand, async, cancellationToken);
58          await _connector.Flush(async, cancellationToken);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    