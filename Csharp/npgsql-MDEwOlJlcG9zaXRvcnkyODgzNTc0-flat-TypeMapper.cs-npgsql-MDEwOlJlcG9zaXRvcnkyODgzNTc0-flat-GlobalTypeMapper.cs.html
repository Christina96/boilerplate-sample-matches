
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using Microsoft.Extensions.Logging;
9  using Npgsql.Internal.TypeHandlers;
10  using Npgsql.Internal.TypeHandling;
11  using Npgsql.PostgresTypes;
12  using Npgsql.TypeMapping;
13  using NpgsqlTypes;
14  namespace Npgsql.Internal.TypeMapping;
15  public sealed class TypeMapper
16  {
17      internal NpgsqlConnector Connector { get; }
18      readonly object _writeLock = new();
19      NpgsqlDatabaseInfo? _databaseInfo;
20      internal NpgsqlDatabaseInfo DatabaseInfo
21      {
22          get
23          {
24              var databaseInfo = _databaseInfo;
25              if (databaseInfo is null)
26                  ThrowHelper.ThrowInvalidOperationException("Internal error: this type mapper hasn't yet been bound to a database info object");
27              return databaseInfo;
28          }
29      }
30      volatile TypeHandlerResolver[] _handlerResolvers;
31      volatile TypeMappingResolver[] _mappingResolvers;
32      internal NpgsqlTypeHandler UnrecognizedTypeHandler { get; }
33      readonly ConcurrentDictionary<uint, NpgsqlTypeHandler> _handlersByOID = new();
34      readonly ConcurrentDictionary<NpgsqlDbType, NpgsqlTypeHandler> _handlersByNpgsqlDbType = new();
35      readonly ConcurrentDictionary<Type, NpgsqlTypeHandler> _handlersByClrType = new();
36      readonly ConcurrentDictionary<string, NpgsqlTypeHandler> _handlersByDataTypeName = new();
37      readonly Dictionary<uint, TypeMappingInfo> _userTypeMappings = new();
38      readonly INpgsqlNameTranslator _defaultNameTranslator;
39      readonly ILogger _commandLogger;
40      #region Construction
41      internal TypeMapper(NpgsqlConnector connector, INpgsqlNameTranslator defaultNameTranslator)
42      {
43          Connector = connector;
44          _defaultNameTranslator = defaultNameTranslator;
45          UnrecognizedTypeHandler = new UnknownTypeHandler(Connector.TextEncoding);
46          _handlerResolvers = Array.Empty<TypeHandlerResolver>();
47          _mappingResolvers = Array.Empty<TypeMappingResolver>();
48          _commandLogger = connector.LoggingConfiguration.CommandLogger;
49      }
50      #endregion Constructors
51      internal void Initialize(
52          NpgsqlDatabaseInfo databaseInfo,
53          List<TypeHandlerResolverFactory> resolverFactories,
54          Dictionary<string, IUserTypeMapping> userTypeMappings)
55      {
56          _databaseInfo = databaseInfo;
57          var handlerResolvers = new TypeHandlerResolver[resolverFactories.Count];
58          var mappingResolvers = new List<TypeMappingResolver>(resolverFactories.Count);
59          for (var i = 0; i < resolverFactories.Count; i++)
60          {
61              handlerResolvers[i] = resolverFactories[i].Create(this, Connector);
62              var mappingResolver = resolverFactories[i].CreateMappingResolver();
63              if (mappingResolver is not null)
64                  mappingResolvers.Add(mappingResolver);
65          }
66          for (var i = resolverFactories.Count - 1; i >= 0; i--)
67          {
68              var globalMappingResolver = resolverFactories[i].CreateGlobalMappingResolver();
69              if (globalMappingResolver is not null)
70                  GlobalTypeMapper.Instance.TryAddMappingResolver(globalMappingResolver);
71          }
72          _handlerResolvers = handlerResolvers;
73          _mappingResolvers = mappingResolvers.ToArray();
74          foreach (var userTypeMapping in userTypeMappings.Values)
75          {
76              if (DatabaseInfo.TryGetPostgresTypeByName(userTypeMapping.PgTypeName, out var pgType))
77              {
78                  _handlersByOID[pgType.OID] =
79                      _handlersByDataTypeName[pgType.FullName] =
80                          _handlersByDataTypeName[pgType.Name] =
81                              _handlersByClrType[userTypeMapping.ClrType] = userTypeMapping.CreateHandler(pgType, Connector);
82                  _userTypeMappings[pgType.OID] = new(npgsqlDbType: null, pgType.Name, userTypeMapping.ClrType);
83              }
84          }
85      }
86      #region Type handler lookup
87      public NpgsqlTypeHandler ResolveByOID(uint oid)
88          => TryResolveByOID(oid, out var result) ? result : UnrecognizedTypeHandler;
89      internal bool TryResolveByOID(uint oid, [NotNullWhen(true)] out NpgsqlTypeHandler? handler)
90      {
91          if (_handlersByOID.TryGetValue(oid, out handler))
92              return true;
93          return TryResolveLong(oid, out handler);
94          bool TryResolveLong(uint oid, [NotNullWhen(true)] out NpgsqlTypeHandler? handler)
95          {
96              if (!DatabaseInfo.ByOID.TryGetValue(oid, out var pgType))
97              {
98                  handler = null;
99                  return false;
100              }
101              lock (_writeLock)
102              {
103                  if ((handler = ResolveByPostgresType(pgType)) is not null)
104                  {
105                      _handlersByOID[oid] = handler;
106                      return true;
107                  }
108                  if ((handler = ResolveComplexTypeByDataTypeName(pgType.FullName, throwOnError: false)) is not null)
109                  {
110                      _handlersByOID[oid] = handler;
111                      return true;
112                  }
113                  handler = null;
114                  return false;
115              }
116          }
117      }
118      public NpgsqlTypeHandler ResolveByNpgsqlDbType(NpgsqlDbType npgsqlDbType)
119      {
120          if (_handlersByNpgsqlDbType.TryGetValue(npgsqlDbType, out var handler))
121              return handler;
122          return ResolveLong(npgsqlDbType);
123          NpgsqlTypeHandler ResolveLong(NpgsqlDbType npgsqlDbType)
124          {
125              lock (_writeLock)
126              {
127                  if (GlobalTypeMapper.NpgsqlDbTypeToDataTypeName(npgsqlDbType) is { } dataTypeName)
128                  {
129                      foreach (var resolver in _handlerResolvers)
130                      {
131                          try
132                          {
133                              if (resolver.ResolveByDataTypeName(dataTypeName) is { } handler)
134                                  return _handlersByNpgsqlDbType[npgsqlDbType] = handler;
135                          }
136                          catch (Exception e)
137                          {
138                              _commandLogger.LogError(e,
139                                  $"Type resolver {resolver.GetType().Name} threw exception while resolving NpgsqlDbType {npgsqlDbType}");
140                          }
141                      }
142                  }
143                  foreach (var resolver in _handlerResolvers)
144                  {
145                      try
146                      {
147                          if (resolver.ResolveByNpgsqlDbType(npgsqlDbType) is { } handler)
148                              return _handlersByNpgsqlDbType[npgsqlDbType] = handler;
149                      }
150                      catch (Exception e)
151                      {
152                          _commandLogger.LogError(e,
153                              $"Type resolver {resolver.GetType().Name} threw exception while resolving NpgsqlDbType {npgsqlDbType}");
154                      }
155                  }
156                  if (npgsqlDbType.HasFlag(NpgsqlDbType.Array))
157                  {
158                      var elementHandler = ResolveByNpgsqlDbType(npgsqlDbType & ~NpgsqlDbType.Array);
159                      if (elementHandler.PostgresType.Array is not { } pgArrayType)
160                          throw new ArgumentException(
161                              $"No array type could be found in the database for element {elementHandler.PostgresType}");
162                      return _handlersByNpgsqlDbType[npgsqlDbType] =
163                          elementHandler.CreateArrayHandler(pgArrayType, Connector.Settings.ArrayNullabilityMode);
164                  }
165                  throw new NpgsqlException($"The NpgsqlDbType '{npgsqlDbType}' isn't present in your database. " +
166                                            "You may need to install an extension or upgrade to a newer version.");
167              }
168          }
169      }
170      internal NpgsqlTypeHandler ResolveByDataTypeName(string typeName)
171          => ResolveByDataTypeNameCore(typeName) ?? ResolveComplexTypeByDataTypeName(typeName, throwOnError: true)!;
172      NpgsqlTypeHandler? ResolveByDataTypeNameCore(string typeName)
173      {
174          if (_handlersByDataTypeName.TryGetValue(typeName, out var handler))
175              return handler;
176          return ResolveLong(typeName);
177          NpgsqlTypeHandler? ResolveLong(string typeName)
178          {
179              lock (_writeLock)
180              {
181                  foreach (var resolver in _handlerResolvers)
182                  {
183                      try
184                      {
185                          if (resolver.ResolveByDataTypeName(typeName) is { } handler)
186                              return _handlersByDataTypeName[typeName] = handler;
187                      }
188                      catch (Exception e)
189                      {
190                          _commandLogger.LogError(e, $"Type resolver {resolver.GetType().Name} threw exception while resolving data type name {typeName}");
191                      }
192                  }
193                  return null;
194              }
195          }
196      }
197      NpgsqlTypeHandler? ResolveByPostgresType(PostgresType type)
198      {
199          if (_handlersByDataTypeName.TryGetValue(type.FullName, out var handler))
200              return handler;
201          return ResolveLong(type);
202          NpgsqlTypeHandler? ResolveLong(PostgresType type)
203          {
204              lock (_writeLock)
205              {
206                  foreach (var resolver in _handlerResolvers)
207                  {
208                      try
209                      {
210                          if (resolver.ResolveByPostgresType(type) is { } handler)
211                              return _handlersByDataTypeName[type.FullName] = handler;
212                      }
213                      catch (Exception e)
214                      {
215                          _commandLogger.LogError(e, $"Type resolver {resolver.GetType().Name} threw exception while resolving data type name {type.FullName}");
216                      }
217                  }
218                  return null;
219              }
220          }
221      }
222      NpgsqlTypeHandler? ResolveComplexTypeByDataTypeName(string typeName, bool throwOnError)
223      {
224          lock (_writeLock)
225          {
226              var pgType = DatabaseInfo.GetPostgresTypeByName(typeName);
227              switch (pgType)
228              {
229              case PostgresArrayType pgArrayType:
230              {
231                  var elementHandler = ResolveByOID(pgArrayType.Element.OID);
232                  return _handlersByDataTypeName[typeName] =
233                      elementHandler.CreateArrayHandler(pgArrayType, Connector.Settings.ArrayNullabilityMode);
234              }
235              case PostgresEnumType pgEnumType:
236              {
237                  return _handlersByDataTypeName[typeName] =
238                      new UnmappedEnumHandler(pgEnumType, _defaultNameTranslator, Connector.TextEncoding);
239              }
240              case PostgresDomainType pgDomainType:
241                  return _handlersByDataTypeName[typeName] = ResolveByOID(pgDomainType.BaseType.OID);
242              case PostgresBaseType pgBaseType:
243                  return throwOnError
244                      ? throw new NotSupportedException($"PostgreSQL type '{pgBaseType}' isn't supported by Npgsql")
245                      : null;
246              case PostgresCompositeType pgCompositeType:
247                  return throwOnError
248                      ? throw new NotSupportedException(
249                          $"Composite type '{pgCompositeType}' must be mapped with Npgsql before being used, see the docs.")
250                      : null;
251  #pragma warning disable CS0618
252              case PostgresRangeType:
253              case PostgresMultirangeType:
254                  return throwOnError
255                      ? throw new NotSupportedException(
256                          $"'{pgType}' is a range type; please call {nameof(NpgsqlSlimDataSourceBuilder.EnableRanges)} on {nameof(NpgsqlSlimDataSourceBuilder)} to enable ranges. " +
257                          "See https:&bsol;&bsol;www.npgsql.org/doc/types/ranges.html for more information.")
258                      : null;
259  #pragma warning restore CS0618
260              default:
261                  throw new ArgumentOutOfRangeException($"Unhandled PostgreSQL type type: {pgType.GetType()}");
262              }
263          }
264      }
265      internal NpgsqlTypeHandler ResolveByValue<T>(T value)
266      {
267          if (value is null)
268              return ResolveByClrType(typeof(T));
269          if (typeof(T).IsValueType)
270          {
271              NpgsqlTypeHandler? handler;
272              foreach (var resolver in _handlerResolvers)
273              {
274                  try
275                  {
276                      if ((handler = resolver.ResolveValueTypeGenerically(value)) is not null)
277                          return handler;
278                  }
279                  catch (Exception e)
280                  {
281                      _commandLogger.LogError(e, $"Type resolver {resolver.GetType().Name} threw exception while resolving value with type {typeof(T)}");
282                  }
283              }
284          }
285          return ResolveByValue((object)value);
286      }
287      internal NpgsqlTypeHandler ResolveByValue(object value)
288      {
289          var type = value.GetType();
290          if (_handlersByClrType.TryGetValue(type, out var handler))
291              return handler;
292          return ResolveLong(value, type);
293          NpgsqlTypeHandler ResolveLong(object value, Type type)
294          {
295              foreach (var resolver in _handlerResolvers)
296              {
297                  try
298                  {
299                      if (resolver.ResolveValueDependentValue(value) is { } handler)
300                          return handler;
301                  }
302                  catch (Exception e)
303                  {
304                      _commandLogger.LogError(e, $"Type resolver {resolver.GetType().Name} threw exception while resolving value with type {type}");
305                  }
306              }
307              return ResolveByClrType(type);
308          }
309      }
310      public NpgsqlTypeHandler ResolveByClrType(Type type)
311      {
312          if (_handlersByClrType.TryGetValue(type, out var handler))
313              return handler;
314          return ResolveLong(type);
315          NpgsqlTypeHandler ResolveLong(Type type)
316          {
317              lock (_writeLock)
318              {
319                  foreach (var resolver in _handlerResolvers)
320                  {
321                      try
322                      {
323                          if (resolver.ResolveByClrType(type) is { } handler)
324                              return _handlersByClrType[type] = handler;
325                      }
326                      catch (Exception e)
327                      {
328                          _commandLogger.LogError(e, $"Type resolver {resolver.GetType().Name} threw exception while resolving value with type {type}");
329                      }
330                  }
331                  var arrayElementType = GetArrayListElementType(type);
332                  if (arrayElementType is not null)
333                  {
334                      if (ResolveByClrType(arrayElementType) is not { } elementHandler)
335                          throw new ArgumentException($"Array type over CLR type {arrayElementType.Name} isn't supported by Npgsql");
336                      if (elementHandler.PostgresType.Array is not { } pgArrayType)
337                          throw new ArgumentException(
338                              $"No array type could be found in the database for element {elementHandler.PostgresType}");
339                      return _handlersByClrType[type] =
340                          elementHandler.CreateArrayHandler(pgArrayType, Connector.Settings.ArrayNullabilityMode);
341                  }
342                  if (Nullable.GetUnderlyingType(type) is { } underlyingType && ResolveByClrType(underlyingType) is { } underlyingHandler)
343                      return _handlersByClrType[type] = underlyingHandler;
344                  if (type.IsEnum)
345                  {
346                      return DatabaseInfo.TryGetPostgresTypeByName(GetPgName(type, _defaultNameTranslator), out var pgType)
347                             && pgType is PostgresEnumType pgEnumType
348                          ? _handlersByClrType[type] = new UnmappedEnumHandler(pgEnumType, _defaultNameTranslator, Connector.TextEncoding)
349                          : throw new NotSupportedException(
350                              $"Could not find a PostgreSQL enum type corresponding to {type.Name}. " +
351                              "Consider mapping the enum before usage, refer to the documentation for more details.");
352                  }
353                  if (typeof(IEnumerable).IsAssignableFrom(type))
354                      throw new NotSupportedException("IEnumerable parameters are not supported, pass an array or List instead");
355                  throw new NotSupportedException($"The CLR type {type} isn't natively supported by Npgsql or your PostgreSQL. " +
356                                                  $"To use it with a PostgreSQL composite you need to specify {nameof(NpgsqlParameter.DataTypeName)} or to map it, please refer to the documentation.");
357              }
358              static Type? GetArrayListElementType(Type type)
359              {
360                  var typeInfo = type.GetTypeInfo();
361                  if (typeInfo.IsArray)
362                      return GetUnderlyingType(type.GetElementType()!); 
363                  var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x => x.GetTypeInfo().IsGenericType && x.GetGenericTypeDefinition() == typeof(IList<>));
364                  if (ilist != null)
365                      return GetUnderlyingType(ilist.GetGenericArguments()[0]);
366                  if (typeof(IList).IsAssignableFrom(type))
367                      throw new NotSupportedException("Non-generic IList is a supported parameter, but the NpgsqlDbType parameter must be set on the parameter");
368                  return null;
369                  Type GetUnderlyingType(Type t)
370                      => Nullable.GetUnderlyingType(t) ?? t;
371              }   
372          }
373      }
374      #endregion Type handler lookup
375      internal bool TryGetMapping(PostgresType pgType, [NotNullWhen(true)] out TypeMappingInfo? mapping)
376      {
377          foreach (var resolver in _mappingResolvers)
378              if ((mapping = resolver.GetMappingByPostgresType(this, pgType)) is not null)
379                  return true;
380          switch (pgType)
381          {
382          case PostgresArrayType pgArrayType:
383              if (TryGetMapping(pgArrayType.Element, out var elementMapping))
384              {
385                  mapping = new(elementMapping.NpgsqlDbType | NpgsqlDbType.Array, pgType.DisplayName);
386                  return true;
387              }
388              break;
389          case PostgresDomainType pgDomainType:
390              if (TryGetMapping(pgDomainType.BaseType, out var baseMapping))
391              {
392                  mapping = new(baseMapping.NpgsqlDbType, pgType.DisplayName, baseMapping.ClrTypes);
393                  return true;
394              }
395              break;
396          case PostgresEnumType or PostgresCompositeType:
397              return _userTypeMappings.TryGetValue(pgType.OID, out mapping);
398          }
399          mapping = null;
400          return false;
401      }
402      internal (NpgsqlDbType? npgsqlDbType, PostgresType postgresType) GetTypeInfoByOid(uint oid)
403      {
404          if (!DatabaseInfo.ByOID.TryGetValue(oid, out var pgType))
405              ThrowHelper.ThrowInvalidOperationException($"Couldn't find PostgreSQL type with OID {oid}");
406          if (TryGetMapping(pgType, out var mapping))
407              return (mapping.NpgsqlDbType, pgType);
408          return (null, pgType);
409      }
<span onclick='openModal()' class='match'>410      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
411          => clrType.GetCustomAttribute<PgNameAttribute>()?.PgName
412             ?? nameTranslator.TranslateTypeName(clrType.Name);
413  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using System.Threading;
9  using Npgsql.Internal.TypeHandling;
10  using Npgsql.Internal.TypeMapping;
11  using Npgsql.NameTranslation;
12  using NpgsqlTypes;
13  using static Npgsql.Util.Statics;
14  namespace Npgsql.TypeMapping;
15  sealed class GlobalTypeMapper : INpgsqlTypeMapper
16  {
17      public static GlobalTypeMapper Instance { get; }
18      public INpgsqlNameTranslator DefaultNameTranslator { get; set; } = new NpgsqlSnakeCaseNameTranslator();
19      internal List<TypeHandlerResolverFactory> HandlerResolverFactories { get; } = new();
20      List<TypeMappingResolver> MappingResolvers { get; } = new();
21      public ConcurrentDictionary<string, IUserTypeMapping> UserTypeMappings { get; } = new();
22      readonly ConcurrentDictionary<Type, TypeMappingInfo> _mappingsByClrType = new();
23      internal ReaderWriterLockSlim Lock { get; }
24          = new(LockRecursionPolicy.SupportsRecursion);
25      static GlobalTypeMapper()
26          => Instance = new GlobalTypeMapper();
27      GlobalTypeMapper()
28          => Reset();
29      #region Mapping management
30      public INpgsqlTypeMapper MapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
31          where TEnum : struct, Enum
32      {
33          if (pgName != null && pgName.Trim() == "")
34              throw new ArgumentException("pgName can't be empty", nameof(pgName));
35          nameTranslator ??= DefaultNameTranslator;
36          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
37          Lock.EnterWriteLock();
38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping<TEnum>(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
50          where TEnum : struct, Enum
51      {
52          if (pgName != null && pgName.Trim() == "")
53              throw new ArgumentException("pgName can't be empty", nameof(pgName));
54          nameTranslator ??= DefaultNameTranslator;
55          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
56          Lock.EnterWriteLock();
57          try
58          {
59              if (UserTypeMappings.TryRemove(pgName, out _))
60              {
61                  RecordChange();
62                  return true;
63              }
64              return false;
65          }
66          finally
67          {
68              Lock.ExitWriteLock();
69          }
70      }
71      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
72      public INpgsqlTypeMapper MapComposite<T>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
73      {
74          if (pgName != null && pgName.Trim() == "")
75              throw new ArgumentException("pgName can't be empty", nameof(pgName));
76          nameTranslator ??= DefaultNameTranslator;
77          pgName ??= GetPgName(typeof(T), nameTranslator);
78          Lock.EnterWriteLock();
79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping<T>(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
91      public INpgsqlTypeMapper MapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
92      {
93          var openMethod = typeof(GlobalTypeMapper).GetMethod(nameof(MapComposite), new[] { typeof(string), typeof(INpgsqlNameTranslator) })!;
94          var method = openMethod.MakeGenericMethod(clrType);
95          method.Invoke(this, new object?[] { pgName, nameTranslator });
96          return this;
97      }
98      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
99      public bool UnmapComposite<T>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
100          => UnmapComposite(typeof(T), pgName, nameTranslator);
101      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
102      public bool UnmapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
103      {
104          if (pgName != null && pgName.Trim() == "")
105              throw new ArgumentException("pgName can't be empty", nameof(pgName));
106          nameTranslator ??= DefaultNameTranslator;
107          pgName ??= GetPgName(clrType, nameTranslator);
108          Lock.EnterWriteLock();
109          try
110          {
111              if (UserTypeMappings.TryRemove(pgName, out _))
112              {
113                  RecordChange();
114                  return true;
115              }
116              return false;
117          }
118          finally
119          {
120              Lock.ExitWriteLock();
121          }
122      }
123      public void AddTypeResolverFactory(TypeHandlerResolverFactory resolverFactory)
124      {
125          Lock.EnterWriteLock();
126          try
127          {
128              var type = resolverFactory.GetType();
129              if (HandlerResolverFactories[0].GetType() == type)
130                  HandlerResolverFactories[0] = resolverFactory;
131              else
132              {
133                  for (var i = 0; i < HandlerResolverFactories.Count; i++)
134                      if (HandlerResolverFactories[i].GetType() == type)
135                          HandlerResolverFactories.RemoveAt(i);
136                  HandlerResolverFactories.Insert(0, resolverFactory);
137              }
138              var mappingResolver = resolverFactory.CreateMappingResolver();
139              if (mappingResolver is not null)
140                  AddMappingResolver(mappingResolver, overwrite: true);
141              RecordChange();
142          }
143          finally
144          {
145              Lock.ExitWriteLock();
146          }
147      }
148      internal void TryAddMappingResolver(TypeMappingResolver resolver)
149      {
150          Lock.EnterWriteLock();
151          try
152          {
153              if (AddMappingResolver(resolver, overwrite: false))
154                  RecordChange();
155          }
156          finally
157          {
158              Lock.ExitWriteLock();
159          }
160      }
161      bool AddMappingResolver(TypeMappingResolver resolver, bool overwrite)
162      {
163          var type = resolver.GetType();
164          if (MappingResolvers[0].GetType() == type)
165          {
166              if (!overwrite)
167                  return false;
168              MappingResolvers[0] = resolver;
169          }
170          else
171          {
172              for (var i = 0; i < MappingResolvers.Count; i++)
173              {
174                  if (MappingResolvers[i].GetType() == type)
175                  {
176                      if (!overwrite)
177                          return false;
178                      MappingResolvers.RemoveAt(i);
179                      break;
180                  }
181              }
182              MappingResolvers.Insert(0, resolver);
183          }
184          return true;
185      }
186      public void Reset()
187      {
188          Lock.EnterWriteLock();
189          try
190          {
191              HandlerResolverFactories.Clear();
192              HandlerResolverFactories.Add(new BuiltInTypeHandlerResolverFactory());
193              MappingResolvers.Clear();
194              MappingResolvers.Add(new BuiltInTypeMappingResolver());
195              UserTypeMappings.Clear();
196              RecordChange();
197          }
198          finally
199          {
200              Lock.ExitWriteLock();
201          }
202      }
203      internal void RecordChange()
204          => _mappingsByClrType.Clear();
<span onclick='openModal()' class='match'>205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          => clrType.GetCustomAttribute<PgNameAttribute>()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
</span>209      #region NpgsqlDbType/DbType inference for NpgsqlParameter
210      [RequiresUnreferencedCode("ToNpgsqlDbType uses interface-based reflection and isn't trimming-safe")]
211      internal bool TryResolveMappingByValue(object value, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
212      {
213          Lock.EnterReadLock();
214          try
215          {
216              var type = value.GetType();
217              if (_mappingsByClrType.TryGetValue(type, out typeMapping))
218                  return true;
219              foreach (var resolver in MappingResolvers)
220                  if ((typeMapping = resolver.GetMappingByValueDependentValue(value)) is not null)
221                      return true;
222              return TryResolveMappingByClrType(type, out typeMapping);
223          }
224          finally
225          {
226              Lock.ExitReadLock();
227          }
228          bool TryResolveMappingByClrType(Type clrType, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
229          {
230              if (_mappingsByClrType.TryGetValue(clrType, out typeMapping))
231                  return true;
232              foreach (var resolver in MappingResolvers)
233              {
234                  if ((typeMapping = resolver.GetMappingByClrType(clrType)) is not null)
235                  {
236                      _mappingsByClrType[clrType] = typeMapping;
237                      return true;
238                  }
239              }
240              if (clrType.IsArray)
241              {
242                  if (TryResolveMappingByClrType(clrType.GetElementType()!, out var elementMapping))
243                  {
244                      _mappingsByClrType[clrType] = typeMapping = new(
245                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
246                          elementMapping.DataTypeName + "[]");
247                      return true;
248                  }
249                  typeMapping = null;
250                  return false;
251              }
252              var typeInfo = clrType.GetTypeInfo();
253              var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =>
254                  x.GetTypeInfo().IsGenericType && x.GetGenericTypeDefinition() == typeof(IList<>));
255              if (ilist != null)
256              {
257                  if (TryResolveMappingByClrType(ilist.GetGenericArguments()[0], out var elementMapping))
258                  {
259                      _mappingsByClrType[clrType] = typeMapping = new(
260                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
261                          elementMapping.DataTypeName + "[]");
262                      return true;
263                  }
264                  typeMapping = null;
265                  return false;
266              }
267              if (typeInfo.IsGenericType && clrType.GetGenericTypeDefinition() == typeof(NpgsqlRange<>))
268              {
269                  if (TryResolveMappingByClrType(clrType.GetGenericArguments()[0], out var elementMapping))
270                  {
271                      _mappingsByClrType[clrType] = typeMapping = new(
272                          NpgsqlDbType.Range | elementMapping.NpgsqlDbType,
273                          dataTypeName: null);
274                      return true;
275                  }
276                  typeMapping = null;
277                  return false;
278              }
279              typeMapping = null;
280              return false;
281          }
282      }
283      #endregion NpgsqlDbType/DbType inference for NpgsqlParameter
284      #region Static translation tables
285      public static string? NpgsqlDbTypeToDataTypeName(NpgsqlDbType npgsqlDbType)
286          => npgsqlDbType switch
287          {
288              NpgsqlDbType.Smallint => "smallint",
289              NpgsqlDbType.Integer  => "integer",
290              NpgsqlDbType.Bigint   => "bigint",
291              NpgsqlDbType.Real     => "real",
292              NpgsqlDbType.Double   => "double precision",
293              NpgsqlDbType.Numeric  => "numeric",
294              NpgsqlDbType.Money    => "money",
295              NpgsqlDbType.Text      => "text",
296              NpgsqlDbType.Xml       => "xml",
297              NpgsqlDbType.Varchar   => "character varying",
298              NpgsqlDbType.Char      => "character",
299              NpgsqlDbType.Name      => "name",
300              NpgsqlDbType.Refcursor => "refcursor",
301              NpgsqlDbType.Citext    => "citext",
302              NpgsqlDbType.Jsonb     => "jsonb",
303              NpgsqlDbType.Json      => "json",
304              NpgsqlDbType.JsonPath  => "jsonpath",
305              NpgsqlDbType.Timestamp   => "timestamp without time zone",
306              NpgsqlDbType.TimestampTz => "timestamp with time zone",
307              NpgsqlDbType.Date        => "date",
308              NpgsqlDbType.Time        => "time without time zone",
309              NpgsqlDbType.TimeTz      => "time with time zone",
310              NpgsqlDbType.Interval    => "interval",
311              NpgsqlDbType.Cidr     => "cidr",
312              NpgsqlDbType.Inet     => "inet",
313              NpgsqlDbType.MacAddr  => "macaddr",
314              NpgsqlDbType.MacAddr8 => "macaddr8",
315              NpgsqlDbType.TsQuery   => "tsquery",
316              NpgsqlDbType.TsVector  => "tsvector",
317              NpgsqlDbType.Box     => "box",
318              NpgsqlDbType.Circle  => "circle",
319              NpgsqlDbType.Line    => "line",
320              NpgsqlDbType.LSeg    => "lseg",
321              NpgsqlDbType.Path    => "path",
322              NpgsqlDbType.Point   => "point",
323              NpgsqlDbType.Polygon => "polygon",
324              NpgsqlDbType.LQuery    => "lquery",
325              NpgsqlDbType.LTree     => "ltree",
326              NpgsqlDbType.LTxtQuery => "ltxtquery",
327              NpgsqlDbType.Oid       => "oid",
328              NpgsqlDbType.Xid       => "xid",
329              NpgsqlDbType.Xid8      => "xid8",
330              NpgsqlDbType.Cid       => "cid",
331              NpgsqlDbType.Regtype   => "regtype",
332              NpgsqlDbType.Regconfig => "regconfig",
333              NpgsqlDbType.Boolean => "boolean",
334              NpgsqlDbType.Bytea   => "bytea",
335              NpgsqlDbType.Uuid    => "uuid",
336              NpgsqlDbType.Varbit  => "bit varying",
337              NpgsqlDbType.Bit     => "bit",
338              NpgsqlDbType.Hstore  => "hstore",
339              NpgsqlDbType.Geometry  => "geometry",
340              NpgsqlDbType.Geography => "geography",
341              NpgsqlDbType.IntegerRange     => "int4range",
342              NpgsqlDbType.BigIntRange      => "int8range",
343              NpgsqlDbType.NumericRange     => "numrange",
344              NpgsqlDbType.TimestampRange   => "tsrange",
345              NpgsqlDbType.TimestampTzRange => "tstzrange",
346              NpgsqlDbType.DateRange        => "daterange",
347              NpgsqlDbType.IntegerMultirange     => "int4multirange",
348              NpgsqlDbType.BigIntMultirange      => "int8multirange",
349              NpgsqlDbType.NumericMultirange     => "nummultirange",
350              NpgsqlDbType.TimestampMultirange   => "tsmultirange",
351              NpgsqlDbType.TimestampTzMultirange => "tstzmultirange",
352              NpgsqlDbType.DateMultirange        => "datemultirange",
353              NpgsqlDbType.Int2Vector   => "int2vector",
354              NpgsqlDbType.Oidvector    => "oidvector",
355              NpgsqlDbType.PgLsn        => "pg_lsn",
356              NpgsqlDbType.Tid          => "tid",
357              NpgsqlDbType.InternalChar => "char",
358              NpgsqlDbType.Unknown => "unknown",
359              _ => npgsqlDbType.HasFlag(NpgsqlDbType.Array)
360                  ? NpgsqlDbTypeToDataTypeName(npgsqlDbType & ~NpgsqlDbType.Array) + "[]"
361                  : null 
362          };
363      public static NpgsqlDbType DataTypeNameToNpgsqlDbType(string typeName)
364      {
365          var parenIndex = typeName.IndexOf('(');
366          if (parenIndex > -1)
367              typeName = typeName.Substring(0, parenIndex);
368          return typeName switch
369          {
370              "smallint" => NpgsqlDbType.Smallint,
371              "integer" or "int" => NpgsqlDbType.Integer,
372              "bigint" => NpgsqlDbType.Bigint,
373              "real" => NpgsqlDbType.Real,
374              "double precision" => NpgsqlDbType.Double,
375              "numeric" => NpgsqlDbType.Numeric,
376              "money" => NpgsqlDbType.Money,
377              "text" => NpgsqlDbType.Text,
378              "xml" => NpgsqlDbType.Xml,
379              "character varying" or "varchar" => NpgsqlDbType.Varchar,
380              "character" => NpgsqlDbType.Char,
381              "name" => NpgsqlDbType.Name,
382              "refcursor" => NpgsqlDbType.Refcursor,
383              "citext" => NpgsqlDbType.Citext,
384              "jsonb" => NpgsqlDbType.Jsonb,
385              "json" => NpgsqlDbType.Json,
386              "jsonpath" => NpgsqlDbType.JsonPath,
387              "timestamp without time zone" or "timestamp" => NpgsqlDbType.Timestamp,
388              "timestamp with time zone" or "timestamptz" => NpgsqlDbType.TimestampTz,
389              "date" => NpgsqlDbType.Date,
390              "time without time zone" or "timetz" => NpgsqlDbType.Time,
391              "time with time zone" or "time" => NpgsqlDbType.TimeTz,
392              "interval" => NpgsqlDbType.Interval,
393              "cidr" => NpgsqlDbType.Cidr,
394              "inet" => NpgsqlDbType.Inet,
395              "macaddr" => NpgsqlDbType.MacAddr,
396              "macaddr8" => NpgsqlDbType.MacAddr8,
397              "tsquery" => NpgsqlDbType.TsQuery,
398              "tsvector" => NpgsqlDbType.TsVector,
399              "box" => NpgsqlDbType.Box,
400              "circle" => NpgsqlDbType.Circle,
401              "line" => NpgsqlDbType.Line,
402              "lseg" => NpgsqlDbType.LSeg,
403              "path" => NpgsqlDbType.Path,
404              "point" => NpgsqlDbType.Point,
405              "polygon" => NpgsqlDbType.Polygon,
406              "lquery" => NpgsqlDbType.LQuery,
407              "ltree" => NpgsqlDbType.LTree,
408              "ltxtquery" => NpgsqlDbType.LTxtQuery,
409              "oid" => NpgsqlDbType.Oid,
410              "xid" => NpgsqlDbType.Xid,
411              "xid8" => NpgsqlDbType.Xid8,
412              "cid" => NpgsqlDbType.Cid,
413              "regtype" => NpgsqlDbType.Regtype,
414              "regconfig" => NpgsqlDbType.Regconfig,
415              "boolean" or "bool" => NpgsqlDbType.Boolean,
416              "bytea" => NpgsqlDbType.Bytea,
417              "uuid" => NpgsqlDbType.Uuid,
418              "bit varying" or "varbit" => NpgsqlDbType.Varbit,
419              "bit" => NpgsqlDbType.Bit,
420              "hstore" => NpgsqlDbType.Hstore,
421              "geometry" => NpgsqlDbType.Geometry,
422              "geography" => NpgsqlDbType.Geography,
423              "int4range" => NpgsqlDbType.IntegerRange,
424              "int8range" => NpgsqlDbType.BigIntRange,
425              "numrange" => NpgsqlDbType.NumericRange,
426              "tsrange" => NpgsqlDbType.TimestampRange,
427              "tstzrange" => NpgsqlDbType.TimestampTzRange,
428              "daterange" => NpgsqlDbType.DateRange,
429              "int4multirange" => NpgsqlDbType.IntegerMultirange,
430              "int8multirange" => NpgsqlDbType.BigIntMultirange,
431              "nummultirange" => NpgsqlDbType.NumericMultirange,
432              "tsmultirange" => NpgsqlDbType.TimestampMultirange,
433              "tstzmultirange" => NpgsqlDbType.TimestampTzMultirange,
434              "datemultirange" => NpgsqlDbType.DateMultirange,
435              "int2vector" => NpgsqlDbType.Int2Vector,
436              "oidvector" => NpgsqlDbType.Oidvector,
437              "pg_lsn" => NpgsqlDbType.PgLsn,
438              "tid" => NpgsqlDbType.Tid,
439              "char" => NpgsqlDbType.InternalChar,
440              _ => typeName.EndsWith("[]", StringComparison.Ordinal) &&
441                   DataTypeNameToNpgsqlDbType(typeName.Substring(0, typeName.Length - 2)) is { } elementNpgsqlDbType &&
442                   elementNpgsqlDbType != NpgsqlDbType.Unknown
443                  ? elementNpgsqlDbType | NpgsqlDbType.Array
444                  : NpgsqlDbType.Unknown 
445          };
446      }
447      internal static NpgsqlDbType? DbTypeToNpgsqlDbType(DbType dbType)
448          => dbType switch
449          {
450              DbType.AnsiString            => NpgsqlDbType.Text,
451              DbType.Binary                => NpgsqlDbType.Bytea,
452              DbType.Byte                  => NpgsqlDbType.Smallint,
453              DbType.Boolean               => NpgsqlDbType.Boolean,
454              DbType.Currency              => NpgsqlDbType.Money,
455              DbType.Date                  => NpgsqlDbType.Date,
456              DbType.DateTime              => LegacyTimestampBehavior ? NpgsqlDbType.Timestamp : NpgsqlDbType.TimestampTz,
457              DbType.Decimal               => NpgsqlDbType.Numeric,
458              DbType.VarNumeric            => NpgsqlDbType.Numeric,
459              DbType.Double                => NpgsqlDbType.Double,
460              DbType.Guid                  => NpgsqlDbType.Uuid,
461              DbType.Int16                 => NpgsqlDbType.Smallint,
462              DbType.Int32                 => NpgsqlDbType.Integer,
463              DbType.Int64                 => NpgsqlDbType.Bigint,
464              DbType.Single                => NpgsqlDbType.Real,
465              DbType.String                => NpgsqlDbType.Text,
466              DbType.Time                  => NpgsqlDbType.Time,
467              DbType.AnsiStringFixedLength => NpgsqlDbType.Text,
468              DbType.StringFixedLength     => NpgsqlDbType.Text,
469              DbType.Xml                   => NpgsqlDbType.Xml,
470              DbType.DateTime2             => NpgsqlDbType.Timestamp,
471              DbType.DateTimeOffset        => NpgsqlDbType.TimestampTz,
472              DbType.Object                => null,
473              DbType.SByte                 => null,
474              DbType.UInt16                => null,
475              DbType.UInt32                => null,
476              DbType.UInt64                => null,
477              _ => throw new ArgumentOutOfRangeException(nameof(dbType), dbType, null)
478          };
479      internal static DbType NpgsqlDbTypeToDbType(NpgsqlDbType npgsqlDbType)
480          => npgsqlDbType switch
481          {
482              NpgsqlDbType.Smallint    => DbType.Int16,
483              NpgsqlDbType.Integer     => DbType.Int32,
484              NpgsqlDbType.Bigint      => DbType.Int64,
485              NpgsqlDbType.Real        => DbType.Single,
486              NpgsqlDbType.Double      => DbType.Double,
487              NpgsqlDbType.Numeric     => DbType.Decimal,
488              NpgsqlDbType.Money       => DbType.Currency,
489              NpgsqlDbType.Text        => DbType.String,
490              NpgsqlDbType.Xml         => DbType.Xml,
491              NpgsqlDbType.Varchar     => DbType.String,
492              NpgsqlDbType.Char        => DbType.String,
493              NpgsqlDbType.Name        => DbType.String,
494              NpgsqlDbType.Refcursor   => DbType.String,
495              NpgsqlDbType.Citext      => DbType.String,
496              NpgsqlDbType.Jsonb       => DbType.Object,
497              NpgsqlDbType.Json        => DbType.Object,
498              NpgsqlDbType.JsonPath    => DbType.String,
499              NpgsqlDbType.Timestamp   => LegacyTimestampBehavior ? DbType.DateTime : DbType.DateTime2,
500              NpgsqlDbType.TimestampTz => LegacyTimestampBehavior ? DbType.DateTimeOffset : DbType.DateTime,
501              NpgsqlDbType.Date        => DbType.Date,
502              NpgsqlDbType.Time        => DbType.Time,
503              NpgsqlDbType.Bytea       => DbType.Binary,
504              NpgsqlDbType.Boolean     => DbType.Boolean,
505              NpgsqlDbType.Uuid        => DbType.Guid,
506              NpgsqlDbType.Unknown     => DbType.Object,
507              _ => DbType.Object
508          };
509      #endregion Static translation tables
510  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-TypeMapper.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</div>
                </div>
                <div class="column column_space"><pre><code>410      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
411          => clrType.GetCustomAttribute<PgNameAttribute>()?.PgName
412             ?? nameTranslator.TranslateTypeName(clrType.Name);
413  }
</pre></code></div>
                <div class="column column_space"><pre><code>205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          => clrType.GetCustomAttribute<PgNameAttribute>()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    