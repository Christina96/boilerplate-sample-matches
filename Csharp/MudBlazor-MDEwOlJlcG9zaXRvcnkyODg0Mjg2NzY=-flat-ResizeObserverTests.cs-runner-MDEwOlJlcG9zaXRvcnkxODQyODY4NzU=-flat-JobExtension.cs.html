
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ResizeObserverTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Threading.Tasks;
5  using FluentAssertions;
6  using Microsoft.AspNetCore.Components;
7  using Microsoft.JSInterop;
8  using Microsoft.JSInterop.Infrastructure;
9  using Moq;
10  using MudBlazor.Interop;
11  using MudBlazor.Services;
12  using NUnit.Framework;
13  namespace MudBlazor.UnitTests.Services
14  {
15      [TestFixture]
16      public class ResizeObserverTests
17      {
18          private class PseudoElementReferenceContext : ElementReferenceContext
19          {
20          }
21          private Mock<IJSRuntime> _runtimeMock;
22          private ResizeObserver _service;
23          [SetUp]
24          public void SetUp()
25          {
26              _runtimeMock = new Mock<IJSRuntime>(MockBehavior.Strict);
27              _service = new ResizeObserver(_runtimeMock.Object);
28          }
29          [Test]
30          public async Task ObserveAndCache()
31          {
32              var random = new Random();
<span onclick='openModal()' class='match'>33              List<ElementReference> allReferences = new();
34              List<ElementReference> notObservedReferences = new();
35              Dictionary<ElementReference, BoundingClientRect> resolvedElements = new();
</span>36              var amount = 13;
37              for (var i = 1; i <= amount; i++)
38              {
39                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
40                  var rect = GetRandomRect(random);
41                  if (i % 4 == 0)
42                  {
43                      reference = new ElementReference();
44                      notObservedReferences.Add(reference);
45                  }
46                  else if (i % 5 == 0)
47                  {
48                      reference = new ElementReference(Guid.NewGuid().ToString());
49                      notObservedReferences.Add(reference);
50                  }
51                  else
52                  {
53                      resolvedElements.Add(reference, rect);
54                  }
55                  allReferences.Add(reference);
56              }
57              _runtimeMock.Setup(x => x.InvokeAsync<IEnumerable<BoundingClientRect>>(
58                  "mudResizeObserver.connect",
59                  It.Is<object[]>(z =>
60                      (Guid)z[0] != default &&
61                      (z[1] is DotNetObjectReference<ResizeObserver>) == true &&
62                      (z[2] is IEnumerable<ElementReference>) == true &&
63                      (z[3] is IEnumerable<Guid>) == true &&
64                      (z[4] is ResizeObserverOptions) == true && ((ResizeObserverOptions)z[4]).EnableLogging == false && ((ResizeObserverOptions)z[4]).ReportRate == 200
65                  )
66              )).ReturnsAsync(resolvedElements.Values).Verifiable();
67              var actual = await _service.Observe(allReferences);
68              actual.Should().BeEquivalentTo(resolvedElements.Values);
69              foreach (var item in resolvedElements.Keys)
70              {
71                  _service.IsElementObserved(item).Should().BeTrue();
72                  var size = _service.GetSizeInfo(item);
73                  size.Should().BeEquivalentTo(resolvedElements[item]);
74                  size.Width.Should().Be(_service.GetWidth(item));
75                  size.Height.Should().Be(_service.GetHeight(item));
76              }
77              foreach (var item in notObservedReferences)
78              {
79                  _service.IsElementObserved(item).Should().BeFalse();
80                  var size = _service.GetSizeInfo(item);
81                  size.Should().BeNull();
82                  _service.GetWidth(item).Should().Be(0.0);
83                  _service.GetHeight(item).Should().Be(0.0);
84              }
85              _runtimeMock.Verify();
86          }
87          [Test]
88          public async Task NotValidElementsToObserve()
89          {
90              List<ElementReference> notObservedReferences = new();
91              var amount = 10;
92              for (var i = 1; i <= amount; i++)
93              {
94                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
95                  if (i % 2 == 0)
96                  {
97                      reference = new ElementReference();
98                  }
99                  else
100                  {
101                      reference = new ElementReference(Guid.NewGuid().ToString());
102                  }
103                  notObservedReferences.Add(reference);
104              }
105              var actual = await _service.Observe(notObservedReferences);
106              actual.Should().BeEmpty();
107          }
108          [Test]
109          public async Task Unobserve()
110          {
111              var random = new Random();
112              Dictionary<ElementReference, BoundingClientRect> resolvedElements = new();
113              var amount = 13;
114              for (var i = 1; i <= amount; i++)
115              {
116                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
117                  var rect = GetRandomRect(random);
118                  resolvedElements.Add(reference, rect);
119              }
120              List<Guid> ids = new();
121              var observerId = Guid.Empty;
122              _runtimeMock.Setup(x => x.InvokeAsync<IEnumerable<BoundingClientRect>>(
123                  "mudResizeObserver.connect",
124                  It.Is<object[]>(z =>
125                      (Guid)z[0] != default &&
126                      (z[1] is DotNetObjectReference<ResizeObserver>) == true &&
127                      (z[2] is IEnumerable<ElementReference>) == true &&
128                      (z[3] is IEnumerable<Guid>) == true &&
129                      (z[4] is ResizeObserverOptions) == true && ((ResizeObserverOptions)z[4]).EnableLogging == false && ((ResizeObserverOptions)z[4]).ReportRate == 200
130                  )
131              )).ReturnsAsync(resolvedElements.Values).Callback<String, object[]>((x, y) => { observerId = (Guid)y[0]; ids = new List<Guid>((IEnumerable<Guid>)y[3]); }).Verifiable();
132              foreach (var item in resolvedElements)
133              {
134                  _runtimeMock.Setup(x => x.InvokeAsync<IJSVoidResult>(
135                  "mudResizeObserver.disconnect",
136                  It.Is<object[]>(z =>
137                      (Guid)z[0] == observerId &&
138                      ids.Contains((Guid)z[1]) == true
139                  )
140              )).ReturnsAsync(Mock.Of<IJSVoidResult>).Callback<String, Object[]>((x, y) => { ids.Remove((Guid)y[1]); }).Verifiable();
141              }
142              await _service.Observe(resolvedElements.Keys);
143              foreach (var item in resolvedElements.Keys)
144              {
145                  _service.IsElementObserved(item).Should().BeTrue();
146                  await _service.Unobserve(item);
147                  _service.IsElementObserved(item).Should().BeFalse();
148              }
149              _runtimeMock.Verify();
150          }
151          [Test]
152          public async Task OnSizeChanged()
153          {
154              var random = new Random();
155              Dictionary<ElementReference, BoundingClientRect> resolvedElements = new();
156              var amount = 13;
157              for (var i = 1; i <= amount; i++)
158              {
159                  var reference = new ElementReference(Guid.NewGuid().ToString(), new PseudoElementReferenceContext());
160                  var rect = GetRandomRect(random);
161                  resolvedElements.Add(reference, rect);
162              }
163              List<Guid> ids = new();
164              _runtimeMock.Setup(x => x.InvokeAsync<IEnumerable<BoundingClientRect>>(
165                  "mudResizeObserver.connect",
166                  It.Is<object[]>(z =>
167                      (Guid)z[0] != default &&
168                      (z[1] is DotNetObjectReference<ResizeObserver>) == true &&
169                      (z[2] is IEnumerable<ElementReference>) == true &&
170                      (z[3] is IEnumerable<Guid>) == true &&
171                      (z[4] is ResizeObserverOptions) == true && ((ResizeObserverOptions)z[4]).EnableLogging == false && ((ResizeObserverOptions)z[4]).ReportRate == 200
172                  )
173              )).ReturnsAsync(resolvedElements.Values).Callback<String, object[]>((x, y) => { ids = new List<Guid>((IEnumerable<Guid>)y[3]); }).Verifiable();
174              await _service.Observe(resolvedElements.Keys);
175              var changes = new List<ResizeObserver.SizeChangeUpdateInfo>();
176              Dictionary<ElementReference, BoundingClientRect> expectedRects = new();
177              for (var i = 0; i < resolvedElements.Count(); i++)
178              {
179                  var item = resolvedElements.ElementAt(i);
180                  var correspondingId = ids[i];
181                  if (random.NextDouble() > 0.5)
182                  {
183                      changes.Add(new ResizeObserver.SizeChangeUpdateInfo(Guid.NewGuid(), GetRandomRect(random)));
184                  }
185                  else
186                  {
187                      var rect = GetRandomRect(random);
188                      expectedRects.Add(item.Key, rect);
189                      changes.Add(new ResizeObserver.SizeChangeUpdateInfo(correspondingId, rect));
190                  }
191              }
192              foreach (var item in expectedRects)
193              {
194                  resolvedElements[item.Key] = item.Value;
195              }
196              var sizeChangesChecked = false;
197              _service.OnResized += (sizeChanges) =>
198              {
199                  sizeChanges.Should().NotBeEmpty().And.BeEquivalentTo(expectedRects);
200                  sizeChangesChecked = true;
201              };
202              _service.OnSizeChanged(changes);
203              sizeChangesChecked.Should().BeTrue();
204              foreach (var item in resolvedElements)
205              {
206                  var sizeInfo = _service.GetSizeInfo(item.Key);
207                  sizeInfo.Should().BeEquivalentTo(item.Value);
208              }
209              _runtimeMock.Verify();
210          }
211          #region Helper
212          private static BoundingClientRect GetRandomRect(Random random)
213          {
214              return new BoundingClientRect
215              {
216                  Height = random.Next(10, 200) + random.NextDouble(),
217                  Left = random.Next(10, 200) + random.NextDouble(),
218                  Top = random.Next(10, 200) + random.NextDouble(),
219                  Width = random.Next(10, 200) + random.NextDouble(),
220              };
221          }
222          #endregion
223      }
224  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobExtension.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Globalization;
5  using System.IO;
6  using System.Linq;
7  using System.Runtime.Serialization;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using GitHub.DistributedTask.ObjectTemplating.Tokens;
11  using GitHub.DistributedTask.Pipelines;
12  using GitHub.DistributedTask.Pipelines.ContextData;
13  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
14  using GitHub.DistributedTask.WebApi;
15  using GitHub.Runner.Common;
16  using GitHub.Runner.Common.Util;
17  using GitHub.Runner.Sdk;
18  using Pipelines = GitHub.DistributedTask.Pipelines;
19  namespace GitHub.Runner.Worker
20  {
21      [DataContract]
22      public class SetupInfo
23      {
24          [DataMember]
25          public string Group { get; set; }
26          [DataMember]
27          public string Detail { get; set; }
28      }
29      [ServiceLocator(Default = typeof(JobExtension))]
30      public interface IJobExtension : IRunnerService
31      {
32          Task<List<IStep>> InitializeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message);
33          void FinalizeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, DateTime jobStartTimeUtc);
34      }
35      public sealed class JobExtension : RunnerService, IJobExtension
36      {
37          private readonly HashSet<string> _existingProcesses = new(StringComparer.OrdinalIgnoreCase);
38          private bool _processCleanup;
39          private string _processLookupId = $"github_{Guid.NewGuid()}";
40          private CancellationTokenSource _diskSpaceCheckToken = new();
41          private Task _diskSpaceCheckTask = null;
42          public async Task<List<IStep>> InitializeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message)
43          {
44              Trace.Entering();
45              ArgUtil.NotNull(jobContext, nameof(jobContext));
46              ArgUtil.NotNull(message, nameof(message));
47              IExecutionContext context = jobContext.CreateChild(Guid.NewGuid(), "Set up job", $"{nameof(JobExtension)}_Init", null, null, ActionRunStage.Pre);
48              context.StepTelemetry.Type = "runner";
49              context.StepTelemetry.Action = "setup_job";
<span onclick='openModal()' class='match'>50              List<IStep> preJobSteps = new();
51              List<IStep> jobSteps = new();
52              using (var register = jobContext.CancellationToken.Register(() => { context.CancelToken(); }))
</span>53              {
54                  try
55                  {
56                      context.Start();
57                      context.Debug($"Starting: Set up job");
58                      context.Output($"Current runner version: '{BuildConstants.RunnerPackage.Version}'");
59                      var setting = HostContext.GetService<IConfigurationStore>().GetSettings();
60                      var credFile = HostContext.GetConfigFile(WellKnownConfigFile.Credentials);
61                      if (File.Exists(credFile))
62                      {
63                          var credData = IOUtil.LoadObject<CredentialData>(credFile);
64                          if (credData != null &&
65                              credData.Data.TryGetValue("clientId", out var clientId))
66                          {
67                              context.Output($"Runner name: '{setting.AgentName}'");
68                              if (message.Variables.TryGetValue("system.runnerGroupName", out VariableValue runnerGroupName))
69                              {
70                                  context.Output($"Runner group name: '{runnerGroupName.Value}'");
71                              }
72                              context.Output($"Machine name: '{Environment.MachineName}'");
73                          }
74                      }
75                      var setupInfoFile = HostContext.GetConfigFile(WellKnownConfigFile.SetupInfo);
76                      if (File.Exists(setupInfoFile))
77                      {
78                          Trace.Info($"Load machine setup info from {setupInfoFile}");
79                          try
80                          {
81                              var setupInfo = IOUtil.LoadObject<List<SetupInfo>>(setupInfoFile);
82                              if (setupInfo?.Count > 0)
83                              {
84                                  foreach (var info in setupInfo)
85                                  {
86                                      if (!string.IsNullOrEmpty(info?.Detail))
87                                      {
88                                          var groupName = info.Group;
89                                          if (string.IsNullOrEmpty(groupName))
90                                          {
91                                              groupName = "Machine Setup Info";
92                                          }
93                                          context.Output($"##[group]{groupName}");
94                                          var multiLines = info.Detail.Replace("\r\n", "\n").TrimEnd('\n').Split('\n');
95                                          foreach (var line in multiLines)
96                                          {
97                                              context.Output(line);
98                                          }
99                                          context.Output("##[endgroup]");
100                                      }
101                                  }
102                              }
103                          }
104                          catch (Exception ex)
105                          {
106                              context.Output($"Fail to load and print machine setup info: {ex.Message}");
107                              Trace.Error(ex);
108                          }
109                      }
110                      try
111                      {
112                          var tokenPermissions = jobContext.Global.Variables.Get("system.github.token.permissions") ?? "";
113                          if (!string.IsNullOrEmpty(tokenPermissions))
114                          {
115                              context.Output($"##[group]GITHUB_TOKEN Permissions");
116                              var permissions = StringUtil.ConvertFromJson<Dictionary<string, string>>(tokenPermissions);
117                              foreach (KeyValuePair<string, string> entry in permissions)
118                              {
119                                  context.Output($"{entry.Key}: {entry.Value}");
120                              }
121                              context.Output("##[endgroup]");
122                          }
123                      }
124                      catch (Exception ex)
125                      {
126                          context.Output($"Fail to parse and display GITHUB_TOKEN permissions list: {ex.Message}");
127                          Trace.Error(ex);
128                      }
129                      var secretSource = context.GetGitHubContext("secret_source");
130                      if (!string.IsNullOrEmpty(secretSource))
131                      {
132                          context.Output($"Secret source: {secretSource}");
133                      }
134                      var repoFullName = context.GetGitHubContext("repository");
135                      ArgUtil.NotNull(repoFullName, nameof(repoFullName));
136                      context.Debug($"Primary repository: {repoFullName}");
137                      if (!string.IsNullOrEmpty(HostContext.WebProxy.HttpProxyAddress))
138                      {
139                          context.Output($"Runner is running behind proxy server '{HostContext.WebProxy.HttpProxyAddress}' for all HTTP requests.");
140                      }
141                      if (!string.IsNullOrEmpty(HostContext.WebProxy.HttpsProxyAddress))
142                      {
143                          context.Output($"Runner is running behind proxy server '{HostContext.WebProxy.HttpsProxyAddress}' for all HTTPS requests.");
144                      }
145                      context.Output("Prepare workflow directory");
146                      var directoryManager = HostContext.GetService<IPipelineDirectoryManager>();
147                      TrackingConfig trackingConfig = directoryManager.PrepareDirectory(
148                          context,
149                          message.Workspace);
150                      context.Debug("Update context data");
151                      string _workDirectory = HostContext.GetDirectory(WellKnownDirectory.Work);
152                      context.SetRunnerContext("workspace", Path.Combine(_workDirectory, trackingConfig.PipelineDirectory));
153                      context.SetGitHubContext("workspace", Path.Combine(_workDirectory, trackingConfig.WorkspaceDirectory));
154                      var configurationStore = HostContext.GetService<IConfigurationStore>();
155                      var runnerSettings = configurationStore.GetSettings();
156                      if (string.IsNullOrEmpty(context.GetGitHubContext("server_url")) && !runnerSettings.IsHostedServer && !string.IsNullOrEmpty(runnerSettings.GitHubUrl))
157                      {
158                          var url = new Uri(runnerSettings.GitHubUrl);
159                          var portInfo = url.IsDefaultPort ? string.Empty : $":{url.Port.ToString(CultureInfo.InvariantCulture)}";
160                          context.SetGitHubContext("server_url", $"{url.Scheme}:&bsol;&bsol;{url.Host}{portInfo}");
161                          context.SetGitHubContext("api_url", $"{url.Scheme}:&bsol;&bsol;{url.Host}{portInfo}/api/v3");
162                          context.SetGitHubContext("graphql_url", $"{url.Scheme}:&bsol;&bsol;{url.Host}{portInfo}/api/graphql");
163                      }
164                      context.Debug("Evaluating job-level environment variables");
165                      var templateEvaluator = context.ToPipelineTemplateEvaluator();
166                      foreach (var token in message.EnvironmentVariables)
167                      {
168                          var environmentVariables = templateEvaluator.EvaluateStepEnvironment(token, jobContext.ExpressionValues, jobContext.ExpressionFunctions, VarUtil.EnvironmentVariableKeyComparer);
169                          foreach (var pair in environmentVariables)
170                          {
171                              context.Global.EnvironmentVariables[pair.Key] = pair.Value ?? string.Empty;
172                              context.SetEnvContext(pair.Key, pair.Value ?? string.Empty);
173                          }
174                      }
175                      context.Debug("Evaluating job container");
176                      var container = templateEvaluator.EvaluateJobContainer(message.JobContainer, jobContext.ExpressionValues, jobContext.ExpressionFunctions);
177                      ValidateJobContainer(container);
178                      if (container != null)
179                      {
180                          jobContext.Global.Container = new Container.ContainerInfo(HostContext, container);
181                      }
182                      context.Debug("Evaluating job service containers");
183                      var serviceContainers = templateEvaluator.EvaluateJobServiceContainers(message.JobServiceContainers, jobContext.ExpressionValues, jobContext.ExpressionFunctions);
184                      if (serviceContainers?.Count > 0)
185                      {
186                          foreach (var pair in serviceContainers)
187                          {
188                              var networkAlias = pair.Key;
189                              var serviceContainer = pair.Value;
190                              if (serviceContainer == null)
191                              {
192                                  context.Output($"The service '{networkAlias}' will not be started because the container definition has an empty image.");
193                                  continue;
194                              }
195                              jobContext.Global.ServiceContainers.Add(new Container.ContainerInfo(HostContext, serviceContainer, false, networkAlias));
196                          }
197                      }
198                      context.Debug("Evaluating job defaults");
199                      foreach (var token in message.Defaults)
200                      {
201                          var defaults = token.AssertMapping("defaults");
202                          if (defaults.Any(x => string.Equals(x.Key.AssertString("defaults key").Value, "run", StringComparison.OrdinalIgnoreCase)))
203                          {
204                              context.Global.JobDefaults["run"] = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
205                              var defaultsRun = defaults.First(x => string.Equals(x.Key.AssertString("defaults key").Value, "run", StringComparison.OrdinalIgnoreCase));
206                              var jobDefaults = templateEvaluator.EvaluateJobDefaultsRun(defaultsRun.Value, jobContext.ExpressionValues, jobContext.ExpressionFunctions);
207                              foreach (var pair in jobDefaults)
208                              {
209                                  if (!string.IsNullOrEmpty(pair.Value))
210                                  {
211                                      context.Global.JobDefaults["run"][pair.Key] = pair.Value;
212                                  }
213                              }
214                          }
215                      }
216                      Trace.Info("Downloading actions");
217                      var actionManager = HostContext.GetService<IActionManager>();
218                      var prepareResult = await actionManager.PrepareActionsAsync(context, message.Steps);
219                      var startedHookPath = Environment.GetEnvironmentVariable("ACTIONS_RUNNER_HOOK_JOB_STARTED");
220                      if (!string.IsNullOrEmpty(startedHookPath))
221                      {
222                          var hookProvider = HostContext.GetService<IJobHookProvider>();
223                          var jobHookData = new JobHookData(ActionRunStage.Pre, startedHookPath);
224                          preJobSteps.Add(new JobExtensionRunner(runAsync: hookProvider.RunHook,
225                                                                            condition: $"{PipelineTemplateConstants.Always}()",
226                                                                            displayName: Constants.Hooks.JobStartedStepName,
227                                                                            data: (object)jobHookData));
228                      }
229                      preJobSteps.AddRange(prepareResult.ContainerSetupSteps);
230                      if (jobContext.Global.Container != null || jobContext.Global.ServiceContainers.Count > 0)
231                      {
232                          var containerProvider = HostContext.GetService<IContainerOperationProvider>();
233                          var containers = new List<Container.ContainerInfo>();
234                          if (jobContext.Global.Container != null)
235                          {
236                              containers.Add(jobContext.Global.Container);
237                          }
238                          containers.AddRange(jobContext.Global.ServiceContainers);
239                          preJobSteps.Add(new JobExtensionRunner(runAsync: containerProvider.StartContainersAsync,
240                                                                            condition: $"{PipelineTemplateConstants.Success}()",
241                                                                            displayName: "Initialize containers",
242                                                                            data: (object)containers));
243                      }
244                      foreach (var step in message.Steps)
245                      {
246                          if (step.Type == Pipelines.StepType.Action)
247                          {
248                              var action = step as Pipelines.ActionStep;
249                              Trace.Info($"Adding {action.DisplayName}.");
250                              var actionRunner = HostContext.CreateService<IActionRunner>();
251                              actionRunner.Action = action;
252                              actionRunner.Stage = ActionRunStage.Main;
253                              actionRunner.Condition = step.Condition;
254                              var contextData = new Pipelines.ContextData.DictionaryContextData();
255                              if (message.ContextData?.Count > 0)
256                              {
257                                  foreach (var pair in message.ContextData)
258                                  {
259                                      contextData[pair.Key] = pair.Value;
260                                  }
261                              }
262                              actionRunner.EvaluateDisplayName(contextData, context, out _);
263                              jobSteps.Add(actionRunner);
264                              if (prepareResult.PreStepTracker.TryGetValue(step.Id, out var preStep))
265                              {
266                                  Trace.Info($"Adding pre-{action.DisplayName}.");
267                                  preStep.EvaluateDisplayName(contextData, context, out _);
268                                  preStep.DisplayName = $"Pre {preStep.DisplayName}";
269                                  preJobSteps.Add(preStep);
270                              }
271                          }
272                      }
273                      if (message.Variables.TryGetValue("system.workflowFileFullPath", out VariableValue workflowFileFullPath))
274                      {
275                          var usesLogText = $"Uses: {workflowFileFullPath.Value}";
276                          var reference = GetWorkflowReference(message.Variables);
277                          context.Output(usesLogText + reference);
278                          if (message.ContextData.TryGetValue("inputs", out var pipelineContextData))
279                          {
280                              var inputs = pipelineContextData.AssertDictionary("inputs");
281                              if (inputs.Any())
282                              {
283                                  context.Output($"##[group] Inputs");
284                                  foreach (var input in inputs)
285                                  {
286                                      context.Output($"  {input.Key}: {input.Value}");
287                                  }
288                                  context.Output("##[endgroup]");
289                              }
290                          }
291                      }
292                      if (!string.IsNullOrWhiteSpace(message.JobDisplayName))
293                      {
294                          context.Output($"Complete job name: {message.JobDisplayName}");
295                      }
296                      var intraActionStates = new Dictionary<Guid, Dictionary<string, string>>();
297                      foreach (var preStep in prepareResult.PreStepTracker)
298                      {
299                          intraActionStates[preStep.Key] = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
300                      }
301                      foreach (var step in preJobSteps)
302                      {
303                          if (step is JobExtensionRunner)
304                          {
305                              JobExtensionRunner extensionStep = step as JobExtensionRunner;
306                              ArgUtil.NotNull(extensionStep, extensionStep.DisplayName);
307                              Guid stepId = Guid.NewGuid();
308                              extensionStep.ExecutionContext = jobContext.CreateChild(stepId, extensionStep.DisplayName, stepId.ToString("N"), null, stepId.ToString("N"), ActionRunStage.Pre);
309                              extensionStep.ExecutionContext.StepTelemetry.Type = "runner";
310                              extensionStep.ExecutionContext.StepTelemetry.Action = extensionStep.DisplayName.ToLowerInvariant().Replace(' ', '_');
311                          }
312                          else if (step is IActionRunner actionStep)
313                          {
314                              ArgUtil.NotNull(actionStep, step.DisplayName);
315                              Guid stepId = Guid.NewGuid();
316                              actionStep.ExecutionContext = jobContext.CreateChild(stepId, actionStep.DisplayName, stepId.ToString("N"), null, null, ActionRunStage.Pre, intraActionStates[actionStep.Action.Id]);
317                          }
318                      }
319                      foreach (var step in jobSteps)
320                      {
321                          if (step is IActionRunner actionStep)
322                          {
323                              ArgUtil.NotNull(actionStep, step.DisplayName);
324                              intraActionStates.TryGetValue(actionStep.Action.Id, out var intraActionState);
325                              actionStep.ExecutionContext = jobContext.CreateChild(actionStep.Action.Id, actionStep.DisplayName, actionStep.Action.Name, null, actionStep.Action.ContextName, ActionRunStage.Main, intraActionState);
326                          }
327                      }
328                      var completedHookPath = Environment.GetEnvironmentVariable("ACTIONS_RUNNER_HOOK_JOB_COMPLETED");
329                      if (!string.IsNullOrEmpty(completedHookPath))
330                      {
331                          var hookProvider = HostContext.GetService<IJobHookProvider>();
332                          var jobHookData = new JobHookData(ActionRunStage.Post, completedHookPath);
333                          jobContext.RegisterPostJobStep(new JobExtensionRunner(runAsync: hookProvider.RunHook,
334                                                                            condition: $"{PipelineTemplateConstants.Always}()",
335                                                                            displayName: Constants.Hooks.JobCompletedStepName,
336                                                                            data: (object)jobHookData));
337                      }
338                      List<IStep> steps = new();
339                      steps.AddRange(preJobSteps);
340                      steps.AddRange(jobSteps);
341                      _processCleanup = jobContext.Global.Variables.GetBoolean("process.clean") ?? true;
342                      if (_processCleanup)
343                      {
344                          Environment.SetEnvironmentVariable(Constants.ProcessTrackingId, _processLookupId);
345                          context.Debug("Collect running processes for tracking orphan processes.");
346                          Dictionary<int, Process> processes = SnapshotProcesses();
347                          foreach (var proc in processes)
348                          {
349                              _existingProcesses.Add($"{proc.Key}_{proc.Value.ProcessName}");
350                          }
351                      }
352                      jobContext.Global.EnvironmentVariables.TryGetValue(Constants.Runner.Features.DiskSpaceWarning, out var enableWarning);
353                      if (StringUtil.ConvertToBoolean(enableWarning, defaultValue: true))
354                      {
355                          _diskSpaceCheckTask = CheckDiskSpaceAsync(context, _diskSpaceCheckToken.Token);
356                      }
357                      return steps;
358                  }
359                  catch (OperationCanceledException ex) when (jobContext.CancellationToken.IsCancellationRequested)
360                  {
361                      Trace.Error($"Caught cancellation exception from JobExtension Initialization: {ex}");
362                      context.Error(ex);
363                      context.Result = TaskResult.Canceled;
364                      throw;
365                  }
366                  catch (Exception ex)
367                  {
368                      Trace.Error($"Caught exception from JobExtension Initialization: {ex}");
369                      context.Error(ex);
370                      context.Result = TaskResult.Failed;
371                      throw;
372                  }
373                  finally
374                  {
375                      context.Debug("Finishing: Set up job");
376                      context.Complete();
377                  }
378              }
379          }
380          private string GetWorkflowReference(IDictionary<string, VariableValue> variables)
381          {
382              var reference = "";
383              if (variables.TryGetValue("system.workflowFileSha", out VariableValue workflowFileSha))
384              {
385                  if (variables.TryGetValue("system.workflowFileRef", out VariableValue workflowFileRef)
386                      && !string.IsNullOrEmpty(workflowFileRef.Value))
387                  {
388                      reference += $"@{workflowFileRef.Value} ({workflowFileSha.Value})";
389                  }
390                  else
391                  {
392                      reference += $"@{workflowFileSha.Value}";
393                  }
394              }
395              return reference;
396          }
397          public void FinalizeJob(IExecutionContext jobContext, Pipelines.AgentJobRequestMessage message, DateTime jobStartTimeUtc)
398          {
399              Trace.Entering();
400              ArgUtil.NotNull(jobContext, nameof(jobContext));
401              IExecutionContext context = jobContext.CreateChild(Guid.NewGuid(), "Complete job", $"{nameof(JobExtension)}_Final", null, null, ActionRunStage.Post);
402              context.StepTelemetry.Type = "runner";
403              context.StepTelemetry.Action = "complete_job";
404              using (var register = jobContext.CancellationToken.Register(() => { context.CancelToken(); }))
405              {
406                  try
407                  {
408                      context.Start();
409                      context.Debug("Starting: Complete job");
410                      Trace.Info("Initialize Env context");
411  #if OS_WINDOWS
412                      var envContext = new DictionaryContextData();
413  #else
414                      var envContext = new CaseSensitiveDictionaryContextData();
415  #endif
416                      context.ExpressionValues["env"] = envContext;
417                      foreach (var pair in context.Global.EnvironmentVariables)
418                      {
419                          envContext[pair.Key] = new StringContextData(pair.Value ?? string.Empty);
420                      }
421                      Trace.Info("Initialize steps context");
422                      context.ExpressionValues["steps"] = context.Global.StepsContext.GetScope(context.ScopeName);
423                      var templateEvaluator = context.ToPipelineTemplateEvaluator();
424                      if (message.JobOutputs != null && message.JobOutputs.Type != TokenType.Null)
425                      {
426                          try
427                          {
428                              context.Output($"Evaluate and set job outputs");
429                              Trace.Info("Initialize Env context for evaluating job outputs");
430                              var outputs = templateEvaluator.EvaluateJobOutput(message.JobOutputs, context.ExpressionValues, context.ExpressionFunctions);
431                              foreach (var output in outputs)
432                              {
433                                  if (string.IsNullOrEmpty(output.Value))
434                                  {
435                                      context.Debug($"Skip output '{output.Key}' since it's empty");
436                                      continue;
437                                  }
438                                  if (!string.Equals(output.Value, HostContext.SecretMasker.MaskSecrets(output.Value)))
439                                  {
440                                      context.Warning($"Skip output '{output.Key}' since it may contain secret.");
441                                      continue;
442                                  }
443                                  context.Output($"Set output '{output.Key}'");
444                                  jobContext.JobOutputs[output.Key] = output.Value;
445                              }
446                          }
447                          catch (Exception ex)
448                          {
449                              context.Result = TaskResult.Failed;
450                              context.Error($"Fail to evaluate job outputs");
451                              context.Error(ex);
452                              jobContext.Result = TaskResultUtil.MergeTaskResults(jobContext.Result, TaskResult.Failed);
453                          }
454                      }
455                      if (jobContext.ActionsEnvironment?.Url != null && jobContext.ActionsEnvironment?.Url.Type != TokenType.Null)
456                      {
457                          try
458                          {
459                              context.Output($"Evaluate and set environment url");
460                              var environmentUrlToken = templateEvaluator.EvaluateEnvironmentUrl(jobContext.ActionsEnvironment.Url, context.ExpressionValues, context.ExpressionFunctions);
461                              var environmentUrl = environmentUrlToken.AssertString("environment.url");
462                              if (!string.Equals(environmentUrl.Value, HostContext.SecretMasker.MaskSecrets(environmentUrl.Value)))
463                              {
464                                  context.Warning($"Skip setting environment url as environment '{jobContext.ActionsEnvironment.Name}' may contain secret.");
465                              }
466                              else
467                              {
468                                  context.Output($"Evaluated environment url: {environmentUrl}");
469                                  jobContext.ActionsEnvironment.Url = environmentUrlToken;
470                              }
471                          }
472                          catch (Exception ex)
473                          {
474                              context.Result = TaskResult.Failed;
475                              context.Error($"Failed to evaluate environment url");
476                              context.Error(ex);
477                              jobContext.Result = TaskResultUtil.MergeTaskResults(jobContext.Result, TaskResult.Failed);
478                          }
479                      }
480                      if (context.Global.Variables.GetBoolean(Constants.Variables.Actions.RunnerDebug) ?? false)
481                      {
482                          Trace.Info("Support log upload starting.");
483                          context.Output("Uploading runner diagnostic logs");
484                          IDiagnosticLogManager diagnosticLogManager = HostContext.GetService<IDiagnosticLogManager>();
485                          try
486                          {
487                              diagnosticLogManager.UploadDiagnosticLogs(executionContext: context, parentContext: jobContext, message: message, jobStartTimeUtc: jobStartTimeUtc);
488                              Trace.Info("Support log upload complete.");
489                              context.Output("Completed runner diagnostic log upload");
490                          }
491                          catch (Exception ex)
492                          {
493                              Trace.Info("Error uploading support logs.");
494                              context.Output("Error uploading runner diagnostic logs");
495                              Trace.Error(ex);
496                          }
497                      }
498                      if (_processCleanup)
499                      {
500                          context.Output("Cleaning up orphan processes");
501                          Dictionary<int, Process> currentProcesses = SnapshotProcesses();
502                          foreach (var proc in currentProcesses)
503                          {
504                              if (proc.Key == Process.GetCurrentProcess().Id)
505                              {
506                                  continue;
507                              }
508                              if (_existingProcesses.Contains($"{proc.Key}_{proc.Value.ProcessName}"))
509                              {
510                                  Trace.Verbose($"Skip existing process. PID: {proc.Key} ({proc.Value.ProcessName})");
511                              }
512                              else
513                              {
514                                  Trace.Info($"Inspecting process environment variables. PID: {proc.Key} ({proc.Value.ProcessName})");
515                                  string lookupId = null;
516                                  try
517                                  {
518                                      lookupId = proc.Value.GetEnvironmentVariable(HostContext, Constants.ProcessTrackingId);
519                                  }
520                                  catch (Exception ex)
521                                  {
522                                      Trace.Warning($"Ignore exception during read process environment variables: {ex.Message}");
523                                      Trace.Verbose(ex.ToString());
524                                  }
525                                  if (string.Equals(lookupId, _processLookupId, StringComparison.OrdinalIgnoreCase))
526                                  {
527                                      context.Output($"Terminate orphan process: pid ({proc.Key}) ({proc.Value.ProcessName})");
528                                      try
529                                      {
530                                          proc.Value.Kill();
531                                      }
532                                      catch (Exception ex)
533                                      {
534                                          Trace.Error("Catch exception during orphan process cleanup.");
535                                          Trace.Error(ex);
536                                      }
537                                  }
538                              }
539                          }
540                      }
541                      if (_diskSpaceCheckTask != null)
542                      {
543                          _diskSpaceCheckToken.Cancel();
544                      }
545                  }
546                  catch (Exception ex)
547                  {
548                      Trace.Error($"Caught exception from JobExtension finalization: {ex}");
549                      context.Output(ex.Message);
550                  }
551                  finally
552                  {
553                      context.Debug("Finishing: Complete job");
554                      context.Complete();
555                  }
556              }
557          }
558          private async Task CheckDiskSpaceAsync(IExecutionContext context, CancellationToken token)
559          {
560              while (!token.IsCancellationRequested)
561              {
562                  var lowDiskSpaceThreshold = context.Global.Variables.GetInt(WellKnownDistributedTaskVariables.RunnerLowDiskspaceThreshold);
563                  if (lowDiskSpaceThreshold == null)
564                  {
565                      Trace.Info($"Low diskspace warning is not enabled.");
566                      return;
567                  }
568                  var workDirRoot = Directory.GetDirectoryRoot(HostContext.GetDirectory(WellKnownDirectory.Work));
569                  var driveInfo = new DriveInfo(workDirRoot);
570                  var freeSpaceInMB = driveInfo.AvailableFreeSpace / 1024 / 1024;
571                  if (freeSpaceInMB < lowDiskSpaceThreshold)
572                  {
573                      var issue = new Issue() { Type = IssueType.Warning, Message = $"You are running out of disk space. The runner will stop working when the machine runs out of disk space. Free space left: {freeSpaceInMB} MB" };
574                      issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = Constants.Runner.LowDiskSpace;
575                      context.AddIssue(issue, ExecutionContextLogOptions.Default);
576                      return;
577                  }
578                  try
579                  {
580                      await Task.Delay(10 * 1000, token);
581                  }
582                  catch (TaskCanceledException)
583                  {
584                  }
585              }
586          }
587          private Dictionary<int, Process> SnapshotProcesses()
588          {
589              Dictionary<int, Process> snapshot = new();
590              foreach (var proc in Process.GetProcesses())
591              {
592                  try
593                  {
594                      if (!string.IsNullOrEmpty(proc.ProcessName))
595                      {
596                          snapshot[proc.Id] = proc;
597                      }
598                  }
599                  catch (Exception ex)
600                  {
601                      Trace.Verbose($"Ignore any exception during taking process snapshot of process pid={proc.Id}: '{ex.Message}'.");
602                  }
603              }
604              Trace.Info($"Total accessible running process: {snapshot.Count}.");
605              return snapshot;
606          }
607          private static void ValidateJobContainer(JobContainer container)
608          {
609              if (StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(Constants.Variables.Actions.RequireJobContainer)) && container == null)
610              {
611                  throw new ArgumentException("Jobs without a job container are forbidden on this runner, please add a 'container:' to your job or contact your self-hosted runner administrator.");
612              }
613          }
614      }
615  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-ResizeObserverTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-JobExtension.cs</div>
                </div>
                <div class="column column_space"><pre><code>33              List<ElementReference> allReferences = new();
34              List<ElementReference> notObservedReferences = new();
35              Dictionary<ElementReference, BoundingClientRect> resolvedElements = new();
</pre></code></div>
                <div class="column column_space"><pre><code>50              List<IStep> preJobSteps = new();
51              List<IStep> jobSteps = new();
52              using (var register = jobContext.CancellationToken.Register(() => { context.CancelToken(); }))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    