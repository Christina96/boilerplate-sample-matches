
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using System.Threading;
9  using Npgsql.Internal.TypeHandling;
10  using Npgsql.Internal.TypeMapping;
11  using Npgsql.NameTranslation;
12  using NpgsqlTypes;
13  using static Npgsql.Util.Statics;
14  namespace Npgsql.TypeMapping;
15  sealed class GlobalTypeMapper : INpgsqlTypeMapper
16  {
17      public static GlobalTypeMapper Instance { get; }
18      public INpgsqlNameTranslator DefaultNameTranslator { get; set; } = new NpgsqlSnakeCaseNameTranslator();
19      internal List<TypeHandlerResolverFactory> HandlerResolverFactories { get; } = new();
20      List<TypeMappingResolver> MappingResolvers { get; } = new();
21      public ConcurrentDictionary<string, IUserTypeMapping> UserTypeMappings { get; } = new();
22      readonly ConcurrentDictionary<Type, TypeMappingInfo> _mappingsByClrType = new();
23      internal ReaderWriterLockSlim Lock { get; }
24          = new(LockRecursionPolicy.SupportsRecursion);
25      static GlobalTypeMapper()
26          => Instance = new GlobalTypeMapper();
27      GlobalTypeMapper()
28          => Reset();
29      #region Mapping management
30      public INpgsqlTypeMapper MapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
31          where TEnum : struct, Enum
32      {
33          if (pgName != null && pgName.Trim() == "")
34              throw new ArgumentException("pgName can't be empty", nameof(pgName));
35          nameTranslator ??= DefaultNameTranslator;
36          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
37          Lock.EnterWriteLock();
<span onclick='openModal()' class='match'>38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping<TEnum>(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
</span>50          where TEnum : struct, Enum
51      {
52          if (pgName != null && pgName.Trim() == "")
53              throw new ArgumentException("pgName can't be empty", nameof(pgName));
54          nameTranslator ??= DefaultNameTranslator;
55          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
56          Lock.EnterWriteLock();
57          try
58          {
59              if (UserTypeMappings.TryRemove(pgName, out _))
60              {
61                  RecordChange();
62                  return true;
63              }
64              return false;
65          }
66          finally
67          {
68              Lock.ExitWriteLock();
69          }
70      }
71      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
72      public INpgsqlTypeMapper MapComposite<T>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
73      {
74          if (pgName != null && pgName.Trim() == "")
75              throw new ArgumentException("pgName can't be empty", nameof(pgName));
76          nameTranslator ??= DefaultNameTranslator;
77          pgName ??= GetPgName(typeof(T), nameTranslator);
78          Lock.EnterWriteLock();
79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping<T>(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
91      public INpgsqlTypeMapper MapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
92      {
93          var openMethod = typeof(GlobalTypeMapper).GetMethod(nameof(MapComposite), new[] { typeof(string), typeof(INpgsqlNameTranslator) })!;
94          var method = openMethod.MakeGenericMethod(clrType);
95          method.Invoke(this, new object?[] { pgName, nameTranslator });
96          return this;
97      }
98      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
99      public bool UnmapComposite<T>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
100          => UnmapComposite(typeof(T), pgName, nameTranslator);
101      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
102      public bool UnmapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
103      {
104          if (pgName != null && pgName.Trim() == "")
105              throw new ArgumentException("pgName can't be empty", nameof(pgName));
106          nameTranslator ??= DefaultNameTranslator;
107          pgName ??= GetPgName(clrType, nameTranslator);
108          Lock.EnterWriteLock();
109          try
110          {
111              if (UserTypeMappings.TryRemove(pgName, out _))
112              {
113                  RecordChange();
114                  return true;
115              }
116              return false;
117          }
118          finally
119          {
120              Lock.ExitWriteLock();
121          }
122      }
123      public void AddTypeResolverFactory(TypeHandlerResolverFactory resolverFactory)
124      {
125          Lock.EnterWriteLock();
126          try
127          {
128              var type = resolverFactory.GetType();
129              if (HandlerResolverFactories[0].GetType() == type)
130                  HandlerResolverFactories[0] = resolverFactory;
131              else
132              {
133                  for (var i = 0; i < HandlerResolverFactories.Count; i++)
134                      if (HandlerResolverFactories[i].GetType() == type)
135                          HandlerResolverFactories.RemoveAt(i);
136                  HandlerResolverFactories.Insert(0, resolverFactory);
137              }
138              var mappingResolver = resolverFactory.CreateMappingResolver();
139              if (mappingResolver is not null)
140                  AddMappingResolver(mappingResolver, overwrite: true);
141              RecordChange();
142          }
143          finally
144          {
145              Lock.ExitWriteLock();
146          }
147      }
148      internal void TryAddMappingResolver(TypeMappingResolver resolver)
149      {
150          Lock.EnterWriteLock();
151          try
152          {
153              if (AddMappingResolver(resolver, overwrite: false))
154                  RecordChange();
155          }
156          finally
157          {
158              Lock.ExitWriteLock();
159          }
160      }
161      bool AddMappingResolver(TypeMappingResolver resolver, bool overwrite)
162      {
163          var type = resolver.GetType();
164          if (MappingResolvers[0].GetType() == type)
165          {
166              if (!overwrite)
167                  return false;
168              MappingResolvers[0] = resolver;
169          }
170          else
171          {
172              for (var i = 0; i < MappingResolvers.Count; i++)
173              {
174                  if (MappingResolvers[i].GetType() == type)
175                  {
176                      if (!overwrite)
177                          return false;
178                      MappingResolvers.RemoveAt(i);
179                      break;
180                  }
181              }
182              MappingResolvers.Insert(0, resolver);
183          }
184          return true;
185      }
186      public void Reset()
187      {
188          Lock.EnterWriteLock();
189          try
190          {
191              HandlerResolverFactories.Clear();
192              HandlerResolverFactories.Add(new BuiltInTypeHandlerResolverFactory());
193              MappingResolvers.Clear();
194              MappingResolvers.Add(new BuiltInTypeMappingResolver());
195              UserTypeMappings.Clear();
196              RecordChange();
197          }
198          finally
199          {
200              Lock.ExitWriteLock();
201          }
202      }
203      internal void RecordChange()
204          => _mappingsByClrType.Clear();
205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          => clrType.GetCustomAttribute<PgNameAttribute>()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
209      #region NpgsqlDbType/DbType inference for NpgsqlParameter
210      [RequiresUnreferencedCode("ToNpgsqlDbType uses interface-based reflection and isn't trimming-safe")]
211      internal bool TryResolveMappingByValue(object value, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
212      {
213          Lock.EnterReadLock();
214          try
215          {
216              var type = value.GetType();
217              if (_mappingsByClrType.TryGetValue(type, out typeMapping))
218                  return true;
219              foreach (var resolver in MappingResolvers)
220                  if ((typeMapping = resolver.GetMappingByValueDependentValue(value)) is not null)
221                      return true;
222              return TryResolveMappingByClrType(type, out typeMapping);
223          }
224          finally
225          {
226              Lock.ExitReadLock();
227          }
228          bool TryResolveMappingByClrType(Type clrType, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
229          {
230              if (_mappingsByClrType.TryGetValue(clrType, out typeMapping))
231                  return true;
232              foreach (var resolver in MappingResolvers)
233              {
234                  if ((typeMapping = resolver.GetMappingByClrType(clrType)) is not null)
235                  {
236                      _mappingsByClrType[clrType] = typeMapping;
237                      return true;
238                  }
239              }
240              if (clrType.IsArray)
241              {
242                  if (TryResolveMappingByClrType(clrType.GetElementType()!, out var elementMapping))
243                  {
244                      _mappingsByClrType[clrType] = typeMapping = new(
245                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
246                          elementMapping.DataTypeName + "[]");
247                      return true;
248                  }
249                  typeMapping = null;
250                  return false;
251              }
252              var typeInfo = clrType.GetTypeInfo();
253              var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =>
254                  x.GetTypeInfo().IsGenericType && x.GetGenericTypeDefinition() == typeof(IList<>));
255              if (ilist != null)
256              {
257                  if (TryResolveMappingByClrType(ilist.GetGenericArguments()[0], out var elementMapping))
258                  {
259                      _mappingsByClrType[clrType] = typeMapping = new(
260                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
261                          elementMapping.DataTypeName + "[]");
262                      return true;
263                  }
264                  typeMapping = null;
265                  return false;
266              }
267              if (typeInfo.IsGenericType && clrType.GetGenericTypeDefinition() == typeof(NpgsqlRange<>))
268              {
269                  if (TryResolveMappingByClrType(clrType.GetGenericArguments()[0], out var elementMapping))
270                  {
271                      _mappingsByClrType[clrType] = typeMapping = new(
272                          NpgsqlDbType.Range | elementMapping.NpgsqlDbType,
273                          dataTypeName: null);
274                      return true;
275                  }
276                  typeMapping = null;
277                  return false;
278              }
279              typeMapping = null;
280              return false;
281          }
282      }
283      #endregion NpgsqlDbType/DbType inference for NpgsqlParameter
284      #region Static translation tables
285      public static string? NpgsqlDbTypeToDataTypeName(NpgsqlDbType npgsqlDbType)
286          => npgsqlDbType switch
287          {
288              NpgsqlDbType.Smallint => "smallint",
289              NpgsqlDbType.Integer  => "integer",
290              NpgsqlDbType.Bigint   => "bigint",
291              NpgsqlDbType.Real     => "real",
292              NpgsqlDbType.Double   => "double precision",
293              NpgsqlDbType.Numeric  => "numeric",
294              NpgsqlDbType.Money    => "money",
295              NpgsqlDbType.Text      => "text",
296              NpgsqlDbType.Xml       => "xml",
297              NpgsqlDbType.Varchar   => "character varying",
298              NpgsqlDbType.Char      => "character",
299              NpgsqlDbType.Name      => "name",
300              NpgsqlDbType.Refcursor => "refcursor",
301              NpgsqlDbType.Citext    => "citext",
302              NpgsqlDbType.Jsonb     => "jsonb",
303              NpgsqlDbType.Json      => "json",
304              NpgsqlDbType.JsonPath  => "jsonpath",
305              NpgsqlDbType.Timestamp   => "timestamp without time zone",
306              NpgsqlDbType.TimestampTz => "timestamp with time zone",
307              NpgsqlDbType.Date        => "date",
308              NpgsqlDbType.Time        => "time without time zone",
309              NpgsqlDbType.TimeTz      => "time with time zone",
310              NpgsqlDbType.Interval    => "interval",
311              NpgsqlDbType.Cidr     => "cidr",
312              NpgsqlDbType.Inet     => "inet",
313              NpgsqlDbType.MacAddr  => "macaddr",
314              NpgsqlDbType.MacAddr8 => "macaddr8",
315              NpgsqlDbType.TsQuery   => "tsquery",
316              NpgsqlDbType.TsVector  => "tsvector",
317              NpgsqlDbType.Box     => "box",
318              NpgsqlDbType.Circle  => "circle",
319              NpgsqlDbType.Line    => "line",
320              NpgsqlDbType.LSeg    => "lseg",
321              NpgsqlDbType.Path    => "path",
322              NpgsqlDbType.Point   => "point",
323              NpgsqlDbType.Polygon => "polygon",
324              NpgsqlDbType.LQuery    => "lquery",
325              NpgsqlDbType.LTree     => "ltree",
326              NpgsqlDbType.LTxtQuery => "ltxtquery",
327              NpgsqlDbType.Oid       => "oid",
328              NpgsqlDbType.Xid       => "xid",
329              NpgsqlDbType.Xid8      => "xid8",
330              NpgsqlDbType.Cid       => "cid",
331              NpgsqlDbType.Regtype   => "regtype",
332              NpgsqlDbType.Regconfig => "regconfig",
333              NpgsqlDbType.Boolean => "boolean",
334              NpgsqlDbType.Bytea   => "bytea",
335              NpgsqlDbType.Uuid    => "uuid",
336              NpgsqlDbType.Varbit  => "bit varying",
337              NpgsqlDbType.Bit     => "bit",
338              NpgsqlDbType.Hstore  => "hstore",
339              NpgsqlDbType.Geometry  => "geometry",
340              NpgsqlDbType.Geography => "geography",
341              NpgsqlDbType.IntegerRange     => "int4range",
342              NpgsqlDbType.BigIntRange      => "int8range",
343              NpgsqlDbType.NumericRange     => "numrange",
344              NpgsqlDbType.TimestampRange   => "tsrange",
345              NpgsqlDbType.TimestampTzRange => "tstzrange",
346              NpgsqlDbType.DateRange        => "daterange",
347              NpgsqlDbType.IntegerMultirange     => "int4multirange",
348              NpgsqlDbType.BigIntMultirange      => "int8multirange",
349              NpgsqlDbType.NumericMultirange     => "nummultirange",
350              NpgsqlDbType.TimestampMultirange   => "tsmultirange",
351              NpgsqlDbType.TimestampTzMultirange => "tstzmultirange",
352              NpgsqlDbType.DateMultirange        => "datemultirange",
353              NpgsqlDbType.Int2Vector   => "int2vector",
354              NpgsqlDbType.Oidvector    => "oidvector",
355              NpgsqlDbType.PgLsn        => "pg_lsn",
356              NpgsqlDbType.Tid          => "tid",
357              NpgsqlDbType.InternalChar => "char",
358              NpgsqlDbType.Unknown => "unknown",
359              _ => npgsqlDbType.HasFlag(NpgsqlDbType.Array)
360                  ? NpgsqlDbTypeToDataTypeName(npgsqlDbType & ~NpgsqlDbType.Array) + "[]"
361                  : null 
362          };
363      public static NpgsqlDbType DataTypeNameToNpgsqlDbType(string typeName)
364      {
365          var parenIndex = typeName.IndexOf('(');
366          if (parenIndex > -1)
367              typeName = typeName.Substring(0, parenIndex);
368          return typeName switch
369          {
370              "smallint" => NpgsqlDbType.Smallint,
371              "integer" or "int" => NpgsqlDbType.Integer,
372              "bigint" => NpgsqlDbType.Bigint,
373              "real" => NpgsqlDbType.Real,
374              "double precision" => NpgsqlDbType.Double,
375              "numeric" => NpgsqlDbType.Numeric,
376              "money" => NpgsqlDbType.Money,
377              "text" => NpgsqlDbType.Text,
378              "xml" => NpgsqlDbType.Xml,
379              "character varying" or "varchar" => NpgsqlDbType.Varchar,
380              "character" => NpgsqlDbType.Char,
381              "name" => NpgsqlDbType.Name,
382              "refcursor" => NpgsqlDbType.Refcursor,
383              "citext" => NpgsqlDbType.Citext,
384              "jsonb" => NpgsqlDbType.Jsonb,
385              "json" => NpgsqlDbType.Json,
386              "jsonpath" => NpgsqlDbType.JsonPath,
387              "timestamp without time zone" or "timestamp" => NpgsqlDbType.Timestamp,
388              "timestamp with time zone" or "timestamptz" => NpgsqlDbType.TimestampTz,
389              "date" => NpgsqlDbType.Date,
390              "time without time zone" or "timetz" => NpgsqlDbType.Time,
391              "time with time zone" or "time" => NpgsqlDbType.TimeTz,
392              "interval" => NpgsqlDbType.Interval,
393              "cidr" => NpgsqlDbType.Cidr,
394              "inet" => NpgsqlDbType.Inet,
395              "macaddr" => NpgsqlDbType.MacAddr,
396              "macaddr8" => NpgsqlDbType.MacAddr8,
397              "tsquery" => NpgsqlDbType.TsQuery,
398              "tsvector" => NpgsqlDbType.TsVector,
399              "box" => NpgsqlDbType.Box,
400              "circle" => NpgsqlDbType.Circle,
401              "line" => NpgsqlDbType.Line,
402              "lseg" => NpgsqlDbType.LSeg,
403              "path" => NpgsqlDbType.Path,
404              "point" => NpgsqlDbType.Point,
405              "polygon" => NpgsqlDbType.Polygon,
406              "lquery" => NpgsqlDbType.LQuery,
407              "ltree" => NpgsqlDbType.LTree,
408              "ltxtquery" => NpgsqlDbType.LTxtQuery,
409              "oid" => NpgsqlDbType.Oid,
410              "xid" => NpgsqlDbType.Xid,
411              "xid8" => NpgsqlDbType.Xid8,
412              "cid" => NpgsqlDbType.Cid,
413              "regtype" => NpgsqlDbType.Regtype,
414              "regconfig" => NpgsqlDbType.Regconfig,
415              "boolean" or "bool" => NpgsqlDbType.Boolean,
416              "bytea" => NpgsqlDbType.Bytea,
417              "uuid" => NpgsqlDbType.Uuid,
418              "bit varying" or "varbit" => NpgsqlDbType.Varbit,
419              "bit" => NpgsqlDbType.Bit,
420              "hstore" => NpgsqlDbType.Hstore,
421              "geometry" => NpgsqlDbType.Geometry,
422              "geography" => NpgsqlDbType.Geography,
423              "int4range" => NpgsqlDbType.IntegerRange,
424              "int8range" => NpgsqlDbType.BigIntRange,
425              "numrange" => NpgsqlDbType.NumericRange,
426              "tsrange" => NpgsqlDbType.TimestampRange,
427              "tstzrange" => NpgsqlDbType.TimestampTzRange,
428              "daterange" => NpgsqlDbType.DateRange,
429              "int4multirange" => NpgsqlDbType.IntegerMultirange,
430              "int8multirange" => NpgsqlDbType.BigIntMultirange,
431              "nummultirange" => NpgsqlDbType.NumericMultirange,
432              "tsmultirange" => NpgsqlDbType.TimestampMultirange,
433              "tstzmultirange" => NpgsqlDbType.TimestampTzMultirange,
434              "datemultirange" => NpgsqlDbType.DateMultirange,
435              "int2vector" => NpgsqlDbType.Int2Vector,
436              "oidvector" => NpgsqlDbType.Oidvector,
437              "pg_lsn" => NpgsqlDbType.PgLsn,
438              "tid" => NpgsqlDbType.Tid,
439              "char" => NpgsqlDbType.InternalChar,
440              _ => typeName.EndsWith("[]", StringComparison.Ordinal) &&
441                   DataTypeNameToNpgsqlDbType(typeName.Substring(0, typeName.Length - 2)) is { } elementNpgsqlDbType &&
442                   elementNpgsqlDbType != NpgsqlDbType.Unknown
443                  ? elementNpgsqlDbType | NpgsqlDbType.Array
444                  : NpgsqlDbType.Unknown 
445          };
446      }
447      internal static NpgsqlDbType? DbTypeToNpgsqlDbType(DbType dbType)
448          => dbType switch
449          {
450              DbType.AnsiString            => NpgsqlDbType.Text,
451              DbType.Binary                => NpgsqlDbType.Bytea,
452              DbType.Byte                  => NpgsqlDbType.Smallint,
453              DbType.Boolean               => NpgsqlDbType.Boolean,
454              DbType.Currency              => NpgsqlDbType.Money,
455              DbType.Date                  => NpgsqlDbType.Date,
456              DbType.DateTime              => LegacyTimestampBehavior ? NpgsqlDbType.Timestamp : NpgsqlDbType.TimestampTz,
457              DbType.Decimal               => NpgsqlDbType.Numeric,
458              DbType.VarNumeric            => NpgsqlDbType.Numeric,
459              DbType.Double                => NpgsqlDbType.Double,
460              DbType.Guid                  => NpgsqlDbType.Uuid,
461              DbType.Int16                 => NpgsqlDbType.Smallint,
462              DbType.Int32                 => NpgsqlDbType.Integer,
463              DbType.Int64                 => NpgsqlDbType.Bigint,
464              DbType.Single                => NpgsqlDbType.Real,
465              DbType.String                => NpgsqlDbType.Text,
466              DbType.Time                  => NpgsqlDbType.Time,
467              DbType.AnsiStringFixedLength => NpgsqlDbType.Text,
468              DbType.StringFixedLength     => NpgsqlDbType.Text,
469              DbType.Xml                   => NpgsqlDbType.Xml,
470              DbType.DateTime2             => NpgsqlDbType.Timestamp,
471              DbType.DateTimeOffset        => NpgsqlDbType.TimestampTz,
472              DbType.Object                => null,
473              DbType.SByte                 => null,
474              DbType.UInt16                => null,
475              DbType.UInt32                => null,
476              DbType.UInt64                => null,
477              _ => throw new ArgumentOutOfRangeException(nameof(dbType), dbType, null)
478          };
479      internal static DbType NpgsqlDbTypeToDbType(NpgsqlDbType npgsqlDbType)
480          => npgsqlDbType switch
481          {
482              NpgsqlDbType.Smallint    => DbType.Int16,
483              NpgsqlDbType.Integer     => DbType.Int32,
484              NpgsqlDbType.Bigint      => DbType.Int64,
485              NpgsqlDbType.Real        => DbType.Single,
486              NpgsqlDbType.Double      => DbType.Double,
487              NpgsqlDbType.Numeric     => DbType.Decimal,
488              NpgsqlDbType.Money       => DbType.Currency,
489              NpgsqlDbType.Text        => DbType.String,
490              NpgsqlDbType.Xml         => DbType.Xml,
491              NpgsqlDbType.Varchar     => DbType.String,
492              NpgsqlDbType.Char        => DbType.String,
493              NpgsqlDbType.Name        => DbType.String,
494              NpgsqlDbType.Refcursor   => DbType.String,
495              NpgsqlDbType.Citext      => DbType.String,
496              NpgsqlDbType.Jsonb       => DbType.Object,
497              NpgsqlDbType.Json        => DbType.Object,
498              NpgsqlDbType.JsonPath    => DbType.String,
499              NpgsqlDbType.Timestamp   => LegacyTimestampBehavior ? DbType.DateTime : DbType.DateTime2,
500              NpgsqlDbType.TimestampTz => LegacyTimestampBehavior ? DbType.DateTimeOffset : DbType.DateTime,
501              NpgsqlDbType.Date        => DbType.Date,
502              NpgsqlDbType.Time        => DbType.Time,
503              NpgsqlDbType.Bytea       => DbType.Binary,
504              NpgsqlDbType.Boolean     => DbType.Boolean,
505              NpgsqlDbType.Uuid        => DbType.Guid,
506              NpgsqlDbType.Unknown     => DbType.Object,
507              _ => DbType.Object
508          };
509      #endregion Static translation tables
510  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.Data;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Linq;
7  using System.Reflection;
8  using System.Threading;
9  using Npgsql.Internal.TypeHandling;
10  using Npgsql.Internal.TypeMapping;
11  using Npgsql.NameTranslation;
12  using NpgsqlTypes;
13  using static Npgsql.Util.Statics;
14  namespace Npgsql.TypeMapping;
15  sealed class GlobalTypeMapper : INpgsqlTypeMapper
16  {
17      public static GlobalTypeMapper Instance { get; }
18      public INpgsqlNameTranslator DefaultNameTranslator { get; set; } = new NpgsqlSnakeCaseNameTranslator();
19      internal List<TypeHandlerResolverFactory> HandlerResolverFactories { get; } = new();
20      List<TypeMappingResolver> MappingResolvers { get; } = new();
21      public ConcurrentDictionary<string, IUserTypeMapping> UserTypeMappings { get; } = new();
22      readonly ConcurrentDictionary<Type, TypeMappingInfo> _mappingsByClrType = new();
23      internal ReaderWriterLockSlim Lock { get; }
24          = new(LockRecursionPolicy.SupportsRecursion);
25      static GlobalTypeMapper()
26          => Instance = new GlobalTypeMapper();
27      GlobalTypeMapper()
28          => Reset();
29      #region Mapping management
30      public INpgsqlTypeMapper MapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
31          where TEnum : struct, Enum
32      {
33          if (pgName != null && pgName.Trim() == "")
34              throw new ArgumentException("pgName can't be empty", nameof(pgName));
35          nameTranslator ??= DefaultNameTranslator;
36          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
37          Lock.EnterWriteLock();
38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping<TEnum>(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
50          where TEnum : struct, Enum
51      {
52          if (pgName != null && pgName.Trim() == "")
53              throw new ArgumentException("pgName can't be empty", nameof(pgName));
54          nameTranslator ??= DefaultNameTranslator;
55          pgName ??= GetPgName(typeof(TEnum), nameTranslator);
56          Lock.EnterWriteLock();
57          try
58          {
59              if (UserTypeMappings.TryRemove(pgName, out _))
60              {
61                  RecordChange();
62                  return true;
63              }
64              return false;
65          }
66          finally
67          {
68              Lock.ExitWriteLock();
69          }
70      }
71      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
72      public INpgsqlTypeMapper MapComposite<T>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
73      {
74          if (pgName != null && pgName.Trim() == "")
75              throw new ArgumentException("pgName can't be empty", nameof(pgName));
76          nameTranslator ??= DefaultNameTranslator;
77          pgName ??= GetPgName(typeof(T), nameTranslator);
78          Lock.EnterWriteLock();
<span onclick='openModal()' class='match'>79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping<T>(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
</span>91      public INpgsqlTypeMapper MapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
92      {
93          var openMethod = typeof(GlobalTypeMapper).GetMethod(nameof(MapComposite), new[] { typeof(string), typeof(INpgsqlNameTranslator) })!;
94          var method = openMethod.MakeGenericMethod(clrType);
95          method.Invoke(this, new object?[] { pgName, nameTranslator });
96          return this;
97      }
98      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
99      public bool UnmapComposite<T>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
100          => UnmapComposite(typeof(T), pgName, nameTranslator);
101      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
102      public bool UnmapComposite(Type clrType, string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
103      {
104          if (pgName != null && pgName.Trim() == "")
105              throw new ArgumentException("pgName can't be empty", nameof(pgName));
106          nameTranslator ??= DefaultNameTranslator;
107          pgName ??= GetPgName(clrType, nameTranslator);
108          Lock.EnterWriteLock();
109          try
110          {
111              if (UserTypeMappings.TryRemove(pgName, out _))
112              {
113                  RecordChange();
114                  return true;
115              }
116              return false;
117          }
118          finally
119          {
120              Lock.ExitWriteLock();
121          }
122      }
123      public void AddTypeResolverFactory(TypeHandlerResolverFactory resolverFactory)
124      {
125          Lock.EnterWriteLock();
126          try
127          {
128              var type = resolverFactory.GetType();
129              if (HandlerResolverFactories[0].GetType() == type)
130                  HandlerResolverFactories[0] = resolverFactory;
131              else
132              {
133                  for (var i = 0; i < HandlerResolverFactories.Count; i++)
134                      if (HandlerResolverFactories[i].GetType() == type)
135                          HandlerResolverFactories.RemoveAt(i);
136                  HandlerResolverFactories.Insert(0, resolverFactory);
137              }
138              var mappingResolver = resolverFactory.CreateMappingResolver();
139              if (mappingResolver is not null)
140                  AddMappingResolver(mappingResolver, overwrite: true);
141              RecordChange();
142          }
143          finally
144          {
145              Lock.ExitWriteLock();
146          }
147      }
148      internal void TryAddMappingResolver(TypeMappingResolver resolver)
149      {
150          Lock.EnterWriteLock();
151          try
152          {
153              if (AddMappingResolver(resolver, overwrite: false))
154                  RecordChange();
155          }
156          finally
157          {
158              Lock.ExitWriteLock();
159          }
160      }
161      bool AddMappingResolver(TypeMappingResolver resolver, bool overwrite)
162      {
163          var type = resolver.GetType();
164          if (MappingResolvers[0].GetType() == type)
165          {
166              if (!overwrite)
167                  return false;
168              MappingResolvers[0] = resolver;
169          }
170          else
171          {
172              for (var i = 0; i < MappingResolvers.Count; i++)
173              {
174                  if (MappingResolvers[i].GetType() == type)
175                  {
176                      if (!overwrite)
177                          return false;
178                      MappingResolvers.RemoveAt(i);
179                      break;
180                  }
181              }
182              MappingResolvers.Insert(0, resolver);
183          }
184          return true;
185      }
186      public void Reset()
187      {
188          Lock.EnterWriteLock();
189          try
190          {
191              HandlerResolverFactories.Clear();
192              HandlerResolverFactories.Add(new BuiltInTypeHandlerResolverFactory());
193              MappingResolvers.Clear();
194              MappingResolvers.Add(new BuiltInTypeMappingResolver());
195              UserTypeMappings.Clear();
196              RecordChange();
197          }
198          finally
199          {
200              Lock.ExitWriteLock();
201          }
202      }
203      internal void RecordChange()
204          => _mappingsByClrType.Clear();
205      static string GetPgName(Type clrType, INpgsqlNameTranslator nameTranslator)
206          => clrType.GetCustomAttribute<PgNameAttribute>()?.PgName
207             ?? nameTranslator.TranslateTypeName(clrType.Name);
208      #endregion Mapping management
209      #region NpgsqlDbType/DbType inference for NpgsqlParameter
210      [RequiresUnreferencedCode("ToNpgsqlDbType uses interface-based reflection and isn't trimming-safe")]
211      internal bool TryResolveMappingByValue(object value, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
212      {
213          Lock.EnterReadLock();
214          try
215          {
216              var type = value.GetType();
217              if (_mappingsByClrType.TryGetValue(type, out typeMapping))
218                  return true;
219              foreach (var resolver in MappingResolvers)
220                  if ((typeMapping = resolver.GetMappingByValueDependentValue(value)) is not null)
221                      return true;
222              return TryResolveMappingByClrType(type, out typeMapping);
223          }
224          finally
225          {
226              Lock.ExitReadLock();
227          }
228          bool TryResolveMappingByClrType(Type clrType, [NotNullWhen(true)] out TypeMappingInfo? typeMapping)
229          {
230              if (_mappingsByClrType.TryGetValue(clrType, out typeMapping))
231                  return true;
232              foreach (var resolver in MappingResolvers)
233              {
234                  if ((typeMapping = resolver.GetMappingByClrType(clrType)) is not null)
235                  {
236                      _mappingsByClrType[clrType] = typeMapping;
237                      return true;
238                  }
239              }
240              if (clrType.IsArray)
241              {
242                  if (TryResolveMappingByClrType(clrType.GetElementType()!, out var elementMapping))
243                  {
244                      _mappingsByClrType[clrType] = typeMapping = new(
245                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
246                          elementMapping.DataTypeName + "[]");
247                      return true;
248                  }
249                  typeMapping = null;
250                  return false;
251              }
252              var typeInfo = clrType.GetTypeInfo();
253              var ilist = typeInfo.ImplementedInterfaces.FirstOrDefault(x =>
254                  x.GetTypeInfo().IsGenericType && x.GetGenericTypeDefinition() == typeof(IList<>));
255              if (ilist != null)
256              {
257                  if (TryResolveMappingByClrType(ilist.GetGenericArguments()[0], out var elementMapping))
258                  {
259                      _mappingsByClrType[clrType] = typeMapping = new(
260                          NpgsqlDbType.Array | elementMapping.NpgsqlDbType,
261                          elementMapping.DataTypeName + "[]");
262                      return true;
263                  }
264                  typeMapping = null;
265                  return false;
266              }
267              if (typeInfo.IsGenericType && clrType.GetGenericTypeDefinition() == typeof(NpgsqlRange<>))
268              {
269                  if (TryResolveMappingByClrType(clrType.GetGenericArguments()[0], out var elementMapping))
270                  {
271                      _mappingsByClrType[clrType] = typeMapping = new(
272                          NpgsqlDbType.Range | elementMapping.NpgsqlDbType,
273                          dataTypeName: null);
274                      return true;
275                  }
276                  typeMapping = null;
277                  return false;
278              }
279              typeMapping = null;
280              return false;
281          }
282      }
283      #endregion NpgsqlDbType/DbType inference for NpgsqlParameter
284      #region Static translation tables
285      public static string? NpgsqlDbTypeToDataTypeName(NpgsqlDbType npgsqlDbType)
286          => npgsqlDbType switch
287          {
288              NpgsqlDbType.Smallint => "smallint",
289              NpgsqlDbType.Integer  => "integer",
290              NpgsqlDbType.Bigint   => "bigint",
291              NpgsqlDbType.Real     => "real",
292              NpgsqlDbType.Double   => "double precision",
293              NpgsqlDbType.Numeric  => "numeric",
294              NpgsqlDbType.Money    => "money",
295              NpgsqlDbType.Text      => "text",
296              NpgsqlDbType.Xml       => "xml",
297              NpgsqlDbType.Varchar   => "character varying",
298              NpgsqlDbType.Char      => "character",
299              NpgsqlDbType.Name      => "name",
300              NpgsqlDbType.Refcursor => "refcursor",
301              NpgsqlDbType.Citext    => "citext",
302              NpgsqlDbType.Jsonb     => "jsonb",
303              NpgsqlDbType.Json      => "json",
304              NpgsqlDbType.JsonPath  => "jsonpath",
305              NpgsqlDbType.Timestamp   => "timestamp without time zone",
306              NpgsqlDbType.TimestampTz => "timestamp with time zone",
307              NpgsqlDbType.Date        => "date",
308              NpgsqlDbType.Time        => "time without time zone",
309              NpgsqlDbType.TimeTz      => "time with time zone",
310              NpgsqlDbType.Interval    => "interval",
311              NpgsqlDbType.Cidr     => "cidr",
312              NpgsqlDbType.Inet     => "inet",
313              NpgsqlDbType.MacAddr  => "macaddr",
314              NpgsqlDbType.MacAddr8 => "macaddr8",
315              NpgsqlDbType.TsQuery   => "tsquery",
316              NpgsqlDbType.TsVector  => "tsvector",
317              NpgsqlDbType.Box     => "box",
318              NpgsqlDbType.Circle  => "circle",
319              NpgsqlDbType.Line    => "line",
320              NpgsqlDbType.LSeg    => "lseg",
321              NpgsqlDbType.Path    => "path",
322              NpgsqlDbType.Point   => "point",
323              NpgsqlDbType.Polygon => "polygon",
324              NpgsqlDbType.LQuery    => "lquery",
325              NpgsqlDbType.LTree     => "ltree",
326              NpgsqlDbType.LTxtQuery => "ltxtquery",
327              NpgsqlDbType.Oid       => "oid",
328              NpgsqlDbType.Xid       => "xid",
329              NpgsqlDbType.Xid8      => "xid8",
330              NpgsqlDbType.Cid       => "cid",
331              NpgsqlDbType.Regtype   => "regtype",
332              NpgsqlDbType.Regconfig => "regconfig",
333              NpgsqlDbType.Boolean => "boolean",
334              NpgsqlDbType.Bytea   => "bytea",
335              NpgsqlDbType.Uuid    => "uuid",
336              NpgsqlDbType.Varbit  => "bit varying",
337              NpgsqlDbType.Bit     => "bit",
338              NpgsqlDbType.Hstore  => "hstore",
339              NpgsqlDbType.Geometry  => "geometry",
340              NpgsqlDbType.Geography => "geography",
341              NpgsqlDbType.IntegerRange     => "int4range",
342              NpgsqlDbType.BigIntRange      => "int8range",
343              NpgsqlDbType.NumericRange     => "numrange",
344              NpgsqlDbType.TimestampRange   => "tsrange",
345              NpgsqlDbType.TimestampTzRange => "tstzrange",
346              NpgsqlDbType.DateRange        => "daterange",
347              NpgsqlDbType.IntegerMultirange     => "int4multirange",
348              NpgsqlDbType.BigIntMultirange      => "int8multirange",
349              NpgsqlDbType.NumericMultirange     => "nummultirange",
350              NpgsqlDbType.TimestampMultirange   => "tsmultirange",
351              NpgsqlDbType.TimestampTzMultirange => "tstzmultirange",
352              NpgsqlDbType.DateMultirange        => "datemultirange",
353              NpgsqlDbType.Int2Vector   => "int2vector",
354              NpgsqlDbType.Oidvector    => "oidvector",
355              NpgsqlDbType.PgLsn        => "pg_lsn",
356              NpgsqlDbType.Tid          => "tid",
357              NpgsqlDbType.InternalChar => "char",
358              NpgsqlDbType.Unknown => "unknown",
359              _ => npgsqlDbType.HasFlag(NpgsqlDbType.Array)
360                  ? NpgsqlDbTypeToDataTypeName(npgsqlDbType & ~NpgsqlDbType.Array) + "[]"
361                  : null 
362          };
363      public static NpgsqlDbType DataTypeNameToNpgsqlDbType(string typeName)
364      {
365          var parenIndex = typeName.IndexOf('(');
366          if (parenIndex > -1)
367              typeName = typeName.Substring(0, parenIndex);
368          return typeName switch
369          {
370              "smallint" => NpgsqlDbType.Smallint,
371              "integer" or "int" => NpgsqlDbType.Integer,
372              "bigint" => NpgsqlDbType.Bigint,
373              "real" => NpgsqlDbType.Real,
374              "double precision" => NpgsqlDbType.Double,
375              "numeric" => NpgsqlDbType.Numeric,
376              "money" => NpgsqlDbType.Money,
377              "text" => NpgsqlDbType.Text,
378              "xml" => NpgsqlDbType.Xml,
379              "character varying" or "varchar" => NpgsqlDbType.Varchar,
380              "character" => NpgsqlDbType.Char,
381              "name" => NpgsqlDbType.Name,
382              "refcursor" => NpgsqlDbType.Refcursor,
383              "citext" => NpgsqlDbType.Citext,
384              "jsonb" => NpgsqlDbType.Jsonb,
385              "json" => NpgsqlDbType.Json,
386              "jsonpath" => NpgsqlDbType.JsonPath,
387              "timestamp without time zone" or "timestamp" => NpgsqlDbType.Timestamp,
388              "timestamp with time zone" or "timestamptz" => NpgsqlDbType.TimestampTz,
389              "date" => NpgsqlDbType.Date,
390              "time without time zone" or "timetz" => NpgsqlDbType.Time,
391              "time with time zone" or "time" => NpgsqlDbType.TimeTz,
392              "interval" => NpgsqlDbType.Interval,
393              "cidr" => NpgsqlDbType.Cidr,
394              "inet" => NpgsqlDbType.Inet,
395              "macaddr" => NpgsqlDbType.MacAddr,
396              "macaddr8" => NpgsqlDbType.MacAddr8,
397              "tsquery" => NpgsqlDbType.TsQuery,
398              "tsvector" => NpgsqlDbType.TsVector,
399              "box" => NpgsqlDbType.Box,
400              "circle" => NpgsqlDbType.Circle,
401              "line" => NpgsqlDbType.Line,
402              "lseg" => NpgsqlDbType.LSeg,
403              "path" => NpgsqlDbType.Path,
404              "point" => NpgsqlDbType.Point,
405              "polygon" => NpgsqlDbType.Polygon,
406              "lquery" => NpgsqlDbType.LQuery,
407              "ltree" => NpgsqlDbType.LTree,
408              "ltxtquery" => NpgsqlDbType.LTxtQuery,
409              "oid" => NpgsqlDbType.Oid,
410              "xid" => NpgsqlDbType.Xid,
411              "xid8" => NpgsqlDbType.Xid8,
412              "cid" => NpgsqlDbType.Cid,
413              "regtype" => NpgsqlDbType.Regtype,
414              "regconfig" => NpgsqlDbType.Regconfig,
415              "boolean" or "bool" => NpgsqlDbType.Boolean,
416              "bytea" => NpgsqlDbType.Bytea,
417              "uuid" => NpgsqlDbType.Uuid,
418              "bit varying" or "varbit" => NpgsqlDbType.Varbit,
419              "bit" => NpgsqlDbType.Bit,
420              "hstore" => NpgsqlDbType.Hstore,
421              "geometry" => NpgsqlDbType.Geometry,
422              "geography" => NpgsqlDbType.Geography,
423              "int4range" => NpgsqlDbType.IntegerRange,
424              "int8range" => NpgsqlDbType.BigIntRange,
425              "numrange" => NpgsqlDbType.NumericRange,
426              "tsrange" => NpgsqlDbType.TimestampRange,
427              "tstzrange" => NpgsqlDbType.TimestampTzRange,
428              "daterange" => NpgsqlDbType.DateRange,
429              "int4multirange" => NpgsqlDbType.IntegerMultirange,
430              "int8multirange" => NpgsqlDbType.BigIntMultirange,
431              "nummultirange" => NpgsqlDbType.NumericMultirange,
432              "tsmultirange" => NpgsqlDbType.TimestampMultirange,
433              "tstzmultirange" => NpgsqlDbType.TimestampTzMultirange,
434              "datemultirange" => NpgsqlDbType.DateMultirange,
435              "int2vector" => NpgsqlDbType.Int2Vector,
436              "oidvector" => NpgsqlDbType.Oidvector,
437              "pg_lsn" => NpgsqlDbType.PgLsn,
438              "tid" => NpgsqlDbType.Tid,
439              "char" => NpgsqlDbType.InternalChar,
440              _ => typeName.EndsWith("[]", StringComparison.Ordinal) &&
441                   DataTypeNameToNpgsqlDbType(typeName.Substring(0, typeName.Length - 2)) is { } elementNpgsqlDbType &&
442                   elementNpgsqlDbType != NpgsqlDbType.Unknown
443                  ? elementNpgsqlDbType | NpgsqlDbType.Array
444                  : NpgsqlDbType.Unknown 
445          };
446      }
447      internal static NpgsqlDbType? DbTypeToNpgsqlDbType(DbType dbType)
448          => dbType switch
449          {
450              DbType.AnsiString            => NpgsqlDbType.Text,
451              DbType.Binary                => NpgsqlDbType.Bytea,
452              DbType.Byte                  => NpgsqlDbType.Smallint,
453              DbType.Boolean               => NpgsqlDbType.Boolean,
454              DbType.Currency              => NpgsqlDbType.Money,
455              DbType.Date                  => NpgsqlDbType.Date,
456              DbType.DateTime              => LegacyTimestampBehavior ? NpgsqlDbType.Timestamp : NpgsqlDbType.TimestampTz,
457              DbType.Decimal               => NpgsqlDbType.Numeric,
458              DbType.VarNumeric            => NpgsqlDbType.Numeric,
459              DbType.Double                => NpgsqlDbType.Double,
460              DbType.Guid                  => NpgsqlDbType.Uuid,
461              DbType.Int16                 => NpgsqlDbType.Smallint,
462              DbType.Int32                 => NpgsqlDbType.Integer,
463              DbType.Int64                 => NpgsqlDbType.Bigint,
464              DbType.Single                => NpgsqlDbType.Real,
465              DbType.String                => NpgsqlDbType.Text,
466              DbType.Time                  => NpgsqlDbType.Time,
467              DbType.AnsiStringFixedLength => NpgsqlDbType.Text,
468              DbType.StringFixedLength     => NpgsqlDbType.Text,
469              DbType.Xml                   => NpgsqlDbType.Xml,
470              DbType.DateTime2             => NpgsqlDbType.Timestamp,
471              DbType.DateTimeOffset        => NpgsqlDbType.TimestampTz,
472              DbType.Object                => null,
473              DbType.SByte                 => null,
474              DbType.UInt16                => null,
475              DbType.UInt32                => null,
476              DbType.UInt64                => null,
477              _ => throw new ArgumentOutOfRangeException(nameof(dbType), dbType, null)
478          };
479      internal static DbType NpgsqlDbTypeToDbType(NpgsqlDbType npgsqlDbType)
480          => npgsqlDbType switch
481          {
482              NpgsqlDbType.Smallint    => DbType.Int16,
483              NpgsqlDbType.Integer     => DbType.Int32,
484              NpgsqlDbType.Bigint      => DbType.Int64,
485              NpgsqlDbType.Real        => DbType.Single,
486              NpgsqlDbType.Double      => DbType.Double,
487              NpgsqlDbType.Numeric     => DbType.Decimal,
488              NpgsqlDbType.Money       => DbType.Currency,
489              NpgsqlDbType.Text        => DbType.String,
490              NpgsqlDbType.Xml         => DbType.Xml,
491              NpgsqlDbType.Varchar     => DbType.String,
492              NpgsqlDbType.Char        => DbType.String,
493              NpgsqlDbType.Name        => DbType.String,
494              NpgsqlDbType.Refcursor   => DbType.String,
495              NpgsqlDbType.Citext      => DbType.String,
496              NpgsqlDbType.Jsonb       => DbType.Object,
497              NpgsqlDbType.Json        => DbType.Object,
498              NpgsqlDbType.JsonPath    => DbType.String,
499              NpgsqlDbType.Timestamp   => LegacyTimestampBehavior ? DbType.DateTime : DbType.DateTime2,
500              NpgsqlDbType.TimestampTz => LegacyTimestampBehavior ? DbType.DateTimeOffset : DbType.DateTime,
501              NpgsqlDbType.Date        => DbType.Date,
502              NpgsqlDbType.Time        => DbType.Time,
503              NpgsqlDbType.Bytea       => DbType.Binary,
504              NpgsqlDbType.Boolean     => DbType.Boolean,
505              NpgsqlDbType.Uuid        => DbType.Guid,
506              NpgsqlDbType.Unknown     => DbType.Object,
507              _ => DbType.Object
508          };
509      #endregion Static translation tables
510  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-GlobalTypeMapper.cs</div>
                </div>
                <div class="column column_space"><pre><code>38          try
39          {
40              UserTypeMappings[pgName] = new UserEnumTypeMapping<TEnum>(pgName, nameTranslator);
41              RecordChange();
42              return this;
43          }
44          finally
45          {
46              Lock.ExitWriteLock();
47          }
48      }
49      public bool UnmapEnum<TEnum>(string? pgName = null, INpgsqlNameTranslator? nameTranslator = null)
</pre></code></div>
                <div class="column column_space"><pre><code>79          try
80          {
81              UserTypeMappings[pgName] = new UserCompositeTypeMapping<T>(pgName, nameTranslator);
82              RecordChange();
83              return this;
84          }
85          finally
86          {
87              Lock.ExitWriteLock();
88          }
89      }
90      [RequiresUnreferencedCode("Composite type mapping currently isn't trimming-safe.")]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    