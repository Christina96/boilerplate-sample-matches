
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 32, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessInvokerL0.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.IO;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Xunit;
8  using System.Threading.Channels;
9  using GitHub.Runner.Sdk;
10  using System.Linq;
11  namespace GitHub.Runner.Common.Tests
12  {
13      public sealed class ProcessInvokerL0
14      {
15  #if OS_WINDOWS
16          [Fact]
17          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
18          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
19          public async Task DefaultsToCurrentSystemOemEncoding()
20          {
21              using (TestHostContext hc = new TestHostContext(this))
22              {
23                  Tracing trace = hc.GetTrace();
24                  var processInvoker = new ProcessInvokerWrapper();
25                  processInvoker.Initialize(hc);
26                  var stdout = new List&lt;string&gt;();
27                  var stderr = new List&lt;string&gt;();
28                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
29                  {
30                      stdout.Add(e.Data);
31                  };
32                  processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
33                  {
34                      stderr.Add(e.Data);
35                  };
36                  await processInvoker.ExecuteAsync(
37                      workingDirectory: &quot;&quot;,
38                      fileName: &quot;powershell.exe&quot;,
39                      arguments: $@&quot;-NoLogo -Sta -NoProfile -NonInteractive -ExecutionPolicy Unrestricted -Command &quot;&quot;Write-Host &#x27;From STDOUT &#x27;&#x27;ç&#x27;&#x27;&#x27; ; Write-Error &#x27;From STDERR &#x27;&#x27;ç&#x27;&#x27;&#x27;&quot;&quot;&quot;,
40                      environment: null,
41                      requireExitCodeZero: false,
42                      cancellationToken: CancellationToken.None);
43                  Assert.Equal(1, stdout.Count);
44                  Assert.Equal(&quot;From STDOUT &#x27;ç&#x27;&quot;, stdout[0]);
45                  Assert.True(stderr.Count &gt; 0);
46                  Assert.Contains(&quot;From STDERR &#x27;ç&#x27;&quot;, stderr[0]);
47              }
48          }
49  #endif
50          [Fact]
51          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
52          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
53          public async Task SuccessExitsWithCodeZero()
54          {
55              using (TestHostContext hc = new(this))
56              {
57                  Tracing trace = hc.GetTrace();
58                  Int32 exitCode = -1;
59                  var processInvoker = new ProcessInvokerWrapper();
60                  processInvoker.Initialize(hc);
61  #if OS_WINDOWS
62                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;dir &gt;nul\&quot;&quot;, null, CancellationToken.None);
63  #else
64                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c echo .&quot;, null, CancellationToken.None);
65  #endif
66                  trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
67                  Assert.Equal(0, exitCode);
68              }
69          }
70          [Fact]
71          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
72          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
73          public async Task SetCIEnv()
74          {
75              using (TestHostContext hc = new(this))
76              {
77                  var existingCI = Environment.GetEnvironmentVariable(&quot;CI&quot;);
78                  try
79                  {
80                      Environment.SetEnvironmentVariable(&quot;CI&quot;, null);
81                      Tracing trace = hc.GetTrace();
82                      Int32 exitCode = -1;
83                      var processInvoker = new ProcessInvokerWrapper();
84                      processInvoker.Initialize(hc);
85                      var stdout = new List&lt;string&gt;();
86                      var stderr = new List&lt;string&gt;();
87                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
88                      {
89                          trace.Info(e.Data);
90                          stdout.Add(e.Data);
91                      };
92                      processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
93                      {
94                          trace.Info(e.Data);
95                          stderr.Add(e.Data);
96                      };
97  #if OS_WINDOWS
98                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %CI%\&quot;&quot;, null, CancellationToken.None);
99  #else
100                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;echo $CI\&quot;&quot;, null, CancellationToken.None);
101  #endif
102                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
103                      Assert.Equal(0, exitCode);
104                      Assert.Equal(&quot;true&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
105                  }
106                  finally
107                  {
108                      Environment.SetEnvironmentVariable(&quot;CI&quot;, existingCI);
109                  }
110              }
111          }
112  #if OS_WINDOWS
113          [Fact]
114          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
115          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
116          public async Task SetTestEnvWithNullInKey()
117          {
118              using (TestHostContext hc = new(this))
119              {
120                  Tracing trace = hc.GetTrace();
121                  Int32 exitCode = -1;
122                  var processInvoker = new ProcessInvokerWrapper();
123                  processInvoker.Initialize(hc);
124                  var stdout = new List&lt;string&gt;();
125                  var stderr = new List&lt;string&gt;();
126                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
127                  {
128                      trace.Info(e.Data);
129                      stdout.Add(e.Data);
130                  };
131                  processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
132                  {
133                      trace.Info(e.Data);
134                      stderr.Add(e.Data);
135                  };
136                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %TEST%\&quot;&quot;,  new Dictionary&lt;string, string&gt;() { { &quot;TEST\0second&quot;, &quot;first&quot; } }, CancellationToken.None);
137                  trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
138                  Assert.Equal(0, exitCode);
139                  Assert.Equal(&quot;first&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
140              }
141          }
142          [Fact]
143          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
144          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
145          public async Task SetTestEnvWithNullInValue()
146          {
147              using (TestHostContext hc = new(this))
148              {
149                  Tracing trace = hc.GetTrace();
150                  Int32 exitCode = -1;
151                  var processInvoker = new ProcessInvokerWrapper();
152                  processInvoker.Initialize(hc);
153                  var stdout = new List&lt;string&gt;();
154                  var stderr = new List&lt;string&gt;();
155                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
156                  {
157                      trace.Info(e.Data);
158                      stdout.Add(e.Data);
159                  };
160                  processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
161                  {
162                      trace.Info(e.Data);
163                      stderr.Add(e.Data);
164                  };
165                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %TEST%\&quot;&quot;,  new Dictionary&lt;string, string&gt;() { { &quot;TEST&quot;, &quot;first\0second&quot; } }, CancellationToken.None);
166                  trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
167                  Assert.Equal(0, exitCode);
168                  Assert.Equal(&quot;first&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
169              }
170          }
171  #endif
172          [Fact]
173          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
174          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
175          public async Task KeepExistingCIEnv()
176          {
177              using (TestHostContext hc = new(this))
178              {
179                  var existingCI = Environment.GetEnvironmentVariable(&quot;CI&quot;);
180                  try
181                  {
182                      Environment.SetEnvironmentVariable(&quot;CI&quot;, null);
183                      Tracing trace = hc.GetTrace();
184                      Int32 exitCode = -1;
185                      var processInvoker = new ProcessInvokerWrapper();
186                      processInvoker.Initialize(hc);
187                      var stdout = new List&lt;string&gt;();
188                      var stderr = new List&lt;string&gt;();
189                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
190                      {
191                          trace.Info(e.Data);
192                          stdout.Add(e.Data);
193                      };
194                      processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
195                      {
196                          trace.Info(e.Data);
197                          stderr.Add(e.Data);
198                      };
199  #if OS_WINDOWS
200                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %CI%\&quot;&quot;, new Dictionary&lt;string, string&gt;() { { &quot;CI&quot;, &quot;false&quot; } }, CancellationToken.None);
201  #else
202                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;echo $CI\&quot;&quot;, new Dictionary&lt;string, string&gt;() { { &quot;CI&quot;, &quot;false&quot; } }, CancellationToken.None);
203  #endif
204                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
205                      Assert.Equal(0, exitCode);
206                      Assert.Equal(&quot;false&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
207                  }
208                  finally
209                  {
210                      Environment.SetEnvironmentVariable(&quot;CI&quot;, existingCI);
211                  }
212              }
213          }
214  #if !OS_WINDOWS
215          [Fact]
216          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
217          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
218          public async Task TestCancel()
219          {
220              const int SecondsToRun = 20;
221              using (TestHostContext hc = new(this))
222              using (var tokenSource = new CancellationTokenSource())
223              {
224                  Tracing trace = hc.GetTrace();
225                  var processInvoker = new ProcessInvokerWrapper();
226                  processInvoker.Initialize(hc);
227                  Stopwatch watch = Stopwatch.StartNew();
228                  Task execTask;
229  #if OS_WINDOWS
230                  execTask = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, $&quot;/c \&quot;choice /T {SecondsToRun} /D y\&quot;&quot;, null, tokenSource.Token);
231  #else
232                  execTask = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, $&quot;-c \&quot;sleep {SecondsToRun}\&quot;&quot;, null, tokenSource.Token);
233  #endif
234                  await Task.Delay(500);
235                  tokenSource.Cancel();
236                  try
237                  {
238                      await execTask;
239                  }
240                  catch (OperationCanceledException)
241                  {
242                      trace.Info(&quot;Get expected OperationCanceledException.&quot;);
243                  }
244                  Assert.True(execTask.IsCompleted);
245                  Assert.True(!execTask.IsFaulted);
246                  Assert.True(execTask.IsCanceled);
247                  watch.Stop();
248                  long elapsedSeconds = watch.ElapsedMilliseconds / 1000;
249  #if ARM
250                  long expectedSeconds = (SecondsToRun * 3) / 4;
251  #else
252                  long expectedSeconds = SecondsToRun / 2;
253  #endif
254                  Assert.True(elapsedSeconds &lt;= expectedSeconds, $&quot;cancellation failed, because task took too long to run. {elapsedSeconds}&quot;);
255              }
256          }
257  #endif
258          [Fact]
259          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
260          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
261          public async Task RedirectSTDINCloseStream()
262          {
263              using (TestHostContext hc = new(this))
264              {
265                  Tracing trace = hc.GetTrace();
266                  CancellationTokenSource cancellationTokenSource = new();
267                  Int32 exitCode = -1;
268                  Channel&lt;string&gt; redirectSTDIN = Channel.CreateUnbounded&lt;string&gt;(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true });
269                  List&lt;string&gt; stdout = new();
270                  redirectSTDIN.Writer.TryWrite(&quot;Single line of STDIN&quot;);
271                  var processInvoker = new ProcessInvokerWrapper();
272                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
273                   {
274                       stdout.Add(e.Data);
275                   };
276                  processInvoker.Initialize(hc);
277  #if OS_WINDOWS
<span onclick='openModal()' class='match'>278                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c more&quot;, null, false, null, false, redirectSTDIN, false, false, cancellationTokenSource.Token);
279  #else
</span>280                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;read input; echo $input; read input; echo $input; read input; echo $input;\&quot;&quot;, null, false, null, false, redirectSTDIN, false, false, cancellationTokenSource.Token);
281  #endif
282                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
283                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
284                  await Task.Delay(100);
285                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
286                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
287                  await Task.Delay(100);
288                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
289                  cancellationTokenSource.CancelAfter(100);
290                  try
291                  {
292                      exitCode = await proc;
293                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
294                  }
295                  catch (Exception ex)
296                  {
297                      trace.Error(ex);
298                  }
299                  trace.Info(&quot;STDOUT: {0}&quot;, string.Join(Environment.NewLine, stdout));
300                  Assert.False(stdout.Contains(&quot;More line of STDIN&quot;), &quot;STDIN should be closed after first input line.&quot;);
301              }
302          }
303          [Fact]
304          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
305          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
306          public async Task RedirectSTDINKeepStreamOpen()
307          {
308              using (TestHostContext hc = new(this))
309              {
310                  Tracing trace = hc.GetTrace();
311                  CancellationTokenSource cancellationTokenSource = new();
312                  Int32 exitCode = -1;
313                  Channel&lt;string&gt; redirectSTDIN = Channel.CreateUnbounded&lt;string&gt;(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true });
314                  List&lt;string&gt; stdout = new();
315                  redirectSTDIN.Writer.TryWrite(&quot;Single line of STDIN&quot;);
316                  var processInvoker = new ProcessInvokerWrapper();
317                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
318                   {
319                       stdout.Add(e.Data);
320                   };
321                  processInvoker.Initialize(hc);
322  #if OS_WINDOWS
323                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c more&quot;, null, false, null, false, redirectSTDIN, false, true, cancellationTokenSource.Token);
324  #else
325                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;read input; echo $input; read input; echo $input; read input; echo $input;\&quot;&quot;, null, false, null, false, redirectSTDIN, false, true, cancellationTokenSource.Token);
326  #endif
327                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
328                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
329                  await Task.Delay(100);
330                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
331                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
332                  await Task.Delay(100);
333                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
334                  cancellationTokenSource.CancelAfter(100);
335                  try
336                  {
337                      exitCode = await proc;
338                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
339                  }
340                  catch (Exception ex)
341                  {
342                      trace.Error(ex);
343                  }
344                  trace.Info(&quot;STDOUT: {0}&quot;, string.Join(Environment.NewLine, stdout));
345                  Assert.True(stdout.Contains(&quot;More line of STDIN&quot;), &quot;STDIN should keep open and accept more inputs after first input line.&quot;);
346              }
347          }
348  #if OS_LINUX
349          [Fact]
350          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
351          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
352          public async Task OomScoreAdjIsWriten_Default()
353          {
354              string testProcPath = $&quot;/proc/{Process.GetCurrentProcess().Id}/oom_score_adj&quot;;
355              if (File.Exists(testProcPath))
356              {
357                  using (TestHostContext hc = new(this))
358                  using (var tokenSource = new CancellationTokenSource())
359                  {
360                      Tracing trace = hc.GetTrace();
361                      var processInvoker = new ProcessInvokerWrapper();
362                      processInvoker.Initialize(hc);
363                      int oomScoreAdj = -9999;
364                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
365                      {
366                          oomScoreAdj = int.Parse(e.Data);
367                          tokenSource.Cancel();
368                      };
369                      try
370                      {
371                          var proc = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;cat /proc/$$/oom_score_adj\&quot;&quot;, null, false, null, false, null, false, false,
372                                                              highPriorityProcess: false,
373                                                              cancellationToken: tokenSource.Token);
374                          Assert.Equal(500, oomScoreAdj);
375                      }
376                      catch (OperationCanceledException)
377                      {
378                          trace.Info(&quot;Caught expected OperationCanceledException&quot;);
379                      }
380                  }
381              }
382          }
383          [Fact]
384          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
385          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
386          public async Task OomScoreAdjIsWriten_FromEnv()
387          {
388              string testProcPath = $&quot;/proc/{Process.GetCurrentProcess().Id}/oom_score_adj&quot;;
389              if (File.Exists(testProcPath))
390              {
391                  using (TestHostContext hc = new(this))
392                  using (var tokenSource = new CancellationTokenSource())
393                  {
394                      Tracing trace = hc.GetTrace();
395                      var processInvoker = new ProcessInvokerWrapper();
396                      processInvoker.Initialize(hc);
397                      int oomScoreAdj = -9999;
398                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
399                      {
400                          oomScoreAdj = int.Parse(e.Data);
401                          tokenSource.Cancel();
402                      };
403                      try
404                      {
405                          var proc = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;cat /proc/$$/oom_score_adj\&quot;&quot;,
406                                                                  new Dictionary&lt;string, string&gt; { { &quot;PIPELINE_JOB_OOMSCOREADJ&quot;, &quot;1234&quot; } },
407                                                                  false, null, false, null, false, false,
408                                                                  highPriorityProcess: false,
409                                                                  cancellationToken: tokenSource.Token);
410                          Assert.Equal(1234, oomScoreAdj);
411                      }
412                      catch (OperationCanceledException)
413                      {
414                          trace.Info(&quot;Caught expected OperationCanceledException&quot;);
415                      }
416                  }
417              }
418          }
419          [Fact]
420          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
421          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
422          public async Task OomScoreAdjIsInherited()
423          {
424              string testProcPath = $&quot;/proc/{Process.GetCurrentProcess().Id}/oom_score_adj&quot;;
425              if (File.Exists(testProcPath))
426              {
427                  int testProcOomScoreAdj = 123;
428                  File.WriteAllText(testProcPath, testProcOomScoreAdj.ToString());
429                  using (TestHostContext hc = new(this))
430                  using (var tokenSource = new CancellationTokenSource())
431                  {
432                      Tracing trace = hc.GetTrace();
433                      var processInvoker = new ProcessInvokerWrapper();
434                      processInvoker.Initialize(hc);
435                      int oomScoreAdj = -9999;
436                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
437                      {
438                          oomScoreAdj = int.Parse(e.Data);
439                          tokenSource.Cancel();
440                      };
441                      try
442                      {
443                          var proc = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;cat /proc/$$/oom_score_adj\&quot;&quot;, null, false, null, false, null, false, false,
444                                                              highPriorityProcess: true,
445                                                              cancellationToken: tokenSource.Token);
446                          Assert.Equal(123, oomScoreAdj);
447                      }
448                      catch (OperationCanceledException)
449                      {
450                          trace.Info(&quot;Caught expected OperationCanceledException&quot;);
451                      }
452                  }
453              }
454          }
455  #endif
456      }
457  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessInvokerL0.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.IO;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Xunit;
8  using System.Threading.Channels;
9  using GitHub.Runner.Sdk;
10  using System.Linq;
11  namespace GitHub.Runner.Common.Tests
12  {
13      public sealed class ProcessInvokerL0
14      {
15  #if OS_WINDOWS
16          [Fact]
17          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
18          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
19          public async Task DefaultsToCurrentSystemOemEncoding()
20          {
21              using (TestHostContext hc = new TestHostContext(this))
22              {
23                  Tracing trace = hc.GetTrace();
24                  var processInvoker = new ProcessInvokerWrapper();
25                  processInvoker.Initialize(hc);
26                  var stdout = new List&lt;string&gt;();
27                  var stderr = new List&lt;string&gt;();
28                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
29                  {
30                      stdout.Add(e.Data);
31                  };
32                  processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
33                  {
34                      stderr.Add(e.Data);
35                  };
36                  await processInvoker.ExecuteAsync(
37                      workingDirectory: &quot;&quot;,
38                      fileName: &quot;powershell.exe&quot;,
39                      arguments: $@&quot;-NoLogo -Sta -NoProfile -NonInteractive -ExecutionPolicy Unrestricted -Command &quot;&quot;Write-Host &#x27;From STDOUT &#x27;&#x27;ç&#x27;&#x27;&#x27; ; Write-Error &#x27;From STDERR &#x27;&#x27;ç&#x27;&#x27;&#x27;&quot;&quot;&quot;,
40                      environment: null,
41                      requireExitCodeZero: false,
42                      cancellationToken: CancellationToken.None);
43                  Assert.Equal(1, stdout.Count);
44                  Assert.Equal(&quot;From STDOUT &#x27;ç&#x27;&quot;, stdout[0]);
45                  Assert.True(stderr.Count &gt; 0);
46                  Assert.Contains(&quot;From STDERR &#x27;ç&#x27;&quot;, stderr[0]);
47              }
48          }
49  #endif
50          [Fact]
51          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
52          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
53          public async Task SuccessExitsWithCodeZero()
54          {
55              using (TestHostContext hc = new(this))
56              {
57                  Tracing trace = hc.GetTrace();
58                  Int32 exitCode = -1;
59                  var processInvoker = new ProcessInvokerWrapper();
60                  processInvoker.Initialize(hc);
61  #if OS_WINDOWS
62                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;dir &gt;nul\&quot;&quot;, null, CancellationToken.None);
63  #else
64                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c echo .&quot;, null, CancellationToken.None);
65  #endif
66                  trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
67                  Assert.Equal(0, exitCode);
68              }
69          }
70          [Fact]
71          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
72          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
73          public async Task SetCIEnv()
74          {
75              using (TestHostContext hc = new(this))
76              {
77                  var existingCI = Environment.GetEnvironmentVariable(&quot;CI&quot;);
78                  try
79                  {
80                      Environment.SetEnvironmentVariable(&quot;CI&quot;, null);
81                      Tracing trace = hc.GetTrace();
82                      Int32 exitCode = -1;
83                      var processInvoker = new ProcessInvokerWrapper();
84                      processInvoker.Initialize(hc);
85                      var stdout = new List&lt;string&gt;();
86                      var stderr = new List&lt;string&gt;();
87                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
88                      {
89                          trace.Info(e.Data);
90                          stdout.Add(e.Data);
91                      };
92                      processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
93                      {
94                          trace.Info(e.Data);
95                          stderr.Add(e.Data);
96                      };
97  #if OS_WINDOWS
98                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %CI%\&quot;&quot;, null, CancellationToken.None);
99  #else
100                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;echo $CI\&quot;&quot;, null, CancellationToken.None);
101  #endif
102                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
103                      Assert.Equal(0, exitCode);
104                      Assert.Equal(&quot;true&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
105                  }
106                  finally
107                  {
108                      Environment.SetEnvironmentVariable(&quot;CI&quot;, existingCI);
109                  }
110              }
111          }
112  #if OS_WINDOWS
113          [Fact]
114          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
115          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
116          public async Task SetTestEnvWithNullInKey()
117          {
118              using (TestHostContext hc = new(this))
119              {
120                  Tracing trace = hc.GetTrace();
121                  Int32 exitCode = -1;
122                  var processInvoker = new ProcessInvokerWrapper();
123                  processInvoker.Initialize(hc);
124                  var stdout = new List&lt;string&gt;();
125                  var stderr = new List&lt;string&gt;();
126                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
127                  {
128                      trace.Info(e.Data);
129                      stdout.Add(e.Data);
130                  };
131                  processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
132                  {
133                      trace.Info(e.Data);
134                      stderr.Add(e.Data);
135                  };
136                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %TEST%\&quot;&quot;,  new Dictionary&lt;string, string&gt;() { { &quot;TEST\0second&quot;, &quot;first&quot; } }, CancellationToken.None);
137                  trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
138                  Assert.Equal(0, exitCode);
139                  Assert.Equal(&quot;first&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
140              }
141          }
142          [Fact]
143          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
144          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
145          public async Task SetTestEnvWithNullInValue()
146          {
147              using (TestHostContext hc = new(this))
148              {
149                  Tracing trace = hc.GetTrace();
150                  Int32 exitCode = -1;
151                  var processInvoker = new ProcessInvokerWrapper();
152                  processInvoker.Initialize(hc);
153                  var stdout = new List&lt;string&gt;();
154                  var stderr = new List&lt;string&gt;();
155                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
156                  {
157                      trace.Info(e.Data);
158                      stdout.Add(e.Data);
159                  };
160                  processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
161                  {
162                      trace.Info(e.Data);
163                      stderr.Add(e.Data);
164                  };
165                  exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %TEST%\&quot;&quot;,  new Dictionary&lt;string, string&gt;() { { &quot;TEST&quot;, &quot;first\0second&quot; } }, CancellationToken.None);
166                  trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
167                  Assert.Equal(0, exitCode);
168                  Assert.Equal(&quot;first&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
169              }
170          }
171  #endif
172          [Fact]
173          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
174          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
175          public async Task KeepExistingCIEnv()
176          {
177              using (TestHostContext hc = new(this))
178              {
179                  var existingCI = Environment.GetEnvironmentVariable(&quot;CI&quot;);
180                  try
181                  {
182                      Environment.SetEnvironmentVariable(&quot;CI&quot;, null);
183                      Tracing trace = hc.GetTrace();
184                      Int32 exitCode = -1;
185                      var processInvoker = new ProcessInvokerWrapper();
186                      processInvoker.Initialize(hc);
187                      var stdout = new List&lt;string&gt;();
188                      var stderr = new List&lt;string&gt;();
189                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
190                      {
191                          trace.Info(e.Data);
192                          stdout.Add(e.Data);
193                      };
194                      processInvoker.ErrorDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
195                      {
196                          trace.Info(e.Data);
197                          stderr.Add(e.Data);
198                      };
199  #if OS_WINDOWS
200                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c \&quot;echo %CI%\&quot;&quot;, new Dictionary&lt;string, string&gt;() { { &quot;CI&quot;, &quot;false&quot; } }, CancellationToken.None);
201  #else
202                      exitCode = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;echo $CI\&quot;&quot;, new Dictionary&lt;string, string&gt;() { { &quot;CI&quot;, &quot;false&quot; } }, CancellationToken.None);
203  #endif
204                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
205                      Assert.Equal(0, exitCode);
206                      Assert.Equal(&quot;false&quot;, stdout.First(x =&gt; !string.IsNullOrWhiteSpace(x)));
207                  }
208                  finally
209                  {
210                      Environment.SetEnvironmentVariable(&quot;CI&quot;, existingCI);
211                  }
212              }
213          }
214  #if !OS_WINDOWS
215          [Fact]
216          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
217          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
218          public async Task TestCancel()
219          {
220              const int SecondsToRun = 20;
221              using (TestHostContext hc = new(this))
222              using (var tokenSource = new CancellationTokenSource())
223              {
224                  Tracing trace = hc.GetTrace();
225                  var processInvoker = new ProcessInvokerWrapper();
226                  processInvoker.Initialize(hc);
227                  Stopwatch watch = Stopwatch.StartNew();
228                  Task execTask;
229  #if OS_WINDOWS
230                  execTask = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, $&quot;/c \&quot;choice /T {SecondsToRun} /D y\&quot;&quot;, null, tokenSource.Token);
231  #else
232                  execTask = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, $&quot;-c \&quot;sleep {SecondsToRun}\&quot;&quot;, null, tokenSource.Token);
233  #endif
234                  await Task.Delay(500);
235                  tokenSource.Cancel();
236                  try
237                  {
238                      await execTask;
239                  }
240                  catch (OperationCanceledException)
241                  {
242                      trace.Info(&quot;Get expected OperationCanceledException.&quot;);
243                  }
244                  Assert.True(execTask.IsCompleted);
245                  Assert.True(!execTask.IsFaulted);
246                  Assert.True(execTask.IsCanceled);
247                  watch.Stop();
248                  long elapsedSeconds = watch.ElapsedMilliseconds / 1000;
249  #if ARM
250                  long expectedSeconds = (SecondsToRun * 3) / 4;
251  #else
252                  long expectedSeconds = SecondsToRun / 2;
253  #endif
254                  Assert.True(elapsedSeconds &lt;= expectedSeconds, $&quot;cancellation failed, because task took too long to run. {elapsedSeconds}&quot;);
255              }
256          }
257  #endif
258          [Fact]
259          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
260          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
261          public async Task RedirectSTDINCloseStream()
262          {
263              using (TestHostContext hc = new(this))
264              {
265                  Tracing trace = hc.GetTrace();
266                  CancellationTokenSource cancellationTokenSource = new();
267                  Int32 exitCode = -1;
268                  Channel&lt;string&gt; redirectSTDIN = Channel.CreateUnbounded&lt;string&gt;(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true });
269                  List&lt;string&gt; stdout = new();
270                  redirectSTDIN.Writer.TryWrite(&quot;Single line of STDIN&quot;);
271                  var processInvoker = new ProcessInvokerWrapper();
272                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
273                   {
274                       stdout.Add(e.Data);
275                   };
276                  processInvoker.Initialize(hc);
277  #if OS_WINDOWS
278                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c more&quot;, null, false, null, false, redirectSTDIN, false, false, cancellationTokenSource.Token);
279  #else
<span onclick='openModal()' class='match'>280                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;read input; echo $input; read input; echo $input; read input; echo $input;\&quot;&quot;, null, false, null, false, redirectSTDIN, false, false, cancellationTokenSource.Token);
281  #endif
</span>282                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
283                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
284                  await Task.Delay(100);
285                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
286                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
287                  await Task.Delay(100);
288                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
289                  cancellationTokenSource.CancelAfter(100);
290                  try
291                  {
292                      exitCode = await proc;
293                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
294                  }
295                  catch (Exception ex)
296                  {
297                      trace.Error(ex);
298                  }
299                  trace.Info(&quot;STDOUT: {0}&quot;, string.Join(Environment.NewLine, stdout));
300                  Assert.False(stdout.Contains(&quot;More line of STDIN&quot;), &quot;STDIN should be closed after first input line.&quot;);
301              }
302          }
303          [Fact]
304          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
305          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
306          public async Task RedirectSTDINKeepStreamOpen()
307          {
308              using (TestHostContext hc = new(this))
309              {
310                  Tracing trace = hc.GetTrace();
311                  CancellationTokenSource cancellationTokenSource = new();
312                  Int32 exitCode = -1;
313                  Channel&lt;string&gt; redirectSTDIN = Channel.CreateUnbounded&lt;string&gt;(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true });
314                  List&lt;string&gt; stdout = new();
315                  redirectSTDIN.Writer.TryWrite(&quot;Single line of STDIN&quot;);
316                  var processInvoker = new ProcessInvokerWrapper();
317                  processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
318                   {
319                       stdout.Add(e.Data);
320                   };
321                  processInvoker.Initialize(hc);
322  #if OS_WINDOWS
323                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c more&quot;, null, false, null, false, redirectSTDIN, false, true, cancellationTokenSource.Token);
324  #else
325                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;read input; echo $input; read input; echo $input; read input; echo $input;\&quot;&quot;, null, false, null, false, redirectSTDIN, false, true, cancellationTokenSource.Token);
326  #endif
327                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
328                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
329                  await Task.Delay(100);
330                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
331                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
332                  await Task.Delay(100);
333                  redirectSTDIN.Writer.TryWrite(&quot;More line of STDIN&quot;);
334                  cancellationTokenSource.CancelAfter(100);
335                  try
336                  {
337                      exitCode = await proc;
338                      trace.Info(&quot;Exit Code: {0}&quot;, exitCode);
339                  }
340                  catch (Exception ex)
341                  {
342                      trace.Error(ex);
343                  }
344                  trace.Info(&quot;STDOUT: {0}&quot;, string.Join(Environment.NewLine, stdout));
345                  Assert.True(stdout.Contains(&quot;More line of STDIN&quot;), &quot;STDIN should keep open and accept more inputs after first input line.&quot;);
346              }
347          }
348  #if OS_LINUX
349          [Fact]
350          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
351          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
352          public async Task OomScoreAdjIsWriten_Default()
353          {
354              string testProcPath = $&quot;/proc/{Process.GetCurrentProcess().Id}/oom_score_adj&quot;;
355              if (File.Exists(testProcPath))
356              {
357                  using (TestHostContext hc = new(this))
358                  using (var tokenSource = new CancellationTokenSource())
359                  {
360                      Tracing trace = hc.GetTrace();
361                      var processInvoker = new ProcessInvokerWrapper();
362                      processInvoker.Initialize(hc);
363                      int oomScoreAdj = -9999;
364                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
365                      {
366                          oomScoreAdj = int.Parse(e.Data);
367                          tokenSource.Cancel();
368                      };
369                      try
370                      {
371                          var proc = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;cat /proc/$$/oom_score_adj\&quot;&quot;, null, false, null, false, null, false, false,
372                                                              highPriorityProcess: false,
373                                                              cancellationToken: tokenSource.Token);
374                          Assert.Equal(500, oomScoreAdj);
375                      }
376                      catch (OperationCanceledException)
377                      {
378                          trace.Info(&quot;Caught expected OperationCanceledException&quot;);
379                      }
380                  }
381              }
382          }
383          [Fact]
384          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
385          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
386          public async Task OomScoreAdjIsWriten_FromEnv()
387          {
388              string testProcPath = $&quot;/proc/{Process.GetCurrentProcess().Id}/oom_score_adj&quot;;
389              if (File.Exists(testProcPath))
390              {
391                  using (TestHostContext hc = new(this))
392                  using (var tokenSource = new CancellationTokenSource())
393                  {
394                      Tracing trace = hc.GetTrace();
395                      var processInvoker = new ProcessInvokerWrapper();
396                      processInvoker.Initialize(hc);
397                      int oomScoreAdj = -9999;
398                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
399                      {
400                          oomScoreAdj = int.Parse(e.Data);
401                          tokenSource.Cancel();
402                      };
403                      try
404                      {
405                          var proc = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;cat /proc/$$/oom_score_adj\&quot;&quot;,
406                                                                  new Dictionary&lt;string, string&gt; { { &quot;PIPELINE_JOB_OOMSCOREADJ&quot;, &quot;1234&quot; } },
407                                                                  false, null, false, null, false, false,
408                                                                  highPriorityProcess: false,
409                                                                  cancellationToken: tokenSource.Token);
410                          Assert.Equal(1234, oomScoreAdj);
411                      }
412                      catch (OperationCanceledException)
413                      {
414                          trace.Info(&quot;Caught expected OperationCanceledException&quot;);
415                      }
416                  }
417              }
418          }
419          [Fact]
420          [Trait(&quot;Level&quot;, &quot;L0&quot;)]
421          [Trait(&quot;Category&quot;, &quot;Common&quot;)]
422          public async Task OomScoreAdjIsInherited()
423          {
424              string testProcPath = $&quot;/proc/{Process.GetCurrentProcess().Id}/oom_score_adj&quot;;
425              if (File.Exists(testProcPath))
426              {
427                  int testProcOomScoreAdj = 123;
428                  File.WriteAllText(testProcPath, testProcOomScoreAdj.ToString());
429                  using (TestHostContext hc = new(this))
430                  using (var tokenSource = new CancellationTokenSource())
431                  {
432                      Tracing trace = hc.GetTrace();
433                      var processInvoker = new ProcessInvokerWrapper();
434                      processInvoker.Initialize(hc);
435                      int oomScoreAdj = -9999;
436                      processInvoker.OutputDataReceived += (object sender, ProcessDataReceivedEventArgs e) =&gt;
437                      {
438                          oomScoreAdj = int.Parse(e.Data);
439                          tokenSource.Cancel();
440                      };
441                      try
442                      {
443                          var proc = await processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;cat /proc/$$/oom_score_adj\&quot;&quot;, null, false, null, false, null, false, false,
444                                                              highPriorityProcess: true,
445                                                              cancellationToken: tokenSource.Token);
446                          Assert.Equal(123, oomScoreAdj);
447                      }
448                      catch (OperationCanceledException)
449                      {
450                          trace.Info(&quot;Caught expected OperationCanceledException&quot;);
451                      }
452                  }
453              }
454          }
455  #endif
456      }
457  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessInvokerL0.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ProcessInvokerL0.cs</div>
                </div>
                <div class="column column_space"><pre><code>278                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;cmd.exe&quot;, &quot;/c more&quot;, null, false, null, false, redirectSTDIN, false, false, cancellationTokenSource.Token);
279  #else
</pre></code></div>
                <div class="column column_space"><pre><code>280                  var proc = processInvoker.ExecuteAsync(&quot;&quot;, &quot;bash&quot;, &quot;-c \&quot;read input; echo $input; read input; echo $input; read input; echo $input;\&quot;&quot;, null, false, null, false, redirectSTDIN, false, false, cancellationTokenSource.Token);
281  #endif
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    