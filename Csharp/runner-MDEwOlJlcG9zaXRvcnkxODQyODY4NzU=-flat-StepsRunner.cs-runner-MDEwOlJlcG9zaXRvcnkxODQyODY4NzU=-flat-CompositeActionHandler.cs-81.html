
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-StepsRunner.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Threading;
4  using System.Threading.Tasks;
5  using GitHub.DistributedTask.Expressions2;
6  using GitHub.DistributedTask.ObjectTemplating.Tokens;
7  using GitHub.DistributedTask.Pipelines.ContextData;
8  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
9  using GitHub.DistributedTask.WebApi;
10  using GitHub.Runner.Common;
11  using GitHub.Runner.Common.Util;
12  using GitHub.Runner.Sdk;
13  using GitHub.Runner.Worker.Expressions;
14  namespace GitHub.Runner.Worker
15  {
16      public interface IStep
17      {
18          string Condition { get; set; }
19          TemplateToken ContinueOnError { get; }
20          string DisplayName { get; set; }
21          IExecutionContext ExecutionContext { get; set; }
22          TemplateToken Timeout { get; }
23          bool TryUpdateDisplayName(out bool updated);
24          bool EvaluateDisplayName(DictionaryContextData contextData, IExecutionContext context, out bool updated);
25          Task RunAsync();
26      }
27      [ServiceLocator(Default = typeof(StepsRunner))]
28      public interface IStepsRunner : IRunnerService
29      {
30          Task RunAsync(IExecutionContext Context);
31      }
32      public sealed class StepsRunner : RunnerService, IStepsRunner
33      {
34          public async Task RunAsync(IExecutionContext jobContext)
35          {
36              ArgUtil.NotNull(jobContext, nameof(jobContext));
37              ArgUtil.NotNull(jobContext.JobSteps, nameof(jobContext.JobSteps));
38              CancellationTokenRegistration? jobCancelRegister = null;
39              jobContext.JobContext.Status = (jobContext.Result ?? TaskResult.Succeeded).ToActionResult();
40              var scopeInputs = new Dictionary&lt;string, PipelineContextData&gt;(StringComparer.OrdinalIgnoreCase);
41              bool checkPostJobActions = false;
42              while (jobContext.JobSteps.Count &gt; 0 || !checkPostJobActions)
43              {
44                  if (jobContext.JobSteps.Count == 0 &amp;&amp; !checkPostJobActions)
45                  {
46                      checkPostJobActions = true;
47                      while (jobContext.PostJobSteps.TryPop(out var postStep))
48                      {
49                          jobContext.JobSteps.Enqueue(postStep);
50                      }
51                      continue;
52                  }
53                  var step = jobContext.JobSteps.Dequeue();
54                  Trace.Info($&quot;Processing step: DisplayName=&#x27;{step.DisplayName}&#x27;&quot;);
55                  ArgUtil.NotNull(step.ExecutionContext, nameof(step.ExecutionContext));
56                  ArgUtil.NotNull(step.ExecutionContext.Global, nameof(step.ExecutionContext.Global));
57                  ArgUtil.NotNull(step.ExecutionContext.Global.Variables, nameof(step.ExecutionContext.Global.Variables));
58                  step.ExecutionContext.Start();
59                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;AlwaysFunction&gt;(PipelineTemplateConstants.Always, 0, 0));
60                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;CancelledFunction&gt;(PipelineTemplateConstants.Cancelled, 0, 0));
61                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;FailureFunction&gt;(PipelineTemplateConstants.Failure, 0, 0));
62                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;SuccessFunction&gt;(PipelineTemplateConstants.Success, 0, 0));
63                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;HashFilesFunction&gt;(PipelineTemplateConstants.HashFiles, 1, byte.MaxValue));
64                  step.ExecutionContext.ExpressionValues[&quot;steps&quot;] = step.ExecutionContext.Global.StepsContext.GetScope(step.ExecutionContext.ScopeName);
65  #if OS_WINDOWS
66                  var envContext = new DictionaryContextData();
67  #else
68                  var envContext = new CaseSensitiveDictionaryContextData();
69  #endif
70                  step.ExecutionContext.ExpressionValues[&quot;env&quot;] = envContext;
71                  foreach (var pair in step.ExecutionContext.Global.EnvironmentVariables)
72                  {
73                      envContext[pair.Key] = new StringContextData(pair.Value ?? string.Empty);
74                  }
75                  bool evaluateStepEnvFailed = false;
76                  if (step is IActionRunner actionStep)
77                  {
78                      step.ExecutionContext.SetGitHubContext(&quot;action&quot;, actionStep.Action.Name);
79                      try
80                      {
81                          var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator();
82                          var actionEnvironment = templateEvaluator.EvaluateStepEnvironment(actionStep.Action.Environment, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions, VarUtil.EnvironmentVariableKeyComparer);
83                          foreach (var env in actionEnvironment)
84                          {
85                              envContext[env.Key] = new StringContextData(env.Value ?? string.Empty);
86                              step.ExecutionContext.StepEnvironmentOverrides.Add(env.Key);
87                          }
88                      }
89                      catch (Exception ex)
90                      {
91                          Trace.Info(&quot;Caught exception from expression for step.env&quot;);
92                          evaluateStepEnvFailed = true;
93                          step.ExecutionContext.Error(ex);
94                          CompleteStep(step, TaskResult.Failed);
95                      }
96                  }
97                  if (!evaluateStepEnvFailed)
98                  {
99                      try
100                      {
101                          if (!jobContext.CancellationToken.IsCancellationRequested)
102                          {
103                              jobCancelRegister = jobContext.CancellationToken.Register(() =&gt;
104                              {
105                                  jobContext.Result = HostContext.RunnerShutdownToken.IsCancellationRequested
106                                                      ? TaskResult.Failed
107                                                      : TaskResult.Canceled;
108                                  jobContext.JobContext.Status = jobContext.Result?.ToActionResult();
109                                  step.ExecutionContext.Debug($&quot;Re-evaluate condition on job cancellation for step: &#x27;{step.DisplayName}&#x27;.&quot;);
110                                  var conditionReTestTraceWriter = new ConditionTraceWriter(Trace, null); 
111                                  var conditionReTestResult = false;
112                                  if (HostContext.RunnerShutdownToken.IsCancellationRequested)
113                                  {
114                                      step.ExecutionContext.Debug($&quot;Skip Re-evaluate condition on runner shutdown.&quot;);
115                                  }
116                                  else
117                                  {
118                                      try
119                                      {
120                                          var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator(conditionReTestTraceWriter);
121                                          var condition = new BasicExpressionToken(null, null, null, step.Condition);
122                                          conditionReTestResult = templateEvaluator.EvaluateStepIf(condition, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions, step.ExecutionContext.ToExpressionState());
123                                      }
124                                      catch (Exception ex)
125                                      {
126                                          Trace.Info(&quot;Caught exception from expression when re-test condition on job cancellation.&quot;);
127                                          step.ExecutionContext.Error(ex);
128                                      }
129                                  }
130                                  if (!conditionReTestResult)
131                                  {
132                                      Trace.Info(&quot;Cancel current running step.&quot;);
133                                      step.ExecutionContext.CancelToken();
134                                  }
135                              });
136                          }
137                          else
138                          {
139                              if (jobContext.Result != TaskResult.Canceled)
140                              {
141                                  jobContext.Result = HostContext.RunnerShutdownToken.IsCancellationRequested
142                                      ? TaskResult.Failed
143                                      : TaskResult.Canceled;
144                                  jobContext.JobContext.Status = jobContext.Result?.ToActionResult();
145                              }
146                          }
147                          step.ExecutionContext.Debug($&quot;Evaluating condition for step: &#x27;{step.DisplayName}&#x27;&quot;);
148                          var conditionTraceWriter = new ConditionTraceWriter(Trace, step.ExecutionContext);
149                          var conditionResult = false;
150                          var conditionEvaluateError = default(Exception);
151                          if (HostContext.RunnerShutdownToken.IsCancellationRequested)
152                          {
153                              step.ExecutionContext.Debug($&quot;Skip evaluate condition on runner shutdown.&quot;);
154                          }
155                          else
156                          {
157                              step.TryUpdateDisplayName(out _);
158                              try
159                              {
160                                  var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator(conditionTraceWriter);
161                                  var condition = new BasicExpressionToken(null, null, null, step.Condition);
162                                  conditionResult = templateEvaluator.EvaluateStepIf(condition, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions, step.ExecutionContext.ToExpressionState());
163                              }
164                              catch (Exception ex)
165                              {
166                                  Trace.Info(&quot;Caught exception from expression.&quot;);
167                                  Trace.Error(ex);
168                                  conditionEvaluateError = ex;
169                              }
170                          }
171                          if (!conditionResult &amp;&amp; conditionEvaluateError == null)
172                          {
173                              Trace.Info(&quot;Skipping step due to condition evaluation.&quot;);
174                              CompleteStep(step, TaskResult.Skipped, resultCode: conditionTraceWriter.Trace);
175                          }
176                          else if (conditionEvaluateError != null)
177                          {
178                              step.ExecutionContext.Error(conditionEvaluateError);
179                              CompleteStep(step, TaskResult.Failed);
180                          }
181                          else
182                          {
183                              await RunStepAsync(step, jobContext.CancellationToken);
184                              CompleteStep(step);
185                          }
186                      }
187                      finally
188                      {
189                          if (jobCancelRegister != null)
190                          {
191                              jobCancelRegister?.Dispose();
192                              jobCancelRegister = null;
193                          }
194                      }
195                  }
196                  if (step.ExecutionContext.Result == TaskResult.Failed)
197                  {
198                      Trace.Info($&quot;Update job result with current step result &#x27;{step.ExecutionContext.Result}&#x27;.&quot;);
199                      jobContext.Result = TaskResultUtil.MergeTaskResults(jobContext.Result, step.ExecutionContext.Result.Value);
200                      jobContext.JobContext.Status = jobContext.Result?.ToActionResult();
201                  }
202                  else
203                  {
204                      Trace.Info($&quot;No need for updating job result with current step result &#x27;{step.ExecutionContext.Result}&#x27;.&quot;);
205                  }
206                  Trace.Info($&quot;Current state: job state = &#x27;{jobContext.Result}&#x27;&quot;);
207              }
208          }
209          private async Task RunStepAsync(IStep step, CancellationToken jobCancellationToken)
210          {
211              Trace.Info(&quot;Starting the step.&quot;);
212              step.ExecutionContext.Debug($&quot;Starting: {step.DisplayName}&quot;);
213              var timeoutMinutes = 0;
214              var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator();
215              try
216              {
217                  timeoutMinutes = templateEvaluator.EvaluateStepTimeout(step.Timeout, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions);
218              }
219              catch (Exception ex)
220              {
221                  Trace.Info(&quot;An error occurred when attempting to determine the step timeout.&quot;);
222                  Trace.Error(ex);
223                  step.ExecutionContext.Error(&quot;An error occurred when attempting to determine the step timeout.&quot;);
224                  step.ExecutionContext.Error(ex);
225              }
226              if (timeoutMinutes &gt; 0)
227              {
228                  var timeout = TimeSpan.FromMinutes(timeoutMinutes);
229                  step.ExecutionContext.SetTimeout(timeout);
230              }
231              await EncodingUtil.SetEncoding(HostContext, Trace, step.ExecutionContext.CancellationToken);
232              try
233              {
234                  await step.RunAsync();
235              }
236              catch (OperationCanceledException ex)
237              {
238                  if (step.ExecutionContext.CancellationToken.IsCancellationRequested &amp;&amp;
239                      !jobCancellationToken.IsCancellationRequested)
240                  {
241                      Trace.Error($&quot;Caught timeout exception from step: {ex.Message}&quot;);
242                      step.ExecutionContext.Error(&quot;The action has timed out.&quot;);
243                      step.ExecutionContext.Result = TaskResult.Failed;
244                  }
245                  else
246                  {
247                      Trace.Error($&quot;Caught cancellation exception from step: {ex}&quot;);
248                      step.ExecutionContext.Error(ex);
249                      step.ExecutionContext.Result = TaskResult.Canceled;
250                  }
251              }
252              catch (Exception ex)
253              {
254                  Trace.Error($&quot;Caught exception from step: {ex}&quot;);
255                  step.ExecutionContext.Error(ex);
256                  step.ExecutionContext.Result = TaskResult.Failed;
257              }
258              if (step.ExecutionContext.CommandResult != null)
259              {
260                  step.ExecutionContext.Result = TaskResultUtil.MergeTaskResults(step.ExecutionContext.Result, step.ExecutionContext.CommandResult.Value);
261              }
<span onclick='openModal()' class='match'>262              step.ExecutionContext.ApplyContinueOnError(step.ContinueOnError);
263              Trace.Info($&quot;Step result: {step.ExecutionContext.Result}&quot;);
264              step.ExecutionContext.Debug($&quot;Finishing: {step.DisplayName}&quot;);
</span>265          }
266          private void CompleteStep(IStep step, TaskResult? result = null, string resultCode = null)
267          {
268              var executionContext = step.ExecutionContext;
269              executionContext.Complete(result, resultCode: resultCode);
270          }
271      }
272  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-CompositeActionHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GitHub.DistributedTask.Expressions2;
7  using GitHub.DistributedTask.ObjectTemplating.Tokens;
8  using GitHub.DistributedTask.Pipelines.ContextData;
9  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
10  using GitHub.DistributedTask.WebApi;
11  using GitHub.Runner.Common;
12  using GitHub.Runner.Common.Util;
13  using GitHub.Runner.Sdk;
14  using GitHub.Runner.Worker.Container;
15  using GitHub.Runner.Worker.Container.ContainerHooks;
16  using GitHub.Runner.Worker.Expressions;
17  using Pipelines = GitHub.DistributedTask.Pipelines;
18  namespace GitHub.Runner.Worker.Handlers
19  {
20      [ServiceLocator(Default = typeof(CompositeActionHandler))]
21      public interface ICompositeActionHandler : IHandler
22      {
23          CompositeActionExecutionData Data { get; set; }
24      }
25      public sealed class CompositeActionHandler : Handler, ICompositeActionHandler
26      {
27          public CompositeActionExecutionData Data { get; set; }
28          public async Task RunAsync(ActionRunStage stage)
29          {
30              Trace.Entering();
31              ArgUtil.NotNull(ExecutionContext, nameof(ExecutionContext));
32              ArgUtil.NotNull(Inputs, nameof(Inputs));
33              List&lt;Pipelines.ActionStep&gt; steps;
34              if (stage == ActionRunStage.Pre)
35              {
36                  ArgUtil.NotNull(Data.PreSteps, nameof(Data.PreSteps));
37                  steps = Data.PreSteps;
38              }
39              else if (stage == ActionRunStage.Post)
40              {
41                  ArgUtil.NotNull(Data.PostSteps, nameof(Data.PostSteps));
42                  steps = new List&lt;Pipelines.ActionStep&gt;();
43                  foreach (var step in Data.PostSteps.ToList())
44                  {
45                      if (ExecutionContext.Root.EmbeddedStepsWithPostRegistered.ContainsKey(step.Id))
46                      {
47                          step.Condition = ExecutionContext.Root.EmbeddedStepsWithPostRegistered[step.Id];
48                          steps.Add(step);
49                      }
50                      else
51                      {
52                          Trace.Info($&quot;Skipping executing post step id: {step.Id}, name: ${step.DisplayName}&quot;);
53                      }
54                  }
55              }
56              else
57              {
58                  ArgUtil.NotNull(Data.Steps, nameof(Data.Steps));
59                  steps = Data.Steps;
60              }
61              if (stage == ActionRunStage.Main)
62              {
63                  var hasRunsStep = false;
64                  var hasUsesStep = false;
65                  foreach (var step in steps)
66                  {
67                      if (step.Reference.Type == Pipelines.ActionSourceType.Script)
68                      {
69                          hasRunsStep = true;
70                      }
71                      else
72                      {
73                          hasUsesStep = true;
74                      }
75                  }
76                  ExecutionContext.StepTelemetry.HasPreStep = Data.HasPre;
77                  ExecutionContext.StepTelemetry.HasPostStep = Data.HasPost;
78                  ExecutionContext.StepTelemetry.HasRunsStep = hasRunsStep;
79                  ExecutionContext.StepTelemetry.HasUsesStep = hasUsesStep;
80                  ExecutionContext.StepTelemetry.StepCount = steps.Count;
81              }
82              ExecutionContext.StepTelemetry.Type = &quot;composite&quot;;
83              try
84              {
85                  var inputsData = new DictionaryContextData();
86                  foreach (var i in Inputs)
87                  {
88                      inputsData[i.Key] = new StringContextData(i.Value);
89                  }
90                  var childScopeName = ExecutionContext.GetFullyQualifiedContextName();
91                  if (string.IsNullOrEmpty(childScopeName))
92                  {
93                      childScopeName = $&quot;__{Guid.NewGuid()}&quot;;
94                  }
95                  var embeddedSteps = new List&lt;IStep&gt;();
96                  if (LocalActionContainerSetupSteps != null &amp;&amp; LocalActionContainerSetupSteps.Count &gt; 0)
97                  {
98                      foreach (var step in LocalActionContainerSetupSteps)
99                      {
100                          ArgUtil.NotNull(step, step.DisplayName);
101                          var stepId = $&quot;__{Guid.NewGuid()}&quot;;
102                          step.ExecutionContext = ExecutionContext.CreateEmbeddedChild(childScopeName, stepId, Guid.NewGuid(), stage);
103                          embeddedSteps.Add(step);
104                      }
105                  }
106                  foreach (Pipelines.ActionStep stepData in steps)
107                  {
108                      string siblingScopeName = null;
109                      if (!String.IsNullOrEmpty(ExecutionContext.SiblingScopeName) &amp;&amp; stage == ActionRunStage.Post)
110                      {
111                          siblingScopeName = $&quot;{ExecutionContext.SiblingScopeName}.{stepData.ContextName}&quot;;
112                      }
113                      var step = HostContext.CreateService&lt;IActionRunner&gt;();
114                      step.Action = stepData;
115                      step.Stage = stage;
116                      step.Condition = stepData.Condition;
117                      ExecutionContext.Root.EmbeddedIntraActionState.TryGetValue(step.Action.Id, out var intraActionState);
118                      step.ExecutionContext = ExecutionContext.CreateEmbeddedChild(childScopeName, stepData.ContextName, step.Action.Id, stage, intraActionState: intraActionState, siblingScopeName: siblingScopeName);
119                      step.ExecutionContext.ExpressionValues[&quot;inputs&quot;] = inputsData;
120                      if (!String.IsNullOrEmpty(ExecutionContext.SiblingScopeName))
121                      {
122                          step.ExecutionContext.ExpressionValues[&quot;steps&quot;] = ExecutionContext.Global.StepsContext.GetScope(ExecutionContext.SiblingScopeName);
123                      }
124                      else
125                      {
126                          step.ExecutionContext.ExpressionValues[&quot;steps&quot;] = ExecutionContext.Global.StepsContext.GetScope(childScopeName);
127                      }
128                      var gitHubContext = step.ExecutionContext.ExpressionValues[&quot;github&quot;] as GitHubContext;
129                      ArgUtil.NotNull(gitHubContext, nameof(gitHubContext));
130                      gitHubContext = gitHubContext.ShallowCopy();
131                      step.ExecutionContext.ExpressionValues[&quot;github&quot;] = gitHubContext;
132                      step.ExecutionContext.SetGitHubContext(&quot;action_path&quot;, ActionDirectory);
133                      embeddedSteps.Add(step);
134                  }
135                  await RunStepsAsync(embeddedSteps, stage);
136                  ExecutionContext.ExpressionValues[&quot;inputs&quot;] = inputsData;
137                  ExecutionContext.ExpressionValues[&quot;steps&quot;] = ExecutionContext.Global.StepsContext.GetScope(childScopeName);
138                  ProcessOutputs();
139              }
140              catch (Exception ex)
141              {
142                  Trace.Error($&quot;Caught exception from composite steps {nameof(CompositeActionHandler)}: {ex}&quot;);
143                  ExecutionContext.Error(ex);
144                  ExecutionContext.Result = TaskResult.Failed;
145              }
146          }
147          private void ProcessOutputs()
148          {
149              ArgUtil.NotNull(ExecutionContext, nameof(ExecutionContext));
150              if (Data.Outputs != null)
151              {
152                  var actionManifestManager = HostContext.GetService&lt;IActionManifestManager&gt;();
153                  var evaluateContext = new Dictionary&lt;string, PipelineContextData&gt;(StringComparer.OrdinalIgnoreCase);
154                  foreach (var pair in ExecutionContext.ExpressionValues)
155                  {
156                      evaluateContext[pair.Key] = pair.Value;
157                  }
158                  DictionaryContextData actionOutputs = actionManifestManager.EvaluateCompositeOutputs(ExecutionContext, Data.Outputs, evaluateContext);
159                  foreach (var pair in actionOutputs)
160                  {
161                      var outputName = pair.Key;
162                      var outputDefinition = pair.Value as DictionaryContextData;
163                      if (outputDefinition.TryGetValue(&quot;value&quot;, out var val))
164                      {
165                          var outputValue = val.AssertString(&quot;output value&quot;);
166                          ExecutionContext.SetOutput(outputName, outputValue.Value, out _);
167                      }
168                  }
169              }
170          }
171          private async Task RunStepsAsync(List&lt;IStep&gt; embeddedSteps, ActionRunStage stage)
172          {
173              ArgUtil.NotNull(embeddedSteps, nameof(embeddedSteps));
174              foreach (IStep step in embeddedSteps)
175              {
176                  Trace.Info($&quot;Processing embedded step: DisplayName=&#x27;{step.DisplayName}&#x27;&quot;);
177                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;HashFilesFunction&gt;(PipelineTemplateConstants.HashFiles, 1, byte.MaxValue));
178                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;AlwaysFunction&gt;(PipelineTemplateConstants.Always, 0, 0));
179                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;CancelledFunction&gt;(PipelineTemplateConstants.Cancelled, 0, 0));
180                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;FailureFunction&gt;(PipelineTemplateConstants.Failure, 0, 0));
181                  step.ExecutionContext.ExpressionFunctions.Add(new FunctionInfo&lt;SuccessFunction&gt;(PipelineTemplateConstants.Success, 0, 0));
182                  var actionResult = ExecutionContext.Result?.ToActionResult() ?? ActionResult.Success;
183                  step.ExecutionContext.SetGitHubContext(&quot;action_status&quot;, actionResult.ToString().ToLowerInvariant());
184                  Trace.Info(&quot;Initialize Env context for embedded step&quot;);
185  #if OS_WINDOWS
186                  var envContext = new DictionaryContextData();
187  #else
188                  var envContext = new CaseSensitiveDictionaryContextData();
189  #endif
190                  step.ExecutionContext.ExpressionValues[&quot;env&quot;] = envContext;
191                  foreach (var pair in ExecutionContext.Global.EnvironmentVariables)
192                  {
193                      envContext[pair.Key] = new StringContextData(pair.Value ?? string.Empty);
194                  }
195                  if (ExecutionContext.ExpressionValues.TryGetValue(&quot;env&quot;, out var envContextData))
196                  {
197  #if OS_WINDOWS
198                      var dict = envContextData as DictionaryContextData;
199  #else
200                      var dict = envContextData as CaseSensitiveDictionaryContextData;
201  #endif
202                      foreach (var pair in dict)
203                      {
204                          if (ExecutionContext.StepEnvironmentOverrides.Contains(pair.Key))
205                          {
206                              envContext[pair.Key] = pair.Value;
207                          }
208                      }
209                  }
210                  try
211                  {
212                      if (step is IActionRunner actionStep)
213                      {
214                          step.ExecutionContext.StepEnvironmentOverrides.AddRange(ExecutionContext.StepEnvironmentOverrides);
215                          var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator();
216                          var actionEnvironment = templateEvaluator.EvaluateStepEnvironment(actionStep.Action.Environment, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions, Common.Util.VarUtil.EnvironmentVariableKeyComparer);
217                          foreach (var env in actionEnvironment)
218                          {
219                              envContext[env.Key] = new StringContextData(env.Value ?? string.Empty);
220                              step.ExecutionContext.StepEnvironmentOverrides.Add(env.Key);
221                          }
222                      }
223                  }
224                  catch (Exception ex)
225                  {
226                      Trace.Info(&quot;Caught exception from expression for embedded step.env&quot;);
227                      step.ExecutionContext.Error(ex);
228                      SetStepConclusion(step, TaskResult.Failed);
229                  }
230                  CancellationTokenRegistration? jobCancelRegister = null;
231                  try
232                  {
233                      if (!ExecutionContext.Root.CancellationToken.IsCancellationRequested)
234                      {
235                          jobCancelRegister = ExecutionContext.Root.CancellationToken.Register(() =&gt;
236                          {
237                              ExecutionContext.Root.Result = TaskResult.Canceled;
238                              ExecutionContext.Root.JobContext.Status = ExecutionContext.Root.Result?.ToActionResult();
239                              step.ExecutionContext.Debug($&quot;Re-evaluate condition on job cancellation for step: &#x27;{step.DisplayName}&#x27;.&quot;);
240                              var conditionReTestTraceWriter = new ConditionTraceWriter(Trace, null); 
241                              var conditionReTestResult = false;
242                              if (HostContext.RunnerShutdownToken.IsCancellationRequested)
243                              {
244                                  step.ExecutionContext.Debug($&quot;Skip Re-evaluate condition on runner shutdown.&quot;);
245                              }
246                              else
247                              {
248                                  try
249                                  {
250                                      var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator(conditionReTestTraceWriter);
251                                      var condition = new BasicExpressionToken(null, null, null, step.Condition);
252                                      conditionReTestResult = templateEvaluator.EvaluateStepIf(condition, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions, step.ExecutionContext.ToExpressionState());
253                                  }
254                                  catch (Exception ex)
255                                  {
256                                      Trace.Info(&quot;Caught exception from expression when re-test condition on job cancellation.&quot;);
257                                      step.ExecutionContext.Error(ex);
258                                  }
259                              }
260                              if (!conditionReTestResult)
261                              {
262                                  Trace.Info(&quot;Cancel current running step.&quot;);
263                                  step.ExecutionContext.CancelToken();
264                              }
265                          });
266                      }
267                      else
268                      {
269                          if (ExecutionContext.Root.Result != TaskResult.Canceled)
270                          {
271                              ExecutionContext.Root.Result = TaskResult.Canceled;
272                              ExecutionContext.Root.JobContext.Status = ExecutionContext.Root.Result?.ToActionResult();
273                          }
274                      }
275                      step.ExecutionContext.Debug($&quot;Evaluating condition for step: &#x27;{step.DisplayName}&#x27;&quot;);
276                      var conditionTraceWriter = new ConditionTraceWriter(Trace, step.ExecutionContext);
277                      var conditionResult = false;
278                      var conditionEvaluateError = default(Exception);
279                      if (HostContext.RunnerShutdownToken.IsCancellationRequested)
280                      {
281                          step.ExecutionContext.Debug($&quot;Skip evaluate condition on runner shutdown.&quot;);
282                      }
283                      else
284                      {
285                          try
286                          {
287                              var templateEvaluator = step.ExecutionContext.ToPipelineTemplateEvaluator(conditionTraceWriter);
288                              var condition = new BasicExpressionToken(null, null, null, step.Condition);
289                              conditionResult = templateEvaluator.EvaluateStepIf(condition, step.ExecutionContext.ExpressionValues, step.ExecutionContext.ExpressionFunctions, step.ExecutionContext.ToExpressionState());
290                          }
291                          catch (Exception ex)
292                          {
293                              Trace.Info(&quot;Caught exception from expression.&quot;);
294                              Trace.Error(ex);
295                              conditionEvaluateError = ex;
296                          }
297                      }
298                      if (!conditionResult &amp;&amp; conditionEvaluateError == null)
299                      {
300                          Trace.Info(&quot;Skipping step due to condition evaluation.&quot;);
301                          SetStepConclusion(step, TaskResult.Skipped);
302                          continue;
303                      }
304                      else if (conditionEvaluateError != null)
305                      {
306                          step.ExecutionContext.Error(conditionEvaluateError);
307                          SetStepConclusion(step, TaskResult.Failed);
308                          ExecutionContext.Result = TaskResult.Failed;
309                          break;
310                      }
311                      else
312                      {
313                          await RunStepAsync(step);
314                      }
315                  }
316                  finally
317                  {
318                      if (jobCancelRegister != null)
319                      {
320                          jobCancelRegister?.Dispose();
321                          jobCancelRegister = null;
322                      }
323                  }
324                  if (step.ExecutionContext.Result == TaskResult.Failed || step.ExecutionContext.Result == TaskResult.Canceled)
325                  {
326                      Trace.Info($&quot;Update job result with current composite step result &#x27;{step.ExecutionContext.Result}&#x27;.&quot;);
327                      ExecutionContext.Result = TaskResultUtil.MergeTaskResults(ExecutionContext.Result, step.ExecutionContext.Result.Value);
328                  }
329                  step.ExecutionContext.UpdateGlobalStepsContext();
330              }
331          }
332          private async Task RunStepAsync(IStep step)
333          {
334              Trace.Info($&quot;Starting: {step.DisplayName}&quot;);
335              step.ExecutionContext.Debug($&quot;Starting: {step.DisplayName}&quot;);
336              await Common.Util.EncodingUtil.SetEncoding(HostContext, Trace, step.ExecutionContext.CancellationToken);
337              try
338              {
339                  await step.RunAsync();
340              }
341              catch (OperationCanceledException ex)
342              {
343                  if (step.ExecutionContext.CancellationToken.IsCancellationRequested &amp;&amp;
344                      !ExecutionContext.Root.CancellationToken.IsCancellationRequested)
345                  {
346                      Trace.Error($&quot;Caught timeout exception from step: {ex.Message}&quot;);
347                      step.ExecutionContext.Error(&quot;The action has timed out.&quot;);
348                      SetStepConclusion(step, TaskResult.Failed);
349                  }
350                  else
351                  {
352                      Trace.Error($&quot;Caught cancellation exception from step: {ex}&quot;);
353                      step.ExecutionContext.Error(ex);
354                      SetStepConclusion(step, TaskResult.Canceled);
355                  }
356              }
357              catch (Exception ex)
358              {
359                  Trace.Error($&quot;Caught exception from step: {ex}&quot;);
360                  step.ExecutionContext.Error(ex);
361                  SetStepConclusion(step, TaskResult.Failed);
362              }
363              if (step.ExecutionContext.CommandResult != null)
364              {
365                  SetStepConclusion(step, Common.Util.TaskResultUtil.MergeTaskResults(step.ExecutionContext.Result, step.ExecutionContext.CommandResult.Value));
366              }
<span onclick='openModal()' class='match'>367              step.ExecutionContext.ApplyContinueOnError(step.ContinueOnError);
368              Trace.Info($&quot;Step result: {step.ExecutionContext.Result}&quot;);
369              step.ExecutionContext.Debug($&quot;Finished: {step.DisplayName}&quot;);
</span>370              step.ExecutionContext.PublishStepTelemetry();
371          }
372          private void SetStepConclusion(IStep step, TaskResult result)
373          {
374              step.ExecutionContext.Result = result;
375              step.ExecutionContext.UpdateGlobalStepsContext();
376          }
377      }
378  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-StepsRunner.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-CompositeActionHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>262              step.ExecutionContext.ApplyContinueOnError(step.ContinueOnError);
263              Trace.Info($&quot;Step result: {step.ExecutionContext.Result}&quot;);
264              step.ExecutionContext.Debug($&quot;Finishing: {step.DisplayName}&quot;);
</pre></code></div>
                <div class="column column_space"><pre><code>367              step.ExecutionContext.ApplyContinueOnError(step.ContinueOnError);
368              Trace.Info($&quot;Step result: {step.ExecutionContext.Result}&quot;);
369              step.ExecutionContext.Debug($&quot;Finished: {step.DisplayName}&quot;);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    