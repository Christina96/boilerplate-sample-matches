
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRawCopyStream.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Microsoft.Extensions.Logging;
7  using Npgsql.BackendMessages;
8  using Npgsql.Internal;
9  using static Npgsql.Util.Statics;
10  #pragma warning disable 1591
11  namespace Npgsql;
12  public sealed class NpgsqlRawCopyStream : Stream, ICancelable
13  {
14      #region Fields and Properties
15      NpgsqlConnector _connector;
16      NpgsqlReadBuffer _readBuf;
17      NpgsqlWriteBuffer _writeBuf;
18      int _leftToReadInDataMsg;
19      bool _isDisposed, _isConsumed;
20      bool _canRead;
21      bool _canWrite;
22      internal bool IsBinary { get; private set; }
23      public override bool CanWrite => _canWrite;
24      public override bool CanRead => _canRead;
25      public override bool CanTimeout => true;
26      public override int WriteTimeout
27      {
28          get => (int) _writeBuf.Timeout.TotalMilliseconds;
29          set => _writeBuf.Timeout = TimeSpan.FromMilliseconds(value);
30      }
31      public override int ReadTimeout
32      {
33          get => (int) _readBuf.Timeout.TotalMilliseconds;
34          set
35          {
36              _readBuf.Timeout = TimeSpan.FromMilliseconds(value);
37              _connector.UserTimeout = value;
38          }
39      }
40      internal static readonly byte[] BinarySignature =
41      {
42          (byte)'P',(byte)'G',(byte)'C',(byte)'O',(byte)'P',(byte)'Y',
43          (byte)'\n', 255, (byte)'\r', (byte)'\n', 0
44      };
45      readonly ILogger _copyLogger;
46      #endregion
47      #region Constructor / Initializer
48      internal NpgsqlRawCopyStream(NpgsqlConnector connector)
49      {
50          _connector = connector;
51          _readBuf = connector.ReadBuffer;
52          _writeBuf = connector.WriteBuffer;
53          _copyLogger = connector.LoggingConfiguration.CopyLogger;
54      }
55      internal async Task Init(string copyCommand, bool async, CancellationToken cancellationToken = default)
56      {
57          await _connector.WriteQuery(copyCommand, async, cancellationToken);
58          await _connector.Flush(async, cancellationToken);
59          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
60          var msg = await _connector.ReadMessage(async);
61          switch (msg.Code)
62          {
63          case BackendMessageCode.CopyInResponse:
64              var copyInResponse = (CopyInResponseMessage) msg;
65              IsBinary = copyInResponse.IsBinary;
66              _canWrite = true;
67              _writeBuf.StartCopyMode();
68              break;
69          case BackendMessageCode.CopyOutResponse:
70              var copyOutResponse = (CopyOutResponseMessage) msg;
71              IsBinary = copyOutResponse.IsBinary;
72              _canRead = true;
73              break;
74          case BackendMessageCode.CommandComplete:
75              throw new InvalidOperationException(
76                  "This API only supports import/export from the client, i.e. COPY commands containing TO/FROM STDIN. " +
77                  "To import/export with files on your PostgreSQL machine, simply execute the command with ExecuteNonQuery. " +
78                  "Note that your data has been successfully imported/exported.");
79          default:
80              throw _connector.UnexpectedMessageReceived(msg.Code);
81          }
82      }
83      #endregion
84      #region Write
85      public override void Write(byte[] buffer, int offset, int count)
86      {
87          ValidateArguments(buffer, offset, count);
88          Write(new ReadOnlySpan<byte>(buffer, offset, count));
89      }
90      public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
91      {
92          ValidateArguments(buffer, offset, count);
93          return WriteAsync(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
94      }
95  #if NETSTANDARD2_0
96      public void Write(ReadOnlySpan<byte> buffer)
97  #else
98      public override void Write(ReadOnlySpan<byte> buffer)
99  #endif
100      {
101          CheckDisposed();
102          if (!CanWrite)
103              throw new InvalidOperationException("Stream not open for writing");
104          if (buffer.Length == 0) { return; }
105          if (buffer.Length <= _writeBuf.WriteSpaceLeft)
106          {
107              _writeBuf.WriteBytes(buffer);
108              return;
109          }
110          try
111          {
112              Flush();
113              if (buffer.Length <= _writeBuf.WriteSpaceLeft)
114              {
115                  _writeBuf.WriteBytes(buffer);
116                  return;
117              }
118              _writeBuf.DirectWrite(buffer);
119          }
120          catch (Exception e)
121          {
122              _connector.Break(e);
123              throw;
124          }
125      }
126  #if NETSTANDARD2_0
127      public ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
128  #else
129      public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
130  #endif
131      {
132          CheckDisposed();
133          if (!CanWrite)
134              throw new InvalidOperationException("Stream not open for writing");
135          cancellationToken.ThrowIfCancellationRequested();
136          using (NoSynchronizationContextScope.Enter())
137              return WriteAsyncInternal(buffer, cancellationToken);
138          async ValueTask WriteAsyncInternal(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
139          {
140              if (buffer.Length == 0)
141                  return;
142              if (buffer.Length <= _writeBuf.WriteSpaceLeft)
143              {
144                  _writeBuf.WriteBytes(buffer.Span);
145                  return;
146              }
147              try
148              {
149                  await FlushAsync(true, cancellationToken);
150                  if (buffer.Length <= _writeBuf.WriteSpaceLeft)
151                  {
152                      _writeBuf.WriteBytes(buffer.Span);
153                      return;
154                  }
155                  await _writeBuf.DirectWrite(buffer, true, cancellationToken);
156              }
157              catch (Exception e)
158              {
159                  _connector.Break(e);
160                  throw;
161              }
162          }
163      }
164      public override void Flush() => FlushAsync(false).GetAwaiter().GetResult();
165      public override Task FlushAsync(CancellationToken cancellationToken)
166      {
167          if (cancellationToken.IsCancellationRequested)
168              return Task.FromCanceled(cancellationToken);
169          using (NoSynchronizationContextScope.Enter())
170              return FlushAsync(true, cancellationToken);
171      }
172      Task FlushAsync(bool async, CancellationToken cancellationToken = default)
173      {
174          CheckDisposed();
175          return _writeBuf.Flush(async, cancellationToken);
176      }
177      #endregion
178      #region Read
179      public override int Read(byte[] buffer, int offset, int count)
180      {
181          ValidateArguments(buffer, offset, count);
182          return Read(new Span<byte>(buffer, offset, count));
183      }
184      public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
185      {
186          ValidateArguments(buffer, offset, count);
187          return ReadAsync(new Memory<byte>(buffer, offset, count), cancellationToken).AsTask();
188      }
189  #if NETSTANDARD2_0
190      public int Read(Span<byte> span)
191  #else
192      public override int Read(Span<byte> span)
193  #endif
194      {
195          CheckDisposed();
196          if (!CanRead)
197              throw new InvalidOperationException("Stream not open for reading");
198          var count = ReadCore(span.Length, false).GetAwaiter().GetResult();
199          if (count > 0)
200              _readBuf.ReadBytes(span.Slice(0, count));
201          return count;
202      }
203  #if NETSTANDARD2_0
204      public ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
205  #else
206      public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken)
207  #endif
208      {
209          CheckDisposed();
210          if (!CanRead)
211              throw new InvalidOperationException("Stream not open for reading");
212          cancellationToken.ThrowIfCancellationRequested();
213          using (NoSynchronizationContextScope.Enter())
214              return ReadAsyncInternal();
215          async ValueTask<int> ReadAsyncInternal()
216          {
217              var count = await ReadCore(buffer.Length, true, cancellationToken);
218              if (count > 0)
219                  _readBuf.ReadBytes(buffer.Slice(0, count).Span);
220              return count;
221          }
222      }
223      async ValueTask<int> ReadCore(int count, bool async, CancellationToken cancellationToken = default)
224      {
225          if (_isConsumed)
226              return 0;
227          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
228          if (_leftToReadInDataMsg == 0)
229          {
230              IBackendMessage msg;
231              try
232              {
233                  msg = await _connector.ReadMessage(async);
234              }
235              catch
236              {
237                  if (!_isDisposed)
238                      Cleanup();
239                  throw;
240              }
241              switch (msg.Code)
242              {
243              case BackendMessageCode.CopyData:
244                  _leftToReadInDataMsg = ((CopyDataMessage)msg).Length;
245                  break;
246              case BackendMessageCode.CopyDone:
247                  Expect<CommandCompleteMessage>(await _connector.ReadMessage(async), _connector);
248                  Expect<ReadyForQueryMessage>(await _connector.ReadMessage(async), _connector);
249                  _isConsumed = true;
250                  return 0;
251              default:
252                  throw _connector.UnexpectedMessageReceived(msg.Code);
253              }
254          }
255          Debug.Assert(_leftToReadInDataMsg > 0);
256          if (_readBuf.ReadBytesLeft == 0)
257              await _readBuf.ReadMore(async);
258          Debug.Assert(_readBuf.ReadBytesLeft > 0);
259          var maxCount = Math.Min(_readBuf.ReadBytesLeft, _leftToReadInDataMsg);
260          if (count > maxCount)
261              count = maxCount;
262          _leftToReadInDataMsg -= count;
263          return count;
264      }
265      #endregion
266      #region Cancel
267      public void Cancel() => Cancel(false).GetAwaiter().GetResult();
268      public Task CancelAsync()
269      {
270          using (NoSynchronizationContextScope.Enter())
271              return Cancel(true);
272      }
273      async Task Cancel(bool async)
274      {
275          CheckDisposed();
276          if (CanWrite)
277          {
278              _writeBuf.EndCopyMode();
279              _writeBuf.Clear();
280              await _connector.WriteCopyFail(async);
281              await _connector.Flush(async);
282              try
283              {
284                  var msg = await _connector.ReadMessage(async);
285                  throw _connector.Break(
286                      new NpgsqlException("Expected ErrorResponse when cancelling COPY but got: " + msg.Code));
287              }
288              catch (PostgresException e)
289              {
290                  Cleanup();
291                  if (e.SqlState != PostgresErrorCodes.QueryCanceled)
292                      throw;
293              }
294          }
295          else
296          {
297              _connector.PerformPostgresCancellation();
298          }
299      }
300      #endregion
301      #region Dispose
302      protected override void Dispose(bool disposing) => DisposeAsync(disposing, false).GetAwaiter().GetResult();
303  #if NETSTANDARD2_0
304      public ValueTask DisposeAsync()
305  #else
306      public override ValueTask DisposeAsync()
307  #endif
308          => DisposeAsync(disposing: true, async: true);
309      async ValueTask DisposeAsync(bool disposing, bool async)
310      {
311          if (_isDisposed || !disposing)
312              return;
313          try
314          {
315              _connector.CurrentCopyOperation = null;
316              if (CanWrite)
317              {
318                  await FlushAsync(async);
319                  _writeBuf.EndCopyMode();
320                  await _connector.WriteCopyDone(async);
321                  await _connector.Flush(async);
322                  Expect<CommandCompleteMessage>(await _connector.ReadMessage(async), _connector);
323                  Expect<ReadyForQueryMessage>(await _connector.ReadMessage(async), _connector);
324              }
325              else
326              {
327                  if (!_isConsumed)
328                  {
329                      try
330                      {
331                          if (_leftToReadInDataMsg > 0)
332                          {
333                              await _readBuf.Skip(_leftToReadInDataMsg, async);
334                          }
335                          _connector.SkipUntil(BackendMessageCode.ReadyForQuery);
336                      }
337                      catch (OperationCanceledException e) when (e.InnerException is PostgresException pg && pg.SqlState == PostgresErrorCodes.QueryCanceled)
338                      {
339                          LogMessages.CopyOperationCancelled(_copyLogger, _connector.Id);
340                      }
341                      catch (Exception e)
342                      {
343                          LogMessages.ExceptionWhenDisposingCopyOperation(_copyLogger, _connector.Id, e);
344                      }
345                  }
346              }
347          }
348          finally
349          {
350              Cleanup();
351          }
352      }
353  #pragma warning disable CS8625
354      void Cleanup()
355      {
356          Debug.Assert(!_isDisposed);
357          LogMessages.CopyOperationCompleted(_copyLogger, _connector.Id);
358          _connector.EndUserAction();
359          _connector.CurrentCopyOperation = null;
360          _connector.Connection?.EndBindingScope(ConnectorBindingScope.Copy);
361          _connector = null;
362          _readBuf = null;
363          _writeBuf = null;
<span onclick='openModal()' class='match'>364          _isDisposed = true;
365      }
366  #pragma warning restore CS8625
367      void CheckDisposed()
368      {
369          if (_isDisposed) {
</span>370              throw new ObjectDisposedException(nameof(NpgsqlRawCopyStream), "The COPY operation has already ended.");
371          }
372      }
373      #endregion
374      #region Unsupported
375      public override bool CanSeek => false;
376      public override long Seek(long offset, SeekOrigin origin)
377      {
378          throw new NotSupportedException();
379      }
380      public override void SetLength(long value)
381      {
382          throw new NotSupportedException();
383      }
384      public override long Length => throw new NotSupportedException();
385      public override long Position
386      {
387          get => throw new NotSupportedException();
388          set => throw new NotSupportedException();
389      }
390      #endregion
391      #region Input validation
392      static void ValidateArguments(byte[] buffer, int offset, int count)
393      {
394          if (buffer == null)
395              throw new ArgumentNullException(nameof(buffer));
396          if (offset < 0)
397              throw new ArgumentNullException(nameof(offset));
398          if (count < 0)
399              throw new ArgumentNullException(nameof(count));
400          if (buffer.Length - offset < count)
401              throw new ArgumentException("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
402      }
403      #endregion
404  }
405  public sealed class NpgsqlCopyTextWriter : StreamWriter, ICancelable
406  {
407      internal NpgsqlCopyTextWriter(NpgsqlConnector connector, NpgsqlRawCopyStream underlying) : base(underlying)
408      {
409          if (underlying.IsBinary)
410              throw connector.Break(new Exception("Can't use a binary copy stream for text writing"));
411      }
412      public void Cancel()
413          => ((NpgsqlRawCopyStream)BaseStream).Cancel();
414      public Task CancelAsync()
415      {
416          using (NoSynchronizationContextScope.Enter())
417              return ((NpgsqlRawCopyStream)BaseStream).CancelAsync();
418      }
419  #if NETSTANDARD2_0
420      public ValueTask DisposeAsync()
421      {
422          Dispose();
423          return default;
424      }
425  #endif
426  }
427  public sealed class NpgsqlCopyTextReader : StreamReader, ICancelable
428  {
429      internal NpgsqlCopyTextReader(NpgsqlConnector connector, NpgsqlRawCopyStream underlying) : base(underlying)
430      {
431          if (underlying.IsBinary)
432              throw connector.Break(new Exception("Can't use a binary copy stream for text reading"));
433      }
434      public void Cancel()
435          => ((NpgsqlRawCopyStream)BaseStream).Cancel();
436      public Task CancelAsync()
437      {
438          using (NoSynchronizationContextScope.Enter())
439              return ((NpgsqlRawCopyStream)BaseStream).CancelAsync();
440      }
441      public ValueTask DisposeAsync()
442      {
443          Dispose();
444          return default;
445      }
446  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-VolatileResourceManager.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics;
3  using System.Threading;
4  using System.Transactions;
5  using Microsoft.Extensions.Logging;
6  using Npgsql.Internal;
7  namespace Npgsql;
8  sealed class VolatileResourceManager : ISinglePhaseNotification
9  {
10      NpgsqlConnector _connector;
11      Transaction _transaction;
12      readonly string _txId;
13      NpgsqlTransaction _localTx = null!;
14      string? _preparedTxName;
15      bool IsPrepared => _preparedTxName != null;
16      bool _isDisposed;
17      readonly ILogger _transactionLogger;
18      const int MaximumRollbackAttempts = 20;
19      internal VolatileResourceManager(NpgsqlConnection connection, Transaction transaction)
20      {
21          _connector = connection.Connector!;
22          _transaction = transaction;
23          _txId = transaction.TransactionInformation.LocalIdentifier;
24          _transactionLogger = _connector.LoggingConfiguration.TransactionLogger;
25      }
26      internal void Init()
27          => _localTx = _connector.Connection!.BeginTransaction(ConvertIsolationLevel(_transaction.IsolationLevel));
28      public void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment)
29      {
30          CheckDisposed();
31          LogMessages.CommittingSinglePhaseTransaction(_transactionLogger, _txId, _connector.Id);
32          try
33          {
34              _localTx.Commit();
35              singlePhaseEnlistment.Committed();
36          }
37          catch (PostgresException e)
38          {
39              singlePhaseEnlistment.Aborted(e);
40          }
41          catch (Exception e)
42          {
43              singlePhaseEnlistment.InDoubt(e);
44          }
45          finally
46          {
47              Dispose();
48          }
49      }
50      public void Prepare(PreparingEnlistment preparingEnlistment)
51      {
52          CheckDisposed();
53          LogMessages.PreparingTwoPhaseTransaction(_transactionLogger, _txId, _connector.Id);
54          _preparedTxName = $"{_transaction.TransactionInformation.DistributedIdentifier}/{_connector.BackendProcessId}";
55          try
56          {
57              using (_connector.StartUserAction())
58                  _connector.ExecuteInternalCommand($"PREPARE TRANSACTION '{_preparedTxName}'");
59              if (_connector.Connection != null)
60                  _connector.Connection.EnlistedTransaction = null;
61              preparingEnlistment.Prepared();
62          }
63          catch (Exception e)
64          {
65              Dispose();
66              preparingEnlistment.ForceRollback(e);
67          }
68      }
69      public void Commit(Enlistment enlistment)
70      {
71          CheckDisposed();
72          LogMessages.CommittingTwoPhaseTransaction(_transactionLogger, _txId, _connector.Id);
73          try
74          {
75              if (_connector.Connection == null)
76              {
77                  using (_connector.StartUserAction())
78                      _connector.ExecuteInternalCommand($"COMMIT PREPARED '{_preparedTxName}'");
79              }
80              else
81              {
82                  using var conn2 = (NpgsqlConnection)((ICloneable)_connector.Connection).Clone();
83                  conn2.Open();
84                  var connector = conn2.Connector!;
85                  using (connector.StartUserAction())
86                      connector.ExecuteInternalCommand($"COMMIT PREPARED '{_preparedTxName}'");
87              }
88          }
89          catch (Exception e)
90          {
91              LogMessages.TwoPhaseTransactionCommitFailed(_transactionLogger, _txId, _connector.Id, e);
92          }
93          finally
94          {
95              Dispose();
96              enlistment.Done();
97          }
98      }
99      public void Rollback(Enlistment enlistment)
100      {
101          CheckDisposed();
102          try
103          {
104              if (IsPrepared)
105                  RollbackTwoPhase();
106              else
107                  RollbackLocal();
108          }
109          finally
110          {
111              Dispose();
112              enlistment.Done();
113          }
114      }
115      public void InDoubt(Enlistment enlistment)
116      {
117          LogMessages.TwoPhaseTransactionInDoubt(_transactionLogger, _txId, _connector.Id);
118          try
119          {
120              RollbackTwoPhase();
121          }
122          finally
123          {
124              Dispose();
125              enlistment.Done();
126          }
127      }
128      void RollbackLocal()
129      {
130          LogMessages.RollingBackSinglePhaseTransaction(_transactionLogger, _txId, _connector.Id);
131          try
132          {
133              var attempt = 0;
134              while (true)
135              {
136                  try
137                  {
138                      _localTx.Rollback();
139                      return;
140                  }
141                  catch (NpgsqlOperationInProgressException)
142                  {
143                      if (attempt++ == MaximumRollbackAttempts)
144                          throw new Exception(
145                              $"Could not roll back after {MaximumRollbackAttempts} attempts, aborting. Transaction is in an unknown state.");
146                      LogMessages.ConnectionInUseWhenRollingBack(_transactionLogger, _txId, _connector.Id);
147                      _connector.PerformPostgresCancellation();
148                      Thread.Sleep(500);
149                  }
150              }
151          }
152          catch
153          {
154              LogMessages.SinglePhaseTransactionRollbackFailed(_transactionLogger, _txId, _connector.Id);
155          }
156      }
157      void RollbackTwoPhase()
158      {
159          LogMessages.RollingBackTwoPhaseTransaction(_transactionLogger, _txId, _connector.Id);
160          try
161          {
162              if (_connector.Connection == null)
163              {
164                  using (_connector.StartUserAction())
165                      _connector.ExecuteInternalCommand($"ROLLBACK PREPARED '{_preparedTxName}'");
166              }
167              else
168              {
169                  using var conn2 = (NpgsqlConnection)((ICloneable)_connector.Connection).Clone();
170                  conn2.Open();
171                  var connector = conn2.Connector!;
172                  using (connector.StartUserAction())
173                      connector.ExecuteInternalCommand($"ROLLBACK PREPARED '{_preparedTxName}'");
174              }
175          }
176          catch (Exception e)
177          {
178              LogMessages.TwoPhaseTransactionRollbackFailed(_transactionLogger, _txId, _connector.Id, e);
179          }
180      }
181      #region Dispose/Cleanup
182  #pragma warning disable CS8625
183      void Dispose()
184      {
185          if (_isDisposed)
186              return;
187          LogMessages.CleaningUpResourceManager(_transactionLogger, _txId, _connector.Id);
188          if (_localTx != null)
189          {
190              _localTx.Dispose();
191              _localTx = null;
192          }
193          if (_connector.Connection != null)
194              _connector.Connection.EnlistedTransaction = null;
195          else
196          {
197              if (_connector.TryRemovePendingEnlistedConnector(_transaction))
198                  _connector.Return();
199          }
200          _connector = null!;
201          _transaction = null!;
<span onclick='openModal()' class='match'>202          _isDisposed = true;
203      }
204  #pragma warning restore CS8625
205      void CheckDisposed()
206      {
207          if (_isDisposed)
208              throw new ObjectDisposedException(nameof(VolatileResourceManager));
</span>209      }
210      #endregion
211      static System.Data.IsolationLevel ConvertIsolationLevel(IsolationLevel isolationLevel)
212          => isolationLevel switch
213          {
214              IsolationLevel.Chaos           => System.Data.IsolationLevel.Chaos,
215              IsolationLevel.ReadCommitted   => System.Data.IsolationLevel.ReadCommitted,
216              IsolationLevel.ReadUncommitted => System.Data.IsolationLevel.ReadUncommitted,
217              IsolationLevel.RepeatableRead  => System.Data.IsolationLevel.RepeatableRead,
218              IsolationLevel.Serializable    => System.Data.IsolationLevel.Serializable,
219              IsolationLevel.Snapshot        => System.Data.IsolationLevel.Snapshot,
220              _                              => System.Data.IsolationLevel.Unspecified
221          };
222  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRawCopyStream.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-VolatileResourceManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>364          _isDisposed = true;
365      }
366  #pragma warning restore CS8625
367      void CheckDisposed()
368      {
369          if (_isDisposed) {
</pre></code></div>
                <div class="column column_space"><pre><code>202          _isDisposed = true;
203      }
204  #pragma warning restore CS8625
205      void CheckDisposed()
206      {
207          if (_isDisposed)
208              throw new ObjectDisposedException(nameof(VolatileResourceManager));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    