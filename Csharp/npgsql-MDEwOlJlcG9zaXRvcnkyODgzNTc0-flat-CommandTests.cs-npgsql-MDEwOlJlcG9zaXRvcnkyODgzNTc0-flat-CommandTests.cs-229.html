
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</h3>
            <pre><code>1  using Npgsql.BackendMessages;
2  using Npgsql.Internal;
3  using Npgsql.Tests.Support;
4  using Npgsql.TypeMapping;
5  using NpgsqlTypes;
6  using NUnit.Framework;
7  using System;
8  using System.Buffers.Binary;
9  using System.Data;
10  using System.Linq;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using static Npgsql.Tests.TestUtil;
15  namespace Npgsql.Tests;
16  public class CommandTests : MultiplexingTestBase
17  {
18      #region Legacy batching
19      [Test]
20      [TestCase(new[] { true }, TestName = &quot;SingleQuery&quot;)]
21      [TestCase(new[] { false }, TestName = &quot;SingleNonQuery&quot;)]
22      [TestCase(new[] { true, true }, TestName = &quot;TwoQueries&quot;)]
23      [TestCase(new[] { false, false }, TestName = &quot;TwoNonQueries&quot;)]
24      [TestCase(new[] { false, true }, TestName = &quot;NonQueryQuery&quot;)]
25      [TestCase(new[] { true, false }, TestName = &quot;QueryNonQuery&quot;)]
26      public async Task Multiple_statements(bool[] queries)
27      {
28          await using var conn = await OpenConnectionAsync();
29          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
30          var sb = new StringBuilder();
31          foreach (var query in queries)
32              sb.Append(query ? &quot;SELECT 1;&quot; : $&quot;UPDATE {table} SET name=&#x27;yo&#x27; WHERE 1=0;&quot;);
33          var sql = sb.ToString();
34          foreach (var prepare in new[] { false, true })
35          {
36              await using var cmd = conn.CreateCommand();
37              cmd.CommandText = sql;
38              if (prepare &amp;&amp; !IsMultiplexing)
39                  await cmd.PrepareAsync();
40              await using var reader = await cmd.ExecuteReaderAsync();
41              var numResultSets = queries.Count(q =&gt; q);
42              for (var i = 0; i &lt; numResultSets; i++)
43              {
44                  Assert.That(await reader.ReadAsync(), Is.True);
45                  Assert.That(reader[0], Is.EqualTo(1));
46                  Assert.That(await reader.NextResultAsync(), Is.EqualTo(i != numResultSets - 1));
47              }
48          }
49      }
50      [Test]
51      public async Task Multiple_statements_with_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
52      {
53          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
54              return;
55          await using var conn = await OpenConnectionAsync();
56          await using var cmd = conn.CreateCommand();
57          cmd.CommandText = &quot;SELECT @p1; SELECT @p2&quot;;
58          var p1 = new NpgsqlParameter(&quot;p1&quot;, NpgsqlDbType.Integer);
59          var p2 = new NpgsqlParameter(&quot;p2&quot;, NpgsqlDbType.Text);
60          cmd.Parameters.Add(p1);
61          cmd.Parameters.Add(p2);
62          if (prepare == PrepareOrNot.Prepared)
63              cmd.Prepare();
64          p1.Value = 8;
65          p2.Value = &quot;foo&quot;;
66          await using var reader = await cmd.ExecuteReaderAsync();
67          Assert.That(await reader.ReadAsync(), Is.True);
68          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
69          Assert.That(await reader.NextResultAsync(), Is.True);
70          Assert.That(await reader.ReadAsync(), Is.True);
71          Assert.That(reader.GetString(0), Is.EqualTo(&quot;foo&quot;));
72          Assert.That(await reader.NextResultAsync(), Is.False);
73      }
74      [Test]
75      public async Task SingleRow_legacy_batching([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
76      {
77          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
78              return;
79          using var conn = await OpenConnectionAsync();
80          using var cmd = new NpgsqlCommand(&quot;SELECT 1; SELECT 2&quot;, conn);
81          if (prepare == PrepareOrNot.Prepared)
82              cmd.Prepare();
83          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
84          Assert.That(reader.Read(), Is.True);
85          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
86          Assert.That(reader.Read(), Is.False);
87          Assert.That(reader.NextResult(), Is.False);
88      }
89      [Test, Description(&quot;Makes sure a later command can depend on an earlier one&quot;)]
90      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/641&quot;)]
91      public async Task Multiple_statements_with_dependencies()
92      {
93          using var conn = await OpenConnectionAsync();
94          var table = await CreateTempTable(conn, &quot;a INT&quot;);
95          await conn.ExecuteNonQueryAsync($&quot;ALTER TABLE {table} ADD COLUMN b INT; INSERT INTO {table} (b) VALUES (8)&quot;);
96          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT b FROM {table}&quot;), Is.EqualTo(8));
97      }
98      [Test, Description(&quot;Forces async write mode when the first statement in a multi-statement command is big&quot;)]
99      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/641&quot;)]
100      public async Task Multiple_statements_large_first_command()
101      {
102          using var conn = await OpenConnectionAsync();
103          using var cmd = new NpgsqlCommand($&quot;SELECT repeat(&#x27;X&#x27;, {conn.Settings.WriteBufferSize}); SELECT @p&quot;, conn);
104          var expected1 = new string(&#x27;X&#x27;, conn.Settings.WriteBufferSize);
105          var expected2 = new string(&#x27;Y&#x27;, conn.Settings.WriteBufferSize);
106          cmd.Parameters.AddWithValue(&quot;p&quot;, expected2);
107          using var reader = await cmd.ExecuteReaderAsync();
108          reader.Read();
109          Assert.That(reader.GetString(0), Is.EqualTo(expected1));
110          reader.NextResult();
111          reader.Read();
112          Assert.That(reader.GetString(0), Is.EqualTo(expected2));
113      }
114      [Test]
115      [NonParallelizable] 
116      public async Task Legacy_batching_is_not_supported_when_EnableSqlParsing_is_disabled()
117      {
118          using var _ = DisableSqlRewriting();
119          using var conn = await OpenConnectionAsync();
120          using var cmd = new NpgsqlCommand(&quot;SELECT 1; SELECT 2&quot;, conn);
121          Assert.That(async () =&gt; await cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf&lt;PostgresException&gt;()
122              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
123      }
124      #endregion
125      #region Timeout
126      [Test, Description(&quot;Checks that CommandTimeout gets enforced as a socket timeout&quot;)]
127      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/327&quot;)]
128      public async Task Timeout()
129      {
130          if (IsMultiplexing)
131              return; 
132          await using var dataSource = CreateDataSource(csb =&gt; csb.CommandTimeout = 1);
133          await using var conn = await dataSource.OpenConnectionAsync();
134          await using var cmd = CreateSleepCommand(conn, 10);
135          Assert.That(() =&gt; cmd.ExecuteNonQuery(), Throws.Exception
136              .TypeOf&lt;NpgsqlException&gt;()
137              .With.InnerException.TypeOf&lt;TimeoutException&gt;()
138          );
139          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
140      }
141      [Test, Description(&quot;Times out an async operation, testing that cancellation occurs successfully&quot;)]
142      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/607&quot;)]
143      public async Task Timeout_async_soft()
144      {
145          if (IsMultiplexing)
146              return; 
147          await using var dataSource = CreateDataSource(csb =&gt; csb.CommandTimeout = 1);
148          await using var conn = await dataSource.OpenConnectionAsync();
149          await using var cmd = CreateSleepCommand(conn, 10);
150          Assert.That(async () =&gt; await cmd.ExecuteNonQueryAsync(),
151              Throws.Exception
152                  .TypeOf&lt;NpgsqlException&gt;()
153                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
154          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
155      }
156      [Test, Description(&quot;Times out an async operation, with unsuccessful cancellation (socket break)&quot;)]
157      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/607&quot;)]
158      public async Task Timeout_async_hard()
159      {
160          if (IsMultiplexing)
161              return; 
162          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
163          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
165          await using var conn = await dataSource.OpenConnectionAsync();
166          await postmasterMock.WaitForServerConnection();
167          var processId = conn.ProcessID;
168          Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;),
169              Throws.Exception
170                  .TypeOf&lt;NpgsqlException&gt;()
171                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
172          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
173          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
174              Is.EqualTo(processId));
175      }
176      [Test]
177      public async Task Timeout_from_connection_string()
178      {
179          Assert.That(NpgsqlConnector.MinimumInternalCommandTimeout, Is.Not.EqualTo(NpgsqlCommand.DefaultTimeout));
180          var timeout = NpgsqlConnector.MinimumInternalCommandTimeout;
181          await using var dataSource = CreateDataSource(csb =&gt; csb.CommandTimeout = timeout);
182          await using var conn = await dataSource.OpenConnectionAsync();
183          await using var command = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
184          Assert.That(command.CommandTimeout, Is.EqualTo(timeout));
185          command.CommandTimeout = 10;
186          await command.ExecuteScalarAsync();
187          Assert.That(command.CommandTimeout, Is.EqualTo(10));
188      }
189      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/395&quot;)]
190      public async Task Timeout_switch_connection()
191      {
192          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
193          if (csb.CommandTimeout &gt;= 100 &amp;&amp; csb.CommandTimeout &lt; 105)
194              IgnoreExceptOnBuildServer(&quot;Bad default command timeout&quot;);
195          await using var dataSource1 = CreateDataSource(ConnectionString + &quot;;CommandTimeout=100&quot;);
196          await using var c1 = dataSource1.CreateConnection();
197          await using var cmd = c1.CreateCommand();
198          Assert.That(cmd.CommandTimeout, Is.EqualTo(100));
199          await using var dataSource2 = CreateDataSource(ConnectionString + &quot;;CommandTimeout=101&quot;);
200          await using (var c2 = dataSource2.CreateConnection())
201          {
202              cmd.Connection = c2;
203              Assert.That(cmd.CommandTimeout, Is.EqualTo(101));
204          }
205          cmd.CommandTimeout = 102;
206          await using (var c2 = dataSource2.CreateConnection())
207          {
208              cmd.Connection = c2;
209              Assert.That(cmd.CommandTimeout, Is.EqualTo(102));
210          }
211      }
212      [Test]
213      public async Task Prepare_timeout_hard([Values] SyncOrAsync async)
214      {
215          if (IsMultiplexing)
216              return; 
217          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
218          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
219          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
220          await using var conn = await dataSource.OpenConnectionAsync();
221          await postmasterMock.WaitForServerConnection();
222          var processId = conn.ProcessID;
223          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
224          Assert.That(async () =&gt;
225              {
226                  if (async == SyncOrAsync.Sync)
227                      cmd.Prepare();
228                  else
229                      await cmd.PrepareAsync();
230              },
231              Throws.Exception
232                  .TypeOf&lt;NpgsqlException&gt;()
233                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
234          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
235          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
236              Is.EqualTo(processId));
237      }
238      #endregion
239      #region Cancel
240      [Test, Description(&quot;Basic cancellation scenario&quot;)]
241      [Ignore(&quot;Flaky, see https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/5070&quot;)]
242      public async Task Cancel()
243      {
244          if (IsMultiplexing)
245              return;
246          await using var conn = await OpenConnectionAsync();
247          await using var cmd = CreateSleepCommand(conn, 5);
248          var queryTask = Task.Run(() =&gt; cmd.ExecuteNonQuery());
249          cmd.WaitUntilCommandIsInProgress();
250          cmd.Cancel();
251          Assert.That(async () =&gt; await queryTask, Throws
252              .TypeOf&lt;OperationCanceledException&gt;()
253              .With.InnerException.TypeOf&lt;PostgresException&gt;()
254              .With.InnerException.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled)
255          );
256      }
257      [Test]
258      public async Task Cancel_async_immediately()
259      {
260          if (IsMultiplexing)
261              return; 
262          await using var conn = await OpenConnectionAsync();
263          await using var cmd = conn.CreateCommand();
264          cmd.CommandText = &quot;SELECT 1&quot;;
265          var t = cmd.ExecuteScalarAsync(new(canceled: true));
266          Assert.That(t.IsCompleted, Is.True); 
267          Assert.That(t.Status, Is.EqualTo(TaskStatus.Canceled));
268          Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t);
269          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
270          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
271      }
272      [Test, Description(&quot;Cancels an async query with the cancellation token, with successful PG cancellation&quot;)]
273      [Explicit(&quot;Flaky due to #5033&quot;)]
274      public async Task Cancel_async_soft()
275      {
276          if (IsMultiplexing)
277              return; 
278          await using var conn = await OpenConnectionAsync();
279          await using var cmd = CreateSleepCommand(conn);
280          using var cancellationSource = new CancellationTokenSource();
281          var t = cmd.ExecuteNonQueryAsync(cancellationSource.Token);
282          cancellationSource.Cancel();
283          var exception = Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t)!;
284          Assert.That(exception.InnerException,
285              Is.TypeOf&lt;PostgresException&gt;().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
286          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
287          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
288          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
289      }
290      [Test, Description(&quot;Cancels an async query with the cancellation token, with unsuccessful PG cancellation (socket break)&quot;)]
291      public async Task Cancel_async_hard()
292      {
293          if (IsMultiplexing)
294              return; 
295          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
296          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
297          await using var conn = await dataSource.OpenConnectionAsync();
298          await postmasterMock.WaitForServerConnection();
299          var processId = conn.ProcessID;
300          using var cancellationSource = new CancellationTokenSource();
301          using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
302          var t = cmd.ExecuteScalarAsync(cancellationSource.Token);
303          cancellationSource.Cancel();
304          var exception = Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t)!;
305          Assert.That(exception.InnerException, Is.TypeOf&lt;TimeoutException&gt;());
306          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
307          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
308          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
309              Is.EqualTo(processId));
310      }
311      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3466&quot;)]
312      [Ignore(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4668&quot;)]
313      public async Task Bug3466([Values(false, true)] bool isBroken)
314      {
315          if (IsMultiplexing)
316              return; 
317          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
318          {
319              Pooling = false
320          };
321          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString(), completeCancellationImmediately: false);
322          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
323          await using var conn = await dataSource.OpenConnectionAsync();
324          var serverMock = await postmasterMock.WaitForServerConnection();
325          var processId = conn.ProcessID;
326          using var cancellationSource = new CancellationTokenSource();
327          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn)
328          {
329              CommandTimeout = 4
330          };
331          var t = Task.Run(() =&gt; cmd.ExecuteScalar());
332          cmd.WaitUntilCommandIsInProgress();
333          var cancelTask = Task.Run(() =&gt; cmd.Cancel());
334          var cancellationRequest = await postmasterMock.WaitForCancellationRequest();
335          if (isBroken)
336          {
337              Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t);
338              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
339          }
340          else
341          {
342              await serverMock
343                  .WriteParseComplete()
344                  .WriteBindComplete()
345                  .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
346                  .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
347                  .WriteCommandComplete()
348                  .WriteReadyForQuery()
349                  .FlushAsync();
350              Assert.DoesNotThrowAsync(async () =&gt; await t);
351              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
352              await conn.CloseAsync();
353          }
354          cancellationRequest.Complete();
355          Assert.DoesNotThrowAsync(async () =&gt; await cancelTask);
356      }
357      [Test, Description(&quot;Check that cancel only affects the command on which its was invoked&quot;)]
358      [Explicit(&quot;Timing-sensitive&quot;)]
359      public async Task Cancel_cross_command()
360      {
361          await using var conn = await OpenConnectionAsync();
362          await using var cmd1 = CreateSleepCommand(conn, 2);
363          await using var cmd2 = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
364          var cancelTask = Task.Factory.StartNew(() =&gt;
365          {
366              Thread.Sleep(300);
367              cmd2.Cancel();
368          });
369          Assert.That(() =&gt; cmd1.ExecuteNonQueryAsync(), Throws.Nothing);
370          cancelTask.Wait();
371      }
372      #endregion
373      #region Cursors
374      [Test]
375      public async Task Cursor_statement()
376      {
377          using var conn = await OpenConnectionAsync();
378          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
379          using var t = conn.BeginTransaction();
380          for (var x = 0; x &lt; 5; x++)
381              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;);
382          var i = 0;
383          var command = new NpgsqlCommand($&quot;DECLARE TE CURSOR FOR SELECT * FROM {table}&quot;, conn);
384          command.ExecuteNonQuery();
385          command.CommandText = &quot;FETCH FORWARD 3 IN TE&quot;;
386          var dr = command.ExecuteReader();
387          while (dr.Read())
388              i++;
389          Assert.AreEqual(3, i);
390          dr.Close();
391          i = 0;
392          command.CommandText = &quot;FETCH BACKWARD 1 IN TE&quot;;
393          var dr2 = command.ExecuteReader();
394          while (dr2.Read())
395              i++;
396          Assert.AreEqual(1, i);
397          dr2.Close();
398          command.CommandText = &quot;close te;&quot;;
399          command.ExecuteNonQuery();
400      }
401      [Test]
402      public async Task Cursor_move_RecordsAffected()
403      {
404          using var connection = await OpenConnectionAsync();
405          using var transaction = connection.BeginTransaction();
406          var command = new NpgsqlCommand(&quot;DECLARE curs CURSOR FOR SELECT * FROM (VALUES (1), (2), (3)) as t&quot;, connection);
407          command.ExecuteNonQuery();
408          command.CommandText = &quot;MOVE FORWARD ALL IN curs&quot;;
409          var count = command.ExecuteNonQuery();
410          Assert.AreEqual(3, count);
411      }
412      #endregion
413      #region CommandBehavior.CloseConnection
414      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/693&quot;)]
415      public async Task CloseConnection()
416      {
417          using var conn = await OpenConnectionAsync();
418          using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
419          using (var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection))
420              while (reader.Read()) {}
421          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
422      }
423      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1194&quot;)]
424      public async Task CloseConnection_with_open_reader_with_CloseConnection()
425      {
426          using var conn = await OpenConnectionAsync();
427          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
428          var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection);
429          var wasClosed = false;
430          reader.ReaderClosed += (sender, args) =&gt; { wasClosed = true; };
431          conn.Close();
432          Assert.That(wasClosed, Is.True);
433      }
434      [Test]
435      public async Task CloseConnection_with_exception()
436      {
437          using var conn = await OpenConnectionAsync();
438          using (var cmd = new NpgsqlCommand(&quot;SE&quot;, conn))
439              Assert.That(() =&gt; cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection), Throws.Exception.TypeOf&lt;PostgresException&gt;());
440          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
441      }
442      #endregion
443      [Test]
444      public async Task SingleRow([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
445      {
446          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
447              return;
448          await using var conn = await OpenConnectionAsync();
449          await using var cmd = new NpgsqlCommand(&quot;SELECT 1, 2 UNION SELECT 3, 4&quot;, conn);
450          if (prepare == PrepareOrNot.Prepared)
451              cmd.Prepare();
452          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
453          Assert.That(() =&gt; reader.GetInt32(0), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
454          Assert.That(reader.Read(), Is.True);
455          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
456          Assert.That(reader.Read(), Is.False);
457      }
458      #region Parameters
459      [Test]
460      public async Task Positional_parameter()
461      {
462          await using var conn = await OpenConnectionAsync();
463          await using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn);
464          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
465          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
466      }
467      [Test]
468      public async Task Positional_parameters_are_not_supported_with_legacy_batching()
469      {
470          await using var conn = await OpenConnectionAsync();
471          await using var cmd = new NpgsqlCommand(&quot;SELECT $1; SELECT $1&quot;, conn);
472          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
473          Assert.That(async () =&gt; await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;PostgresException&gt;()
474              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
475      }
476      [Test]
477      [NonParallelizable] 
478      public async Task Positional_parameters_are_supported_when_EnableSqlParsing_is_disabled()
479      {
480          using var _ = DisableSqlRewriting();
481          using var conn = await OpenConnectionAsync();
482          using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn);
483          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
484          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
485      }
486      [Test]
487      [NonParallelizable] 
488      public async Task Named_parameters_are_not_supported_when_EnableSqlParsing_is_disabled()
489      {
490          using var _ = DisableSqlRewriting();
491          using var conn = await OpenConnectionAsync();
492          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
493          cmd.Parameters.Add(new NpgsqlParameter(&quot;p&quot;, 8));
494          Assert.That(async () =&gt; await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
495      }
496      [Test, Description(&quot;Makes sure writing an unset parameter isn&#x27;t allowed&quot;)]
497      public async Task Parameter_without_Value()
498      {
499          using var conn = await OpenConnectionAsync();
500          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
501          cmd.Parameters.Add(new NpgsqlParameter(&quot;@p&quot;, NpgsqlDbType.Integer));
502          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;InvalidCastException&gt;());
503      }
504      [Test]
505      public async Task Unreferenced_named_parameter_works()
506      {
507          await using var conn = await OpenConnectionAsync();
508          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
509          cmd.Parameters.AddWithValue(&quot;not_used&quot;, 8);
510          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
511      }
512      [Test]
513      public async Task Unreferenced_positional_parameter_works()
514      {
515          await using var conn = await OpenConnectionAsync();
516          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
517          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
518          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
519      }
520      [Test]
521      public async Task Mixing_positional_and_named_parameters_is_not_supported()
522      {
523          await using var conn = await OpenConnectionAsync();
524          await using var cmd = new NpgsqlCommand(&quot;SELECT $1, @p&quot;, conn);
525          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
526          cmd.Parameters.Add(new NpgsqlParameter { ParameterName = &quot;p&quot;, Value = 9 });
527          Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
528      }
529      [Test]
530      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4171&quot;)]
531      public async Task Cached_command_clears_parameters_placeholder_type()
532      {
533          await using var conn = await OpenConnectionAsync();
534          await using (var cmd1 = conn.CreateCommand())
535          {
536              cmd1.CommandText = &quot;SELECT @p1&quot;;
537              cmd1.Parameters.AddWithValue(&quot;@p1&quot;, 8);
538              await using var reader1 = await cmd1.ExecuteReaderAsync();
539              reader1.Read();
540              Assert.That(reader1[0], Is.EqualTo(8));
541          }
542          await using (var cmd2 = conn.CreateCommand())
543          {
544              cmd2.CommandText = &quot;SELECT $1&quot;;
545              cmd2.Parameters.AddWithValue(8);
546              await using var reader2 = await cmd2.ExecuteReaderAsync();
547              reader2.Read();
548              Assert.That(reader2[0], Is.EqualTo(8));
549          }
550      }
551      [Test]
552      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4171&quot;)]
553      public async Task Reuse_command_with_different_parameter_placeholder_types()
554      {
555          await using var conn = await OpenConnectionAsync();
556          await using var cmd = conn.CreateCommand();
557          cmd.CommandText = &quot;SELECT @p1&quot;;
558          cmd.Parameters.AddWithValue(&quot;@p1&quot;, 8);
559          _ = await cmd.ExecuteScalarAsync();
560          cmd.CommandText = &quot;SELECT $1&quot;;
561          cmd.Parameters[0].ParameterName = null;
562          _ = await cmd.ExecuteScalarAsync();
563      }
564      [Test]
565      public async Task Positional_output_parameters_are_not_supported()
566      {
567          await using var conn = await OpenConnectionAsync();
568          await using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn);
569          cmd.Parameters.Add(new NpgsqlParameter { Value = 8, Direction = ParameterDirection.InputOutput });
570          Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
571      }
572      [Test]
573      public void Parameters_get_name()
574      {
575          var command = new NpgsqlCommand();
576          command.Parameters.Add(new NpgsqlParameter(&quot;:Parameter1&quot;, DbType.Boolean));
577          command.Parameters.Add(new NpgsqlParameter(&quot;:Parameter2&quot;, DbType.Int32));
578          command.Parameters.Add(new NpgsqlParameter(&quot;:Parameter3&quot;, DbType.DateTime));
579          command.Parameters.Add(new NpgsqlParameter(&quot;Parameter4&quot;, DbType.DateTime));
580          var idbPrmtr = command.Parameters[&quot;Parameter1&quot;];
581          Assert.IsNotNull(idbPrmtr);
582          command.Parameters[0].Value = 1;
583          Assert.AreEqual(&quot;:Parameter1&quot;, command.Parameters[&quot;Parameter1&quot;].ParameterName);
584          Assert.AreEqual(&quot;:Parameter2&quot;, command.Parameters[&quot;Parameter2&quot;].ParameterName);
585          Assert.AreEqual(&quot;:Parameter3&quot;, command.Parameters[&quot;Parameter3&quot;].ParameterName);
586          Assert.AreEqual(&quot;Parameter4&quot;, command.Parameters[&quot;Parameter4&quot;].ParameterName); 
587          Assert.AreEqual(&quot;:Parameter1&quot;, command.Parameters[0].ParameterName);
588          Assert.AreEqual(&quot;:Parameter2&quot;, command.Parameters[1].ParameterName);
589          Assert.AreEqual(&quot;:Parameter3&quot;, command.Parameters[2].ParameterName);
590          Assert.AreEqual(&quot;Parameter4&quot;, command.Parameters[3].ParameterName);
591      }
592      [Test]
593      public async Task Same_param_multiple_times()
594      {
595          using var conn = await OpenConnectionAsync();
596          using var cmd = new NpgsqlCommand(&quot;SELECT @p1, @p1&quot;, conn);
597          cmd.Parameters.AddWithValue(&quot;@p1&quot;, 8);
598          using var reader = await cmd.ExecuteReaderAsync();
599          reader.Read();
600          Assert.That(reader[0], Is.EqualTo(8));
601          Assert.That(reader[1], Is.EqualTo(8));
602      }
603      [Test]
604      public async Task Generic_parameter()
605      {
606          using var conn = await OpenConnectionAsync();
607          using var cmd = new NpgsqlCommand(&quot;SELECT @p1, @p2, @p3, @p4&quot;, conn);
608          cmd.Parameters.Add(new NpgsqlParameter&lt;int&gt;(&quot;p1&quot;, 8));
609          cmd.Parameters.Add(new NpgsqlParameter&lt;short&gt;(&quot;p2&quot;, 8) { NpgsqlDbType = NpgsqlDbType.Integer });
610          cmd.Parameters.Add(new NpgsqlParameter&lt;string&gt;(&quot;p3&quot;, &quot;hello&quot;));
611          cmd.Parameters.Add(new NpgsqlParameter&lt;char[]&gt;(&quot;p4&quot;, new[] { &#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27; }));
612          using var reader = await cmd.ExecuteReaderAsync();
613          reader.Read();
614          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
615          Assert.That(reader.GetInt32(1), Is.EqualTo(8));
616          Assert.That(reader.GetString(2), Is.EqualTo(&quot;hello&quot;));
617          Assert.That(reader.GetString(3), Is.EqualTo(&quot;foo&quot;));
618      }
619      #endregion Parameters
620      [Test]
621      public async Task CommandText_not_set()
622      {
623          await using var conn = await OpenConnectionAsync();
624          await using (var cmd = new NpgsqlCommand())
625          {
626              cmd.Connection = conn;
627              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
628              cmd.CommandText = null;
629              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
630              cmd.CommandText = &quot;&quot;;
631          }
632          await using (var cmd = conn.CreateCommand())
633              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
634      }
635      [Test]
636      public async Task ExecuteScalar()
637      {
638          await using var conn = await OpenConnectionAsync();
639          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
640          await using var command = new NpgsqlCommand($&quot;SELECT name FROM {table}&quot;, conn);
641          Assert.That(command.ExecuteScalarAsync, Is.Null);
642          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (NULL)&quot;);
643          Assert.That(command.ExecuteScalarAsync, Is.EqualTo(DBNull.Value));
644          await conn.ExecuteNonQueryAsync($&quot;TRUNCATE {table}&quot;);
645          for (var i = 0; i &lt; 2; i++)
646              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;);
647          Assert.That(command.ExecuteScalarAsync, Is.EqualTo(&quot;X&quot;));
648      }
649      [Test]
650      public async Task ExecuteNonQuery()
651      {
652          await using var conn = await OpenConnectionAsync();
653          await using var cmd = new NpgsqlCommand { Connection = conn };
654          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
655          cmd.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;John&#x27;)&quot;;
656          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
657          cmd.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;John&#x27;); INSERT INTO {table} (name) VALUES (&#x27;John&#x27;)&quot;;
658          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(2));
659          cmd.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;{new string(&#x27;x&#x27;, conn.Settings.WriteBufferSize)}&#x27;)&quot;;
660          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
661      }
662      [Test, Description(&quot;Makes sure a command is unusable after it is disposed&quot;)]
663      public async Task Dispose()
664      {
665          await using var conn = await OpenConnectionAsync();
666          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
667          cmd.Dispose();
668          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
669          Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
670          Assert.That(() =&gt; cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
671          Assert.That(() =&gt; cmd.PrepareAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
672      }
673      [Test, Description(&quot;Disposing a command with an open reader does not close the reader. This is the SqlClient behavior.&quot;)]
674      public async Task Command_Dispose_does_not_close_reader()
675      {
676          await using var conn = await OpenConnectionAsync();
677          var cmd = new NpgsqlCommand(&quot;SELECT 1, 2&quot;, conn);
678          await cmd.ExecuteReaderAsync();
679          cmd.Dispose();
680          cmd = new NpgsqlCommand(&quot;SELECT 3&quot;, conn);
681          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;NpgsqlOperationInProgressException&gt;());
682      }
683      [Test]
684      public async Task Non_standards_conforming_strings()
685      {
686          await using var dataSource = CreateDataSource();
687          await using var conn = await dataSource.OpenConnectionAsync();
688          if (IsMultiplexing)
689          {
690              Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;set standard_conforming_strings=off&quot;),
691                  Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
692          }
693          else
694          {
695              await conn.ExecuteNonQueryAsync(&quot;set standard_conforming_strings=off&quot;);
696              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
697              await conn.ExecuteNonQueryAsync(&quot;set standard_conforming_strings=on&quot;);
698          }
699      }
700      [Test]
701      public async Task Parameter_and_operator_unclear()
702      {
703          await using var conn = await OpenConnectionAsync();
704          await using var command = new NpgsqlCommand(&quot;select :arr[2]&quot;, conn);
705          command.Parameters.AddWithValue(&quot;:arr&quot;, new int[] {5, 4, 3, 2, 1});
706          await using var rdr = await command.ExecuteReaderAsync();
707          rdr.Read();
708          Assert.AreEqual(rdr.GetInt32(0), 4);
709      }
710      [Test]
711      [TestCase(CommandBehavior.Default)]
712      [TestCase(CommandBehavior.SequentialAccess)]
713      public async Task Statement_mapped_output_parameters(CommandBehavior behavior)
714      {
715          await using var conn = await OpenConnectionAsync();
716          var command = new NpgsqlCommand(&quot;select 3, 4 as param1, 5 as param2, 6;&quot;, conn);
717          var p = new NpgsqlParameter(&quot;param2&quot;, NpgsqlDbType.Integer);
718          p.Direction = ParameterDirection.Output;
719          p.Value = -1;
720          command.Parameters.Add(p);
721          p = new NpgsqlParameter(&quot;param1&quot;, NpgsqlDbType.Integer);
722          p.Direction = ParameterDirection.Output;
723          p.Value = -1;
724          command.Parameters.Add(p);
725          p = new NpgsqlParameter(&quot;p&quot;, NpgsqlDbType.Integer);
726          p.Direction = ParameterDirection.Output;
727          p.Value = -1;
728          command.Parameters.Add(p);
729          await using var reader = await command.ExecuteReaderAsync(behavior);
730          Assert.AreEqual(4, command.Parameters[&quot;param1&quot;].Value);
731          Assert.AreEqual(5, command.Parameters[&quot;param2&quot;].Value);
732          reader.Read();
733          Assert.AreEqual(3, reader.GetInt32(0));
734          Assert.AreEqual(4, reader.GetInt32(1));
735          Assert.AreEqual(5, reader.GetInt32(2));
736          Assert.AreEqual(6, reader.GetInt32(3));
737      }
738      [Test]
739      public async Task Bug1006158_output_parameters()
740      {
741          await using var conn = await OpenConnectionAsync();
742          MinimumPgVersion(conn, &quot;14.0&quot;, &quot;Stored procedure OUT parameters are only support starting with version 14&quot;);
743          var sproc = await GetTempProcedureName(conn);
744          var createFunction = $@&quot;
745  CREATE PROCEDURE {sproc}(OUT a integer, OUT b boolean) AS $$
746  BEGIN
747      a := 3;
748      b := true;
749  END
750  $$ LANGUAGE plpgsql;&quot;;
751          var command = new NpgsqlCommand(createFunction, conn);
752          await command.ExecuteNonQueryAsync();
753          command = new NpgsqlCommand(sproc, conn);
754          command.CommandType = CommandType.StoredProcedure;
755          command.Parameters.Add(new NpgsqlParameter(&quot;a&quot;, DbType.Int32));
756          command.Parameters[0].Direction = ParameterDirection.Output;
757          command.Parameters.Add(new NpgsqlParameter(&quot;b&quot;, DbType.Boolean));
758          command.Parameters[1].Direction = ParameterDirection.Output;
759          _ = await command.ExecuteScalarAsync();
760          Assert.AreEqual(3, command.Parameters[0].Value);
761          Assert.AreEqual(true, command.Parameters[1].Value);
762      }
763      [Test]
764      public async Task Bug1010788_UpdateRowSource()
765      {
766          if (IsMultiplexing)
767              return;
768          using var conn = await OpenConnectionAsync();
769          var table = await CreateTempTable(conn, &quot;id SERIAL PRIMARY KEY, name TEXT&quot;);
770          var command = new NpgsqlCommand($&quot;SELECT * FROM {table}&quot;, conn);
771          Assert.AreEqual(UpdateRowSource.Both, command.UpdatedRowSource);
772          var cmdBuilder = new NpgsqlCommandBuilder();
773          var da = new NpgsqlDataAdapter(command);
774          cmdBuilder.DataAdapter = da;
775          Assert.IsNotNull(da.SelectCommand);
776          Assert.IsNotNull(cmdBuilder.DataAdapter);
777          var updateCommand = cmdBuilder.GetUpdateCommand();
778          Assert.AreEqual(UpdateRowSource.None, updateCommand.UpdatedRowSource);
779      }
780      [Test]
781      public async Task TableDirect()
782      {
783          using var conn = await OpenConnectionAsync();
784          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
785          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;foo&#x27;)&quot;);
786          using var cmd = new NpgsqlCommand(table, conn) { CommandType = CommandType.TableDirect };
787          using var rdr = await cmd.ExecuteReaderAsync();
788          Assert.That(rdr.Read(), Is.True);
789          Assert.That(rdr[&quot;name&quot;], Is.EqualTo(&quot;foo&quot;));
790      }
791      [Test]
792      [TestCase(CommandBehavior.Default)]
793      [TestCase(CommandBehavior.SequentialAccess)]
794      public async Task Input_and_output_parameters(CommandBehavior behavior)
795      {
796          using var conn = await OpenConnectionAsync();
797          using var cmd = new NpgsqlCommand(&quot;SELECT @c-1 AS c, @a+2 AS b&quot;, conn);
798          cmd.Parameters.Add(new NpgsqlParameter(&quot;a&quot;, 3));
799          var b = new NpgsqlParameter { ParameterName = &quot;b&quot;, Direction = ParameterDirection.Output };
800          cmd.Parameters.Add(b);
801          var c = new NpgsqlParameter { ParameterName = &quot;c&quot;, Direction = ParameterDirection.InputOutput, Value = 4 };
802          cmd.Parameters.Add(c);
803          using (await cmd.ExecuteReaderAsync(behavior))
804          {
805              Assert.AreEqual(5, b.Value);
806              Assert.AreEqual(3, c.Value);
807          }
808      }
809      [Test]
810      public async Task Send_NpgsqlDbType_Unknown([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
811      {
812          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
813              return;
814          using var conn = await OpenConnectionAsync();
815          using var cmd = new NpgsqlCommand(&quot;SELECT @p::TIMESTAMP&quot;, conn);
816          cmd.CommandText = &quot;SELECT @p::TIMESTAMP&quot;;
817          cmd.Parameters.Add(new NpgsqlParameter(&quot;p&quot;, NpgsqlDbType.Unknown) { Value = &quot;2008-1-1&quot; });
818          if (prepare == PrepareOrNot.Prepared)
819              cmd.Prepare();
820          using var reader = await cmd.ExecuteReaderAsync();
821          reader.Read();
822          Assert.That(reader.GetValue(0), Is.EqualTo(new DateTime(2008, 1, 1)));
823      }
824      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/503&quot;)]
825      public async Task Invalid_UTF8()
826      {
827          const string badString = &quot;SELECT &#x27;abc\uD801\uD802d&#x27;&quot;;
828          await using var dataSource = CreateDataSource();
829          using var conn = await dataSource.OpenConnectionAsync();
830          Assert.That(() =&gt; conn.ExecuteScalarAsync(badString), Throws.Exception.TypeOf&lt;EncoderFallbackException&gt;());
831      }
832      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/395&quot;)]
833      public async Task Use_across_connection_change([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
834      {
835          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
836              return;
837          using var conn1 = await OpenConnectionAsync();
838          using var conn2 = await OpenConnectionAsync();
839          using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn1);
840          if (prepare == PrepareOrNot.Prepared)
841              cmd.Prepare();
842          cmd.Connection = conn2;
843          Assert.That(cmd.IsPrepared, Is.False);
844          if (prepare == PrepareOrNot.Prepared)
845              cmd.Prepare();
846          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
847      }
848      [Test, Description(&quot;CreateCommand before connection open&quot;)]
849      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/565&quot;)]
850      public async Task Create_command_before_connection_open()
851      {
852          using var conn = new NpgsqlConnection(ConnectionString);
853          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
854          conn.Open();
855          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
856      }
857      [Test]
858      public void Connection_not_set_throws()
859      {
860          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;);
861          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
862      }
863      [Test]
864      public void Connection_not_open_throws()
865      {
866          using var conn = CreateConnection();
867          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
868          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
869      }
870      [Test]
871      public async Task ExecuteNonQuery_Throws_PostgresException([Values] bool async)
872      {
873          if (!async &amp;&amp; IsMultiplexing)
874              return;
875          await using var conn = await OpenConnectionAsync();
876          var table1 = await CreateTempTable(conn, &quot;id integer PRIMARY key, t varchar(40)&quot;);
877          var table2 = await CreateTempTable(conn, $&quot;id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED&quot;);
878          var sql = $&quot;insert into {table2} ({table1}_id) values (1) returning id&quot;;
879          var ex = async
880              ? Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await conn.ExecuteNonQueryAsync(sql))
881              : Assert.Throws&lt;PostgresException&gt;(() =&gt; conn.ExecuteNonQuery(sql));
882          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
883      }
884      [Test]
885      public async Task ExecuteScalar_Throws_PostgresException([Values] bool async)
886      {
887          if (!async &amp;&amp; IsMultiplexing)
888              return;
889          await using var conn = await OpenConnectionAsync();
890          var table1 = await CreateTempTable(conn, &quot;id integer PRIMARY key, t varchar(40)&quot;);
891          var table2 = await CreateTempTable(conn, $&quot;id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED&quot;);
892          var sql = $&quot;insert into {table2} ({table1}_id) values (1) returning id&quot;;
893          var ex = async
894              ? Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await conn.ExecuteScalarAsync(sql))
895              : Assert.Throws&lt;PostgresException&gt;(() =&gt; conn.ExecuteScalar(sql));
896          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
897      }
898      [Test]
899      public async Task ExecuteReader_Throws_PostgresException([Values] bool async)
900      {
901          if (!async &amp;&amp; IsMultiplexing)
902              return;
903          await using var conn = await OpenConnectionAsync();
904          var table1 = await CreateTempTable(conn, &quot;id integer PRIMARY key, t varchar(40)&quot;);
905          var table2 = await CreateTempTable(conn, $&quot;id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED&quot;);
906          await using var cmd = conn.CreateCommand();
907          cmd.CommandText = $&quot;insert into {table2} ({table1}_id) values (1) returning id&quot;;
908          await using var reader = async
909              ? await cmd.ExecuteReaderAsync()
910              : cmd.ExecuteReader();
911          Assert.IsTrue(async ? await reader.ReadAsync() : reader.Read());
912          var value = reader.GetInt32(0);
913          Assert.That(value, Is.EqualTo(1));
914          Assert.IsFalse(async ? await reader.ReadAsync() : reader.Read());
915          var ex = async
916              ? Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await reader.NextResultAsync())
917              : Assert.Throws&lt;PostgresException&gt;(() =&gt; reader.NextResult());
918          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
919      }
920      [Test]
921      public void Command_is_recycled()
922      {
923          using var conn = OpenConnection();
924          var cmd1 = conn.CreateCommand();
925          cmd1.CommandText = &quot;SELECT @p1&quot;;
926          var tx = conn.BeginTransaction();
927          cmd1.Transaction = tx;
928          cmd1.Parameters.AddWithValue(&quot;p1&quot;, 8);
929          _ = cmd1.ExecuteScalar();
930          cmd1.Dispose();
931          var cmd2 = conn.CreateCommand();
932          Assert.That(cmd2, Is.SameAs(cmd1));
933          Assert.That(cmd2.CommandText, Is.Empty);
934          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
935          Assert.That(cmd2.Transaction, Is.Null);
936          Assert.That(cmd2.Parameters, Is.Empty);
937      }
938      [Test]
939      public void Command_recycled_resets_CommandType()
940      {
941          using var conn = CreateConnection();
942          var cmd1 = conn.CreateCommand();
943          cmd1.CommandType = CommandType.StoredProcedure;
944          cmd1.Dispose();
945          var cmd2 = conn.CreateCommand();
946          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
947      }
948      [Test]
949      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/831&quot;)]
950      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2795&quot;)]
951      public async Task Many_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
952      {
953          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
954              return;
955          using var conn = await OpenConnectionAsync();
956          var table = await CreateTempTable(conn, &quot;some_column INT&quot;);
957          using var cmd = new NpgsqlCommand { Connection = conn };
958          var sb = new StringBuilder($&quot;INSERT INTO {table} (some_column) VALUES &quot;);
959          for (var i = 0; i &lt; ushort.MaxValue; i++)
960          {
961              var paramName = &quot;p&quot; + i;
<span onclick='openModal()' class='match'>962              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
963              if (i &gt; 0)
</span>964                  sb.Append(&quot;, &quot;);
965              sb.Append($&quot;(@{paramName})&quot;);
966          }
967          cmd.CommandText = sb.ToString();
968          if (prepare == PrepareOrNot.Prepared)
969              cmd.Prepare();
970          await cmd.ExecuteNonQueryAsync();
971      }
972      [Test, Description(&quot;Bypasses PostgreSQL&#x27;s uint16 limitation on the number of parameters&quot;)]
973      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/831&quot;)]
974      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/858&quot;)]
975      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2703&quot;)]
976      public async Task Too_many_parameters_throws([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
977      {
978          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
979              return;
980          using var conn = await OpenConnectionAsync();
981          using var cmd = new NpgsqlCommand { Connection = conn };
982          var sb = new StringBuilder(&quot;SOME RANDOM SQL &quot;);
983          for (var i = 0; i &lt; ushort.MaxValue + 1; i++)
984          {
985              var paramName = &quot;p&quot; + i;
986              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
987              if (i &gt; 0)
988                  sb.Append(&quot;, &quot;);
989              sb.Append(&#x27;@&#x27;);
990              sb.Append(paramName);
991          }
992          cmd.CommandText = sb.ToString();
993          if (prepare == PrepareOrNot.Prepared)
994          {
995              Assert.That(() =&gt; cmd.Prepare(), Throws.Exception
996                  .InstanceOf&lt;NpgsqlException&gt;()
997                  .With.Message.EqualTo(&quot;A statement cannot have more than 65535 parameters&quot;));
998          }
999          else
1000          {
1001              Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception
1002                  .InstanceOf&lt;NpgsqlException&gt;()
1003                  .With.Message.EqualTo(&quot;A statement cannot have more than 65535 parameters&quot;));
1004          }
1005      }
1006      [Test, Description(&quot;An individual statement cannot have more than 65535 parameters, but a command can (across multiple statements).&quot;)]
1007      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1199&quot;)]
1008      public async Task Many_parameters_across_statements()
1009      {
1010          using var conn = await OpenConnectionAsync();
1011          using var cmd = new NpgsqlCommand { Connection = conn };
1012          var paramIndex = 0;
1013          var sb = new StringBuilder();
1014          for (var statementIndex = 0; statementIndex &lt; 1000; statementIndex++)
1015          {
1016              if (statementIndex &gt; 0)
1017                  sb.Append(&quot;; &quot;);
1018              sb.Append(&quot;SELECT &quot;);
1019              var startIndex = paramIndex;
1020              var endIndex = paramIndex + 70;
1021              for (; paramIndex &lt; endIndex; paramIndex++)
1022              {
1023                  var paramName = &quot;p&quot; + paramIndex;
1024                  cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
1025                  if (paramIndex &gt; startIndex)
1026                      sb.Append(&quot;, &quot;);
1027                  sb.Append(&#x27;@&#x27;);
1028                  sb.Append(paramName);
1029              }
1030          }
1031          cmd.CommandText = sb.ToString();
1032          await cmd.ExecuteNonQueryAsync();
1033      }
1034      [Test, Description(&quot;Makes sure that Npgsql doesn&#x27;t attempt to send all data before the user can start reading. That would cause a deadlock.&quot;)]
1035      public async Task Batched_big_statements_do_not_deadlock()
1036      {
1037          var data = new string(&#x27;x&#x27;, 1024);
1038          using var conn = await OpenConnectionAsync();
1039          var sb = new StringBuilder();
1040          for (var i = 0; i &lt; 500; i++)
1041              sb.Append(&quot;SELECT @p;&quot;);
1042          using var cmd = new NpgsqlCommand(sb.ToString(), conn);
1043          cmd.Parameters.AddWithValue(&quot;p&quot;, NpgsqlDbType.Text, data);
1044          using var reader = await cmd.ExecuteReaderAsync();
1045          for (var i = 0; i &lt; 500; i++)
1046          {
1047              reader.Read();
1048              Assert.That(reader.GetString(0), Is.EqualTo(data));
1049              reader.NextResult();
1050          }
1051      }
1052      [Test]
1053      public void Batched_small_then_big_statements_do_not_deadlock_in_sync_io()
1054      {
1055          if (IsMultiplexing)
1056              return; 
1057          using var conn = OpenConnection();
1058          var data = new string(&#x27;x&#x27;, 5_000_000);
1059          using var cmd = new NpgsqlCommand(&quot;SELECT generate_series(1, 500000); SELECT @p&quot;, conn);
1060          cmd.Parameters.AddWithValue(&quot;p&quot;, NpgsqlDbType.Text, data);
1061          cmd.ExecuteNonQuery();
1062      }
1063      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1429&quot;)]
1064      public async Task Same_command_different_param_values()
1065      {
1066          using var conn = await OpenConnectionAsync();
1067          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
1068          cmd.Parameters.AddWithValue(&quot;p&quot;, 8);
1069          await cmd.ExecuteNonQueryAsync();
1070          cmd.Parameters[0].Value = 9;
1071          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1072      }
1073      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1429&quot;)]
1074      public async Task Same_command_different_param_instances()
1075      {
1076          using var conn = await OpenConnectionAsync();
1077          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
1078          cmd.Parameters.AddWithValue(&quot;p&quot;, 8);
1079          await cmd.ExecuteNonQueryAsync();
1080          cmd.Parameters.RemoveAt(0);
1081          cmd.Parameters.AddWithValue(&quot;p&quot;, 9);
1082          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1083      }
1084      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3509&quot;), Ignore(&quot;Flaky&quot;)]
1085      public async Task Bug3509()
1086      {
1087          if (IsMultiplexing)
1088              return;
1089          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1090          {
1091              KeepAlive = 1,
1092          };
1093          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1094          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1095          await using var conn = await dataSource.OpenConnectionAsync();
1096          var serverMock = await postmasterMock.WaitForServerConnection();
1097          await serverMock.WaitForData();
1098          var queryTask = Task.Run(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;));
1099          await Task.Delay(300);
1100          await serverMock
1101              .WriteErrorResponse(&quot;42&quot;)
1102              .WriteReadyForQuery()
1103              .FlushAsync();
1104          await serverMock
1105              .WriteScalarResponseAndFlush(1);
1106          var ex = Assert.ThrowsAsync&lt;NpgsqlException&gt;(async () =&gt; await queryTask)!;
1107          Assert.That(ex.InnerException, Is.TypeOf&lt;NpgsqlException&gt;()
1108              .With.InnerException.TypeOf&lt;PostgresException&gt;());
1109      }
1110      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4134&quot;)]
1111      public async Task Cached_command_double_dispose()
1112      {
1113          await using var conn = await OpenConnectionAsync();
1114          var cmd1 = conn.CreateCommand();
1115          cmd1.Dispose();
1116          cmd1.Dispose();
1117          var cmd2 = conn.CreateCommand();
1118          Assert.That(cmd2, Is.SameAs(cmd1));
1119          cmd2.CommandText = &quot;SELECT 1&quot;;
1120          Assert.That(await cmd2.ExecuteScalarAsync(), Is.EqualTo(1));
1121      }
1122      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4330&quot;)]
1123      public async Task Prepare_with_positional_placeholders_after_named()
1124      {
1125          if (IsMultiplexing)
1126              return; 
1127          await using var conn = await OpenConnectionAsync();
1128          await using var command = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
1129          command.Parameters.AddWithValue(&quot;p&quot;, 10);
1130          await command.ExecuteNonQueryAsync();
1131          command.Parameters.Clear();
1132          command.CommandText = &quot;SELECT $1&quot;;
1133          command.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer });
1134          Assert.DoesNotThrowAsync(() =&gt; command.PrepareAsync());
1135      }
1136      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4621&quot;)]
1137      [Description(&quot;Most of 08* errors are coming whenever there was an error while connecting to a remote server from a cluster, so the connection to the cluster is still OK&quot;)]
1138      public async Task Postgres_connection_errors_not_break_connection()
1139      {
1140          if (IsMultiplexing)
1141              return;
1142          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1143          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1144          await using var conn = await dataSource.OpenConnectionAsync();
1145          await using var cmd = conn.CreateCommand();
1146          cmd.CommandText = &quot;SELECT 1&quot;;
1147          var queryTask = cmd.ExecuteNonQueryAsync();
1148          var server = await postmasterMock.WaitForServerConnection();
1149          await server
1150              .WriteErrorResponse(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection)
1151              .WriteReadyForQuery()
1152              .FlushAsync();
1153          var ex = Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await queryTask)!;
1154          Assert.That(ex.SqlState, Is.EqualTo(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection));
1155          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
1156      }
1157      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4804&quot;)]
1158      [Description(&quot;Concurrent write and read failure can lead to deadlocks while cleaning up the connector.&quot;)]
1159      public async Task Concurrent_read_write_failure_deadlock()
1160      {
1161          if (IsMultiplexing)
1162              return;
1163          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1165          await using var conn = await dataSource.OpenConnectionAsync();
1166          await using var cmd = conn.CreateCommand();
1167          cmd.CommandText = new string(&#x27;a&#x27;, 8_000_000);
1168          var queryTask = cmd.ExecuteNonQueryAsync();
1169          var server = await postmasterMock.WaitForServerConnection();
1170          server.Close();
1171          Assert.ThrowsAsync&lt;NpgsqlException&gt;(async () =&gt; await queryTask);
1172      }
1173      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4906&quot;)]
1174      [Description(&quot;Make sure we don&#x27;t cancel a prepended query (and do not deadlock in case of a failure)&quot;)]
1175      [Explicit(&quot;Flaky due to #5033&quot;)]
1176      public async Task Not_cancel_prepended_query([Values] bool failPrependedQuery)
1177      {
1178          if (IsMultiplexing)
1179              return;
1180          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1181          var csb = new NpgsqlConnectionStringBuilder(postmasterMock.ConnectionString)
1182          {
1183              NoResetOnClose = false
1184          };
1185          await using var dataSource = CreateDataSource(csb.ConnectionString);
1186          await using var conn = await dataSource.OpenConnectionAsync();
1187          await conn.CloseAsync();
1188          await conn.OpenAsync();
1189          using var cts = new CancellationTokenSource();
1190          var queryTask = conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;, cancellationToken: cts.Token);
1191          var server = await postmasterMock.WaitForServerConnection();
1192          await server.ExpectSimpleQuery(&quot;DISCARD ALL&quot;);
1193          await server.ExpectExtendedQuery();
1194          var cancelTask = Task.Run(cts.Cancel);
1195          var cancellationRequestTask = postmasterMock.WaitForCancellationRequest().AsTask();
1196          await Task.Delay(1000);
1197          Assert.IsFalse(cancelTask.IsCompleted);
1198          Assert.IsFalse(cancellationRequestTask.IsCompleted);
1199          if (failPrependedQuery)
1200          {
1201              await server
1202                  .WriteErrorResponse(PostgresErrorCodes.SyntaxError)
1203                  .WriteReadyForQuery()
1204                  .FlushAsync();
1205              await cancelTask;
1206              await cancellationRequestTask;
1207              Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await queryTask);
1208              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
1209              return;
1210          }
1211          await server
1212              .WriteCommandComplete()
1213              .WriteReadyForQuery()
1214              .FlushAsync();
1215          await cancelTask;
1216          await cancellationRequestTask;
1217          await server
1218              .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1219              .WriteReadyForQuery()
1220              .FlushAsync();
1221          Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await queryTask);
1222          queryTask = conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;);
1223          await server.ExpectExtendedQuery();
1224          await server
1225              .WriteParseComplete()
1226              .WriteBindComplete()
1227              .WriteNoData()
1228              .WriteCommandComplete()
1229              .WriteReadyForQuery()
1230              .FlushAsync();
1231          await queryTask;
1232      }
1233      #region Logging
1234      [Test]
1235      public async Task Log_ExecuteScalar_single_statement_without_parameters()
1236      {
1237          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1238          await using var conn = await dataSource.OpenConnectionAsync();
1239          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
1240          using (listLoggerProvider.Record())
1241          {
1242              await cmd.ExecuteScalarAsync();
1243          }
1244          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1245          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;).And.Contains(&quot;SELECT 1&quot;));
1246          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT 1&quot;);
1247          AssertLoggingStateDoesNotContain(executingCommandEvent, &quot;Parameters&quot;);
1248          if (!IsMultiplexing)
1249              AssertLoggingStateContains(executingCommandEvent, &quot;ConnectorId&quot;, conn.ProcessID);
1250      }
1251      [Test]
1252      public async Task Log_ExecuteScalar_single_statement_with_positional_parameters()
1253      {
1254          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1255          await using var conn = await dataSource.OpenConnectionAsync();
1256          await using var cmd = new NpgsqlCommand(&quot;SELECT $1, $2&quot;, conn);
1257          cmd.Parameters.Add(new() { Value = 8 });
1258          cmd.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1259          using (listLoggerProvider.Record())
1260          {
1261              await cmd.ExecuteScalarAsync();
1262          }
1263          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1264          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;)
1265              .And.Contains(&quot;SELECT $1, $2&quot;)
1266              .And.Contains(&quot;Parameters: [8, NULL]&quot;));
1267          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT $1, $2&quot;);
1268          AssertLoggingStateContains(executingCommandEvent, &quot;Parameters&quot;, new object[] { 8, &quot;NULL&quot; });
1269          if (!IsMultiplexing)
1270              AssertLoggingStateContains(executingCommandEvent, &quot;ConnectorId&quot;, conn.ProcessID);
1271      }
1272      [Test]
1273      public async Task Log_ExecuteScalar_single_statement_with_named_parameters()
1274      {
1275          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1276          await using var conn = await dataSource.OpenConnectionAsync();
1277          await using var cmd = new NpgsqlCommand(&quot;SELECT @p1, @p2&quot;, conn);
1278          cmd.Parameters.Add(new() { ParameterName = &quot;p1&quot;, Value = 8 });
1279          cmd.Parameters.Add(new() { ParameterName = &quot;p2&quot;, NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1280          using (listLoggerProvider.Record())
1281          {
1282              await cmd.ExecuteScalarAsync();
1283          }
1284          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1285          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;)
1286              .And.Contains(&quot;SELECT $1, $2&quot;)
1287              .And.Contains(&quot;Parameters: [8, NULL]&quot;));
1288          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT $1, $2&quot;);
1289          AssertLoggingStateContains(executingCommandEvent, &quot;Parameters&quot;, new object[] { 8, &quot;NULL&quot; });
1290          if (!IsMultiplexing)
1291              AssertLoggingStateContains(executingCommandEvent, &quot;ConnectorId&quot;, conn.ProcessID);
1292      }
1293      [Test]
1294      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
1295      {
1296          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
1297          await using var conn = await dataSource.OpenConnectionAsync();
1298          await using var cmd = new NpgsqlCommand(&quot;SELECT $1, $2&quot;, conn);
1299          cmd.Parameters.Add(new() { Value = 8 });
1300          cmd.Parameters.Add(new() { Value = 9 });
1301          using (listLoggerProvider.Record())
1302          {
1303              await cmd.ExecuteScalarAsync();
1304          }
1305          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1306          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;).And.Contains($&quot;SELECT $1, $2&quot;));
1307          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT $1, $2&quot;);
1308          AssertLoggingStateDoesNotContain(executingCommandEvent, &quot;Parameters&quot;);
1309      }
1310      #endregion Logging
1311      public CommandTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1312  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</h3>
            <pre><code>1  using Npgsql.BackendMessages;
2  using Npgsql.Internal;
3  using Npgsql.Tests.Support;
4  using Npgsql.TypeMapping;
5  using NpgsqlTypes;
6  using NUnit.Framework;
7  using System;
8  using System.Buffers.Binary;
9  using System.Data;
10  using System.Linq;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using static Npgsql.Tests.TestUtil;
15  namespace Npgsql.Tests;
16  public class CommandTests : MultiplexingTestBase
17  {
18      #region Legacy batching
19      [Test]
20      [TestCase(new[] { true }, TestName = &quot;SingleQuery&quot;)]
21      [TestCase(new[] { false }, TestName = &quot;SingleNonQuery&quot;)]
22      [TestCase(new[] { true, true }, TestName = &quot;TwoQueries&quot;)]
23      [TestCase(new[] { false, false }, TestName = &quot;TwoNonQueries&quot;)]
24      [TestCase(new[] { false, true }, TestName = &quot;NonQueryQuery&quot;)]
25      [TestCase(new[] { true, false }, TestName = &quot;QueryNonQuery&quot;)]
26      public async Task Multiple_statements(bool[] queries)
27      {
28          await using var conn = await OpenConnectionAsync();
29          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
30          var sb = new StringBuilder();
31          foreach (var query in queries)
32              sb.Append(query ? &quot;SELECT 1;&quot; : $&quot;UPDATE {table} SET name=&#x27;yo&#x27; WHERE 1=0;&quot;);
33          var sql = sb.ToString();
34          foreach (var prepare in new[] { false, true })
35          {
36              await using var cmd = conn.CreateCommand();
37              cmd.CommandText = sql;
38              if (prepare &amp;&amp; !IsMultiplexing)
39                  await cmd.PrepareAsync();
40              await using var reader = await cmd.ExecuteReaderAsync();
41              var numResultSets = queries.Count(q =&gt; q);
42              for (var i = 0; i &lt; numResultSets; i++)
43              {
44                  Assert.That(await reader.ReadAsync(), Is.True);
45                  Assert.That(reader[0], Is.EqualTo(1));
46                  Assert.That(await reader.NextResultAsync(), Is.EqualTo(i != numResultSets - 1));
47              }
48          }
49      }
50      [Test]
51      public async Task Multiple_statements_with_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
52      {
53          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
54              return;
55          await using var conn = await OpenConnectionAsync();
56          await using var cmd = conn.CreateCommand();
57          cmd.CommandText = &quot;SELECT @p1; SELECT @p2&quot;;
58          var p1 = new NpgsqlParameter(&quot;p1&quot;, NpgsqlDbType.Integer);
59          var p2 = new NpgsqlParameter(&quot;p2&quot;, NpgsqlDbType.Text);
60          cmd.Parameters.Add(p1);
61          cmd.Parameters.Add(p2);
62          if (prepare == PrepareOrNot.Prepared)
63              cmd.Prepare();
64          p1.Value = 8;
65          p2.Value = &quot;foo&quot;;
66          await using var reader = await cmd.ExecuteReaderAsync();
67          Assert.That(await reader.ReadAsync(), Is.True);
68          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
69          Assert.That(await reader.NextResultAsync(), Is.True);
70          Assert.That(await reader.ReadAsync(), Is.True);
71          Assert.That(reader.GetString(0), Is.EqualTo(&quot;foo&quot;));
72          Assert.That(await reader.NextResultAsync(), Is.False);
73      }
74      [Test]
75      public async Task SingleRow_legacy_batching([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
76      {
77          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
78              return;
79          using var conn = await OpenConnectionAsync();
80          using var cmd = new NpgsqlCommand(&quot;SELECT 1; SELECT 2&quot;, conn);
81          if (prepare == PrepareOrNot.Prepared)
82              cmd.Prepare();
83          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
84          Assert.That(reader.Read(), Is.True);
85          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
86          Assert.That(reader.Read(), Is.False);
87          Assert.That(reader.NextResult(), Is.False);
88      }
89      [Test, Description(&quot;Makes sure a later command can depend on an earlier one&quot;)]
90      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/641&quot;)]
91      public async Task Multiple_statements_with_dependencies()
92      {
93          using var conn = await OpenConnectionAsync();
94          var table = await CreateTempTable(conn, &quot;a INT&quot;);
95          await conn.ExecuteNonQueryAsync($&quot;ALTER TABLE {table} ADD COLUMN b INT; INSERT INTO {table} (b) VALUES (8)&quot;);
96          Assert.That(await conn.ExecuteScalarAsync($&quot;SELECT b FROM {table}&quot;), Is.EqualTo(8));
97      }
98      [Test, Description(&quot;Forces async write mode when the first statement in a multi-statement command is big&quot;)]
99      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/641&quot;)]
100      public async Task Multiple_statements_large_first_command()
101      {
102          using var conn = await OpenConnectionAsync();
103          using var cmd = new NpgsqlCommand($&quot;SELECT repeat(&#x27;X&#x27;, {conn.Settings.WriteBufferSize}); SELECT @p&quot;, conn);
104          var expected1 = new string(&#x27;X&#x27;, conn.Settings.WriteBufferSize);
105          var expected2 = new string(&#x27;Y&#x27;, conn.Settings.WriteBufferSize);
106          cmd.Parameters.AddWithValue(&quot;p&quot;, expected2);
107          using var reader = await cmd.ExecuteReaderAsync();
108          reader.Read();
109          Assert.That(reader.GetString(0), Is.EqualTo(expected1));
110          reader.NextResult();
111          reader.Read();
112          Assert.That(reader.GetString(0), Is.EqualTo(expected2));
113      }
114      [Test]
115      [NonParallelizable] 
116      public async Task Legacy_batching_is_not_supported_when_EnableSqlParsing_is_disabled()
117      {
118          using var _ = DisableSqlRewriting();
119          using var conn = await OpenConnectionAsync();
120          using var cmd = new NpgsqlCommand(&quot;SELECT 1; SELECT 2&quot;, conn);
121          Assert.That(async () =&gt; await cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf&lt;PostgresException&gt;()
122              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
123      }
124      #endregion
125      #region Timeout
126      [Test, Description(&quot;Checks that CommandTimeout gets enforced as a socket timeout&quot;)]
127      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/327&quot;)]
128      public async Task Timeout()
129      {
130          if (IsMultiplexing)
131              return; 
132          await using var dataSource = CreateDataSource(csb =&gt; csb.CommandTimeout = 1);
133          await using var conn = await dataSource.OpenConnectionAsync();
134          await using var cmd = CreateSleepCommand(conn, 10);
135          Assert.That(() =&gt; cmd.ExecuteNonQuery(), Throws.Exception
136              .TypeOf&lt;NpgsqlException&gt;()
137              .With.InnerException.TypeOf&lt;TimeoutException&gt;()
138          );
139          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
140      }
141      [Test, Description(&quot;Times out an async operation, testing that cancellation occurs successfully&quot;)]
142      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/607&quot;)]
143      public async Task Timeout_async_soft()
144      {
145          if (IsMultiplexing)
146              return; 
147          await using var dataSource = CreateDataSource(csb =&gt; csb.CommandTimeout = 1);
148          await using var conn = await dataSource.OpenConnectionAsync();
149          await using var cmd = CreateSleepCommand(conn, 10);
150          Assert.That(async () =&gt; await cmd.ExecuteNonQueryAsync(),
151              Throws.Exception
152                  .TypeOf&lt;NpgsqlException&gt;()
153                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
154          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
155      }
156      [Test, Description(&quot;Times out an async operation, with unsuccessful cancellation (socket break)&quot;)]
157      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/607&quot;)]
158      public async Task Timeout_async_hard()
159      {
160          if (IsMultiplexing)
161              return; 
162          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
163          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
165          await using var conn = await dataSource.OpenConnectionAsync();
166          await postmasterMock.WaitForServerConnection();
167          var processId = conn.ProcessID;
168          Assert.That(async () =&gt; await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;),
169              Throws.Exception
170                  .TypeOf&lt;NpgsqlException&gt;()
171                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
172          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
173          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
174              Is.EqualTo(processId));
175      }
176      [Test]
177      public async Task Timeout_from_connection_string()
178      {
179          Assert.That(NpgsqlConnector.MinimumInternalCommandTimeout, Is.Not.EqualTo(NpgsqlCommand.DefaultTimeout));
180          var timeout = NpgsqlConnector.MinimumInternalCommandTimeout;
181          await using var dataSource = CreateDataSource(csb =&gt; csb.CommandTimeout = timeout);
182          await using var conn = await dataSource.OpenConnectionAsync();
183          await using var command = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
184          Assert.That(command.CommandTimeout, Is.EqualTo(timeout));
185          command.CommandTimeout = 10;
186          await command.ExecuteScalarAsync();
187          Assert.That(command.CommandTimeout, Is.EqualTo(10));
188      }
189      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/395&quot;)]
190      public async Task Timeout_switch_connection()
191      {
192          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
193          if (csb.CommandTimeout &gt;= 100 &amp;&amp; csb.CommandTimeout &lt; 105)
194              IgnoreExceptOnBuildServer(&quot;Bad default command timeout&quot;);
195          await using var dataSource1 = CreateDataSource(ConnectionString + &quot;;CommandTimeout=100&quot;);
196          await using var c1 = dataSource1.CreateConnection();
197          await using var cmd = c1.CreateCommand();
198          Assert.That(cmd.CommandTimeout, Is.EqualTo(100));
199          await using var dataSource2 = CreateDataSource(ConnectionString + &quot;;CommandTimeout=101&quot;);
200          await using (var c2 = dataSource2.CreateConnection())
201          {
202              cmd.Connection = c2;
203              Assert.That(cmd.CommandTimeout, Is.EqualTo(101));
204          }
205          cmd.CommandTimeout = 102;
206          await using (var c2 = dataSource2.CreateConnection())
207          {
208              cmd.Connection = c2;
209              Assert.That(cmd.CommandTimeout, Is.EqualTo(102));
210          }
211      }
212      [Test]
213      public async Task Prepare_timeout_hard([Values] SyncOrAsync async)
214      {
215          if (IsMultiplexing)
216              return; 
217          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
218          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
219          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
220          await using var conn = await dataSource.OpenConnectionAsync();
221          await postmasterMock.WaitForServerConnection();
222          var processId = conn.ProcessID;
223          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
224          Assert.That(async () =&gt;
225              {
226                  if (async == SyncOrAsync.Sync)
227                      cmd.Prepare();
228                  else
229                      await cmd.PrepareAsync();
230              },
231              Throws.Exception
232                  .TypeOf&lt;NpgsqlException&gt;()
233                  .With.InnerException.TypeOf&lt;TimeoutException&gt;());
234          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
235          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
236              Is.EqualTo(processId));
237      }
238      #endregion
239      #region Cancel
240      [Test, Description(&quot;Basic cancellation scenario&quot;)]
241      [Ignore(&quot;Flaky, see https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/5070&quot;)]
242      public async Task Cancel()
243      {
244          if (IsMultiplexing)
245              return;
246          await using var conn = await OpenConnectionAsync();
247          await using var cmd = CreateSleepCommand(conn, 5);
248          var queryTask = Task.Run(() =&gt; cmd.ExecuteNonQuery());
249          cmd.WaitUntilCommandIsInProgress();
250          cmd.Cancel();
251          Assert.That(async () =&gt; await queryTask, Throws
252              .TypeOf&lt;OperationCanceledException&gt;()
253              .With.InnerException.TypeOf&lt;PostgresException&gt;()
254              .With.InnerException.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled)
255          );
256      }
257      [Test]
258      public async Task Cancel_async_immediately()
259      {
260          if (IsMultiplexing)
261              return; 
262          await using var conn = await OpenConnectionAsync();
263          await using var cmd = conn.CreateCommand();
264          cmd.CommandText = &quot;SELECT 1&quot;;
265          var t = cmd.ExecuteScalarAsync(new(canceled: true));
266          Assert.That(t.IsCompleted, Is.True); 
267          Assert.That(t.Status, Is.EqualTo(TaskStatus.Canceled));
268          Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t);
269          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
270          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
271      }
272      [Test, Description(&quot;Cancels an async query with the cancellation token, with successful PG cancellation&quot;)]
273      [Explicit(&quot;Flaky due to #5033&quot;)]
274      public async Task Cancel_async_soft()
275      {
276          if (IsMultiplexing)
277              return; 
278          await using var conn = await OpenConnectionAsync();
279          await using var cmd = CreateSleepCommand(conn);
280          using var cancellationSource = new CancellationTokenSource();
281          var t = cmd.ExecuteNonQueryAsync(cancellationSource.Token);
282          cancellationSource.Cancel();
283          var exception = Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t)!;
284          Assert.That(exception.InnerException,
285              Is.TypeOf&lt;PostgresException&gt;().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
286          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
287          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
288          Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
289      }
290      [Test, Description(&quot;Cancels an async query with the cancellation token, with unsuccessful PG cancellation (socket break)&quot;)]
291      public async Task Cancel_async_hard()
292      {
293          if (IsMultiplexing)
294              return; 
295          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
296          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
297          await using var conn = await dataSource.OpenConnectionAsync();
298          await postmasterMock.WaitForServerConnection();
299          var processId = conn.ProcessID;
300          using var cancellationSource = new CancellationTokenSource();
301          using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
302          var t = cmd.ExecuteScalarAsync(cancellationSource.Token);
303          cancellationSource.Cancel();
304          var exception = Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t)!;
305          Assert.That(exception.InnerException, Is.TypeOf&lt;TimeoutException&gt;());
306          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
307          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
308          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
309              Is.EqualTo(processId));
310      }
311      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3466&quot;)]
312      [Ignore(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4668&quot;)]
313      public async Task Bug3466([Values(false, true)] bool isBroken)
314      {
315          if (IsMultiplexing)
316              return; 
317          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
318          {
319              Pooling = false
320          };
321          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString(), completeCancellationImmediately: false);
322          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
323          await using var conn = await dataSource.OpenConnectionAsync();
324          var serverMock = await postmasterMock.WaitForServerConnection();
325          var processId = conn.ProcessID;
326          using var cancellationSource = new CancellationTokenSource();
327          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn)
328          {
329              CommandTimeout = 4
330          };
331          var t = Task.Run(() =&gt; cmd.ExecuteScalar());
332          cmd.WaitUntilCommandIsInProgress();
333          var cancelTask = Task.Run(() =&gt; cmd.Cancel());
334          var cancellationRequest = await postmasterMock.WaitForCancellationRequest();
335          if (isBroken)
336          {
337              Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await t);
338              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
339          }
340          else
341          {
342              await serverMock
343                  .WriteParseComplete()
344                  .WriteBindComplete()
345                  .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
346                  .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
347                  .WriteCommandComplete()
348                  .WriteReadyForQuery()
349                  .FlushAsync();
350              Assert.DoesNotThrowAsync(async () =&gt; await t);
351              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
352              await conn.CloseAsync();
353          }
354          cancellationRequest.Complete();
355          Assert.DoesNotThrowAsync(async () =&gt; await cancelTask);
356      }
357      [Test, Description(&quot;Check that cancel only affects the command on which its was invoked&quot;)]
358      [Explicit(&quot;Timing-sensitive&quot;)]
359      public async Task Cancel_cross_command()
360      {
361          await using var conn = await OpenConnectionAsync();
362          await using var cmd1 = CreateSleepCommand(conn, 2);
363          await using var cmd2 = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
364          var cancelTask = Task.Factory.StartNew(() =&gt;
365          {
366              Thread.Sleep(300);
367              cmd2.Cancel();
368          });
369          Assert.That(() =&gt; cmd1.ExecuteNonQueryAsync(), Throws.Nothing);
370          cancelTask.Wait();
371      }
372      #endregion
373      #region Cursors
374      [Test]
375      public async Task Cursor_statement()
376      {
377          using var conn = await OpenConnectionAsync();
378          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
379          using var t = conn.BeginTransaction();
380          for (var x = 0; x &lt; 5; x++)
381              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;);
382          var i = 0;
383          var command = new NpgsqlCommand($&quot;DECLARE TE CURSOR FOR SELECT * FROM {table}&quot;, conn);
384          command.ExecuteNonQuery();
385          command.CommandText = &quot;FETCH FORWARD 3 IN TE&quot;;
386          var dr = command.ExecuteReader();
387          while (dr.Read())
388              i++;
389          Assert.AreEqual(3, i);
390          dr.Close();
391          i = 0;
392          command.CommandText = &quot;FETCH BACKWARD 1 IN TE&quot;;
393          var dr2 = command.ExecuteReader();
394          while (dr2.Read())
395              i++;
396          Assert.AreEqual(1, i);
397          dr2.Close();
398          command.CommandText = &quot;close te;&quot;;
399          command.ExecuteNonQuery();
400      }
401      [Test]
402      public async Task Cursor_move_RecordsAffected()
403      {
404          using var connection = await OpenConnectionAsync();
405          using var transaction = connection.BeginTransaction();
406          var command = new NpgsqlCommand(&quot;DECLARE curs CURSOR FOR SELECT * FROM (VALUES (1), (2), (3)) as t&quot;, connection);
407          command.ExecuteNonQuery();
408          command.CommandText = &quot;MOVE FORWARD ALL IN curs&quot;;
409          var count = command.ExecuteNonQuery();
410          Assert.AreEqual(3, count);
411      }
412      #endregion
413      #region CommandBehavior.CloseConnection
414      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/693&quot;)]
415      public async Task CloseConnection()
416      {
417          using var conn = await OpenConnectionAsync();
418          using (var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn))
419          using (var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection))
420              while (reader.Read()) {}
421          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
422      }
423      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1194&quot;)]
424      public async Task CloseConnection_with_open_reader_with_CloseConnection()
425      {
426          using var conn = await OpenConnectionAsync();
427          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
428          var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection);
429          var wasClosed = false;
430          reader.ReaderClosed += (sender, args) =&gt; { wasClosed = true; };
431          conn.Close();
432          Assert.That(wasClosed, Is.True);
433      }
434      [Test]
435      public async Task CloseConnection_with_exception()
436      {
437          using var conn = await OpenConnectionAsync();
438          using (var cmd = new NpgsqlCommand(&quot;SE&quot;, conn))
439              Assert.That(() =&gt; cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection), Throws.Exception.TypeOf&lt;PostgresException&gt;());
440          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
441      }
442      #endregion
443      [Test]
444      public async Task SingleRow([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
445      {
446          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
447              return;
448          await using var conn = await OpenConnectionAsync();
449          await using var cmd = new NpgsqlCommand(&quot;SELECT 1, 2 UNION SELECT 3, 4&quot;, conn);
450          if (prepare == PrepareOrNot.Prepared)
451              cmd.Prepare();
452          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
453          Assert.That(() =&gt; reader.GetInt32(0), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
454          Assert.That(reader.Read(), Is.True);
455          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
456          Assert.That(reader.Read(), Is.False);
457      }
458      #region Parameters
459      [Test]
460      public async Task Positional_parameter()
461      {
462          await using var conn = await OpenConnectionAsync();
463          await using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn);
464          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
465          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
466      }
467      [Test]
468      public async Task Positional_parameters_are_not_supported_with_legacy_batching()
469      {
470          await using var conn = await OpenConnectionAsync();
471          await using var cmd = new NpgsqlCommand(&quot;SELECT $1; SELECT $1&quot;, conn);
472          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
473          Assert.That(async () =&gt; await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;PostgresException&gt;()
474              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
475      }
476      [Test]
477      [NonParallelizable] 
478      public async Task Positional_parameters_are_supported_when_EnableSqlParsing_is_disabled()
479      {
480          using var _ = DisableSqlRewriting();
481          using var conn = await OpenConnectionAsync();
482          using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn);
483          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
484          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
485      }
486      [Test]
487      [NonParallelizable] 
488      public async Task Named_parameters_are_not_supported_when_EnableSqlParsing_is_disabled()
489      {
490          using var _ = DisableSqlRewriting();
491          using var conn = await OpenConnectionAsync();
492          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
493          cmd.Parameters.Add(new NpgsqlParameter(&quot;p&quot;, 8));
494          Assert.That(async () =&gt; await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
495      }
496      [Test, Description(&quot;Makes sure writing an unset parameter isn&#x27;t allowed&quot;)]
497      public async Task Parameter_without_Value()
498      {
499          using var conn = await OpenConnectionAsync();
500          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
501          cmd.Parameters.Add(new NpgsqlParameter(&quot;@p&quot;, NpgsqlDbType.Integer));
502          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;InvalidCastException&gt;());
503      }
504      [Test]
505      public async Task Unreferenced_named_parameter_works()
506      {
507          await using var conn = await OpenConnectionAsync();
508          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
509          cmd.Parameters.AddWithValue(&quot;not_used&quot;, 8);
510          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
511      }
512      [Test]
513      public async Task Unreferenced_positional_parameter_works()
514      {
515          await using var conn = await OpenConnectionAsync();
516          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
517          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
518          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
519      }
520      [Test]
521      public async Task Mixing_positional_and_named_parameters_is_not_supported()
522      {
523          await using var conn = await OpenConnectionAsync();
524          await using var cmd = new NpgsqlCommand(&quot;SELECT $1, @p&quot;, conn);
525          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
526          cmd.Parameters.Add(new NpgsqlParameter { ParameterName = &quot;p&quot;, Value = 9 });
527          Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
528      }
529      [Test]
530      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4171&quot;)]
531      public async Task Cached_command_clears_parameters_placeholder_type()
532      {
533          await using var conn = await OpenConnectionAsync();
534          await using (var cmd1 = conn.CreateCommand())
535          {
536              cmd1.CommandText = &quot;SELECT @p1&quot;;
537              cmd1.Parameters.AddWithValue(&quot;@p1&quot;, 8);
538              await using var reader1 = await cmd1.ExecuteReaderAsync();
539              reader1.Read();
540              Assert.That(reader1[0], Is.EqualTo(8));
541          }
542          await using (var cmd2 = conn.CreateCommand())
543          {
544              cmd2.CommandText = &quot;SELECT $1&quot;;
545              cmd2.Parameters.AddWithValue(8);
546              await using var reader2 = await cmd2.ExecuteReaderAsync();
547              reader2.Read();
548              Assert.That(reader2[0], Is.EqualTo(8));
549          }
550      }
551      [Test]
552      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4171&quot;)]
553      public async Task Reuse_command_with_different_parameter_placeholder_types()
554      {
555          await using var conn = await OpenConnectionAsync();
556          await using var cmd = conn.CreateCommand();
557          cmd.CommandText = &quot;SELECT @p1&quot;;
558          cmd.Parameters.AddWithValue(&quot;@p1&quot;, 8);
559          _ = await cmd.ExecuteScalarAsync();
560          cmd.CommandText = &quot;SELECT $1&quot;;
561          cmd.Parameters[0].ParameterName = null;
562          _ = await cmd.ExecuteScalarAsync();
563      }
564      [Test]
565      public async Task Positional_output_parameters_are_not_supported()
566      {
567          await using var conn = await OpenConnectionAsync();
568          await using var cmd = new NpgsqlCommand(&quot;SELECT $1&quot;, conn);
569          cmd.Parameters.Add(new NpgsqlParameter { Value = 8, Direction = ParameterDirection.InputOutput });
570          Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
571      }
572      [Test]
573      public void Parameters_get_name()
574      {
575          var command = new NpgsqlCommand();
576          command.Parameters.Add(new NpgsqlParameter(&quot;:Parameter1&quot;, DbType.Boolean));
577          command.Parameters.Add(new NpgsqlParameter(&quot;:Parameter2&quot;, DbType.Int32));
578          command.Parameters.Add(new NpgsqlParameter(&quot;:Parameter3&quot;, DbType.DateTime));
579          command.Parameters.Add(new NpgsqlParameter(&quot;Parameter4&quot;, DbType.DateTime));
580          var idbPrmtr = command.Parameters[&quot;Parameter1&quot;];
581          Assert.IsNotNull(idbPrmtr);
582          command.Parameters[0].Value = 1;
583          Assert.AreEqual(&quot;:Parameter1&quot;, command.Parameters[&quot;Parameter1&quot;].ParameterName);
584          Assert.AreEqual(&quot;:Parameter2&quot;, command.Parameters[&quot;Parameter2&quot;].ParameterName);
585          Assert.AreEqual(&quot;:Parameter3&quot;, command.Parameters[&quot;Parameter3&quot;].ParameterName);
586          Assert.AreEqual(&quot;Parameter4&quot;, command.Parameters[&quot;Parameter4&quot;].ParameterName); 
587          Assert.AreEqual(&quot;:Parameter1&quot;, command.Parameters[0].ParameterName);
588          Assert.AreEqual(&quot;:Parameter2&quot;, command.Parameters[1].ParameterName);
589          Assert.AreEqual(&quot;:Parameter3&quot;, command.Parameters[2].ParameterName);
590          Assert.AreEqual(&quot;Parameter4&quot;, command.Parameters[3].ParameterName);
591      }
592      [Test]
593      public async Task Same_param_multiple_times()
594      {
595          using var conn = await OpenConnectionAsync();
596          using var cmd = new NpgsqlCommand(&quot;SELECT @p1, @p1&quot;, conn);
597          cmd.Parameters.AddWithValue(&quot;@p1&quot;, 8);
598          using var reader = await cmd.ExecuteReaderAsync();
599          reader.Read();
600          Assert.That(reader[0], Is.EqualTo(8));
601          Assert.That(reader[1], Is.EqualTo(8));
602      }
603      [Test]
604      public async Task Generic_parameter()
605      {
606          using var conn = await OpenConnectionAsync();
607          using var cmd = new NpgsqlCommand(&quot;SELECT @p1, @p2, @p3, @p4&quot;, conn);
608          cmd.Parameters.Add(new NpgsqlParameter&lt;int&gt;(&quot;p1&quot;, 8));
609          cmd.Parameters.Add(new NpgsqlParameter&lt;short&gt;(&quot;p2&quot;, 8) { NpgsqlDbType = NpgsqlDbType.Integer });
610          cmd.Parameters.Add(new NpgsqlParameter&lt;string&gt;(&quot;p3&quot;, &quot;hello&quot;));
611          cmd.Parameters.Add(new NpgsqlParameter&lt;char[]&gt;(&quot;p4&quot;, new[] { &#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27; }));
612          using var reader = await cmd.ExecuteReaderAsync();
613          reader.Read();
614          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
615          Assert.That(reader.GetInt32(1), Is.EqualTo(8));
616          Assert.That(reader.GetString(2), Is.EqualTo(&quot;hello&quot;));
617          Assert.That(reader.GetString(3), Is.EqualTo(&quot;foo&quot;));
618      }
619      #endregion Parameters
620      [Test]
621      public async Task CommandText_not_set()
622      {
623          await using var conn = await OpenConnectionAsync();
624          await using (var cmd = new NpgsqlCommand())
625          {
626              cmd.Connection = conn;
627              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
628              cmd.CommandText = null;
629              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
630              cmd.CommandText = &quot;&quot;;
631          }
632          await using (var cmd = conn.CreateCommand())
633              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
634      }
635      [Test]
636      public async Task ExecuteScalar()
637      {
638          await using var conn = await OpenConnectionAsync();
639          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
640          await using var command = new NpgsqlCommand($&quot;SELECT name FROM {table}&quot;, conn);
641          Assert.That(command.ExecuteScalarAsync, Is.Null);
642          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (NULL)&quot;);
643          Assert.That(command.ExecuteScalarAsync, Is.EqualTo(DBNull.Value));
644          await conn.ExecuteNonQueryAsync($&quot;TRUNCATE {table}&quot;);
645          for (var i = 0; i &lt; 2; i++)
646              await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;X&#x27;)&quot;);
647          Assert.That(command.ExecuteScalarAsync, Is.EqualTo(&quot;X&quot;));
648      }
649      [Test]
650      public async Task ExecuteNonQuery()
651      {
652          await using var conn = await OpenConnectionAsync();
653          await using var cmd = new NpgsqlCommand { Connection = conn };
654          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
655          cmd.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;John&#x27;)&quot;;
656          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
657          cmd.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;John&#x27;); INSERT INTO {table} (name) VALUES (&#x27;John&#x27;)&quot;;
658          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(2));
659          cmd.CommandText = $&quot;INSERT INTO {table} (name) VALUES (&#x27;{new string(&#x27;x&#x27;, conn.Settings.WriteBufferSize)}&#x27;)&quot;;
660          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
661      }
662      [Test, Description(&quot;Makes sure a command is unusable after it is disposed&quot;)]
663      public async Task Dispose()
664      {
665          await using var conn = await OpenConnectionAsync();
666          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
667          cmd.Dispose();
668          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
669          Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
670          Assert.That(() =&gt; cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
671          Assert.That(() =&gt; cmd.PrepareAsync(), Throws.Exception.TypeOf&lt;ObjectDisposedException&gt;());
672      }
673      [Test, Description(&quot;Disposing a command with an open reader does not close the reader. This is the SqlClient behavior.&quot;)]
674      public async Task Command_Dispose_does_not_close_reader()
675      {
676          await using var conn = await OpenConnectionAsync();
677          var cmd = new NpgsqlCommand(&quot;SELECT 1, 2&quot;, conn);
678          await cmd.ExecuteReaderAsync();
679          cmd.Dispose();
680          cmd = new NpgsqlCommand(&quot;SELECT 3&quot;, conn);
681          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;NpgsqlOperationInProgressException&gt;());
682      }
683      [Test]
684      public async Task Non_standards_conforming_strings()
685      {
686          await using var dataSource = CreateDataSource();
687          await using var conn = await dataSource.OpenConnectionAsync();
688          if (IsMultiplexing)
689          {
690              Assert.That(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;set standard_conforming_strings=off&quot;),
691                  Throws.Exception.TypeOf&lt;NotSupportedException&gt;());
692          }
693          else
694          {
695              await conn.ExecuteNonQueryAsync(&quot;set standard_conforming_strings=off&quot;);
696              Assert.That(await conn.ExecuteScalarAsync(&quot;SELECT 1&quot;), Is.EqualTo(1));
697              await conn.ExecuteNonQueryAsync(&quot;set standard_conforming_strings=on&quot;);
698          }
699      }
700      [Test]
701      public async Task Parameter_and_operator_unclear()
702      {
703          await using var conn = await OpenConnectionAsync();
704          await using var command = new NpgsqlCommand(&quot;select :arr[2]&quot;, conn);
705          command.Parameters.AddWithValue(&quot;:arr&quot;, new int[] {5, 4, 3, 2, 1});
706          await using var rdr = await command.ExecuteReaderAsync();
707          rdr.Read();
708          Assert.AreEqual(rdr.GetInt32(0), 4);
709      }
710      [Test]
711      [TestCase(CommandBehavior.Default)]
712      [TestCase(CommandBehavior.SequentialAccess)]
713      public async Task Statement_mapped_output_parameters(CommandBehavior behavior)
714      {
715          await using var conn = await OpenConnectionAsync();
716          var command = new NpgsqlCommand(&quot;select 3, 4 as param1, 5 as param2, 6;&quot;, conn);
717          var p = new NpgsqlParameter(&quot;param2&quot;, NpgsqlDbType.Integer);
718          p.Direction = ParameterDirection.Output;
719          p.Value = -1;
720          command.Parameters.Add(p);
721          p = new NpgsqlParameter(&quot;param1&quot;, NpgsqlDbType.Integer);
722          p.Direction = ParameterDirection.Output;
723          p.Value = -1;
724          command.Parameters.Add(p);
725          p = new NpgsqlParameter(&quot;p&quot;, NpgsqlDbType.Integer);
726          p.Direction = ParameterDirection.Output;
727          p.Value = -1;
728          command.Parameters.Add(p);
729          await using var reader = await command.ExecuteReaderAsync(behavior);
730          Assert.AreEqual(4, command.Parameters[&quot;param1&quot;].Value);
731          Assert.AreEqual(5, command.Parameters[&quot;param2&quot;].Value);
732          reader.Read();
733          Assert.AreEqual(3, reader.GetInt32(0));
734          Assert.AreEqual(4, reader.GetInt32(1));
735          Assert.AreEqual(5, reader.GetInt32(2));
736          Assert.AreEqual(6, reader.GetInt32(3));
737      }
738      [Test]
739      public async Task Bug1006158_output_parameters()
740      {
741          await using var conn = await OpenConnectionAsync();
742          MinimumPgVersion(conn, &quot;14.0&quot;, &quot;Stored procedure OUT parameters are only support starting with version 14&quot;);
743          var sproc = await GetTempProcedureName(conn);
744          var createFunction = $@&quot;
745  CREATE PROCEDURE {sproc}(OUT a integer, OUT b boolean) AS $$
746  BEGIN
747      a := 3;
748      b := true;
749  END
750  $$ LANGUAGE plpgsql;&quot;;
751          var command = new NpgsqlCommand(createFunction, conn);
752          await command.ExecuteNonQueryAsync();
753          command = new NpgsqlCommand(sproc, conn);
754          command.CommandType = CommandType.StoredProcedure;
755          command.Parameters.Add(new NpgsqlParameter(&quot;a&quot;, DbType.Int32));
756          command.Parameters[0].Direction = ParameterDirection.Output;
757          command.Parameters.Add(new NpgsqlParameter(&quot;b&quot;, DbType.Boolean));
758          command.Parameters[1].Direction = ParameterDirection.Output;
759          _ = await command.ExecuteScalarAsync();
760          Assert.AreEqual(3, command.Parameters[0].Value);
761          Assert.AreEqual(true, command.Parameters[1].Value);
762      }
763      [Test]
764      public async Task Bug1010788_UpdateRowSource()
765      {
766          if (IsMultiplexing)
767              return;
768          using var conn = await OpenConnectionAsync();
769          var table = await CreateTempTable(conn, &quot;id SERIAL PRIMARY KEY, name TEXT&quot;);
770          var command = new NpgsqlCommand($&quot;SELECT * FROM {table}&quot;, conn);
771          Assert.AreEqual(UpdateRowSource.Both, command.UpdatedRowSource);
772          var cmdBuilder = new NpgsqlCommandBuilder();
773          var da = new NpgsqlDataAdapter(command);
774          cmdBuilder.DataAdapter = da;
775          Assert.IsNotNull(da.SelectCommand);
776          Assert.IsNotNull(cmdBuilder.DataAdapter);
777          var updateCommand = cmdBuilder.GetUpdateCommand();
778          Assert.AreEqual(UpdateRowSource.None, updateCommand.UpdatedRowSource);
779      }
780      [Test]
781      public async Task TableDirect()
782      {
783          using var conn = await OpenConnectionAsync();
784          var table = await CreateTempTable(conn, &quot;name TEXT&quot;);
785          await conn.ExecuteNonQueryAsync($&quot;INSERT INTO {table} (name) VALUES (&#x27;foo&#x27;)&quot;);
786          using var cmd = new NpgsqlCommand(table, conn) { CommandType = CommandType.TableDirect };
787          using var rdr = await cmd.ExecuteReaderAsync();
788          Assert.That(rdr.Read(), Is.True);
789          Assert.That(rdr[&quot;name&quot;], Is.EqualTo(&quot;foo&quot;));
790      }
791      [Test]
792      [TestCase(CommandBehavior.Default)]
793      [TestCase(CommandBehavior.SequentialAccess)]
794      public async Task Input_and_output_parameters(CommandBehavior behavior)
795      {
796          using var conn = await OpenConnectionAsync();
797          using var cmd = new NpgsqlCommand(&quot;SELECT @c-1 AS c, @a+2 AS b&quot;, conn);
798          cmd.Parameters.Add(new NpgsqlParameter(&quot;a&quot;, 3));
799          var b = new NpgsqlParameter { ParameterName = &quot;b&quot;, Direction = ParameterDirection.Output };
800          cmd.Parameters.Add(b);
801          var c = new NpgsqlParameter { ParameterName = &quot;c&quot;, Direction = ParameterDirection.InputOutput, Value = 4 };
802          cmd.Parameters.Add(c);
803          using (await cmd.ExecuteReaderAsync(behavior))
804          {
805              Assert.AreEqual(5, b.Value);
806              Assert.AreEqual(3, c.Value);
807          }
808      }
809      [Test]
810      public async Task Send_NpgsqlDbType_Unknown([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
811      {
812          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
813              return;
814          using var conn = await OpenConnectionAsync();
815          using var cmd = new NpgsqlCommand(&quot;SELECT @p::TIMESTAMP&quot;, conn);
816          cmd.CommandText = &quot;SELECT @p::TIMESTAMP&quot;;
817          cmd.Parameters.Add(new NpgsqlParameter(&quot;p&quot;, NpgsqlDbType.Unknown) { Value = &quot;2008-1-1&quot; });
818          if (prepare == PrepareOrNot.Prepared)
819              cmd.Prepare();
820          using var reader = await cmd.ExecuteReaderAsync();
821          reader.Read();
822          Assert.That(reader.GetValue(0), Is.EqualTo(new DateTime(2008, 1, 1)));
823      }
824      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/503&quot;)]
825      public async Task Invalid_UTF8()
826      {
827          const string badString = &quot;SELECT &#x27;abc\uD801\uD802d&#x27;&quot;;
828          await using var dataSource = CreateDataSource();
829          using var conn = await dataSource.OpenConnectionAsync();
830          Assert.That(() =&gt; conn.ExecuteScalarAsync(badString), Throws.Exception.TypeOf&lt;EncoderFallbackException&gt;());
831      }
832      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/395&quot;)]
833      public async Task Use_across_connection_change([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
834      {
835          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
836              return;
837          using var conn1 = await OpenConnectionAsync();
838          using var conn2 = await OpenConnectionAsync();
839          using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn1);
840          if (prepare == PrepareOrNot.Prepared)
841              cmd.Prepare();
842          cmd.Connection = conn2;
843          Assert.That(cmd.IsPrepared, Is.False);
844          if (prepare == PrepareOrNot.Prepared)
845              cmd.Prepare();
846          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
847      }
848      [Test, Description(&quot;CreateCommand before connection open&quot;)]
849      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/565&quot;)]
850      public async Task Create_command_before_connection_open()
851      {
852          using var conn = new NpgsqlConnection(ConnectionString);
853          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
854          conn.Open();
855          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
856      }
857      [Test]
858      public void Connection_not_set_throws()
859      {
860          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;);
861          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
862      }
863      [Test]
864      public void Connection_not_open_throws()
865      {
866          using var conn = CreateConnection();
867          var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
868          Assert.That(() =&gt; cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf&lt;InvalidOperationException&gt;());
869      }
870      [Test]
871      public async Task ExecuteNonQuery_Throws_PostgresException([Values] bool async)
872      {
873          if (!async &amp;&amp; IsMultiplexing)
874              return;
875          await using var conn = await OpenConnectionAsync();
876          var table1 = await CreateTempTable(conn, &quot;id integer PRIMARY key, t varchar(40)&quot;);
877          var table2 = await CreateTempTable(conn, $&quot;id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED&quot;);
878          var sql = $&quot;insert into {table2} ({table1}_id) values (1) returning id&quot;;
879          var ex = async
880              ? Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await conn.ExecuteNonQueryAsync(sql))
881              : Assert.Throws&lt;PostgresException&gt;(() =&gt; conn.ExecuteNonQuery(sql));
882          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
883      }
884      [Test]
885      public async Task ExecuteScalar_Throws_PostgresException([Values] bool async)
886      {
887          if (!async &amp;&amp; IsMultiplexing)
888              return;
889          await using var conn = await OpenConnectionAsync();
890          var table1 = await CreateTempTable(conn, &quot;id integer PRIMARY key, t varchar(40)&quot;);
891          var table2 = await CreateTempTable(conn, $&quot;id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED&quot;);
892          var sql = $&quot;insert into {table2} ({table1}_id) values (1) returning id&quot;;
893          var ex = async
894              ? Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await conn.ExecuteScalarAsync(sql))
895              : Assert.Throws&lt;PostgresException&gt;(() =&gt; conn.ExecuteScalar(sql));
896          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
897      }
898      [Test]
899      public async Task ExecuteReader_Throws_PostgresException([Values] bool async)
900      {
901          if (!async &amp;&amp; IsMultiplexing)
902              return;
903          await using var conn = await OpenConnectionAsync();
904          var table1 = await CreateTempTable(conn, &quot;id integer PRIMARY key, t varchar(40)&quot;);
905          var table2 = await CreateTempTable(conn, $&quot;id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED&quot;);
906          await using var cmd = conn.CreateCommand();
907          cmd.CommandText = $&quot;insert into {table2} ({table1}_id) values (1) returning id&quot;;
908          await using var reader = async
909              ? await cmd.ExecuteReaderAsync()
910              : cmd.ExecuteReader();
911          Assert.IsTrue(async ? await reader.ReadAsync() : reader.Read());
912          var value = reader.GetInt32(0);
913          Assert.That(value, Is.EqualTo(1));
914          Assert.IsFalse(async ? await reader.ReadAsync() : reader.Read());
915          var ex = async
916              ? Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await reader.NextResultAsync())
917              : Assert.Throws&lt;PostgresException&gt;(() =&gt; reader.NextResult());
918          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
919      }
920      [Test]
921      public void Command_is_recycled()
922      {
923          using var conn = OpenConnection();
924          var cmd1 = conn.CreateCommand();
925          cmd1.CommandText = &quot;SELECT @p1&quot;;
926          var tx = conn.BeginTransaction();
927          cmd1.Transaction = tx;
928          cmd1.Parameters.AddWithValue(&quot;p1&quot;, 8);
929          _ = cmd1.ExecuteScalar();
930          cmd1.Dispose();
931          var cmd2 = conn.CreateCommand();
932          Assert.That(cmd2, Is.SameAs(cmd1));
933          Assert.That(cmd2.CommandText, Is.Empty);
934          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
935          Assert.That(cmd2.Transaction, Is.Null);
936          Assert.That(cmd2.Parameters, Is.Empty);
937      }
938      [Test]
939      public void Command_recycled_resets_CommandType()
940      {
941          using var conn = CreateConnection();
942          var cmd1 = conn.CreateCommand();
943          cmd1.CommandType = CommandType.StoredProcedure;
944          cmd1.Dispose();
945          var cmd2 = conn.CreateCommand();
946          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
947      }
948      [Test]
949      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/831&quot;)]
950      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2795&quot;)]
951      public async Task Many_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
952      {
953          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
954              return;
955          using var conn = await OpenConnectionAsync();
956          var table = await CreateTempTable(conn, &quot;some_column INT&quot;);
957          using var cmd = new NpgsqlCommand { Connection = conn };
958          var sb = new StringBuilder($&quot;INSERT INTO {table} (some_column) VALUES &quot;);
959          for (var i = 0; i &lt; ushort.MaxValue; i++)
960          {
961              var paramName = &quot;p&quot; + i;
962              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
963              if (i &gt; 0)
964                  sb.Append(&quot;, &quot;);
965              sb.Append($&quot;(@{paramName})&quot;);
966          }
967          cmd.CommandText = sb.ToString();
968          if (prepare == PrepareOrNot.Prepared)
969              cmd.Prepare();
970          await cmd.ExecuteNonQueryAsync();
971      }
972      [Test, Description(&quot;Bypasses PostgreSQL&#x27;s uint16 limitation on the number of parameters&quot;)]
973      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/831&quot;)]
974      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/858&quot;)]
975      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/2703&quot;)]
976      public async Task Too_many_parameters_throws([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
977      {
978          if (prepare == PrepareOrNot.Prepared &amp;&amp; IsMultiplexing)
979              return;
980          using var conn = await OpenConnectionAsync();
981          using var cmd = new NpgsqlCommand { Connection = conn };
982          var sb = new StringBuilder(&quot;SOME RANDOM SQL &quot;);
983          for (var i = 0; i &lt; ushort.MaxValue + 1; i++)
984          {
985              var paramName = &quot;p&quot; + i;
<span onclick='openModal()' class='match'>986              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
987              if (i &gt; 0)
</span>988                  sb.Append(&quot;, &quot;);
989              sb.Append(&#x27;@&#x27;);
990              sb.Append(paramName);
991          }
992          cmd.CommandText = sb.ToString();
993          if (prepare == PrepareOrNot.Prepared)
994          {
995              Assert.That(() =&gt; cmd.Prepare(), Throws.Exception
996                  .InstanceOf&lt;NpgsqlException&gt;()
997                  .With.Message.EqualTo(&quot;A statement cannot have more than 65535 parameters&quot;));
998          }
999          else
1000          {
1001              Assert.That(() =&gt; cmd.ExecuteNonQueryAsync(), Throws.Exception
1002                  .InstanceOf&lt;NpgsqlException&gt;()
1003                  .With.Message.EqualTo(&quot;A statement cannot have more than 65535 parameters&quot;));
1004          }
1005      }
1006      [Test, Description(&quot;An individual statement cannot have more than 65535 parameters, but a command can (across multiple statements).&quot;)]
1007      [IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1199&quot;)]
1008      public async Task Many_parameters_across_statements()
1009      {
1010          using var conn = await OpenConnectionAsync();
1011          using var cmd = new NpgsqlCommand { Connection = conn };
1012          var paramIndex = 0;
1013          var sb = new StringBuilder();
1014          for (var statementIndex = 0; statementIndex &lt; 1000; statementIndex++)
1015          {
1016              if (statementIndex &gt; 0)
1017                  sb.Append(&quot;; &quot;);
1018              sb.Append(&quot;SELECT &quot;);
1019              var startIndex = paramIndex;
1020              var endIndex = paramIndex + 70;
1021              for (; paramIndex &lt; endIndex; paramIndex++)
1022              {
1023                  var paramName = &quot;p&quot; + paramIndex;
1024                  cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
1025                  if (paramIndex &gt; startIndex)
1026                      sb.Append(&quot;, &quot;);
1027                  sb.Append(&#x27;@&#x27;);
1028                  sb.Append(paramName);
1029              }
1030          }
1031          cmd.CommandText = sb.ToString();
1032          await cmd.ExecuteNonQueryAsync();
1033      }
1034      [Test, Description(&quot;Makes sure that Npgsql doesn&#x27;t attempt to send all data before the user can start reading. That would cause a deadlock.&quot;)]
1035      public async Task Batched_big_statements_do_not_deadlock()
1036      {
1037          var data = new string(&#x27;x&#x27;, 1024);
1038          using var conn = await OpenConnectionAsync();
1039          var sb = new StringBuilder();
1040          for (var i = 0; i &lt; 500; i++)
1041              sb.Append(&quot;SELECT @p;&quot;);
1042          using var cmd = new NpgsqlCommand(sb.ToString(), conn);
1043          cmd.Parameters.AddWithValue(&quot;p&quot;, NpgsqlDbType.Text, data);
1044          using var reader = await cmd.ExecuteReaderAsync();
1045          for (var i = 0; i &lt; 500; i++)
1046          {
1047              reader.Read();
1048              Assert.That(reader.GetString(0), Is.EqualTo(data));
1049              reader.NextResult();
1050          }
1051      }
1052      [Test]
1053      public void Batched_small_then_big_statements_do_not_deadlock_in_sync_io()
1054      {
1055          if (IsMultiplexing)
1056              return; 
1057          using var conn = OpenConnection();
1058          var data = new string(&#x27;x&#x27;, 5_000_000);
1059          using var cmd = new NpgsqlCommand(&quot;SELECT generate_series(1, 500000); SELECT @p&quot;, conn);
1060          cmd.Parameters.AddWithValue(&quot;p&quot;, NpgsqlDbType.Text, data);
1061          cmd.ExecuteNonQuery();
1062      }
1063      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1429&quot;)]
1064      public async Task Same_command_different_param_values()
1065      {
1066          using var conn = await OpenConnectionAsync();
1067          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
1068          cmd.Parameters.AddWithValue(&quot;p&quot;, 8);
1069          await cmd.ExecuteNonQueryAsync();
1070          cmd.Parameters[0].Value = 9;
1071          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1072      }
1073      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/1429&quot;)]
1074      public async Task Same_command_different_param_instances()
1075      {
1076          using var conn = await OpenConnectionAsync();
1077          using var cmd = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
1078          cmd.Parameters.AddWithValue(&quot;p&quot;, 8);
1079          await cmd.ExecuteNonQueryAsync();
1080          cmd.Parameters.RemoveAt(0);
1081          cmd.Parameters.AddWithValue(&quot;p&quot;, 9);
1082          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1083      }
1084      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/3509&quot;), Ignore(&quot;Flaky&quot;)]
1085      public async Task Bug3509()
1086      {
1087          if (IsMultiplexing)
1088              return;
1089          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1090          {
1091              KeepAlive = 1,
1092          };
1093          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1094          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1095          await using var conn = await dataSource.OpenConnectionAsync();
1096          var serverMock = await postmasterMock.WaitForServerConnection();
1097          await serverMock.WaitForData();
1098          var queryTask = Task.Run(async () =&gt; await conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;));
1099          await Task.Delay(300);
1100          await serverMock
1101              .WriteErrorResponse(&quot;42&quot;)
1102              .WriteReadyForQuery()
1103              .FlushAsync();
1104          await serverMock
1105              .WriteScalarResponseAndFlush(1);
1106          var ex = Assert.ThrowsAsync&lt;NpgsqlException&gt;(async () =&gt; await queryTask)!;
1107          Assert.That(ex.InnerException, Is.TypeOf&lt;NpgsqlException&gt;()
1108              .With.InnerException.TypeOf&lt;PostgresException&gt;());
1109      }
1110      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4134&quot;)]
1111      public async Task Cached_command_double_dispose()
1112      {
1113          await using var conn = await OpenConnectionAsync();
1114          var cmd1 = conn.CreateCommand();
1115          cmd1.Dispose();
1116          cmd1.Dispose();
1117          var cmd2 = conn.CreateCommand();
1118          Assert.That(cmd2, Is.SameAs(cmd1));
1119          cmd2.CommandText = &quot;SELECT 1&quot;;
1120          Assert.That(await cmd2.ExecuteScalarAsync(), Is.EqualTo(1));
1121      }
1122      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4330&quot;)]
1123      public async Task Prepare_with_positional_placeholders_after_named()
1124      {
1125          if (IsMultiplexing)
1126              return; 
1127          await using var conn = await OpenConnectionAsync();
1128          await using var command = new NpgsqlCommand(&quot;SELECT @p&quot;, conn);
1129          command.Parameters.AddWithValue(&quot;p&quot;, 10);
1130          await command.ExecuteNonQueryAsync();
1131          command.Parameters.Clear();
1132          command.CommandText = &quot;SELECT $1&quot;;
1133          command.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer });
1134          Assert.DoesNotThrowAsync(() =&gt; command.PrepareAsync());
1135      }
1136      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4621&quot;)]
1137      [Description(&quot;Most of 08* errors are coming whenever there was an error while connecting to a remote server from a cluster, so the connection to the cluster is still OK&quot;)]
1138      public async Task Postgres_connection_errors_not_break_connection()
1139      {
1140          if (IsMultiplexing)
1141              return;
1142          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1143          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1144          await using var conn = await dataSource.OpenConnectionAsync();
1145          await using var cmd = conn.CreateCommand();
1146          cmd.CommandText = &quot;SELECT 1&quot;;
1147          var queryTask = cmd.ExecuteNonQueryAsync();
1148          var server = await postmasterMock.WaitForServerConnection();
1149          await server
1150              .WriteErrorResponse(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection)
1151              .WriteReadyForQuery()
1152              .FlushAsync();
1153          var ex = Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await queryTask)!;
1154          Assert.That(ex.SqlState, Is.EqualTo(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection));
1155          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
1156      }
1157      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4804&quot;)]
1158      [Description(&quot;Concurrent write and read failure can lead to deadlocks while cleaning up the connector.&quot;)]
1159      public async Task Concurrent_read_write_failure_deadlock()
1160      {
1161          if (IsMultiplexing)
1162              return;
1163          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1165          await using var conn = await dataSource.OpenConnectionAsync();
1166          await using var cmd = conn.CreateCommand();
1167          cmd.CommandText = new string(&#x27;a&#x27;, 8_000_000);
1168          var queryTask = cmd.ExecuteNonQueryAsync();
1169          var server = await postmasterMock.WaitForServerConnection();
1170          server.Close();
1171          Assert.ThrowsAsync&lt;NpgsqlException&gt;(async () =&gt; await queryTask);
1172      }
1173      [Test, IssueLink(&quot;https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues/4906&quot;)]
1174      [Description(&quot;Make sure we don&#x27;t cancel a prepended query (and do not deadlock in case of a failure)&quot;)]
1175      [Explicit(&quot;Flaky due to #5033&quot;)]
1176      public async Task Not_cancel_prepended_query([Values] bool failPrependedQuery)
1177      {
1178          if (IsMultiplexing)
1179              return;
1180          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1181          var csb = new NpgsqlConnectionStringBuilder(postmasterMock.ConnectionString)
1182          {
1183              NoResetOnClose = false
1184          };
1185          await using var dataSource = CreateDataSource(csb.ConnectionString);
1186          await using var conn = await dataSource.OpenConnectionAsync();
1187          await conn.CloseAsync();
1188          await conn.OpenAsync();
1189          using var cts = new CancellationTokenSource();
1190          var queryTask = conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;, cancellationToken: cts.Token);
1191          var server = await postmasterMock.WaitForServerConnection();
1192          await server.ExpectSimpleQuery(&quot;DISCARD ALL&quot;);
1193          await server.ExpectExtendedQuery();
1194          var cancelTask = Task.Run(cts.Cancel);
1195          var cancellationRequestTask = postmasterMock.WaitForCancellationRequest().AsTask();
1196          await Task.Delay(1000);
1197          Assert.IsFalse(cancelTask.IsCompleted);
1198          Assert.IsFalse(cancellationRequestTask.IsCompleted);
1199          if (failPrependedQuery)
1200          {
1201              await server
1202                  .WriteErrorResponse(PostgresErrorCodes.SyntaxError)
1203                  .WriteReadyForQuery()
1204                  .FlushAsync();
1205              await cancelTask;
1206              await cancellationRequestTask;
1207              Assert.ThrowsAsync&lt;PostgresException&gt;(async () =&gt; await queryTask);
1208              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
1209              return;
1210          }
1211          await server
1212              .WriteCommandComplete()
1213              .WriteReadyForQuery()
1214              .FlushAsync();
1215          await cancelTask;
1216          await cancellationRequestTask;
1217          await server
1218              .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1219              .WriteReadyForQuery()
1220              .FlushAsync();
1221          Assert.ThrowsAsync&lt;OperationCanceledException&gt;(async () =&gt; await queryTask);
1222          queryTask = conn.ExecuteNonQueryAsync(&quot;SELECT 1&quot;);
1223          await server.ExpectExtendedQuery();
1224          await server
1225              .WriteParseComplete()
1226              .WriteBindComplete()
1227              .WriteNoData()
1228              .WriteCommandComplete()
1229              .WriteReadyForQuery()
1230              .FlushAsync();
1231          await queryTask;
1232      }
1233      #region Logging
1234      [Test]
1235      public async Task Log_ExecuteScalar_single_statement_without_parameters()
1236      {
1237          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1238          await using var conn = await dataSource.OpenConnectionAsync();
1239          await using var cmd = new NpgsqlCommand(&quot;SELECT 1&quot;, conn);
1240          using (listLoggerProvider.Record())
1241          {
1242              await cmd.ExecuteScalarAsync();
1243          }
1244          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1245          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;).And.Contains(&quot;SELECT 1&quot;));
1246          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT 1&quot;);
1247          AssertLoggingStateDoesNotContain(executingCommandEvent, &quot;Parameters&quot;);
1248          if (!IsMultiplexing)
1249              AssertLoggingStateContains(executingCommandEvent, &quot;ConnectorId&quot;, conn.ProcessID);
1250      }
1251      [Test]
1252      public async Task Log_ExecuteScalar_single_statement_with_positional_parameters()
1253      {
1254          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1255          await using var conn = await dataSource.OpenConnectionAsync();
1256          await using var cmd = new NpgsqlCommand(&quot;SELECT $1, $2&quot;, conn);
1257          cmd.Parameters.Add(new() { Value = 8 });
1258          cmd.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1259          using (listLoggerProvider.Record())
1260          {
1261              await cmd.ExecuteScalarAsync();
1262          }
1263          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1264          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;)
1265              .And.Contains(&quot;SELECT $1, $2&quot;)
1266              .And.Contains(&quot;Parameters: [8, NULL]&quot;));
1267          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT $1, $2&quot;);
1268          AssertLoggingStateContains(executingCommandEvent, &quot;Parameters&quot;, new object[] { 8, &quot;NULL&quot; });
1269          if (!IsMultiplexing)
1270              AssertLoggingStateContains(executingCommandEvent, &quot;ConnectorId&quot;, conn.ProcessID);
1271      }
1272      [Test]
1273      public async Task Log_ExecuteScalar_single_statement_with_named_parameters()
1274      {
1275          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1276          await using var conn = await dataSource.OpenConnectionAsync();
1277          await using var cmd = new NpgsqlCommand(&quot;SELECT @p1, @p2&quot;, conn);
1278          cmd.Parameters.Add(new() { ParameterName = &quot;p1&quot;, Value = 8 });
1279          cmd.Parameters.Add(new() { ParameterName = &quot;p2&quot;, NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1280          using (listLoggerProvider.Record())
1281          {
1282              await cmd.ExecuteScalarAsync();
1283          }
1284          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1285          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;)
1286              .And.Contains(&quot;SELECT $1, $2&quot;)
1287              .And.Contains(&quot;Parameters: [8, NULL]&quot;));
1288          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT $1, $2&quot;);
1289          AssertLoggingStateContains(executingCommandEvent, &quot;Parameters&quot;, new object[] { 8, &quot;NULL&quot; });
1290          if (!IsMultiplexing)
1291              AssertLoggingStateContains(executingCommandEvent, &quot;ConnectorId&quot;, conn.ProcessID);
1292      }
1293      [Test]
1294      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
1295      {
1296          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
1297          await using var conn = await dataSource.OpenConnectionAsync();
1298          await using var cmd = new NpgsqlCommand(&quot;SELECT $1, $2&quot;, conn);
1299          cmd.Parameters.Add(new() { Value = 8 });
1300          cmd.Parameters.Add(new() { Value = 9 });
1301          using (listLoggerProvider.Record())
1302          {
1303              await cmd.ExecuteScalarAsync();
1304          }
1305          var executingCommandEvent = listLoggerProvider.Log.Single(l =&gt; l.Id == NpgsqlEventId.CommandExecutionCompleted);
1306          Assert.That(executingCommandEvent.Message, Does.Contain(&quot;Command execution completed&quot;).And.Contains($&quot;SELECT $1, $2&quot;));
1307          AssertLoggingStateContains(executingCommandEvent, &quot;CommandText&quot;, &quot;SELECT $1, $2&quot;);
1308          AssertLoggingStateDoesNotContain(executingCommandEvent, &quot;Parameters&quot;);
1309      }
1310      #endregion Logging
1311      public CommandTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1312  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>962              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
963              if (i &gt; 0)
</pre></code></div>
                <div class="column column_space"><pre><code>986              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
987              if (i &gt; 0)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    