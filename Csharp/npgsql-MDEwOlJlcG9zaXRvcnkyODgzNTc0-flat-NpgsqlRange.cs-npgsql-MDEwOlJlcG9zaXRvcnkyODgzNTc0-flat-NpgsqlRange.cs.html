
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRange.cs</h3>
            <pre><code>1  using System;
2  using System.ComponentModel;
3  using System.Diagnostics.CodeAnalysis;
4  using System.Globalization;
5  using System.Text;
6  namespace NpgsqlTypes;
7  public readonly struct NpgsqlRange<T> : IEquatable<NpgsqlRange<T>>
8  {
9      const string EmptyLiteral = "empty";
10      const string LowerInfinityLiteral = "-infinity";
11      const string UpperInfinityLiteral = "infinity";
12      const string NullLiteral = "null";
13      const char LowerInclusiveBound = '[';
14      const char LowerExclusiveBound = '(';
15      const char UpperInclusiveBound = ']';
16      const char UpperExclusiveBound = ')';
17      const char BoundSeparator = ',';
18      static readonly TypeConverter BoundConverter = TypeDescriptor.GetConverter(typeof(T));
19      static readonly bool HasEquatableBounds = typeof(IEquatable<T>).IsAssignableFrom(typeof(T));
20      public static readonly NpgsqlRange<T> Empty = new(default, default, RangeFlags.Empty);
21      [MaybeNull, AllowNull]
22      public T LowerBound { get; }
23      [MaybeNull, AllowNull]
24      public T UpperBound { get; }
25      internal readonly RangeFlags Flags;
26      public bool LowerBoundIsInclusive => (Flags & RangeFlags.LowerBoundInclusive) != 0;
27      public bool UpperBoundIsInclusive => (Flags & RangeFlags.UpperBoundInclusive) != 0;
28      public bool LowerBoundInfinite => (Flags & RangeFlags.LowerBoundInfinite) != 0;
29      public bool UpperBoundInfinite => (Flags & RangeFlags.UpperBoundInfinite) != 0;
30      public bool IsEmpty => (Flags & RangeFlags.Empty) != 0;
31      public NpgsqlRange([AllowNull] T lowerBound, [AllowNull] T upperBound)
32          : this(lowerBound, true, false, upperBound, true, false) { }
33      public NpgsqlRange(
34          [AllowNull] T lowerBound, bool lowerBoundIsInclusive,
35          [AllowNull] T upperBound, bool upperBoundIsInclusive)
36          : this(lowerBound, lowerBoundIsInclusive, false, upperBound, upperBoundIsInclusive, false) { }
37      public NpgsqlRange(
38          [AllowNull] T lowerBound, bool lowerBoundIsInclusive, bool lowerBoundInfinite,
39          [AllowNull] T upperBound, bool upperBoundIsInclusive, bool upperBoundInfinite)
40          : this(
41              lowerBound,
42              upperBound,
43              EvaluateBoundaryFlags(
44                  lowerBoundIsInclusive,
45                  upperBoundIsInclusive,
46                  lowerBoundInfinite,
47                  upperBoundInfinite)) { }
48      internal NpgsqlRange([AllowNull] T lowerBound, [AllowNull] T upperBound, RangeFlags flags) : this()
49      {
50          LowerBound = (flags & RangeFlags.LowerBoundInfinite) != 0 ? default : lowerBound;
51          UpperBound = (flags & RangeFlags.UpperBoundInfinite) != 0 ? default : upperBound;
52          Flags = flags;
53          if (IsEmptyRange(LowerBound, UpperBound, Flags))
54          {
55              LowerBound = default!;
56              UpperBound = default!;
57              Flags = RangeFlags.Empty;
58          }
59      }
60      static bool IsEmptyRange([AllowNull] T lowerBound, [AllowNull] T upperBound, RangeFlags flags)
61      {
62          if ((flags & RangeFlags.Empty) == RangeFlags.Empty)
63              return true;
64          if ((flags & RangeFlags.Infinite) == RangeFlags.Infinite)
65              return false;
66          if ((flags & RangeFlags.Inclusive) == RangeFlags.Inclusive)
67              return false;
68          if (lowerBound is null || upperBound is null)
69              return false;
70          if (!HasEquatableBounds)
71              return lowerBound?.Equals(upperBound) ?? false;
72          var lower = (IEquatable<T>)lowerBound;
73          var upper = (IEquatable<T>)upperBound;
74          return !lower.Equals(default!) && !upper.Equals(default!) && lower.Equals(upperBound);
75      }
76      static RangeFlags EvaluateBoundaryFlags(bool lowerBoundIsInclusive, bool upperBoundIsInclusive, bool lowerBoundInfinite, bool upperBoundInfinite)
77      {
78          var result = RangeFlags.None;
79          if (lowerBoundIsInclusive)
80              result |= RangeFlags.LowerBoundInclusive;
81          if (upperBoundIsInclusive)
82              result |= RangeFlags.UpperBoundInclusive;
83          if (lowerBoundInfinite)
84              result |= RangeFlags.LowerBoundInfinite;
85          if (upperBoundInfinite)
86              result |= RangeFlags.UpperBoundInfinite;
87          if ((result & RangeFlags.LowerInclusiveInfinite) == RangeFlags.LowerInclusiveInfinite)
88              result &= ~RangeFlags.LowerBoundInclusive;
89          if ((result & RangeFlags.UpperInclusiveInfinite) == RangeFlags.UpperInclusiveInfinite)
90              result &= ~RangeFlags.UpperBoundInclusive;
91          return result;
92      }
93      public static bool operator ==(NpgsqlRange<T> x, NpgsqlRange<T> y) => x.Equals(y);
94      public static bool operator !=(NpgsqlRange<T> x, NpgsqlRange<T> y) => !x.Equals(y);
95      public override bool Equals(object? o) => o is NpgsqlRange<T> range && Equals(range);
96      public bool Equals(NpgsqlRange<T> other)
97      {
98          if (Flags != other.Flags)
99              return false;
100          if (HasEquatableBounds)
101          {
102              var lowerEqual = LowerBound is null
103                  ? other.LowerBound is null
104                  : !(other.LowerBound is null) && ((IEquatable<T>)LowerBound).Equals(other.LowerBound);
105              if (!lowerEqual)
106                  return false;
107              return UpperBound is null
108                  ? other.UpperBound is null
109                  : !(other.UpperBound is null) && ((IEquatable<T>)UpperBound).Equals(other.UpperBound);
110          }
111          return
112              (LowerBound?.Equals(other.LowerBound) ?? other.LowerBound is null) &&
113              (UpperBound?.Equals(other.UpperBound) ?? other.UpperBound is null);
114      }
115      public override int GetHashCode()
116          => unchecked((397 * (int)Flags) ^ (397 * (LowerBound?.GetHashCode() ?? 0)) ^ (397 * (UpperBound?.GetHashCode() ?? 0)));
117      public override string ToString()
118      {
119          if (IsEmpty)
120              return EmptyLiteral;
121          var sb = new StringBuilder();
122          sb.Append(LowerBoundIsInclusive ? LowerInclusiveBound : LowerExclusiveBound);
123          if (!LowerBoundInfinite)
124              sb.Append(LowerBound);
125          sb.Append(BoundSeparator);
126          if (!UpperBoundInfinite)
127              sb.Append(UpperBound);
128          sb.Append(UpperBoundIsInclusive ? UpperInclusiveBound : UpperExclusiveBound);
129          return sb.ToString();
130      }
131      public static NpgsqlRange<T> Parse(string value)
132      {
133          if (value is null)
134              throw new ArgumentNullException(nameof(value));
135          value = value.Trim();
136          if (value.Length < 3)
137              throw new FormatException("Malformed range literal.");
138          if (string.Equals(value, EmptyLiteral, StringComparison.OrdinalIgnoreCase))
139              return Empty;
140          var lowerInclusive = value[0] == LowerInclusiveBound;
141          var lowerExclusive = value[0] == LowerExclusiveBound;
142          if (!lowerInclusive && !lowerExclusive)
143              throw new FormatException("Malformed range literal. Missing left parenthesis or bracket.");
144          var upperInclusive = value[value.Length - 1] == UpperInclusiveBound;
<span onclick='openModal()' class='match'>145          var upperExclusive = value[value.Length - 1] == UpperExclusiveBound;
146          if (!upperInclusive && !upperExclusive)
</span>147              throw new FormatException("Malformed range literal. Missing right parenthesis or bracket.");
148          var separator = value.IndexOf(BoundSeparator);
149          if (separator == -1)
150              throw new FormatException("Malformed range literal. Missing comma after lower bound.");
151          if (separator != value.LastIndexOf(BoundSeparator))
152              throw new NotSupportedException("Ranges with embedded commas are not currently supported.");
153          var lowerSegment = value.Substring(1, separator - 1).Trim();
154          var upperSegment = value.Substring(separator + 1, value.Length - separator - 2).Trim();
155          var lowerInfinite =
156              lowerSegment.Length == 0 ||
157              string.Equals(lowerSegment, string.Empty, StringComparison.OrdinalIgnoreCase) ||
158              string.Equals(lowerSegment, NullLiteral, StringComparison.OrdinalIgnoreCase) ||
159              string.Equals(lowerSegment, LowerInfinityLiteral, StringComparison.OrdinalIgnoreCase);
160          var upperInfinite =
161              upperSegment.Length == 0 ||
162              string.Equals(upperSegment, string.Empty, StringComparison.OrdinalIgnoreCase) ||
163              string.Equals(upperSegment, NullLiteral, StringComparison.OrdinalIgnoreCase) ||
164              string.Equals(upperSegment, UpperInfinityLiteral, StringComparison.OrdinalIgnoreCase);
165          var lower = lowerInfinite ? default : (T?)BoundConverter.ConvertFromString(lowerSegment);
166          var upper = upperInfinite ? default : (T?)BoundConverter.ConvertFromString(upperSegment);
167          return new NpgsqlRange<T>(lower, lowerInclusive, lowerInfinite, upper, upperInclusive, upperInfinite);
168      }
169      public class RangeTypeConverter : TypeConverter
170      {
171          public static void Register() =>
172              TypeDescriptor.AddAttributes(
173                  typeof(NpgsqlRange<T>),
174                  new TypeConverterAttribute(typeof(RangeTypeConverter)));
175          public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
176              => sourceType == typeof(string);
177          public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType)
178              => destinationType == typeof(string);
179          public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
180              => value is string s ? Parse(s) : base.ConvertFrom(context, culture, value);
181          public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
182              => value is null ? string.Empty : value.ToString();
183      }
184  }
185  [Flags]
186  enum RangeFlags : byte
187  {
188      None = 0,
189      Empty = 1,
190      LowerBoundInclusive = 2,
191      UpperBoundInclusive = 4,
192      LowerBoundInfinite = 8,
193      UpperBoundInfinite = 16,
194      Inclusive = LowerBoundInclusive | UpperBoundInclusive,
195      Infinite = LowerBoundInfinite | UpperBoundInfinite,
196      LowerInclusiveInfinite = LowerBoundInclusive | LowerBoundInfinite,
197      UpperInclusiveInfinite = UpperBoundInclusive | UpperBoundInfinite
198  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRange.cs</h3>
            <pre><code>1  using System;
2  using System.ComponentModel;
3  using System.Diagnostics.CodeAnalysis;
4  using System.Globalization;
5  using System.Text;
6  namespace NpgsqlTypes;
7  public readonly struct NpgsqlRange<T> : IEquatable<NpgsqlRange<T>>
8  {
9      const string EmptyLiteral = "empty";
10      const string LowerInfinityLiteral = "-infinity";
11      const string UpperInfinityLiteral = "infinity";
12      const string NullLiteral = "null";
13      const char LowerInclusiveBound = '[';
14      const char LowerExclusiveBound = '(';
15      const char UpperInclusiveBound = ']';
16      const char UpperExclusiveBound = ')';
17      const char BoundSeparator = ',';
18      static readonly TypeConverter BoundConverter = TypeDescriptor.GetConverter(typeof(T));
19      static readonly bool HasEquatableBounds = typeof(IEquatable<T>).IsAssignableFrom(typeof(T));
20      public static readonly NpgsqlRange<T> Empty = new(default, default, RangeFlags.Empty);
21      [MaybeNull, AllowNull]
22      public T LowerBound { get; }
23      [MaybeNull, AllowNull]
24      public T UpperBound { get; }
25      internal readonly RangeFlags Flags;
26      public bool LowerBoundIsInclusive => (Flags & RangeFlags.LowerBoundInclusive) != 0;
27      public bool UpperBoundIsInclusive => (Flags & RangeFlags.UpperBoundInclusive) != 0;
28      public bool LowerBoundInfinite => (Flags & RangeFlags.LowerBoundInfinite) != 0;
29      public bool UpperBoundInfinite => (Flags & RangeFlags.UpperBoundInfinite) != 0;
30      public bool IsEmpty => (Flags & RangeFlags.Empty) != 0;
31      public NpgsqlRange([AllowNull] T lowerBound, [AllowNull] T upperBound)
32          : this(lowerBound, true, false, upperBound, true, false) { }
33      public NpgsqlRange(
34          [AllowNull] T lowerBound, bool lowerBoundIsInclusive,
35          [AllowNull] T upperBound, bool upperBoundIsInclusive)
36          : this(lowerBound, lowerBoundIsInclusive, false, upperBound, upperBoundIsInclusive, false) { }
37      public NpgsqlRange(
38          [AllowNull] T lowerBound, bool lowerBoundIsInclusive, bool lowerBoundInfinite,
39          [AllowNull] T upperBound, bool upperBoundIsInclusive, bool upperBoundInfinite)
40          : this(
41              lowerBound,
42              upperBound,
43              EvaluateBoundaryFlags(
44                  lowerBoundIsInclusive,
45                  upperBoundIsInclusive,
46                  lowerBoundInfinite,
47                  upperBoundInfinite)) { }
48      internal NpgsqlRange([AllowNull] T lowerBound, [AllowNull] T upperBound, RangeFlags flags) : this()
49      {
50          LowerBound = (flags & RangeFlags.LowerBoundInfinite) != 0 ? default : lowerBound;
51          UpperBound = (flags & RangeFlags.UpperBoundInfinite) != 0 ? default : upperBound;
52          Flags = flags;
53          if (IsEmptyRange(LowerBound, UpperBound, Flags))
54          {
55              LowerBound = default!;
56              UpperBound = default!;
57              Flags = RangeFlags.Empty;
58          }
59      }
60      static bool IsEmptyRange([AllowNull] T lowerBound, [AllowNull] T upperBound, RangeFlags flags)
61      {
62          if ((flags & RangeFlags.Empty) == RangeFlags.Empty)
63              return true;
64          if ((flags & RangeFlags.Infinite) == RangeFlags.Infinite)
65              return false;
66          if ((flags & RangeFlags.Inclusive) == RangeFlags.Inclusive)
67              return false;
68          if (lowerBound is null || upperBound is null)
69              return false;
70          if (!HasEquatableBounds)
71              return lowerBound?.Equals(upperBound) ?? false;
72          var lower = (IEquatable<T>)lowerBound;
73          var upper = (IEquatable<T>)upperBound;
74          return !lower.Equals(default!) && !upper.Equals(default!) && lower.Equals(upperBound);
75      }
76      static RangeFlags EvaluateBoundaryFlags(bool lowerBoundIsInclusive, bool upperBoundIsInclusive, bool lowerBoundInfinite, bool upperBoundInfinite)
77      {
78          var result = RangeFlags.None;
79          if (lowerBoundIsInclusive)
80              result |= RangeFlags.LowerBoundInclusive;
81          if (upperBoundIsInclusive)
82              result |= RangeFlags.UpperBoundInclusive;
83          if (lowerBoundInfinite)
84              result |= RangeFlags.LowerBoundInfinite;
85          if (upperBoundInfinite)
86              result |= RangeFlags.UpperBoundInfinite;
87          if ((result & RangeFlags.LowerInclusiveInfinite) == RangeFlags.LowerInclusiveInfinite)
88              result &= ~RangeFlags.LowerBoundInclusive;
89          if ((result & RangeFlags.UpperInclusiveInfinite) == RangeFlags.UpperInclusiveInfinite)
90              result &= ~RangeFlags.UpperBoundInclusive;
91          return result;
92      }
93      public static bool operator ==(NpgsqlRange<T> x, NpgsqlRange<T> y) => x.Equals(y);
94      public static bool operator !=(NpgsqlRange<T> x, NpgsqlRange<T> y) => !x.Equals(y);
95      public override bool Equals(object? o) => o is NpgsqlRange<T> range && Equals(range);
96      public bool Equals(NpgsqlRange<T> other)
97      {
98          if (Flags != other.Flags)
99              return false;
100          if (HasEquatableBounds)
101          {
102              var lowerEqual = LowerBound is null
103                  ? other.LowerBound is null
104                  : !(other.LowerBound is null) && ((IEquatable<T>)LowerBound).Equals(other.LowerBound);
105              if (!lowerEqual)
106                  return false;
107              return UpperBound is null
108                  ? other.UpperBound is null
109                  : !(other.UpperBound is null) && ((IEquatable<T>)UpperBound).Equals(other.UpperBound);
110          }
111          return
112              (LowerBound?.Equals(other.LowerBound) ?? other.LowerBound is null) &&
113              (UpperBound?.Equals(other.UpperBound) ?? other.UpperBound is null);
114      }
115      public override int GetHashCode()
116          => unchecked((397 * (int)Flags) ^ (397 * (LowerBound?.GetHashCode() ?? 0)) ^ (397 * (UpperBound?.GetHashCode() ?? 0)));
117      public override string ToString()
118      {
119          if (IsEmpty)
120              return EmptyLiteral;
121          var sb = new StringBuilder();
122          sb.Append(LowerBoundIsInclusive ? LowerInclusiveBound : LowerExclusiveBound);
123          if (!LowerBoundInfinite)
124              sb.Append(LowerBound);
125          sb.Append(BoundSeparator);
126          if (!UpperBoundInfinite)
127              sb.Append(UpperBound);
128          sb.Append(UpperBoundIsInclusive ? UpperInclusiveBound : UpperExclusiveBound);
129          return sb.ToString();
130      }
131      public static NpgsqlRange<T> Parse(string value)
132      {
133          if (value is null)
134              throw new ArgumentNullException(nameof(value));
135          value = value.Trim();
136          if (value.Length < 3)
137              throw new FormatException("Malformed range literal.");
138          if (string.Equals(value, EmptyLiteral, StringComparison.OrdinalIgnoreCase))
139              return Empty;
140          var lowerInclusive = value[0] == LowerInclusiveBound;
141          var lowerExclusive = value[0] == LowerExclusiveBound;
142          if (!lowerInclusive && !lowerExclusive)
143              throw new FormatException("Malformed range literal. Missing left parenthesis or bracket.");
<span onclick='openModal()' class='match'>144          var upperInclusive = value[value.Length - 1] == UpperInclusiveBound;
145          var upperExclusive = value[value.Length - 1] == UpperExclusiveBound;
</span>146          if (!upperInclusive && !upperExclusive)
147              throw new FormatException("Malformed range literal. Missing right parenthesis or bracket.");
148          var separator = value.IndexOf(BoundSeparator);
149          if (separator == -1)
150              throw new FormatException("Malformed range literal. Missing comma after lower bound.");
151          if (separator != value.LastIndexOf(BoundSeparator))
152              throw new NotSupportedException("Ranges with embedded commas are not currently supported.");
153          var lowerSegment = value.Substring(1, separator - 1).Trim();
154          var upperSegment = value.Substring(separator + 1, value.Length - separator - 2).Trim();
155          var lowerInfinite =
156              lowerSegment.Length == 0 ||
157              string.Equals(lowerSegment, string.Empty, StringComparison.OrdinalIgnoreCase) ||
158              string.Equals(lowerSegment, NullLiteral, StringComparison.OrdinalIgnoreCase) ||
159              string.Equals(lowerSegment, LowerInfinityLiteral, StringComparison.OrdinalIgnoreCase);
160          var upperInfinite =
161              upperSegment.Length == 0 ||
162              string.Equals(upperSegment, string.Empty, StringComparison.OrdinalIgnoreCase) ||
163              string.Equals(upperSegment, NullLiteral, StringComparison.OrdinalIgnoreCase) ||
164              string.Equals(upperSegment, UpperInfinityLiteral, StringComparison.OrdinalIgnoreCase);
165          var lower = lowerInfinite ? default : (T?)BoundConverter.ConvertFromString(lowerSegment);
166          var upper = upperInfinite ? default : (T?)BoundConverter.ConvertFromString(upperSegment);
167          return new NpgsqlRange<T>(lower, lowerInclusive, lowerInfinite, upper, upperInclusive, upperInfinite);
168      }
169      public class RangeTypeConverter : TypeConverter
170      {
171          public static void Register() =>
172              TypeDescriptor.AddAttributes(
173                  typeof(NpgsqlRange<T>),
174                  new TypeConverterAttribute(typeof(RangeTypeConverter)));
175          public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
176              => sourceType == typeof(string);
177          public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType)
178              => destinationType == typeof(string);
179          public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
180              => value is string s ? Parse(s) : base.ConvertFrom(context, culture, value);
181          public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
182              => value is null ? string.Empty : value.ToString();
183      }
184  }
185  [Flags]
186  enum RangeFlags : byte
187  {
188      None = 0,
189      Empty = 1,
190      LowerBoundInclusive = 2,
191      UpperBoundInclusive = 4,
192      LowerBoundInfinite = 8,
193      UpperBoundInfinite = 16,
194      Inclusive = LowerBoundInclusive | UpperBoundInclusive,
195      Infinite = LowerBoundInfinite | UpperBoundInfinite,
196      LowerInclusiveInfinite = LowerBoundInclusive | LowerBoundInfinite,
197      UpperInclusiveInfinite = UpperBoundInclusive | UpperBoundInfinite
198  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRange.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRange.cs</div>
                </div>
                <div class="column column_space"><pre><code>145          var upperExclusive = value[value.Length - 1] == UpperExclusiveBound;
146          if (!upperInclusive && !upperExclusive)
</pre></code></div>
                <div class="column column_space"><pre><code>144          var upperInclusive = value[value.Length - 1] == UpperInclusiveBound;
145          var upperExclusive = value[value.Length - 1] == UpperExclusiveBound;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    