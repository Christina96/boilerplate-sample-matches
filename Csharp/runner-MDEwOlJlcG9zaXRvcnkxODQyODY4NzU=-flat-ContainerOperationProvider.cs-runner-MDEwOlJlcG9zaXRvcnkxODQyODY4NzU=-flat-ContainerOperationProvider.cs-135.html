
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Threading.Tasks;
5  using System.Linq;
6  using System.Threading;
7  using GitHub.Runner.Worker.Container;
8  using GitHub.Services.Common;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
13  using GitHub.Runner.Worker.Container.ContainerHooks;
14  #if OS_WINDOWS 
15  using System.ServiceProcess;
16  using Microsoft.Win32;
17  #endif
18  namespace GitHub.Runner.Worker
19  {
20      [ServiceLocator(Default = typeof(ContainerOperationProvider))]
21      public interface IContainerOperationProvider : IRunnerService
22      {
23          Task StartContainersAsync(IExecutionContext executionContext, object data);
24          Task StopContainersAsync(IExecutionContext executionContext, object data);
25      }
26      public class ContainerOperationProvider : RunnerService, IContainerOperationProvider
27      {
28          private IDockerCommandManager _dockerManager;
29          private IContainerHookManager _containerHookManager;
30          public override void Initialize(IHostContext hostContext)
31          {
32              base.Initialize(hostContext);
33              if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable(Constants.Hooks.ContainerHooksPath)))
34              {
35                  _dockerManager = HostContext.GetService&lt;IDockerCommandManager&gt;();
36              }
37              else
38              {
39                  _containerHookManager = HostContext.GetService&lt;IContainerHookManager&gt;();
40              }
41          }
42          public async Task StartContainersAsync(IExecutionContext executionContext, object data)
43          {
44              Trace.Entering();
45              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
46              {
47                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
48              }
49              ArgUtil.NotNull(executionContext, nameof(executionContext));
50              List&lt;ContainerInfo&gt; containers = data as List&lt;ContainerInfo&gt;;
51              ArgUtil.NotNull(containers, nameof(containers));
52              var postJobStep = new JobExtensionRunner(runAsync: this.StopContainersAsync,
53                                                  condition: $&quot;{PipelineTemplateConstants.Always}()&quot;,
54                                                  displayName: &quot;Stop containers&quot;,
55                                                  data: data);
56              executionContext.Debug($&quot;Register post job cleanup for stopping/deleting containers.&quot;);
57              executionContext.RegisterPostJobStep(postJobStep);
58              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
59              {
60                  containers.ForEach(container =&gt; UpdateRegistryAuthForGitHubToken(executionContext, container));
61                  containers.Where(container =&gt; container.IsJobContainer).ForEach(container =&gt; MountWellKnownDirectories(executionContext, container));
62                  await _containerHookManager.PrepareJobAsync(executionContext, containers);
63                  return;
64              }
65              await AssertCompatibleOS(executionContext);
66              executionContext.Output(&quot;##[group]Clean up resources from previous jobs&quot;);
<span onclick='openModal()' class='match'>67              var staleContainers = await _dockerManager.DockerPS(executionContext, $&quot;--all --quiet --no-trunc --filter \&quot;label={_dockerManager.DockerInstanceLabel}\&quot;&quot;);
68              foreach (var staleContainer in staleContainers)
</span>69              {
70                  int containerRemoveExitCode = await _dockerManager.DockerRemove(executionContext, staleContainer);
71                  if (containerRemoveExitCode != 0)
72                  {
73                      executionContext.Warning($&quot;Delete stale containers failed, docker rm fail with exit code {containerRemoveExitCode} for container {staleContainer}&quot;);
74                  }
75              }
76              int networkPruneExitCode = await _dockerManager.DockerNetworkPrune(executionContext);
77              if (networkPruneExitCode != 0)
78              {
79                  executionContext.Warning($&quot;Delete stale container networks failed, docker network prune fail with exit code {networkPruneExitCode}&quot;);
80              }
81              executionContext.Output(&quot;##[endgroup]&quot;);
82              executionContext.Output(&quot;##[group]Create local container network&quot;);
83              var containerNetwork = $&quot;github_network_{Guid.NewGuid().ToString(&quot;N&quot;)}&quot;;
84              await CreateContainerNetworkAsync(executionContext, containerNetwork);
85              executionContext.JobContext.Container[&quot;network&quot;] = new StringContextData(containerNetwork);
86              executionContext.Output(&quot;##[endgroup]&quot;);
87              foreach (var container in containers)
88              {
89                  container.ContainerNetwork = containerNetwork;
90                  await StartContainerAsync(executionContext, container);
91              }
92              await RunContainersHealthcheck(executionContext, containers);
93          }
94          public async Task RunContainersHealthcheck(IExecutionContext executionContext, List&lt;ContainerInfo&gt; containers)
95          {
96              executionContext.Output(&quot;##[group]Waiting for all services to be ready&quot;);
97              var unhealthyContainers = new List&lt;ContainerInfo&gt;();
98              foreach (var container in containers.Where(c =&gt; !c.IsJobContainer))
99              {
100                  var healthy_container = await ContainerHealthcheck(executionContext, container);
101                  if (!healthy_container)
102                  {
103                      unhealthyContainers.Add(container);
104                  }
105                  else
106                  {
107                      executionContext.Output($&quot;{container.ContainerNetworkAlias} service is healthy.&quot;);
108                  }
109              }
110              executionContext.Output(&quot;##[endgroup]&quot;);
111              if (unhealthyContainers.Count &gt; 0)
112              {
113                  foreach (var container in unhealthyContainers)
114                  {
115                      executionContext.Output($&quot;##[group]Service container {container.ContainerNetworkAlias} failed.&quot;);
116                      await _dockerManager.DockerLogs(context: executionContext, containerId: container.ContainerId);
117                      executionContext.Error($&quot;Failed to initialize container {container.ContainerImage}&quot;);
118                      container.FailedInitialization = true;
119                      executionContext.Output(&quot;##[endgroup]&quot;);
120                  }
121                  throw new InvalidOperationException(&quot;One or more containers failed to start.&quot;);
122              }
123          }
124          public async Task StopContainersAsync(IExecutionContext executionContext, object data)
125          {
126              Trace.Entering();
127              ArgUtil.NotNull(executionContext, nameof(executionContext));
128              List&lt;ContainerInfo&gt; containers = data as List&lt;ContainerInfo&gt;;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
131              {
132                  await _containerHookManager.CleanupJobAsync(executionContext, containers);
133                  return;
134              }
135              foreach (var container in containers)
136              {
137                  await StopContainerAsync(executionContext, container);
138              }
139              await RemoveContainerNetworkAsync(executionContext, containers.First().ContainerNetwork);
140          }
141          private async Task StartContainerAsync(IExecutionContext executionContext, ContainerInfo container)
142          {
143              Trace.Entering();
144              ArgUtil.NotNull(executionContext, nameof(executionContext));
145              ArgUtil.NotNull(container, nameof(container));
146              ArgUtil.NotNullOrEmpty(container.ContainerImage, nameof(container.ContainerImage));
147              Trace.Info($&quot;Container name: {container.ContainerName}&quot;);
148              Trace.Info($&quot;Container image: {container.ContainerImage}&quot;);
149              Trace.Info($&quot;Container options: {container.ContainerCreateOptions}&quot;);
150              var groupName = container.IsJobContainer ? &quot;Starting job container&quot; : $&quot;Starting {container.ContainerNetworkAlias} service container&quot;;
151              executionContext.Output($&quot;##[group]{groupName}&quot;);
152              foreach (var port in container.UserPortMappings)
153              {
154                  Trace.Info($&quot;User provided port: {port.Value}&quot;);
155              }
156              foreach (var mount in container.UserMountVolumes)
157              {
158                  Trace.Info($&quot;User provided volume: {mount.UserProvidedValue}&quot;);
159                  if (string.Equals(mount.SourceVolumePath, &quot;/&quot;, StringComparison.OrdinalIgnoreCase))
160                  {
161                      executionContext.Warning($&quot;Volume mount {mount.UserProvidedValue} is going to mount &#x27;/&#x27; into the container which may cause file ownership change in the entire file system and cause Actions Runner to lose permission to access the disk.&quot;);
162                  }
163              }
164              UpdateRegistryAuthForGitHubToken(executionContext, container);
165              var configLocation = await ContainerRegistryLogin(executionContext, container);
166              int retryCount = 0;
167              int pullExitCode = 0;
168              while (retryCount &lt; 3)
169              {
170                  pullExitCode = await _dockerManager.DockerPull(executionContext, container.ContainerImage, configLocation);
171                  if (pullExitCode == 0)
172                  {
173                      break;
174                  }
175                  else
176                  {
177                      retryCount++;
178                      if (retryCount &lt; 3)
179                      {
180                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
181                          executionContext.Warning($&quot;Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.&quot;);
182                          await Task.Delay(backOff);
183                      }
184                  }
185              }
186              ContainerRegistryLogout(configLocation);
187              if (retryCount == 3 &amp;&amp; pullExitCode != 0)
188              {
189                  throw new InvalidOperationException($&quot;Docker pull failed with exit code {pullExitCode}&quot;);
190              }
191              if (container.IsJobContainer)
192              {
193                  MountWellKnownDirectories(executionContext, container);
194              }
195              container.ContainerId = await _dockerManager.DockerCreate(executionContext, container);
196              ArgUtil.NotNullOrEmpty(container.ContainerId, nameof(container.ContainerId));
197              int startExitCode = await _dockerManager.DockerStart(executionContext, container.ContainerId);
198              if (startExitCode != 0)
199              {
200                  throw new InvalidOperationException($&quot;Docker start fail with exit code {startExitCode}&quot;);
201              }
202              try
203              {
204                  var psOutputs = await _dockerManager.DockerPS(executionContext, $&quot;--all --filter id={container.ContainerId} --filter status=running --no-trunc --format \&quot;{{{{.ID}}}} {{{{.Status}}}}\&quot;&quot;);
205                  if (psOutputs.FirstOrDefault(x =&gt; !string.IsNullOrEmpty(x))?.StartsWith(container.ContainerId) != true)
206                  {
207                      await _dockerManager.DockerPS(executionContext, $&quot;--all --filter id={container.ContainerId} --no-trunc --format \&quot;{{{{.ID}}}} {{{{.Status}}}}\&quot;&quot;);
208                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
209                      if (logsExitCode != 0)
210                      {
211                          executionContext.Warning($&quot;Docker logs fail with exit code {logsExitCode}&quot;);
212                      }
213                      executionContext.Warning($&quot;Docker container {container.ContainerId} is not in running state.&quot;);
214                  }
215              }
216              catch (Exception ex)
217              {
218                  Trace.Error(&quot;Catch exception when check container log and container status.&quot;);
219                  Trace.Error(ex);
220              }
221              if (!container.IsJobContainer)
222              {
223                  var service = new DictionaryContextData()
224                  {
225                      [&quot;id&quot;] = new StringContextData(container.ContainerId),
226                      [&quot;ports&quot;] = new DictionaryContextData(),
227                      [&quot;network&quot;] = new StringContextData(container.ContainerNetwork)
228                  };
229                  container.AddPortMappings(await _dockerManager.DockerPort(executionContext, container.ContainerId));
230                  foreach (var port in container.PortMappings)
231                  {
232                      (service[&quot;ports&quot;] as DictionaryContextData)[port.ContainerPort] = new StringContextData(port.HostPort);
233                  }
234                  executionContext.JobContext.Services[container.ContainerNetworkAlias] = service;
235              }
236              else
237              {
238                  var configEnvFormat = &quot;--format \&quot;{{range .Config.Env}}{{println .}}{{end}}\&quot;&quot;;
239                  var containerEnv = await _dockerManager.DockerInspect(executionContext, container.ContainerId, configEnvFormat);
240                  container.ContainerRuntimePath = DockerUtil.ParsePathFromConfigEnv(containerEnv);
241                  executionContext.JobContext.Container[&quot;id&quot;] = new StringContextData(container.ContainerId);
242              }
243              executionContext.Output(&quot;##[endgroup]&quot;);
244          }
245          private void MountWellKnownDirectories(IExecutionContext executionContext, ContainerInfo container)
246          {
247              var githubContext = executionContext.ExpressionValues[&quot;github&quot;] as GitHubContext;
248              ArgUtil.NotNull(githubContext, nameof(githubContext));
249              var workingDirectory = githubContext[&quot;workspace&quot;] as StringContextData;
250              ArgUtil.NotNullOrEmpty(workingDirectory, nameof(workingDirectory));
251              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Work), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Work))));
252  #if OS_WINDOWS
253                  container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals))));
254  #else
255              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals)), true));
256  #endif
257              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Temp), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Temp))));
258              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Actions), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Actions))));
259              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Tools), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Tools))));
260              var tempHomeDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), &quot;_github_home&quot;);
261              Directory.CreateDirectory(tempHomeDirectory);
262              container.MountVolumes.Add(new MountVolume(tempHomeDirectory, &quot;/github/home&quot;));
263              container.AddPathTranslateMapping(tempHomeDirectory, &quot;/github/home&quot;);
264              container.ContainerEnvironmentVariables[&quot;HOME&quot;] = container.TranslateToContainerPath(tempHomeDirectory);
265              var tempWorkflowDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), &quot;_github_workflow&quot;);
266              Directory.CreateDirectory(tempWorkflowDirectory);
267              container.MountVolumes.Add(new MountVolume(tempWorkflowDirectory, &quot;/github/workflow&quot;));
268              container.AddPathTranslateMapping(tempWorkflowDirectory, &quot;/github/workflow&quot;);
269              container.ContainerWorkDirectory = container.TranslateToContainerPath(workingDirectory);
270              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
271              {
272                  container.ContainerEntryPoint = &quot;tail&quot;;
273                  container.ContainerEntryPointArgs = &quot;\&quot;-f\&quot; \&quot;/dev/null\&quot;&quot;;
274              }
275          }
276          private async Task StopContainerAsync(IExecutionContext executionContext, ContainerInfo container)
277          {
278              Trace.Entering();
279              ArgUtil.NotNull(executionContext, nameof(executionContext));
280              ArgUtil.NotNull(container, nameof(container));
281              if (!string.IsNullOrEmpty(container.ContainerId))
282              {
283                  if (!container.IsJobContainer &amp;&amp; !container.FailedInitialization)
284                  {
285                      executionContext.Output($&quot;Print service container logs: {container.ContainerDisplayName}&quot;);
286                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
287                      if (logsExitCode != 0)
288                      {
289                          executionContext.Warning($&quot;Docker logs fail with exit code {logsExitCode}&quot;);
290                      }
291                  }
292                  executionContext.Output($&quot;Stop and remove container: {container.ContainerDisplayName}&quot;);
293                  int rmExitCode = await _dockerManager.DockerRemove(executionContext, container.ContainerId);
294                  if (rmExitCode != 0)
295                  {
296                      executionContext.Warning($&quot;Docker rm fail with exit code {rmExitCode}&quot;);
297                  }
298              }
299          }
300  #if !OS_WINDOWS
301          private async Task&lt;List&lt;string&gt;&gt; ExecuteCommandAsync(IExecutionContext context, string command, string arg)
302          {
303              context.Command($&quot;{command} {arg}&quot;);
304              List&lt;string&gt; outputs = new();
305              object outputLock = new();
306              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
307              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
308              {
309                  if (!string.IsNullOrEmpty(message.Data))
310                  {
311                      lock (outputLock)
312                      {
313                          outputs.Add(message.Data);
314                      }
315                  }
316              };
317              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
318              {
319                  if (!string.IsNullOrEmpty(message.Data))
320                  {
321                      lock (outputLock)
322                      {
323                          outputs.Add(message.Data);
324                      }
325                  }
326              };
327              await processInvoker.ExecuteAsync(
328                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
329                              fileName: command,
330                              arguments: arg,
331                              environment: null,
332                              requireExitCodeZero: true,
333                              outputEncoding: null,
334                              cancellationToken: CancellationToken.None);
335              foreach (var outputLine in outputs)
336              {
337                  context.Output(outputLine);
338              }
339              return outputs;
340          }
341  #endif
342          private async Task CreateContainerNetworkAsync(IExecutionContext executionContext, string network)
343          {
344              Trace.Entering();
345              ArgUtil.NotNull(executionContext, nameof(executionContext));
346              int networkExitCode = await _dockerManager.DockerNetworkCreate(executionContext, network);
347              if (networkExitCode != 0)
348              {
349                  throw new InvalidOperationException($&quot;Docker network create failed with exit code {networkExitCode}&quot;);
350              }
351          }
352          private async Task RemoveContainerNetworkAsync(IExecutionContext executionContext, string network)
353          {
354              Trace.Entering();
355              ArgUtil.NotNull(executionContext, nameof(executionContext));
356              ArgUtil.NotNull(network, nameof(network));
357              executionContext.Output($&quot;Remove container network: {network}&quot;);
358              int removeExitCode = await _dockerManager.DockerNetworkRemove(executionContext, network);
359              if (removeExitCode != 0)
360              {
361                  executionContext.Warning($&quot;Docker network rm failed with exit code {removeExitCode}&quot;);
362              }
363          }
364          private async Task&lt;bool&gt; ContainerHealthcheck(IExecutionContext executionContext, ContainerInfo container)
365          {
366              string healthCheck = &quot;--format=\&quot;{{if .Config.Healthcheck}}{{print .State.Health.Status}}{{end}}\&quot;&quot;;
367              string serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
368              if (string.IsNullOrEmpty(serviceHealth))
369              {
370                  return true;
371              }
372              var retryCount = 0;
373              while (string.Equals(serviceHealth, &quot;starting&quot;, StringComparison.OrdinalIgnoreCase))
374              {
375                  TimeSpan backoff = BackoffTimerHelper.GetExponentialBackoff(retryCount, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(32), TimeSpan.FromSeconds(2));
376                  executionContext.Output($&quot;{container.ContainerNetworkAlias} service is starting, waiting {backoff.Seconds} seconds before checking again.&quot;);
377                  await Task.Delay(backoff, executionContext.CancellationToken);
378                  serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
379                  retryCount++;
380              }
381              return string.Equals(serviceHealth, &quot;healthy&quot;, StringComparison.OrdinalIgnoreCase);
382          }
383          private async Task&lt;string&gt; ContainerRegistryLogin(IExecutionContext executionContext, ContainerInfo container)
384          {
385              if (string.IsNullOrEmpty(container.RegistryAuthUsername) || string.IsNullOrEmpty(container.RegistryAuthPassword))
386              {
387                  return &quot;&quot;;
388              }
389              var configLocation = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), $&quot;.docker_{Guid.NewGuid()}&quot;);
390              try
391              {
392                  var dirInfo = Directory.CreateDirectory(configLocation);
393              }
394              catch (Exception e)
395              {
396                  throw new InvalidOperationException($&quot;Failed to create directory to store registry client credentials: {e.Message}&quot;);
397              }
398              var loginExitCode = await _dockerManager.DockerLogin(
399                  executionContext,
400                  configLocation,
401                  container.RegistryServer,
402                  container.RegistryAuthUsername,
403                  container.RegistryAuthPassword);
404              if (loginExitCode != 0)
405              {
406                  throw new InvalidOperationException($&quot;Docker login for &#x27;{container.RegistryServer}&#x27; failed with exit code {loginExitCode}&quot;);
407              }
408              return configLocation;
409          }
410          private void ContainerRegistryLogout(string configLocation)
411          {
412              try
413              {
414                  if (!string.IsNullOrEmpty(configLocation) &amp;&amp; Directory.Exists(configLocation))
415                  {
416                      Directory.Delete(configLocation, recursive: true);
417                  }
418              }
419              catch (Exception e)
420              {
421                  throw new InvalidOperationException($&quot;Failed to remove directory containing Docker client credentials: {e.Message}&quot;);
422              }
423          }
424          private void UpdateRegistryAuthForGitHubToken(IExecutionContext executionContext, ContainerInfo container)
425          {
426              var registryIsTokenCompatible = container.RegistryServer.Equals(&quot;ghcr.io&quot;, StringComparison.OrdinalIgnoreCase) || container.RegistryServer.Equals(&quot;containers.pkg.github.com&quot;, StringComparison.OrdinalIgnoreCase);
427              var isFallbackTokenFromHostedGithub = HostContext.GetService&lt;IConfigurationStore&gt;().GetSettings().IsHostedServer;
428              if (!registryIsTokenCompatible || !isFallbackTokenFromHostedGithub)
429              {
430                  return;
431              }
432              var registryCredentialsNotSupplied = string.IsNullOrEmpty(container.RegistryAuthUsername) &amp;&amp; string.IsNullOrEmpty(container.RegistryAuthPassword);
433              if (registryCredentialsNotSupplied)
434              {
435                  container.RegistryAuthUsername = executionContext.GetGitHubContext(&quot;actor&quot;);
436                  container.RegistryAuthPassword = executionContext.GetGitHubContext(&quot;token&quot;);
437              }
438          }
439          private async Task AssertCompatibleOS(IExecutionContext executionContext)
440          {
441  #if OS_WINDOWS
442  #pragma warning disable CA1416
443              ServiceController[] scServices = ServiceController.GetServices();
444              if (scServices.Any(x =&gt; String.Equals(x.ServiceName, &quot;cexecsvc&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; x.Status == ServiceControllerStatus.Running))
445              {
446                  throw new NotSupportedException(&quot;Container feature is not supported when runner is already running inside container.&quot;);
447              }
448  #pragma warning restore CA1416
449  #else
450              var initProcessCgroup = File.ReadLines(&quot;/proc/1/cgroup&quot;);
451              if (initProcessCgroup.Any(x =&gt; x.IndexOf(&quot;:/docker/&quot;, StringComparison.OrdinalIgnoreCase) &gt;= 0))
452              {
453                  throw new NotSupportedException(&quot;Container feature is not supported when runner is already running inside container.&quot;);
454              }
455  #endif
456  #if OS_WINDOWS
457  #pragma warning disable CA1416
458              object windowsInstallationType = Registry.GetValue(@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion&quot;, &quot;InstallationType&quot;, defaultValue: null);
459              ArgUtil.NotNull(windowsInstallationType, nameof(windowsInstallationType));
460              object windowsReleaseId = Registry.GetValue(@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion&quot;, &quot;ReleaseId&quot;, defaultValue: null);
461              ArgUtil.NotNull(windowsReleaseId, nameof(windowsReleaseId));
462              executionContext.Debug($&quot;Current Windows version: &#x27;{windowsReleaseId} ({windowsInstallationType})&#x27;&quot;);
463              if (int.TryParse(windowsReleaseId.ToString(), out int releaseId))
464              {
465                  if (!windowsInstallationType.ToString().StartsWith(&quot;Server&quot;, StringComparison.OrdinalIgnoreCase) || releaseId &lt; 1803)
466                  {
467                      throw new NotSupportedException(&quot;Container feature requires Windows Server 1803 or higher.&quot;);
468                  }
469              }
470              else
471              {
472                  throw new ArgumentOutOfRangeException(@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId&quot;);
473              }
474  #pragma warning restore CA1416
475  #endif
476              executionContext.Output(&quot;##[group]Checking docker version&quot;);
477              DockerVersion dockerVersion = await _dockerManager.DockerVersion(executionContext);
478              executionContext.Output(&quot;##[endgroup]&quot;);
479              ArgUtil.NotNull(dockerVersion.ServerVersion, nameof(dockerVersion.ServerVersion));
480              ArgUtil.NotNull(dockerVersion.ClientVersion, nameof(dockerVersion.ClientVersion));
481  #if OS_WINDOWS
482              Version requiredDockerEngineAPIVersion = new Version(1, 30);  
483  #else
484              Version requiredDockerEngineAPIVersion = new(1, 35); 
485  #endif
486              if (dockerVersion.ServerVersion &lt; requiredDockerEngineAPIVersion)
487              {
488                  throw new NotSupportedException($&quot;Min required docker engine API server version is &#x27;{requiredDockerEngineAPIVersion}&#x27;, your docker (&#x27;{_dockerManager.DockerPath}&#x27;) server version is &#x27;{dockerVersion.ServerVersion}&#x27;&quot;);
489              }
490              if (dockerVersion.ClientVersion &lt; requiredDockerEngineAPIVersion)
491              {
492                  throw new NotSupportedException($&quot;Min required docker engine API client version is &#x27;{requiredDockerEngineAPIVersion}&#x27;, your docker (&#x27;{_dockerManager.DockerPath}&#x27;) client version is &#x27;{dockerVersion.ClientVersion}&#x27;&quot;);
493              }
494          }
495      }
496  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Threading.Tasks;
5  using System.Linq;
6  using System.Threading;
7  using GitHub.Runner.Worker.Container;
8  using GitHub.Services.Common;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using GitHub.DistributedTask.Pipelines.ObjectTemplating;
13  using GitHub.Runner.Worker.Container.ContainerHooks;
14  #if OS_WINDOWS 
15  using System.ServiceProcess;
16  using Microsoft.Win32;
17  #endif
18  namespace GitHub.Runner.Worker
19  {
20      [ServiceLocator(Default = typeof(ContainerOperationProvider))]
21      public interface IContainerOperationProvider : IRunnerService
22      {
23          Task StartContainersAsync(IExecutionContext executionContext, object data);
24          Task StopContainersAsync(IExecutionContext executionContext, object data);
25      }
26      public class ContainerOperationProvider : RunnerService, IContainerOperationProvider
27      {
28          private IDockerCommandManager _dockerManager;
29          private IContainerHookManager _containerHookManager;
30          public override void Initialize(IHostContext hostContext)
31          {
32              base.Initialize(hostContext);
33              if (string.IsNullOrEmpty(Environment.GetEnvironmentVariable(Constants.Hooks.ContainerHooksPath)))
34              {
35                  _dockerManager = HostContext.GetService&lt;IDockerCommandManager&gt;();
36              }
37              else
38              {
39                  _containerHookManager = HostContext.GetService&lt;IContainerHookManager&gt;();
40              }
41          }
42          public async Task StartContainersAsync(IExecutionContext executionContext, object data)
43          {
44              Trace.Entering();
45              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
46              {
47                  throw new NotSupportedException(&quot;Container operations are only supported on Linux runners&quot;);
48              }
49              ArgUtil.NotNull(executionContext, nameof(executionContext));
50              List&lt;ContainerInfo&gt; containers = data as List&lt;ContainerInfo&gt;;
51              ArgUtil.NotNull(containers, nameof(containers));
52              var postJobStep = new JobExtensionRunner(runAsync: this.StopContainersAsync,
53                                                  condition: $&quot;{PipelineTemplateConstants.Always}()&quot;,
54                                                  displayName: &quot;Stop containers&quot;,
55                                                  data: data);
56              executionContext.Debug($&quot;Register post job cleanup for stopping/deleting containers.&quot;);
57              executionContext.RegisterPostJobStep(postJobStep);
58              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
59              {
60                  containers.ForEach(container =&gt; UpdateRegistryAuthForGitHubToken(executionContext, container));
61                  containers.Where(container =&gt; container.IsJobContainer).ForEach(container =&gt; MountWellKnownDirectories(executionContext, container));
62                  await _containerHookManager.PrepareJobAsync(executionContext, containers);
63                  return;
64              }
65              await AssertCompatibleOS(executionContext);
66              executionContext.Output(&quot;##[group]Clean up resources from previous jobs&quot;);
67              var staleContainers = await _dockerManager.DockerPS(executionContext, $&quot;--all --quiet --no-trunc --filter \&quot;label={_dockerManager.DockerInstanceLabel}\&quot;&quot;);
68              foreach (var staleContainer in staleContainers)
69              {
70                  int containerRemoveExitCode = await _dockerManager.DockerRemove(executionContext, staleContainer);
71                  if (containerRemoveExitCode != 0)
72                  {
73                      executionContext.Warning($&quot;Delete stale containers failed, docker rm fail with exit code {containerRemoveExitCode} for container {staleContainer}&quot;);
74                  }
75              }
76              int networkPruneExitCode = await _dockerManager.DockerNetworkPrune(executionContext);
77              if (networkPruneExitCode != 0)
78              {
79                  executionContext.Warning($&quot;Delete stale container networks failed, docker network prune fail with exit code {networkPruneExitCode}&quot;);
80              }
81              executionContext.Output(&quot;##[endgroup]&quot;);
82              executionContext.Output(&quot;##[group]Create local container network&quot;);
83              var containerNetwork = $&quot;github_network_{Guid.NewGuid().ToString(&quot;N&quot;)}&quot;;
84              await CreateContainerNetworkAsync(executionContext, containerNetwork);
85              executionContext.JobContext.Container[&quot;network&quot;] = new StringContextData(containerNetwork);
86              executionContext.Output(&quot;##[endgroup]&quot;);
87              foreach (var container in containers)
88              {
89                  container.ContainerNetwork = containerNetwork;
90                  await StartContainerAsync(executionContext, container);
91              }
92              await RunContainersHealthcheck(executionContext, containers);
93          }
94          public async Task RunContainersHealthcheck(IExecutionContext executionContext, List&lt;ContainerInfo&gt; containers)
95          {
96              executionContext.Output(&quot;##[group]Waiting for all services to be ready&quot;);
97              var unhealthyContainers = new List&lt;ContainerInfo&gt;();
98              foreach (var container in containers.Where(c =&gt; !c.IsJobContainer))
99              {
100                  var healthy_container = await ContainerHealthcheck(executionContext, container);
101                  if (!healthy_container)
102                  {
103                      unhealthyContainers.Add(container);
104                  }
105                  else
106                  {
107                      executionContext.Output($&quot;{container.ContainerNetworkAlias} service is healthy.&quot;);
108                  }
109              }
110              executionContext.Output(&quot;##[endgroup]&quot;);
111              if (unhealthyContainers.Count &gt; 0)
112              {
113                  foreach (var container in unhealthyContainers)
114                  {
115                      executionContext.Output($&quot;##[group]Service container {container.ContainerNetworkAlias} failed.&quot;);
116                      await _dockerManager.DockerLogs(context: executionContext, containerId: container.ContainerId);
117                      executionContext.Error($&quot;Failed to initialize container {container.ContainerImage}&quot;);
118                      container.FailedInitialization = true;
119                      executionContext.Output(&quot;##[endgroup]&quot;);
120                  }
121                  throw new InvalidOperationException(&quot;One or more containers failed to start.&quot;);
122              }
123          }
124          public async Task StopContainersAsync(IExecutionContext executionContext, object data)
125          {
126              Trace.Entering();
127              ArgUtil.NotNull(executionContext, nameof(executionContext));
128              List&lt;ContainerInfo&gt; containers = data as List&lt;ContainerInfo&gt;;
129              ArgUtil.NotNull(containers, nameof(containers));
130              if (FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
131              {
132                  await _containerHookManager.CleanupJobAsync(executionContext, containers);
133                  return;
134              }
135              foreach (var container in containers)
136              {
137                  await StopContainerAsync(executionContext, container);
138              }
139              await RemoveContainerNetworkAsync(executionContext, containers.First().ContainerNetwork);
140          }
141          private async Task StartContainerAsync(IExecutionContext executionContext, ContainerInfo container)
142          {
143              Trace.Entering();
144              ArgUtil.NotNull(executionContext, nameof(executionContext));
145              ArgUtil.NotNull(container, nameof(container));
146              ArgUtil.NotNullOrEmpty(container.ContainerImage, nameof(container.ContainerImage));
147              Trace.Info($&quot;Container name: {container.ContainerName}&quot;);
148              Trace.Info($&quot;Container image: {container.ContainerImage}&quot;);
149              Trace.Info($&quot;Container options: {container.ContainerCreateOptions}&quot;);
150              var groupName = container.IsJobContainer ? &quot;Starting job container&quot; : $&quot;Starting {container.ContainerNetworkAlias} service container&quot;;
151              executionContext.Output($&quot;##[group]{groupName}&quot;);
152              foreach (var port in container.UserPortMappings)
153              {
154                  Trace.Info($&quot;User provided port: {port.Value}&quot;);
155              }
156              foreach (var mount in container.UserMountVolumes)
157              {
158                  Trace.Info($&quot;User provided volume: {mount.UserProvidedValue}&quot;);
159                  if (string.Equals(mount.SourceVolumePath, &quot;/&quot;, StringComparison.OrdinalIgnoreCase))
160                  {
161                      executionContext.Warning($&quot;Volume mount {mount.UserProvidedValue} is going to mount &#x27;/&#x27; into the container which may cause file ownership change in the entire file system and cause Actions Runner to lose permission to access the disk.&quot;);
162                  }
163              }
164              UpdateRegistryAuthForGitHubToken(executionContext, container);
165              var configLocation = await ContainerRegistryLogin(executionContext, container);
166              int retryCount = 0;
167              int pullExitCode = 0;
168              while (retryCount &lt; 3)
169              {
170                  pullExitCode = await _dockerManager.DockerPull(executionContext, container.ContainerImage, configLocation);
171                  if (pullExitCode == 0)
172                  {
173                      break;
174                  }
175                  else
176                  {
177                      retryCount++;
178                      if (retryCount &lt; 3)
179                      {
180                          var backOff = BackoffTimerHelper.GetRandomBackoff(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(10));
181                          executionContext.Warning($&quot;Docker pull failed with exit code {pullExitCode}, back off {backOff.TotalSeconds} seconds before retry.&quot;);
182                          await Task.Delay(backOff);
183                      }
184                  }
185              }
186              ContainerRegistryLogout(configLocation);
187              if (retryCount == 3 &amp;&amp; pullExitCode != 0)
188              {
189                  throw new InvalidOperationException($&quot;Docker pull failed with exit code {pullExitCode}&quot;);
190              }
191              if (container.IsJobContainer)
192              {
193                  MountWellKnownDirectories(executionContext, container);
194              }
195              container.ContainerId = await _dockerManager.DockerCreate(executionContext, container);
196              ArgUtil.NotNullOrEmpty(container.ContainerId, nameof(container.ContainerId));
197              int startExitCode = await _dockerManager.DockerStart(executionContext, container.ContainerId);
198              if (startExitCode != 0)
199              {
200                  throw new InvalidOperationException($&quot;Docker start fail with exit code {startExitCode}&quot;);
201              }
202              try
203              {
<span onclick='openModal()' class='match'>204                  var psOutputs = await _dockerManager.DockerPS(executionContext, $&quot;--all --filter id={container.ContainerId} --filter status=running --no-trunc --format \&quot;{{{{.ID}}}} {{{{.Status}}}}\&quot;&quot;);
205                  if (psOutputs.FirstOrDefault(x =&gt; !string.IsNullOrEmpty(x))?.StartsWith(container.ContainerId) != true)
</span>206                  {
207                      await _dockerManager.DockerPS(executionContext, $&quot;--all --filter id={container.ContainerId} --no-trunc --format \&quot;{{{{.ID}}}} {{{{.Status}}}}\&quot;&quot;);
208                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
209                      if (logsExitCode != 0)
210                      {
211                          executionContext.Warning($&quot;Docker logs fail with exit code {logsExitCode}&quot;);
212                      }
213                      executionContext.Warning($&quot;Docker container {container.ContainerId} is not in running state.&quot;);
214                  }
215              }
216              catch (Exception ex)
217              {
218                  Trace.Error(&quot;Catch exception when check container log and container status.&quot;);
219                  Trace.Error(ex);
220              }
221              if (!container.IsJobContainer)
222              {
223                  var service = new DictionaryContextData()
224                  {
225                      [&quot;id&quot;] = new StringContextData(container.ContainerId),
226                      [&quot;ports&quot;] = new DictionaryContextData(),
227                      [&quot;network&quot;] = new StringContextData(container.ContainerNetwork)
228                  };
229                  container.AddPortMappings(await _dockerManager.DockerPort(executionContext, container.ContainerId));
230                  foreach (var port in container.PortMappings)
231                  {
232                      (service[&quot;ports&quot;] as DictionaryContextData)[port.ContainerPort] = new StringContextData(port.HostPort);
233                  }
234                  executionContext.JobContext.Services[container.ContainerNetworkAlias] = service;
235              }
236              else
237              {
238                  var configEnvFormat = &quot;--format \&quot;{{range .Config.Env}}{{println .}}{{end}}\&quot;&quot;;
239                  var containerEnv = await _dockerManager.DockerInspect(executionContext, container.ContainerId, configEnvFormat);
240                  container.ContainerRuntimePath = DockerUtil.ParsePathFromConfigEnv(containerEnv);
241                  executionContext.JobContext.Container[&quot;id&quot;] = new StringContextData(container.ContainerId);
242              }
243              executionContext.Output(&quot;##[endgroup]&quot;);
244          }
245          private void MountWellKnownDirectories(IExecutionContext executionContext, ContainerInfo container)
246          {
247              var githubContext = executionContext.ExpressionValues[&quot;github&quot;] as GitHubContext;
248              ArgUtil.NotNull(githubContext, nameof(githubContext));
249              var workingDirectory = githubContext[&quot;workspace&quot;] as StringContextData;
250              ArgUtil.NotNullOrEmpty(workingDirectory, nameof(workingDirectory));
251              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Work), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Work))));
252  #if OS_WINDOWS
253                  container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals))));
254  #else
255              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Externals), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Externals)), true));
256  #endif
257              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Temp), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Temp))));
258              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Actions), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Actions))));
259              container.MountVolumes.Add(new MountVolume(HostContext.GetDirectory(WellKnownDirectory.Tools), container.TranslateToContainerPath(HostContext.GetDirectory(WellKnownDirectory.Tools))));
260              var tempHomeDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), &quot;_github_home&quot;);
261              Directory.CreateDirectory(tempHomeDirectory);
262              container.MountVolumes.Add(new MountVolume(tempHomeDirectory, &quot;/github/home&quot;));
263              container.AddPathTranslateMapping(tempHomeDirectory, &quot;/github/home&quot;);
264              container.ContainerEnvironmentVariables[&quot;HOME&quot;] = container.TranslateToContainerPath(tempHomeDirectory);
265              var tempWorkflowDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), &quot;_github_workflow&quot;);
266              Directory.CreateDirectory(tempWorkflowDirectory);
267              container.MountVolumes.Add(new MountVolume(tempWorkflowDirectory, &quot;/github/workflow&quot;));
268              container.AddPathTranslateMapping(tempWorkflowDirectory, &quot;/github/workflow&quot;);
269              container.ContainerWorkDirectory = container.TranslateToContainerPath(workingDirectory);
270              if (!FeatureManager.IsContainerHooksEnabled(executionContext.Global.Variables))
271              {
272                  container.ContainerEntryPoint = &quot;tail&quot;;
273                  container.ContainerEntryPointArgs = &quot;\&quot;-f\&quot; \&quot;/dev/null\&quot;&quot;;
274              }
275          }
276          private async Task StopContainerAsync(IExecutionContext executionContext, ContainerInfo container)
277          {
278              Trace.Entering();
279              ArgUtil.NotNull(executionContext, nameof(executionContext));
280              ArgUtil.NotNull(container, nameof(container));
281              if (!string.IsNullOrEmpty(container.ContainerId))
282              {
283                  if (!container.IsJobContainer &amp;&amp; !container.FailedInitialization)
284                  {
285                      executionContext.Output($&quot;Print service container logs: {container.ContainerDisplayName}&quot;);
286                      int logsExitCode = await _dockerManager.DockerLogs(executionContext, container.ContainerId);
287                      if (logsExitCode != 0)
288                      {
289                          executionContext.Warning($&quot;Docker logs fail with exit code {logsExitCode}&quot;);
290                      }
291                  }
292                  executionContext.Output($&quot;Stop and remove container: {container.ContainerDisplayName}&quot;);
293                  int rmExitCode = await _dockerManager.DockerRemove(executionContext, container.ContainerId);
294                  if (rmExitCode != 0)
295                  {
296                      executionContext.Warning($&quot;Docker rm fail with exit code {rmExitCode}&quot;);
297                  }
298              }
299          }
300  #if !OS_WINDOWS
301          private async Task&lt;List&lt;string&gt;&gt; ExecuteCommandAsync(IExecutionContext context, string command, string arg)
302          {
303              context.Command($&quot;{command} {arg}&quot;);
304              List&lt;string&gt; outputs = new();
305              object outputLock = new();
306              var processInvoker = HostContext.CreateService&lt;IProcessInvoker&gt;();
307              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
308              {
309                  if (!string.IsNullOrEmpty(message.Data))
310                  {
311                      lock (outputLock)
312                      {
313                          outputs.Add(message.Data);
314                      }
315                  }
316              };
317              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
318              {
319                  if (!string.IsNullOrEmpty(message.Data))
320                  {
321                      lock (outputLock)
322                      {
323                          outputs.Add(message.Data);
324                      }
325                  }
326              };
327              await processInvoker.ExecuteAsync(
328                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
329                              fileName: command,
330                              arguments: arg,
331                              environment: null,
332                              requireExitCodeZero: true,
333                              outputEncoding: null,
334                              cancellationToken: CancellationToken.None);
335              foreach (var outputLine in outputs)
336              {
337                  context.Output(outputLine);
338              }
339              return outputs;
340          }
341  #endif
342          private async Task CreateContainerNetworkAsync(IExecutionContext executionContext, string network)
343          {
344              Trace.Entering();
345              ArgUtil.NotNull(executionContext, nameof(executionContext));
346              int networkExitCode = await _dockerManager.DockerNetworkCreate(executionContext, network);
347              if (networkExitCode != 0)
348              {
349                  throw new InvalidOperationException($&quot;Docker network create failed with exit code {networkExitCode}&quot;);
350              }
351          }
352          private async Task RemoveContainerNetworkAsync(IExecutionContext executionContext, string network)
353          {
354              Trace.Entering();
355              ArgUtil.NotNull(executionContext, nameof(executionContext));
356              ArgUtil.NotNull(network, nameof(network));
357              executionContext.Output($&quot;Remove container network: {network}&quot;);
358              int removeExitCode = await _dockerManager.DockerNetworkRemove(executionContext, network);
359              if (removeExitCode != 0)
360              {
361                  executionContext.Warning($&quot;Docker network rm failed with exit code {removeExitCode}&quot;);
362              }
363          }
364          private async Task&lt;bool&gt; ContainerHealthcheck(IExecutionContext executionContext, ContainerInfo container)
365          {
366              string healthCheck = &quot;--format=\&quot;{{if .Config.Healthcheck}}{{print .State.Health.Status}}{{end}}\&quot;&quot;;
367              string serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
368              if (string.IsNullOrEmpty(serviceHealth))
369              {
370                  return true;
371              }
372              var retryCount = 0;
373              while (string.Equals(serviceHealth, &quot;starting&quot;, StringComparison.OrdinalIgnoreCase))
374              {
375                  TimeSpan backoff = BackoffTimerHelper.GetExponentialBackoff(retryCount, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(32), TimeSpan.FromSeconds(2));
376                  executionContext.Output($&quot;{container.ContainerNetworkAlias} service is starting, waiting {backoff.Seconds} seconds before checking again.&quot;);
377                  await Task.Delay(backoff, executionContext.CancellationToken);
378                  serviceHealth = (await _dockerManager.DockerInspect(context: executionContext, dockerObject: container.ContainerId, options: healthCheck)).FirstOrDefault();
379                  retryCount++;
380              }
381              return string.Equals(serviceHealth, &quot;healthy&quot;, StringComparison.OrdinalIgnoreCase);
382          }
383          private async Task&lt;string&gt; ContainerRegistryLogin(IExecutionContext executionContext, ContainerInfo container)
384          {
385              if (string.IsNullOrEmpty(container.RegistryAuthUsername) || string.IsNullOrEmpty(container.RegistryAuthPassword))
386              {
387                  return &quot;&quot;;
388              }
389              var configLocation = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), $&quot;.docker_{Guid.NewGuid()}&quot;);
390              try
391              {
392                  var dirInfo = Directory.CreateDirectory(configLocation);
393              }
394              catch (Exception e)
395              {
396                  throw new InvalidOperationException($&quot;Failed to create directory to store registry client credentials: {e.Message}&quot;);
397              }
398              var loginExitCode = await _dockerManager.DockerLogin(
399                  executionContext,
400                  configLocation,
401                  container.RegistryServer,
402                  container.RegistryAuthUsername,
403                  container.RegistryAuthPassword);
404              if (loginExitCode != 0)
405              {
406                  throw new InvalidOperationException($&quot;Docker login for &#x27;{container.RegistryServer}&#x27; failed with exit code {loginExitCode}&quot;);
407              }
408              return configLocation;
409          }
410          private void ContainerRegistryLogout(string configLocation)
411          {
412              try
413              {
414                  if (!string.IsNullOrEmpty(configLocation) &amp;&amp; Directory.Exists(configLocation))
415                  {
416                      Directory.Delete(configLocation, recursive: true);
417                  }
418              }
419              catch (Exception e)
420              {
421                  throw new InvalidOperationException($&quot;Failed to remove directory containing Docker client credentials: {e.Message}&quot;);
422              }
423          }
424          private void UpdateRegistryAuthForGitHubToken(IExecutionContext executionContext, ContainerInfo container)
425          {
426              var registryIsTokenCompatible = container.RegistryServer.Equals(&quot;ghcr.io&quot;, StringComparison.OrdinalIgnoreCase) || container.RegistryServer.Equals(&quot;containers.pkg.github.com&quot;, StringComparison.OrdinalIgnoreCase);
427              var isFallbackTokenFromHostedGithub = HostContext.GetService&lt;IConfigurationStore&gt;().GetSettings().IsHostedServer;
428              if (!registryIsTokenCompatible || !isFallbackTokenFromHostedGithub)
429              {
430                  return;
431              }
432              var registryCredentialsNotSupplied = string.IsNullOrEmpty(container.RegistryAuthUsername) &amp;&amp; string.IsNullOrEmpty(container.RegistryAuthPassword);
433              if (registryCredentialsNotSupplied)
434              {
435                  container.RegistryAuthUsername = executionContext.GetGitHubContext(&quot;actor&quot;);
436                  container.RegistryAuthPassword = executionContext.GetGitHubContext(&quot;token&quot;);
437              }
438          }
439          private async Task AssertCompatibleOS(IExecutionContext executionContext)
440          {
441  #if OS_WINDOWS
442  #pragma warning disable CA1416
443              ServiceController[] scServices = ServiceController.GetServices();
444              if (scServices.Any(x =&gt; String.Equals(x.ServiceName, &quot;cexecsvc&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; x.Status == ServiceControllerStatus.Running))
445              {
446                  throw new NotSupportedException(&quot;Container feature is not supported when runner is already running inside container.&quot;);
447              }
448  #pragma warning restore CA1416
449  #else
450              var initProcessCgroup = File.ReadLines(&quot;/proc/1/cgroup&quot;);
451              if (initProcessCgroup.Any(x =&gt; x.IndexOf(&quot;:/docker/&quot;, StringComparison.OrdinalIgnoreCase) &gt;= 0))
452              {
453                  throw new NotSupportedException(&quot;Container feature is not supported when runner is already running inside container.&quot;);
454              }
455  #endif
456  #if OS_WINDOWS
457  #pragma warning disable CA1416
458              object windowsInstallationType = Registry.GetValue(@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion&quot;, &quot;InstallationType&quot;, defaultValue: null);
459              ArgUtil.NotNull(windowsInstallationType, nameof(windowsInstallationType));
460              object windowsReleaseId = Registry.GetValue(@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion&quot;, &quot;ReleaseId&quot;, defaultValue: null);
461              ArgUtil.NotNull(windowsReleaseId, nameof(windowsReleaseId));
462              executionContext.Debug($&quot;Current Windows version: &#x27;{windowsReleaseId} ({windowsInstallationType})&#x27;&quot;);
463              if (int.TryParse(windowsReleaseId.ToString(), out int releaseId))
464              {
465                  if (!windowsInstallationType.ToString().StartsWith(&quot;Server&quot;, StringComparison.OrdinalIgnoreCase) || releaseId &lt; 1803)
466                  {
467                      throw new NotSupportedException(&quot;Container feature requires Windows Server 1803 or higher.&quot;);
468                  }
469              }
470              else
471              {
472                  throw new ArgumentOutOfRangeException(@&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId&quot;);
473              }
474  #pragma warning restore CA1416
475  #endif
476              executionContext.Output(&quot;##[group]Checking docker version&quot;);
477              DockerVersion dockerVersion = await _dockerManager.DockerVersion(executionContext);
478              executionContext.Output(&quot;##[endgroup]&quot;);
479              ArgUtil.NotNull(dockerVersion.ServerVersion, nameof(dockerVersion.ServerVersion));
480              ArgUtil.NotNull(dockerVersion.ClientVersion, nameof(dockerVersion.ClientVersion));
481  #if OS_WINDOWS
482              Version requiredDockerEngineAPIVersion = new Version(1, 30);  
483  #else
484              Version requiredDockerEngineAPIVersion = new(1, 35); 
485  #endif
486              if (dockerVersion.ServerVersion &lt; requiredDockerEngineAPIVersion)
487              {
488                  throw new NotSupportedException($&quot;Min required docker engine API server version is &#x27;{requiredDockerEngineAPIVersion}&#x27;, your docker (&#x27;{_dockerManager.DockerPath}&#x27;) server version is &#x27;{dockerVersion.ServerVersion}&#x27;&quot;);
489              }
490              if (dockerVersion.ClientVersion &lt; requiredDockerEngineAPIVersion)
491              {
492                  throw new NotSupportedException($&quot;Min required docker engine API client version is &#x27;{requiredDockerEngineAPIVersion}&#x27;, your docker (&#x27;{_dockerManager.DockerPath}&#x27;) client version is &#x27;{dockerVersion.ClientVersion}&#x27;&quot;);
493              }
494          }
495      }
496  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerOperationProvider.cs</div>
                </div>
                <div class="column column_space"><pre><code>67              var staleContainers = await _dockerManager.DockerPS(executionContext, $&quot;--all --quiet --no-trunc --filter \&quot;label={_dockerManager.DockerInstanceLabel}\&quot;&quot;);
68              foreach (var staleContainer in staleContainers)
</pre></code></div>
                <div class="column column_space"><pre><code>204                  var psOutputs = await _dockerManager.DockerPS(executionContext, $&quot;--all --filter id={container.ContainerId} --filter status=running --no-trunc --format \&quot;{{{{.ID}}}} {{{{.Status}}}}\&quot;&quot;);
205                  if (psOutputs.FirstOrDefault(x =&gt; !string.IsNullOrEmpty(x))?.StartsWith(container.ContainerId) != true)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    