
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.361930294906166%, Tokens: 10</h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-Program_9.cs</h3>
            <pre><code>1  using System.IO;
2  using Microsoft.AspNetCore.Hosting;
3  using Microsoft.Extensions.Logging;
4  namespace CookieSample
5  {
6      public static class Program
7      {
8          public static void Main(string[] args)
9          {
10              var host = new WebHostBuilder()
11                  .ConfigureLogging(factory =>
12                  {
<span onclick='openModal()' class='match'>13                      factory.AddConsole();
14                      factory.AddFilter("Console", level => level >= LogLevel.Information);
15                  })
16                  .UseKestrel()
17                  .UseContentRoot(Directory.GetCurrentDirectory())
18                  .UseIISIntegration()
19                  .UseStartup<Startup>()
20                  .Build();
21              host.Run();
22          }
</span>23      }
24  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtil.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.IO;
5  using System.Linq;
6  using System.Security.Cryptography;
7  using System.Text;
8  using System.Threading;
9  namespace GitHub.Runner.Sdk
10  {
11      public static class IOUtil
12      {
13          public static string ExeExtension
14          {
15              get
16              {
17  #if OS_WINDOWS
18                  return ".exe";
19  #else
20                  return string.Empty;
21  #endif
22              }
23          }
24          public static StringComparison FilePathStringComparison
25          {
26              get
27              {
28  #if OS_LINUX
29                  return StringComparison.Ordinal;
30  #else
31                  return StringComparison.OrdinalIgnoreCase;
32  #endif
33              }
34          }
35          public static void SaveObject(object obj, string path)
36          {
37              File.WriteAllText(path, StringUtil.ConvertToJson(obj), Encoding.UTF8);
38          }
39          public static T LoadObject<T>(string path, bool required = false)
40          {
41              string json = File.ReadAllText(path, Encoding.UTF8);
42              if (required && string.IsNullOrEmpty(json))
43              {
44                  throw new ArgumentNullException($"File {path} is empty");
45              }
46              T result = StringUtil.ConvertFromJson<T>(json);
47              if (required && result == null)
48              {
49                  throw new ArgumentException("Converting json to object resulted in a null value");
50              }
51              return result;
52          }
53          public static string GetSha256Hash(string path)
54          {
55              string hashString = path.ToLowerInvariant();
56              using (SHA256 sha256hash = SHA256.Create())
57              {
58                  byte[] data = sha256hash.ComputeHash(Encoding.UTF8.GetBytes(hashString));
59                  StringBuilder sBuilder = new();
60                  for (int i = 0; i < data.Length; i++)
61                  {
62                      sBuilder.Append(data[i].ToString("x2"));
63                  }
64                  string hash = sBuilder.ToString();
65                  return hash;
66              }
67          }
68          public static void Delete(string path, CancellationToken cancellationToken)
69          {
70              DeleteDirectory(path, cancellationToken);
71              DeleteFile(path);
72          }
73          public static void DeleteDirectory(string path, CancellationToken cancellationToken)
74          {
75              DeleteDirectory(path, contentsOnly: false, continueOnContentDeleteError: false, cancellationToken: cancellationToken);
76          }
77          public static void DeleteDirectory(string path, bool contentsOnly, bool continueOnContentDeleteError, CancellationToken cancellationToken)
78          {
79              ArgUtil.NotNullOrEmpty(path, nameof(path));
80              DirectoryInfo directory = new(path);
81              if (!directory.Exists)
82              {
83                  return;
84              }
85              if (!contentsOnly)
86              {
87                  RemoveReadOnly(directory);
88                  if (directory.Attributes.HasFlag(FileAttributes.ReparsePoint))
89                  {
90                      directory.Delete();
91                      return;
92                  }
93              }
94              var directories = new ConcurrentStack<DirectoryInfo>();
95              if (!contentsOnly)
96              {
97                  directories.Push(directory);
98              }
99              using (var tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
100              {
101                  try
102                  {
103                      Enumerate(directory, tokenSource)
104                          .AsParallel()
105                          .WithCancellation(tokenSource.Token)
106                          .ForAll((FileSystemInfo item) =>
107                          {
108                              bool success = false;
109                              try
110                              {
111                                  RemoveReadOnly(item);
112                                  if (item is FileInfo)
113                                  {
114                                      item.Delete();
115                                  }
116                                  else
117                                  {
118                                      var subdirectory = item as DirectoryInfo;
119                                      ArgUtil.NotNull(subdirectory, nameof(subdirectory));
120                                      if (subdirectory.Attributes.HasFlag(FileAttributes.ReparsePoint))
121                                      {
122                                          try
123                                          {
124                                              subdirectory.Delete();
125                                          }
126                                          catch (DirectoryNotFoundException)
127                                          {
128                                              File.Delete(subdirectory.FullName);
129                                          }
130                                      }
131                                      else
132                                      {
133                                          directories.Push(subdirectory);
134                                      }
135                                  }
136                                  success = true;
137                              }
138                              catch (Exception) when (continueOnContentDeleteError)
139                              {
140                                  success = true;
141                              }
142                              finally
143                              {
144                                  if (!success)
145                                  {
146                                      tokenSource.Cancel(); 
147                                  }
148                              }
149                          });
150                  }
151                  catch (Exception)
152                  {
153                      tokenSource.Cancel();
154                      throw;
155                  }
156              }
157              foreach (DirectoryInfo dir in directories.OrderByDescending(x => x.FullName.Length))
158              {
159                  cancellationToken.ThrowIfCancellationRequested();
160                  dir.Delete();
161              }
162          }
163          public static void DeleteFile(string path)
164          {
165              ArgUtil.NotNullOrEmpty(path, nameof(path));
166              var file = new FileInfo(path);
167              if (file.Exists)
168              {
169                  RemoveReadOnly(file);
170                  file.Delete();
171              }
172          }
173          public static void MoveDirectory(string sourceDir, string targetDir, string stagingDir, CancellationToken token)
174          {
<span onclick='openModal()' class='match'>175              ArgUtil.Directory(sourceDir, nameof(sourceDir));
176              ArgUtil.NotNullOrEmpty(targetDir, nameof(targetDir));
177              ArgUtil.NotNullOrEmpty(stagingDir, nameof(stagingDir));
178              DeleteDirectory(stagingDir, token);
179              Directory.CreateDirectory(Path.GetDirectoryName(stagingDir));
180              Directory.Move(sourceDir, stagingDir);
181              DeleteDirectory(targetDir, token);
182              Directory.CreateDirectory(Path.GetDirectoryName(targetDir));
183              Directory.Move(stagingDir, targetDir);
184          }
</span>185          public static string MakeRelative(string path, string folder)
186          {
187              ArgUtil.NotNullOrEmpty(path, nameof(path));
188              ArgUtil.NotNull(folder, nameof(folder));
189              path = path.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
190              folder = folder.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
191              if (!path.StartsWith(folder, IOUtil.FilePathStringComparison))
192              {
193                  return path;
194              }
195              if (path.Length == folder.Length)
196              {
197                  return string.Empty;
198              }
199              if (folder.Length > 0 && folder[folder.Length - 1] == Path.DirectorySeparatorChar)
200              {
201                  return path.Substring(folder.Length);
202              }
203              else if (path[folder.Length] == Path.DirectorySeparatorChar)
204              {
205                  return path.Substring(folder.Length + 1);
206              }
207              else
208              {
209                  return path;
210              }
211          }
212          public static string ResolvePath(String rootPath, String relativePath)
213          {
214              ArgUtil.NotNullOrEmpty(rootPath, nameof(rootPath));
215              ArgUtil.NotNullOrEmpty(relativePath, nameof(relativePath));
216              if (!Path.IsPathRooted(rootPath))
217              {
218                  throw new ArgumentException($"{rootPath} should be a rooted path.");
219              }
220              if (relativePath.IndexOfAny(Path.GetInvalidPathChars()) > -1)
221              {
222                  throw new InvalidOperationException($"{relativePath} contains invalid path characters.");
223              }
224              else if (Path.GetFileName(relativePath).IndexOfAny(Path.GetInvalidFileNameChars()) > -1)
225              {
226                  throw new InvalidOperationException($"{relativePath} contains invalid folder name characters.");
227              }
228              else if (Path.IsPathRooted(relativePath))
229              {
230                  throw new InvalidOperationException($"{relativePath} can not be a rooted path.");
231              }
232              else
233              {
234                  rootPath = rootPath.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
235                  relativePath = relativePath.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
236                  relativePath = String.Concat(rootPath, Path.AltDirectorySeparatorChar, relativePath);
237                  String[] split = relativePath.Split(new[] { Path.AltDirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);
238                  var segments = new Stack<String>(split.Length);
239                  Int32 skip = 0;
240                  for (Int32 i = split.Length - 1; i >= 0; i--)
241                  {
242                      String segment = split[i];
243                      if (String.Equals(segment, ".", StringComparison.Ordinal))
244                      {
245                          continue;
246                      }
247                      else if (String.Equals(segment, "..", StringComparison.Ordinal))
248                      {
249                          skip++;
250                      }
251                      else if (skip > 0)
252                      {
253                          skip--;
254                      }
255                      else
256                      {
257                          segments.Push(segment);
258                      }
259                  }
260                  if (skip > 0)
261                  {
262                      throw new InvalidOperationException($"The file path {relativePath} is invalid");
263                  }
264  #if OS_WINDOWS
265                  if (segments.Count > 1)
266                  {
267                      return String.Join(Path.DirectorySeparatorChar, segments);
268                  }
269                  else
270                  {
271                      return segments.Pop() + Path.DirectorySeparatorChar;
272                  }
273  #else
274                  return Path.DirectorySeparatorChar + String.Join(Path.DirectorySeparatorChar, segments);
275  #endif
276              }
277          }
278          public static void CopyDirectory(string source, string target, CancellationToken cancellationToken)
279          {
280              ArgUtil.Directory(source, nameof(source));
281              ArgUtil.NotNullOrEmpty(target, nameof(target));
282              ArgUtil.NotNull(cancellationToken, nameof(cancellationToken));
283              cancellationToken.ThrowIfCancellationRequested();
284              Directory.CreateDirectory(target);
285              DirectoryInfo sourceDir = new(source);
286              foreach (FileInfo sourceFile in sourceDir.GetFiles() ?? new FileInfo[0])
287              {
288                  cancellationToken.ThrowIfCancellationRequested();
289                  FileInfo targetFile = new(Path.Combine(target, sourceFile.Name));
290                  if (!targetFile.Exists ||
291                      sourceFile.Length != targetFile.Length ||
292                      sourceFile.LastWriteTime != targetFile.LastWriteTime)
293                  {
294                      sourceFile.CopyTo(targetFile.FullName, true);
295                  }
296              }
297              foreach (DirectoryInfo subDir in sourceDir.GetDirectories() ?? new DirectoryInfo[0])
298              {
299                  CopyDirectory(
300                      source: subDir.FullName,
301                      target: Path.Combine(target, subDir.Name),
302                      cancellationToken: cancellationToken);
303              }
304          }
305          public static void ValidateExecutePermission(string directory)
306          {
307              ArgUtil.Directory(directory, nameof(directory));
308              string dir = directory;
309              string failsafeString = Environment.GetEnvironmentVariable("AGENT_TEST_VALIDATE_EXECUTE_PERMISSIONS_FAILSAFE");
310              int failsafe;
311              if (string.IsNullOrEmpty(failsafeString) || !int.TryParse(failsafeString, out failsafe))
312              {
313                  failsafe = 100;
314              }
315              for (int i = 0; i < failsafe; i++)
316              {
317                  try
318                  {
319                      Directory.EnumerateFileSystemEntries(dir).FirstOrDefault();
320                  }
321                  catch (UnauthorizedAccessException ex)
322                  {
323                      string message = $"Permission to read the directory contents is required for '{directory}' and each directory up the hierarchy. {ex.Message}";
324                      throw new UnauthorizedAccessException(message, ex);
325                  }
326                  dir = Path.GetDirectoryName(dir);
327                  if (string.IsNullOrEmpty(dir))
328                  {
329                      return;
330                  }
331              }
332              throw new NotSupportedException($"Unable to validate execute permissions for directory '{directory}'. Exceeded maximum iterations.");
333          }
334          public static void CreateEmptyFile(string path)
335          {
336              Directory.CreateDirectory(Path.GetDirectoryName(path));
337              File.WriteAllText(path, null);
338          }
339          private static IEnumerable<FileSystemInfo> Enumerate(DirectoryInfo directory, CancellationTokenSource tokenSource)
340          {
341              ArgUtil.NotNull(directory, nameof(directory));
342              ArgUtil.Equal(false, directory.Attributes.HasFlag(FileAttributes.ReparsePoint), nameof(directory.Attributes.HasFlag));
343              var directories = new Stack<DirectoryInfo>(new[] { directory });
344              while (directories.Count > 0)
345              {
346                  directory = directories.Pop();
347                  foreach (FileSystemInfo item in directory.GetFileSystemInfos())
348                  {
349                      directory = item as DirectoryInfo;
350                      if (directory != null &&
351                          !item.Attributes.HasFlag(FileAttributes.ReparsePoint))
352                      {
353                          directories.Push(directory);
354                      }
355                      yield return item;
356                  }
357              }
358          }
359          private static void RemoveReadOnly(FileSystemInfo item)
360          {
361              ArgUtil.NotNull(item, nameof(item));
362              if (item.Attributes.HasFlag(FileAttributes.ReadOnly))
363              {
364                  item.Attributes = item.Attributes & ~FileAttributes.ReadOnly;
365              }
366          }
367      }
368  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-Program_9.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-IOUtil.cs</div>
                <div class="column column_space"><pre><code>13                      factory.AddConsole();
14                      factory.AddFilter("Console", level => level >= LogLevel.Information);
15                  })
16                  .UseKestrel()
17                  .UseContentRoot(Directory.GetCurrentDirectory())
18                  .UseIISIntegration()
19                  .UseStartup<Startup>()
20                  .Build();
21              host.Run();
22          }
</pre></code></div>
                <div class="column column_space"><pre><code>175              ArgUtil.Directory(sourceDir, nameof(sourceDir));
176              ArgUtil.NotNullOrEmpty(targetDir, nameof(targetDir));
177              ArgUtil.NotNullOrEmpty(stagingDir, nameof(stagingDir));
178              DeleteDirectory(stagingDir, token);
179              Directory.CreateDirectory(Path.GetDirectoryName(stagingDir));
180              Directory.Move(sourceDir, stagingDir);
181              DeleteDirectory(targetDir, token);
182              Directory.CreateDirectory(Path.GetDirectoryName(targetDir));
183              Directory.Move(stagingDir, targetDir);
184          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    