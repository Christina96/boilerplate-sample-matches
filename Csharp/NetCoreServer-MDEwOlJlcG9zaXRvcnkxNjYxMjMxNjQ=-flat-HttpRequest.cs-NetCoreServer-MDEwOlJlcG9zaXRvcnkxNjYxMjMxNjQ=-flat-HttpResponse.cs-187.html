
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 121, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpRequest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Text;
5  namespace NetCoreServer
6  {
7      public class HttpRequest
8      {
9          public HttpRequest()
10          {
11              Clear();
12          }
13          public HttpRequest(string method, string url, string protocol = &quot;HTTP/1.1&quot;)
14          {
15              SetBegin(method, url, protocol);
16          }
17          public bool IsEmpty { get { return (_cache.Size == 0); } }
18          public bool IsErrorSet { get; private set; }
19          public string Method { get { return _method; } }
20          public string Url { get { return _url; } }
21          public string Protocol { get { return _protocol; } }
22          public long Headers { get { return _headers.Count; } }
23          public (string, string) Header(int i)
24          {
25              Debug.Assert((i &lt; _headers.Count), &quot;Index out of bounds!&quot;);
26              if (i &gt;= _headers.Count)
27                  return (&quot;&quot;, &quot;&quot;);
28              return _headers[i];
29          }
30          public long Cookies { get { return _cookies.Count; } }
31          public (string, string) Cookie(int i)
32          {
33              Debug.Assert((i &lt; _cookies.Count), &quot;Index out of bounds!&quot;);
34              if (i &gt;= _cookies.Count)
35                  return (&quot;&quot;, &quot;&quot;);
36              return _cookies[i];
37          }
38          public string Body { get { return _cache.ExtractString(_bodyIndex, _bodySize); } }
39          public byte[] BodyBytes { get { return _cache.Data[_bodyIndex..(_bodyIndex + _bodySize)]; } }
40          public Span&lt;byte&gt; BodySpan { get { return new Span&lt;byte&gt;(_cache.Data, _bodyIndex, _bodySize); } }
41          public long BodyLength { get { return _bodyLength; } }
42          public Buffer Cache { get { return _cache; } }
43          public override string ToString()
44          {
45              StringBuilder sb = new StringBuilder();
46              sb.AppendLine($&quot;Request method: {Method}&quot;);
47              sb.AppendLine($&quot;Request URL: {Url}&quot;);
48              sb.AppendLine($&quot;Request protocol: {Protocol}&quot;);
49              sb.AppendLine($&quot;Request headers: {Headers}&quot;);
50              for (int i = 0; i &lt; Headers; i++)
51              {
52                  var header = Header(i);
53                  sb.AppendLine($&quot;{header.Item1} : {header.Item2}&quot;);
54              }
55              sb.AppendLine($&quot;Request body: {BodyLength}&quot;);
56              sb.AppendLine(Body);
57              return sb.ToString();
58          }
59          public HttpRequest Clear()
60          {
61              IsErrorSet = false;
62              _method = &quot;&quot;;
63              _url = &quot;&quot;;
64              _protocol = &quot;&quot;;
65              _headers.Clear();
66              _cookies.Clear();
67              _bodyIndex = 0;
68              _bodySize = 0;
69              _bodyLength = 0;
70              _bodyLengthProvided = false;
71              _cache.Clear();
72              _cacheSize = 0;
73              return this;
74          }
75          public HttpRequest SetBegin(string method, string url, string protocol = &quot;HTTP/1.1&quot;)
76          {
77              Clear();
78              _cache.Append(method);
79              _method = method;
80              _cache.Append(&quot; &quot;);
81              _cache.Append(url);
82              _url = url;
83              _cache.Append(&quot; &quot;);
84              _cache.Append(protocol);
85              _protocol = protocol;
86              _cache.Append(&quot;\r\n&quot;);
87              return this;
88          }
89          public HttpRequest SetHeader(string key, string value)
90          {
91              _cache.Append(key);
92              _cache.Append(&quot;: &quot;);
93              _cache.Append(value);
94              _cache.Append(&quot;\r\n&quot;);
95              _headers.Add((key, value));
96              return this;
97          }
98          public HttpRequest SetCookie(string name, string value)
99          {
100              string key = &quot;Cookie&quot;;
101              string cookie = name + &quot;=&quot; + value;
102              _cache.Append(key);
103              _cache.Append(&quot;: &quot;);
104              _cache.Append(cookie);
105              _cache.Append(&quot;\r\n&quot;);
106              _headers.Add((key, cookie));
107              _cookies.Add((name, value));
108              return this;
109          }
110          public HttpRequest AddCookie(string name, string value)
111          {
112              _cache.Append(&quot;; &quot;);
113              _cache.Append(name);
114              _cache.Append(&quot;=&quot;);
115              _cache.Append(value);
116              _cookies.Add((name, value));
117              return this;
118          }
119          public HttpRequest SetBody(string body = &quot;&quot;) =&gt; SetBody(body.AsSpan());
120          public HttpRequest SetBody(ReadOnlySpan&lt;char&gt; body)
121          {
122              int length = body.IsEmpty ? 0 : Encoding.UTF8.GetByteCount(body);
123              SetHeader(&quot;Content-Length&quot;, length.ToString());
124              _cache.Append(&quot;\r\n&quot;);
125              int index = (int)_cache.Size;
126              _cache.Append(body);
127              _bodyIndex = index;
128              _bodySize = length;
129              _bodyLength = length;
130              _bodyLengthProvided = true;
131              return this;
132          }
133          public HttpRequest SetBody(byte[] body) =&gt; SetBody(body.AsSpan());
134          public HttpRequest SetBody(ReadOnlySpan&lt;byte&gt; body)
135          {
136              SetHeader(&quot;Content-Length&quot;, body.Length.ToString());
137              _cache.Append(&quot;\r\n&quot;);
138              int index = (int)_cache.Size;
139              _cache.Append(body);
140              _bodyIndex = index;
141              _bodySize = body.Length;
142              _bodyLength = body.Length;
143              _bodyLengthProvided = true;
144              return this;
145          }
146          public HttpRequest SetBodyLength(int length)
147          {
148              SetHeader(&quot;Content-Length&quot;, length.ToString());
149              _cache.Append(&quot;\r\n&quot;);
150              int index = (int)_cache.Size;
151              _bodyIndex = index;
152              _bodySize = 0;
153              _bodyLength = length;
154              _bodyLengthProvided = true;
155              return this;
156          }
157          public HttpRequest MakeHeadRequest(string url)
158          {
159              Clear();
160              SetBegin(&quot;HEAD&quot;, url);
161              SetBody();
162              return this;
163          }
164          public HttpRequest MakeGetRequest(string url)
165          {
166              Clear();
167              SetBegin(&quot;GET&quot;, url);
168              SetBody();
169              return this;
170          }
171          public HttpRequest MakePostRequest(string url, string content, string contentType = &quot;text/plain; charset=UTF-8&quot;) =&gt; MakePostRequest(url, content.AsSpan(), contentType);
172          public HttpRequest MakePostRequest(string url, ReadOnlySpan&lt;char&gt; content, string contentType = &quot;text/plain; charset=UTF-8&quot;)
173          {
174              Clear();
175              SetBegin(&quot;POST&quot;, url);
176              if (!string.IsNullOrEmpty(contentType))
177                  SetHeader(&quot;Content-Type&quot;, contentType);
178              SetBody(content);
179              return this;
180          }
181          public HttpRequest MakePostRequest(string url, byte[] content, string contentType = &quot;&quot;) =&gt; MakePostRequest(url, content.AsSpan(), contentType);
182          public HttpRequest MakePostRequest(string url, ReadOnlySpan&lt;byte&gt; content, string contentType = &quot;&quot;)
183          {
184              Clear();
185              SetBegin(&quot;POST&quot;, url);
186              if (!string.IsNullOrEmpty(contentType))
187                  SetHeader(&quot;Content-Type&quot;, contentType);
188              SetBody(content);
189              return this;
190          }
191          public HttpRequest MakePutRequest(string url, string content, string contentType = &quot;text/plain; charset=UTF-8&quot;) =&gt; MakePutRequest(url, content.AsSpan(), contentType);
192          public HttpRequest MakePutRequest(string url, ReadOnlySpan&lt;char&gt; content, string contentType = &quot;text/plain; charset=UTF-8&quot;)
193          {
194              Clear();
195              SetBegin(&quot;PUT&quot;, url);
196              if (!string.IsNullOrEmpty(contentType))
197                  SetHeader(&quot;Content-Type&quot;, contentType);
198              SetBody(content);
199              return this;
200          }
201          public HttpRequest MakePutRequest(string url, byte[] content, string contentType = &quot;&quot;) =&gt; MakePutRequest(url, content.AsSpan(), contentType);
202          public HttpRequest MakePutRequest(string url, ReadOnlySpan&lt;byte&gt; content, string contentType = &quot;&quot;)
203          {
204              Clear();
205              SetBegin(&quot;PUT&quot;, url);
206              if (!string.IsNullOrEmpty(contentType))
207                  SetHeader(&quot;Content-Type&quot;, contentType);
208              SetBody(content);
209              return this;
210          }
211          public HttpRequest MakeDeleteRequest(string url)
212          {
213              Clear();
214              SetBegin(&quot;DELETE&quot;, url);
215              SetBody();
216              return this;
217          }
218          public HttpRequest MakeOptionsRequest(string url)
219          {
220              Clear();
221              SetBegin(&quot;OPTIONS&quot;, url);
222              SetBody();
223              return this;
224          }
225          public HttpRequest MakeTraceRequest(string url)
226          {
227              Clear();
228              SetBegin(&quot;TRACE&quot;, url);
229              SetBody();
230              return this;
231          }
232          private string _method;
233          private string _url;
234          private string _protocol;
235          private List&lt;(string, string)&gt; _headers = new List&lt;(string, string)&gt;();
236          private List&lt;(string, string)&gt; _cookies = new List&lt;(string, string)&gt;();
237          private int _bodyIndex;
238          private int _bodySize;
239          private int _bodyLength;
240          private bool _bodyLengthProvided;
241          private Buffer _cache = new Buffer();
242          private int _cacheSize;
243          internal bool IsPendingHeader()
244          {
245              return (!IsErrorSet &amp;&amp; (_bodyIndex == 0));
246          }
247          internal bool IsPendingBody()
248          {
249              return (!IsErrorSet &amp;&amp; (_bodyIndex &gt; 0) &amp;&amp; (_bodySize &gt; 0));
250          }
251          internal bool ReceiveHeader(byte[] buffer, int offset, int size)
252          {
253              _cache.Append(buffer, offset, size);
254              for (int i = _cacheSize; i &lt; (int)_cache.Size; i++)
255              {
256                  if ((i + 3) &gt;= (int)_cache.Size)
257                      break;
258                  if ((_cache[i + 0] == &#x27;\r&#x27;) &amp;&amp; (_cache[i + 1] == &#x27;\n&#x27;) &amp;&amp; (_cache[i + 2] == &#x27;\r&#x27;) &amp;&amp; (_cache[i + 3] == &#x27;\n&#x27;))
259                  {
260                      int index = 0;
261                      IsErrorSet = true;
262                      int methodIndex = index;
263                      int methodSize = 0;
264                      while (_cache[index] != &#x27; &#x27;)
265                      {
266                          methodSize++;
267                          index++;
268                          if (index &gt;= (int)_cache.Size)
269                              return false;
270                      }
271                      index++;
272                      if (index &gt;= (int)_cache.Size)
273                          return false;
274                      _method = _cache.ExtractString(methodIndex, methodSize);
275                      int urlIndex = index;
276                      int urlSize = 0;
277                      while (_cache[index] != &#x27; &#x27;)
278                      {
279                          urlSize++;
280                          index++;
281                          if (index &gt;= (int)_cache.Size)
282                              return false;
283                      }
284                      index++;
285                      if (index &gt;= (int)_cache.Size)
286                          return false;
287                      _url = _cache.ExtractString(urlIndex, urlSize);
288                      int protocolIndex = index;
289                      int protocolSize = 0;
290                      while (_cache[index] != &#x27;\r&#x27;)
291                      {
292                          protocolSize++;
293                          index++;
294                          if (index &gt;= (int)_cache.Size)
295                              return false;
296                      }
297                      index++;
298                      if ((index &gt;= (int)_cache.Size) || (_cache[index] != &#x27;\n&#x27;))
299                          return false;
300                      index++;
301                      if (index &gt;= (int)_cache.Size)
302                          return false;
303                      _protocol = _cache.ExtractString(protocolIndex, protocolSize);
304                      while ((index &lt; (int)_cache.Size) &amp;&amp; (index &lt; i))
305                      {
306                          int headerNameIndex = index;
307                          int headerNameSize = 0;
308                          while (_cache[index] != &#x27;:&#x27;)
309                          {
310                              headerNameSize++;
311                              index++;
312                              if (index &gt;= i)
313                                  break;
314                              if (index &gt;= (int)_cache.Size)
315                                  return false;
316                          }
317                          index++;
318                          if (index &gt;= i)
319                              break;
320                          if (index &gt;= (int)_cache.Size)
321                              return false;
322                          while (char.IsWhiteSpace((char)_cache[index]))
323                          {
324                              index++;
325                              if (index &gt;= i)
326                                  break;
327                              if (index &gt;= (int)_cache.Size)
328                                  return false;
329                          }
330                          int headerValueIndex = index;
331                          int headerValueSize = 0;
332                          while (_cache[index] != &#x27;\r&#x27;)
333                          {
334                              headerValueSize++;
335                              index++;
336                              if (index &gt;= i)
337                                  break;
338                              if (index &gt;= (int)_cache.Size)
339                                  return false;
340                          }
341                          index++;
342                          if ((index &gt;= (int)_cache.Size) || (_cache[index] != &#x27;\n&#x27;))
343                              return false;
344                          index++;
345                          if (index &gt;= (int)_cache.Size)
346                              return false;
347                          if (headerNameSize == 0)
<span onclick='openModal()' class='match'>348                              return false;
349                          string headerName = _cache.ExtractString(headerNameIndex, headerNameSize);
350                          string headerValue = _cache.ExtractString(headerValueIndex, headerValueSize);
351                          _headers.Add((headerName, headerValue));
352                          if (string.Compare(headerName, &quot;Content-Length&quot;, StringComparison.OrdinalIgnoreCase) == 0)
353                          {
354                              _bodyLength = 0;
355                              for (int j = headerValueIndex; j &lt; (headerValueIndex + headerValueSize); j++)
356                              {
357                                  if ((_cache[j] &lt; &#x27;0&#x27;) || (_cache[j] &gt; &#x27;9&#x27;))
358                                      return false;
359                                  _bodyLength *= 10;
360                                  _bodyLength += _cache[j] - &#x27;0&#x27;;
361                                  _bodyLengthProvided = true;
362                              }
363                          }
364                          if (string.Compare(headerName, &quot;Cookie&quot;, StringComparison.OrdinalIgnoreCase) == 0)
</span>365                          {
366                              bool name = true;
367                              bool token = false;
368                              int current = headerValueIndex;
369                              int nameIndex = index;
370                              int nameSize = 0;
371                              int cookieIndex = index;
372                              int cookieSize = 0;
373                              for (int j = headerValueIndex; j &lt; (headerValueIndex + headerValueSize); j++)
374                              {
375                                  if (_cache[j] == &#x27; &#x27;)
376                                  {
377                                      if (token)
378                                      {
379                                          if (name)
380                                          {
381                                              nameIndex = current;
382                                              nameSize = j - current;
383                                          }
384                                          else
385                                          {
386                                              cookieIndex = current;
387                                              cookieSize = j - current;
388                                          }
389                                      }
390                                      token = false;
391                                      continue;
392                                  }
393                                  if (_cache[j] == &#x27;=&#x27;)
394                                  {
395                                      if (token)
396                                      {
397                                          if (name)
398                                          {
399                                              nameIndex = current;
400                                              nameSize = j - current;
401                                          }
402                                          else
403                                          {
404                                              cookieIndex = current;
405                                              cookieSize = j - current;
406                                          }
407                                      }
408                                      token = false;
409                                      name = false;
410                                      continue;
411                                  }
412                                  if (_cache[j] == &#x27;;&#x27;)
413                                  {
414                                      if (token)
415                                      {
416                                          if (name)
417                                          {
418                                              nameIndex = current;
419                                              nameSize = j - current;
420                                          }
421                                          else
422                                          {
423                                              cookieIndex = current;
424                                              cookieSize = j - current;
425                                          }
426                                          if ((nameSize &gt; 0) &amp;&amp; (cookieSize &gt; 0))
427                                          {
428                                              _cookies.Add((_cache.ExtractString(nameIndex, nameSize), _cache.ExtractString(cookieIndex, cookieSize)));
429                                              nameIndex = j;
430                                              nameSize = 0;
431                                              cookieIndex = j;
432                                              cookieSize = 0;
433                                          }
434                                      }
435                                      token = false;
436                                      name = true;
437                                      continue;
438                                  }
439                                  if (!token)
440                                  {
441                                      current = j;
442                                      token = true;
443                                  }
444                              }
445                              if (token)
446                              {
447                                  if (name)
448                                  {
449                                      nameIndex = current;
450                                      nameSize = headerValueIndex + headerValueSize - current;
451                                  }
452                                  else
453                                  {
454                                      cookieIndex = current;
455                                      cookieSize = headerValueIndex + headerValueSize - current;
456                                  }
457                                  if ((nameSize &gt; 0) &amp;&amp; (cookieSize &gt; 0))
458                                  {
459                                      _cookies.Add((_cache.ExtractString(nameIndex, nameSize), _cache.ExtractString(cookieIndex, cookieSize)));
460                                  }
461                              }
462                          }
463                      }
464                      IsErrorSet = false;
465                      _bodyIndex = i + 4;
466                      _bodySize = (int)_cache.Size - i - 4;
467                      _cacheSize = (int)_cache.Size;
468                      return true;
469                  }
470              }
471              _cacheSize = ((int)_cache.Size &gt;= 3) ? ((int)_cache.Size - 3) : 0;
472              return false;
473          }
474          internal bool ReceiveBody(byte[] buffer, int offset, int size)
475          {
476              _cache.Append(buffer, offset, size);
477              _cacheSize = (int)_cache.Size;
478              _bodySize += size;
479              if (_bodyLengthProvided)
480              {
481                  if (_bodySize &gt;= _bodyLength)
482                  {
483                      _bodySize = _bodyLength;
484                      return true;
485                  }
486              }
487              else
488              {
489                  if ((Method == &quot;HEAD&quot;) || (Method == &quot;GET&quot;) || (Method == &quot;DELETE&quot;) || (Method == &quot;OPTIONS&quot;) || (Method == &quot;TRACE&quot;))
490                  {
491                      _bodyLength = 0;
492                      _bodySize = 0;
493                      return true;
494                  }
495                  if (_bodySize &gt;= 4)
496                  {
497                      int index = _bodyIndex + _bodySize - 4;
498                      if ((_cache[index + 0] == &#x27;\r&#x27;) &amp;&amp; (_cache[index + 1] == &#x27;\n&#x27;) &amp;&amp; (_cache[index + 2] == &#x27;\r&#x27;) &amp;&amp; (_cache[index + 3] == &#x27;\n&#x27;))
499                      {
500                          _bodyLength = _bodySize;
501                          return true;
502                      }
503                  }
504              }
505              return false;
506          }
507      }
508  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpResponse.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Text;
5  namespace NetCoreServer
6  {
7      public class HttpResponse
8      {
9          static HttpResponse()
10          {
11              _mimeTable = new Dictionary&lt;string, string&gt;
12              {
13                  { &quot;.html&quot;,      &quot;text/html&quot; },
14                  { &quot;.css&quot;,       &quot;text/css&quot; },
15                  { &quot;.js&quot;,        &quot;text/javascript&quot; },
16                  { &quot;.vue&quot;,       &quot;text/html&quot; },
17                  { &quot;.xml&quot;,       &quot;text/xml&quot; },
18                  { &quot;.atom&quot;,      &quot;application/atom+xml&quot; },
19                  { &quot;.fastsoap&quot;,  &quot;application/fastsoap&quot; },
20                  { &quot;.gzip&quot;,      &quot;application/gzip&quot; },
21                  { &quot;.json&quot;,      &quot;application/json&quot; },
22                  { &quot;.map&quot;,       &quot;application/json&quot; },
23                  { &quot;.pdf&quot;,       &quot;application/pdf&quot; },
24                  { &quot;.ps&quot;,        &quot;application/postscript&quot; },
25                  { &quot;.soap&quot;,      &quot;application/soap+xml&quot; },
26                  { &quot;.sql&quot;,       &quot;application/sql&quot; },
27                  { &quot;.xslt&quot;,      &quot;application/xslt+xml&quot; },
28                  { &quot;.zip&quot;,       &quot;application/zip&quot; },
29                  { &quot;.zlib&quot;,      &quot;application/zlib&quot; },
30                  { &quot;.aac&quot;,       &quot;audio/aac&quot; },
31                  { &quot;.ac3&quot;,       &quot;audio/ac3&quot; },
32                  { &quot;.mp3&quot;,       &quot;audio/mpeg&quot; },
33                  { &quot;.ogg&quot;,       &quot;audio/ogg&quot; },
34                  { &quot;.ttf&quot;,       &quot;font/ttf&quot; },
35                  { &quot;.bmp&quot;,       &quot;image/bmp&quot; },
36                  { &quot;.emf&quot;,       &quot;image/emf&quot; },
37                  { &quot;.gif&quot;,       &quot;image/gif&quot; },
38                  { &quot;.jpg&quot;,       &quot;image/jpeg&quot; },
39                  { &quot;.jpm&quot;,       &quot;image/jpm&quot; },
40                  { &quot;.jpx&quot;,       &quot;image/jpx&quot; },
41                  { &quot;.jrx&quot;,       &quot;image/jrx&quot; },
42                  { &quot;.png&quot;,       &quot;image/png&quot; },
43                  { &quot;.svg&quot;,       &quot;image/svg+xml&quot; },
44                  { &quot;.tiff&quot;,      &quot;image/tiff&quot; },
45                  { &quot;.wmf&quot;,       &quot;image/wmf&quot; },
46                  { &quot;.http&quot;,      &quot;message/http&quot; },
47                  { &quot;.s-http&quot;,    &quot;message/s-http&quot; },
48                  { &quot;.mesh&quot;,      &quot;model/mesh&quot; },
49                  { &quot;.vrml&quot;,      &quot;model/vrml&quot; },
50                  { &quot;.csv&quot;,       &quot;text/csv&quot; },
51                  { &quot;.plain&quot;,     &quot;text/plain&quot; },
52                  { &quot;.richtext&quot;,  &quot;text/richtext&quot; },
53                  { &quot;.rtf&quot;,       &quot;text/rtf&quot; },
54                  { &quot;.rtx&quot;,       &quot;text/rtx&quot; },
55                  { &quot;.sgml&quot;,      &quot;text/sgml&quot; },
56                  { &quot;.strings&quot;,   &quot;text/strings&quot; },
57                  { &quot;.url&quot;,       &quot;text/uri-list&quot; },
58                  { &quot;.H264&quot;,      &quot;video/H264&quot; },
59                  { &quot;.H265&quot;,      &quot;video/H265&quot; },
60                  { &quot;.mp4&quot;,       &quot;video/mp4&quot; },
61                  { &quot;.mpeg&quot;,      &quot;video/mpeg&quot; },
62                  { &quot;.raw&quot;,       &quot;video/raw&quot; }
63              };
64          }
65          public HttpResponse()
66          {
67              Clear();
68          }
69          public HttpResponse(int status, string protocol = &quot;HTTP/1.1&quot;)
70          {
71              SetBegin(status, protocol);
72          }
73          public HttpResponse(int status, string statusPhrase, string protocol)
74          {
75              SetBegin(status, statusPhrase, protocol);
76          }
77          public bool IsEmpty { get { return (_cache.Size &gt; 0); } }
78          public bool IsErrorSet { get; private set; }
79          public int Status { get; private set; }
80          public string StatusPhrase { get { return _statusPhrase; } }
81          public string Protocol { get { return _protocol; } }
82          public long Headers { get { return _headers.Count; } }
83          public (string, string) Header(int i)
84          {
85              Debug.Assert((i &lt; _headers.Count), &quot;Index out of bounds!&quot;);
86              if (i &gt;= _headers.Count)
87                  return (&quot;&quot;, &quot;&quot;);
88              return _headers[i];
89          }
90          public string Body { get { return _cache.ExtractString(_bodyIndex, _bodySize); } }
91          public byte[] BodyBytes { get { return _cache.Data[_bodyIndex..(_bodyIndex + _bodySize)]; } }
92          public ReadOnlySpan&lt;byte&gt; BodySpan { get { return new ReadOnlySpan&lt;byte&gt;(_cache.Data, _bodyIndex, _bodySize); } }
93          public long BodyLength { get { return _bodyLength; } }
94          public Buffer Cache { get { return _cache; } }
95          public override string ToString()
96          {
97              StringBuilder sb = new StringBuilder();
98              sb.AppendLine($&quot;Status: {Status}&quot;);
99              sb.AppendLine($&quot;Status phrase: {StatusPhrase}&quot;);
100              sb.AppendLine($&quot;Protocol: {Protocol}&quot;);
101              sb.AppendLine($&quot;Headers: {Headers}&quot;);
102              for (int i = 0; i &lt; Headers; i++)
103              {
104                  var header = Header(i);
105                  sb.AppendLine($&quot;{header.Item1} : {header.Item2}&quot;);
106              }
107              sb.AppendLine($&quot;Body: {BodyLength}&quot;);
108              sb.AppendLine(Body);
109              return sb.ToString();
110          }
111          public HttpResponse Clear()
112          {
113              IsErrorSet = false;
114              Status = 0;
115              _statusPhrase = &quot;&quot;;
116              _protocol = &quot;&quot;;
117              _headers.Clear();
118              _bodyIndex = 0;
119              _bodySize = 0;
120              _bodyLength = 0;
121              _bodyLengthProvided = false;
122              _cache.Clear();
123              _cacheSize = 0;
124              return this;
125          }
126          public HttpResponse SetBegin(int status, string protocol = &quot;HTTP/1.1&quot;)
127          {
128              string statusPhrase;
129              switch (status)
130              {
131                  case 100: statusPhrase = &quot;Continue&quot;; break;
132                  case 101: statusPhrase = &quot;Switching Protocols&quot;; break;
133                  case 102: statusPhrase = &quot;Processing&quot;; break;
134                  case 103: statusPhrase = &quot;Early Hints&quot;; break;
135                  case 200: statusPhrase = &quot;OK&quot;; break;
136                  case 201: statusPhrase = &quot;Created&quot;; break;
137                  case 202: statusPhrase = &quot;Accepted&quot;; break;
138                  case 203: statusPhrase = &quot;Non-Authoritative Information&quot;; break;
139                  case 204: statusPhrase = &quot;No Content&quot;; break;
140                  case 205: statusPhrase = &quot;Reset Content&quot;; break;
141                  case 206: statusPhrase = &quot;Partial Content&quot;; break;
142                  case 207: statusPhrase = &quot;Multi-Status&quot;; break;
143                  case 208: statusPhrase = &quot;Already Reported&quot;; break;
144                  case 226: statusPhrase = &quot;IM Used&quot;; break;
145                  case 300: statusPhrase = &quot;Multiple Choices&quot;; break;
146                  case 301: statusPhrase = &quot;Moved Permanently&quot;; break;
147                  case 302: statusPhrase = &quot;Found&quot;; break;
148                  case 303: statusPhrase = &quot;See Other&quot;; break;
149                  case 304: statusPhrase = &quot;Not Modified&quot;; break;
150                  case 305: statusPhrase = &quot;Use Proxy&quot;; break;
151                  case 306: statusPhrase = &quot;Switch Proxy&quot;; break;
152                  case 307: statusPhrase = &quot;Temporary Redirect&quot;; break;
153                  case 308: statusPhrase = &quot;Permanent Redirect&quot;; break;
154                  case 400: statusPhrase = &quot;Bad Request&quot;; break;
155                  case 401: statusPhrase = &quot;Unauthorized&quot;; break;
156                  case 402: statusPhrase = &quot;Payment Required&quot;; break;
157                  case 403: statusPhrase = &quot;Forbidden&quot;; break;
158                  case 404: statusPhrase = &quot;Not Found&quot;; break;
159                  case 405: statusPhrase = &quot;Method Not Allowed&quot;; break;
160                  case 406: statusPhrase = &quot;Not Acceptable&quot;; break;
161                  case 407: statusPhrase = &quot;Proxy Authentication Required&quot;; break;
162                  case 408: statusPhrase = &quot;Request Timeout&quot;; break;
163                  case 409: statusPhrase = &quot;Conflict&quot;; break;
164                  case 410: statusPhrase = &quot;Gone&quot;; break;
165                  case 411: statusPhrase = &quot;Length Required&quot;; break;
166                  case 412: statusPhrase = &quot;Precondition Failed&quot;; break;
167                  case 413: statusPhrase = &quot;Payload Too Large&quot;; break;
168                  case 414: statusPhrase = &quot;URI Too Long&quot;; break;
169                  case 415: statusPhrase = &quot;Unsupported Media Type&quot;; break;
170                  case 416: statusPhrase = &quot;Range Not Satisfiable&quot;; break;
171                  case 417: statusPhrase = &quot;Expectation Failed&quot;; break;
172                  case 421: statusPhrase = &quot;Misdirected Request&quot;; break;
173                  case 422: statusPhrase = &quot;Unprocessable Entity&quot;; break;
174                  case 423: statusPhrase = &quot;Locked&quot;; break;
175                  case 424: statusPhrase = &quot;Failed Dependency&quot;; break;
176                  case 425: statusPhrase = &quot;Too Early&quot;; break;
177                  case 426: statusPhrase = &quot;Upgrade Required&quot;; break;
178                  case 427: statusPhrase = &quot;Unassigned&quot;; break;
179                  case 428: statusPhrase = &quot;Precondition Required&quot;; break;
180                  case 429: statusPhrase = &quot;Too Many Requests&quot;; break;
181                  case 431: statusPhrase = &quot;Request Header Fields Too Large&quot;; break;
182                  case 451: statusPhrase = &quot;Unavailable For Legal Reasons&quot;; break;
183                  case 500: statusPhrase = &quot;Internal Server Error&quot;; break;
184                  case 501: statusPhrase = &quot;Not Implemented&quot;; break;
185                  case 502: statusPhrase = &quot;Bad Gateway&quot;; break;
186                  case 503: statusPhrase = &quot;Service Unavailable&quot;; break;
187                  case 504: statusPhrase = &quot;Gateway Timeout&quot;; break;
188                  case 505: statusPhrase = &quot;HTTP Version Not Supported&quot;; break;
189                  case 506: statusPhrase = &quot;Variant Also Negotiates&quot;; break;
190                  case 507: statusPhrase = &quot;Insufficient Storage&quot;; break;
191                  case 508: statusPhrase = &quot;Loop Detected&quot;; break;
192                  case 510: statusPhrase = &quot;Not Extended&quot;; break;
193                  case 511: statusPhrase = &quot;Network Authentication Required&quot;; break;
194                  default: statusPhrase = &quot;Unknown&quot;; break;
195              }
196              SetBegin(status, statusPhrase, protocol);
197              return this;
198          }
199          public HttpResponse SetBegin(int status, string statusPhrase, string protocol)
200          {
201              Clear();
202              _cache.Append(protocol);
203              _protocol = protocol;
204              _cache.Append(&quot; &quot;);
205              _cache.Append(status.ToString());
206              Status = status;
207              _cache.Append(&quot; &quot;);
208              _cache.Append(statusPhrase);
209              _statusPhrase = statusPhrase;
210              _cache.Append(&quot;\r\n&quot;);
211              return this;
212          }
213          public HttpResponse SetContentType(string extension)
214          {
215              if (_mimeTable.TryGetValue(extension, out string mime))
216                  return SetHeader(&quot;Content-Type&quot;, mime);
217              return this;
218          }
219          public HttpResponse SetHeader(string key, string value)
220          {
221              _cache.Append(key);
222              _cache.Append(&quot;: &quot;);
223              _cache.Append(value);
224              _cache.Append(&quot;\r\n&quot;);
225              _headers.Add((key, value));
226              return this;
227          }
228          public HttpResponse SetCookie(string name, string value, int maxAge = 86400, string path = &quot;&quot;, string domain = &quot;&quot;, bool secure = true, bool strict = true, bool httpOnly = true)
229          {
230              string key = &quot;Set-Cookie&quot;;
231              _cache.Append(key);
232              _cache.Append(&quot;: &quot;);
233              int valueIndex = (int)_cache.Size;
234              _cache.Append(name);
235              _cache.Append(&quot;=&quot;);
236              _cache.Append(value);
237              _cache.Append(&quot;; Max-Age=&quot;);
238              _cache.Append(maxAge.ToString());
239              if (!string.IsNullOrEmpty(domain))
240              {
241                  _cache.Append(&quot;; Domain=&quot;);
242                  _cache.Append(domain);
243              }
244              if (!string.IsNullOrEmpty(path))
245              {
246                  _cache.Append(&quot;; Path=&quot;);
247                  _cache.Append(path);
248              }
249              if (secure)
250                  _cache.Append(&quot;; Secure&quot;);
251              if (strict)
252                  _cache.Append(&quot;; SameSite=Strict&quot;);
253              if (httpOnly)
254                  _cache.Append(&quot;; HttpOnly&quot;);
255              int valueSize = (int)_cache.Size - valueIndex;
256              string cookie = _cache.ExtractString(valueIndex, valueSize);
257              _cache.Append(&quot;\r\n&quot;);
258              _headers.Add((key, cookie));
259              return this;
260          }
261          public HttpResponse SetBody(string body = &quot;&quot;) =&gt; SetBody(body.AsSpan());
262          public HttpResponse SetBody(ReadOnlySpan&lt;char&gt; body)
263          {
264              int length = body.IsEmpty ? 0 : Encoding.UTF8.GetByteCount(body);
265              SetHeader(&quot;Content-Length&quot;, length.ToString());
266              _cache.Append(&quot;\r\n&quot;);
267              int index = (int)_cache.Size;
268              _cache.Append(body);
269              _bodyIndex = index;
270              _bodySize = length;
271              _bodyLength = length;
272              _bodyLengthProvided = true;
273              return this;
274          }
275          public HttpResponse SetBody(byte[] body) =&gt; SetBody(body.AsSpan());
276          public HttpResponse SetBody(ReadOnlySpan&lt;byte&gt; body)
277          {
278              SetHeader(&quot;Content-Length&quot;, body.Length.ToString());
279              _cache.Append(&quot;\r\n&quot;);
280              int index = (int)_cache.Size;
281              _cache.Append(body);
282              _bodyIndex = index;
283              _bodySize = body.Length;
284              _bodyLength = body.Length;
285              _bodyLengthProvided = true;
286              return this;
287          }
288          public HttpResponse SetBodyLength(int length)
289          {
290              SetHeader(&quot;Content-Length&quot;, length.ToString());
291              _cache.Append(&quot;\r\n&quot;);
292              int index = (int)_cache.Size;
293              _bodyIndex = index;
294              _bodySize = 0;
295              _bodyLength = length;
296              _bodyLengthProvided = true;
297              return this;
298          }
299          public HttpResponse MakeOkResponse(int status = 200)
300          {
301              Clear();
302              SetBegin(status);
303              SetBody();
304              return this;
305          }
306          public HttpResponse MakeErrorResponse(string content = &quot;&quot;, string contentType = &quot;text/plain; charset=UTF-8&quot;)
307          {
308              return MakeErrorResponse(500, content, contentType);
309          }
310          public HttpResponse MakeErrorResponse(int status, string content = &quot;&quot;, string contentType = &quot;text/plain; charset=UTF-8&quot;)
311          {
312              Clear();
313              SetBegin(status);
314              if (!string.IsNullOrEmpty(contentType))
315                  SetHeader(&quot;Content-Type&quot;, contentType);
316              SetBody(content);
317              return this;
318          }
319          public HttpResponse MakeHeadResponse()
320          {
321              Clear();
322              SetBegin(200);
323              SetBody();
324              return this;
325          }
326          public HttpResponse MakeGetResponse(string content = &quot;&quot;, string contentType = &quot;text/plain; charset=UTF-8&quot;) =&gt; MakeGetResponse(content.AsSpan(), contentType);
327          public HttpResponse MakeGetResponse(ReadOnlySpan&lt;char&gt; content, string contentType = &quot;text/plain; charset=UTF-8&quot;)
328          {
329              Clear();
330              SetBegin(200);
331              if (!string.IsNullOrEmpty(contentType))
332                  SetHeader(&quot;Content-Type&quot;, contentType);
333              SetBody(content);
334              return this;
335          }
336          public HttpResponse MakeGetResponse(byte[] content, string contentType = &quot;&quot;) =&gt; MakeGetResponse(content.AsSpan(), contentType);
337          public HttpResponse MakeGetResponse(ReadOnlySpan&lt;byte&gt; content, string contentType = &quot;&quot;)
338          {
339              Clear();
340              SetBegin(200);
341              if (!string.IsNullOrEmpty(contentType))
342                  SetHeader(&quot;Content-Type&quot;, contentType);
343              SetBody(content);
344              return this;
345          }
346          public HttpResponse MakeOptionsResponse(string allow = &quot;HEAD,GET,POST,PUT,DELETE,OPTIONS,TRACE&quot;)
347          {
348              Clear();
349              SetBegin(200);
350              SetHeader(&quot;Allow&quot;, allow);
351              SetBody();
352              return this;
353          }
354          public HttpResponse MakeTraceResponse(string content) =&gt; MakeTraceResponse(content.AsSpan());
355          public HttpResponse MakeTraceResponse(ReadOnlySpan&lt;char&gt; content)
356          {
357              Clear();
358              SetBegin(200);
359              SetHeader(&quot;Content-Type&quot;, &quot;message/http&quot;);
360              SetBody(content);
361              return this;
362          }
363          public HttpResponse MakeTraceResponse(byte[] content) =&gt; MakeTraceResponse(content.AsSpan());
364          public HttpResponse MakeTraceResponse(ReadOnlySpan&lt;byte&gt; content)
365          {
366              Clear();
367              SetBegin(200);
368              SetHeader(&quot;Content-Type&quot;, &quot;message/http&quot;);
369              SetBody(content);
370              return this;
371          }
372          public HttpResponse MakeTraceResponse(HttpRequest request) =&gt; MakeTraceResponse(request.Cache.AsSpan());
373          private string _statusPhrase;
374          private string _protocol;
375          private List&lt;(string, string)&gt; _headers = new List&lt;(string, string)&gt;();
376          private int _bodyIndex;
377          private int _bodySize;
378          private int _bodyLength;
379          private bool _bodyLengthProvided;
380          private Buffer _cache = new Buffer();
381          private int _cacheSize;
382          private static readonly Dictionary&lt;string, string&gt; _mimeTable;
383          internal bool IsPendingHeader()
384          {
385              return (!IsErrorSet &amp;&amp; (_bodyIndex == 0));
386          }
387          internal bool IsPendingBody()
388          {
389              return (!IsErrorSet &amp;&amp; (_bodyIndex &gt; 0) &amp;&amp; (_bodySize &gt; 0));
390          }
391          internal bool ReceiveHeader(byte[] buffer, int offset, int size)
392          {
393              _cache.Append(buffer, offset, size);
394              for (int i = _cacheSize; i &lt; (int)_cache.Size; i++)
395              {
396                  if ((i + 3) &gt;= (int)_cache.Size)
397                      break;
398                  if ((_cache[i + 0] == &#x27;\r&#x27;) &amp;&amp; (_cache[i + 1] == &#x27;\n&#x27;) &amp;&amp; (_cache[i + 2] == &#x27;\r&#x27;) &amp;&amp; (_cache[i + 3] == &#x27;\n&#x27;))
399                  {
400                      int index = 0;
401                      IsErrorSet = true;
402                      int protocolIndex = index;
403                      int protocolSize = 0;
404                      while (_cache[index] != &#x27; &#x27;)
405                      {
406                          protocolSize++;
407                          index++;
408                          if (index &gt;= (int)_cache.Size)
409                              return false;
410                      }
411                      index++;
412                      if ((index &gt;= (int)_cache.Size))
413                          return false;
414                      _protocol = _cache.ExtractString(protocolIndex, protocolSize);
415                      int statusIndex = index;
416                      int statusSize = 0;
417                      while (_cache[index] != &#x27; &#x27;)
418                      {
419                          if ((_cache[index] &lt; &#x27;0&#x27;) || (_cache[index] &gt; &#x27;9&#x27;))
420                              return false;
421                          statusSize++;
422                          index++;
423                          if (index &gt;= (int)_cache.Size)
424                              return false;
425                      }
426                      Status = 0;
427                      for (int j = statusIndex; j &lt; (statusIndex + statusSize); j++)
428                      {
429                          Status *= 10;
430                          Status += _cache[j] - &#x27;0&#x27;;
431                      }
432                      index++;
433                      if (index &gt;= (int)_cache.Size)
434                          return false;
435                      int statusPhraseIndex = index;
436                      int statusPhraseSize = 0;
437                      while (_cache[index] != &#x27;\r&#x27;)
438                      {
439                          statusPhraseSize++;
440                          index++;
441                          if (index &gt;= (int)_cache.Size)
442                              return false;
443                      }
444                      index++;
445                      if ((index &gt;= (int)_cache.Size) || (_cache[index] != &#x27;\n&#x27;))
446                          return false;
447                      index++;
448                      if (index &gt;= (int)_cache.Size)
449                          return false;
450                      _statusPhrase = _cache.ExtractString(statusPhraseIndex, statusPhraseSize);
451                      while ((index &lt; (int)_cache.Size) &amp;&amp; (index &lt; i))
452                      {
453                          int headerNameIndex = index;
454                          int headerNameSize = 0;
455                          while (_cache[index] != &#x27;:&#x27;)
456                          {
457                              headerNameSize++;
458                              index++;
459                              if (index &gt;= i)
460                                  break;
461                              if (index &gt;= (int)_cache.Size)
462                                  return false;
463                          }
464                          index++;
465                          if (index &gt;= i)
466                              break;
467                          if (index &gt;= (int)_cache.Size)
468                              return false;
469                          while (char.IsWhiteSpace((char)_cache[index]))
470                          {
471                              index++;
472                              if (index &gt;= i)
473                                  break;
474                              if (index &gt;= (int)_cache.Size)
475                                  return false;
476                          }
477                          int headerValueIndex = index;
478                          int headerValueSize = 0;
479                          while (_cache[index] != &#x27;\r&#x27;)
480                          {
481                              headerValueSize++;
482                              index++;
483                              if (index &gt;= i)
484                                  break;
485                              if (index &gt;= (int)_cache.Size)
486                                  return false;
487                          }
488                          index++;
489                          if ((index &gt;= (int)_cache.Size) || (_cache[index] != &#x27;\n&#x27;))
490                              return false;
491                          index++;
492                          if (index &gt;= (int)_cache.Size)
493                              return false;
494                          if (headerNameSize == 0)
<span onclick='openModal()' class='match'>495                              return false;
496                          string headerName = _cache.ExtractString(headerNameIndex, headerNameSize);
497                          string headerValue = _cache.ExtractString(headerValueIndex, headerValueSize);
498                          _headers.Add((headerName, headerValue));
499                          if (string.Compare(headerName, &quot;Content-Length&quot;, StringComparison.OrdinalIgnoreCase) == 0)
500                          {
501                              _bodyLength = 0;
502                              for (int j = headerValueIndex; j &lt; (headerValueIndex + headerValueSize); j++)
503                              {
504                                  if ((_cache[j] &lt; &#x27;0&#x27;) || (_cache[j] &gt; &#x27;9&#x27;))
505                                      return false;
506                                  _bodyLength *= 10;
507                                  _bodyLength += _cache[j] - &#x27;0&#x27;;
508                                  _bodyLengthProvided = true;
509                              }
510                          }
511                      }
</span>512                      IsErrorSet = false;
513                      _bodyIndex = i + 4;
514                      _bodySize = (int)_cache.Size - i - 4;
515                      _cacheSize = (int)_cache.Size;
516                      return true;
517                  }
518              }
519              _cacheSize = ((int)_cache.Size &gt;= 3) ? ((int)_cache.Size - 3) : 0;
520              return false;
521          }
522          internal bool ReceiveBody(byte[] buffer, int offset, int size)
523          {
524              _cache.Append(buffer, offset, size);
525              _cacheSize = (int)_cache.Size;
526              _bodySize += size;
527              if (_bodyLengthProvided)
528              {
529                  if (_bodySize &gt;= _bodyLength)
530                  {
531                      _bodySize = _bodyLength;
532                      return true;
533                  }
534              }
535              else
536              {
537                  if (_bodySize &gt;= 4)
538                  {
539                      int index = _bodyIndex + _bodySize - 4;
540                      if ((_cache[index + 0] == &#x27;\r&#x27;) &amp;&amp; (_cache[index + 1] == &#x27;\n&#x27;) &amp;&amp; (_cache[index + 2] == &#x27;\r&#x27;) &amp;&amp;
541                          (_cache[index + 3] == &#x27;\n&#x27;))
542                      {
543                          _bodyLength = _bodySize;
544                          return true;
545                      }
546                  }
547              }
548              return false;
549          }
550      }
551  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpRequest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpResponse.cs</div>
                </div>
                <div class="column column_space"><pre><code>348                              return false;
349                          string headerName = _cache.ExtractString(headerNameIndex, headerNameSize);
350                          string headerValue = _cache.ExtractString(headerValueIndex, headerValueSize);
351                          _headers.Add((headerName, headerValue));
352                          if (string.Compare(headerName, &quot;Content-Length&quot;, StringComparison.OrdinalIgnoreCase) == 0)
353                          {
354                              _bodyLength = 0;
355                              for (int j = headerValueIndex; j &lt; (headerValueIndex + headerValueSize); j++)
356                              {
357                                  if ((_cache[j] &lt; &#x27;0&#x27;) || (_cache[j] &gt; &#x27;9&#x27;))
358                                      return false;
359                                  _bodyLength *= 10;
360                                  _bodyLength += _cache[j] - &#x27;0&#x27;;
361                                  _bodyLengthProvided = true;
362                              }
363                          }
364                          if (string.Compare(headerName, &quot;Cookie&quot;, StringComparison.OrdinalIgnoreCase) == 0)
</pre></code></div>
                <div class="column column_space"><pre><code>495                              return false;
496                          string headerName = _cache.ExtractString(headerNameIndex, headerNameSize);
497                          string headerValue = _cache.ExtractString(headerValueIndex, headerValueSize);
498                          _headers.Add((headerName, headerValue));
499                          if (string.Compare(headerName, &quot;Content-Length&quot;, StringComparison.OrdinalIgnoreCase) == 0)
500                          {
501                              _bodyLength = 0;
502                              for (int j = headerValueIndex; j &lt; (headerValueIndex + headerValueSize); j++)
503                              {
504                                  if ((_cache[j] &lt; &#x27;0&#x27;) || (_cache[j] &gt; &#x27;9&#x27;))
505                                      return false;
506                                  _bodyLength *= 10;
507                                  _bodyLength += _cache[j] - &#x27;0&#x27;;
508                                  _bodyLengthProvided = true;
509                              }
510                          }
511                      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    