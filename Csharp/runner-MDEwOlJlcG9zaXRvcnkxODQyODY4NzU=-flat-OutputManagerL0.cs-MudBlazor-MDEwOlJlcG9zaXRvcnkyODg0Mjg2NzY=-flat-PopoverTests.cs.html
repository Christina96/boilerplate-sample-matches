
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 26.533166458072593%, Tokens: 20</h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-OutputManagerL0.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Runtime.CompilerServices;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.Actions.RunService.WebApi;
9  using GitHub.Runner.Sdk;
10  using GitHub.Runner.Worker;
11  using GitHub.Runner.Worker.Container;
12  using GitHub.Runner.Worker.Handlers;
13  using Moq;
14  using Xunit;
15  using DTWebApi = GitHub.DistributedTask.WebApi;
16  namespace GitHub.Runner.Common.Tests.Worker
17  {
18      public sealed class OutputManagerL0
19      {
20          private Mock<IExecutionContext> _executionContext;
21          private Mock<IActionCommandManager> _commandManager;
22          private Variables _variables;
23          private OnMatcherChanged _onMatcherChanged;
24          private List<Tuple<DTWebApi.Issue, string>> _issues;
25          private List<string> _messages;
26          private List<string> _commands;
27          private OutputManager _outputManager;
28          [Fact]
29          [Trait("Level", "L0")]
30          [Trait("Category", "Worker")]
31          public void AddMatcher_Clobber()
32          {
33              var matchers = new IssueMatchersConfig
34              {
35                  Matchers =
36                  {
37                      new IssueMatcherConfig
38                      {
39                          Owner = "my-matcher-1",
40                          Patterns = new[]
41                          {
42                              new IssuePatternConfig
43                              {
44                                  Pattern = "ERROR: (.+)",
45                                  Message = 1,
46                              },
47                          },
48                      },
49                      new IssueMatcherConfig
50                      {
51                          Owner = "my-matcher-2",
52                          Patterns = new[]
53                          {
54                              new IssuePatternConfig
55                              {
56                                  Pattern = "NOT GOOD: (.+)",
57                                  Message = 1,
58                              },
59                          },
60                      },
61                  },
62              };
63              using (Setup(matchers: matchers))
64              using (_outputManager)
65              {
66                  Process("ERROR: message 1");
67                  Process("NOT GOOD: message 2");
68                  Add(new IssueMatcherConfig
69                  {
70                      Owner = "my-matcher-1",
71                      Patterns = new[]
72                      {
73                          new IssuePatternConfig
74                          {
75                              Pattern = "ERROR: (.+) END MESSAGE",
76                              Message = 1,
77                          },
78                      },
79                  });
80                  Process("ERROR: message 3 END MESSAGE");
81                  Process("ERROR: message 4");
82                  Process("NOT GOOD: message 5");
83                  Assert.Equal(4, _issues.Count);
84                  Assert.Equal("message 1", _issues[0].Item1.Message);
85                  Assert.Equal("message 2", _issues[1].Item1.Message);
86                  Assert.Equal("message 3", _issues[2].Item1.Message);
87                  Assert.Equal("message 5", _issues[3].Item1.Message);
88                  Assert.Equal(0, _commands.Count);
89                  Assert.Equal(1, _messages.Count);
90                  Assert.Equal("ERROR: message 4", _messages[0]);
91              }
92          }
93          [Fact]
94          [Trait("Level", "L0")]
95          [Trait("Category", "Worker")]
96          public void AddMatcher_Prepend()
97          {
98              var matchers = new IssueMatchersConfig
99              {
100                  Matchers =
101                  {
102                      new IssueMatcherConfig
103                      {
104                          Owner = "my-matcher-1",
105                          Patterns = new[]
106                          {
107                              new IssuePatternConfig
108                              {
109                                  Pattern = "ERROR: (.+)",
110                                  Message = 1,
111                              },
112                          },
113                      },
114                      new IssueMatcherConfig
115                      {
116                          Owner = "my-matcher-2",
117                          Patterns = new[]
118                          {
119                              new IssuePatternConfig
120                              {
121                                  Pattern = "NOT GOOD: (.+)",
122                                  Message = 1,
123                              },
124                          },
125                      },
126                  },
127              };
128              using (Setup(matchers: matchers))
129              using (_outputManager)
130              {
131                  Process("ERROR: message 1");
132                  Process("NOT GOOD: message 2");
133                  Add(new IssueMatcherConfig
134                  {
135                      Owner = "new-matcher",
136                      Patterns = new[]
137                      {
138                          new IssuePatternConfig
139                          {
140                              Pattern = "ERROR: (.+) END MESSAGE",
141                              Message = 1,
142                          },
143                      },
144                  });
145                  Process("ERROR: message 3 END MESSAGE");
146                  Process("ERROR: message 4");
147                  Process("NOT GOOD: message 5");
148                  Assert.Equal(5, _issues.Count);
149                  Assert.Equal("message 1", _issues[0].Item1.Message);
150                  Assert.Equal("message 2", _issues[1].Item1.Message);
151                  Assert.Equal("message 3", _issues[2].Item1.Message);
152                  Assert.Equal("message 4", _issues[3].Item1.Message);
153                  Assert.Equal("message 5", _issues[4].Item1.Message);
154                  Assert.Equal(0, _commands.Count);
155                  Assert.Equal(0, _messages.Count);
156              }
157          }
158          [Fact]
159          [Trait("Level", "L0")]
160          [Trait("Category", "Worker")]
161          public void MatcherCode()
162          {
163              var matchers = new IssueMatchersConfig
164              {
165                  Matchers =
166                  {
167                      new IssueMatcherConfig
168                      {
169                          Owner = "my-matcher-1",
170                          Patterns = new[]
171                          {
172                              new IssuePatternConfig
173                              {
174                                  Pattern = @"(.*): (.+)",
175                                  Code = 1,
176                                  Message = 2,
177                              },
178                          },
179                      },
180                  },
181              };
182              using (Setup(matchers: matchers))
183              using (_outputManager)
184              {
185                  Process("BAD: real bad");
186                  Process(": not working");
187                  Assert.Equal(2, _issues.Count);
188                  Assert.Equal("real bad", _issues[0].Item1.Message);
189                  Assert.Equal("BAD", _issues[0].Item1.Data["code"]);
190                  Assert.Equal("not working", _issues[1].Item1.Message);
191                  Assert.False(_issues[1].Item1.Data.ContainsKey("code"));
192                  Assert.Equal(0, _commands.Count);
193                  Assert.Equal(0, _messages.Count);
194              }
195          }
196          [Fact]
197          [Trait("Level", "L0")]
198          [Trait("Category", "Worker")]
199          public void DoesNotResetMatchingMatcher()
200          {
201              var matchers = new IssueMatchersConfig
202              {
203                  Matchers =
204                  {
205                      new IssueMatcherConfig
206                      {
207                          Owner = "my-matcher-1",
208                          Patterns = new[]
209                          {
210                              new IssuePatternConfig
211                              {
212                                  Pattern = "Start: .+",
213                              },
214                              new IssuePatternConfig
215                              {
216                                  Pattern = "Error: (.+)",
217                                  Message = 1,
218                                  Loop = true,
219                              },
220                          },
221                      },
222                  },
223              };
224              using (Setup(matchers: matchers))
225              using (_outputManager)
226              {
227                  Process("Start: hello");
228                  Process("Error: it broke");
229                  Process("Error: oh no");
230                  Process("Error: not good");
231                  Process("regular message 1");
232                  Process("Start: hello again");
233                  Process("Error: it broke again");
234                  Process("Error: real bad");
235                  Process("regular message 2");
236                  Assert.Equal(5, _issues.Count);
237                  Assert.Equal("it broke", _issues[0].Item1.Message);
238                  Assert.Equal("oh no", _issues[1].Item1.Message);
239                  Assert.Equal("not good", _issues[2].Item1.Message);
240                  Assert.Equal("it broke again", _issues[3].Item1.Message);
241                  Assert.Equal("real bad", _issues[4].Item1.Message);
242                  Assert.Equal(0, _commands.Count);
243                  Assert.Equal(4, _messages.Count);
244                  Assert.Equal("Start: hello", _messages[0]);
245                  Assert.Equal("regular message 1", _messages[1]);
246                  Assert.Equal("Start: hello again", _messages[2]);
247                  Assert.Equal("regular message 2", _messages[3]);
248              }
249          }
250          [Fact]
251          [Trait("Level", "L0")]
252          [Trait("Category", "Worker")]
253          public void InitialMatchers()
254          {
255              var matchers = new IssueMatchersConfig
256              {
257                  Matchers =
258                  {
259                      new IssueMatcherConfig
260                      {
261                          Owner = "my-matcher-1",
262                          Patterns = new[]
263                          {
264                              new IssuePatternConfig
265                              {
266                                  Pattern = "ERROR: (.+)",
267                                  Message = 1,
268                              },
269                          },
270                      },
271                      new IssueMatcherConfig
272                      {
273                          Owner = "my-matcher-2",
274                          Patterns = new[]
275                          {
276                              new IssuePatternConfig
277                              {
278                                  Pattern = "NOT GOOD: (.+)",
279                                  Message = 1,
280                              },
281                          },
282                      },
283                  },
284              };
285              using (Setup(matchers: matchers))
286              using (_outputManager)
287              {
288                  Process("ERROR: it is broken");
289                  Process("NOT GOOD: that did not work");
290                  Assert.Equal(2, _issues.Count);
291                  Assert.Equal("it is broken", _issues[0].Item1.Message);
292                  Assert.Equal("that did not work", _issues[1].Item1.Message);
293                  Assert.Equal(0, _commands.Count);
294                  Assert.Equal(0, _messages.Count);
295              }
296          }
297          [Fact]
298          [Trait("Level", "L0")]
299          [Trait("Category", "Worker")]
300          public void MatcherLineColumn()
301          {
302              var matchers = new IssueMatchersConfig
303              {
304                  Matchers =
305                  {
306                      new IssueMatcherConfig
307                      {
308                          Owner = "my-matcher-1",
309                          Patterns = new[]
310                          {
311                              new IssuePatternConfig
312                              {
313                                  Pattern = @"\((.+),(.+)\): (.+)",
314                                  Line = 1,
315                                  Column = 2,
316                                  Message = 3,
317                              },
318                          },
319                      },
320                  },
321              };
322              using (Setup(matchers: matchers))
323              using (_outputManager)
324              {
325                  Process("(12,34): real bad");
326                  Process("(12,thirty-four): it is broken");
327                  Process("(twelve,34): not working");
328                  Assert.Equal(3, _issues.Count);
329                  Assert.Equal("real bad", _issues[0].Item1.Message);
330                  Assert.Equal("12", _issues[0].Item1.Data["line"]);
331                  Assert.Equal("34", _issues[0].Item1.Data["col"]);
332                  Assert.Equal("it is broken", _issues[1].Item1.Message);
333                  Assert.Equal("12", _issues[1].Item1.Data["line"]);
334                  Assert.False(_issues[1].Item1.Data.ContainsKey("col"));
335                  Assert.Equal("not working", _issues[2].Item1.Message);
336                  Assert.False(_issues[2].Item1.Data.ContainsKey("line"));
337                  Assert.Equal("34", _issues[2].Item1.Data["col"]);
338                  Assert.Equal(0, _commands.Count);
339                  Assert.Equal(2, _messages.Count);
340                  Assert.Equal("##[debug]Unable to parse column number 'thirty-four'", _messages[0]);
341                  Assert.Equal("##[debug]Unable to parse line number 'twelve'", _messages[1]);
342              }
343          }
344          [Fact]
345          [Trait("Level", "L0")]
346          [Trait("Category", "Worker")]
347          public void MatcherDoesNotReceiveCommand()
348          {
349              using (Setup())
350              using (_outputManager)
351              {
352                  Add(new IssueMatcherConfig
353                  {
354                      Owner = "my-matcher",
355                      Patterns = new[]
356                      {
357                          new IssuePatternConfig
358                          {
359                              Pattern = "ERROR: (.+)",
360                              Message = 1,
361                          },
362                      },
363                  });
364                  Process("this line is an ERROR: it is broken");
365                  Process("##[some-command]this line is a command even though it contains ERROR: not working");
366                  Process("this line is a command too ##[some-command]even though it contains ERROR: not working again");
367                  Process("##[not-command]this line is an ERROR: it is broken again");
368                  Assert.Equal(2, _issues.Count);
369                  Assert.Equal("it is broken", _issues[0].Item1.Message);
370                  Assert.Equal("it is broken again", _issues[1].Item1.Message);
371                  Assert.Equal(2, _commands.Count);
372                  Assert.Equal("##[some-command]this line is a command even though it contains ERROR: not working", _commands[0]);
373                  Assert.Equal("this line is a command too ##[some-command]even though it contains ERROR: not working again", _commands[1]);
374                  Assert.Equal(0, _messages.Count);
375              }
376          }
377          [Fact]
378          [Trait("Level", "L0")]
379          [Trait("Category", "Worker")]
380          public void MatcherRemoveColorCodes()
381          {
382              using (Setup())
383              using (_outputManager)
384              {
385                  Add(new IssueMatcherConfig
386                  {
387                      Owner = "my-matcher",
388                      Patterns = new[]
389                      {
390                          new IssuePatternConfig
391                          {
392                              Pattern = "^the error: (.+)$",
393                              Message = 1,
394                          },
395                      },
396                  });
397                  Process("the error: \033[31mred, \033[1;31mbright red, \033[mreset");
398                  Assert.Equal(1, _issues.Count);
399                  Assert.Equal("red, bright red, reset", _issues[0].Item1.Message);
400                  Assert.Equal("the error: red, bright red, reset", _issues[0].Item2);
401                  Assert.Equal(0, _commands.Count);
402                  Assert.Equal(0, _messages.Count);
403              }
404          }
405          [Fact]
406          [Trait("Level", "L0")]
407          [Trait("Category", "Worker")]
408          public void RemoveMatcher()
409          {
410              var matchers = new IssueMatchersConfig
411              {
412                  Matchers =
413                  {
414                      new IssueMatcherConfig
415                      {
416                          Owner = "my-matcher-1",
417                          Patterns = new[]
418                          {
419                              new IssuePatternConfig
420                              {
421                                  Pattern = "ERROR: (.+)",
422                                  Message = 1,
423                              },
424                          },
425                      },
426                      new IssueMatcherConfig
427                      {
428                          Owner = "my-matcher-2",
429                          Patterns = new[]
430                          {
431                              new IssuePatternConfig
432                              {
433                                  Pattern = "NOT GOOD: (.+)",
434                                  Message = 1,
435                              },
436                          },
437                      },
438                  },
439              };
440              using (Setup(matchers: matchers))
441              using (_outputManager)
442              {
443                  Process("ERROR: message 1");
444                  Process("NOT GOOD: message 2");
445                  Remove("my-matcher-1");
446                  Process("ERROR: message 3");
447                  Process("NOT GOOD: message 4");
448                  Assert.Equal(3, _issues.Count);
449                  Assert.Equal("message 1", _issues[0].Item1.Message);
450                  Assert.Equal("message 2", _issues[1].Item1.Message);
451                  Assert.Equal("message 4", _issues[2].Item1.Message);
452                  Assert.Equal(0, _commands.Count);
453                  Assert.Equal(1, _messages.Count);
454                  Assert.Equal("ERROR: message 3", _messages[0]);
455              }
456          }
457          [Fact]
458          [Trait("Level", "L0")]
459          [Trait("Category", "Worker")]
460          public void ResetsOtherMatchers()
461          {
462              var matchers = new IssueMatchersConfig
463              {
464                  Matchers =
465                  {
466                      new IssueMatcherConfig
467                      {
468                          Owner = "my-matcher-1",
469                          Patterns = new[]
470                          {
471                              new IssuePatternConfig
472                              {
473                                  Pattern = "Matches both line 1: .+",
474                              },
475                              new IssuePatternConfig
476                              {
477                                  Pattern = "Matches 1 only line 2: (.+)",
478                                  Message = 1,
479                              },
480                          },
481                      },
482                      new IssueMatcherConfig
483                      {
484                          Owner = "my-matcher-2",
485                          Patterns = new[]
486                          {
487                              new IssuePatternConfig
488                              {
489                                  Pattern = "Matches both line 1: (.+)",
490                              },
491                              new IssuePatternConfig
492                              {
493                                  Pattern = "(.+)",
494                                  Message = 1,
495                              },
496                          },
497                      },
498                  },
499              };
500              using (Setup(matchers: matchers))
501              using (_outputManager)
502              {
503                  Process("Matches both line 1: hello");
504                  Process("Matches 1 only line 2: it broke");
505                  Process("regular message 1");
506                  Process("regular message 2");
507                  Process("Matches both line 1: hello again");
508                  Process("oh no, another error");
509                  Assert.Equal(2, _issues.Count);
510                  Assert.Equal("it broke", _issues[0].Item1.Message);
511                  Assert.Equal("oh no, another error", _issues[1].Item1.Message);
512                  Assert.Equal(0, _commands.Count);
513                  Assert.Equal(4, _messages.Count);
514                  Assert.Equal("Matches both line 1: hello", _messages[0]);
515                  Assert.Equal("regular message 1", _messages[1]);
516                  Assert.Equal("regular message 2", _messages[2]);
517                  Assert.Equal("Matches both line 1: hello again", _messages[3]);
518              }
519          }
520          [Fact]
521          [Trait("Level", "L0")]
522          [Trait("Category", "Worker")]
523          public void MatcherSeverity()
524          {
525              var matchers = new IssueMatchersConfig
526              {
527                  Matchers =
528                  {
529                      new IssueMatcherConfig
530                      {
531                          Owner = "my-matcher-1",
532                          Patterns = new[]
533                          {
534                              new IssuePatternConfig
535                              {
536                                  Pattern = "(.*): (.+)",
537                                  Severity = 1,
538                                  Message = 2,
539                              },
540                          },
541                      },
542                      new IssueMatcherConfig
543                      {
544                          Owner = "my-matcher-2",
545                          Patterns = new[]
546                          {
547                              new IssuePatternConfig
548                              {
549                                  Pattern = "ERROR! (.+)",
550                                  Message = 1,
551                              },
552                          },
553                      },
554                  },
555              };
556              using (Setup(matchers: matchers))
557              using (_outputManager)
558              {
559                  Process("ERRor: real bad");
560                  Process("WARNing: not great");
561                  Process("info: hey");
562                  Process(": not working");
563                  Process("ERROR! uh oh");
564                  Assert.Equal(4, _issues.Count);
565                  Assert.Equal("real bad", _issues[0].Item1.Message);
566                  Assert.Equal(DTWebApi.IssueType.Error, _issues[0].Item1.Type);
567                  Assert.Equal("not great", _issues[1].Item1.Message);
568                  Assert.Equal(DTWebApi.IssueType.Warning, _issues[1].Item1.Type);
569                  Assert.Equal("not working", _issues[2].Item1.Message);
570                  Assert.Equal(DTWebApi.IssueType.Error, _issues[2].Item1.Type);
571                  Assert.Equal("uh oh", _issues[3].Item1.Message);
572                  Assert.Equal(DTWebApi.IssueType.Error, _issues[3].Item1.Type);
573                  Assert.Equal(0, _commands.Count);
574                  Assert.Equal(2, _messages.Count);
575                  Assert.StartsWith("##[debug]Skipped", _messages[0]);
576                  Assert.Contains("'info'", _messages[0]);
577                  Assert.Equal("info: hey", _messages[1]);
578              }
579          }
580          [Fact]
581          [Trait("Level", "L0")]
582          [Trait("Category", "Worker")]
583          public void MatcherTimeout()
584          {
585              Environment.SetEnvironmentVariable("GITHUB_ACTIONS_RUNNER_ISSUE_MATCHER_TIMEOUT", "0:0:0.01");
586              var matchers = new IssueMatchersConfig
587              {
588                  Matchers =
589                  {
590                      new IssueMatcherConfig
591                      {
592                          Owner = "email",
593                          Patterns = new[]
594                          {
595                              new IssuePatternConfig
596                              {
597                                  Pattern = @"^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$",
598                                  Message = 0,
599                              },
600                          },
601                      },
602                      new IssueMatcherConfig
603                      {
604                          Owner = "err",
605                          Patterns = new[]
606                          {
607                              new IssuePatternConfig
608                              {
609                                  Pattern = @"ERR: (.+)",
610                                  Message = 1,
611                              },
612                          },
613                      },
614                  },
615              };
616              using (Setup(matchers: matchers))
617              using (_outputManager)
618              {
<span onclick='openModal()' class='match'>619                  Process("john.doe@contoso.com");
620                  Process("t@t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.c%20");
621                  Process("jane.doe@contoso.com");
622                  Process("ERR: this error");
623                  Assert.Equal(3, _issues.Count);
624                  Assert.Equal("john.doe@contoso.com", _issues[0].Item1.Message);
625                  Assert.Contains("Removing issue matcher 'email'", _issues[1].Item1.Message);
626                  Assert.Equal("this error", _issues[2].Item1.Message);
627                  Assert.Equal(0, _commands.Count);
628                  Assert.Equal(2, _messages.Where(x => x.StartsWith("##[debug]Timeout processing issue matcher")).Count());
629                  Assert.Equal(1, _messages.Where(x => x.Equals("t@t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.c%20")).Count());
630                  Assert.Equal(1, _messages.Where(x => x.StartsWith("jane.doe@contoso.com")).Count());
631              }
632          }
633          [Fact]
</span>634          [Trait("Level", "L0")]
635          [Trait("Category", "Worker")]
636          public async void MatcherFile()
637          {
638              Environment.SetEnvironmentVariable("RUNNER_TEST_GET_REPOSITORY_PATH_FAILSAFE", "2");
639              var matchers = new IssueMatchersConfig
640              {
641                  Matchers =
642                  {
643                      new IssueMatcherConfig
644                      {
645                          Owner = "my-matcher-1",
646                          Patterns = new[]
647                          {
648                              new IssuePatternConfig
649                              {
650                                  Pattern = @"(.+): (.+)",
651                                  File = 1,
652                                  Message = 2,
653                              },
654                          },
655                      },
656                  },
657              };
658              using (var hostContext = Setup(matchers: matchers))
659              using (_outputManager)
660              {
661                  var workDirectory = hostContext.GetDirectory(WellKnownDirectory.Work);
662                  ArgUtil.NotNullOrEmpty(workDirectory, nameof(workDirectory));
663                  Directory.CreateDirectory(workDirectory);
664                  var workspaceDirectory = Path.Combine(workDirectory, "workspace");
665                  Directory.CreateDirectory(workspaceDirectory);
666                  _executionContext.Setup(x => x.GetGitHubContext("workspace")).Returns(workspaceDirectory);
667                  _executionContext.Setup(x => x.GetGitHubContext("repository")).Returns("my-org/workflow-repo");
668                  var workflowRepository = Path.Combine(workspaceDirectory, "workflow-repo");
669                  var nestedOtherRepository = Path.Combine(workspaceDirectory, "workflow-repo", "nested-other-repo");
670                  var otherRepository = Path.Combine(workspaceDirectory, workflowRepository, "nested-other-repo");
671                  var nestedWorkflowRepository = Path.Combine(workspaceDirectory, "other-repo", "nested-workflow-repo");
672                  var workflowRepositoryUsingSsh = Path.Combine(workspaceDirectory, "workflow-repo-using-ssh");
673                  await CreateRepository(hostContext, workflowRepository, "https:&bsol;&bsol;github.com/my-org/workflow-repo");
674                  await CreateRepository(hostContext, nestedOtherRepository, "https:&bsol;&bsol;github.com/my-org/other-repo");
675                  await CreateRepository(hostContext, otherRepository, "https:&bsol;&bsol;github.com/my-org/other-repo");
676                  await CreateRepository(hostContext, nestedWorkflowRepository, "https:&bsol;&bsol;github.com/my-org/workflow-repo");
677                  await CreateRepository(hostContext, workflowRepositoryUsingSsh, "git@github.com:my-org/workflow-repo.git");
678                  var file_noRepository = Path.Combine(workspaceDirectory, "no-repo.txt");
679                  var file_workflowRepository = Path.Combine(workflowRepository, "workflow-repo.txt");
680                  var file_workflowRepository_nestedDirectory = Path.Combine(workflowRepository, "subdir", "subdir2", "workflow-repo-nested-dir.txt");
681                  var file_workflowRepository_failsafe = Path.Combine(workflowRepository, "failsafe-subdir", "failsafe-subdir2", "failsafe-subdir3", "workflow-repo-failsafe.txt");
682                  var file_nestedOtherRepository = Path.Combine(nestedOtherRepository, "nested-other-repo");
683                  var file_otherRepository = Path.Combine(otherRepository, "other-repo.txt");
684                  var file_nestedWorkflowRepository = Path.Combine(nestedWorkflowRepository, "nested-workflow-repo.txt");
685                  var file_workflowRepositoryUsingSsh = Path.Combine(workflowRepositoryUsingSsh, "workflow-repo-using-ssh.txt");
686                  foreach (var file in new[] { file_noRepository, file_workflowRepository, file_workflowRepository_nestedDirectory, file_workflowRepository_failsafe, file_nestedOtherRepository, file_otherRepository, file_nestedWorkflowRepository, file_workflowRepositoryUsingSsh })
687                  {
688                      Directory.CreateDirectory(Path.GetDirectoryName(file));
689                      File.WriteAllText(file, "");
690                  }
691                  Process($"{file_noRepository}: some error 1");
692                  Process($"{file_workflowRepository}: some error 2");
693                  Process($"{file_workflowRepository.Substring(workspaceDirectory.Length + 1)}: some error 3"); 
694                  Process($"{file_workflowRepository_nestedDirectory}: some error 4");
695                  Process($"{file_workflowRepository_failsafe}: some error 5");
696                  Process($"{file_nestedOtherRepository}: some error 6");
697                  Process($"{file_otherRepository}: some error 7");
698                  Process($"{file_nestedWorkflowRepository}: some error 8");
699                  Process($"{file_workflowRepositoryUsingSsh}: some error 9");
700                  Assert.Equal(9, _issues.Count);
701                  Assert.Equal("some error 1", _issues[0].Item1.Message);
702                  Assert.False(_issues[0].Item1.Data.ContainsKey("file"));
703                  Assert.Equal("some error 2", _issues[1].Item1.Message);
704                  Assert.Equal(file_workflowRepository.Substring(workflowRepository.Length + 1).Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), _issues[1].Item1.Data["file"]);
705                  Assert.Equal("some error 3", _issues[2].Item1.Message);
706                  Assert.Equal(file_workflowRepository.Substring(workflowRepository.Length + 1).Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), _issues[2].Item1.Data["file"]);
707                  Assert.Equal("some error 4", _issues[3].Item1.Message);
708                  Assert.Equal(file_workflowRepository_nestedDirectory.Substring(workflowRepository.Length + 1).Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), _issues[3].Item1.Data["file"]);
709                  Assert.Equal("some error 5", _issues[4].Item1.Message);
710                  Assert.False(_issues[4].Item1.Data.ContainsKey("file"));
711                  Assert.Equal("some error 6", _issues[5].Item1.Message);
712                  Assert.False(_issues[5].Item1.Data.ContainsKey("file"));
713                  Assert.Equal("some error 7", _issues[6].Item1.Message);
714                  Assert.False(_issues[6].Item1.Data.ContainsKey("file"));
715                  Assert.Equal("some error 8", _issues[7].Item1.Message);
716                  Assert.Equal(file_nestedWorkflowRepository.Substring(nestedWorkflowRepository.Length + 1).Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), _issues[7].Item1.Data["file"]);
717                  Assert.Equal("some error 9", _issues[8].Item1.Message);
718                  Assert.Equal(file_workflowRepositoryUsingSsh.Substring(workflowRepositoryUsingSsh.Length + 1).Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), _issues[8].Item1.Data["file"]);
719              }
720              Environment.SetEnvironmentVariable("RUNNER_TEST_GET_REPOSITORY_PATH_FAILSAFE", "");
721          }
722  #if OS_LINUX
723          [Fact]
724          [Trait("Level", "L0")]
725          [Trait("Category", "Worker")]
726          public async void MatcherFile_JobContainer()
727          {
728              var matchers = new IssueMatchersConfig
729              {
730                  Matchers =
731                  {
732                      new IssueMatcherConfig
733                      {
734                          Owner = "my-matcher-1",
735                          Patterns = new[]
736                          {
737                              new IssuePatternConfig
738                              {
739                                  Pattern = @"(.+): (.+)",
740                                  File = 1,
741                                  Message = 2,
742                              },
743                          },
744                      },
745                  },
746              };
747              var container = new ContainerInfo();
748              using (var hostContext = Setup(matchers: matchers, jobContainer: container))
749              using (_outputManager)
750              {
751                  var workDirectory = hostContext.GetDirectory(WellKnownDirectory.Work);
752                  ArgUtil.NotNullOrEmpty(workDirectory, nameof(workDirectory));
753                  Directory.CreateDirectory(workDirectory);
754                  var workspaceDirectory = Path.Combine(workDirectory, "workspace");
755                  Directory.CreateDirectory(workspaceDirectory);
756                  _executionContext.Setup(x => x.GetGitHubContext("workspace")).Returns(workspaceDirectory);
757                  _executionContext.Setup(x => x.GetGitHubContext("repository")).Returns("my-org/workflow-repo");
758                  await CreateRepository(hostContext, workspaceDirectory, "https:&bsol;&bsol;github.com/my-org/workflow-repo");
759                  var file = Path.Combine(workspaceDirectory, "some-file.txt");
760                  File.WriteAllText(file, "");
761                  container.AddPathTranslateMapping(workspaceDirectory, "/container/path/to/workspace");
762                  Process($"/container/path/to/workspace/some-file.txt: some error 1");
763                  Process($"some-file.txt: some error 2");
764                  Assert.Equal(2, _issues.Count);
765                  Assert.Equal("some error 1", _issues[0].Item1.Message);
766                  Assert.Equal("some-file.txt", _issues[0].Item1.Data["file"]);
767                  Assert.Equal("some error 2", _issues[1].Item1.Message);
768                  Assert.Equal("some-file.txt", _issues[1].Item1.Data["file"]);
769              }
770          }
771          [Fact]
772          [Trait("Level", "L0")]
773          [Trait("Category", "Worker")]
774          public async void MatcherFile_StepContainer()
775          {
776              var matchers = new IssueMatchersConfig
777              {
778                  Matchers =
779                  {
780                      new IssueMatcherConfig
781                      {
782                          Owner = "my-matcher-1",
783                          Patterns = new[]
784                          {
785                              new IssuePatternConfig
786                              {
787                                  Pattern = @"(.+): (.+)",
788                                  File = 1,
789                                  Message = 2,
790                              },
791                          },
792                      },
793                  },
794              };
795              var container = new ContainerInfo();
796              using (var hostContext = Setup(matchers: matchers, stepContainer: container))
797              using (_outputManager)
798              {
799                  var workDirectory = hostContext.GetDirectory(WellKnownDirectory.Work);
800                  ArgUtil.NotNullOrEmpty(workDirectory, nameof(workDirectory));
801                  Directory.CreateDirectory(workDirectory);
802                  var workspaceDirectory = Path.Combine(workDirectory, "workspace");
803                  Directory.CreateDirectory(workspaceDirectory);
804                  _executionContext.Setup(x => x.GetGitHubContext("workspace")).Returns(workspaceDirectory);
805                  _executionContext.Setup(x => x.GetGitHubContext("repository")).Returns("my-org/workflow-repo");
806                  await CreateRepository(hostContext, workspaceDirectory, "https:&bsol;&bsol;github.com/my-org/workflow-repo");
807                  var file = Path.Combine(workspaceDirectory, "some-file.txt");
808                  File.WriteAllText(file, "");
809                  container.AddPathTranslateMapping(workspaceDirectory, "/container/path/to/workspace");
810                  Process($"/container/path/to/workspace/some-file.txt: some error 1");
811                  Process($"some-file.txt: some error 2");
812                  Assert.Equal(2, _issues.Count);
813                  Assert.Equal("some error 1", _issues[0].Item1.Message);
814                  Assert.Equal("some-file.txt", _issues[0].Item1.Data["file"]);
815                  Assert.Equal("some error 2", _issues[1].Item1.Message);
816                  Assert.Equal("some-file.txt", _issues[1].Item1.Data["file"]);
817              }
818          }
819  #endif
820          [Fact]
821          [Trait("Level", "L0")]
822          [Trait("Category", "Worker")]
823          public async void MatcherFromPath()
824          {
825              var matchers = new IssueMatchersConfig
826              {
827                  Matchers =
828                  {
829                      new IssueMatcherConfig
830                      {
831                          Owner = "my-matcher-1",
832                          Patterns = new[]
833                          {
834                              new IssuePatternConfig
835                              {
836                                  Pattern = @"(.+): (.+) \[(.+)\]",
837                                  File = 1,
838                                  Message = 2,
839                                  FromPath = 3,
840                              },
841                          },
842                      },
843                  },
844              };
845              using (var hostContext = Setup(matchers: matchers))
846              using (_outputManager)
847              {
848                  var workDirectory = hostContext.GetDirectory(WellKnownDirectory.Work);
849                  ArgUtil.NotNullOrEmpty(workDirectory, nameof(workDirectory));
850                  Directory.CreateDirectory(workDirectory);
851                  var workspaceDirectory = Path.Combine(workDirectory, "workspace");
852                  Directory.CreateDirectory(workspaceDirectory);
853                  _executionContext.Setup(x => x.GetGitHubContext("workspace")).Returns(workspaceDirectory);
854                  _executionContext.Setup(x => x.GetGitHubContext("repository")).Returns("my-org/workflow-repo");
855                  var repositoryPath = Path.Combine(workspaceDirectory, "workflow-repo");
856                  await CreateRepository(hostContext, repositoryPath, "https:&bsol;&bsol;github.com/my-org/workflow-repo");
857                  var filePath = Path.Combine(repositoryPath, "some-project", "some-directory", "some-file.txt");
858                  Directory.CreateDirectory(Path.GetDirectoryName(filePath));
859                  File.WriteAllText(filePath, "");
860                  Process("some-directory/some-file.txt: some error [workflow-repo/some-project/some-project.proj]");
861                  Assert.Equal(1, _issues.Count);
862                  Assert.Equal("some error", _issues[0].Item1.Message);
863                  Assert.Equal("some-project/some-directory/some-file.txt", _issues[0].Item1.Data["file"]);
864                  Assert.Equal(0, _commands.Count);
865                  Assert.Equal(0, _messages.Count);
866              }
867          }
868          [Fact]
869          [Trait("Level", "L0")]
870          [Trait("Category", "Worker")]
871          public void CaptureTelemetryForGitUnsafeRepository()
872          {
873              using (Setup())
874              using (_outputManager)
875              {
876                  Process("fatal: unsafe repository ('/github/workspace' is owned by someone else)");
877                  Assert.Contains("fatal: unsafe repository ('/github/workspace' is owned by someone else)", _executionContext.Object.StepTelemetry.ErrorMessages);
878              }
879          }
880          private TestHostContext Setup(
881              [CallerMemberName] string name = "",
882              IssueMatchersConfig matchers = null,
883              ContainerInfo jobContainer = null,
884              ContainerInfo stepContainer = null)
885          {
886              matchers?.Validate();
887              _onMatcherChanged = null;
888              _issues = new List<Tuple<DTWebApi.Issue, string>>();
889              _messages = new List<string>();
890              _commands = new List<string>();
891              var hostContext = new TestHostContext(this, name);
892              _variables = new Variables(hostContext, new Dictionary<string, DTWebApi.VariableValue>());
893              _executionContext = new Mock<IExecutionContext>();
894              _executionContext.Setup(x => x.Global)
895                  .Returns(new GlobalContext
896                  {
897                      Container = jobContainer,
898                      Variables = _variables,
899                      WriteDebug = true,
900                  });
901              _executionContext.Setup(x => x.StepTelemetry)
902                  .Returns(new DTWebApi.ActionsStepTelemetry());
903              _executionContext.Setup(x => x.GetMatchers())
904                  .Returns(matchers?.Matchers ?? new List<IssueMatcherConfig>());
905              _executionContext.Setup(x => x.Add(It.IsAny<OnMatcherChanged>()))
906                  .Callback((OnMatcherChanged handler) =>
907                  {
908                      _onMatcherChanged = handler;
909                  });
910              _executionContext.Setup(x => x.AddIssue(It.IsAny<DTWebApi.Issue>(), It.IsAny<ExecutionContextLogOptions>()))
911                  .Callback((DTWebApi.Issue issue, ExecutionContextLogOptions logOptions) =>
912                  {
913                      var resolvedMessage = issue.Message;
914                      if (logOptions.WriteToLog && !string.IsNullOrEmpty(logOptions.LogMessageOverride))
915                      {
916                          resolvedMessage = logOptions.LogMessageOverride;
917                      }
918                      _issues.Add(new(issue, resolvedMessage));
919                  });
920              _executionContext.Setup(x => x.Write(It.IsAny<string>(), It.IsAny<string>()))
921                  .Callback((string tag, string message) =>
922                  {
923                      _messages.Add($"{tag}{message}");
924                      hostContext.GetTrace().Info($"{tag}{message}");
925                  });
926              _commandManager = new Mock<IActionCommandManager>();
927              _commandManager.Setup(x => x.TryProcessCommand(It.IsAny<IExecutionContext>(), It.IsAny<string>(), It.IsAny<ContainerInfo>()))
928                  .Returns((IExecutionContext executionContext, string line, ContainerInfo container) =>
929                  {
930                      if (line.IndexOf("##[some-command]") >= 0)
931                      {
932                          _commands.Add(line);
933                          return true;
934                      }
935                      return false;
936                  });
937              _outputManager = new OutputManager(_executionContext.Object, _commandManager.Object, stepContainer);
938              return hostContext;
939          }
940          private void Add(IssueMatcherConfig matcher)
941          {
942              var matchers = new IssueMatchersConfig
943              {
944                  Matchers =
945                  {
946                      matcher,
947                  },
948              };
949              matchers.Validate();
950              _onMatcherChanged(null, new MatcherChangedEventArgs(matcher));
951          }
952          private void Remove(string owner)
953          {
954              var matcher = new IssueMatcherConfig { Owner = owner };
955              _onMatcherChanged(null, new MatcherChangedEventArgs(matcher));
956          }
957          private void Process(string line)
958          {
959              _outputManager.OnDataReceived(null, new ProcessDataReceivedEventArgs(line));
960          }
961          private async Task CreateRepository(TestHostContext hostConetxt, string path, string url)
962          {
963              Directory.CreateDirectory(path);
964              var gitPath = WhichUtil.Which("git", true);
965              var environment = new Dictionary<string, string>();
966              using (var processInvoker = new ProcessInvoker(hostConetxt.GetTrace()))
967              {
968                  await processInvoker.ExecuteAsync(path, gitPath, "init", environment, CancellationToken.None);
969              }
970              using (var processInvoker = new ProcessInvoker(hostConetxt.GetTrace()))
971              {
972                  await processInvoker.ExecuteAsync(path, gitPath, $"remote add origin {url}", environment, CancellationToken.None);
973              }
974          }
975      }
976  }
</code></pre>
        </div>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-PopoverTests.cs</h3>
            <pre><code>1  #pragma warning disable CS1998 
2  using System;
3  using System.Collections.Generic;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Bunit;
7  using FluentAssertions;
8  using Microsoft.AspNetCore.Components;
9  using Microsoft.AspNetCore.Components.Rendering;
10  using Microsoft.Extensions.DependencyInjection;
11  using Microsoft.Extensions.Options;
12  using Microsoft.JSInterop;
13  using Microsoft.JSInterop.Infrastructure;
14  using Moq;
15  using MudBlazor.UnitTests.TestComponents;
16  using MudBlazor.UnitTests.TestComponents.Popover;
17  using NUnit.Framework;
18  using static Bunit.ComponentParameterFactory;
19  namespace MudBlazor.UnitTests.Components
20  {
21      [TestFixture]
22      public class PopoverTests : BunitTest
23      {
24          [Test]
25          public void PopoverOptions_Defaults()
26          {
27              var options = new PopoverOptions();
28              options.ContainerClass.Should().Be("mudblazor-main-content");
29              options.FlipMargin.Should().Be(0);
30              options.ThrowOnDuplicateProvider.Should().Be(true);
31          }
32          [Test]
33          public void MudPopoverHandler_Constructor()
34          {
35              RenderFragment renderFragement = (tree) => { };
36              var mock = Mock.Of<IJSRuntime>();
37              Action updater = () => { };
38              var handler = new MudPopoverHandler(renderFragement, mock, updater);
39              handler.Id.Should().NotBe(default(Guid));
40              handler.UserAttributes.Should().BeEmpty();
41              handler.Class.Should().BeNull();
42              handler.Tag.Should().BeNull();
43              handler.Fragment.Should().BeSameAs(renderFragement);
44              handler.IsConnected.Should().BeFalse();
45              handler.ShowContent.Should().BeFalse();
46          }
47          [Test]
48          public void MudPopoverHandler_PreventNullValuesInConstructor()
49          {
50              RenderFragment renderFragement = (tree) => { };
51              var mock = Mock.Of<IJSRuntime>();
52              Action updater = () => { };
53              Assert.Throws<ArgumentNullException>(() => new MudPopoverHandler(null, mock, updater));
54              Assert.Throws<ArgumentNullException>(() => new MudPopoverHandler(renderFragement, null, updater));
55              Assert.Throws<ArgumentNullException>(() => new MudPopoverHandler(renderFragement, mock, null));
56          }
57          [Test]
58          public void MudPopoverHandler_SetComponentBaseParameters()
59          {
60              RenderFragment renderFragement = (tree) => { };
61              var mock = Mock.Of<IJSRuntime>();
62              Action updater = () => { };
63              var handler = new MudPopoverHandler(renderFragement, mock, updater);
<span onclick='openModal()' class='match'>64              var comp = Context.RenderComponent<MudBadge>(p =>
65              {
66                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
67                  p.Add(x => x.Tag, "my tag");
68              });
69              handler.SetComponentBaseParameters(comp.Instance, "my-extra-class", "my-extra-style:2px", true);
70              handler.Id.Should().NotBe(default(Guid));
71              handler.UserAttributes.Should().BeEquivalentTo(new Dictionary<string, object> { { "myprop1", "myValue1" } });
72              handler.Class.Should().Be("my-extra-class");
73              handler.Tag.Should().Be("my tag");
74              handler.Fragment.Should().BeSameAs(renderFragement);
75              handler.IsConnected.Should().BeFalse();
76              handler.ShowContent.Should().BeTrue();
77          }
78          [Test(Description = "Remove in v7")]
</span>79          public void MudPopoverHandler_UpdateFragment()
80          {
81              RenderFragment initialRenderFragement = (tree) => { };
82              var mock = Mock.Of<IJSRuntime>();
83              var updateCounter = 0;
84              Action updater = () => { updateCounter++; };
85              var handler = new MudPopoverHandler(initialRenderFragement, mock, updater);
86              var comp = Context.RenderComponent<MudBadge>(p =>
87              {
88                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
89                  p.Add(x => x.Tag, "my tag");
90              });
91              RenderFragment newRenderFragement = (tree) => { };
92              handler.UpdateFragment(newRenderFragement, comp.Instance, "my-extra-class", "my-extra-style:2px", true);
93              handler.Id.Should().NotBe(default(Guid));
94              handler.UserAttributes.Should().BeEquivalentTo(new Dictionary<string, object> { { "myprop1", "myValue1" } });
95              handler.Class.Should().Be("my-extra-class");
96              handler.Style.Should().Be("my-extra-style:2px");
97              handler.Tag.Should().Be("my tag");
98              handler.Fragment.Should().BeSameAs(newRenderFragement);
99              handler.IsConnected.Should().BeFalse();
100              handler.ShowContent.Should().BeTrue();
101              updateCounter.Should().Be(1);
102          }
103          [Test]
104          public async Task MudPopoverHandler_UpdateFragmentAsync()
105          {
106              var mock = Mock.Of<IJSRuntime>();
107              var updateCounter = 0;
108              RenderFragment initialRenderFragment = _ => { };
109              RenderFragment newRenderFragment = _ => { };
110              void Updater() => updateCounter++;
111              var handler = new MudPopoverHandler(initialRenderFragment, mock, Updater);
112              var comp = Context.RenderComponent<MudBadge>(p =>
113              {
114                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
115                  p.Add(x => x.Tag, "my tag");
116              });
117              await handler.UpdateFragmentAsync(newRenderFragment, comp.Instance, "my-extra-class", "my-extra-style:2px", true);
118              handler.Id.Should().NotBe(default(Guid));
119              handler.UserAttributes.Should().BeEquivalentTo(new Dictionary<string, object> { { "myprop1", "myValue1" } });
120              handler.Class.Should().Be("my-extra-class");
121              handler.Style.Should().Be("my-extra-style:2px");
122              handler.Tag.Should().Be("my tag");
123              handler.Fragment.Should().BeSameAs(newRenderFragment);
124              handler.IsConnected.Should().BeFalse();
125              handler.ShowContent.Should().BeTrue();
126              updateCounter.Should().Be(1);
127          }
128          [Test]
129          public async Task MudPopoverHandler_DetachAndUpdateFragmentAsync()
130          {
131              var mock = Mock.Of<IJSRuntime>();
132              var updateCounter = 0;
133              RenderFragment initialRenderFragment = _ => { };
134              RenderFragment newRenderFragment = _ => { };
135              void Updater() => updateCounter++;
136              var handler = new MudPopoverHandler(initialRenderFragment, mock, Updater);
137              var comp = Context.RenderComponent<MudBadge>(p =>
138              {
139                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
140                  p.Add(x => x.Tag, "my tag");
141              });
142              await handler.Detach();
143              await handler.UpdateFragmentAsync(newRenderFragment, comp.Instance, "my-new-extra-class", "my-new-extra-style:2px", true);
144              updateCounter.Should().Be(0);
145          }
146          [Test]
147          public async Task MudPopoverHandler_DetachAndUpdateFragmentConcurrent_UpdateFragmentDoesNotRunInTheSameTimeAsDetach()
148          {
149              var connectTcs = new TaskCompletionSource<IJSVoidResult>();
150              var mock = new Mock<IJSRuntime>();
151              var handler = new MudPopoverHandler((tree) => { }, mock.Object, () => { });
152              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.connect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
153                  .ReturnsAsync(Mock.Of<IJSVoidResult>())
154                  .Verifiable();
155              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.disconnect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
156                  .Returns(new ValueTask<IJSVoidResult>(connectTcs.Task))
157                  .Verifiable();
158              var comp = Context.RenderComponent<MudBadge>(p =>
159              {
160                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
161                  p.Add(x => x.Tag, "my tag");
162              });
163              RenderFragment newRenderFragement = (tree) => { };
164              await handler.Initialize();
165              _ = handler.Detach();
166              var task2 = handler.UpdateFragmentAsync(newRenderFragement, comp.Instance, "my-new-extra-class", "my-new-extra-style:2px", true);
167              var completedTask = await Task.WhenAny(Task.Delay(50), task2);
168              completedTask.Should().NotBe(task2);
169              mock.Verify();
170              mock.VerifyNoOtherCalls();
171          }
172          [Test]
173          public async Task MudPopoverHandler_DetachAndUpdateFragmentConcurrent_UpdateFragmentAsyncShouldRunAfterDetach()
174          {
175              var connectTcs = new TaskCompletionSource<IJSVoidResult>();
176              var mock = new Mock<IJSRuntime>();
177              var handler = new MudPopoverHandler(_ => { }, mock.Object, () => { });
178              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.connect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
179                  .ReturnsAsync(Mock.Of<IJSVoidResult>())
180                  .Verifiable();
181              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.disconnect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
182                  .Returns(new ValueTask<IJSVoidResult>(connectTcs.Task))
183                  .Verifiable();
184              var comp = Context.RenderComponent<MudBadge>(p =>
185              {
186                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
187                  p.Add(x => x.Tag, "my tag");
188              });
189              RenderFragment newRenderFragement = (tree) => { };
190              await handler.Initialize();
191              var task1 = handler.Detach();
192              var task2 = handler.UpdateFragmentAsync(newRenderFragement, comp.Instance, "my-new-extra-class", "my-new-extra-style:2px", true);
193              connectTcs.SetResult(Mock.Of<IJSVoidResult>());
194              await Task.WhenAll(task1, task2);
195              mock.Verify();
196              mock.VerifyNoOtherCalls();
197          }
198          [Test(Description = "Remove in v7")]
199          public void MudPopoverHandler_UpdaterInvokationTest()
200          {
201              RenderFragment initialRenderFragement = (tree) => { };
202              var mock = Mock.Of<IJSRuntime>();
203              var updateCounter = 0;
204              Action updater = () => { updateCounter++; };
205              var handler = new MudPopoverHandler(initialRenderFragement, mock, updater);
206              var comp = Context.RenderComponent<MudBadge>(p =>
207              {
208                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
209                  p.Add(x => x.Tag, "my tag");
210              });
211              RenderFragment newRenderFragement = (tree) => { };
212              for (int i = 0; i < 4; i++)
213              {
214                  handler.UpdateFragment(newRenderFragement, comp.Instance, "my-extra-class", "my-extra-style:2px", i % 2 == 0);
215              }
216              updateCounter.Should().Be(4);
217              handler.UpdateFragment(newRenderFragement, comp.Instance, "my-new-extra-class", "my-new-extra-style:2px", true);
218              updateCounter.Should().Be(5);
219              handler.Class.Should().Be("my-new-extra-class");
220              handler.Style.Should().Be("my-new-extra-style:2px");
221          }
222          [Test]
223          public async Task MudPopoverHandler_UpdaterInvocationAsync()
224          {
225              var mock = Mock.Of<IJSRuntime>();
226              var updateCounter = 0;
227              RenderFragment initialRenderFragment = _ => { };
228              RenderFragment newRenderFragment = _ => { };
229              void Updater() => updateCounter++;
230              var handler = new MudPopoverHandler(initialRenderFragment, mock, Updater);
231              var comp = Context.RenderComponent<MudBadge>(p =>
232              {
233                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
234                  p.Add(x => x.Tag, "my tag");
235              });
236              for (int i = 0; i < 4; i++)
237              {
238                 await handler.UpdateFragmentAsync(newRenderFragment, comp.Instance, "my-extra-class", "my-extra-style:2px", i % 2 == 0);
239              }
240              updateCounter.Should().Be(4);
241              await handler.UpdateFragmentAsync(newRenderFragment, comp.Instance, "my-new-extra-class", "my-new-extra-style:2px", true);
242              updateCounter.Should().Be(5);
243              handler.Class.Should().Be("my-new-extra-class");
244              handler.Style.Should().Be("my-new-extra-style:2px");
245          }
246          [Test]
247          public async Task MudPopoverHandler_InitializeAndDetach()
248          {
249              var handlerId = Guid.NewGuid();
250              RenderFragment renderFragement = (tree) => { };
251              var mock = new Mock<IJSRuntime>();
252              mock.Setup(x =>
253              x.InvokeAsync<IJSVoidResult>(
254                  "mudPopover.connect",
255                  It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
256              mock.Setup(x =>
257              x.InvokeAsync<IJSVoidResult>(
258                  "mudPopover.disconnect",
259                  It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
260              var updateCounter = 0;
261              Action updater = () => { updateCounter++; };
262              var handler = new MudPopoverHandler(renderFragement, mock.Object, updater);
263              handlerId = handler.Id;
264              handler.IsConnected.Should().BeFalse();
265              await handler.Initialize();
266              handler.IsConnected.Should().BeTrue();
267              await handler.Detach();
268              handler.IsConnected.Should().BeFalse();
269          }
270          [Test]
271          public async Task MudPopoverHandler_InitializeAndDetach_DetachThrowsTaskCanceledException()
272          {
273              var handlerId = Guid.NewGuid();
274              RenderFragment renderFragement = (tree) => { };
275              var mock = new Mock<IJSRuntime>();
276              mock.Setup(x =>
277              x.InvokeAsync<IJSVoidResult>(
278                  "mudPopover.connect",
279                  It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
280              mock.Setup(x =>
281              x.InvokeAsync<IJSVoidResult>(
282                  "mudPopover.disconnect",
283                  It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ThrowsAsync(new TaskCanceledException()).Verifiable();
284              var updateCounter = 0;
285              Action updater = () => { updateCounter++; };
286              var handler = new MudPopoverHandler(renderFragement, mock.Object, updater);
287              handlerId = handler.Id;
288              await handler.Initialize();
289              await handler.Detach();
290              handler.IsConnected.Should().BeFalse();
291          }
292          [Test]
293          public async Task MudPopoverHandler_InitializeAndDetach_DetachThrowsNotTaskCanceledException()
294          {
295              var handlerId = Guid.NewGuid();
296              RenderFragment renderFragement = (tree) => { };
297              var mock = new Mock<IJSRuntime>();
298              mock.Setup(x =>
299              x.InvokeAsync<IJSVoidResult>(
300                  "mudPopover.connect",
301                  It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
302              mock.Setup(x =>
303              x.InvokeAsync<IJSVoidResult>(
304                  "mudPopover.disconnect",
305                  It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ThrowsAsync(new InvalidOperationException()).Verifiable();
306              var updateCounter = 0;
307              Action updater = () => { updateCounter++; };
308              var handler = new MudPopoverHandler(renderFragement, mock.Object, updater);
309              handlerId = handler.Id;
310              await handler.Initialize();
311              Assert.ThrowsAsync<InvalidOperationException>(async () => await handler.Detach());
312              handler.IsConnected.Should().BeFalse();
313          }
314          [Test]
315          public async Task MudPopoverHandler_InitializeAndDetachConcurrent_DetachDoesNotRunAtSameTimeAsInitialize()
316          {
317              var connectTcs = new TaskCompletionSource<IJSVoidResult>();
318              var mock = new Mock<IJSRuntime>();
319              var handler = new MudPopoverHandler(_ => { }, mock.Object, () => { });
320              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.connect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
321                  .Returns(new ValueTask<IJSVoidResult>(connectTcs.Task))
322                  .Verifiable();
323              _ = handler.Initialize();
324              var task2 = handler.Detach();
325              var completedTask = await Task.WhenAny(Task.Delay(50), task2);
326              completedTask.Should().NotBe(task2);
327              mock.Verify();
328              mock.VerifyNoOtherCalls();
329          }
330          [Test]
331          public async Task MudPopoverHandler_InitializeAndDetachConcurrent_DetachRunsAfterInitialize()
332          {
333              var connectTcs = new TaskCompletionSource<IJSVoidResult>();
334              var mock = new Mock<IJSRuntime>();
335              var handler = new MudPopoverHandler(_ => { }, mock.Object, () => { });
336              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.connect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
337                  .Returns(new ValueTask<IJSVoidResult>(connectTcs.Task))
338                  .Verifiable();
339              mock.Setup(x => x.InvokeAsync<IJSVoidResult>("mudPopover.disconnect", It.Is<object[]>(y => y.Length == 1 && (Guid)y[0] == handler.Id)))
340                  .ReturnsAsync(Mock.Of<IJSVoidResult>())
341                  .Verifiable();
342              var task1 = handler.Initialize();
343              var task2 = handler.Detach();
344              connectTcs.SetResult(Mock.Of<IJSVoidResult>());
345              await Task.WhenAll(task1, task2);
346              mock.Verify();
347              mock.VerifyNoOtherCalls();
348          }
349          [Test]
350          public async Task MudPopoverHandler_DetachCalledBeforeInitialize_NoInteropShouldOccur()
351          {
352              var mock = new Mock<IJSRuntime>();
353              var handler = new MudPopoverHandler(_ => { }, mock.Object, () => { });
354              await handler.Detach();
355              handler.IsConnected.Should().BeFalse();
356              await handler.Initialize();
357              handler.IsConnected.Should().BeFalse();
358              mock.VerifyNoOtherCalls();
359          }
360          [Test]
361          public void MudPopoverService_Constructor_NoJsInterop()
362          {
363              Assert.Throws<ArgumentNullException>(() => _ = new MudPopoverService(null));
364          }
365          [Test]
366          public async Task MudPopoverService_Constructor_NullOption()
367          {
368              var mock = new Mock<IJSRuntime>();
369              mock.Setup(x =>
370             x.InvokeAsync<IJSVoidResult>(
371                 "mudPopover.initialize",
372                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
373              {
374                  var service = new MudPopoverService(mock.Object, null);
375                  await service.InitializeIfNeeded();
376              }
377              {
378                  var service = new MudPopoverService(mock.Object);
379                  await service.InitializeIfNeeded();
380              }
381              mock.Verify();
382          }
383          [Test]
384          public async Task MudPopoverService_Initialize_Catch_JSDisconnectedException()
385          {
386              var mock = new Mock<IJSRuntime>();
387              mock.Setup(x =>
388             x.InvokeAsync<IJSVoidResult>(
389                 "mudPopover.initialize",
390                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0))).ThrowsAsync(new JSDisconnectedException("JSDisconnectedException")).Verifiable();
391              {
392                  var service = new MudPopoverService(mock.Object);
393                  await service.InitializeIfNeeded();
394              }
395              mock.Verify();
396          }
397          [Test]
398          public async Task MudPopoverService_Initialize_Catch_TaskCanceledException()
399          {
400              var mock = new Mock<IJSRuntime>();
401              mock.Setup(x =>
402             x.InvokeAsync<IJSVoidResult>(
403                 "mudPopover.initialize",
404                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0))).ThrowsAsync(new TaskCanceledException()).Verifiable();
405              {
406                  var service = new MudPopoverService(mock.Object);
407                  await service.InitializeIfNeeded();
408              }
409              mock.Verify();
410          }
411          [Test]
412          public async Task MudPopoverService_Constructor_OptionWithCustomClass()
413          {
414              var mock = new Mock<IJSRuntime>();
415              var option = new PopoverOptions
416              {
417                  ContainerClass = "my-custom-class",
418                  FlipMargin = 12,
419              };
420              var optionMock = new Mock<IOptions<PopoverOptions>>();
421              optionMock.SetupGet(x => x.Value).Returns(option);
422              mock.Setup(x =>
423             x.InvokeAsync<IJSVoidResult>(
424                 "mudPopover.initialize",
425                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "my-custom-class" && (int)x[1] == 12))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
426              var service = new MudPopoverService(mock.Object, optionMock.Object);
427              await service.InitializeIfNeeded();
428              mock.Verify();
429          }
430          [Test]
431          public async Task MudPopoverService_CallInitializeOnlyOnce()
432          {
433              var mock = new Mock<IJSRuntime>();
434              mock.Setup(x =>
435             x.InvokeAsync<IJSVoidResult>(
436                 "mudPopover.initialize",
437                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0))).ReturnsAsync(Mock.Of<IJSVoidResult>(), TimeSpan.FromMilliseconds(300)).Verifiable();
438              Task[] tasks = new Task[5];
439              var service = new MudPopoverService(mock.Object);
440              for (int i = 0; i < 5; i++)
441              {
442                  tasks[i] = Task.Run(async () => await service.InitializeIfNeeded());
443              }
444              Task.WaitAll(tasks);
445              mock.Verify(x =>
446             x.InvokeAsync<IJSVoidResult>(
447                 "mudPopover.initialize",
448                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0)), Times.Once());
449          }
450          [Test]
451          public async Task MudPopoverService_OnlyDisposeIfConnected()
452          {
453              var service = new MudPopoverService(Mock.Of<IJSRuntime>(MockBehavior.Strict));
454              await service.DisposeAsync();
455          }
456          [Test]
457          public async Task MudPopoverService_DisposeAsync()
458          {
459              var mock = new Mock<IJSRuntime>();
460              mock.Setup(x =>
461             x.InvokeAsync<IJSVoidResult>(
462                 "mudPopover.initialize",
463                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
464              mock.Setup(x =>
465              x.InvokeAsync<IJSVoidResult>(
466              "mudPopover.dispose",
467              It.Is<object[]>(x => x.Length == 0))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
468              var service = new MudPopoverService(mock.Object);
469              await service.InitializeIfNeeded();
470              await service.DisposeAsync();
471              mock.Verify();
472          }
473          [Test]
474          public async Task MudPopoverService_DisposeAsync_WithTaskCancelException()
475          {
476              var mock = new Mock<IJSRuntime>();
477              mock.Setup(x =>
478             x.InvokeAsync<IJSVoidResult>(
479                 "mudPopover.initialize",
480                 It.Is<object[]>(x => x.Length == 2 && (string)x[0] == "mudblazor-main-content" && (int)x[1] == 0))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
481              mock.Setup(x =>
482              x.InvokeAsync<IJSVoidResult>(
483              "mudPopover.dispose",
484              It.Is<object[]>(x => x.Length == 0))).ThrowsAsync(new TaskCanceledException()).Verifiable();
485              var service = new MudPopoverService(mock.Object);
486              await service.InitializeIfNeeded();
487              await service.DisposeAsync();
488              mock.Verify();
489          }
490          [Test(Description = "Remove in v7")]
491          public void MudPopoverService_RegisterAndUseHandler()
492          {
493              var service = new MudPopoverService(Mock.Of<IJSRuntime>(MockBehavior.Strict));
494              int fragmentChangedCounter = 0;
495              service.FragmentsChanged += (e, args) =>
496              {
497                  fragmentChangedCounter++;
498              };
499              RenderFragment fragment = (builder) => { };
500              var handler = service.Register(fragment);
501              handler.Should().NotBeNull();
502              fragmentChangedCounter.Should().Be(1);
503              RenderFragment changedFragment = (builder) => { };
504              var comp = Context.RenderComponent<MudBadge>(p =>
505              {
506                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
507                  p.Add(x => x.Tag, "my tag");
508              });
509              handler.UpdateFragment(changedFragment, comp.Instance, "my-class", "my-style", true);
510              fragmentChangedCounter.Should().Be(1);
511          }
512          [Test]
513          public async Task MudPopoverService_RegisterAndUseHandlerAsync()
514          {
515              var service = new MudPopoverService(Mock.Of<IJSRuntime>(MockBehavior.Strict));
516              int fragmentChangedCounter = 0;
517              service.FragmentsChanged += (_, _) =>
518              {
519                  fragmentChangedCounter++;
520              };
521              RenderFragment fragment = _ => { };
522              RenderFragment changedFragment = _ => { };
523              var handler = service.Register(fragment);
524              handler.Should().NotBeNull();
525              fragmentChangedCounter.Should().Be(1);
526              var comp = Context.RenderComponent<MudBadge>(p =>
527              {
528                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
529                  p.Add(x => x.Tag, "my tag");
530              });
531              await handler.UpdateFragmentAsync(changedFragment, comp.Instance, "my-class", "my-style", true);
532              fragmentChangedCounter.Should().Be(1);
533          }
534          [Test]
535          public async Task MudPopoverService_Unregister_NullFragment()
536          {
537              var service = new MudPopoverService(Mock.Of<IJSRuntime>(MockBehavior.Strict));
538              var result = await service.Unregister(null);
539              result.Should().BeFalse();
540          }
541          [Test]
542          public async Task MudPopoverService_Unregister_HandlerNotFound()
543          {
544              var service = new MudPopoverService(Mock.Of<IJSRuntime>(MockBehavior.Strict));
545              var handler = new MudPopoverHandler((tree) => { }, Mock.Of<IJSRuntime>(MockBehavior.Strict), () => { });
546              var result = await service.Unregister(handler);
547              result.Should().BeFalse();
548          }
549          [Test]
550          public async Task MudPopoverService_Unregister_NotConnected()
551          {
552              var service = new MudPopoverService(Mock.Of<IJSRuntime>(MockBehavior.Strict));
553              RenderFragment fragment = (builder) => { };
554              var handler = service.Register(fragment);
555              var result = await service.Unregister(handler);
556              result.Should().BeTrue();
557          }
558          [Test]
559          public async Task MudPopoverService_Unregister()
560          {
561              var handlerId = Guid.NewGuid();
562              var mock = new Mock<IJSRuntime>();
563              mock.Setup(x =>
564             x.InvokeAsync<IJSVoidResult>(
565                 "mudPopover.connect",
566                 It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
567              mock.Setup(x =>
568              x.InvokeAsync<IJSVoidResult>(
569             "mudPopover.disconnect",
570             It.Is<object[]>(x => x.Length == 1 && (Guid)x[0] == handlerId))).ReturnsAsync(Mock.Of<IJSVoidResult>).Verifiable();
571              var service = new MudPopoverService(mock.Object);
572              await service.InitializeIfNeeded();
573              RenderFragment fragment = (builder) => { };
574              var handler = service.Register(fragment);
575              handlerId = handler.Id;
576              await handler.Initialize();
577              int fragmentChangedCounter = 0;
578              service.FragmentsChanged += (e, args) =>
579              {
580                  fragmentChangedCounter++;
581              };
582              var result = await service.Unregister(handler);
583              result.Should().BeTrue();
584              fragmentChangedCounter.Should().Be(1);
585              var secondResult = await service.Unregister(handler);
586              secondResult.Should().BeFalse();
587              mock.Verify();
588          }
589          [Test]
590          public void MudPopover_DefaultValues()
591          {
592              var popover = new MudPopover();
593              popover.MaxHeight.Should().BeNull();
594              popover.Paper.Should().BeTrue();
595              popover.Elevation.Should().Be(8);
596              popover.Square.Should().BeFalse();
597              popover.Open.Should().BeFalse();
598              popover.Fixed.Should().BeFalse();
599              popover.AnchorOrigin.Should().Be(Origin.TopLeft);
600              popover.TransformOrigin.Should().Be(Origin.TopLeft);
601              popover.RelativeWidth.Should().BeFalse();
602              popover.OverflowBehavior.Should().Be(OverflowBehavior.FlipOnOpen);
603              popover.Duration.Should().Be(251);
604          }
605          [Test]
606          public async Task MudPopover_OpenAndClose()
607          {
608              var comp = Context.RenderComponent<PopoverTest>();
609              var provider = comp.Find(".mud-popover-provider");
610              provider.Children.Should().ContainSingle();
611              var popoverNode = comp.Find(".popoverparent").Children[1];
612              popoverNode.Id.Should().StartWith("popover-");
613              var handlerId = Guid.Parse(popoverNode.Id.Substring(8));
614              handlerId.Should().NotBe(Guid.Empty);
615              provider.Children.Should().ContainSingle();
616              provider.FirstElementChild.Id.Should().Be($"popovercontent-{handlerId}");
617              provider.FirstElementChild.Children.Should().BeEmpty();
618              await comp.Instance.Open();
619              provider.FirstElementChild.Children.Should().ContainSingle();
620              provider.FirstElementChild.Children[0].TextContent.Should().Be("Popover content");
621              await comp.Instance.Close();
622              provider.FirstElementChild.Children.Should().BeEmpty();
623          }
624          [Test]
625          public void MudPopover_Property_MaxHeight()
626          {
627              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(x => x.MaxHeight, 100));
628              var popoverElement = comp.Find(".test-popover-content").ParentElement;
629              popoverElement.GetAttribute("style").Split(';', StringSplitOptions.RemoveEmptyEntries).Should().Contain(new[] { "max-height:100px", "my-custom-style:3px" });
630          }
631          [Test]
632          public void MudPopover_Property_TransitionDuration()
633          {
634              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(x => x.Duration, 100));
635              var popoverElement = comp.Find(".test-popover-content").ParentElement;
636              popoverElement.GetAttribute("style").Split(';', StringSplitOptions.RemoveEmptyEntries).Should().Contain(new[] { "transition-duration:100ms" });
637          }
638          [Test]
639          public void MudPopover_Property_Fixed()
640          {
641              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(
642                  x => x.Fixed, true));
643              var popoverElement = comp.Find(".test-popover-content").ParentElement;
644              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", "mud-popover-fixed", "my-custom-class" });
645          }
646          [Test]
647          public void MudPopover_Property_RelativeWidth()
648          {
649              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(
650                  x => x.RelativeWidth, true));
651              var popoverElement = comp.Find(".test-popover-content").ParentElement;
652              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", "mud-popover-relative-width", "my-custom-class" });
653          }
654          [Test]
655          public void MudPopover_Property_Paper()
656          {
657              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(
658                  x => x.Paper, true));
659              var popoverElement = comp.Find(".test-popover-content").ParentElement;
660              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", "mud-paper", "mud-elevation-8", "my-custom-class" });
661          }
662          [Test]
663          public void MudPopover_Property_PaperAndSqaure()
664          {
665              var comp = Context.RenderComponent<PopoverPropertyTest>(p =>
666              {
667                  p.Add(x => x.Paper, true);
668                  p.Add(x => x.Square, true);
669              });
670              var popoverElement = comp.Find(".test-popover-content").ParentElement;
671              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", "mud-paper-square", "mud-elevation-8", "my-custom-class" });
672          }
673          [Test]
674          public void MudPopover_Property_Elevation()
675          {
676              var comp = Context.RenderComponent<PopoverPropertyTest>(p =>
677              {
678                  p.Add(x => x.Paper, true);
679                  p.Add(x => x.Elevation, 10);
680              });
681              var popoverElement = comp.Find(".test-popover-content").ParentElement;
682              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", "mud-paper", "mud-elevation-10", "my-custom-class" });
683          }
684          [Test]
685          [TestCase(Origin.BottomCenter, "bottom-center")]
686          [TestCase(Origin.BottomLeft, "bottom-left")]
687          [TestCase(Origin.BottomRight, "bottom-right")]
688          [TestCase(Origin.CenterCenter, "center-center")]
689          [TestCase(Origin.CenterLeft, "center-left")]
690          [TestCase(Origin.CenterRight, "center-right")]
691          [TestCase(Origin.TopCenter, "top-center")]
692          [TestCase(Origin.TopLeft, "top-left")]
693          [TestCase(Origin.TopRight, "top-right")]
694          public void MudPopover_Property_TransformOrigin(Origin transformOrigin, string expectedClass)
695          {
696              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(
697                  x => x.TransformOrigin, transformOrigin));
698              var popoverElement = comp.Find(".test-popover-content").ParentElement;
699              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", $"mud-popover-{expectedClass}", "my-custom-class" });
700          }
701          [Test]
702          [TestCase(Origin.BottomCenter, "bottom-center")]
703          [TestCase(Origin.BottomLeft, "bottom-left")]
704          [TestCase(Origin.BottomRight, "bottom-right")]
705          [TestCase(Origin.CenterCenter, "center-center")]
706          [TestCase(Origin.CenterLeft, "center-left")]
707          [TestCase(Origin.CenterRight, "center-right")]
708          [TestCase(Origin.TopCenter, "top-center")]
709          [TestCase(Origin.TopLeft, "top-left")]
710          [TestCase(Origin.TopRight, "top-right")]
711          public void MudPopover_Property_AnchorOrigin(Origin anchorOrigin, string expectedClass)
712          {
713              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(
714                  x => x.AnchorOrigin, anchorOrigin));
715              var popoverElement = comp.Find(".test-popover-content").ParentElement;
716              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", $"mud-popover-anchor-{expectedClass}", "my-custom-class" });
717          }
718          [Test]
719          [TestCase(OverflowBehavior.FlipNever, "flip-never")]
720          [TestCase(OverflowBehavior.FlipOnOpen, "flip-onopen")]
721          [TestCase(OverflowBehavior.FlipAlways, "flip-always")]
722          public void MudPopover_Property_OverflowBehavior(OverflowBehavior overflowBehavior, string expectedClass)
723          {
724              var comp = Context.RenderComponent<PopoverPropertyTest>(p => p.Add(
725                  x => x.OverflowBehavior, overflowBehavior));
726              var popoverElement = comp.Find(".test-popover-content").ParentElement;
727              popoverElement.ClassList.Should().Contain(new[] { "mud-popover-open", $"mud-popover-overflow-{expectedClass}", "my-custom-class" });
728          }
729          [Test]
730          public async Task MudPopover_WithDynamicContent()
731          {
732              var comp = Context.RenderComponent<PopoverComplexContent>();
733              var dynamicContentElement = comp.Find(".dynamic-content");
734              dynamicContentElement.ChildNodes.Should().BeEmpty();
735              await comp.Instance.AddRow();
736              dynamicContentElement.ChildNodes.Should().ContainSingle();
737              dynamicContentElement.ChildNodes[0].TextContent.Should().Be("Popover content 0");
738              await comp.Instance.AddRow();
739              dynamicContentElement.ChildNodes.Should().HaveCount(2);
740              dynamicContentElement.ChildNodes[0].TextContent.Should().Be("Popover content 0");
741              dynamicContentElement.ChildNodes[1].TextContent.Should().Be("Popover content 1");
742              await comp.Instance.AddRow();
743              dynamicContentElement.ChildNodes.Should().HaveCount(3);
744              dynamicContentElement.ChildNodes[0].TextContent.Should().Be("Popover content 0");
745              dynamicContentElement.ChildNodes[1].TextContent.Should().Be("Popover content 1");
746              dynamicContentElement.ChildNodes[2].TextContent.Should().Be("Popover content 2");
747          }
748          [Test]
749          public void MudPopoverProvider_DefaultValue()
750          {
751              var provider = new MudPopoverProvider();
752              provider.IsEnabled.Should().BeTrue();
753          }
754          [Test]
755          public void MudPopoverProvider_RenderElementsBasedOnEnableState()
756          {
757              var comp = Context.RenderComponent<PopoverProviderTest>(p => p.Add(x => x.ProviderIsEnabled, true));
758              comp.Find("#my-content").TextContent.Should().Be("Popover content");
759              for (int i = 0; i < 3; i++)
760              {
761                  comp.SetParametersAndRender(p => p.Add(x => x.ProviderIsEnabled, false));
762                  Assert.Throws<ElementNotFoundException>(() => comp.Find("#my-content"));
763                  comp.SetParametersAndRender(p => p.Add(x => x.ProviderIsEnabled, true));
764                  comp.Find("#my-content").TextContent.Should().Be("Popover content");
765              }
766          }
767          [Test]
768          public void MudPopoverProvider_NoRenderWhenIsEnabledIsFalse()
769          {
770              var comp = Context.RenderComponent<PopoverProviderTest>(p => p.Add(x => x.ProviderIsEnabled, false));
771              Assert.Throws<ElementNotFoundException>(() => comp.Find("#my-content"));
772          }
773          [TestCase(false)]
774          [TestCase(true)]
775          public async Task MudPopoverProvider_ThrowOnDuplicate(bool ThrowOnDuplicateProvider)
776          {
777              var options = new PopoverOptions
778              {
779                  ThrowOnDuplicateProvider = ThrowOnDuplicateProvider
780              };
781              Context.Services.Configure<PopoverOptions>(x => x.ThrowOnDuplicateProvider = ThrowOnDuplicateProvider);
782              Context.JSInterop.Setup<int>("mudpopoverHelper.countProviders").SetResult(ThrowOnDuplicateProvider == true ? 2 : 1);
783              if (ThrowOnDuplicateProvider == true)
784              {
785                  var ex = Assert.Throws<InvalidOperationException>(() => Context.RenderComponent<PopoverDuplicationTest>());
786                  ex.Message.Should().StartWith("Duplicate MudPopoverProvider detected");
787              }
788              else
789              {
790                  var comp = Context.RenderComponent<PopoverDuplicationTest>();
791                  await comp.Instance.Open();
792                  await comp.Instance.Close();
793              }
794          }
795      }
796  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-OutputManagerL0.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-PopoverTests.cs</div>
                <div class="column column_space"><pre><code>619                  Process("john.doe@contoso.com");
620                  Process("t@t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.c%20");
621                  Process("jane.doe@contoso.com");
622                  Process("ERR: this error");
623                  Assert.Equal(3, _issues.Count);
624                  Assert.Equal("john.doe@contoso.com", _issues[0].Item1.Message);
625                  Assert.Contains("Removing issue matcher 'email'", _issues[1].Item1.Message);
626                  Assert.Equal("this error", _issues[2].Item1.Message);
627                  Assert.Equal(0, _commands.Count);
628                  Assert.Equal(2, _messages.Where(x => x.StartsWith("##[debug]Timeout processing issue matcher")).Count());
629                  Assert.Equal(1, _messages.Where(x => x.Equals("t@t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.t.c%20")).Count());
630                  Assert.Equal(1, _messages.Where(x => x.StartsWith("jane.doe@contoso.com")).Count());
631              }
632          }
633          [Fact]
</pre></code></div>
                <div class="column column_space"><pre><code>64              var comp = Context.RenderComponent<MudBadge>(p =>
65              {
66                  p.Add(x => x.UserAttributes, new Dictionary<string, object> { { "myprop1", "myValue1" } });
67                  p.Add(x => x.Tag, "my tag");
68              });
69              handler.SetComponentBaseParameters(comp.Instance, "my-extra-class", "my-extra-style:2px", true);
70              handler.Id.Should().NotBe(default(Guid));
71              handler.UserAttributes.Should().BeEquivalentTo(new Dictionary<string, object> { { "myprop1", "myValue1" } });
72              handler.Class.Should().Be("my-extra-class");
73              handler.Tag.Should().Be("my tag");
74              handler.Fragment.Should().BeSameAs(renderFragement);
75              handler.IsConnected.Should().BeFalse();
76              handler.ShowContent.Should().BeTrue();
77          }
78          [Test(Description = "Remove in v7")]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    