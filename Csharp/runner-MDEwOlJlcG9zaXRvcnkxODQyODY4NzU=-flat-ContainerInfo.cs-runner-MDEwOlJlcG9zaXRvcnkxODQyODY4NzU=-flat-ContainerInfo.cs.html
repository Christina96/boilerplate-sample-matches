
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 175, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerInfo.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using GitHub.Runner.Common;
5  using GitHub.Runner.Sdk;
6  using Pipelines = GitHub.DistributedTask.Pipelines;
7  using System.Collections.ObjectModel;
8  using System.Linq;
9  namespace GitHub.Runner.Worker.Container
10  {
11      public class ContainerInfo
12      {
13          private List<MountVolume> _mountVolumes;
14          private IDictionary<string, string> _userPortMappings;
15          private List<PortMapping> _portMappings;
16          private IDictionary<string, string> _environmentVariables;
17          private List<PathMapping> _pathMappings = new();
18          public ContainerInfo()
19          {
20          }
21          public ContainerInfo(IHostContext hostContext)
22          {
23              UpdateWebProxyEnv(hostContext.WebProxy);
24          }
25          public ContainerInfo(IHostContext hostContext, Pipelines.JobContainer container, bool isJobContainer = true, string networkAlias = null)
26          {
27              this.ContainerName = container.Alias;
28              string containerImage = container.Image;
29              ArgUtil.NotNullOrEmpty(containerImage, nameof(containerImage));
30              this.ContainerImage = containerImage;
31              this.ContainerDisplayName = $"{container.Alias}_{Pipelines.Validation.NameValidation.Sanitize(containerImage)}_{Guid.NewGuid().ToString("N").Substring(0, 6)}";
32              this.ContainerCreateOptions = container.Options;
33              _environmentVariables = container.Environment;
34              this.IsJobContainer = isJobContainer;
35              this.ContainerNetworkAlias = networkAlias;
36              this.RegistryAuthUsername = container.Credentials?.Username;
37              this.RegistryAuthPassword = container.Credentials?.Password;
38              this.RegistryServer = DockerUtil.ParseRegistryHostnameFromImageName(this.ContainerImage);
39  #if OS_WINDOWS
40              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Work), "C:\\__w"));
41              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Tools), "C:\\__t")); 
42              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Externals), "C:\\__e"));
43  #else
44              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Work), "/__w"));
45              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Tools), "/__t")); 
46              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Externals), "/__e"));
47              if (this.IsJobContainer)
48              {
49                  this.MountVolumes.Add(new MountVolume("/var/run/docker.sock", "/var/run/docker.sock"));
50              }
51  #endif
52              if (container.Ports?.Count > 0)
53              {
54                  foreach (var port in container.Ports)
55                  {
56                      UserPortMappings[port] = port;
57                  }
58              }
59              if (container.Volumes?.Count > 0)
60              {
61                  foreach (var volume in container.Volumes)
62                  {
63                      MountVolumes.Add(new MountVolume(volume, isUserProvided: true));
64                  }
65              }
66              UpdateWebProxyEnv(hostContext.WebProxy);
67          }
68          public string ContainerId { get; set; }
69          public string ContainerDisplayName { get; set; }
70          public string ContainerNetwork { get; set; }
71          public string ContainerNetworkAlias { get; set; }
72          public string ContainerImage { get; set; }
73          public string ContainerName { get; set; }
74          public string ContainerEntryPointArgs { get; set; }
75          public string ContainerEntryPoint { get; set; }
76          public string ContainerWorkDirectory { get; set; }
77          public string ContainerCreateOptions { get; private set; }
78          public string ContainerRuntimePath { get; set; }
79          public string RegistryServer { get; set; }
80          public string RegistryAuthUsername { get; set; }
81          public string RegistryAuthPassword { get; set; }
82          public bool IsJobContainer { get; set; }
83          public bool IsAlpine { get; set; }
84          public bool FailedInitialization { get; set; }
85          public IDictionary<string, string> ContainerEnvironmentVariables
86          {
87              get
88              {
89                  if (_environmentVariables == null)
90                  {
91                      _environmentVariables = new Dictionary<string, string>();
92                  }
93                  return _environmentVariables;
94              }
95          }
96          public ReadOnlyCollection<MountVolume> UserMountVolumes
97          {
98              get
99              {
100                  return MountVolumes.Where(v => !string.IsNullOrEmpty(v.UserProvidedValue)).ToList().AsReadOnly();
101              }
102          }
103          public ReadOnlyCollection<MountVolume> SystemMountVolumes
104          {
105              get
106              {
107                  return MountVolumes.Where(v => string.IsNullOrEmpty(v.UserProvidedValue)).ToList().AsReadOnly();
108              }
109          }
110          public List<MountVolume> MountVolumes
111          {
112              get
113              {
114                  if (_mountVolumes == null)
115                  {
116                      _mountVolumes = new List<MountVolume>();
117                  }
118                  return _mountVolumes;
119              }
120          }
121          public IDictionary<string, string> UserPortMappings
122          {
123              get
124              {
125                  if (_userPortMappings == null)
126                  {
127                      _userPortMappings = new Dictionary<string, string>();
128                  }
129                  return _userPortMappings;
130              }
131          }
132          public List<PortMapping> PortMappings
133          {
134              get
135              {
136                  if (_portMappings == null)
137                  {
138                      _portMappings = new List<PortMapping>();
139                  }
140                  return _portMappings;
141              }
142          }
143          public string TranslateToContainerPath(string path)
144          {
145              if (!string.IsNullOrEmpty(path))
146              {
147                  foreach (var mapping in _pathMappings)
148                  {
149  #if OS_WINDOWS
150                      if (string.Equals(path, mapping.HostPath, StringComparison.OrdinalIgnoreCase))
151                      {
152                          return mapping.ContainerPath;
153                      }
154                      if (path.StartsWith(mapping.HostPath + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase) ||
155                          path.StartsWith(mapping.HostPath + Path.AltDirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
156                      {
157                          return mapping.ContainerPath + path.Remove(0, mapping.HostPath.Length);
158                      }
159  #else
160                      if (string.Equals(path, mapping.HostPath))
161                      {
162                          return mapping.ContainerPath;
163                      }
164                      if (path.StartsWith(mapping.HostPath + Path.DirectorySeparatorChar))
165                      {
166                          return mapping.ContainerPath + path.Remove(0, mapping.HostPath.Length);
167                      }
168  #endif
169                  }
170              }
171              return path;
172          }
<span onclick='openModal()' class='match'>173          public string TranslateToHostPath(string path)
174          {
175              if (!string.IsNullOrEmpty(path))
176              {
177                  foreach (var mapping in _pathMappings)
178                  {
179  #if OS_WINDOWS
180                      if (string.Equals(path, mapping.ContainerPath, StringComparison.OrdinalIgnoreCase))
181                      {
182                          return mapping.HostPath;
183                      }
184                      if (path.StartsWith(mapping.ContainerPath + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase) ||
185                          path.StartsWith(mapping.ContainerPath + Path.AltDirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
186                      {
187                          return mapping.HostPath + path.Remove(0, mapping.ContainerPath.Length);
188                      }
189  #else
190                      if (string.Equals(path, mapping.ContainerPath))
191                      {
192                          return mapping.HostPath;
193                      }
194                      if (path.StartsWith(mapping.ContainerPath + Path.DirectorySeparatorChar))
195                      {
196                          return mapping.HostPath + path.Remove(0, mapping.ContainerPath.Length);
197                      }
198  #endif
199                  }
200              }
201              return path;
202          }
203          public void AddPortMappings(List<PortMapping> portMappings)
</span>204          {
205              foreach (var port in portMappings)
206              {
207                  PortMappings.Add(port);
208              }
209          }
210          public void AddPortMappings(IDictionary<string, string> portMappings)
211          {
212              foreach (var pair in portMappings)
213              {
214                  PortMappings.Add(new PortMapping(pair.Key, pair.Value));
215              }
216          }
217          public void AddPathTranslateMapping(string hostCommonPath, string containerCommonPath)
218          {
219              _pathMappings.Insert(0, new PathMapping(hostCommonPath, containerCommonPath));
220          }
221          private void UpdateWebProxyEnv(RunnerWebProxy webProxy)
222          {
223              if (!String.IsNullOrEmpty(webProxy.HttpProxyAddress))
224              {
225                  ContainerEnvironmentVariables.TryAdd("HTTP_PROXY", webProxy.HttpProxyAddress);
226                  ContainerEnvironmentVariables.TryAdd("http_proxy", webProxy.HttpProxyAddress);
227              }
228              if (!String.IsNullOrEmpty(webProxy.HttpsProxyAddress))
229              {
230                  ContainerEnvironmentVariables.TryAdd("HTTPS_PROXY", webProxy.HttpsProxyAddress);
231                  ContainerEnvironmentVariables.TryAdd("https_proxy", webProxy.HttpsProxyAddress);
232              }
233              if (!String.IsNullOrEmpty(webProxy.NoProxyString))
234              {
235                  ContainerEnvironmentVariables.TryAdd("NO_PROXY", webProxy.NoProxyString);
236                  ContainerEnvironmentVariables.TryAdd("no_proxy", webProxy.NoProxyString);
237              }
238          }
239      }
240      public class MountVolume
241      {
242          public string UserProvidedValue { get; set; }
243          public MountVolume(string sourceVolumePath, string targetVolumePath, bool readOnly = false)
244          {
245              this.SourceVolumePath = sourceVolumePath;
246              this.TargetVolumePath = targetVolumePath;
247              this.ReadOnly = readOnly;
248          }
249          public MountVolume(string fromString)
250          {
251              ParseVolumeString(fromString);
252          }
253          public MountVolume(string fromString, bool isUserProvided)
254          {
255              ParseVolumeString(fromString);
256              if (isUserProvided)
257              {
258                  UserProvidedValue = fromString;
259              }
260          }
261          private void ParseVolumeString(string volume)
262          {
263              var volumeSplit = volume.Split(":");
264              if (volumeSplit.Length == 3)
265              {
266                  SourceVolumePath = volumeSplit[0];
267                  TargetVolumePath = volumeSplit[1];
268                  ReadOnly = String.Equals(volumeSplit[2], "ro", StringComparison.OrdinalIgnoreCase);
269              }
270              else if (volumeSplit.Length == 2)
271              {
272                  if (String.Equals(volumeSplit[1], "ro", StringComparison.OrdinalIgnoreCase))
273                  {
274                      TargetVolumePath = volumeSplit[0];
275                      ReadOnly = true;
276                  }
277                  else
278                  {
279                      SourceVolumePath = volumeSplit[0];
280                      TargetVolumePath = volumeSplit[1];
281                      ReadOnly = false;
282                  }
283              }
284              else
285              {
286                  TargetVolumePath = volume;
287                  ReadOnly = false;
288              }
289          }
290          public string SourceVolumePath { get; set; }
291          public string TargetVolumePath { get; set; }
292          public bool ReadOnly { get; set; }
293      }
294      public class PortMapping
295      {
296          public PortMapping(string hostPort, string containerPort)
297          {
298              this.HostPort = hostPort;
299              this.ContainerPort = containerPort;
300          }
301          public PortMapping(string hostPort, string containerPort, string protocol)
302          {
303              this.HostPort = hostPort;
304              this.ContainerPort = containerPort;
305              this.Protocol = protocol;
306          }
307          public string HostPort { get; set; }
308          public string ContainerPort { get; set; }
309          public string Protocol { get; set; }
310      }
311      public class DockerVersion
312      {
313          public DockerVersion(Version serverVersion, Version clientVersion)
314          {
315              this.ServerVersion = serverVersion;
316              this.ClientVersion = clientVersion;
317          }
318          public Version ServerVersion { get; set; }
319          public Version ClientVersion { get; set; }
320      }
321      public class PathMapping
322      {
323          public PathMapping(string hostPath, string containerPath)
324          {
325              this.HostPath = hostPath;
326              this.ContainerPath = containerPath;
327          }
328          public string HostPath { get; set; }
329          public string ContainerPath { get; set; }
330      }
331  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerInfo.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using GitHub.Runner.Common;
5  using GitHub.Runner.Sdk;
6  using Pipelines = GitHub.DistributedTask.Pipelines;
7  using System.Collections.ObjectModel;
8  using System.Linq;
9  namespace GitHub.Runner.Worker.Container
10  {
11      public class ContainerInfo
12      {
13          private List<MountVolume> _mountVolumes;
14          private IDictionary<string, string> _userPortMappings;
15          private List<PortMapping> _portMappings;
16          private IDictionary<string, string> _environmentVariables;
17          private List<PathMapping> _pathMappings = new();
18          public ContainerInfo()
19          {
20          }
21          public ContainerInfo(IHostContext hostContext)
22          {
23              UpdateWebProxyEnv(hostContext.WebProxy);
24          }
25          public ContainerInfo(IHostContext hostContext, Pipelines.JobContainer container, bool isJobContainer = true, string networkAlias = null)
26          {
27              this.ContainerName = container.Alias;
28              string containerImage = container.Image;
29              ArgUtil.NotNullOrEmpty(containerImage, nameof(containerImage));
30              this.ContainerImage = containerImage;
31              this.ContainerDisplayName = $"{container.Alias}_{Pipelines.Validation.NameValidation.Sanitize(containerImage)}_{Guid.NewGuid().ToString("N").Substring(0, 6)}";
32              this.ContainerCreateOptions = container.Options;
33              _environmentVariables = container.Environment;
34              this.IsJobContainer = isJobContainer;
35              this.ContainerNetworkAlias = networkAlias;
36              this.RegistryAuthUsername = container.Credentials?.Username;
37              this.RegistryAuthPassword = container.Credentials?.Password;
38              this.RegistryServer = DockerUtil.ParseRegistryHostnameFromImageName(this.ContainerImage);
39  #if OS_WINDOWS
40              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Work), "C:\\__w"));
41              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Tools), "C:\\__t")); 
42              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Externals), "C:\\__e"));
43  #else
44              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Work), "/__w"));
45              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Tools), "/__t")); 
46              _pathMappings.Add(new PathMapping(hostContext.GetDirectory(WellKnownDirectory.Externals), "/__e"));
47              if (this.IsJobContainer)
48              {
49                  this.MountVolumes.Add(new MountVolume("/var/run/docker.sock", "/var/run/docker.sock"));
50              }
51  #endif
52              if (container.Ports?.Count > 0)
53              {
54                  foreach (var port in container.Ports)
55                  {
56                      UserPortMappings[port] = port;
57                  }
58              }
59              if (container.Volumes?.Count > 0)
60              {
61                  foreach (var volume in container.Volumes)
62                  {
63                      MountVolumes.Add(new MountVolume(volume, isUserProvided: true));
64                  }
65              }
66              UpdateWebProxyEnv(hostContext.WebProxy);
67          }
68          public string ContainerId { get; set; }
69          public string ContainerDisplayName { get; set; }
70          public string ContainerNetwork { get; set; }
71          public string ContainerNetworkAlias { get; set; }
72          public string ContainerImage { get; set; }
73          public string ContainerName { get; set; }
74          public string ContainerEntryPointArgs { get; set; }
75          public string ContainerEntryPoint { get; set; }
76          public string ContainerWorkDirectory { get; set; }
77          public string ContainerCreateOptions { get; private set; }
78          public string ContainerRuntimePath { get; set; }
79          public string RegistryServer { get; set; }
80          public string RegistryAuthUsername { get; set; }
81          public string RegistryAuthPassword { get; set; }
82          public bool IsJobContainer { get; set; }
83          public bool IsAlpine { get; set; }
84          public bool FailedInitialization { get; set; }
85          public IDictionary<string, string> ContainerEnvironmentVariables
86          {
87              get
88              {
89                  if (_environmentVariables == null)
90                  {
91                      _environmentVariables = new Dictionary<string, string>();
92                  }
93                  return _environmentVariables;
94              }
95          }
96          public ReadOnlyCollection<MountVolume> UserMountVolumes
97          {
98              get
99              {
100                  return MountVolumes.Where(v => !string.IsNullOrEmpty(v.UserProvidedValue)).ToList().AsReadOnly();
101              }
102          }
103          public ReadOnlyCollection<MountVolume> SystemMountVolumes
104          {
105              get
106              {
107                  return MountVolumes.Where(v => string.IsNullOrEmpty(v.UserProvidedValue)).ToList().AsReadOnly();
108              }
109          }
110          public List<MountVolume> MountVolumes
111          {
112              get
113              {
114                  if (_mountVolumes == null)
115                  {
116                      _mountVolumes = new List<MountVolume>();
117                  }
118                  return _mountVolumes;
119              }
120          }
121          public IDictionary<string, string> UserPortMappings
122          {
123              get
124              {
125                  if (_userPortMappings == null)
126                  {
127                      _userPortMappings = new Dictionary<string, string>();
128                  }
129                  return _userPortMappings;
130              }
131          }
132          public List<PortMapping> PortMappings
133          {
134              get
135              {
136                  if (_portMappings == null)
137                  {
138                      _portMappings = new List<PortMapping>();
139                  }
140                  return _portMappings;
141              }
142          }
<span onclick='openModal()' class='match'>143          public string TranslateToContainerPath(string path)
144          {
145              if (!string.IsNullOrEmpty(path))
146              {
147                  foreach (var mapping in _pathMappings)
148                  {
149  #if OS_WINDOWS
150                      if (string.Equals(path, mapping.HostPath, StringComparison.OrdinalIgnoreCase))
151                      {
152                          return mapping.ContainerPath;
153                      }
154                      if (path.StartsWith(mapping.HostPath + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase) ||
155                          path.StartsWith(mapping.HostPath + Path.AltDirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
156                      {
157                          return mapping.ContainerPath + path.Remove(0, mapping.HostPath.Length);
158                      }
159  #else
160                      if (string.Equals(path, mapping.HostPath))
161                      {
162                          return mapping.ContainerPath;
163                      }
164                      if (path.StartsWith(mapping.HostPath + Path.DirectorySeparatorChar))
165                      {
166                          return mapping.ContainerPath + path.Remove(0, mapping.HostPath.Length);
167                      }
168  #endif
169                  }
170              }
171              return path;
172          }
173          public string TranslateToHostPath(string path)
</span>174          {
175              if (!string.IsNullOrEmpty(path))
176              {
177                  foreach (var mapping in _pathMappings)
178                  {
179  #if OS_WINDOWS
180                      if (string.Equals(path, mapping.ContainerPath, StringComparison.OrdinalIgnoreCase))
181                      {
182                          return mapping.HostPath;
183                      }
184                      if (path.StartsWith(mapping.ContainerPath + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase) ||
185                          path.StartsWith(mapping.ContainerPath + Path.AltDirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
186                      {
187                          return mapping.HostPath + path.Remove(0, mapping.ContainerPath.Length);
188                      }
189  #else
190                      if (string.Equals(path, mapping.ContainerPath))
191                      {
192                          return mapping.HostPath;
193                      }
194                      if (path.StartsWith(mapping.ContainerPath + Path.DirectorySeparatorChar))
195                      {
196                          return mapping.HostPath + path.Remove(0, mapping.ContainerPath.Length);
197                      }
198  #endif
199                  }
200              }
201              return path;
202          }
203          public void AddPortMappings(List<PortMapping> portMappings)
204          {
205              foreach (var port in portMappings)
206              {
207                  PortMappings.Add(port);
208              }
209          }
210          public void AddPortMappings(IDictionary<string, string> portMappings)
211          {
212              foreach (var pair in portMappings)
213              {
214                  PortMappings.Add(new PortMapping(pair.Key, pair.Value));
215              }
216          }
217          public void AddPathTranslateMapping(string hostCommonPath, string containerCommonPath)
218          {
219              _pathMappings.Insert(0, new PathMapping(hostCommonPath, containerCommonPath));
220          }
221          private void UpdateWebProxyEnv(RunnerWebProxy webProxy)
222          {
223              if (!String.IsNullOrEmpty(webProxy.HttpProxyAddress))
224              {
225                  ContainerEnvironmentVariables.TryAdd("HTTP_PROXY", webProxy.HttpProxyAddress);
226                  ContainerEnvironmentVariables.TryAdd("http_proxy", webProxy.HttpProxyAddress);
227              }
228              if (!String.IsNullOrEmpty(webProxy.HttpsProxyAddress))
229              {
230                  ContainerEnvironmentVariables.TryAdd("HTTPS_PROXY", webProxy.HttpsProxyAddress);
231                  ContainerEnvironmentVariables.TryAdd("https_proxy", webProxy.HttpsProxyAddress);
232              }
233              if (!String.IsNullOrEmpty(webProxy.NoProxyString))
234              {
235                  ContainerEnvironmentVariables.TryAdd("NO_PROXY", webProxy.NoProxyString);
236                  ContainerEnvironmentVariables.TryAdd("no_proxy", webProxy.NoProxyString);
237              }
238          }
239      }
240      public class MountVolume
241      {
242          public string UserProvidedValue { get; set; }
243          public MountVolume(string sourceVolumePath, string targetVolumePath, bool readOnly = false)
244          {
245              this.SourceVolumePath = sourceVolumePath;
246              this.TargetVolumePath = targetVolumePath;
247              this.ReadOnly = readOnly;
248          }
249          public MountVolume(string fromString)
250          {
251              ParseVolumeString(fromString);
252          }
253          public MountVolume(string fromString, bool isUserProvided)
254          {
255              ParseVolumeString(fromString);
256              if (isUserProvided)
257              {
258                  UserProvidedValue = fromString;
259              }
260          }
261          private void ParseVolumeString(string volume)
262          {
263              var volumeSplit = volume.Split(":");
264              if (volumeSplit.Length == 3)
265              {
266                  SourceVolumePath = volumeSplit[0];
267                  TargetVolumePath = volumeSplit[1];
268                  ReadOnly = String.Equals(volumeSplit[2], "ro", StringComparison.OrdinalIgnoreCase);
269              }
270              else if (volumeSplit.Length == 2)
271              {
272                  if (String.Equals(volumeSplit[1], "ro", StringComparison.OrdinalIgnoreCase))
273                  {
274                      TargetVolumePath = volumeSplit[0];
275                      ReadOnly = true;
276                  }
277                  else
278                  {
279                      SourceVolumePath = volumeSplit[0];
280                      TargetVolumePath = volumeSplit[1];
281                      ReadOnly = false;
282                  }
283              }
284              else
285              {
286                  TargetVolumePath = volume;
287                  ReadOnly = false;
288              }
289          }
290          public string SourceVolumePath { get; set; }
291          public string TargetVolumePath { get; set; }
292          public bool ReadOnly { get; set; }
293      }
294      public class PortMapping
295      {
296          public PortMapping(string hostPort, string containerPort)
297          {
298              this.HostPort = hostPort;
299              this.ContainerPort = containerPort;
300          }
301          public PortMapping(string hostPort, string containerPort, string protocol)
302          {
303              this.HostPort = hostPort;
304              this.ContainerPort = containerPort;
305              this.Protocol = protocol;
306          }
307          public string HostPort { get; set; }
308          public string ContainerPort { get; set; }
309          public string Protocol { get; set; }
310      }
311      public class DockerVersion
312      {
313          public DockerVersion(Version serverVersion, Version clientVersion)
314          {
315              this.ServerVersion = serverVersion;
316              this.ClientVersion = clientVersion;
317          }
318          public Version ServerVersion { get; set; }
319          public Version ClientVersion { get; set; }
320      }
321      public class PathMapping
322      {
323          public PathMapping(string hostPath, string containerPath)
324          {
325              this.HostPath = hostPath;
326              this.ContainerPath = containerPath;
327          }
328          public string HostPath { get; set; }
329          public string ContainerPath { get; set; }
330      }
331  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerInfo.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ContainerInfo.cs</div>
                </div>
                <div class="column column_space"><pre><code>173          public string TranslateToHostPath(string path)
174          {
175              if (!string.IsNullOrEmpty(path))
176              {
177                  foreach (var mapping in _pathMappings)
178                  {
179  #if OS_WINDOWS
180                      if (string.Equals(path, mapping.ContainerPath, StringComparison.OrdinalIgnoreCase))
181                      {
182                          return mapping.HostPath;
183                      }
184                      if (path.StartsWith(mapping.ContainerPath + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase) ||
185                          path.StartsWith(mapping.ContainerPath + Path.AltDirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
186                      {
187                          return mapping.HostPath + path.Remove(0, mapping.ContainerPath.Length);
188                      }
189  #else
190                      if (string.Equals(path, mapping.ContainerPath))
191                      {
192                          return mapping.HostPath;
193                      }
194                      if (path.StartsWith(mapping.ContainerPath + Path.DirectorySeparatorChar))
195                      {
196                          return mapping.HostPath + path.Remove(0, mapping.ContainerPath.Length);
197                      }
198  #endif
199                  }
200              }
201              return path;
202          }
203          public void AddPortMappings(List<PortMapping> portMappings)
</pre></code></div>
                <div class="column column_space"><pre><code>143          public string TranslateToContainerPath(string path)
144          {
145              if (!string.IsNullOrEmpty(path))
146              {
147                  foreach (var mapping in _pathMappings)
148                  {
149  #if OS_WINDOWS
150                      if (string.Equals(path, mapping.HostPath, StringComparison.OrdinalIgnoreCase))
151                      {
152                          return mapping.ContainerPath;
153                      }
154                      if (path.StartsWith(mapping.HostPath + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase) ||
155                          path.StartsWith(mapping.HostPath + Path.AltDirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
156                      {
157                          return mapping.ContainerPath + path.Remove(0, mapping.HostPath.Length);
158                      }
159  #else
160                      if (string.Equals(path, mapping.HostPath))
161                      {
162                          return mapping.ContainerPath;
163                      }
164                      if (path.StartsWith(mapping.HostPath + Path.DirectorySeparatorChar))
165                      {
166                          return mapping.ContainerPath + path.Remove(0, mapping.HostPath.Length);
167                      }
168  #endif
169                  }
170              }
171              return path;
172          }
173          public string TranslateToHostPath(string path)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    