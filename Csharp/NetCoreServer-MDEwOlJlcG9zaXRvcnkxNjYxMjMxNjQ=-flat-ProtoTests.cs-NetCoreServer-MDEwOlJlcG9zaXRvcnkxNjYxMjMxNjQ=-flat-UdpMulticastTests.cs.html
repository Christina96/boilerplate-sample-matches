
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 34, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-ProtoTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Net;
4  using System.Net.Sockets;
5  using System.Threading;
6  using NetCoreServer;
7  using Xunit;
8  using com.chronoxor.simple;
9  using com.chronoxor.simple.FBE;
10  namespace tests
11  {
<span onclick='openModal()' class='match'>12      class TcpProtoClient : NetCoreServer.TcpClient
13      {
14          public bool Conected { get; set; }
15          public bool Disconected { get; set; }
16          public bool Errors { get; set; }
17          public TcpProtoClient(string address, int port) : base(address, port) {}
</span>18          public delegate void ConnectedHandler();
19          public event ConnectedHandler Connected = () => {};
20          protected override void OnConnected()
21          {
22              Conected = true;
23              Connected?.Invoke();
24          }
25          public delegate void DisconnectedHandler();
26          public event DisconnectedHandler Disconnected = () => {};
27          protected override void OnDisconnected()
28          {
29              Disconected = true;
30              Disconnected?.Invoke();
31          }
32          public delegate void ReceivedHandler(byte[] buffer, long offset, long size);
33          public event ReceivedHandler Received = (buffer, offset, size) => {};
34          protected override void OnReceived(byte[] buffer, long offset, long size)
35          {
36              Received?.Invoke(buffer, offset, size);
37          }
38          protected override void OnError(SocketError error) { Errors = true; }
39      }
40      class ProtoClient : Client, ISenderListener, IReceiverListener, IDisposable
41      {
42          private readonly TcpProtoClient _tcpProtoClient;
43          public Guid Id => _tcpProtoClient.Id;
44          public bool IsConnected => _tcpProtoClient.IsConnected;
45          public TcpProtoClient TcpClient => _tcpProtoClient;
46          public ProtoClient(string address, int port)
47          {
48              _tcpProtoClient = new TcpProtoClient(address, port);
49              _tcpProtoClient.Connected += OnConnected;
50              _tcpProtoClient.Disconnected += OnDisconnected;
51              _tcpProtoClient.Received += OnReceived;
52              ReceivedResponse_DisconnectRequest += HandleDisconnectRequest;
53              ReceivedResponse_SimpleResponse += HandleSimpleResponse;
54              ReceivedResponse_SimpleReject += HandleSimpleReject;
55              ReceivedResponse_SimpleNotify += HandleSimpleNotify;
56          }
57          private void DisposeClient()
58          {
59              _tcpProtoClient.Connected -= OnConnected;
60              _tcpProtoClient.Connected -= OnDisconnected;
61              _tcpProtoClient.Received -= OnReceived;
62              ReceivedResponse_DisconnectRequest -= HandleDisconnectRequest;
63              ReceivedResponse_SimpleResponse -= HandleSimpleResponse;
64              ReceivedResponse_SimpleReject -= HandleSimpleReject;
65              ReceivedResponse_SimpleNotify -= HandleSimpleNotify;
66              _tcpProtoClient.Dispose();
67          }
68          public bool ConnectAsync() { return _tcpProtoClient.ConnectAsync(); }
69          public bool DisconnectAsync() { return _tcpProtoClient.DisconnectAsync(); }
70          public bool ReconnectAsync() { return _tcpProtoClient.ReconnectAsync(); }
71          #region Connection handlers
72          public delegate void ConnectedHandler();
73          public event ConnectedHandler Connected = () => {};
74          private void OnConnected()
75          {
76              Reset();
77              Connected?.Invoke();
78          }
79          public delegate void DisconnectedHandler();
80          public event DisconnectedHandler Disconnected = () => {};
81          private void OnDisconnected()
82          {
83              Disconnected?.Invoke();
84          }
85          public long OnSend(byte[] buffer, long offset, long size)
86          {
87              return _tcpProtoClient.SendAsync(buffer, offset, size) ? size : 0;
88          }
89          public void OnReceived(byte[] buffer, long offset, long size)
90          {
91              Receive(buffer, offset, size);
92          }
93          #endregion
94          #region Protocol handlers
95          private void HandleDisconnectRequest(DisconnectRequest request) { _tcpProtoClient.DisconnectAsync(); }
96          private void HandleSimpleResponse(SimpleResponse response) {}
97          private void HandleSimpleReject(SimpleReject reject) {}
98          private void HandleSimpleNotify(SimpleNotify notify) {}
99          #endregion
100          #region IDisposable implementation
101          private bool _disposed;
102          public void Dispose()
103          {
104              Dispose(true);
105              GC.SuppressFinalize(this);
106          }
107          protected virtual void Dispose(bool disposingManagedResources)
108          {
109              if (!_disposed)
110              {
111                  if (disposingManagedResources)
112                  {
113                      DisposeClient();
114                  }
115                  _disposed = true;
116              }
117          }
118          #endregion
119      }
120      class ProtoSessionSender : Sender, ISenderListener
121      {
122          public ProtoSession Session { get; }
123          public ProtoSessionSender(ProtoSession session) { Session = session; }
124          public long OnSend(byte[] buffer, long offset, long size)
125          {
126              return Session.SendAsync(buffer, offset, size) ? size : 0;
127          }
128      }
129      class ProtoSessionReceiver : Receiver, IReceiverListener
130      {
131          public ProtoSession Session { get; }
132          public ProtoSessionReceiver(ProtoSession session) { Session = session; }
133          public void OnReceive(SimpleRequest request) { Session.OnReceive(request); }
134      }
135      class ProtoSession : TcpSession
136      {
137          public ProtoSessionSender Sender { get; }
138          public ProtoSessionReceiver Receiver { get; }
139          public ProtoSession(TcpServer server) : base(server)
140          {
141              Sender = new ProtoSessionSender(this);
142              Receiver = new ProtoSessionReceiver(this);
143          }
144          protected override void OnReceived(byte[] buffer, long offset, long size)
145          {
146              Receiver.Receive(buffer, offset, size);
147          }
148          public void OnReceive(SimpleRequest request)
149          {
150              SimpleResponse response = SimpleResponse.Default;
151              response.id = request.id;
152              response.Hash = 0;
153              response.Length = (uint)request.Message.Length;
154              Sender.Send(response);
155          }
156      }
157      class ProtoSender : Sender, ISenderListener
158      {
159          public ProtoServer Server { get; }
160          public ProtoSender(ProtoServer server) { Server = server; }
161          public long OnSend(byte[] buffer, long offset, long size)
162          {
163              Server.Multicast(buffer, offset, size);
164              return size;
165          }
166      }
167      class ProtoServer : TcpServer
168      {
169          public bool Started { get; set; }
170          public bool Stopped { get; set; }
171          public bool Connected { get; set; }
172          public bool Disconnected { get; set; }
173          public int Clients { get; set; }
174          public bool Errors { get; set; }
175          public ProtoSender Sender { get; }
176          public ProtoServer(IPAddress address, int port) : base(address, port)
177          {
178              Sender = new ProtoSender(this);
179          }
180          protected override TcpSession CreateSession() { return new ProtoSession(this); }
181          protected override void OnStarted() { Started = true; }
182          protected override void OnStopped() { Stopped = true; }
183          protected override void OnConnected(TcpSession session) { Connected = true; Clients++; }
184          protected override void OnDisconnected(TcpSession session) { Disconnected = true; Clients--; }
185          protected override void OnError(SocketError error) { Errors = true; }
186      }
187      public class ProtoTests
188      {
189          [Fact(DisplayName = "Protocol server test")]
190          public void ProtoServerTest()
191          {
192              string address = "127.0.0.1";
193              int port = 4444;
194              var server = new ProtoServer(IPAddress.Any, port);
195              Assert.True(server.Start());
196              while (!server.IsStarted)
197                  Thread.Yield();
198              var client = new ProtoClient(address, port);
199              Assert.True(client.ConnectAsync());
200              while (!client.IsConnected || (server.Clients != 1))
201                  Thread.Yield();
202              SimpleRequest request = SimpleRequest.Default;
203              request.Message = "test";
204              var response = client.Request(request).Result;
205              Assert.Equal(request.id, response.id);
206              Assert.Equal(0u, response.Hash);
207              Assert.Equal(4u, response.Length);
208              Assert.True(client.DisconnectAsync());
209              while (client.IsConnected || (server.Clients != 0))
210                  Thread.Yield();
211              Assert.True(server.Stop());
212              while (server.IsStarted)
213                  Thread.Yield();
214              Assert.True(server.Started);
215              Assert.True(server.Stopped);
216              Assert.True(server.Connected);
217              Assert.True(server.Disconnected);
218              Assert.True(server.BytesSent > 0);
219              Assert.True(server.BytesReceived > 0);
220              Assert.True(!server.Errors);
221              Assert.True(client.TcpClient.Conected);
222              Assert.True(client.TcpClient.Disconected);
223              Assert.True(client.TcpClient.BytesSent > 0);
224              Assert.True(client.TcpClient.BytesReceived > 0);
225              Assert.True(!client.TcpClient.Errors);
226          }
227          [Fact(DisplayName = "Protocol multicast test")]
228          public void ProtoServerMulticastTest()
229          {
230              string address = "127.0.0.1";
231              int port = 4442;
232              var server = new ProtoServer(IPAddress.Any, port);
233              Assert.True(server.Start());
234              while (!server.IsStarted)
235                  Thread.Yield();
236              var client1 = new ProtoClient(address, port);
237              Assert.True(client1.ConnectAsync());
238              while (!client1.IsConnected || (server.Clients != 1))
239                  Thread.Yield();
240              SimpleNotify notify = SimpleNotify.Default;
241              notify.Notification = "test";
242              server.Sender.Send(notify);
243              while (client1.TcpClient.BytesReceived == 0)
244                  Thread.Yield();
245              var client2 = new ProtoClient(address, port);
246              Assert.True(client2.ConnectAsync());
247              while (!client2.IsConnected || (server.Clients != 2))
248                  Thread.Yield();
249              server.Sender.Send(notify);
250              while (client2.TcpClient.BytesReceived == 0)
251                  Thread.Yield();
252              var client3 = new ProtoClient(address, port);
253              Assert.True(client3.ConnectAsync());
254              while (!client3.IsConnected || (server.Clients != 3))
255                  Thread.Yield();
256              server.Sender.Send(notify);
257              while (client3.TcpClient.BytesReceived == 0)
258                  Thread.Yield();
259              Assert.True(client1.DisconnectAsync());
260              while (client1.IsConnected || (server.Clients != 2))
261                  Thread.Yield();
262              Assert.True(client2.DisconnectAsync());
263              while (client2.IsConnected || (server.Clients != 1))
264                  Thread.Yield();
265              Assert.True(client3.DisconnectAsync());
266              while (client3.IsConnected || (server.Clients != 0))
267                  Thread.Yield();
268              Assert.True(server.Stop());
269              while (server.IsStarted)
270                  Thread.Yield();
271              Assert.True(server.Started);
272              Assert.True(server.Stopped);
273              Assert.True(server.Connected);
274              Assert.True(server.Disconnected);
275              Assert.True(server.BytesSent > 0);
276              Assert.True(server.BytesReceived == 0);
277              Assert.True(!server.Errors);
278              Assert.True(client1.TcpClient.BytesSent == 0);
279              Assert.True(client2.TcpClient.BytesSent == 0);
280              Assert.True(client3.TcpClient.BytesSent == 0);
281              Assert.True(client1.TcpClient.BytesReceived > 0);
282              Assert.True(client2.TcpClient.BytesReceived > 0);
283              Assert.True(client3.TcpClient.BytesReceived > 0);
284              Assert.True(!client1.TcpClient.Errors);
285              Assert.True(!client2.TcpClient.Errors);
286              Assert.True(!client3.TcpClient.Errors);
287          }
288          [Fact(DisplayName = "Protocol server random test")]
289          public void TcpServerRandomTest()
290          {
291              string address = "127.0.0.1";
292              int port = 4443;
293              var server = new ProtoServer(IPAddress.Any, port);
294              Assert.True(server.Start());
295              while (!server.IsStarted)
296                  Thread.Yield();
297              int duration = 10;
298              var clients = new List<ProtoClient>();
299              var rand = new Random();
300              var start = DateTime.UtcNow;
301              while ((DateTime.UtcNow - start).TotalSeconds < duration)
302              {
303                  if ((rand.Next() % 1000) == 0)
304                  {
305                      server.DisconnectAll();
306                  }
307                  else if ((rand.Next() % 100) == 0)
308                  {
309                      if (clients.Count < 100)
310                      {
311                          var client = new ProtoClient(address, port);
312                          clients.Add(client);
313                          client.ConnectAsync();
314                          while (!client.IsConnected)
315                              Thread.Yield();
316                      }
317                  }
318                  else if ((rand.Next() % 100) == 0)
319                  {
320                      if (clients.Count > 0)
321                      {
322                          int index = rand.Next() % clients.Count;
323                          var client = clients[index];
324                          if (client.IsConnected)
325                          {
326                              client.DisconnectAsync();
327                              while (client.IsConnected)
328                                  Thread.Yield();
329                          }
330                          else
331                          {
332                              client.ConnectAsync();
333                              while (!client.IsConnected)
334                                  Thread.Yield();
335                          }
336                      }
337                  }
338                  else if ((rand.Next() % 100) == 0)
339                  {
340                      if (clients.Count > 0)
341                      {
342                          int index = rand.Next() % clients.Count;
343                          var client = clients[index];
344                          if (client.IsConnected)
345                          {
346                              client.ReconnectAsync();
347                              while (!client.IsConnected)
348                                  Thread.Yield();
349                          }
350                      }
351                  }
352                  else if ((rand.Next() % 10) == 0)
353                  {
354                      SimpleNotify notify = SimpleNotify.Default;
355                      notify.Notification = "test";
356                      server.Sender.Send(notify);
357                  }
358                  else if ((rand.Next() % 1) == 0)
359                  {
360                      if (clients.Count > 0)
361                      {
362                          int index = rand.Next() % clients.Count;
363                          var client = clients[index];
364                          if (client.IsConnected)
365                          {
366                              SimpleRequest request = SimpleRequest.Default;
367                              request.Message = "test";
368                              client.Request(request);
369                          }
370                      }
371                  }
372                  Thread.Sleep(1);
373              }
374              foreach (var client in clients)
375              {
376                  client.DisconnectAsync();
377                  while (client.IsConnected)
378                      Thread.Yield();
379              }
380              Assert.True(server.Stop());
381              while (server.IsStarted)
382                  Thread.Yield();
383              Assert.True(server.Started);
384              Assert.True(server.Stopped);
385              Assert.True(server.Connected);
386              Assert.True(server.Disconnected);
387              Assert.True(server.BytesSent > 0);
388              Assert.True(server.BytesReceived > 0);
389              Assert.True(!server.Errors);
390          }
391      }
392  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-UdpMulticastTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Net;
4  using System.Net.Sockets;
5  using System.Threading;
6  using NetCoreServer;
7  using Xunit;
8  namespace tests
9  {
<span onclick='openModal()' class='match'>10      class MulticastUdpClient : NetCoreServer.UdpClient
11      {
12          public bool Connected { get; set; }
13          public bool Disconnected { get; set; }
14          public bool Errors { get; set; }
15          public MulticastUdpClient(string address, int port) : base(address, port) {}
</span>16          protected override void OnConnected() { Connected = true; ReceiveAsync(); }
17          protected override void OnDisconnected() { Disconnected = true; }
18          protected override void OnReceived(EndPoint endpoint, byte[] buffer, long offset, long size) { ReceiveAsync(); }
19          protected override void OnError(SocketError error) { Errors = true; }
20      }
21      class MulticastUdpServer : UdpServer
22      {
23          public bool Started { get; set; }
24          public bool Stopped { get; set; }
25          public bool Errors { get; set; }
26          public MulticastUdpServer(IPAddress address, int port) : base(address, port) {}
27          protected override void OnStarted() { Started = true; ReceiveAsync(); }
28          protected override void OnStopped() { Stopped = true; }
29          protected override void OnError(SocketError error) { Errors = true; }
30      }
31      public class UdpMulticastTests
32      {
33          [Fact(DisplayName = "UDP server multicast test")]
34          public void UdpMulticastServerTest()
35          {
36              string listenAddress = "0.0.0.0";
37              string multicastAddress = "239.255.0.1";
38              int multicastPort = 3335;
39              var server = new MulticastUdpServer(IPAddress.Any, 0);
40              Assert.True(server.Start(multicastAddress, multicastPort));
41              while (!server.IsStarted)
42                  Thread.Yield();
43              var client1 = new MulticastUdpClient(listenAddress, multicastPort);
44              client1.SetupMulticast(true);
45              Assert.True(client1.Connect());
46              while (!client1.IsConnected)
47                  Thread.Yield();
48              client1.JoinMulticastGroup(multicastAddress);
49              Thread.Sleep(100);
50              server.Multicast("test");
51              while (client1.BytesReceived != 4)
52                  Thread.Yield();
53              var client2 = new MulticastUdpClient(listenAddress, multicastPort);
54              client2.SetupMulticast(true);
55              Assert.True(client2.Connect());
56              while (!client2.IsConnected)
57                  Thread.Yield();
58              client2.JoinMulticastGroup(multicastAddress);
59              Thread.Sleep(100);
60              server.Multicast("test");
61              while ((client1.BytesReceived != 8) || (client2.BytesReceived != 4))
62                  Thread.Yield();
63              var client3 = new MulticastUdpClient(listenAddress, multicastPort);
64              client3.SetupMulticast(true);
65              Assert.True(client3.Connect());
66              while (!client3.IsConnected)
67                  Thread.Yield();
68              client3.JoinMulticastGroup(multicastAddress);
69              Thread.Sleep(100);
70              server.Multicast("test");
71              while ((client1.BytesReceived != 12) || (client2.BytesReceived != 8) || (client3.BytesReceived != 4))
72                  Thread.Yield();
73              client1.LeaveMulticastGroup(multicastAddress);
74              Thread.Sleep(100);
75              Assert.True(client1.Disconnect());
76              while (client1.IsConnected)
77                  Thread.Yield();
78              server.Multicast("test");
79              while ((client1.BytesReceived != 12) || (client2.BytesReceived != 12) || (client3.BytesReceived != 8))
80                  Thread.Yield();
81              client2.LeaveMulticastGroup(multicastAddress);
82              Thread.Sleep(100);
83              Assert.True(client2.Disconnect());
84              while (client2.IsConnected)
85                  Thread.Yield();
86              server.Multicast("test");
87              while ((client1.BytesReceived != 12) || (client2.BytesReceived != 12) || (client3.BytesReceived != 12))
88                  Thread.Yield();
89              client3.LeaveMulticastGroup(multicastAddress);
90              Thread.Sleep(100);
91              Assert.True(client3.Disconnect());
92              while (client3.IsConnected)
93                  Thread.Yield();
94              Assert.True(server.Stop());
95              while (server.IsStarted)
96                  Thread.Yield();
97              Assert.True(server.Started);
98              Assert.True(server.Stopped);
99              Assert.True(server.BytesSent > 0);
100              Assert.True(server.BytesReceived == 0);
101              Assert.True(!server.Errors);
102              Assert.True(client1.BytesSent == 0);
103              Assert.True(client2.BytesSent == 0);
104              Assert.True(client3.BytesSent == 0);
105              Assert.True(client1.BytesReceived == 12);
106              Assert.True(client2.BytesReceived == 12);
107              Assert.True(client3.BytesReceived == 12);
108              Assert.True(!client1.Errors);
109              Assert.True(!client2.Errors);
110              Assert.True(!client3.Errors);
111          }
112          [Fact(DisplayName = "UDP server multicast random test")]
113          public void UdpMulticastServerRandomTest()
114          {
115              string listenAddress = "0.0.0.0";
116              string multicastAddress = "239.255.0.1";
117              int multicastPort = 3336;
118              var server = new MulticastUdpServer(IPAddress.Any, 0);
119              Assert.True(server.Start(multicastAddress, multicastPort));
120              while (!server.IsStarted)
121                  Thread.Yield();
122              int duration = 10;
123              var clients = new List<MulticastUdpClient>();
124              var rand = new Random();
125              var start = DateTime.UtcNow;
126              while ((DateTime.UtcNow - start).TotalSeconds < duration)
127              {
128                  if ((rand.Next() % 100) == 0)
129                  {
130                      if (clients.Count < 100)
131                      {
132                          var client = new MulticastUdpClient(listenAddress, multicastPort);
133                          clients.Add(client);
134                          client.SetupMulticast(true);
135                          client.Connect();
136                          while (!client.IsConnected)
137                              Thread.Yield();
138                          client.JoinMulticastGroup(multicastAddress);
139                          Thread.Sleep(100);
140                      }
141                  }
142                  else if ((rand.Next() % 100) == 0)
143                  {
144                      if (clients.Count > 0)
145                      {
146                          int index = rand.Next() % clients.Count;
147                          var client = clients[index];
148                          if (client.IsConnected)
149                          {
150                              client.LeaveMulticastGroup(multicastAddress);
151                              Thread.Sleep(100);
152                              client.Disconnect();
153                              while (client.IsConnected)
154                                  Thread.Yield();
155                          }
156                          else
157                          {
158                              client.Connect();
159                              while (!client.IsConnected)
160                                  Thread.Yield();
161                              client.JoinMulticastGroup(multicastAddress);
162                              Thread.Sleep(100);
163                          }
164                      }
165                  }
166                  else if ((rand.Next() % 10) == 0)
167                  {
168                      server.Multicast("test");
169                  }
170                  Thread.Sleep(1);
171              }
172              foreach (var client in clients)
173              {
174                  client.Disconnect();
175                  while (client.IsConnected)
176                      Thread.Yield();
177              }
178              Assert.True(server.Stop());
179              while (server.IsStarted)
180                  Thread.Yield();
181              Assert.True(server.Started);
182              Assert.True(server.Stopped);
183              Assert.True(server.BytesSent > 0);
184              Assert.True(server.BytesReceived == 0);
185              Assert.True(!server.Errors);
186          }
187      }
188  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-ProtoTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-UdpMulticastTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>12      class TcpProtoClient : NetCoreServer.TcpClient
13      {
14          public bool Conected { get; set; }
15          public bool Disconected { get; set; }
16          public bool Errors { get; set; }
17          public TcpProtoClient(string address, int port) : base(address, port) {}
</pre></code></div>
                <div class="column column_space"><pre><code>10      class MulticastUdpClient : NetCoreServer.UdpClient
11      {
12          public bool Connected { get; set; }
13          public bool Disconnected { get; set; }
14          public bool Errors { get; set; }
15          public MulticastUdpClient(string address, int port) : base(address, port) {}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    