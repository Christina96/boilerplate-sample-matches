
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-SslSession.cs</h3>
            <pre><code>1  using System;
2  using System.Net.Security;
3  using System.Net.Sockets;
4  using System.Text;
5  using System.Threading;
6  namespace NetCoreServer
7  {
8      public class SslSession : IDisposable
9      {
10          public SslSession(SslServer server)
11          {
12              Id = Guid.NewGuid();
13              Server = server;
14              OptionReceiveBufferSize = server.OptionReceiveBufferSize;
15              OptionSendBufferSize = server.OptionSendBufferSize;
16          }
17          public Guid Id { get; }
18          public SslServer Server { get; }
19          public Socket Socket { get; private set; }
20          public long BytesPending { get; private set; }
21          public long BytesSending { get; private set; }
22          public long BytesSent { get; private set; }
23          public long BytesReceived { get; private set; }
24          public int OptionReceiveBufferLimit { get; set; } = 0;
25          public int OptionReceiveBufferSize { get; set; } = 8192;
26          public int OptionSendBufferLimit { get; set; } = 0;
27          public int OptionSendBufferSize { get; set; } = 8192;
28          #region Connect/Disconnect session
29          private bool _disconnecting;
30          private SslStream _sslStream;
31          private Guid? _sslStreamId;
32          public bool IsConnected { get; private set; }
33          public bool IsHandshaked { get; private set; }
34          internal void Connect(Socket socket)
35          {
36              Socket = socket;
37              IsSocketDisposed = false;
38              _receiveBuffer = new Buffer();
39              _sendBufferMain = new Buffer();
40              _sendBufferFlush = new Buffer();
41              if (Server.OptionKeepAlive)
42                  Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
43              if (Server.OptionTcpKeepAliveTime >= 0)
44                  Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.TcpKeepAliveTime, Server.OptionTcpKeepAliveTime);
45              if (Server.OptionTcpKeepAliveInterval >= 0)
46                  Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.TcpKeepAliveInterval, Server.OptionTcpKeepAliveInterval);
47              if (Server.OptionTcpKeepAliveRetryCount >= 0)
48                  Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.TcpKeepAliveRetryCount, Server.OptionTcpKeepAliveRetryCount);
49              if (Server.OptionNoDelay)
50                  Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
51              _receiveBuffer.Reserve(OptionReceiveBufferSize);
52              _sendBufferMain.Reserve(OptionSendBufferSize);
53              _sendBufferFlush.Reserve(OptionSendBufferSize);
54              BytesPending = 0;
55              BytesSending = 0;
56              BytesSent = 0;
57              BytesReceived = 0;
58              OnConnecting();
59              Server.OnConnectingInternal(this);
60              IsConnected = true;
61              OnConnected();
62              Server.OnConnectedInternal(this);
63              try
64              {
65                  _sslStreamId = Guid.NewGuid();
66                  _sslStream = (Server.Context.CertificateValidationCallback != null) ? new SslStream(new NetworkStream(Socket, false), false, Server.Context.CertificateValidationCallback) : new SslStream(new NetworkStream(Socket, false), false);
67                  OnHandshaking();
68                  Server.OnHandshakingInternal(this);
69                  _sslStream.BeginAuthenticateAsServer(Server.Context.Certificate, Server.Context.ClientCertificateRequired, Server.Context.Protocols, false, ProcessHandshake, _sslStreamId);
70              }
71              catch (Exception)
72              {
73                  SendError(SocketError.NotConnected);
74                  Disconnect();
75              }
76          }
77          public virtual bool Disconnect()
78          {
79              if (!IsConnected)
80                  return false;
81              if (_disconnecting)
82                  return false;
83              _disconnecting = true;
84              OnDisconnecting();
85              Server.OnDisconnectingInternal(this);
86              try
87              {
88                  try
89                  {
90                      _sslStream.ShutdownAsync().Wait();
91                  }
92                  catch (Exception) {}
93                  _sslStream.Dispose();
94                  _sslStreamId = null;
95                  try
96                  {
97                      Socket.Shutdown(SocketShutdown.Both);
98                  }
99                  catch (SocketException) {}
100                  Socket.Close();
101                  Socket.Dispose();
102                  IsSocketDisposed = true;
103              }
104              catch (ObjectDisposedException) {}
105              IsHandshaked = false;
106              IsConnected = false;
107              _receiving = false;
108              _sending = false;
109              ClearBuffers();
110              OnDisconnected();
111              Server.OnDisconnectedInternal(this);
112              Server.UnregisterSession(Id);
113              _disconnecting = false;
114              return true;
115          }
116          #endregion
117          #region Send/Receive data
118          private bool _receiving;
119          private Buffer _receiveBuffer;
120          private readonly object _sendLock = new object();
121          private bool _sending;
122          private Buffer _sendBufferMain;
123          private Buffer _sendBufferFlush;
124          private long _sendBufferFlushOffset;
125          public virtual long Send(byte[] buffer) => Send(buffer.AsSpan());
126          public virtual long Send(byte[] buffer, long offset, long size) => Send(buffer.AsSpan((int)offset, (int)size));
127          public virtual long Send(ReadOnlySpan<byte> buffer)
128          {
129              if (!IsHandshaked)
130                  return 0;
131              if (buffer.IsEmpty)
132                  return 0;
133              try
134              {
135                  _sslStream.Write(buffer);
136                  long sent = buffer.Length;
137                  BytesSent += sent;
138                  Interlocked.Add(ref Server._bytesSent, sent);
139                  OnSent(sent, BytesPending + BytesSending);
140                  return sent;
141              }
142              catch (Exception)
143              {
144                  SendError(SocketError.OperationAborted);
145                  Disconnect();
146                  return 0;
147              }
148          }
149          public virtual long Send(string text) => Send(Encoding.UTF8.GetBytes(text));
150          public virtual long Send(ReadOnlySpan<char> text) => Send(Encoding.UTF8.GetBytes(text.ToArray()));
151          public virtual bool SendAsync(byte[] buffer) => SendAsync(buffer.AsSpan());
152          public virtual bool SendAsync(byte[] buffer, long offset, long size) => SendAsync(buffer.AsSpan((int)offset, (int)size));
153          public virtual bool SendAsync(ReadOnlySpan<byte> buffer)
154          {
155              if (!IsHandshaked)
156                  return false;
157              if (buffer.IsEmpty)
158                  return true;
159              lock (_sendLock)
160              {
161                  if (((_sendBufferMain.Size + buffer.Length) > OptionSendBufferLimit) && (OptionSendBufferLimit > 0))
162                  {
163                      SendError(SocketError.NoBufferSpaceAvailable);
164                      return false;
165                  }
166                  _sendBufferMain.Append(buffer);
167                  BytesPending = _sendBufferMain.Size;
168                  if (_sending)
169                      return true;
170                  else
171                      _sending = true;
172                  TrySend();
173              }
174              return true;
175          }
176          public virtual bool SendAsync(string text) => SendAsync(Encoding.UTF8.GetBytes(text));
177          public virtual bool SendAsync(ReadOnlySpan<char> text) => SendAsync(Encoding.UTF8.GetBytes(text.ToArray()));
178          public virtual long Receive(byte[] buffer) { return Receive(buffer, 0, buffer.Length); }
179          public virtual long Receive(byte[] buffer, long offset, long size)
180          {
181              if (!IsHandshaked)
182                  return 0;
183              if (size == 0)
184                  return 0;
185              try
186              {
187                  long received = _sslStream.Read(buffer, (int)offset, (int)size);
188                  if (received > 0)
189                  {
190                      BytesReceived += received;
191                      Interlocked.Add(ref Server._bytesReceived, received);
192                      OnReceived(buffer, 0, received);
193                  }
194                  return received;
195              }
196              catch (Exception)
197              {
198                  SendError(SocketError.OperationAborted);
199                  Disconnect();
200                  return 0;
201              }
202          }
203          public virtual string Receive(long size)
204          {
205              var buffer = new byte[size];
206              var length = Receive(buffer);
207              return Encoding.UTF8.GetString(buffer, 0, (int)length);
208          }
209          public virtual void ReceiveAsync()
210          {
211              TryReceive();
212          }
213          private void TryReceive()
214          {
215              if (_receiving)
216                  return;
217              if (!IsHandshaked)
218                  return;
219              try
220              {
221                  IAsyncResult result;
222                  do
223                  {
224                      if (!IsHandshaked)
225                          return;
226                      _receiving = true;
227                      result = _sslStream.BeginRead(_receiveBuffer.Data, 0, (int)_receiveBuffer.Capacity, ProcessReceive, _sslStreamId);
228                  } while (result.CompletedSynchronously);
229              }
230              catch (ObjectDisposedException) {}
231          }
232          private void TrySend()
233          {
234              if (!IsHandshaked)
235                  return;
236              bool empty = false;
237              lock (_sendLock)
238              {
239                  if (_sendBufferFlush.IsEmpty)
240                  {
241                      _sendBufferFlush = Interlocked.Exchange(ref _sendBufferMain, _sendBufferFlush);
242                      _sendBufferFlushOffset = 0;
243                      BytesPending = 0;
244                      BytesSending += _sendBufferFlush.Size;
245                      if (_sendBufferFlush.IsEmpty)
246                      {
247                          empty = true;
248                          _sending = false;
249                      }
250                  }
251                  else
252                      return;
253              }
254              if (empty)
255              {
256                  OnEmpty();
257                  return;
258              }
259              try
260              {
261                  _sslStream.BeginWrite(_sendBufferFlush.Data, (int)_sendBufferFlushOffset, (int)(_sendBufferFlush.Size - _sendBufferFlushOffset), ProcessSend, _sslStreamId);
262              }
263              catch (ObjectDisposedException) {}
264          }
265          private void ClearBuffers()
266          {
267              lock (_sendLock)
268              {
269                  _sendBufferMain.Clear();
270                  _sendBufferFlush.Clear();
271                  _sendBufferFlushOffset= 0;
272                  BytesPending = 0;
273                  BytesSending = 0;
274              }
275          }
276          #endregion
277          #region IO processing
278          private void ProcessHandshake(IAsyncResult result)
279          {
280              try
281              {
282                  if (IsHandshaked)
283                      return;
284                  var sslStreamId = result.AsyncState as Guid?;
285                  if (_sslStreamId != sslStreamId)
286                      return;
<span onclick='openModal()' class='match'>287                  _sslStream.EndAuthenticateAsServer(result);
288                  IsHandshaked = true;
289                  TryReceive();
290                  if (IsSocketDisposed)
</span>291                      return;
292                  OnHandshaked();
293                  Server.OnHandshakedInternal(this);
294                  if (_sendBufferMain.IsEmpty)
295                      OnEmpty();
296              }
297              catch (Exception)
298              {
299                  SendError(SocketError.NotConnected);
300                  Disconnect();
301              }
302          }
303          private void ProcessReceive(IAsyncResult result)
304          {
305              try
306              {
307                  if (!IsHandshaked)
308                      return;
309                  var sslStreamId = result.AsyncState as Guid?;
310                  if (_sslStreamId != sslStreamId)
311                      return;
312                  long size = _sslStream.EndRead(result);
313                  if (size > 0)
314                  {
315                      BytesReceived += size;
316                      Interlocked.Add(ref Server._bytesReceived, size);
317                      OnReceived(_receiveBuffer.Data, 0, size);
318                      if (_receiveBuffer.Capacity == size)
319                      {
320                          if (((2 * size) > OptionReceiveBufferLimit) && (OptionReceiveBufferLimit > 0))
321                          {
322                              SendError(SocketError.NoBufferSpaceAvailable);
323                              Disconnect();
324                              return;
325                          }
326                          _receiveBuffer.Reserve(2 * size);
327                      }
328                  }
329                  _receiving = false;
330                  if (size > 0)
331                  {
332                      if (!result.CompletedSynchronously)
333                          TryReceive();
334                  }
335                  else
336                      Disconnect();
337              }
338              catch (Exception)
339              {
340                  SendError(SocketError.OperationAborted);
341                  Disconnect();
342              }
343          }
344          private void ProcessSend(IAsyncResult result)
345          {
346              try
347              {
348                  var sslStreamId = result.AsyncState as Guid?;
349                  if (_sslStreamId != sslStreamId)
350                      return;
351                  if (!IsHandshaked)
352                      return;
353                  _sslStream.EndWrite(result);
354                  long size = _sendBufferFlush.Size;
355                  if (size > 0)
356                  {
357                      BytesSending -= size;
358                      BytesSent += size;
359                      Interlocked.Add(ref Server._bytesSent, size);
360                      _sendBufferFlushOffset += size;
361                      if (_sendBufferFlushOffset == _sendBufferFlush.Size)
362                      {
363                          _sendBufferFlush.Clear();
364                          _sendBufferFlushOffset = 0;
365                      }
366                      OnSent(size, BytesPending + BytesSending);
367                  }
368                  TrySend();
369              }
370              catch (Exception)
371              {
372                  SendError(SocketError.OperationAborted);
373                  Disconnect();
374              }
375          }
376          #endregion
377          #region Session handlers
378          protected virtual void OnConnecting() {}
379          protected virtual void OnConnected() {}
380          protected virtual void OnHandshaking() {}
381          protected virtual void OnHandshaked() {}
382          protected virtual void OnDisconnecting() {}
383          protected virtual void OnDisconnected() {}
384          protected virtual void OnReceived(byte[] buffer, long offset, long size) {}
385          protected virtual void OnSent(long sent, long pending) {}
386          protected virtual void OnEmpty() {}
387          protected virtual void OnError(SocketError error) {}
388          #endregion
389          #region Error handling
390          private void SendError(SocketError error)
391          {
392              if ((error == SocketError.ConnectionAborted) ||
393                  (error == SocketError.ConnectionRefused) ||
394                  (error == SocketError.ConnectionReset) ||
395                  (error == SocketError.OperationAborted) ||
396                  (error == SocketError.Shutdown))
397                  return;
398              OnError(error);
399          }
400          #endregion
401          #region IDisposable implementation
402          public bool IsDisposed { get; private set; }
403          public bool IsSocketDisposed { get; private set; } = true;
404          public void Dispose()
405          {
406              Dispose(true);
407              GC.SuppressFinalize(this);
408          }
409          protected virtual void Dispose(bool disposingManagedResources)
410          {
411              if (!IsDisposed)
412              {
413                  if (disposingManagedResources)
414                  {
415                      Disconnect();
416                  }
417                  IsDisposed = true;
418              }
419          }
420          #endregion
421      }
422  }
</code></pre>
        </div>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudDataGrid.razor.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Collections.Specialized;
4  using System.Diagnostics.CodeAnalysis;
5  using System.Globalization;
6  using System.Linq;
7  using System.Reflection;
8  using System.Text.Json;
9  using System.Threading.Tasks;
10  using Microsoft.AspNetCore.Components;
11  using Microsoft.AspNetCore.Components.Web;
12  using MudBlazor.Utilities;
13  namespace MudBlazor
14  {
15      [CascadingTypeParameter(nameof(T))]
16      public partial class MudDataGrid<T> : MudComponentBase
17      {
18          private Func<IFilterDefinition<T>> _defaultFilterDefinitionFactory = () => new FilterDefinition<T>();
19          private int _currentPage = 0;
20          internal int? _rowsPerPage;
21          private bool _isFirstRendered = false;
22          private bool _filtersMenuVisible = false;
23          private bool _columnsPanelVisible = false;
24          private IEnumerable<T> _items;
25          private T _selectedItem;
26          internal HashSet<object> _groupExpansions = new HashSet<object>();
27          private List<GroupDefinition<T>> _currentPageGroups = new List<GroupDefinition<T>>();
28          private List<GroupDefinition<T>> _allGroups = new List<GroupDefinition<T>>();
29          internal HashSet<T> _openHierarchies = new HashSet<T>();
30          private PropertyInfo[] _properties = typeof(T).GetProperties();
31          private MudDropContainer<Column<T>> _dropContainer;
32          protected string _classname =>
33              new CssBuilder("mud-table")
34                 .AddClass("mud-data-grid")
35                 .AddClass("mud-xs-table", Breakpoint == Breakpoint.Xs)
36                 .AddClass("mud-sm-table", Breakpoint == Breakpoint.Sm)
37                 .AddClass("mud-md-table", Breakpoint == Breakpoint.Md)
38                 .AddClass("mud-lg-table", Breakpoint == Breakpoint.Lg || Breakpoint == Breakpoint.Always)
39                 .AddClass("mud-xl-table", Breakpoint == Breakpoint.Xl || Breakpoint == Breakpoint.Always)
40                 .AddClass("mud-table-dense", Dense)
41                 .AddClass("mud-table-hover", Hover)
42                 .AddClass("mud-table-bordered", Bordered)
43                 .AddClass("mud-table-striped", Striped)
44                 .AddClass("mud-table-outlined", Outlined)
45                 .AddClass("mud-table-square", Square)
46                 .AddClass("mud-table-sticky-header", FixedHeader)
47                 .AddClass("mud-table-sticky-footer", FixedFooter)
48                 .AddClass($"mud-elevation-{Elevation}", !Outlined)
49                .AddClass(Class)
50              .Build();
51          protected string _style =>
52              new StyleBuilder()
53                  .AddStyle("overflow-x", "auto", when: HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container)
54                  .AddStyle("position", "relative", when: hasStickyColumns)
55                  .AddStyle(Style)
56              .Build();
57          protected string _tableStyle =>
58              new StyleBuilder()
59                  .AddStyle("height", Height, !string.IsNullOrWhiteSpace(Height))
60                  .AddStyle("width", "max-content", when: (HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container))
61                  .AddStyle("overflow", "clip", when: (HorizontalScrollbar || ColumnResizeMode == ResizeMode.Container) && hasStickyColumns)
62                  .AddStyle("display", "block", when: HorizontalScrollbar)
63              .Build();
64          protected string _tableClass =>
65              new CssBuilder("mud-table-container")
66                  .AddClass("cursor-col-resize", when: IsResizing)
67              .Build();
68          protected string _headClassname => new CssBuilder("mud-table-head")
69              .AddClass(HeaderClass).Build();
70          protected string _footClassname => new CssBuilder("mud-table-foot")
71              .AddClass(FooterClass).Build();
72          protected string _headerFooterStyle =>
73              new StyleBuilder()
74                  .AddStyle("position", "sticky", when: hasStickyColumns)
75                  .AddStyle("left", "0px", when: hasStickyColumns)
76              .Build();
77          internal SortDirection GetColumnSortDirection(string columnName)
78          {
79              if (columnName == null)
80              {
81                  return SortDirection.None;
82              }
83              else
84              {
85                  SortDefinition<T> sortDefinition = null;
86                  var ok = SortDefinitions.TryGetValue(columnName, out sortDefinition);
87                  if (ok)
88                  {
89                      return sortDefinition.Descending ? SortDirection.Descending : SortDirection.Ascending;
90                  }
91                  else
92                  {
93                      return SortDirection.None;
94                  }
95              }
96          }
97          protected int numPages
98          {
99              get
100              {
101                  if (ServerData != null)
102                      return (int)Math.Ceiling(_server_data.TotalItems / (double)RowsPerPage);
103                  return (int)Math.Ceiling(FilteredItems.Count() / (double)RowsPerPage);
104              }
105          }
106          internal static bool RenderedColumnsItemsSelector(Column<T> item, string dropZone) => item?.PropertyName == dropZone;
107          private static void Swap<TItem>(List<TItem> list, int indexA, int indexB)
108          {
109              TItem tmp = list[indexA];
110              list[indexA] = list[indexB];
111              list[indexB] = tmp;
112          }
113          private Task ItemUpdatedAsync(MudItemDropInfo<Column<T>> dropItem)
114          {
115              dropItem.Item.Identifier = dropItem.DropzoneIdentifier;
116              var dragAndDropSource = RenderedColumns.Where(rc => rc.PropertyName == dropItem.Item.PropertyName).SingleOrDefault();
117              var dragAndDropDestination = RenderedColumns.Where(rc => rc.PropertyName == dropItem.DropzoneIdentifier).SingleOrDefault();
118              if (dragAndDropSource != null && dragAndDropDestination != null)
119              {
120                  var dragAndDropSourceIndex = RenderedColumns.IndexOf(dragAndDropSource);
121                  var dragAndDropDestinationIndex = RenderedColumns.IndexOf(dragAndDropDestination);
122                  Swap<Column<T>>(RenderedColumns, dragAndDropSourceIndex, dragAndDropDestinationIndex);
123                  var dest = dragAndDropDestination.HeaderCell.Width;
124                  var src = dragAndDropSource.HeaderCell.Width;
125                  dragAndDropSource.HeaderCell.Width = dest;
126                  dragAndDropDestination.HeaderCell.Width = src;
127                  StateHasChanged();
128              }
129              return Task.CompletedTask;
130          }
131          public readonly List<Column<T>> RenderedColumns = new List<Column<T>>();
132          internal T _editingItem;
133          internal T editingSourceItem;
134          internal T _previousEditingItem;
135          internal bool isEditFormOpen;
136          private Converter<bool, bool?> _oppositeBoolConverter = new Converter<bool, bool?>
137          {
138              SetFunc = value => value ? false : true,
139              GetFunc = value => value.HasValue ? !value.Value : true,
140          };
141          #region Notify Children Delegates
142          internal Action<Dictionary<string, SortDefinition<T>>, HashSet<string>> SortChangedEvent { get; set; }
143          internal Action<HashSet<T>> SelectedItemsChangedEvent { get; set; }
144          internal Action<bool> SelectedAllItemsChangedEvent { get; set; }
145          internal Action StartedEditingItemEvent { get; set; }
146          internal Action EditingCanceledEvent { get; set; }
147          public Action PagerStateHasChangedEvent { get; set; }
148          #endregion
149          #region EventCallbacks
150          [Parameter] public EventCallback<T> SelectedItemChanged { get; set; }
151          [Parameter] public EventCallback<HashSet<T>> SelectedItemsChanged { get; set; }
152          [Parameter] public EventCallback<DataGridRowClickEventArgs<T>> RowClick { get; set; }
153          [Parameter] public EventCallback<T> StartedEditingItem { get; set; }
154          [Parameter] public EventCallback<T> CanceledEditingItem { get; set; }
155          [Obsolete("Use CanceledEditingItem instead", false)]
156          [Parameter] public EventCallback<T> CancelledEditingItem { get => CanceledEditingItem; set => CanceledEditingItem = value; }
157          [Parameter] public EventCallback<T> CommittedItemChanges { get; set; }
158          [Parameter] public EventCallback<FormFieldChangedEventArgs> FormFieldChanged { get; set; }
159          #endregion
160          #region Parameters
161          [Parameter] public bool DragDropColumnReordering { get; set; } = false;
162          [Parameter] public string DragIndicatorIcon { get; set; } = Icons.Material.Filled.DragIndicator;
163          [Parameter] public Size DragIndicatorSize { get; set; } = Size.Small;
164          [Parameter] public string DropAllowedClass { get; set; } = "drop-allowed";
165          [Parameter] public string DropNotAllowedClass { get; set; } = "drop-not-allowed";
166          [Parameter] public bool ApplyDropClassesOnDragStarted { get; set; } = false;
167          [Parameter] public SortMode SortMode { get; set; } = SortMode.Multiple;
168          [Parameter] public bool Filterable { get; set; } = false;
169          [Parameter] public bool Hideable { get; set; } = false;
170          [Parameter] public bool ShowColumnOptions { get; set; } = true;
171          [Parameter] public Breakpoint Breakpoint { get; set; } = Breakpoint.Xs;
172          [Parameter] public int Elevation { set; get; } = 1;
173          [Parameter] public bool Square { get; set; }
174          [Parameter] public bool Outlined { get; set; }
175          [Parameter] public bool Bordered { get; set; }
176          [Parameter] public RenderFragment ColGroup { get; set; }
177          [Parameter] public bool Dense { get; set; }
178          [Parameter] public bool Hover { get; set; }
179          [Parameter] public bool Striped { get; set; }
180          [Parameter] public bool FixedHeader { get; set; }
181          [Parameter] public bool FixedFooter { get; set; }
182          [Parameter] public bool ShowFilterIcons { get; set; } = true;
183          [Parameter] public DataGridFilterMode FilterMode { get; set; }
184          [Parameter] public DataGridFilterCaseSensitivity FilterCaseSensitivity { get; set; }
185          [Parameter] public RenderFragment<MudDataGrid<T>> FilterTemplate { get; set; }
186          [Parameter] public List<IFilterDefinition<T>> FilterDefinitions { get; set; } = new List<IFilterDefinition<T>>();
187          [Parameter] public Dictionary<string, SortDefinition<T>> SortDefinitions { get; set; } = new Dictionary<string, SortDefinition<T>>();
188          [Parameter] public bool Virtualize { get; set; }
189          [Parameter] public int OverscanCount { get; set; } = 3;
190          [Parameter] public string RowClass { get; set; }
191          [Parameter] public string RowStyle { get; set; }
192          [Parameter] public Func<T, int, string> RowClassFunc { get; set; }
193          [Parameter] public Func<T, int, string> RowStyleFunc { get; set; }
194          [Parameter] public bool MultiSelection { get; set; }
195          [Parameter] public DataGridEditMode? EditMode { get; set; }
196          [Parameter] public DataGridEditTrigger? EditTrigger { get; set; } = DataGridEditTrigger.Manual;
197          [Parameter] public DialogOptions EditDialogOptions { get; set; }
198          [Parameter]
199          public IEnumerable<T> Items
200          {
201              get => _items;
202              set
203              {
204                  if (_items == value)
205                      return;
206                  _items = value;
207                  if (PagerStateHasChangedEvent != null)
208                      InvokeAsync(PagerStateHasChangedEvent);
209                  if (Groupable)
210                  {
211                      GroupItems();
212                  }
213                  if (_items is INotifyCollectionChanged changed)
214                  {
215                      changed.CollectionChanged += (s, e) =>
216                      {
217                          _currentRenderFilteredItemsCache = null;
218                          if (Groupable)
219                              GroupItems();
220                      };
221                  }
222              }
223          }
224          [Parameter] public bool Loading { get; set; }
225          [Parameter] public bool CanCancelEdit { get; set; } = true;
226          [Parameter] public Color LoadingProgressColor { get; set; } = Color.Info;
227          [Parameter] public RenderFragment ToolBarContent { get; set; }
228          [Parameter] public bool HorizontalScrollbar { get; set; }
229          [Parameter] public ResizeMode ColumnResizeMode { get; set; }
230          [Parameter] public string HeaderClass { get; set; }
231          [Parameter] public string Height { get; set; }
232          [Parameter] public string FooterClass { get; set; }
233          [Parameter] public Func<T, bool> QuickFilter { get; set; } = null;
234          [Parameter] public RenderFragment Header { get; set; }
235          [Parameter] public RenderFragment Columns { get; set; }
236          [Parameter]
237          public CultureInfo Culture { get; set; }
238          [Parameter] public RenderFragment<CellContext<T>> ChildRowContent { get; set; }
239          [Parameter] public RenderFragment NoRecordsContent { get; set; }
240          [Parameter] public RenderFragment LoadingContent { get; set; }
241          [Parameter] public RenderFragment PagerContent { get; set; }
242          [Parameter] public Func<GridState<T>, Task<GridData<T>>> ServerData { get; set; }
243          [Parameter]
244          public int RowsPerPage
245          {
246              get => _rowsPerPage ?? 10;
247              set
248              {
249                  if (_rowsPerPage == null)
250                      InvokeAsync(() => SetRowsPerPageAsync(value));
251              }
252          }
253          [Parameter]
254          public int CurrentPage
255          {
256              get => _currentPage;
257              set
258              {
259                  if (_currentPage == value)
260                      return;
261                  _currentPage = value;
262                  InvokeAsync(StateHasChanged);
263                  if (_isFirstRendered)
264                      InvokeAsync(InvokeServerLoadFunc);
265              }
266          }
267          [Parameter] public bool ReadOnly { get; set; } = true;
268          [Parameter]
269          public HashSet<T> SelectedItems
270          {
271              get
272              {
273                  if (!MultiSelection)
274                      if (_selectedItem is null)
275                          return new HashSet<T>(Array.Empty<T>());
276                      else
277                          return new HashSet<T>(new T[] { _selectedItem });
278                  else
279                      return Selection;
280              }
281              set
282              {
283                  if (value == Selection)
284                      return;
285                  if (value == null)
286                  {
287                      if (Selection.Count == 0)
288                          return;
289                      Selection = new HashSet<T>();
290                  }
291                  else
292                      Selection = value;
293                  SelectedItemsChangedEvent?.Invoke(Selection);
294                  SelectedItemsChanged.InvokeAsync(Selection);
295                  InvokeAsync(StateHasChanged);
296              }
297          }
298          [Parameter]
299          public T SelectedItem
300          {
301              get => _selectedItem;
302              set
303              {
304                  if (EqualityComparer<T>.Default.Equals(SelectedItem, value))
305                      return;
306                  _selectedItem = value;
307                  SelectedItemChanged.InvokeAsync(value);
308              }
309          }
310          [Parameter]
311          public bool Groupable
312          {
313              get { return _groupable; }
314              set
315              {
316                  if (_groupable != value)
317                  {
318                      _groupable = value;
319                      if (!_groupable)
320                      {
321                          _currentPageGroups.Clear();
322                          _allGroups.Clear();
323                          _groupExpansions.Clear();
324                          _groupExpansions.Add("__initial__");
325                          foreach (var column in RenderedColumns)
326                              column.RemoveGrouping();
327                      }
328                  }
329              }
330          }
331          private bool _groupable = false;
332          [Parameter] public bool GroupExpanded { get; set; }
333          [Parameter] public string GroupClass { get; set; }
334          [Parameter] public string GroupStyle { get; set; }
335          [Parameter] public Func<GroupDefinition<T>, string> GroupClassFunc { get; set; }
336          [Parameter] public Func<GroupDefinition<T>, string> GroupStyleFunc { get; set; }
337          [Parameter] public bool ShowMenuIcon { get; set; } = false;
338          #endregion
339          #region Properties
340          internal IEnumerable<T> CurrentPageItems
341          {
342              get
343              {
344                  if (@PagerContent == null)
345                  {
346                      return FilteredItems; 
347                  }
348                  if (ServerData == null)
349                  {
350                      var filteredItemCount = GetFilteredItemsCount();
351                      int lastPageNo;
352                      if (filteredItemCount == 0)
353                          lastPageNo = 0;
354                      else
355                          lastPageNo = (filteredItemCount / RowsPerPage) - (filteredItemCount % RowsPerPage == 0 ? 1 : 0);
356                      CurrentPage = lastPageNo < CurrentPage ? lastPageNo : CurrentPage;
357                  }
358                  return GetItemsOfPage(CurrentPage, RowsPerPage);
359              }
360          }
361          public HashSet<T> Selection { get; set; } = new HashSet<T>();
362          public bool HasPager { get; set; }
363          public IEnumerable<T> ServerItems => _server_data.Items;
364          private GridData<T> _server_data = new GridData<T>() { TotalItems = 0, Items = Array.Empty<T>() };
365          private IEnumerable<T> _currentRenderFilteredItemsCache = null;
366          internal uint FilteringRunCount { get; private set; }
367          public IEnumerable<T> FilteredItems
368          {
369              get
370              {
371                  if (_currentRenderFilteredItemsCache != null) return _currentRenderFilteredItemsCache;
372                  var items = ServerData != null
373                      ? _server_data.Items
374                      : Items;
375                  if (QuickFilter != null)
376                  {
377                      items = items.Where(QuickFilter);
378                  }
379                  if (ServerData is null)
380                  {
381                      foreach (var filterDefinition in FilterDefinitions)
382                      {
383                          var filterFunc = filterDefinition.GenerateFilterFunction(new FilterOptions
384                          {
385                              FilterCaseSensitivity = FilterCaseSensitivity
386                          });
387                          items = items.Where(filterFunc);
388                      }
389                  }
390                  _currentRenderFilteredItemsCache = Sort(items).ToList(); 
391                  unchecked { FilteringRunCount++; }
392                  GroupItems(noStateChange: true);
393                  return _currentRenderFilteredItemsCache;
394              }
395          }
396          public Interfaces.IForm Validator { get; set; } = new DataGridRowValidator();
397          internal Column<T> GroupedColumn
398          {
399              get
400              {
401                  return RenderedColumns.FirstOrDefault(x => x.grouping);
402              }
403          }
404          #endregion
405          #region Computed Properties
406          private bool hasFooter
407          {
408              get
409              {
410                  return RenderedColumns.Any(x => !x.Hidden && (x.FooterTemplate != null || x.AggregateDefinition != null));
411              }
412          }
413          private bool hasStickyColumns
414          {
415              get
416              {
417                  return RenderedColumns.Any(x => x.StickyLeft || x.StickyRight);
418              }
419          }
420          private bool hasHierarchyColumn
421          {
422              get
423              {
424                  return RenderedColumns.Any(x => x.Tag?.ToString() == "hierarchy-column");
425              }
426          }
427          #endregion
428          [UnconditionalSuppressMessage("Trimming", "IL2046: 'RequiresUnreferencedCodeAttribute' annotations must match across all interface implementations or overrides.", Justification = "Suppressing because we annotating the whole component with RequiresUnreferencedCodeAttribute for information that generic type must be preserved.")]
429          protected override async Task OnAfterRenderAsync(bool firstRender)
430          {
431              if (firstRender)
432              {
433                  await InvokeServerLoadFunc();
434                  if (ServerData == null)
435                      StateHasChanged();
436                  _isFirstRendered = true;
437              }
438              else
439              {
440                  PagerStateHasChangedEvent?.Invoke();
441              }
442              await base.OnAfterRenderAsync(firstRender);
443          }
444          [UnconditionalSuppressMessage("Trimming", "IL2046: 'RequiresUnreferencedCodeAttribute' annotations must match across all interface implementations or overrides.", Justification = "Suppressing because we annotating the whole component with RequiresUnreferencedCodeAttribute for information that generic type must be preserved.")]
445          public override async Task SetParametersAsync(ParameterView parameters)
446          {
447              var sortModeBefore = SortMode;
448              await base.SetParametersAsync(parameters);
449              if (parameters.TryGetValue(nameof(SortMode), out SortMode sortMode) && sortMode != sortModeBefore)
450                  await ClearCurrentSortings();
451          }
452          #region Methods
453          protected IEnumerable<T> GetItemsOfPage(int page, int pageSize)
454          {
455              if (page < 0 || pageSize <= 0)
456                  return Array.Empty<T>();
457              if (ServerData != null)
458              {
459                  return QuickFilter != null
460                      ? _server_data.Items.Where(QuickFilter)
461                      : _server_data.Items;
462              }
463              return FilteredItems.Skip(page * pageSize).Take(pageSize);
464          }
465          internal async Task InvokeServerLoadFunc()
466          {
467              if (ServerData == null)
468                  return;
469              Loading = true;
470              StateHasChanged();
471              var state = new GridState<T>
472              {
473                  Page = CurrentPage,
474                  PageSize = RowsPerPage,
475                  SortDefinitions = SortDefinitions.Values.OrderBy(sd => sd.Index).ToList(),
476                  FilterDefinitions = FilterDefinitions.ToList()
477              };
478              _server_data = await ServerData(state);
479              _currentRenderFilteredItemsCache = null;
480              if (CurrentPage * RowsPerPage > _server_data.TotalItems)
481                  CurrentPage = 0;
482              Loading = false;
483              StateHasChanged();
484              PagerStateHasChangedEvent?.Invoke();
485          }
486          internal void AddColumn(Column<T> column)
487          {
488              if (column.Tag?.ToString() == "hierarchy-column")
489              {
490                  RenderedColumns.Insert(0, column);
491              }
492              else if (column.Tag?.ToString() == "select-column")
493              {
494                  if (RenderedColumns.Select(x => x.Tag).Contains("hierarchy-column"))
495                  {
496                      RenderedColumns.Insert(1, column);
497                  }
498                  else
499                  {
500                      RenderedColumns.Insert(0, column);
501                  }
502              }
503              else
504              {
505                  RenderedColumns.Add(column);
506              }
507          }
508          internal IFilterDefinition<T> CreateFilterDefinitionInstance()
509          {
510              return _defaultFilterDefinitionFactory();
511          }
512          public void SetDefaultFilterDefinition<TFilterDefinition>() where TFilterDefinition : IFilterDefinition<T>, new()
513          {
514              SetDefaultFilterDefinition(() => new TFilterDefinition());
515          }
516          public void SetDefaultFilterDefinition(Func<IFilterDefinition<T>> factory)
517          {
518              _defaultFilterDefinitionFactory = factory;
519          }
520          public void AddFilter()
521          {
522              var column = RenderedColumns.FirstOrDefault(x => x.filterable);
523              var filterDefinition = CreateFilterDefinitionInstance();
524              filterDefinition.Id = Guid.NewGuid();
525              filterDefinition.Title = column?.Title;
526              filterDefinition.Column = column;
<span onclick='openModal()' class='match'>527              FilterDefinitions.Add(filterDefinition);
528              _filtersMenuVisible = true;
529              StateHasChanged();
530          }
</span>531          internal Task ApplyFiltersAsync()
532          {
533              _filtersMenuVisible = false;
534              return InvokeServerLoadFunc();
535          }
536          public Task ClearFiltersAsync()
537          {
538              FilterDefinitions.Clear();
539              return InvokeServerLoadFunc();
540          }
541          public async Task AddFilterAsync(IFilterDefinition<T> definition)
542          {
543              FilterDefinitions.Add(definition);
544              _filtersMenuVisible = true;
545              await InvokeServerLoadFunc();
546              if (ServerData is null) StateHasChanged();
547          }
548          internal async Task RemoveFilterAsync(Guid id)
549          {
550              FilterDefinitions.RemoveAll(x => x.Id == id);
551              await InvokeServerLoadFunc();
552              GroupItems();
553          }
554          internal async Task SetSelectedItemAsync(bool value, T item)
555          {
556              if (value)
557                  Selection.Add(item);
558              else
559                  Selection.Remove(item);
560              await InvokeAsync(() => SelectedItemsChangedEvent.Invoke(SelectedItems));
561              await SelectedItemsChanged.InvokeAsync(SelectedItems);
562              await InvokeAsync(StateHasChanged);
563          }
564          internal async Task SetSelectAllAsync(bool value)
565          {
566              var items = ServerData != null
567                      ? ServerItems
568                      : Items;
569              if (value)
570                  Selection = new HashSet<T>(items);
571              else
572                  Selection.Clear();
573              SelectedItemsChangedEvent?.Invoke(SelectedItems);
574              SelectedAllItemsChangedEvent?.Invoke(value);
575              await SelectedItemsChanged.InvokeAsync(SelectedItems);
576              StateHasChanged();
577          }
578          internal IEnumerable<T> Sort(IEnumerable<T> items)
579          {
580              if (null == items || !items.Any())
581                  return items;
582              if (null == SortDefinitions || 0 == SortDefinitions.Count)
583                  return items;
584              IOrderedEnumerable<T> orderedEnumerable = null;
585              foreach (var sortDefinition in SortDefinitions.Values.Where(sd => sd.SortFunc != null).OrderBy(sd => sd.Index))
586              {
587                  if (null == orderedEnumerable)
588                      orderedEnumerable = sortDefinition.Descending ? items.OrderByDescending(item => sortDefinition.SortFunc(item), sortDefinition.Comparer)
589                          : items.OrderBy(item => sortDefinition.SortFunc(item), sortDefinition.Comparer);
590                  else
591                      orderedEnumerable = sortDefinition.Descending ? orderedEnumerable.ThenByDescending(item => sortDefinition.SortFunc(item), sortDefinition.Comparer)
592                          : orderedEnumerable.ThenBy(item => sortDefinition.SortFunc(item), sortDefinition.Comparer);
593              }
594              return orderedEnumerable ?? items;
595          }
596          internal void ClearEditingItem()
597          {
598              _editingItem = default;
599              editingSourceItem = default;
600          }
601          internal async Task CommitItemChangesAsync(T item)
602          {
603              await CommittedItemChanges.InvokeAsync(item);
604          }
605          internal async Task CommitItemChangesAsync()
606          {
607              if (editingSourceItem != null)
608              {
609                  foreach (var property in _properties)
610                  {
611                      if (property.CanWrite)
612                          property.SetValue(editingSourceItem, property.GetValue(_editingItem));
613                  }
614                  await CommittedItemChanges.InvokeAsync(editingSourceItem);
615                  ClearEditingItem();
616                  isEditFormOpen = false;
617              }
618          }
619          internal async Task OnRowClickedAsync(MouseEventArgs args, T item, int rowIndex)
620          {
621              await RowClick.InvokeAsync(new DataGridRowClickEventArgs<T>(args, item, rowIndex));
622              if (EditMode != DataGridEditMode.Cell && EditTrigger == DataGridEditTrigger.OnRowClick)
623                  await SetEditingItemAsync(item);
624              await SetSelectedItemAsync(item);
625          }
626          public int GetFilteredItemsCount()
627          {
628              if (ServerData != null)
629                  return _server_data.TotalItems;
630              return FilteredItems.Count();
631          }
632          public void NavigateTo(Page page)
633          {
634              switch (page)
635              {
636                  case Page.First:
637                      CurrentPage = 0;
638                      break;
639                  case Page.Last:
640                      CurrentPage = Math.Max(0, numPages - 1);
641                      break;
642                  case Page.Next:
643                      CurrentPage = Math.Min(numPages - 1, CurrentPage + 1);
644                      break;
645                  case Page.Previous:
646                      CurrentPage = Math.Max(0, CurrentPage - 1);
647                      break;
648              }
649              GroupItems();
650          }
651          public async Task SetRowsPerPageAsync(int size)
652          {
653              if (_rowsPerPage == size)
654                  return;
655              _rowsPerPage = size;
656              CurrentPage = 0;
657              StateHasChanged();
658              if (_isFirstRendered)
659                  await InvokeAsync(InvokeServerLoadFunc);
660          }
661          public async Task SetSortAsync(string field, SortDirection direction, Func<T, object> sortFunc, IComparer<object> comparer = null)
662          {
663              var removedSortDefinitions = new HashSet<string>(SortDefinitions.Keys);
664              SortDefinitions.Clear();
665              var newDefinition = new SortDefinition<T>(field, direction == SortDirection.Descending, 0, sortFunc, comparer);
666              SortDefinitions[field] = newDefinition;
667              removedSortDefinitions.Remove(field);
668              await InvokeSortUpdates(SortDefinitions, removedSortDefinitions);
669          }
670          public async Task ExtendSortAsync(string field, SortDirection direction, Func<T, object> sortFunc, IComparer<object> comparer = null)
671          {
672              if (SortMode != SortMode.Multiple)
673              {
674                  await SetSortAsync(field, direction, sortFunc, comparer);
675                  return;
676              }
677              if (SortDefinitions.TryGetValue(field, out var sortDefinition))
678                  SortDefinitions[field] = sortDefinition with { Descending = direction == SortDirection.Descending, SortFunc = sortFunc, Comparer = comparer };
679              else
680              {
681                  var newDefinition = new SortDefinition<T>(field, direction == SortDirection.Descending, SortDefinitions.Count, sortFunc, comparer);
682                  SortDefinitions[field] = newDefinition;
683              }
684              await InvokeSortUpdates(SortDefinitions, null);
685          }
686          public async Task RemoveSortAsync(string field)
687          {
688              if (!string.IsNullOrWhiteSpace(field) && SortDefinitions.TryGetValue(field, out var definition))
689              {
690                  SortDefinitions.Remove(field);
691                  foreach (var defToUpdate in SortDefinitions.Where(kvp => kvp.Value.Index > definition.Index).ToList())
692                      SortDefinitions[defToUpdate.Key] = defToUpdate.Value with { Index = defToUpdate.Value.Index - 1 };
693                  await InvokeSortUpdates(SortDefinitions, new HashSet<string>() { field });
694              }
695          }
696          private async Task ClearCurrentSortings()
697          {
698              var removedSortDefinitions = new HashSet<string>(SortDefinitions.Keys);
699              SortDefinitions.Clear();
700              await InvokeSortUpdates(SortDefinitions, removedSortDefinitions);
701          }
702          private async Task InvokeSortUpdates(Dictionary<string, SortDefinition<T>> activeSortDefinitions, HashSet<string> removedSortDefinitions)
703          {
704              SortChangedEvent?.Invoke(activeSortDefinitions, removedSortDefinitions);
705              if (_isFirstRendered)
706              {
707                  await InvokeServerLoadFunc();
708                  if (ServerData == null)
709                      StateHasChanged();
710              }
711          }
712          public async Task SetSelectedItemAsync(T item)
713          {
714              if (MultiSelection)
715              {
716                  if (Selection.Contains(item))
717                  {
718                      Selection.Remove(item);
719                  }
720                  else
721                  {
722                      Selection.Add(item);
723                  }
724                  SelectedItemsChangedEvent?.Invoke(SelectedItems);
725                  await SelectedItemsChanged.InvokeAsync(SelectedItems);
726              }
727              SelectedItem = item;
728          }
729          [UnconditionalSuppressMessage("Trimming", "IL2026: Using member 'System.Text.Json.JsonSerializer.Deserialize<T>(string, System.Text.Json.JsonSerializerOptions?)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code. JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.", Justification = "Suppressing because T is a type supplied by the user and it is unlikely that it is not referenced by their code.")]
730          public async Task SetEditingItemAsync(T item)
731          {
732              if (ReadOnly) return;
733              editingSourceItem = item;
734              EditingCanceledEvent?.Invoke();
735              _previousEditingItem = _editingItem;
736              _editingItem = JsonSerializer.Deserialize<T>(JsonSerializer.Serialize(item));
737              StartedEditingItemEvent?.Invoke();
738              await StartedEditingItem.InvokeAsync(_editingItem);
739              isEditFormOpen = true;
740          }
741          public async Task CancelEditingItemAsync()
742          {
743              EditingCanceledEvent?.Invoke();
744              await CanceledEditingItem.InvokeAsync(_editingItem);
745              ClearEditingItem();
746              isEditFormOpen = false;
747          }
748          public void ToggleFiltersMenu()
749          {
750              _filtersMenuVisible = !_filtersMenuVisible;
751              StateHasChanged();
752          }
753          public Task ReloadServerData()
754          {
755              return InvokeServerLoadFunc();
756          }
757          public void OpenFilters()
758          {
759              _filtersMenuVisible = true;
760              StateHasChanged();
761          }
762          internal async Task HideAllColumnsAsync()
763          {
764              foreach (var column in RenderedColumns)
765              {
766                  if (column.Hideable ?? false)
767                      await column.HideAsync();
768              }
769              StateHasChanged();
770          }
771          internal async Task ShowAllColumnsAsync()
772          {
773              foreach (var column in RenderedColumns)
774              {
775                  if (column.Hideable ?? false)
776                      await column.ShowAsync();
777              }
778              StateHasChanged();
779          }
780          public void ShowColumnsPanel()
781          {
782              _columnsPanelVisible = true;
783              StateHasChanged();
784          }
785          public void HideColumnsPanel()
786          {
787              _columnsPanelVisible = false;
788              StateHasChanged();
789          }
790          internal void DropContainerHasChanged()
791          {
792              _dropContainer?.Refresh();
793          }
794          public void GroupItems(bool noStateChange = false)
795          {
796              if (GroupedColumn == null)
797              {
798                  _currentPageGroups = new List<GroupDefinition<T>>();
799                  _allGroups = new List<GroupDefinition<T>>();
800                  if (_isFirstRendered && !noStateChange)
801                      StateHasChanged();
802                  return;
803              }
804              var currentPageGroupings = CurrentPageItems.GroupBy(GroupedColumn.groupBy);
805              var allGroupings = FilteredItems.GroupBy(GroupedColumn.groupBy);
806              if (GetFilteredItemsCount() > 0 && _groupExpansions.Count == 0 && GroupExpanded)
807              {
808                  _groupExpansions.Add("__initial__");
809                  foreach (var group in allGroupings)
810                  {
811                      _groupExpansions.Add(group.Key);
812                  }
813              }
814              _currentPageGroups = currentPageGroupings.Select(x => new GroupDefinition<T>(x,
815                  _groupExpansions.Contains(x.Key))).ToList();
816              _allGroups = allGroupings.Select(x => new GroupDefinition<T>(x,
817                  _groupExpansions.Contains(x.Key))).ToList();                
818              if ((_isFirstRendered || ServerData != null) && !noStateChange)
819                  StateHasChanged();
820          }
821          internal void ChangedGrouping(Column<T> column)
822          {
823              foreach (var c in RenderedColumns)
824              {
825                  if (c.PropertyName != column.PropertyName)
826                      c.RemoveGrouping();
827              }
828              GroupItems();
829          }
830          internal void ToggleGroupExpansion(GroupDefinition<T> g)
831          {
832              if (_groupExpansions.Contains(g.Grouping.Key))
833              {
834                  _groupExpansions.Remove(g.Grouping.Key);
835              }
836              else
837              {
838                  _groupExpansions.Add(g.Grouping.Key);
839              }
840              GroupItems();
841          }
842          public void ExpandAllGroups()
843          {
844              foreach (var group in _allGroups)
845              {
846                  group.IsExpanded = true;
847                  _groupExpansions.Add(group.Grouping.Key);
848              }
849          }
850          public void CollapseAllGroups()
851          {
852              _groupExpansions.Clear();
853              _groupExpansions.Add("__initial__");
854              foreach (var group in _allGroups)
855                  group.IsExpanded = false;
856          }
857          #endregion
858          internal async Task ToggleHierarchyVisibilityAsync(T item)
859          {
860              if (_openHierarchies.Contains(item))
861              {
862                  _openHierarchies.Remove(item);
863              }
864              else
865              {
866                  _openHierarchies.Add(item);
867              }
868              await InvokeAsync(StateHasChanged);
869          }
870          #region Resize feature
871          [Inject] private IEventListener EventListener { get; set; }
872          internal bool IsResizing { get; set; }
873          private ElementReference _gridElement;
874          private DataGridColumnResizeService<T> _resizeService;
875          internal DataGridColumnResizeService<T> ResizeService
876          {
877              get
878              {
879                  return _resizeService ??= new DataGridColumnResizeService<T>(this, EventListener);
880              }
881          }
882          internal async Task<bool> StartResizeColumn(HeaderCell<T> headerCell, double clientX)
883              => await ResizeService.StartResizeColumn(headerCell, clientX, RenderedColumns, ColumnResizeMode);
884          internal async Task<double> GetActualHeight()
885          {
886              var gridRect = await _gridElement.MudGetBoundingClientRectAsync();
887              var gridHeight = gridRect.Height;
888              return gridHeight;
889          }
890          #endregion
891      }
892  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-SslSession.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudDataGrid.razor.cs</div>
                </div>
                <div class="column column_space"><pre><code>287                  _sslStream.EndAuthenticateAsServer(result);
288                  IsHandshaked = true;
289                  TryReceive();
290                  if (IsSocketDisposed)
</pre></code></div>
                <div class="column column_space"><pre><code>527              FilterDefinitions.Add(filterDefinition);
528              _filtersMenuVisible = true;
529              StateHasChanged();
530          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    