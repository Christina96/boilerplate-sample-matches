
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 246, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-iTween_121.cs</h3>
            <pre><code>1  #region Namespaces
2  using System;
3  using System.Collections;
4  using System.Collections.Generic;
5  using System.Reflection;
6  using UnityEngine;
7  #endregion
8  public class iTween : MonoBehaviour{
9  	#region Variables
10  	public static List&lt;Hashtable&gt; tweens = new List&lt;Hashtable&gt;();
11  	private static GameObject cameraFade;
12  	public string id, type, method;
13  	public iTween.EaseType easeType;
14  	public float time, delay;
15  	public LoopType loopType;
16  	public bool isRunning,isPaused;
17  	public string _name;
18   	private float runningTime, percentage;
19  	private float delayStarted; 
20  	private bool kinematic, isLocal, loop, reverse, wasPaused, physics;
21  	private Hashtable tweenArguments;
22  	private Space space;
23  	private delegate float EasingFunction(float start, float end, float Value);
24  	private delegate void ApplyTween();
25  	private EasingFunction ease;
26  	private ApplyTween apply;
27  	private AudioSource audioSource;
28  	private Vector3[] vector3s;
29  	private Vector2[] vector2s;
30  	private Color[,] colors;
31  	private float[] floats;
32  	private Rect[] rects;
33  	private CRSpline path;
34  	private Vector3 preUpdate;
35  	private Vector3 postUpdate;
36  	private NamedValueColor namedcolorvalue;
37      private float lastRealTime; 
38      private bool useRealTime; 
39  	private Transform thisTransform;
40  	public enum EaseType{
41  		easeInQuad,
42  		easeOutQuad,
43  		easeInOutQuad,
44  		easeInCubic,
45  		easeOutCubic,
46  		easeInOutCubic,
47  		easeInQuart,
48  		easeOutQuart,
49  		easeInOutQuart,
50  		easeInQuint,
51  		easeOutQuint,
52  		easeInOutQuint,
53  		easeInSine,
54  		easeOutSine,
55  		easeInOutSine,
56  		easeInExpo,
57  		easeOutExpo,
58  		easeInOutExpo,
59  		easeInCirc,
60  		easeOutCirc,
61  		easeInOutCirc,
62  		linear,
63  		spring,
64  		easeInBounce,
65  		easeOutBounce,
66  		easeInOutBounce,
67  		easeInBack,
68  		easeOutBack,
69  		easeInOutBack,
70  		easeInElastic,
71  		easeOutElastic,
72  		easeInOutElastic,
73  		punch
74  	}
75  	public enum LoopType{
76  		none,
77  		loop,
78  		pingPong
79  	}
80  	public enum NamedValueColor{
81  		_Color,
82  		_SpecColor,
83  		_Emission,
84  		_ReflectColor
85  	}
86  	#endregion
87  	#region Defaults
88  	public static class Defaults{
89  		public static float time = 1f;
90  		public static float delay = 0f;	
91  		public static NamedValueColor namedColorValue = NamedValueColor._Color;
92  		public static LoopType loopType = LoopType.none;
93  		public static EaseType easeType = iTween.EaseType.easeOutExpo;
94  		public static float lookSpeed = 3f;
95  		public static bool isLocal = false;
96  		public static Space space = Space.Self;
97  		public static bool orientToPath = false;
98  		public static Color color = Color.white;
99  		public static float updateTimePercentage = .05f;
100  		public static float updateTime = 1f*updateTimePercentage;
101  		public static int cameraFadeDepth = 999999;
102  		public static float lookAhead = .05f;
103          public static bool useRealTime = false; 
104  		public static Vector3 up = Vector3.up;
105  	}
106  	#endregion
107  	#region #1 Static Registers
108  	public static void Init(GameObject target){
109  		MoveBy(target,Vector3.zero,0);
110  	}
111  	public static void CameraFadeFrom(float amount, float time){
112  		if(cameraFade){
113  			CameraFadeFrom(Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
114  		}else{
115  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
116  		}
117  	}
118  	public static void CameraFadeFrom(Hashtable args){		
119  		if(cameraFade){
120  			ColorFrom(cameraFade,args);
121  		}else{
122  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
123  		}
124  	}	
125  	public static void CameraFadeTo(float amount, float time){
126  		if(cameraFade){
127  			CameraFadeTo(Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
128  		}else{
129  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
130  		}
131  	}	
132  	public static void CameraFadeTo(Hashtable args){
133  		if(cameraFade){
134  			ColorTo(cameraFade,args);
135  		}else{
136  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
137  		}
138  	}	
139  	public static void ValueTo(GameObject target, Hashtable args){
140  		args = iTween.CleanArgs(args);
141  		if (!args.Contains(&quot;onupdate&quot;) || !args.Contains(&quot;from&quot;) || !args.Contains(&quot;to&quot;)) {
142  			Debug.LogError(&quot;iTween Error: ValueTo() requires an &#x27;onupdate&#x27; callback function and a &#x27;from&#x27; and &#x27;to&#x27; property.  The supplied &#x27;onupdate&#x27; callback must accept a single argument that is the same type as the supplied &#x27;from&#x27; and &#x27;to&#x27; properties!&quot;);
143  			return;
144  		}else{
145  			args[&quot;type&quot;]=&quot;value&quot;;
146  			if (args[&quot;from&quot;].GetType() == typeof(Vector2)) {
147  				args[&quot;method&quot;]=&quot;vector2&quot;;
148  			}else if (args[&quot;from&quot;].GetType() == typeof(Vector3)) {
149  				args[&quot;method&quot;]=&quot;vector3&quot;;
150  			}else if (args[&quot;from&quot;].GetType() == typeof(Rect)) {
151  				args[&quot;method&quot;]=&quot;rect&quot;;
152  			}else if (args[&quot;from&quot;].GetType() == typeof(Single)) {
153  				args[&quot;method&quot;]=&quot;float&quot;;
154  			}else if (args[&quot;from&quot;].GetType() == typeof(Color)) {
155  				args[&quot;method&quot;]=&quot;color&quot;;
156  			}else{
157  				Debug.LogError(&quot;iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!&quot;);
158  				return;	
159  			}
160  			if (!args.Contains(&quot;easetype&quot;)) {
161  				args.Add(&quot;easetype&quot;,EaseType.linear);
162  			}
163  			Launch(target,args);
164  		}
165  	}
166  	public static void FadeFrom(GameObject target, float alpha, float time){
167  		FadeFrom(target,Hash(&quot;alpha&quot;,alpha,&quot;time&quot;,time));
168  	}
169  	public static void FadeFrom(GameObject target, Hashtable args){	
170  		ColorFrom(target,args);
171  	}		
172  	public static void FadeTo(GameObject target, float alpha, float time){
173  		FadeTo(target,Hash(&quot;alpha&quot;,alpha,&quot;time&quot;,time));
174  	}	
175  	public static void FadeTo(GameObject target, Hashtable args){
176  		ColorTo(target,args);
177  	}		
178  	public static void ColorFrom(GameObject target, Color color, float time){
179  		ColorFrom(target,Hash(&quot;color&quot;,color,&quot;time&quot;,time));
180  	}
181  	public static void ColorFrom(GameObject target, Hashtable args){	
182  		Color fromColor = new Color();
183  		Color tempColor = new Color();
184  		args = iTween.CleanArgs(args);
185  		if(!args.Contains(&quot;includechildren&quot;) || (bool)args[&quot;includechildren&quot;]){
186  			foreach(Transform child in target.transform){
187  				Hashtable argsCopy = (Hashtable)args.Clone();
188  				argsCopy[&quot;ischild&quot;]=true;
189  				ColorFrom(child.gameObject,argsCopy);
190  			}
191  		}
192  		if (!args.Contains(&quot;easetype&quot;)) {
193  			args.Add(&quot;easetype&quot;,EaseType.linear);
194  		}
195  		if(target.GetComponent&lt;GUITexture&gt;()){
196  			tempColor=fromColor=target.guiTexture.color;	
197  		}else if(target.GetComponent&lt;GUIText&gt;()){
198  			tempColor=fromColor=target.guiText.material.color;
199  		}else if(target.renderer){
200  			tempColor=fromColor=target.renderer.material.color;
201  		}else if(target.light){
202  			tempColor=fromColor=target.light.color;
203  		}
204  		if(args.Contains(&quot;color&quot;)){
205  			fromColor=(Color)args[&quot;color&quot;];
206  		}else{
207  			if (args.Contains(&quot;r&quot;)) {
208  				fromColor.r=(float)args[&quot;r&quot;];
209  			}
210  			if (args.Contains(&quot;g&quot;)) {
211  				fromColor.g=(float)args[&quot;g&quot;];
212  			}
213  			if (args.Contains(&quot;b&quot;)) {
214  				fromColor.b=(float)args[&quot;b&quot;];
215  			}
216  			if (args.Contains(&quot;a&quot;)) {
217  				fromColor.a=(float)args[&quot;a&quot;];
218  			}
219  		}
220  		if(args.Contains(&quot;amount&quot;)){
221  			fromColor.a=(float)args[&quot;amount&quot;];
222  			args.Remove(&quot;amount&quot;);
223  		}else if(args.Contains(&quot;alpha&quot;)){
224  			fromColor.a=(float)args[&quot;alpha&quot;];
225  			args.Remove(&quot;alpha&quot;);
226  		}
227  		if(target.GetComponent&lt;GUITexture&gt;()){
228  			target.guiTexture.color=fromColor;	
229  		}else if(target.GetComponent&lt;GUIText&gt;()){
230  			target.guiText.material.color=fromColor;
231  		}else if(target.renderer){
232  			target.renderer.material.color=fromColor;
233  		}else if(target.light){
234  			target.light.color=fromColor;
235  		}
236  		args[&quot;color&quot;]=tempColor;
237  		args[&quot;type&quot;]=&quot;color&quot;;
238  		args[&quot;method&quot;]=&quot;to&quot;;
239  		Launch(target,args);
240  	}		
241  	public static void ColorTo(GameObject target, Color color, float time){
242  		ColorTo(target,Hash(&quot;color&quot;,color,&quot;time&quot;,time));
243  	}
244  	public static void ColorTo(GameObject target, Hashtable args){	
245  		args = iTween.CleanArgs(args);
246  		if(!args.Contains(&quot;includechildren&quot;) || (bool)args[&quot;includechildren&quot;]){
247  			foreach(Transform child in target.transform){
248  				Hashtable argsCopy = (Hashtable)args.Clone();
249  				argsCopy[&quot;ischild&quot;]=true;
250  				ColorTo(child.gameObject,argsCopy);
251  			}
252  		}
253  		if (!args.Contains(&quot;easetype&quot;)) {
254  			args.Add(&quot;easetype&quot;,EaseType.linear);
255  		}
256  		args[&quot;type&quot;]=&quot;color&quot;;
257  		args[&quot;method&quot;]=&quot;to&quot;;
258  		Launch(target,args);
259  	}	
260  	public static void AudioFrom(GameObject target, float volume, float pitch, float time){
261  		AudioFrom(target,Hash(&quot;volume&quot;,volume,&quot;pitch&quot;,pitch,&quot;time&quot;,time));
262  	}
263  	public static void AudioFrom(GameObject target, Hashtable args){
264  		Vector2 tempAudioProperties;
265  		Vector2 fromAudioProperties;
266  		AudioSource tempAudioSource;
267  		args = iTween.CleanArgs(args);
268  		if(args.Contains(&quot;audiosource&quot;)){
269  			tempAudioSource=(AudioSource)args[&quot;audiosource&quot;];
270  		}else{
271  			if(target.GetComponent&lt;AudioSource&gt;()){
272  				tempAudioSource=target.audio;
273  			}else{
274  				Debug.LogError(&quot;iTween Error: AudioFrom requires an AudioSource.&quot;);
275  				return;
276  			}
277  		}			
278  		tempAudioProperties.x=fromAudioProperties.x=tempAudioSource.volume;
279  		tempAudioProperties.y=fromAudioProperties.y=tempAudioSource.pitch;
280  		if(args.Contains(&quot;volume&quot;)){
281  			fromAudioProperties.x=(float)args[&quot;volume&quot;];
282  		}
283  		if(args.Contains(&quot;pitch&quot;)){
284  			fromAudioProperties.y=(float)args[&quot;pitch&quot;];
285  		}
286  		tempAudioSource.volume=fromAudioProperties.x;
287  		tempAudioSource.pitch=fromAudioProperties.y;
288  		args[&quot;volume&quot;]=tempAudioProperties.x;
289  		args[&quot;pitch&quot;]=tempAudioProperties.y;
290  		if (!args.Contains(&quot;easetype&quot;)) {
291  			args.Add(&quot;easetype&quot;,EaseType.linear);
292  		}
293  		args[&quot;type&quot;]=&quot;audio&quot;;
294  		args[&quot;method&quot;]=&quot;to&quot;;
295  		Launch(target,args);			
296  	}		
297  	public static void AudioTo(GameObject target, float volume, float pitch, float time){
298  		AudioTo(target,Hash(&quot;volume&quot;,volume,&quot;pitch&quot;,pitch,&quot;time&quot;,time));
299  	}
300  	public static void AudioTo(GameObject target, Hashtable args){
301  		args = iTween.CleanArgs(args);
302  		if (!args.Contains(&quot;easetype&quot;)) {
303  			args.Add(&quot;easetype&quot;,EaseType.linear);
304  		}
305  		args[&quot;type&quot;]=&quot;audio&quot;;
306  		args[&quot;method&quot;]=&quot;to&quot;;
307  		Launch(target,args);			
308  	}	
309  	public static void Stab(GameObject target, AudioClip audioclip, float delay){
310  		Stab(target,Hash(&quot;audioclip&quot;,audioclip,&quot;delay&quot;,delay));
311  	}
312  	public static void Stab(GameObject target, Hashtable args){
313  		args = iTween.CleanArgs(args);
314  		args[&quot;type&quot;]=&quot;stab&quot;;
315  		Launch(target,args);			
316  	}
317  	public static void LookFrom(GameObject target, Vector3 looktarget, float time){
318  		LookFrom(target,Hash(&quot;looktarget&quot;,looktarget,&quot;time&quot;,time));
319  	}	
320  	public static void LookFrom(GameObject target, Hashtable args){
321  		Vector3 tempRotation;
322  		Vector3 tempRestriction;
323  		args = iTween.CleanArgs(args);
324  		tempRotation=target.transform.eulerAngles;
325  		if (args[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
326  			target.transform.LookAt((Transform)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
327  		}else if(args[&quot;looktarget&quot;].GetType() == typeof(Vector3)){
328  			target.transform.LookAt((Vector3)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
329  		}
330  		if(args.Contains(&quot;axis&quot;)){
331  			tempRestriction=target.transform.eulerAngles;
332  			switch((string)args[&quot;axis&quot;]){
333  				case &quot;x&quot;:
334  				 	tempRestriction.y=tempRotation.y;
335  					tempRestriction.z=tempRotation.z;
336  				break;
337  				case &quot;y&quot;:
338  					tempRestriction.x=tempRotation.x;
339  					tempRestriction.z=tempRotation.z;
340  				break;
341  				case &quot;z&quot;:
342  					tempRestriction.x=tempRotation.x;
343  					tempRestriction.y=tempRotation.y;
344  				break;
345  			}
346  			target.transform.eulerAngles=tempRestriction;
347  		}		
348  		args[&quot;rotation&quot;] = tempRotation;
349  		args[&quot;type&quot;]=&quot;rotate&quot;;
350  		args[&quot;method&quot;]=&quot;to&quot;;
351  		Launch(target,args);
352  	}		
353  	public static void LookTo(GameObject target, Vector3 looktarget, float time){
354  		LookTo(target,Hash(&quot;looktarget&quot;,looktarget,&quot;time&quot;,time));
355  	}
356  	public static void LookTo(GameObject target, Hashtable args){		
357  		args = iTween.CleanArgs(args);			
358  		if(args.Contains(&quot;looktarget&quot;)){
359  			if (args[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
360  				Transform transform = (Transform)args[&quot;looktarget&quot;];
361  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
362  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
363  			}
364  		}
365  		args[&quot;type&quot;]=&quot;look&quot;;
366  		args[&quot;method&quot;]=&quot;to&quot;;
367  		Launch(target,args);
368  	}		
369  	public static void MoveTo(GameObject target, Vector3 position, float time){
370  		MoveTo(target,Hash(&quot;position&quot;,position,&quot;time&quot;,time));
371  	}	
372  	public static void MoveTo(GameObject target, Hashtable args){
373  		args = iTween.CleanArgs(args);
374  		if(args.Contains(&quot;position&quot;)){
375  			if (args[&quot;position&quot;].GetType() == typeof(Transform)) {
376  				Transform transform = (Transform)args[&quot;position&quot;];
377  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
378  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
379  				args[&quot;scale&quot;]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);
380  			}
381  		}		
382  		args[&quot;type&quot;]=&quot;move&quot;;
383  		args[&quot;method&quot;]=&quot;to&quot;;
384  		Launch(target,args);
385  	}
386  	public static void MoveFrom(GameObject target, Vector3 position, float time){
387  		MoveFrom(target,Hash(&quot;position&quot;,position,&quot;time&quot;,time));
388  	}		
389  	public static void MoveFrom(GameObject target, Hashtable args){
390  			args = iTween.CleanArgs(args);
391  		bool tempIsLocal;
392  		if(args.Contains(&quot;islocal&quot;)){
393  			tempIsLocal = (bool)args[&quot;islocal&quot;];
394  		}else{
395  			tempIsLocal = Defaults.isLocal;	
396  		}
397  		if(args.Contains(&quot;path&quot;)){
398  			Vector3[] fromPath;
399  			Vector3[] suppliedPath;
400  			if(args[&quot;path&quot;].GetType() == typeof(Vector3[])){
401  				Vector3[] temp = (Vector3[])args[&quot;path&quot;];
402  				suppliedPath=new Vector3[temp.Length];
403  				Array.Copy(temp,suppliedPath, temp.Length);	
404  			}else{
405  				Transform[] temp = (Transform[])args[&quot;path&quot;];
406  				suppliedPath = new Vector3[temp.Length];
407  				for (int i = 0; i &lt; temp.Length; i++) {
408  					suppliedPath[i]=temp[i].position;
409  				}
410  			}
411  			if(suppliedPath[suppliedPath.Length-1] != target.transform.position){
412  				fromPath= new Vector3[suppliedPath.Length+1];
413  				Array.Copy(suppliedPath,fromPath,suppliedPath.Length);
414  				if(tempIsLocal){
415  					fromPath[fromPath.Length-1] = target.transform.localPosition;
416  					target.transform.localPosition=fromPath[0];
417  				}else{
418  					fromPath[fromPath.Length-1] = target.transform.position;
419  					target.transform.position=fromPath[0];
420  				}
421  				args[&quot;path&quot;]=fromPath;
422  			}else{
423  				if(tempIsLocal){
424  					target.transform.localPosition=suppliedPath[0];
425  				}else{
426  					target.transform.position=suppliedPath[0];
427  				}
428  				args[&quot;path&quot;]=suppliedPath;
429  			}
430  		}else{
431  			Vector3 tempPosition;
432  			Vector3 fromPosition;
433  			if(tempIsLocal){
434  				tempPosition=fromPosition=target.transform.localPosition;
435  			}else{
436  				tempPosition=fromPosition=target.transform.position;	
437  			}
438  			if(args.Contains(&quot;position&quot;)){
439  				if (args[&quot;position&quot;].GetType() == typeof(Transform)){
440  					Transform trans = (Transform)args[&quot;position&quot;];
441  					fromPosition=trans.position;
442  				}else if(args[&quot;position&quot;].GetType() == typeof(Vector3)){
443  					fromPosition=(Vector3)args[&quot;position&quot;];
444  				}			
445  			}else{
446  				if (args.Contains(&quot;x&quot;)) {
447  					fromPosition.x=(float)args[&quot;x&quot;];
448  				}
449  				if (args.Contains(&quot;y&quot;)) {
450  					fromPosition.y=(float)args[&quot;y&quot;];
451  				}
452  				if (args.Contains(&quot;z&quot;)) {
453  					fromPosition.z=(float)args[&quot;z&quot;];
454  				}
455  			}
456  			if(tempIsLocal){
457  				target.transform.localPosition = fromPosition;
458  			}else{
459  				target.transform.position = fromPosition;	
460  			}
461  			args[&quot;position&quot;]=tempPosition;
462  		}
463  		args[&quot;type&quot;]=&quot;move&quot;;
464  		args[&quot;method&quot;]=&quot;to&quot;;
465  		Launch(target,args);
466  	}
467  	public static void MoveAdd(GameObject target, Vector3 amount, float time){
468  		MoveAdd(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
469  	}
470  	public static void MoveAdd(GameObject target, Hashtable args){
471  		args = iTween.CleanArgs(args);
472  		args[&quot;type&quot;]=&quot;move&quot;;
473  		args[&quot;method&quot;]=&quot;add&quot;;
474  		Launch(target,args);
475  	}
476  	public static void MoveBy(GameObject target, Vector3 amount, float time){
477  		MoveBy(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
478  	}
479  	public static void MoveBy(GameObject target, Hashtable args){
480  		args = iTween.CleanArgs(args);
481  		args[&quot;type&quot;]=&quot;move&quot;;
482  		args[&quot;method&quot;]=&quot;by&quot;;
483  		Launch(target,args);
484  	}
485  	public static void ScaleTo(GameObject target, Vector3 scale, float time){
486  		ScaleTo(target,Hash(&quot;scale&quot;,scale,&quot;time&quot;,time));
487  	}
488  	public static void ScaleTo(GameObject target, Hashtable args){
489  		args = iTween.CleanArgs(args);
490  		if(args.Contains(&quot;scale&quot;)){
491  			if (args[&quot;scale&quot;].GetType() == typeof(Transform)) {
492  				Transform transform = (Transform)args[&quot;scale&quot;];
493  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
494  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
495  				args[&quot;scale&quot;]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);
496  			}
497  		}
498  		args[&quot;type&quot;]=&quot;scale&quot;;
499  		args[&quot;method&quot;]=&quot;to&quot;;
500  		Launch(target,args);
501  	}
502  	public static void ScaleFrom(GameObject target, Vector3 scale, float time){
503  		ScaleFrom(target,Hash(&quot;scale&quot;,scale,&quot;time&quot;,time));
504  	}
505  	public static void ScaleFrom(GameObject target, Hashtable args){
506  		Vector3 tempScale;
507  		Vector3 fromScale;
508  		args = iTween.CleanArgs(args);
509  		tempScale=fromScale=target.transform.localScale;
510  		if(args.Contains(&quot;scale&quot;)){
511  			if (args[&quot;scale&quot;].GetType() == typeof(Transform)){
512  				Transform trans = (Transform)args[&quot;scale&quot;];
513  				fromScale=trans.localScale;
514  			}else if(args[&quot;scale&quot;].GetType() == typeof(Vector3)){
515  				fromScale=(Vector3)args[&quot;scale&quot;];
516  			}	
517  		}else{
518  			if (args.Contains(&quot;x&quot;)) {
519  				fromScale.x=(float)args[&quot;x&quot;];
520  			}
521  			if (args.Contains(&quot;y&quot;)) {
522  				fromScale.y=(float)args[&quot;y&quot;];
523  			}
524  			if (args.Contains(&quot;z&quot;)) {
525  				fromScale.z=(float)args[&quot;z&quot;];
526  			}
527  		}
528  		target.transform.localScale = fromScale;	
529  		args[&quot;scale&quot;]=tempScale;
530  		args[&quot;type&quot;]=&quot;scale&quot;;
531  		args[&quot;method&quot;]=&quot;to&quot;;
532  		Launch(target,args);
533  	}
534  	public static void ScaleAdd(GameObject target, Vector3 amount, float time){
535  		ScaleAdd(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
536  	}
537  	public static void ScaleAdd(GameObject target, Hashtable args){
538  		args = iTween.CleanArgs(args);
539  		args[&quot;type&quot;]=&quot;scale&quot;;
540  		args[&quot;method&quot;]=&quot;add&quot;;
541  		Launch(target,args);
542  	}
543  	public static void ScaleBy(GameObject target, Vector3 amount, float time){
544  		ScaleBy(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
545  	}
546  	public static void ScaleBy(GameObject target, Hashtable args){
547  		args = iTween.CleanArgs(args);
548  		args[&quot;type&quot;]=&quot;scale&quot;;
549  		args[&quot;method&quot;]=&quot;by&quot;;
550  		Launch(target,args);
551  	}
552  	public static void RotateTo(GameObject target, Vector3 rotation, float time){
553  		RotateTo(target,Hash(&quot;rotation&quot;,rotation,&quot;time&quot;,time));
554  	}
555  	public static void RotateTo(GameObject target, Hashtable args){
556  		args = iTween.CleanArgs(args);
557  		if(args.Contains(&quot;rotation&quot;)){
558  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)) {
559  				Transform transform = (Transform)args[&quot;rotation&quot;];
560  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
561  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
562  				args[&quot;scale&quot;]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);
563  			}
564  		}		
565  		args[&quot;type&quot;]=&quot;rotate&quot;;
566  		args[&quot;method&quot;]=&quot;to&quot;;
567  		Launch(target,args);
568  	}	
569  	public static void RotateFrom(GameObject target, Vector3 rotation, float time){
570  		RotateFrom(target,Hash(&quot;rotation&quot;,rotation,&quot;time&quot;,time));
571  	}
572  	public static void RotateFrom(GameObject target, Hashtable args){
573  		Vector3 tempRotation;
574  		Vector3 fromRotation;
575  		bool tempIsLocal;
576  		args = iTween.CleanArgs(args);
577  		if(args.Contains(&quot;islocal&quot;)){
578  			tempIsLocal = (bool)args[&quot;islocal&quot;];
579  		}else{
580  			tempIsLocal = Defaults.isLocal;	
581  		}
582  		if(tempIsLocal){
583  			tempRotation=fromRotation=target.transform.localEulerAngles;
584  		}else{
585  			tempRotation=fromRotation=target.transform.eulerAngles;	
586  		}
587  		if(args.Contains(&quot;rotation&quot;)){
588  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)){
589  				Transform trans = (Transform)args[&quot;rotation&quot;];
590  				fromRotation=trans.eulerAngles;
591  			}else if(args[&quot;rotation&quot;].GetType() == typeof(Vector3)){
592  				fromRotation=(Vector3)args[&quot;rotation&quot;];
593  			}	
594  		}else{
595  			if (args.Contains(&quot;x&quot;)) {
596  				fromRotation.x=(float)args[&quot;x&quot;];
597  			}
598  			if (args.Contains(&quot;y&quot;)) {
599  				fromRotation.y=(float)args[&quot;y&quot;];
600  			}
601  			if (args.Contains(&quot;z&quot;)) {
602  				fromRotation.z=(float)args[&quot;z&quot;];
603  			}
604  		}
605  		if(tempIsLocal){
606  			target.transform.localEulerAngles = fromRotation;
607  		}else{
608  			target.transform.eulerAngles = fromRotation;	
609  		}
610  		args[&quot;rotation&quot;]=tempRotation;
611  		args[&quot;type&quot;]=&quot;rotate&quot;;
612  		args[&quot;method&quot;]=&quot;to&quot;;
613  		Launch(target,args);
614  	}	
615  	public static void RotateAdd(GameObject target, Vector3 amount, float time){
616  		RotateAdd(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
617  	}
618  	public static void RotateAdd(GameObject target, Hashtable args){
619  		args = iTween.CleanArgs(args);
620  		args[&quot;type&quot;]=&quot;rotate&quot;;
621  		args[&quot;method&quot;]=&quot;add&quot;;
622  		Launch(target,args);
623  	}
624  	public static void RotateBy(GameObject target, Vector3 amount, float time){
625  		RotateBy(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
626  	}
627  	public static void RotateBy(GameObject target, Hashtable args){
628  		args = iTween.CleanArgs(args);
629  		args[&quot;type&quot;]=&quot;rotate&quot;;
630  		args[&quot;method&quot;]=&quot;by&quot;;
631  		Launch(target,args);
632  	}		
633  	public static void ShakePosition(GameObject target, Vector3 amount, float time){
634  		ShakePosition(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
635  	}
636  	public static void ShakePosition(GameObject target, Hashtable args){
637  		args = iTween.CleanArgs(args);
638  		args[&quot;type&quot;]=&quot;shake&quot;;
639  		args[&quot;method&quot;]=&quot;position&quot;;
640  		Launch(target,args);
641  	}		
642  	public static void ShakeScale(GameObject target, Vector3 amount, float time){
643  		ShakeScale(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
644  	}
645  	public static void ShakeScale(GameObject target, Hashtable args){
646  		args = iTween.CleanArgs(args);
647  		args[&quot;type&quot;]=&quot;shake&quot;;
648  		args[&quot;method&quot;]=&quot;scale&quot;;
649  		Launch(target,args);
650  	}		
651  	public static void ShakeRotation(GameObject target, Vector3 amount, float time){
652  		ShakeRotation(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
653  	}
654  	public static void ShakeRotation(GameObject target, Hashtable args){
655  		args = iTween.CleanArgs(args);
656  		args[&quot;type&quot;]=&quot;shake&quot;;
657  		args[&quot;method&quot;]=&quot;rotation&quot;;
658  		Launch(target,args);
659  	}			
660  	public static void PunchPosition(GameObject target, Vector3 amount, float time){
661  		PunchPosition(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
662  	}
663  	public static void PunchPosition(GameObject target, Hashtable args){
664  		args = iTween.CleanArgs(args);
665  		args[&quot;type&quot;]=&quot;punch&quot;;
666  		args[&quot;method&quot;]=&quot;position&quot;;
667  		args[&quot;easetype&quot;]=EaseType.punch;
668  		Launch(target,args);
669  	}		
670  	public static void PunchRotation(GameObject target, Vector3 amount, float time){
671  		PunchRotation(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
672  	}
673  	public static void PunchRotation(GameObject target, Hashtable args){
674  		args = iTween.CleanArgs(args);
675  		args[&quot;type&quot;]=&quot;punch&quot;;
676  		args[&quot;method&quot;]=&quot;rotation&quot;;
677  		args[&quot;easetype&quot;]=EaseType.punch;
678  		Launch(target,args);
679  	}	
680  	public static void PunchScale(GameObject target, Vector3 amount, float time){
681  		PunchScale(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
682  	}
683  	public static void PunchScale(GameObject target, Hashtable args){
684  		args = iTween.CleanArgs(args);
685  		args[&quot;type&quot;]=&quot;punch&quot;;
686  		args[&quot;method&quot;]=&quot;scale&quot;;
687  		args[&quot;easetype&quot;]=EaseType.punch;
688  		Launch(target,args);
689  	}	
690  	#endregion
691  	#region #2 Generate Method Targets
692  	void GenerateTargets(){
693  		switch (type) {
694  			case &quot;value&quot;:
695  				switch (method) {
696  					case &quot;float&quot;:
697  						GenerateFloatTargets();
698  						apply = new ApplyTween(ApplyFloatTargets);
699  					break;
700  				case &quot;vector2&quot;:
701  						GenerateVector2Targets();
702  						apply = new ApplyTween(ApplyVector2Targets);
703  					break;
704  				case &quot;vector3&quot;:
705  						GenerateVector3Targets();
706  						apply = new ApplyTween(ApplyVector3Targets);
707  					break;
708  				case &quot;color&quot;:
709  						GenerateColorTargets();
710  						apply = new ApplyTween(ApplyColorTargets);
711  					break;
712  				case &quot;rect&quot;:
713  						GenerateRectTargets();
714  						apply = new ApplyTween(ApplyRectTargets);
715  					break;
716  				}
717  			break;
718  			case &quot;color&quot;:
719  				switch (method) {
720  					case &quot;to&quot;:
721  						GenerateColorToTargets();
722  						apply = new ApplyTween(ApplyColorToTargets);
723  					break;
724  				}
725  			break;
726  			case &quot;audio&quot;:
727  				switch (method) {
728  					case &quot;to&quot;:
729  						GenerateAudioToTargets();
730  						apply = new ApplyTween(ApplyAudioToTargets);
731  					break;
732  				}
733  			break;
734  			case &quot;move&quot;:
735  				switch (method) {
736  					case &quot;to&quot;:
737  						if(tweenArguments.Contains(&quot;path&quot;)){
738  							GenerateMoveToPathTargets();
739  							apply = new ApplyTween(ApplyMoveToPathTargets);
740  						}else{ 
741  							GenerateMoveToTargets();
742  							apply = new ApplyTween(ApplyMoveToTargets);
743  						}
744  					break;
745  					case &quot;by&quot;:
746  					case &quot;add&quot;:
747  						GenerateMoveByTargets();
748  						apply = new ApplyTween(ApplyMoveByTargets);
749  					break;
750  				}
751  			break;
752  			case &quot;scale&quot;:
753  				switch (method){
754  					case &quot;to&quot;:
755  						GenerateScaleToTargets();
756  						apply = new ApplyTween(ApplyScaleToTargets);
757  					break;
758  					case &quot;by&quot;:
759  						GenerateScaleByTargets();
760  						apply = new ApplyTween(ApplyScaleToTargets);
761  					break;
762  					case &quot;add&quot;:
763  						GenerateScaleAddTargets();
764  						apply = new ApplyTween(ApplyScaleToTargets);
765  					break;
766  				}
767  			break;
768  			case &quot;rotate&quot;:
769  				switch (method) {
770  					case &quot;to&quot;:
771  						GenerateRotateToTargets();
772  						apply = new ApplyTween(ApplyRotateToTargets);
773  					break;
774  					case &quot;add&quot;:
775  						GenerateRotateAddTargets();
776  						apply = new ApplyTween(ApplyRotateAddTargets);
777  					break;
778  					case &quot;by&quot;:
779  						GenerateRotateByTargets();
780  						apply = new ApplyTween(ApplyRotateAddTargets);
781  					break;				
782  				}
783  			break;
784  			case &quot;shake&quot;:
785  				switch (method) {
786  					case &quot;position&quot;:
787  						GenerateShakePositionTargets();
788  						apply = new ApplyTween(ApplyShakePositionTargets);
789  					break;		
790  					case &quot;scale&quot;:
791  						GenerateShakeScaleTargets();
792  						apply = new ApplyTween(ApplyShakeScaleTargets);
793  					break;
794  					case &quot;rotation&quot;:
795  						GenerateShakeRotationTargets();
796  						apply = new ApplyTween(ApplyShakeRotationTargets);
797  					break;
798  				}
799  			break;			
800  			case &quot;punch&quot;:
801  				switch (method) {
802  					case &quot;position&quot;:
803  						GeneratePunchPositionTargets();
804  						apply = new ApplyTween(ApplyPunchPositionTargets);
805  					break;	
806  					case &quot;rotation&quot;:
807  						GeneratePunchRotationTargets();
808  						apply = new ApplyTween(ApplyPunchRotationTargets);
809  					break;	
810  					case &quot;scale&quot;:
811  						GeneratePunchScaleTargets();
812  						apply = new ApplyTween(ApplyPunchScaleTargets);
813  					break;
814  				}
815  			break;
816  			case &quot;look&quot;:
817  				switch (method) {
818  					case &quot;to&quot;:
819  						GenerateLookToTargets();
820  						apply = new ApplyTween(ApplyLookToTargets);
821  					break;	
822  				}
823  			break;	
824  			case &quot;stab&quot;:
825  				GenerateStabTargets();
826  				apply = new ApplyTween(ApplyStabTargets);
827  			break;	
828  		}
829  	}
830  	#endregion
831  	#region #3 Generate Specific Targets
832  	void GenerateRectTargets(){
833  		rects=new Rect[3];
834  		rects[0]=(Rect)tweenArguments[&quot;from&quot;];
835  		rects[1]=(Rect)tweenArguments[&quot;to&quot;];
836  	}		
837  	void GenerateColorTargets(){
838  		colors=new Color[1,3];
839  		colors[0,0]=(Color)tweenArguments[&quot;from&quot;];
840  		colors[0,1]=(Color)tweenArguments[&quot;to&quot;];
841  	}	
842  	void GenerateVector3Targets(){
843  		vector3s=new Vector3[3];
844  		vector3s[0]=(Vector3)tweenArguments[&quot;from&quot;];
845  		vector3s[1]=(Vector3)tweenArguments[&quot;to&quot;];
846  		if(tweenArguments.Contains(&quot;speed&quot;)){
847  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
848  			time = distance/(float)tweenArguments[&quot;speed&quot;];
849  		}
850  	}
851  	void GenerateVector2Targets(){
852  		vector2s=new Vector2[3];
853  		vector2s[0]=(Vector2)tweenArguments[&quot;from&quot;];
854  		vector2s[1]=(Vector2)tweenArguments[&quot;to&quot;];
855  		if(tweenArguments.Contains(&quot;speed&quot;)){
856  			Vector3 fromV3 = new Vector3(vector2s[0].x,vector2s[0].y,0);
857  			Vector3 toV3 = new Vector3(vector2s[1].x,vector2s[1].y,0);
858  			float distance = Math.Abs(Vector3.Distance(fromV3,toV3));
859  			time = distance/(float)tweenArguments[&quot;speed&quot;];
860  		}
861  	}
862  	void GenerateFloatTargets(){
863  		floats=new float[3];
864  		floats[0]=(float)tweenArguments[&quot;from&quot;];
865  		floats[1]=(float)tweenArguments[&quot;to&quot;];
866  		if(tweenArguments.Contains(&quot;speed&quot;)){
867  			float distance = Math.Abs(floats[0] - floats[1]);
868  			time = distance/(float)tweenArguments[&quot;speed&quot;];
869  		}
870  	}
871  	void GenerateColorToTargets(){
872  		if(GetComponent&lt;GUITexture&gt;()){
873  			colors = new Color[1,3];
874  			colors[0,0] = colors[0,1] = guiTexture.color;
875  		}else if(GetComponent&lt;GUIText&gt;()){
876  			colors = new Color[1,3];
877  			colors[0,0] = colors[0,1] = guiText.material.color;
878  		}else if(renderer){
879  			colors = new Color[renderer.materials.Length,3];
880  			for (int i = 0; i &lt; renderer.materials.Length; i++) {
881  				colors[i,0]=renderer.materials[i].GetColor(namedcolorvalue.ToString());
882  				colors[i,1]=renderer.materials[i].GetColor(namedcolorvalue.ToString());
883  			}
884  		}else if(light){
885  			colors = new Color[1,3];
886  			colors[0,0] = colors[0,1] = light.color;	
887  		}else{
888  			colors = new Color[1,3]; 
889  		}
890  		if (tweenArguments.Contains(&quot;color&quot;)) {
891  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
892  				colors[i,1]=(Color)tweenArguments[&quot;color&quot;];
893  			}
894  		}else{
895  			if (tweenArguments.Contains(&quot;r&quot;)) {
896  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
897  					colors[i,1].r=(float)tweenArguments[&quot;r&quot;];
898  				}
899  			}
900  			if (tweenArguments.Contains(&quot;g&quot;)) {
901  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
902  					colors[i,1].g=(float)tweenArguments[&quot;g&quot;];
903  				}
904  			}
905  			if (tweenArguments.Contains(&quot;b&quot;)) {
906  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
907  					colors[i,1].b=(float)tweenArguments[&quot;b&quot;];
908  				}
909  			}
910  			if (tweenArguments.Contains(&quot;a&quot;)) {
911  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
912  					colors[i,1].a=(float)tweenArguments[&quot;a&quot;];
913  				}
914  			}
915  		}
916  		if(tweenArguments.Contains(&quot;amount&quot;)){
917  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
918  				colors[i,1].a=(float)tweenArguments[&quot;amount&quot;];
919  			}
920  		}else if(tweenArguments.Contains(&quot;alpha&quot;)){
921  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
922  				colors[i,1].a=(float)tweenArguments[&quot;alpha&quot;];
923  			}
924  		}
925  	}
926  	void GenerateAudioToTargets(){
927  		vector2s=new Vector2[3];
928  		if(tweenArguments.Contains(&quot;audiosource&quot;)){
929  			audioSource=(AudioSource)tweenArguments[&quot;audiosource&quot;];
930  		}else{
931  			if(GetComponent&lt;AudioSource&gt;()){
932  				audioSource=audio;
933  			}else{
934  				Debug.LogError(&quot;iTween Error: AudioTo requires an AudioSource.&quot;);
935  				Dispose();
936  			}
937  		}		
938  		vector2s[0]=vector2s[1]=new Vector2(audioSource.volume,audioSource.pitch);
939  		if (tweenArguments.Contains(&quot;volume&quot;)) {
940  			vector2s[1].x=(float)tweenArguments[&quot;volume&quot;];	
941  		}
942  		if (tweenArguments.Contains(&quot;pitch&quot;)) {
943  			vector2s[1].y=(float)tweenArguments[&quot;pitch&quot;];	
944  		}
945  	}
946  	void GenerateStabTargets(){
947  		if(tweenArguments.Contains(&quot;audiosource&quot;)){
948  			audioSource=(AudioSource)tweenArguments[&quot;audiosource&quot;];
949  		}else{
950  			if(GetComponent&lt;AudioSource&gt;()){
951  				audioSource=audio;
952  			}else{
953  				gameObject.AddComponent&lt;AudioSource&gt;();
954  				audioSource=audio;
955  				audioSource.playOnAwake=false;
956  			}
957  		}
958  		audioSource.clip=(AudioClip)tweenArguments[&quot;audioclip&quot;];
959  		if(tweenArguments.Contains(&quot;pitch&quot;)){
960  			audioSource.pitch=(float)tweenArguments[&quot;pitch&quot;];
961  		}
962  		if(tweenArguments.Contains(&quot;volume&quot;)){
963  			audioSource.volume=(float)tweenArguments[&quot;volume&quot;];
964  		}
965  		time=audioSource.clip.length/audioSource.pitch;
966  	}
967  	void GenerateLookToTargets(){
968  		vector3s=new Vector3[3];
969  		vector3s[0]=thisTransform.eulerAngles;
970  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
971  			if (tweenArguments[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
972  				thisTransform.LookAt((Transform)tweenArguments[&quot;looktarget&quot;], (Vector3?)tweenArguments[&quot;up&quot;] ?? Defaults.up);
973  			}else if(tweenArguments[&quot;looktarget&quot;].GetType() == typeof(Vector3)){
974  				thisTransform.LookAt((Vector3)tweenArguments[&quot;looktarget&quot;], (Vector3?)tweenArguments[&quot;up&quot;] ?? Defaults.up);
975  			}
976  		}else{
977  			Debug.LogError(&quot;iTween Error: LookTo needs a &#x27;looktarget&#x27; property!&quot;);
978  			Dispose();
979  		}
980  		vector3s[1]=thisTransform.eulerAngles;
981  		thisTransform.eulerAngles=vector3s[0];
982  		if(tweenArguments.Contains(&quot;axis&quot;)){
983  			switch((string)tweenArguments[&quot;axis&quot;]){
984  				case &quot;x&quot;:
985  					vector3s[1].y=vector3s[0].y;
986  					vector3s[1].z=vector3s[0].z;
987  				break;
988  				case &quot;y&quot;:
989  					vector3s[1].x=vector3s[0].x;
990  					vector3s[1].z=vector3s[0].z;
991  				break;
992  				case &quot;z&quot;:
993  					vector3s[1].x=vector3s[0].x;
994  					vector3s[1].y=vector3s[0].y;
995  				break;
996  			}
997  		}
998  		vector3s[1]=new Vector3(clerp(vector3s[0].x,vector3s[1].x,1),clerp(vector3s[0].y,vector3s[1].y,1),clerp(vector3s[0].z,vector3s[1].z,1));
999  		if(tweenArguments.Contains(&quot;speed&quot;)){
1000  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1001  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1002  		}
1003  	}	
1004  	void GenerateMoveToPathTargets(){
1005  		 Vector3[] suppliedPath;
1006  		if(tweenArguments[&quot;path&quot;].GetType() == typeof(Vector3[])){
1007  			Vector3[] temp = (Vector3[])tweenArguments[&quot;path&quot;];
1008  			if(temp.Length==1){
1009  				Debug.LogError(&quot;iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!&quot;);
1010  				Dispose();
1011  			}
1012  			suppliedPath=new Vector3[temp.Length];
1013  			Array.Copy(temp,suppliedPath, temp.Length);
1014  		}else{
1015  			Transform[] temp = (Transform[])tweenArguments[&quot;path&quot;];
1016  			if(temp.Length==1){
1017  				Debug.LogError(&quot;iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!&quot;);
1018  				Dispose();
1019  			}
1020  			suppliedPath = new Vector3[temp.Length];
1021  			for (int i = 0; i &lt; temp.Length; i++) {
1022  				suppliedPath[i]=temp[i].position;
1023  			}
1024  		}
1025  		bool plotStart;
1026  		int offset;
1027  		if(thisTransform.position != suppliedPath[0]){
1028  			if(!tweenArguments.Contains(&quot;movetopath&quot;) || (bool)tweenArguments[&quot;movetopath&quot;]==true){
1029  				plotStart=true;
1030  				offset=3;	
1031  			}else{
1032  				plotStart=false;
1033  				offset=2;
1034  			}
1035  		}else{
1036  			plotStart=false;
1037  			offset=2;
1038  		}				
1039  		vector3s = new Vector3[suppliedPath.Length+offset];
1040  		if(plotStart){
1041  			vector3s[1]=thisTransform.position;
1042  			offset=2;
1043  		}else{
1044  			offset=1;
1045  		}		
1046  		Array.Copy(suppliedPath,0,vector3s,offset,suppliedPath.Length);
1047  		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
1048  		vector3s[vector3s.Length-1] = vector3s[vector3s.Length-2] + (vector3s[vector3s.Length-2] - vector3s[vector3s.Length-3]);
1049  		if(vector3s[1] == vector3s[vector3s.Length-2]){
1050  			Vector3[] tmpLoopSpline = new Vector3[vector3s.Length];
1051  			Array.Copy(vector3s,tmpLoopSpline,vector3s.Length);
1052  			tmpLoopSpline[0]=tmpLoopSpline[tmpLoopSpline.Length-3];
1053  			tmpLoopSpline[tmpLoopSpline.Length-1]=tmpLoopSpline[2];
1054  			vector3s=new Vector3[tmpLoopSpline.Length];
1055  			Array.Copy(tmpLoopSpline,vector3s,tmpLoopSpline.Length);
1056  		}
1057  		path = new CRSpline(vector3s);
1058  		if(tweenArguments.Contains(&quot;speed&quot;)){
1059  			float distance = PathLength(vector3s);
1060  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1061  		}
1062  	}
1063  	void GenerateMoveToTargets(){
1064  		vector3s=new Vector3[3];
1065  		if (isLocal) {
1066  			vector3s[0]=vector3s[1]=thisTransform.localPosition;				
1067  		}else{
1068  			vector3s[0]=vector3s[1]=thisTransform.position;
1069  		}
1070  		if (tweenArguments.Contains(&quot;position&quot;)) {
1071  			if (tweenArguments[&quot;position&quot;].GetType() == typeof(Transform)){
1072  				Transform trans = (Transform)tweenArguments[&quot;position&quot;];
1073  				vector3s[1]=trans.position;
1074  			}else if(tweenArguments[&quot;position&quot;].GetType() == typeof(Vector3)){
1075  				vector3s[1]=(Vector3)tweenArguments[&quot;position&quot;];
1076  			}
1077  		}else{
1078  			if (tweenArguments.Contains(&quot;x&quot;)) {
1079  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1080  			}
1081  			if (tweenArguments.Contains(&quot;y&quot;)) {
1082  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1083  			}
1084  			if (tweenArguments.Contains(&quot;z&quot;)) {
1085  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1086  			}
1087  		}
1088  		if(tweenArguments.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)tweenArguments[&quot;orienttopath&quot;]){
1089  			tweenArguments[&quot;looktarget&quot;] = vector3s[1];
1090  		}
1091  		if(tweenArguments.Contains(&quot;speed&quot;)){
1092  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1093  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1094  		}
1095  	}
1096  	void GenerateMoveByTargets(){
1097  		vector3s=new Vector3[6];
1098  		vector3s[4] = thisTransform.eulerAngles;
1099  		vector3s[0]=vector3s[1]=vector3s[3]=thisTransform.position;
1100  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1101  			vector3s[1]=vector3s[0] + (Vector3)tweenArguments[&quot;amount&quot;];
1102  		}else{
1103  			if (tweenArguments.Contains(&quot;x&quot;)) {
1104  				vector3s[1].x=vector3s[0].x + (float)tweenArguments[&quot;x&quot;];
1105  			}
1106  			if (tweenArguments.Contains(&quot;y&quot;)) {
1107  				vector3s[1].y=vector3s[0].y +(float)tweenArguments[&quot;y&quot;];
1108  			}
1109  			if (tweenArguments.Contains(&quot;z&quot;)) {
1110  				vector3s[1].z=vector3s[0].z + (float)tweenArguments[&quot;z&quot;];
1111  			}
1112  		}	
1113  		thisTransform.Translate(vector3s[1],space);
1114  		vector3s[5] = thisTransform.position;
1115  		thisTransform.position=vector3s[0];
1116  		if(tweenArguments.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)tweenArguments[&quot;orienttopath&quot;]){
1117  			tweenArguments[&quot;looktarget&quot;] = vector3s[1];
1118  		}
1119  		if(tweenArguments.Contains(&quot;speed&quot;)){
1120  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1121  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1122  		}
1123  	}
1124  	void GenerateScaleToTargets(){
1125  		vector3s=new Vector3[3];
1126  		vector3s[0]=vector3s[1]=thisTransform.localScale;				
1127  		if (tweenArguments.Contains(&quot;scale&quot;)) {
1128  			if (tweenArguments[&quot;scale&quot;].GetType() == typeof(Transform)){
1129  				Transform trans = (Transform)tweenArguments[&quot;scale&quot;];
1130  				vector3s[1]=trans.localScale;					
1131  			}else if(tweenArguments[&quot;scale&quot;].GetType() == typeof(Vector3)){
1132  				vector3s[1]=(Vector3)tweenArguments[&quot;scale&quot;];
1133  			}
1134  		}else{
1135  			if (tweenArguments.Contains(&quot;x&quot;)) {
1136  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1137  			}
1138  			if (tweenArguments.Contains(&quot;y&quot;)) {
1139  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1140  			}
1141  			if (tweenArguments.Contains(&quot;z&quot;)) {
1142  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1143  			}
1144  		} 
1145  		if(tweenArguments.Contains(&quot;speed&quot;)){
1146  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1147  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1148  		}
1149  	}
1150  	void GenerateScaleByTargets(){
1151  		vector3s=new Vector3[3];
1152  		vector3s[0]=vector3s[1]=thisTransform.localScale;				
1153  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1154  			vector3s[1]=Vector3.Scale(vector3s[1],(Vector3)tweenArguments[&quot;amount&quot;]);
1155  		}else{
1156  			if (tweenArguments.Contains(&quot;x&quot;)) {
1157  				vector3s[1].x*=(float)tweenArguments[&quot;x&quot;];
1158  			}
1159  			if (tweenArguments.Contains(&quot;y&quot;)) {
1160  				vector3s[1].y*=(float)tweenArguments[&quot;y&quot;];
1161  			}
1162  			if (tweenArguments.Contains(&quot;z&quot;)) {
1163  				vector3s[1].z*=(float)tweenArguments[&quot;z&quot;];
1164  			}
1165  		} 
1166  		if(tweenArguments.Contains(&quot;speed&quot;)){
1167  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1168  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1169  		}
1170  	}
1171  	void GenerateScaleAddTargets(){
1172  		vector3s=new Vector3[3];
1173  		vector3s[0]=vector3s[1]=thisTransform.localScale;				
1174  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1175  			vector3s[1]+=(Vector3)tweenArguments[&quot;amount&quot;];
1176  		}else{
1177  			if (tweenArguments.Contains(&quot;x&quot;)) {
1178  				vector3s[1].x+=(float)tweenArguments[&quot;x&quot;];
1179  			}
1180  			if (tweenArguments.Contains(&quot;y&quot;)) {
1181  				vector3s[1].y+=(float)tweenArguments[&quot;y&quot;];
1182  			}
1183  			if (tweenArguments.Contains(&quot;z&quot;)) {
1184  				vector3s[1].z+=(float)tweenArguments[&quot;z&quot;];
1185  			}
1186  		}
1187  		if(tweenArguments.Contains(&quot;speed&quot;)){
1188  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1189  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1190  		}
1191  	}
1192  	void GenerateRotateToTargets(){
1193  		vector3s=new Vector3[3];
1194  		if (isLocal) {
1195  			vector3s[0]=vector3s[1]=thisTransform.localEulerAngles;				
1196  		}else{
1197  			vector3s[0]=vector3s[1]=thisTransform.eulerAngles;
1198  		}
1199  		if (tweenArguments.Contains(&quot;rotation&quot;)) {
1200  			if (tweenArguments[&quot;rotation&quot;].GetType() == typeof(Transform)){
1201  				Transform trans = (Transform)tweenArguments[&quot;rotation&quot;];
1202  				vector3s[1]=trans.eulerAngles;			
1203  			}else if(tweenArguments[&quot;rotation&quot;].GetType() == typeof(Vector3)){
1204  				vector3s[1]=(Vector3)tweenArguments[&quot;rotation&quot;];
1205  			}
1206  		}else{
1207  			if (tweenArguments.Contains(&quot;x&quot;)) {
1208  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1209  			}
1210  			if (tweenArguments.Contains(&quot;y&quot;)) {
1211  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1212  			}
1213  			if (tweenArguments.Contains(&quot;z&quot;)) {
1214  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1215  			}
1216  		}
1217  		vector3s[1]=new Vector3(clerp(vector3s[0].x,vector3s[1].x,1),clerp(vector3s[0].y,vector3s[1].y,1),clerp(vector3s[0].z,vector3s[1].z,1));
1218  		if(tweenArguments.Contains(&quot;speed&quot;)){
1219  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1220  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1221  		}
1222  	}
1223  	void GenerateRotateAddTargets(){
1224  		vector3s=new Vector3[5];
1225  		vector3s[0]=vector3s[1]=vector3s[3]=thisTransform.eulerAngles;
1226  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1227  			vector3s[1]+=(Vector3)tweenArguments[&quot;amount&quot;];
1228  		}else{
1229  			if (tweenArguments.Contains(&quot;x&quot;)) {
1230  				vector3s[1].x+=(float)tweenArguments[&quot;x&quot;];
1231  			}
1232  			if (tweenArguments.Contains(&quot;y&quot;)) {
1233  				vector3s[1].y+=(float)tweenArguments[&quot;y&quot;];
1234  			}
1235  			if (tweenArguments.Contains(&quot;z&quot;)) {
1236  				vector3s[1].z+=(float)tweenArguments[&quot;z&quot;];
1237  			}
1238  		}
1239  		if(tweenArguments.Contains(&quot;speed&quot;)){
1240  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1241  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1242  		}
1243  	}		
1244  	void GenerateRotateByTargets(){
1245  		vector3s=new Vector3[4];
1246  		vector3s[0]=vector3s[1]=vector3s[3]=thisTransform.eulerAngles;
1247  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1248  			vector3s[1]+=Vector3.Scale((Vector3)tweenArguments[&quot;amount&quot;],new Vector3(360,360,360));
1249  		}else{
1250  			if (tweenArguments.Contains(&quot;x&quot;)) {
1251  				vector3s[1].x+=360 * (float)tweenArguments[&quot;x&quot;];
1252  			}
1253  			if (tweenArguments.Contains(&quot;y&quot;)) {
1254  				vector3s[1].y+=360 * (float)tweenArguments[&quot;y&quot;];
1255  			}
1256  			if (tweenArguments.Contains(&quot;z&quot;)) {
1257  				vector3s[1].z+=360 * (float)tweenArguments[&quot;z&quot;];
1258  			}
1259  		}
1260  		if(tweenArguments.Contains(&quot;speed&quot;)){
1261  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1262  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1263  		}
1264  	}		
1265  	void GenerateShakePositionTargets(){
1266  		vector3s=new Vector3[4];
1267  		vector3s[3] = thisTransform.eulerAngles;		
1268  		vector3s[0]=thisTransform.position;
1269  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1270  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1271  		}else{
1272  			if (tweenArguments.Contains(&quot;x&quot;)) {
1273  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1274  			}
1275  			if (tweenArguments.Contains(&quot;y&quot;)) {
1276  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1277  			}
1278  			if (tweenArguments.Contains(&quot;z&quot;)) {
1279  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1280  			}
1281  		}
1282  	}		
1283  	void GenerateShakeScaleTargets(){
1284  		vector3s=new Vector3[3];
1285  		vector3s[0]=thisTransform.localScale;
1286  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1287  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1288  		}else{
1289  			if (tweenArguments.Contains(&quot;x&quot;)) {
1290  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1291  			}
1292  			if (tweenArguments.Contains(&quot;y&quot;)) {
1293  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1294  			}
1295  			if (tweenArguments.Contains(&quot;z&quot;)) {
1296  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1297  			}
1298  		}
1299  	}		
1300  	void GenerateShakeRotationTargets(){
1301  		vector3s=new Vector3[3];
1302  		vector3s[0]=thisTransform.eulerAngles;
1303  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1304  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1305  		}else{
1306  			if (tweenArguments.Contains(&quot;x&quot;)) {
1307  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1308  			}
1309  			if (tweenArguments.Contains(&quot;y&quot;)) {
1310  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1311  			}
1312  			if (tweenArguments.Contains(&quot;z&quot;)) {
1313  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1314  			}
1315  		}
1316  	}	
1317  	void GeneratePunchPositionTargets(){
1318  		vector3s=new Vector3[5];
1319  		vector3s[4] = thisTransform.eulerAngles;
1320  		vector3s[0]=thisTransform.position;
1321  		vector3s[1]=vector3s[3]=Vector3.zero;
1322  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1323  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1324  		}else{
1325  			if (tweenArguments.Contains(&quot;x&quot;)) {
1326  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1327  			}
1328  			if (tweenArguments.Contains(&quot;y&quot;)) {
1329  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1330  			}
1331  			if (tweenArguments.Contains(&quot;z&quot;)) {
1332  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1333  			}
1334  		}
1335  	}	
1336  	void GeneratePunchRotationTargets(){
1337  		vector3s=new Vector3[4];
1338  		vector3s[0]=thisTransform.eulerAngles;
1339  		vector3s[1]=vector3s[3]=Vector3.zero;
1340  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1341  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1342  		}else{
1343  			if (tweenArguments.Contains(&quot;x&quot;)) {
1344  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1345  			}
1346  			if (tweenArguments.Contains(&quot;y&quot;)) {
1347  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1348  			}
1349  			if (tweenArguments.Contains(&quot;z&quot;)) {
1350  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1351  			}
1352  		}
1353  	}		
1354  	void GeneratePunchScaleTargets(){
1355  		vector3s=new Vector3[3];
1356  		vector3s[0]=thisTransform.localScale;
1357  		vector3s[1]=Vector3.zero;
1358  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1359  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1360  		}else{
1361  			if (tweenArguments.Contains(&quot;x&quot;)) {
1362  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1363  			}
1364  			if (tweenArguments.Contains(&quot;y&quot;)) {
1365  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1366  			}
1367  			if (tweenArguments.Contains(&quot;z&quot;)) {
1368  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1369  			}
1370  		}
1371  	}
1372  	#endregion
1373  	#region #4 Apply Targets
1374  	void ApplyRectTargets(){
1375  		rects[2].x = ease(rects[0].x,rects[1].x,percentage);
1376  		rects[2].y = ease(rects[0].y,rects[1].y,percentage);
1377  		rects[2].width = ease(rects[0].width,rects[1].width,percentage);
1378  		rects[2].height = ease(rects[0].height,rects[1].height,percentage);
1379  		tweenArguments[&quot;onupdateparams&quot;]=rects[2];
1380  		if(percentage==1){
1381  			tweenArguments[&quot;onupdateparams&quot;]=rects[1];
1382  		}
1383  	}		
1384  	void ApplyColorTargets(){
1385  		colors[0,2].r = ease(colors[0,0].r,colors[0,1].r,percentage);
1386  		colors[0,2].g = ease(colors[0,0].g,colors[0,1].g,percentage);
1387  		colors[0,2].b = ease(colors[0,0].b,colors[0,1].b,percentage);
1388  		colors[0,2].a = ease(colors[0,0].a,colors[0,1].a,percentage);
1389  		tweenArguments[&quot;onupdateparams&quot;]=colors[0,2];
1390  		if(percentage==1){
1391  			tweenArguments[&quot;onupdateparams&quot;]=colors[0,1];
1392  		}
1393  	}	
1394  	void ApplyVector3Targets(){
1395  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1396  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1397  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1398  		tweenArguments[&quot;onupdateparams&quot;]=vector3s[2];
1399  		if(percentage==1){
1400  			tweenArguments[&quot;onupdateparams&quot;]=vector3s[1];
1401  		}
1402  	}		
1403  	void ApplyVector2Targets(){
1404  		vector2s[2].x = ease(vector2s[0].x,vector2s[1].x,percentage);
1405  		vector2s[2].y = ease(vector2s[0].y,vector2s[1].y,percentage);
1406  		tweenArguments[&quot;onupdateparams&quot;]=vector2s[2];
1407  		if(percentage==1){
1408  			tweenArguments[&quot;onupdateparams&quot;]=vector2s[1];
1409  		}
1410  	}	
1411  	void ApplyFloatTargets(){
1412  		floats[2] = ease(floats[0],floats[1],percentage);
1413  		tweenArguments[&quot;onupdateparams&quot;]=floats[2];
1414  		if(percentage==1){
1415  			tweenArguments[&quot;onupdateparams&quot;]=floats[1];
1416  		}
1417  	}	
1418  	void ApplyColorToTargets(){
1419  		for (int i = 0; i &lt; colors.GetLength(0); i++) {
1420  			colors[i,2].r = ease(colors[i,0].r,colors[i,1].r,percentage);
1421  			colors[i,2].g = ease(colors[i,0].g,colors[i,1].g,percentage);
1422  			colors[i,2].b = ease(colors[i,0].b,colors[i,1].b,percentage);
1423  			colors[i,2].a = ease(colors[i,0].a,colors[i,1].a,percentage);
1424  		}
1425  		if(GetComponent&lt;GUITexture&gt;()){
1426  			guiTexture.color=colors[0,2];
1427  		}else if(GetComponent&lt;GUIText&gt;()){
1428  			guiText.material.color=colors[0,2];
1429  		}else if(renderer){
1430  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
1431  				renderer.materials[i].SetColor(namedcolorvalue.ToString(),colors[i,2]);
1432  			}
1433  		}else if(light){
1434  			light.color=colors[0,2];
1435  		}
1436  		if(percentage==1){
1437  			if(GetComponent&lt;GUITexture&gt;()){
1438  				guiTexture.color=colors[0,1];
1439  			}else if(GetComponent&lt;GUIText&gt;()){
1440  				guiText.material.color=colors[0,1];
1441  			}else if(renderer){
1442  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
1443  					renderer.materials[i].SetColor(namedcolorvalue.ToString(),colors[i,1]);
1444  				}
1445  			}else if(light){
1446  				light.color=colors[0,1];
1447  			}			
1448  		}
1449  	}	
1450  	void ApplyAudioToTargets(){
1451  		vector2s[2].x = ease(vector2s[0].x,vector2s[1].x,percentage);
1452  		vector2s[2].y = ease(vector2s[0].y,vector2s[1].y,percentage);
1453  		audioSource.volume=vector2s[2].x;
1454  		audioSource.pitch=vector2s[2].y;
1455  		if(percentage==1){
1456  			audioSource.volume=vector2s[1].x;
1457  			audioSource.pitch=vector2s[1].y;	
1458  		}
1459  	}	
1460  	void ApplyStabTargets(){
1461  	}
1462  	void ApplyMoveToPathTargets(){
1463  		preUpdate = thisTransform.position;
1464  		float t = ease(0,1,percentage);
1465  		float lookAheadAmount;
1466  		if(isLocal){
1467  			thisTransform.localPosition=path.Interp(Mathf.Clamp(t,0,1));	
1468  		}else{
1469  			thisTransform.position=path.Interp(Mathf.Clamp(t,0,1));	
1470  		}
1471  		if(tweenArguments.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)tweenArguments[&quot;orienttopath&quot;]){
1472  			float tLook;
1473  			if(tweenArguments.Contains(&quot;lookahead&quot;)){
1474  				lookAheadAmount = (float)tweenArguments[&quot;lookahead&quot;];
1475  			}else{
1476  				lookAheadAmount = Defaults.lookAhead;
1477  			}
1478  			tLook = ease(0,1, Mathf.Min(1f, percentage+lookAheadAmount)); 
1479  			tweenArguments[&quot;looktarget&quot;] = path.Interp(Mathf.Clamp(tLook,0,1));
1480  		}
1481  		postUpdate=thisTransform.position;
1482  		if(physics){
1483  			thisTransform.position=preUpdate;
1484  			rigidbody.MovePosition(postUpdate);
1485  		}
1486  	}
1487  	void ApplyMoveToTargets(){
1488  		preUpdate=thisTransform.position;
1489  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1490  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1491  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1492  		if (isLocal) {
1493  			thisTransform.localPosition=vector3s[2];
1494  		}else{
1495  			thisTransform.position=vector3s[2];
1496  		}
1497  		if(percentage==1){
1498  			if (isLocal) {
1499  				thisTransform.localPosition=vector3s[1];		
1500  			}else{
1501  				thisTransform.position=vector3s[1];
1502  			}
1503  		}
1504  		postUpdate=thisTransform.position;
1505  		if(physics){
1506  			thisTransform.position=preUpdate;
1507  			rigidbody.MovePosition(postUpdate);
1508  		}
1509  	}	
1510  	void ApplyMoveByTargets(){	
1511  		preUpdate = thisTransform.position;
1512  		Vector3 currentRotation = new Vector3();
1513  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1514  			currentRotation = thisTransform.eulerAngles;
1515  			thisTransform.eulerAngles = vector3s[4];	
1516  		}
1517  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1518  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1519  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1520  		thisTransform.Translate(vector3s[2]-vector3s[3],space);
1521  		vector3s[3]=vector3s[2];
1522  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1523  			thisTransform.eulerAngles = currentRotation;	
1524  		}
1525  		postUpdate=thisTransform.position;
1526  		if(physics){
1527  			thisTransform.position=preUpdate;
1528  			rigidbody.MovePosition(postUpdate);
1529  		}
1530  	}	
1531  	void ApplyScaleToTargets(){
1532  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1533  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1534  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1535  		thisTransform.localScale=vector3s[2];	
1536  		if(percentage==1){
1537  			thisTransform.localScale=vector3s[1];
1538  		}
1539  	}
1540  	void ApplyLookToTargets(){
1541  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1542  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1543  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1544  		if (isLocal) {
1545  			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
1546  		}else{
1547  			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
1548  		};	
1549  	}	
1550  	void ApplyRotateToTargets(){
1551  		preUpdate=thisTransform.eulerAngles;
1552  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1553  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1554  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1555  		if (isLocal) {
1556  			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
1557  		}else{
1558  			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
1559  		};	
1560  		if(percentage==1){
1561  			if (isLocal) {
1562  				thisTransform.localRotation = Quaternion.Euler(vector3s[1]);
1563  			}else{
1564  				thisTransform.rotation = Quaternion.Euler(vector3s[1]);
1565  			};
1566  		}
1567  		postUpdate=thisTransform.eulerAngles;
1568  		if(physics){
1569  			thisTransform.eulerAngles=preUpdate;
1570  			rigidbody.MoveRotation(Quaternion.Euler(postUpdate));
1571  		}
1572  	}
1573  	void ApplyRotateAddTargets(){
1574  		preUpdate = thisTransform.eulerAngles;
1575  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1576  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1577  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1578  		thisTransform.Rotate(vector3s[2]-vector3s[3],space);
1579  		vector3s[3]=vector3s[2];	
1580  		postUpdate=thisTransform.eulerAngles;
1581  		if(physics){
1582  			thisTransform.eulerAngles=preUpdate;
1583  			rigidbody.MoveRotation(Quaternion.Euler(postUpdate));
1584  		}		
1585  	}	
1586  	void ApplyShakePositionTargets(){
1587  		if (isLocal) {
1588  			preUpdate = thisTransform.localPosition;
1589  		}else{
1590  			preUpdate = thisTransform.position;
1591  		}
1592  		Vector3 currentRotation = new Vector3();
1593  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1594  			currentRotation = thisTransform.eulerAngles;
1595  			thisTransform.eulerAngles = vector3s[3];	
1596  		}
1597  		if (percentage==0) {
1598  			thisTransform.Translate(vector3s[1],space);
1599  		}
1600  		if (isLocal) {
1601  			thisTransform.localPosition=vector3s[0];
1602  		}else{
1603  			thisTransform.position=vector3s[0];
1604  		}
1605  		float diminishingControl = 1-percentage;
1606  		vector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);
1607  		vector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);
1608  		vector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);
1609  		if (isLocal) {
1610  			thisTransform.localPosition+=vector3s[2];
1611  		}else{
1612  			thisTransform.position+=vector3s[2];
1613  		}
1614  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1615  			thisTransform.eulerAngles = currentRotation;	
1616  		}	
1617  		postUpdate=thisTransform.position;
1618  		if(physics){
1619  			thisTransform.position=preUpdate;
1620  			rigidbody.MovePosition(postUpdate);
1621  		}
1622  	}	
1623  	void ApplyShakeScaleTargets(){
1624  		if (percentage==0) {
1625  			thisTransform.localScale=vector3s[1];
1626  		}
1627  		thisTransform.localScale=vector3s[0];
1628  		float diminishingControl = 1-percentage;
1629  		vector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);
1630  		vector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);
1631  		vector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);
1632  		thisTransform.localScale+=vector3s[2];
1633  	}		
1634  	void ApplyShakeRotationTargets(){
1635  		preUpdate = thisTransform.eulerAngles;
1636  		if (percentage==0) {
1637  			thisTransform.Rotate(vector3s[1],space);
1638  		}
1639  		thisTransform.eulerAngles=vector3s[0];
1640  		float diminishingControl = 1-percentage;
1641  		vector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);
1642  		vector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);
1643  		vector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);
1644  		thisTransform.Rotate(vector3s[2],space);
1645  		postUpdate=thisTransform.eulerAngles;
1646  		if(physics){
1647  			thisTransform.eulerAngles=preUpdate;
1648  			rigidbody.MoveRotation(Quaternion.Euler(postUpdate));
1649  		}
1650  	}		
1651  	void ApplyPunchPositionTargets(){
1652  		preUpdate = thisTransform.position;
1653  		Vector3 currentRotation = new Vector3();
1654  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1655  			currentRotation = thisTransform.eulerAngles;
1656  			thisTransform.eulerAngles = vector3s[4];	
1657  		}
1658  		if(vector3s[1].x&gt;0){
1659  			vector3s[2].x = punch(vector3s[1].x,percentage);
1660  		}else if(vector3s[1].x&lt;0){
1661  			vector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); 
1662  		}
1663  		if(vector3s[1].y&gt;0){
1664  			vector3s[2].y=punch(vector3s[1].y,percentage);
1665  		}else if(vector3s[1].y&lt;0){
1666  			vector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); 
1667  		}
1668  		if(vector3s[1].z&gt;0){
1669  			vector3s[2].z=punch(vector3s[1].z,percentage);
1670  		}else if(vector3s[1].z&lt;0){
1671  			vector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); 
1672  		}
1673  		thisTransform.Translate(vector3s[2]-vector3s[3],space);
1674  		vector3s[3]=vector3s[2];
1675  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1676  			thisTransform.eulerAngles = currentRotation;	
1677  		}
1678  		postUpdate=thisTransform.position;
1679  		if(physics){
1680  			thisTransform.position=preUpdate;
1681  			rigidbody.MovePosition(postUpdate);
1682  		}
1683  	}		
1684  	void ApplyPunchRotationTargets(){
1685  		preUpdate = thisTransform.eulerAngles;
1686  		if(vector3s[1].x&gt;0){
1687  			vector3s[2].x = punch(vector3s[1].x,percentage);
1688  		}else if(vector3s[1].x&lt;0){
1689  			vector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); 
1690  		}
1691  		if(vector3s[1].y&gt;0){
1692  			vector3s[2].y=punch(vector3s[1].y,percentage);
1693  		}else if(vector3s[1].y&lt;0){
1694  			vector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); 
1695  		}
1696  		if(vector3s[1].z&gt;0){
1697  			vector3s[2].z=punch(vector3s[1].z,percentage);
1698  		}else if(vector3s[1].z&lt;0){
1699  			vector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); 
1700  		}
1701  		thisTransform.Rotate(vector3s[2]-vector3s[3],space);
1702  		vector3s[3]=vector3s[2];
1703  		postUpdate=thisTransform.eulerAngles;
1704  		if(physics){
1705  			thisTransform.eulerAngles=preUpdate;
1706  			rigidbody.MoveRotation(Quaternion.Euler(postUpdate));
1707  		}
1708  	}	
1709  	void ApplyPunchScaleTargets(){
1710  		if(vector3s[1].x&gt;0){
1711  			vector3s[2].x = punch(vector3s[1].x,percentage);
1712  		}else if(vector3s[1].x&lt;0){
1713  			vector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); 
1714  		}
1715  		if(vector3s[1].y&gt;0){
1716  			vector3s[2].y=punch(vector3s[1].y,percentage);
1717  		}else if(vector3s[1].y&lt;0){
1718  			vector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); 
1719  		}
1720  		if(vector3s[1].z&gt;0){
1721  			vector3s[2].z=punch(vector3s[1].z,percentage);
1722  		}else if(vector3s[1].z&lt;0){
1723  			vector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); 
1724  		}
1725  		thisTransform.localScale=vector3s[0]+vector3s[2];
1726  	}		
1727  	#endregion	
1728  	#region #5 Tween Steps
1729  	IEnumerator TweenDelay(){
1730  		delayStarted = Time.time;
1731  		yield return new WaitForSeconds (delay);
1732  		if(wasPaused){
1733  			wasPaused=false;
1734  			TweenStart();	
1735  		}
1736  	}	
1737  	void TweenStart(){		
1738  		CallBack(&quot;onstart&quot;);
1739  		if(!loop){
1740  			ConflictCheck();
1741  			GenerateTargets();
1742  		}
1743  		if(type == &quot;stab&quot;){
1744  			audioSource.PlayOneShot(audioSource.clip);
1745  		}
1746  		if (type == &quot;move&quot; || type==&quot;scale&quot; || type==&quot;rotate&quot; || type==&quot;punch&quot; || type==&quot;shake&quot; || type==&quot;curve&quot; || type==&quot;look&quot;) {
1747  			EnableKinematic();
1748  		}
1749  		isRunning = true;
1750  	}
1751  	IEnumerator TweenRestart(){
1752  		if(delay &gt; 0){
1753  			delayStarted = Time.time;
1754  			yield return new WaitForSeconds (delay);
1755  		}
1756  		loop=true;
1757  		TweenStart();
1758  	}	
1759  	void TweenUpdate(){
1760  		apply();
1761  		CallBack(&quot;onupdate&quot;);
1762  		UpdatePercentage();		
1763  	}
1764  	void TweenComplete(){
1765  		isRunning=false;
1766  		if(percentage&gt;.5f){
1767  			percentage=1f;
1768  		}else{
1769  			percentage=0;	
1770  		}
1771  		apply();
1772  		if(type == &quot;value&quot;){
1773  			CallBack(&quot;onupdate&quot;); 
1774  		}
1775  		if(loopType==LoopType.none){
1776  			Dispose();
1777  		}else{
1778  			TweenLoop();
1779  		}
1780  		CallBack(&quot;oncomplete&quot;);
1781  	}
1782  	void TweenLoop(){
1783  		DisableKinematic(); 
1784  		switch(loopType){
1785  			case LoopType.loop:
1786  				percentage=0;
1787  				runningTime=0;
1788  				apply();
1789  				StartCoroutine(&quot;TweenRestart&quot;);
1790  				break;
1791  			case LoopType.pingPong:
1792  				reverse = !reverse;
1793  				runningTime=0;
1794  				StartCoroutine(&quot;TweenRestart&quot;);
1795  				break;
1796  		}
1797  	}	
1798  	#endregion
1799  	#region #6 Update Callable
1800  	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed){
1801  		Rect diff = new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
1802  		return (diff);
1803  	}
1804  	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed){
1805  		Vector3 diff = targetValue - currentValue;
1806  		currentValue += (diff * speed) * Time.deltaTime;
1807  		return (currentValue);
1808  	}
1809  	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed){
1810  		Vector2 diff = targetValue - currentValue;
1811  		currentValue += (diff * speed) * Time.deltaTime;
1812  		return (currentValue);
1813  	}
1814  	public static float FloatUpdate(float currentValue, float targetValue, float speed){
1815  		float diff = targetValue - currentValue;
1816  		currentValue += (diff * speed) * Time.deltaTime;
1817  		return (currentValue);
1818  	}
1819  	public static void FadeUpdate(GameObject target, Hashtable args){
1820  		args[&quot;a&quot;]=args[&quot;alpha&quot;];
1821  		ColorUpdate(target,args);
1822  	}
1823  	public static void FadeUpdate(GameObject target, float alpha, float time){
1824  		FadeUpdate(target,Hash(&quot;alpha&quot;,alpha,&quot;time&quot;,time));
1825  	}
1826  	public static void ColorUpdate(GameObject target, Hashtable args){
1827  		CleanArgs(args);
1828  		float time;
1829  		Color[] colors = new Color[4];
1830  		if(!args.Contains(&quot;includechildren&quot;) || (bool)args[&quot;includechildren&quot;]){
1831  			foreach(Transform child in target.transform){
1832  				ColorUpdate(child.gameObject,args);
1833  			}
1834  		}		 
1835  		if(args.Contains(&quot;time&quot;)){
1836  			time=(float)args[&quot;time&quot;];
1837  			time*=Defaults.updateTimePercentage;
1838  		}else{
1839  			time=Defaults.updateTime;
1840  		}
1841  		if(target.GetComponent&lt;GUITexture&gt;()){
1842  			colors[0] = colors[1] = target.guiTexture.color;
1843  		}else if(target.GetComponent&lt;GUIText&gt;()){
1844  			colors[0] = colors[1] = target.guiText.material.color;
1845  		}else if(target.renderer){
1846  			colors[0] = colors[1] = target.renderer.material.color;
1847  		}else if(target.light){
1848  			colors[0] = colors[1] = target.light.color;	
1849  		}		
1850  		if (args.Contains(&quot;color&quot;)) {
1851  			colors[1]=(Color)args[&quot;color&quot;];
1852  		}else{
1853  			if (args.Contains(&quot;r&quot;)) {
1854  				colors[1].r=(float)args[&quot;r&quot;];
1855  			}
1856  			if (args.Contains(&quot;g&quot;)) {
1857  				colors[1].g=(float)args[&quot;g&quot;];
1858  			}
1859  			if (args.Contains(&quot;b&quot;)) {
1860  				colors[1].b=(float)args[&quot;b&quot;];
1861  			}
1862  			if (args.Contains(&quot;a&quot;)) {
1863  				colors[1].a=(float)args[&quot;a&quot;];
1864  			}
1865  		}
1866  		colors[3].r=Mathf.SmoothDamp(colors[0].r,colors[1].r,ref colors[2].r,time);
1867  		colors[3].g=Mathf.SmoothDamp(colors[0].g,colors[1].g,ref colors[2].g,time);
1868  		colors[3].b=Mathf.SmoothDamp(colors[0].b,colors[1].b,ref colors[2].b,time);
1869  		colors[3].a=Mathf.SmoothDamp(colors[0].a,colors[1].a,ref colors[2].a,time);
1870  		if(target.GetComponent&lt;GUITexture&gt;()){
1871  			target.guiTexture.color=colors[3];
1872  		}else if(target.GetComponent&lt;GUIText&gt;()){
1873  			target.guiText.material.color=colors[3];
1874  		}else if(target.renderer){
1875  			target.renderer.material.color=colors[3];
1876  		}else if(target.light){
1877  			target.light.color=colors[3];	
1878  		}
1879  	}	
1880  	public static void ColorUpdate(GameObject target, Color color, float time){
1881  		ColorUpdate(target,Hash(&quot;color&quot;,color,&quot;time&quot;,time));
1882  	}
1883  	public static void AudioUpdate(GameObject target, Hashtable args){
1884  		CleanArgs(args);
1885  		AudioSource audioSource;
1886  		float time;
1887  		Vector2[] vector2s = new Vector2[4];
1888  		if(args.Contains(&quot;time&quot;)){
1889  			time=(float)args[&quot;time&quot;];
1890  			time*=Defaults.updateTimePercentage;
1891  		}else{
1892  			time=Defaults.updateTime;
1893  		}
1894  		if(args.Contains(&quot;audiosource&quot;)){
1895  			audioSource=(AudioSource)args[&quot;audiosource&quot;];
1896  		}else{
1897  			if(target.GetComponent&lt;AudioSource&gt;()){
1898  				audioSource=target.audio;
1899  			}else{
1900  				Debug.LogError(&quot;iTween Error: AudioUpdate requires an AudioSource.&quot;);
1901  				return;
1902  			}
1903  		}		
1904  		vector2s[0] = vector2s[1] = new Vector2(audioSource.volume,audioSource.pitch);
1905  		if(args.Contains(&quot;volume&quot;)){
1906  			vector2s[1].x=(float)args[&quot;volume&quot;];
1907  		}
1908  		if(args.Contains(&quot;pitch&quot;)){
1909  			vector2s[1].y=(float)args[&quot;pitch&quot;];
1910  		}
1911  		vector2s[3].x=Mathf.SmoothDampAngle(vector2s[0].x,vector2s[1].x,ref vector2s[2].x,time);
1912  		vector2s[3].y=Mathf.SmoothDampAngle(vector2s[0].y,vector2s[1].y,ref vector2s[2].y,time);
1913  		audioSource.volume=vector2s[3].x;
1914  		audioSource.pitch=vector2s[3].y;
1915  	}
1916  	public static void AudioUpdate(GameObject target, float volume, float pitch, float time){
1917  		AudioUpdate(target,Hash(&quot;volume&quot;,volume,&quot;pitch&quot;,pitch,&quot;time&quot;,time));
1918  	}
1919  	public static void RotateUpdate(GameObject target, Hashtable args){
1920  		CleanArgs(args);
1921  		bool isLocal;
1922  		float time;
1923  		Vector3[] vector3s = new Vector3[4];
1924  		Vector3 preUpdate = target.transform.eulerAngles;
1925  		if(args.Contains(&quot;time&quot;)){
1926  			time=(float)args[&quot;time&quot;];
1927  			time*=Defaults.updateTimePercentage;
1928  		}else{
1929  			time=Defaults.updateTime;
1930  		}
1931  		if(args.Contains(&quot;islocal&quot;)){
1932  			isLocal = (bool)args[&quot;islocal&quot;];
1933  		}else{
1934  			isLocal = Defaults.isLocal;	
1935  		}
1936  		if(isLocal){
<span onclick='openModal()' class='match'>1937  			vector3s[0] = target.transform.localEulerAngles;
1938  		}else{
1939  			vector3s[0] = target.transform.eulerAngles;	
1940  		}
1941  		if(args.Contains(&quot;rotation&quot;)){
1942  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)){
1943  				Transform trans = (Transform)args[&quot;rotation&quot;];
1944  				vector3s[1]=trans.eulerAngles;
1945  			}else if(args[&quot;rotation&quot;].GetType() == typeof(Vector3)){
1946  				vector3s[1]=(Vector3)args[&quot;rotation&quot;];
1947  			}	
1948  		}
1949  		vector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
1950  		vector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
1951  		vector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
1952  		if(isLocal){
1953  			target.transform.localEulerAngles=vector3s[3];
1954  		}else{
1955  			target.transform.eulerAngles=vector3s[3];
1956  		}
1957  		if(target.rigidbody != null){
</span>1958  			Vector3 postUpdate=target.transform.eulerAngles;
1959  			target.transform.eulerAngles=preUpdate;
1960  			target.rigidbody.MoveRotation(Quaternion.Euler(postUpdate));
1961  		}
1962  	}
1963  	public static void RotateUpdate(GameObject target, Vector3 rotation, float time){
1964  		RotateUpdate(target,Hash(&quot;rotation&quot;,rotation,&quot;time&quot;,time));
1965  	}
1966  	public static void ScaleUpdate(GameObject target, Hashtable args){
1967  		CleanArgs(args);
1968  		float time;
1969  		Vector3[] vector3s = new Vector3[4];
1970  		if(args.Contains(&quot;time&quot;)){
1971  			time=(float)args[&quot;time&quot;];
1972  			time*=Defaults.updateTimePercentage;
1973  		}else{
1974  			time=Defaults.updateTime;
1975  		}
1976  		vector3s[0] = vector3s[1] = target.transform.localScale;
1977  		if (args.Contains(&quot;scale&quot;)) {
1978  			if (args[&quot;scale&quot;].GetType() == typeof(Transform)){
1979  				Transform trans = (Transform)args[&quot;scale&quot;];
1980  				vector3s[1]=trans.localScale;
1981  			}else if(args[&quot;scale&quot;].GetType() == typeof(Vector3)){
1982  				vector3s[1]=(Vector3)args[&quot;scale&quot;];
1983  			}				
1984  		}else{
1985  			if (args.Contains(&quot;x&quot;)) {
1986  				vector3s[1].x=(float)args[&quot;x&quot;];
1987  			}
1988  			if (args.Contains(&quot;y&quot;)) {
1989  				vector3s[1].y=(float)args[&quot;y&quot;];
1990  			}
1991  			if (args.Contains(&quot;z&quot;)) {
1992  				vector3s[1].z=(float)args[&quot;z&quot;];
1993  			}
1994  		}
1995  		vector3s[3].x=Mathf.SmoothDamp(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
1996  		vector3s[3].y=Mathf.SmoothDamp(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
1997  		vector3s[3].z=Mathf.SmoothDamp(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
1998  		target.transform.localScale=vector3s[3];		
1999  	}	
2000  	public static void ScaleUpdate(GameObject target, Vector3 scale, float time){
2001  		ScaleUpdate(target,Hash(&quot;scale&quot;,scale,&quot;time&quot;,time));
2002  	}
2003  	public static void MoveUpdate(GameObject target, Hashtable args){
2004  		CleanArgs(args);
2005  		float time;
2006  		Vector3[] vector3s = new Vector3[4];
2007  		bool isLocal;
2008  		Vector3 preUpdate = target.transform.position;
2009  		if(args.Contains(&quot;time&quot;)){
2010  			time=(float)args[&quot;time&quot;];
2011  			time*=Defaults.updateTimePercentage;
2012  		}else{
2013  			time=Defaults.updateTime;
2014  		}
2015  		if(args.Contains(&quot;islocal&quot;)){
2016  			isLocal = (bool)args[&quot;islocal&quot;];
2017  		}else{
2018  			isLocal = Defaults.isLocal;	
2019  		}
2020  		if(isLocal){
2021  			vector3s[0] = vector3s[1] = target.transform.localPosition;
2022  		}else{
2023  			vector3s[0] = vector3s[1] = target.transform.position;	
2024  		}
2025  		if (args.Contains(&quot;position&quot;)) {
2026  			if (args[&quot;position&quot;].GetType() == typeof(Transform)){
2027  				Transform trans = (Transform)args[&quot;position&quot;];
2028  				vector3s[1]=trans.position;
2029  			}else if(args[&quot;position&quot;].GetType() == typeof(Vector3)){
2030  				vector3s[1]=(Vector3)args[&quot;position&quot;];
2031  			}			
2032  		}else{
2033  			if (args.Contains(&quot;x&quot;)) {
2034  				vector3s[1].x=(float)args[&quot;x&quot;];
2035  			}
2036  			if (args.Contains(&quot;y&quot;)) {
2037  				vector3s[1].y=(float)args[&quot;y&quot;];
2038  			}
2039  			if (args.Contains(&quot;z&quot;)) {
2040  				vector3s[1].z=(float)args[&quot;z&quot;];
2041  			}
2042  		}
2043  		vector3s[3].x=Mathf.SmoothDamp(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
2044  		vector3s[3].y=Mathf.SmoothDamp(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
2045  		vector3s[3].z=Mathf.SmoothDamp(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
2046  		if(args.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)args[&quot;orienttopath&quot;]){
2047  			args[&quot;looktarget&quot;] = vector3s[3];
2048  		}
2049  		if(args.Contains(&quot;looktarget&quot;)){
2050  			iTween.LookUpdate(target,args);
2051  		}
2052  		if(isLocal){
2053  			target.transform.localPosition = vector3s[3];			
2054  		}else{
2055  			target.transform.position=vector3s[3];	
2056  		}	
2057  		if(target.rigidbody != null){
2058  			Vector3 postUpdate=target.transform.position;
2059  			target.transform.position=preUpdate;
2060  			target.rigidbody.MovePosition(postUpdate);
2061  		}
2062  	}
2063  	public static void MoveUpdate(GameObject target, Vector3 position, float time){
2064  		MoveUpdate(target,Hash(&quot;position&quot;,position,&quot;time&quot;,time));
2065  	}
2066  	public static void LookUpdate(GameObject target, Hashtable args){
2067  		CleanArgs(args);
2068  		float time;
2069  		Vector3[] vector3s = new Vector3[5];
2070  		if(args.Contains(&quot;looktime&quot;)){
2071  			time=(float)args[&quot;looktime&quot;];
2072  			time*=Defaults.updateTimePercentage;
2073  		}else if(args.Contains(&quot;time&quot;)){
2074  			time=(float)args[&quot;time&quot;]*.15f;
2075  			time*=Defaults.updateTimePercentage;
2076  		}else{
2077  			time=Defaults.updateTime;
2078  		}
2079  		vector3s[0] = target.transform.eulerAngles;
2080  		if(args.Contains(&quot;looktarget&quot;)){
2081  			if (args[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
2082  				target.transform.LookAt((Transform)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
2083  			}else if(args[&quot;looktarget&quot;].GetType() == typeof(Vector3)){
2084  				target.transform.LookAt((Vector3)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
2085  			}
2086  		}else{
2087  			Debug.LogError(&quot;iTween Error: LookUpdate needs a &#x27;looktarget&#x27; property!&quot;);
2088  			return;
2089  		}
2090  		vector3s[1]=target.transform.eulerAngles;
2091  		target.transform.eulerAngles=vector3s[0];
2092  		vector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
2093  		vector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
2094  		vector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
2095  		target.transform.eulerAngles=vector3s[3];
2096  		if(args.Contains(&quot;axis&quot;)){
2097  			vector3s[4]=target.transform.eulerAngles;
2098  			switch((string)args[&quot;axis&quot;]){
2099  				case &quot;x&quot;:
2100  					vector3s[4].y=vector3s[0].y;
2101  					vector3s[4].z=vector3s[0].z;
2102  				break;
2103  				case &quot;y&quot;:
2104  					vector3s[4].x=vector3s[0].x;
2105  					vector3s[4].z=vector3s[0].z;
2106  				break;
2107  				case &quot;z&quot;:
2108  					vector3s[4].x=vector3s[0].x;
2109  					vector3s[4].y=vector3s[0].y;
2110  				break;
2111  			}
2112  			target.transform.eulerAngles=vector3s[4];
2113  		}	
2114  	}
2115  	public static void LookUpdate(GameObject target, Vector3 looktarget, float time){
2116  		LookUpdate(target,Hash(&quot;looktarget&quot;,looktarget,&quot;time&quot;,time));
2117  	}
2118  	#endregion
2119  	#region #7 External Utilities
2120  	public static float PathLength(Transform[] path){
2121  		Vector3[] suppliedPath = new Vector3[path.Length];
2122  		float pathLength = 0;
2123  		for (int i = 0; i &lt; path.Length; i++) {
2124  			suppliedPath[i]=path[i].position;
2125  		}
2126  		Vector3[] vector3s = PathControlPointGenerator(suppliedPath);
2127  		Vector3 prevPt = Interp(vector3s,0);
2128  		int SmoothAmount = path.Length*20;
2129  		for (int i = 1; i &lt;= SmoothAmount; i++) {
2130  			float pm = (float) i / SmoothAmount;
2131  			Vector3 currPt = Interp(vector3s,pm);
2132  			pathLength += Vector3.Distance(prevPt,currPt);
2133  			prevPt = currPt;
2134  		}
2135  		return pathLength;
2136  	}
2137  	public static float PathLength(Vector3[] path){
2138  		float pathLength = 0;
2139  		Vector3[] vector3s = PathControlPointGenerator(path);
2140  		Vector3 prevPt = Interp(vector3s,0);
2141  		int SmoothAmount = path.Length*20;
2142  		for (int i = 1; i &lt;= SmoothAmount; i++) {
2143  			float pm = (float) i / SmoothAmount;
2144  			Vector3 currPt = Interp(vector3s,pm);
2145  			pathLength += Vector3.Distance(prevPt,currPt);
2146  			prevPt = currPt;
2147  		}
2148  		return pathLength;
2149  	}	
2150  	public static Texture2D CameraTexture(Color color){
2151  		Texture2D texture = new Texture2D(Screen.width,Screen.height,TextureFormat.ARGB32, false);
2152  		Color[] colors = new Color[Screen.width*Screen.height];
2153  		for (int i = 0; i &lt; colors.Length; i++) {
2154  			colors[i]=color;
2155  		}
2156  		texture.SetPixels(colors);
2157  		texture.Apply();
2158  		return(texture);		
2159  	}
2160  	public static void PutOnPath(GameObject target, Vector3[] path, float percent){
2161  		target.transform.position=Interp(PathControlPointGenerator(path),percent);
2162  	}
2163  	public static void PutOnPath(Transform target, Vector3[] path, float percent){
2164  		target.position=Interp(PathControlPointGenerator(path),percent);
2165  	}	
2166  	public static void PutOnPath(GameObject target, Transform[] path, float percent){
2167  		Vector3[] suppliedPath = new Vector3[path.Length];
2168  		for (int i = 0; i &lt; path.Length; i++) {
2169  			suppliedPath[i]=path[i].position;
2170  		}	
2171  		target.transform.position=Interp(PathControlPointGenerator(suppliedPath),percent);
2172  	}	
2173  	public static void PutOnPath(Transform target, Transform[] path, float percent){
2174  		Vector3[] suppliedPath = new Vector3[path.Length];
2175  		for (int i = 0; i &lt; path.Length; i++) {
2176  			suppliedPath[i]=path[i].position;
2177  		}	
2178  		target.position=Interp(PathControlPointGenerator(suppliedPath),percent);
2179  	}		
2180  	public static Vector3 PointOnPath(Transform[] path, float percent){
2181  		Vector3[] suppliedPath = new Vector3[path.Length];
2182  		for (int i = 0; i &lt; path.Length; i++) {
2183  			suppliedPath[i]=path[i].position;
2184  		}	
2185  		return(Interp(PathControlPointGenerator(suppliedPath),percent));
2186  	}
2187  	public static void DrawLine(Vector3[] line) {
2188  		if(line.Length&gt;0){
2189  			DrawLineHelper(line,Defaults.color,&quot;gizmos&quot;);
2190  		}
2191  	}	
2192  	public static void DrawLine(Vector3[] line, Color color) {
2193  		if(line.Length&gt;0){
2194  			DrawLineHelper(line,color,&quot;gizmos&quot;);
2195  		}
2196  	}		
2197  	public static void DrawLine(Transform[] line) {
2198  		if(line.Length&gt;0){
2199  			Vector3[] suppliedLine = new Vector3[line.Length];
2200  			for (int i = 0; i &lt; line.Length; i++) {
2201  				suppliedLine[i]=line[i].position;
2202  			}
2203  			DrawLineHelper(suppliedLine,Defaults.color,&quot;gizmos&quot;);
2204  		}
2205  	}		
2206  	public static void DrawLine(Transform[] line,Color color) {
2207  		if(line.Length&gt;0){
2208  			Vector3[] suppliedLine = new Vector3[line.Length];
2209  			for (int i = 0; i &lt; line.Length; i++) {
2210  				suppliedLine[i]=line[i].position;
2211  			}
2212  			DrawLineHelper(suppliedLine, color,&quot;gizmos&quot;);
2213  		}
2214  	}	
2215  	public static void DrawLineGizmos(Vector3[] line) {
2216  		if(line.Length&gt;0){
2217  			DrawLineHelper(line,Defaults.color,&quot;gizmos&quot;);
2218  		}
2219  	}	
2220  	public static void DrawLineGizmos(Vector3[] line, Color color) {
2221  		if(line.Length&gt;0){
2222  			DrawLineHelper(line,color,&quot;gizmos&quot;);
2223  		}
2224  	}		
2225  	public static void DrawLineGizmos(Transform[] line) {
2226  		if(line.Length&gt;0){
2227  			Vector3[] suppliedLine = new Vector3[line.Length];
2228  			for (int i = 0; i &lt; line.Length; i++) {
2229  				suppliedLine[i]=line[i].position;
2230  			}
2231  			DrawLineHelper(suppliedLine,Defaults.color,&quot;gizmos&quot;);
2232  		}
2233  	}		
2234  	public static void DrawLineGizmos(Transform[] line,Color color) {
2235  		if(line.Length&gt;0){
2236  			Vector3[] suppliedLine = new Vector3[line.Length];
2237  			for (int i = 0; i &lt; line.Length; i++) {
2238  				suppliedLine[i]=line[i].position;
2239  			}
2240  			DrawLineHelper(suppliedLine, color,&quot;gizmos&quot;);
2241  		}
2242  	}
2243  	public static void DrawLineHandles(Vector3[] line) {
2244  		if(line.Length&gt;0){
2245  			DrawLineHelper(line,Defaults.color,&quot;handles&quot;);
2246  		}
2247  	}	
2248  	public static void DrawLineHandles(Vector3[] line, Color color) {
2249  		if(line.Length&gt;0){
2250  			DrawLineHelper(line,color,&quot;handles&quot;);
2251  		}
2252  	}		
2253  	public static void DrawLineHandles(Transform[] line) {
2254  		if(line.Length&gt;0){
2255  			Vector3[] suppliedLine = new Vector3[line.Length];
2256  			for (int i = 0; i &lt; line.Length; i++) {
2257  				suppliedLine[i]=line[i].position;
2258  			}
2259  			DrawLineHelper(suppliedLine,Defaults.color,&quot;handles&quot;);
2260  		}
2261  	}		
2262  	public static void DrawLineHandles(Transform[] line,Color color) {
2263  		if(line.Length&gt;0){
2264  			Vector3[] suppliedLine = new Vector3[line.Length];
2265  			for (int i = 0; i &lt; line.Length; i++) {
2266  				suppliedLine[i]=line[i].position;
2267  			}
2268  			DrawLineHelper(suppliedLine, color,&quot;handles&quot;);
2269  		}
2270  	}	
2271  	public static Vector3 PointOnPath(Vector3[] path, float percent){
2272  		return(Interp(PathControlPointGenerator(path),percent));
2273  	}		
2274  	public static void DrawPath(Vector3[] path) {
2275  		if(path.Length&gt;0){
2276  			DrawPathHelper(path,Defaults.color,&quot;gizmos&quot;);
2277  		}
2278  	}		
2279  	public static void DrawPath(Vector3[] path, Color color) {
2280  		if(path.Length&gt;0){
2281  			DrawPathHelper(path, color,&quot;gizmos&quot;);
2282  		}
2283  	}
2284  	public static void DrawPath(Transform[] path) {
2285  		if(path.Length&gt;0){
2286  			Vector3[] suppliedPath = new Vector3[path.Length];
2287  			for (int i = 0; i &lt; path.Length; i++) {
2288  				suppliedPath[i]=path[i].position;
2289  			}
2290  			DrawPathHelper(suppliedPath,Defaults.color,&quot;gizmos&quot;);	
2291  		}
2292  	}		
2293  	public static void DrawPath(Transform[] path,Color color) {
2294  		if(path.Length&gt;0){
2295  			Vector3[] suppliedPath = new Vector3[path.Length];
2296  			for (int i = 0; i &lt; path.Length; i++) {
2297  				suppliedPath[i]=path[i].position;
2298  			}
2299  			DrawPathHelper(suppliedPath, color,&quot;gizmos&quot;);
2300  		}
2301  	}	
2302  	public static void DrawPathGizmos(Vector3[] path) {
2303  		if(path.Length&gt;0){
2304  			DrawPathHelper(path,Defaults.color,&quot;gizmos&quot;);
2305  		}
2306  	}		
2307  	public static void DrawPathGizmos(Vector3[] path, Color color) {
2308  		if(path.Length&gt;0){
2309  			DrawPathHelper(path, color,&quot;gizmos&quot;);
2310  		}
2311  	}
2312  	public static void DrawPathGizmos(Transform[] path) {
2313  		if(path.Length&gt;0){
2314  			Vector3[] suppliedPath = new Vector3[path.Length];
2315  			for (int i = 0; i &lt; path.Length; i++) {
2316  				suppliedPath[i]=path[i].position;
2317  			}
2318  			DrawPathHelper(suppliedPath,Defaults.color,&quot;gizmos&quot;);	
2319  		}
2320  	}		
2321  	public static void DrawPathGizmos(Transform[] path,Color color) {
2322  		if(path.Length&gt;0){
2323  			Vector3[] suppliedPath = new Vector3[path.Length];
2324  			for (int i = 0; i &lt; path.Length; i++) {
2325  				suppliedPath[i]=path[i].position;
2326  			}
2327  			DrawPathHelper(suppliedPath, color,&quot;gizmos&quot;);
2328  		}
2329  	}	
2330  	public static void DrawPathHandles(Vector3[] path) {
2331  		if(path.Length&gt;0){
2332  			DrawPathHelper(path,Defaults.color,&quot;handles&quot;);
2333  		}
2334  	}		
2335  	public static void DrawPathHandles(Vector3[] path, Color color) {
2336  		if(path.Length&gt;0){
2337  			DrawPathHelper(path, color,&quot;handles&quot;);
2338  		}
2339  	}
2340  	public static void DrawPathHandles(Transform[] path) {
2341  		if(path.Length&gt;0){
2342  			Vector3[] suppliedPath = new Vector3[path.Length];
2343  			for (int i = 0; i &lt; path.Length; i++) {
2344  				suppliedPath[i]=path[i].position;
2345  			}
2346  			DrawPathHelper(suppliedPath,Defaults.color,&quot;handles&quot;);	
2347  		}
2348  	}		
2349  	public static void DrawPathHandles(Transform[] path,Color color) {
2350  		if(path.Length&gt;0){
2351  			Vector3[] suppliedPath = new Vector3[path.Length];
2352  			for (int i = 0; i &lt; path.Length; i++) {
2353  				suppliedPath[i]=path[i].position;
2354  			}
2355  			DrawPathHelper(suppliedPath, color,&quot;handles&quot;);
2356  		}
2357  	}
2358  	public static void CameraFadeDepth(int depth){
2359  		if(cameraFade){
2360  			cameraFade.transform.position=new Vector3(cameraFade.transform.position.x,cameraFade.transform.position.y,depth);
2361  		}
2362  	}
2363  	public static void CameraFadeDestroy(){
2364  		if(cameraFade){
2365  			Destroy(cameraFade);
2366  		}
2367  	}
2368  	public static void CameraFadeSwap(Texture2D texture){
2369  		if(cameraFade){
2370  			cameraFade.guiTexture.texture=texture;
2371  		}
2372  	}
2373  	public static GameObject CameraFadeAdd(Texture2D texture, int depth){
2374  		if(cameraFade){
2375  			return null;
2376  		}else{			
2377  			cameraFade = new GameObject(&quot;iTween Camera Fade&quot;);
2378  			cameraFade.transform.position= new Vector3(.5f,.5f,depth);
2379  			cameraFade.AddComponent&lt;GUITexture&gt;();
2380  			cameraFade.guiTexture.texture=texture;
2381  			cameraFade.guiTexture.color = new Color(.5f,.5f,.5f,0);
2382  			return cameraFade;
2383  		}
2384  	}
2385  	public static GameObject CameraFadeAdd(Texture2D texture){
2386  		if(cameraFade){
2387  			return null;
2388  		}else{			
2389  			cameraFade = new GameObject(&quot;iTween Camera Fade&quot;);
2390  			cameraFade.transform.position= new Vector3(.5f,.5f,Defaults.cameraFadeDepth);
2391  			cameraFade.AddComponent&lt;GUITexture&gt;();
2392  			cameraFade.guiTexture.texture=texture;
2393  			cameraFade.guiTexture.color = new Color(.5f,.5f,.5f,0);
2394  			return cameraFade;
2395  		}
2396  	}
2397  	public static GameObject CameraFadeAdd(){
2398  		if(cameraFade){
2399  			return null;
2400  		}else{			
2401  			cameraFade = new GameObject(&quot;iTween Camera Fade&quot;);
2402  			cameraFade.transform.position= new Vector3(.5f,.5f,Defaults.cameraFadeDepth);
2403  			cameraFade.AddComponent&lt;GUITexture&gt;();
2404  			cameraFade.guiTexture.texture=CameraTexture(Color.black);
2405  			cameraFade.guiTexture.color = new Color(.5f,.5f,.5f,0);
2406  			return cameraFade;
2407  		}
2408  	}	
2409  	public static void Resume(GameObject target){
2410  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2411  		foreach (iTween item in tweens){
2412  			item.enabled=true;
2413  		}
2414  	}
2415  	public static void Resume(GameObject target, bool includechildren){
2416  		Resume(target);
2417  		if(includechildren){
2418  			foreach(Transform child in target.transform){
2419  				Resume(child.gameObject,true);
2420  			}			
2421  		}
2422  	}	
2423  	public static void Resume(GameObject target, string type){
2424  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2425  		foreach (iTween item in tweens){
2426  			string targetType = item.type+item.method;
2427  			targetType=targetType.Substring(0,type.Length);
2428  			if(targetType.ToLower() == type.ToLower()){
2429  				item.enabled=true;
2430  			}
2431  		}
2432  	}
2433  	public static void Resume(GameObject target, string type, bool includechildren){
2434  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2435  		foreach (iTween item in tweens){
2436  			string targetType = item.type+item.method;
2437  			targetType=targetType.Substring(0,type.Length);
2438  			if(targetType.ToLower() == type.ToLower()){
2439  				item.enabled=true;
2440  			}
2441  		}
2442  		if(includechildren){
2443  			foreach(Transform child in target.transform){
2444  				Resume(child.gameObject,type,true);
2445  			}			
2446  		}		
2447  	}	
2448  	public static void Resume(){
2449  		for (int i = 0; i &lt; tweens.Count; i++) {
2450  			Hashtable currentTween = tweens[i];
2451  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2452  			Resume(target);
2453  		}
2454  	}	
2455  	public static void Resume(string type){
2456  		ArrayList resumeArray = new ArrayList();
2457  		for (int i = 0; i &lt; tweens.Count; i++) {
2458  			Hashtable currentTween = tweens[i];
2459  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2460  			resumeArray.Insert(resumeArray.Count,target);
2461  		}
2462  		for (int i = 0; i &lt; resumeArray.Count; i++) {
2463  			Resume((GameObject)resumeArray[i],type);
2464  		}
2465  	}			
2466  	public static void Pause(GameObject target){
2467  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2468  		foreach (iTween item in tweens){
2469  			if(item.delay&gt;0){
2470  				item.delay-=Time.time-item.delayStarted;
2471  				item.StopCoroutine(&quot;TweenDelay&quot;);
2472  			}
2473  			item.isPaused=true;
2474  			item.enabled=false;
2475  		}
2476  	}
2477  	public static void Pause(GameObject target, bool includechildren){
2478  		Pause(target);
2479  		if(includechildren){
2480  			foreach(Transform child in target.transform){
2481  				Pause(child.gameObject,true);
2482  			}			
2483  		}
2484  	}	
2485  	public static void Pause(GameObject target, string type){
2486  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2487  		foreach (iTween item in tweens){
2488  			string targetType = item.type+item.method;
2489  			targetType=targetType.Substring(0,type.Length);
2490  			if(targetType.ToLower() == type.ToLower()){
2491  				if(item.delay&gt;0){
2492  					item.delay-=Time.time-item.delayStarted;
2493  					item.StopCoroutine(&quot;TweenDelay&quot;);
2494  				}
2495  				item.isPaused=true;
2496  				item.enabled=false;
2497  			}
2498  		}
2499  	}
2500  	public static void Pause(GameObject target, string type, bool includechildren){
2501  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2502  		foreach (iTween item in tweens){
2503  			string targetType = item.type+item.method;
2504  			targetType=targetType.Substring(0,type.Length);
2505  			if(targetType.ToLower() == type.ToLower()){
2506  				if(item.delay&gt;0){
2507  					item.delay-=Time.time-item.delayStarted;
2508  					item.StopCoroutine(&quot;TweenDelay&quot;);
2509  				}
2510  				item.isPaused=true;
2511  				item.enabled=false;
2512  			}
2513  		}
2514  		if(includechildren){
2515  			foreach(Transform child in target.transform){
2516  				Pause(child.gameObject,type,true);
2517  			}			
2518  		}		
2519  	}	
2520  	public static void Pause(){
2521  		for (int i = 0; i &lt; tweens.Count; i++) {
2522  			Hashtable currentTween = tweens[i];
2523  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2524  			Pause(target);
2525  		}
2526  	}	
2527  	public static void Pause(string type){
2528  		ArrayList pauseArray = new ArrayList();
2529  		for (int i = 0; i &lt; tweens.Count; i++) {
2530  			Hashtable currentTween = tweens[i];
2531  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2532  			pauseArray.Insert(pauseArray.Count,target);
2533  		}
2534  		for (int i = 0; i &lt; pauseArray.Count; i++) {
2535  			Pause((GameObject)pauseArray[i],type);
2536  		}
2537  	}		
2538  	public static int Count(){
2539  		return(tweens.Count);
2540  	}
2541  	public static int Count(string type){
2542  		int tweenCount = 0;
2543  		for (int i = 0; i &lt; tweens.Count; i++) {
2544  			Hashtable currentTween = tweens[i];
2545  			string targetType = (string)currentTween[&quot;type&quot;]+(string)currentTween[&quot;method&quot;];
2546  			targetType=targetType.Substring(0,type.Length);
2547  			if(targetType.ToLower() == type.ToLower()){
2548  				tweenCount++;
2549  			}
2550  		}	
2551  		return(tweenCount);
2552  	}			
2553  	public static int Count(GameObject target){
2554  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2555  		return(tweens.Length);
2556  	}
2557  	public static int Count(GameObject target, string type){
2558  		int tweenCount = 0;
2559  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2560  		foreach (iTween item in tweens){
2561  			string targetType = item.type+item.method;
2562  			targetType=targetType.Substring(0,type.Length);
2563  			if(targetType.ToLower() == type.ToLower()){
2564  				tweenCount++;
2565  			}
2566  		}
2567  		return(tweenCount);
2568  	}	
2569  	public static void Stop(){
2570  		for (int i = 0; i &lt; tweens.Count; i++) {
2571  			Hashtable currentTween = tweens[i];
2572  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2573  			Stop(target);
2574  		}
2575  		tweens.Clear();
2576  	}	
2577  	public static void Stop(string type){
2578  		ArrayList stopArray = new ArrayList();
2579  		for (int i = 0; i &lt; tweens.Count; i++) {
2580  			Hashtable currentTween = tweens[i];
2581  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2582  			stopArray.Insert(stopArray.Count,target);
2583  		}
2584  		for (int i = 0; i &lt; stopArray.Count; i++) {
2585  			Stop((GameObject)stopArray[i],type);
2586  		}
2587  	}		
2588  	public static void StopByName(string name){
2589  		ArrayList stopArray = new ArrayList();
2590  		for (int i = 0; i &lt; tweens.Count; i++) {
2591  			Hashtable currentTween = tweens[i];
2592  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2593  			stopArray.Insert(stopArray.Count,target);
2594  		}
2595  		for (int i = 0; i &lt; stopArray.Count; i++) {
2596  			StopByName((GameObject)stopArray[i],name);
2597  		}
2598  	}
2599  	public static void Stop(GameObject target){
2600  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2601  		foreach (iTween item in tweens){
2602  			item.Dispose();
2603  		}
2604  	}
2605  	public static void Stop(GameObject target, bool includechildren){
2606  		Stop(target);
2607  		if(includechildren){
2608  			foreach(Transform child in target.transform){
2609  				Stop(child.gameObject,true);
2610  			}			
2611  		}
2612  	}	
2613  	public static void Stop(GameObject target, string type){
2614  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2615  		foreach (iTween item in tweens){
2616  			string targetType = item.type+item.method;
2617  			targetType=targetType.Substring(0,type.Length);
2618  			if(targetType.ToLower() == type.ToLower()){
2619  				item.Dispose();
2620  			}
2621  		}
2622  	}
2623  	public static void StopByName(GameObject target, string name){
2624  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2625  		foreach (iTween item in tweens){
2626  			if(item._name == name){
2627  				item.Dispose();
2628  			}
2629  		}
2630  	}
2631  	public static void Stop(GameObject target, string type, bool includechildren){
2632  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2633  		foreach (iTween item in tweens){
2634  			string targetType = item.type+item.method;
2635  			targetType=targetType.Substring(0,type.Length);
2636  			if(targetType.ToLower() == type.ToLower()){
2637  				item.Dispose();
2638  			}
2639  		}
2640  		if(includechildren){
2641  			foreach(Transform child in target.transform){
2642  				Stop(child.gameObject,type,true);
2643  			}			
2644  		}		
2645  	}
2646  	public static void StopByName(GameObject target, string name, bool includechildren){
2647  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2648  		foreach (iTween item in tweens){
2649  			if(item._name == name){
2650  				item.Dispose();
2651  			}
2652  		}
2653  		if(includechildren){
2654  			foreach(Transform child in target.transform){
2655  				StopByName(child.gameObject,name,true);
2656  			}			
2657  		}		
2658  	}
2659  	public static Hashtable Hash(params object[] args){
2660  		Hashtable hashTable = new Hashtable(args.Length/2);
2661  		if (args.Length %2 != 0) {
2662  			Debug.LogError(&quot;Tween Error: Hash requires an even number of arguments!&quot;); 
2663  			return null;
2664  		}else{
2665  			int i = 0;
2666  			while(i &lt; args.Length - 1) {
2667  				hashTable.Add(args[i], args[i+1]);
2668  				i += 2;
2669  			}
2670  			return hashTable;
2671  		}
2672  	}	
2673  	#endregion		
2674  	#region Component Segments
2675  	private iTween(Hashtable h) {
2676  		tweenArguments = h;	
2677  	}
2678  	void Awake(){
2679  		thisTransform = transform;
2680  		RetrieveArgs();
2681          lastRealTime = Time.realtimeSinceStartup; 
2682  	}
2683  	IEnumerator Start(){
2684  		if(delay &gt; 0){
2685  			yield return StartCoroutine(&quot;TweenDelay&quot;);
2686  		}
2687  		TweenStart();
2688  	}	
2689  	void Update(){
2690  		if(isRunning &amp;&amp; !physics){
2691  			if(!reverse){
2692  				if(percentage&lt;1f){
2693  					TweenUpdate();
2694  				}else{
2695  					TweenComplete();	
2696  				}
2697  			}else{
2698  				if(percentage&gt;0){
2699  					TweenUpdate();
2700  				}else{
2701  					TweenComplete();	
2702  				}
2703  			}
2704  		}
2705  	}
2706  	void FixedUpdate(){
2707  		if(isRunning &amp;&amp; physics){
2708  			if(!reverse){
2709  				if(percentage&lt;1f){
2710  					TweenUpdate();
2711  				}else{
2712  					TweenComplete();	
2713  				}
2714  			}else{
2715  				if(percentage&gt;0){
2716  					TweenUpdate();
2717  				}else{
2718  					TweenComplete();	
2719  				}
2720  			}
2721  		}	
2722  	}
2723  	void LateUpdate(){
2724  		if(tweenArguments.Contains(&quot;looktarget&quot;) &amp;&amp; isRunning){
2725  			if(type ==&quot;move&quot; || type ==&quot;shake&quot; || type==&quot;punch&quot;){
2726  				LookUpdate(gameObject,tweenArguments);
2727  			}			
2728  		}
2729  	}
2730  	void OnEnable(){
2731  		if(isRunning){
2732  			EnableKinematic();
2733  		}
2734  		if(isPaused){
2735  			isPaused=false;
2736  			if(delay &gt; 0){
2737  				wasPaused=true;
2738  				ResumeDelay();
2739  			}
2740  		}
2741  	}
2742  	void OnDisable(){
2743  		DisableKinematic();
2744  	}
2745  	#endregion
2746  	#region Internal Helpers
2747  	private static void DrawLineHelper(Vector3[] line, Color color, string method){
2748  		Gizmos.color=color;
2749  		for (int i = 0; i &lt; line.Length-1; i++) {
2750  			if(method == &quot;gizmos&quot;){
2751  				Gizmos.DrawLine(line[i], line[i+1]);;
2752  			}else if(method == &quot;handles&quot;){
2753  				Debug.LogError(&quot;iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!&quot;);
2754  			}
2755  		}
2756  	}		
2757  	private static void DrawPathHelper(Vector3[] path, Color color, string method){
2758  		Vector3[] vector3s = PathControlPointGenerator(path);
2759  		Vector3 prevPt = Interp(vector3s,0);
2760  		Gizmos.color=color;
2761  		int SmoothAmount = path.Length*20;
2762  		for (int i = 1; i &lt;= SmoothAmount; i++) {
2763  			float pm = (float) i / SmoothAmount;
2764  			Vector3 currPt = Interp(vector3s,pm);
2765  			if(method == &quot;gizmos&quot;){
2766  				Gizmos.DrawLine(currPt, prevPt);
2767  			}else if(method == &quot;handles&quot;){
2768  				Debug.LogError(&quot;iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!&quot;);
2769  			}
2770  			prevPt = currPt;
2771  		}
2772  	}	
2773  	private static Vector3[] PathControlPointGenerator(Vector3[] path){
2774  		Vector3[] suppliedPath;
2775  		Vector3[] vector3s;
2776  		suppliedPath = path;
2777  		int offset = 2;
2778  		vector3s = new Vector3[suppliedPath.Length+offset];
2779  		Array.Copy(suppliedPath,0,vector3s,1,suppliedPath.Length);
2780  		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
2781  		vector3s[vector3s.Length-1] = vector3s[vector3s.Length-2] + (vector3s[vector3s.Length-2] - vector3s[vector3s.Length-3]);
2782  		if(vector3s[1] == vector3s[vector3s.Length-2]){
2783  			Vector3[] tmpLoopSpline = new Vector3[vector3s.Length];
2784  			Array.Copy(vector3s,tmpLoopSpline,vector3s.Length);
2785  			tmpLoopSpline[0]=tmpLoopSpline[tmpLoopSpline.Length-3];
2786  			tmpLoopSpline[tmpLoopSpline.Length-1]=tmpLoopSpline[2];
2787  			vector3s=new Vector3[tmpLoopSpline.Length];
2788  			Array.Copy(tmpLoopSpline,vector3s,tmpLoopSpline.Length);
2789  		}	
2790  		return(vector3s);
2791  	}
2792  	private static Vector3 Interp(Vector3[] pts, float t){
2793  		int numSections = pts.Length - 3;
2794  		int currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
2795  		float u = t * (float) numSections - (float) currPt;
2796  		Vector3 a = pts[currPt];
2797  		Vector3 b = pts[currPt + 1];
2798  		Vector3 c = pts[currPt + 2];
2799  		Vector3 d = pts[currPt + 3];
2800  		return .5f * (
2801  			(-a + 3f * b - 3f * c + d) * (u * u * u)
2802  			+ (2f * a - 5f * b + 4f * c - d) * (u * u)
2803  			+ (-a + c) * u
2804  			+ 2f * b
2805  		);
2806  	}	
2807  	private class CRSpline {
2808  		public Vector3[] pts;
2809  		public CRSpline(params Vector3[] pts) {
2810  			this.pts = new Vector3[pts.Length];
2811  			Array.Copy(pts, this.pts, pts.Length);
2812  		}
2813  		public Vector3 Interp(float t) {
2814  			int numSections = pts.Length - 3;
2815  			int currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
2816  			float u = t * (float) numSections - (float) currPt;
2817  			Vector3 a = pts[currPt];
2818  			Vector3 b = pts[currPt + 1];
2819  			Vector3 c = pts[currPt + 2];
2820  			Vector3 d = pts[currPt + 3];
2821  			return .5f*((-a+3f*b-3f*c+d)*(u*u*u)+(2f*a-5f*b+4f*c-d)*(u*u)+(-a+c)*u+2f*b);
2822  		}	
2823  	}	
2824  	static void Launch(GameObject target, Hashtable args){
2825  		if(!args.Contains(&quot;id&quot;)){
2826  			args[&quot;id&quot;] = GenerateID();
2827  		}
2828  		if(!args.Contains(&quot;target&quot;)){
2829  			args[&quot;target&quot;] = target;
2830  		}		
2831  		tweens.Insert (0, args);
2832  		target.AddComponent&lt;iTween&gt;();
2833  	}		
2834  	static Hashtable CleanArgs(Hashtable args){
2835  		Hashtable argsCopy = new Hashtable(args.Count);
2836  		Hashtable argsCaseUnified = new Hashtable(args.Count);
2837  		foreach (DictionaryEntry item in args) {
2838  			argsCopy.Add(item.Key, item.Value);
2839  		}
2840  		foreach (DictionaryEntry item in argsCopy) {
2841  			if(item.Value.GetType() == typeof(System.Int32)){
2842  				int original = (int)item.Value;
2843  				float casted = (float)original;
2844  				args[item.Key] = casted;
2845  			}
2846  			if(item.Value.GetType() == typeof(System.Double)){
2847  				double original = (double)item.Value;
2848  				float casted = (float)original;
2849  				args[item.Key] = casted;
2850  			}
2851  		}	
2852  		foreach (DictionaryEntry item in args) {
2853  			argsCaseUnified.Add(item.Key.ToString().ToLower(), item.Value);
2854  		}	
2855  		args = argsCaseUnified;
2856  		return args;
2857  	}	
2858  	static string GenerateID(){
2859  		return System.Guid.NewGuid().ToString();
2860  	}	
2861  	void RetrieveArgs(){
2862  		foreach (Hashtable item in tweens) {
2863  			if((GameObject)item[&quot;target&quot;] == gameObject){
2864  				tweenArguments=item;
2865  				break;
2866  			}
2867  		}
2868  		id=(string)tweenArguments[&quot;id&quot;];
2869  		type=(string)tweenArguments[&quot;type&quot;];
2870  		_name=(string)tweenArguments[&quot;name&quot;];
2871  		method=(string)tweenArguments[&quot;method&quot;];
2872  		if(tweenArguments.Contains(&quot;time&quot;)){
2873  			time=(float)tweenArguments[&quot;time&quot;];
2874  		}else{
2875  			time=Defaults.time;
2876  		}
2877  		if(rigidbody != null){
2878  			physics=true;
2879  		}
2880  		if(tweenArguments.Contains(&quot;delay&quot;)){
2881  			delay=(float)tweenArguments[&quot;delay&quot;];
2882  		}else{
2883  			delay=Defaults.delay;
2884  		}
2885  		if(tweenArguments.Contains(&quot;namedcolorvalue&quot;)){
2886  			if(tweenArguments[&quot;namedcolorvalue&quot;].GetType() == typeof(NamedValueColor)){
2887  				namedcolorvalue=(NamedValueColor)tweenArguments[&quot;namedcolorvalue&quot;];
2888  			}else{
2889  				try {
2890  					namedcolorvalue=(NamedValueColor)Enum.Parse(typeof(NamedValueColor),(string)tweenArguments[&quot;namedcolorvalue&quot;],true); 
2891  				} catch {
2892  					Debug.LogWarning(&quot;iTween: Unsupported namedcolorvalue supplied! Default will be used.&quot;);
2893  					namedcolorvalue = iTween.NamedValueColor._Color;
2894  				}
2895  			}			
2896  		}else{
2897  			namedcolorvalue=Defaults.namedColorValue;	
2898  		}	
2899  		if(tweenArguments.Contains(&quot;looptype&quot;)){
2900  			if(tweenArguments[&quot;looptype&quot;].GetType() == typeof(LoopType)){
2901  				loopType=(LoopType)tweenArguments[&quot;looptype&quot;];
2902  			}else{
2903  				try {
2904  					loopType=(LoopType)Enum.Parse(typeof(LoopType),(string)tweenArguments[&quot;looptype&quot;],true); 
2905  				} catch {
2906  					Debug.LogWarning(&quot;iTween: Unsupported loopType supplied! Default will be used.&quot;);
2907  					loopType = iTween.LoopType.none;	
2908  				}
2909  			}			
2910  		}else{
2911  			loopType = iTween.LoopType.none;	
2912  		}			
2913  		if(tweenArguments.Contains(&quot;easetype&quot;)){
2914  			if(tweenArguments[&quot;easetype&quot;].GetType() == typeof(EaseType)){
2915  				easeType=(EaseType)tweenArguments[&quot;easetype&quot;];
2916  			}else{
2917  				try {
2918  					easeType=(EaseType)Enum.Parse(typeof(EaseType),(string)tweenArguments[&quot;easetype&quot;],true); 
2919  				} catch {
2920  					Debug.LogWarning(&quot;iTween: Unsupported easeType supplied! Default will be used.&quot;);
2921  					easeType=Defaults.easeType;
2922  				}
2923  			}
2924  		}else{
2925  			easeType=Defaults.easeType;
2926  		}
2927  		if(tweenArguments.Contains(&quot;space&quot;)){
2928  			if(tweenArguments[&quot;space&quot;].GetType() == typeof(Space)){
2929  				space=(Space)tweenArguments[&quot;space&quot;];
2930  			}else{
2931  				try {
2932  					space=(Space)Enum.Parse(typeof(Space),(string)tweenArguments[&quot;space&quot;],true); 	
2933  				} catch {
2934  					Debug.LogWarning(&quot;iTween: Unsupported space supplied! Default will be used.&quot;);
2935  					space = Defaults.space;
2936  				}
2937  			}			
2938  		}else{
2939  			space = Defaults.space;
2940  		}
2941  		if(tweenArguments.Contains(&quot;islocal&quot;)){
2942  			isLocal = (bool)tweenArguments[&quot;islocal&quot;];
2943  		}else{
2944  			isLocal = Defaults.isLocal;
2945  		}
2946          if (tweenArguments.Contains(&quot;ignoretimescale&quot;))
2947          {
2948              useRealTime = (bool)tweenArguments[&quot;ignoretimescale&quot;];
2949          }
2950          else
2951          {
2952              useRealTime = Defaults.useRealTime;
2953          }
2954  		GetEasingFunction();
2955  	}	
2956  	void GetEasingFunction(){
2957  		switch (easeType){
2958  		case EaseType.easeInQuad:
2959  			ease  = new EasingFunction(easeInQuad);
2960  			break;
2961  		case EaseType.easeOutQuad:
2962  			ease = new EasingFunction(easeOutQuad);
2963  			break;
2964  		case EaseType.easeInOutQuad:
2965  			ease = new EasingFunction(easeInOutQuad);
2966  			break;
2967  		case EaseType.easeInCubic:
2968  			ease = new EasingFunction(easeInCubic);
2969  			break;
2970  		case EaseType.easeOutCubic:
2971  			ease = new EasingFunction(easeOutCubic);
2972  			break;
2973  		case EaseType.easeInOutCubic:
2974  			ease = new EasingFunction(easeInOutCubic);
2975  			break;
2976  		case EaseType.easeInQuart:
2977  			ease = new EasingFunction(easeInQuart);
2978  			break;
2979  		case EaseType.easeOutQuart:
2980  			ease = new EasingFunction(easeOutQuart);
2981  			break;
2982  		case EaseType.easeInOutQuart:
2983  			ease = new EasingFunction(easeInOutQuart);
2984  			break;
2985  		case EaseType.easeInQuint:
2986  			ease = new EasingFunction(easeInQuint);
2987  			break;
2988  		case EaseType.easeOutQuint:
2989  			ease = new EasingFunction(easeOutQuint);
2990  			break;
2991  		case EaseType.easeInOutQuint:
2992  			ease = new EasingFunction(easeInOutQuint);
2993  			break;
2994  		case EaseType.easeInSine:
2995  			ease = new EasingFunction(easeInSine);
2996  			break;
2997  		case EaseType.easeOutSine:
2998  			ease = new EasingFunction(easeOutSine);
2999  			break;
3000  		case EaseType.easeInOutSine:
3001  			ease = new EasingFunction(easeInOutSine);
3002  			break;
3003  		case EaseType.easeInExpo:
3004  			ease = new EasingFunction(easeInExpo);
3005  			break;
3006  		case EaseType.easeOutExpo:
3007  			ease = new EasingFunction(easeOutExpo);
3008  			break;
3009  		case EaseType.easeInOutExpo:
3010  			ease = new EasingFunction(easeInOutExpo);
3011  			break;
3012  		case EaseType.easeInCirc:
3013  			ease = new EasingFunction(easeInCirc);
3014  			break;
3015  		case EaseType.easeOutCirc:
3016  			ease = new EasingFunction(easeOutCirc);
3017  			break;
3018  		case EaseType.easeInOutCirc:
3019  			ease = new EasingFunction(easeInOutCirc);
3020  			break;
3021  		case EaseType.linear:
3022  			ease = new EasingFunction(linear);
3023  			break;
3024  		case EaseType.spring:
3025  			ease = new EasingFunction(spring);
3026  			break;
3027  		case EaseType.easeInBounce:
3028  			ease = new EasingFunction(easeInBounce);
3029  			break;
3030  		case EaseType.easeOutBounce:
3031  			ease = new EasingFunction(easeOutBounce);
3032  			break;
3033  		case EaseType.easeInOutBounce:
3034  			ease = new EasingFunction(easeInOutBounce);
3035  			break;
3036  		case EaseType.easeInBack:
3037  			ease = new EasingFunction(easeInBack);
3038  			break;
3039  		case EaseType.easeOutBack:
3040  			ease = new EasingFunction(easeOutBack);
3041  			break;
3042  		case EaseType.easeInOutBack:
3043  			ease = new EasingFunction(easeInOutBack);
3044  			break;
3045  		case EaseType.easeInElastic:
3046  			ease = new EasingFunction(easeInElastic);
3047  			break;
3048  		case EaseType.easeOutElastic:
3049  			ease = new EasingFunction(easeOutElastic);
3050  			break;
3051  		case EaseType.easeInOutElastic:
3052  			ease = new EasingFunction(easeInOutElastic);
3053  			break;
3054  		}
3055  	}
3056  	void UpdatePercentage(){
3057  	        if (useRealTime)
3058  	        {
3059  	            runningTime += (Time.realtimeSinceStartup - lastRealTime);      
3060  	        }
3061  	        else
3062  	        {
3063  	            runningTime += Time.deltaTime;
3064  	        }
3065  			if(reverse){
3066  				percentage = 1 - runningTime/time;	
3067  			}else{
3068  				percentage = runningTime/time;	
3069  			}
3070  	        lastRealTime = Time.realtimeSinceStartup; 
3071  	}
3072  	void CallBack(string callbackType){
3073  		if (tweenArguments.Contains(callbackType) &amp;&amp; !tweenArguments.Contains(&quot;ischild&quot;)) {
3074  			GameObject target;
3075  			if (tweenArguments.Contains(callbackType+&quot;target&quot;)) {
3076  				target=(GameObject)tweenArguments[callbackType+&quot;target&quot;];
3077  			}else{
3078  				target=gameObject;	
3079  			}
3080  			if (tweenArguments[callbackType].GetType() == typeof(System.String)) {
3081  				target.SendMessage((string)tweenArguments[callbackType],(object)tweenArguments[callbackType+&quot;params&quot;],SendMessageOptions.DontRequireReceiver);
3082  			}else{
3083  				Debug.LogError(&quot;iTween Error: Callback method references must be passed as a String!&quot;);
3084  				Destroy (this);
3085  			}
3086  		}
3087  	}
3088  	void Dispose(){
3089  		for (int i = 0; i &lt; tweens.Count; i++) {
3090  			Hashtable tweenEntry = tweens[i];
3091  			if ((string)tweenEntry[&quot;id&quot;] == id){
3092  				tweens.RemoveAt(i);
3093  				break;
3094  			}
3095  		}
3096  		Destroy(this);
3097  	}	
3098  	void ConflictCheck(){
3099  		Component[] tweens = GetComponents&lt;iTween&gt;();
3100  		foreach (iTween item in tweens) {
3101  			if(item.type == &quot;value&quot;){
3102  				return;
3103  			}else if(item.isRunning &amp;&amp; item.type==type){
3104  				if (item.method != method) {
3105  					return;
3106  				}				
3107  				if(item.tweenArguments.Count != tweenArguments.Count){
3108  					item.Dispose();
3109  					return;
3110  				}
3111  				foreach (DictionaryEntry currentProp in tweenArguments) {
3112  					if(!item.tweenArguments.Contains(currentProp.Key)){
3113  						item.Dispose();
3114  						return;
3115  					}else{
3116  						if(!item.tweenArguments[currentProp.Key].Equals(tweenArguments[currentProp.Key]) &amp;&amp; (string)currentProp.Key != &quot;id&quot;){
3117  							item.Dispose();
3118  							return;
3119  						}
3120  					}
3121  				}
3122  				Dispose();
3123  			}
3124  		}
3125  	}
3126  	void EnableKinematic(){
3127  	}
3128  	void DisableKinematic(){
3129  	}
3130  	void ResumeDelay(){
3131  		StartCoroutine(&quot;TweenDelay&quot;);
3132  	}	
3133  	#endregion	
3134  	#region Easing Curves
3135  	private float linear(float start, float end, float value){
3136  		return Mathf.Lerp(start, end, value);
3137  	}
3138  	private float clerp(float start, float end, float value){
3139  		float min = 0.0f;
3140  		float max = 360.0f;
3141  		float half = Mathf.Abs((max - min) * 0.5f);
3142  		float retval = 0.0f;
3143  		float diff = 0.0f;
3144  		if ((end - start) &lt; -half){
3145  			diff = ((max - start) + end) * value;
3146  			retval = start + diff;
3147  		}else if ((end - start) &gt; half){
3148  			diff = -((max - end) + start) * value;
3149  			retval = start + diff;
3150  		}else retval = start + (end - start) * value;
3151  		return retval;
3152      }
3153  	private float spring(float start, float end, float value){
3154  		value = Mathf.Clamp01(value);
3155  		value = (Mathf.Sin(value * Mathf.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + (1.2f * (1f - value)));
3156  		return start + (end - start) * value;
3157  	}
3158  	private float easeInQuad(float start, float end, float value){
3159  		end -= start;
3160  		return end * value * value + start;
3161  	}
3162  	private float easeOutQuad(float start, float end, float value){
3163  		end -= start;
3164  		return -end * value * (value - 2) + start;
3165  	}
3166  	private float easeInOutQuad(float start, float end, float value){
3167  		value /= .5f;
3168  		end -= start;
3169  		if (value &lt; 1) return end * 0.5f * value * value + start;
3170  		value--;
3171  		return -end * 0.5f * (value * (value - 2) - 1) + start;
3172  	}
3173  	private float easeInCubic(float start, float end, float value){
3174  		end -= start;
3175  		return end * value * value * value + start;
3176  	}
3177  	private float easeOutCubic(float start, float end, float value){
3178  		value--;
3179  		end -= start;
3180  		return end * (value * value * value + 1) + start;
3181  	}
3182  	private float easeInOutCubic(float start, float end, float value){
3183  		value /= .5f;
3184  		end -= start;
3185  		if (value &lt; 1) return end * 0.5f * value * value * value + start;
3186  		value -= 2;
3187  		return end * 0.5f * (value * value * value + 2) + start;
3188  	}
3189  	private float easeInQuart(float start, float end, float value){
3190  		end -= start;
3191  		return end * value * value * value * value + start;
3192  	}
3193  	private float easeOutQuart(float start, float end, float value){
3194  		value--;
3195  		end -= start;
3196  		return -end * (value * value * value * value - 1) + start;
3197  	}
3198  	private float easeInOutQuart(float start, float end, float value){
3199  		value /= .5f;
3200  		end -= start;
3201  		if (value &lt; 1) return end * 0.5f * value * value * value * value + start;
3202  		value -= 2;
3203  		return -end * 0.5f * (value * value * value * value - 2) + start;
3204  	}
3205  	private float easeInQuint(float start, float end, float value){
3206  		end -= start;
3207  		return end * value * value * value * value * value + start;
3208  	}
3209  	private float easeOutQuint(float start, float end, float value){
3210  		value--;
3211  		end -= start;
3212  		return end * (value * value * value * value * value + 1) + start;
3213  	}
3214  	private float easeInOutQuint(float start, float end, float value){
3215  		value /= .5f;
3216  		end -= start;
3217  		if (value &lt; 1) return end * 0.5f * value * value * value * value * value + start;
3218  		value -= 2;
3219  		return end * 0.5f * (value * value * value * value * value + 2) + start;
3220  	}
3221  	private float easeInSine(float start, float end, float value){
3222  		end -= start;
3223  		return -end * Mathf.Cos(value * (Mathf.PI * 0.5f)) + end + start;
3224  	}
3225  	private float easeOutSine(float start, float end, float value){
3226  		end -= start;
3227  		return end * Mathf.Sin(value * (Mathf.PI * 0.5f)) + start;
3228  	}
3229  	private float easeInOutSine(float start, float end, float value){
3230  		end -= start;
3231  		return -end * 0.5f * (Mathf.Cos(Mathf.PI * value) - 1) + start;
3232  	}
3233  	private float easeInExpo(float start, float end, float value){
3234  		end -= start;
3235  		return end * Mathf.Pow(2, 10 * (value - 1)) + start;
3236  	}
3237  	private float easeOutExpo(float start, float end, float value){
3238  		end -= start;
3239  		return end * (-Mathf.Pow(2, -10 * value ) + 1) + start;
3240  	}
3241  	private float easeInOutExpo(float start, float end, float value){
3242  		value /= .5f;
3243  		end -= start;
3244  		if (value &lt; 1) return end * 0.5f * Mathf.Pow(2, 10 * (value - 1)) + start;
3245  		value--;
3246  		return end * 0.5f * (-Mathf.Pow(2, -10 * value) + 2) + start;
3247  	}
3248  	private float easeInCirc(float start, float end, float value){
3249  		end -= start;
3250  		return -end * (Mathf.Sqrt(1 - value * value) - 1) + start;
3251  	}
3252  	private float easeOutCirc(float start, float end, float value){
3253  		value--;
3254  		end -= start;
3255  		return end * Mathf.Sqrt(1 - value * value) + start;
3256  	}
3257  	private float easeInOutCirc(float start, float end, float value){
3258  		value /= .5f;
3259  		end -= start;
3260  		if (value &lt; 1) return -end * 0.5f * (Mathf.Sqrt(1 - value * value) - 1) + start;
3261  		value -= 2;
3262  		return end * 0.5f * (Mathf.Sqrt(1 - value * value) + 1) + start;
3263  	}
3264  	private float easeInBounce(float start, float end, float value){
3265  		end -= start;
3266  		float d = 1f;
3267  		return end - easeOutBounce(0, end, d-value) + start;
3268  	}
3269  	private float easeOutBounce(float start, float end, float value){
3270  		value /= 1f;
3271  		end -= start;
3272  		if (value &lt; (1 / 2.75f)){
3273  			return end * (7.5625f * value * value) + start;
3274  		}else if (value &lt; (2 / 2.75f)){
3275  			value -= (1.5f / 2.75f);
3276  			return end * (7.5625f * (value) * value + .75f) + start;
3277  		}else if (value &lt; (2.5 / 2.75)){
3278  			value -= (2.25f / 2.75f);
3279  			return end * (7.5625f * (value) * value + .9375f) + start;
3280  		}else{
3281  			value -= (2.625f / 2.75f);
3282  			return end * (7.5625f * (value) * value + .984375f) + start;
3283  		}
3284  	}
3285  	private float easeInOutBounce(float start, float end, float value){
3286  		end -= start;
3287  		float d = 1f;
3288  		if (value &lt; d* 0.5f) return easeInBounce(0, end, value*2) * 0.5f + start;
3289  		else return easeOutBounce(0, end, value*2-d) * 0.5f + end*0.5f + start;
3290  	}
3291  	private float easeInBack(float start, float end, float value){
3292  		end -= start;
3293  		value /= 1;
3294  		float s = 1.70158f;
3295  		return end * (value) * value * ((s + 1) * value - s) + start;
3296  	}
3297  	private float easeOutBack(float start, float end, float value){
3298  		float s = 1.70158f;
3299  		end -= start;
3300  		value = (value) - 1;
3301  		return end * ((value) * value * ((s + 1) * value + s) + 1) + start;
3302  	}
3303  	private float easeInOutBack(float start, float end, float value){
3304  		float s = 1.70158f;
3305  		end -= start;
3306  		value /= .5f;
3307  		if ((value) &lt; 1){
3308  			s *= (1.525f);
3309  			return end * 0.5f * (value * value * (((s) + 1) * value - s)) + start;
3310  		}
3311  		value -= 2;
3312  		s *= (1.525f);
3313  		return end * 0.5f * ((value) * value * (((s) + 1) * value + s) + 2) + start;
3314  	}
3315  	private float punch(float amplitude, float value){
3316  		float s = 9;
3317  		if (value == 0){
3318  			return 0;
3319  		}
3320  		else if (value == 1){
3321  			return 0;
3322  		}
3323  		float period = 1 * 0.3f;
3324  		s = period / (2 * Mathf.PI) * Mathf.Asin(0);
3325  		return (amplitude * Mathf.Pow(2, -10 * value) * Mathf.Sin((value * 1 - s) * (2 * Mathf.PI) / period));
3326      }
3327  	private float easeInElastic(float start, float end, float value){
3328  		end -= start;
3329  		float d = 1f;
3330  		float p = d * .3f;
3331  		float s = 0;
3332  		float a = 0;
3333  		if (value == 0) return start;
3334  		if ((value /= d) == 1) return start + end;
3335  		if (a == 0f || a &lt; Mathf.Abs(end)){
3336  			a = end;
3337  			s = p / 4;
3338  			}else{
3339  			s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
3340  		}
3341  		return -(a * Mathf.Pow(2, 10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p)) + start;
3342  	}		
3343  	private float easeOutElastic(float start, float end, float value){
3344  		end -= start;
3345  		float d = 1f;
3346  		float p = d * .3f;
3347  		float s = 0;
3348  		float a = 0;
3349  		if (value == 0) return start;
3350  		if ((value /= d) == 1) return start + end;
3351  		if (a == 0f || a &lt; Mathf.Abs(end)){
3352  			a = end;
3353  			s = p * 0.25f;
3354  			}else{
3355  			s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
3356  		}
3357  		return (a * Mathf.Pow(2, -10 * value) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p) + end + start);
3358  	}		
3359  	private float easeInOutElastic(float start, float end, float value){
3360  		end -= start;
3361  		float d = 1f;
3362  		float p = d * .3f;
3363  		float s = 0;
3364  		float a = 0;
3365  		if (value == 0) return start;
3366  		if ((value /= d*0.5f) == 2) return start + end;
3367  		if (a == 0f || a &lt; Mathf.Abs(end)){
3368  			a = end;
3369  			s = p / 4;
3370  			}else{
3371  			s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
3372  		}
3373  		if (value &lt; 1) return -0.5f * (a * Mathf.Pow(2, 10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p)) + start;
3374  		return a * Mathf.Pow(2, -10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p) * 0.5f + end + start;
3375  	}		
3376  	#endregion	
3377  	#region Deprecated and Renamed
3378  	#endregion
3379  } 
</code></pre>
        </div>
        <div class="column">
            <h3>dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-iTween.cs</h3>
            <pre><code>1  #region Namespaces
2  using System;
3  using System.Collections;
4  using System.Collections.Generic;
5  using System.Reflection;
6  using UnityEngine;
7  #endregion
8  public class iTween : MonoBehaviour{
9  	#region Variables
10  	public static List&lt;Hashtable&gt; tweens = new List&lt;Hashtable&gt;();
11  	private static GameObject cameraFade;
12  	public string id, type, method;
13  	public iTween.EaseType easeType;
14  	public float time, delay;
15  	public LoopType loopType;
16  	public bool isRunning,isPaused;
17  	public string _name;
18   	private float runningTime, percentage;
19  	private float delayStarted; 
20  	private bool kinematic, isLocal, loop, reverse, wasPaused, physics;
21  	private Hashtable tweenArguments;
22  	private Space space;
23  	private delegate float EasingFunction(float start, float end, float Value);
24  	private delegate void ApplyTween();
25  	private EasingFunction ease;
26  	private ApplyTween apply;
27  	private AudioSource audioSource;
28  	private Vector3[] vector3s;
29  	private Vector2[] vector2s;
30  	private Color[,] colors;
31  	private float[] floats;
32  	private Rect[] rects;
33  	private CRSpline path;
34  	private Vector3 preUpdate;
35  	private Vector3 postUpdate;
36  	private NamedValueColor namedcolorvalue;
37      private float lastRealTime; 
38      private bool useRealTime; 
39  	private Transform thisTransform;
40  	public enum EaseType{
41  		easeInQuad,
42  		easeOutQuad,
43  		easeInOutQuad,
44  		easeInCubic,
45  		easeOutCubic,
46  		easeInOutCubic,
47  		easeInQuart,
48  		easeOutQuart,
49  		easeInOutQuart,
50  		easeInQuint,
51  		easeOutQuint,
52  		easeInOutQuint,
53  		easeInSine,
54  		easeOutSine,
55  		easeInOutSine,
56  		easeInExpo,
57  		easeOutExpo,
58  		easeInOutExpo,
59  		easeInCirc,
60  		easeOutCirc,
61  		easeInOutCirc,
62  		linear,
63  		spring,
64  		easeInBounce,
65  		easeOutBounce,
66  		easeInOutBounce,
67  		easeInBack,
68  		easeOutBack,
69  		easeInOutBack,
70  		easeInElastic,
71  		easeOutElastic,
72  		easeInOutElastic,
73  		punch
74  	}
75  	public enum LoopType{
76  		none,
77  		loop,
78  		pingPong
79  	}
80  	public enum NamedValueColor{
81  		_Color,
82  		_SpecColor,
83  		_Emission,
84  		_ReflectColor
85  	}
86  	#endregion
87  	#region Defaults
88  	public static class Defaults{
89  		public static float time = 1f;
90  		public static float delay = 0f;	
91  		public static NamedValueColor namedColorValue = NamedValueColor._Color;
92  		public static LoopType loopType = LoopType.none;
93  		public static EaseType easeType = iTween.EaseType.easeOutExpo;
94  		public static float lookSpeed = 3f;
95  		public static bool isLocal = false;
96  		public static Space space = Space.Self;
97  		public static bool orientToPath = false;
98  		public static Color color = Color.white;
99  		public static float updateTimePercentage = .05f;
100  		public static float updateTime = 1f*updateTimePercentage;
101  		public static int cameraFadeDepth = 999999;
102  		public static float lookAhead = .05f;
103          public static bool useRealTime = false; 
104  		public static Vector3 up = Vector3.up;
105  	}
106  	#endregion
107  	#region #1 Static Registers
108  	public static void Init(GameObject target){
109  		MoveBy(target,Vector3.zero,0);
110  	}
111  	public static void CameraFadeFrom(float amount, float time){
112  		if(cameraFade){
113  			CameraFadeFrom(Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
114  		}else{
115  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
116  		}
117  	}
118  	public static void CameraFadeFrom(Hashtable args){		
119  		if(cameraFade){
120  			ColorFrom(cameraFade,args);
121  		}else{
122  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
123  		}
124  	}	
125  	public static void CameraFadeTo(float amount, float time){
126  		if(cameraFade){
127  			CameraFadeTo(Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
128  		}else{
129  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
130  		}
131  	}	
132  	public static void CameraFadeTo(Hashtable args){
133  		if(cameraFade){
134  			ColorTo(cameraFade,args);
135  		}else{
136  			Debug.LogError(&quot;iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.&quot;);
137  		}
138  	}	
139  	public static void ValueTo(GameObject target, Hashtable args){
140  		args = iTween.CleanArgs(args);
141  		if (!args.Contains(&quot;onupdate&quot;) || !args.Contains(&quot;from&quot;) || !args.Contains(&quot;to&quot;)) {
142  			Debug.LogError(&quot;iTween Error: ValueTo() requires an &#x27;onupdate&#x27; callback function and a &#x27;from&#x27; and &#x27;to&#x27; property.  The supplied &#x27;onupdate&#x27; callback must accept a single argument that is the same type as the supplied &#x27;from&#x27; and &#x27;to&#x27; properties!&quot;);
143  			return;
144  		}else{
145  			args[&quot;type&quot;]=&quot;value&quot;;
146  			if (args[&quot;from&quot;].GetType() == typeof(Vector2)) {
147  				args[&quot;method&quot;]=&quot;vector2&quot;;
148  			}else if (args[&quot;from&quot;].GetType() == typeof(Vector3)) {
149  				args[&quot;method&quot;]=&quot;vector3&quot;;
150  			}else if (args[&quot;from&quot;].GetType() == typeof(Rect)) {
151  				args[&quot;method&quot;]=&quot;rect&quot;;
152  			}else if (args[&quot;from&quot;].GetType() == typeof(Single)) {
153  				args[&quot;method&quot;]=&quot;float&quot;;
154  			}else if (args[&quot;from&quot;].GetType() == typeof(Color)) {
155  				args[&quot;method&quot;]=&quot;color&quot;;
156  			}else{
157  				Debug.LogError(&quot;iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!&quot;);
158  				return;	
159  			}
160  			if (!args.Contains(&quot;easetype&quot;)) {
161  				args.Add(&quot;easetype&quot;,EaseType.linear);
162  			}
163  			Launch(target,args);
164  		}
165  	}
166  	public static void FadeFrom(GameObject target, float alpha, float time){
167  		FadeFrom(target,Hash(&quot;alpha&quot;,alpha,&quot;time&quot;,time));
168  	}
169  	public static void FadeFrom(GameObject target, Hashtable args){	
170  		ColorFrom(target,args);
171  	}		
172  	public static void FadeTo(GameObject target, float alpha, float time){
173  		FadeTo(target,Hash(&quot;alpha&quot;,alpha,&quot;time&quot;,time));
174  	}	
175  	public static void FadeTo(GameObject target, Hashtable args){
176  		ColorTo(target,args);
177  	}		
178  	public static void ColorFrom(GameObject target, Color color, float time){
179  		ColorFrom(target,Hash(&quot;color&quot;,color,&quot;time&quot;,time));
180  	}
181  	public static void ColorFrom(GameObject target, Hashtable args){	
182  		Color fromColor = new Color();
183  		Color tempColor = new Color();
184  		args = iTween.CleanArgs(args);
185  		if(!args.Contains(&quot;includechildren&quot;) || (bool)args[&quot;includechildren&quot;]){
186  			foreach(Transform child in target.transform){
187  				Hashtable argsCopy = (Hashtable)args.Clone();
188  				argsCopy[&quot;ischild&quot;]=true;
189  				ColorFrom(child.gameObject,argsCopy);
190  			}
191  		}
192  		if (!args.Contains(&quot;easetype&quot;)) {
193  			args.Add(&quot;easetype&quot;,EaseType.linear);
194  		}
195  		if(target.GetComponent&lt;GUITexture&gt;()){
196  			tempColor=fromColor=target.GetComponent&lt;GUITexture&gt;().color;	
197  		}else if(target.GetComponent&lt;GUIText&gt;()){
198  			tempColor=fromColor=target.GetComponent&lt;GUIText&gt;().material.color;
199  		}else if(target.GetComponent&lt;Renderer&gt;()){
200  			tempColor=fromColor=target.GetComponent&lt;Renderer&gt;().material.color;
201  		}else if(target.GetComponent&lt;Light&gt;()){
202  			tempColor=fromColor=target.GetComponent&lt;Light&gt;().color;
203  		}
204  		if(args.Contains(&quot;color&quot;)){
205  			fromColor=(Color)args[&quot;color&quot;];
206  		}else{
207  			if (args.Contains(&quot;r&quot;)) {
208  				fromColor.r=(float)args[&quot;r&quot;];
209  			}
210  			if (args.Contains(&quot;g&quot;)) {
211  				fromColor.g=(float)args[&quot;g&quot;];
212  			}
213  			if (args.Contains(&quot;b&quot;)) {
214  				fromColor.b=(float)args[&quot;b&quot;];
215  			}
216  			if (args.Contains(&quot;a&quot;)) {
217  				fromColor.a=(float)args[&quot;a&quot;];
218  			}
219  		}
220  		if(args.Contains(&quot;amount&quot;)){
221  			fromColor.a=(float)args[&quot;amount&quot;];
222  			args.Remove(&quot;amount&quot;);
223  		}else if(args.Contains(&quot;alpha&quot;)){
224  			fromColor.a=(float)args[&quot;alpha&quot;];
225  			args.Remove(&quot;alpha&quot;);
226  		}
227  		if(target.GetComponent&lt;GUITexture&gt;()){
228  			target.GetComponent&lt;GUITexture&gt;().color=fromColor;	
229  		}else if(target.GetComponent&lt;GUIText&gt;()){
230  			target.GetComponent&lt;GUIText&gt;().material.color=fromColor;
231  		}else if(target.GetComponent&lt;Renderer&gt;()){
232  			target.GetComponent&lt;Renderer&gt;().material.color=fromColor;
233  		}else if(target.GetComponent&lt;Light&gt;()){
234  			target.GetComponent&lt;Light&gt;().color=fromColor;
235  		}
236  		args[&quot;color&quot;]=tempColor;
237  		args[&quot;type&quot;]=&quot;color&quot;;
238  		args[&quot;method&quot;]=&quot;to&quot;;
239  		Launch(target,args);
240  	}		
241  	public static void ColorTo(GameObject target, Color color, float time){
242  		ColorTo(target,Hash(&quot;color&quot;,color,&quot;time&quot;,time));
243  	}
244  	public static void ColorTo(GameObject target, Hashtable args){	
245  		args = iTween.CleanArgs(args);
246  		if(!args.Contains(&quot;includechildren&quot;) || (bool)args[&quot;includechildren&quot;]){
247  			foreach(Transform child in target.transform){
248  				Hashtable argsCopy = (Hashtable)args.Clone();
249  				argsCopy[&quot;ischild&quot;]=true;
250  				ColorTo(child.gameObject,argsCopy);
251  			}
252  		}
253  		if (!args.Contains(&quot;easetype&quot;)) {
254  			args.Add(&quot;easetype&quot;,EaseType.linear);
255  		}
256  		args[&quot;type&quot;]=&quot;color&quot;;
257  		args[&quot;method&quot;]=&quot;to&quot;;
258  		Launch(target,args);
259  	}	
260  	public static void AudioFrom(GameObject target, float volume, float pitch, float time){
261  		AudioFrom(target,Hash(&quot;volume&quot;,volume,&quot;pitch&quot;,pitch,&quot;time&quot;,time));
262  	}
263  	public static void AudioFrom(GameObject target, Hashtable args){
264  		Vector2 tempAudioProperties;
265  		Vector2 fromAudioProperties;
266  		AudioSource tempAudioSource;
267  		args = iTween.CleanArgs(args);
268  		if(args.Contains(&quot;audiosource&quot;)){
269  			tempAudioSource=(AudioSource)args[&quot;audiosource&quot;];
270  		}else{
271  			if(target.GetComponent&lt;AudioSource&gt;()){
272  				tempAudioSource=target.GetComponent&lt;AudioSource&gt;();
273  			}else{
274  				Debug.LogError(&quot;iTween Error: AudioFrom requires an AudioSource.&quot;);
275  				return;
276  			}
277  		}			
278  		tempAudioProperties.x=fromAudioProperties.x=tempAudioSource.volume;
279  		tempAudioProperties.y=fromAudioProperties.y=tempAudioSource.pitch;
280  		if(args.Contains(&quot;volume&quot;)){
281  			fromAudioProperties.x=(float)args[&quot;volume&quot;];
282  		}
283  		if(args.Contains(&quot;pitch&quot;)){
284  			fromAudioProperties.y=(float)args[&quot;pitch&quot;];
285  		}
286  		tempAudioSource.volume=fromAudioProperties.x;
287  		tempAudioSource.pitch=fromAudioProperties.y;
288  		args[&quot;volume&quot;]=tempAudioProperties.x;
289  		args[&quot;pitch&quot;]=tempAudioProperties.y;
290  		if (!args.Contains(&quot;easetype&quot;)) {
291  			args.Add(&quot;easetype&quot;,EaseType.linear);
292  		}
293  		args[&quot;type&quot;]=&quot;audio&quot;;
294  		args[&quot;method&quot;]=&quot;to&quot;;
295  		Launch(target,args);			
296  	}		
297  	public static void AudioTo(GameObject target, float volume, float pitch, float time){
298  		AudioTo(target,Hash(&quot;volume&quot;,volume,&quot;pitch&quot;,pitch,&quot;time&quot;,time));
299  	}
300  	public static void AudioTo(GameObject target, Hashtable args){
301  		args = iTween.CleanArgs(args);
302  		if (!args.Contains(&quot;easetype&quot;)) {
303  			args.Add(&quot;easetype&quot;,EaseType.linear);
304  		}
305  		args[&quot;type&quot;]=&quot;audio&quot;;
306  		args[&quot;method&quot;]=&quot;to&quot;;
307  		Launch(target,args);			
308  	}	
309  	public static void Stab(GameObject target, AudioClip audioclip, float delay){
310  		Stab(target,Hash(&quot;audioclip&quot;,audioclip,&quot;delay&quot;,delay));
311  	}
312  	public static void Stab(GameObject target, Hashtable args){
313  		args = iTween.CleanArgs(args);
314  		args[&quot;type&quot;]=&quot;stab&quot;;
315  		Launch(target,args);			
316  	}
317  	public static void LookFrom(GameObject target, Vector3 looktarget, float time){
318  		LookFrom(target,Hash(&quot;looktarget&quot;,looktarget,&quot;time&quot;,time));
319  	}	
320  	public static void LookFrom(GameObject target, Hashtable args){
321  		Vector3 tempRotation;
322  		Vector3 tempRestriction;
323  		args = iTween.CleanArgs(args);
324  		tempRotation=target.transform.eulerAngles;
325  		if (args[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
326  			target.transform.LookAt((Transform)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
327  		}else if(args[&quot;looktarget&quot;].GetType() == typeof(Vector3)){
328  			target.transform.LookAt((Vector3)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
329  		}
330  		if(args.Contains(&quot;axis&quot;)){
331  			tempRestriction=target.transform.eulerAngles;
332  			switch((string)args[&quot;axis&quot;]){
333  				case &quot;x&quot;:
334  				 	tempRestriction.y=tempRotation.y;
335  					tempRestriction.z=tempRotation.z;
336  				break;
337  				case &quot;y&quot;:
338  					tempRestriction.x=tempRotation.x;
339  					tempRestriction.z=tempRotation.z;
340  				break;
341  				case &quot;z&quot;:
342  					tempRestriction.x=tempRotation.x;
343  					tempRestriction.y=tempRotation.y;
344  				break;
345  			}
346  			target.transform.eulerAngles=tempRestriction;
347  		}		
348  		args[&quot;rotation&quot;] = tempRotation;
349  		args[&quot;type&quot;]=&quot;rotate&quot;;
350  		args[&quot;method&quot;]=&quot;to&quot;;
351  		Launch(target,args);
352  	}		
353  	public static void LookTo(GameObject target, Vector3 looktarget, float time){
354  		LookTo(target,Hash(&quot;looktarget&quot;,looktarget,&quot;time&quot;,time));
355  	}
356  	public static void LookTo(GameObject target, Hashtable args){		
357  		args = iTween.CleanArgs(args);			
358  		if(args.Contains(&quot;looktarget&quot;)){
359  			if (args[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
360  				Transform transform = (Transform)args[&quot;looktarget&quot;];
361  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
362  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
363  			}
364  		}
365  		args[&quot;type&quot;]=&quot;look&quot;;
366  		args[&quot;method&quot;]=&quot;to&quot;;
367  		Launch(target,args);
368  	}		
369  	public static void MoveTo(GameObject target, Vector3 position, float time){
370  		MoveTo(target,Hash(&quot;position&quot;,position,&quot;time&quot;,time));
371  	}	
372  	public static void MoveTo(GameObject target, Hashtable args){
373  		args = iTween.CleanArgs(args);
374  		if(args.Contains(&quot;position&quot;)){
375  			if (args[&quot;position&quot;].GetType() == typeof(Transform)) {
376  				Transform transform = (Transform)args[&quot;position&quot;];
377  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
378  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
379  				args[&quot;scale&quot;]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);
380  			}
381  		}		
382  		args[&quot;type&quot;]=&quot;move&quot;;
383  		args[&quot;method&quot;]=&quot;to&quot;;
384  		Launch(target,args);
385  	}
386  	public static void MoveFrom(GameObject target, Vector3 position, float time){
387  		MoveFrom(target,Hash(&quot;position&quot;,position,&quot;time&quot;,time));
388  	}		
389  	public static void MoveFrom(GameObject target, Hashtable args){
390  			args = iTween.CleanArgs(args);
391  		bool tempIsLocal;
392  		if(args.Contains(&quot;islocal&quot;)){
393  			tempIsLocal = (bool)args[&quot;islocal&quot;];
394  		}else{
395  			tempIsLocal = Defaults.isLocal;	
396  		}
397  		if(args.Contains(&quot;path&quot;)){
398  			Vector3[] fromPath;
399  			Vector3[] suppliedPath;
400  			if(args[&quot;path&quot;].GetType() == typeof(Vector3[])){
401  				Vector3[] temp = (Vector3[])args[&quot;path&quot;];
402  				suppliedPath=new Vector3[temp.Length];
403  				Array.Copy(temp,suppliedPath, temp.Length);	
404  			}else{
405  				Transform[] temp = (Transform[])args[&quot;path&quot;];
406  				suppliedPath = new Vector3[temp.Length];
407  				for (int i = 0; i &lt; temp.Length; i++) {
408  					suppliedPath[i]=temp[i].position;
409  				}
410  			}
411  			if(suppliedPath[suppliedPath.Length-1] != target.transform.position){
412  				fromPath= new Vector3[suppliedPath.Length+1];
413  				Array.Copy(suppliedPath,fromPath,suppliedPath.Length);
414  				if(tempIsLocal){
415  					fromPath[fromPath.Length-1] = target.transform.localPosition;
416  					target.transform.localPosition=fromPath[0];
417  				}else{
418  					fromPath[fromPath.Length-1] = target.transform.position;
419  					target.transform.position=fromPath[0];
420  				}
421  				args[&quot;path&quot;]=fromPath;
422  			}else{
423  				if(tempIsLocal){
424  					target.transform.localPosition=suppliedPath[0];
425  				}else{
426  					target.transform.position=suppliedPath[0];
427  				}
428  				args[&quot;path&quot;]=suppliedPath;
429  			}
430  		}else{
431  			Vector3 tempPosition;
432  			Vector3 fromPosition;
433  			if(tempIsLocal){
434  				tempPosition=fromPosition=target.transform.localPosition;
435  			}else{
436  				tempPosition=fromPosition=target.transform.position;	
437  			}
438  			if(args.Contains(&quot;position&quot;)){
439  				if (args[&quot;position&quot;].GetType() == typeof(Transform)){
440  					Transform trans = (Transform)args[&quot;position&quot;];
441  					fromPosition=trans.position;
442  				}else if(args[&quot;position&quot;].GetType() == typeof(Vector3)){
443  					fromPosition=(Vector3)args[&quot;position&quot;];
444  				}			
445  			}else{
446  				if (args.Contains(&quot;x&quot;)) {
447  					fromPosition.x=(float)args[&quot;x&quot;];
448  				}
449  				if (args.Contains(&quot;y&quot;)) {
450  					fromPosition.y=(float)args[&quot;y&quot;];
451  				}
452  				if (args.Contains(&quot;z&quot;)) {
453  					fromPosition.z=(float)args[&quot;z&quot;];
454  				}
455  			}
456  			if(tempIsLocal){
457  				target.transform.localPosition = fromPosition;
458  			}else{
459  				target.transform.position = fromPosition;	
460  			}
461  			args[&quot;position&quot;]=tempPosition;
462  		}
463  		args[&quot;type&quot;]=&quot;move&quot;;
464  		args[&quot;method&quot;]=&quot;to&quot;;
465  		Launch(target,args);
466  	}
467  	public static void MoveAdd(GameObject target, Vector3 amount, float time){
468  		MoveAdd(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
469  	}
470  	public static void MoveAdd(GameObject target, Hashtable args){
471  		args = iTween.CleanArgs(args);
472  		args[&quot;type&quot;]=&quot;move&quot;;
473  		args[&quot;method&quot;]=&quot;add&quot;;
474  		Launch(target,args);
475  	}
476  	public static void MoveBy(GameObject target, Vector3 amount, float time){
477  		MoveBy(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
478  	}
479  	public static void MoveBy(GameObject target, Hashtable args){
480  		args = iTween.CleanArgs(args);
481  		args[&quot;type&quot;]=&quot;move&quot;;
482  		args[&quot;method&quot;]=&quot;by&quot;;
483  		Launch(target,args);
484  	}
485  	public static void ScaleTo(GameObject target, Vector3 scale, float time){
486  		ScaleTo(target,Hash(&quot;scale&quot;,scale,&quot;time&quot;,time));
487  	}
488  	public static void ScaleTo(GameObject target, Hashtable args){
489  		args = iTween.CleanArgs(args);
490  		if(args.Contains(&quot;scale&quot;)){
491  			if (args[&quot;scale&quot;].GetType() == typeof(Transform)) {
492  				Transform transform = (Transform)args[&quot;scale&quot;];
493  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
494  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
495  				args[&quot;scale&quot;]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);
496  			}
497  		}
498  		args[&quot;type&quot;]=&quot;scale&quot;;
499  		args[&quot;method&quot;]=&quot;to&quot;;
500  		Launch(target,args);
501  	}
502  	public static void ScaleFrom(GameObject target, Vector3 scale, float time){
503  		ScaleFrom(target,Hash(&quot;scale&quot;,scale,&quot;time&quot;,time));
504  	}
505  	public static void ScaleFrom(GameObject target, Hashtable args){
506  		Vector3 tempScale;
507  		Vector3 fromScale;
508  		args = iTween.CleanArgs(args);
509  		tempScale=fromScale=target.transform.localScale;
510  		if(args.Contains(&quot;scale&quot;)){
511  			if (args[&quot;scale&quot;].GetType() == typeof(Transform)){
512  				Transform trans = (Transform)args[&quot;scale&quot;];
513  				fromScale=trans.localScale;
514  			}else if(args[&quot;scale&quot;].GetType() == typeof(Vector3)){
515  				fromScale=(Vector3)args[&quot;scale&quot;];
516  			}	
517  		}else{
518  			if (args.Contains(&quot;x&quot;)) {
519  				fromScale.x=(float)args[&quot;x&quot;];
520  			}
521  			if (args.Contains(&quot;y&quot;)) {
522  				fromScale.y=(float)args[&quot;y&quot;];
523  			}
524  			if (args.Contains(&quot;z&quot;)) {
525  				fromScale.z=(float)args[&quot;z&quot;];
526  			}
527  		}
528  		target.transform.localScale = fromScale;	
529  		args[&quot;scale&quot;]=tempScale;
530  		args[&quot;type&quot;]=&quot;scale&quot;;
531  		args[&quot;method&quot;]=&quot;to&quot;;
532  		Launch(target,args);
533  	}
534  	public static void ScaleAdd(GameObject target, Vector3 amount, float time){
535  		ScaleAdd(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
536  	}
537  	public static void ScaleAdd(GameObject target, Hashtable args){
538  		args = iTween.CleanArgs(args);
539  		args[&quot;type&quot;]=&quot;scale&quot;;
540  		args[&quot;method&quot;]=&quot;add&quot;;
541  		Launch(target,args);
542  	}
543  	public static void ScaleBy(GameObject target, Vector3 amount, float time){
544  		ScaleBy(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
545  	}
546  	public static void ScaleBy(GameObject target, Hashtable args){
547  		args = iTween.CleanArgs(args);
548  		args[&quot;type&quot;]=&quot;scale&quot;;
549  		args[&quot;method&quot;]=&quot;by&quot;;
550  		Launch(target,args);
551  	}
552  	public static void RotateTo(GameObject target, Vector3 rotation, float time){
553  		RotateTo(target,Hash(&quot;rotation&quot;,rotation,&quot;time&quot;,time));
554  	}
555  	public static void RotateTo(GameObject target, Hashtable args){
556  		args = iTween.CleanArgs(args);
557  		if(args.Contains(&quot;rotation&quot;)){
558  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)) {
559  				Transform transform = (Transform)args[&quot;rotation&quot;];
560  				args[&quot;position&quot;]=new Vector3(transform.position.x,transform.position.y,transform.position.z);
561  				args[&quot;rotation&quot;]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);
562  				args[&quot;scale&quot;]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);
563  			}
564  		}		
565  		args[&quot;type&quot;]=&quot;rotate&quot;;
566  		args[&quot;method&quot;]=&quot;to&quot;;
567  		Launch(target,args);
568  	}	
569  	public static void RotateFrom(GameObject target, Vector3 rotation, float time){
570  		RotateFrom(target,Hash(&quot;rotation&quot;,rotation,&quot;time&quot;,time));
571  	}
572  	public static void RotateFrom(GameObject target, Hashtable args){
573  		Vector3 tempRotation;
574  		Vector3 fromRotation;
575  		bool tempIsLocal;
576  		args = iTween.CleanArgs(args);
577  		if(args.Contains(&quot;islocal&quot;)){
578  			tempIsLocal = (bool)args[&quot;islocal&quot;];
579  		}else{
580  			tempIsLocal = Defaults.isLocal;	
581  		}
582  		if(tempIsLocal){
583  			tempRotation=fromRotation=target.transform.localEulerAngles;
584  		}else{
585  			tempRotation=fromRotation=target.transform.eulerAngles;	
586  		}
587  		if(args.Contains(&quot;rotation&quot;)){
588  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)){
589  				Transform trans = (Transform)args[&quot;rotation&quot;];
590  				fromRotation=trans.eulerAngles;
591  			}else if(args[&quot;rotation&quot;].GetType() == typeof(Vector3)){
592  				fromRotation=(Vector3)args[&quot;rotation&quot;];
593  			}	
594  		}else{
595  			if (args.Contains(&quot;x&quot;)) {
596  				fromRotation.x=(float)args[&quot;x&quot;];
597  			}
598  			if (args.Contains(&quot;y&quot;)) {
599  				fromRotation.y=(float)args[&quot;y&quot;];
600  			}
601  			if (args.Contains(&quot;z&quot;)) {
602  				fromRotation.z=(float)args[&quot;z&quot;];
603  			}
604  		}
605  		if(tempIsLocal){
606  			target.transform.localEulerAngles = fromRotation;
607  		}else{
608  			target.transform.eulerAngles = fromRotation;	
609  		}
610  		args[&quot;rotation&quot;]=tempRotation;
611  		args[&quot;type&quot;]=&quot;rotate&quot;;
612  		args[&quot;method&quot;]=&quot;to&quot;;
613  		Launch(target,args);
614  	}	
615  	public static void RotateAdd(GameObject target, Vector3 amount, float time){
616  		RotateAdd(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
617  	}
618  	public static void RotateAdd(GameObject target, Hashtable args){
619  		args = iTween.CleanArgs(args);
620  		args[&quot;type&quot;]=&quot;rotate&quot;;
621  		args[&quot;method&quot;]=&quot;add&quot;;
622  		Launch(target,args);
623  	}
624  	public static void RotateBy(GameObject target, Vector3 amount, float time){
625  		RotateBy(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
626  	}
627  	public static void RotateBy(GameObject target, Hashtable args){
628  		args = iTween.CleanArgs(args);
629  		args[&quot;type&quot;]=&quot;rotate&quot;;
630  		args[&quot;method&quot;]=&quot;by&quot;;
631  		Launch(target,args);
632  	}		
633  	public static void ShakePosition(GameObject target, Vector3 amount, float time){
634  		ShakePosition(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
635  	}
636  	public static void ShakePosition(GameObject target, Hashtable args){
637  		args = iTween.CleanArgs(args);
638  		args[&quot;type&quot;]=&quot;shake&quot;;
639  		args[&quot;method&quot;]=&quot;position&quot;;
640  		Launch(target,args);
641  	}		
642  	public static void ShakeScale(GameObject target, Vector3 amount, float time){
643  		ShakeScale(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
644  	}
645  	public static void ShakeScale(GameObject target, Hashtable args){
646  		args = iTween.CleanArgs(args);
647  		args[&quot;type&quot;]=&quot;shake&quot;;
648  		args[&quot;method&quot;]=&quot;scale&quot;;
649  		Launch(target,args);
650  	}		
651  	public static void ShakeRotation(GameObject target, Vector3 amount, float time){
652  		ShakeRotation(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
653  	}
654  	public static void ShakeRotation(GameObject target, Hashtable args){
655  		args = iTween.CleanArgs(args);
656  		args[&quot;type&quot;]=&quot;shake&quot;;
657  		args[&quot;method&quot;]=&quot;rotation&quot;;
658  		Launch(target,args);
659  	}			
660  	public static void PunchPosition(GameObject target, Vector3 amount, float time){
661  		PunchPosition(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
662  	}
663  	public static void PunchPosition(GameObject target, Hashtable args){
664  		args = iTween.CleanArgs(args);
665  		args[&quot;type&quot;]=&quot;punch&quot;;
666  		args[&quot;method&quot;]=&quot;position&quot;;
667  		args[&quot;easetype&quot;]=EaseType.punch;
668  		Launch(target,args);
669  	}		
670  	public static void PunchRotation(GameObject target, Vector3 amount, float time){
671  		PunchRotation(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
672  	}
673  	public static void PunchRotation(GameObject target, Hashtable args){
674  		args = iTween.CleanArgs(args);
675  		args[&quot;type&quot;]=&quot;punch&quot;;
676  		args[&quot;method&quot;]=&quot;rotation&quot;;
677  		args[&quot;easetype&quot;]=EaseType.punch;
678  		Launch(target,args);
679  	}	
680  	public static void PunchScale(GameObject target, Vector3 amount, float time){
681  		PunchScale(target,Hash(&quot;amount&quot;,amount,&quot;time&quot;,time));
682  	}
683  	public static void PunchScale(GameObject target, Hashtable args){
684  		args = iTween.CleanArgs(args);
685  		args[&quot;type&quot;]=&quot;punch&quot;;
686  		args[&quot;method&quot;]=&quot;scale&quot;;
687  		args[&quot;easetype&quot;]=EaseType.punch;
688  		Launch(target,args);
689  	}	
690  	#endregion
691  	#region #2 Generate Method Targets
692  	void GenerateTargets(){
693  		switch (type) {
694  			case &quot;value&quot;:
695  				switch (method) {
696  					case &quot;float&quot;:
697  						GenerateFloatTargets();
698  						apply = new ApplyTween(ApplyFloatTargets);
699  					break;
700  				case &quot;vector2&quot;:
701  						GenerateVector2Targets();
702  						apply = new ApplyTween(ApplyVector2Targets);
703  					break;
704  				case &quot;vector3&quot;:
705  						GenerateVector3Targets();
706  						apply = new ApplyTween(ApplyVector3Targets);
707  					break;
708  				case &quot;color&quot;:
709  						GenerateColorTargets();
710  						apply = new ApplyTween(ApplyColorTargets);
711  					break;
712  				case &quot;rect&quot;:
713  						GenerateRectTargets();
714  						apply = new ApplyTween(ApplyRectTargets);
715  					break;
716  				}
717  			break;
718  			case &quot;color&quot;:
719  				switch (method) {
720  					case &quot;to&quot;:
721  						GenerateColorToTargets();
722  						apply = new ApplyTween(ApplyColorToTargets);
723  					break;
724  				}
725  			break;
726  			case &quot;audio&quot;:
727  				switch (method) {
728  					case &quot;to&quot;:
729  						GenerateAudioToTargets();
730  						apply = new ApplyTween(ApplyAudioToTargets);
731  					break;
732  				}
733  			break;
734  			case &quot;move&quot;:
735  				switch (method) {
736  					case &quot;to&quot;:
737  						if(tweenArguments.Contains(&quot;path&quot;)){
738  							GenerateMoveToPathTargets();
739  							apply = new ApplyTween(ApplyMoveToPathTargets);
740  						}else{ 
741  							GenerateMoveToTargets();
742  							apply = new ApplyTween(ApplyMoveToTargets);
743  						}
744  					break;
745  					case &quot;by&quot;:
746  					case &quot;add&quot;:
747  						GenerateMoveByTargets();
748  						apply = new ApplyTween(ApplyMoveByTargets);
749  					break;
750  				}
751  			break;
752  			case &quot;scale&quot;:
753  				switch (method){
754  					case &quot;to&quot;:
755  						GenerateScaleToTargets();
756  						apply = new ApplyTween(ApplyScaleToTargets);
757  					break;
758  					case &quot;by&quot;:
759  						GenerateScaleByTargets();
760  						apply = new ApplyTween(ApplyScaleToTargets);
761  					break;
762  					case &quot;add&quot;:
763  						GenerateScaleAddTargets();
764  						apply = new ApplyTween(ApplyScaleToTargets);
765  					break;
766  				}
767  			break;
768  			case &quot;rotate&quot;:
769  				switch (method) {
770  					case &quot;to&quot;:
771  						GenerateRotateToTargets();
772  						apply = new ApplyTween(ApplyRotateToTargets);
773  					break;
774  					case &quot;add&quot;:
775  						GenerateRotateAddTargets();
776  						apply = new ApplyTween(ApplyRotateAddTargets);
777  					break;
778  					case &quot;by&quot;:
779  						GenerateRotateByTargets();
780  						apply = new ApplyTween(ApplyRotateAddTargets);
781  					break;				
782  				}
783  			break;
784  			case &quot;shake&quot;:
785  				switch (method) {
786  					case &quot;position&quot;:
787  						GenerateShakePositionTargets();
788  						apply = new ApplyTween(ApplyShakePositionTargets);
789  					break;		
790  					case &quot;scale&quot;:
791  						GenerateShakeScaleTargets();
792  						apply = new ApplyTween(ApplyShakeScaleTargets);
793  					break;
794  					case &quot;rotation&quot;:
795  						GenerateShakeRotationTargets();
796  						apply = new ApplyTween(ApplyShakeRotationTargets);
797  					break;
798  				}
799  			break;			
800  			case &quot;punch&quot;:
801  				switch (method) {
802  					case &quot;position&quot;:
803  						GeneratePunchPositionTargets();
804  						apply = new ApplyTween(ApplyPunchPositionTargets);
805  					break;	
806  					case &quot;rotation&quot;:
807  						GeneratePunchRotationTargets();
808  						apply = new ApplyTween(ApplyPunchRotationTargets);
809  					break;	
810  					case &quot;scale&quot;:
811  						GeneratePunchScaleTargets();
812  						apply = new ApplyTween(ApplyPunchScaleTargets);
813  					break;
814  				}
815  			break;
816  			case &quot;look&quot;:
817  				switch (method) {
818  					case &quot;to&quot;:
819  						GenerateLookToTargets();
820  						apply = new ApplyTween(ApplyLookToTargets);
821  					break;	
822  				}
823  			break;	
824  			case &quot;stab&quot;:
825  				GenerateStabTargets();
826  				apply = new ApplyTween(ApplyStabTargets);
827  			break;	
828  		}
829  	}
830  	#endregion
831  	#region #3 Generate Specific Targets
832  	void GenerateRectTargets(){
833  		rects=new Rect[3];
834  		rects[0]=(Rect)tweenArguments[&quot;from&quot;];
835  		rects[1]=(Rect)tweenArguments[&quot;to&quot;];
836  	}		
837  	void GenerateColorTargets(){
838  		colors=new Color[1,3];
839  		colors[0,0]=(Color)tweenArguments[&quot;from&quot;];
840  		colors[0,1]=(Color)tweenArguments[&quot;to&quot;];
841  	}	
842  	void GenerateVector3Targets(){
843  		vector3s=new Vector3[3];
844  		vector3s[0]=(Vector3)tweenArguments[&quot;from&quot;];
845  		vector3s[1]=(Vector3)tweenArguments[&quot;to&quot;];
846  		if(tweenArguments.Contains(&quot;speed&quot;)){
847  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
848  			time = distance/(float)tweenArguments[&quot;speed&quot;];
849  		}
850  	}
851  	void GenerateVector2Targets(){
852  		vector2s=new Vector2[3];
853  		vector2s[0]=(Vector2)tweenArguments[&quot;from&quot;];
854  		vector2s[1]=(Vector2)tweenArguments[&quot;to&quot;];
855  		if(tweenArguments.Contains(&quot;speed&quot;)){
856  			Vector3 fromV3 = new Vector3(vector2s[0].x,vector2s[0].y,0);
857  			Vector3 toV3 = new Vector3(vector2s[1].x,vector2s[1].y,0);
858  			float distance = Math.Abs(Vector3.Distance(fromV3,toV3));
859  			time = distance/(float)tweenArguments[&quot;speed&quot;];
860  		}
861  	}
862  	void GenerateFloatTargets(){
863  		floats=new float[3];
864  		floats[0]=(float)tweenArguments[&quot;from&quot;];
865  		floats[1]=(float)tweenArguments[&quot;to&quot;];
866  		if(tweenArguments.Contains(&quot;speed&quot;)){
867  			float distance = Math.Abs(floats[0] - floats[1]);
868  			time = distance/(float)tweenArguments[&quot;speed&quot;];
869  		}
870  	}
871  	void GenerateColorToTargets(){
872  		if(GetComponent&lt;GUITexture&gt;()){
873  			colors = new Color[1,3];
874  			colors[0,0] = colors[0,1] = GetComponent&lt;GUITexture&gt;().color;
875  		}else if(GetComponent&lt;GUIText&gt;()){
876  			colors = new Color[1,3];
877  			colors[0,0] = colors[0,1] = GetComponent&lt;GUIText&gt;().material.color;
878  		}else if(GetComponent&lt;Renderer&gt;()){
879  			colors = new Color[GetComponent&lt;Renderer&gt;().materials.Length,3];
880  			for (int i = 0; i &lt; GetComponent&lt;Renderer&gt;().materials.Length; i++) {
881  				colors[i,0]=GetComponent&lt;Renderer&gt;().materials[i].GetColor(namedcolorvalue.ToString());
882  				colors[i,1]=GetComponent&lt;Renderer&gt;().materials[i].GetColor(namedcolorvalue.ToString());
883  			}
884  		}else if(GetComponent&lt;Light&gt;()){
885  			colors = new Color[1,3];
886  			colors[0,0] = colors[0,1] = GetComponent&lt;Light&gt;().color;	
887  		}else{
888  			colors = new Color[1,3]; 
889  		}
890  		if (tweenArguments.Contains(&quot;color&quot;)) {
891  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
892  				colors[i,1]=(Color)tweenArguments[&quot;color&quot;];
893  			}
894  		}else{
895  			if (tweenArguments.Contains(&quot;r&quot;)) {
896  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
897  					colors[i,1].r=(float)tweenArguments[&quot;r&quot;];
898  				}
899  			}
900  			if (tweenArguments.Contains(&quot;g&quot;)) {
901  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
902  					colors[i,1].g=(float)tweenArguments[&quot;g&quot;];
903  				}
904  			}
905  			if (tweenArguments.Contains(&quot;b&quot;)) {
906  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
907  					colors[i,1].b=(float)tweenArguments[&quot;b&quot;];
908  				}
909  			}
910  			if (tweenArguments.Contains(&quot;a&quot;)) {
911  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
912  					colors[i,1].a=(float)tweenArguments[&quot;a&quot;];
913  				}
914  			}
915  		}
916  		if(tweenArguments.Contains(&quot;amount&quot;)){
917  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
918  				colors[i,1].a=(float)tweenArguments[&quot;amount&quot;];
919  			}
920  		}else if(tweenArguments.Contains(&quot;alpha&quot;)){
921  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
922  				colors[i,1].a=(float)tweenArguments[&quot;alpha&quot;];
923  			}
924  		}
925  	}
926  	void GenerateAudioToTargets(){
927  		vector2s=new Vector2[3];
928  		if(tweenArguments.Contains(&quot;audiosource&quot;)){
929  			audioSource=(AudioSource)tweenArguments[&quot;audiosource&quot;];
930  		}else{
931  			if(GetComponent&lt;AudioSource&gt;()){
932  				audioSource=GetComponent&lt;AudioSource&gt;();
933  			}else{
934  				Debug.LogError(&quot;iTween Error: AudioTo requires an AudioSource.&quot;);
935  				Dispose();
936  			}
937  		}		
938  		vector2s[0]=vector2s[1]=new Vector2(audioSource.volume,audioSource.pitch);
939  		if (tweenArguments.Contains(&quot;volume&quot;)) {
940  			vector2s[1].x=(float)tweenArguments[&quot;volume&quot;];	
941  		}
942  		if (tweenArguments.Contains(&quot;pitch&quot;)) {
943  			vector2s[1].y=(float)tweenArguments[&quot;pitch&quot;];	
944  		}
945  	}
946  	void GenerateStabTargets(){
947  		if(tweenArguments.Contains(&quot;audiosource&quot;)){
948  			audioSource=(AudioSource)tweenArguments[&quot;audiosource&quot;];
949  		}else{
950  			if(GetComponent&lt;AudioSource&gt;()){
951  				audioSource=GetComponent&lt;AudioSource&gt;();
952  			}else{
953  				gameObject.AddComponent&lt;AudioSource&gt;();
954  				audioSource=GetComponent&lt;AudioSource&gt;();
955  				audioSource.playOnAwake=false;
956  			}
957  		}
958  		audioSource.clip=(AudioClip)tweenArguments[&quot;audioclip&quot;];
959  		if(tweenArguments.Contains(&quot;pitch&quot;)){
960  			audioSource.pitch=(float)tweenArguments[&quot;pitch&quot;];
961  		}
962  		if(tweenArguments.Contains(&quot;volume&quot;)){
963  			audioSource.volume=(float)tweenArguments[&quot;volume&quot;];
964  		}
965  		time=audioSource.clip.length/audioSource.pitch;
966  	}
967  	void GenerateLookToTargets(){
968  		vector3s=new Vector3[3];
969  		vector3s[0]=thisTransform.eulerAngles;
970  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
971  			if (tweenArguments[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
972  				thisTransform.LookAt((Transform)tweenArguments[&quot;looktarget&quot;], (Vector3?)tweenArguments[&quot;up&quot;] ?? Defaults.up);
973  			}else if(tweenArguments[&quot;looktarget&quot;].GetType() == typeof(Vector3)){
974  				thisTransform.LookAt((Vector3)tweenArguments[&quot;looktarget&quot;], (Vector3?)tweenArguments[&quot;up&quot;] ?? Defaults.up);
975  			}
976  		}else{
977  			Debug.LogError(&quot;iTween Error: LookTo needs a &#x27;looktarget&#x27; property!&quot;);
978  			Dispose();
979  		}
980  		vector3s[1]=thisTransform.eulerAngles;
981  		thisTransform.eulerAngles=vector3s[0];
982  		if(tweenArguments.Contains(&quot;axis&quot;)){
983  			switch((string)tweenArguments[&quot;axis&quot;]){
984  				case &quot;x&quot;:
985  					vector3s[1].y=vector3s[0].y;
986  					vector3s[1].z=vector3s[0].z;
987  				break;
988  				case &quot;y&quot;:
989  					vector3s[1].x=vector3s[0].x;
990  					vector3s[1].z=vector3s[0].z;
991  				break;
992  				case &quot;z&quot;:
993  					vector3s[1].x=vector3s[0].x;
994  					vector3s[1].y=vector3s[0].y;
995  				break;
996  			}
997  		}
998  		vector3s[1]=new Vector3(clerp(vector3s[0].x,vector3s[1].x,1),clerp(vector3s[0].y,vector3s[1].y,1),clerp(vector3s[0].z,vector3s[1].z,1));
999  		if(tweenArguments.Contains(&quot;speed&quot;)){
1000  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1001  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1002  		}
1003  	}	
1004  	void GenerateMoveToPathTargets(){
1005  		 Vector3[] suppliedPath;
1006  		if(tweenArguments[&quot;path&quot;].GetType() == typeof(Vector3[])){
1007  			Vector3[] temp = (Vector3[])tweenArguments[&quot;path&quot;];
1008  			if(temp.Length==1){
1009  				Debug.LogError(&quot;iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!&quot;);
1010  				Dispose();
1011  			}
1012  			suppliedPath=new Vector3[temp.Length];
1013  			Array.Copy(temp,suppliedPath, temp.Length);
1014  		}else{
1015  			Transform[] temp = (Transform[])tweenArguments[&quot;path&quot;];
1016  			if(temp.Length==1){
1017  				Debug.LogError(&quot;iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!&quot;);
1018  				Dispose();
1019  			}
1020  			suppliedPath = new Vector3[temp.Length];
1021  			for (int i = 0; i &lt; temp.Length; i++) {
1022  				suppliedPath[i]=temp[i].position;
1023  			}
1024  		}
1025  		bool plotStart;
1026  		int offset;
1027  		if(thisTransform.position != suppliedPath[0]){
1028  			if(!tweenArguments.Contains(&quot;movetopath&quot;) || (bool)tweenArguments[&quot;movetopath&quot;]==true){
1029  				plotStart=true;
1030  				offset=3;	
1031  			}else{
1032  				plotStart=false;
1033  				offset=2;
1034  			}
1035  		}else{
1036  			plotStart=false;
1037  			offset=2;
1038  		}				
1039  		vector3s = new Vector3[suppliedPath.Length+offset];
1040  		if(plotStart){
1041  			vector3s[1]=thisTransform.position;
1042  			offset=2;
1043  		}else{
1044  			offset=1;
1045  		}		
1046  		Array.Copy(suppliedPath,0,vector3s,offset,suppliedPath.Length);
1047  		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
1048  		vector3s[vector3s.Length-1] = vector3s[vector3s.Length-2] + (vector3s[vector3s.Length-2] - vector3s[vector3s.Length-3]);
1049  		if(vector3s[1] == vector3s[vector3s.Length-2]){
1050  			Vector3[] tmpLoopSpline = new Vector3[vector3s.Length];
1051  			Array.Copy(vector3s,tmpLoopSpline,vector3s.Length);
1052  			tmpLoopSpline[0]=tmpLoopSpline[tmpLoopSpline.Length-3];
1053  			tmpLoopSpline[tmpLoopSpline.Length-1]=tmpLoopSpline[2];
1054  			vector3s=new Vector3[tmpLoopSpline.Length];
1055  			Array.Copy(tmpLoopSpline,vector3s,tmpLoopSpline.Length);
1056  		}
1057  		path = new CRSpline(vector3s);
1058  		if(tweenArguments.Contains(&quot;speed&quot;)){
1059  			float distance = PathLength(vector3s);
1060  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1061  		}
1062  	}
1063  	void GenerateMoveToTargets(){
1064  		vector3s=new Vector3[3];
1065  		if (isLocal) {
1066  			vector3s[0]=vector3s[1]=thisTransform.localPosition;				
1067  		}else{
1068  			vector3s[0]=vector3s[1]=thisTransform.position;
1069  		}
1070  		if (tweenArguments.Contains(&quot;position&quot;)) {
1071  			if (tweenArguments[&quot;position&quot;].GetType() == typeof(Transform)){
1072  				Transform trans = (Transform)tweenArguments[&quot;position&quot;];
1073  				vector3s[1]=trans.position;
1074  			}else if(tweenArguments[&quot;position&quot;].GetType() == typeof(Vector3)){
1075  				vector3s[1]=(Vector3)tweenArguments[&quot;position&quot;];
1076  			}
1077  		}else{
1078  			if (tweenArguments.Contains(&quot;x&quot;)) {
1079  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1080  			}
1081  			if (tweenArguments.Contains(&quot;y&quot;)) {
1082  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1083  			}
1084  			if (tweenArguments.Contains(&quot;z&quot;)) {
1085  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1086  			}
1087  		}
1088  		if(tweenArguments.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)tweenArguments[&quot;orienttopath&quot;]){
1089  			tweenArguments[&quot;looktarget&quot;] = vector3s[1];
1090  		}
1091  		if(tweenArguments.Contains(&quot;speed&quot;)){
1092  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1093  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1094  		}
1095  	}
1096  	void GenerateMoveByTargets(){
1097  		vector3s=new Vector3[6];
1098  		vector3s[4] = thisTransform.eulerAngles;
1099  		vector3s[0]=vector3s[1]=vector3s[3]=thisTransform.position;
1100  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1101  			vector3s[1]=vector3s[0] + (Vector3)tweenArguments[&quot;amount&quot;];
1102  		}else{
1103  			if (tweenArguments.Contains(&quot;x&quot;)) {
1104  				vector3s[1].x=vector3s[0].x + (float)tweenArguments[&quot;x&quot;];
1105  			}
1106  			if (tweenArguments.Contains(&quot;y&quot;)) {
1107  				vector3s[1].y=vector3s[0].y +(float)tweenArguments[&quot;y&quot;];
1108  			}
1109  			if (tweenArguments.Contains(&quot;z&quot;)) {
1110  				vector3s[1].z=vector3s[0].z + (float)tweenArguments[&quot;z&quot;];
1111  			}
1112  		}	
1113  		thisTransform.Translate(vector3s[1],space);
1114  		vector3s[5] = thisTransform.position;
1115  		thisTransform.position=vector3s[0];
1116  		if(tweenArguments.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)tweenArguments[&quot;orienttopath&quot;]){
1117  			tweenArguments[&quot;looktarget&quot;] = vector3s[1];
1118  		}
1119  		if(tweenArguments.Contains(&quot;speed&quot;)){
1120  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1121  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1122  		}
1123  	}
1124  	void GenerateScaleToTargets(){
1125  		vector3s=new Vector3[3];
1126  		vector3s[0]=vector3s[1]=thisTransform.localScale;				
1127  		if (tweenArguments.Contains(&quot;scale&quot;)) {
1128  			if (tweenArguments[&quot;scale&quot;].GetType() == typeof(Transform)){
1129  				Transform trans = (Transform)tweenArguments[&quot;scale&quot;];
1130  				vector3s[1]=trans.localScale;					
1131  			}else if(tweenArguments[&quot;scale&quot;].GetType() == typeof(Vector3)){
1132  				vector3s[1]=(Vector3)tweenArguments[&quot;scale&quot;];
1133  			}
1134  		}else{
1135  			if (tweenArguments.Contains(&quot;x&quot;)) {
1136  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1137  			}
1138  			if (tweenArguments.Contains(&quot;y&quot;)) {
1139  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1140  			}
1141  			if (tweenArguments.Contains(&quot;z&quot;)) {
1142  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1143  			}
1144  		} 
1145  		if(tweenArguments.Contains(&quot;speed&quot;)){
1146  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1147  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1148  		}
1149  	}
1150  	void GenerateScaleByTargets(){
1151  		vector3s=new Vector3[3];
1152  		vector3s[0]=vector3s[1]=thisTransform.localScale;				
1153  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1154  			vector3s[1]=Vector3.Scale(vector3s[1],(Vector3)tweenArguments[&quot;amount&quot;]);
1155  		}else{
1156  			if (tweenArguments.Contains(&quot;x&quot;)) {
1157  				vector3s[1].x*=(float)tweenArguments[&quot;x&quot;];
1158  			}
1159  			if (tweenArguments.Contains(&quot;y&quot;)) {
1160  				vector3s[1].y*=(float)tweenArguments[&quot;y&quot;];
1161  			}
1162  			if (tweenArguments.Contains(&quot;z&quot;)) {
1163  				vector3s[1].z*=(float)tweenArguments[&quot;z&quot;];
1164  			}
1165  		} 
1166  		if(tweenArguments.Contains(&quot;speed&quot;)){
1167  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1168  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1169  		}
1170  	}
1171  	void GenerateScaleAddTargets(){
1172  		vector3s=new Vector3[3];
1173  		vector3s[0]=vector3s[1]=thisTransform.localScale;				
1174  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1175  			vector3s[1]+=(Vector3)tweenArguments[&quot;amount&quot;];
1176  		}else{
1177  			if (tweenArguments.Contains(&quot;x&quot;)) {
1178  				vector3s[1].x+=(float)tweenArguments[&quot;x&quot;];
1179  			}
1180  			if (tweenArguments.Contains(&quot;y&quot;)) {
1181  				vector3s[1].y+=(float)tweenArguments[&quot;y&quot;];
1182  			}
1183  			if (tweenArguments.Contains(&quot;z&quot;)) {
1184  				vector3s[1].z+=(float)tweenArguments[&quot;z&quot;];
1185  			}
1186  		}
1187  		if(tweenArguments.Contains(&quot;speed&quot;)){
1188  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1189  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1190  		}
1191  	}
1192  	void GenerateRotateToTargets(){
1193  		vector3s=new Vector3[3];
1194  		if (isLocal) {
1195  			vector3s[0]=vector3s[1]=thisTransform.localEulerAngles;				
1196  		}else{
1197  			vector3s[0]=vector3s[1]=thisTransform.eulerAngles;
1198  		}
1199  		if (tweenArguments.Contains(&quot;rotation&quot;)) {
1200  			if (tweenArguments[&quot;rotation&quot;].GetType() == typeof(Transform)){
1201  				Transform trans = (Transform)tweenArguments[&quot;rotation&quot;];
1202  				vector3s[1]=trans.eulerAngles;			
1203  			}else if(tweenArguments[&quot;rotation&quot;].GetType() == typeof(Vector3)){
1204  				vector3s[1]=(Vector3)tweenArguments[&quot;rotation&quot;];
1205  			}
1206  		}else{
1207  			if (tweenArguments.Contains(&quot;x&quot;)) {
1208  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1209  			}
1210  			if (tweenArguments.Contains(&quot;y&quot;)) {
1211  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1212  			}
1213  			if (tweenArguments.Contains(&quot;z&quot;)) {
1214  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1215  			}
1216  		}
1217  		vector3s[1]=new Vector3(clerp(vector3s[0].x,vector3s[1].x,1),clerp(vector3s[0].y,vector3s[1].y,1),clerp(vector3s[0].z,vector3s[1].z,1));
1218  		if(tweenArguments.Contains(&quot;speed&quot;)){
1219  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1220  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1221  		}
1222  	}
1223  	void GenerateRotateAddTargets(){
1224  		vector3s=new Vector3[5];
1225  		vector3s[0]=vector3s[1]=vector3s[3]=thisTransform.eulerAngles;
1226  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1227  			vector3s[1]+=(Vector3)tweenArguments[&quot;amount&quot;];
1228  		}else{
1229  			if (tweenArguments.Contains(&quot;x&quot;)) {
1230  				vector3s[1].x+=(float)tweenArguments[&quot;x&quot;];
1231  			}
1232  			if (tweenArguments.Contains(&quot;y&quot;)) {
1233  				vector3s[1].y+=(float)tweenArguments[&quot;y&quot;];
1234  			}
1235  			if (tweenArguments.Contains(&quot;z&quot;)) {
1236  				vector3s[1].z+=(float)tweenArguments[&quot;z&quot;];
1237  			}
1238  		}
1239  		if(tweenArguments.Contains(&quot;speed&quot;)){
1240  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1241  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1242  		}
1243  	}		
1244  	void GenerateRotateByTargets(){
1245  		vector3s=new Vector3[4];
1246  		vector3s[0]=vector3s[1]=vector3s[3]=thisTransform.eulerAngles;
1247  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1248  			vector3s[1]+=Vector3.Scale((Vector3)tweenArguments[&quot;amount&quot;],new Vector3(360,360,360));
1249  		}else{
1250  			if (tweenArguments.Contains(&quot;x&quot;)) {
1251  				vector3s[1].x+=360 * (float)tweenArguments[&quot;x&quot;];
1252  			}
1253  			if (tweenArguments.Contains(&quot;y&quot;)) {
1254  				vector3s[1].y+=360 * (float)tweenArguments[&quot;y&quot;];
1255  			}
1256  			if (tweenArguments.Contains(&quot;z&quot;)) {
1257  				vector3s[1].z+=360 * (float)tweenArguments[&quot;z&quot;];
1258  			}
1259  		}
1260  		if(tweenArguments.Contains(&quot;speed&quot;)){
1261  			float distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));
1262  			time = distance/(float)tweenArguments[&quot;speed&quot;];
1263  		}
1264  	}		
1265  	void GenerateShakePositionTargets(){
1266  		vector3s=new Vector3[4];
1267  		vector3s[3] = thisTransform.eulerAngles;		
1268  		vector3s[0]=thisTransform.position;
1269  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1270  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1271  		}else{
1272  			if (tweenArguments.Contains(&quot;x&quot;)) {
1273  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1274  			}
1275  			if (tweenArguments.Contains(&quot;y&quot;)) {
1276  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1277  			}
1278  			if (tweenArguments.Contains(&quot;z&quot;)) {
1279  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1280  			}
1281  		}
1282  	}		
1283  	void GenerateShakeScaleTargets(){
1284  		vector3s=new Vector3[3];
1285  		vector3s[0]=thisTransform.localScale;
1286  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1287  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1288  		}else{
1289  			if (tweenArguments.Contains(&quot;x&quot;)) {
1290  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1291  			}
1292  			if (tweenArguments.Contains(&quot;y&quot;)) {
1293  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1294  			}
1295  			if (tweenArguments.Contains(&quot;z&quot;)) {
1296  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1297  			}
1298  		}
1299  	}		
1300  	void GenerateShakeRotationTargets(){
1301  		vector3s=new Vector3[3];
1302  		vector3s[0]=thisTransform.eulerAngles;
1303  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1304  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1305  		}else{
1306  			if (tweenArguments.Contains(&quot;x&quot;)) {
1307  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1308  			}
1309  			if (tweenArguments.Contains(&quot;y&quot;)) {
1310  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1311  			}
1312  			if (tweenArguments.Contains(&quot;z&quot;)) {
1313  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1314  			}
1315  		}
1316  	}	
1317  	void GeneratePunchPositionTargets(){
1318  		vector3s=new Vector3[5];
1319  		vector3s[4] = thisTransform.eulerAngles;
1320  		vector3s[0]=thisTransform.position;
1321  		vector3s[1]=vector3s[3]=Vector3.zero;
1322  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1323  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1324  		}else{
1325  			if (tweenArguments.Contains(&quot;x&quot;)) {
1326  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1327  			}
1328  			if (tweenArguments.Contains(&quot;y&quot;)) {
1329  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1330  			}
1331  			if (tweenArguments.Contains(&quot;z&quot;)) {
1332  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1333  			}
1334  		}
1335  	}	
1336  	void GeneratePunchRotationTargets(){
1337  		vector3s=new Vector3[4];
1338  		vector3s[0]=thisTransform.eulerAngles;
1339  		vector3s[1]=vector3s[3]=Vector3.zero;
1340  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1341  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1342  		}else{
1343  			if (tweenArguments.Contains(&quot;x&quot;)) {
1344  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1345  			}
1346  			if (tweenArguments.Contains(&quot;y&quot;)) {
1347  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1348  			}
1349  			if (tweenArguments.Contains(&quot;z&quot;)) {
1350  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1351  			}
1352  		}
1353  	}		
1354  	void GeneratePunchScaleTargets(){
1355  		vector3s=new Vector3[3];
1356  		vector3s[0]=thisTransform.localScale;
1357  		vector3s[1]=Vector3.zero;
1358  		if (tweenArguments.Contains(&quot;amount&quot;)) {
1359  			vector3s[1]=(Vector3)tweenArguments[&quot;amount&quot;];
1360  		}else{
1361  			if (tweenArguments.Contains(&quot;x&quot;)) {
1362  				vector3s[1].x=(float)tweenArguments[&quot;x&quot;];
1363  			}
1364  			if (tweenArguments.Contains(&quot;y&quot;)) {
1365  				vector3s[1].y=(float)tweenArguments[&quot;y&quot;];
1366  			}
1367  			if (tweenArguments.Contains(&quot;z&quot;)) {
1368  				vector3s[1].z=(float)tweenArguments[&quot;z&quot;];
1369  			}
1370  		}
1371  	}
1372  	#endregion
1373  	#region #4 Apply Targets
1374  	void ApplyRectTargets(){
1375  		rects[2].x = ease(rects[0].x,rects[1].x,percentage);
1376  		rects[2].y = ease(rects[0].y,rects[1].y,percentage);
1377  		rects[2].width = ease(rects[0].width,rects[1].width,percentage);
1378  		rects[2].height = ease(rects[0].height,rects[1].height,percentage);
1379  		tweenArguments[&quot;onupdateparams&quot;]=rects[2];
1380  		if(percentage==1){
1381  			tweenArguments[&quot;onupdateparams&quot;]=rects[1];
1382  		}
1383  	}		
1384  	void ApplyColorTargets(){
1385  		colors[0,2].r = ease(colors[0,0].r,colors[0,1].r,percentage);
1386  		colors[0,2].g = ease(colors[0,0].g,colors[0,1].g,percentage);
1387  		colors[0,2].b = ease(colors[0,0].b,colors[0,1].b,percentage);
1388  		colors[0,2].a = ease(colors[0,0].a,colors[0,1].a,percentage);
1389  		tweenArguments[&quot;onupdateparams&quot;]=colors[0,2];
1390  		if(percentage==1){
1391  			tweenArguments[&quot;onupdateparams&quot;]=colors[0,1];
1392  		}
1393  	}	
1394  	void ApplyVector3Targets(){
1395  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1396  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1397  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1398  		tweenArguments[&quot;onupdateparams&quot;]=vector3s[2];
1399  		if(percentage==1){
1400  			tweenArguments[&quot;onupdateparams&quot;]=vector3s[1];
1401  		}
1402  	}		
1403  	void ApplyVector2Targets(){
1404  		vector2s[2].x = ease(vector2s[0].x,vector2s[1].x,percentage);
1405  		vector2s[2].y = ease(vector2s[0].y,vector2s[1].y,percentage);
1406  		tweenArguments[&quot;onupdateparams&quot;]=vector2s[2];
1407  		if(percentage==1){
1408  			tweenArguments[&quot;onupdateparams&quot;]=vector2s[1];
1409  		}
1410  	}	
1411  	void ApplyFloatTargets(){
1412  		floats[2] = ease(floats[0],floats[1],percentage);
1413  		tweenArguments[&quot;onupdateparams&quot;]=floats[2];
1414  		if(percentage==1){
1415  			tweenArguments[&quot;onupdateparams&quot;]=floats[1];
1416  		}
1417  	}	
1418  	void ApplyColorToTargets(){
1419  		for (int i = 0; i &lt; colors.GetLength(0); i++) {
1420  			colors[i,2].r = ease(colors[i,0].r,colors[i,1].r,percentage);
1421  			colors[i,2].g = ease(colors[i,0].g,colors[i,1].g,percentage);
1422  			colors[i,2].b = ease(colors[i,0].b,colors[i,1].b,percentage);
1423  			colors[i,2].a = ease(colors[i,0].a,colors[i,1].a,percentage);
1424  		}
1425  		if(GetComponent&lt;GUITexture&gt;()){
1426  			GetComponent&lt;GUITexture&gt;().color=colors[0,2];
1427  		}else if(GetComponent&lt;GUIText&gt;()){
1428  			GetComponent&lt;GUIText&gt;().material.color=colors[0,2];
1429  		}else if(GetComponent&lt;Renderer&gt;()){
1430  			for (int i = 0; i &lt; colors.GetLength(0); i++) {
1431  				GetComponent&lt;Renderer&gt;().materials[i].SetColor(namedcolorvalue.ToString(),colors[i,2]);
1432  			}
1433  		}else if(GetComponent&lt;Light&gt;()){
1434  			GetComponent&lt;Light&gt;().color=colors[0,2];
1435  		}
1436  		if(percentage==1){
1437  			if(GetComponent&lt;GUITexture&gt;()){
1438  				GetComponent&lt;GUITexture&gt;().color=colors[0,1];
1439  			}else if(GetComponent&lt;GUIText&gt;()){
1440  				GetComponent&lt;GUIText&gt;().material.color=colors[0,1];
1441  			}else if(GetComponent&lt;Renderer&gt;()){
1442  				for (int i = 0; i &lt; colors.GetLength(0); i++) {
1443  					GetComponent&lt;Renderer&gt;().materials[i].SetColor(namedcolorvalue.ToString(),colors[i,1]);
1444  				}
1445  			}else if(GetComponent&lt;Light&gt;()){
1446  				GetComponent&lt;Light&gt;().color=colors[0,1];
1447  			}			
1448  		}
1449  	}	
1450  	void ApplyAudioToTargets(){
1451  		vector2s[2].x = ease(vector2s[0].x,vector2s[1].x,percentage);
1452  		vector2s[2].y = ease(vector2s[0].y,vector2s[1].y,percentage);
1453  		audioSource.volume=vector2s[2].x;
1454  		audioSource.pitch=vector2s[2].y;
1455  		if(percentage==1){
1456  			audioSource.volume=vector2s[1].x;
1457  			audioSource.pitch=vector2s[1].y;	
1458  		}
1459  	}	
1460  	void ApplyStabTargets(){
1461  	}
1462  	void ApplyMoveToPathTargets(){
1463  		preUpdate = thisTransform.position;
1464  		float t = ease(0,1,percentage);
1465  		float lookAheadAmount;
1466  		if(isLocal){
1467  			thisTransform.localPosition=path.Interp(Mathf.Clamp(t,0,1));	
1468  		}else{
1469  			thisTransform.position=path.Interp(Mathf.Clamp(t,0,1));	
1470  		}
1471  		if(tweenArguments.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)tweenArguments[&quot;orienttopath&quot;]){
1472  			float tLook;
1473  			if(tweenArguments.Contains(&quot;lookahead&quot;)){
1474  				lookAheadAmount = (float)tweenArguments[&quot;lookahead&quot;];
1475  			}else{
1476  				lookAheadAmount = Defaults.lookAhead;
1477  			}
1478  			tLook = ease(0,1, Mathf.Min(1f, percentage+lookAheadAmount)); 
1479  			tweenArguments[&quot;looktarget&quot;] = path.Interp(Mathf.Clamp(tLook,0,1));
1480  		}
1481  		postUpdate=thisTransform.position;
1482  		if(physics){
1483  			thisTransform.position=preUpdate;
1484  			GetComponent&lt;Rigidbody&gt;().MovePosition(postUpdate);
1485  		}
1486  	}
1487  	void ApplyMoveToTargets(){
1488  		preUpdate=thisTransform.position;
1489  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1490  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1491  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1492  		if (isLocal) {
1493  			thisTransform.localPosition=vector3s[2];
1494  		}else{
1495  			thisTransform.position=vector3s[2];
1496  		}
1497  		if(percentage==1){
1498  			if (isLocal) {
1499  				thisTransform.localPosition=vector3s[1];		
1500  			}else{
1501  				thisTransform.position=vector3s[1];
1502  			}
1503  		}
1504  		postUpdate=thisTransform.position;
1505  		if(physics){
1506  			thisTransform.position=preUpdate;
1507  			GetComponent&lt;Rigidbody&gt;().MovePosition(postUpdate);
1508  		}
1509  	}	
1510  	void ApplyMoveByTargets(){	
1511  		preUpdate = thisTransform.position;
1512  		Vector3 currentRotation = new Vector3();
1513  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1514  			currentRotation = thisTransform.eulerAngles;
1515  			thisTransform.eulerAngles = vector3s[4];	
1516  		}
1517  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1518  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1519  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1520  		thisTransform.Translate(vector3s[2]-vector3s[3],space);
1521  		vector3s[3]=vector3s[2];
1522  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1523  			thisTransform.eulerAngles = currentRotation;	
1524  		}
1525  		postUpdate=thisTransform.position;
1526  		if(physics){
1527  			thisTransform.position=preUpdate;
1528  			GetComponent&lt;Rigidbody&gt;().MovePosition(postUpdate);
1529  		}
1530  	}	
1531  	void ApplyScaleToTargets(){
1532  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1533  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1534  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1535  		thisTransform.localScale=vector3s[2];	
1536  		if(percentage==1){
1537  			thisTransform.localScale=vector3s[1];
1538  		}
1539  	}
1540  	void ApplyLookToTargets(){
1541  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1542  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1543  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1544  		if (isLocal) {
1545  			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
1546  		}else{
1547  			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
1548  		};	
1549  	}	
1550  	void ApplyRotateToTargets(){
1551  		preUpdate=thisTransform.eulerAngles;
1552  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1553  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1554  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1555  		if (isLocal) {
1556  			thisTransform.localRotation = Quaternion.Euler(vector3s[2]);
1557  		}else{
1558  			thisTransform.rotation = Quaternion.Euler(vector3s[2]);
1559  		};	
1560  		if(percentage==1){
1561  			if (isLocal) {
1562  				thisTransform.localRotation = Quaternion.Euler(vector3s[1]);
1563  			}else{
1564  				thisTransform.rotation = Quaternion.Euler(vector3s[1]);
1565  			};
1566  		}
1567  		postUpdate=thisTransform.eulerAngles;
1568  		if(physics){
1569  			thisTransform.eulerAngles=preUpdate;
1570  			GetComponent&lt;Rigidbody&gt;().MoveRotation(Quaternion.Euler(postUpdate));
1571  		}
1572  	}
1573  	void ApplyRotateAddTargets(){
1574  		preUpdate = thisTransform.eulerAngles;
1575  		vector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);
1576  		vector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);
1577  		vector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);
1578  		thisTransform.Rotate(vector3s[2]-vector3s[3],space);
1579  		vector3s[3]=vector3s[2];	
1580  		postUpdate=thisTransform.eulerAngles;
1581  		if(physics){
1582  			thisTransform.eulerAngles=preUpdate;
1583  			GetComponent&lt;Rigidbody&gt;().MoveRotation(Quaternion.Euler(postUpdate));
1584  		}		
1585  	}	
1586  	void ApplyShakePositionTargets(){
1587  		if (isLocal) {
1588  			preUpdate = thisTransform.localPosition;
1589  		}else{
1590  			preUpdate = thisTransform.position;
1591  		}
1592  		Vector3 currentRotation = new Vector3();
1593  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1594  			currentRotation = thisTransform.eulerAngles;
1595  			thisTransform.eulerAngles = vector3s[3];	
1596  		}
1597  		if (percentage==0) {
1598  			thisTransform.Translate(vector3s[1],space);
1599  		}
1600  		if (isLocal) {
1601  			thisTransform.localPosition=vector3s[0];
1602  		}else{
1603  			thisTransform.position=vector3s[0];
1604  		}
1605  		float diminishingControl = 1-percentage;
1606  		vector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);
1607  		vector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);
1608  		vector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);
1609  		if (isLocal) {
1610  			thisTransform.localPosition+=vector3s[2];
1611  		}else{
1612  			thisTransform.position+=vector3s[2];
1613  		}
1614  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1615  			thisTransform.eulerAngles = currentRotation;	
1616  		}	
1617  		postUpdate=thisTransform.position;
1618  		if(physics){
1619  			thisTransform.position=preUpdate;
1620  			GetComponent&lt;Rigidbody&gt;().MovePosition(postUpdate);
1621  		}
1622  	}	
1623  	void ApplyShakeScaleTargets(){
1624  		if (percentage==0) {
1625  			thisTransform.localScale=vector3s[1];
1626  		}
1627  		thisTransform.localScale=vector3s[0];
1628  		float diminishingControl = 1-percentage;
1629  		vector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);
1630  		vector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);
1631  		vector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);
1632  		thisTransform.localScale+=vector3s[2];
1633  	}		
1634  	void ApplyShakeRotationTargets(){
1635  		preUpdate = thisTransform.eulerAngles;
1636  		if (percentage==0) {
1637  			thisTransform.Rotate(vector3s[1],space);
1638  		}
1639  		thisTransform.eulerAngles=vector3s[0];
1640  		float diminishingControl = 1-percentage;
1641  		vector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);
1642  		vector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);
1643  		vector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);
1644  		thisTransform.Rotate(vector3s[2],space);
1645  		postUpdate=thisTransform.eulerAngles;
1646  		if(physics){
1647  			thisTransform.eulerAngles=preUpdate;
1648  			GetComponent&lt;Rigidbody&gt;().MoveRotation(Quaternion.Euler(postUpdate));
1649  		}
1650  	}		
1651  	void ApplyPunchPositionTargets(){
1652  		preUpdate = thisTransform.position;
1653  		Vector3 currentRotation = new Vector3();
1654  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1655  			currentRotation = thisTransform.eulerAngles;
1656  			thisTransform.eulerAngles = vector3s[4];	
1657  		}
1658  		if(vector3s[1].x&gt;0){
1659  			vector3s[2].x = punch(vector3s[1].x,percentage);
1660  		}else if(vector3s[1].x&lt;0){
1661  			vector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); 
1662  		}
1663  		if(vector3s[1].y&gt;0){
1664  			vector3s[2].y=punch(vector3s[1].y,percentage);
1665  		}else if(vector3s[1].y&lt;0){
1666  			vector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); 
1667  		}
1668  		if(vector3s[1].z&gt;0){
1669  			vector3s[2].z=punch(vector3s[1].z,percentage);
1670  		}else if(vector3s[1].z&lt;0){
1671  			vector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); 
1672  		}
1673  		thisTransform.Translate(vector3s[2]-vector3s[3],space);
1674  		vector3s[3]=vector3s[2];
1675  		if(tweenArguments.Contains(&quot;looktarget&quot;)){
1676  			thisTransform.eulerAngles = currentRotation;	
1677  		}
1678  		postUpdate=thisTransform.position;
1679  		if(physics){
1680  			thisTransform.position=preUpdate;
1681  			GetComponent&lt;Rigidbody&gt;().MovePosition(postUpdate);
1682  		}
1683  	}		
1684  	void ApplyPunchRotationTargets(){
1685  		preUpdate = thisTransform.eulerAngles;
1686  		if(vector3s[1].x&gt;0){
1687  			vector3s[2].x = punch(vector3s[1].x,percentage);
1688  		}else if(vector3s[1].x&lt;0){
1689  			vector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); 
1690  		}
1691  		if(vector3s[1].y&gt;0){
1692  			vector3s[2].y=punch(vector3s[1].y,percentage);
1693  		}else if(vector3s[1].y&lt;0){
1694  			vector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); 
1695  		}
1696  		if(vector3s[1].z&gt;0){
1697  			vector3s[2].z=punch(vector3s[1].z,percentage);
1698  		}else if(vector3s[1].z&lt;0){
1699  			vector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); 
1700  		}
1701  		thisTransform.Rotate(vector3s[2]-vector3s[3],space);
1702  		vector3s[3]=vector3s[2];
1703  		postUpdate=thisTransform.eulerAngles;
1704  		if(physics){
1705  			thisTransform.eulerAngles=preUpdate;
1706  			GetComponent&lt;Rigidbody&gt;().MoveRotation(Quaternion.Euler(postUpdate));
1707  		}
1708  	}	
1709  	void ApplyPunchScaleTargets(){
1710  		if(vector3s[1].x&gt;0){
1711  			vector3s[2].x = punch(vector3s[1].x,percentage);
1712  		}else if(vector3s[1].x&lt;0){
1713  			vector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); 
1714  		}
1715  		if(vector3s[1].y&gt;0){
1716  			vector3s[2].y=punch(vector3s[1].y,percentage);
1717  		}else if(vector3s[1].y&lt;0){
1718  			vector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); 
1719  		}
1720  		if(vector3s[1].z&gt;0){
1721  			vector3s[2].z=punch(vector3s[1].z,percentage);
1722  		}else if(vector3s[1].z&lt;0){
1723  			vector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); 
1724  		}
1725  		thisTransform.localScale=vector3s[0]+vector3s[2];
1726  	}		
1727  	#endregion	
1728  	#region #5 Tween Steps
1729  	IEnumerator TweenDelay(){
1730  		delayStarted = Time.time;
1731  		yield return new WaitForSeconds (delay);
1732  		if(wasPaused){
1733  			wasPaused=false;
1734  			TweenStart();	
1735  		}
1736  	}	
1737  	void TweenStart(){		
1738  		CallBack(&quot;onstart&quot;);
1739  		if(!loop){
1740  			ConflictCheck();
1741  			GenerateTargets();
1742  		}
1743  		if(type == &quot;stab&quot;){
1744  			audioSource.PlayOneShot(audioSource.clip);
1745  		}
1746  		if (type == &quot;move&quot; || type==&quot;scale&quot; || type==&quot;rotate&quot; || type==&quot;punch&quot; || type==&quot;shake&quot; || type==&quot;curve&quot; || type==&quot;look&quot;) {
1747  			EnableKinematic();
1748  		}
1749  		isRunning = true;
1750  	}
1751  	IEnumerator TweenRestart(){
1752  		if(delay &gt; 0){
1753  			delayStarted = Time.time;
1754  			yield return new WaitForSeconds (delay);
1755  		}
1756  		loop=true;
1757  		TweenStart();
1758  	}	
1759  	void TweenUpdate(){
1760  		apply();
1761  		CallBack(&quot;onupdate&quot;);
1762  		UpdatePercentage();		
1763  	}
1764  	void TweenComplete(){
1765  		isRunning=false;
1766  		if(percentage&gt;.5f){
1767  			percentage=1f;
1768  		}else{
1769  			percentage=0;	
1770  		}
1771  		apply();
1772  		if(type == &quot;value&quot;){
1773  			CallBack(&quot;onupdate&quot;); 
1774  		}
1775  		if(loopType==LoopType.none){
1776  			Dispose();
1777  		}else{
1778  			TweenLoop();
1779  		}
1780  		CallBack(&quot;oncomplete&quot;);
1781  	}
1782  	void TweenLoop(){
1783  		DisableKinematic(); 
1784  		switch(loopType){
1785  			case LoopType.loop:
1786  				percentage=0;
1787  				runningTime=0;
1788  				apply();
1789  				StartCoroutine(&quot;TweenRestart&quot;);
1790  				break;
1791  			case LoopType.pingPong:
1792  				reverse = !reverse;
1793  				runningTime=0;
1794  				StartCoroutine(&quot;TweenRestart&quot;);
1795  				break;
1796  		}
1797  	}	
1798  	#endregion
1799  	#region #6 Update Callable
1800  	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed){
1801  		Rect diff = new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
1802  		return (diff);
1803  	}
1804  	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed){
1805  		Vector3 diff = targetValue - currentValue;
1806  		currentValue += (diff * speed) * Time.deltaTime;
1807  		return (currentValue);
1808  	}
1809  	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed){
1810  		Vector2 diff = targetValue - currentValue;
1811  		currentValue += (diff * speed) * Time.deltaTime;
1812  		return (currentValue);
1813  	}
1814  	public static float FloatUpdate(float currentValue, float targetValue, float speed){
1815  		float diff = targetValue - currentValue;
1816  		currentValue += (diff * speed) * Time.deltaTime;
1817  		return (currentValue);
1818  	}
1819  	public static void FadeUpdate(GameObject target, Hashtable args){
1820  		args[&quot;a&quot;]=args[&quot;alpha&quot;];
1821  		ColorUpdate(target,args);
1822  	}
1823  	public static void FadeUpdate(GameObject target, float alpha, float time){
1824  		FadeUpdate(target,Hash(&quot;alpha&quot;,alpha,&quot;time&quot;,time));
1825  	}
1826  	public static void ColorUpdate(GameObject target, Hashtable args){
1827  		CleanArgs(args);
1828  		float time;
1829  		Color[] colors = new Color[4];
1830  		if(!args.Contains(&quot;includechildren&quot;) || (bool)args[&quot;includechildren&quot;]){
1831  			foreach(Transform child in target.transform){
1832  				ColorUpdate(child.gameObject,args);
1833  			}
1834  		}		 
1835  		if(args.Contains(&quot;time&quot;)){
1836  			time=(float)args[&quot;time&quot;];
1837  			time*=Defaults.updateTimePercentage;
1838  		}else{
1839  			time=Defaults.updateTime;
1840  		}
1841  		if(target.GetComponent&lt;GUITexture&gt;()){
1842  			colors[0] = colors[1] = target.GetComponent&lt;GUITexture&gt;().color;
1843  		}else if(target.GetComponent&lt;GUIText&gt;()){
1844  			colors[0] = colors[1] = target.GetComponent&lt;GUIText&gt;().material.color;
1845  		}else if(target.GetComponent&lt;Renderer&gt;()){
1846  			colors[0] = colors[1] = target.GetComponent&lt;Renderer&gt;().material.color;
1847  		}else if(target.GetComponent&lt;Light&gt;()){
1848  			colors[0] = colors[1] = target.GetComponent&lt;Light&gt;().color;	
1849  		}		
1850  		if (args.Contains(&quot;color&quot;)) {
1851  			colors[1]=(Color)args[&quot;color&quot;];
1852  		}else{
1853  			if (args.Contains(&quot;r&quot;)) {
1854  				colors[1].r=(float)args[&quot;r&quot;];
1855  			}
1856  			if (args.Contains(&quot;g&quot;)) {
1857  				colors[1].g=(float)args[&quot;g&quot;];
1858  			}
1859  			if (args.Contains(&quot;b&quot;)) {
1860  				colors[1].b=(float)args[&quot;b&quot;];
1861  			}
1862  			if (args.Contains(&quot;a&quot;)) {
1863  				colors[1].a=(float)args[&quot;a&quot;];
1864  			}
1865  		}
1866  		colors[3].r=Mathf.SmoothDamp(colors[0].r,colors[1].r,ref colors[2].r,time);
1867  		colors[3].g=Mathf.SmoothDamp(colors[0].g,colors[1].g,ref colors[2].g,time);
1868  		colors[3].b=Mathf.SmoothDamp(colors[0].b,colors[1].b,ref colors[2].b,time);
1869  		colors[3].a=Mathf.SmoothDamp(colors[0].a,colors[1].a,ref colors[2].a,time);
1870  		if(target.GetComponent&lt;GUITexture&gt;()){
1871  			target.GetComponent&lt;GUITexture&gt;().color=colors[3];
1872  		}else if(target.GetComponent&lt;GUIText&gt;()){
1873  			target.GetComponent&lt;GUIText&gt;().material.color=colors[3];
1874  		}else if(target.GetComponent&lt;Renderer&gt;()){
1875  			target.GetComponent&lt;Renderer&gt;().material.color=colors[3];
1876  		}else if(target.GetComponent&lt;Light&gt;()){
1877  			target.GetComponent&lt;Light&gt;().color=colors[3];	
1878  		}
1879  	}	
1880  	public static void ColorUpdate(GameObject target, Color color, float time){
1881  		ColorUpdate(target,Hash(&quot;color&quot;,color,&quot;time&quot;,time));
1882  	}
1883  	public static void AudioUpdate(GameObject target, Hashtable args){
1884  		CleanArgs(args);
1885  		AudioSource audioSource;
1886  		float time;
1887  		Vector2[] vector2s = new Vector2[4];
1888  		if(args.Contains(&quot;time&quot;)){
1889  			time=(float)args[&quot;time&quot;];
1890  			time*=Defaults.updateTimePercentage;
1891  		}else{
1892  			time=Defaults.updateTime;
1893  		}
1894  		if(args.Contains(&quot;audiosource&quot;)){
1895  			audioSource=(AudioSource)args[&quot;audiosource&quot;];
1896  		}else{
1897  			if(target.GetComponent&lt;AudioSource&gt;()){
1898  				audioSource=target.GetComponent&lt;AudioSource&gt;();
1899  			}else{
1900  				Debug.LogError(&quot;iTween Error: AudioUpdate requires an AudioSource.&quot;);
1901  				return;
1902  			}
1903  		}		
1904  		vector2s[0] = vector2s[1] = new Vector2(audioSource.volume,audioSource.pitch);
1905  		if(args.Contains(&quot;volume&quot;)){
1906  			vector2s[1].x=(float)args[&quot;volume&quot;];
1907  		}
1908  		if(args.Contains(&quot;pitch&quot;)){
1909  			vector2s[1].y=(float)args[&quot;pitch&quot;];
1910  		}
1911  		vector2s[3].x=Mathf.SmoothDampAngle(vector2s[0].x,vector2s[1].x,ref vector2s[2].x,time);
1912  		vector2s[3].y=Mathf.SmoothDampAngle(vector2s[0].y,vector2s[1].y,ref vector2s[2].y,time);
1913  		audioSource.volume=vector2s[3].x;
1914  		audioSource.pitch=vector2s[3].y;
1915  	}
1916  	public static void AudioUpdate(GameObject target, float volume, float pitch, float time){
1917  		AudioUpdate(target,Hash(&quot;volume&quot;,volume,&quot;pitch&quot;,pitch,&quot;time&quot;,time));
1918  	}
1919  	public static void RotateUpdate(GameObject target, Hashtable args){
1920  		CleanArgs(args);
1921  		bool isLocal;
1922  		float time;
1923  		Vector3[] vector3s = new Vector3[4];
1924  		Vector3 preUpdate = target.transform.eulerAngles;
1925  		if(args.Contains(&quot;time&quot;)){
1926  			time=(float)args[&quot;time&quot;];
1927  			time*=Defaults.updateTimePercentage;
1928  		}else{
1929  			time=Defaults.updateTime;
1930  		}
1931  		if(args.Contains(&quot;islocal&quot;)){
1932  			isLocal = (bool)args[&quot;islocal&quot;];
1933  		}else{
1934  			isLocal = Defaults.isLocal;	
1935  		}
1936  		if(isLocal){
<span onclick='openModal()' class='match'>1937  			vector3s[0] = target.transform.localEulerAngles;
1938  		}else{
1939  			vector3s[0] = target.transform.eulerAngles;	
1940  		}
1941  		if(args.Contains(&quot;rotation&quot;)){
1942  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)){
1943  				Transform trans = (Transform)args[&quot;rotation&quot;];
1944  				vector3s[1]=trans.eulerAngles;
1945  			}else if(args[&quot;rotation&quot;].GetType() == typeof(Vector3)){
1946  				vector3s[1]=(Vector3)args[&quot;rotation&quot;];
1947  			}	
1948  		}
1949  		vector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
1950  		vector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
1951  		vector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
1952  		if(isLocal){
1953  			target.transform.localEulerAngles=vector3s[3];
1954  		}else{
1955  			target.transform.eulerAngles=vector3s[3];
1956  		}
1957  		if(target.GetComponent&lt;Rigidbody&gt;() != null){
</span>1958  			Vector3 postUpdate=target.transform.eulerAngles;
1959  			target.transform.eulerAngles=preUpdate;
1960  			target.GetComponent&lt;Rigidbody&gt;().MoveRotation(Quaternion.Euler(postUpdate));
1961  		}
1962  	}
1963  	public static void RotateUpdate(GameObject target, Vector3 rotation, float time){
1964  		RotateUpdate(target,Hash(&quot;rotation&quot;,rotation,&quot;time&quot;,time));
1965  	}
1966  	public static void ScaleUpdate(GameObject target, Hashtable args){
1967  		CleanArgs(args);
1968  		float time;
1969  		Vector3[] vector3s = new Vector3[4];
1970  		if(args.Contains(&quot;time&quot;)){
1971  			time=(float)args[&quot;time&quot;];
1972  			time*=Defaults.updateTimePercentage;
1973  		}else{
1974  			time=Defaults.updateTime;
1975  		}
1976  		vector3s[0] = vector3s[1] = target.transform.localScale;
1977  		if (args.Contains(&quot;scale&quot;)) {
1978  			if (args[&quot;scale&quot;].GetType() == typeof(Transform)){
1979  				Transform trans = (Transform)args[&quot;scale&quot;];
1980  				vector3s[1]=trans.localScale;
1981  			}else if(args[&quot;scale&quot;].GetType() == typeof(Vector3)){
1982  				vector3s[1]=(Vector3)args[&quot;scale&quot;];
1983  			}				
1984  		}else{
1985  			if (args.Contains(&quot;x&quot;)) {
1986  				vector3s[1].x=(float)args[&quot;x&quot;];
1987  			}
1988  			if (args.Contains(&quot;y&quot;)) {
1989  				vector3s[1].y=(float)args[&quot;y&quot;];
1990  			}
1991  			if (args.Contains(&quot;z&quot;)) {
1992  				vector3s[1].z=(float)args[&quot;z&quot;];
1993  			}
1994  		}
1995  		vector3s[3].x=Mathf.SmoothDamp(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
1996  		vector3s[3].y=Mathf.SmoothDamp(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
1997  		vector3s[3].z=Mathf.SmoothDamp(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
1998  		target.transform.localScale=vector3s[3];		
1999  	}	
2000  	public static void ScaleUpdate(GameObject target, Vector3 scale, float time){
2001  		ScaleUpdate(target,Hash(&quot;scale&quot;,scale,&quot;time&quot;,time));
2002  	}
2003  	public static void MoveUpdate(GameObject target, Hashtable args){
2004  		CleanArgs(args);
2005  		float time;
2006  		Vector3[] vector3s = new Vector3[4];
2007  		bool isLocal;
2008  		Vector3 preUpdate = target.transform.position;
2009  		if(args.Contains(&quot;time&quot;)){
2010  			time=(float)args[&quot;time&quot;];
2011  			time*=Defaults.updateTimePercentage;
2012  		}else{
2013  			time=Defaults.updateTime;
2014  		}
2015  		if(args.Contains(&quot;islocal&quot;)){
2016  			isLocal = (bool)args[&quot;islocal&quot;];
2017  		}else{
2018  			isLocal = Defaults.isLocal;	
2019  		}
2020  		if(isLocal){
2021  			vector3s[0] = vector3s[1] = target.transform.localPosition;
2022  		}else{
2023  			vector3s[0] = vector3s[1] = target.transform.position;	
2024  		}
2025  		if (args.Contains(&quot;position&quot;)) {
2026  			if (args[&quot;position&quot;].GetType() == typeof(Transform)){
2027  				Transform trans = (Transform)args[&quot;position&quot;];
2028  				vector3s[1]=trans.position;
2029  			}else if(args[&quot;position&quot;].GetType() == typeof(Vector3)){
2030  				vector3s[1]=(Vector3)args[&quot;position&quot;];
2031  			}			
2032  		}else{
2033  			if (args.Contains(&quot;x&quot;)) {
2034  				vector3s[1].x=(float)args[&quot;x&quot;];
2035  			}
2036  			if (args.Contains(&quot;y&quot;)) {
2037  				vector3s[1].y=(float)args[&quot;y&quot;];
2038  			}
2039  			if (args.Contains(&quot;z&quot;)) {
2040  				vector3s[1].z=(float)args[&quot;z&quot;];
2041  			}
2042  		}
2043  		vector3s[3].x=Mathf.SmoothDamp(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
2044  		vector3s[3].y=Mathf.SmoothDamp(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
2045  		vector3s[3].z=Mathf.SmoothDamp(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
2046  		if(args.Contains(&quot;orienttopath&quot;) &amp;&amp; (bool)args[&quot;orienttopath&quot;]){
2047  			args[&quot;looktarget&quot;] = vector3s[3];
2048  		}
2049  		if(args.Contains(&quot;looktarget&quot;)){
2050  			iTween.LookUpdate(target,args);
2051  		}
2052  		if(isLocal){
2053  			target.transform.localPosition = vector3s[3];			
2054  		}else{
2055  			target.transform.position=vector3s[3];	
2056  		}	
2057  		if(target.GetComponent&lt;Rigidbody&gt;() != null){
2058  			Vector3 postUpdate=target.transform.position;
2059  			target.transform.position=preUpdate;
2060  			target.GetComponent&lt;Rigidbody&gt;().MovePosition(postUpdate);
2061  		}
2062  	}
2063  	public static void MoveUpdate(GameObject target, Vector3 position, float time){
2064  		MoveUpdate(target,Hash(&quot;position&quot;,position,&quot;time&quot;,time));
2065  	}
2066  	public static void LookUpdate(GameObject target, Hashtable args){
2067  		CleanArgs(args);
2068  		float time;
2069  		Vector3[] vector3s = new Vector3[5];
2070  		if(args.Contains(&quot;looktime&quot;)){
2071  			time=(float)args[&quot;looktime&quot;];
2072  			time*=Defaults.updateTimePercentage;
2073  		}else if(args.Contains(&quot;time&quot;)){
2074  			time=(float)args[&quot;time&quot;]*.15f;
2075  			time*=Defaults.updateTimePercentage;
2076  		}else{
2077  			time=Defaults.updateTime;
2078  		}
2079  		vector3s[0] = target.transform.eulerAngles;
2080  		if(args.Contains(&quot;looktarget&quot;)){
2081  			if (args[&quot;looktarget&quot;].GetType() == typeof(Transform)) {
2082  				target.transform.LookAt((Transform)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
2083  			}else if(args[&quot;looktarget&quot;].GetType() == typeof(Vector3)){
2084  				target.transform.LookAt((Vector3)args[&quot;looktarget&quot;], (Vector3?)args[&quot;up&quot;] ?? Defaults.up);
2085  			}
2086  		}else{
2087  			Debug.LogError(&quot;iTween Error: LookUpdate needs a &#x27;looktarget&#x27; property!&quot;);
2088  			return;
2089  		}
2090  		vector3s[1]=target.transform.eulerAngles;
2091  		target.transform.eulerAngles=vector3s[0];
2092  		vector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
2093  		vector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
2094  		vector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
2095  		target.transform.eulerAngles=vector3s[3];
2096  		if(args.Contains(&quot;axis&quot;)){
2097  			vector3s[4]=target.transform.eulerAngles;
2098  			switch((string)args[&quot;axis&quot;]){
2099  				case &quot;x&quot;:
2100  					vector3s[4].y=vector3s[0].y;
2101  					vector3s[4].z=vector3s[0].z;
2102  				break;
2103  				case &quot;y&quot;:
2104  					vector3s[4].x=vector3s[0].x;
2105  					vector3s[4].z=vector3s[0].z;
2106  				break;
2107  				case &quot;z&quot;:
2108  					vector3s[4].x=vector3s[0].x;
2109  					vector3s[4].y=vector3s[0].y;
2110  				break;
2111  			}
2112  			target.transform.eulerAngles=vector3s[4];
2113  		}	
2114  	}
2115  	public static void LookUpdate(GameObject target, Vector3 looktarget, float time){
2116  		LookUpdate(target,Hash(&quot;looktarget&quot;,looktarget,&quot;time&quot;,time));
2117  	}
2118  	#endregion
2119  	#region #7 External Utilities
2120  	public static float PathLength(Transform[] path){
2121  		Vector3[] suppliedPath = new Vector3[path.Length];
2122  		float pathLength = 0;
2123  		for (int i = 0; i &lt; path.Length; i++) {
2124  			suppliedPath[i]=path[i].position;
2125  		}
2126  		Vector3[] vector3s = PathControlPointGenerator(suppliedPath);
2127  		Vector3 prevPt = Interp(vector3s,0);
2128  		int SmoothAmount = path.Length*20;
2129  		for (int i = 1; i &lt;= SmoothAmount; i++) {
2130  			float pm = (float) i / SmoothAmount;
2131  			Vector3 currPt = Interp(vector3s,pm);
2132  			pathLength += Vector3.Distance(prevPt,currPt);
2133  			prevPt = currPt;
2134  		}
2135  		return pathLength;
2136  	}
2137  	public static float PathLength(Vector3[] path){
2138  		float pathLength = 0;
2139  		Vector3[] vector3s = PathControlPointGenerator(path);
2140  		Vector3 prevPt = Interp(vector3s,0);
2141  		int SmoothAmount = path.Length*20;
2142  		for (int i = 1; i &lt;= SmoothAmount; i++) {
2143  			float pm = (float) i / SmoothAmount;
2144  			Vector3 currPt = Interp(vector3s,pm);
2145  			pathLength += Vector3.Distance(prevPt,currPt);
2146  			prevPt = currPt;
2147  		}
2148  		return pathLength;
2149  	}	
2150  	public static Texture2D CameraTexture(Color color){
2151  		Texture2D texture = new Texture2D(Screen.width,Screen.height,TextureFormat.ARGB32, false);
2152  		Color[] colors = new Color[Screen.width*Screen.height];
2153  		for (int i = 0; i &lt; colors.Length; i++) {
2154  			colors[i]=color;
2155  		}
2156  		texture.SetPixels(colors);
2157  		texture.Apply();
2158  		return(texture);		
2159  	}
2160  	public static void PutOnPath(GameObject target, Vector3[] path, float percent){
2161  		target.transform.position=Interp(PathControlPointGenerator(path),percent);
2162  	}
2163  	public static void PutOnPath(Transform target, Vector3[] path, float percent){
2164  		target.position=Interp(PathControlPointGenerator(path),percent);
2165  	}	
2166  	public static void PutOnPath(GameObject target, Transform[] path, float percent){
2167  		Vector3[] suppliedPath = new Vector3[path.Length];
2168  		for (int i = 0; i &lt; path.Length; i++) {
2169  			suppliedPath[i]=path[i].position;
2170  		}	
2171  		target.transform.position=Interp(PathControlPointGenerator(suppliedPath),percent);
2172  	}	
2173  	public static void PutOnPath(Transform target, Transform[] path, float percent){
2174  		Vector3[] suppliedPath = new Vector3[path.Length];
2175  		for (int i = 0; i &lt; path.Length; i++) {
2176  			suppliedPath[i]=path[i].position;
2177  		}	
2178  		target.position=Interp(PathControlPointGenerator(suppliedPath),percent);
2179  	}		
2180  	public static Vector3 PointOnPath(Transform[] path, float percent){
2181  		Vector3[] suppliedPath = new Vector3[path.Length];
2182  		for (int i = 0; i &lt; path.Length; i++) {
2183  			suppliedPath[i]=path[i].position;
2184  		}	
2185  		return(Interp(PathControlPointGenerator(suppliedPath),percent));
2186  	}
2187  	public static void DrawLine(Vector3[] line) {
2188  		if(line.Length&gt;0){
2189  			DrawLineHelper(line,Defaults.color,&quot;gizmos&quot;);
2190  		}
2191  	}	
2192  	public static void DrawLine(Vector3[] line, Color color) {
2193  		if(line.Length&gt;0){
2194  			DrawLineHelper(line,color,&quot;gizmos&quot;);
2195  		}
2196  	}		
2197  	public static void DrawLine(Transform[] line) {
2198  		if(line.Length&gt;0){
2199  			Vector3[] suppliedLine = new Vector3[line.Length];
2200  			for (int i = 0; i &lt; line.Length; i++) {
2201  				suppliedLine[i]=line[i].position;
2202  			}
2203  			DrawLineHelper(suppliedLine,Defaults.color,&quot;gizmos&quot;);
2204  		}
2205  	}		
2206  	public static void DrawLine(Transform[] line,Color color) {
2207  		if(line.Length&gt;0){
2208  			Vector3[] suppliedLine = new Vector3[line.Length];
2209  			for (int i = 0; i &lt; line.Length; i++) {
2210  				suppliedLine[i]=line[i].position;
2211  			}
2212  			DrawLineHelper(suppliedLine, color,&quot;gizmos&quot;);
2213  		}
2214  	}	
2215  	public static void DrawLineGizmos(Vector3[] line) {
2216  		if(line.Length&gt;0){
2217  			DrawLineHelper(line,Defaults.color,&quot;gizmos&quot;);
2218  		}
2219  	}	
2220  	public static void DrawLineGizmos(Vector3[] line, Color color) {
2221  		if(line.Length&gt;0){
2222  			DrawLineHelper(line,color,&quot;gizmos&quot;);
2223  		}
2224  	}		
2225  	public static void DrawLineGizmos(Transform[] line) {
2226  		if(line.Length&gt;0){
2227  			Vector3[] suppliedLine = new Vector3[line.Length];
2228  			for (int i = 0; i &lt; line.Length; i++) {
2229  				suppliedLine[i]=line[i].position;
2230  			}
2231  			DrawLineHelper(suppliedLine,Defaults.color,&quot;gizmos&quot;);
2232  		}
2233  	}		
2234  	public static void DrawLineGizmos(Transform[] line,Color color) {
2235  		if(line.Length&gt;0){
2236  			Vector3[] suppliedLine = new Vector3[line.Length];
2237  			for (int i = 0; i &lt; line.Length; i++) {
2238  				suppliedLine[i]=line[i].position;
2239  			}
2240  			DrawLineHelper(suppliedLine, color,&quot;gizmos&quot;);
2241  		}
2242  	}
2243  	public static void DrawLineHandles(Vector3[] line) {
2244  		if(line.Length&gt;0){
2245  			DrawLineHelper(line,Defaults.color,&quot;handles&quot;);
2246  		}
2247  	}	
2248  	public static void DrawLineHandles(Vector3[] line, Color color) {
2249  		if(line.Length&gt;0){
2250  			DrawLineHelper(line,color,&quot;handles&quot;);
2251  		}
2252  	}		
2253  	public static void DrawLineHandles(Transform[] line) {
2254  		if(line.Length&gt;0){
2255  			Vector3[] suppliedLine = new Vector3[line.Length];
2256  			for (int i = 0; i &lt; line.Length; i++) {
2257  				suppliedLine[i]=line[i].position;
2258  			}
2259  			DrawLineHelper(suppliedLine,Defaults.color,&quot;handles&quot;);
2260  		}
2261  	}		
2262  	public static void DrawLineHandles(Transform[] line,Color color) {
2263  		if(line.Length&gt;0){
2264  			Vector3[] suppliedLine = new Vector3[line.Length];
2265  			for (int i = 0; i &lt; line.Length; i++) {
2266  				suppliedLine[i]=line[i].position;
2267  			}
2268  			DrawLineHelper(suppliedLine, color,&quot;handles&quot;);
2269  		}
2270  	}	
2271  	public static Vector3 PointOnPath(Vector3[] path, float percent){
2272  		return(Interp(PathControlPointGenerator(path),percent));
2273  	}		
2274  	public static void DrawPath(Vector3[] path) {
2275  		if(path.Length&gt;0){
2276  			DrawPathHelper(path,Defaults.color,&quot;gizmos&quot;);
2277  		}
2278  	}		
2279  	public static void DrawPath(Vector3[] path, Color color) {
2280  		if(path.Length&gt;0){
2281  			DrawPathHelper(path, color,&quot;gizmos&quot;);
2282  		}
2283  	}
2284  	public static void DrawPath(Transform[] path) {
2285  		if(path.Length&gt;0){
2286  			Vector3[] suppliedPath = new Vector3[path.Length];
2287  			for (int i = 0; i &lt; path.Length; i++) {
2288  				suppliedPath[i]=path[i].position;
2289  			}
2290  			DrawPathHelper(suppliedPath,Defaults.color,&quot;gizmos&quot;);	
2291  		}
2292  	}		
2293  	public static void DrawPath(Transform[] path,Color color) {
2294  		if(path.Length&gt;0){
2295  			Vector3[] suppliedPath = new Vector3[path.Length];
2296  			for (int i = 0; i &lt; path.Length; i++) {
2297  				suppliedPath[i]=path[i].position;
2298  			}
2299  			DrawPathHelper(suppliedPath, color,&quot;gizmos&quot;);
2300  		}
2301  	}	
2302  	public static void DrawPathGizmos(Vector3[] path) {
2303  		if(path.Length&gt;0){
2304  			DrawPathHelper(path,Defaults.color,&quot;gizmos&quot;);
2305  		}
2306  	}		
2307  	public static void DrawPathGizmos(Vector3[] path, Color color) {
2308  		if(path.Length&gt;0){
2309  			DrawPathHelper(path, color,&quot;gizmos&quot;);
2310  		}
2311  	}
2312  	public static void DrawPathGizmos(Transform[] path) {
2313  		if(path.Length&gt;0){
2314  			Vector3[] suppliedPath = new Vector3[path.Length];
2315  			for (int i = 0; i &lt; path.Length; i++) {
2316  				suppliedPath[i]=path[i].position;
2317  			}
2318  			DrawPathHelper(suppliedPath,Defaults.color,&quot;gizmos&quot;);	
2319  		}
2320  	}		
2321  	public static void DrawPathGizmos(Transform[] path,Color color) {
2322  		if(path.Length&gt;0){
2323  			Vector3[] suppliedPath = new Vector3[path.Length];
2324  			for (int i = 0; i &lt; path.Length; i++) {
2325  				suppliedPath[i]=path[i].position;
2326  			}
2327  			DrawPathHelper(suppliedPath, color,&quot;gizmos&quot;);
2328  		}
2329  	}	
2330  	public static void DrawPathHandles(Vector3[] path) {
2331  		if(path.Length&gt;0){
2332  			DrawPathHelper(path,Defaults.color,&quot;handles&quot;);
2333  		}
2334  	}		
2335  	public static void DrawPathHandles(Vector3[] path, Color color) {
2336  		if(path.Length&gt;0){
2337  			DrawPathHelper(path, color,&quot;handles&quot;);
2338  		}
2339  	}
2340  	public static void DrawPathHandles(Transform[] path) {
2341  		if(path.Length&gt;0){
2342  			Vector3[] suppliedPath = new Vector3[path.Length];
2343  			for (int i = 0; i &lt; path.Length; i++) {
2344  				suppliedPath[i]=path[i].position;
2345  			}
2346  			DrawPathHelper(suppliedPath,Defaults.color,&quot;handles&quot;);	
2347  		}
2348  	}		
2349  	public static void DrawPathHandles(Transform[] path,Color color) {
2350  		if(path.Length&gt;0){
2351  			Vector3[] suppliedPath = new Vector3[path.Length];
2352  			for (int i = 0; i &lt; path.Length; i++) {
2353  				suppliedPath[i]=path[i].position;
2354  			}
2355  			DrawPathHelper(suppliedPath, color,&quot;handles&quot;);
2356  		}
2357  	}
2358  	public static void CameraFadeDepth(int depth){
2359  		if(cameraFade){
2360  			cameraFade.transform.position=new Vector3(cameraFade.transform.position.x,cameraFade.transform.position.y,depth);
2361  		}
2362  	}
2363  	public static void CameraFadeDestroy(){
2364  		if(cameraFade){
2365  			Destroy(cameraFade);
2366  		}
2367  	}
2368  	public static void CameraFadeSwap(Texture2D texture){
2369  		if(cameraFade){
2370  			cameraFade.GetComponent&lt;GUITexture&gt;().texture=texture;
2371  		}
2372  	}
2373  	public static GameObject CameraFadeAdd(Texture2D texture, int depth){
2374  		if(cameraFade){
2375  			return null;
2376  		}else{			
2377  			cameraFade = new GameObject(&quot;iTween Camera Fade&quot;);
2378  			cameraFade.transform.position= new Vector3(.5f,.5f,depth);
2379  			cameraFade.AddComponent&lt;GUITexture&gt;();
2380  			cameraFade.GetComponent&lt;GUITexture&gt;().texture=texture;
2381  			cameraFade.GetComponent&lt;GUITexture&gt;().color = new Color(.5f,.5f,.5f,0);
2382  			return cameraFade;
2383  		}
2384  	}
2385  	public static GameObject CameraFadeAdd(Texture2D texture){
2386  		if(cameraFade){
2387  			return null;
2388  		}else{			
2389  			cameraFade = new GameObject(&quot;iTween Camera Fade&quot;);
2390  			cameraFade.transform.position= new Vector3(.5f,.5f,Defaults.cameraFadeDepth);
2391  			cameraFade.AddComponent&lt;GUITexture&gt;();
2392  			cameraFade.GetComponent&lt;GUITexture&gt;().texture=texture;
2393  			cameraFade.GetComponent&lt;GUITexture&gt;().color = new Color(.5f,.5f,.5f,0);
2394  			return cameraFade;
2395  		}
2396  	}
2397  	public static GameObject CameraFadeAdd(){
2398  		if(cameraFade){
2399  			return null;
2400  		}else{			
2401  			cameraFade = new GameObject(&quot;iTween Camera Fade&quot;);
2402  			cameraFade.transform.position= new Vector3(.5f,.5f,Defaults.cameraFadeDepth);
2403  			cameraFade.AddComponent&lt;GUITexture&gt;();
2404  			cameraFade.GetComponent&lt;GUITexture&gt;().texture=CameraTexture(Color.black);
2405  			cameraFade.GetComponent&lt;GUITexture&gt;().color = new Color(.5f,.5f,.5f,0);
2406  			return cameraFade;
2407  		}
2408  	}	
2409  	public static void Resume(GameObject target){
2410  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2411  		foreach (iTween item in tweens){
2412  			item.enabled=true;
2413  		}
2414  	}
2415  	public static void Resume(GameObject target, bool includechildren){
2416  		Resume(target);
2417  		if(includechildren){
2418  			foreach(Transform child in target.transform){
2419  				Resume(child.gameObject,true);
2420  			}			
2421  		}
2422  	}	
2423  	public static void Resume(GameObject target, string type){
2424  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2425  		foreach (iTween item in tweens){
2426  			string targetType = item.type+item.method;
2427  			targetType=targetType.Substring(0,type.Length);
2428  			if(targetType.ToLower() == type.ToLower()){
2429  				item.enabled=true;
2430  			}
2431  		}
2432  	}
2433  	public static void Resume(GameObject target, string type, bool includechildren){
2434  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2435  		foreach (iTween item in tweens){
2436  			string targetType = item.type+item.method;
2437  			targetType=targetType.Substring(0,type.Length);
2438  			if(targetType.ToLower() == type.ToLower()){
2439  				item.enabled=true;
2440  			}
2441  		}
2442  		if(includechildren){
2443  			foreach(Transform child in target.transform){
2444  				Resume(child.gameObject,type,true);
2445  			}			
2446  		}		
2447  	}	
2448  	public static void Resume(){
2449  		for (int i = 0; i &lt; tweens.Count; i++) {
2450  			Hashtable currentTween = tweens[i];
2451  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2452  			Resume(target);
2453  		}
2454  	}	
2455  	public static void Resume(string type){
2456  		ArrayList resumeArray = new ArrayList();
2457  		for (int i = 0; i &lt; tweens.Count; i++) {
2458  			Hashtable currentTween = tweens[i];
2459  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2460  			resumeArray.Insert(resumeArray.Count,target);
2461  		}
2462  		for (int i = 0; i &lt; resumeArray.Count; i++) {
2463  			Resume((GameObject)resumeArray[i],type);
2464  		}
2465  	}			
2466  	public static void Pause(GameObject target){
2467  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2468  		foreach (iTween item in tweens){
2469  			if(item.delay&gt;0){
2470  				item.delay-=Time.time-item.delayStarted;
2471  				item.StopCoroutine(&quot;TweenDelay&quot;);
2472  			}
2473  			item.isPaused=true;
2474  			item.enabled=false;
2475  		}
2476  	}
2477  	public static void Pause(GameObject target, bool includechildren){
2478  		Pause(target);
2479  		if(includechildren){
2480  			foreach(Transform child in target.transform){
2481  				Pause(child.gameObject,true);
2482  			}			
2483  		}
2484  	}	
2485  	public static void Pause(GameObject target, string type){
2486  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2487  		foreach (iTween item in tweens){
2488  			string targetType = item.type+item.method;
2489  			targetType=targetType.Substring(0,type.Length);
2490  			if(targetType.ToLower() == type.ToLower()){
2491  				if(item.delay&gt;0){
2492  					item.delay-=Time.time-item.delayStarted;
2493  					item.StopCoroutine(&quot;TweenDelay&quot;);
2494  				}
2495  				item.isPaused=true;
2496  				item.enabled=false;
2497  			}
2498  		}
2499  	}
2500  	public static void Pause(GameObject target, string type, bool includechildren){
2501  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2502  		foreach (iTween item in tweens){
2503  			string targetType = item.type+item.method;
2504  			targetType=targetType.Substring(0,type.Length);
2505  			if(targetType.ToLower() == type.ToLower()){
2506  				if(item.delay&gt;0){
2507  					item.delay-=Time.time-item.delayStarted;
2508  					item.StopCoroutine(&quot;TweenDelay&quot;);
2509  				}
2510  				item.isPaused=true;
2511  				item.enabled=false;
2512  			}
2513  		}
2514  		if(includechildren){
2515  			foreach(Transform child in target.transform){
2516  				Pause(child.gameObject,type,true);
2517  			}			
2518  		}		
2519  	}	
2520  	public static void Pause(){
2521  		for (int i = 0; i &lt; tweens.Count; i++) {
2522  			Hashtable currentTween = tweens[i];
2523  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2524  			Pause(target);
2525  		}
2526  	}	
2527  	public static void Pause(string type){
2528  		ArrayList pauseArray = new ArrayList();
2529  		for (int i = 0; i &lt; tweens.Count; i++) {
2530  			Hashtable currentTween = tweens[i];
2531  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2532  			pauseArray.Insert(pauseArray.Count,target);
2533  		}
2534  		for (int i = 0; i &lt; pauseArray.Count; i++) {
2535  			Pause((GameObject)pauseArray[i],type);
2536  		}
2537  	}		
2538  	public static int Count(){
2539  		return(tweens.Count);
2540  	}
2541  	public static int Count(string type){
2542  		int tweenCount = 0;
2543  		for (int i = 0; i &lt; tweens.Count; i++) {
2544  			Hashtable currentTween = tweens[i];
2545  			string targetType = (string)currentTween[&quot;type&quot;]+(string)currentTween[&quot;method&quot;];
2546  			targetType=targetType.Substring(0,type.Length);
2547  			if(targetType.ToLower() == type.ToLower()){
2548  				tweenCount++;
2549  			}
2550  		}	
2551  		return(tweenCount);
2552  	}			
2553  	public static int Count(GameObject target){
2554  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2555  		return(tweens.Length);
2556  	}
2557  	public static int Count(GameObject target, string type){
2558  		int tweenCount = 0;
2559  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2560  		foreach (iTween item in tweens){
2561  			string targetType = item.type+item.method;
2562  			targetType=targetType.Substring(0,type.Length);
2563  			if(targetType.ToLower() == type.ToLower()){
2564  				tweenCount++;
2565  			}
2566  		}
2567  		return(tweenCount);
2568  	}	
2569  	public static void Stop(){
2570  		for (int i = 0; i &lt; tweens.Count; i++) {
2571  			Hashtable currentTween = tweens[i];
2572  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2573  			Stop(target);
2574  		}
2575  		tweens.Clear();
2576  	}	
2577  	public static void Stop(string type){
2578  		ArrayList stopArray = new ArrayList();
2579  		for (int i = 0; i &lt; tweens.Count; i++) {
2580  			Hashtable currentTween = tweens[i];
2581  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2582  			stopArray.Insert(stopArray.Count,target);
2583  		}
2584  		for (int i = 0; i &lt; stopArray.Count; i++) {
2585  			Stop((GameObject)stopArray[i],type);
2586  		}
2587  	}		
2588  	public static void StopByName(string name){
2589  		ArrayList stopArray = new ArrayList();
2590  		for (int i = 0; i &lt; tweens.Count; i++) {
2591  			Hashtable currentTween = tweens[i];
2592  			GameObject target = (GameObject)currentTween[&quot;target&quot;];
2593  			stopArray.Insert(stopArray.Count,target);
2594  		}
2595  		for (int i = 0; i &lt; stopArray.Count; i++) {
2596  			StopByName((GameObject)stopArray[i],name);
2597  		}
2598  	}
2599  	public static void Stop(GameObject target){
2600  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2601  		foreach (iTween item in tweens){
2602  			item.Dispose();
2603  		}
2604  	}
2605  	public static void Stop(GameObject target, bool includechildren){
2606  		Stop(target);
2607  		if(includechildren){
2608  			foreach(Transform child in target.transform){
2609  				Stop(child.gameObject,true);
2610  			}			
2611  		}
2612  	}	
2613  	public static void Stop(GameObject target, string type){
2614  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2615  		foreach (iTween item in tweens){
2616  			string targetType = item.type+item.method;
2617  			targetType=targetType.Substring(0,type.Length);
2618  			if(targetType.ToLower() == type.ToLower()){
2619  				item.Dispose();
2620  			}
2621  		}
2622  	}
2623  	public static void StopByName(GameObject target, string name){
2624  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2625  		foreach (iTween item in tweens){
2626  			if(item._name == name){
2627  				item.Dispose();
2628  			}
2629  		}
2630  	}
2631  	public static void Stop(GameObject target, string type, bool includechildren){
2632  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2633  		foreach (iTween item in tweens){
2634  			string targetType = item.type+item.method;
2635  			targetType=targetType.Substring(0,type.Length);
2636  			if(targetType.ToLower() == type.ToLower()){
2637  				item.Dispose();
2638  			}
2639  		}
2640  		if(includechildren){
2641  			foreach(Transform child in target.transform){
2642  				Stop(child.gameObject,type,true);
2643  			}			
2644  		}		
2645  	}
2646  	public static void StopByName(GameObject target, string name, bool includechildren){
2647  		Component[] tweens = target.GetComponents&lt;iTween&gt;();
2648  		foreach (iTween item in tweens){
2649  			if(item._name == name){
2650  				item.Dispose();
2651  			}
2652  		}
2653  		if(includechildren){
2654  			foreach(Transform child in target.transform){
2655  				StopByName(child.gameObject,name,true);
2656  			}			
2657  		}		
2658  	}
2659  	public static Hashtable Hash(params object[] args){
2660  		Hashtable hashTable = new Hashtable(args.Length/2);
2661  		if (args.Length %2 != 0) {
2662  			Debug.LogError(&quot;Tween Error: Hash requires an even number of arguments!&quot;); 
2663  			return null;
2664  		}else{
2665  			int i = 0;
2666  			while(i &lt; args.Length - 1) {
2667  				hashTable.Add(args[i], args[i+1]);
2668  				i += 2;
2669  			}
2670  			return hashTable;
2671  		}
2672  	}	
2673  	#endregion		
2674  	#region Component Segments
2675  	private iTween(Hashtable h) {
2676  		tweenArguments = h;	
2677  	}
2678  	void Awake(){
2679  		thisTransform = transform;
2680  		RetrieveArgs();
2681          lastRealTime = Time.realtimeSinceStartup; 
2682  	}
2683  	IEnumerator Start(){
2684  		if(delay &gt; 0){
2685  			yield return StartCoroutine(&quot;TweenDelay&quot;);
2686  		}
2687  		TweenStart();
2688  	}	
2689  	void Update(){
2690  		if(isRunning &amp;&amp; !physics){
2691  			if(!reverse){
2692  				if(percentage&lt;1f){
2693  					TweenUpdate();
2694  				}else{
2695  					TweenComplete();	
2696  				}
2697  			}else{
2698  				if(percentage&gt;0){
2699  					TweenUpdate();
2700  				}else{
2701  					TweenComplete();	
2702  				}
2703  			}
2704  		}
2705  	}
2706  	void FixedUpdate(){
2707  		if(isRunning &amp;&amp; physics){
2708  			if(!reverse){
2709  				if(percentage&lt;1f){
2710  					TweenUpdate();
2711  				}else{
2712  					TweenComplete();	
2713  				}
2714  			}else{
2715  				if(percentage&gt;0){
2716  					TweenUpdate();
2717  				}else{
2718  					TweenComplete();	
2719  				}
2720  			}
2721  		}	
2722  	}
2723  	void LateUpdate(){
2724  		if(tweenArguments.Contains(&quot;looktarget&quot;) &amp;&amp; isRunning){
2725  			if(type ==&quot;move&quot; || type ==&quot;shake&quot; || type==&quot;punch&quot;){
2726  				LookUpdate(gameObject,tweenArguments);
2727  			}			
2728  		}
2729  	}
2730  	void OnEnable(){
2731  		if(isRunning){
2732  			EnableKinematic();
2733  		}
2734  		if(isPaused){
2735  			isPaused=false;
2736  			if(delay &gt; 0){
2737  				wasPaused=true;
2738  				ResumeDelay();
2739  			}
2740  		}
2741  	}
2742  	void OnDisable(){
2743  		DisableKinematic();
2744  	}
2745  	#endregion
2746  	#region Internal Helpers
2747  	private static void DrawLineHelper(Vector3[] line, Color color, string method){
2748  		Gizmos.color=color;
2749  		for (int i = 0; i &lt; line.Length-1; i++) {
2750  			if(method == &quot;gizmos&quot;){
2751  				Gizmos.DrawLine(line[i], line[i+1]);;
2752  			}else if(method == &quot;handles&quot;){
2753  				Debug.LogError(&quot;iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!&quot;);
2754  			}
2755  		}
2756  	}		
2757  	private static void DrawPathHelper(Vector3[] path, Color color, string method){
2758  		Vector3[] vector3s = PathControlPointGenerator(path);
2759  		Vector3 prevPt = Interp(vector3s,0);
2760  		Gizmos.color=color;
2761  		int SmoothAmount = path.Length*20;
2762  		for (int i = 1; i &lt;= SmoothAmount; i++) {
2763  			float pm = (float) i / SmoothAmount;
2764  			Vector3 currPt = Interp(vector3s,pm);
2765  			if(method == &quot;gizmos&quot;){
2766  				Gizmos.DrawLine(currPt, prevPt);
2767  			}else if(method == &quot;handles&quot;){
2768  				Debug.LogError(&quot;iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!&quot;);
2769  			}
2770  			prevPt = currPt;
2771  		}
2772  	}	
2773  	private static Vector3[] PathControlPointGenerator(Vector3[] path){
2774  		Vector3[] suppliedPath;
2775  		Vector3[] vector3s;
2776  		suppliedPath = path;
2777  		int offset = 2;
2778  		vector3s = new Vector3[suppliedPath.Length+offset];
2779  		Array.Copy(suppliedPath,0,vector3s,1,suppliedPath.Length);
2780  		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
2781  		vector3s[vector3s.Length-1] = vector3s[vector3s.Length-2] + (vector3s[vector3s.Length-2] - vector3s[vector3s.Length-3]);
2782  		if(vector3s[1] == vector3s[vector3s.Length-2]){
2783  			Vector3[] tmpLoopSpline = new Vector3[vector3s.Length];
2784  			Array.Copy(vector3s,tmpLoopSpline,vector3s.Length);
2785  			tmpLoopSpline[0]=tmpLoopSpline[tmpLoopSpline.Length-3];
2786  			tmpLoopSpline[tmpLoopSpline.Length-1]=tmpLoopSpline[2];
2787  			vector3s=new Vector3[tmpLoopSpline.Length];
2788  			Array.Copy(tmpLoopSpline,vector3s,tmpLoopSpline.Length);
2789  		}	
2790  		return(vector3s);
2791  	}
2792  	private static Vector3 Interp(Vector3[] pts, float t){
2793  		int numSections = pts.Length - 3;
2794  		int currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
2795  		float u = t * (float) numSections - (float) currPt;
2796  		Vector3 a = pts[currPt];
2797  		Vector3 b = pts[currPt + 1];
2798  		Vector3 c = pts[currPt + 2];
2799  		Vector3 d = pts[currPt + 3];
2800  		return .5f * (
2801  			(-a + 3f * b - 3f * c + d) * (u * u * u)
2802  			+ (2f * a - 5f * b + 4f * c - d) * (u * u)
2803  			+ (-a + c) * u
2804  			+ 2f * b
2805  		);
2806  	}	
2807  	private class CRSpline {
2808  		public Vector3[] pts;
2809  		public CRSpline(params Vector3[] pts) {
2810  			this.pts = new Vector3[pts.Length];
2811  			Array.Copy(pts, this.pts, pts.Length);
2812  		}
2813  		public Vector3 Interp(float t) {
2814  			int numSections = pts.Length - 3;
2815  			int currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);
2816  			float u = t * (float) numSections - (float) currPt;
2817  			Vector3 a = pts[currPt];
2818  			Vector3 b = pts[currPt + 1];
2819  			Vector3 c = pts[currPt + 2];
2820  			Vector3 d = pts[currPt + 3];
2821  			return .5f*((-a+3f*b-3f*c+d)*(u*u*u)+(2f*a-5f*b+4f*c-d)*(u*u)+(-a+c)*u+2f*b);
2822  		}	
2823  	}	
2824  	static void Launch(GameObject target, Hashtable args){
2825  		if(!args.Contains(&quot;id&quot;)){
2826  			args[&quot;id&quot;] = GenerateID();
2827  		}
2828  		if(!args.Contains(&quot;target&quot;)){
2829  			args[&quot;target&quot;] = target;
2830  		}		
2831  		tweens.Insert (0, args);
2832  		target.AddComponent&lt;iTween&gt;();
2833  	}		
2834  	static Hashtable CleanArgs(Hashtable args){
2835  		Hashtable argsCopy = new Hashtable(args.Count);
2836  		Hashtable argsCaseUnified = new Hashtable(args.Count);
2837  		foreach (DictionaryEntry item in args) {
2838  			argsCopy.Add(item.Key, item.Value);
2839  		}
2840  		foreach (DictionaryEntry item in argsCopy) {
2841  			if(item.Value.GetType() == typeof(System.Int32)){
2842  				int original = (int)item.Value;
2843  				float casted = (float)original;
2844  				args[item.Key] = casted;
2845  			}
2846  			if(item.Value.GetType() == typeof(System.Double)){
2847  				double original = (double)item.Value;
2848  				float casted = (float)original;
2849  				args[item.Key] = casted;
2850  			}
2851  		}	
2852  		foreach (DictionaryEntry item in args) {
2853  			argsCaseUnified.Add(item.Key.ToString().ToLower(), item.Value);
2854  		}	
2855  		args = argsCaseUnified;
2856  		return args;
2857  	}	
2858  	static string GenerateID(){
2859  		return System.Guid.NewGuid().ToString();
2860  	}	
2861  	void RetrieveArgs(){
2862  		foreach (Hashtable item in tweens) {
2863  			if((GameObject)item[&quot;target&quot;] == gameObject){
2864  				tweenArguments=item;
2865  				break;
2866  			}
2867  		}
2868  		id=(string)tweenArguments[&quot;id&quot;];
2869  		type=(string)tweenArguments[&quot;type&quot;];
2870  		_name=(string)tweenArguments[&quot;name&quot;];
2871  		method=(string)tweenArguments[&quot;method&quot;];
2872  		if(tweenArguments.Contains(&quot;time&quot;)){
2873  			time=(float)tweenArguments[&quot;time&quot;];
2874  		}else{
2875  			time=Defaults.time;
2876  		}
2877  		if(GetComponent&lt;Rigidbody&gt;() != null){
2878  			physics=true;
2879  		}
2880  		if(tweenArguments.Contains(&quot;delay&quot;)){
2881  			delay=(float)tweenArguments[&quot;delay&quot;];
2882  		}else{
2883  			delay=Defaults.delay;
2884  		}
2885  		if(tweenArguments.Contains(&quot;namedcolorvalue&quot;)){
2886  			if(tweenArguments[&quot;namedcolorvalue&quot;].GetType() == typeof(NamedValueColor)){
2887  				namedcolorvalue=(NamedValueColor)tweenArguments[&quot;namedcolorvalue&quot;];
2888  			}else{
2889  				try {
2890  					namedcolorvalue=(NamedValueColor)Enum.Parse(typeof(NamedValueColor),(string)tweenArguments[&quot;namedcolorvalue&quot;],true); 
2891  				} catch {
2892  					Debug.LogWarning(&quot;iTween: Unsupported namedcolorvalue supplied! Default will be used.&quot;);
2893  					namedcolorvalue = iTween.NamedValueColor._Color;
2894  				}
2895  			}			
2896  		}else{
2897  			namedcolorvalue=Defaults.namedColorValue;	
2898  		}	
2899  		if(tweenArguments.Contains(&quot;looptype&quot;)){
2900  			if(tweenArguments[&quot;looptype&quot;].GetType() == typeof(LoopType)){
2901  				loopType=(LoopType)tweenArguments[&quot;looptype&quot;];
2902  			}else{
2903  				try {
2904  					loopType=(LoopType)Enum.Parse(typeof(LoopType),(string)tweenArguments[&quot;looptype&quot;],true); 
2905  				} catch {
2906  					Debug.LogWarning(&quot;iTween: Unsupported loopType supplied! Default will be used.&quot;);
2907  					loopType = iTween.LoopType.none;	
2908  				}
2909  			}			
2910  		}else{
2911  			loopType = iTween.LoopType.none;	
2912  		}			
2913  		if(tweenArguments.Contains(&quot;easetype&quot;)){
2914  			if(tweenArguments[&quot;easetype&quot;].GetType() == typeof(EaseType)){
2915  				easeType=(EaseType)tweenArguments[&quot;easetype&quot;];
2916  			}else{
2917  				try {
2918  					easeType=(EaseType)Enum.Parse(typeof(EaseType),(string)tweenArguments[&quot;easetype&quot;],true); 
2919  				} catch {
2920  					Debug.LogWarning(&quot;iTween: Unsupported easeType supplied! Default will be used.&quot;);
2921  					easeType=Defaults.easeType;
2922  				}
2923  			}
2924  		}else{
2925  			easeType=Defaults.easeType;
2926  		}
2927  		if(tweenArguments.Contains(&quot;space&quot;)){
2928  			if(tweenArguments[&quot;space&quot;].GetType() == typeof(Space)){
2929  				space=(Space)tweenArguments[&quot;space&quot;];
2930  			}else{
2931  				try {
2932  					space=(Space)Enum.Parse(typeof(Space),(string)tweenArguments[&quot;space&quot;],true); 	
2933  				} catch {
2934  					Debug.LogWarning(&quot;iTween: Unsupported space supplied! Default will be used.&quot;);
2935  					space = Defaults.space;
2936  				}
2937  			}			
2938  		}else{
2939  			space = Defaults.space;
2940  		}
2941  		if(tweenArguments.Contains(&quot;islocal&quot;)){
2942  			isLocal = (bool)tweenArguments[&quot;islocal&quot;];
2943  		}else{
2944  			isLocal = Defaults.isLocal;
2945  		}
2946          if (tweenArguments.Contains(&quot;ignoretimescale&quot;))
2947          {
2948              useRealTime = (bool)tweenArguments[&quot;ignoretimescale&quot;];
2949          }
2950          else
2951          {
2952              useRealTime = Defaults.useRealTime;
2953          }
2954  		GetEasingFunction();
2955  	}	
2956  	void GetEasingFunction(){
2957  		switch (easeType){
2958  		case EaseType.easeInQuad:
2959  			ease  = new EasingFunction(easeInQuad);
2960  			break;
2961  		case EaseType.easeOutQuad:
2962  			ease = new EasingFunction(easeOutQuad);
2963  			break;
2964  		case EaseType.easeInOutQuad:
2965  			ease = new EasingFunction(easeInOutQuad);
2966  			break;
2967  		case EaseType.easeInCubic:
2968  			ease = new EasingFunction(easeInCubic);
2969  			break;
2970  		case EaseType.easeOutCubic:
2971  			ease = new EasingFunction(easeOutCubic);
2972  			break;
2973  		case EaseType.easeInOutCubic:
2974  			ease = new EasingFunction(easeInOutCubic);
2975  			break;
2976  		case EaseType.easeInQuart:
2977  			ease = new EasingFunction(easeInQuart);
2978  			break;
2979  		case EaseType.easeOutQuart:
2980  			ease = new EasingFunction(easeOutQuart);
2981  			break;
2982  		case EaseType.easeInOutQuart:
2983  			ease = new EasingFunction(easeInOutQuart);
2984  			break;
2985  		case EaseType.easeInQuint:
2986  			ease = new EasingFunction(easeInQuint);
2987  			break;
2988  		case EaseType.easeOutQuint:
2989  			ease = new EasingFunction(easeOutQuint);
2990  			break;
2991  		case EaseType.easeInOutQuint:
2992  			ease = new EasingFunction(easeInOutQuint);
2993  			break;
2994  		case EaseType.easeInSine:
2995  			ease = new EasingFunction(easeInSine);
2996  			break;
2997  		case EaseType.easeOutSine:
2998  			ease = new EasingFunction(easeOutSine);
2999  			break;
3000  		case EaseType.easeInOutSine:
3001  			ease = new EasingFunction(easeInOutSine);
3002  			break;
3003  		case EaseType.easeInExpo:
3004  			ease = new EasingFunction(easeInExpo);
3005  			break;
3006  		case EaseType.easeOutExpo:
3007  			ease = new EasingFunction(easeOutExpo);
3008  			break;
3009  		case EaseType.easeInOutExpo:
3010  			ease = new EasingFunction(easeInOutExpo);
3011  			break;
3012  		case EaseType.easeInCirc:
3013  			ease = new EasingFunction(easeInCirc);
3014  			break;
3015  		case EaseType.easeOutCirc:
3016  			ease = new EasingFunction(easeOutCirc);
3017  			break;
3018  		case EaseType.easeInOutCirc:
3019  			ease = new EasingFunction(easeInOutCirc);
3020  			break;
3021  		case EaseType.linear:
3022  			ease = new EasingFunction(linear);
3023  			break;
3024  		case EaseType.spring:
3025  			ease = new EasingFunction(spring);
3026  			break;
3027  		case EaseType.easeInBounce:
3028  			ease = new EasingFunction(easeInBounce);
3029  			break;
3030  		case EaseType.easeOutBounce:
3031  			ease = new EasingFunction(easeOutBounce);
3032  			break;
3033  		case EaseType.easeInOutBounce:
3034  			ease = new EasingFunction(easeInOutBounce);
3035  			break;
3036  		case EaseType.easeInBack:
3037  			ease = new EasingFunction(easeInBack);
3038  			break;
3039  		case EaseType.easeOutBack:
3040  			ease = new EasingFunction(easeOutBack);
3041  			break;
3042  		case EaseType.easeInOutBack:
3043  			ease = new EasingFunction(easeInOutBack);
3044  			break;
3045  		case EaseType.easeInElastic:
3046  			ease = new EasingFunction(easeInElastic);
3047  			break;
3048  		case EaseType.easeOutElastic:
3049  			ease = new EasingFunction(easeOutElastic);
3050  			break;
3051  		case EaseType.easeInOutElastic:
3052  			ease = new EasingFunction(easeInOutElastic);
3053  			break;
3054  		}
3055  	}
3056  	void UpdatePercentage(){
3057  	        if (useRealTime)
3058  	        {
3059  	            runningTime += (Time.realtimeSinceStartup - lastRealTime);      
3060  	        }
3061  	        else
3062  	        {
3063  	            runningTime += Time.deltaTime;
3064  	        }
3065  			if(reverse){
3066  				percentage = 1 - runningTime/time;	
3067  			}else{
3068  				percentage = runningTime/time;	
3069  			}
3070  	        lastRealTime = Time.realtimeSinceStartup; 
3071  	}
3072  	void CallBack(string callbackType){
3073  		if (tweenArguments.Contains(callbackType) &amp;&amp; !tweenArguments.Contains(&quot;ischild&quot;)) {
3074  			GameObject target;
3075  			if (tweenArguments.Contains(callbackType+&quot;target&quot;)) {
3076  				target=(GameObject)tweenArguments[callbackType+&quot;target&quot;];
3077  			}else{
3078  				target=gameObject;	
3079  			}
3080  			if (tweenArguments[callbackType].GetType() == typeof(System.String)) {
3081  				target.SendMessage((string)tweenArguments[callbackType],(object)tweenArguments[callbackType+&quot;params&quot;],SendMessageOptions.DontRequireReceiver);
3082  			}else{
3083  				Debug.LogError(&quot;iTween Error: Callback method references must be passed as a String!&quot;);
3084  				Destroy (this);
3085  			}
3086  		}
3087  	}
3088  	void Dispose(){
3089  		for (int i = 0; i &lt; tweens.Count; i++) {
3090  			Hashtable tweenEntry = tweens[i];
3091  			if ((string)tweenEntry[&quot;id&quot;] == id){
3092  				tweens.RemoveAt(i);
3093  				break;
3094  			}
3095  		}
3096  		Destroy(this);
3097  	}	
3098  	void ConflictCheck(){
3099  		Component[] tweens = GetComponents&lt;iTween&gt;();
3100  		foreach (iTween item in tweens) {
3101  			if(item.type == &quot;value&quot;){
3102  				return;
3103  			}else if(item.isRunning &amp;&amp; item.type==type){
3104  				if (item.method != method) {
3105  					return;
3106  				}				
3107  				if(item.tweenArguments.Count != tweenArguments.Count){
3108  					item.Dispose();
3109  					return;
3110  				}
3111  				foreach (DictionaryEntry currentProp in tweenArguments) {
3112  					if(!item.tweenArguments.Contains(currentProp.Key)){
3113  						item.Dispose();
3114  						return;
3115  					}else{
3116  						if(!item.tweenArguments[currentProp.Key].Equals(tweenArguments[currentProp.Key]) &amp;&amp; (string)currentProp.Key != &quot;id&quot;){
3117  							item.Dispose();
3118  							return;
3119  						}
3120  					}
3121  				}
3122  				Dispose();
3123  			}
3124  		}
3125  	}
3126  	void EnableKinematic(){
3127  	}
3128  	void DisableKinematic(){
3129  	}
3130  	void ResumeDelay(){
3131  		StartCoroutine(&quot;TweenDelay&quot;);
3132  	}	
3133  	#endregion	
3134  	#region Easing Curves
3135  	private float linear(float start, float end, float value){
3136  		return Mathf.Lerp(start, end, value);
3137  	}
3138  	private float clerp(float start, float end, float value){
3139  		float min = 0.0f;
3140  		float max = 360.0f;
3141  		float half = Mathf.Abs((max - min) * 0.5f);
3142  		float retval = 0.0f;
3143  		float diff = 0.0f;
3144  		if ((end - start) &lt; -half){
3145  			diff = ((max - start) + end) * value;
3146  			retval = start + diff;
3147  		}else if ((end - start) &gt; half){
3148  			diff = -((max - end) + start) * value;
3149  			retval = start + diff;
3150  		}else retval = start + (end - start) * value;
3151  		return retval;
3152      }
3153  	private float spring(float start, float end, float value){
3154  		value = Mathf.Clamp01(value);
3155  		value = (Mathf.Sin(value * Mathf.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + (1.2f * (1f - value)));
3156  		return start + (end - start) * value;
3157  	}
3158  	private float easeInQuad(float start, float end, float value){
3159  		end -= start;
3160  		return end * value * value + start;
3161  	}
3162  	private float easeOutQuad(float start, float end, float value){
3163  		end -= start;
3164  		return -end * value * (value - 2) + start;
3165  	}
3166  	private float easeInOutQuad(float start, float end, float value){
3167  		value /= .5f;
3168  		end -= start;
3169  		if (value &lt; 1) return end * 0.5f * value * value + start;
3170  		value--;
3171  		return -end * 0.5f * (value * (value - 2) - 1) + start;
3172  	}
3173  	private float easeInCubic(float start, float end, float value){
3174  		end -= start;
3175  		return end * value * value * value + start;
3176  	}
3177  	private float easeOutCubic(float start, float end, float value){
3178  		value--;
3179  		end -= start;
3180  		return end * (value * value * value + 1) + start;
3181  	}
3182  	private float easeInOutCubic(float start, float end, float value){
3183  		value /= .5f;
3184  		end -= start;
3185  		if (value &lt; 1) return end * 0.5f * value * value * value + start;
3186  		value -= 2;
3187  		return end * 0.5f * (value * value * value + 2) + start;
3188  	}
3189  	private float easeInQuart(float start, float end, float value){
3190  		end -= start;
3191  		return end * value * value * value * value + start;
3192  	}
3193  	private float easeOutQuart(float start, float end, float value){
3194  		value--;
3195  		end -= start;
3196  		return -end * (value * value * value * value - 1) + start;
3197  	}
3198  	private float easeInOutQuart(float start, float end, float value){
3199  		value /= .5f;
3200  		end -= start;
3201  		if (value &lt; 1) return end * 0.5f * value * value * value * value + start;
3202  		value -= 2;
3203  		return -end * 0.5f * (value * value * value * value - 2) + start;
3204  	}
3205  	private float easeInQuint(float start, float end, float value){
3206  		end -= start;
3207  		return end * value * value * value * value * value + start;
3208  	}
3209  	private float easeOutQuint(float start, float end, float value){
3210  		value--;
3211  		end -= start;
3212  		return end * (value * value * value * value * value + 1) + start;
3213  	}
3214  	private float easeInOutQuint(float start, float end, float value){
3215  		value /= .5f;
3216  		end -= start;
3217  		if (value &lt; 1) return end * 0.5f * value * value * value * value * value + start;
3218  		value -= 2;
3219  		return end * 0.5f * (value * value * value * value * value + 2) + start;
3220  	}
3221  	private float easeInSine(float start, float end, float value){
3222  		end -= start;
3223  		return -end * Mathf.Cos(value * (Mathf.PI * 0.5f)) + end + start;
3224  	}
3225  	private float easeOutSine(float start, float end, float value){
3226  		end -= start;
3227  		return end * Mathf.Sin(value * (Mathf.PI * 0.5f)) + start;
3228  	}
3229  	private float easeInOutSine(float start, float end, float value){
3230  		end -= start;
3231  		return -end * 0.5f * (Mathf.Cos(Mathf.PI * value) - 1) + start;
3232  	}
3233  	private float easeInExpo(float start, float end, float value){
3234  		end -= start;
3235  		return end * Mathf.Pow(2, 10 * (value - 1)) + start;
3236  	}
3237  	private float easeOutExpo(float start, float end, float value){
3238  		end -= start;
3239  		return end * (-Mathf.Pow(2, -10 * value ) + 1) + start;
3240  	}
3241  	private float easeInOutExpo(float start, float end, float value){
3242  		value /= .5f;
3243  		end -= start;
3244  		if (value &lt; 1) return end * 0.5f * Mathf.Pow(2, 10 * (value - 1)) + start;
3245  		value--;
3246  		return end * 0.5f * (-Mathf.Pow(2, -10 * value) + 2) + start;
3247  	}
3248  	private float easeInCirc(float start, float end, float value){
3249  		end -= start;
3250  		return -end * (Mathf.Sqrt(1 - value * value) - 1) + start;
3251  	}
3252  	private float easeOutCirc(float start, float end, float value){
3253  		value--;
3254  		end -= start;
3255  		return end * Mathf.Sqrt(1 - value * value) + start;
3256  	}
3257  	private float easeInOutCirc(float start, float end, float value){
3258  		value /= .5f;
3259  		end -= start;
3260  		if (value &lt; 1) return -end * 0.5f * (Mathf.Sqrt(1 - value * value) - 1) + start;
3261  		value -= 2;
3262  		return end * 0.5f * (Mathf.Sqrt(1 - value * value) + 1) + start;
3263  	}
3264  	private float easeInBounce(float start, float end, float value){
3265  		end -= start;
3266  		float d = 1f;
3267  		return end - easeOutBounce(0, end, d-value) + start;
3268  	}
3269  	private float easeOutBounce(float start, float end, float value){
3270  		value /= 1f;
3271  		end -= start;
3272  		if (value &lt; (1 / 2.75f)){
3273  			return end * (7.5625f * value * value) + start;
3274  		}else if (value &lt; (2 / 2.75f)){
3275  			value -= (1.5f / 2.75f);
3276  			return end * (7.5625f * (value) * value + .75f) + start;
3277  		}else if (value &lt; (2.5 / 2.75)){
3278  			value -= (2.25f / 2.75f);
3279  			return end * (7.5625f * (value) * value + .9375f) + start;
3280  		}else{
3281  			value -= (2.625f / 2.75f);
3282  			return end * (7.5625f * (value) * value + .984375f) + start;
3283  		}
3284  	}
3285  	private float easeInOutBounce(float start, float end, float value){
3286  		end -= start;
3287  		float d = 1f;
3288  		if (value &lt; d* 0.5f) return easeInBounce(0, end, value*2) * 0.5f + start;
3289  		else return easeOutBounce(0, end, value*2-d) * 0.5f + end*0.5f + start;
3290  	}
3291  	private float easeInBack(float start, float end, float value){
3292  		end -= start;
3293  		value /= 1;
3294  		float s = 1.70158f;
3295  		return end * (value) * value * ((s + 1) * value - s) + start;
3296  	}
3297  	private float easeOutBack(float start, float end, float value){
3298  		float s = 1.70158f;
3299  		end -= start;
3300  		value = (value) - 1;
3301  		return end * ((value) * value * ((s + 1) * value + s) + 1) + start;
3302  	}
3303  	private float easeInOutBack(float start, float end, float value){
3304  		float s = 1.70158f;
3305  		end -= start;
3306  		value /= .5f;
3307  		if ((value) &lt; 1){
3308  			s *= (1.525f);
3309  			return end * 0.5f * (value * value * (((s) + 1) * value - s)) + start;
3310  		}
3311  		value -= 2;
3312  		s *= (1.525f);
3313  		return end * 0.5f * ((value) * value * (((s) + 1) * value + s) + 2) + start;
3314  	}
3315  	private float punch(float amplitude, float value){
3316  		float s = 9;
3317  		if (value == 0){
3318  			return 0;
3319  		}
3320  		else if (value == 1){
3321  			return 0;
3322  		}
3323  		float period = 1 * 0.3f;
3324  		s = period / (2 * Mathf.PI) * Mathf.Asin(0);
3325  		return (amplitude * Mathf.Pow(2, -10 * value) * Mathf.Sin((value * 1 - s) * (2 * Mathf.PI) / period));
3326      }
3327  	private float easeInElastic(float start, float end, float value){
3328  		end -= start;
3329  		float d = 1f;
3330  		float p = d * .3f;
3331  		float s = 0;
3332  		float a = 0;
3333  		if (value == 0) return start;
3334  		if ((value /= d) == 1) return start + end;
3335  		if (a == 0f || a &lt; Mathf.Abs(end)){
3336  			a = end;
3337  			s = p / 4;
3338  			}else{
3339  			s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
3340  		}
3341  		return -(a * Mathf.Pow(2, 10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p)) + start;
3342  	}		
3343  	private float easeOutElastic(float start, float end, float value){
3344  		end -= start;
3345  		float d = 1f;
3346  		float p = d * .3f;
3347  		float s = 0;
3348  		float a = 0;
3349  		if (value == 0) return start;
3350  		if ((value /= d) == 1) return start + end;
3351  		if (a == 0f || a &lt; Mathf.Abs(end)){
3352  			a = end;
3353  			s = p * 0.25f;
3354  			}else{
3355  			s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
3356  		}
3357  		return (a * Mathf.Pow(2, -10 * value) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p) + end + start);
3358  	}		
3359  	private float easeInOutElastic(float start, float end, float value){
3360  		end -= start;
3361  		float d = 1f;
3362  		float p = d * .3f;
3363  		float s = 0;
3364  		float a = 0;
3365  		if (value == 0) return start;
3366  		if ((value /= d*0.5f) == 2) return start + end;
3367  		if (a == 0f || a &lt; Mathf.Abs(end)){
3368  			a = end;
3369  			s = p / 4;
3370  			}else{
3371  			s = p / (2 * Mathf.PI) * Mathf.Asin(end / a);
3372  		}
3373  		if (value &lt; 1) return -0.5f * (a * Mathf.Pow(2, 10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p)) + start;
3374  		return a * Mathf.Pow(2, -10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p) * 0.5f + end + start;
3375  	}		
3376  	#endregion	
3377  	#region Deprecated and Renamed
3378  	#endregion
3379  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-iTween_121.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from dotween-MDEwOlJlcG9zaXRvcnkzMjQ3NTE2Mg==-flat-iTween.cs</div>
                </div>
                <div class="column column_space"><pre><code>1937  			vector3s[0] = target.transform.localEulerAngles;
1938  		}else{
1939  			vector3s[0] = target.transform.eulerAngles;	
1940  		}
1941  		if(args.Contains(&quot;rotation&quot;)){
1942  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)){
1943  				Transform trans = (Transform)args[&quot;rotation&quot;];
1944  				vector3s[1]=trans.eulerAngles;
1945  			}else if(args[&quot;rotation&quot;].GetType() == typeof(Vector3)){
1946  				vector3s[1]=(Vector3)args[&quot;rotation&quot;];
1947  			}	
1948  		}
1949  		vector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
1950  		vector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
1951  		vector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
1952  		if(isLocal){
1953  			target.transform.localEulerAngles=vector3s[3];
1954  		}else{
1955  			target.transform.eulerAngles=vector3s[3];
1956  		}
1957  		if(target.rigidbody != null){
</pre></code></div>
                <div class="column column_space"><pre><code>1937  			vector3s[0] = target.transform.localEulerAngles;
1938  		}else{
1939  			vector3s[0] = target.transform.eulerAngles;	
1940  		}
1941  		if(args.Contains(&quot;rotation&quot;)){
1942  			if (args[&quot;rotation&quot;].GetType() == typeof(Transform)){
1943  				Transform trans = (Transform)args[&quot;rotation&quot;];
1944  				vector3s[1]=trans.eulerAngles;
1945  			}else if(args[&quot;rotation&quot;].GetType() == typeof(Vector3)){
1946  				vector3s[1]=(Vector3)args[&quot;rotation&quot;];
1947  			}	
1948  		}
1949  		vector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);
1950  		vector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);
1951  		vector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);
1952  		if(isLocal){
1953  			target.transform.localEulerAngles=vector3s[3];
1954  		}else{
1955  			target.transform.eulerAngles=vector3s[3];
1956  		}
1957  		if(target.GetComponent&lt;Rigidbody&gt;() != null){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    