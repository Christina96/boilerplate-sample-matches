
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-TimelineTests.cs</h3>
            <pre><code>1  using System;
2  using System.Threading.Tasks;
3  using AngleSharp.Css.Dom;
4  using AngleSharp.Html.Dom;
5  using Bunit;
6  using FluentAssertions;
7  using MudBlazor.UnitTests.TestComponents;
8  using NUnit.Framework;
9  namespace MudBlazor.UnitTests.Components
10  {
11      [TestFixture]
12      public class TimelineTests : BunitTest
13      {
14          [Test]
15          public void TimelineTest_DefaultValues()
16          {
17              var comp = Context.RenderComponent<MudTimeline>();
18              comp.Instance.TimelineOrientation.Should().Be(TimelineOrientation.Vertical);
19              comp.Instance.TimelinePosition.Should().Be(TimelinePosition.Alternate);
20              comp.Instance.TimelineAlign.Should().Be(TimelineAlign.Default);
21              comp.Instance.Reverse.Should().Be(false);
22              comp.Instance.DisableModifiers.Should().Be(false);
23          }
24          [Test]
25          public async Task TimelineTest()
26          {
27              var comp = Context.RenderComponent<TimelineTest>();
28              var timeline = comp.FindComponent<MudTimeline>().Instance;
29              timeline.Should().NotBeNull();
30              comp.WaitForAssertion(() => comp.FindAll("div.mud-timeline").Count.Should().Be(1));
31              comp.FindAll("div.mud-timeline-item").Count.Should().Be(5);
32              var items = comp.FindComponents<MudTimelineItem>();
33              items.Count.Should().Be(5);
<span onclick='openModal()' class='match'>34              for (var i = 1; i <= 4; i++)
35              {
</span>36                  await comp.InvokeAsync(() => timeline.MoveTo(i));
37                  timeline.SelectedIndex.Should().Be(i);
38                  timeline.SelectedContainer.Should().Be(items[i].Instance);
39              }
40              await comp.InvokeAsync(() => timeline.MoveTo(0));
41              timeline.SelectedIndex.Should().Be(0);
42              timeline.SelectedContainer.Should().Be(items[0].Instance);
43          }
44          [Test]
45          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Alternate, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
46          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Start, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
47          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Left, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
48          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Right, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
49          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.End, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
50          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Top, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-top" })]
51          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Bottom, false, new[] { "mud-timeline-horizontal", "mud-timeline-position-bottom" })]
52          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Alternate, false, new[] { "mud-timeline-vertical", "mud-timeline-position-alternate" })]
53          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Top, false, new[] { "mud-timeline-vertical", "mud-timeline-position-alternate" })]
54          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Bottom, false, new[] { "mud-timeline-vertical", "mud-timeline-position-alternate" })]
55          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Start, false, new[] { "mud-timeline-vertical", "mud-timeline-position-start" })]
56          [TestCase(TimelineOrientation.Vertical, TimelinePosition.End, false, new[] { "mud-timeline-vertical", "mud-timeline-position-end" })]
57          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Left, false, new[] { "mud-timeline-vertical", "mud-timeline-position-start" })]
58          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Right, false, new[] { "mud-timeline-vertical", "mud-timeline-position-end" })]
59          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Alternate, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
60          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Start, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
61          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Left, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
62          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Right, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
63          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.End, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-alternate" })]
64          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Top, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-top" })]
65          [TestCase(TimelineOrientation.Horizontal, TimelinePosition.Bottom, true, new[] { "mud-timeline-horizontal", "mud-timeline-position-bottom" })]
66          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Alternate, true, new[] { "mud-timeline-vertical", "mud-timeline-position-alternate" })]
67          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Top, true, new[] { "mud-timeline-vertical", "mud-timeline-position-alternate" })]
68          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Bottom, true, new[] { "mud-timeline-vertical", "mud-timeline-position-alternate" })]
69          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Start, true, new[] { "mud-timeline-vertical", "mud-timeline-position-start" })]
70          [TestCase(TimelineOrientation.Vertical, TimelinePosition.End, true, new[] { "mud-timeline-vertical", "mud-timeline-position-end" })]
71          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Left, true, new[] { "mud-timeline-vertical", "mud-timeline-position-end" })]
72          [TestCase(TimelineOrientation.Vertical, TimelinePosition.Right, true, new[] { "mud-timeline-vertical", "mud-timeline-position-start" })]
73          public void TimelineTest_Position(TimelineOrientation orientation, TimelinePosition position, bool rtl, string[] expectedClass)
74          {
75              var comp = Context.RenderComponent<TimelineTest>(p => p.AddCascadingValue("RightToLeft", rtl));
76              var timeline = comp.FindComponent<MudTimeline>();
77              timeline.SetParametersAndRender(p =>
78              {
79                  p.Add(x => x.TimelineOrientation, orientation);
80                  p.Add(x => x.TimelinePosition, position);
81              });
82              timeline.Nodes.Should().ContainSingle();
83              timeline.Nodes[0].Should().BeAssignableTo<IHtmlDivElement>();
84              (timeline.Nodes[0] as IHtmlDivElement).ClassList.Should().Contain(expectedClass);
85          }
86          [Test]
87          public void TimelineTest_SelectItem()
88          {
89              var comp = Context.RenderComponent<TimelineTest>();
90              var itemsDiv = comp.FindAll(".mud-timeline-item");
91              itemsDiv.Should().HaveCount(5);
92              for (int i = 0; i < 5; i++)
93              {
94                  itemsDiv[i].Click();
95                  comp.Instance.SelectedIndex.Should().Be(i);
96              }
97          }
98          [Test]
99          public void TimelineTest_DotStyles()
100          {
101              var comp = Context.RenderComponent<TimelineTest>();
102              var firstItem = comp.FindComponent<MudTimelineItem>();
103              comp.Find("div.mud-timeline-item-dot-inner").GetStyle()["background-color"].Should().Be("");
104              firstItem.SetParametersAndRender(p =>
105              {
106                  p.Add(t => t.DotStyle, "background-color: #ff0000");
107              });
108              comp.Find("div.mud-timeline-item-dot-inner").GetStyle()["background-color"].Should().Be("rgba(255, 0, 0, 1)");
109          }
110      }
111  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</h3>
            <pre><code>1  #if NET7_0_OR_GREATER
2  using System;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.Runtime.InteropServices;
6  using System.Text;
7  using System.Threading;
8  using System.Transactions;
9  using NUnit.Framework;
10  using static Npgsql.Tests.TestUtil;
11  namespace Npgsql.Tests;
12  [NonParallelizable]
13  public class DistributedTransactionTests : TestBase
14  {
15      [Test]
16      public void Two_connections_rollback_implicit_enlistment()
17      {
18          using var adminConn = OpenConnection();
19          var table = CreateTempTable(adminConn, "name TEXT");
20          var dataSource = EnlistOnDataSource;
21          using (new TransactionScope())
22          using (var conn1 = dataSource.OpenConnection())
23          using (var conn2 = dataSource.OpenConnection())
24          {
25              conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
26              conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')");
27          }
28          Retry(() =>
29          {
30              AssertNoDistributedIdentifier();
31              AssertNoPreparedTransactions();
32              AssertNumberOfRows(adminConn, table, 0);
33          });
34      }
35      [Test]
36      public void Two_connections_rollback_explicit_enlistment()
37      {
38          using var adminConn = OpenConnection();
39          var table = CreateTempTable(adminConn, "name TEXT");
40          var dataSource = EnlistOffDataSource;
41          using (var conn1 = dataSource.OpenConnection())
42          using (var conn2 = dataSource.OpenConnection())
43          using (new TransactionScope())
44          {
45              conn1.EnlistTransaction(Transaction.Current);
46              conn2.EnlistTransaction(Transaction.Current);
47              Assert.That(conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')"), Is.EqualTo(1), "Unexpected first insert rowcount");
48              Assert.That(conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')"), Is.EqualTo(1), "Unexpected second insert rowcount");
49          }
50          Retry(() =>
51          {
52              AssertNoDistributedIdentifier();
53              AssertNoPreparedTransactions();
54              AssertNumberOfRows(adminConn, table, 0);
55          });
56      }
57      [Test]
58      public void Two_connections_commit()
59      {
60          using var adminConn = OpenConnection();
61          var table = CreateTempTable(adminConn, "name TEXT");
62          var dataSource = EnlistOnDataSource;
63          using (var scope = new TransactionScope())
64          using (var conn1 = dataSource.OpenConnection())
65          using (var conn2 = dataSource.OpenConnection())
66          {
67              conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
68              conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')");
69              scope.Complete();
70          }
71          Retry(() =>
72          {
73              AssertNoDistributedIdentifier();
74              AssertNoPreparedTransactions();
75              AssertNumberOfRows(adminConn, table, 2);
76          });
77      }
78      [Test]
79      public void Two_connections_with_failure()
80      {
81          using var dataSource = CreateDataSource(csb => csb.Enlist = true);
82          using var adminConn = dataSource.OpenConnection();
83          var table = CreateTempTable(adminConn, "name TEXT");
84          using var scope = new TransactionScope();
85          using var conn1 = dataSource.OpenConnection();
86          using var conn2 = dataSource.OpenConnection();
87          conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
88          conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')");
89          conn1.ExecuteNonQuery($"SELECT pg_terminate_backend({conn2.ProcessID})");
90          scope.Complete();
91          Assert.That(() => scope.Dispose(), Throws.Exception.TypeOf<TransactionAbortedException>());
92          AssertNoDistributedIdentifier();
93          AssertNoPreparedTransactions();
94          AssertNumberOfRows(adminConn, table, 0);
95      }
96      [Test(Description = "Transaction race, bool distributed")]
97      [Explicit("Fails on Appveyor (https:&bsol;&bsol;ci.appveyor.com/project/roji/npgsql/build/3.3.0-250)")]
98      public void Transaction_race([Values(false, true)] bool distributed)
99      {
100          using var adminConn = OpenConnection();
101          var table = CreateTempTable(adminConn, "name TEXT");
102          var dataSource = EnlistOnDataSource;
103          for (var i = 1; i <= 100; i++)
104          {
105              var eventQueue = new ConcurrentQueue<TransactionEvent>();
106              try
107              {
108                  using (var tx = new TransactionScope())
109                  using (var conn1 = dataSource.OpenConnection())
110                  {
111                      eventQueue.Enqueue(new TransactionEvent("Scope started, connection enlisted"));
112                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
113                      eventQueue.Enqueue(new TransactionEvent("Insert done"));
114                      if (distributed)
115                      {
116                          EnlistResource.EscalateToDistributed(eventQueue);
117                          AssertHasDistributedIdentifier();
118                      }
119                      else
120                      {
121                          EnlistResource.EnlistVolatile(eventQueue);
122                          AssertNoDistributedIdentifier();
123                      }
124                      tx.Complete();
125                      eventQueue.Enqueue(new TransactionEvent("Scope completed"));
126                  }
127                  eventQueue.Enqueue(new TransactionEvent("Scope disposed"));
128                  AssertNoDistributedIdentifier();
129                  if (distributed)
130                  {
131                      const int maxLoop = 20;
132                      for (var j = 0; j < maxLoop; j++)
133                      {
134                          Thread.Sleep(10);
135                          try
136                          {
137                              AssertNumberOfRows(adminConn, table, i);
138                              break;
139                          }
140                          catch
141                          {
142                              if (j == maxLoop - 1)
143                                  throw;
144                          }
145                      }
146                  }
147                  else
148                      AssertNumberOfRows(adminConn, table, i);
149              }
150              catch (Exception ex)
151              {
152                  Assert.Fail(
153                      @"Failed at iteration {0}.
154  Events:
155  {1}
156  Exception {2}",
157                      i, FormatEventQueue(eventQueue), ex);
158              }
159          }
160      }
161      [Test(Description = "Connection reuse race after transaction, bool distributed"), Explicit]
162      public void Connection_reuse_race_after_transaction([Values(false, true)] bool distributed)
163      {
164          using var adminConn = OpenConnection();
165          var table = CreateTempTable(adminConn, "name TEXT");
166          var dataSource = EnlistOffDataSource;
167          for (var i = 1; i <= 100; i++)
168          {
169              var eventQueue = new ConcurrentQueue<TransactionEvent>();
170              try
171              {
172                  using var conn1 = dataSource.OpenConnection();
173                  using (var scope = new TransactionScope())
174                  {
175                      conn1.EnlistTransaction(Transaction.Current);
176                      eventQueue.Enqueue(new TransactionEvent("Scope started, connection enlisted"));
177                      if (distributed)
178                      {
179                          EnlistResource.EscalateToDistributed(eventQueue);
180                          AssertHasDistributedIdentifier();
181                      }
182                      else
183                      {
184                          EnlistResource.EnlistVolatile(eventQueue);
185                          AssertNoDistributedIdentifier();
186                      }
187                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
188                      eventQueue.Enqueue(new TransactionEvent("Insert done"));
189                      scope.Complete();
190                      eventQueue.Enqueue(new TransactionEvent("Scope completed"));
191                  }
192                  eventQueue.Enqueue(new TransactionEvent("Scope disposed"));
193                  Assert.DoesNotThrow(() => conn1.ExecuteScalar($"SELECT COUNT(*) FROM {table}"));
194              }
195              catch (Exception ex)
196              {
197                  Assert.Fail(
198                      @"Failed at iteration {0}.
199  Events:
200  {1}
201  Exception {2}",
202                      i, FormatEventQueue(eventQueue), ex);
203              }
204          }
205      }
206      [Test(Description = "Connection reuse race after rollback, bool distributed"), Explicit("Currently failing.")]
207      public void Connection_reuse_race_after_rollback([Values(false, true)] bool distributed)
208      {
209          using var adminConn = OpenConnection();
210          var table = CreateTempTable(adminConn, "name TEXT");
211          var dataSource = EnlistOffDataSource;
212          for (var i = 1; i <= 100; i++)
213          {
214              var eventQueue = new ConcurrentQueue<TransactionEvent>();
215              try
216              {
217                  using var conn1 = dataSource.OpenConnection();
218                  using (new TransactionScope())
219                  {
220                      conn1.EnlistTransaction(Transaction.Current);
221                      eventQueue.Enqueue(new TransactionEvent("Scope started, connection enlisted"));
222                      if (distributed)
223                      {
224                          EnlistResource.EscalateToDistributed(eventQueue);
225                          AssertHasDistributedIdentifier();
226                      }
227                      else
228                      {
229                          EnlistResource.EnlistVolatile(eventQueue);
230                          AssertNoDistributedIdentifier();
231                      }
232                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
233                      eventQueue.Enqueue(new TransactionEvent("Insert done"));
234                      eventQueue.Enqueue(new TransactionEvent("Scope not completed"));
235                  }
236                  eventQueue.Enqueue(new TransactionEvent("Scope disposed"));
237                  conn1.EnlistTransaction(null);
238                  eventQueue.Enqueue(new TransactionEvent("Connection enlisted with null"));
239                  Assert.DoesNotThrow(() => conn1.ExecuteScalar($"SELECT COUNT(*) FROM {table}"));
240              }
241              catch (Exception ex)
242              {
243                  Assert.Fail(
244                      @"Failed at iteration {0}.
245  Events:
246  {1}
247  Exception {2}",
248                      i, FormatEventQueue(eventQueue), ex);
249              }
250          }
251      }
252      [Test(Description = "Connection reuse race chaining transactions, bool distributed")]
253      [Explicit]
254      public void Connection_reuse_race_chaining_transaction([Values(false, true)] bool distributed)
255      {
256          using var adminConn = OpenConnection();
257          var table = CreateTempTable(adminConn, "name TEXT");
258          var dataSource = EnlistOffDataSource;
<span onclick='openModal()' class='match'>259          for (var i = 1; i <= 100; i++)
260          {
</span>261              var eventQueue = new ConcurrentQueue<TransactionEvent>();
262              try
263              {
264                  using var conn1 = dataSource.OpenConnection();
265                  using (var scope = new TransactionScope())
266                  {
267                      eventQueue.Enqueue(new TransactionEvent("First scope started"));
268                      conn1.EnlistTransaction(Transaction.Current);
269                      eventQueue.Enqueue(new TransactionEvent("First scope, connection enlisted"));
270                      if (distributed)
271                      {
272                          EnlistResource.EscalateToDistributed(eventQueue);
273                          AssertHasDistributedIdentifier();
274                      }
275                      else
276                      {
277                          EnlistResource.EnlistVolatile(eventQueue);
278                          AssertNoDistributedIdentifier();
279                      }
280                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
281                      eventQueue.Enqueue(new TransactionEvent("First insert done"));
282                      scope.Complete();
283                      eventQueue.Enqueue(new TransactionEvent("First scope completed"));
284                  }
285                  eventQueue.Enqueue(new TransactionEvent("First scope disposed"));
286                  using (var scope = new TransactionScope())
287                  {
288                      eventQueue.Enqueue(new TransactionEvent("Second scope started"));
289                      conn1.EnlistTransaction(Transaction.Current);
290                      eventQueue.Enqueue(new TransactionEvent("Second scope, connection enlisted"));
291                      if (distributed)
292                      {
293                          EnlistResource.EscalateToDistributed(eventQueue);
294                          AssertHasDistributedIdentifier();
295                      }
296                      else
297                      {
298                          EnlistResource.EnlistVolatile(eventQueue);
299                          AssertNoDistributedIdentifier();
300                      }
301                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
302                      eventQueue.Enqueue(new TransactionEvent("Second insert done"));
303                      scope.Complete();
304                      eventQueue.Enqueue(new TransactionEvent("Second scope completed"));
305                  }
306                  eventQueue.Enqueue(new TransactionEvent("Second scope disposed"));
307              }
308              catch (Exception ex)
309              {
310                  Assert.Fail(
311                      @"Failed at iteration {0}.
312  Events:
313  {1}
314  Exception {2}",
315                      i, FormatEventQueue(eventQueue), ex);
316              }
317          }
318      }
319      #region Utilities
320      static void Retry(Action action)
321      {
322          const int Retries = 50;
323          for (var i = 0; i < Retries; i++)
324          {
325              try
326              {
327                  action();
328                  return;
329              }
330              catch (AssertionException)
331              {
332                  if (i == Retries - 1)
333                  {
334                      throw;
335                  }
336                  Thread.Sleep(100);
337              }
338          }
339      }
340      void AssertNoPreparedTransactions()
341          => Assert.That(GetNumberOfPreparedTransactions(), Is.EqualTo(0), "Prepared transactions found");
342      int GetNumberOfPreparedTransactions()
343      {
344          var dataSource = EnlistOffDataSource;
345          using (var conn = dataSource.OpenConnection())
346          using (var cmd = new NpgsqlCommand("SELECT COUNT(*) FROM pg_prepared_xacts WHERE database = @database", conn))
347          {
348              cmd.Parameters.Add(new NpgsqlParameter("database", conn.Database));
349              return (int)(long)cmd.ExecuteScalar()!;
350          }
351      }
352      void AssertNumberOfRows(NpgsqlConnection connection, string table, int expected)
353          => Assert.That(connection.ExecuteScalar($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(expected), "Unexpected data count");
354      static void AssertNoDistributedIdentifier()
355          => Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.EqualTo(Guid.Empty), "Distributed identifier found");
356      static void AssertHasDistributedIdentifier()
357          => Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.Not.EqualTo(Guid.Empty), "Distributed identifier not found");
358      NpgsqlDataSource EnlistOnDataSource { get; set; } = default!;
359      NpgsqlDataSource EnlistOffDataSource { get; set; } = default!;
360      static string FormatEventQueue(ConcurrentQueue<TransactionEvent> eventQueue)
361      {
362          eventQueue.Enqueue(new TransactionEvent(@"-------------
363  Start formatting event queue, going to sleep a bit for late events
364  -------------"));
365          Thread.Sleep(20);
366          var eventsMessage = new StringBuilder();
367          foreach (var evt in eventQueue)
368          {
369              eventsMessage.AppendLine(evt.Message);
370          }
371          return eventsMessage.ToString();
372      }
373      public class EnlistResource : IEnlistmentNotification
374      {
375          public static int Counter { get; set; }
376          readonly bool _shouldRollBack;
377          readonly string _name;
378          readonly ConcurrentQueue<TransactionEvent>? _eventQueue;
379          public static void EnlistVolatile(ConcurrentQueue<TransactionEvent> eventQueue)
380              => EnlistVolatile(false, eventQueue);
381          public static void EnlistVolatile(bool shouldRollBack = false, ConcurrentQueue<TransactionEvent>? eventQueue = null)
382              => Enlist(false, shouldRollBack, eventQueue);
383          public static void EscalateToDistributed(ConcurrentQueue<TransactionEvent> eventQueue)
384              => EscalateToDistributed(false, eventQueue);
385          public static void EscalateToDistributed(bool shouldRollBack = false, ConcurrentQueue<TransactionEvent>? eventQueue = null)
386              => Enlist(true, shouldRollBack, eventQueue);
387          static void Enlist(bool durable, bool shouldRollBack, ConcurrentQueue<TransactionEvent>? eventQueue)
388          {
389              Counter++;
390              var name = $"{(durable ? "Durable" : "Volatile")} resource {Counter}";
391              var resource = new EnlistResource(shouldRollBack, name, eventQueue);
392              if (durable)
393                  Transaction.Current!.EnlistDurable(Guid.NewGuid(), resource, EnlistmentOptions.None);
394              else
395                  Transaction.Current!.EnlistVolatile(resource, EnlistmentOptions.None);
396              Transaction.Current.TransactionCompleted += resource.Current_TransactionCompleted!;
397              eventQueue?.Enqueue(new TransactionEvent(name + ": enlisted"));
398          }
399          EnlistResource(bool shouldRollBack, string name, ConcurrentQueue<TransactionEvent>? eventQueue)
400          {
401              _shouldRollBack = shouldRollBack;
402              _name = name;
403              _eventQueue = eventQueue;
404          }
405          public void Prepare(PreparingEnlistment preparingEnlistment)
406          {
407              _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase start"));
408              Thread.Sleep(1);
409              if (_shouldRollBack)
410              {
411                  _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase, calling rollback-ed"));
412                  preparingEnlistment.ForceRollback();
413              }
414              else
415              {
416                  _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase, calling prepared"));
417                  preparingEnlistment.Prepared();
418              }
419              Thread.Sleep(1);
420              _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase end"));
421          }
422          public void Commit(Enlistment enlistment)
423          {
424              _eventQueue?.Enqueue(new TransactionEvent(_name + ": commit phase start"));
425              Thread.Sleep(1);
426              _eventQueue?.Enqueue(new TransactionEvent(_name + ": commit phase, calling done"));
427              enlistment.Done();
428              Thread.Sleep(1);
429              _eventQueue?.Enqueue(new TransactionEvent(_name + ": commit phase end"));
430          }
431          public void Rollback(Enlistment enlistment)
432          {
433              _eventQueue?.Enqueue(new TransactionEvent(_name + ": rollback phase start"));
434              Thread.Sleep(1);
435              _eventQueue?.Enqueue(new TransactionEvent(_name + ": rollback phase, calling done"));
436              enlistment.Done();
437              Thread.Sleep(1);
438              _eventQueue?.Enqueue(new TransactionEvent(_name + ": rollback phase end"));
439          }
440          public void InDoubt(Enlistment enlistment)
441          {
442              _eventQueue?.Enqueue(new TransactionEvent(_name + ": in-doubt phase start"));
443              Thread.Sleep(1);
444              _eventQueue?.Enqueue(new TransactionEvent(_name + ": in-doubt phase, calling done"));
445              enlistment.Done();
446              Thread.Sleep(1);
447              _eventQueue?.Enqueue(new TransactionEvent(_name + ": in-doubt phase end"));
448          }
449          void Current_TransactionCompleted(object sender, TransactionEventArgs e)
450          {
451              _eventQueue?.Enqueue(new TransactionEvent(_name + ": transaction completed start"));
452              Thread.Sleep(1);
453              _eventQueue?.Enqueue(new TransactionEvent(_name + ": transaction completed middle"));
454              Thread.Sleep(1);
455              _eventQueue?.Enqueue(new TransactionEvent(_name + ": transaction completed end"));
456          }
457      }
458      public class TransactionEvent
459      {
460          public TransactionEvent(string message)
461              => Message = $"{message} (TId {Thread.CurrentThread.ManagedThreadId})";
462          public string Message { get; }
463      }
464      #endregion Utilities
465      #region Setup
466      [OneTimeSetUp]
467      public void OneTimeSetUp()
468      {
469          if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
470          {
471              Assert.Ignore("Distributed transactions are only supported on Windows");
472              return;
473          }
474          using var connection = OpenConnection();
475          if (int.Parse((string)connection.ExecuteScalar("SHOW max_prepared_transactions")!) == 0)
476          {
477              IgnoreExceptOnBuildServer("max_prepared_transactions is set to 0 in your postgresql.conf");
478              return;
479          }
480          var lingeringTransactions = new List<string>();
481          using (var cmd = new NpgsqlCommand("SELECT gid FROM pg_prepared_xacts WHERE database=@database", connection))
482          {
483              cmd.Parameters.AddWithValue("database", new NpgsqlConnectionStringBuilder(ConnectionString).Database!);
484              using var reader = cmd.ExecuteReader();
485              while (reader.Read())
486                  lingeringTransactions.Add(reader.GetString(0));
487          }
488          foreach (var xactGid in lingeringTransactions)
489              connection.ExecuteNonQuery($"ROLLBACK PREPARED '{xactGid}'");
490          EnlistOnDataSource = CreateDataSource(csb => csb.Enlist = true);
491          EnlistOffDataSource = CreateDataSource(csb => csb.Enlist = false);
492      }
493      [OneTimeTearDown]
494      public void OnTimeTearDown()
495      {
496          EnlistOnDataSource?.Dispose();
497          EnlistOnDataSource = null!;
498          EnlistOffDataSource?.Dispose();
499          EnlistOffDataSource = null!;
500      }
501      [SetUp]
502      public void SetUp()
503          => EnlistResource.Counter = 0;
504      internal static string CreateTempTable(NpgsqlConnection conn, string columns)
505      {
506          var tableName = "temp_table" + Interlocked.Increment(ref _tempTableCounter);
507          conn.ExecuteNonQuery(@$"
508  START TRANSACTION; SELECT pg_advisory_xact_lock(0);
509  DROP TABLE IF EXISTS {tableName} CASCADE;
510  COMMIT;
511  CREATE TABLE {tableName} ({columns})");
512          return tableName;
513      }
514      #endregion
515  }
516  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-TimelineTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>34              for (var i = 1; i <= 4; i++)
35              {
</pre></code></div>
                <div class="column column_space"><pre><code>259          for (var i = 1; i <= 100; i++)
260          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    