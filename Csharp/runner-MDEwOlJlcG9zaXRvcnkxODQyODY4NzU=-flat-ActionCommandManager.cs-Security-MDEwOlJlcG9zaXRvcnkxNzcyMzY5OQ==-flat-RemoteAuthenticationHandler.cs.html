
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionCommandManager.cs</h3>
            <pre><code>1  using GitHub.DistributedTask.Pipelines.ContextData;
2  using GitHub.DistributedTask.WebApi;
3  using GitHub.Runner.Worker.Container;
4  using System;
5  using System.Collections.Generic;
6  using System.IO;
7  using System.Linq;
8  using GitHub.Runner.Common;
9  using GitHub.Runner.Sdk;
10  namespace GitHub.Runner.Worker
11  {
12      [ServiceLocator(Default = typeof(ActionCommandManager))]
13      public interface IActionCommandManager : IRunnerService
14      {
15          void EnablePluginInternalCommand();
16          void DisablePluginInternalCommand();
17          bool TryProcessCommand(IExecutionContext context, string input, ContainerInfo container);
18      }
19      public sealed class ActionCommandManager : RunnerService, IActionCommandManager
20      {
21          private const string _stopCommand = "stop-commands";
22          private readonly Dictionary<string, IActionCommandExtension> _commandExtensions = new(StringComparer.OrdinalIgnoreCase);
23          private readonly HashSet<string> _registeredCommands = new(StringComparer.OrdinalIgnoreCase);
24          private readonly object _commandSerializeLock = new();
25          private bool _stopProcessCommand = false;
26          private string _stopToken = null;
27          public override void Initialize(IHostContext hostContext)
28          {
29              base.Initialize(hostContext);
30              _registeredCommands.Add(_stopCommand);
31              var extensionManager = hostContext.GetService<IExtensionManager>();
32              foreach (var commandExt in extensionManager.GetExtensions<IActionCommandExtension>() ?? new List<IActionCommandExtension>())
33              {
34                  Trace.Info($"Register action command extension for command {commandExt.Command}");
35                  _commandExtensions[commandExt.Command] = commandExt;
36                  if (commandExt.Command != "internal-set-repo-path")
37                  {
38                      _registeredCommands.Add(commandExt.Command);
39                  }
40              }
41          }
42          public void EnablePluginInternalCommand()
43          {
44              Trace.Info($"Enable plugin internal command extension.");
45              _registeredCommands.Add("internal-set-repo-path");
46          }
47          public void DisablePluginInternalCommand()
48          {
49              Trace.Info($"Disable plugin internal command extension.");
50              _registeredCommands.Remove("internal-set-repo-path");
51          }
52          public bool TryProcessCommand(IExecutionContext context, string input, ContainerInfo container)
53          {
54              if (string.IsNullOrEmpty(input))
55              {
56                  return false;
57              }
58              ActionCommand actionCommand;
59              if (!ActionCommand.TryParseV2(input, _registeredCommands, out actionCommand) &&
60                  !ActionCommand.TryParse(input, _registeredCommands, out actionCommand))
61              {
62                  return false;
63              }
64              if (!ActionCommandManager.EnhancedAnnotationsEnabled(context) && actionCommand.Command == "notice")
65              {
66                  context.Debug($"Enhanced Annotations not enabled on the server: 'notice' command will not be processed.");
67                  return false;
68              }
69              lock (_commandSerializeLock)
70              {
71                  if (_stopProcessCommand)
72                  {
73                      if (!string.IsNullOrEmpty(_stopToken) &&
74                               string.Equals(actionCommand.Command, _stopToken, StringComparison.OrdinalIgnoreCase))
75                      {
76                          context.Output(input);
77                          context.Debug("Resume processing commands");
78                          _registeredCommands.Remove(_stopToken);
79                          _stopProcessCommand = false;
80                          _stopToken = null;
81                          return true;
82                      }
83                      else
84                      {
85                          context.Debug($"Process commands has been stopped and waiting for '##[{_stopToken}]' to resume.");
86                          return false;
87                      }
88                  }
89                  else
90                  {
91                      if (string.Equals(actionCommand.Command, _stopCommand, StringComparison.OrdinalIgnoreCase))
92                      {
93                          ValidateStopToken(context, actionCommand.Data);
94                          _stopToken = actionCommand.Data;
95                          _stopProcessCommand = true;
96                          _registeredCommands.Add(_stopToken);
97                          if (_stopToken.Length > 6)
98                          {
99                              HostContext.SecretMasker.AddValue(_stopToken);
100                          }
101                          context.Output(input);
102                          context.Debug("Paused processing commands until the token you called ::stopCommands:: with is received");
103                          return true;
104                      }
105                      else if (_commandExtensions.TryGetValue(actionCommand.Command, out IActionCommandExtension extension))
106                      {
107                          if (context.EchoOnActionCommand && !extension.OmitEcho)
108                          {
109                              context.Output(input);
110                          }
111                          try
112                          {
113                              extension.ProcessCommand(context, input, actionCommand, container);
114                          }
115                          catch (Exception ex)
116                          {
117                              var commandInformation = extension.OmitEcho ? extension.Command : input;
118                              context.Error($"Unable to process command '{commandInformation}' successfully.");
119                              context.Error(ex);
120                              context.CommandResult = TaskResult.Failed;
121                          }
122                      }
123                      else
124                      {
125                          context.Warning($"Can't find command extension for ##[{actionCommand.Command}.command].");
126                      }
127                  }
128              }
129              return true;
130          }
131          private void ValidateStopToken(IExecutionContext context, string stopToken)
132          {
133  #if OS_WINDOWS
134              var envContext = context.ExpressionValues["env"] as DictionaryContextData;
135  #else
136              var envContext = context.ExpressionValues["env"] as CaseSensitiveDictionaryContextData;
137  #endif
138              var allowUnsecureStopCommandTokens = false;
139              allowUnsecureStopCommandTokens = StringUtil.ConvertToBoolean(Environment.GetEnvironmentVariable(Constants.Variables.Actions.AllowUnsupportedStopCommandTokens));
140              if (!allowUnsecureStopCommandTokens && envContext.ContainsKey(Constants.Variables.Actions.AllowUnsupportedStopCommandTokens))
141              {
142                  allowUnsecureStopCommandTokens = StringUtil.ConvertToBoolean(envContext[Constants.Variables.Actions.AllowUnsupportedStopCommandTokens].ToString());
143              }
144              bool isTokenInvalid = _registeredCommands.Contains(stopToken)
145                  || string.IsNullOrEmpty(stopToken)
146                  || string.Equals(stopToken, "pause-logging", StringComparison.OrdinalIgnoreCase);
147              if (isTokenInvalid)
148              {
149                  var telemetry = new JobTelemetry
150                  {
151                      Message = $"Invoked ::stopCommand:: with token: [{stopToken}]",
152                      Type = JobTelemetryType.ActionCommand
153                  };
154                  context.Global.JobTelemetry.Add(telemetry);
155              }
156              if (isTokenInvalid && !allowUnsecureStopCommandTokens)
157              {
158                  throw new Exception(Constants.Runner.UnsupportedStopCommandTokenDisabled);
159              }
160          }
161          internal static bool EnhancedAnnotationsEnabled(IExecutionContext context)
162          {
163              return context.Global.Variables.GetBoolean("DistributedTask.EnhancedAnnotations") ?? false;
164          }
165      }
166      public interface IActionCommandExtension : IExtension
167      {
168          string Command { get; }
169          bool OmitEcho { get; }
170          void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container);
171      }
172      public sealed class InternalPluginSetRepoPathCommandExtension : RunnerService, IActionCommandExtension
173      {
174          public string Command => "internal-set-repo-path";
175          public bool OmitEcho => false;
176          public Type ExtensionType => typeof(IActionCommandExtension);
177          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
178          {
179              if (!command.Properties.TryGetValue(SetRepoPathCommandProperties.repoFullName, out string repoFullName) || string.IsNullOrEmpty(repoFullName))
180              {
181                  throw new Exception("Required field 'repoFullName' is missing in ##[internal-set-repo-path] command.");
182              }
183              if (!command.Properties.TryGetValue(SetRepoPathCommandProperties.workspaceRepo, out string workspaceRepo) || string.IsNullOrEmpty(workspaceRepo))
184              {
185                  throw new Exception("Required field 'workspaceRepo' is missing in ##[internal-set-repo-path] command.");
186              }
187              var directoryManager = HostContext.GetService<IPipelineDirectoryManager>();
188              var trackingConfig = directoryManager.UpdateRepositoryDirectory(context, repoFullName, command.Data, StringUtil.ConvertToBoolean(workspaceRepo));
189          }
190          private static class SetRepoPathCommandProperties
191          {
192              public const String repoFullName = "repoFullName";
193              public const String workspaceRepo = "workspaceRepo";
194          }
195      }
196      public sealed class SetEnvCommandExtension : RunnerService, IActionCommandExtension
197      {
198          public string Command => "set-env";
199          public bool OmitEcho => false;
200          public Type ExtensionType => typeof(IActionCommandExtension);
201          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
202          {
203              var allowUnsecureCommands = false;
204              bool.TryParse(Environment.GetEnvironmentVariable(Constants.Variables.Actions.AllowUnsupportedCommands), out allowUnsecureCommands);
205  #if OS_WINDOWS
206              var envContext = context.ExpressionValues["env"] as DictionaryContextData;
207  #else
208              var envContext = context.ExpressionValues["env"] as CaseSensitiveDictionaryContextData;
209  #endif
210              if (!allowUnsecureCommands && envContext.ContainsKey(Constants.Variables.Actions.AllowUnsupportedCommands))
211              {
212                  bool.TryParse(envContext[Constants.Variables.Actions.AllowUnsupportedCommands].ToString(), out allowUnsecureCommands);
213              }
214              if (!allowUnsecureCommands)
215              {
216                  throw new Exception(String.Format(Constants.Runner.UnsupportedCommandMessageDisabled, this.Command));
217              }
218              if (!command.Properties.TryGetValue(SetEnvCommandProperties.Name, out string envName) || string.IsNullOrEmpty(envName))
219              {
220                  throw new Exception("Required field 'name' is missing in ##[set-env] command.");
221              }
222              foreach (var blocked in _setEnvBlockList)
223              {
224                  if (string.Equals(blocked, envName, StringComparison.OrdinalIgnoreCase))
225                  {
226                      var issue = new Issue()
227                      {
228                          Type = IssueType.Error,
229                          Message = $"Can't update {blocked} environment variable using ::set-env:: command."
230                      };
231                      issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = $"{Constants.Runner.UnsupportedCommand}_{envName}";
232                      context.AddIssue(issue, ExecutionContextLogOptions.Default);
233                      return;
234                  }
235              }
<span onclick='openModal()' class='match'>236              context.Global.EnvironmentVariables[envName] = command.Data;
237              context.SetEnvContext(envName, command.Data);
</span>238              context.Debug($"{envName}='{command.Data}'");
239          }
240          private static class SetEnvCommandProperties
241          {
242              public const String Name = "name";
243          }
244          private string[] _setEnvBlockList =
245          {
246              "NODE_OPTIONS"
247          };
248      }
249      public sealed class SetOutputCommandExtension : RunnerService, IActionCommandExtension
250      {
251          public string Command => "set-output";
252          public bool OmitEcho => false;
253          public Type ExtensionType => typeof(IActionCommandExtension);
254          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
255          {
256              if (context.Global.Variables.GetBoolean("DistributedTask.DeprecateStepOutputCommands") ?? false)
257              {
258                  var issue = new Issue()
259                  {
260                      Type = IssueType.Warning,
261                      Message = String.Format(Constants.Runner.UnsupportedCommandMessage, this.Command)
262                  };
263                  issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = Constants.Runner.UnsupportedCommand;
264                  context.AddIssue(issue, ExecutionContextLogOptions.Default);
265              }
266              if (!command.Properties.TryGetValue(SetOutputCommandProperties.Name, out string outputName) || string.IsNullOrEmpty(outputName))
267              {
268                  throw new Exception("Required field 'name' is missing in ##[set-output] command.");
269              }
270              context.SetOutput(outputName, command.Data, out var reference);
271              context.Debug($"{reference}='{command.Data}'");
272          }
273          private static class SetOutputCommandProperties
274          {
275              public const String Name = "name";
276          }
277      }
278      public sealed class SaveStateCommandExtension : RunnerService, IActionCommandExtension
279      {
280          public string Command => "save-state";
281          public bool OmitEcho => false;
282          public Type ExtensionType => typeof(IActionCommandExtension);
283          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
284          {
285              if (context.Global.Variables.GetBoolean("DistributedTask.DeprecateStepOutputCommands") ?? false)
286              {
287                  var issue = new Issue()
288                  {
289                      Type = IssueType.Warning,
290                      Message = String.Format(Constants.Runner.UnsupportedCommandMessage, this.Command)
291                  };
292                  issue.Data[Constants.Runner.InternalTelemetryIssueDataKey] = Constants.Runner.UnsupportedCommand;
293                  context.AddIssue(issue, ExecutionContextLogOptions.Default);
294              }
295              if (!command.Properties.TryGetValue(SaveStateCommandProperties.Name, out string stateName) || string.IsNullOrEmpty(stateName))
296              {
297                  throw new Exception("Required field 'name' is missing in ##[save-state] command.");
298              }
299              if (context.IsEmbedded)
300              {
301                  var id = context.EmbeddedId;
302                  if (!context.Root.EmbeddedIntraActionState.ContainsKey(id))
303                  {
304                      context.Root.EmbeddedIntraActionState[id] = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
305                  }
306                  context.Root.EmbeddedIntraActionState[id][stateName] = command.Data;
307              }
308              else
309              {
310                  context.IntraActionState[stateName] = command.Data;
311              }
312              context.Debug($"Save intra-action state {stateName} = {command.Data}");
313          }
314          private static class SaveStateCommandProperties
315          {
316              public const String Name = "name";
317          }
318      }
319      public sealed class AddMaskCommandExtension : RunnerService, IActionCommandExtension
320      {
321          public string Command => "add-mask";
322          public bool OmitEcho => true;
323          public Type ExtensionType => typeof(IActionCommandExtension);
324          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
325          {
326              if (string.IsNullOrWhiteSpace(command.Data))
327              {
328                  context.Warning("Can't add secret mask for empty string in ##[add-mask] command.");
329              }
330              else
331              {
332                  if (context.EchoOnActionCommand)
333                  {
334                      context.Output($"::{Command}::***");
335                  }
336                  HostContext.SecretMasker.AddValue(command.Data);
337                  Trace.Info($"Add new secret mask with length of {command.Data.Length}");
338                  var split = command.Data.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
339                  foreach (var item in split)
340                  {
341                      HostContext.SecretMasker.AddValue(item);
342                  }
343              }
344          }
345      }
346      public sealed class AddPathCommandExtension : RunnerService, IActionCommandExtension
347      {
348          public string Command => "add-path";
349          public bool OmitEcho => false;
350          public Type ExtensionType => typeof(IActionCommandExtension);
351          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
352          {
353              var allowUnsecureCommands = false;
354              bool.TryParse(Environment.GetEnvironmentVariable(Constants.Variables.Actions.AllowUnsupportedCommands), out allowUnsecureCommands);
355  #if OS_WINDOWS
356              var envContext = context.ExpressionValues["env"] as DictionaryContextData;
357  #else
358              var envContext = context.ExpressionValues["env"] as CaseSensitiveDictionaryContextData;
359  #endif
360              if (!allowUnsecureCommands && envContext.ContainsKey(Constants.Variables.Actions.AllowUnsupportedCommands))
361              {
362                  bool.TryParse(envContext[Constants.Variables.Actions.AllowUnsupportedCommands].ToString(), out allowUnsecureCommands);
363              }
364              if (!allowUnsecureCommands)
365              {
366                  throw new Exception(String.Format(Constants.Runner.UnsupportedCommandMessageDisabled, this.Command));
367              }
368              ArgUtil.NotNullOrEmpty(command.Data, "path");
369              context.Global.PrependPath.RemoveAll(x => string.Equals(x, command.Data, StringComparison.CurrentCulture));
370              context.Global.PrependPath.Add(command.Data);
371          }
372      }
373      public sealed class AddMatcherCommandExtension : RunnerService, IActionCommandExtension
374      {
375          public string Command => "add-matcher";
376          public bool OmitEcho => false;
377          public Type ExtensionType => typeof(IActionCommandExtension);
378          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
379          {
380              var file = command.Data;
381              if (string.IsNullOrEmpty(file))
382              {
383                  context.Warning("File path must be specified.");
384                  return;
385              }
386              if (container != null)
387              {
388                  file = container.TranslateToHostPath(file);
389              }
390              if (!Path.IsPathRooted(file))
391              {
392                  var githubContext = context.ExpressionValues["github"] as GitHubContext;
393                  ArgUtil.NotNull(githubContext, nameof(githubContext));
394                  var workspace = githubContext["workspace"].ToString();
395                  ArgUtil.NotNullOrEmpty(workspace, "workspace");
396                  file = Path.Combine(workspace, file);
397              }
398              var config = IOUtil.LoadObject<IssueMatchersConfig>(file);
399              if (config?.Matchers?.Count > 0)
400              {
401                  config.Validate();
402                  context.AddMatchers(config);
403              }
404          }
405      }
406      public sealed class RemoveMatcherCommandExtension : RunnerService, IActionCommandExtension
407      {
408          public string Command => "remove-matcher";
409          public bool OmitEcho => false;
410          public Type ExtensionType => typeof(IActionCommandExtension);
411          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
412          {
413              command.Properties.TryGetValue(RemoveMatcherCommandProperties.Owner, out string owner);
414              var file = command.Data;
415              if (!string.IsNullOrEmpty(owner) && !string.IsNullOrEmpty(file))
416              {
417                  context.Warning("Either specify an owner name or a file path in ##[remove-matcher] command. Both values cannot be set.");
418                  return;
419              }
420              if (string.IsNullOrEmpty(owner) && string.IsNullOrEmpty(file))
421              {
422                  context.Warning("Either an owner name or a file path must be specified in ##[remove-matcher] command.");
423                  return;
424              }
425              if (!string.IsNullOrEmpty(owner))
426              {
427                  context.RemoveMatchers(new[] { owner });
428              }
429              else
430              {
431                  if (container != null)
432                  {
433                      file = container.TranslateToHostPath(file);
434                  }
435                  if (!Path.IsPathRooted(file))
436                  {
437                      var githubContext = context.ExpressionValues["github"] as GitHubContext;
438                      ArgUtil.NotNull(githubContext, nameof(githubContext));
439                      var workspace = githubContext["workspace"].ToString();
440                      ArgUtil.NotNullOrEmpty(workspace, "workspace");
441                      file = Path.Combine(workspace, file);
442                  }
443                  var config = IOUtil.LoadObject<IssueMatchersConfig>(file);
444                  if (config?.Matchers?.Count > 0)
445                  {
446                      context.RemoveMatchers(config.Matchers.Select(x => x.Owner));
447                  }
448              }
449          }
450          private static class RemoveMatcherCommandProperties
451          {
452              public const string Owner = "owner";
453          }
454      }
455      public sealed class DebugCommandExtension : RunnerService, IActionCommandExtension
456      {
457          public string Command => "debug";
458          public bool OmitEcho => true;
459          public Type ExtensionType => typeof(IActionCommandExtension);
460          public void ProcessCommand(IExecutionContext context, string inputLine, ActionCommand command, ContainerInfo container)
461          {
462              context.Debug(command.Data);
463          }
464      }
465      public sealed class WarningCommandExtension : IssueCommandExtension
466      {
467          public override IssueType Type => IssueType.Warning;
468          public override string Command => "warning";
469      }
470      public sealed class ErrorCommandExtension : IssueCommandExtension
471      {
472          public override IssueType Type => IssueType.Error;
473          public override string Command => "error";
474      }
475      public sealed class NoticeCommandExtension : IssueCommandExtension
476      {
477          public override IssueType Type => IssueType.Notice;
478          public override string Command => "notice";
479      }
480      public abstract class IssueCommandExtension : RunnerService, IActionCommandExtension
481      {
482          public abstract IssueType Type { get; }
483          public abstract string Command { get; }
484          public bool OmitEcho => true;
485          public Type ExtensionType => typeof(IActionCommandExtension);
486          public void ProcessCommand(IExecutionContext context, string inputLine, ActionCommand command, ContainerInfo container)
487          {
488              ValidateLinesAndColumns(command, context);
489              command.Properties.TryGetValue(IssueCommandProperties.File, out string file);
490              command.Properties.TryGetValue(IssueCommandProperties.Line, out string line);
491              command.Properties.TryGetValue(IssueCommandProperties.Column, out string column);
492              if (!ActionCommandManager.EnhancedAnnotationsEnabled(context))
493              {
494                  context.Debug("Enhanced Annotations not enabled on the server. The 'title', 'end_line', and 'end_column' fields are unsupported.");
495              }
496              Issue issue = new()
497              {
498                  Category = "General",
499                  Type = this.Type,
500                  Message = command.Data
501              };
502              if (!string.IsNullOrEmpty(file))
503              {
504                  issue.Category = "Code";
505                  if (container != null)
506                  {
507                      file = container.TranslateToHostPath(file);
508                      command.Properties[IssueCommandProperties.File] = file;
509                  }
510                  string repoName = context.GetGitHubContext("repository");
511                  var repoPath = context.GetGitHubContext("workspace");
512                  string relativeSourcePath = IOUtil.MakeRelative(file, repoPath);
513                  if (!string.Equals(relativeSourcePath, file, IOUtil.FilePathStringComparison))
514                  {
515                      if (!string.IsNullOrEmpty(repoName))
516                      {
517                          command.Properties["repo"] = repoName;
518                      }
519                      if (!string.IsNullOrEmpty(relativeSourcePath))
520                      {
521                          command.Properties[IssueCommandProperties.File] = relativeSourcePath.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
522                      }
523                  }
524              }
525              foreach (var property in command.Properties)
526              {
527                  if (!string.Equals(property.Key, Constants.Runner.InternalTelemetryIssueDataKey, StringComparison.OrdinalIgnoreCase))
528                  {
529                      issue.Data[property.Key] = property.Value;
530                  }
531              }
532              context.AddIssue(issue, ExecutionContextLogOptions.Default);
533          }
534          public static void ValidateLinesAndColumns(ActionCommand command, IExecutionContext context)
535          {
536              command.Properties.TryGetValue(IssueCommandProperties.Line, out string line);
537              command.Properties.TryGetValue(IssueCommandProperties.EndLine, out string endLine);
538              command.Properties.TryGetValue(IssueCommandProperties.Column, out string column);
539              command.Properties.TryGetValue(IssueCommandProperties.EndColumn, out string endColumn);
540              var hasStartLine = int.TryParse(line, out int lineNumber);
541              var hasEndLine = int.TryParse(endLine, out int endLineNumber);
542              var hasStartColumn = int.TryParse(column, out int columnNumber);
543              var hasEndColumn = int.TryParse(endColumn, out int endColumnNumber);
544              var hasColumn = hasStartColumn || hasEndColumn;
545              if (hasEndLine && !hasStartLine)
546              {
547                  context.Debug($"Invalid {command.Command} command value. '{IssueCommandProperties.EndLine}' can only be set if '{IssueCommandProperties.Line}' is provided");
548                  command.Properties[IssueCommandProperties.Line] = endLine;
549                  hasStartLine = true;
550                  line = endLine;
551              }
552              if (hasEndColumn && !hasStartColumn)
553              {
554                  context.Debug($"Invalid {command.Command} command value. '{IssueCommandProperties.EndColumn}' can only be set if '{IssueCommandProperties.Column}' is provided");
555                  command.Properties[IssueCommandProperties.Column] = endColumn;
556                  hasStartColumn = true;
557                  column = endColumn;
558              }
559              if (!hasStartLine && hasColumn)
560              {
561                  context.Debug($"Invalid {command.Command} command value. '{IssueCommandProperties.Column}' and '{IssueCommandProperties.EndColumn}' can only be set if '{IssueCommandProperties.Line}' value is provided.");
562                  command.Properties.Remove(IssueCommandProperties.Column);
563                  command.Properties.Remove(IssueCommandProperties.EndColumn);
564              }
565              if (hasEndLine && line != endLine && hasColumn)
566              {
567                  context.Debug($"Invalid {command.Command} command value. '{IssueCommandProperties.Column}' and '{IssueCommandProperties.EndColumn}' cannot be set if '{IssueCommandProperties.Line}' and '{IssueCommandProperties.EndLine}' are different values.");
568                  command.Properties.Remove(IssueCommandProperties.Column);
569                  command.Properties.Remove(IssueCommandProperties.EndColumn);
570              }
571              if (hasStartLine && hasEndLine && endLineNumber < lineNumber)
572              {
573                  context.Debug($"Invalid {command.Command} command value. '{IssueCommandProperties.EndLine}' cannot be less than '{IssueCommandProperties.Line}'.");
574                  command.Properties.Remove(IssueCommandProperties.Line);
575                  command.Properties.Remove(IssueCommandProperties.EndLine);
576              }
577              if (hasStartColumn && hasEndColumn && endColumnNumber < columnNumber)
578              {
579                  context.Debug($"Invalid {command.Command} command value. '{IssueCommandProperties.EndColumn}' cannot be less than '{IssueCommandProperties.Column}'.");
580                  command.Properties.Remove(IssueCommandProperties.Column);
581                  command.Properties.Remove(IssueCommandProperties.EndColumn);
582              }
583          }
584          private static class IssueCommandProperties
585          {
586              public const String File = "file";
587              public const String Line = "line";
588              public const String EndLine = "endLine";
589              public const String Column = "col";
590              public const String EndColumn = "endColumn";
591              public const String Title = "title";
592          }
593      }
594      public sealed class GroupCommandExtension : GroupingCommandExtension
595      {
596          public override string Command => "group";
597      }
598      public sealed class EndGroupCommandExtension : GroupingCommandExtension
599      {
600          public override string Command => "endgroup";
601      }
602      public abstract class GroupingCommandExtension : RunnerService, IActionCommandExtension
603      {
604          public abstract string Command { get; }
605          public bool OmitEcho => false;
606          public Type ExtensionType => typeof(IActionCommandExtension);
607          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
608          {
609              var data = this is GroupCommandExtension ? command.Data : string.Empty;
610              context.Output($"##[{Command}]{data}");
611          }
612      }
613      public sealed class EchoCommandExtension : RunnerService, IActionCommandExtension
614      {
615          public string Command => "echo";
616          public bool OmitEcho => false;
617          public Type ExtensionType => typeof(IActionCommandExtension);
618          public void ProcessCommand(IExecutionContext context, string line, ActionCommand command, ContainerInfo container)
619          {
620              ArgUtil.NotNullOrEmpty(command.Data, "value");
621              switch (command.Data.Trim().ToUpperInvariant())
622              {
623                  case "ON":
624                      context.EchoOnActionCommand = true;
625                      context.Debug("Setting echo command value to 'on'");
626                      break;
627                  case "OFF":
628                      context.EchoOnActionCommand = false;
629                      context.Debug("Setting echo command value to 'off'");
630                      break;
631                  default:
632                      throw new Exception($"Invalid echo command value. Possible values can be: 'on', 'off'. Current value is: '{command.Data}'.");
633              }
634          }
635      }
636  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-RemoteAuthenticationHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Security.Cryptography;
3  using System.Text.Encodings.Web;
4  using System.Threading.Tasks;
5  using Microsoft.AspNetCore.WebUtilities;
6  using Microsoft.Extensions.Logging;
7  using Microsoft.Extensions.Options;
8  namespace Microsoft.AspNetCore.Authentication
9  {
10      public abstract class RemoteAuthenticationHandler<TOptions> : AuthenticationHandler<TOptions>, IAuthenticationRequestHandler
11          where TOptions : RemoteAuthenticationOptions, new()
12      {
13          private const string CorrelationProperty = ".xsrf";
14          private const string CorrelationMarker = "N";
15          private const string AuthSchemeKey = ".AuthScheme";
16          private static readonly RandomNumberGenerator CryptoRandom = RandomNumberGenerator.Create();
17          protected string SignInScheme => Options.SignInScheme;
18          protected new RemoteAuthenticationEvents Events
19          {
20              get { return (RemoteAuthenticationEvents)base.Events; }
21              set { base.Events = value; }
22          }
23          protected RemoteAuthenticationHandler(IOptionsMonitor<TOptions> options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
24              : base(options, logger, encoder, clock) { }
25          protected override Task<object> CreateEventsAsync()
26              => Task.FromResult<object>(new RemoteAuthenticationEvents());
27          public virtual Task<bool> ShouldHandleRequestAsync()
28              => Task.FromResult(Options.CallbackPath == Request.Path);
29          public virtual async Task<bool> HandleRequestAsync()
30          {
31              if (!await ShouldHandleRequestAsync())
32              {
33                  return false;
34              }
35              AuthenticationTicket ticket = null;
36              Exception exception = null;
37              AuthenticationProperties properties = null;
38              try
39              {
40                  var authResult = await HandleRemoteAuthenticateAsync();
41                  if (authResult == null)
42                  {
43                      exception = new InvalidOperationException("Invalid return state, unable to redirect.");
44                  }
45                  else if (authResult.Handled)
46                  {
47                      return true;
48                  }
49                  else if (authResult.Skipped || authResult.None)
50                  {
51                      return false;
52                  }
53                  else if (!authResult.Succeeded)
54                  {
55                      exception = authResult.Failure ?? new InvalidOperationException("Invalid return state, unable to redirect.");
56                      properties = authResult.Properties;
57                  }
58                  ticket = authResult?.Ticket;
59              }
60              catch (Exception ex)
61              {
62                  exception = ex;
63              }
64              if (exception != null)
65              {
66                  Logger.RemoteAuthenticationError(exception.Message);
67                  var errorContext = new RemoteFailureContext(Context, Scheme, Options, exception)
68                  {
69                      Properties = properties
70                  };
71                  await Events.RemoteFailure(errorContext);
72                  if (errorContext.Result != null)
73                  {
74                      if (errorContext.Result.Handled)
75                      {
76                          return true;
77                      }
78                      else if (errorContext.Result.Skipped)
79                      {
80                          return false;
81                      }
82                      else if (errorContext.Result.Failure != null)
83                      {
84                          throw new Exception("An error was returned from the RemoteFailure event.", errorContext.Result.Failure);
85                      }
86                  }
87                  if (errorContext.Failure != null)
88                  {
89                      throw new Exception("An error was encountered while handling the remote login.", errorContext.Failure);
90                  }
91              }
92              var ticketContext = new TicketReceivedContext(Context, Scheme, Options, ticket)
93              {
94                  ReturnUri = ticket.Properties.RedirectUri
95              };
96              ticket.Properties.RedirectUri = null;
<span onclick='openModal()' class='match'>97              ticketContext.Properties.Items[AuthSchemeKey] = Scheme.Name;
98              await Events.TicketReceived(ticketContext);
</span>99              if (ticketContext.Result != null)
100              {
101                  if (ticketContext.Result.Handled)
102                  {
103                      Logger.SigninHandled();
104                      return true;
105                  }
106                  else if (ticketContext.Result.Skipped)
107                  {
108                      Logger.SigninSkipped();
109                      return false;
110                  }
111              }
112              await Context.SignInAsync(SignInScheme, ticketContext.Principal, ticketContext.Properties);
113              if (string.IsNullOrEmpty(ticketContext.ReturnUri))
114              {
115                  ticketContext.ReturnUri = "/";
116              }
117              Response.Redirect(ticketContext.ReturnUri);
118              return true;
119          }
120          protected abstract Task<HandleRequestResult> HandleRemoteAuthenticateAsync();
121          protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
122          {
123              var result = await Context.AuthenticateAsync(SignInScheme);
124              if (result != null)
125              {
126                  if (result.Failure != null)
127                  {
128                      return result;
129                  }
130                  string authenticatedScheme;
131                  var ticket = result.Ticket;
132                  if (ticket != null && ticket.Principal != null && ticket.Properties != null
133                      && ticket.Properties.Items.TryGetValue(AuthSchemeKey, out authenticatedScheme)
134                      && string.Equals(Scheme.Name, authenticatedScheme, StringComparison.Ordinal))
135                  {
136                      return AuthenticateResult.Success(new AuthenticationTicket(ticket.Principal,
137                          ticket.Properties, Scheme.Name));
138                  }
139                  return AuthenticateResult.Fail("Not authenticated");
140              }
141              return AuthenticateResult.Fail("Remote authentication does not directly support AuthenticateAsync");
142          }
143          protected override Task HandleForbiddenAsync(AuthenticationProperties properties)
144              => Context.ForbidAsync(SignInScheme);
145          protected virtual void GenerateCorrelationId(AuthenticationProperties properties)
146          {
147              if (properties == null)
148              {
149                  throw new ArgumentNullException(nameof(properties));
150              }
151              var bytes = new byte[32];
152              CryptoRandom.GetBytes(bytes);
153              var correlationId = Base64UrlTextEncoder.Encode(bytes);
154              var cookieOptions = Options.CorrelationCookie.Build(Context, Clock.UtcNow);
155              properties.Items[CorrelationProperty] = correlationId;
156              var cookieName = Options.CorrelationCookie.Name + Scheme.Name + "." + correlationId;
157              Response.Cookies.Append(cookieName, CorrelationMarker, cookieOptions);
158          }
159          protected virtual bool ValidateCorrelationId(AuthenticationProperties properties)
160          {
161              if (properties == null)
162              {
163                  throw new ArgumentNullException(nameof(properties));
164              }
165              if (!properties.Items.TryGetValue(CorrelationProperty, out string correlationId))
166              {
167                  Logger.CorrelationPropertyNotFound(Options.CorrelationCookie.Name);
168                  return false;
169              }
170              properties.Items.Remove(CorrelationProperty);
171              var cookieName = Options.CorrelationCookie.Name + Scheme.Name + "." + correlationId;
172              var correlationCookie = Request.Cookies[cookieName];
173              if (string.IsNullOrEmpty(correlationCookie))
174              {
175                  Logger.CorrelationCookieNotFound(cookieName);
176                  return false;
177              }
178              var cookieOptions = Options.CorrelationCookie.Build(Context, Clock.UtcNow);
179              Response.Cookies.Delete(cookieName, cookieOptions);
180              if (!string.Equals(correlationCookie, CorrelationMarker, StringComparison.Ordinal))
181              {
182                  Logger.UnexpectedCorrelationCookieValue(cookieName, correlationCookie);
183                  return false;
184              }
185              return true;
186          }
187          protected virtual async Task<HandleRequestResult> HandleAccessDeniedErrorAsync(AuthenticationProperties properties)
188          {
189              Logger.AccessDeniedError();
190              var context = new AccessDeniedContext(Context, Scheme, Options)
191              {
192                  AccessDeniedPath = Options.AccessDeniedPath,
193                  Properties = properties,
194                  ReturnUrl = properties?.RedirectUri,
195                  ReturnUrlParameter = Options.ReturnUrlParameter
196              };
197              await Events.AccessDenied(context);
198              if (context.Result != null)
199              {
200                  if (context.Result.Handled)
201                  {
202                      Logger.AccessDeniedContextHandled();
203                  }
204                  else if (context.Result.Skipped)
205                  {
206                      Logger.AccessDeniedContextSkipped();
207                  }
208                  return context.Result;
209              }
210              if (context.AccessDeniedPath.HasValue)
211              {
212                  string uri = context.AccessDeniedPath;
213                  if (!string.IsNullOrEmpty(context.ReturnUrlParameter) && !string.IsNullOrEmpty(context.ReturnUrl))
214                  {
215                      uri = QueryHelpers.AddQueryString(uri, context.ReturnUrlParameter, context.ReturnUrl);
216                  }
217                  Response.Redirect(uri);
218                  return HandleRequestResult.Handle();
219              }
220              return HandleRequestResult.Fail("Access was denied by the resource owner or by the remote server.", properties);
221          }
222      }
223  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-ActionCommandManager.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-RemoteAuthenticationHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>236              context.Global.EnvironmentVariables[envName] = command.Data;
237              context.SetEnvContext(envName, command.Data);
</pre></code></div>
                <div class="column column_space"><pre><code>97              ticketContext.Properties.Items[AuthSchemeKey] = Scheme.Name;
98              await Events.TicketReceived(ticketContext);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    