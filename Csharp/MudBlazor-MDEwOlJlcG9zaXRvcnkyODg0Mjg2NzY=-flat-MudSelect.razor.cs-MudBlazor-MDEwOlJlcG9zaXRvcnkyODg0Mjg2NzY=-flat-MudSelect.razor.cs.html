
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudSelect.razor.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics.CodeAnalysis;
4  using System.Linq;
5  using System.Threading.Tasks;
6  using Microsoft.AspNetCore.Components;
7  using Microsoft.AspNetCore.Components.Web;
8  using MudBlazor.Services;
9  using MudBlazor.Utilities;
10  using MudBlazor.Utilities.Exceptions;
11  namespace MudBlazor
12  {
13      public partial class MudSelect<T> : MudBaseInput<T>, IMudSelect, IMudShadowSelect
14      {
15          private HashSet<T> _selectedValues = new HashSet<T>();
16          private IEqualityComparer<T> _comparer;
17          private bool _dense;
18          private string multiSelectionText;
19          private bool? _selectAllChecked;
20          private IKeyInterceptor _keyInterceptor;
21          protected string Classname =>
22              new CssBuilder("mud-select")
23              .AddClass(Class)
24              .Build();
25          [Inject] private IKeyInterceptorFactory KeyInterceptorFactory { get; set; }
26          [Inject] IScrollManager ScrollManager { get; set; }
27          private string _elementId = "select_" + Guid.NewGuid().ToString().Substring(0, 8);
28          private Task SelectNextItem() => SelectAdjacentItem(+1);
29          private Task SelectPreviousItem() => SelectAdjacentItem(-1);
30          private async Task SelectAdjacentItem(int direction)
31          {
32              if (_items == null || _items.Count == 0)
33                  return;
34              var index = _items.FindIndex(x => x.ItemId == (string)_activeItemId);
35              if (direction < 0 && index < 0)
36                  index = 0;
37              MudSelectItem<T> item = null;
38              for (int i = 0; i < _items.Count; i++)
39              {
40                  index += direction;
41                  if (index < 0)
42                      index = 0;
43                  if (index >= _items.Count)
44                      index = _items.Count - 1;
45                  if (_items[index].Disabled)
46                      continue;
47                  item = _items[index];
48                  if (!MultiSelection)
49                  {
50                      _selectedValues.Clear();
51                      _selectedValues.Add(item.Value);
52                      await SetValueAsync(item.Value, updateText: true);
53                      HilightItem(item);
54                      break;
55                  }
56                  else
57                  {
58                      HilightItem(item);
59                      break;
60                  }
61              }
62              await _elementReference.SetText(Text);
63              await ScrollToItemAsync(item);
64          }
65          private ValueTask ScrollToItemAsync(MudSelectItem<T> item)
66              =>item != null? ScrollManager.ScrollToListItemAsync(item.ItemId): ValueTask.CompletedTask;
67          private async Task SelectFirstItem(string startChar = null)
68          {
69              if (_items == null || _items.Count == 0)
70                  return;
71              var items = _items.Where(x => !x.Disabled);
72              var firstItem = items.FirstOrDefault();
73              if (!string.IsNullOrWhiteSpace(startChar))
74              {
75                  var currentItem = items.FirstOrDefault(x => x.ItemId == (string)_activeItemId);
76                  if (currentItem != null &&
77                      Converter.Set(currentItem.Value)?.ToLowerInvariant().StartsWith(startChar) == true)
78                  {
79                      items = items.SkipWhile(x => x != currentItem).Skip(1);
80                  }
81                  items = items.Where(x => Converter.Set(x.Value)?.ToLowerInvariant().StartsWith(startChar) == true);
82              }
83              var item = items.FirstOrDefault();
84              if (item == null)
85                  return;
86              if (!MultiSelection)
87              {
88                  _selectedValues.Clear();
89                  _selectedValues.Add(item.Value);
90                  await SetValueAsync(item.Value, updateText: true);
91                  HilightItem(item);
92              }
93              else
94              {
95                  HilightItem(item);
96              }
97              await _elementReference.SetText(Text);
98              await ScrollToItemAsync(item);
99          }
100          private async Task SelectLastItem()
101          {
102              if (_items == null || _items.Count == 0)
103                  return;
104              var item = _items.LastOrDefault(x => !x.Disabled);
105              if (item == null)
106                  return;
107              if (!MultiSelection)
108              {
109                  _selectedValues.Clear();
110                  _selectedValues.Add(item.Value);
111                  await SetValueAsync(item.Value, updateText: true);
112                  HilightItem(item);
113              }
114              else
115              {
116                  HilightItem(item);
117              }
118              await _elementReference.SetText(Text);
119              await ScrollToItemAsync(item);
120          }
121          [Category(CategoryTypes.FormComponent.Behavior)]
122          [Parameter] public EventCallback OnOpen { get; set; }
123          [Category(CategoryTypes.FormComponent.Behavior)]
124          [Parameter] public EventCallback OnClose { get; set; }
125          [Parameter]
126          [Category(CategoryTypes.FormComponent.ListBehavior)]
127          public RenderFragment ChildContent { get; set; }
128          [Parameter]
129          [Category(CategoryTypes.FormComponent.ListAppearance)]
130          public string PopoverClass { get; set; }
131          [Parameter]
132          [Category(CategoryTypes.FormComponent.ListAppearance)]
133          public string ListClass { get; set; }
134          [Parameter]
135          [Category(CategoryTypes.FormComponent.ListAppearance)]
136          public bool Dense
137          {
138              get { return _dense; }
139              set { _dense = value; }
140          }
141          [Parameter]
142          [Category(CategoryTypes.FormComponent.Appearance)]
143          public string OpenIcon { get; set; } = Icons.Material.Filled.ArrowDropDown;
144          [Parameter]
145          [Category(CategoryTypes.FormComponent.Appearance)]
146          public string CloseIcon { get; set; } = Icons.Material.Filled.ArrowDropUp;
147          [Parameter]
148          [Category(CategoryTypes.FormComponent.ListBehavior)]
149          public bool SelectAll { get; set; }
150          [Parameter]
151          [Category(CategoryTypes.FormComponent.ListAppearance)]
152          public string SelectAllText { get; set; } = "Select all";
153          [Parameter] public EventCallback<IEnumerable<T>> SelectedValuesChanged { get; set; }
154          [Parameter]
155          [Category(CategoryTypes.FormComponent.Behavior)]
156          public Func<List<string>, string> MultiSelectionTextFunc { get; set; }
157          [Parameter]
158          [Category(CategoryTypes.FormComponent.Behavior)]
159          public string Delimiter { get; set; } = ", ";
160          [Parameter]
161          [Category(CategoryTypes.FormComponent.Data)]
162          public IEnumerable<T> SelectedValues
163          {
164              get
165              {
166                  if (_selectedValues == null)
167                      _selectedValues = new HashSet<T>(_comparer);
168                  return _selectedValues;
169              }
170              set
171              {
172                  var set = value ?? new HashSet<T>(_comparer);
173                  if (SelectedValues.Count() == set.Count() && _selectedValues.All(x => set.Contains(x)))
174                      return;
175                  _selectedValues = new HashSet<T>(set, _comparer);
176                  SelectionChangedFromOutside?.Invoke(_selectedValues);
177                  if (!MultiSelection)
178                      SetValueAsync(_selectedValues.FirstOrDefault()).AndForget();
179                  else
180                  {
181                      if (MultiSelectionTextFunc != null)
182                      {
183                          SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
184                              selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
185                              multiSelectionTextFunc: MultiSelectionTextFunc).AndForget();
186                      }
187                      else
188                      {
189                          SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))), updateValue: false).AndForget();
190                      }
191                  }
192                  SelectedValuesChanged.InvokeAsync(new HashSet<T>(SelectedValues, _comparer));
193                  if (MultiSelection && typeof(T) == typeof(string))
194                      SetValueAsync((T)(object)Text, updateText: false).AndForget();
195              }
196          }
197          [Parameter]
198          [Category(CategoryTypes.FormComponent.Behavior)]
199          public IEqualityComparer<T> Comparer
200          {
201              get => _comparer;
202              set
203              {
204                  _comparer = value;
205                  _selectedValues = new HashSet<T>(_selectedValues, _comparer);
206                  SelectedValues = _selectedValues;
207              }
208          }
209          private Func<T, string> _toStringFunc = x => x?.ToString();
210          private MudInput<string> _elementReference;
211          [Parameter]
212          [Category(CategoryTypes.FormComponent.ListBehavior)]
213          public Func<T, string> ToStringFunc
214          {
215              get => _toStringFunc;
216              set
217              {
218                  if (_toStringFunc == value)
219                      return;
220                  _toStringFunc = value;
221                  Converter = new Converter<T>
222                  {
223                      SetFunc = _toStringFunc ?? (x => x?.ToString()),
224                  };
225              }
226          }
227          public MudSelect()
228          {
229              Adornment = Adornment.End;
230              IconSize = Size.Medium;
231          }
232          protected override void OnAfterRender(bool firstRender)
233          {
234              base.OnAfterRender(firstRender);
235              if (firstRender && Value != null)
236              {
237                  StateHasChanged();
238              }
239              UpdateSelectAllChecked();
240              lock (this)
241              {
242                  if (_renderComplete != null)
243                  {
244                      _renderComplete.TrySetResult();
245                      _renderComplete = null;
246                  }
247              }
248          }
249          private Task WaitForRender()
250          {
251              Task t = null;
252              lock (this)
253              {
254                  if (_renderComplete != null)
255                      return _renderComplete.Task;
256                  _renderComplete = new TaskCompletionSource();
257                  t = _renderComplete.Task;
258              }
259              StateHasChanged();
260              return t;
261          }
262          private TaskCompletionSource _renderComplete;
263          protected bool CanRenderValue
264          {
265              get
266              {
267                  if (Value == null)
268                      return false;
269                  if (!_shadowLookup.TryGetValue(Value, out var item))
270                      return false;
271                  return (item.ChildContent != null);
272              }
273          }
274          protected bool IsValueInList
275          {
276              get
277              {
278                  if (Value == null)
279                      return false;
280                  return _shadowLookup.TryGetValue(Value, out var _);
281              }
282          }
283          protected RenderFragment GetSelectedValuePresenter()
284          {
285              if (Value == null)
286                  return null;
287              if (!_shadowLookup.TryGetValue(Value, out var item))
288                  return null; 
289              return item.ChildContent;
290          }
291          protected override Task UpdateValuePropertyAsync(bool updateText)
292          {
293              if (typeof(T) == typeof(string) || !MultiSelection)
294                  base.UpdateValuePropertyAsync(updateText);
295              return Task.CompletedTask;
296          }
297          protected override Task UpdateTextPropertyAsync(bool updateValue)
298          {
299              if (MultiSelectionTextFunc != null)
300              {
301                  return MultiSelection
302                      ? SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
303                          selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
304                          multiSelectionTextFunc: MultiSelectionTextFunc)
305                      : base.UpdateTextPropertyAsync(updateValue);
306              }
307              else
308              {
309                  return MultiSelection
310                      ? SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))))
311                      : base.UpdateTextPropertyAsync(updateValue);
312              }
313          }
314          internal event Action<ICollection<T>> SelectionChangedFromOutside;
315          private bool _multiSelection;
316          [Parameter]
317          [Category(CategoryTypes.FormComponent.ListBehavior)]
318          public bool MultiSelection
319          {
320              get => _multiSelection;
321              set
322              {
323                  if (value != _multiSelection)
324                  {
325                      _multiSelection = value;
326                      UpdateTextPropertyAsync(false).AndForget();
327                  }
328              }
329          }
330          public IReadOnlyList<MudSelectItem<T>> Items => _items;
331          protected internal List<MudSelectItem<T>> _items = new();
332          protected Dictionary<T, MudSelectItem<T>> _valueLookup = new();
333          protected Dictionary<T, MudSelectItem<T>> _shadowLookup = new();
334          private object _activeItemId = null;
335          internal bool Add(MudSelectItem<T> item)
336          {
337              if (item == null)
338                  return false;
339              bool? result = null;
340              if (!_items.Select(x => x.Value).Contains(item.Value))
341              {
342                  _items.Add(item);
343                  if (item.Value != null)
344                  {
345                      _valueLookup[item.Value] = item;
346                      if (item.Value.Equals(Value) && !MultiSelection)
347                          result = true;
348                  }
349              }
350              UpdateSelectAllChecked();
351              if (result.HasValue == false)
352              {
353                  result = item.Value?.Equals(Value);
354              }
355              return result == true;
356          }
357          internal void Remove(MudSelectItem<T> item)
358          {
359              _items.Remove(item);
360              if (item.Value != null)
361                  _valueLookup.Remove(item.Value);
362          }
363          [Parameter]
364          [Category(CategoryTypes.FormComponent.ListAppearance)]
365          public int MaxHeight { get; set; } = 300;
366          [Parameter]
367          [Category(CategoryTypes.FormComponent.ListAppearance)]
368          public Origin AnchorOrigin { get; set; } = Origin.TopCenter;
369          [Parameter]
370          [Category(CategoryTypes.FormComponent.ListAppearance)]
371          public Origin TransformOrigin { get; set; } = Origin.TopCenter;
372          [ExcludeFromCodeCoverage]
373          [Obsolete("Use AnchorOrigin or TransformOrigin instead.", true)]
374          [Parameter] public Direction Direction { get; set; } = Direction.Bottom;
375          [ExcludeFromCodeCoverage]
376          [Obsolete("Use AnchorOrigin or TransformOrigin instead.", true)]
377          [Parameter] public bool OffsetX { get; set; }
378          [Obsolete("Use AnchorOrigin or TransformOrigin instead.", true)]
379          [Parameter] public bool OffsetY { get; set; }
380          [Parameter]
381          [Category(CategoryTypes.FormComponent.Behavior)]
382          public bool Strict { get; set; }
383          [Parameter]
384          [Category(CategoryTypes.FormComponent.Behavior)]
385          public bool Clearable { get; set; } = false;
386          [Parameter]
387          [Category(CategoryTypes.FormComponent.ListBehavior)]
388          public bool LockScroll { get; set; } = false;
389          [Parameter] public EventCallback<MouseEventArgs> OnClearButtonClick { get; set; }
390          internal bool _isOpen;
391          public string _currentIcon { get; set; }
392          public async Task SelectOption(int index)
393          {
394              if (index < 0 || index >= _items.Count)
395              {
396                  if (!MultiSelection)
397                      await CloseMenu();
398                  return;
399              }
400              await SelectOption(_items[index].Value);
401          }
402          public async Task SelectOption(object obj)
403          {
404              var value = (T)obj;
405              if (MultiSelection)
406              {
407                  if (!_selectedValues.Contains(value))
408                      _selectedValues.Add(value);
409                  else
410                      _selectedValues.Remove(value);
411                  if (MultiSelectionTextFunc != null)
412                  {
413                      await SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
414                          selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
415                          multiSelectionTextFunc: MultiSelectionTextFunc);
416                  }
417                  else
418                  {
419                      await SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))), updateValue: false);
420                  }
421                  UpdateSelectAllChecked();
422                  await BeginValidateAsync();
423              }
424              else
425              {
426                  await CloseMenu(false);
427                  if (EqualityComparer<T>.Default.Equals(Value, value))
428                  {
429                      StateHasChanged();
430                      return;
431                  }
432                  await SetValueAsync(value);
433                  _elementReference.SetText(Text).AndForget();
434                  _selectedValues.Clear();
435                  _selectedValues.Add(value);
436              }
437              HilightItemForValue(value);
438              await SelectedValuesChanged.InvokeAsync(SelectedValues);
439              if (MultiSelection && typeof(T) == typeof(string))
440                  await SetValueAsync((T)(object)Text, updateText: false);
441              await InvokeAsync(StateHasChanged);
442          }
443          private async void HilightItemForValue(T value)
444          {
445              if (value == null)
446              {
447                  HilightItem(null);
448                  return;
449              }
450              await WaitForRender();
451              _valueLookup.TryGetValue(value, out var item);
452              HilightItem(item);
453          }
454          private async void HilightItem(MudSelectItem<T> item)
455          {
456              _activeItemId = item?.ItemId;
457              await WaitForRender();
458              await Task.Delay(1);
459              StateHasChanged();
460          }
461          private async Task HilightSelectedValue()
462          {
463              await WaitForRender();
464              if (MultiSelection)
465                  HilightItem(_items.FirstOrDefault(x => !x.Disabled));
466              else
467                  HilightItemForValue(Value);
468          }
469          private void UpdateSelectAllChecked()
470          {
471              if (MultiSelection && SelectAll)
472              {
473                  var oldState = _selectAllChecked;
474                  if (_selectedValues.Count == 0)
475                  {
476                      _selectAllChecked = false;
477                  }
478                  else if (_items.Count == _selectedValues.Count)
479                  {
480                      _selectAllChecked = true;
481                  }
482                  else
483                  {
484                      _selectAllChecked = null;
485                  }
486              }
487          }
488          public async Task ToggleMenu()
489          {
490              if (GetDisabledState() || GetReadOnlyState())
491                  return;
492              if (_isOpen)
493                  await CloseMenu(true);
494              else
495                  await OpenMenu();
496          }
497          public async Task OpenMenu()
498          {
499              if (GetDisabledState() || GetReadOnlyState())
500                  return;
501              _isOpen = true;
502              UpdateIcon();
503              StateHasChanged();
504              await HilightSelectedValue();
505              if (_activeItemId != null)
506              {
507                  var index = _items.FindIndex(x => x.ItemId == (string)_activeItemId);
508                  if (index > 0)
509                  {
510                      var item = _items[index];
511                      await ScrollToItemAsync(item);
512                  }
513              }
514              await _keyInterceptor.UpdateKey(new() { Key = "Escape", StopDown = "Key+none" });
515              await OnOpen.InvokeAsync();
516          }
517          public async Task CloseMenu(bool focusAgain = true)
518          {
519              _isOpen = false;
520              UpdateIcon();
521              if (focusAgain == true)
522              {
523                  StateHasChanged();
524                  await OnBlur.InvokeAsync(new FocusEventArgs());
525                  _elementReference.FocusAsync().AndForget(ignoreExceptions:true);
526                  StateHasChanged();
527              }
528              await _keyInterceptor.UpdateKey(new() { Key = "Escape", StopDown = "none" });
529              await OnClose.InvokeAsync();
530          }
531          private void UpdateIcon()
532          {
533              _currentIcon = !string.IsNullOrWhiteSpace(AdornmentIcon) ? AdornmentIcon : _isOpen ? CloseIcon : OpenIcon;
534          }
535          protected override void OnInitialized()
536          {
537              base.OnInitialized();
538              UpdateIcon();
539          }
540          protected override void OnParametersSet()
541          {
542              base.OnParametersSet();
543              UpdateIcon();
544          }
545          protected override async Task OnAfterRenderAsync(bool firstRender)
546          {
547              if (firstRender)
548              {
549                  _keyInterceptor = KeyInterceptorFactory.Create();
550                  await _keyInterceptor.Connect(_elementId, new KeyInterceptorOptions()
551                  {
552                      TargetClass = "mud-input-control",
553                      Keys = {
554                          new KeyOptions { Key=" ", PreventDown = "key+none" }, 
555                          new KeyOptions { Key="ArrowUp", PreventDown = "key+none" }, 
556                          new KeyOptions { Key="ArrowDown", PreventDown = "key+none" }, 
557                          new KeyOptions { Key="Home", PreventDown = "key+none" },
558                          new KeyOptions { Key="End", PreventDown = "key+none" },
559                          new KeyOptions { Key="Escape" },
560                          new KeyOptions { Key="Enter", PreventDown = "key+none" },
561                          new KeyOptions { Key="NumpadEnter", PreventDown = "key+none" },
562                          new KeyOptions { Key="a", PreventDown = "key+ctrl" }, 
563                          new KeyOptions { Key="A", PreventDown = "key+ctrl" }, 
564                          new KeyOptions { Key="/./", SubscribeDown = true, SubscribeUp = true }, 
565                      },
566                  });
567                  _keyInterceptor.KeyDown += HandleKeyDown;
568                  _keyInterceptor.KeyUp += HandleKeyUp;
569              }
570              await base.OnAfterRenderAsync(firstRender);
571          }
572          public void CheckGenericTypeMatch(object select_item)
573          {
574              var itemT = select_item.GetType().GenericTypeArguments[0];
575              if (itemT != typeof(T))
576                  throw new GenericTypeMismatchException("MudSelect", "MudSelectItem", typeof(T), itemT);
577          }
578          public override ValueTask FocusAsync()
579          {
580              return _elementReference.FocusAsync();
581          }
582          public override ValueTask BlurAsync()
583          {
584              return _elementReference.BlurAsync();
585          }
586          public override ValueTask SelectAsync()
587          {
588              return _elementReference.SelectAsync();
589          }
590          public override ValueTask SelectRangeAsync(int pos1, int pos2)
591          {
592              return _elementReference.SelectRangeAsync(pos1, pos2);
593          }
594          protected async ValueTask SelectClearButtonClickHandlerAsync(MouseEventArgs e)
595          {
<span onclick='openModal()' class='match'>596              await SetValueAsync(default, false);
597              await SetTextAsync(default, false);
598              _selectedValues.Clear();
599              await BeginValidateAsync();
600              StateHasChanged();
601              await SelectedValuesChanged.InvokeAsync(_selectedValues);
602              await OnClearButtonClick.InvokeAsync(e);
</span>603          }
604          protected async Task SetCustomizedTextAsync(string text, bool updateValue = true,
605              List<string> selectedConvertedValues = null,
606              Func<List<string>, string> multiSelectionTextFunc = null)
607          {
608              Text = multiSelectionTextFunc?.Invoke(selectedConvertedValues);
609              if (multiSelectionText != text)
610              {
611                  multiSelectionText = text;
612                  if (!string.IsNullOrWhiteSpace(multiSelectionText))
613                      Touched = true;
614                  if (updateValue)
615                      await UpdateValuePropertyAsync(false);
616                  await TextChanged.InvokeAsync(multiSelectionText);
617              }
618          }
619          [Parameter]
620          [Category(CategoryTypes.FormComponent.ListAppearance)]
621          public string CheckedIcon { get; set; } = Icons.Material.Filled.CheckBox;
622          [Parameter]
623          [Category(CategoryTypes.FormComponent.ListAppearance)]
624          public string UncheckedIcon { get; set; } = Icons.Material.Filled.CheckBoxOutlineBlank;
625          [Parameter]
626          [Category(CategoryTypes.FormComponent.ListAppearance)]
627          public string IndeterminateIcon { get; set; } = Icons.Material.Filled.IndeterminateCheckBox;
628          protected string SelectAllCheckBoxIcon
629          {
630              get
631              {
632                  return _selectAllChecked.HasValue ? _selectAllChecked.Value ? CheckedIcon : UncheckedIcon : IndeterminateIcon;
633              }
634          }
635          internal async void HandleKeyDown(KeyboardEventArgs obj)
636          {
637              if (GetDisabledState() || GetReadOnlyState())
638                  return;
639              var key = obj.Key.ToLowerInvariant();
640              if (_isOpen && key.Length == 1 && key != " " && !(obj.CtrlKey || obj.ShiftKey || obj.AltKey || obj.MetaKey))
641              {
642                  await SelectFirstItem(key);
643                  return;
644              }
645              switch (obj.Key)
646              {
647                  case "Tab":
648                      await CloseMenu(false);
649                      break;
650                  case "ArrowUp":
651                      if (obj.AltKey == true)
652                      {
653                          await CloseMenu();
654                          break;
655                      }
656                      else if (_isOpen == false)
657                      {
658                          await OpenMenu();
659                          break;
660                      }
661                      else
662                      {
663                          await SelectPreviousItem();
664                          break;
665                      }
666                  case "ArrowDown":
667                      if (obj.AltKey == true)
668                      {
669                          await OpenMenu();
670                          break;
671                      }
672                      else if (_isOpen == false)
673                      {
674                          await OpenMenu();
675                          break;
676                      }
677                      else
678                      {
679                          await SelectNextItem();
680                          break;
681                      }
682                  case " ":
683                      await ToggleMenu();
684                      break;
685                  case "Escape":
686                      await CloseMenu(true);
687                      break;
688                  case "Home":
689                      await SelectFirstItem();
690                      break;
691                  case "End":
692                      await SelectLastItem();
693                      break;
694                  case "Enter":
695                  case "NumpadEnter":
696                      var index = _items.FindIndex(x => x.ItemId == (string)_activeItemId);
697                      if (!MultiSelection)
698                      {
699                          if (!_isOpen)
700                          {
701                              await OpenMenu();
702                              return;
703                          }
704                          await SelectOption(index);
705                          break;
706                      }
707                      else
708                      {
709                          if (_isOpen == false)
710                          {
711                              await OpenMenu();
712                              break;
713                          }
714                          else
715                          {
716                              await SelectOption(index);
717                              await _elementReference.SetText(Text);
718                              break;
719                          }
720                      }
721                  case "a":
722                  case "A":
723                      if (obj.CtrlKey == true)
724                      {
725                          if (MultiSelection)
726                          {
727                              await SelectAllClickAsync();
728                              await WaitForRender();
729                              await Task.Delay(1);
730                              StateHasChanged();
731                          }
732                      }
733                      break;
734              }
735              OnKeyDown.InvokeAsync(obj).AndForget();
736          }
737          internal void HandleKeyUp(KeyboardEventArgs obj)
738          {
739              OnKeyUp.InvokeAsync(obj).AndForget();
740          }
741          [ExcludeFromCodeCoverage]
742          [Obsolete("Use Clear instead.", true)]
743          public Task ClearAsync() => Clear();
744          public async Task Clear()
745          {
746              await SetValueAsync(default, false);
747              await SetTextAsync(default, false);
748              _selectedValues.Clear();
749              await BeginValidateAsync();
750              StateHasChanged();
751              await SelectedValuesChanged.InvokeAsync(_selectedValues);
752          }
753          private async Task SelectAllClickAsync()
754          {
755              if (!_selectAllChecked.HasValue)
756                  _selectAllChecked = true;
757              else if (_selectAllChecked.Value)
758                  _selectAllChecked = false;
759              else
760                  _selectAllChecked = true;
761              if (_selectAllChecked.Value == true)
762                  await SelectAllItems();
763              else
764                  await Clear();
765          }
766          private async Task SelectAllItems()
767          {
768              if (!MultiSelection)
769                  return;
770              var selectedValues = new HashSet<T>(_items.Where(x => !x.Disabled && x.Value != null).Select(x => x.Value), _comparer);
771              _selectedValues = new HashSet<T>(selectedValues, _comparer);
772              if (MultiSelectionTextFunc != null)
773              {
774                  await SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
775                      selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
776                      multiSelectionTextFunc: MultiSelectionTextFunc);
777              }
778              else
779              {
780                  await SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))), updateValue: false);
781              }
782              UpdateSelectAllChecked();
783              _selectedValues = selectedValues; 
784              await BeginValidateAsync();
785              await SelectedValuesChanged.InvokeAsync(SelectedValues);
786              if (MultiSelection && typeof(T) == typeof(string))
787                  SetValueAsync((T)(object)Text, updateText: false).AndForget();
788          }
789          public void RegisterShadowItem(MudSelectItem<T> item)
790          {
791              if (item == null || item.Value == null)
792                  return;
793              _shadowLookup[item.Value] = item;
794          }
795          public void UnregisterShadowItem(MudSelectItem<T> item)
796          {
797              if (item == null || item.Value == null)
798                  return;
799              _shadowLookup.Remove(item.Value);
800          }
801          private async Task OnFocusOutAsync(FocusEventArgs focusEventArgs)
802          {
803              if (_isOpen)
804              {
805                  await FocusAsync();
806              }
807          }
808          internal Task OnBlurAsync(FocusEventArgs obj)
809          {
810              return base.OnBlur.InvokeAsync(obj);
811          }
812          protected override void Dispose(bool disposing)
813          {
814              base.Dispose(disposing);
815              if (disposing == true)
816              {
817                  if (_keyInterceptor != null)
818                  {
819                      _keyInterceptor.KeyDown -= HandleKeyDown;
820                      _keyInterceptor.KeyUp -= HandleKeyUp;
821                      _keyInterceptor.Dispose();
822                  }
823              }
824          }
825          protected override bool HasValue(T value)
826          {
827              if (MultiSelection)
828                  return SelectedValues?.Count() > 0;
829              else
830                  return base.HasValue(value);
831          }
832          public override async Task ForceUpdate()
833          {
834              await base.ForceUpdate();
835              if (MultiSelection == false)
836              {
837                  SelectedValues = new HashSet<T>(_comparer) { Value };
838              }
839              else
840              {
841                  await SelectedValuesChanged.InvokeAsync(new HashSet<T>(SelectedValues, _comparer));
842              }
843          }
844      }
845  }
</code></pre>
        </div>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudSelect.razor.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics.CodeAnalysis;
4  using System.Linq;
5  using System.Threading.Tasks;
6  using Microsoft.AspNetCore.Components;
7  using Microsoft.AspNetCore.Components.Web;
8  using MudBlazor.Services;
9  using MudBlazor.Utilities;
10  using MudBlazor.Utilities.Exceptions;
11  namespace MudBlazor
12  {
13      public partial class MudSelect<T> : MudBaseInput<T>, IMudSelect, IMudShadowSelect
14      {
15          private HashSet<T> _selectedValues = new HashSet<T>();
16          private IEqualityComparer<T> _comparer;
17          private bool _dense;
18          private string multiSelectionText;
19          private bool? _selectAllChecked;
20          private IKeyInterceptor _keyInterceptor;
21          protected string Classname =>
22              new CssBuilder("mud-select")
23              .AddClass(Class)
24              .Build();
25          [Inject] private IKeyInterceptorFactory KeyInterceptorFactory { get; set; }
26          [Inject] IScrollManager ScrollManager { get; set; }
27          private string _elementId = "select_" + Guid.NewGuid().ToString().Substring(0, 8);
28          private Task SelectNextItem() => SelectAdjacentItem(+1);
29          private Task SelectPreviousItem() => SelectAdjacentItem(-1);
30          private async Task SelectAdjacentItem(int direction)
31          {
32              if (_items == null || _items.Count == 0)
33                  return;
34              var index = _items.FindIndex(x => x.ItemId == (string)_activeItemId);
35              if (direction < 0 && index < 0)
36                  index = 0;
37              MudSelectItem<T> item = null;
38              for (int i = 0; i < _items.Count; i++)
39              {
40                  index += direction;
41                  if (index < 0)
42                      index = 0;
43                  if (index >= _items.Count)
44                      index = _items.Count - 1;
45                  if (_items[index].Disabled)
46                      continue;
47                  item = _items[index];
48                  if (!MultiSelection)
49                  {
50                      _selectedValues.Clear();
51                      _selectedValues.Add(item.Value);
52                      await SetValueAsync(item.Value, updateText: true);
53                      HilightItem(item);
54                      break;
55                  }
56                  else
57                  {
58                      HilightItem(item);
59                      break;
60                  }
61              }
62              await _elementReference.SetText(Text);
63              await ScrollToItemAsync(item);
64          }
65          private ValueTask ScrollToItemAsync(MudSelectItem<T> item)
66              =>item != null? ScrollManager.ScrollToListItemAsync(item.ItemId): ValueTask.CompletedTask;
67          private async Task SelectFirstItem(string startChar = null)
68          {
69              if (_items == null || _items.Count == 0)
70                  return;
71              var items = _items.Where(x => !x.Disabled);
72              var firstItem = items.FirstOrDefault();
73              if (!string.IsNullOrWhiteSpace(startChar))
74              {
75                  var currentItem = items.FirstOrDefault(x => x.ItemId == (string)_activeItemId);
76                  if (currentItem != null &&
77                      Converter.Set(currentItem.Value)?.ToLowerInvariant().StartsWith(startChar) == true)
78                  {
79                      items = items.SkipWhile(x => x != currentItem).Skip(1);
80                  }
81                  items = items.Where(x => Converter.Set(x.Value)?.ToLowerInvariant().StartsWith(startChar) == true);
82              }
83              var item = items.FirstOrDefault();
84              if (item == null)
85                  return;
86              if (!MultiSelection)
87              {
88                  _selectedValues.Clear();
89                  _selectedValues.Add(item.Value);
90                  await SetValueAsync(item.Value, updateText: true);
91                  HilightItem(item);
92              }
93              else
94              {
95                  HilightItem(item);
96              }
97              await _elementReference.SetText(Text);
98              await ScrollToItemAsync(item);
99          }
100          private async Task SelectLastItem()
101          {
102              if (_items == null || _items.Count == 0)
103                  return;
104              var item = _items.LastOrDefault(x => !x.Disabled);
105              if (item == null)
106                  return;
107              if (!MultiSelection)
108              {
109                  _selectedValues.Clear();
110                  _selectedValues.Add(item.Value);
111                  await SetValueAsync(item.Value, updateText: true);
112                  HilightItem(item);
113              }
114              else
115              {
116                  HilightItem(item);
117              }
118              await _elementReference.SetText(Text);
119              await ScrollToItemAsync(item);
120          }
121          [Category(CategoryTypes.FormComponent.Behavior)]
122          [Parameter] public EventCallback OnOpen { get; set; }
123          [Category(CategoryTypes.FormComponent.Behavior)]
124          [Parameter] public EventCallback OnClose { get; set; }
125          [Parameter]
126          [Category(CategoryTypes.FormComponent.ListBehavior)]
127          public RenderFragment ChildContent { get; set; }
128          [Parameter]
129          [Category(CategoryTypes.FormComponent.ListAppearance)]
130          public string PopoverClass { get; set; }
131          [Parameter]
132          [Category(CategoryTypes.FormComponent.ListAppearance)]
133          public string ListClass { get; set; }
134          [Parameter]
135          [Category(CategoryTypes.FormComponent.ListAppearance)]
136          public bool Dense
137          {
138              get { return _dense; }
139              set { _dense = value; }
140          }
141          [Parameter]
142          [Category(CategoryTypes.FormComponent.Appearance)]
143          public string OpenIcon { get; set; } = Icons.Material.Filled.ArrowDropDown;
144          [Parameter]
145          [Category(CategoryTypes.FormComponent.Appearance)]
146          public string CloseIcon { get; set; } = Icons.Material.Filled.ArrowDropUp;
147          [Parameter]
148          [Category(CategoryTypes.FormComponent.ListBehavior)]
149          public bool SelectAll { get; set; }
150          [Parameter]
151          [Category(CategoryTypes.FormComponent.ListAppearance)]
152          public string SelectAllText { get; set; } = "Select all";
153          [Parameter] public EventCallback<IEnumerable<T>> SelectedValuesChanged { get; set; }
154          [Parameter]
155          [Category(CategoryTypes.FormComponent.Behavior)]
156          public Func<List<string>, string> MultiSelectionTextFunc { get; set; }
157          [Parameter]
158          [Category(CategoryTypes.FormComponent.Behavior)]
159          public string Delimiter { get; set; } = ", ";
160          [Parameter]
161          [Category(CategoryTypes.FormComponent.Data)]
162          public IEnumerable<T> SelectedValues
163          {
164              get
165              {
166                  if (_selectedValues == null)
167                      _selectedValues = new HashSet<T>(_comparer);
168                  return _selectedValues;
169              }
170              set
171              {
172                  var set = value ?? new HashSet<T>(_comparer);
173                  if (SelectedValues.Count() == set.Count() && _selectedValues.All(x => set.Contains(x)))
174                      return;
175                  _selectedValues = new HashSet<T>(set, _comparer);
176                  SelectionChangedFromOutside?.Invoke(_selectedValues);
177                  if (!MultiSelection)
178                      SetValueAsync(_selectedValues.FirstOrDefault()).AndForget();
179                  else
180                  {
181                      if (MultiSelectionTextFunc != null)
182                      {
183                          SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
184                              selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
185                              multiSelectionTextFunc: MultiSelectionTextFunc).AndForget();
186                      }
187                      else
188                      {
189                          SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))), updateValue: false).AndForget();
190                      }
191                  }
192                  SelectedValuesChanged.InvokeAsync(new HashSet<T>(SelectedValues, _comparer));
193                  if (MultiSelection && typeof(T) == typeof(string))
194                      SetValueAsync((T)(object)Text, updateText: false).AndForget();
195              }
196          }
197          [Parameter]
198          [Category(CategoryTypes.FormComponent.Behavior)]
199          public IEqualityComparer<T> Comparer
200          {
201              get => _comparer;
202              set
203              {
204                  _comparer = value;
205                  _selectedValues = new HashSet<T>(_selectedValues, _comparer);
206                  SelectedValues = _selectedValues;
207              }
208          }
209          private Func<T, string> _toStringFunc = x => x?.ToString();
210          private MudInput<string> _elementReference;
211          [Parameter]
212          [Category(CategoryTypes.FormComponent.ListBehavior)]
213          public Func<T, string> ToStringFunc
214          {
215              get => _toStringFunc;
216              set
217              {
218                  if (_toStringFunc == value)
219                      return;
220                  _toStringFunc = value;
221                  Converter = new Converter<T>
222                  {
223                      SetFunc = _toStringFunc ?? (x => x?.ToString()),
224                  };
225              }
226          }
227          public MudSelect()
228          {
229              Adornment = Adornment.End;
230              IconSize = Size.Medium;
231          }
232          protected override void OnAfterRender(bool firstRender)
233          {
234              base.OnAfterRender(firstRender);
235              if (firstRender && Value != null)
236              {
237                  StateHasChanged();
238              }
239              UpdateSelectAllChecked();
240              lock (this)
241              {
242                  if (_renderComplete != null)
243                  {
244                      _renderComplete.TrySetResult();
245                      _renderComplete = null;
246                  }
247              }
248          }
249          private Task WaitForRender()
250          {
251              Task t = null;
252              lock (this)
253              {
254                  if (_renderComplete != null)
255                      return _renderComplete.Task;
256                  _renderComplete = new TaskCompletionSource();
257                  t = _renderComplete.Task;
258              }
259              StateHasChanged();
260              return t;
261          }
262          private TaskCompletionSource _renderComplete;
263          protected bool CanRenderValue
264          {
265              get
266              {
267                  if (Value == null)
268                      return false;
269                  if (!_shadowLookup.TryGetValue(Value, out var item))
270                      return false;
271                  return (item.ChildContent != null);
272              }
273          }
274          protected bool IsValueInList
275          {
276              get
277              {
278                  if (Value == null)
279                      return false;
280                  return _shadowLookup.TryGetValue(Value, out var _);
281              }
282          }
283          protected RenderFragment GetSelectedValuePresenter()
284          {
285              if (Value == null)
286                  return null;
287              if (!_shadowLookup.TryGetValue(Value, out var item))
288                  return null; 
289              return item.ChildContent;
290          }
291          protected override Task UpdateValuePropertyAsync(bool updateText)
292          {
293              if (typeof(T) == typeof(string) || !MultiSelection)
294                  base.UpdateValuePropertyAsync(updateText);
295              return Task.CompletedTask;
296          }
297          protected override Task UpdateTextPropertyAsync(bool updateValue)
298          {
299              if (MultiSelectionTextFunc != null)
300              {
301                  return MultiSelection
302                      ? SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
303                          selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
304                          multiSelectionTextFunc: MultiSelectionTextFunc)
305                      : base.UpdateTextPropertyAsync(updateValue);
306              }
307              else
308              {
309                  return MultiSelection
310                      ? SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))))
311                      : base.UpdateTextPropertyAsync(updateValue);
312              }
313          }
314          internal event Action<ICollection<T>> SelectionChangedFromOutside;
315          private bool _multiSelection;
316          [Parameter]
317          [Category(CategoryTypes.FormComponent.ListBehavior)]
318          public bool MultiSelection
319          {
320              get => _multiSelection;
321              set
322              {
323                  if (value != _multiSelection)
324                  {
325                      _multiSelection = value;
326                      UpdateTextPropertyAsync(false).AndForget();
327                  }
328              }
329          }
330          public IReadOnlyList<MudSelectItem<T>> Items => _items;
331          protected internal List<MudSelectItem<T>> _items = new();
332          protected Dictionary<T, MudSelectItem<T>> _valueLookup = new();
333          protected Dictionary<T, MudSelectItem<T>> _shadowLookup = new();
334          private object _activeItemId = null;
335          internal bool Add(MudSelectItem<T> item)
336          {
337              if (item == null)
338                  return false;
339              bool? result = null;
340              if (!_items.Select(x => x.Value).Contains(item.Value))
341              {
342                  _items.Add(item);
343                  if (item.Value != null)
344                  {
345                      _valueLookup[item.Value] = item;
346                      if (item.Value.Equals(Value) && !MultiSelection)
347                          result = true;
348                  }
349              }
350              UpdateSelectAllChecked();
351              if (result.HasValue == false)
352              {
353                  result = item.Value?.Equals(Value);
354              }
355              return result == true;
356          }
357          internal void Remove(MudSelectItem<T> item)
358          {
359              _items.Remove(item);
360              if (item.Value != null)
361                  _valueLookup.Remove(item.Value);
362          }
363          [Parameter]
364          [Category(CategoryTypes.FormComponent.ListAppearance)]
365          public int MaxHeight { get; set; } = 300;
366          [Parameter]
367          [Category(CategoryTypes.FormComponent.ListAppearance)]
368          public Origin AnchorOrigin { get; set; } = Origin.TopCenter;
369          [Parameter]
370          [Category(CategoryTypes.FormComponent.ListAppearance)]
371          public Origin TransformOrigin { get; set; } = Origin.TopCenter;
372          [ExcludeFromCodeCoverage]
373          [Obsolete("Use AnchorOrigin or TransformOrigin instead.", true)]
374          [Parameter] public Direction Direction { get; set; } = Direction.Bottom;
375          [ExcludeFromCodeCoverage]
376          [Obsolete("Use AnchorOrigin or TransformOrigin instead.", true)]
377          [Parameter] public bool OffsetX { get; set; }
378          [Obsolete("Use AnchorOrigin or TransformOrigin instead.", true)]
379          [Parameter] public bool OffsetY { get; set; }
380          [Parameter]
381          [Category(CategoryTypes.FormComponent.Behavior)]
382          public bool Strict { get; set; }
383          [Parameter]
384          [Category(CategoryTypes.FormComponent.Behavior)]
385          public bool Clearable { get; set; } = false;
386          [Parameter]
387          [Category(CategoryTypes.FormComponent.ListBehavior)]
388          public bool LockScroll { get; set; } = false;
389          [Parameter] public EventCallback<MouseEventArgs> OnClearButtonClick { get; set; }
390          internal bool _isOpen;
391          public string _currentIcon { get; set; }
392          public async Task SelectOption(int index)
393          {
394              if (index < 0 || index >= _items.Count)
395              {
396                  if (!MultiSelection)
397                      await CloseMenu();
398                  return;
399              }
400              await SelectOption(_items[index].Value);
401          }
402          public async Task SelectOption(object obj)
403          {
404              var value = (T)obj;
405              if (MultiSelection)
406              {
407                  if (!_selectedValues.Contains(value))
408                      _selectedValues.Add(value);
409                  else
410                      _selectedValues.Remove(value);
411                  if (MultiSelectionTextFunc != null)
412                  {
413                      await SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
414                          selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
415                          multiSelectionTextFunc: MultiSelectionTextFunc);
416                  }
417                  else
418                  {
419                      await SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))), updateValue: false);
420                  }
421                  UpdateSelectAllChecked();
422                  await BeginValidateAsync();
423              }
424              else
425              {
426                  await CloseMenu(false);
427                  if (EqualityComparer<T>.Default.Equals(Value, value))
428                  {
429                      StateHasChanged();
430                      return;
431                  }
432                  await SetValueAsync(value);
433                  _elementReference.SetText(Text).AndForget();
434                  _selectedValues.Clear();
435                  _selectedValues.Add(value);
436              }
437              HilightItemForValue(value);
438              await SelectedValuesChanged.InvokeAsync(SelectedValues);
439              if (MultiSelection && typeof(T) == typeof(string))
440                  await SetValueAsync((T)(object)Text, updateText: false);
441              await InvokeAsync(StateHasChanged);
442          }
443          private async void HilightItemForValue(T value)
444          {
445              if (value == null)
446              {
447                  HilightItem(null);
448                  return;
449              }
450              await WaitForRender();
451              _valueLookup.TryGetValue(value, out var item);
452              HilightItem(item);
453          }
454          private async void HilightItem(MudSelectItem<T> item)
455          {
456              _activeItemId = item?.ItemId;
457              await WaitForRender();
458              await Task.Delay(1);
459              StateHasChanged();
460          }
461          private async Task HilightSelectedValue()
462          {
463              await WaitForRender();
464              if (MultiSelection)
465                  HilightItem(_items.FirstOrDefault(x => !x.Disabled));
466              else
467                  HilightItemForValue(Value);
468          }
469          private void UpdateSelectAllChecked()
470          {
471              if (MultiSelection && SelectAll)
472              {
473                  var oldState = _selectAllChecked;
474                  if (_selectedValues.Count == 0)
475                  {
476                      _selectAllChecked = false;
477                  }
478                  else if (_items.Count == _selectedValues.Count)
479                  {
480                      _selectAllChecked = true;
481                  }
482                  else
483                  {
484                      _selectAllChecked = null;
485                  }
486              }
487          }
488          public async Task ToggleMenu()
489          {
490              if (GetDisabledState() || GetReadOnlyState())
491                  return;
492              if (_isOpen)
493                  await CloseMenu(true);
494              else
495                  await OpenMenu();
496          }
497          public async Task OpenMenu()
498          {
499              if (GetDisabledState() || GetReadOnlyState())
500                  return;
501              _isOpen = true;
502              UpdateIcon();
503              StateHasChanged();
504              await HilightSelectedValue();
505              if (_activeItemId != null)
506              {
507                  var index = _items.FindIndex(x => x.ItemId == (string)_activeItemId);
508                  if (index > 0)
509                  {
510                      var item = _items[index];
511                      await ScrollToItemAsync(item);
512                  }
513              }
514              await _keyInterceptor.UpdateKey(new() { Key = "Escape", StopDown = "Key+none" });
515              await OnOpen.InvokeAsync();
516          }
517          public async Task CloseMenu(bool focusAgain = true)
518          {
519              _isOpen = false;
520              UpdateIcon();
521              if (focusAgain == true)
522              {
523                  StateHasChanged();
524                  await OnBlur.InvokeAsync(new FocusEventArgs());
525                  _elementReference.FocusAsync().AndForget(ignoreExceptions:true);
526                  StateHasChanged();
527              }
528              await _keyInterceptor.UpdateKey(new() { Key = "Escape", StopDown = "none" });
529              await OnClose.InvokeAsync();
530          }
531          private void UpdateIcon()
532          {
533              _currentIcon = !string.IsNullOrWhiteSpace(AdornmentIcon) ? AdornmentIcon : _isOpen ? CloseIcon : OpenIcon;
534          }
535          protected override void OnInitialized()
536          {
537              base.OnInitialized();
538              UpdateIcon();
539          }
540          protected override void OnParametersSet()
541          {
542              base.OnParametersSet();
543              UpdateIcon();
544          }
545          protected override async Task OnAfterRenderAsync(bool firstRender)
546          {
547              if (firstRender)
548              {
549                  _keyInterceptor = KeyInterceptorFactory.Create();
550                  await _keyInterceptor.Connect(_elementId, new KeyInterceptorOptions()
551                  {
552                      TargetClass = "mud-input-control",
553                      Keys = {
554                          new KeyOptions { Key=" ", PreventDown = "key+none" }, 
555                          new KeyOptions { Key="ArrowUp", PreventDown = "key+none" }, 
556                          new KeyOptions { Key="ArrowDown", PreventDown = "key+none" }, 
557                          new KeyOptions { Key="Home", PreventDown = "key+none" },
558                          new KeyOptions { Key="End", PreventDown = "key+none" },
559                          new KeyOptions { Key="Escape" },
560                          new KeyOptions { Key="Enter", PreventDown = "key+none" },
561                          new KeyOptions { Key="NumpadEnter", PreventDown = "key+none" },
562                          new KeyOptions { Key="a", PreventDown = "key+ctrl" }, 
563                          new KeyOptions { Key="A", PreventDown = "key+ctrl" }, 
564                          new KeyOptions { Key="/./", SubscribeDown = true, SubscribeUp = true }, 
565                      },
566                  });
567                  _keyInterceptor.KeyDown += HandleKeyDown;
568                  _keyInterceptor.KeyUp += HandleKeyUp;
569              }
570              await base.OnAfterRenderAsync(firstRender);
571          }
572          public void CheckGenericTypeMatch(object select_item)
573          {
574              var itemT = select_item.GetType().GenericTypeArguments[0];
575              if (itemT != typeof(T))
576                  throw new GenericTypeMismatchException("MudSelect", "MudSelectItem", typeof(T), itemT);
577          }
578          public override ValueTask FocusAsync()
579          {
580              return _elementReference.FocusAsync();
581          }
582          public override ValueTask BlurAsync()
583          {
584              return _elementReference.BlurAsync();
585          }
586          public override ValueTask SelectAsync()
587          {
588              return _elementReference.SelectAsync();
589          }
590          public override ValueTask SelectRangeAsync(int pos1, int pos2)
591          {
592              return _elementReference.SelectRangeAsync(pos1, pos2);
593          }
594          protected async ValueTask SelectClearButtonClickHandlerAsync(MouseEventArgs e)
595          {
596              await SetValueAsync(default, false);
597              await SetTextAsync(default, false);
598              _selectedValues.Clear();
599              await BeginValidateAsync();
600              StateHasChanged();
601              await SelectedValuesChanged.InvokeAsync(_selectedValues);
602              await OnClearButtonClick.InvokeAsync(e);
603          }
604          protected async Task SetCustomizedTextAsync(string text, bool updateValue = true,
605              List<string> selectedConvertedValues = null,
606              Func<List<string>, string> multiSelectionTextFunc = null)
607          {
608              Text = multiSelectionTextFunc?.Invoke(selectedConvertedValues);
609              if (multiSelectionText != text)
610              {
611                  multiSelectionText = text;
612                  if (!string.IsNullOrWhiteSpace(multiSelectionText))
613                      Touched = true;
614                  if (updateValue)
615                      await UpdateValuePropertyAsync(false);
616                  await TextChanged.InvokeAsync(multiSelectionText);
617              }
618          }
619          [Parameter]
620          [Category(CategoryTypes.FormComponent.ListAppearance)]
621          public string CheckedIcon { get; set; } = Icons.Material.Filled.CheckBox;
622          [Parameter]
623          [Category(CategoryTypes.FormComponent.ListAppearance)]
624          public string UncheckedIcon { get; set; } = Icons.Material.Filled.CheckBoxOutlineBlank;
625          [Parameter]
626          [Category(CategoryTypes.FormComponent.ListAppearance)]
627          public string IndeterminateIcon { get; set; } = Icons.Material.Filled.IndeterminateCheckBox;
628          protected string SelectAllCheckBoxIcon
629          {
630              get
631              {
632                  return _selectAllChecked.HasValue ? _selectAllChecked.Value ? CheckedIcon : UncheckedIcon : IndeterminateIcon;
633              }
634          }
635          internal async void HandleKeyDown(KeyboardEventArgs obj)
636          {
637              if (GetDisabledState() || GetReadOnlyState())
638                  return;
639              var key = obj.Key.ToLowerInvariant();
640              if (_isOpen && key.Length == 1 && key != " " && !(obj.CtrlKey || obj.ShiftKey || obj.AltKey || obj.MetaKey))
641              {
642                  await SelectFirstItem(key);
643                  return;
644              }
645              switch (obj.Key)
646              {
647                  case "Tab":
648                      await CloseMenu(false);
649                      break;
650                  case "ArrowUp":
651                      if (obj.AltKey == true)
652                      {
653                          await CloseMenu();
654                          break;
655                      }
656                      else if (_isOpen == false)
657                      {
658                          await OpenMenu();
659                          break;
660                      }
661                      else
662                      {
663                          await SelectPreviousItem();
664                          break;
665                      }
666                  case "ArrowDown":
667                      if (obj.AltKey == true)
668                      {
669                          await OpenMenu();
670                          break;
671                      }
672                      else if (_isOpen == false)
673                      {
674                          await OpenMenu();
675                          break;
676                      }
677                      else
678                      {
679                          await SelectNextItem();
680                          break;
681                      }
682                  case " ":
683                      await ToggleMenu();
684                      break;
685                  case "Escape":
686                      await CloseMenu(true);
687                      break;
688                  case "Home":
689                      await SelectFirstItem();
690                      break;
691                  case "End":
692                      await SelectLastItem();
693                      break;
694                  case "Enter":
695                  case "NumpadEnter":
696                      var index = _items.FindIndex(x => x.ItemId == (string)_activeItemId);
697                      if (!MultiSelection)
698                      {
699                          if (!_isOpen)
700                          {
701                              await OpenMenu();
702                              return;
703                          }
704                          await SelectOption(index);
705                          break;
706                      }
707                      else
708                      {
709                          if (_isOpen == false)
710                          {
711                              await OpenMenu();
712                              break;
713                          }
714                          else
715                          {
716                              await SelectOption(index);
717                              await _elementReference.SetText(Text);
718                              break;
719                          }
720                      }
721                  case "a":
722                  case "A":
723                      if (obj.CtrlKey == true)
724                      {
725                          if (MultiSelection)
726                          {
727                              await SelectAllClickAsync();
728                              await WaitForRender();
729                              await Task.Delay(1);
730                              StateHasChanged();
731                          }
732                      }
733                      break;
734              }
735              OnKeyDown.InvokeAsync(obj).AndForget();
736          }
737          internal void HandleKeyUp(KeyboardEventArgs obj)
738          {
739              OnKeyUp.InvokeAsync(obj).AndForget();
740          }
741          [ExcludeFromCodeCoverage]
742          [Obsolete("Use Clear instead.", true)]
743          public Task ClearAsync() => Clear();
744          public async Task Clear()
745          {
<span onclick='openModal()' class='match'>746              await SetValueAsync(default, false);
747              await SetTextAsync(default, false);
748              _selectedValues.Clear();
749              await BeginValidateAsync();
750              StateHasChanged();
751              await SelectedValuesChanged.InvokeAsync(_selectedValues);
752          }
</span>753          private async Task SelectAllClickAsync()
754          {
755              if (!_selectAllChecked.HasValue)
756                  _selectAllChecked = true;
757              else if (_selectAllChecked.Value)
758                  _selectAllChecked = false;
759              else
760                  _selectAllChecked = true;
761              if (_selectAllChecked.Value == true)
762                  await SelectAllItems();
763              else
764                  await Clear();
765          }
766          private async Task SelectAllItems()
767          {
768              if (!MultiSelection)
769                  return;
770              var selectedValues = new HashSet<T>(_items.Where(x => !x.Disabled && x.Value != null).Select(x => x.Value), _comparer);
771              _selectedValues = new HashSet<T>(selectedValues, _comparer);
772              if (MultiSelectionTextFunc != null)
773              {
774                  await SetCustomizedTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))),
775                      selectedConvertedValues: SelectedValues.Select(x => Converter.Set(x)).ToList(),
776                      multiSelectionTextFunc: MultiSelectionTextFunc);
777              }
778              else
779              {
780                  await SetTextAsync(string.Join(Delimiter, SelectedValues.Select(x => Converter.Set(x))), updateValue: false);
781              }
782              UpdateSelectAllChecked();
783              _selectedValues = selectedValues; 
784              await BeginValidateAsync();
785              await SelectedValuesChanged.InvokeAsync(SelectedValues);
786              if (MultiSelection && typeof(T) == typeof(string))
787                  SetValueAsync((T)(object)Text, updateText: false).AndForget();
788          }
789          public void RegisterShadowItem(MudSelectItem<T> item)
790          {
791              if (item == null || item.Value == null)
792                  return;
793              _shadowLookup[item.Value] = item;
794          }
795          public void UnregisterShadowItem(MudSelectItem<T> item)
796          {
797              if (item == null || item.Value == null)
798                  return;
799              _shadowLookup.Remove(item.Value);
800          }
801          private async Task OnFocusOutAsync(FocusEventArgs focusEventArgs)
802          {
803              if (_isOpen)
804              {
805                  await FocusAsync();
806              }
807          }
808          internal Task OnBlurAsync(FocusEventArgs obj)
809          {
810              return base.OnBlur.InvokeAsync(obj);
811          }
812          protected override void Dispose(bool disposing)
813          {
814              base.Dispose(disposing);
815              if (disposing == true)
816              {
817                  if (_keyInterceptor != null)
818                  {
819                      _keyInterceptor.KeyDown -= HandleKeyDown;
820                      _keyInterceptor.KeyUp -= HandleKeyUp;
821                      _keyInterceptor.Dispose();
822                  }
823              }
824          }
825          protected override bool HasValue(T value)
826          {
827              if (MultiSelection)
828                  return SelectedValues?.Count() > 0;
829              else
830                  return base.HasValue(value);
831          }
832          public override async Task ForceUpdate()
833          {
834              await base.ForceUpdate();
835              if (MultiSelection == false)
836              {
837                  SelectedValues = new HashSet<T>(_comparer) { Value };
838              }
839              else
840              {
841                  await SelectedValuesChanged.InvokeAsync(new HashSet<T>(SelectedValues, _comparer));
842              }
843          }
844      }
845  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudSelect.razor.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-MudSelect.razor.cs</div>
                </div>
                <div class="column column_space"><pre><code>596              await SetValueAsync(default, false);
597              await SetTextAsync(default, false);
598              _selectedValues.Clear();
599              await BeginValidateAsync();
600              StateHasChanged();
601              await SelectedValuesChanged.InvokeAsync(_selectedValues);
602              await OnClearButtonClick.InvokeAsync(e);
</pre></code></div>
                <div class="column column_space"><pre><code>746              await SetValueAsync(default, false);
747              await SetTextAsync(default, false);
748              _selectedValues.Clear();
749              await BeginValidateAsync();
750              StateHasChanged();
751              await SelectedValuesChanged.InvokeAsync(_selectedValues);
752          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    