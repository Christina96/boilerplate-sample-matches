
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PagingLoggerL0.cs</h3>
            <pre><code>1  using Moq;
2  using System;
3  using System.IO;
4  using Xunit;
5  namespace GitHub.Runner.Common.Tests.Listener
6  {
7      public sealed class PagingLoggerL0
8      {
9          private const string LogData = "messagemessagemessagemessagemessagemessagemessagemessageXPLATmessagemessagemessagemessagemessagemessagemessagemessage";
10          private const int PagesToWrite = 2;
11          private Mock<IJobServerQueue> _jobServerQueue;
12          public PagingLoggerL0()
13          {
14              _jobServerQueue = new Mock<IJobServerQueue>();
15              PagingLogger.PagingFolder = "pages_" + Guid.NewGuid().ToString();
16          }
17          private void CleanLogFolder()
18          {
19              using (TestHostContext hc = new(this))
20              {
21                  string pagesFolder = Path.Combine(hc.GetDirectory(WellKnownDirectory.Diag), PagingLogger.PagingFolder);
22                  if (Directory.Exists(pagesFolder))
23                  {
24                      Directory.Delete(pagesFolder, true);
25                  }
26              }
27          }
28          [Fact]
29          [Trait("Level", "L0")]
30          [Trait("Category", "Common")]
31          public void WriteAndShipLog()
32          {
33              CleanLogFolder();
34              try
35              {
36                  using (var hc = new TestHostContext(this))
37                  {
38                      var pagingLogger = new PagingLogger();
<span onclick='openModal()' class='match'>39                      hc.SetSingleton<IJobServerQueue>(_jobServerQueue.Object);
40                      pagingLogger.Initialize(hc);
</span>41                      Guid timeLineId = Guid.NewGuid();
42                      Guid timeLineRecordId = Guid.NewGuid();
43                      int totalBytes = PagesToWrite * PagingLogger.PageSize;
44                      int bytesWritten = 0;
45                      int logDataSize = System.Text.Encoding.UTF8.GetByteCount(LogData);
46                      _jobServerQueue.Setup(x => x.QueueFileUpload(timeLineId, timeLineRecordId, It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), true))
47                          .Callback((Guid timelineId, Guid timelineRecordId, string type, string name, string path, bool deleteSource) =>
48                          {
49                              bool fileExists = File.Exists(path);
50                              Assert.True(fileExists);
51                              using (var freader = new StreamReader(new FileStream(path, FileMode.Open, FileAccess.Read), System.Text.Encoding.UTF8))
52                              {
53                                  string line;
54                                  while ((line = freader.ReadLine()) != null)
55                                  {
56                                      Assert.EndsWith(LogData, line);
57                                      bytesWritten += logDataSize;
58                                  }
59                              }
60                              File.Delete(path);
61                          });
62                      int bytesSent = 0;
63                      pagingLogger.Setup(timeLineId, timeLineRecordId);
64                      while (bytesSent < totalBytes)
65                      {
66                          pagingLogger.Write(LogData);
67                          bytesSent += logDataSize;
68                      }
69                      pagingLogger.End();
70                      _jobServerQueue.Verify(x => x.QueueFileUpload(timeLineId, timeLineRecordId, It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), true), Times.AtLeast(PagesToWrite));
71                      Assert.Equal(bytesSent, bytesWritten);
72                  }
73              }
74              finally
75              {
76                  CleanLogFolder();
77              }
78          }
79          [Fact]
80          [Trait("Level", "L0")]
81          [Trait("Category", "Common")]
82          public void ShipEmptyLog()
83          {
84              CleanLogFolder();
85              try
86              {
87                  using (var hc = new TestHostContext(this))
88                  {
89                      var pagingLogger = new PagingLogger();
90                      hc.SetSingleton<IJobServerQueue>(_jobServerQueue.Object);
91                      pagingLogger.Initialize(hc);
92                      Guid timeLineId = Guid.NewGuid();
93                      Guid timeLineRecordId = Guid.NewGuid();
94                      _jobServerQueue.Setup(x => x.QueueFileUpload(It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), true));
95                      pagingLogger.Setup(timeLineId, timeLineRecordId);
96                      pagingLogger.End();
97                      _jobServerQueue.Verify(x => x.QueueFileUpload(It.IsAny<Guid>(), It.IsAny<Guid>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), true), Times.Exactly(0));
98                  }
99              }
100              finally
101              {
102                  CleanLogFolder();
103              }
104          }
105      }
106  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-SelfUpdaterL0.cs</h3>
            <pre><code>1  #if !(OS_WINDOWS && ARM64)
2  using System;
3  using System.Collections.Generic;
4  using System.IO;
5  using System.Linq;
6  using System.Net.Http;
7  using System.Reflection;
8  using System.Text.RegularExpressions;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using GitHub.DistributedTask.WebApi;
12  using GitHub.Runner.Listener;
13  using GitHub.Runner.Sdk;
14  using Moq;
15  using Xunit;
16  namespace GitHub.Runner.Common.Tests.Listener
17  {
18      public sealed class SelfUpdaterL0
19      {
20          private Mock<IRunnerServer> _runnerServer;
21          private Mock<ITerminal> _term;
22          private Mock<IConfigurationStore> _configStore;
23          private Mock<IJobDispatcher> _jobDispatcher;
24          private AgentRefreshMessage _refreshMessage = new(1, "2.999.0");
25          private List<TrimmedPackageMetadata> _trimmedPackages = new();
26  #if !OS_WINDOWS
27          private string _packageUrl = null;
28  #else
29          private string _packageUrl = null;
30  #endif
31          public SelfUpdaterL0()
32          {
33              _runnerServer = new Mock<IRunnerServer>();
34              _term = new Mock<ITerminal>();
35              _configStore = new Mock<IConfigurationStore>();
36              _jobDispatcher = new Mock<IJobDispatcher>();
37              _configStore.Setup(x => x.GetSettings()).Returns(new RunnerSettings() { PoolId = 1, AgentId = 1 });
38              Environment.SetEnvironmentVariable("_GITHUB_ACTION_EXECUTE_UPDATE_SCRIPT", "1");
39          }
40          private async Task FetchLatestRunner()
41          {
42              var latestVersion = "";
43              var httpClientHandler = new HttpClientHandler();
44              httpClientHandler.AllowAutoRedirect = false;
45              using (var client = new HttpClient(httpClientHandler))
46              {
47                  var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Get, "https:&bsol;&bsol;github.com/actions/runner/releases/latest"));
48                  if (response.StatusCode == System.Net.HttpStatusCode.Redirect)
49                  {
50                      var redirectUrl = response.Headers.Location.ToString();
51                      Regex regex = new(@"/runner/releases/tag/v(?<version>\d+\.\d+\.\d+)");
52                      var match = regex.Match(redirectUrl);
53                      if (match.Success)
54                      {
55                          latestVersion = match.Groups["version"].Value;
56  #if !OS_WINDOWS
57                          _packageUrl = $"https:&bsol;&bsol;github.com/actions/runner/releases/download/v{latestVersion}/actions-runner-{BuildConstants.RunnerPackage.PackageName}-{latestVersion}.tar.gz";
58  #else
59                          _packageUrl = $"https:&bsol;&bsol;github.com/actions/runner/releases/download/v{latestVersion}/actions-runner-{BuildConstants.RunnerPackage.PackageName}-{latestVersion}.zip";
60  #endif
61                      }
62                      else
63                      {
64                          throw new Exception("The latest runner version could not be determined so a download URL could not be generated for it. Please check the location header of the redirect response of 'https:&bsol;&bsol;github.com/actions/runner/releases/latest'");
65                      }
66                  }
67              }
68              using (var client = new HttpClient())
69              {
70                  var json = await client.GetStringAsync($"https:&bsol;&bsol;github.com/actions/runner/releases/download/v{latestVersion}/actions-runner-{BuildConstants.RunnerPackage.PackageName}-{latestVersion}-trimmedpackages.json");
71                  _trimmedPackages = StringUtil.ConvertFromJson<List<TrimmedPackageMetadata>>(json);
72              }
73              _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
74                           .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl }));
75          }
76          [Fact]
77          [Trait("Level", "L0")]
78          [Trait("Category", "Runner")]
79          public async void TestSelfUpdateAsync()
80          {
81              try
82              {
83                  await FetchLatestRunner();
84                  Assert.NotNull(_packageUrl);
85                  Assert.NotNull(_trimmedPackages);
86                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
87                  using (var hc = new TestHostContext(this))
88                  {
89                      hc.GetTrace().Info(_packageUrl);
90                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
91                      var updater = new Runner.Listener.SelfUpdater();
92                      hc.SetSingleton<ITerminal>(_term.Object);
93                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
94                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
95                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
96                      var p1 = new ProcessInvokerWrapper();
97                      p1.Initialize(hc);
98                      var p2 = new ProcessInvokerWrapper();
99                      p2.Initialize(hc);
100                      var p3 = new ProcessInvokerWrapper();
101                      p3.Initialize(hc);
102                      hc.EnqueueInstance<IProcessInvoker>(p1);
103                      hc.EnqueueInstance<IProcessInvoker>(p2);
104                      hc.EnqueueInstance<IProcessInvoker>(p3);
105                      updater.Initialize(hc);
106                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
107                                   .Callback((int p, int a, string s, string t) =>
108                                   {
109                                       hc.GetTrace().Info(t);
110                                   })
111                                   .Returns(Task.FromResult(new TaskAgent()));
112                      try
113                      {
114                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
115                          Assert.True(result);
116                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0")));
117                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0")));
118                      }
119                      finally
120                      {
121                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0"), CancellationToken.None);
122                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0"), CancellationToken.None);
123                      }
124                  }
125              }
126              finally
127              {
128                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
129              }
130          }
131          [Fact]
132          [Trait("Level", "L0")]
133          [Trait("Category", "Runner")]
134          public async void TestSelfUpdateAsync_NoUpdateOnOldVersion()
135          {
136              try
137              {
138                  await FetchLatestRunner();
139                  Assert.NotNull(_packageUrl);
140                  Assert.NotNull(_trimmedPackages);
141                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
142                  using (var hc = new TestHostContext(this))
143                  {
144                      hc.GetTrace().Info(_packageUrl);
145                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
146                      var updater = new Runner.Listener.SelfUpdater();
147                      hc.SetSingleton<ITerminal>(_term.Object);
148                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
149                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
150                      var p1 = new ProcessInvokerWrapper();
151                      p1.Initialize(hc);
152                      var p2 = new ProcessInvokerWrapper();
153                      p2.Initialize(hc);
154                      var p3 = new ProcessInvokerWrapper();
155                      p3.Initialize(hc);
156                      hc.EnqueueInstance<IProcessInvoker>(p1);
157                      hc.EnqueueInstance<IProcessInvoker>(p2);
158                      hc.EnqueueInstance<IProcessInvoker>(p3);
159                      updater.Initialize(hc);
160                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.200.0", true, It.IsAny<CancellationToken>()))
161                               .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.200.0"), DownloadUrl = _packageUrl }));
162                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
163                                   .Callback((int p, int a, string s, string t) =>
164                                   {
165                                       hc.GetTrace().Info(t);
166                                   })
167                                   .Returns(Task.FromResult(new TaskAgent()));
168                      var result = await updater.SelfUpdate(new AgentRefreshMessage(1, "2.200.0"), _jobDispatcher.Object, true, hc.RunnerShutdownToken);
169                      Assert.False(result);
170                  }
171              }
172              finally
173              {
174                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
175              }
176          }
177          [Fact]
178          [Trait("Level", "L0")]
179          [Trait("Category", "Runner")]
180          public async void TestSelfUpdateAsync_DownloadRetry()
181          {
182              try
183              {
184                  await FetchLatestRunner();
185                  Assert.NotNull(_packageUrl);
186                  Assert.NotNull(_trimmedPackages);
187                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
188                  using (var hc = new TestHostContext(this))
189                  {
190                      hc.GetTrace().Info(_packageUrl);
191                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
192                      var updater = new Runner.Listener.SelfUpdater();
193                      hc.SetSingleton<ITerminal>(_term.Object);
194                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
195                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
196                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
197                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
198                               .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = $"https:&bsol;&bsol;github.com/actions/runner/notexists" }));
199                      var p1 = new ProcessInvokerWrapper();
200                      p1.Initialize(hc);
201                      var p2 = new ProcessInvokerWrapper();
202                      p2.Initialize(hc);
203                      var p3 = new ProcessInvokerWrapper();
204                      p3.Initialize(hc);
205                      hc.EnqueueInstance<IProcessInvoker>(p1);
206                      hc.EnqueueInstance<IProcessInvoker>(p2);
207                      hc.EnqueueInstance<IProcessInvoker>(p3);
208                      updater.Initialize(hc);
209                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
210                                   .Callback((int p, int a, string s, string t) =>
211                                   {
212                                       hc.GetTrace().Info(t);
213                                   })
214                                   .Returns(Task.FromResult(new TaskAgent()));
215                      var ex = await Assert.ThrowsAsync<TaskCanceledException>(() => updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken));
216                      Assert.Contains($"failed after {Constants.RunnerDownloadRetryMaxAttempts} download attempts", ex.Message);
217                  }
218              }
219              finally
220              {
221                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
222              }
223          }
224          [Fact]
225          [Trait("Level", "L0")]
226          [Trait("Category", "Runner")]
227          public async void TestSelfUpdateAsync_ValidateHash()
228          {
229              try
230              {
231                  await FetchLatestRunner();
232                  Assert.NotNull(_packageUrl);
233                  Assert.NotNull(_trimmedPackages);
234                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
235                  using (var hc = new TestHostContext(this))
236                  {
237                      hc.GetTrace().Info(_packageUrl);
238                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
239                      var updater = new Runner.Listener.SelfUpdater();
240                      hc.SetSingleton<ITerminal>(_term.Object);
<span onclick='openModal()' class='match'>241                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
242                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
</span>243                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
244                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
245                               .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl, HashValue = "bad_hash" }));
246                      var p1 = new ProcessInvokerWrapper();
247                      p1.Initialize(hc);
248                      var p2 = new ProcessInvokerWrapper();
249                      p2.Initialize(hc);
250                      var p3 = new ProcessInvokerWrapper();
251                      p3.Initialize(hc);
252                      hc.EnqueueInstance<IProcessInvoker>(p1);
253                      hc.EnqueueInstance<IProcessInvoker>(p2);
254                      hc.EnqueueInstance<IProcessInvoker>(p3);
255                      updater.Initialize(hc);
256                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
257                                   .Callback((int p, int a, string s, string t) =>
258                                   {
259                                       hc.GetTrace().Info(t);
260                                   })
261                                   .Returns(Task.FromResult(new TaskAgent()));
262                      var ex = await Assert.ThrowsAsync<Exception>(() => updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken));
263                      Assert.Contains("did not match expected Runner Hash", ex.Message);
264                  }
265              }
266              finally
267              {
268                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
269              }
270          }
271          [Fact]
272          [Trait("Level", "L0")]
273          [Trait("Category", "Runner")]
274          public async void TestSelfUpdateAsync_CloneHash_RuntimeAndExternals()
275          {
276              try
277              {
278                  await FetchLatestRunner();
279                  Assert.NotNull(_packageUrl);
280                  Assert.NotNull(_trimmedPackages);
281                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
282                  using (var hc = new TestHostContext(this))
283                  {
284                      hc.GetTrace().Info(_packageUrl);
285                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
286                      var updater = new Runner.Listener.SelfUpdater();
287                      hc.SetSingleton<ITerminal>(_term.Object);
288                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
289                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
290                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
291                      var p1 = new ProcessInvokerWrapper();
292                      p1.Initialize(hc);
293                      var p2 = new ProcessInvokerWrapper();
294                      p2.Initialize(hc);
295                      var p3 = new ProcessInvokerWrapper();
296                      p3.Initialize(hc);
297                      hc.EnqueueInstance<IProcessInvoker>(p1);
298                      hc.EnqueueInstance<IProcessInvoker>(p2);
299                      hc.EnqueueInstance<IProcessInvoker>(p3);
300                      updater.Initialize(hc);
301                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
302                           .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl, TrimmedPackages = new List<TrimmedPackageMetadata>() { new TrimmedPackageMetadata() } }));
303                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
304                                   .Callback((int p, int a, string s, string t) =>
305                                   {
306                                       hc.GetTrace().Info(t);
307                                   })
308                                   .Returns(Task.FromResult(new TaskAgent()));
309                      try
310                      {
311                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
312                          Assert.True(result);
313                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0")));
314                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0")));
315                          FieldInfo contentHashesProperty = updater.GetType().GetField("_contentHashes", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
316                          Assert.NotNull(contentHashesProperty);
317                          Dictionary<string, string> contentHashes = (Dictionary<string, string>)contentHashesProperty.GetValue(updater);
318                          hc.GetTrace().Info(StringUtil.ConvertToJson(contentHashes));
319                          var dotnetRuntimeHashFile = Path.Combine(TestUtil.GetSrcPath(), $"Misc/contentHash/dotnetRuntime/{BuildConstants.RunnerPackage.PackageName}");
320                          var externalsHashFile = Path.Combine(TestUtil.GetSrcPath(), $"Misc/contentHash/externals/{BuildConstants.RunnerPackage.PackageName}");
321                          Assert.Equal(File.ReadAllText(dotnetRuntimeHashFile).Trim(), contentHashes["dotnetRuntime"]);
322                          Assert.Equal(File.ReadAllText(externalsHashFile).Trim(), contentHashes["externals"]);
323                      }
324                      finally
325                      {
326                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0"), CancellationToken.None);
327                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0"), CancellationToken.None);
328                      }
329                  }
330              }
331              finally
332              {
333                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
334              }
335          }
336          [Fact]
337          [Trait("Level", "L0")]
338          [Trait("Category", "Runner")]
339          public async void TestSelfUpdateAsync_Cancel_CloneHashTask_WhenNotNeeded()
340          {
341              try
342              {
343                  await FetchLatestRunner();
344                  Assert.NotNull(_packageUrl);
345                  Assert.NotNull(_trimmedPackages);
346                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
347                  using (var hc = new TestHostContext(this))
348                  {
349                      hc.GetTrace().Info(_packageUrl);
350                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
351                      var updater = new Runner.Listener.SelfUpdater();
352                      hc.SetSingleton<ITerminal>(_term.Object);
353                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
354                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
355                      hc.SetSingleton<IHttpClientHandlerFactory>(new Mock<IHttpClientHandlerFactory>().Object);
356                      var p1 = new ProcessInvokerWrapper();
357                      p1.Initialize(hc);
358                      var p2 = new ProcessInvokerWrapper();
359                      p2.Initialize(hc);
360                      var p3 = new ProcessInvokerWrapper();
361                      p3.Initialize(hc);
362                      hc.EnqueueInstance<IProcessInvoker>(p1);
363                      hc.EnqueueInstance<IProcessInvoker>(p2);
364                      hc.EnqueueInstance<IProcessInvoker>(p3);
365                      updater.Initialize(hc);
366                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
367                                   .Callback((int p, int a, string s, string t) =>
368                                   {
369                                       hc.GetTrace().Info(t);
370                                   })
371                                   .Returns(Task.FromResult(new TaskAgent()));
372                      try
373                      {
374                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
375                          FieldInfo contentHashesProperty = updater.GetType().GetField("_contentHashes", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
376                          Assert.NotNull(contentHashesProperty);
377                          Dictionary<string, string> contentHashes = (Dictionary<string, string>)contentHashesProperty.GetValue(updater);
378                          hc.GetTrace().Info(StringUtil.ConvertToJson(contentHashes));
379                          Assert.NotEqual(2, contentHashes.Count);
380                      }
381                      catch (Exception ex)
382                      {
383                          hc.GetTrace().Error(ex);
384                      }
385                  }
386              }
387              finally
388              {
389                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
390              }
391          }
392          [Fact]
393          [Trait("Level", "L0")]
394          [Trait("Category", "Runner")]
395          public async void TestSelfUpdateAsync_UseExternalsTrimmedPackage()
396          {
397              try
398              {
399                  await FetchLatestRunner();
400                  Assert.NotNull(_packageUrl);
401                  Assert.NotNull(_trimmedPackages);
402                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
403                  using (var hc = new TestHostContext(this))
404                  {
405                      hc.GetTrace().Info(_packageUrl);
406                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
407                      var updater = new Runner.Listener.SelfUpdater();
408                      hc.SetSingleton<ITerminal>(_term.Object);
409                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
410                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
411                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
412                      var p1 = new ProcessInvokerWrapper();  
413                      p1.Initialize(hc);
414                      var p2 = new ProcessInvokerWrapper();  
415                      p2.Initialize(hc);
416                      var p3 = new ProcessInvokerWrapper();  
417                      p3.Initialize(hc);
418                      var p4 = new ProcessInvokerWrapper();  
419                      p4.Initialize(hc);
420                      var p5 = new ProcessInvokerWrapper();  
421                      p5.Initialize(hc);
422                      hc.EnqueueInstance<IProcessInvoker>(p1);
423                      hc.EnqueueInstance<IProcessInvoker>(p2);
424                      hc.EnqueueInstance<IProcessInvoker>(p3);
425                      hc.EnqueueInstance<IProcessInvoker>(p4);
426                      hc.EnqueueInstance<IProcessInvoker>(p5);
427                      updater.Initialize(hc);
428                      var trim = _trimmedPackages.Where(x => !x.TrimmedContents.ContainsKey("dotnetRuntime")).ToList();
429                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
430                           .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl, TrimmedPackages = trim }));
431                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
432                                   .Callback((int p, int a, string s, string t) =>
433                                   {
434                                       hc.GetTrace().Info(t);
435                                   })
436                                   .Returns(Task.FromResult(new TaskAgent()));
437                      try
438                      {
439                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
440                          Assert.True(result);
441                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0")));
442                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0")));
443                      }
444                      finally
445                      {
446                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0"), CancellationToken.None);
447                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0"), CancellationToken.None);
448                      }
449                      var traceFile = Path.GetTempFileName();
450                      File.Copy(hc.TraceFileName, traceFile, true);
451                      var externalsHashFile = Path.Combine(TestUtil.GetSrcPath(), $"Misc/contentHash/externals/{BuildConstants.RunnerPackage.PackageName}");
452                      var externalsHash = await File.ReadAllTextAsync(externalsHashFile);
453                      if (externalsHash == trim[0].TrimmedContents["externals"])
454                      {
455                          Assert.Contains("Use trimmed (externals) package", File.ReadAllText(traceFile));
456                      }
457                      else
458                      {
459                          Assert.Contains("the current runner does not carry those trimmed content (Hash mismatch)", File.ReadAllText(traceFile));
460                      }
461                  }
462              }
463              finally
464              {
465                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
466              }
467          }
468          [Fact]
469          [Trait("Level", "L0")]
470          [Trait("Category", "Runner")]
471          public async void TestSelfUpdateAsync_UseExternalsRuntimeTrimmedPackage()
472          {
473              try
474              {
475                  await FetchLatestRunner();
476                  Assert.NotNull(_packageUrl);
477                  Assert.NotNull(_trimmedPackages);
478                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
479                  using (var hc = new TestHostContext(this))
480                  {
481                      hc.GetTrace().Info(_packageUrl);
482                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
483                      var updater = new Runner.Listener.SelfUpdater();
484                      hc.SetSingleton<ITerminal>(_term.Object);
485                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
486                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
487                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
488                      var p1 = new ProcessInvokerWrapper();  
489                      p1.Initialize(hc);
490                      var p2 = new ProcessInvokerWrapper();  
491                      p2.Initialize(hc);
492                      var p3 = new ProcessInvokerWrapper();  
493                      p3.Initialize(hc);
494                      var p4 = new ProcessInvokerWrapper();  
495                      p4.Initialize(hc);
496                      var p5 = new ProcessInvokerWrapper();  
497                      p5.Initialize(hc);
498                      var p6 = new ProcessInvokerWrapper();  
499                      p6.Initialize(hc);
500                      hc.EnqueueInstance<IProcessInvoker>(p1);
501                      hc.EnqueueInstance<IProcessInvoker>(p2);
502                      hc.EnqueueInstance<IProcessInvoker>(p3);
503                      hc.EnqueueInstance<IProcessInvoker>(p4);
504                      hc.EnqueueInstance<IProcessInvoker>(p5);
505                      hc.EnqueueInstance<IProcessInvoker>(p6);
506                      updater.Initialize(hc);
507                      var trim = _trimmedPackages.Where(x => x.TrimmedContents.ContainsKey("dotnetRuntime") && x.TrimmedContents.ContainsKey("externals")).ToList();
508                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
509                           .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl, TrimmedPackages = trim }));
510                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
511                                   .Callback((int p, int a, string s, string t) =>
512                                   {
513                                       hc.GetTrace().Info(t);
514                                   })
515                                   .Returns(Task.FromResult(new TaskAgent()));
516                      try
517                      {
518                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
519                          Assert.True(result);
520                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0")));
521                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0")));
522                      }
523                      finally
524                      {
525                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0"), CancellationToken.None);
526                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0"), CancellationToken.None);
527                      }
528                      var traceFile = Path.GetTempFileName();
529                      File.Copy(hc.TraceFileName, traceFile, true);
530                      var externalsHashFile = Path.Combine(TestUtil.GetSrcPath(), $"Misc/contentHash/externals/{BuildConstants.RunnerPackage.PackageName}");
531                      var externalsHash = await File.ReadAllTextAsync(externalsHashFile);
532                      var runtimeHashFile = Path.Combine(TestUtil.GetSrcPath(), $"Misc/contentHash/dotnetRuntime/{BuildConstants.RunnerPackage.PackageName}");
533                      var runtimeHash = await File.ReadAllTextAsync(runtimeHashFile);
534                      if (externalsHash == trim[0].TrimmedContents["externals"] &&
535                          runtimeHash == trim[0].TrimmedContents["dotnetRuntime"])
536                      {
537                          Assert.Contains("Use trimmed (runtime+externals) package", File.ReadAllText(traceFile));
538                      }
539                      else
540                      {
541                          Assert.Contains("the current runner does not carry those trimmed content (Hash mismatch)", File.ReadAllText(traceFile));
542                      }
543                  }
544              }
545              finally
546              {
547                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
548              }
549          }
550          [Fact]
551          [Trait("Level", "L0")]
552          [Trait("Category", "Runner")]
553          public async void TestSelfUpdateAsync_NotUseExternalsRuntimeTrimmedPackageOnHashMismatch()
554          {
555              try
556              {
557                  await FetchLatestRunner();
558                  Assert.NotNull(_packageUrl);
559                  Assert.NotNull(_trimmedPackages);
560                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
561                  using (var hc = new TestHostContext(this))
562                  {
563                      hc.GetTrace().Info(_packageUrl);
564                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
565                      var updater = new Runner.Listener.SelfUpdater();
566                      hc.SetSingleton<ITerminal>(_term.Object);
567                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
568                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
569                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
570                      var p1 = new ProcessInvokerWrapper();  
571                      p1.Initialize(hc);
572                      var p2 = new ProcessInvokerWrapper();  
573                      p2.Initialize(hc);
574                      var p3 = new ProcessInvokerWrapper();  
575                      p3.Initialize(hc);
576                      var p4 = new ProcessInvokerWrapper();  
577                      p4.Initialize(hc);
578                      var p5 = new ProcessInvokerWrapper();  
579                      p5.Initialize(hc);
580                      var p6 = new ProcessInvokerWrapper();  
581                      p6.Initialize(hc);
582                      hc.EnqueueInstance<IProcessInvoker>(p1);
583                      hc.EnqueueInstance<IProcessInvoker>(p2);
584                      hc.EnqueueInstance<IProcessInvoker>(p3);
585                      hc.EnqueueInstance<IProcessInvoker>(p4);
586                      hc.EnqueueInstance<IProcessInvoker>(p5);
587                      hc.EnqueueInstance<IProcessInvoker>(p6);
588                      updater.Initialize(hc);
589                      var trim = _trimmedPackages.ToList();
590                      foreach (var package in trim)
591                      {
592                          foreach (var hash in package.TrimmedContents.Keys)
593                          {
594                              package.TrimmedContents[hash] = "mismatch";
595                          }
596                      }
597                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
598                           .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl, TrimmedPackages = trim }));
599                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
600                                   .Callback((int p, int a, string s, string t) =>
601                                   {
602                                       hc.GetTrace().Info(t);
603                                   })
604                                   .Returns(Task.FromResult(new TaskAgent()));
605                      try
606                      {
607                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
608                          Assert.True(result);
609                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0")));
610                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0")));
611                      }
612                      finally
613                      {
614                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0"), CancellationToken.None);
615                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0"), CancellationToken.None);
616                      }
617                      var traceFile = Path.GetTempFileName();
618                      File.Copy(hc.TraceFileName, traceFile, true);
619                      Assert.Contains("the current runner does not carry those trimmed content (Hash mismatch)", File.ReadAllText(traceFile));
620                  }
621              }
622              finally
623              {
624                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
625              }
626          }
627          [Fact]
628          [Trait("Level", "L0")]
629          [Trait("Category", "Runner")]
630          public async void TestSelfUpdateAsync_FallbackToFullPackage()
631          {
632              try
633              {
634                  await FetchLatestRunner();
635                  Assert.NotNull(_packageUrl);
636                  Assert.NotNull(_trimmedPackages);
637                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", Path.GetFullPath(Path.Combine(TestUtil.GetSrcPath(), "..", "_layout", "bin")));
638                  using (var hc = new TestHostContext(this))
639                  {
640                      hc.GetTrace().Info(_packageUrl);
641                      hc.GetTrace().Info(StringUtil.ConvertToJson(_trimmedPackages));
642                      var updater = new Runner.Listener.SelfUpdater();
643                      hc.SetSingleton<ITerminal>(_term.Object);
644                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
645                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
646                      hc.SetSingleton<IHttpClientHandlerFactory>(new HttpClientHandlerFactory());
647                      var p1 = new ProcessInvokerWrapper();  
648                      p1.Initialize(hc);
649                      var p2 = new ProcessInvokerWrapper();  
650                      p2.Initialize(hc);
651                      var p3 = new ProcessInvokerWrapper();  
652                      p3.Initialize(hc);
653                      var p4 = new ProcessInvokerWrapper();  
654                      p4.Initialize(hc);
655                      hc.EnqueueInstance<IProcessInvoker>(p1);
656                      hc.EnqueueInstance<IProcessInvoker>(p2);
657                      hc.EnqueueInstance<IProcessInvoker>(p3);
658                      hc.EnqueueInstance<IProcessInvoker>(p4);
659                      updater.Initialize(hc);
660                      var trim = _trimmedPackages.ToList();
661                      foreach (var package in trim)
662                      {
663                          package.HashValue = "mismatch";
664                      }
665                      _runnerServer.Setup(x => x.GetPackageAsync("agent", BuildConstants.RunnerPackage.PackageName, "2.999.0", true, It.IsAny<CancellationToken>()))
666                           .Returns(Task.FromResult(new PackageMetadata() { Platform = BuildConstants.RunnerPackage.PackageName, Version = new PackageVersion("2.999.0"), DownloadUrl = _packageUrl, TrimmedPackages = trim }));
667                      _runnerServer.Setup(x => x.UpdateAgentUpdateStateAsync(1, 1, It.IsAny<string>(), It.IsAny<string>()))
668                                   .Callback((int p, int a, string s, string t) =>
669                                   {
670                                       hc.GetTrace().Info(t);
671                                   })
672                                   .Returns(Task.FromResult(new TaskAgent()));
673                      try
674                      {
675                          var result = await updater.SelfUpdate(_refreshMessage, _jobDispatcher.Object, true, hc.RunnerShutdownToken);
676                          Assert.True(result);
677                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0")));
678                          Assert.True(Directory.Exists(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0")));
679                      }
680                      finally
681                      {
682                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "bin.2.999.0"), CancellationToken.None);
683                          IOUtil.DeleteDirectory(Path.Combine(hc.GetDirectory(WellKnownDirectory.Root), "externals.2.999.0"), CancellationToken.None);
684                      }
685                      var traceFile = Path.GetTempFileName();
686                      File.Copy(hc.TraceFileName, traceFile, true);
687                      if (File.ReadAllText(traceFile).Contains("Use trimmed (runtime+externals) package"))
688                      {
689                          Assert.Contains("Something wrong with the trimmed runner package, failback to use the full package for runner updates", File.ReadAllText(traceFile));
690                      }
691                      else
692                      {
693                          hc.GetTrace().Warning("Skipping the 'TestSelfUpdateAsync_FallbackToFullPackage' test, as the `externals` or `runtime` hashes have been updated");
694                      }
695                  }
696              }
697              finally
698              {
699                  Environment.SetEnvironmentVariable("RUNNER_L0_OVERRIDEBINDIR", null);
700              }
701          }
702      }
703  }
704  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PagingLoggerL0.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-SelfUpdaterL0.cs</div>
                </div>
                <div class="column column_space"><pre><code>39                      hc.SetSingleton<IJobServerQueue>(_jobServerQueue.Object);
40                      pagingLogger.Initialize(hc);
</pre></code></div>
                <div class="column column_space"><pre><code>241                      hc.SetSingleton<IRunnerServer>(_runnerServer.Object);
242                      hc.SetSingleton<IConfigurationStore>(_configStore.Object);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    