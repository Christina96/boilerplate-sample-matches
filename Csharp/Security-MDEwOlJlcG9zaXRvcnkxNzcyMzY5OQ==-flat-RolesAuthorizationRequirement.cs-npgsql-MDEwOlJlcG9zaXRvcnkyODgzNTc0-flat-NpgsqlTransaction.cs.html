
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.333333333333332%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-RolesAuthorizationRequirement.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Threading.Tasks;
5  namespace Microsoft.AspNetCore.Authorization.Infrastructure
6  {
7      public class RolesAuthorizationRequirement : AuthorizationHandler<RolesAuthorizationRequirement>, IAuthorizationRequirement
8      {
9          public RolesAuthorizationRequirement(IEnumerable<string> allowedRoles)
10          {
<span onclick='openModal()' class='match'>11              if (allowedRoles == null)
12              {
13                  throw new ArgumentNullException(nameof(allowedRoles));
14              }
15              if (allowedRoles.Count() == 0)
16              {
17                  throw new InvalidOperationException(Resources.Exception_RoleRequirementEmpty);
18              }
</span>19              AllowedRoles = allowedRoles;
20          }
21          public IEnumerable<string> AllowedRoles { get; }
22          protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, RolesAuthorizationRequirement requirement)
23          {
24              if (context.User != null)
25              {
26                  bool found = false;
27                  if (requirement.AllowedRoles == null || !requirement.AllowedRoles.Any())
28                  {
29                  }
30                  else
31                  {
32                      found = requirement.AllowedRoles.Any(r => context.User.IsInRole(r));
33                  }
34                  if (found)
35                  {
36                      context.Succeed(requirement);
37                  }
38              }
39              return Task.CompletedTask;
40          }
41      }
42  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTransaction.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Data.Common;
4  using System.Diagnostics;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using Microsoft.Extensions.Logging;
8  using Npgsql.Internal;
9  namespace Npgsql;
10  public sealed class NpgsqlTransaction : DbTransaction
11  {
12      #region Fields and Properties
13      public new NpgsqlConnection? Connection
14      {
15          get
16          {
17              CheckDisposed();
18              return _connector?.Connection;
19          }
20      }
21      NpgsqlConnector _connector;
22      protected override DbConnection? DbConnection => Connection;
23      internal bool IsCompleted => _connector is null || _connector.TransactionStatus == TransactionStatus.Idle;
24      internal bool IsDisposed;
25      Exception? _disposeReason;
26      public override IsolationLevel IsolationLevel
27      {
28          get
29          {
30              CheckReady();
31              return _isolationLevel;
32          }
33      }
34      IsolationLevel _isolationLevel;
35      readonly ILogger _transactionLogger;
36      const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadCommitted;
37      #endregion
38      #region Initialization
39      internal NpgsqlTransaction(NpgsqlConnector connector)
40      {
41          _connector = connector;
42          _transactionLogger = connector.TransactionLogger;
43      }
44      internal void Init(IsolationLevel isolationLevel = DefaultIsolationLevel)
45      {
46          Debug.Assert(isolationLevel != IsolationLevel.Chaos);
47          if (!_connector.DatabaseInfo.SupportsTransactions)
48              return;
49          switch (isolationLevel)
50          {
51          case IsolationLevel.RepeatableRead:
52          case IsolationLevel.Snapshot:
53              _connector.PrependInternalMessage(PregeneratedMessages.BeginTransRepeatableRead, 2);
54              break;
55          case IsolationLevel.Serializable:
56              _connector.PrependInternalMessage(PregeneratedMessages.BeginTransSerializable, 2);
57              break;
58          case IsolationLevel.ReadUncommitted:
59              _connector.PrependInternalMessage(PregeneratedMessages.BeginTransReadUncommitted, 2);
60              break;
61          case IsolationLevel.ReadCommitted:
62              _connector.PrependInternalMessage(PregeneratedMessages.BeginTransReadCommitted, 2);
63              break;
64          case IsolationLevel.Unspecified:
65              isolationLevel = DefaultIsolationLevel;
66              goto case DefaultIsolationLevel;
67          default:
68              throw new NotSupportedException("Isolation level not supported: " + isolationLevel);
69          }
70          _connector.TransactionStatus = TransactionStatus.Pending;
71          _isolationLevel = isolationLevel;
72          IsDisposed = false;
73          LogMessages.StartedTransaction(_transactionLogger, isolationLevel, _connector.Id);
74      }
75      #endregion
76      #region Commit
77      public override void Commit() => Commit(false).GetAwaiter().GetResult();
78      async Task Commit(bool async, CancellationToken cancellationToken = default)
79      {
80          CheckReady();
81          if (!_connector.DatabaseInfo.SupportsTransactions)
82              return;
83          using (_connector.StartUserAction(cancellationToken))
84          {
85              await _connector.ExecuteInternalCommand(PregeneratedMessages.CommitTransaction, async, cancellationToken);
86              LogMessages.CommittedTransaction(_transactionLogger, _connector.Id);
87          }
88      }
89  #if NETSTANDARD2_0
90      public Task CommitAsync(CancellationToken cancellationToken = default)
91  #else
92      public override Task CommitAsync(CancellationToken cancellationToken = default)
93  #endif
94      {
95          using (NoSynchronizationContextScope.Enter())
96              return Commit(true, cancellationToken);
97      }
98      #endregion
99      #region Rollback
100      public override void Rollback() => Rollback(false).GetAwaiter().GetResult();
101      async Task Rollback(bool async, CancellationToken cancellationToken = default)
102      {
103          CheckReady();
104          if (!_connector.DatabaseInfo.SupportsTransactions)
105              return;
106          using (_connector.StartUserAction(cancellationToken))
107          {
108              await _connector.Rollback(async, cancellationToken);
109              LogMessages.RolledBackTransaction(_transactionLogger, _connector.Id);
110          }
111      }
112  #if NETSTANDARD2_0
113      public Task RollbackAsync(CancellationToken cancellationToken = default)
114  #else
115      public override Task RollbackAsync(CancellationToken cancellationToken = default)
116  #endif
117      {
118          using (NoSynchronizationContextScope.Enter())
119              return Rollback(true, cancellationToken);
120      }
121      #endregion
122      #region Savepoints
123  #if NET5_0_OR_GREATER
124      public override void Save(string name)
125  #else
126      public void Save(string name)
127  #endif
128      {
<span onclick='openModal()' class='match'>129          if (name == null)
130              throw new ArgumentNullException(nameof(name));
131          if (string.IsNullOrWhiteSpace(name))
132              throw new ArgumentException("name can't be empty", nameof(name));
</span>133          CheckReady();
134          if (!_connector.DatabaseInfo.SupportsTransactions)
135              return;
136          using var _ = _connector.StartUserAction();
137          LogMessages.CreatingSavepoint(_transactionLogger, name, _connector.Id);
138          if (RequiresQuoting(name))
139              name = $"\"{name.Replace("\"", "\"\"")}\"";
140          _connector.WriteBuffer.WriteByte(FrontendMessageCode.Query);
141          _connector.WriteBuffer.WriteInt32(
142              sizeof(int)  +                               
143              _connector.TextEncoding.GetByteCount("SAVEPOINT ") +
144              _connector.TextEncoding.GetByteCount(name) +
145              sizeof(byte));                               
146          _connector.WriteBuffer.WriteString("SAVEPOINT ");
147          _connector.WriteBuffer.WriteString(name);
148          _connector.WriteBuffer.WriteByte(0);
149          _connector.PendingPrependedResponses += 2;
150      }
151  #if NET5_0_OR_GREATER
152      public override Task SaveAsync(string name, CancellationToken cancellationToken = default)
153  #else
154      public Task SaveAsync(string name, CancellationToken cancellationToken = default)
155  #endif
156      {
157          Save(name);
158          return Task.CompletedTask;
159      }
160      async Task Rollback(string name, bool async, CancellationToken cancellationToken = default)
161      {
162          if (name == null)
163              throw new ArgumentNullException(nameof(name));
164          if (string.IsNullOrWhiteSpace(name))
165              throw new ArgumentException("name can't be empty", nameof(name));
166          CheckReady();
167          if (!_connector.DatabaseInfo.SupportsTransactions)
168              return;
169          using (_connector.StartUserAction(cancellationToken))
170          {
171              var quotedName = RequiresQuoting(name) ? $"\"{name.Replace("\"", "\"\"")}\"" : name;
172              await _connector.ExecuteInternalCommand($"ROLLBACK TO SAVEPOINT {quotedName}", async, cancellationToken);
173              LogMessages.RolledBackToSavepoint(_transactionLogger, name, _connector.Id);
174          }
175      }
176  #if NET5_0_OR_GREATER
177      public override void Rollback(string name)
178  #else
179      public void Rollback(string name)
180  #endif
181          => Rollback(name, false).GetAwaiter().GetResult();
182  #if NET5_0_OR_GREATER
183      public override Task RollbackAsync(string name, CancellationToken cancellationToken = default)
184  #else
185      public Task RollbackAsync(string name, CancellationToken cancellationToken = default)
186  #endif
187      {
188          using (NoSynchronizationContextScope.Enter())
189              return Rollback(name, true, cancellationToken);
190      }
191      async Task Release(string name, bool async, CancellationToken cancellationToken = default)
192      {
193          if (name == null)
194              throw new ArgumentNullException(nameof(name));
195          if (string.IsNullOrWhiteSpace(name))
196              throw new ArgumentException("name can't be empty", nameof(name));
197          CheckReady();
198          if (!_connector.DatabaseInfo.SupportsTransactions)
199              return;
200          using (_connector.StartUserAction(cancellationToken))
201          {
202              var quotedName = RequiresQuoting(name) ? $"\"{name.Replace("\"", "\"\"")}\"" : name;
203              await _connector.ExecuteInternalCommand($"RELEASE SAVEPOINT {quotedName}", async, cancellationToken);
204              LogMessages.ReleasedSavepoint(_transactionLogger, name, _connector.Id);
205          }
206      }
207  #if NET5_0_OR_GREATER
208      public override void Release(string name) => Release(name, false).GetAwaiter().GetResult();
209  #else
210      public void Release(string name) => Release(name, false).GetAwaiter().GetResult();
211  #endif
212  #if NET5_0_OR_GREATER
213      public override Task ReleaseAsync(string name, CancellationToken cancellationToken = default)
214  #else
215      public Task ReleaseAsync(string name, CancellationToken cancellationToken = default)
216  #endif
217      {
218          using (NoSynchronizationContextScope.Enter())
219              return Release(name, true, cancellationToken);
220      }
221  #if NET5_0_OR_GREATER
222      public override bool SupportsSavepoints
223  #else
224      public bool SupportsSavepoints
225  #endif
226      {
227          get => _connector.DatabaseInfo.SupportsTransactions;
228      }
229      #endregion
230      #region Dispose
231      protected override void Dispose(bool disposing)
232      {
233          if (IsDisposed)
234              return;
235          if (disposing)
236          {
237              if (!IsCompleted)
238              {
239                  try
240                  {
241                      _connector.CloseOngoingOperations(async: false).GetAwaiter().GetResult();
242                      Rollback();
243                  }
244                  catch
245                  {
246                      Debug.Assert(_connector.IsBroken);
247                  }
248              }
249              IsDisposed = true;
250              _connector?.Connection?.EndBindingScope(ConnectorBindingScope.Transaction);
251          }
252      }
253  #if NETSTANDARD2_0
254      public ValueTask DisposeAsync()
255  #else
256      public override ValueTask DisposeAsync()
257  #endif
258      {
259          if (!IsDisposed)
260          {
261              if (!IsCompleted)
262              {
263                  using (NoSynchronizationContextScope.Enter())
264                      return DisposeAsyncInternal();
265              }
266              IsDisposed = true;
267              _connector?.Connection?.EndBindingScope(ConnectorBindingScope.Transaction);
268          }
269          return default;
270          async ValueTask DisposeAsyncInternal()
271          {
272              try
273              {
274                  await _connector.CloseOngoingOperations(async: true);
275                  await Rollback(async: true);
276              }
277              catch (Exception ex)
278              {
279                  Debug.Assert(_connector.IsBroken);
280                  LogMessages.ExceptionDuringTransactionDispose(_transactionLogger, _connector.Id, ex);
281              }
282              IsDisposed = true;
283              _connector?.Connection?.EndBindingScope(ConnectorBindingScope.Transaction);
284          }
285      }
286      internal void DisposeImmediately(Exception? disposeReason)
287      {
288          IsDisposed = true;
289          _disposeReason = disposeReason;
290      }
291      #endregion
292      #region Checks
293      void CheckReady()
294      {
295          CheckDisposed();
296          if (IsCompleted)
297              ThrowHelper.ThrowInvalidOperationException("This NpgsqlTransaction has completed; it is no longer usable.");
298      }
299      void CheckDisposed()
300      {
301          if (IsDisposed)
302              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlTransaction), _disposeReason);
303      }
304      static bool RequiresQuoting(string identifier)
305      {
306          Debug.Assert(identifier.Length > 0);
307          var first = identifier[0];
308          if (first != '_' && !char.IsLower(first))
309              return true;
310          foreach (var c in identifier.AsSpan(1))
311              if (c != '_' && c != '$' && !char.IsLower(c) && !char.IsDigit(c))
312                  return true;
313          return false;
314      }
315      #endregion
316      #region Misc
317      internal void UnbindIfNecessary()
318      {
319          if (!IsDisposed)
320          {
321              if (_connector.UnboundTransaction is { IsDisposed: true } previousTransaction)
322              {
323                  previousTransaction._connector = _connector;
324                  _connector.Transaction = previousTransaction;
325              }
326              else
327                  _connector.Transaction = null;
328              _connector.UnboundTransaction = this;
329              _connector = null!;
330          }
331      }
332      #endregion
333  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-RolesAuthorizationRequirement.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTransaction.cs</div>
                </div>
                <div class="column column_space"><pre><code>11              if (allowedRoles == null)
12              {
13                  throw new ArgumentNullException(nameof(allowedRoles));
14              }
15              if (allowedRoles.Count() == 0)
16              {
17                  throw new InvalidOperationException(Resources.Exception_RoleRequirementEmpty);
18              }
</pre></code></div>
                <div class="column column_space"><pre><code>129          if (name == null)
130              throw new ArgumentNullException(nameof(name));
131          if (string.IsNullOrWhiteSpace(name))
132              throw new ArgumentException("name can't be empty", nameof(name));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    