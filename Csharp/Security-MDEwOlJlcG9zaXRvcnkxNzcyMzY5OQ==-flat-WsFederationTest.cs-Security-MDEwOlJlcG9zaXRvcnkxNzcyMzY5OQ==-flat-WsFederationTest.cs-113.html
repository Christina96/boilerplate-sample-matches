
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Net;
6  using System.Net.Http;
7  using System.Security.Claims;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using Microsoft.AspNetCore.Authentication.Cookies;
12  using Microsoft.AspNetCore.Builder;
13  using Microsoft.AspNetCore.Hosting;
14  using Microsoft.AspNetCore.Http;
15  using Microsoft.AspNetCore.Http.Extensions;
16  using Microsoft.AspNetCore.TestHost;
17  using Microsoft.AspNetCore.WebUtilities;
18  using Microsoft.Extensions.DependencyInjection;
19  using Microsoft.IdentityModel.Tokens;
20  using Microsoft.Net.Http.Headers;
21  using Xunit;
22  namespace Microsoft.AspNetCore.Authentication.WsFederation
23  {
24      public class WsFederationTest
25      {
26          [Fact]
27          public async Task VerifySchemeDefaults()
28          {
29              var services = new ServiceCollection();
30              services.AddAuthentication().AddWsFederation();
31              var sp = services.BuildServiceProvider();
32              var schemeProvider = sp.GetRequiredService&lt;IAuthenticationSchemeProvider&gt;();
33              var scheme = await schemeProvider.GetSchemeAsync(WsFederationDefaults.AuthenticationScheme);
34              Assert.NotNull(scheme);
35              Assert.Equal(&quot;WsFederationHandler&quot;, scheme.HandlerType.Name);
36              Assert.Equal(WsFederationDefaults.AuthenticationScheme, scheme.DisplayName);
37          }
38          [Fact]
39          public async Task MissingConfigurationThrows()
40          {
41              var builder = new WebHostBuilder()
42                  .Configure(ConfigureApp)
43                  .ConfigureServices(services =&gt;
44                  {
45                      services.AddAuthentication(sharedOptions =&gt;
46                      {
47                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
48                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
49                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
50                      })
51                      .AddCookie()
52                      .AddWsFederation();
53                  });
54              var server = new TestServer(builder);
55              var httpClient = server.CreateClient();
56              var exception = await Assert.ThrowsAsync&lt;InvalidOperationException&gt;(() =&gt; httpClient.GetAsync(&quot;/&quot;));
57              Assert.Equal(&quot;Provide MetadataAddress, Configuration, or ConfigurationManager to WsFederationOptions&quot;, exception.Message);
58          }
59          [Fact]
60          public async Task ChallengeRedirects()
61          {
62              var httpClient = CreateClient();
63              var response = await httpClient.GetAsync(&quot;/&quot;);
64              Assert.Equal(&quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed&quot;, response.Headers.Location.GetLeftPart(System.UriPartial.Path));
65              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
66              Assert.Equal(&quot;http:&amp;bsol;&amp;bsol;Automation1&quot;, queryItems[&quot;wtrealm&quot;]);
67              Assert.True(queryItems[&quot;wctx&quot;].ToString().Equals(CustomStateDataFormat.ValidStateData), &quot;wctx does not equal ValidStateData&quot;);
68              Assert.Equal(httpClient.BaseAddress + &quot;signin-wsfed&quot;, queryItems[&quot;wreply&quot;]);
69              Assert.Equal(&quot;wsignin1.0&quot;, queryItems[&quot;wa&quot;]);
70          }
71          [Fact]
72          public async Task MapWillNotAffectRedirect()
73          {
74              var httpClient = CreateClient();
75              var response = await httpClient.GetAsync(&quot;/mapped-challenge&quot;);
76              Assert.Equal(&quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed&quot;, response.Headers.Location.GetLeftPart(System.UriPartial.Path));
77              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
78              Assert.Equal(&quot;http:&amp;bsol;&amp;bsol;Automation1&quot;, queryItems[&quot;wtrealm&quot;]);
79              Assert.True(queryItems[&quot;wctx&quot;].ToString().Equals(CustomStateDataFormat.ValidStateData), &quot;wctx does not equal ValidStateData&quot;);
80              Assert.Equal(httpClient.BaseAddress + &quot;signin-wsfed&quot;, queryItems[&quot;wreply&quot;]);
81              Assert.Equal(&quot;wsignin1.0&quot;, queryItems[&quot;wa&quot;]);
82          }
83          [Fact]
84          public async Task PreMappedWillAffectRedirect()
85          {
86              var httpClient = CreateClient();
87              var response = await httpClient.GetAsync(&quot;/premapped-challenge&quot;);
88              Assert.Equal(&quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed&quot;, response.Headers.Location.GetLeftPart(System.UriPartial.Path));
89              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
90              Assert.Equal(&quot;http:&amp;bsol;&amp;bsol;Automation1&quot;, queryItems[&quot;wtrealm&quot;]);
91              Assert.True(queryItems[&quot;wctx&quot;].ToString().Equals(CustomStateDataFormat.ValidStateData), &quot;wctx does not equal ValidStateData&quot;);
92              Assert.Equal(httpClient.BaseAddress + &quot;premapped-challenge/signin-wsfed&quot;, queryItems[&quot;wreply&quot;]);
93              Assert.Equal(&quot;wsignin1.0&quot;, queryItems[&quot;wa&quot;]);
94          }
95          [Fact]
96          public async Task ValidTokenIsAccepted()
97          {
98              var httpClient = CreateClient();
99              var response = await httpClient.GetAsync(&quot;/&quot;);
100              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
101              var request = new HttpRequestMessage(HttpMethod.Post, queryItems[&quot;wreply&quot;]);
102              CopyCookies(response, request);
103              request.Content = CreateSignInContent(&quot;WsFederation/ValidToken.xml&quot;, queryItems[&quot;wctx&quot;]);
104              response = await httpClient.SendAsync(request);
105              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
106              request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
107              CopyCookies(response, request);
108              response = await httpClient.SendAsync(request);
109              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
110          }
111          [Fact]
112          public async Task ValidUnsolicitedTokenIsRefused()
113          {
114              var httpClient = CreateClient();
115              var form = CreateSignInContent(&quot;WsFederation/ValidToken.xml&quot;, suppressWctx: true);
116              var exception = await Assert.ThrowsAsync&lt;Exception&gt;(() =&gt; httpClient.PostAsync(httpClient.BaseAddress + &quot;signin-wsfed&quot;, form));
117              Assert.Contains(&quot;Unsolicited logins are not allowed.&quot;, exception.InnerException.Message);
118          }
119          [Fact]
120          public async Task ValidUnsolicitedTokenIsAcceptedWhenAllowed()
121          {
122              var httpClient = CreateClient(allowUnsolicited: true);
123              var form = CreateSignInContent(&quot;WsFederation/ValidToken.xml&quot;, suppressWctx: true);
124              var response = await httpClient.PostAsync(httpClient.BaseAddress + &quot;signin-wsfed&quot;, form);
125              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
126              var request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
127              CopyCookies(response, request);
128              response = await httpClient.SendAsync(request);
129              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
130          }
131          [Fact]
132          public async Task InvalidTokenIsRejected()
133          {
134              var httpClient = CreateClient();
135              var response = await httpClient.GetAsync(&quot;/&quot;);
136              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
137              var request = new HttpRequestMessage(HttpMethod.Post, queryItems[&quot;wreply&quot;]);
138              CopyCookies(response, request);
139              request.Content = CreateSignInContent(&quot;WsFederation/InvalidToken.xml&quot;, queryItems[&quot;wctx&quot;]);
140              response = await httpClient.SendAsync(request);
141              Assert.Equal(&quot;AuthenticationFailed&quot;, await response.Content.ReadAsStringAsync());
142          }
143          [Fact]
144          public async Task RemoteSignoutRequestTriggersSignout()
145          {
146              var httpClient = CreateClient();
147              var response = await httpClient.GetAsync(&quot;/signin-wsfed?wa=wsignoutcleanup1.0&quot;);
148              response.EnsureSuccessStatusCode();
149              var cookie = response.Headers.GetValues(HeaderNames.SetCookie).Single();
150              Assert.Equal(&quot;.AspNetCore.Cookies=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; samesite=lax&quot;, cookie);
151              Assert.Equal(&quot;OnRemoteSignOut&quot;, response.Headers.GetValues(&quot;EventHeader&quot;).Single());
152              Assert.Equal(&quot;&quot;, await response.Content.ReadAsStringAsync());
153          }
154          [Fact]
155          public async Task EventsResolvedFromDI()
156          {
157              var builder = new WebHostBuilder()
158                  .ConfigureServices(services =&gt;
159                  {
160                      services.AddSingleton&lt;MyWsFedEvents&gt;();
161                      services.AddAuthentication(sharedOptions =&gt;
162                      {
163                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
164                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
165                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
166                      })
167                      .AddCookie()
168                      .AddWsFederation(options =&gt;
169                      {
170                          options.Wtrealm = &quot;http:&amp;bsol;&amp;bsol;Automation1&quot;;
171                          options.MetadataAddress = &quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml&quot;;
172                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
173                          options.EventsType = typeof(MyWsFedEvents);
174                      });
175                  })
176                  .Configure(app =&gt;
177                  {
178                      app.Run(context =&gt; context.ChallengeAsync());
179                  });
180              var server = new TestServer(builder);
181              var result = await server.CreateClient().GetAsync(&quot;&quot;);
182              Assert.Contains(&quot;CustomKey=CustomValue&quot;, result.Headers.Location.Query);
183          }
184          private class MyWsFedEvents : WsFederationEvents
185          {
186              public override Task RedirectToIdentityProvider(RedirectContext context)
187              {
188                  context.ProtocolMessage.SetParameter(&quot;CustomKey&quot;, &quot;CustomValue&quot;);
189                  return base.RedirectToIdentityProvider(context);
190              }
191          }
192          private FormUrlEncodedContent CreateSignInContent(string tokenFile, string wctx = null, bool suppressWctx = false)
193          {
194              var kvps = new List&lt;KeyValuePair&lt;string, string&gt;&gt;();
<span onclick='openModal()' class='match'>195              kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wa&quot;, &quot;wsignin1.0&quot;));
196              kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wresult&quot;, File.ReadAllText(tokenFile)));
</span>197              if (!string.IsNullOrEmpty(wctx))
198              {
199                  kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wctx&quot;, wctx));
200              }
201              if (suppressWctx)
202              {
203                  kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;suppressWctx&quot;, &quot;true&quot;));
204              }
205              return new FormUrlEncodedContent(kvps);
206          }
207          private void CopyCookies(HttpResponseMessage response, HttpRequestMessage request)
208          {
209              var cookies = SetCookieHeaderValue.ParseList(response.Headers.GetValues(HeaderNames.SetCookie).ToList());
210              foreach (var cookie in cookies)
211              {
212                  if (cookie.Value.HasValue)
213                  {
214                      request.Headers.Add(HeaderNames.Cookie, new CookieHeaderValue(cookie.Name, cookie.Value).ToString());
215                  }
216              }
217          }
218          private HttpClient CreateClient(bool allowUnsolicited = false)
219          {
220              var builder = new WebHostBuilder()
221                  .Configure(ConfigureApp)
222                  .ConfigureServices(services =&gt;
223                  {
224                      services.AddAuthentication(sharedOptions =&gt;
225                      {
226                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
227                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
228                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
229                      })
230                      .AddCookie()
231                      .AddWsFederation(options =&gt;
232                      {
233                          options.Wtrealm = &quot;http:&amp;bsol;&amp;bsol;Automation1&quot;;
234                          options.MetadataAddress = &quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml&quot;;
235                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
236                          options.StateDataFormat = new CustomStateDataFormat();
237                          options.SecurityTokenHandlers = new List&lt;ISecurityTokenValidator&gt;() { new TestSecurityTokenValidator() };
238                          options.UseTokenLifetime = false;
239                          options.AllowUnsolicitedLogins = allowUnsolicited;
240                          options.Events = new WsFederationEvents()
241                          {
242                              OnMessageReceived = context =&gt;
243                              {
244                                  if (!context.ProtocolMessage.Parameters.TryGetValue(&quot;suppressWctx&quot;, out var suppress))
245                                  {
246                                      Assert.True(context.ProtocolMessage.Wctx.Equals(&quot;customValue&quot;), &quot;wctx is not my custom value&quot;);
247                                  }
248                                  context.HttpContext.Items[&quot;MessageReceived&quot;] = true;
249                                  return Task.FromResult(0);
250                              },
251                              OnRedirectToIdentityProvider = context =&gt;
252                              {
253                                  if (context.ProtocolMessage.IsSignInMessage)
254                                  {
255                                      context.ProtocolMessage.Wctx = &quot;customValue&quot;;
256                                  }
257                                  return Task.FromResult(0);
258                              },
259                              OnSecurityTokenReceived = context =&gt;
260                              {
261                                  context.HttpContext.Items[&quot;SecurityTokenReceived&quot;] = true;
262                                  return Task.FromResult(0);
263                              },
264                              OnSecurityTokenValidated = context =&gt;
265                              {
266                                  Assert.True((bool)context.HttpContext.Items[&quot;MessageReceived&quot;], &quot;MessageReceived notification not invoked&quot;);
267                                  Assert.True((bool)context.HttpContext.Items[&quot;SecurityTokenReceived&quot;], &quot;SecurityTokenReceived notification not invoked&quot;);
268                                  if (context.Principal != null)
269                                  {
270                                      var identity = context.Principal.Identities.Single();
271                                      identity.AddClaim(new Claim(&quot;ReturnEndpoint&quot;, &quot;true&quot;));
272                                      identity.AddClaim(new Claim(&quot;Authenticated&quot;, &quot;true&quot;));
273                                      identity.AddClaim(new Claim(identity.RoleClaimType, &quot;Guest&quot;, ClaimValueTypes.String));
274                                  }
275                                  return Task.FromResult(0);
276                              },
277                              OnAuthenticationFailed = context =&gt;
278                              {
279                                  context.HttpContext.Items[&quot;AuthenticationFailed&quot;] = true;
280                                  context.HttpContext.Request.Path = new PathString(&quot;/AuthenticationFailed&quot;);
281                                  context.SkipHandler();
282                                  return Task.FromResult(0);
283                              },
284                              OnRemoteSignOut = context =&gt;
285                              {
286                                  context.Response.Headers[&quot;EventHeader&quot;] = &quot;OnRemoteSignOut&quot;;
287                                  return Task.FromResult(0);
288                              }
289                          };
290                      });
291                  });
292              var server = new TestServer(builder);
293              return server.CreateClient();
294          }
295          private void ConfigureApp(IApplicationBuilder app)
296          {
297              app.Map(&quot;/PreMapped-Challenge&quot;, mapped =&gt;
298              {
299                  mapped.UseAuthentication();
300                  mapped.Run(async context =&gt;
301                  {
302                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
303                  });
304              });
305              app.UseAuthentication();
306              app.Map(&quot;/Logout&quot;, subApp =&gt;
307                  {
308                      subApp.Run(async context =&gt;
309                          {
310                              if (context.User.Identity.IsAuthenticated)
311                              {
312                                  var authProperties = new AuthenticationProperties() { RedirectUri = context.Request.GetEncodedUrl() };
313                                  await context.SignOutAsync(WsFederationDefaults.AuthenticationScheme, authProperties);
314                                  await context.Response.WriteAsync(&quot;Signing out...&quot;);
315                              }
316                              else
317                              {
318                                  await context.Response.WriteAsync(&quot;SignedOut&quot;);
319                              }
320                          });
321                  });
322              app.Map(&quot;/AuthenticationFailed&quot;, subApp =&gt;
323              {
324                  subApp.Run(async context =&gt;
325                  {
326                      await context.Response.WriteAsync(&quot;AuthenticationFailed&quot;);
327                  });
328              });
329              app.Map(&quot;/signout-wsfed&quot;, subApp =&gt;
330              {
331                  subApp.Run(async context =&gt;
332                  {
333                      await context.Response.WriteAsync(&quot;signout-wsfed&quot;);
334                  });
335              });
336              app.Map(&quot;/mapped-challenge&quot;, subApp =&gt;
337              {
338                  subApp.Run(async context =&gt;
339                  {
340                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
341                  });
342              });
343              app.Run(async context =&gt;
344              {
345                  var result = context.AuthenticateAsync();
346                  if (context.User == null || !context.User.Identity.IsAuthenticated)
347                  {
348                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
349                      await context.Response.WriteAsync(&quot;Unauthorized&quot;);
350                  }
351                  else
352                  {
353                      var identity = context.User.Identities.Single();
354                      if (identity.NameClaimType == &quot;Name_Failed&quot; &amp;&amp; identity.RoleClaimType == &quot;Role_Failed&quot;)
355                      {
356                          context.Response.StatusCode = 500;
357                          await context.Response.WriteAsync(&quot;SignIn_Failed&quot;);
358                      }
359                      else if (!identity.HasClaim(&quot;Authenticated&quot;, &quot;true&quot;) || !identity.HasClaim(&quot;ReturnEndpoint&quot;, &quot;true&quot;) || !identity.HasClaim(identity.RoleClaimType, &quot;Guest&quot;))
360                      {
361                          await context.Response.WriteAsync(&quot;Provider not invoked&quot;);
362                          return;
363                      }
364                      else
365                      {
366                          await context.Response.WriteAsync(WsFederationDefaults.AuthenticationScheme);
367                      }
368                  }
369              });
370          }
371          private class WaadMetadataDocumentHandler : HttpMessageHandler
372          {
373              protected override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
374              {
375                  var metadata = File.ReadAllText(@&quot;WsFederation/federationmetadata.xml&quot;);
376                  var newResponse = new HttpResponseMessage() { Content = new StringContent(metadata, Encoding.UTF8, &quot;text/xml&quot;) };
377                  return Task.FromResult&lt;HttpResponseMessage&gt;(newResponse);
378              }
379          }
380      }
381  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Net;
6  using System.Net.Http;
7  using System.Security.Claims;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using Microsoft.AspNetCore.Authentication.Cookies;
12  using Microsoft.AspNetCore.Builder;
13  using Microsoft.AspNetCore.Hosting;
14  using Microsoft.AspNetCore.Http;
15  using Microsoft.AspNetCore.Http.Extensions;
16  using Microsoft.AspNetCore.TestHost;
17  using Microsoft.AspNetCore.WebUtilities;
18  using Microsoft.Extensions.DependencyInjection;
19  using Microsoft.IdentityModel.Tokens;
20  using Microsoft.Net.Http.Headers;
21  using Xunit;
22  namespace Microsoft.AspNetCore.Authentication.WsFederation
23  {
24      public class WsFederationTest
25      {
26          [Fact]
27          public async Task VerifySchemeDefaults()
28          {
29              var services = new ServiceCollection();
30              services.AddAuthentication().AddWsFederation();
31              var sp = services.BuildServiceProvider();
32              var schemeProvider = sp.GetRequiredService&lt;IAuthenticationSchemeProvider&gt;();
33              var scheme = await schemeProvider.GetSchemeAsync(WsFederationDefaults.AuthenticationScheme);
34              Assert.NotNull(scheme);
35              Assert.Equal(&quot;WsFederationHandler&quot;, scheme.HandlerType.Name);
36              Assert.Equal(WsFederationDefaults.AuthenticationScheme, scheme.DisplayName);
37          }
38          [Fact]
39          public async Task MissingConfigurationThrows()
40          {
41              var builder = new WebHostBuilder()
42                  .Configure(ConfigureApp)
43                  .ConfigureServices(services =&gt;
44                  {
45                      services.AddAuthentication(sharedOptions =&gt;
46                      {
47                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
48                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
49                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
50                      })
51                      .AddCookie()
52                      .AddWsFederation();
53                  });
54              var server = new TestServer(builder);
55              var httpClient = server.CreateClient();
56              var exception = await Assert.ThrowsAsync&lt;InvalidOperationException&gt;(() =&gt; httpClient.GetAsync(&quot;/&quot;));
57              Assert.Equal(&quot;Provide MetadataAddress, Configuration, or ConfigurationManager to WsFederationOptions&quot;, exception.Message);
58          }
59          [Fact]
60          public async Task ChallengeRedirects()
61          {
62              var httpClient = CreateClient();
63              var response = await httpClient.GetAsync(&quot;/&quot;);
64              Assert.Equal(&quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed&quot;, response.Headers.Location.GetLeftPart(System.UriPartial.Path));
65              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
66              Assert.Equal(&quot;http:&amp;bsol;&amp;bsol;Automation1&quot;, queryItems[&quot;wtrealm&quot;]);
67              Assert.True(queryItems[&quot;wctx&quot;].ToString().Equals(CustomStateDataFormat.ValidStateData), &quot;wctx does not equal ValidStateData&quot;);
68              Assert.Equal(httpClient.BaseAddress + &quot;signin-wsfed&quot;, queryItems[&quot;wreply&quot;]);
69              Assert.Equal(&quot;wsignin1.0&quot;, queryItems[&quot;wa&quot;]);
70          }
71          [Fact]
72          public async Task MapWillNotAffectRedirect()
73          {
74              var httpClient = CreateClient();
75              var response = await httpClient.GetAsync(&quot;/mapped-challenge&quot;);
76              Assert.Equal(&quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed&quot;, response.Headers.Location.GetLeftPart(System.UriPartial.Path));
77              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
78              Assert.Equal(&quot;http:&amp;bsol;&amp;bsol;Automation1&quot;, queryItems[&quot;wtrealm&quot;]);
79              Assert.True(queryItems[&quot;wctx&quot;].ToString().Equals(CustomStateDataFormat.ValidStateData), &quot;wctx does not equal ValidStateData&quot;);
80              Assert.Equal(httpClient.BaseAddress + &quot;signin-wsfed&quot;, queryItems[&quot;wreply&quot;]);
81              Assert.Equal(&quot;wsignin1.0&quot;, queryItems[&quot;wa&quot;]);
82          }
83          [Fact]
84          public async Task PreMappedWillAffectRedirect()
85          {
86              var httpClient = CreateClient();
87              var response = await httpClient.GetAsync(&quot;/premapped-challenge&quot;);
88              Assert.Equal(&quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/wsfed&quot;, response.Headers.Location.GetLeftPart(System.UriPartial.Path));
89              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
90              Assert.Equal(&quot;http:&amp;bsol;&amp;bsol;Automation1&quot;, queryItems[&quot;wtrealm&quot;]);
91              Assert.True(queryItems[&quot;wctx&quot;].ToString().Equals(CustomStateDataFormat.ValidStateData), &quot;wctx does not equal ValidStateData&quot;);
92              Assert.Equal(httpClient.BaseAddress + &quot;premapped-challenge/signin-wsfed&quot;, queryItems[&quot;wreply&quot;]);
93              Assert.Equal(&quot;wsignin1.0&quot;, queryItems[&quot;wa&quot;]);
94          }
95          [Fact]
96          public async Task ValidTokenIsAccepted()
97          {
98              var httpClient = CreateClient();
99              var response = await httpClient.GetAsync(&quot;/&quot;);
100              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
101              var request = new HttpRequestMessage(HttpMethod.Post, queryItems[&quot;wreply&quot;]);
102              CopyCookies(response, request);
103              request.Content = CreateSignInContent(&quot;WsFederation/ValidToken.xml&quot;, queryItems[&quot;wctx&quot;]);
104              response = await httpClient.SendAsync(request);
105              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
106              request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
107              CopyCookies(response, request);
108              response = await httpClient.SendAsync(request);
109              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
110          }
111          [Fact]
112          public async Task ValidUnsolicitedTokenIsRefused()
113          {
114              var httpClient = CreateClient();
115              var form = CreateSignInContent(&quot;WsFederation/ValidToken.xml&quot;, suppressWctx: true);
116              var exception = await Assert.ThrowsAsync&lt;Exception&gt;(() =&gt; httpClient.PostAsync(httpClient.BaseAddress + &quot;signin-wsfed&quot;, form));
117              Assert.Contains(&quot;Unsolicited logins are not allowed.&quot;, exception.InnerException.Message);
118          }
119          [Fact]
120          public async Task ValidUnsolicitedTokenIsAcceptedWhenAllowed()
121          {
122              var httpClient = CreateClient(allowUnsolicited: true);
123              var form = CreateSignInContent(&quot;WsFederation/ValidToken.xml&quot;, suppressWctx: true);
124              var response = await httpClient.PostAsync(httpClient.BaseAddress + &quot;signin-wsfed&quot;, form);
125              Assert.Equal(HttpStatusCode.Found, response.StatusCode);
126              var request = new HttpRequestMessage(HttpMethod.Get, response.Headers.Location);
127              CopyCookies(response, request);
128              response = await httpClient.SendAsync(request);
129              Assert.Equal(WsFederationDefaults.AuthenticationScheme, await response.Content.ReadAsStringAsync());
130          }
131          [Fact]
132          public async Task InvalidTokenIsRejected()
133          {
134              var httpClient = CreateClient();
135              var response = await httpClient.GetAsync(&quot;/&quot;);
136              var queryItems = QueryHelpers.ParseQuery(response.Headers.Location.Query);
137              var request = new HttpRequestMessage(HttpMethod.Post, queryItems[&quot;wreply&quot;]);
138              CopyCookies(response, request);
139              request.Content = CreateSignInContent(&quot;WsFederation/InvalidToken.xml&quot;, queryItems[&quot;wctx&quot;]);
140              response = await httpClient.SendAsync(request);
141              Assert.Equal(&quot;AuthenticationFailed&quot;, await response.Content.ReadAsStringAsync());
142          }
143          [Fact]
144          public async Task RemoteSignoutRequestTriggersSignout()
145          {
146              var httpClient = CreateClient();
147              var response = await httpClient.GetAsync(&quot;/signin-wsfed?wa=wsignoutcleanup1.0&quot;);
148              response.EnsureSuccessStatusCode();
149              var cookie = response.Headers.GetValues(HeaderNames.SetCookie).Single();
150              Assert.Equal(&quot;.AspNetCore.Cookies=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; samesite=lax&quot;, cookie);
151              Assert.Equal(&quot;OnRemoteSignOut&quot;, response.Headers.GetValues(&quot;EventHeader&quot;).Single());
152              Assert.Equal(&quot;&quot;, await response.Content.ReadAsStringAsync());
153          }
154          [Fact]
155          public async Task EventsResolvedFromDI()
156          {
157              var builder = new WebHostBuilder()
158                  .ConfigureServices(services =&gt;
159                  {
160                      services.AddSingleton&lt;MyWsFedEvents&gt;();
161                      services.AddAuthentication(sharedOptions =&gt;
162                      {
163                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
164                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
165                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
166                      })
167                      .AddCookie()
168                      .AddWsFederation(options =&gt;
169                      {
170                          options.Wtrealm = &quot;http:&amp;bsol;&amp;bsol;Automation1&quot;;
171                          options.MetadataAddress = &quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml&quot;;
172                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
173                          options.EventsType = typeof(MyWsFedEvents);
174                      });
175                  })
176                  .Configure(app =&gt;
177                  {
178                      app.Run(context =&gt; context.ChallengeAsync());
179                  });
180              var server = new TestServer(builder);
181              var result = await server.CreateClient().GetAsync(&quot;&quot;);
182              Assert.Contains(&quot;CustomKey=CustomValue&quot;, result.Headers.Location.Query);
183          }
184          private class MyWsFedEvents : WsFederationEvents
185          {
186              public override Task RedirectToIdentityProvider(RedirectContext context)
187              {
188                  context.ProtocolMessage.SetParameter(&quot;CustomKey&quot;, &quot;CustomValue&quot;);
189                  return base.RedirectToIdentityProvider(context);
190              }
191          }
192          private FormUrlEncodedContent CreateSignInContent(string tokenFile, string wctx = null, bool suppressWctx = false)
193          {
194              var kvps = new List&lt;KeyValuePair&lt;string, string&gt;&gt;();
195              kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wa&quot;, &quot;wsignin1.0&quot;));
196              kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wresult&quot;, File.ReadAllText(tokenFile)));
197              if (!string.IsNullOrEmpty(wctx))
198              {
199                  kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wctx&quot;, wctx));
200              }
201              if (suppressWctx)
202              {
<span onclick='openModal()' class='match'>203                  kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;suppressWctx&quot;, &quot;true&quot;));
204              }
</span>205              return new FormUrlEncodedContent(kvps);
206          }
207          private void CopyCookies(HttpResponseMessage response, HttpRequestMessage request)
208          {
209              var cookies = SetCookieHeaderValue.ParseList(response.Headers.GetValues(HeaderNames.SetCookie).ToList());
210              foreach (var cookie in cookies)
211              {
212                  if (cookie.Value.HasValue)
213                  {
214                      request.Headers.Add(HeaderNames.Cookie, new CookieHeaderValue(cookie.Name, cookie.Value).ToString());
215                  }
216              }
217          }
218          private HttpClient CreateClient(bool allowUnsolicited = false)
219          {
220              var builder = new WebHostBuilder()
221                  .Configure(ConfigureApp)
222                  .ConfigureServices(services =&gt;
223                  {
224                      services.AddAuthentication(sharedOptions =&gt;
225                      {
226                          sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
227                          sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
228                          sharedOptions.DefaultChallengeScheme = WsFederationDefaults.AuthenticationScheme;
229                      })
230                      .AddCookie()
231                      .AddWsFederation(options =&gt;
232                      {
233                          options.Wtrealm = &quot;http:&amp;bsol;&amp;bsol;Automation1&quot;;
234                          options.MetadataAddress = &quot;https:&amp;bsol;&amp;bsol;login.windows.net/4afbc689-805b-48cf-a24c-d4aa3248a248/federationmetadata/2007-06/federationmetadata.xml&quot;;
235                          options.BackchannelHttpHandler = new WaadMetadataDocumentHandler();
236                          options.StateDataFormat = new CustomStateDataFormat();
237                          options.SecurityTokenHandlers = new List&lt;ISecurityTokenValidator&gt;() { new TestSecurityTokenValidator() };
238                          options.UseTokenLifetime = false;
239                          options.AllowUnsolicitedLogins = allowUnsolicited;
240                          options.Events = new WsFederationEvents()
241                          {
242                              OnMessageReceived = context =&gt;
243                              {
244                                  if (!context.ProtocolMessage.Parameters.TryGetValue(&quot;suppressWctx&quot;, out var suppress))
245                                  {
246                                      Assert.True(context.ProtocolMessage.Wctx.Equals(&quot;customValue&quot;), &quot;wctx is not my custom value&quot;);
247                                  }
248                                  context.HttpContext.Items[&quot;MessageReceived&quot;] = true;
249                                  return Task.FromResult(0);
250                              },
251                              OnRedirectToIdentityProvider = context =&gt;
252                              {
253                                  if (context.ProtocolMessage.IsSignInMessage)
254                                  {
255                                      context.ProtocolMessage.Wctx = &quot;customValue&quot;;
256                                  }
257                                  return Task.FromResult(0);
258                              },
259                              OnSecurityTokenReceived = context =&gt;
260                              {
261                                  context.HttpContext.Items[&quot;SecurityTokenReceived&quot;] = true;
262                                  return Task.FromResult(0);
263                              },
264                              OnSecurityTokenValidated = context =&gt;
265                              {
266                                  Assert.True((bool)context.HttpContext.Items[&quot;MessageReceived&quot;], &quot;MessageReceived notification not invoked&quot;);
267                                  Assert.True((bool)context.HttpContext.Items[&quot;SecurityTokenReceived&quot;], &quot;SecurityTokenReceived notification not invoked&quot;);
268                                  if (context.Principal != null)
269                                  {
270                                      var identity = context.Principal.Identities.Single();
271                                      identity.AddClaim(new Claim(&quot;ReturnEndpoint&quot;, &quot;true&quot;));
272                                      identity.AddClaim(new Claim(&quot;Authenticated&quot;, &quot;true&quot;));
273                                      identity.AddClaim(new Claim(identity.RoleClaimType, &quot;Guest&quot;, ClaimValueTypes.String));
274                                  }
275                                  return Task.FromResult(0);
276                              },
277                              OnAuthenticationFailed = context =&gt;
278                              {
279                                  context.HttpContext.Items[&quot;AuthenticationFailed&quot;] = true;
280                                  context.HttpContext.Request.Path = new PathString(&quot;/AuthenticationFailed&quot;);
281                                  context.SkipHandler();
282                                  return Task.FromResult(0);
283                              },
284                              OnRemoteSignOut = context =&gt;
285                              {
286                                  context.Response.Headers[&quot;EventHeader&quot;] = &quot;OnRemoteSignOut&quot;;
287                                  return Task.FromResult(0);
288                              }
289                          };
290                      });
291                  });
292              var server = new TestServer(builder);
293              return server.CreateClient();
294          }
295          private void ConfigureApp(IApplicationBuilder app)
296          {
297              app.Map(&quot;/PreMapped-Challenge&quot;, mapped =&gt;
298              {
299                  mapped.UseAuthentication();
300                  mapped.Run(async context =&gt;
301                  {
302                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
303                  });
304              });
305              app.UseAuthentication();
306              app.Map(&quot;/Logout&quot;, subApp =&gt;
307                  {
308                      subApp.Run(async context =&gt;
309                          {
310                              if (context.User.Identity.IsAuthenticated)
311                              {
312                                  var authProperties = new AuthenticationProperties() { RedirectUri = context.Request.GetEncodedUrl() };
313                                  await context.SignOutAsync(WsFederationDefaults.AuthenticationScheme, authProperties);
314                                  await context.Response.WriteAsync(&quot;Signing out...&quot;);
315                              }
316                              else
317                              {
318                                  await context.Response.WriteAsync(&quot;SignedOut&quot;);
319                              }
320                          });
321                  });
322              app.Map(&quot;/AuthenticationFailed&quot;, subApp =&gt;
323              {
324                  subApp.Run(async context =&gt;
325                  {
326                      await context.Response.WriteAsync(&quot;AuthenticationFailed&quot;);
327                  });
328              });
329              app.Map(&quot;/signout-wsfed&quot;, subApp =&gt;
330              {
331                  subApp.Run(async context =&gt;
332                  {
333                      await context.Response.WriteAsync(&quot;signout-wsfed&quot;);
334                  });
335              });
336              app.Map(&quot;/mapped-challenge&quot;, subApp =&gt;
337              {
338                  subApp.Run(async context =&gt;
339                  {
340                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
341                  });
342              });
343              app.Run(async context =&gt;
344              {
345                  var result = context.AuthenticateAsync();
346                  if (context.User == null || !context.User.Identity.IsAuthenticated)
347                  {
348                      await context.ChallengeAsync(WsFederationDefaults.AuthenticationScheme);
349                      await context.Response.WriteAsync(&quot;Unauthorized&quot;);
350                  }
351                  else
352                  {
353                      var identity = context.User.Identities.Single();
354                      if (identity.NameClaimType == &quot;Name_Failed&quot; &amp;&amp; identity.RoleClaimType == &quot;Role_Failed&quot;)
355                      {
356                          context.Response.StatusCode = 500;
357                          await context.Response.WriteAsync(&quot;SignIn_Failed&quot;);
358                      }
359                      else if (!identity.HasClaim(&quot;Authenticated&quot;, &quot;true&quot;) || !identity.HasClaim(&quot;ReturnEndpoint&quot;, &quot;true&quot;) || !identity.HasClaim(identity.RoleClaimType, &quot;Guest&quot;))
360                      {
361                          await context.Response.WriteAsync(&quot;Provider not invoked&quot;);
362                          return;
363                      }
364                      else
365                      {
366                          await context.Response.WriteAsync(WsFederationDefaults.AuthenticationScheme);
367                      }
368                  }
369              });
370          }
371          private class WaadMetadataDocumentHandler : HttpMessageHandler
372          {
373              protected override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
374              {
375                  var metadata = File.ReadAllText(@&quot;WsFederation/federationmetadata.xml&quot;);
376                  var newResponse = new HttpResponseMessage() { Content = new StringContent(metadata, Encoding.UTF8, &quot;text/xml&quot;) };
377                  return Task.FromResult&lt;HttpResponseMessage&gt;(newResponse);
378              }
379          }
380      }
381  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationTest.cs</div>
                </div>
                <div class="column column_space"><pre><code>195              kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wa&quot;, &quot;wsignin1.0&quot;));
196              kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;wresult&quot;, File.ReadAllText(tokenFile)));
</pre></code></div>
                <div class="column column_space"><pre><code>203                  kvps.Add(new KeyValuePair&lt;string, string&gt;(&quot;suppressWctx&quot;, &quot;true&quot;));
204              }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    