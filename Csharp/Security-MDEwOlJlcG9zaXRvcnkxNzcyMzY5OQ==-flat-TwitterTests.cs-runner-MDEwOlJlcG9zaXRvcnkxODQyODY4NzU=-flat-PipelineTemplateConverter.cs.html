
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-TwitterTests.cs</h3>
            <pre><code>1  using Microsoft.AspNetCore.Builder;
2  using Microsoft.AspNetCore.Hosting;
3  using Microsoft.AspNetCore.Http;
4  using Microsoft.AspNetCore.TestHost;
5  using Microsoft.Extensions.DependencyInjection;
6  using Microsoft.Net.Http.Headers;
7  using System;
8  using System.Linq;
9  using System.Net;
10  using System.Net.Http;
11  using System.Security.Claims;
12  using System.Text;
13  using System.Threading.Tasks;
14  using Xunit;
15  namespace Microsoft.AspNetCore.Authentication.Twitter
16  {
17      public class TwitterTests : RemoteAuthenticationTests<TwitterOptions>
18      {
19          protected override string DefaultScheme => TwitterDefaults.AuthenticationScheme;
20          protected override Type HandlerType => typeof(TwitterHandler);
21          protected override bool SupportsSignIn { get => false; }
22          protected override bool SupportsSignOut { get => false; }
23          protected override void RegisterAuth(AuthenticationBuilder services, Action<TwitterOptions> configure)
24          {
25              services.AddTwitter(o =>
26              {
27                  ConfigureDefaults(o);
28                  configure.Invoke(o);
29              });
30          }
31          protected override void ConfigureDefaults(TwitterOptions o)
32          {
33              o.ConsumerKey = "whatever";
34              o.ConsumerSecret = "whatever";
35              o.SignInScheme = "auth1";
36          }
37          [Fact]
38          public async Task ChallengeWillTriggerApplyRedirectEvent()
39          {
40              var server = CreateServer(o =>
41              {
42                  o.ConsumerKey = "Test Consumer Key";
43                  o.ConsumerSecret = "Test Consumer Secret";
44                  o.Events = new TwitterEvents
45                  {
46                      OnRedirectToAuthorizationEndpoint = context =>
47                      {
48                          context.Response.Redirect(context.RedirectUri + "&custom=test");
49                          return Task.FromResult(0);
50                      }
51                  };
52                  o.BackchannelHttpHandler = new TestHttpMessageHandler
53                  {
54                      Sender = BackchannelRequestToken
55                  };
56              },
57              async context =>
58              {
59                  await context.ChallengeAsync("Twitter");
60                  return true;
61              });
62              var transaction = await server.SendAsync("http:&bsol;&bsol;example.com/challenge");
63              Assert.Equal(HttpStatusCode.Redirect, transaction.Response.StatusCode);
64              var query = transaction.Response.Headers.Location.Query;
65              Assert.Contains("custom=test", query);
66          }
67          [Fact]
68          public async Task ThrowsIfClientIdMissing()
69          {
70              var server = CreateServer(o =>
71              {
72                  o.ConsumerSecret = "Test Consumer Secret";
73              });
74              await Assert.ThrowsAsync<ArgumentException>("ConsumerKey", async () => await server.SendAsync("http:&bsol;&bsol;example.com/challenge"));
75          }
76          [Fact]
77          public async Task ThrowsIfClientSecretMissing()
78          {
79              var server = CreateServer(o =>
80              {
81                  o.ConsumerKey = "Test Consumer Key";
82              });
83              await Assert.ThrowsAsync<ArgumentException>("ConsumerSecret", async () => await server.SendAsync("http:&bsol;&bsol;example.com/challenge"));
84          }
85          [Fact]
86          public async Task BadSignInWillThrow()
87          {
88              var server = CreateServer(o =>
89              {
90                  o.ConsumerKey = "Test Consumer Key";
91                  o.ConsumerSecret = "Test Consumer Secret";
92              });
93              var error = await Assert.ThrowsAnyAsync<Exception>(() => server.SendAsync("https:&bsol;&bsol;example.com/signin-twitter"));
94              Assert.Equal("Invalid state cookie.", error.GetBaseException().Message);
95          }
96          [Fact]
97          public async Task SignInThrows()
98          {
99              var server = CreateServer(o =>
100              {
101                  o.ConsumerKey = "Test Consumer Key";
102                  o.ConsumerSecret = "Test Consumer Secret";
103              });
104              var transaction = await server.SendAsync("https:&bsol;&bsol;example.com/signIn");
105              Assert.Equal(HttpStatusCode.OK, transaction.Response.StatusCode);
106          }
107          [Fact]
108          public async Task SignOutThrows()
109          {
110              var server = CreateServer(o =>
111              {
112                  o.ConsumerKey = "Test Consumer Key";
113                  o.ConsumerSecret = "Test Consumer Secret";
114              });
115              var transaction = await server.SendAsync("https:&bsol;&bsol;example.com/signOut");
116              Assert.Equal(HttpStatusCode.OK, transaction.Response.StatusCode);
117          }
118          [Fact]
119          public async Task ForbidThrows()
120          {
121              var server = CreateServer(o =>
122              {
123                  o.ConsumerKey = "Test Consumer Key";
124                  o.ConsumerSecret = "Test Consumer Secret";
125              });
126              var transaction = await server.SendAsync("https:&bsol;&bsol;example.com/signOut");
127              Assert.Equal(HttpStatusCode.OK, transaction.Response.StatusCode);
128          }
129          [Fact]
130          public async Task ChallengeWillTriggerRedirection()
131          {
132              var server = CreateServer(o =>
133              {
134                  o.ConsumerKey = "Test Consumer Key";
135                  o.ConsumerSecret = "Test Consumer Secret";
<span onclick='openModal()' class='match'>136                  o.BackchannelHttpHandler = new TestHttpMessageHandler
137                  {
138                      Sender = BackchannelRequestToken
139                  };
140              },
</span>141              async context =>
142              {
143                  await context.ChallengeAsync("Twitter");
144                  return true;
145              });
146              var transaction = await server.SendAsync("http:&bsol;&bsol;example.com/challenge");
147              Assert.Equal(HttpStatusCode.Redirect, transaction.Response.StatusCode);
148              var location = transaction.Response.Headers.Location.AbsoluteUri;
149              Assert.Contains("https:&bsol;&bsol;api.twitter.com/oauth/authenticate?oauth_token=", location);
150          }
151          [Fact]
152          public async Task HandleRequestAsync_RedirectsToAccessDeniedPathWhenExplicitlySet()
153          {
154              var server = CreateServer(o =>
155              {
156                  o.ConsumerKey = "Test Consumer Key";
157                  o.ConsumerSecret = "Test Consumer Secret";
158                  o.BackchannelHttpHandler = new TestHttpMessageHandler
159                  {
160                      Sender = BackchannelRequestToken
161                  };
162                  o.AccessDeniedPath = "/access-denied";
163                  o.Events.OnRemoteFailure = context => throw new InvalidOperationException("This event should not be called.");
164              },
165              async context =>
166              {
167                  var properties = new AuthenticationProperties();
168                  properties.Items["testkey"] = "testvalue";
169                  await context.ChallengeAsync("Twitter", properties);
170                  return true;
171              });
172              var transaction = await server.SendAsync("http:&bsol;&bsol;example.com/challenge");
173              Assert.Equal(HttpStatusCode.Redirect, transaction.Response.StatusCode);
174              var location = transaction.Response.Headers.Location.AbsoluteUri;
175              Assert.Contains("https:&bsol;&bsol;api.twitter.com/oauth/authenticate?oauth_token=", location);
176              Assert.True(transaction.Response.Headers.TryGetValues(HeaderNames.SetCookie, out var setCookie));
177              Assert.True(SetCookieHeaderValue.TryParseList(setCookie.ToList(), out var setCookieValues));
178              Assert.Single(setCookieValues);
179              var setCookieValue = setCookieValues.Single();
180              var cookie = new CookieHeaderValue(setCookieValue.Name, setCookieValue.Value);
181              var request = new HttpRequestMessage(HttpMethod.Get, "/signin-twitter?denied=ABCDEFG");
182              request.Headers.Add(HeaderNames.Cookie, cookie.ToString());
183              var client = server.CreateClient();
184              var response = await client.SendAsync(request);
185              Assert.Equal(HttpStatusCode.Redirect, response.StatusCode);
186              Assert.Equal("/access-denied?ReturnUrl=%2Fchallenge", response.Headers.Location.ToString());
187          }
188          [Fact]
189          public async Task BadCallbackCallsAccessDeniedWithState()
190          {
191              var server = CreateServer(o =>
192              {
193                  o.ConsumerKey = "Test Consumer Key";
194                  o.ConsumerSecret = "Test Consumer Secret";
195                  o.BackchannelHttpHandler = new TestHttpMessageHandler
196                  {
197                      Sender = BackchannelRequestToken
198                  };
199                  o.Events = new TwitterEvents()
200                  {
201                      OnAccessDenied = context =>
202                      {
203                          Assert.NotNull(context.Properties);
204                          Assert.Equal("testvalue", context.Properties.Items["testkey"]);
205                          context.Response.StatusCode = StatusCodes.Status406NotAcceptable;
206                          context.HandleResponse();
207                          return Task.CompletedTask;
208                      }
209                  };
210              },
211              async context =>
212              {
213                  var properties = new AuthenticationProperties();
214                  properties.Items["testkey"] = "testvalue";
215                  await context.ChallengeAsync("Twitter", properties);
216                  return true;
217              });
218              var transaction = await server.SendAsync("http:&bsol;&bsol;example.com/challenge");
219              Assert.Equal(HttpStatusCode.Redirect, transaction.Response.StatusCode);
220              var location = transaction.Response.Headers.Location.AbsoluteUri;
221              Assert.Contains("https:&bsol;&bsol;api.twitter.com/oauth/authenticate?oauth_token=", location);
222              Assert.True(transaction.Response.Headers.TryGetValues(HeaderNames.SetCookie, out var setCookie));
223              Assert.True(SetCookieHeaderValue.TryParseList(setCookie.ToList(), out var setCookieValues));
224              Assert.Single(setCookieValues);
225              var setCookieValue = setCookieValues.Single();
226              var cookie = new CookieHeaderValue(setCookieValue.Name, setCookieValue.Value);
227              var request = new HttpRequestMessage(HttpMethod.Get, "/signin-twitter?denied=ABCDEFG");
228              request.Headers.Add(HeaderNames.Cookie, cookie.ToString());
229              var client = server.CreateClient();
230              var response = await client.SendAsync(request);
231              Assert.Equal(HttpStatusCode.NotAcceptable, response.StatusCode);
232          }
233          [Fact]
234          public async Task BadCallbackCallsRemoteAuthFailedWithState()
235          {
236              var server = CreateServer(o =>
237              {
238                  o.ConsumerKey = "Test Consumer Key";
239                  o.ConsumerSecret = "Test Consumer Secret";
240                  o.BackchannelHttpHandler = new TestHttpMessageHandler
241                  {
242                      Sender = BackchannelRequestToken
243                  };
244                  o.Events = new TwitterEvents()
245                  {
246                      OnRemoteFailure = context =>
247                      {
248                          Assert.NotNull(context.Failure);
249                          Assert.Equal("Access was denied by the resource owner or by the remote server.", context.Failure.Message);
250                          Assert.NotNull(context.Properties);
251                          Assert.Equal("testvalue", context.Properties.Items["testkey"]);
252                          context.Response.StatusCode = StatusCodes.Status406NotAcceptable;
253                          context.HandleResponse();
254                          return Task.CompletedTask;
255                      }
256                  };
257              },
258              async context =>
259              {
260                  var properties = new AuthenticationProperties();
261                  properties.Items["testkey"] = "testvalue";
262                  await context.ChallengeAsync("Twitter", properties);
263                  return true;
264              });
265              var transaction = await server.SendAsync("http:&bsol;&bsol;example.com/challenge");
266              Assert.Equal(HttpStatusCode.Redirect, transaction.Response.StatusCode);
267              var location = transaction.Response.Headers.Location.AbsoluteUri;
268              Assert.Contains("https:&bsol;&bsol;api.twitter.com/oauth/authenticate?oauth_token=", location);
269              Assert.True(transaction.Response.Headers.TryGetValues(HeaderNames.SetCookie, out var setCookie));
270              Assert.True(SetCookieHeaderValue.TryParseList(setCookie.ToList(), out var setCookieValues));
271              Assert.Single(setCookieValues);
272              var setCookieValue = setCookieValues.Single();
273              var cookie = new CookieHeaderValue(setCookieValue.Name, setCookieValue.Value);
274              var request = new HttpRequestMessage(HttpMethod.Get, "/signin-twitter?denied=ABCDEFG");
275              request.Headers.Add(HeaderNames.Cookie, cookie.ToString());
276              var client = server.CreateClient();
277              var response = await client.SendAsync(request);
278              Assert.Equal(HttpStatusCode.NotAcceptable, response.StatusCode);
279          }
280          private static TestServer CreateServer(Action<TwitterOptions> options, Func<HttpContext, Task<bool>> handler = null)
281          {
282              var builder = new WebHostBuilder()
283                  .Configure(app =>
284                  {
285                      app.UseAuthentication();
286                      app.Use(async (context, next) =>
287                      {
288                          var req = context.Request;
289                          var res = context.Response;
290                          if (req.Path == new PathString("/signIn"))
291                          {
292                              await Assert.ThrowsAsync<InvalidOperationException>(() => context.SignInAsync("Twitter", new ClaimsPrincipal()));
293                          }
294                          else if (req.Path == new PathString("/signOut"))
295                          {
296                              await Assert.ThrowsAsync<InvalidOperationException>(() => context.SignOutAsync("Twitter"));
297                          }
298                          else if (req.Path == new PathString("/forbid"))
299                          {
300                              await Assert.ThrowsAsync<InvalidOperationException>(() => context.ForbidAsync("Twitter"));
301                          }
302                          else if (handler == null || ! await handler(context))
303                          {
304                              await next();
305                          }
306                      });
307                  })
308                  .ConfigureServices(services =>
309                  {
310                      Action<TwitterOptions> wrapOptions = o =>
311                      {
312                          o.SignInScheme = "External";
313                          options(o);
314                      };
315                      services.AddAuthentication()
316                          .AddCookie("External", _ => { })
317                          .AddTwitter(wrapOptions);
318                  });
319              return new TestServer(builder);
320          }
321          private HttpResponseMessage BackchannelRequestToken(HttpRequestMessage req)
322          {
323              if (req.RequestUri.AbsoluteUri == "https:&bsol;&bsol;api.twitter.com/oauth/request_token")
324              {
325                  return new HttpResponseMessage(HttpStatusCode.OK)
326                  {
327                      Content =
328                          new StringContent("oauth_callback_confirmed=true&oauth_token=test_oauth_token&oauth_token_secret=test_oauth_token_secret",
329                              Encoding.UTF8,
330                              "application/x-www-form-urlencoded")
331                  };
332              }
333              throw new NotImplementedException(req.RequestUri.AbsoluteUri);
334          }
335      }
336  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateConverter.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Linq;
5  using GitHub.DistributedTask.Expressions2;
6  using GitHub.DistributedTask.Expressions2.Sdk;
7  using GitHub.DistributedTask.Expressions2.Sdk.Functions;
8  using GitHub.DistributedTask.ObjectTemplating;
9  using GitHub.DistributedTask.ObjectTemplating.Tokens;
10  using GitHub.DistributedTask.Pipelines.ContextData;
11  using GitHub.DistributedTask.Pipelines.Validation;
12  using GitHub.Services.Common;
13  using Newtonsoft.Json.Linq;
14  namespace GitHub.DistributedTask.Pipelines.ObjectTemplating
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)]
17      public static class PipelineTemplateConverter
18      {
19          public static List<Step> ConvertToSteps(
20              TemplateContext context,
21              TemplateToken steps)
22          {
23              var stepsSequence = steps.AssertSequence($"job {PipelineTemplateConstants.Steps}");
24              var result = new List<Step>();
25              var nameBuilder = new ReferenceNameBuilder();
26              foreach (var stepsItem in stepsSequence)
27              {
28                  var step = ConvertToStep(context, stepsItem, nameBuilder);
29                  if (step != null) 
30                  {
31                      if (step.Enabled)
32                      {
33                          result.Add(step);
34                      }
35                  }
36              }
37              foreach (ActionStep step in result)
38              {
39                  if (!String.IsNullOrEmpty(step.ContextName))
40                  {
41                      continue;
42                  }
43                  var name = default(string);
44                  switch (step.Reference.Type)
45                  {
46                      case ActionSourceType.ContainerRegistry:
47                          var containerReference = step.Reference as ContainerRegistryReference;
48                          name = containerReference.Image;
49                          break;
50                      case ActionSourceType.Repository:
51                          var repositoryReference = step.Reference as RepositoryPathReference;
52                          name = !String.IsNullOrEmpty(repositoryReference.Name) ? repositoryReference.Name : PipelineConstants.SelfAlias;
53                          break;
54                  }
55                  if (String.IsNullOrEmpty(name))
56                  {
57                      name = "run";
58                  }
59                  nameBuilder.AppendSegment($"__{name}");
60                  step.ContextName = nameBuilder.Build();
61              }
62              return result;
63          }
64          internal static Boolean ConvertToIfResult(
65              TemplateContext context,
66              TemplateToken ifResult)
67          {
68              var expression = ifResult.Traverse().FirstOrDefault(x => x is ExpressionToken);
69              if (expression != null)
70              {
71                  throw new ArgumentException($"Unexpected type '{expression.GetType().Name}' encountered while reading 'if'.");
72              }
73              var evaluationResult = EvaluationResult.CreateIntermediateResult(null, ifResult);
74              return evaluationResult.IsTruthy;
75          }
76          internal static Boolean? ConvertToStepContinueOnError(
77              TemplateContext context,
78              TemplateToken token,
79              Boolean allowExpressions = false)
80          {
81              if (allowExpressions && token is ExpressionToken)
82              {
83                  return null;
84              }
85              var booleanToken = token.AssertBoolean($"step {PipelineTemplateConstants.ContinueOnError}");
86              return booleanToken.Value;
87          }
88          internal static String ConvertToStepDisplayName(
89              TemplateContext context,
90              TemplateToken token,
91              Boolean allowExpressions = false)
92          {
93              if (allowExpressions && token is ExpressionToken)
94              {
95                  return null;
96              }
97              var stringToken = token.AssertString($"step {PipelineTemplateConstants.Name}");
98              return stringToken.Value;
99          }
100          internal static Dictionary<String, String> ConvertToStepEnvironment(
101              TemplateContext context,
102              TemplateToken environment,
103              StringComparer keyComparer,
104              Boolean allowExpressions = false)
105          {
106              var result = new Dictionary<String, String>(keyComparer);
107              if (allowExpressions && environment is ExpressionToken)
108              {
109                  return result;
110              }
111              var mapping = environment.AssertMapping("environment");
112              foreach (var pair in mapping)
113              {
114                  if (allowExpressions && pair.Key is ExpressionToken)
115                  {
116                      continue;
117                  }
118                  var key = pair.Key.AssertString("environment key");
119                  if (allowExpressions && pair.Value is ExpressionToken)
120                  {
121                      continue;
122                  }
123                  var value = pair.Value.AssertString("environment value");
124                  result[key.Value] = value.Value;
125              }
126              return result;
127          }
128          internal static Dictionary<String, String> ConvertToStepInputs(
129              TemplateContext context,
130              TemplateToken inputs,
131              Boolean allowExpressions = false)
132          {
133              var result = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
134              if (allowExpressions && inputs is ExpressionToken)
135              {
136                  return result;
137              }
138              var mapping = inputs.AssertMapping("inputs");
139              foreach (var pair in mapping)
140              {
141                  if (allowExpressions && pair.Key is ExpressionToken)
142                  {
143                      continue;
144                  }
145                  var key = pair.Key.AssertString("inputs key");
146                  if (allowExpressions && pair.Value is ExpressionToken)
147                  {
148                      continue;
149                  }
150                  var value = pair.Value.AssertString("inputs value");
151                  result[key.Value] = value.Value;
152              }
153              return result;
154          }
155          internal static Int32? ConvertToStepTimeout(
156              TemplateContext context,
157              TemplateToken token,
158              Boolean allowExpressions = false)
159          {
160              if (allowExpressions && token is ExpressionToken)
161              {
162                  return null;
163              }
164              var numberToken = token.AssertNumber($"step {PipelineTemplateConstants.TimeoutMinutes}");
165              return (Int32)numberToken.Value;
166          }
167          internal static ContainerRegistryCredentials ConvertToContainerCredentials(TemplateToken token)
168          {
169              var credentials = token.AssertMapping(PipelineTemplateConstants.Credentials);
170              var result = new ContainerRegistryCredentials();
171              foreach (var credentialProperty in credentials)
172              {
173                  var propertyName = credentialProperty.Key.AssertString($"{PipelineTemplateConstants.Credentials} key");
174                  switch (propertyName.Value)
175                  {
176                      case PipelineTemplateConstants.Username:
177                          result.Username = credentialProperty.Value.AssertString(PipelineTemplateConstants.Username).Value;
178                          break;
179                      case PipelineTemplateConstants.Password:
180                          result.Password = credentialProperty.Value.AssertString(PipelineTemplateConstants.Password).Value;
181                          break;
182                      default:
183                          propertyName.AssertUnexpectedValue($"{PipelineTemplateConstants.Credentials} key {propertyName}");
184                          break;
185                  }
186              }
187              return result;
188          }
189          internal static JobContainer ConvertToJobContainer(
190              TemplateContext context,
191              TemplateToken value,
192              bool allowExpressions = false)
193          {
194              var result = new JobContainer();
195              if (allowExpressions && value.Traverse().Any(x => x is ExpressionToken))
196              {
197                  return result;
198              }
199              if (value is StringToken containerLiteral)
200              {
201                  if (String.IsNullOrEmpty(containerLiteral.Value))
202                  {
203                      return null;
204                  }
205                  result.Image = containerLiteral.Value;
206              }
207              else
208              {
209                  var containerMapping = value.AssertMapping($"{PipelineTemplateConstants.Container}");
210                  foreach (var containerPropertyPair in containerMapping)
211                  {
212                      var propertyName = containerPropertyPair.Key.AssertString($"{PipelineTemplateConstants.Container} key");
213                      switch (propertyName.Value)
214                      {
215                          case PipelineTemplateConstants.Image:
216                              result.Image = containerPropertyPair.Value.AssertString($"{PipelineTemplateConstants.Container} {propertyName}").Value;
217                              break;
218                          case PipelineTemplateConstants.Env:
219                              var env = containerPropertyPair.Value.AssertMapping($"{PipelineTemplateConstants.Container} {propertyName}");
220                              var envDict = new Dictionary<String, String>(env.Count);
221                              foreach (var envPair in env)
222                              {
223                                  var envKey = envPair.Key.ToString();
224                                  var envValue = envPair.Value.AssertString($"{PipelineTemplateConstants.Container} {propertyName} {envPair.Key.ToString()}").Value;
225                                  envDict.Add(envKey, envValue);
226                              }
227                              result.Environment = envDict;
228                              break;
229                          case PipelineTemplateConstants.Options:
230                              result.Options = containerPropertyPair.Value.AssertString($"{PipelineTemplateConstants.Container} {propertyName}").Value;
231                              break;
232                          case PipelineTemplateConstants.Ports:
233                              var ports = containerPropertyPair.Value.AssertSequence($"{PipelineTemplateConstants.Container} {propertyName}");
234                              var portList = new List<String>(ports.Count);
235                              foreach (var portItem in ports)
236                              {
237                                  var portString = portItem.AssertString($"{PipelineTemplateConstants.Container} {propertyName} {portItem.ToString()}").Value;
238                                  portList.Add(portString);
239                              }
240                              result.Ports = portList;
241                              break;
242                          case PipelineTemplateConstants.Volumes:
243                              var volumes = containerPropertyPair.Value.AssertSequence($"{PipelineTemplateConstants.Container} {propertyName}");
244                              var volumeList = new List<String>(volumes.Count);
245                              foreach (var volumeItem in volumes)
246                              {
247                                  var volumeString = volumeItem.AssertString($"{PipelineTemplateConstants.Container} {propertyName} {volumeItem.ToString()}").Value;
248                                  volumeList.Add(volumeString);
249                              }
250                              result.Volumes = volumeList;
251                              break;
252                          case PipelineTemplateConstants.Credentials:
253                              result.Credentials = ConvertToContainerCredentials(containerPropertyPair.Value);
254                              break;
255                          default:
256                              propertyName.AssertUnexpectedValue($"{PipelineTemplateConstants.Container} key");
257                              break;
258                      }
259                  }
260              }
261              if (result.Image.StartsWith("docker:&bsol;&bsol;", StringComparison.Ordinal))
262              {
263                  result.Image = result.Image.Substring("docker:&bsol;&bsol;".Length);
264              }
265              if (String.IsNullOrEmpty(result.Image))
266              {
267                  return null;
268              }
269              return result;
270          }
271          internal static List<KeyValuePair<String, JobContainer>> ConvertToJobServiceContainers(
272              TemplateContext context,
273              TemplateToken services,
274              bool allowExpressions = false)
275          {
276              var result = new List<KeyValuePair<String, JobContainer>>();
277              if (allowExpressions && services.Traverse().Any(x => x is ExpressionToken))
278              {
279                  return result;
280              }
281              var servicesMapping = services.AssertMapping("services");
282              foreach (var servicePair in servicesMapping)
283              {
284                  var networkAlias = servicePair.Key.AssertString("services key").Value;
285                  var container = ConvertToJobContainer(context, servicePair.Value);
286                  result.Add(new KeyValuePair<String, JobContainer>(networkAlias, container));
287              }
288              return result;
289          }
290          private static ActionStep ConvertToStep(
291              TemplateContext context,
292              TemplateToken stepsItem,
293              ReferenceNameBuilder nameBuilder)
294          {
295              var step = stepsItem.AssertMapping($"{PipelineTemplateConstants.Steps} item");
296              var continueOnError = default(ScalarToken);
297              var env = default(TemplateToken);
298              var id = default(StringToken);
299              var ifCondition = default(String);
300              var ifToken = default(ScalarToken);
301              var name = default(ScalarToken);
302              var run = default(ScalarToken);
303              var timeoutMinutes = default(ScalarToken);
304              var uses = default(StringToken);
305              var with = default(TemplateToken);
306              var workingDir = default(ScalarToken);
307              var path = default(ScalarToken);
308              var clean = default(ScalarToken);
309              var fetchDepth = default(ScalarToken);
310              var lfs = default(ScalarToken);
311              var submodules = default(ScalarToken);
312              var shell = default(ScalarToken);
313              foreach (var stepProperty in step)
314              {
315                  var propertyName = stepProperty.Key.AssertString($"{PipelineTemplateConstants.Steps} item key");
316                  switch (propertyName.Value)
317                  {
318                      case PipelineTemplateConstants.Clean:
319                          clean = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Clean}");
320                          break;
321                      case PipelineTemplateConstants.ContinueOnError:
322                          ConvertToStepContinueOnError(context, stepProperty.Value, allowExpressions: true); 
323                          continueOnError = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} {PipelineTemplateConstants.ContinueOnError}");
324                          break;
325                      case PipelineTemplateConstants.Env:
326                          ConvertToStepEnvironment(context, stepProperty.Value, StringComparer.Ordinal, allowExpressions: true); 
327                          env = stepProperty.Value;
328                          break;
329                      case PipelineTemplateConstants.FetchDepth:
330                          fetchDepth = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.FetchDepth}");
331                          break;
332                      case PipelineTemplateConstants.Id:
333                          id = stepProperty.Value.AssertString($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Id}");
334                          if (!String.IsNullOrEmpty(id.Value))
335                          {
336                              if (!nameBuilder.TryAddKnownName(id.Value, out var error))
337                              {
338                                  context.Error(id, error);
339                              }
340                          }
341                          break;
342                      case PipelineTemplateConstants.If:
343                          ifToken = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.If}");
344                          break;
345                      case PipelineTemplateConstants.Lfs:
346                          lfs = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Lfs}");
347                          break;
348                      case PipelineTemplateConstants.Name:
349                          name = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Name}");
350                          break;
351                      case PipelineTemplateConstants.Path:
352                          path = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Path}");
353                          break;
354                      case PipelineTemplateConstants.Run:
355                          run = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Run}");
356                          break;
357                      case PipelineTemplateConstants.Shell:
358                          shell = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Shell}");
359                          break;
360                      case PipelineTemplateConstants.Submodules:
361                          submodules = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Submodules}");
362                          break;
363                      case PipelineTemplateConstants.TimeoutMinutes:
364                          ConvertToStepTimeout(context, stepProperty.Value, allowExpressions: true); 
365                          timeoutMinutes = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.TimeoutMinutes}");
366                          break;
367                      case PipelineTemplateConstants.Uses:
368                          uses = stepProperty.Value.AssertString($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Uses}");
369                          break;
370                      case PipelineTemplateConstants.With:
371                          ConvertToStepInputs(context, stepProperty.Value, allowExpressions: true); 
372                          with = stepProperty.Value;
373                          break;
374                      case PipelineTemplateConstants.WorkingDirectory:
375                          workingDir = stepProperty.Value.AssertScalar($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.WorkingDirectory}");
376                          break;
377                      default:
378                          propertyName.AssertUnexpectedValue($"{PipelineTemplateConstants.Steps} item key"); 
379                          break;
380                  }
381              }
382              ifCondition = ConvertToIfCondition(context, ifToken, false);
383              if (run != null)
384              {
385                  var result = new ActionStep
386                  {
387                      ContextName = id?.Value,
388                      ContinueOnError = continueOnError,
389                      DisplayNameToken = name,
390                      Condition = ifCondition,
391                      TimeoutInMinutes = timeoutMinutes,
392                      Environment = env,
393                      Reference = new ScriptReference(),
394                  };
395                  var inputs = new MappingToken(null, null, null);
396                  inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.Script), run);
397                  if (workingDir != null)
398                  {
399                      inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.WorkingDirectory), workingDir);
400                  }
401                  if (shell != null)
402                  {
403                      inputs.Add(new StringToken(null, null, null, PipelineConstants.ScriptStepInputs.Shell), shell);
404                  }
405                  result.Inputs = inputs;
406                  return result;
407              }
408              else
409              {
410                  uses.AssertString($"{PipelineTemplateConstants.Steps} item {PipelineTemplateConstants.Uses}");
411                  var result = new ActionStep
412                  {
413                      ContextName = id?.Value,
414                      ContinueOnError = continueOnError,
415                      DisplayNameToken = name,
416                      Condition = ifCondition,
417                      TimeoutInMinutes = timeoutMinutes,
418                      Inputs = with,
419                      Environment = env,
420                  };
421                  if (uses.Value.StartsWith("docker:&bsol;&bsol;", StringComparison.Ordinal))
422                  {
423                      var image = uses.Value.Substring("docker:&bsol;&bsol;".Length);
<span onclick='openModal()' class='match'>424                      result.Reference = new ContainerRegistryReference { Image = image };
425                  }
</span>426                  else if (uses.Value.StartsWith("./") || uses.Value.StartsWith(".\\"))
427                  {
428                      result.Reference = new RepositoryPathReference
429                      {
430                          RepositoryType = PipelineConstants.SelfAlias,
431                          Path = uses.Value
432                      };
433                  }
434                  else
435                  {
436                      var usesSegments = uses.Value.Split('@');
437                      var pathSegments = usesSegments[0].Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
438                      var gitRef = usesSegments.Length == 2 ? usesSegments[1] : String.Empty;
439                      if (usesSegments.Length != 2 ||
440                          pathSegments.Length < 2 ||
441                          String.IsNullOrEmpty(pathSegments[0]) ||
442                          String.IsNullOrEmpty(pathSegments[1]) ||
443                          String.IsNullOrEmpty(gitRef))
444                      {
445                          context.Error(uses, $"Expected format {{org}}/{{repo}}[/path]@ref. Actual '{uses.Value}'");
446                      }
447                      else
448                      {
449                          var repositoryName = $"{pathSegments[0]}/{pathSegments[1]}";
450                          var directoryPath = pathSegments.Length > 2 ? String.Join("/", pathSegments.Skip(2)) : String.Empty;
451                          result.Reference = new RepositoryPathReference
452                          {
453                              RepositoryType = RepositoryTypes.GitHub,
454                              Name = repositoryName,
455                              Ref = gitRef,
456                              Path = directoryPath,
457                          };
458                      }
459                  }
460                  return result;
461              }
462          }
463          private static String ConvertToIfCondition(
464              TemplateContext context,
465              TemplateToken token,
466              Boolean isJob)
467          {
468              String condition;
469              if (token is null)
470              {
471                  condition = null;
472              }
473              else if (token is BasicExpressionToken expressionToken)
474              {
475                  condition = expressionToken.Expression;
476              }
477              else
478              {
479                  var stringToken = token.AssertString($"{(isJob ? "job" : "step")} {PipelineTemplateConstants.If}");
480                  condition = stringToken.Value;
481              }
482              if (String.IsNullOrWhiteSpace(condition))
483              {
484                  return $"{PipelineTemplateConstants.Success}()";
485              }
486              var expressionParser = new ExpressionParser();
487              var functions = default(IFunctionInfo[]);
488              var namedValues = default(INamedValueInfo[]);
489              if (isJob)
490              {
491                  namedValues = s_jobIfNamedValues;
492              }
493              else
494              {
495                  namedValues = s_stepNamedValues;
496                  functions = s_stepConditionFunctions;
497              }
498              var node = default(ExpressionNode);
499              try
500              {
501                  node = expressionParser.CreateTree(condition, null, namedValues, functions) as ExpressionNode;
502              }
503              catch (Exception ex)
504              {
505                  context.Error(token, ex);
506                  return null;
507              }
508              if (node == null)
509              {
510                  return $"{PipelineTemplateConstants.Success}()";
511              }
512              var hasStatusFunction = node.Traverse().Any(x =>
513              {
514                  if (x is Function function)
515                  {
516                      return String.Equals(function.Name, PipelineTemplateConstants.Always, StringComparison.OrdinalIgnoreCase) ||
517                          String.Equals(function.Name, PipelineTemplateConstants.Cancelled, StringComparison.OrdinalIgnoreCase) ||
518                          String.Equals(function.Name, PipelineTemplateConstants.Failure, StringComparison.OrdinalIgnoreCase) ||
519                          String.Equals(function.Name, PipelineTemplateConstants.Success, StringComparison.OrdinalIgnoreCase);
520                  }
521                  return false;
522              });
523              return hasStatusFunction ? condition : $"{PipelineTemplateConstants.Success}() && ({condition})";
524          }
525          private static readonly INamedValueInfo[] s_jobIfNamedValues = new INamedValueInfo[]
526          {
527              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.GitHub),
528              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Needs),
529              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Vars),
530          };
531          private static readonly INamedValueInfo[] s_stepNamedValues = new INamedValueInfo[]
532          {
533              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Strategy),
534              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Matrix),
535              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Steps),
536              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.GitHub),
537              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Inputs),
538              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Job),
539              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Runner),
540              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Env),
541              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Needs),
542              new NamedValueInfo<NoOperationNamedValue>(PipelineTemplateConstants.Vars),
543          };
544          private static readonly IFunctionInfo[] s_stepConditionFunctions = new IFunctionInfo[]
545          {
546              new FunctionInfo<NoOperation>(PipelineTemplateConstants.Always, 0, 0),
547              new FunctionInfo<NoOperation>(PipelineTemplateConstants.Cancelled, 0, 0),
548              new FunctionInfo<NoOperation>(PipelineTemplateConstants.Failure, 0, 0),
549              new FunctionInfo<NoOperation>(PipelineTemplateConstants.Success, 0, 0),
550              new FunctionInfo<NoOperation>(PipelineTemplateConstants.HashFiles, 1, Byte.MaxValue),
551          };
552      }
553  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-TwitterTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateConverter.cs</div>
                </div>
                <div class="column column_space"><pre><code>136                  o.BackchannelHttpHandler = new TestHttpMessageHandler
137                  {
138                      Sender = BackchannelRequestToken
139                  };
140              },
</pre></code></div>
                <div class="column column_space"><pre><code>424                      result.Reference = new ContainerRegistryReference { Image = image };
425                  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    