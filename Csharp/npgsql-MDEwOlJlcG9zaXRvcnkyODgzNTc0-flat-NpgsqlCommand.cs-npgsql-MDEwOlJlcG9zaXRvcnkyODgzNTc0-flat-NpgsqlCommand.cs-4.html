
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlCommand.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Data;
5  using System.Data.Common;
6  using System.Diagnostics;
7  using System.Linq;
8  using System.Runtime.CompilerServices;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using Npgsql.BackendMessages;
13  using Npgsql.Util;
14  using NpgsqlTypes;
15  using static Npgsql.Util.Statics;
16  using System.Diagnostics.CodeAnalysis;
17  using System.Threading.Channels;
18  using Microsoft.Extensions.Logging;
19  using Npgsql.Internal;
20  using Npgsql.Properties;
21  namespace Npgsql;
22  [System.ComponentModel.DesignerCategory(&quot;&quot;)]
23  public class NpgsqlCommand : DbCommand, ICloneable, IComponent
24  {
25      #region Fields
26      NpgsqlTransaction? _transaction;
27      readonly NpgsqlConnector? _connector;
28      NpgsqlConnector? _connectorPreparedOn;
29      string _commandText;
30      CommandBehavior _behavior;
31      int? _timeout;
32      readonly NpgsqlParameterCollection _parameters;
33      internal bool IsWrappedByBatch { get; }
34      internal List&lt;NpgsqlBatchCommand&gt; InternalBatchCommands { get; }
35      Activity? CurrentActivity;
36      [Obsolete(&quot;Use the new DbBatch API&quot;)]
37      public IReadOnlyList&lt;NpgsqlBatchCommand&gt; Statements =&gt; InternalBatchCommands.AsReadOnly();
38      UpdateRowSource _updateRowSource = UpdateRowSource.Both;
39      bool IsExplicitlyPrepared =&gt; _connectorPreparedOn != null;
40      internal bool IsCacheable { get; set; }
41  #if DEBUG
42      internal static bool EnableSqlRewriting;
43      internal static bool EnableStoredProcedureCompatMode;
44  #else
45      internal static readonly bool EnableSqlRewriting;
46      internal static readonly bool EnableStoredProcedureCompatMode;
47  #endif
48      internal bool EnableErrorBarriers { get; set; }
49      static readonly List&lt;NpgsqlParameter&gt; EmptyParameters = new();
50      static readonly SingleThreadSynchronizationContext SingleThreadSynchronizationContext = new(&quot;NpgsqlRemainingAsyncSendWorker&quot;);
51      #endregion Fields
52      #region Constants
53      internal const int DefaultTimeout = 30;
54      #endregion
55      #region Constructors
56      static NpgsqlCommand()
57      {
58          EnableSqlRewriting = !AppContext.TryGetSwitch(&quot;Npgsql.EnableSqlRewriting&quot;, out var enabled) || enabled;
59          EnableStoredProcedureCompatMode = AppContext.TryGetSwitch(&quot;Npgsql.EnableStoredProcedureCompatMode&quot;, out enabled) &amp;&amp; enabled;
60      }
61      public NpgsqlCommand() : this(null, null, null) {}
62      public NpgsqlCommand(string? cmdText) : this(cmdText, null, null) {}
63      public NpgsqlCommand(string? cmdText, NpgsqlConnection? connection)
64      {
65          GC.SuppressFinalize(this);
66          InternalBatchCommands = new List&lt;NpgsqlBatchCommand&gt;(1);
67          _parameters = new NpgsqlParameterCollection();
68          _commandText = cmdText ?? string.Empty;
69          InternalConnection = connection;
70          CommandType = CommandType.Text;
71      }
72      public NpgsqlCommand(string? cmdText, NpgsqlConnection? connection, NpgsqlTransaction? transaction)
73          : this(cmdText, connection)
74          =&gt; Transaction = transaction;
75      internal NpgsqlCommand(int batchCommandCapacity, NpgsqlConnection? connection = null)
76      {
77          GC.SuppressFinalize(this);
78          InternalBatchCommands = new List&lt;NpgsqlBatchCommand&gt;(batchCommandCapacity);
79          InternalConnection = connection;
80          CommandType = CommandType.Text;
81          IsWrappedByBatch = true;
82          _commandText = null!;
83          _parameters = null!;
84      }
85      internal NpgsqlCommand(string? cmdText, NpgsqlConnector connector) : this(cmdText)
86          =&gt; _connector = connector;
87      internal NpgsqlCommand(NpgsqlConnector connector, int batchCommandCapacity)
88          : this(batchCommandCapacity)
89          =&gt; _connector = connector;
90      internal static NpgsqlCommand CreateCachedCommand(NpgsqlConnection connection)
91          =&gt; new(null, connection) { IsCacheable = true };
92      #endregion Constructors
93      #region Public properties
94      [AllowNull, DefaultValue(&quot;&quot;)]
95      [Category(&quot;Data&quot;)]
96      public override string CommandText
97      {
98          get =&gt; _commandText;
99          set
100          {
101              Debug.Assert(!IsWrappedByBatch);
102              if (State != CommandState.Idle)
103                  ThrowHelper.ThrowInvalidOperationException(&quot;An open data reader exists for this command.&quot;);
104              _commandText = value ?? string.Empty;
105              ResetPreparation();
106          }
107      }
108      [DefaultValue(DefaultTimeout)]
109      public override int CommandTimeout
110      {
111          get =&gt; _timeout ?? (InternalConnection?.CommandTimeout ?? DefaultTimeout);
112          set
113          {
114              if (value &lt; 0) {
115                  throw new ArgumentOutOfRangeException(nameof(value), value, &quot;CommandTimeout can&#x27;t be less than zero.&quot;);
116              }
117              _timeout = value;
118          }
119      }
120      [DefaultValue(CommandType.Text)]
121      [Category(&quot;Data&quot;)]
122      public override CommandType CommandType { get; set; }
123      internal NpgsqlConnection? InternalConnection { get; private set; }
124      protected override DbConnection? DbConnection
125      {
126          get =&gt; InternalConnection;
127          set
128          {
129              if (InternalConnection == value)
130                  return;
131              InternalConnection = State == CommandState.Idle
132                  ? (NpgsqlConnection?)value
133                  : throw new InvalidOperationException(&quot;An open data reader exists for this command.&quot;);
134              Transaction = null;
135          }
136      }
137      [DefaultValue(null)]
138      [Category(&quot;Behavior&quot;)]
139      public new NpgsqlConnection? Connection
140      {
141          get =&gt; (NpgsqlConnection?)DbConnection;
142          set =&gt; DbConnection = value;
143      }
144      public override bool DesignTimeVisible { get; set; }
145      [Category(&quot;Behavior&quot;), DefaultValue(UpdateRowSource.Both)]
146      public override UpdateRowSource UpdatedRowSource
147      {
148          get =&gt; _updateRowSource;
149          set
150          {
151              switch (value)
152              {
153              case UpdateRowSource.None:
154              case UpdateRowSource.OutputParameters:
155              case UpdateRowSource.FirstReturnedRecord:
156              case UpdateRowSource.Both:
157                  _updateRowSource = value;
158                  break;
159              default:
160                  throw new ArgumentOutOfRangeException();
161              }
162          }
163      }
164      public bool IsPrepared =&gt;
165          _connectorPreparedOn == (InternalConnection?.Connector ?? _connector) &amp;&amp;
166          InternalBatchCommands.Any() &amp;&amp; InternalBatchCommands.All(s =&gt; s.PreparedStatement?.IsPrepared == true);
167      #endregion Public properties
168      #region Known/unknown Result Types Management
169      public bool AllResultTypesAreUnknown
170      {
171          get =&gt; _allResultTypesAreUnknown;
172          set
173          {
174              _unknownResultTypeList = null;
175              _allResultTypesAreUnknown = value;
176          }
177      }
178      bool _allResultTypesAreUnknown;
179      public bool[]? UnknownResultTypeList
180      {
181          get =&gt; _unknownResultTypeList;
182          set
183          {
184              _allResultTypesAreUnknown = false;
185              _unknownResultTypeList = value;
186          }
187      }
188      bool[]? _unknownResultTypeList;
189      #endregion
190      #region Result Types Management
191      internal Type[]? ObjectResultTypes { get; set; }
192      #endregion
193      #region State management
194      volatile int _state;
195      internal CommandState State
196      {
197          get =&gt; (CommandState)_state;
198          set
199          {
200              var newState = (int)value;
201              if (newState == _state)
202                  return;
203              _state = newState;
204          }
205      }
206      internal void ResetPreparation() =&gt; _connectorPreparedOn = null;
207      #endregion State management
208      #region Parameters
209      protected override DbParameter CreateDbParameter() =&gt; CreateParameter();
210      public new NpgsqlParameter CreateParameter() =&gt; new();
211      protected override DbParameterCollection DbParameterCollection =&gt; Parameters;
212      public new NpgsqlParameterCollection Parameters =&gt; _parameters;
213      #endregion
214      #region DeriveParameters
215      const string DeriveParametersForFunctionQuery = @&quot;
216  SELECT
217  CASE
218  	WHEN pg_proc.proargnames IS NULL THEN array_cat(array_fill(&#x27;&#x27;::name,ARRAY[pg_proc.pronargs]),array_agg(pg_attribute.attname ORDER BY pg_attribute.attnum))
219  	ELSE pg_proc.proargnames
220  END AS proargnames,
221  pg_proc.proargtypes,
222  CASE
223  	WHEN pg_proc.proallargtypes IS NULL AND (array_agg(pg_attribute.atttypid))[1] IS NOT NULL THEN array_cat(string_to_array(pg_proc.proargtypes::text,&#x27; &#x27;)::oid[],array_agg(pg_attribute.atttypid ORDER BY pg_attribute.attnum))
224  	ELSE pg_proc.proallargtypes
225  END AS proallargtypes,
226  CASE
227  	WHEN pg_proc.proargmodes IS NULL AND (array_agg(pg_attribute.atttypid))[1] IS NOT NULL THEN array_cat(array_fill(&#x27;i&#x27;::&quot;&quot;char&quot;&quot;,ARRAY[pg_proc.pronargs]),array_fill(&#x27;o&#x27;::&quot;&quot;char&quot;&quot;,ARRAY[array_length(array_agg(pg_attribute.atttypid), 1)]))
228      ELSE pg_proc.proargmodes
229  END AS proargmodes
230  FROM pg_proc
231  LEFT JOIN pg_type ON pg_proc.prorettype = pg_type.oid
232  LEFT JOIN pg_attribute ON pg_type.typrelid = pg_attribute.attrelid AND pg_attribute.attnum &gt;= 1 AND NOT pg_attribute.attisdropped
233  WHERE pg_proc.oid = :proname::regproc
234  GROUP BY pg_proc.proargnames, pg_proc.proargtypes, pg_proc.proallargtypes, pg_proc.proargmodes, pg_proc.pronargs;
235  &quot;;
236      internal void DeriveParameters()
237      {
238          var conn = CheckAndGetConnection();
239          Debug.Assert(conn is not null);
240          if (string.IsNullOrEmpty(CommandText))
241              throw new InvalidOperationException(&quot;CommandText property has not been initialized&quot;);
242          using var _ = conn.StartTemporaryBindingScope(out var connector);
243          if (InternalBatchCommands.Any(s =&gt; s.PreparedStatement?.IsExplicit == true))
244              throw new NpgsqlException(&quot;Deriving parameters isn&#x27;t supported for commands that are already prepared.&quot;);
245          Unprepare();
246          Parameters.Clear();
247          switch (CommandType)
248          {
249          case CommandType.Text:
250              DeriveParametersForQuery(connector);
251              break;
252          case CommandType.StoredProcedure:
253              DeriveParametersForFunction();
254              break;
255          default:
256              throw new NotSupportedException(&quot;Cannot derive parameters for CommandType &quot; + CommandType);
257          }
258      }
259      void DeriveParametersForFunction()
260      {
261          using var c = new NpgsqlCommand(DeriveParametersForFunctionQuery, InternalConnection);
262          c.Parameters.Add(new NpgsqlParameter(&quot;proname&quot;, NpgsqlDbType.Text));
263          c.Parameters[0].Value = CommandText;
264          string[]? names = null;
265          uint[]? types = null;
266          char[]? modes = null;
267          using (var rdr = c.ExecuteReader(CommandBehavior.SingleRow | CommandBehavior.SingleResult))
268          {
269              if (rdr.Read())
270              {
271                  if (!rdr.IsDBNull(0))
272                      names = rdr.GetFieldValue&lt;string[]&gt;(0);
273                  if (!rdr.IsDBNull(2))
274                      types = rdr.GetFieldValue&lt;uint[]&gt;(2);
275                  if (!rdr.IsDBNull(3))
276                      modes = rdr.GetFieldValue&lt;char[]&gt;(3);
277                  if (types == null)
278                  {
279                      if (rdr.IsDBNull(1) || rdr.GetFieldValue&lt;uint[]&gt;(1).Length == 0)
280                          return;  
281                      types = rdr.GetFieldValue&lt;uint[]&gt;(1);
282                  }
283              }
284              else
285                  throw new InvalidOperationException($&quot;{CommandText} does not exist in pg_proc&quot;);
286          }
287          var typeMapper = c.InternalConnection!.Connector!.TypeMapper;
288          for (var i = 0; i &lt; types.Length; i++)
289          {
290              var param = new NpgsqlParameter();
291              var (npgsqlDbType, postgresType) = typeMapper.GetTypeInfoByOid(types[i]);
292              param.DataTypeName = postgresType.DisplayName;
293              param.PostgresType = postgresType;
294              if (npgsqlDbType.HasValue)
295                  param.NpgsqlDbType = npgsqlDbType.Value;
296              if (names != null &amp;&amp; i &lt; names.Length)
297                  param.ParameterName = names[i];
298              else
299                  param.ParameterName = &quot;parameter&quot; + (i + 1);
300              if (modes == null) 
301                  param.Direction = ParameterDirection.Input;
302              else
303              {
304                  param.Direction = modes[i] switch
305                  {
306                      &#x27;i&#x27; =&gt; ParameterDirection.Input,
307                      &#x27;o&#x27; =&gt; ParameterDirection.Output,
308                      &#x27;t&#x27; =&gt; ParameterDirection.Output,
309                      &#x27;b&#x27; =&gt; ParameterDirection.InputOutput,
310                      &#x27;v&#x27; =&gt; throw new NotSupportedException(&quot;Cannot derive function parameter of type VARIADIC&quot;),
311                      _ =&gt; throw new ArgumentOutOfRangeException(&quot;Unknown code in proargmodes while deriving: &quot; + modes[i])
312                  };
313              }
314              Parameters.Add(param);
315          }
316      }
317      void DeriveParametersForQuery(NpgsqlConnector connector)
318      {
319          using (connector.StartUserAction())
320          {
321              LogMessages.DerivingParameters(connector.CommandLogger, CommandText, connector.Id);
322              if (IsWrappedByBatch)
323                  foreach (var batchCommand in InternalBatchCommands)
324                      connector.SqlQueryParser.ParseRawQuery(batchCommand, connector.UseConformingStrings, deriveParameters: true);
325              else
326                  connector.SqlQueryParser.ParseRawQuery(this, connector.UseConformingStrings, deriveParameters: true);
327              var sendTask = SendDeriveParameters(connector, false);
328              if (sendTask.IsFaulted)
329                  sendTask.GetAwaiter().GetResult();
330              foreach (var batchCommand in InternalBatchCommands)
331              {
332                  Expect&lt;ParseCompleteMessage&gt;(
333                      connector.ReadMessage(async: false).GetAwaiter().GetResult(), connector);
334                  var paramTypeOIDs = Expect&lt;ParameterDescriptionMessage&gt;(
335                      connector.ReadMessage(async: false).GetAwaiter().GetResult(), connector).TypeOIDs;
336                  if (batchCommand.PositionalParameters.Count != paramTypeOIDs.Count)
337                  {
338                      connector.SkipUntil(BackendMessageCode.ReadyForQuery);
339                      Parameters.Clear();
340                      throw new NpgsqlException(&quot;There was a mismatch in the number of derived parameters between the Npgsql SQL parser and the PostgreSQL parser. Please report this as bug to the Npgsql developers (https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues).&quot;);
341                  }
342                  for (var i = 0; i &lt; paramTypeOIDs.Count; i++)
343                  {
344                      try
345                      {
346                          var param = batchCommand.PositionalParameters[i];
347                          var paramOid = paramTypeOIDs[i];
348                          var (npgsqlDbType, postgresType) = connector.TypeMapper.GetTypeInfoByOid(paramOid);
349                          if (param.NpgsqlDbType != NpgsqlDbType.Unknown &amp;&amp; param.NpgsqlDbType != npgsqlDbType)
350                              throw new NpgsqlException(&quot;The backend parser inferred different types for parameters with the same name. Please try explicit casting within your SQL statement or batch or use different placeholder names.&quot;);
351                          param.DataTypeName = postgresType.DisplayName;
352                          param.PostgresType = postgresType;
353                          if (npgsqlDbType.HasValue)
354                              param.NpgsqlDbType = npgsqlDbType.Value;
355                      }
356                      catch
357                      {
358                          connector.SkipUntil(BackendMessageCode.ReadyForQuery);
359                          Parameters.Clear();
360                          throw;
361                      }
362                  }
363                  var msg = connector.ReadMessage(async: false).GetAwaiter().GetResult();
364                  switch (msg.Code)
365                  {
366                  case BackendMessageCode.RowDescription:
367                  case BackendMessageCode.NoData:
368                      break;
369                  default:
370                      throw connector.UnexpectedMessageReceived(msg.Code);
371                  }
372              }
373              Expect&lt;ReadyForQueryMessage&gt;(connector.ReadMessage(async: false).GetAwaiter().GetResult(), connector);
374              sendTask.GetAwaiter().GetResult();
375          }
376      }
377      #endregion
378      #region Prepare
379      public override void Prepare() =&gt; Prepare(false).GetAwaiter().GetResult();
380  #if NETSTANDARD2_0
381      public virtual Task PrepareAsync(CancellationToken cancellationToken = default)
382  #else
383      public override Task PrepareAsync(CancellationToken cancellationToken = default)
384  #endif
385      {
386          using (NoSynchronizationContextScope.Enter())
387              return Prepare(true, cancellationToken);
388      }
389      Task Prepare(bool async, CancellationToken cancellationToken = default)
390      {
391          var connection = CheckAndGetConnection();
392          Debug.Assert(connection is not null);
393          if (connection.Settings.Multiplexing)
394              throw new NotSupportedException(&quot;Explicit preparation not supported with multiplexing&quot;);
395          var connector = connection.Connector!;
396          var logger = connector.CommandLogger;
397          var needToPrepare = false;
398          if (IsWrappedByBatch)
399          {
400              foreach (var batchCommand in InternalBatchCommands)
401              {
402                  batchCommand.Parameters.ProcessParameters(connector.TypeMapper, validateValues: false, CommandType);
403                  ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand);
404                  needToPrepare = batchCommand.ExplicitPrepare(connector) || needToPrepare;
405              }
406              if (logger.IsEnabled(LogLevel.Debug) &amp;&amp; needToPrepare)
407                  LogMessages.PreparingCommandExplicitly(logger, string.Join(&quot;; &quot;, InternalBatchCommands.Select(c =&gt; c.CommandText)), connector.Id);
408          }
409          else
410          {
411              Parameters.ProcessParameters(connector.TypeMapper, validateValues: false, CommandType);
412              ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand: null);
413              foreach (var batchCommand in InternalBatchCommands)
414                  needToPrepare = batchCommand.ExplicitPrepare(connector) || needToPrepare;
415              if (logger.IsEnabled(LogLevel.Debug) &amp;&amp; needToPrepare)
416                  LogMessages.PreparingCommandExplicitly(logger, CommandText, connector.Id);
417          }
418          _connectorPreparedOn = connector;
419          return needToPrepare
420              ? PrepareLong(this, async, connector, cancellationToken)
421              : Task.CompletedTask;
422          static async Task PrepareLong(NpgsqlCommand command, bool async, NpgsqlConnector connector, CancellationToken cancellationToken)
423          {
424              try
425              {
426                  using (connector.StartUserAction(cancellationToken))
427                  {
428                      var sendTask = command.SendPrepare(connector, async, CancellationToken.None);
429                      if (sendTask.IsFaulted)
430                          sendTask.GetAwaiter().GetResult();
431                      var isFirst = true;
432                      foreach (var batchCommand in command.InternalBatchCommands)
433                      {
434                          if (!batchCommand.IsPreparing)
435                              continue;
436                          var pStatement = batchCommand.PreparedStatement!;
437                          if (pStatement.StatementBeingReplaced != null)
438                          {
439                              Expect&lt;CloseCompletedMessage&gt;(await connector.ReadMessage(async), connector);
440                              pStatement.StatementBeingReplaced.CompleteUnprepare();
441                              pStatement.StatementBeingReplaced = null;
442                          }
443                          Expect&lt;ParseCompleteMessage&gt;(await connector.ReadMessage(async), connector);
444                          Expect&lt;ParameterDescriptionMessage&gt;(await connector.ReadMessage(async), connector);
445                          var msg = await connector.ReadMessage(async);
446                          switch (msg.Code)
447                          {
448                          case BackendMessageCode.RowDescription:
449                              var description = ((RowDescriptionMessage)msg).Clone();
450                              command.FixupRowDescription(description, isFirst);
451                              batchCommand.Description = description;
452                              break;
453                          case BackendMessageCode.NoData:
454                              batchCommand.Description = null;
455                              break;
456                          default:
457                              throw connector.UnexpectedMessageReceived(msg.Code);
458                          }
459                          pStatement.State = PreparedState.Prepared;
460                          connector.PreparedStatementManager.NumPrepared++;
461                          batchCommand.IsPreparing = false;
462                          isFirst = false;
463                      }
464                      Expect&lt;ReadyForQueryMessage&gt;(await connector.ReadMessage(async), connector);
465                      if (async)
466                          await sendTask;
467                      else
468                          sendTask.GetAwaiter().GetResult();
469                  }
470                  LogMessages.CommandPreparedExplicitly(connector.CommandLogger, connector.Id);
471              }
472              catch
473              {
474                  foreach (var batchCommand in command.InternalBatchCommands)
475                  {
476                      if (batchCommand.IsPreparing)
477                      {
478                          batchCommand.IsPreparing = false;
479                          batchCommand.PreparedStatement!.AbortPrepare();
480                      }
481                  }
482                  throw;
483              }
484          }
485      }
486      public void Unprepare()
487          =&gt; Unprepare(false).GetAwaiter().GetResult();
488      public Task UnprepareAsync(CancellationToken cancellationToken = default)
489      {
490          using (NoSynchronizationContextScope.Enter())
491              return Unprepare(true, cancellationToken);
492      }
493      async Task Unprepare(bool async, CancellationToken cancellationToken = default)
494      {
495          var connection = CheckAndGetConnection();
496          Debug.Assert(connection is not null);
497          if (connection.Settings.Multiplexing)
498              throw new NotSupportedException(&quot;Explicit preparation not supported with multiplexing&quot;);
499          if (InternalBatchCommands.All(s =&gt; !s.IsPrepared))
500              return;
501          var connector = connection.Connector!;
502          LogMessages.UnpreparingCommand(connector.CommandLogger, connector.Id);
503          using (connector.StartUserAction(cancellationToken))
504          {
505              var sendTask = SendClose(connector, async, cancellationToken);
506              if (sendTask.IsFaulted)
507                  sendTask.GetAwaiter().GetResult();
508              foreach (var batchCommand in InternalBatchCommands)
509              {
510                  if (batchCommand.PreparedStatement?.State == PreparedState.BeingUnprepared)
511                  {
512                      Expect&lt;CloseCompletedMessage&gt;(await connector.ReadMessage(async), connector);
513                      var pStatement = batchCommand.PreparedStatement;
514                      pStatement.CompleteUnprepare();
515                      if (!pStatement.IsExplicit)
516                          connector.PreparedStatementManager.AutoPrepared[pStatement.AutoPreparedSlotIndex] = null;
517                      batchCommand.PreparedStatement = null;
518                  }
519              }
520              Expect&lt;ReadyForQueryMessage&gt;(await connector.ReadMessage(async), connector);
521              if (async)
522                  await sendTask;
523              else
524                  sendTask.GetAwaiter().GetResult();
525          }
526      }
527      #endregion Prepare
528      #region Query analysis
529      internal void ProcessRawQuery(SqlQueryParser? parser, bool standardConformingStrings, NpgsqlBatchCommand? batchCommand)
530      {
531          var (commandText, commandType, parameters) = batchCommand is null
532              ? (CommandText, CommandType, Parameters)
533              : (batchCommand.CommandText, batchCommand.CommandType, batchCommand.Parameters);
534          if (string.IsNullOrEmpty(commandText))
535              ThrowHelper.ThrowInvalidOperationException(&quot;CommandText property has not been initialized&quot;);
536          switch (commandType)
537          {
538          case CommandType.Text:
539              switch (parameters.PlaceholderType)
540              {
541              case PlaceholderType.Positional:
542                  if (batchCommand is null)
543                  {
544                      batchCommand = TruncateStatementsToOne();
545                      batchCommand.FinalCommandText = CommandText;
546                      batchCommand.PositionalParameters = Parameters.InternalList;
547                  }
548                  else
549                  {
550                      batchCommand.FinalCommandText = batchCommand.CommandText;
551                      batchCommand.PositionalParameters = batchCommand.Parameters.InternalList;
552                  }
553                  ValidateParameterCount(batchCommand);
554                  break;
555              case PlaceholderType.NoParameters:
556                  if (EnableSqlRewriting)
557                      goto case PlaceholderType.Named;
558                  goto case PlaceholderType.Positional;
559              case PlaceholderType.Named:
560                  if (!EnableSqlRewriting)
561                      ThrowHelper.ThrowNotSupportedException($&quot;Named parameters are not supported when Npgsql.{nameof(EnableSqlRewriting)} is disabled&quot;);
562                  parser ??= new SqlQueryParser();
563                  if (batchCommand is null)
564                  {
565                      parser.ParseRawQuery(this, standardConformingStrings);
566                      if (InternalBatchCommands.Count &gt; 1 &amp;&amp; _parameters.HasOutputParameters)
567                          ThrowHelper.ThrowNotSupportedException(&quot;Commands with multiple queries cannot have out parameters&quot;);
568                      for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
569                          ValidateParameterCount(InternalBatchCommands[i]);
570                  }
571                  else
572                  {
573                      parser.ParseRawQuery(batchCommand, standardConformingStrings);
574                      if (batchCommand.Parameters.HasOutputParameters)
575                          ThrowHelper.ThrowNotSupportedException(&quot;Batches cannot cannot have out parameters&quot;);
576                      ValidateParameterCount(batchCommand);
577                  }
578                  break;
579              case PlaceholderType.Mixed:
580                  ThrowHelper.ThrowNotSupportedException(&quot;Mixing named and positional parameters isn&#x27;t supported&quot;);
581                  break;
582              default:
583                  ThrowHelper.ThrowArgumentOutOfRangeException(nameof(PlaceholderType), $&quot;Unknown {nameof(PlaceholderType)} value: {{0}}&quot;, Parameters.PlaceholderType);
584                  break;
585              }
586              break;
587          case CommandType.TableDirect:
588              batchCommand ??= TruncateStatementsToOne();
589              batchCommand.FinalCommandText = &quot;SELECT * FROM &quot; + CommandText;
590              break;
591          case CommandType.StoredProcedure:
592              var sqlBuilder = new StringBuilder()
593                  .Append(EnableStoredProcedureCompatMode ? &quot;SELECT * FROM &quot; : &quot;CALL &quot;)
594                  .Append(CommandText)
595                  .Append(&#x27;(&#x27;);
596              var isFirstParam = true;
597              var seenNamedParam = false;
598              var inputParameters = new List&lt;NpgsqlParameter&gt;(parameters.Count);
599              for (var i = 0; i &lt; parameters.Count; i++)
600              {
601                  var parameter = parameters[i];
602                  if (EnableStoredProcedureCompatMode &amp;&amp; parameter.Direction == ParameterDirection.Output)
603                      continue;
604                  if (isFirstParam)
605                      isFirstParam = false;
606                  else
607                      sqlBuilder.Append(&quot;, &quot;);
608                  if (parameter.IsPositional)
609                  {
610                      if (seenNamedParam)
611                          ThrowHelper.ThrowArgumentException(NpgsqlStrings.PositionalParameterAfterNamed);
612                  }
613                  else
614                  {
615                      seenNamedParam = true;
616                      sqlBuilder
617                          .Append(&#x27;&quot;&#x27;)
618                          .Append(parameter.TrimmedName.Replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;))
619                          .Append(&quot;\&quot; := &quot;);
620                  }
621                  if (parameter.Direction == ParameterDirection.Output)
622                      sqlBuilder.Append(&quot;NULL&quot;);
623                  else
624                  {
625                      inputParameters.Add(parameter);
626                      sqlBuilder.Append(&#x27;$&#x27;).Append(inputParameters.Count);
627                  }
628              }
629              sqlBuilder.Append(&#x27;)&#x27;);
630              batchCommand ??= TruncateStatementsToOne();
631              batchCommand.FinalCommandText = sqlBuilder.ToString();
632              batchCommand.PositionalParameters.AddRange(inputParameters);
633              ValidateParameterCount(batchCommand);
634              break;
635          default:
636              ThrowHelper.ThrowArgumentOutOfRangeException(nameof(CommandType), $&quot;Internal Npgsql bug: unexpected value {{0}} of enum {nameof(CommandType)}. Please file a bug.&quot;, commandType);
637              break;
638          }
639          static void ValidateParameterCount(NpgsqlBatchCommand batchCommand)
640          {
641              if (batchCommand.PositionalParameters.Count &gt; ushort.MaxValue)
642                  ThrowHelper.ThrowNpgsqlException(&quot;A statement cannot have more than 65535 parameters&quot;);
643          }
644      }
645      #endregion
646      #region Message Creation / Population
647      void BeginSend(NpgsqlConnector connector)
648          =&gt; connector.WriteBuffer.Timeout = TimeSpan.FromSeconds(CommandTimeout);
649      internal Task Write(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken = default)
650      {
651          return (_behavior &amp; CommandBehavior.SchemaOnly) == 0
652              ? WriteExecute(connector, async, flush, cancellationToken)
653              : WriteExecuteSchemaOnly(connector, async, flush, cancellationToken);
<span onclick='openModal()' class='match'>654          async Task WriteExecute(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken)
655          {
656              NpgsqlBatchCommand? batchCommand = null;
</span>657              for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
658              {
659                  ForceAsyncIfNecessary(ref async, i);
660                  batchCommand = InternalBatchCommands[i];
661                  var pStatement = batchCommand.PreparedStatement;
662                  Debug.Assert(batchCommand.FinalCommandText is not null);
663                  if (pStatement == null || batchCommand.IsPreparing)
664                  {
665                      if (pStatement?.StatementBeingReplaced != null)
666                          await connector.WriteClose(StatementOrPortal.Statement, pStatement.StatementBeingReplaced.Name!, async, cancellationToken);
667                      await connector.WriteParse(batchCommand.FinalCommandText, batchCommand.StatementName, batchCommand.PositionalParameters, async, cancellationToken);
668                      await connector.WriteBind(
669                          batchCommand.PositionalParameters, string.Empty, batchCommand.StatementName, AllResultTypesAreUnknown,
670                          i == 0 ? UnknownResultTypeList : null,
671                          async, cancellationToken);
672                      await connector.WriteDescribe(StatementOrPortal.Portal, string.Empty, async, cancellationToken);
673                  }
674                  else
675                  {
676                      await connector.WriteBind(
677                          batchCommand.PositionalParameters, string.Empty, batchCommand.StatementName, AllResultTypesAreUnknown,
678                          i == 0 ? UnknownResultTypeList : null,
679                          async, cancellationToken);
680                  }
681                  await connector.WriteExecute(0, async, cancellationToken);
682                  if (batchCommand.AppendErrorBarrier ?? EnableErrorBarriers)
683                      await connector.WriteSync(async, cancellationToken);
684                  if (pStatement != null)
685                      pStatement.LastUsed = DateTime.UtcNow;
686              }
687              if (batchCommand is null || !(batchCommand.AppendErrorBarrier ?? EnableErrorBarriers))
688              {
689                  await connector.WriteSync(async, cancellationToken);
690              }
691              if (flush)
692                  await connector.Flush(async, cancellationToken);
693          }
694          async Task WriteExecuteSchemaOnly(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken)
695          {
696              var wroteSomething = false;
697              for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
698              {
699                  ForceAsyncIfNecessary(ref async, i);
700                  var batchCommand = InternalBatchCommands[i];
701                  if (batchCommand.PreparedStatement?.State == PreparedState.Prepared)
702                      continue;   
703                  await connector.WriteParse(batchCommand.FinalCommandText!, batchCommand.StatementName, batchCommand.PositionalParameters, async, cancellationToken);
704                  await connector.WriteDescribe(StatementOrPortal.Statement, batchCommand.StatementName, async, cancellationToken);
705                  wroteSomething = true;
706              }
707              if (wroteSomething)
708              {
709                  await connector.WriteSync(async, cancellationToken);
710                  if (flush)
711                      await connector.Flush(async, cancellationToken);
712              }
713          }
714      }
715      async Task SendDeriveParameters(NpgsqlConnector connector, bool async, CancellationToken cancellationToken = default)
716      {
717          BeginSend(connector);
718          for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
719          {
720              ForceAsyncIfNecessary(ref async, i);
721              var batchCommand = InternalBatchCommands[i];
722              await connector.WriteParse(batchCommand.FinalCommandText!, string.Empty, EmptyParameters, async, cancellationToken);
723              await connector.WriteDescribe(StatementOrPortal.Statement, string.Empty, async, cancellationToken);
724          }
725          await connector.WriteSync(async, cancellationToken);
726          await connector.Flush(async, cancellationToken);
727      }
728      async Task SendPrepare(NpgsqlConnector connector, bool async, CancellationToken cancellationToken = default)
729      {
730          BeginSend(connector);
731          for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
732          {
733              ForceAsyncIfNecessary(ref async, i);
734              var batchCommand = InternalBatchCommands[i];
735              var pStatement = batchCommand.PreparedStatement;
736              if (!batchCommand.IsPreparing)
737                  continue;
738              var statementToClose = pStatement!.StatementBeingReplaced;
739              if (statementToClose != null)
740                  await connector.WriteClose(StatementOrPortal.Statement, statementToClose.Name!, async, cancellationToken);
741              await connector.WriteParse(batchCommand.FinalCommandText!, pStatement.Name!, batchCommand.PositionalParameters, async, cancellationToken);
742              await connector.WriteDescribe(StatementOrPortal.Statement, pStatement.Name!, async, cancellationToken);
743          }
744          await connector.WriteSync(async, cancellationToken);
745          await connector.Flush(async, cancellationToken);
746      }
747      [MethodImpl(MethodImplOptions.AggressiveInlining)]
748      void ForceAsyncIfNecessary(ref bool async, int numberOfStatementInBatch)
749      {
750          if (!async &amp;&amp; numberOfStatementInBatch &gt; 0)
751          {
752              async = true;
753              SynchronizationContext.SetSynchronizationContext(SingleThreadSynchronizationContext);
754          }
755      }
756      async Task SendClose(NpgsqlConnector connector, bool async, CancellationToken cancellationToken = default)
757      {
758          BeginSend(connector);
759          var i = 0;
760          foreach (var batchCommand in InternalBatchCommands.Where(s =&gt; s.IsPrepared))
761          {
762              ForceAsyncIfNecessary(ref async, i);
763              await connector.WriteClose(StatementOrPortal.Statement, batchCommand.StatementName, async, cancellationToken);
764              batchCommand.PreparedStatement!.State = PreparedState.BeingUnprepared;
765              i++;
766          }
767          await connector.WriteSync(async, cancellationToken);
768          await connector.Flush(async, cancellationToken);
769      }
770      #endregion
771      #region Execute Non Query
772      public override int ExecuteNonQuery() =&gt; ExecuteNonQuery(false, CancellationToken.None).GetAwaiter().GetResult();
773      public override Task&lt;int&gt; ExecuteNonQueryAsync(CancellationToken cancellationToken)
774      {
775          using (NoSynchronizationContextScope.Enter())
776              return ExecuteNonQuery(true, cancellationToken);
777      }
778      [MethodImpl(MethodImplOptions.AggressiveInlining)]
779      async Task&lt;int&gt; ExecuteNonQuery(bool async, CancellationToken cancellationToken)
780      {
781          var reader = await ExecuteReader(CommandBehavior.Default, async, cancellationToken);
782          try
783          {
784              while (async ? await reader.NextResultAsync(cancellationToken) : reader.NextResult()) ;
785              return reader.RecordsAffected;
786          }
787          finally
788          {
789              if (async)
790                  await reader.DisposeAsync();
791              else
792                  reader.Dispose();
793          }
794      }
795      #endregion Execute Non Query
796      #region Execute Scalar
797      public override object? ExecuteScalar() =&gt; ExecuteScalar(false, CancellationToken.None).GetAwaiter().GetResult();
798      public override Task&lt;object?&gt; ExecuteScalarAsync(CancellationToken cancellationToken)
799      {
800          using (NoSynchronizationContextScope.Enter())
801              return ExecuteScalar(true, cancellationToken).AsTask();
802      }
803      [MethodImpl(MethodImplOptions.AggressiveInlining)]
804      async ValueTask&lt;object?&gt; ExecuteScalar(bool async, CancellationToken cancellationToken)
805      {
806          var behavior = CommandBehavior.SingleRow;
807          if (IsWrappedByBatch || !Parameters.HasOutputParameters)
808              behavior |= CommandBehavior.SequentialAccess;
809          var reader = await ExecuteReader(behavior, async, cancellationToken);
810          try
811          {
812              var read = async ? await reader.ReadAsync(cancellationToken) : reader.Read();
813              var value = read &amp;&amp; reader.FieldCount != 0 ? reader.GetValue(0) : null;
814              while (async ? await reader.NextResultAsync(cancellationToken) : reader.NextResult()) ;
815              return value;
816          }
817          finally
818          {
819              if (async)
820                  await reader.DisposeAsync();
821              else
822                  reader.Dispose();
823          }
824      }
825      #endregion Execute Scalar
826      #region Execute Reader
827      protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
828          =&gt; ExecuteReader(behavior);
829      protected override async Task&lt;DbDataReader&gt; ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken)
830          =&gt; await ExecuteReaderAsync(behavior, cancellationToken);
831      public new NpgsqlDataReader ExecuteReader(CommandBehavior behavior = CommandBehavior.Default)
832          =&gt; ExecuteReader(behavior, async: false, CancellationToken.None).GetAwaiter().GetResult();
833      public new Task&lt;NpgsqlDataReader&gt; ExecuteReaderAsync(CancellationToken cancellationToken = default)
834          =&gt; ExecuteReaderAsync(CommandBehavior.Default, cancellationToken);
835      public new Task&lt;NpgsqlDataReader&gt; ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken = default)
836      {
837          using (NoSynchronizationContextScope.Enter())
838              return ExecuteReader(behavior, async: true, cancellationToken).AsTask();
839      }
840      internal ManualResetValueTaskSource&lt;NpgsqlConnector&gt; ExecutionCompletion { get; }
841          = new();
842      internal virtual async ValueTask&lt;NpgsqlDataReader&gt; ExecuteReader(CommandBehavior behavior, bool async, CancellationToken cancellationToken)
843      {
844          var conn = CheckAndGetConnection();
845          _behavior = behavior;
846          NpgsqlConnector? connector;
847          if (_connector is not null)
848          {
849              Debug.Assert(conn is null);
850              if (behavior.HasFlag(CommandBehavior.CloseConnection))
851                  ThrowHelper.ThrowArgumentException($&quot;{nameof(CommandBehavior.CloseConnection)} is not supported with {nameof(NpgsqlConnector)}&quot;, nameof(behavior));
852              connector = _connector;
853          }
854          else
855          {
856              Debug.Assert(conn is not null);
857              conn.TryGetBoundConnector(out connector);
858          }
859          try
860          {
861              if (connector is not null)
862              {
863                  var dataSource = connector.DataSource;
864                  var logger = connector.CommandLogger;
865                  cancellationToken.ThrowIfCancellationRequested();
866                  connector.StartUserAction(ConnectorState.Executing, this, CancellationToken.None);
867                  Task? sendTask;
868                  var validateParameterValues = !behavior.HasFlag(CommandBehavior.SchemaOnly);
869                  try
870                  {
871                      switch (IsExplicitlyPrepared)
872                      {
873                      case true:
874                          Debug.Assert(_connectorPreparedOn != null);
875                          if (IsWrappedByBatch)
876                          {
877                              foreach (var batchCommand in InternalBatchCommands)
878                              {
879                                  if (batchCommand.ConnectorPreparedOn != connector)
880                                  {
881                                      foreach (var s in InternalBatchCommands)
882                                          s.ResetPreparation();
883                                      ResetPreparation();
884                                      goto case false;
885                                  }
886                                  batchCommand.Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
887                              }
888                          }
889                          else
890                          {
891                              if (_connectorPreparedOn != connector)
892                              {
893                                  foreach (var s in InternalBatchCommands)
894                                      s.PreparedStatement = null;
895                                  ResetPreparation();
896                                  goto case false;
897                              }
898                              Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
899                          }
900                          NpgsqlEventSource.Log.CommandStartPrepared();
901                          break;
902                      case false:
903                          var numPrepared = 0;
904                          if (IsWrappedByBatch)
905                          {
906                              for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
907                              {
908                                  var batchCommand = InternalBatchCommands[i];
909                                  batchCommand.Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
910                                  ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand);
911                                  if (connector.Settings.MaxAutoPrepare &gt; 0 &amp;&amp; batchCommand.TryAutoPrepare(connector))
912                                  {
913                                      batchCommand.ConnectorPreparedOn = connector;
914                                      numPrepared++;
915                                  }
916                              }
917                          }
918                          else
919                          {
920                              Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
921                              ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand: null);
922                              if (connector.Settings.MaxAutoPrepare &gt; 0)
923                                  for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
924                                      if (InternalBatchCommands[i].TryAutoPrepare(connector))
925                                          numPrepared++;
926                          }
927                          if (numPrepared &gt; 0)
928                          {
929                              _connectorPreparedOn = connector;
930                              if (numPrepared == InternalBatchCommands.Count)
931                                  NpgsqlEventSource.Log.CommandStartPrepared();
932                          }
933                          break;
934                      }
935                      State = CommandState.InProgress;
936                      if (logger.IsEnabled(LogLevel.Information))
937                      {
938                          connector.QueryLogStopWatch.Restart();
939                          if (logger.IsEnabled(LogLevel.Debug))
940                              LogExecutingCompleted(connector, executing: true);
941                      }
942                      NpgsqlEventSource.Log.CommandStart(CommandText);
943                      TraceCommandStart(connector);
944                      connector.ResetCancellation();
945                      BeginSend(connector);
946                      sendTask = Write(connector, async, flush: true, CancellationToken.None);
947                      if (sendTask.IsFaulted)
948                          sendTask.GetAwaiter().GetResult();
949                  }
950                  catch
951                  {
952                      connector.EndUserAction();
953                      throw;
954                  }
955                  var reader = connector.DataReader;
956                  reader.Init(this, behavior, InternalBatchCommands, sendTask);
957                  connector.CurrentReader = reader;
958                  if (async)
959                      await reader.NextResultAsync(cancellationToken);
960                  else
961                      reader.NextResult();
962                  TraceReceivedFirstResponse();
963                  return reader;
964              }
965              else
966              {
967                  Debug.Assert(conn is not null);
968                  Debug.Assert(conn.Settings.Multiplexing);
969                  var dataSource = (MultiplexingDataSource)conn.NpgsqlDataSource;
970                  if (!async)
971                  {
972                      ThrowHelper.ThrowNotSupportedException(&quot;Synchronous command execution is not supported when multiplexing is on&quot;);
973                  }
974                  if (IsWrappedByBatch)
975                  {
976                      foreach (var batchCommand in InternalBatchCommands)
977                      {
978                          batchCommand.Parameters.ProcessParameters(dataSource.TypeMapper, validateValues: true, CommandType);
979                          ProcessRawQuery(null, standardConformingStrings: true, batchCommand);
980                      }
981                  }
982                  else
983                  {
984                      Parameters.ProcessParameters(dataSource.TypeMapper, validateValues: true, CommandType);
985                      ProcessRawQuery(null, standardConformingStrings: true, batchCommand: null);
986                  }
987                  State = CommandState.InProgress;
988                  ExecutionCompletion.Reset();
989                  try
990                  {
991                      await dataSource.MultiplexCommandWriter.WriteAsync(this, cancellationToken);
992                  }
993                  catch (ChannelClosedException ex)
994                  {
995                      Debug.Assert(ex.InnerException is not null);
996                      throw ex.InnerException;
997                  }
998                  connector = await new ValueTask&lt;NpgsqlConnector&gt;(ExecutionCompletion, ExecutionCompletion.Version);
999                  conn.Connector = connector;
1000                  connector.Connection = conn;
1001                  conn.ConnectorBindingScope = ConnectorBindingScope.Reader;
1002                  var reader = connector.DataReader;
1003                  reader.Init(this, behavior, InternalBatchCommands);
1004                  connector.CurrentReader = reader;
1005                  await reader.NextResultAsync(cancellationToken);
1006                  return reader;
1007              }
1008          }
1009          catch (Exception e)
1010          {
1011              var reader = connector?.CurrentReader;
1012              if (e is not NpgsqlOperationInProgressException &amp;&amp; reader is not null)
1013                  await reader.Cleanup(async);
1014              TraceSetException(e);
1015              State = CommandState.Idle;
1016              if ((behavior &amp; CommandBehavior.CloseConnection) == CommandBehavior.CloseConnection)
1017              {
1018                  Debug.Assert(_connector is null &amp;&amp; conn is not null);
1019                  conn.Close();
1020              }
1021              throw;
1022          }
1023      }
1024      #endregion
1025      #region Transactions
1026      protected override DbTransaction? DbTransaction
1027      {
1028          get =&gt; _transaction;
1029          set =&gt; _transaction = (NpgsqlTransaction?)value;
1030      }
1031      public new NpgsqlTransaction? Transaction
1032      {
1033          get =&gt; (NpgsqlTransaction?)DbTransaction;
1034          set =&gt; DbTransaction = value;
1035      }
1036      #endregion Transactions
1037      #region Cancel
1038      public override void Cancel()
1039      {
1040          if (State != CommandState.InProgress)
1041              return;
1042          var connector = Connection?.Connector ?? _connector;
1043          if (connector is null)
1044              return;
1045          connector.PerformUserCancellation();
1046      }
1047      #endregion Cancel
1048      #region Dispose
1049      protected override void Dispose(bool disposing)
1050      {
1051          ResetTransaction();
1052          State = CommandState.Disposed;
1053          if (IsCacheable &amp;&amp; InternalConnection is not null &amp;&amp; InternalConnection.CachedCommand is null)
1054          {
1055              Reset();
1056              InternalConnection.CachedCommand = this;
1057              return;
1058          }
1059          IsCacheable = false;
1060      }
1061      internal void Reset()
1062      {
1063          _commandText = string.Empty;
1064          CommandType = CommandType.Text;
1065          _parameters.Clear();
1066          _timeout = null;
1067          _allResultTypesAreUnknown = false;
1068          EnableErrorBarriers = false;
1069      }
1070      internal void ResetTransaction() =&gt; _transaction = null;
1071      #endregion
1072      #region Tracing
1073      internal void TraceCommandStart(NpgsqlConnector connector)
1074      {
1075          Debug.Assert(CurrentActivity is null);
1076          if (NpgsqlActivitySource.IsEnabled)
1077              CurrentActivity = NpgsqlActivitySource.CommandStart(connector, CommandText, CommandType);
1078      }
1079      internal void TraceReceivedFirstResponse()
1080      {
1081          if (CurrentActivity is not null)
1082          {
1083              NpgsqlActivitySource.ReceivedFirstResponse(CurrentActivity);
1084          }
1085      }
1086      internal void TraceCommandStop()
1087      {
1088          if (CurrentActivity is not null)
1089          {
1090              NpgsqlActivitySource.CommandStop(CurrentActivity);
1091              CurrentActivity = null;
1092          }
1093      }
1094      internal void TraceSetException(Exception e)
1095      {
1096          if (CurrentActivity is not null)
1097          {
1098              NpgsqlActivitySource.SetException(CurrentActivity, e);
1099              CurrentActivity = null;
1100          }
1101      }
1102      #endregion Tracing
1103      #region Misc
1104      NpgsqlBatchCommand TruncateStatementsToOne()
1105      {
1106          switch (InternalBatchCommands.Count)
1107          {
1108          case 0:
1109              var statement = new NpgsqlBatchCommand();
1110              InternalBatchCommands.Add(statement);
1111              return statement;
1112          case 1:
1113              statement = InternalBatchCommands[0];
1114              statement.Reset();
1115              return statement;
1116          default:
1117              statement = InternalBatchCommands[0];
1118              statement.Reset();
1119              InternalBatchCommands.Clear();
1120              InternalBatchCommands.Add(statement);
1121              return statement;
1122          }
1123      }
1124      internal void FixupRowDescription(RowDescriptionMessage rowDescription, bool isFirst)
1125      {
1126          for (var i = 0; i &lt; rowDescription.Count; i++)
1127          {
1128              var field = rowDescription[i];
1129              field.FormatCode = (UnknownResultTypeList == null || !isFirst ? AllResultTypesAreUnknown : UnknownResultTypeList[i])
1130                  ? FormatCode.Text
1131                  : FormatCode.Binary;
1132              field.ResolveHandler();
1133          }
1134      }
1135      internal void LogExecutingCompleted(NpgsqlConnector connector, bool executing)
1136      {
1137          var logParameters = connector.LoggingConfiguration.IsParameterLoggingEnabled || connector.Settings.LogParameters;
1138          var logger = connector.LoggingConfiguration.CommandLogger;
1139          if (InternalBatchCommands.Count == 1)
1140          {
1141              var singleCommand = InternalBatchCommands[0];
1142              if (logParameters &amp;&amp; singleCommand.PositionalParameters.Count &gt; 0)
1143              {
1144                  if (executing)
1145                  {
1146                      LogMessages.ExecutingCommandWithParameters(
1147                          logger,
1148                          singleCommand.FinalCommandText!,
1149                          singleCommand.PositionalParameters.Select(p =&gt; p.Value == DBNull.Value ? &quot;NULL&quot; : p.Value!).ToArray(),
1150                          connector.Id);
1151                  }
1152                  else
1153                  {
1154                      LogMessages.CommandExecutionCompletedWithParameters(
1155                          logger,
1156                          singleCommand.FinalCommandText!,
1157                          singleCommand.PositionalParameters.Select(p =&gt; p.Value == DBNull.Value ? &quot;NULL&quot; : p.Value!).ToArray(),
1158                          connector.QueryLogStopWatch.ElapsedMilliseconds,
1159                          connector.Id);
1160                  }
1161              }
1162              else
1163              {
1164                  if (executing)
1165                      LogMessages.ExecutingCommand(logger, singleCommand.FinalCommandText!, connector.Id);
1166                  else
1167                      LogMessages.CommandExecutionCompleted(logger, singleCommand.FinalCommandText!, connector.QueryLogStopWatch.ElapsedMilliseconds, connector.Id);
1168              }
1169          }
1170          else
1171          {
1172              if (logParameters)
1173              {
1174                  var commands = InternalBatchCommands
1175                      .Select(c =&gt; (
1176                          c.CommandText,
1177                          Parameters: (object[]?)c.PositionalParameters.Select(p =&gt; p.Value == DBNull.Value ? &quot;NULL&quot; : p.Value).ToArray()!)
1178                      ).ToArray();
1179                  if (executing)
1180                      LogMessages.ExecutingBatchWithParameters(logger, commands, connector.Id);
1181                  else
1182                      LogMessages.BatchExecutionCompletedWithParameters(logger, commands, connector.QueryLogStopWatch.ElapsedMilliseconds, connector.Id);
1183              }
1184              else
1185              {
1186                  var commands = InternalBatchCommands.Select(c =&gt; c.CommandText).ToArray().ToArray();
1187                  if (executing)
1188                      LogMessages.ExecutingBatch(logger, commands, connector.Id);
1189                  else
1190                      LogMessages.BatchExecutionCompleted(logger, commands, connector.QueryLogStopWatch.ElapsedMilliseconds, connector.Id);
1191              }
1192          }
1193      }
1194      object ICloneable.Clone() =&gt; Clone();
1195      public virtual NpgsqlCommand Clone()
1196      {
1197          var clone = new NpgsqlCommand(CommandText, InternalConnection, Transaction)
1198          {
1199              CommandTimeout = CommandTimeout, CommandType = CommandType, DesignTimeVisible = DesignTimeVisible, _allResultTypesAreUnknown = _allResultTypesAreUnknown, _unknownResultTypeList = _unknownResultTypeList, ObjectResultTypes = ObjectResultTypes
1200          };
1201          _parameters.CloneTo(clone._parameters);
1202          return clone;
1203      }
1204      NpgsqlConnection? CheckAndGetConnection()
1205      {
1206          if (State == CommandState.Disposed)
1207              ThrowHelper.ThrowObjectDisposedException(GetType().FullName);
1208          if (InternalConnection == null)
1209          {
1210              if (_connector is null)
1211                  ThrowHelper.ThrowInvalidOperationException(&quot;Connection property has not been initialized.&quot;);
1212              return null;
1213          }
1214          switch (InternalConnection.FullState)
1215          {
1216          case ConnectionState.Open:
1217          case ConnectionState.Connecting:
1218          case ConnectionState.Open | ConnectionState.Executing:
1219          case ConnectionState.Open | ConnectionState.Fetching:
1220              return InternalConnection;
1221          default:
1222              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is not open&quot;);
1223              return null;
1224          }
1225      }
1226      [EditorBrowsable(EditorBrowsableState.Never)]
1227      public new event EventHandler? Disposed
1228      {
1229          add =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1230          remove =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1231      }
1232      event EventHandler? IComponent.Disposed
1233      {
1234          add =&gt; Disposed += value;
1235          remove =&gt; Disposed -= value;
1236      }
1237      #endregion
1238  }
1239  enum CommandState
1240  {
1241      Idle,
1242      InProgress,
1243      Disposed
1244  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlCommand.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Data;
5  using System.Data.Common;
6  using System.Diagnostics;
7  using System.Linq;
8  using System.Runtime.CompilerServices;
9  using System.Text;
10  using System.Threading;
11  using System.Threading.Tasks;
12  using Npgsql.BackendMessages;
13  using Npgsql.Util;
14  using NpgsqlTypes;
15  using static Npgsql.Util.Statics;
16  using System.Diagnostics.CodeAnalysis;
17  using System.Threading.Channels;
18  using Microsoft.Extensions.Logging;
19  using Npgsql.Internal;
20  using Npgsql.Properties;
21  namespace Npgsql;
22  [System.ComponentModel.DesignerCategory(&quot;&quot;)]
23  public class NpgsqlCommand : DbCommand, ICloneable, IComponent
24  {
25      #region Fields
26      NpgsqlTransaction? _transaction;
27      readonly NpgsqlConnector? _connector;
28      NpgsqlConnector? _connectorPreparedOn;
29      string _commandText;
30      CommandBehavior _behavior;
31      int? _timeout;
32      readonly NpgsqlParameterCollection _parameters;
33      internal bool IsWrappedByBatch { get; }
34      internal List&lt;NpgsqlBatchCommand&gt; InternalBatchCommands { get; }
35      Activity? CurrentActivity;
36      [Obsolete(&quot;Use the new DbBatch API&quot;)]
37      public IReadOnlyList&lt;NpgsqlBatchCommand&gt; Statements =&gt; InternalBatchCommands.AsReadOnly();
38      UpdateRowSource _updateRowSource = UpdateRowSource.Both;
39      bool IsExplicitlyPrepared =&gt; _connectorPreparedOn != null;
40      internal bool IsCacheable { get; set; }
41  #if DEBUG
42      internal static bool EnableSqlRewriting;
43      internal static bool EnableStoredProcedureCompatMode;
44  #else
45      internal static readonly bool EnableSqlRewriting;
46      internal static readonly bool EnableStoredProcedureCompatMode;
47  #endif
48      internal bool EnableErrorBarriers { get; set; }
49      static readonly List&lt;NpgsqlParameter&gt; EmptyParameters = new();
50      static readonly SingleThreadSynchronizationContext SingleThreadSynchronizationContext = new(&quot;NpgsqlRemainingAsyncSendWorker&quot;);
51      #endregion Fields
52      #region Constants
53      internal const int DefaultTimeout = 30;
54      #endregion
55      #region Constructors
56      static NpgsqlCommand()
57      {
58          EnableSqlRewriting = !AppContext.TryGetSwitch(&quot;Npgsql.EnableSqlRewriting&quot;, out var enabled) || enabled;
59          EnableStoredProcedureCompatMode = AppContext.TryGetSwitch(&quot;Npgsql.EnableStoredProcedureCompatMode&quot;, out enabled) &amp;&amp; enabled;
60      }
61      public NpgsqlCommand() : this(null, null, null) {}
62      public NpgsqlCommand(string? cmdText) : this(cmdText, null, null) {}
63      public NpgsqlCommand(string? cmdText, NpgsqlConnection? connection)
64      {
65          GC.SuppressFinalize(this);
66          InternalBatchCommands = new List&lt;NpgsqlBatchCommand&gt;(1);
67          _parameters = new NpgsqlParameterCollection();
68          _commandText = cmdText ?? string.Empty;
69          InternalConnection = connection;
70          CommandType = CommandType.Text;
71      }
72      public NpgsqlCommand(string? cmdText, NpgsqlConnection? connection, NpgsqlTransaction? transaction)
73          : this(cmdText, connection)
74          =&gt; Transaction = transaction;
75      internal NpgsqlCommand(int batchCommandCapacity, NpgsqlConnection? connection = null)
76      {
77          GC.SuppressFinalize(this);
78          InternalBatchCommands = new List&lt;NpgsqlBatchCommand&gt;(batchCommandCapacity);
79          InternalConnection = connection;
80          CommandType = CommandType.Text;
81          IsWrappedByBatch = true;
82          _commandText = null!;
83          _parameters = null!;
84      }
85      internal NpgsqlCommand(string? cmdText, NpgsqlConnector connector) : this(cmdText)
86          =&gt; _connector = connector;
87      internal NpgsqlCommand(NpgsqlConnector connector, int batchCommandCapacity)
88          : this(batchCommandCapacity)
89          =&gt; _connector = connector;
90      internal static NpgsqlCommand CreateCachedCommand(NpgsqlConnection connection)
91          =&gt; new(null, connection) { IsCacheable = true };
92      #endregion Constructors
93      #region Public properties
94      [AllowNull, DefaultValue(&quot;&quot;)]
95      [Category(&quot;Data&quot;)]
96      public override string CommandText
97      {
98          get =&gt; _commandText;
99          set
100          {
101              Debug.Assert(!IsWrappedByBatch);
102              if (State != CommandState.Idle)
103                  ThrowHelper.ThrowInvalidOperationException(&quot;An open data reader exists for this command.&quot;);
104              _commandText = value ?? string.Empty;
105              ResetPreparation();
106          }
107      }
108      [DefaultValue(DefaultTimeout)]
109      public override int CommandTimeout
110      {
111          get =&gt; _timeout ?? (InternalConnection?.CommandTimeout ?? DefaultTimeout);
112          set
113          {
114              if (value &lt; 0) {
115                  throw new ArgumentOutOfRangeException(nameof(value), value, &quot;CommandTimeout can&#x27;t be less than zero.&quot;);
116              }
117              _timeout = value;
118          }
119      }
120      [DefaultValue(CommandType.Text)]
121      [Category(&quot;Data&quot;)]
122      public override CommandType CommandType { get; set; }
123      internal NpgsqlConnection? InternalConnection { get; private set; }
124      protected override DbConnection? DbConnection
125      {
126          get =&gt; InternalConnection;
127          set
128          {
129              if (InternalConnection == value)
130                  return;
131              InternalConnection = State == CommandState.Idle
132                  ? (NpgsqlConnection?)value
133                  : throw new InvalidOperationException(&quot;An open data reader exists for this command.&quot;);
134              Transaction = null;
135          }
136      }
137      [DefaultValue(null)]
138      [Category(&quot;Behavior&quot;)]
139      public new NpgsqlConnection? Connection
140      {
141          get =&gt; (NpgsqlConnection?)DbConnection;
142          set =&gt; DbConnection = value;
143      }
144      public override bool DesignTimeVisible { get; set; }
145      [Category(&quot;Behavior&quot;), DefaultValue(UpdateRowSource.Both)]
146      public override UpdateRowSource UpdatedRowSource
147      {
148          get =&gt; _updateRowSource;
149          set
150          {
151              switch (value)
152              {
153              case UpdateRowSource.None:
154              case UpdateRowSource.OutputParameters:
155              case UpdateRowSource.FirstReturnedRecord:
156              case UpdateRowSource.Both:
157                  _updateRowSource = value;
158                  break;
159              default:
160                  throw new ArgumentOutOfRangeException();
161              }
162          }
163      }
164      public bool IsPrepared =&gt;
165          _connectorPreparedOn == (InternalConnection?.Connector ?? _connector) &amp;&amp;
166          InternalBatchCommands.Any() &amp;&amp; InternalBatchCommands.All(s =&gt; s.PreparedStatement?.IsPrepared == true);
167      #endregion Public properties
168      #region Known/unknown Result Types Management
169      public bool AllResultTypesAreUnknown
170      {
171          get =&gt; _allResultTypesAreUnknown;
172          set
173          {
174              _unknownResultTypeList = null;
175              _allResultTypesAreUnknown = value;
176          }
177      }
178      bool _allResultTypesAreUnknown;
179      public bool[]? UnknownResultTypeList
180      {
181          get =&gt; _unknownResultTypeList;
182          set
183          {
184              _allResultTypesAreUnknown = false;
185              _unknownResultTypeList = value;
186          }
187      }
188      bool[]? _unknownResultTypeList;
189      #endregion
190      #region Result Types Management
191      internal Type[]? ObjectResultTypes { get; set; }
192      #endregion
193      #region State management
194      volatile int _state;
195      internal CommandState State
196      {
197          get =&gt; (CommandState)_state;
198          set
199          {
200              var newState = (int)value;
201              if (newState == _state)
202                  return;
203              _state = newState;
204          }
205      }
206      internal void ResetPreparation() =&gt; _connectorPreparedOn = null;
207      #endregion State management
208      #region Parameters
209      protected override DbParameter CreateDbParameter() =&gt; CreateParameter();
210      public new NpgsqlParameter CreateParameter() =&gt; new();
211      protected override DbParameterCollection DbParameterCollection =&gt; Parameters;
212      public new NpgsqlParameterCollection Parameters =&gt; _parameters;
213      #endregion
214      #region DeriveParameters
215      const string DeriveParametersForFunctionQuery = @&quot;
216  SELECT
217  CASE
218  	WHEN pg_proc.proargnames IS NULL THEN array_cat(array_fill(&#x27;&#x27;::name,ARRAY[pg_proc.pronargs]),array_agg(pg_attribute.attname ORDER BY pg_attribute.attnum))
219  	ELSE pg_proc.proargnames
220  END AS proargnames,
221  pg_proc.proargtypes,
222  CASE
223  	WHEN pg_proc.proallargtypes IS NULL AND (array_agg(pg_attribute.atttypid))[1] IS NOT NULL THEN array_cat(string_to_array(pg_proc.proargtypes::text,&#x27; &#x27;)::oid[],array_agg(pg_attribute.atttypid ORDER BY pg_attribute.attnum))
224  	ELSE pg_proc.proallargtypes
225  END AS proallargtypes,
226  CASE
227  	WHEN pg_proc.proargmodes IS NULL AND (array_agg(pg_attribute.atttypid))[1] IS NOT NULL THEN array_cat(array_fill(&#x27;i&#x27;::&quot;&quot;char&quot;&quot;,ARRAY[pg_proc.pronargs]),array_fill(&#x27;o&#x27;::&quot;&quot;char&quot;&quot;,ARRAY[array_length(array_agg(pg_attribute.atttypid), 1)]))
228      ELSE pg_proc.proargmodes
229  END AS proargmodes
230  FROM pg_proc
231  LEFT JOIN pg_type ON pg_proc.prorettype = pg_type.oid
232  LEFT JOIN pg_attribute ON pg_type.typrelid = pg_attribute.attrelid AND pg_attribute.attnum &gt;= 1 AND NOT pg_attribute.attisdropped
233  WHERE pg_proc.oid = :proname::regproc
234  GROUP BY pg_proc.proargnames, pg_proc.proargtypes, pg_proc.proallargtypes, pg_proc.proargmodes, pg_proc.pronargs;
235  &quot;;
236      internal void DeriveParameters()
237      {
238          var conn = CheckAndGetConnection();
239          Debug.Assert(conn is not null);
240          if (string.IsNullOrEmpty(CommandText))
241              throw new InvalidOperationException(&quot;CommandText property has not been initialized&quot;);
242          using var _ = conn.StartTemporaryBindingScope(out var connector);
243          if (InternalBatchCommands.Any(s =&gt; s.PreparedStatement?.IsExplicit == true))
244              throw new NpgsqlException(&quot;Deriving parameters isn&#x27;t supported for commands that are already prepared.&quot;);
245          Unprepare();
246          Parameters.Clear();
247          switch (CommandType)
248          {
249          case CommandType.Text:
250              DeriveParametersForQuery(connector);
251              break;
252          case CommandType.StoredProcedure:
253              DeriveParametersForFunction();
254              break;
255          default:
256              throw new NotSupportedException(&quot;Cannot derive parameters for CommandType &quot; + CommandType);
257          }
258      }
259      void DeriveParametersForFunction()
260      {
261          using var c = new NpgsqlCommand(DeriveParametersForFunctionQuery, InternalConnection);
262          c.Parameters.Add(new NpgsqlParameter(&quot;proname&quot;, NpgsqlDbType.Text));
263          c.Parameters[0].Value = CommandText;
264          string[]? names = null;
265          uint[]? types = null;
266          char[]? modes = null;
267          using (var rdr = c.ExecuteReader(CommandBehavior.SingleRow | CommandBehavior.SingleResult))
268          {
269              if (rdr.Read())
270              {
271                  if (!rdr.IsDBNull(0))
272                      names = rdr.GetFieldValue&lt;string[]&gt;(0);
273                  if (!rdr.IsDBNull(2))
274                      types = rdr.GetFieldValue&lt;uint[]&gt;(2);
275                  if (!rdr.IsDBNull(3))
276                      modes = rdr.GetFieldValue&lt;char[]&gt;(3);
277                  if (types == null)
278                  {
279                      if (rdr.IsDBNull(1) || rdr.GetFieldValue&lt;uint[]&gt;(1).Length == 0)
280                          return;  
281                      types = rdr.GetFieldValue&lt;uint[]&gt;(1);
282                  }
283              }
284              else
285                  throw new InvalidOperationException($&quot;{CommandText} does not exist in pg_proc&quot;);
286          }
287          var typeMapper = c.InternalConnection!.Connector!.TypeMapper;
288          for (var i = 0; i &lt; types.Length; i++)
289          {
290              var param = new NpgsqlParameter();
291              var (npgsqlDbType, postgresType) = typeMapper.GetTypeInfoByOid(types[i]);
292              param.DataTypeName = postgresType.DisplayName;
293              param.PostgresType = postgresType;
294              if (npgsqlDbType.HasValue)
295                  param.NpgsqlDbType = npgsqlDbType.Value;
296              if (names != null &amp;&amp; i &lt; names.Length)
297                  param.ParameterName = names[i];
298              else
299                  param.ParameterName = &quot;parameter&quot; + (i + 1);
300              if (modes == null) 
301                  param.Direction = ParameterDirection.Input;
302              else
303              {
304                  param.Direction = modes[i] switch
305                  {
306                      &#x27;i&#x27; =&gt; ParameterDirection.Input,
307                      &#x27;o&#x27; =&gt; ParameterDirection.Output,
308                      &#x27;t&#x27; =&gt; ParameterDirection.Output,
309                      &#x27;b&#x27; =&gt; ParameterDirection.InputOutput,
310                      &#x27;v&#x27; =&gt; throw new NotSupportedException(&quot;Cannot derive function parameter of type VARIADIC&quot;),
311                      _ =&gt; throw new ArgumentOutOfRangeException(&quot;Unknown code in proargmodes while deriving: &quot; + modes[i])
312                  };
313              }
314              Parameters.Add(param);
315          }
316      }
317      void DeriveParametersForQuery(NpgsqlConnector connector)
318      {
319          using (connector.StartUserAction())
320          {
321              LogMessages.DerivingParameters(connector.CommandLogger, CommandText, connector.Id);
322              if (IsWrappedByBatch)
323                  foreach (var batchCommand in InternalBatchCommands)
324                      connector.SqlQueryParser.ParseRawQuery(batchCommand, connector.UseConformingStrings, deriveParameters: true);
325              else
326                  connector.SqlQueryParser.ParseRawQuery(this, connector.UseConformingStrings, deriveParameters: true);
327              var sendTask = SendDeriveParameters(connector, false);
328              if (sendTask.IsFaulted)
329                  sendTask.GetAwaiter().GetResult();
330              foreach (var batchCommand in InternalBatchCommands)
331              {
332                  Expect&lt;ParseCompleteMessage&gt;(
333                      connector.ReadMessage(async: false).GetAwaiter().GetResult(), connector);
334                  var paramTypeOIDs = Expect&lt;ParameterDescriptionMessage&gt;(
335                      connector.ReadMessage(async: false).GetAwaiter().GetResult(), connector).TypeOIDs;
336                  if (batchCommand.PositionalParameters.Count != paramTypeOIDs.Count)
337                  {
338                      connector.SkipUntil(BackendMessageCode.ReadyForQuery);
339                      Parameters.Clear();
340                      throw new NpgsqlException(&quot;There was a mismatch in the number of derived parameters between the Npgsql SQL parser and the PostgreSQL parser. Please report this as bug to the Npgsql developers (https:&amp;bsol;&amp;bsol;github.com/npgsql/npgsql/issues).&quot;);
341                  }
342                  for (var i = 0; i &lt; paramTypeOIDs.Count; i++)
343                  {
344                      try
345                      {
346                          var param = batchCommand.PositionalParameters[i];
347                          var paramOid = paramTypeOIDs[i];
348                          var (npgsqlDbType, postgresType) = connector.TypeMapper.GetTypeInfoByOid(paramOid);
349                          if (param.NpgsqlDbType != NpgsqlDbType.Unknown &amp;&amp; param.NpgsqlDbType != npgsqlDbType)
350                              throw new NpgsqlException(&quot;The backend parser inferred different types for parameters with the same name. Please try explicit casting within your SQL statement or batch or use different placeholder names.&quot;);
351                          param.DataTypeName = postgresType.DisplayName;
352                          param.PostgresType = postgresType;
353                          if (npgsqlDbType.HasValue)
354                              param.NpgsqlDbType = npgsqlDbType.Value;
355                      }
356                      catch
357                      {
358                          connector.SkipUntil(BackendMessageCode.ReadyForQuery);
359                          Parameters.Clear();
360                          throw;
361                      }
362                  }
363                  var msg = connector.ReadMessage(async: false).GetAwaiter().GetResult();
364                  switch (msg.Code)
365                  {
366                  case BackendMessageCode.RowDescription:
367                  case BackendMessageCode.NoData:
368                      break;
369                  default:
370                      throw connector.UnexpectedMessageReceived(msg.Code);
371                  }
372              }
373              Expect&lt;ReadyForQueryMessage&gt;(connector.ReadMessage(async: false).GetAwaiter().GetResult(), connector);
374              sendTask.GetAwaiter().GetResult();
375          }
376      }
377      #endregion
378      #region Prepare
379      public override void Prepare() =&gt; Prepare(false).GetAwaiter().GetResult();
380  #if NETSTANDARD2_0
381      public virtual Task PrepareAsync(CancellationToken cancellationToken = default)
382  #else
383      public override Task PrepareAsync(CancellationToken cancellationToken = default)
384  #endif
385      {
386          using (NoSynchronizationContextScope.Enter())
387              return Prepare(true, cancellationToken);
388      }
389      Task Prepare(bool async, CancellationToken cancellationToken = default)
390      {
391          var connection = CheckAndGetConnection();
392          Debug.Assert(connection is not null);
393          if (connection.Settings.Multiplexing)
394              throw new NotSupportedException(&quot;Explicit preparation not supported with multiplexing&quot;);
395          var connector = connection.Connector!;
396          var logger = connector.CommandLogger;
397          var needToPrepare = false;
398          if (IsWrappedByBatch)
399          {
400              foreach (var batchCommand in InternalBatchCommands)
401              {
402                  batchCommand.Parameters.ProcessParameters(connector.TypeMapper, validateValues: false, CommandType);
403                  ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand);
404                  needToPrepare = batchCommand.ExplicitPrepare(connector) || needToPrepare;
405              }
406              if (logger.IsEnabled(LogLevel.Debug) &amp;&amp; needToPrepare)
407                  LogMessages.PreparingCommandExplicitly(logger, string.Join(&quot;; &quot;, InternalBatchCommands.Select(c =&gt; c.CommandText)), connector.Id);
408          }
409          else
410          {
411              Parameters.ProcessParameters(connector.TypeMapper, validateValues: false, CommandType);
412              ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand: null);
413              foreach (var batchCommand in InternalBatchCommands)
414                  needToPrepare = batchCommand.ExplicitPrepare(connector) || needToPrepare;
415              if (logger.IsEnabled(LogLevel.Debug) &amp;&amp; needToPrepare)
416                  LogMessages.PreparingCommandExplicitly(logger, CommandText, connector.Id);
417          }
418          _connectorPreparedOn = connector;
419          return needToPrepare
420              ? PrepareLong(this, async, connector, cancellationToken)
421              : Task.CompletedTask;
422          static async Task PrepareLong(NpgsqlCommand command, bool async, NpgsqlConnector connector, CancellationToken cancellationToken)
423          {
424              try
425              {
426                  using (connector.StartUserAction(cancellationToken))
427                  {
428                      var sendTask = command.SendPrepare(connector, async, CancellationToken.None);
429                      if (sendTask.IsFaulted)
430                          sendTask.GetAwaiter().GetResult();
431                      var isFirst = true;
432                      foreach (var batchCommand in command.InternalBatchCommands)
433                      {
434                          if (!batchCommand.IsPreparing)
435                              continue;
436                          var pStatement = batchCommand.PreparedStatement!;
437                          if (pStatement.StatementBeingReplaced != null)
438                          {
439                              Expect&lt;CloseCompletedMessage&gt;(await connector.ReadMessage(async), connector);
440                              pStatement.StatementBeingReplaced.CompleteUnprepare();
441                              pStatement.StatementBeingReplaced = null;
442                          }
443                          Expect&lt;ParseCompleteMessage&gt;(await connector.ReadMessage(async), connector);
444                          Expect&lt;ParameterDescriptionMessage&gt;(await connector.ReadMessage(async), connector);
445                          var msg = await connector.ReadMessage(async);
446                          switch (msg.Code)
447                          {
448                          case BackendMessageCode.RowDescription:
449                              var description = ((RowDescriptionMessage)msg).Clone();
450                              command.FixupRowDescription(description, isFirst);
451                              batchCommand.Description = description;
452                              break;
453                          case BackendMessageCode.NoData:
454                              batchCommand.Description = null;
455                              break;
456                          default:
457                              throw connector.UnexpectedMessageReceived(msg.Code);
458                          }
459                          pStatement.State = PreparedState.Prepared;
460                          connector.PreparedStatementManager.NumPrepared++;
461                          batchCommand.IsPreparing = false;
462                          isFirst = false;
463                      }
464                      Expect&lt;ReadyForQueryMessage&gt;(await connector.ReadMessage(async), connector);
465                      if (async)
466                          await sendTask;
467                      else
468                          sendTask.GetAwaiter().GetResult();
469                  }
470                  LogMessages.CommandPreparedExplicitly(connector.CommandLogger, connector.Id);
471              }
472              catch
473              {
474                  foreach (var batchCommand in command.InternalBatchCommands)
475                  {
476                      if (batchCommand.IsPreparing)
477                      {
478                          batchCommand.IsPreparing = false;
479                          batchCommand.PreparedStatement!.AbortPrepare();
480                      }
481                  }
482                  throw;
483              }
484          }
485      }
486      public void Unprepare()
487          =&gt; Unprepare(false).GetAwaiter().GetResult();
488      public Task UnprepareAsync(CancellationToken cancellationToken = default)
489      {
490          using (NoSynchronizationContextScope.Enter())
491              return Unprepare(true, cancellationToken);
492      }
493      async Task Unprepare(bool async, CancellationToken cancellationToken = default)
494      {
495          var connection = CheckAndGetConnection();
496          Debug.Assert(connection is not null);
497          if (connection.Settings.Multiplexing)
498              throw new NotSupportedException(&quot;Explicit preparation not supported with multiplexing&quot;);
499          if (InternalBatchCommands.All(s =&gt; !s.IsPrepared))
500              return;
501          var connector = connection.Connector!;
502          LogMessages.UnpreparingCommand(connector.CommandLogger, connector.Id);
503          using (connector.StartUserAction(cancellationToken))
504          {
505              var sendTask = SendClose(connector, async, cancellationToken);
506              if (sendTask.IsFaulted)
507                  sendTask.GetAwaiter().GetResult();
508              foreach (var batchCommand in InternalBatchCommands)
509              {
510                  if (batchCommand.PreparedStatement?.State == PreparedState.BeingUnprepared)
511                  {
512                      Expect&lt;CloseCompletedMessage&gt;(await connector.ReadMessage(async), connector);
513                      var pStatement = batchCommand.PreparedStatement;
514                      pStatement.CompleteUnprepare();
515                      if (!pStatement.IsExplicit)
516                          connector.PreparedStatementManager.AutoPrepared[pStatement.AutoPreparedSlotIndex] = null;
517                      batchCommand.PreparedStatement = null;
518                  }
519              }
520              Expect&lt;ReadyForQueryMessage&gt;(await connector.ReadMessage(async), connector);
521              if (async)
522                  await sendTask;
523              else
524                  sendTask.GetAwaiter().GetResult();
525          }
526      }
527      #endregion Prepare
528      #region Query analysis
529      internal void ProcessRawQuery(SqlQueryParser? parser, bool standardConformingStrings, NpgsqlBatchCommand? batchCommand)
530      {
531          var (commandText, commandType, parameters) = batchCommand is null
532              ? (CommandText, CommandType, Parameters)
533              : (batchCommand.CommandText, batchCommand.CommandType, batchCommand.Parameters);
534          if (string.IsNullOrEmpty(commandText))
535              ThrowHelper.ThrowInvalidOperationException(&quot;CommandText property has not been initialized&quot;);
536          switch (commandType)
537          {
538          case CommandType.Text:
539              switch (parameters.PlaceholderType)
540              {
541              case PlaceholderType.Positional:
542                  if (batchCommand is null)
543                  {
544                      batchCommand = TruncateStatementsToOne();
545                      batchCommand.FinalCommandText = CommandText;
546                      batchCommand.PositionalParameters = Parameters.InternalList;
547                  }
548                  else
549                  {
550                      batchCommand.FinalCommandText = batchCommand.CommandText;
551                      batchCommand.PositionalParameters = batchCommand.Parameters.InternalList;
552                  }
553                  ValidateParameterCount(batchCommand);
554                  break;
555              case PlaceholderType.NoParameters:
556                  if (EnableSqlRewriting)
557                      goto case PlaceholderType.Named;
558                  goto case PlaceholderType.Positional;
559              case PlaceholderType.Named:
560                  if (!EnableSqlRewriting)
561                      ThrowHelper.ThrowNotSupportedException($&quot;Named parameters are not supported when Npgsql.{nameof(EnableSqlRewriting)} is disabled&quot;);
562                  parser ??= new SqlQueryParser();
563                  if (batchCommand is null)
564                  {
565                      parser.ParseRawQuery(this, standardConformingStrings);
566                      if (InternalBatchCommands.Count &gt; 1 &amp;&amp; _parameters.HasOutputParameters)
567                          ThrowHelper.ThrowNotSupportedException(&quot;Commands with multiple queries cannot have out parameters&quot;);
568                      for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
569                          ValidateParameterCount(InternalBatchCommands[i]);
570                  }
571                  else
572                  {
573                      parser.ParseRawQuery(batchCommand, standardConformingStrings);
574                      if (batchCommand.Parameters.HasOutputParameters)
575                          ThrowHelper.ThrowNotSupportedException(&quot;Batches cannot cannot have out parameters&quot;);
576                      ValidateParameterCount(batchCommand);
577                  }
578                  break;
579              case PlaceholderType.Mixed:
580                  ThrowHelper.ThrowNotSupportedException(&quot;Mixing named and positional parameters isn&#x27;t supported&quot;);
581                  break;
582              default:
583                  ThrowHelper.ThrowArgumentOutOfRangeException(nameof(PlaceholderType), $&quot;Unknown {nameof(PlaceholderType)} value: {{0}}&quot;, Parameters.PlaceholderType);
584                  break;
585              }
586              break;
587          case CommandType.TableDirect:
588              batchCommand ??= TruncateStatementsToOne();
589              batchCommand.FinalCommandText = &quot;SELECT * FROM &quot; + CommandText;
590              break;
591          case CommandType.StoredProcedure:
592              var sqlBuilder = new StringBuilder()
593                  .Append(EnableStoredProcedureCompatMode ? &quot;SELECT * FROM &quot; : &quot;CALL &quot;)
594                  .Append(CommandText)
595                  .Append(&#x27;(&#x27;);
596              var isFirstParam = true;
597              var seenNamedParam = false;
598              var inputParameters = new List&lt;NpgsqlParameter&gt;(parameters.Count);
599              for (var i = 0; i &lt; parameters.Count; i++)
600              {
601                  var parameter = parameters[i];
602                  if (EnableStoredProcedureCompatMode &amp;&amp; parameter.Direction == ParameterDirection.Output)
603                      continue;
604                  if (isFirstParam)
605                      isFirstParam = false;
606                  else
607                      sqlBuilder.Append(&quot;, &quot;);
608                  if (parameter.IsPositional)
609                  {
610                      if (seenNamedParam)
611                          ThrowHelper.ThrowArgumentException(NpgsqlStrings.PositionalParameterAfterNamed);
612                  }
613                  else
614                  {
615                      seenNamedParam = true;
616                      sqlBuilder
617                          .Append(&#x27;&quot;&#x27;)
618                          .Append(parameter.TrimmedName.Replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;))
619                          .Append(&quot;\&quot; := &quot;);
620                  }
621                  if (parameter.Direction == ParameterDirection.Output)
622                      sqlBuilder.Append(&quot;NULL&quot;);
623                  else
624                  {
625                      inputParameters.Add(parameter);
626                      sqlBuilder.Append(&#x27;$&#x27;).Append(inputParameters.Count);
627                  }
628              }
629              sqlBuilder.Append(&#x27;)&#x27;);
630              batchCommand ??= TruncateStatementsToOne();
631              batchCommand.FinalCommandText = sqlBuilder.ToString();
632              batchCommand.PositionalParameters.AddRange(inputParameters);
633              ValidateParameterCount(batchCommand);
634              break;
635          default:
636              ThrowHelper.ThrowArgumentOutOfRangeException(nameof(CommandType), $&quot;Internal Npgsql bug: unexpected value {{0}} of enum {nameof(CommandType)}. Please file a bug.&quot;, commandType);
637              break;
638          }
639          static void ValidateParameterCount(NpgsqlBatchCommand batchCommand)
640          {
641              if (batchCommand.PositionalParameters.Count &gt; ushort.MaxValue)
642                  ThrowHelper.ThrowNpgsqlException(&quot;A statement cannot have more than 65535 parameters&quot;);
643          }
644      }
645      #endregion
646      #region Message Creation / Population
647      void BeginSend(NpgsqlConnector connector)
648          =&gt; connector.WriteBuffer.Timeout = TimeSpan.FromSeconds(CommandTimeout);
649      internal Task Write(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken = default)
650      {
651          return (_behavior &amp; CommandBehavior.SchemaOnly) == 0
652              ? WriteExecute(connector, async, flush, cancellationToken)
653              : WriteExecuteSchemaOnly(connector, async, flush, cancellationToken);
654          async Task WriteExecute(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken)
655          {
656              NpgsqlBatchCommand? batchCommand = null;
657              for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
658              {
659                  ForceAsyncIfNecessary(ref async, i);
660                  batchCommand = InternalBatchCommands[i];
661                  var pStatement = batchCommand.PreparedStatement;
662                  Debug.Assert(batchCommand.FinalCommandText is not null);
663                  if (pStatement == null || batchCommand.IsPreparing)
664                  {
665                      if (pStatement?.StatementBeingReplaced != null)
666                          await connector.WriteClose(StatementOrPortal.Statement, pStatement.StatementBeingReplaced.Name!, async, cancellationToken);
667                      await connector.WriteParse(batchCommand.FinalCommandText, batchCommand.StatementName, batchCommand.PositionalParameters, async, cancellationToken);
668                      await connector.WriteBind(
669                          batchCommand.PositionalParameters, string.Empty, batchCommand.StatementName, AllResultTypesAreUnknown,
670                          i == 0 ? UnknownResultTypeList : null,
671                          async, cancellationToken);
672                      await connector.WriteDescribe(StatementOrPortal.Portal, string.Empty, async, cancellationToken);
673                  }
674                  else
675                  {
676                      await connector.WriteBind(
677                          batchCommand.PositionalParameters, string.Empty, batchCommand.StatementName, AllResultTypesAreUnknown,
678                          i == 0 ? UnknownResultTypeList : null,
679                          async, cancellationToken);
680                  }
681                  await connector.WriteExecute(0, async, cancellationToken);
682                  if (batchCommand.AppendErrorBarrier ?? EnableErrorBarriers)
683                      await connector.WriteSync(async, cancellationToken);
684                  if (pStatement != null)
685                      pStatement.LastUsed = DateTime.UtcNow;
686              }
687              if (batchCommand is null || !(batchCommand.AppendErrorBarrier ?? EnableErrorBarriers))
688              {
689                  await connector.WriteSync(async, cancellationToken);
690              }
691              if (flush)
692                  await connector.Flush(async, cancellationToken);
693          }
<span onclick='openModal()' class='match'>694          async Task WriteExecuteSchemaOnly(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken)
695          {
696              var wroteSomething = false;
</span>697              for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
698              {
699                  ForceAsyncIfNecessary(ref async, i);
700                  var batchCommand = InternalBatchCommands[i];
701                  if (batchCommand.PreparedStatement?.State == PreparedState.Prepared)
702                      continue;   
703                  await connector.WriteParse(batchCommand.FinalCommandText!, batchCommand.StatementName, batchCommand.PositionalParameters, async, cancellationToken);
704                  await connector.WriteDescribe(StatementOrPortal.Statement, batchCommand.StatementName, async, cancellationToken);
705                  wroteSomething = true;
706              }
707              if (wroteSomething)
708              {
709                  await connector.WriteSync(async, cancellationToken);
710                  if (flush)
711                      await connector.Flush(async, cancellationToken);
712              }
713          }
714      }
715      async Task SendDeriveParameters(NpgsqlConnector connector, bool async, CancellationToken cancellationToken = default)
716      {
717          BeginSend(connector);
718          for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
719          {
720              ForceAsyncIfNecessary(ref async, i);
721              var batchCommand = InternalBatchCommands[i];
722              await connector.WriteParse(batchCommand.FinalCommandText!, string.Empty, EmptyParameters, async, cancellationToken);
723              await connector.WriteDescribe(StatementOrPortal.Statement, string.Empty, async, cancellationToken);
724          }
725          await connector.WriteSync(async, cancellationToken);
726          await connector.Flush(async, cancellationToken);
727      }
728      async Task SendPrepare(NpgsqlConnector connector, bool async, CancellationToken cancellationToken = default)
729      {
730          BeginSend(connector);
731          for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
732          {
733              ForceAsyncIfNecessary(ref async, i);
734              var batchCommand = InternalBatchCommands[i];
735              var pStatement = batchCommand.PreparedStatement;
736              if (!batchCommand.IsPreparing)
737                  continue;
738              var statementToClose = pStatement!.StatementBeingReplaced;
739              if (statementToClose != null)
740                  await connector.WriteClose(StatementOrPortal.Statement, statementToClose.Name!, async, cancellationToken);
741              await connector.WriteParse(batchCommand.FinalCommandText!, pStatement.Name!, batchCommand.PositionalParameters, async, cancellationToken);
742              await connector.WriteDescribe(StatementOrPortal.Statement, pStatement.Name!, async, cancellationToken);
743          }
744          await connector.WriteSync(async, cancellationToken);
745          await connector.Flush(async, cancellationToken);
746      }
747      [MethodImpl(MethodImplOptions.AggressiveInlining)]
748      void ForceAsyncIfNecessary(ref bool async, int numberOfStatementInBatch)
749      {
750          if (!async &amp;&amp; numberOfStatementInBatch &gt; 0)
751          {
752              async = true;
753              SynchronizationContext.SetSynchronizationContext(SingleThreadSynchronizationContext);
754          }
755      }
756      async Task SendClose(NpgsqlConnector connector, bool async, CancellationToken cancellationToken = default)
757      {
758          BeginSend(connector);
759          var i = 0;
760          foreach (var batchCommand in InternalBatchCommands.Where(s =&gt; s.IsPrepared))
761          {
762              ForceAsyncIfNecessary(ref async, i);
763              await connector.WriteClose(StatementOrPortal.Statement, batchCommand.StatementName, async, cancellationToken);
764              batchCommand.PreparedStatement!.State = PreparedState.BeingUnprepared;
765              i++;
766          }
767          await connector.WriteSync(async, cancellationToken);
768          await connector.Flush(async, cancellationToken);
769      }
770      #endregion
771      #region Execute Non Query
772      public override int ExecuteNonQuery() =&gt; ExecuteNonQuery(false, CancellationToken.None).GetAwaiter().GetResult();
773      public override Task&lt;int&gt; ExecuteNonQueryAsync(CancellationToken cancellationToken)
774      {
775          using (NoSynchronizationContextScope.Enter())
776              return ExecuteNonQuery(true, cancellationToken);
777      }
778      [MethodImpl(MethodImplOptions.AggressiveInlining)]
779      async Task&lt;int&gt; ExecuteNonQuery(bool async, CancellationToken cancellationToken)
780      {
781          var reader = await ExecuteReader(CommandBehavior.Default, async, cancellationToken);
782          try
783          {
784              while (async ? await reader.NextResultAsync(cancellationToken) : reader.NextResult()) ;
785              return reader.RecordsAffected;
786          }
787          finally
788          {
789              if (async)
790                  await reader.DisposeAsync();
791              else
792                  reader.Dispose();
793          }
794      }
795      #endregion Execute Non Query
796      #region Execute Scalar
797      public override object? ExecuteScalar() =&gt; ExecuteScalar(false, CancellationToken.None).GetAwaiter().GetResult();
798      public override Task&lt;object?&gt; ExecuteScalarAsync(CancellationToken cancellationToken)
799      {
800          using (NoSynchronizationContextScope.Enter())
801              return ExecuteScalar(true, cancellationToken).AsTask();
802      }
803      [MethodImpl(MethodImplOptions.AggressiveInlining)]
804      async ValueTask&lt;object?&gt; ExecuteScalar(bool async, CancellationToken cancellationToken)
805      {
806          var behavior = CommandBehavior.SingleRow;
807          if (IsWrappedByBatch || !Parameters.HasOutputParameters)
808              behavior |= CommandBehavior.SequentialAccess;
809          var reader = await ExecuteReader(behavior, async, cancellationToken);
810          try
811          {
812              var read = async ? await reader.ReadAsync(cancellationToken) : reader.Read();
813              var value = read &amp;&amp; reader.FieldCount != 0 ? reader.GetValue(0) : null;
814              while (async ? await reader.NextResultAsync(cancellationToken) : reader.NextResult()) ;
815              return value;
816          }
817          finally
818          {
819              if (async)
820                  await reader.DisposeAsync();
821              else
822                  reader.Dispose();
823          }
824      }
825      #endregion Execute Scalar
826      #region Execute Reader
827      protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
828          =&gt; ExecuteReader(behavior);
829      protected override async Task&lt;DbDataReader&gt; ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken)
830          =&gt; await ExecuteReaderAsync(behavior, cancellationToken);
831      public new NpgsqlDataReader ExecuteReader(CommandBehavior behavior = CommandBehavior.Default)
832          =&gt; ExecuteReader(behavior, async: false, CancellationToken.None).GetAwaiter().GetResult();
833      public new Task&lt;NpgsqlDataReader&gt; ExecuteReaderAsync(CancellationToken cancellationToken = default)
834          =&gt; ExecuteReaderAsync(CommandBehavior.Default, cancellationToken);
835      public new Task&lt;NpgsqlDataReader&gt; ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken = default)
836      {
837          using (NoSynchronizationContextScope.Enter())
838              return ExecuteReader(behavior, async: true, cancellationToken).AsTask();
839      }
840      internal ManualResetValueTaskSource&lt;NpgsqlConnector&gt; ExecutionCompletion { get; }
841          = new();
842      internal virtual async ValueTask&lt;NpgsqlDataReader&gt; ExecuteReader(CommandBehavior behavior, bool async, CancellationToken cancellationToken)
843      {
844          var conn = CheckAndGetConnection();
845          _behavior = behavior;
846          NpgsqlConnector? connector;
847          if (_connector is not null)
848          {
849              Debug.Assert(conn is null);
850              if (behavior.HasFlag(CommandBehavior.CloseConnection))
851                  ThrowHelper.ThrowArgumentException($&quot;{nameof(CommandBehavior.CloseConnection)} is not supported with {nameof(NpgsqlConnector)}&quot;, nameof(behavior));
852              connector = _connector;
853          }
854          else
855          {
856              Debug.Assert(conn is not null);
857              conn.TryGetBoundConnector(out connector);
858          }
859          try
860          {
861              if (connector is not null)
862              {
863                  var dataSource = connector.DataSource;
864                  var logger = connector.CommandLogger;
865                  cancellationToken.ThrowIfCancellationRequested();
866                  connector.StartUserAction(ConnectorState.Executing, this, CancellationToken.None);
867                  Task? sendTask;
868                  var validateParameterValues = !behavior.HasFlag(CommandBehavior.SchemaOnly);
869                  try
870                  {
871                      switch (IsExplicitlyPrepared)
872                      {
873                      case true:
874                          Debug.Assert(_connectorPreparedOn != null);
875                          if (IsWrappedByBatch)
876                          {
877                              foreach (var batchCommand in InternalBatchCommands)
878                              {
879                                  if (batchCommand.ConnectorPreparedOn != connector)
880                                  {
881                                      foreach (var s in InternalBatchCommands)
882                                          s.ResetPreparation();
883                                      ResetPreparation();
884                                      goto case false;
885                                  }
886                                  batchCommand.Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
887                              }
888                          }
889                          else
890                          {
891                              if (_connectorPreparedOn != connector)
892                              {
893                                  foreach (var s in InternalBatchCommands)
894                                      s.PreparedStatement = null;
895                                  ResetPreparation();
896                                  goto case false;
897                              }
898                              Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
899                          }
900                          NpgsqlEventSource.Log.CommandStartPrepared();
901                          break;
902                      case false:
903                          var numPrepared = 0;
904                          if (IsWrappedByBatch)
905                          {
906                              for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
907                              {
908                                  var batchCommand = InternalBatchCommands[i];
909                                  batchCommand.Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
910                                  ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand);
911                                  if (connector.Settings.MaxAutoPrepare &gt; 0 &amp;&amp; batchCommand.TryAutoPrepare(connector))
912                                  {
913                                      batchCommand.ConnectorPreparedOn = connector;
914                                      numPrepared++;
915                                  }
916                              }
917                          }
918                          else
919                          {
920                              Parameters.ProcessParameters(dataSource.TypeMapper, validateParameterValues, CommandType);
921                              ProcessRawQuery(connector.SqlQueryParser, connector.UseConformingStrings, batchCommand: null);
922                              if (connector.Settings.MaxAutoPrepare &gt; 0)
923                                  for (var i = 0; i &lt; InternalBatchCommands.Count; i++)
924                                      if (InternalBatchCommands[i].TryAutoPrepare(connector))
925                                          numPrepared++;
926                          }
927                          if (numPrepared &gt; 0)
928                          {
929                              _connectorPreparedOn = connector;
930                              if (numPrepared == InternalBatchCommands.Count)
931                                  NpgsqlEventSource.Log.CommandStartPrepared();
932                          }
933                          break;
934                      }
935                      State = CommandState.InProgress;
936                      if (logger.IsEnabled(LogLevel.Information))
937                      {
938                          connector.QueryLogStopWatch.Restart();
939                          if (logger.IsEnabled(LogLevel.Debug))
940                              LogExecutingCompleted(connector, executing: true);
941                      }
942                      NpgsqlEventSource.Log.CommandStart(CommandText);
943                      TraceCommandStart(connector);
944                      connector.ResetCancellation();
945                      BeginSend(connector);
946                      sendTask = Write(connector, async, flush: true, CancellationToken.None);
947                      if (sendTask.IsFaulted)
948                          sendTask.GetAwaiter().GetResult();
949                  }
950                  catch
951                  {
952                      connector.EndUserAction();
953                      throw;
954                  }
955                  var reader = connector.DataReader;
956                  reader.Init(this, behavior, InternalBatchCommands, sendTask);
957                  connector.CurrentReader = reader;
958                  if (async)
959                      await reader.NextResultAsync(cancellationToken);
960                  else
961                      reader.NextResult();
962                  TraceReceivedFirstResponse();
963                  return reader;
964              }
965              else
966              {
967                  Debug.Assert(conn is not null);
968                  Debug.Assert(conn.Settings.Multiplexing);
969                  var dataSource = (MultiplexingDataSource)conn.NpgsqlDataSource;
970                  if (!async)
971                  {
972                      ThrowHelper.ThrowNotSupportedException(&quot;Synchronous command execution is not supported when multiplexing is on&quot;);
973                  }
974                  if (IsWrappedByBatch)
975                  {
976                      foreach (var batchCommand in InternalBatchCommands)
977                      {
978                          batchCommand.Parameters.ProcessParameters(dataSource.TypeMapper, validateValues: true, CommandType);
979                          ProcessRawQuery(null, standardConformingStrings: true, batchCommand);
980                      }
981                  }
982                  else
983                  {
984                      Parameters.ProcessParameters(dataSource.TypeMapper, validateValues: true, CommandType);
985                      ProcessRawQuery(null, standardConformingStrings: true, batchCommand: null);
986                  }
987                  State = CommandState.InProgress;
988                  ExecutionCompletion.Reset();
989                  try
990                  {
991                      await dataSource.MultiplexCommandWriter.WriteAsync(this, cancellationToken);
992                  }
993                  catch (ChannelClosedException ex)
994                  {
995                      Debug.Assert(ex.InnerException is not null);
996                      throw ex.InnerException;
997                  }
998                  connector = await new ValueTask&lt;NpgsqlConnector&gt;(ExecutionCompletion, ExecutionCompletion.Version);
999                  conn.Connector = connector;
1000                  connector.Connection = conn;
1001                  conn.ConnectorBindingScope = ConnectorBindingScope.Reader;
1002                  var reader = connector.DataReader;
1003                  reader.Init(this, behavior, InternalBatchCommands);
1004                  connector.CurrentReader = reader;
1005                  await reader.NextResultAsync(cancellationToken);
1006                  return reader;
1007              }
1008          }
1009          catch (Exception e)
1010          {
1011              var reader = connector?.CurrentReader;
1012              if (e is not NpgsqlOperationInProgressException &amp;&amp; reader is not null)
1013                  await reader.Cleanup(async);
1014              TraceSetException(e);
1015              State = CommandState.Idle;
1016              if ((behavior &amp; CommandBehavior.CloseConnection) == CommandBehavior.CloseConnection)
1017              {
1018                  Debug.Assert(_connector is null &amp;&amp; conn is not null);
1019                  conn.Close();
1020              }
1021              throw;
1022          }
1023      }
1024      #endregion
1025      #region Transactions
1026      protected override DbTransaction? DbTransaction
1027      {
1028          get =&gt; _transaction;
1029          set =&gt; _transaction = (NpgsqlTransaction?)value;
1030      }
1031      public new NpgsqlTransaction? Transaction
1032      {
1033          get =&gt; (NpgsqlTransaction?)DbTransaction;
1034          set =&gt; DbTransaction = value;
1035      }
1036      #endregion Transactions
1037      #region Cancel
1038      public override void Cancel()
1039      {
1040          if (State != CommandState.InProgress)
1041              return;
1042          var connector = Connection?.Connector ?? _connector;
1043          if (connector is null)
1044              return;
1045          connector.PerformUserCancellation();
1046      }
1047      #endregion Cancel
1048      #region Dispose
1049      protected override void Dispose(bool disposing)
1050      {
1051          ResetTransaction();
1052          State = CommandState.Disposed;
1053          if (IsCacheable &amp;&amp; InternalConnection is not null &amp;&amp; InternalConnection.CachedCommand is null)
1054          {
1055              Reset();
1056              InternalConnection.CachedCommand = this;
1057              return;
1058          }
1059          IsCacheable = false;
1060      }
1061      internal void Reset()
1062      {
1063          _commandText = string.Empty;
1064          CommandType = CommandType.Text;
1065          _parameters.Clear();
1066          _timeout = null;
1067          _allResultTypesAreUnknown = false;
1068          EnableErrorBarriers = false;
1069      }
1070      internal void ResetTransaction() =&gt; _transaction = null;
1071      #endregion
1072      #region Tracing
1073      internal void TraceCommandStart(NpgsqlConnector connector)
1074      {
1075          Debug.Assert(CurrentActivity is null);
1076          if (NpgsqlActivitySource.IsEnabled)
1077              CurrentActivity = NpgsqlActivitySource.CommandStart(connector, CommandText, CommandType);
1078      }
1079      internal void TraceReceivedFirstResponse()
1080      {
1081          if (CurrentActivity is not null)
1082          {
1083              NpgsqlActivitySource.ReceivedFirstResponse(CurrentActivity);
1084          }
1085      }
1086      internal void TraceCommandStop()
1087      {
1088          if (CurrentActivity is not null)
1089          {
1090              NpgsqlActivitySource.CommandStop(CurrentActivity);
1091              CurrentActivity = null;
1092          }
1093      }
1094      internal void TraceSetException(Exception e)
1095      {
1096          if (CurrentActivity is not null)
1097          {
1098              NpgsqlActivitySource.SetException(CurrentActivity, e);
1099              CurrentActivity = null;
1100          }
1101      }
1102      #endregion Tracing
1103      #region Misc
1104      NpgsqlBatchCommand TruncateStatementsToOne()
1105      {
1106          switch (InternalBatchCommands.Count)
1107          {
1108          case 0:
1109              var statement = new NpgsqlBatchCommand();
1110              InternalBatchCommands.Add(statement);
1111              return statement;
1112          case 1:
1113              statement = InternalBatchCommands[0];
1114              statement.Reset();
1115              return statement;
1116          default:
1117              statement = InternalBatchCommands[0];
1118              statement.Reset();
1119              InternalBatchCommands.Clear();
1120              InternalBatchCommands.Add(statement);
1121              return statement;
1122          }
1123      }
1124      internal void FixupRowDescription(RowDescriptionMessage rowDescription, bool isFirst)
1125      {
1126          for (var i = 0; i &lt; rowDescription.Count; i++)
1127          {
1128              var field = rowDescription[i];
1129              field.FormatCode = (UnknownResultTypeList == null || !isFirst ? AllResultTypesAreUnknown : UnknownResultTypeList[i])
1130                  ? FormatCode.Text
1131                  : FormatCode.Binary;
1132              field.ResolveHandler();
1133          }
1134      }
1135      internal void LogExecutingCompleted(NpgsqlConnector connector, bool executing)
1136      {
1137          var logParameters = connector.LoggingConfiguration.IsParameterLoggingEnabled || connector.Settings.LogParameters;
1138          var logger = connector.LoggingConfiguration.CommandLogger;
1139          if (InternalBatchCommands.Count == 1)
1140          {
1141              var singleCommand = InternalBatchCommands[0];
1142              if (logParameters &amp;&amp; singleCommand.PositionalParameters.Count &gt; 0)
1143              {
1144                  if (executing)
1145                  {
1146                      LogMessages.ExecutingCommandWithParameters(
1147                          logger,
1148                          singleCommand.FinalCommandText!,
1149                          singleCommand.PositionalParameters.Select(p =&gt; p.Value == DBNull.Value ? &quot;NULL&quot; : p.Value!).ToArray(),
1150                          connector.Id);
1151                  }
1152                  else
1153                  {
1154                      LogMessages.CommandExecutionCompletedWithParameters(
1155                          logger,
1156                          singleCommand.FinalCommandText!,
1157                          singleCommand.PositionalParameters.Select(p =&gt; p.Value == DBNull.Value ? &quot;NULL&quot; : p.Value!).ToArray(),
1158                          connector.QueryLogStopWatch.ElapsedMilliseconds,
1159                          connector.Id);
1160                  }
1161              }
1162              else
1163              {
1164                  if (executing)
1165                      LogMessages.ExecutingCommand(logger, singleCommand.FinalCommandText!, connector.Id);
1166                  else
1167                      LogMessages.CommandExecutionCompleted(logger, singleCommand.FinalCommandText!, connector.QueryLogStopWatch.ElapsedMilliseconds, connector.Id);
1168              }
1169          }
1170          else
1171          {
1172              if (logParameters)
1173              {
1174                  var commands = InternalBatchCommands
1175                      .Select(c =&gt; (
1176                          c.CommandText,
1177                          Parameters: (object[]?)c.PositionalParameters.Select(p =&gt; p.Value == DBNull.Value ? &quot;NULL&quot; : p.Value).ToArray()!)
1178                      ).ToArray();
1179                  if (executing)
1180                      LogMessages.ExecutingBatchWithParameters(logger, commands, connector.Id);
1181                  else
1182                      LogMessages.BatchExecutionCompletedWithParameters(logger, commands, connector.QueryLogStopWatch.ElapsedMilliseconds, connector.Id);
1183              }
1184              else
1185              {
1186                  var commands = InternalBatchCommands.Select(c =&gt; c.CommandText).ToArray().ToArray();
1187                  if (executing)
1188                      LogMessages.ExecutingBatch(logger, commands, connector.Id);
1189                  else
1190                      LogMessages.BatchExecutionCompleted(logger, commands, connector.QueryLogStopWatch.ElapsedMilliseconds, connector.Id);
1191              }
1192          }
1193      }
1194      object ICloneable.Clone() =&gt; Clone();
1195      public virtual NpgsqlCommand Clone()
1196      {
1197          var clone = new NpgsqlCommand(CommandText, InternalConnection, Transaction)
1198          {
1199              CommandTimeout = CommandTimeout, CommandType = CommandType, DesignTimeVisible = DesignTimeVisible, _allResultTypesAreUnknown = _allResultTypesAreUnknown, _unknownResultTypeList = _unknownResultTypeList, ObjectResultTypes = ObjectResultTypes
1200          };
1201          _parameters.CloneTo(clone._parameters);
1202          return clone;
1203      }
1204      NpgsqlConnection? CheckAndGetConnection()
1205      {
1206          if (State == CommandState.Disposed)
1207              ThrowHelper.ThrowObjectDisposedException(GetType().FullName);
1208          if (InternalConnection == null)
1209          {
1210              if (_connector is null)
1211                  ThrowHelper.ThrowInvalidOperationException(&quot;Connection property has not been initialized.&quot;);
1212              return null;
1213          }
1214          switch (InternalConnection.FullState)
1215          {
1216          case ConnectionState.Open:
1217          case ConnectionState.Connecting:
1218          case ConnectionState.Open | ConnectionState.Executing:
1219          case ConnectionState.Open | ConnectionState.Fetching:
1220              return InternalConnection;
1221          default:
1222              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is not open&quot;);
1223              return null;
1224          }
1225      }
1226      [EditorBrowsable(EditorBrowsableState.Never)]
1227      public new event EventHandler? Disposed
1228      {
1229          add =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1230          remove =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1231      }
1232      event EventHandler? IComponent.Disposed
1233      {
1234          add =&gt; Disposed += value;
1235          remove =&gt; Disposed -= value;
1236      }
1237      #endregion
1238  }
1239  enum CommandState
1240  {
1241      Idle,
1242      InProgress,
1243      Disposed
1244  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlCommand.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlCommand.cs</div>
                </div>
                <div class="column column_space"><pre><code>654          async Task WriteExecute(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken)
655          {
656              NpgsqlBatchCommand? batchCommand = null;
</pre></code></div>
                <div class="column column_space"><pre><code>694          async Task WriteExecuteSchemaOnly(NpgsqlConnector connector, bool async, bool flush, CancellationToken cancellationToken)
695          {
696              var wroteSomething = false;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    