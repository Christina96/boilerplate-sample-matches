
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.25133689839572%, Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlDataSource.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Data.Common;
4  using System.Diagnostics;
5  using System.Diagnostics.CodeAnalysis;
6  using System.Net.Security;
7  using System.Security.Cryptography.X509Certificates;
8  using System.Threading;
9  using System.Threading.Tasks;
10  using System.Transactions;
11  using Microsoft.Extensions.Logging;
12  using Npgsql.Internal;
13  using Npgsql.Internal.TypeHandling;
14  using Npgsql.Internal.TypeMapping;
15  using Npgsql.Properties;
16  using Npgsql.Util;
17  namespace Npgsql;
18  public abstract class NpgsqlDataSource : DbDataSource
19  {
20      public override string ConnectionString { get; }
21      internal NpgsqlConnectionStringBuilder Settings { get; }
22      internal NpgsqlDataSourceConfiguration Configuration { get; }
23      internal NpgsqlLoggingConfiguration LoggingConfiguration { get; }
24      readonly List<TypeHandlerResolverFactory> _resolverFactories;
25      readonly Dictionary<string, IUserTypeMapping> _userTypeMappings;
26      readonly INpgsqlNameTranslator _defaultNameTranslator;
<span onclick='openModal()' class='match'>27      internal TypeMapper TypeMapper { get; private set; } = null!; 
28      internal NpgsqlDatabaseInfo DatabaseInfo { get; private set; } = null!; 
29      internal EncryptionHandler EncryptionHandler { get; }
</span>30      internal RemoteCertificateValidationCallback? UserCertificateValidationCallback { get; }
31      internal Action<X509CertificateCollection>? ClientCertificatesCallback { get; }
32      readonly Func<NpgsqlConnectionStringBuilder, CancellationToken, ValueTask<string>>? _periodicPasswordProvider;
33      readonly TimeSpan _periodicPasswordSuccessRefreshInterval, _periodicPasswordFailureRefreshInterval;
34      internal Action<NpgsqlConnection>? ConnectionInitializer { get; }
35      internal Func<NpgsqlConnection, Task>? ConnectionInitializerAsync { get; }
36      readonly Timer? _passwordProviderTimer;
37      readonly CancellationTokenSource? _timerPasswordProviderCancellationTokenSource;
38      readonly Task _passwordRefreshTask = null!;
39      string? _password;
40      bool _isBootstrapped;
41      volatile DatabaseStateInfo _databaseStateInfo = new();
42      private protected readonly Dictionary<Transaction, List<NpgsqlConnector>> _pendingEnlistedConnectors
43          = new();
44      internal abstract (int Total, int Idle, int Busy) Statistics { get; }
45      volatile int _isDisposed;
46      readonly ILogger _connectionLogger;
47      readonly SemaphoreSlim _setupMappingsSemaphore = new(1);
48      internal NpgsqlDataSource(
49          NpgsqlConnectionStringBuilder settings,
50          NpgsqlDataSourceConfiguration dataSourceConfig)
51      {
52          Settings = settings;
53          ConnectionString = settings.PersistSecurityInfo
54              ? settings.ToString()
55              : settings.ToStringWithoutPassword();
56          Configuration = dataSourceConfig;
57          (LoggingConfiguration,
58                  EncryptionHandler,
59                  UserCertificateValidationCallback,
60                  ClientCertificatesCallback,
61                  _periodicPasswordProvider,
62                  _periodicPasswordSuccessRefreshInterval,
63                  _periodicPasswordFailureRefreshInterval,
64                  _resolverFactories,
65                  _userTypeMappings,
66                  _defaultNameTranslator,
67                  ConnectionInitializer,
68                  ConnectionInitializerAsync)
69              = dataSourceConfig;
70          _connectionLogger = LoggingConfiguration.ConnectionLogger;
71          _password = settings.Password;
72          if (_periodicPasswordSuccessRefreshInterval != default)
73          {
74              Debug.Assert(_periodicPasswordProvider is not null);
75              _timerPasswordProviderCancellationTokenSource = new();
76              _passwordProviderTimer = new Timer(state => _ = RefreshPassword(), null, Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
77              _passwordRefreshTask = Task.Run(RefreshPassword);
78          }
79      }
80      public new NpgsqlConnection CreateConnection()
81          => NpgsqlConnection.FromDataSource(this);
82      public new NpgsqlConnection OpenConnection()
83      {
84          var connection = CreateConnection();
85          try
86          {
87              connection.Open();
88              return connection;
89          }
90          catch
91          {
92              connection.Dispose();
93              throw;
94          }
95      }
96      protected override DbConnection OpenDbConnection()
97          => OpenConnection();
98      public new async ValueTask<NpgsqlConnection> OpenConnectionAsync(CancellationToken cancellationToken = default)
99      {
100          var connection = CreateConnection();
101          try
102          {
103              await connection.OpenAsync(cancellationToken).ConfigureAwait(false);
104              return connection;
105          }
106          catch
107          {
108              await connection.DisposeAsync().ConfigureAwait(false);
109              throw;
110          }
111      }
112      protected override async ValueTask<DbConnection> OpenDbConnectionAsync(CancellationToken cancellationToken = default)
113          => await OpenConnectionAsync(cancellationToken);
114      protected override DbConnection CreateDbConnection()
115          => CreateConnection();
116      protected override DbCommand CreateDbCommand(string? commandText = null)
117          => CreateCommand(commandText);
118      protected override DbBatch CreateDbBatch()
119          => CreateBatch();
120      public new NpgsqlCommand CreateCommand(string? commandText = null)
121          => new NpgsqlDataSourceCommand(CreateConnection()) { CommandText = commandText };
122      public new NpgsqlBatch CreateBatch()
123          => new NpgsqlDataSourceBatch(CreateConnection());
124      public static NpgsqlDataSource Create(string connectionString)
125          => new NpgsqlDataSourceBuilder(connectionString).Build();
126      public static NpgsqlDataSource Create(NpgsqlConnectionStringBuilder connectionStringBuilder)
127          => Create(connectionStringBuilder.ToString());
128      internal async Task Bootstrap(
129          NpgsqlConnector connector,
130          NpgsqlTimeout timeout,
131          bool forceReload,
132          bool async,
133          CancellationToken cancellationToken)
134      {
135          if (_isBootstrapped && !forceReload)
136              return;
137          var hasSemaphore = async
138              ? await _setupMappingsSemaphore.WaitAsync(timeout.CheckAndGetTimeLeft(), cancellationToken)
139              : _setupMappingsSemaphore.Wait(timeout.CheckAndGetTimeLeft(), cancellationToken);
140          if (!hasSemaphore)
141              throw new TimeoutException();
142          try
143          {
144              if (_isBootstrapped && !forceReload)
145                  return;
146              var typeMapper = new TypeMapper(connector, _defaultNameTranslator);
147              connector.TypeMapper = typeMapper;
148              NpgsqlDatabaseInfo databaseInfo;
149              using (connector.StartUserAction(ConnectorState.Executing, cancellationToken))
150                  databaseInfo = await NpgsqlDatabaseInfo.Load(connector, timeout, async);
151              DatabaseInfo = databaseInfo;
152              connector.DatabaseInfo = databaseInfo;
153              typeMapper.Initialize(databaseInfo, _resolverFactories, _userTypeMappings);
154              TypeMapper = typeMapper;
155              _isBootstrapped = true;
156          }
157          finally
158          {
159              _setupMappingsSemaphore.Release();
160          }
161      }
162      #region Password management
163      public string Password
164      {
165          set
166          {
167              if (_periodicPasswordProvider is not null)
168                  throw new NotSupportedException(NpgsqlStrings.CannotSetBothPasswordProviderAndPassword);
169              _password = value;
170          }
171      }
172      internal async ValueTask<string?> GetPassword(bool async, CancellationToken cancellationToken = default)
173      {
174          if (_password is null && _periodicPasswordProvider is not null)
175          {
176              if (async)
177                  await _passwordRefreshTask;
178              else
179                  _passwordRefreshTask.GetAwaiter().GetResult();
180              Debug.Assert(_password is not null);
181          }
182          return _password;
183      }
184      async Task RefreshPassword()
185      {
186          try
187          {
188              _password = await _periodicPasswordProvider!(Settings, _timerPasswordProviderCancellationTokenSource!.Token);
189              _passwordProviderTimer!.Change(_periodicPasswordSuccessRefreshInterval, Timeout.InfiniteTimeSpan);
190          }
191          catch (Exception e)
192          {
193              _connectionLogger.LogError(e, "Periodic password provider threw an exception");
194              _passwordProviderTimer!.Change(_periodicPasswordFailureRefreshInterval, Timeout.InfiniteTimeSpan);
195              throw new NpgsqlException("An exception was thrown from the periodic password provider", e);
196          }
197      }
198      #endregion Password management
199      internal abstract ValueTask<NpgsqlConnector> Get(
200          NpgsqlConnection conn, NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken);
201      internal abstract bool TryGetIdleConnector([NotNullWhen(true)] out NpgsqlConnector? connector);
202      internal abstract ValueTask<NpgsqlConnector?> OpenNewConnector(
203          NpgsqlConnection conn, NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken);
204      internal abstract void Return(NpgsqlConnector connector);
205      internal abstract void Clear();
206      internal abstract bool OwnsConnectors { get; }
207      #region Database state management
208      internal DatabaseState GetDatabaseState(bool ignoreExpiration = false)
209      {
210          Debug.Assert(this is not NpgsqlMultiHostDataSource);
211          var databaseStateInfo = _databaseStateInfo;
212          return ignoreExpiration || !databaseStateInfo.Timeout.HasExpired
213              ? databaseStateInfo.State
214              : DatabaseState.Unknown;
215      }
216      internal DatabaseState UpdateDatabaseState(
217          DatabaseState newState,
218          DateTime timeStamp,
219          TimeSpan stateExpiration,
220          bool ignoreTimeStamp = false)
221      {
222          Debug.Assert(this is not NpgsqlMultiHostDataSource);
223          var databaseStateInfo = _databaseStateInfo;
224          if (!ignoreTimeStamp && timeStamp <= databaseStateInfo.TimeStamp)
225              return _databaseStateInfo.State;
226          _databaseStateInfo = new(newState, new NpgsqlTimeout(stateExpiration), timeStamp);
227          return newState;
228      }
229      #endregion Database state management
230      #region Pending Enlisted Connections
231      internal virtual void AddPendingEnlistedConnector(NpgsqlConnector connector, Transaction transaction)
232      {
233          lock (_pendingEnlistedConnectors)
234          {
235              if (!_pendingEnlistedConnectors.TryGetValue(transaction, out var list))
236                  list = _pendingEnlistedConnectors[transaction] = new List<NpgsqlConnector>(1);
237              list.Add(connector);
238          }
239      }
240      internal virtual bool TryRemovePendingEnlistedConnector(NpgsqlConnector connector, Transaction transaction)
241      {
242          lock (_pendingEnlistedConnectors)
243          {
244              if (!_pendingEnlistedConnectors.TryGetValue(transaction, out var list))
245                  return false;
246              list.Remove(connector);
247              if (list.Count == 0)
248                  _pendingEnlistedConnectors.Remove(transaction);
249              return true;
250          }
251      }
252      internal virtual bool TryRentEnlistedPending(Transaction transaction, NpgsqlConnection connection,
253          [NotNullWhen(true)] out NpgsqlConnector? connector)
254      {
255          lock (_pendingEnlistedConnectors)
256          {
257              if (!_pendingEnlistedConnectors.TryGetValue(transaction, out var list))
258              {
259                  connector = null;
260                  return false;
261              }
262              connector = list[list.Count - 1];
263              list.RemoveAt(list.Count - 1);
264              if (list.Count == 0)
265                  _pendingEnlistedConnectors.Remove(transaction);
266              return true;
267          }
268      }
269      #endregion
270      #region Dispose
271      protected sealed override void Dispose(bool disposing)
272      {
273          if (disposing && Interlocked.CompareExchange(ref _isDisposed, 1, 0) == 0)
274              DisposeBase();
275      }
276      protected virtual void DisposeBase()
277      {
278          var cancellationTokenSource = _timerPasswordProviderCancellationTokenSource;
279          if (cancellationTokenSource is not null)
280          {
281              cancellationTokenSource.Cancel();
282              cancellationTokenSource.Dispose();
283          }
284          _passwordProviderTimer?.Dispose();
285          _setupMappingsSemaphore.Dispose();
286          Clear();
287      }
288      protected sealed override ValueTask DisposeAsyncCore()
289      {
290          if (Interlocked.CompareExchange(ref _isDisposed, 1, 0) == 0)
291              return DisposeAsyncBase();
292          return default;
293      }
294  #pragma warning disable CS1998
295      protected virtual async ValueTask DisposeAsyncBase()
296      {
297          var cancellationTokenSource = _timerPasswordProviderCancellationTokenSource;
298          if (cancellationTokenSource is not null)
299          {
300              cancellationTokenSource.Cancel();
301              cancellationTokenSource.Dispose();
302          }
303          if (_passwordProviderTimer is not null)
304          {
305  #if NET5_0_OR_GREATER
306              await _passwordProviderTimer.DisposeAsync();
307  #else
308              _passwordProviderTimer.Dispose();
309  #endif
310          }
311          _setupMappingsSemaphore.Dispose();
312          Clear();
313      }
314  #pragma warning restore CS1998
315      private protected void CheckDisposed()
316      {
317          if (_isDisposed == 1)
318              ThrowHelper.ThrowObjectDisposedException(GetType().FullName);
319      }
320      #endregion
321      sealed class DatabaseStateInfo
322      {
323          internal readonly DatabaseState State;
324          internal readonly NpgsqlTimeout Timeout;
325          internal readonly DateTime TimeStamp;
326          public DatabaseStateInfo() : this(default, default, default) {}
327          public DatabaseStateInfo(DatabaseState state, NpgsqlTimeout timeout, DateTime timeStamp)
328              => (State, Timeout, TimeStamp) = (state, timeout, timeStamp);
329      }
330  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-RemoteAuthenticationOptions.cs</h3>
            <pre><code>1  using System;
2  using System.Net.Http;
3  using Microsoft.AspNetCore.Authentication.Internal;
4  using Microsoft.AspNetCore.DataProtection;
5  using Microsoft.AspNetCore.Http;
6  namespace Microsoft.AspNetCore.Authentication
7  {
8      public class RemoteAuthenticationOptions : AuthenticationSchemeOptions
9      {
10          private const string CorrelationPrefix = ".AspNetCore.Correlation.";
11          private CookieBuilder _correlationCookieBuilder;
12          public RemoteAuthenticationOptions()
13          {
14              _correlationCookieBuilder = new CorrelationCookieBuilder(this)
15              {
16                  Name = CorrelationPrefix,
17                  HttpOnly = true,
18                  SameSite = SameSiteMode.None,
19                  SecurePolicy = CookieSecurePolicy.SameAsRequest,
20                  IsEssential = true,
21              };
22          }
23          public override void Validate(string scheme)
24          {
25              base.Validate(scheme);
26              if (string.Equals(scheme, SignInScheme, StringComparison.Ordinal))
27              {
28                  throw new InvalidOperationException(Resources.Exception_RemoteSignInSchemeCannotBeSelf);
29              }
30          }
31          public override void Validate()
32          {
33              base.Validate();
34              if (CallbackPath == null || !CallbackPath.HasValue)
35              {
36                  throw new ArgumentException(Resources.FormatException_OptionMustBeProvided(nameof(CallbackPath)), nameof(CallbackPath));
37              }
38          }
39          public TimeSpan BackchannelTimeout { get; set; } = TimeSpan.FromSeconds(60);
<span onclick='openModal()' class='match'>40          public HttpMessageHandler BackchannelHttpHandler { get; set; }
41          public HttpClient Backchannel { get; set; }
42          public IDataProtectionProvider DataProtectionProvider { get; set; }
</span>43          public PathString CallbackPath { get; set; }
44          public PathString AccessDeniedPath { get; set; }
45          public string ReturnUrlParameter { get; set; } = "ReturnUrl";
46          public string SignInScheme { get; set; }
47          public TimeSpan RemoteAuthenticationTimeout { get; set; } = TimeSpan.FromMinutes(15);
48          public new RemoteAuthenticationEvents Events
49          {
50              get => (RemoteAuthenticationEvents)base.Events;
51              set => base.Events = value;
52          }
53          public bool SaveTokens { get; set; }
54          public CookieBuilder CorrelationCookie
55          {
56              get => _correlationCookieBuilder;
57              set => _correlationCookieBuilder = value ?? throw new ArgumentNullException(nameof(value));
58          }
59          private class CorrelationCookieBuilder : RequestPathBaseCookieBuilder
60          {
61              private readonly RemoteAuthenticationOptions _options;
62              public CorrelationCookieBuilder(RemoteAuthenticationOptions remoteAuthenticationOptions)
63              {
64                  _options = remoteAuthenticationOptions;
65              }
66              protected override string AdditionalPath => _options.CallbackPath;
67              public override CookieOptions Build(HttpContext context, DateTimeOffset expiresFrom)
68              {
69                  var cookieOptions = base.Build(context, expiresFrom);
70                  if (!Expiration.HasValue || !cookieOptions.Expires.HasValue)
71                  {
72                      cookieOptions.Expires = expiresFrom.Add(_options.RemoteAuthenticationTimeout);
73                  }
74                  return cookieOptions;
75              }
76          }
77      }
78  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlDataSource.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-RemoteAuthenticationOptions.cs</div>
                </div>
                <div class="column column_space"><pre><code>27      internal TypeMapper TypeMapper { get; private set; } = null!; 
28      internal NpgsqlDatabaseInfo DatabaseInfo { get; private set; } = null!; 
29      internal EncryptionHandler EncryptionHandler { get; }
</pre></code></div>
                <div class="column column_space"><pre><code>40          public HttpMessageHandler BackchannelHttpHandler { get; set; }
41          public HttpClient Backchannel { get; set; }
42          public IDataProtectionProvider DataProtectionProvider { get; set; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    