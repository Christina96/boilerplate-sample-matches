
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpRequest.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Text;
5  namespace NetCoreServer
6  {
7      public class HttpRequest
8      {
9          public HttpRequest()
10          {
11              Clear();
12          }
13          public HttpRequest(string method, string url, string protocol = "HTTP/1.1")
14          {
15              SetBegin(method, url, protocol);
16          }
17          public bool IsEmpty { get { return (_cache.Size == 0); } }
18          public bool IsErrorSet { get; private set; }
19          public string Method { get { return _method; } }
20          public string Url { get { return _url; } }
21          public string Protocol { get { return _protocol; } }
22          public long Headers { get { return _headers.Count; } }
23          public (string, string) Header(int i)
24          {
25              Debug.Assert((i < _headers.Count), "Index out of bounds!");
26              if (i >= _headers.Count)
27                  return ("", "");
28              return _headers[i];
29          }
30          public long Cookies { get { return _cookies.Count; } }
31          public (string, string) Cookie(int i)
32          {
33              Debug.Assert((i < _cookies.Count), "Index out of bounds!");
34              if (i >= _cookies.Count)
35                  return ("", "");
36              return _cookies[i];
37          }
38          public string Body { get { return _cache.ExtractString(_bodyIndex, _bodySize); } }
39          public byte[] BodyBytes { get { return _cache.Data[_bodyIndex..(_bodyIndex + _bodySize)]; } }
40          public Span<byte> BodySpan { get { return new Span<byte>(_cache.Data, _bodyIndex, _bodySize); } }
41          public long BodyLength { get { return _bodyLength; } }
42          public Buffer Cache { get { return _cache; } }
43          public override string ToString()
44          {
45              StringBuilder sb = new StringBuilder();
46              sb.AppendLine($"Request method: {Method}");
47              sb.AppendLine($"Request URL: {Url}");
48              sb.AppendLine($"Request protocol: {Protocol}");
49              sb.AppendLine($"Request headers: {Headers}");
50              for (int i = 0; i < Headers; i++)
51              {
52                  var header = Header(i);
53                  sb.AppendLine($"{header.Item1} : {header.Item2}");
54              }
55              sb.AppendLine($"Request body: {BodyLength}");
56              sb.AppendLine(Body);
57              return sb.ToString();
58          }
59          public HttpRequest Clear()
60          {
61              IsErrorSet = false;
62              _method = "";
63              _url = "";
64              _protocol = "";
65              _headers.Clear();
66              _cookies.Clear();
67              _bodyIndex = 0;
68              _bodySize = 0;
69              _bodyLength = 0;
70              _bodyLengthProvided = false;
71              _cache.Clear();
72              _cacheSize = 0;
73              return this;
74          }
75          public HttpRequest SetBegin(string method, string url, string protocol = "HTTP/1.1")
76          {
77              Clear();
78              _cache.Append(method);
79              _method = method;
80              _cache.Append(" ");
81              _cache.Append(url);
82              _url = url;
83              _cache.Append(" ");
84              _cache.Append(protocol);
85              _protocol = protocol;
86              _cache.Append("\r\n");
87              return this;
88          }
89          public HttpRequest SetHeader(string key, string value)
90          {
91              _cache.Append(key);
92              _cache.Append(": ");
93              _cache.Append(value);
94              _cache.Append("\r\n");
95              _headers.Add((key, value));
96              return this;
97          }
98          public HttpRequest SetCookie(string name, string value)
99          {
100              string key = "Cookie";
101              string cookie = name + "=" + value;
102              _cache.Append(key);
103              _cache.Append(": ");
104              _cache.Append(cookie);
105              _cache.Append("\r\n");
106              _headers.Add((key, cookie));
107              _cookies.Add((name, value));
108              return this;
109          }
110          public HttpRequest AddCookie(string name, string value)
111          {
112              _cache.Append("; ");
113              _cache.Append(name);
114              _cache.Append("=");
115              _cache.Append(value);
116              _cookies.Add((name, value));
117              return this;
118          }
119          public HttpRequest SetBody(string body = "") => SetBody(body.AsSpan());
120          public HttpRequest SetBody(ReadOnlySpan<char> body)
121          {
122              int length = body.IsEmpty ? 0 : Encoding.UTF8.GetByteCount(body);
123              SetHeader("Content-Length", length.ToString());
124              _cache.Append("\r\n");
125              int index = (int)_cache.Size;
126              _cache.Append(body);
127              _bodyIndex = index;
128              _bodySize = length;
129              _bodyLength = length;
130              _bodyLengthProvided = true;
131              return this;
132          }
133          public HttpRequest SetBody(byte[] body) => SetBody(body.AsSpan());
134          public HttpRequest SetBody(ReadOnlySpan<byte> body)
135          {
136              SetHeader("Content-Length", body.Length.ToString());
137              _cache.Append("\r\n");
138              int index = (int)_cache.Size;
139              _cache.Append(body);
140              _bodyIndex = index;
141              _bodySize = body.Length;
142              _bodyLength = body.Length;
143              _bodyLengthProvided = true;
144              return this;
145          }
146          public HttpRequest SetBodyLength(int length)
147          {
148              SetHeader("Content-Length", length.ToString());
149              _cache.Append("\r\n");
150              int index = (int)_cache.Size;
151              _bodyIndex = index;
152              _bodySize = 0;
153              _bodyLength = length;
154              _bodyLengthProvided = true;
155              return this;
156          }
157          public HttpRequest MakeHeadRequest(string url)
158          {
159              Clear();
160              SetBegin("HEAD", url);
161              SetBody();
162              return this;
163          }
164          public HttpRequest MakeGetRequest(string url)
165          {
166              Clear();
167              SetBegin("GET", url);
168              SetBody();
169              return this;
170          }
171          public HttpRequest MakePostRequest(string url, string content, string contentType = "text/plain; charset=UTF-8") => MakePostRequest(url, content.AsSpan(), contentType);
172          public HttpRequest MakePostRequest(string url, ReadOnlySpan<char> content, string contentType = "text/plain; charset=UTF-8")
173          {
174              Clear();
175              SetBegin("POST", url);
176              if (!string.IsNullOrEmpty(contentType))
177                  SetHeader("Content-Type", contentType);
178              SetBody(content);
179              return this;
180          }
181          public HttpRequest MakePostRequest(string url, byte[] content, string contentType = "") => MakePostRequest(url, content.AsSpan(), contentType);
182          public HttpRequest MakePostRequest(string url, ReadOnlySpan<byte> content, string contentType = "")
183          {
184              Clear();
185              SetBegin("POST", url);
186              if (!string.IsNullOrEmpty(contentType))
187                  SetHeader("Content-Type", contentType);
188              SetBody(content);
189              return this;
190          }
191          public HttpRequest MakePutRequest(string url, string content, string contentType = "text/plain; charset=UTF-8") => MakePutRequest(url, content.AsSpan(), contentType);
192          public HttpRequest MakePutRequest(string url, ReadOnlySpan<char> content, string contentType = "text/plain; charset=UTF-8")
193          {
194              Clear();
195              SetBegin("PUT", url);
196              if (!string.IsNullOrEmpty(contentType))
197                  SetHeader("Content-Type", contentType);
198              SetBody(content);
199              return this;
200          }
201          public HttpRequest MakePutRequest(string url, byte[] content, string contentType = "") => MakePutRequest(url, content.AsSpan(), contentType);
202          public HttpRequest MakePutRequest(string url, ReadOnlySpan<byte> content, string contentType = "")
203          {
204              Clear();
205              SetBegin("PUT", url);
206              if (!string.IsNullOrEmpty(contentType))
207                  SetHeader("Content-Type", contentType);
208              SetBody(content);
209              return this;
210          }
211          public HttpRequest MakeDeleteRequest(string url)
212          {
213              Clear();
214              SetBegin("DELETE", url);
215              SetBody();
216              return this;
217          }
218          public HttpRequest MakeOptionsRequest(string url)
219          {
220              Clear();
221              SetBegin("OPTIONS", url);
222              SetBody();
223              return this;
224          }
225          public HttpRequest MakeTraceRequest(string url)
226          {
227              Clear();
228              SetBegin("TRACE", url);
229              SetBody();
230              return this;
231          }
232          private string _method;
<span onclick='openModal()' class='match'>233          private string _url;
234          private string _protocol;
235          private List<(string, string)> _headers = new List<(string, string)>();
236          private List<(string, string)> _cookies = new List<(string, string)>();
</span>237          private int _bodyIndex;
238          private int _bodySize;
239          private int _bodyLength;
240          private bool _bodyLengthProvided;
241          private Buffer _cache = new Buffer();
242          private int _cacheSize;
243          internal bool IsPendingHeader()
244          {
245              return (!IsErrorSet && (_bodyIndex == 0));
246          }
247          internal bool IsPendingBody()
248          {
249              return (!IsErrorSet && (_bodyIndex > 0) && (_bodySize > 0));
250          }
251          internal bool ReceiveHeader(byte[] buffer, int offset, int size)
252          {
253              _cache.Append(buffer, offset, size);
254              for (int i = _cacheSize; i < (int)_cache.Size; i++)
255              {
256                  if ((i + 3) >= (int)_cache.Size)
257                      break;
258                  if ((_cache[i + 0] == '\r') && (_cache[i + 1] == '\n') && (_cache[i + 2] == '\r') && (_cache[i + 3] == '\n'))
259                  {
260                      int index = 0;
261                      IsErrorSet = true;
262                      int methodIndex = index;
263                      int methodSize = 0;
264                      while (_cache[index] != ' ')
265                      {
266                          methodSize++;
267                          index++;
268                          if (index >= (int)_cache.Size)
269                              return false;
270                      }
271                      index++;
272                      if (index >= (int)_cache.Size)
273                          return false;
274                      _method = _cache.ExtractString(methodIndex, methodSize);
275                      int urlIndex = index;
276                      int urlSize = 0;
277                      while (_cache[index] != ' ')
278                      {
279                          urlSize++;
280                          index++;
281                          if (index >= (int)_cache.Size)
282                              return false;
283                      }
284                      index++;
285                      if (index >= (int)_cache.Size)
286                          return false;
287                      _url = _cache.ExtractString(urlIndex, urlSize);
288                      int protocolIndex = index;
289                      int protocolSize = 0;
290                      while (_cache[index] != '\r')
291                      {
292                          protocolSize++;
293                          index++;
294                          if (index >= (int)_cache.Size)
295                              return false;
296                      }
297                      index++;
298                      if ((index >= (int)_cache.Size) || (_cache[index] != '\n'))
299                          return false;
300                      index++;
301                      if (index >= (int)_cache.Size)
302                          return false;
303                      _protocol = _cache.ExtractString(protocolIndex, protocolSize);
304                      while ((index < (int)_cache.Size) && (index < i))
305                      {
306                          int headerNameIndex = index;
307                          int headerNameSize = 0;
308                          while (_cache[index] != ':')
309                          {
310                              headerNameSize++;
311                              index++;
312                              if (index >= i)
313                                  break;
314                              if (index >= (int)_cache.Size)
315                                  return false;
316                          }
317                          index++;
318                          if (index >= i)
319                              break;
320                          if (index >= (int)_cache.Size)
321                              return false;
322                          while (char.IsWhiteSpace((char)_cache[index]))
323                          {
324                              index++;
325                              if (index >= i)
326                                  break;
327                              if (index >= (int)_cache.Size)
328                                  return false;
329                          }
330                          int headerValueIndex = index;
331                          int headerValueSize = 0;
332                          while (_cache[index] != '\r')
333                          {
334                              headerValueSize++;
335                              index++;
336                              if (index >= i)
337                                  break;
338                              if (index >= (int)_cache.Size)
339                                  return false;
340                          }
341                          index++;
342                          if ((index >= (int)_cache.Size) || (_cache[index] != '\n'))
343                              return false;
344                          index++;
345                          if (index >= (int)_cache.Size)
346                              return false;
347                          if (headerNameSize == 0)
348                              return false;
349                          string headerName = _cache.ExtractString(headerNameIndex, headerNameSize);
350                          string headerValue = _cache.ExtractString(headerValueIndex, headerValueSize);
351                          _headers.Add((headerName, headerValue));
352                          if (string.Compare(headerName, "Content-Length", StringComparison.OrdinalIgnoreCase) == 0)
353                          {
354                              _bodyLength = 0;
355                              for (int j = headerValueIndex; j < (headerValueIndex + headerValueSize); j++)
356                              {
357                                  if ((_cache[j] < '0') || (_cache[j] > '9'))
358                                      return false;
359                                  _bodyLength *= 10;
360                                  _bodyLength += _cache[j] - '0';
361                                  _bodyLengthProvided = true;
362                              }
363                          }
364                          if (string.Compare(headerName, "Cookie", StringComparison.OrdinalIgnoreCase) == 0)
365                          {
366                              bool name = true;
367                              bool token = false;
368                              int current = headerValueIndex;
369                              int nameIndex = index;
370                              int nameSize = 0;
371                              int cookieIndex = index;
372                              int cookieSize = 0;
373                              for (int j = headerValueIndex; j < (headerValueIndex + headerValueSize); j++)
374                              {
375                                  if (_cache[j] == ' ')
376                                  {
377                                      if (token)
378                                      {
379                                          if (name)
380                                          {
381                                              nameIndex = current;
382                                              nameSize = j - current;
383                                          }
384                                          else
385                                          {
386                                              cookieIndex = current;
387                                              cookieSize = j - current;
388                                          }
389                                      }
390                                      token = false;
391                                      continue;
392                                  }
393                                  if (_cache[j] == '=')
394                                  {
395                                      if (token)
396                                      {
397                                          if (name)
398                                          {
399                                              nameIndex = current;
400                                              nameSize = j - current;
401                                          }
402                                          else
403                                          {
404                                              cookieIndex = current;
405                                              cookieSize = j - current;
406                                          }
407                                      }
408                                      token = false;
409                                      name = false;
410                                      continue;
411                                  }
412                                  if (_cache[j] == ';')
413                                  {
414                                      if (token)
415                                      {
416                                          if (name)
417                                          {
418                                              nameIndex = current;
419                                              nameSize = j - current;
420                                          }
421                                          else
422                                          {
423                                              cookieIndex = current;
424                                              cookieSize = j - current;
425                                          }
426                                          if ((nameSize > 0) && (cookieSize > 0))
427                                          {
428                                              _cookies.Add((_cache.ExtractString(nameIndex, nameSize), _cache.ExtractString(cookieIndex, cookieSize)));
429                                              nameIndex = j;
430                                              nameSize = 0;
431                                              cookieIndex = j;
432                                              cookieSize = 0;
433                                          }
434                                      }
435                                      token = false;
436                                      name = true;
437                                      continue;
438                                  }
439                                  if (!token)
440                                  {
441                                      current = j;
442                                      token = true;
443                                  }
444                              }
445                              if (token)
446                              {
447                                  if (name)
448                                  {
449                                      nameIndex = current;
450                                      nameSize = headerValueIndex + headerValueSize - current;
451                                  }
452                                  else
453                                  {
454                                      cookieIndex = current;
455                                      cookieSize = headerValueIndex + headerValueSize - current;
456                                  }
457                                  if ((nameSize > 0) && (cookieSize > 0))
458                                  {
459                                      _cookies.Add((_cache.ExtractString(nameIndex, nameSize), _cache.ExtractString(cookieIndex, cookieSize)));
460                                  }
461                              }
462                          }
463                      }
464                      IsErrorSet = false;
465                      _bodyIndex = i + 4;
466                      _bodySize = (int)_cache.Size - i - 4;
467                      _cacheSize = (int)_cache.Size;
468                      return true;
469                  }
470              }
471              _cacheSize = ((int)_cache.Size >= 3) ? ((int)_cache.Size - 3) : 0;
472              return false;
473          }
474          internal bool ReceiveBody(byte[] buffer, int offset, int size)
475          {
476              _cache.Append(buffer, offset, size);
477              _cacheSize = (int)_cache.Size;
478              _bodySize += size;
479              if (_bodyLengthProvided)
480              {
481                  if (_bodySize >= _bodyLength)
482                  {
483                      _bodySize = _bodyLength;
484                      return true;
485                  }
486              }
487              else
488              {
489                  if ((Method == "HEAD") || (Method == "GET") || (Method == "DELETE") || (Method == "OPTIONS") || (Method == "TRACE"))
490                  {
491                      _bodyLength = 0;
492                      _bodySize = 0;
493                      return true;
494                  }
495                  if (_bodySize >= 4)
496                  {
497                      int index = _bodyIndex + _bodySize - 4;
498                      if ((_cache[index + 0] == '\r') && (_cache[index + 1] == '\n') && (_cache[index + 2] == '\r') && (_cache[index + 3] == '\n'))
499                      {
500                          _bodyLength = _bodySize;
501                          return true;
502                      }
503                  }
504              }
505              return false;
506          }
507      }
508  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpResponse.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Diagnostics;
4  using System.Text;
5  namespace NetCoreServer
6  {
7      public class HttpResponse
8      {
9          static HttpResponse()
10          {
11              _mimeTable = new Dictionary<string, string>
12              {
13                  { ".html",      "text/html" },
14                  { ".css",       "text/css" },
15                  { ".js",        "text/javascript" },
16                  { ".vue",       "text/html" },
17                  { ".xml",       "text/xml" },
18                  { ".atom",      "application/atom+xml" },
19                  { ".fastsoap",  "application/fastsoap" },
20                  { ".gzip",      "application/gzip" },
21                  { ".json",      "application/json" },
22                  { ".map",       "application/json" },
23                  { ".pdf",       "application/pdf" },
24                  { ".ps",        "application/postscript" },
25                  { ".soap",      "application/soap+xml" },
26                  { ".sql",       "application/sql" },
27                  { ".xslt",      "application/xslt+xml" },
28                  { ".zip",       "application/zip" },
29                  { ".zlib",      "application/zlib" },
30                  { ".aac",       "audio/aac" },
31                  { ".ac3",       "audio/ac3" },
32                  { ".mp3",       "audio/mpeg" },
33                  { ".ogg",       "audio/ogg" },
34                  { ".ttf",       "font/ttf" },
35                  { ".bmp",       "image/bmp" },
36                  { ".emf",       "image/emf" },
37                  { ".gif",       "image/gif" },
38                  { ".jpg",       "image/jpeg" },
39                  { ".jpm",       "image/jpm" },
40                  { ".jpx",       "image/jpx" },
41                  { ".jrx",       "image/jrx" },
42                  { ".png",       "image/png" },
43                  { ".svg",       "image/svg+xml" },
44                  { ".tiff",      "image/tiff" },
45                  { ".wmf",       "image/wmf" },
46                  { ".http",      "message/http" },
47                  { ".s-http",    "message/s-http" },
48                  { ".mesh",      "model/mesh" },
49                  { ".vrml",      "model/vrml" },
50                  { ".csv",       "text/csv" },
51                  { ".plain",     "text/plain" },
52                  { ".richtext",  "text/richtext" },
53                  { ".rtf",       "text/rtf" },
54                  { ".rtx",       "text/rtx" },
55                  { ".sgml",      "text/sgml" },
56                  { ".strings",   "text/strings" },
57                  { ".url",       "text/uri-list" },
58                  { ".H264",      "video/H264" },
59                  { ".H265",      "video/H265" },
60                  { ".mp4",       "video/mp4" },
61                  { ".mpeg",      "video/mpeg" },
62                  { ".raw",       "video/raw" }
63              };
64          }
65          public HttpResponse()
66          {
67              Clear();
68          }
69          public HttpResponse(int status, string protocol = "HTTP/1.1")
70          {
71              SetBegin(status, protocol);
72          }
73          public HttpResponse(int status, string statusPhrase, string protocol)
74          {
75              SetBegin(status, statusPhrase, protocol);
76          }
77          public bool IsEmpty { get { return (_cache.Size > 0); } }
78          public bool IsErrorSet { get; private set; }
79          public int Status { get; private set; }
80          public string StatusPhrase { get { return _statusPhrase; } }
81          public string Protocol { get { return _protocol; } }
82          public long Headers { get { return _headers.Count; } }
83          public (string, string) Header(int i)
84          {
85              Debug.Assert((i < _headers.Count), "Index out of bounds!");
86              if (i >= _headers.Count)
87                  return ("", "");
88              return _headers[i];
89          }
90          public string Body { get { return _cache.ExtractString(_bodyIndex, _bodySize); } }
91          public byte[] BodyBytes { get { return _cache.Data[_bodyIndex..(_bodyIndex + _bodySize)]; } }
92          public ReadOnlySpan<byte> BodySpan { get { return new ReadOnlySpan<byte>(_cache.Data, _bodyIndex, _bodySize); } }
93          public long BodyLength { get { return _bodyLength; } }
94          public Buffer Cache { get { return _cache; } }
95          public override string ToString()
96          {
97              StringBuilder sb = new StringBuilder();
98              sb.AppendLine($"Status: {Status}");
99              sb.AppendLine($"Status phrase: {StatusPhrase}");
100              sb.AppendLine($"Protocol: {Protocol}");
101              sb.AppendLine($"Headers: {Headers}");
102              for (int i = 0; i < Headers; i++)
103              {
104                  var header = Header(i);
105                  sb.AppendLine($"{header.Item1} : {header.Item2}");
106              }
107              sb.AppendLine($"Body: {BodyLength}");
108              sb.AppendLine(Body);
109              return sb.ToString();
110          }
111          public HttpResponse Clear()
112          {
113              IsErrorSet = false;
114              Status = 0;
115              _statusPhrase = "";
116              _protocol = "";
117              _headers.Clear();
118              _bodyIndex = 0;
119              _bodySize = 0;
120              _bodyLength = 0;
121              _bodyLengthProvided = false;
122              _cache.Clear();
123              _cacheSize = 0;
124              return this;
125          }
126          public HttpResponse SetBegin(int status, string protocol = "HTTP/1.1")
127          {
128              string statusPhrase;
129              switch (status)
130              {
131                  case 100: statusPhrase = "Continue"; break;
132                  case 101: statusPhrase = "Switching Protocols"; break;
133                  case 102: statusPhrase = "Processing"; break;
134                  case 103: statusPhrase = "Early Hints"; break;
135                  case 200: statusPhrase = "OK"; break;
136                  case 201: statusPhrase = "Created"; break;
137                  case 202: statusPhrase = "Accepted"; break;
138                  case 203: statusPhrase = "Non-Authoritative Information"; break;
139                  case 204: statusPhrase = "No Content"; break;
140                  case 205: statusPhrase = "Reset Content"; break;
141                  case 206: statusPhrase = "Partial Content"; break;
142                  case 207: statusPhrase = "Multi-Status"; break;
143                  case 208: statusPhrase = "Already Reported"; break;
144                  case 226: statusPhrase = "IM Used"; break;
145                  case 300: statusPhrase = "Multiple Choices"; break;
146                  case 301: statusPhrase = "Moved Permanently"; break;
147                  case 302: statusPhrase = "Found"; break;
148                  case 303: statusPhrase = "See Other"; break;
149                  case 304: statusPhrase = "Not Modified"; break;
150                  case 305: statusPhrase = "Use Proxy"; break;
151                  case 306: statusPhrase = "Switch Proxy"; break;
152                  case 307: statusPhrase = "Temporary Redirect"; break;
153                  case 308: statusPhrase = "Permanent Redirect"; break;
154                  case 400: statusPhrase = "Bad Request"; break;
155                  case 401: statusPhrase = "Unauthorized"; break;
156                  case 402: statusPhrase = "Payment Required"; break;
157                  case 403: statusPhrase = "Forbidden"; break;
158                  case 404: statusPhrase = "Not Found"; break;
159                  case 405: statusPhrase = "Method Not Allowed"; break;
160                  case 406: statusPhrase = "Not Acceptable"; break;
161                  case 407: statusPhrase = "Proxy Authentication Required"; break;
162                  case 408: statusPhrase = "Request Timeout"; break;
163                  case 409: statusPhrase = "Conflict"; break;
164                  case 410: statusPhrase = "Gone"; break;
165                  case 411: statusPhrase = "Length Required"; break;
166                  case 412: statusPhrase = "Precondition Failed"; break;
167                  case 413: statusPhrase = "Payload Too Large"; break;
168                  case 414: statusPhrase = "URI Too Long"; break;
169                  case 415: statusPhrase = "Unsupported Media Type"; break;
170                  case 416: statusPhrase = "Range Not Satisfiable"; break;
171                  case 417: statusPhrase = "Expectation Failed"; break;
172                  case 421: statusPhrase = "Misdirected Request"; break;
173                  case 422: statusPhrase = "Unprocessable Entity"; break;
174                  case 423: statusPhrase = "Locked"; break;
175                  case 424: statusPhrase = "Failed Dependency"; break;
176                  case 425: statusPhrase = "Too Early"; break;
177                  case 426: statusPhrase = "Upgrade Required"; break;
178                  case 427: statusPhrase = "Unassigned"; break;
179                  case 428: statusPhrase = "Precondition Required"; break;
180                  case 429: statusPhrase = "Too Many Requests"; break;
181                  case 431: statusPhrase = "Request Header Fields Too Large"; break;
182                  case 451: statusPhrase = "Unavailable For Legal Reasons"; break;
183                  case 500: statusPhrase = "Internal Server Error"; break;
184                  case 501: statusPhrase = "Not Implemented"; break;
185                  case 502: statusPhrase = "Bad Gateway"; break;
186                  case 503: statusPhrase = "Service Unavailable"; break;
187                  case 504: statusPhrase = "Gateway Timeout"; break;
188                  case 505: statusPhrase = "HTTP Version Not Supported"; break;
189                  case 506: statusPhrase = "Variant Also Negotiates"; break;
190                  case 507: statusPhrase = "Insufficient Storage"; break;
191                  case 508: statusPhrase = "Loop Detected"; break;
192                  case 510: statusPhrase = "Not Extended"; break;
193                  case 511: statusPhrase = "Network Authentication Required"; break;
194                  default: statusPhrase = "Unknown"; break;
195              }
196              SetBegin(status, statusPhrase, protocol);
197              return this;
198          }
199          public HttpResponse SetBegin(int status, string statusPhrase, string protocol)
200          {
201              Clear();
202              _cache.Append(protocol);
203              _protocol = protocol;
204              _cache.Append(" ");
205              _cache.Append(status.ToString());
206              Status = status;
207              _cache.Append(" ");
208              _cache.Append(statusPhrase);
209              _statusPhrase = statusPhrase;
210              _cache.Append("\r\n");
211              return this;
212          }
213          public HttpResponse SetContentType(string extension)
214          {
215              if (_mimeTable.TryGetValue(extension, out string mime))
216                  return SetHeader("Content-Type", mime);
217              return this;
218          }
219          public HttpResponse SetHeader(string key, string value)
220          {
221              _cache.Append(key);
222              _cache.Append(": ");
223              _cache.Append(value);
224              _cache.Append("\r\n");
225              _headers.Add((key, value));
226              return this;
227          }
228          public HttpResponse SetCookie(string name, string value, int maxAge = 86400, string path = "", string domain = "", bool secure = true, bool strict = true, bool httpOnly = true)
229          {
230              string key = "Set-Cookie";
231              _cache.Append(key);
232              _cache.Append(": ");
233              int valueIndex = (int)_cache.Size;
234              _cache.Append(name);
235              _cache.Append("=");
236              _cache.Append(value);
237              _cache.Append("; Max-Age=");
238              _cache.Append(maxAge.ToString());
239              if (!string.IsNullOrEmpty(domain))
240              {
241                  _cache.Append("; Domain=");
242                  _cache.Append(domain);
243              }
244              if (!string.IsNullOrEmpty(path))
245              {
246                  _cache.Append("; Path=");
247                  _cache.Append(path);
248              }
249              if (secure)
250                  _cache.Append("; Secure");
251              if (strict)
252                  _cache.Append("; SameSite=Strict");
253              if (httpOnly)
254                  _cache.Append("; HttpOnly");
255              int valueSize = (int)_cache.Size - valueIndex;
256              string cookie = _cache.ExtractString(valueIndex, valueSize);
257              _cache.Append("\r\n");
258              _headers.Add((key, cookie));
259              return this;
260          }
261          public HttpResponse SetBody(string body = "") => SetBody(body.AsSpan());
262          public HttpResponse SetBody(ReadOnlySpan<char> body)
263          {
264              int length = body.IsEmpty ? 0 : Encoding.UTF8.GetByteCount(body);
265              SetHeader("Content-Length", length.ToString());
266              _cache.Append("\r\n");
267              int index = (int)_cache.Size;
268              _cache.Append(body);
269              _bodyIndex = index;
270              _bodySize = length;
271              _bodyLength = length;
272              _bodyLengthProvided = true;
273              return this;
274          }
275          public HttpResponse SetBody(byte[] body) => SetBody(body.AsSpan());
276          public HttpResponse SetBody(ReadOnlySpan<byte> body)
277          {
278              SetHeader("Content-Length", body.Length.ToString());
279              _cache.Append("\r\n");
280              int index = (int)_cache.Size;
281              _cache.Append(body);
282              _bodyIndex = index;
283              _bodySize = body.Length;
284              _bodyLength = body.Length;
285              _bodyLengthProvided = true;
286              return this;
287          }
288          public HttpResponse SetBodyLength(int length)
289          {
290              SetHeader("Content-Length", length.ToString());
291              _cache.Append("\r\n");
292              int index = (int)_cache.Size;
293              _bodyIndex = index;
294              _bodySize = 0;
295              _bodyLength = length;
296              _bodyLengthProvided = true;
297              return this;
298          }
299          public HttpResponse MakeOkResponse(int status = 200)
300          {
301              Clear();
302              SetBegin(status);
303              SetBody();
304              return this;
305          }
306          public HttpResponse MakeErrorResponse(string content = "", string contentType = "text/plain; charset=UTF-8")
307          {
308              return MakeErrorResponse(500, content, contentType);
309          }
310          public HttpResponse MakeErrorResponse(int status, string content = "", string contentType = "text/plain; charset=UTF-8")
311          {
312              Clear();
313              SetBegin(status);
314              if (!string.IsNullOrEmpty(contentType))
315                  SetHeader("Content-Type", contentType);
316              SetBody(content);
317              return this;
318          }
319          public HttpResponse MakeHeadResponse()
320          {
321              Clear();
322              SetBegin(200);
323              SetBody();
324              return this;
325          }
326          public HttpResponse MakeGetResponse(string content = "", string contentType = "text/plain; charset=UTF-8") => MakeGetResponse(content.AsSpan(), contentType);
327          public HttpResponse MakeGetResponse(ReadOnlySpan<char> content, string contentType = "text/plain; charset=UTF-8")
328          {
329              Clear();
330              SetBegin(200);
331              if (!string.IsNullOrEmpty(contentType))
332                  SetHeader("Content-Type", contentType);
333              SetBody(content);
334              return this;
335          }
336          public HttpResponse MakeGetResponse(byte[] content, string contentType = "") => MakeGetResponse(content.AsSpan(), contentType);
337          public HttpResponse MakeGetResponse(ReadOnlySpan<byte> content, string contentType = "")
338          {
339              Clear();
340              SetBegin(200);
341              if (!string.IsNullOrEmpty(contentType))
342                  SetHeader("Content-Type", contentType);
343              SetBody(content);
344              return this;
345          }
346          public HttpResponse MakeOptionsResponse(string allow = "HEAD,GET,POST,PUT,DELETE,OPTIONS,TRACE")
347          {
348              Clear();
349              SetBegin(200);
350              SetHeader("Allow", allow);
351              SetBody();
352              return this;
353          }
354          public HttpResponse MakeTraceResponse(string content) => MakeTraceResponse(content.AsSpan());
355          public HttpResponse MakeTraceResponse(ReadOnlySpan<char> content)
356          {
357              Clear();
358              SetBegin(200);
359              SetHeader("Content-Type", "message/http");
360              SetBody(content);
361              return this;
362          }
363          public HttpResponse MakeTraceResponse(byte[] content) => MakeTraceResponse(content.AsSpan());
364          public HttpResponse MakeTraceResponse(ReadOnlySpan<byte> content)
365          {
366              Clear();
367              SetBegin(200);
368              SetHeader("Content-Type", "message/http");
369              SetBody(content);
370              return this;
371          }
372          public HttpResponse MakeTraceResponse(HttpRequest request) => MakeTraceResponse(request.Cache.AsSpan());
<span onclick='openModal()' class='match'>373          private string _statusPhrase;
374          private string _protocol;
375          private List<(string, string)> _headers = new List<(string, string)>();
376          private int _bodyIndex;
</span>377          private int _bodySize;
378          private int _bodyLength;
379          private bool _bodyLengthProvided;
380          private Buffer _cache = new Buffer();
381          private int _cacheSize;
382          private static readonly Dictionary<string, string> _mimeTable;
383          internal bool IsPendingHeader()
384          {
385              return (!IsErrorSet && (_bodyIndex == 0));
386          }
387          internal bool IsPendingBody()
388          {
389              return (!IsErrorSet && (_bodyIndex > 0) && (_bodySize > 0));
390          }
391          internal bool ReceiveHeader(byte[] buffer, int offset, int size)
392          {
393              _cache.Append(buffer, offset, size);
394              for (int i = _cacheSize; i < (int)_cache.Size; i++)
395              {
396                  if ((i + 3) >= (int)_cache.Size)
397                      break;
398                  if ((_cache[i + 0] == '\r') && (_cache[i + 1] == '\n') && (_cache[i + 2] == '\r') && (_cache[i + 3] == '\n'))
399                  {
400                      int index = 0;
401                      IsErrorSet = true;
402                      int protocolIndex = index;
403                      int protocolSize = 0;
404                      while (_cache[index] != ' ')
405                      {
406                          protocolSize++;
407                          index++;
408                          if (index >= (int)_cache.Size)
409                              return false;
410                      }
411                      index++;
412                      if ((index >= (int)_cache.Size))
413                          return false;
414                      _protocol = _cache.ExtractString(protocolIndex, protocolSize);
415                      int statusIndex = index;
416                      int statusSize = 0;
417                      while (_cache[index] != ' ')
418                      {
419                          if ((_cache[index] < '0') || (_cache[index] > '9'))
420                              return false;
421                          statusSize++;
422                          index++;
423                          if (index >= (int)_cache.Size)
424                              return false;
425                      }
426                      Status = 0;
427                      for (int j = statusIndex; j < (statusIndex + statusSize); j++)
428                      {
429                          Status *= 10;
430                          Status += _cache[j] - '0';
431                      }
432                      index++;
433                      if (index >= (int)_cache.Size)
434                          return false;
435                      int statusPhraseIndex = index;
436                      int statusPhraseSize = 0;
437                      while (_cache[index] != '\r')
438                      {
439                          statusPhraseSize++;
440                          index++;
441                          if (index >= (int)_cache.Size)
442                              return false;
443                      }
444                      index++;
445                      if ((index >= (int)_cache.Size) || (_cache[index] != '\n'))
446                          return false;
447                      index++;
448                      if (index >= (int)_cache.Size)
449                          return false;
450                      _statusPhrase = _cache.ExtractString(statusPhraseIndex, statusPhraseSize);
451                      while ((index < (int)_cache.Size) && (index < i))
452                      {
453                          int headerNameIndex = index;
454                          int headerNameSize = 0;
455                          while (_cache[index] != ':')
456                          {
457                              headerNameSize++;
458                              index++;
459                              if (index >= i)
460                                  break;
461                              if (index >= (int)_cache.Size)
462                                  return false;
463                          }
464                          index++;
465                          if (index >= i)
466                              break;
467                          if (index >= (int)_cache.Size)
468                              return false;
469                          while (char.IsWhiteSpace((char)_cache[index]))
470                          {
471                              index++;
472                              if (index >= i)
473                                  break;
474                              if (index >= (int)_cache.Size)
475                                  return false;
476                          }
477                          int headerValueIndex = index;
478                          int headerValueSize = 0;
479                          while (_cache[index] != '\r')
480                          {
481                              headerValueSize++;
482                              index++;
483                              if (index >= i)
484                                  break;
485                              if (index >= (int)_cache.Size)
486                                  return false;
487                          }
488                          index++;
489                          if ((index >= (int)_cache.Size) || (_cache[index] != '\n'))
490                              return false;
491                          index++;
492                          if (index >= (int)_cache.Size)
493                              return false;
494                          if (headerNameSize == 0)
495                              return false;
496                          string headerName = _cache.ExtractString(headerNameIndex, headerNameSize);
497                          string headerValue = _cache.ExtractString(headerValueIndex, headerValueSize);
498                          _headers.Add((headerName, headerValue));
499                          if (string.Compare(headerName, "Content-Length", StringComparison.OrdinalIgnoreCase) == 0)
500                          {
501                              _bodyLength = 0;
502                              for (int j = headerValueIndex; j < (headerValueIndex + headerValueSize); j++)
503                              {
504                                  if ((_cache[j] < '0') || (_cache[j] > '9'))
505                                      return false;
506                                  _bodyLength *= 10;
507                                  _bodyLength += _cache[j] - '0';
508                                  _bodyLengthProvided = true;
509                              }
510                          }
511                      }
512                      IsErrorSet = false;
513                      _bodyIndex = i + 4;
514                      _bodySize = (int)_cache.Size - i - 4;
515                      _cacheSize = (int)_cache.Size;
516                      return true;
517                  }
518              }
519              _cacheSize = ((int)_cache.Size >= 3) ? ((int)_cache.Size - 3) : 0;
520              return false;
521          }
522          internal bool ReceiveBody(byte[] buffer, int offset, int size)
523          {
524              _cache.Append(buffer, offset, size);
525              _cacheSize = (int)_cache.Size;
526              _bodySize += size;
527              if (_bodyLengthProvided)
528              {
529                  if (_bodySize >= _bodyLength)
530                  {
531                      _bodySize = _bodyLength;
532                      return true;
533                  }
534              }
535              else
536              {
537                  if (_bodySize >= 4)
538                  {
539                      int index = _bodyIndex + _bodySize - 4;
540                      if ((_cache[index + 0] == '\r') && (_cache[index + 1] == '\n') && (_cache[index + 2] == '\r') &&
541                          (_cache[index + 3] == '\n'))
542                      {
543                          _bodyLength = _bodySize;
544                          return true;
545                      }
546                  }
547              }
548              return false;
549          }
550      }
551  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpRequest.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-HttpResponse.cs</div>
                </div>
                <div class="column column_space"><pre><code>233          private string _url;
234          private string _protocol;
235          private List<(string, string)> _headers = new List<(string, string)>();
236          private List<(string, string)> _cookies = new List<(string, string)>();
</pre></code></div>
                <div class="column column_space"><pre><code>373          private string _statusPhrase;
374          private string _protocol;
375          private List<(string, string)> _headers = new List<(string, string)>();
376          private int _bodyIndex;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    