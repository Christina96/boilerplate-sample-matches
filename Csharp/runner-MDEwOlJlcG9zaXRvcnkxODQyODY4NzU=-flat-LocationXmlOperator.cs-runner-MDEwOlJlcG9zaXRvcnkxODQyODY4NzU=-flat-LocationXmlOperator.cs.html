
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationXmlOperator.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Text;
5  using System.Xml;
6  using GitHub.Services.Common;
7  using GitHub.Services.Location;
8  using GitHub.Services.Common.Internal;
9  namespace GitHub.Services.WebApi.Location
10  {
11      internal class LocationXmlOperator
12      {
13          public LocationXmlOperator(Boolean isClientCache)
14          {
15              m_isClientCache = isClientCache;
16              m_accessMappingLocationServiceUrls = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
17          }
18          public List<ServiceDefinition> ReadServices(XmlDocument document, Dictionary<String, AccessMapping> accessMappings)
19          {
20              List<ServiceDefinition> definitions = new List<ServiceDefinition>();
21              XmlNodeList servicesNodeList = document.SelectNodes("&bsol;&bsol;" + s_services);
22              if (servicesNodeList == null)
23              {
24                  return definitions;
25              }
26              foreach (XmlNode servicesNode in servicesNodeList)
27              {
28                  foreach (XmlNode definitionNode in servicesNode.SelectNodes("./" + s_serviceDefinition))
29                  {
30                      ServiceDefinition definition = new ServiceDefinition();
<span onclick='openModal()' class='match'>31                      XmlNode serviceTypeNode = definitionNode.SelectSingleNode("./" + s_serviceType);
32                      LocationXmlOperator.CheckXmlNodeNullOrEmpty(serviceTypeNode, s_serviceType, definitionNode);
</span>33                      definition.ServiceType = serviceTypeNode.InnerText;
34                      XmlNode identifierNode = definitionNode.SelectSingleNode("./" + s_identifier);
35                      if (m_isClientCache)
36                      {
37                          LocationXmlOperator.CheckXmlNodeNullOrEmpty(identifierNode, s_identifier, definitionNode);
38                      }
39                      definition.Identifier = (identifierNode != null) ? XmlConvert.ToGuid(identifierNode.InnerText) : Guid.Empty;
40                      XmlNode displayNameNode = definitionNode.SelectSingleNode("./" + s_displayName);
41                      LocationXmlOperator.CheckXmlNodeNullOrEmpty(displayNameNode, s_displayName, definitionNode);
42                      definition.DisplayName = displayNameNode.InnerText;
43                      XmlNode descriptionNode = definitionNode.SelectSingleNode("./" + s_description);
44                      definition.Description = (descriptionNode != null) ? descriptionNode.InnerText : String.Empty;
45                      XmlNode relativePathNode = definitionNode.SelectSingleNode("./" + s_relativePath);
46                      LocationXmlOperator.CheckXmlNodeNull(relativePathNode, s_relativePath, definitionNode);
47                      definition.RelativePath = relativePathNode.InnerText;
48                      XmlAttribute relativeToAttribute = relativePathNode.Attributes[s_relativeTo];
49                      CheckXmlAttributeNullOrEmpty(relativeToAttribute, s_relativeTo, relativePathNode);
50                      RelativeToSetting setting;
51                      if (!RelativeToEnumCache.GetRelativeToEnums().TryGetValue(relativeToAttribute.InnerText, out setting))
52                      {
53                          throw new ConfigFileException(relativeToAttribute.InnerText);
54                      }
55                      definition.RelativeToSetting = setting;
56                      if (definition.RelativeToSetting == RelativeToSetting.FullyQualified && definition.RelativePath == String.Empty)
57                      {
58                          definition.RelativePath = null;
59                      }
60                      XmlNode parentServiceTypeNode = definitionNode.SelectSingleNode("./" + s_parentServiceType);
61                      definition.ParentServiceType = (parentServiceTypeNode != null) ? parentServiceTypeNode.InnerText : null;
62                      XmlNode parentIdentifierNode = definitionNode.SelectSingleNode("./" + s_parentIdentifier);
63                      definition.ParentIdentifier = (parentIdentifierNode != null) ? XmlConvert.ToGuid(parentIdentifierNode.InnerText) : Guid.Empty;
64                      definition.LocationMappings = new List<LocationMapping>();
65                      if (definition.RelativeToSetting == RelativeToSetting.FullyQualified)
66                      {
67                          XmlNodeList mappings = definitionNode.SelectNodes(".
68                          foreach (XmlNode mappingNode in mappings)
69                          {
70                              LocationMapping locationMapping = new LocationMapping();
71                              XmlNode accessMappingNode = mappingNode.SelectSingleNode("./" + s_accessMapping);
72                              LocationXmlOperator.CheckXmlNodeNullOrEmpty(accessMappingNode, s_accessMapping, mappingNode);
73                              locationMapping.AccessMappingMoniker = accessMappingNode.InnerText;
74                              XmlNode locationNode = mappingNode.SelectSingleNode("./" + s_location);
75                              if (m_isClientCache)
76                              {
77                                  CheckXmlNodeNullOrEmpty(locationNode, s_location, mappingNode);
78                              }
79                              locationMapping.Location = (locationNode != null) ? locationNode.InnerText : null;
80                              definition.LocationMappings.Add(locationMapping);
81                          }
82                      }
83                      XmlNode resourceVersionNode = definitionNode.SelectSingleNode("./" + s_resourceVersion);
84                      definition.ResourceVersion = (resourceVersionNode != null) ? XmlConvert.ToInt32(resourceVersionNode.InnerText) : 0;
85                      XmlNode minVersionNode = definitionNode.SelectSingleNode("./" + s_minVersion);
86                      definition.MinVersionString = (minVersionNode != null) ? minVersionNode.InnerText : null;
87                      XmlNode maxVersionNode = definitionNode.SelectSingleNode("./" + s_maxVersion);
88                      definition.MaxVersionString = (maxVersionNode != null) ? maxVersionNode.InnerText : null;
89                      XmlNode releasedVersionNode = definitionNode.SelectSingleNode("./" + s_releasedVersion);
90                      definition.ReleasedVersionString = (releasedVersionNode != null) ? releasedVersionNode.InnerText : null;
91                      definitions.Add(definition);
92                  }
93              }
94              return definitions;
95          }
96          public List<String> ReadCachedMisses(XmlDocument document)
97          {
98              List<String> cachedMisses = new List<String>();
99              XmlNodeList cachedMissesNodeList = document.SelectNodes("&bsol;&bsol;" + s_cachedMisses);
100              if (cachedMissesNodeList == null)
101              {
102                  return cachedMisses;
103              }
104              foreach (XmlNode cachedMissesNode in cachedMissesNodeList)
105              {
106                  foreach (XmlNode cachedMissNode in cachedMissesNode.SelectNodes("./" + s_cachedMiss))
107                  {
108                      cachedMisses.Add(cachedMissNode.InnerText);
109                  }
110              }
111              return cachedMisses;
112          }
113          public List<AccessMapping> ReadAccessMappings(XmlDocument document)
114          {
115              List<AccessMapping> accessMappings = new List<AccessMapping>();
116              XmlNodeList accessMappingNodeList = document.SelectNodes("&bsol;&bsol;" + s_accessMappings);
117              if (accessMappingNodeList == null)
118              {
119                  return accessMappings;
120              }
121              foreach (XmlNode accessMappingsNode in accessMappingNodeList)
122              {
123                  foreach (XmlNode accessMappingNode in accessMappingsNode.SelectNodes("./" + s_accessMapping))
124                  {
125                      AccessMapping accessMapping = new AccessMapping();
126                      XmlNode monikerNode = accessMappingNode.SelectSingleNode("./" + s_moniker);
127                      CheckXmlNodeNullOrEmpty(monikerNode, s_moniker, accessMappingNode);
128                      accessMapping.Moniker = monikerNode.InnerText;
129                      XmlNode accessPointNode = accessMappingNode.SelectSingleNode("./" + s_accessPoint);
130                      CheckXmlNodeNullOrEmpty(accessPointNode, s_accessPoint, accessMappingNode);
131                      accessMapping.AccessPoint = accessPointNode.InnerText;
132                      XmlNode displayNameNode = accessMappingNode.SelectSingleNode("./" + s_displayName);
133                      accessMapping.DisplayName = (displayNameNode != null) ? displayNameNode.InnerText : null;
134                      XmlNode virtualDirectoryNode = accessMappingNode.SelectSingleNode("./" + s_virtualDirectory);
135                      accessMapping.VirtualDirectory = (virtualDirectoryNode != null) ? virtualDirectoryNode.InnerText : null;
136                      if (!m_isClientCache)
137                      {
138                          XmlNode locationServiceUrlNode = accessMappingNode.SelectSingleNode("./" + s_locationServiceUrl);
139                          String locationServiceUrl = (locationServiceUrlNode != null) ? locationServiceUrlNode.InnerText : String.Empty;
140                          m_accessMappingLocationServiceUrls[accessMapping.Moniker] = locationServiceUrl;
141                      }
142                      accessMappings.Add(accessMapping);
143                  }
144              }
145              return accessMappings;
146          }
147          public Int32 ReadLastChangeId(XmlDocument document)
148          {
149              XmlNode lastChangeIdNode = document.SelectSingleNode("&bsol;&bsol;" + s_lastChangeId);
150              return (lastChangeIdNode != null) ? XmlConvert.ToInt32(lastChangeIdNode.InnerText) : -1;
151          }
152          public DateTime ReadCacheExpirationDate(XmlDocument document)
153          {
154              XmlNode cacheExpirationDateNode = document.SelectSingleNode("&bsol;&bsol;" + s_cacheExpirationDate);
155              return (cacheExpirationDateNode != null) ? XmlConvert.ToDateTime(cacheExpirationDateNode.InnerText, XmlDateTimeSerializationMode.Utc) : DateTime.MinValue;
156          }
157          public String ReadDefaultAccessMappingMoniker(XmlDocument document)
158          {
159              XmlNode defaultAccessMappingMonikerNode = document.SelectSingleNode("&bsol;&bsol;" + s_defaultAccessMappingMoniker);
160              CheckXmlNodeNullOrEmpty(defaultAccessMappingMonikerNode, s_defaultAccessMappingMoniker, document);
161              return defaultAccessMappingMonikerNode.InnerText;
162          }
163          public String ReadVirtualDirectory(XmlDocument document)
164          {
165              XmlNode virtualDirectoryNode = document.SelectSingleNode("&bsol;&bsol;" + s_virtualDirectory);
166              CheckXmlNodeNull(virtualDirectoryNode, s_virtualDirectory, document);
167              return virtualDirectoryNode.InnerText;
168          }
169          public void WriteLastChangeId(XmlNode documentNode, Int32 lastChangeId)
170          {
171              XmlNode lastChangeIdNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_lastChangeId, null);
172              documentNode.AppendChild(lastChangeIdNode);
173              lastChangeIdNode.InnerText = XmlConvert.ToString(lastChangeId);
174          }
175          public void WriteCacheExpirationDate(XmlNode documentNode, DateTime cacheExpirationDate)
176          {
177              XmlNode cacheExpirationDateNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_cacheExpirationDate, null);
178              documentNode.AppendChild(cacheExpirationDateNode);
179              cacheExpirationDateNode.InnerText = XmlConvert.ToString(cacheExpirationDate, XmlDateTimeSerializationMode.Utc);
180          }
181          public void WriteDefaultAccessMappingMoniker(XmlNode documentNode, String defaultAccessMappingMoniker)
182          {
183              XmlNode defaultAccessMappingMonikerNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_defaultAccessMappingMoniker, null);
184              documentNode.AppendChild(defaultAccessMappingMonikerNode);
185              defaultAccessMappingMonikerNode.InnerText = defaultAccessMappingMoniker;
186          }
187          public void WriteVirtualDirectory(XmlNode documentNode, String virtualDirectory)
188          {
189              XmlNode virtualDirectoryNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_virtualDirectory, null);
190              documentNode.AppendChild(virtualDirectoryNode);
191              virtualDirectoryNode.InnerText = virtualDirectory;
192          }
193          public void WriteAccessMappings(XmlNode documentNode, IEnumerable<AccessMapping> accessMappings)
194          {
195              XmlDocument document = documentNode.OwnerDocument;
196              XmlNode accessMappingsNode = document.CreateNode(XmlNodeType.Element, s_accessMappings, null);
197              documentNode.AppendChild(accessMappingsNode);
198              foreach (AccessMapping accessMapping in accessMappings)
199              {
200                  XmlNode accessMappingNode = document.CreateNode(XmlNodeType.Element, s_accessMapping, null);
201                  accessMappingsNode.AppendChild(accessMappingNode);
202                  XmlNode monikerNode = document.CreateNode(XmlNodeType.Element, s_moniker, null);
203                  accessMappingNode.AppendChild(monikerNode);
204                  monikerNode.InnerText = accessMapping.Moniker;
205                  XmlNode accessPointNode = document.CreateNode(XmlNodeType.Element, s_accessPoint, null);
206                  accessMappingNode.AppendChild(accessPointNode);
207                  accessPointNode.InnerText = accessMapping.AccessPoint;
208                  XmlNode displayNameNode = document.CreateNode(XmlNodeType.Element, s_displayName, null);
209                  accessMappingNode.AppendChild(displayNameNode);
210                  displayNameNode.InnerText = accessMapping.DisplayName;
211                  if (accessMapping.VirtualDirectory != null)
212                  {
213                      XmlNode virtualDirectoryNode = document.CreateNode(XmlNodeType.Element, s_virtualDirectory, null);
214                      accessMappingNode.AppendChild(virtualDirectoryNode);
215                      virtualDirectoryNode.InnerText = accessMapping.VirtualDirectory;
216                  }
217              }
218          }
219          public void WriteServices(XmlNode documentNode, IEnumerable<ServiceDefinition> serviceDefinitions)
220          {
221              XmlDocument document = documentNode.OwnerDocument;
222              XmlNode servicesNode = document.CreateNode(XmlNodeType.Element, s_services, null);
223              documentNode.AppendChild(servicesNode);
224              foreach (ServiceDefinition definition in serviceDefinitions)
225              {
226                  XmlNode serviceDefinitionNode = document.CreateNode(XmlNodeType.Element, s_serviceDefinition, null);
227                  servicesNode.AppendChild(serviceDefinitionNode);
228                  XmlNode serviceTypeNode = document.CreateNode(XmlNodeType.Element, s_serviceType, null);
229                  serviceDefinitionNode.AppendChild(serviceTypeNode);
230                  serviceTypeNode.InnerText = definition.ServiceType;
231                  XmlNode identifierNode = document.CreateNode(XmlNodeType.Element, s_identifier, null);
232                  serviceDefinitionNode.AppendChild(identifierNode);
233                  identifierNode.InnerText = XmlConvert.ToString(definition.Identifier);
234                  if (definition.DisplayName != null)
235                  {
236                      XmlNode displayNameNode = document.CreateNode(XmlNodeType.Element, s_displayName, null);
237                      serviceDefinitionNode.AppendChild(displayNameNode);
238                      displayNameNode.InnerText = definition.DisplayName;
239                  }
240                  if (definition.Description != null)
241                  {
242                      XmlNode descriptionNode = document.CreateNode(XmlNodeType.Element, s_description, null);
243                      serviceDefinitionNode.AppendChild(descriptionNode);
244                      descriptionNode.InnerText = definition.Description;
245                  }
246                  XmlNode relativePathNode = document.CreateNode(XmlNodeType.Element, s_relativePath, null);
247                  serviceDefinitionNode.AppendChild(relativePathNode);
248                  relativePathNode.InnerText = definition.RelativePath;
249                  XmlUtility.AddXmlAttribute(relativePathNode, s_relativeTo, definition.RelativeToSetting.ToString());
250                  XmlNode parentServiceTypeNode = document.CreateNode(XmlNodeType.Element, s_parentServiceType, null);
251                  serviceDefinitionNode.AppendChild(parentServiceTypeNode);
252                  parentServiceTypeNode.InnerText = definition.ParentServiceType;
253                  XmlNode parentIdentifierNode = document.CreateNode(XmlNodeType.Element, s_parentIdentifier, null);
254                  serviceDefinitionNode.AppendChild(parentIdentifierNode);
255                  parentIdentifierNode.InnerText = XmlConvert.ToString(definition.ParentIdentifier);
256                  if (definition.RelativeToSetting == RelativeToSetting.FullyQualified)
257                  {
258                      XmlNode locationMappingsNode = document.CreateNode(XmlNodeType.Element, s_locationMappings, null);
259                      serviceDefinitionNode.AppendChild(locationMappingsNode);
260                      foreach (LocationMapping mapping in definition.LocationMappings)
261                      {
262                          XmlNode locationMappingNode = document.CreateNode(XmlNodeType.Element, s_locationMapping, null);
263                          locationMappingsNode.AppendChild(locationMappingNode);
264                          XmlNode accessMappingNode = document.CreateNode(XmlNodeType.Element, s_accessMapping, null);
265                          locationMappingNode.AppendChild(accessMappingNode);
266                          accessMappingNode.InnerText = mapping.AccessMappingMoniker;
267                          XmlNode locationNode = document.CreateNode(XmlNodeType.Element, s_location, null);
268                          locationMappingNode.AppendChild(locationNode);
269                          locationNode.InnerText = mapping.Location;
270                      }
271                  }
272                  if (definition.ResourceVersion > 0)
273                  {
274                      XmlNode resourceVersionNode = document.CreateNode(XmlNodeType.Element, s_resourceVersion, null);
275                      serviceDefinitionNode.AppendChild(resourceVersionNode);
276                      resourceVersionNode.InnerText = XmlConvert.ToString(definition.ResourceVersion);
277                  }
278                  if (definition.MinVersionString != null)
279                  {
280                      XmlNode minVersionNode = document.CreateNode(XmlNodeType.Element, s_minVersion, null);
281                      serviceDefinitionNode.AppendChild(minVersionNode);
282                      minVersionNode.InnerText = definition.MinVersionString;
283                  }
284                  if (definition.MaxVersionString != null)
285                  {
286                      XmlNode maxVersionNode = document.CreateNode(XmlNodeType.Element, s_maxVersion, null);
287                      serviceDefinitionNode.AppendChild(maxVersionNode);
288                      maxVersionNode.InnerText = definition.MaxVersionString;
289                  }
290                  if (definition.ReleasedVersionString != null)
291                  {
292                      XmlNode releasedVersionNode = document.CreateNode(XmlNodeType.Element, s_releasedVersion, null);
293                      serviceDefinitionNode.AppendChild(releasedVersionNode);
294                      releasedVersionNode.InnerText = definition.ReleasedVersionString;
295                  }
296              }
297          }
298          public void WriteCachedMisses(XmlNode documentNode, IEnumerable<String> cachedMisses)
299          {
300              XmlDocument document = documentNode.OwnerDocument;
301              XmlNode cacheMissesNode = document.CreateNode(XmlNodeType.Element, s_cachedMisses, null);
302              documentNode.AppendChild(cacheMissesNode);
303              foreach (String cacheMiss in cachedMisses)
304              {
305                  XmlNode cacheMissNode = document.CreateNode(XmlNodeType.Element, s_cachedMiss, null);
306                  cacheMissNode.InnerText = cacheMiss;
307                  cacheMissesNode.AppendChild(cacheMissNode);
308              }
309          }
310          public String GetLocationServiceUrl(String moniker)
311          {
312              return m_accessMappingLocationServiceUrls[moniker];
313          }
314          private static void CheckXmlNodeNull(XmlNode node, String nodeName, XmlNode parent)
315          {
316              if (node == null)
317              {
318                  throw new ConfigFileException(CommonResources.XmlNodeMissing(nodeName, parent));
319              }
320          }
321          private static void CheckXmlNodeNullOrEmpty(XmlNode node, String nodeName, XmlNode parent)
322          {
323              CheckXmlNodeNull(node, nodeName, parent);
324              if (node.InnerText.Equals(String.Empty))
325              {
326                  throw new ConfigFileException(CommonResources.XmlNodeEmpty(nodeName, parent.Name));
327              }
328          }
329          private static void CheckXmlAttributeNullOrEmpty(XmlAttribute attribute, String attributeName, XmlNode element)
330          {
331              if (attribute == null)
332              {
333                  throw new ConfigFileException(CommonResources.XmlAttributeNull(attributeName, element.Name));
334              }
335              if (attribute.InnerText.Equals(String.Empty))
336              {
337                  throw new ConfigFileException(CommonResources.XmlAttributeEmpty(attributeName, element.Name));
338              }
339          }
340          private Dictionary<String, String> m_accessMappingLocationServiceUrls;
341          private Boolean m_isClientCache;
342          private static readonly String s_lastChangeId = "LastChangeId";
343          private static readonly String s_cacheExpirationDate = "CacheExpirationDate";
344          private static readonly String s_defaultAccessMappingMoniker = "DefaultAccessMappingMoniker";
345          private static readonly String s_virtualDirectory = "VirtualDirectory";
346          private static readonly String s_services = "Services";
347          private static readonly String s_cachedMisses = "CachedMisses";
348          private static readonly String s_serviceDefinition = "ServiceDefinition";
349          private static readonly String s_cachedMiss = "CachedMiss";
350          private static readonly String s_serviceType = "ServiceType";
351          private static readonly String s_identifier = "Identifier";
352          private static readonly String s_displayName = "DisplayName";
353          private static readonly String s_locationServiceUrl = "LocationServiceUrl";
354          private static readonly String s_description = "Description";
355          private static readonly String s_relativePath = "RelativePath";
356          private static readonly String s_relativeTo = "relativeTo";
357          private static readonly String s_parentServiceType = "ParentServiceType";
358          private static readonly String s_parentIdentifier = "ParentIdentifier";
359          private static readonly String s_locationMappings = "LocationMappings";
360          private static readonly String s_locationMapping = "LocationMapping";
361          private static readonly String s_location = "Location";
362          private static readonly String s_resourceVersion = "ResourceVersion";
363          private static readonly String s_minVersion = "MinVersion";
364          private static readonly String s_maxVersion = "MaxVersion";
365          private static readonly String s_releasedVersion = "ReleasedVersion";
366          private static readonly String s_accessMappings = "AccessMappings";
367          private static readonly String s_accessMapping = "AccessMapping";
368          private static readonly String s_moniker = "Moniker";
369          private static readonly String s_accessPoint = "AccessPoint";
370      }
371      internal static class RelativeToEnumCache
372      {
373          private static Dictionary<String, RelativeToSetting> s_relativeToEnums;
374          static RelativeToEnumCache()
375          {
376              s_relativeToEnums = new Dictionary<String, RelativeToSetting>(StringComparer.OrdinalIgnoreCase);
377              s_relativeToEnums["Context"] = RelativeToSetting.Context;
378              s_relativeToEnums["FullyQualified"] = RelativeToSetting.FullyQualified;
379              s_relativeToEnums["WebApplication"] = RelativeToSetting.WebApplication;
380          }
381          internal static Dictionary<String, RelativeToSetting> GetRelativeToEnums()
382          {
383              return s_relativeToEnums;
384          }
385      }
386  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationXmlOperator.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Text;
5  using System.Xml;
6  using GitHub.Services.Common;
7  using GitHub.Services.Location;
8  using GitHub.Services.Common.Internal;
9  namespace GitHub.Services.WebApi.Location
10  {
11      internal class LocationXmlOperator
12      {
13          public LocationXmlOperator(Boolean isClientCache)
14          {
15              m_isClientCache = isClientCache;
16              m_accessMappingLocationServiceUrls = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
17          }
18          public List<ServiceDefinition> ReadServices(XmlDocument document, Dictionary<String, AccessMapping> accessMappings)
19          {
20              List<ServiceDefinition> definitions = new List<ServiceDefinition>();
21              XmlNodeList servicesNodeList = document.SelectNodes("&bsol;&bsol;" + s_services);
22              if (servicesNodeList == null)
23              {
24                  return definitions;
25              }
26              foreach (XmlNode servicesNode in servicesNodeList)
27              {
28                  foreach (XmlNode definitionNode in servicesNode.SelectNodes("./" + s_serviceDefinition))
29                  {
30                      ServiceDefinition definition = new ServiceDefinition();
31                      XmlNode serviceTypeNode = definitionNode.SelectSingleNode("./" + s_serviceType);
32                      LocationXmlOperator.CheckXmlNodeNullOrEmpty(serviceTypeNode, s_serviceType, definitionNode);
33                      definition.ServiceType = serviceTypeNode.InnerText;
<span onclick='openModal()' class='match'>34                      XmlNode identifierNode = definitionNode.SelectSingleNode("./" + s_identifier);
35                      if (m_isClientCache)
</span>36                      {
37                          LocationXmlOperator.CheckXmlNodeNullOrEmpty(identifierNode, s_identifier, definitionNode);
38                      }
39                      definition.Identifier = (identifierNode != null) ? XmlConvert.ToGuid(identifierNode.InnerText) : Guid.Empty;
40                      XmlNode displayNameNode = definitionNode.SelectSingleNode("./" + s_displayName);
41                      LocationXmlOperator.CheckXmlNodeNullOrEmpty(displayNameNode, s_displayName, definitionNode);
42                      definition.DisplayName = displayNameNode.InnerText;
43                      XmlNode descriptionNode = definitionNode.SelectSingleNode("./" + s_description);
44                      definition.Description = (descriptionNode != null) ? descriptionNode.InnerText : String.Empty;
45                      XmlNode relativePathNode = definitionNode.SelectSingleNode("./" + s_relativePath);
46                      LocationXmlOperator.CheckXmlNodeNull(relativePathNode, s_relativePath, definitionNode);
47                      definition.RelativePath = relativePathNode.InnerText;
48                      XmlAttribute relativeToAttribute = relativePathNode.Attributes[s_relativeTo];
49                      CheckXmlAttributeNullOrEmpty(relativeToAttribute, s_relativeTo, relativePathNode);
50                      RelativeToSetting setting;
51                      if (!RelativeToEnumCache.GetRelativeToEnums().TryGetValue(relativeToAttribute.InnerText, out setting))
52                      {
53                          throw new ConfigFileException(relativeToAttribute.InnerText);
54                      }
55                      definition.RelativeToSetting = setting;
56                      if (definition.RelativeToSetting == RelativeToSetting.FullyQualified && definition.RelativePath == String.Empty)
57                      {
58                          definition.RelativePath = null;
59                      }
60                      XmlNode parentServiceTypeNode = definitionNode.SelectSingleNode("./" + s_parentServiceType);
61                      definition.ParentServiceType = (parentServiceTypeNode != null) ? parentServiceTypeNode.InnerText : null;
62                      XmlNode parentIdentifierNode = definitionNode.SelectSingleNode("./" + s_parentIdentifier);
63                      definition.ParentIdentifier = (parentIdentifierNode != null) ? XmlConvert.ToGuid(parentIdentifierNode.InnerText) : Guid.Empty;
64                      definition.LocationMappings = new List<LocationMapping>();
65                      if (definition.RelativeToSetting == RelativeToSetting.FullyQualified)
66                      {
67                          XmlNodeList mappings = definitionNode.SelectNodes(".
68                          foreach (XmlNode mappingNode in mappings)
69                          {
70                              LocationMapping locationMapping = new LocationMapping();
71                              XmlNode accessMappingNode = mappingNode.SelectSingleNode("./" + s_accessMapping);
72                              LocationXmlOperator.CheckXmlNodeNullOrEmpty(accessMappingNode, s_accessMapping, mappingNode);
73                              locationMapping.AccessMappingMoniker = accessMappingNode.InnerText;
74                              XmlNode locationNode = mappingNode.SelectSingleNode("./" + s_location);
75                              if (m_isClientCache)
76                              {
77                                  CheckXmlNodeNullOrEmpty(locationNode, s_location, mappingNode);
78                              }
79                              locationMapping.Location = (locationNode != null) ? locationNode.InnerText : null;
80                              definition.LocationMappings.Add(locationMapping);
81                          }
82                      }
83                      XmlNode resourceVersionNode = definitionNode.SelectSingleNode("./" + s_resourceVersion);
84                      definition.ResourceVersion = (resourceVersionNode != null) ? XmlConvert.ToInt32(resourceVersionNode.InnerText) : 0;
85                      XmlNode minVersionNode = definitionNode.SelectSingleNode("./" + s_minVersion);
86                      definition.MinVersionString = (minVersionNode != null) ? minVersionNode.InnerText : null;
87                      XmlNode maxVersionNode = definitionNode.SelectSingleNode("./" + s_maxVersion);
88                      definition.MaxVersionString = (maxVersionNode != null) ? maxVersionNode.InnerText : null;
89                      XmlNode releasedVersionNode = definitionNode.SelectSingleNode("./" + s_releasedVersion);
90                      definition.ReleasedVersionString = (releasedVersionNode != null) ? releasedVersionNode.InnerText : null;
91                      definitions.Add(definition);
92                  }
93              }
94              return definitions;
95          }
96          public List<String> ReadCachedMisses(XmlDocument document)
97          {
98              List<String> cachedMisses = new List<String>();
99              XmlNodeList cachedMissesNodeList = document.SelectNodes("&bsol;&bsol;" + s_cachedMisses);
100              if (cachedMissesNodeList == null)
101              {
102                  return cachedMisses;
103              }
104              foreach (XmlNode cachedMissesNode in cachedMissesNodeList)
105              {
106                  foreach (XmlNode cachedMissNode in cachedMissesNode.SelectNodes("./" + s_cachedMiss))
107                  {
108                      cachedMisses.Add(cachedMissNode.InnerText);
109                  }
110              }
111              return cachedMisses;
112          }
113          public List<AccessMapping> ReadAccessMappings(XmlDocument document)
114          {
115              List<AccessMapping> accessMappings = new List<AccessMapping>();
116              XmlNodeList accessMappingNodeList = document.SelectNodes("&bsol;&bsol;" + s_accessMappings);
117              if (accessMappingNodeList == null)
118              {
119                  return accessMappings;
120              }
121              foreach (XmlNode accessMappingsNode in accessMappingNodeList)
122              {
123                  foreach (XmlNode accessMappingNode in accessMappingsNode.SelectNodes("./" + s_accessMapping))
124                  {
125                      AccessMapping accessMapping = new AccessMapping();
126                      XmlNode monikerNode = accessMappingNode.SelectSingleNode("./" + s_moniker);
127                      CheckXmlNodeNullOrEmpty(monikerNode, s_moniker, accessMappingNode);
128                      accessMapping.Moniker = monikerNode.InnerText;
129                      XmlNode accessPointNode = accessMappingNode.SelectSingleNode("./" + s_accessPoint);
130                      CheckXmlNodeNullOrEmpty(accessPointNode, s_accessPoint, accessMappingNode);
131                      accessMapping.AccessPoint = accessPointNode.InnerText;
132                      XmlNode displayNameNode = accessMappingNode.SelectSingleNode("./" + s_displayName);
133                      accessMapping.DisplayName = (displayNameNode != null) ? displayNameNode.InnerText : null;
134                      XmlNode virtualDirectoryNode = accessMappingNode.SelectSingleNode("./" + s_virtualDirectory);
135                      accessMapping.VirtualDirectory = (virtualDirectoryNode != null) ? virtualDirectoryNode.InnerText : null;
136                      if (!m_isClientCache)
137                      {
138                          XmlNode locationServiceUrlNode = accessMappingNode.SelectSingleNode("./" + s_locationServiceUrl);
139                          String locationServiceUrl = (locationServiceUrlNode != null) ? locationServiceUrlNode.InnerText : String.Empty;
140                          m_accessMappingLocationServiceUrls[accessMapping.Moniker] = locationServiceUrl;
141                      }
142                      accessMappings.Add(accessMapping);
143                  }
144              }
145              return accessMappings;
146          }
147          public Int32 ReadLastChangeId(XmlDocument document)
148          {
149              XmlNode lastChangeIdNode = document.SelectSingleNode("&bsol;&bsol;" + s_lastChangeId);
150              return (lastChangeIdNode != null) ? XmlConvert.ToInt32(lastChangeIdNode.InnerText) : -1;
151          }
152          public DateTime ReadCacheExpirationDate(XmlDocument document)
153          {
154              XmlNode cacheExpirationDateNode = document.SelectSingleNode("&bsol;&bsol;" + s_cacheExpirationDate);
155              return (cacheExpirationDateNode != null) ? XmlConvert.ToDateTime(cacheExpirationDateNode.InnerText, XmlDateTimeSerializationMode.Utc) : DateTime.MinValue;
156          }
157          public String ReadDefaultAccessMappingMoniker(XmlDocument document)
158          {
159              XmlNode defaultAccessMappingMonikerNode = document.SelectSingleNode("&bsol;&bsol;" + s_defaultAccessMappingMoniker);
160              CheckXmlNodeNullOrEmpty(defaultAccessMappingMonikerNode, s_defaultAccessMappingMoniker, document);
161              return defaultAccessMappingMonikerNode.InnerText;
162          }
163          public String ReadVirtualDirectory(XmlDocument document)
164          {
165              XmlNode virtualDirectoryNode = document.SelectSingleNode("&bsol;&bsol;" + s_virtualDirectory);
166              CheckXmlNodeNull(virtualDirectoryNode, s_virtualDirectory, document);
167              return virtualDirectoryNode.InnerText;
168          }
169          public void WriteLastChangeId(XmlNode documentNode, Int32 lastChangeId)
170          {
171              XmlNode lastChangeIdNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_lastChangeId, null);
172              documentNode.AppendChild(lastChangeIdNode);
173              lastChangeIdNode.InnerText = XmlConvert.ToString(lastChangeId);
174          }
175          public void WriteCacheExpirationDate(XmlNode documentNode, DateTime cacheExpirationDate)
176          {
177              XmlNode cacheExpirationDateNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_cacheExpirationDate, null);
178              documentNode.AppendChild(cacheExpirationDateNode);
179              cacheExpirationDateNode.InnerText = XmlConvert.ToString(cacheExpirationDate, XmlDateTimeSerializationMode.Utc);
180          }
181          public void WriteDefaultAccessMappingMoniker(XmlNode documentNode, String defaultAccessMappingMoniker)
182          {
183              XmlNode defaultAccessMappingMonikerNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_defaultAccessMappingMoniker, null);
184              documentNode.AppendChild(defaultAccessMappingMonikerNode);
185              defaultAccessMappingMonikerNode.InnerText = defaultAccessMappingMoniker;
186          }
187          public void WriteVirtualDirectory(XmlNode documentNode, String virtualDirectory)
188          {
189              XmlNode virtualDirectoryNode = documentNode.OwnerDocument.CreateNode(XmlNodeType.Element, s_virtualDirectory, null);
190              documentNode.AppendChild(virtualDirectoryNode);
191              virtualDirectoryNode.InnerText = virtualDirectory;
192          }
193          public void WriteAccessMappings(XmlNode documentNode, IEnumerable<AccessMapping> accessMappings)
194          {
195              XmlDocument document = documentNode.OwnerDocument;
196              XmlNode accessMappingsNode = document.CreateNode(XmlNodeType.Element, s_accessMappings, null);
197              documentNode.AppendChild(accessMappingsNode);
198              foreach (AccessMapping accessMapping in accessMappings)
199              {
200                  XmlNode accessMappingNode = document.CreateNode(XmlNodeType.Element, s_accessMapping, null);
201                  accessMappingsNode.AppendChild(accessMappingNode);
202                  XmlNode monikerNode = document.CreateNode(XmlNodeType.Element, s_moniker, null);
203                  accessMappingNode.AppendChild(monikerNode);
204                  monikerNode.InnerText = accessMapping.Moniker;
205                  XmlNode accessPointNode = document.CreateNode(XmlNodeType.Element, s_accessPoint, null);
206                  accessMappingNode.AppendChild(accessPointNode);
207                  accessPointNode.InnerText = accessMapping.AccessPoint;
208                  XmlNode displayNameNode = document.CreateNode(XmlNodeType.Element, s_displayName, null);
209                  accessMappingNode.AppendChild(displayNameNode);
210                  displayNameNode.InnerText = accessMapping.DisplayName;
211                  if (accessMapping.VirtualDirectory != null)
212                  {
213                      XmlNode virtualDirectoryNode = document.CreateNode(XmlNodeType.Element, s_virtualDirectory, null);
214                      accessMappingNode.AppendChild(virtualDirectoryNode);
215                      virtualDirectoryNode.InnerText = accessMapping.VirtualDirectory;
216                  }
217              }
218          }
219          public void WriteServices(XmlNode documentNode, IEnumerable<ServiceDefinition> serviceDefinitions)
220          {
221              XmlDocument document = documentNode.OwnerDocument;
222              XmlNode servicesNode = document.CreateNode(XmlNodeType.Element, s_services, null);
223              documentNode.AppendChild(servicesNode);
224              foreach (ServiceDefinition definition in serviceDefinitions)
225              {
226                  XmlNode serviceDefinitionNode = document.CreateNode(XmlNodeType.Element, s_serviceDefinition, null);
227                  servicesNode.AppendChild(serviceDefinitionNode);
228                  XmlNode serviceTypeNode = document.CreateNode(XmlNodeType.Element, s_serviceType, null);
229                  serviceDefinitionNode.AppendChild(serviceTypeNode);
230                  serviceTypeNode.InnerText = definition.ServiceType;
231                  XmlNode identifierNode = document.CreateNode(XmlNodeType.Element, s_identifier, null);
232                  serviceDefinitionNode.AppendChild(identifierNode);
233                  identifierNode.InnerText = XmlConvert.ToString(definition.Identifier);
234                  if (definition.DisplayName != null)
235                  {
236                      XmlNode displayNameNode = document.CreateNode(XmlNodeType.Element, s_displayName, null);
237                      serviceDefinitionNode.AppendChild(displayNameNode);
238                      displayNameNode.InnerText = definition.DisplayName;
239                  }
240                  if (definition.Description != null)
241                  {
242                      XmlNode descriptionNode = document.CreateNode(XmlNodeType.Element, s_description, null);
243                      serviceDefinitionNode.AppendChild(descriptionNode);
244                      descriptionNode.InnerText = definition.Description;
245                  }
246                  XmlNode relativePathNode = document.CreateNode(XmlNodeType.Element, s_relativePath, null);
247                  serviceDefinitionNode.AppendChild(relativePathNode);
248                  relativePathNode.InnerText = definition.RelativePath;
249                  XmlUtility.AddXmlAttribute(relativePathNode, s_relativeTo, definition.RelativeToSetting.ToString());
250                  XmlNode parentServiceTypeNode = document.CreateNode(XmlNodeType.Element, s_parentServiceType, null);
251                  serviceDefinitionNode.AppendChild(parentServiceTypeNode);
252                  parentServiceTypeNode.InnerText = definition.ParentServiceType;
253                  XmlNode parentIdentifierNode = document.CreateNode(XmlNodeType.Element, s_parentIdentifier, null);
254                  serviceDefinitionNode.AppendChild(parentIdentifierNode);
255                  parentIdentifierNode.InnerText = XmlConvert.ToString(definition.ParentIdentifier);
256                  if (definition.RelativeToSetting == RelativeToSetting.FullyQualified)
257                  {
258                      XmlNode locationMappingsNode = document.CreateNode(XmlNodeType.Element, s_locationMappings, null);
259                      serviceDefinitionNode.AppendChild(locationMappingsNode);
260                      foreach (LocationMapping mapping in definition.LocationMappings)
261                      {
262                          XmlNode locationMappingNode = document.CreateNode(XmlNodeType.Element, s_locationMapping, null);
263                          locationMappingsNode.AppendChild(locationMappingNode);
264                          XmlNode accessMappingNode = document.CreateNode(XmlNodeType.Element, s_accessMapping, null);
265                          locationMappingNode.AppendChild(accessMappingNode);
266                          accessMappingNode.InnerText = mapping.AccessMappingMoniker;
267                          XmlNode locationNode = document.CreateNode(XmlNodeType.Element, s_location, null);
268                          locationMappingNode.AppendChild(locationNode);
269                          locationNode.InnerText = mapping.Location;
270                      }
271                  }
272                  if (definition.ResourceVersion > 0)
273                  {
274                      XmlNode resourceVersionNode = document.CreateNode(XmlNodeType.Element, s_resourceVersion, null);
275                      serviceDefinitionNode.AppendChild(resourceVersionNode);
276                      resourceVersionNode.InnerText = XmlConvert.ToString(definition.ResourceVersion);
277                  }
278                  if (definition.MinVersionString != null)
279                  {
280                      XmlNode minVersionNode = document.CreateNode(XmlNodeType.Element, s_minVersion, null);
281                      serviceDefinitionNode.AppendChild(minVersionNode);
282                      minVersionNode.InnerText = definition.MinVersionString;
283                  }
284                  if (definition.MaxVersionString != null)
285                  {
286                      XmlNode maxVersionNode = document.CreateNode(XmlNodeType.Element, s_maxVersion, null);
287                      serviceDefinitionNode.AppendChild(maxVersionNode);
288                      maxVersionNode.InnerText = definition.MaxVersionString;
289                  }
290                  if (definition.ReleasedVersionString != null)
291                  {
292                      XmlNode releasedVersionNode = document.CreateNode(XmlNodeType.Element, s_releasedVersion, null);
293                      serviceDefinitionNode.AppendChild(releasedVersionNode);
294                      releasedVersionNode.InnerText = definition.ReleasedVersionString;
295                  }
296              }
297          }
298          public void WriteCachedMisses(XmlNode documentNode, IEnumerable<String> cachedMisses)
299          {
300              XmlDocument document = documentNode.OwnerDocument;
301              XmlNode cacheMissesNode = document.CreateNode(XmlNodeType.Element, s_cachedMisses, null);
302              documentNode.AppendChild(cacheMissesNode);
303              foreach (String cacheMiss in cachedMisses)
304              {
305                  XmlNode cacheMissNode = document.CreateNode(XmlNodeType.Element, s_cachedMiss, null);
306                  cacheMissNode.InnerText = cacheMiss;
307                  cacheMissesNode.AppendChild(cacheMissNode);
308              }
309          }
310          public String GetLocationServiceUrl(String moniker)
311          {
312              return m_accessMappingLocationServiceUrls[moniker];
313          }
314          private static void CheckXmlNodeNull(XmlNode node, String nodeName, XmlNode parent)
315          {
316              if (node == null)
317              {
318                  throw new ConfigFileException(CommonResources.XmlNodeMissing(nodeName, parent));
319              }
320          }
321          private static void CheckXmlNodeNullOrEmpty(XmlNode node, String nodeName, XmlNode parent)
322          {
323              CheckXmlNodeNull(node, nodeName, parent);
324              if (node.InnerText.Equals(String.Empty))
325              {
326                  throw new ConfigFileException(CommonResources.XmlNodeEmpty(nodeName, parent.Name));
327              }
328          }
329          private static void CheckXmlAttributeNullOrEmpty(XmlAttribute attribute, String attributeName, XmlNode element)
330          {
331              if (attribute == null)
332              {
333                  throw new ConfigFileException(CommonResources.XmlAttributeNull(attributeName, element.Name));
334              }
335              if (attribute.InnerText.Equals(String.Empty))
336              {
337                  throw new ConfigFileException(CommonResources.XmlAttributeEmpty(attributeName, element.Name));
338              }
339          }
340          private Dictionary<String, String> m_accessMappingLocationServiceUrls;
341          private Boolean m_isClientCache;
342          private static readonly String s_lastChangeId = "LastChangeId";
343          private static readonly String s_cacheExpirationDate = "CacheExpirationDate";
344          private static readonly String s_defaultAccessMappingMoniker = "DefaultAccessMappingMoniker";
345          private static readonly String s_virtualDirectory = "VirtualDirectory";
346          private static readonly String s_services = "Services";
347          private static readonly String s_cachedMisses = "CachedMisses";
348          private static readonly String s_serviceDefinition = "ServiceDefinition";
349          private static readonly String s_cachedMiss = "CachedMiss";
350          private static readonly String s_serviceType = "ServiceType";
351          private static readonly String s_identifier = "Identifier";
352          private static readonly String s_displayName = "DisplayName";
353          private static readonly String s_locationServiceUrl = "LocationServiceUrl";
354          private static readonly String s_description = "Description";
355          private static readonly String s_relativePath = "RelativePath";
356          private static readonly String s_relativeTo = "relativeTo";
357          private static readonly String s_parentServiceType = "ParentServiceType";
358          private static readonly String s_parentIdentifier = "ParentIdentifier";
359          private static readonly String s_locationMappings = "LocationMappings";
360          private static readonly String s_locationMapping = "LocationMapping";
361          private static readonly String s_location = "Location";
362          private static readonly String s_resourceVersion = "ResourceVersion";
363          private static readonly String s_minVersion = "MinVersion";
364          private static readonly String s_maxVersion = "MaxVersion";
365          private static readonly String s_releasedVersion = "ReleasedVersion";
366          private static readonly String s_accessMappings = "AccessMappings";
367          private static readonly String s_accessMapping = "AccessMapping";
368          private static readonly String s_moniker = "Moniker";
369          private static readonly String s_accessPoint = "AccessPoint";
370      }
371      internal static class RelativeToEnumCache
372      {
373          private static Dictionary<String, RelativeToSetting> s_relativeToEnums;
374          static RelativeToEnumCache()
375          {
376              s_relativeToEnums = new Dictionary<String, RelativeToSetting>(StringComparer.OrdinalIgnoreCase);
377              s_relativeToEnums["Context"] = RelativeToSetting.Context;
378              s_relativeToEnums["FullyQualified"] = RelativeToSetting.FullyQualified;
379              s_relativeToEnums["WebApplication"] = RelativeToSetting.WebApplication;
380          }
381          internal static Dictionary<String, RelativeToSetting> GetRelativeToEnums()
382          {
383              return s_relativeToEnums;
384          }
385      }
386  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationXmlOperator.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-LocationXmlOperator.cs</div>
                </div>
                <div class="column column_space"><pre><code>31                      XmlNode serviceTypeNode = definitionNode.SelectSingleNode("./" + s_serviceType);
32                      LocationXmlOperator.CheckXmlNodeNullOrEmpty(serviceTypeNode, s_serviceType, definitionNode);
</pre></code></div>
                <div class="column column_space"><pre><code>34                      XmlNode identifierNode = definitionNode.SelectSingleNode("./" + s_identifier);
35                      if (m_isClientCache)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    