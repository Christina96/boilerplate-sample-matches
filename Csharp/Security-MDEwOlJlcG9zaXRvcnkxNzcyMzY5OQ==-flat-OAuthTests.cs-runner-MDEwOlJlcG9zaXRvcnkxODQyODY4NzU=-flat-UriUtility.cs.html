
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-OAuthTests.cs</h3>
            <pre><code>1  using Microsoft.AspNetCore.Authentication.Cookies;
2  using Microsoft.AspNetCore.Builder;
3  using Microsoft.AspNetCore.Hosting;
4  using Microsoft.AspNetCore.Http;
5  using Microsoft.AspNetCore.TestHost;
6  using Microsoft.Extensions.DependencyInjection;
7  using System;
8  using System.Collections.Generic;
9  using System.Net;
10  using System.Threading.Tasks;
11  using Xunit;
12  namespace Microsoft.AspNetCore.Authentication.OAuth
13  {
14      public class OAuthTests : RemoteAuthenticationTests<OAuthOptions>
15      {
16          protected override string DefaultScheme => OAuthDefaults.DisplayName;
17          protected override Type HandlerType => typeof(OAuthHandler<OAuthOptions>);
18          protected override bool SupportsSignIn { get => false; }
19          protected override bool SupportsSignOut { get => false; }
20          protected override void RegisterAuth(AuthenticationBuilder services, Action<OAuthOptions> configure)
21          {
22              services.AddOAuth(DefaultScheme, o =>
23              {
24                  ConfigureDefaults(o);
25                  configure.Invoke(o);
26              });
27          }
28          [Fact]
29          public async Task ThrowsIfClientIdMissing()
30          {
31              var server = CreateServer(
32                  services => services.AddAuthentication().AddOAuth("weeblie", o =>
33                  {
34                      o.SignInScheme = "whatever";
35                      o.CallbackPath = "/";
36                      o.ClientSecret = "whatever";
37                      o.TokenEndpoint = "/";
38                      o.AuthorizationEndpoint = "/";
39                  }));
40              await Assert.ThrowsAsync<ArgumentException>("ClientId", () => server.SendAsync("http:&bsol;&bsol;example.com/"));
41          }
42          [Fact]
43          public async Task ThrowsIfClientSecretMissing()
44          {
45              var server = CreateServer(
46                  services => services.AddAuthentication().AddOAuth("weeblie", o =>
47                  {
48                      o.SignInScheme = "whatever";
49                      o.ClientId = "Whatever;";
50                      o.CallbackPath = "/";
51                      o.TokenEndpoint = "/";
52                      o.AuthorizationEndpoint = "/";
53                  }));
54              await Assert.ThrowsAsync<ArgumentException>("ClientSecret", () => server.SendAsync("http:&bsol;&bsol;example.com/"));
55          }
56          [Fact]
57          public async Task ThrowsIfCallbackPathMissing()
58          {
59              var server = CreateServer(
60                  services => services.AddAuthentication().AddOAuth("weeblie", o =>
61                  {
62                      o.ClientId = "Whatever;";
63                      o.ClientSecret = "Whatever;";
64                      o.TokenEndpoint = "/";
65                      o.AuthorizationEndpoint = "/";
66                      o.SignInScheme = "eh";
67                  }));
68              await Assert.ThrowsAsync<ArgumentException>("CallbackPath", () => server.SendAsync("http:&bsol;&bsol;example.com/"));
69          }
70          [Fact]
71          public async Task ThrowsIfTokenEndpointMissing()
72          {
73              var server = CreateServer(
74                  services => services.AddAuthentication().AddOAuth("weeblie", o =>
75                  {
76                      o.ClientId = "Whatever;";
77                      o.ClientSecret = "Whatever;";
78                      o.CallbackPath = "/";
79                      o.AuthorizationEndpoint = "/";
80                      o.SignInScheme = "eh";
81                  }));
82              await Assert.ThrowsAsync<ArgumentException>("TokenEndpoint", () => server.SendAsync("http:&bsol;&bsol;example.com/"));
83          }
84          [Fact]
85          public async Task ThrowsIfAuthorizationEndpointMissing()
86          {
87              var server = CreateServer(
88                  services => services.AddAuthentication().AddOAuth("weeblie", o =>
89                  {
90                      o.ClientId = "Whatever;";
91                      o.ClientSecret = "Whatever;";
92                      o.CallbackPath = "/";
93                      o.TokenEndpoint = "/";
94                      o.SignInScheme = "eh";
95                  }));
96              await Assert.ThrowsAsync<ArgumentException>("AuthorizationEndpoint", () => server.SendAsync("http:&bsol;&bsol;example.com/"));
97          }
98          [Fact]
99          public async Task RedirectToIdentityProvider_SetsCorrelationIdCookiePath_ToCallBackPath()
100          {
101              var server = CreateServer(
102                  s => s.AddAuthentication().AddOAuth(
103                      "Weblie",
104                      opt =>
105                      {
106                          ConfigureDefaults(opt);
107                      }),
108                  async ctx =>
109                  {
110                      await ctx.ChallengeAsync("Weblie");
111                      return true;
112                  });
113              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/challenge");
114              var res = transaction.Response;
115              Assert.Equal(HttpStatusCode.Redirect, res.StatusCode);
116              Assert.NotNull(res.Headers.Location);
117              var setCookie = Assert.Single(res.Headers, h => h.Key == "Set-Cookie");
118              var correlation = Assert.Single(setCookie.Value, v => v.StartsWith(".AspNetCore.Correlation."));
119              Assert.Contains("path=/oauth-callback", correlation);
120          }
121          [Fact]
122          public async Task RedirectToAuthorizeEndpoint_CorrelationIdCookieOptions_CanBeOverriden()
123          {
124              var server = CreateServer(
125                  s => s.AddAuthentication().AddOAuth(
126                      "Weblie",
127                      opt =>
128                      {
129                          ConfigureDefaults(opt);
130                          opt.CorrelationCookie.Path = "/";
131                      }),
132                  async ctx =>
133                  {
134                      await ctx.ChallengeAsync("Weblie");
135                      return true;
136                  });
137              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/challenge");
138              var res = transaction.Response;
139              Assert.Equal(HttpStatusCode.Redirect, res.StatusCode);
140              Assert.NotNull(res.Headers.Location);
141              var setCookie = Assert.Single(res.Headers, h => h.Key == "Set-Cookie");
142              var correlation = Assert.Single(setCookie.Value, v => v.StartsWith(".AspNetCore.Correlation."));
143              Assert.Contains("path=/", correlation);
144          }
145          [Fact]
146          public async Task RedirectToAuthorizeEndpoint_HasScopeAsConfigured()
147          {
148              var server = CreateServer(
149                  s => s.AddAuthentication().AddOAuth(
150                      "Weblie",
151                      opt =>
152                      {
153                          ConfigureDefaults(opt);
154                          opt.Scope.Clear();
155                          opt.Scope.Add("foo");
156                          opt.Scope.Add("bar");
157                      }),
158                  async ctx =>
159                  {
160                      await ctx.ChallengeAsync("Weblie");
161                      return true;
162                  });
163              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/challenge");
164              var res = transaction.Response;
165              Assert.Equal(HttpStatusCode.Redirect, res.StatusCode);
166              Assert.Contains("scope=foo%20bar", res.Headers.Location.Query);
167          }
168          [Fact]
169          public async Task RedirectToAuthorizeEndpoint_HasScopeAsOverwritten()
170          {
171              var server = CreateServer(
172                  s => s.AddAuthentication().AddOAuth(
173                      "Weblie",
174                      opt =>
175                      {
176                          ConfigureDefaults(opt);
177                          opt.Scope.Clear();
178                          opt.Scope.Add("foo");
179                          opt.Scope.Add("bar");
180                      }),
181                  async ctx =>
182                  {
183                      var properties = new OAuthChallengeProperties();
184                      properties.SetScope("baz", "qux");
185                      await ctx.ChallengeAsync("Weblie", properties);
186                      return true;
187                  });
188              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/challenge");
189              var res = transaction.Response;
190              Assert.Equal(HttpStatusCode.Redirect, res.StatusCode);
191              Assert.Contains("scope=baz%20qux", res.Headers.Location.Query);
192          }
193          [Fact]
194          public async Task RedirectToAuthorizeEndpoint_HasScopeAsOverwrittenWithBaseAuthenticationProperties()
195          {
196              var server = CreateServer(
197                  s => s.AddAuthentication().AddOAuth(
198                      "Weblie",
199                      opt =>
200                      {
201                          ConfigureDefaults(opt);
202                          opt.Scope.Clear();
203                          opt.Scope.Add("foo");
204                          opt.Scope.Add("bar");
205                      }),
206                  async ctx =>
207                  {
208                      var properties = new AuthenticationProperties();
209                      properties.SetParameter(OAuthChallengeProperties.ScopeKey, new string[] { "baz", "qux" });
210                      await ctx.ChallengeAsync("Weblie", properties);
211                      return true;
212                  });
213              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/challenge");
214              var res = transaction.Response;
215              Assert.Equal(HttpStatusCode.Redirect, res.StatusCode);
216              Assert.Contains("scope=baz%20qux", res.Headers.Location.Query);
217          }
218          protected override void ConfigureDefaults(OAuthOptions o)
219          {
220              o.ClientId = "Test Id";
221              o.ClientSecret = "secret";
222              o.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
223              o.AuthorizationEndpoint = "https:&bsol;&bsol;example.com/provider/login";
224              o.TokenEndpoint = "https:&bsol;&bsol;example.com/provider/token";
225              o.CallbackPath = "/oauth-callback";
226          }
227          [Fact]
228          public async Task HandleRequestAsync_RedirectsToAccessDeniedPathWhenExplicitlySet()
229          {
230              var server = CreateServer(
231                  s => s.AddAuthentication().AddOAuth(
232                      "Weblie",
233                      opt =>
234                      {
235                          opt.ClientId = "Test Id";
236                          opt.ClientSecret = "secret";
237                          opt.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
238                          opt.AuthorizationEndpoint = "https:&bsol;&bsol;example.com/provider/login";
239                          opt.TokenEndpoint = "https:&bsol;&bsol;example.com/provider/token";
240                          opt.CallbackPath = "/oauth-callback";
241                          opt.AccessDeniedPath = "/access-denied";
242                          opt.StateDataFormat = new TestStateDataFormat();
243                          opt.Events.OnRemoteFailure = context => throw new InvalidOperationException("This event should not be called.");
244                      }));
245              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/oauth-callback?error=access_denied&state=protected_state",
246                  ".AspNetCore.Correlation.Weblie.correlationId=N");
247              Assert.Equal(HttpStatusCode.Redirect, transaction.Response.StatusCode);
248              Assert.Equal("/access-denied?ReturnUrl=http%3A%2F%2Ftesthost%2Fredirect", transaction.Response.Headers.Location.ToString());
249          }
250          [Fact]
251          public async Task HandleRequestAsync_InvokesAccessDeniedEvent()
252          {
253              var server = CreateServer(
254                  s => s.AddAuthentication().AddOAuth(
255                      "Weblie",
256                      opt =>
257                      {
258                          opt.ClientId = "Test Id";
259                          opt.ClientSecret = "secret";
260                          opt.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
261                          opt.AuthorizationEndpoint = "https:&bsol;&bsol;example.com/provider/login";
262                          opt.TokenEndpoint = "https:&bsol;&bsol;example.com/provider/token";
263                          opt.CallbackPath = "/oauth-callback";
264                          opt.StateDataFormat = new TestStateDataFormat();
265                          opt.Events = new OAuthEvents()
266                          {
267                              OnAccessDenied = context =>
268                              {
269                                  Assert.Equal("testvalue", context.Properties.Items["testkey"]);
270                                  context.Response.StatusCode = StatusCodes.Status406NotAcceptable;
271                                  context.HandleResponse();
272                                  return Task.CompletedTask;
273                              }
274                          };
275                      }));
276              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/oauth-callback?error=access_denied&state=protected_state",
277                  ".AspNetCore.Correlation.Weblie.correlationId=N");
278              Assert.Equal(HttpStatusCode.NotAcceptable, transaction.Response.StatusCode);
<span onclick='openModal()' class='match'>279              Assert.Null(transaction.Response.Headers.Location);
280          }
</span>281          [Fact]
282          public async Task HandleRequestAsync_InvokesRemoteFailureEventWhenAccessDeniedPathIsNotExplicitlySet()
283          {
284              var server = CreateServer(
285                  s => s.AddAuthentication().AddOAuth(
286                      "Weblie",
287                      opt =>
288                      {
289                          opt.ClientId = "Test Id";
290                          opt.ClientSecret = "secret";
291                          opt.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
292                          opt.AuthorizationEndpoint = "https:&bsol;&bsol;example.com/provider/login";
293                          opt.TokenEndpoint = "https:&bsol;&bsol;example.com/provider/token";
294                          opt.CallbackPath = "/oauth-callback";
295                          opt.StateDataFormat = new TestStateDataFormat();
296                          opt.Events = new OAuthEvents()
297                          {
298                              OnRemoteFailure = context =>
299                              {
300                                  Assert.Equal("Access was denied by the resource owner or by the remote server.", context.Failure.Message);
301                                  Assert.Equal("testvalue", context.Properties.Items["testkey"]);
302                                  context.Response.StatusCode = StatusCodes.Status406NotAcceptable;
303                                  context.HandleResponse();
304                                  return Task.CompletedTask;
305                              }
306                          };
307                      }));
308              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/oauth-callback?error=access_denied&state=protected_state",
309                  ".AspNetCore.Correlation.Weblie.correlationId=N");
310              Assert.Equal(HttpStatusCode.NotAcceptable, transaction.Response.StatusCode);
311              Assert.Null(transaction.Response.Headers.Location);
312          }
313          [Fact]
314          public async Task RemoteAuthenticationFailed_OAuthError_IncludesProperties()
315          {
316              var server = CreateServer(
317                  s => s.AddAuthentication().AddOAuth(
318                      "Weblie",
319                      opt =>
320                      {
321                          opt.ClientId = "Test Id";
322                          opt.ClientSecret = "secret";
323                          opt.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
324                          opt.AuthorizationEndpoint = "https:&bsol;&bsol;example.com/provider/login";
325                          opt.TokenEndpoint = "https:&bsol;&bsol;example.com/provider/token";
326                          opt.CallbackPath = "/oauth-callback";
327                          opt.StateDataFormat = new TestStateDataFormat();
328                          opt.Events = new OAuthEvents()
329                          {
330                              OnRemoteFailure = context =>
331                              {
332                                  Assert.Contains("custom_error", context.Failure.Message);
333                                  Assert.Equal("testvalue", context.Properties.Items["testkey"]);
334                                  context.Response.StatusCode = StatusCodes.Status406NotAcceptable;
335                                  context.HandleResponse();
336                                  return Task.CompletedTask;
337                              }
338                          };
339                      }));
340              var transaction = await server.SendAsync("https:&bsol;&bsol;www.example.com/oauth-callback?error=custom_error&state=protected_state",
341                  ".AspNetCore.Correlation.Weblie.correlationId=N");
342              Assert.Equal(HttpStatusCode.NotAcceptable, transaction.Response.StatusCode);
343              Assert.Null(transaction.Response.Headers.Location);
344          }
345          private static TestServer CreateServer(Action<IServiceCollection> configureServices, Func<HttpContext, Task<bool>> handler = null)
346          {
347              var builder = new WebHostBuilder()
348                  .Configure(app =>
349                  {
350                      app.UseAuthentication();
351                      app.Use(async (context, next) =>
352                      {
353                          if (handler == null || ! await handler(context))
354                          {
355                              await next();
356                          }
357                      });
358                  })
359                  .ConfigureServices(configureServices);
360              return new TestServer(builder);
361          }
362          private class TestStateDataFormat : ISecureDataFormat<AuthenticationProperties>
363          {
364              private AuthenticationProperties Data { get; set; }
365              public string Protect(AuthenticationProperties data)
366              {
367                  return "protected_state";
368              }
369              public string Protect(AuthenticationProperties data, string purpose)
370              {
371                  throw new NotImplementedException();
372              }
373              public AuthenticationProperties Unprotect(string protectedText)
374              {
375                  Assert.Equal("protected_state", protectedText);
376                  var properties = new AuthenticationProperties(new Dictionary<string, string>()
377                  {
378                      { ".xsrf", "correlationId" },
379                      { "testkey", "testvalue" }
380                  });
381                  properties.RedirectUri = "http:&bsol;&bsol;testhost/redirect";
382                  return properties;
383              }
384              public AuthenticationProperties Unprotect(string protectedText, string purpose)
385              {
386                  throw new NotImplementedException();
387              }
388          }
389      }
390  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-UriUtility.cs</h3>
            <pre><code>1  #define ENTITY_ENCODE_HIGH_ASCII_CHARS
2  using System;
3  using System.Collections;
4  using System.Collections.Generic;
5  using System.Collections.Specialized;
6  using System.ComponentModel;
7  using System.Diagnostics;
8  using System.Diagnostics.CodeAnalysis;
9  using System.Globalization;
10  using System.IO;
11  using System.Net;
12  using System.Runtime.Serialization;
13  using System.Text;
14  using System.Text.RegularExpressions;
15  using System.Net.Sockets;
16  namespace GitHub.Services.Common.Internal
17  {
18      [EditorBrowsable(EditorBrowsableState.Never)]
19      public static class UriUtility
20      {
21          private const String c_uriSchemeHttp = "http";
22          private const String c_uriSchemeHttps = "https";
23          private static readonly ICollection<string> UnsafeUriSchemeList = new HashSet<string>(new string[] {
24              "javascript", "vbscript"
25          }, VssStringComparer.UriScheme);
26          private static readonly ICollection<string> SafeUriSchemeList = new HashSet<string>(new string[] {
27              "http", "https", "ftp", "gopher", "mailto", "news", "telnet", "wais",
28              "vstfs", "tfs", "alm", "mtm", "mtms", "mfbclient", "mfbclients",
29              "x-mvwit"
30          }, VssStringComparer.UriScheme);
31          private const char PathSeparatorChar = '/';
32          private const string PathSeparator = "/";
33          private class _AbsoluteUriStringComparer : IEqualityComparer<Uri>
34          {
35              public bool Equals(Uri x, Uri y)
36              {
37                  string xAbsoluteUri = (x != null) ? GetInvariantAbsoluteUri(x) : null;
38                  string yAbsoluteUri = (y != null) ? GetInvariantAbsoluteUri(y) : null;
39                  return VssStringComparer.Url.Equals(xAbsoluteUri, yAbsoluteUri);
40              }
41              public int GetHashCode(Uri obj)
42              {
43                  return GetInvariantAbsoluteUri(obj).GetHashCode();
44              }
45          }
46          private class _UrlPathIgnoreSeparatorsComparer : IEqualityComparer<string>
47          {
48              public bool Equals(string x, string y)
49              {
50                  return VssStringComparer.UrlPath.Equals(TrimPathSeparators(x), TrimPathSeparators(y));
51              }
52              public int GetHashCode(string obj)
53              {
54                  return VssStringComparer.UrlPath.GetHashCode(TrimPathSeparators(obj));
55              }
56          }
57          public static IEqualityComparer<Uri> AbsoluteUriStringComparer = new _AbsoluteUriStringComparer();
58          public static IEqualityComparer<string> UrlPathIgnoreSeparatorsComparer = new _UrlPathIgnoreSeparatorsComparer();
59          public static bool IsUriUnsafe(Uri uri)
60          {
61              ArgumentUtility.CheckForNull(uri, "uri");
62              return !uri.IsAbsoluteUri || UnsafeUriSchemeList.Contains(uri.Scheme)
63                     || IsUriLocalFile(uri); 
64          }
65          public static bool IsUriSafe(Uri uri)
66          {
67              ArgumentUtility.CheckForNull(uri, "uri");
68              return uri.IsAbsoluteUri && SafeUriSchemeList.Contains(uri.Scheme)
69                     && !IsUriLocalFile(uri); 
70          }
71          public static bool IsUriLocalFile(Uri uri)
72          {
73              ArgumentUtility.CheckForNull(uri, "uri");
74              return uri.IsAbsoluteUri && uri.IsFile && !uri.IsUnc;
75          }
76          public static string GetInvariantAbsoluteUri(Uri uri)
77          {
78              Debug.Assert(uri != null);
79              Debug.Assert(uri.IsAbsoluteUri);
80              string absoluteUri = uri.AbsoluteUri;
81              if (uri.Segments.Length > 1)
82              {
83                  absoluteUri = TrimEndingPathSeparator(absoluteUri);
84              }
85              return absoluteUri.ToLowerInvariant();
86          }
87          public static Uri Combine(string baseUri, String relativePath, Boolean treatAbsolutePathAsRelative)
88          {
89              Uri uri = new Uri(baseUri);
90              Debug.Assert(uri.IsAbsoluteUri);
91              return Combine(uri, relativePath, treatAbsolutePathAsRelative);
92          }
93          public static Uri Combine(Uri baseUri, String relativePath, Boolean treatAbsolutePathAsRelative)
94          {
95              if (baseUri == null)
96              {
97                  throw new ArgumentNullException("baseUri");
98              }
99              if (relativePath == null)
100              {
101                  throw new ArgumentNullException("relativePath");
102              }
103              UriBuilder uriBuilder = new UriBuilder(baseUri);
104              Char[] forwardSlash = new Char[] { '/' };
105              uriBuilder.Path = uriBuilder.Path.TrimEnd(forwardSlash);
106              uriBuilder.Path = UriUtility.AppendSlashToPathIfNeeded(uriBuilder.Path);
107              if (VssStringComparer.Url.StartsWith(relativePath, "/"))
108              {
109                  if (treatAbsolutePathAsRelative)
110                  {
111                      relativePath = relativePath.TrimStart(forwardSlash);
112                  }
113                  else
114                  {
115                      throw new ArgumentException(CommonResources.AbsoluteVirtualPathNotAllowed(relativePath), "relativePath");
116                  }
117              }
118              CheckRelativePath(relativePath);
119              Uri relativeUri = new Uri(relativePath, UriKind.Relative);
120              return new Uri(uriBuilder.Uri, relativeUri);
121          }
122          public static bool Equals(Uri uri1, Uri uri2)
123          {
124              return AbsoluteUriStringComparer.Equals(uri1, uri2);
125          }
126          public static string CombinePath(string part1, string part2)
127          {
128              char[] slash = new char[] { '/' };
129              if (string.IsNullOrEmpty(part1))
130              {
131                  return part2;
132              }
133              if (string.IsNullOrEmpty(part2))
134              {
135                  return part1;
136              }
137              return string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}/{1}", part1.TrimEnd(slash), part2.TrimStart(slash));
138          }
139          public static bool IsUriHttp(Uri uri)
140          {
141              ArgumentUtility.CheckForNull(uri, "uri");
142              return uri.IsAbsoluteUri && (uri.Scheme == c_uriSchemeHttp || uri.Scheme == c_uriSchemeHttps);
143          }
144          public static void CheckUriIsHttp(Uri uri)
145          {
146              CheckUriIsHttp(uri, true);
147          }
148          public static void CheckUriIsHttp(Uri uri, bool allowPathAndQuery)
149          {
150              if (uri != null)
151              {
152                  if (!IsUriHttp(uri))
153                  {
154                      throw new VssServiceException(CommonResources.UriUtility_UriNotAllowed(uri.AbsoluteUri));
155                  }
156                  if (allowPathAndQuery == false && uri.PathAndQuery.Trim(new char[] { '/' }).Length > 0)
157                  {
158                      throw new VssServiceException(CommonResources.UriUtility_MustBeAuthorityOnlyUri(uri, uri.GetLeftPart(UriPartial.Authority)));
159                  }
160              }
161          }
162          public static void CheckUriIsAbsoluteAndHttp(Uri uri)
163          {
164              CheckUriIsAbsoluteAndHttp(uri, true);
165          }
166          public static void CheckUriIsAbsoluteAndHttp(Uri uri, bool allowPathAndQuery)
167          {
168              if (uri != null)
169              {
170                  if (uri.IsAbsoluteUri == false)
171                  {
172                      throw new VssServiceException(CommonResources.UriUtility_AbsoluteUriRequired(uri.OriginalString));
173                  }
174                  CheckUriIsHttp(uri, allowPathAndQuery);
175              }
176          }
177          public static void CheckRelativePath(string relativePath)
178          {
179              if (string.IsNullOrEmpty(relativePath) == false)
180              {
181                  try
182                  {
183                      relativePath = relativePath.Replace("\\", "/");
184                      Uri temp = new Uri(relativePath, UriKind.RelativeOrAbsolute);
185                      if (temp.IsAbsoluteUri == true)
186                      {
187                          throw new VssServiceException(CommonResources.UriUtility_RelativePathInvalid(relativePath));
188                      }
189                  }
190                  catch (Exception)
191                  {
192                      throw new VssServiceException(CommonResources.UriUtility_RelativePathInvalid(relativePath));
193                  }
194              }
195          }
196          public static string GetDavUncFromHttpPath(string httppath)
197          {
198              Uri uri = new Uri(httppath, UriKind.Absolute);
199              CheckUriIsHttp(uri);
200              System.Text.StringBuilder sb = new System.Text.StringBuilder();
<span onclick='openModal()' class='match'>201              sb.Append(System.IO.Path.DirectorySeparatorChar);
202              sb.Append(System.IO.Path.DirectorySeparatorChar);
</span>203              sb.Append(uri.Host);
204              if (uri.Scheme == Uri.UriSchemeHttps)
205              {
206                  sb.Append("@SSL");
207              }
208              if (!uri.IsDefaultPort)
209              {
210                  sb.Append("@");
211                  sb.Append(uri.Port);
212              }
213              sb.Append(System.IO.Path.DirectorySeparatorChar);
214              sb.Append("DavWWWRoot"); 
215              sb.Append(System.IO.Path.DirectorySeparatorChar);
216              string specpath = uri.GetComponents(UriComponents.Path, UriFormat.Unescaped);
217              string normpath = specpath.Replace('/', System.IO.Path.DirectorySeparatorChar);
218              sb.Append(normpath);
219              return sb.ToString();
220          }
221          public static Uri TryGetHttpUriFromDavUncPath(string uncPath)
222          {
223              if (uncPath == null)
224              {
225                  throw new ArgumentNullException("uncPath");
226              }
227              Regex regex = new Regex(@"^\\\\(?<host>[^\\|@]+)(?<ssl>@SSL)?(@(?<port>\d+))?\\DavWWWRoot\\(?<path>.+)$", RegexOptions.IgnoreCase | RegexOptions.Singleline);
228              Match match = regex.Match(uncPath);
229              if (match.Success)
230              {
231                  Group hostGroup = match.Groups["host"];
232                  Group sslGroup = match.Groups["ssl"];
233                  Group portGroup = match.Groups["port"];
234                  Group pathGroup = match.Groups["path"];
235                  string scheme = (!sslGroup.Success) ? Uri.UriSchemeHttp : Uri.UriSchemeHttps;
236                  string hostName = hostGroup.Value;
237                  string port = (!portGroup.Success) ? "" : ":" + portGroup.Value;
238                  string path = pathGroup.Value.Replace(Path.DirectorySeparatorChar, '/');
239                  string url = String.Format(CultureInfo.InvariantCulture, "{0}:&bsol;&bsol;{1}{2}/{3}", scheme, hostName, port, path);
240                  return new Uri(url, UriKind.Absolute);
241              }
242              return null;
243          }
244          public static bool IsSameMachine(string hostname1, string hostname2)
245          {
246              bool isSame = false;
247              try
248              {
249                  if (string.IsNullOrEmpty(hostname1) || string.IsNullOrEmpty(hostname2))
250                  {
251                      isSame = false;
252                  }
253                  else if (String.Equals(hostname1, hostname2, StringComparison.OrdinalIgnoreCase))
254                  {
255                      isSame = true;
256                  }
257                  else
258                  {
259                      string host1Dns = Dns.GetHostEntry(hostname1).HostName;
260                      string host2Dns = Dns.GetHostEntry(hostname2).HostName;
261                      isSame = string.Equals(host1Dns, host2Dns, StringComparison.OrdinalIgnoreCase);
262                  }
263              }
264              catch (SocketException)
265              {
266              }
267              return isSame;
268          }
269          public static Boolean IsSubdomainOf(string domain, string parentDomain)
270          {
271              return domain.EndsWith(parentDomain, StringComparison.Ordinal) &&
272                     (domain.Length == parentDomain.Length || domain[domain.Length - parentDomain.Length - 1] == '.');
273          }
274          public static Uri GetAbsoluteUriFromString(string uriString)
275          {
276              Uri uri = GetUriFromString(uriString);
277              if (uri == null)
278              {
279                  throw new VssServiceException(CommonResources.UrlNotValid());
280              }
281              return uri;
282          }
283          public static Uri GetUriFromString(string val)
284          {
285              Uri uri;
286              if (TryCreateAbsoluteUri(val, true, out uri))
287              {
288                  return uri;
289              }
290              return null;
291          }
292          public static bool TryCreateAbsoluteUri(string val, bool requireHttpScheme, out Uri uri)
293          {
294              uri = null;
295              val = val != null ? val.Trim() : null;
296              if (string.IsNullOrEmpty(val))
297              {
298                  return false;
299              }
300              try
301              {
302                  uri = new Uri(val);
303              }
304              catch (FormatException)
305              {
306              }
307              if ((uri == null || !uri.IsAbsoluteUri) &&
308                  !VssStringComparer.Url.StartsWith(val, c_uriSchemeHttp) &&
309                  !VssStringComparer.Url.StartsWith(val, c_uriSchemeHttps))
310              {
311                  try
312                  {
313                      val = c_uriSchemeHttp + ":&bsol;&bsol;" + val;
314                      uri = new Uri(val);
315                  }
316                  catch (FormatException)
317                  {
318                  }
319              }
320              if (uri == null)
321              {
322                  return false;
323              }
324              if (requireHttpScheme &&
325                  !VssStringComparer.Url.StartsWith(uri.Scheme, c_uriSchemeHttp) &&
326                  !VssStringComparer.Url.StartsWith(uri.Scheme, c_uriSchemeHttps))
327              {
328                  return false;
329              }
330              if (!uri.IsAbsoluteUri)
331              {
332                  uri = null;
333                  return false;
334              }
335              return true;
336          }
337          public static string EnsureStartsWithPathSeparator(string relativePath)
338          {
339              if (relativePath != null && !VssStringComparer.Url.StartsWith(relativePath, PathSeparator))
340              {
341                  relativePath = PathSeparator + relativePath;
342              }
343              return relativePath;
344          }
345          public static string EnsureEndsWithPathSeparator(string relativePath)
346          {
347              if (relativePath != null && !VssStringComparer.Url.EndsWith(relativePath, PathSeparator))
348              {
349                  relativePath += PathSeparator;
350              }
351              return relativePath;
352          }
353          public static string TrimStartingPathSeparator(string relativePath)
354          {
355              return (relativePath != null) ? relativePath.TrimStart(PathSeparatorChar) : null;
356          }
357          public static string TrimEndingPathSeparator(string relativePath)
358          {
359              return (relativePath != null) ? relativePath.TrimEnd(PathSeparatorChar) : null;
360          }
361          public static string TrimPathSeparators(string relativePath)
362          {
363              return (relativePath != null) ? relativePath.Trim(PathSeparatorChar) : null;
364          }
365          public static String AppendSlashToPathIfNeeded(string path)
366          {
367              if (path == null) return null;
368              int l = path.Length;
369              if (l == 0) return path;
370              if (path[l - 1] != '/')
371                  path += '/';
372              return path;
373          }
374          public static Uri NormalizePathSeparators(Uri uri)
375          {
376              if (uri.LocalPath.Contains("&bsol;&bsol;"))
377              {
378                  UriBuilder builder = new UriBuilder(uri);
379                  string path = builder.Path;
380                  while (path.Contains("&bsol;&bsol;"))
381                  {
382                      path = path.Replace("&bsol;&bsol;", "/");
383                  }
384                  builder.Path = path;
385                  uri = builder.Uri;
386              }
387              return uri;
388          }
389          #region functionality forked from System.Web.HttpUtility
390          /&bsol;*************************************************************************************************
391          /&bsol;*************************************************************************************************
392          #region ParseFragmentString
393          public static NameValueCollection ParseFragmentString(string fragment)
394          {
395              return ParseFragmentString(fragment, Encoding.UTF8);
396          }
397          public static NameValueCollection ParseFragmentString(string fragment, Encoding encoding)
398          {
399              return ParseFragmentString(fragment, encoding, true);
400          }
401          public static NameValueCollection ParseFragmentString(string fragment, Encoding encoding, Boolean urlEncoded)
402          {
403              ArgumentUtility.CheckForNull(fragment, "fragment");
404              ArgumentUtility.CheckForNull(encoding, "encoding");
405              if (fragment.Length > 0 && fragment[0] == '#')
406              {
407                  fragment = fragment.Substring(1);
408              }
409              return new HttpValueCollection(fragment, false, urlEncoded, encoding);
410          }
411          #endregion
412          #region ParseQueryString
413          public static NameValueCollection ParseQueryString(string query)
414          {
415              return ParseQueryString(query, Encoding.UTF8);
416          }
417          public static NameValueCollection ParseQueryString(string query, Encoding encoding)
418          {
419              return ParseQueryString(query, encoding, true);
420          }
421          public static NameValueCollection ParseQueryString(string query, Encoding encoding, Boolean urlEncoded)
422          {
423              ArgumentUtility.CheckForNull(query, "query");
424              ArgumentUtility.CheckForNull(encoding, "encoding");
425              if (query.Length > 0 && query[0] == '?')
426              {
427                  query = query.Substring(1);
428              }
429              return new HttpValueCollection(query, false, urlEncoded, encoding);
430          }
431          #endregion
432          #region UrlEncode implementation
433          private static byte[] UrlEncode(byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue)
434          {
435              byte[] encoded = UrlEncode(bytes, offset, count);
436              return (alwaysCreateNewReturnValue && (encoded != null) && (encoded == bytes))
437                  ? (byte[])encoded.Clone()
438                  : encoded;
439          }
440          private static byte[] UrlEncode(byte[] bytes, int offset, int count)
441          {
442              if (!ValidateUrlEncodingParameters(bytes, offset, count))
443              {
444                  return null;
445              }
446              int cSpaces = 0;
447              int cUnsafe = 0;
448              for (int i = 0; i < count; i++)
449              {
450                  char ch = (char)bytes[offset + i];
451                  if (ch == ' ')
452                      cSpaces++;
453                  else if (!IsUrlSafeChar(ch))
454                      cUnsafe++;
455              }
456              if (cSpaces == 0 && cUnsafe == 0)
457                  return bytes;
458              byte[] expandedBytes = new byte[count + cUnsafe * 2];
459              int pos = 0;
460              for (int i = 0; i < count; i++)
461              {
462                  byte b = bytes[offset + i];
463                  char ch = (char)b;
464                  if (IsUrlSafeChar(ch))
465                  {
466                      expandedBytes[pos++] = b;
467                  }
468                  else if (ch == ' ')
469                  {
470                      expandedBytes[pos++] = (byte)'+';
471                  }
472                  else
473                  {
474                      expandedBytes[pos++] = (byte)'%';
475                      expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);
476                      expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);
477                  }
478              }
479              return expandedBytes;
480          }
481          private static String UrlEncodeNonAscii(string str, Encoding e)
482          {
483              if (String.IsNullOrEmpty(str))
484                  return str;
485              if (e == null)
486                  e = Encoding.UTF8;
487              byte[] bytes = e.GetBytes(str);
488              byte[] encodedBytes = UrlEncodeNonAscii(bytes, 0, bytes.Length, false &bsol;* alwaysCreateNewReturnValue */);
489              return Encoding.ASCII.GetString(encodedBytes);
490          }
491          private static byte[] UrlEncodeNonAscii(byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue)
492          {
493              if (!ValidateUrlEncodingParameters(bytes, offset, count))
494              {
495                  return null;
496              }
497              int cNonAscii = 0;
498              for (int i = 0; i < count; i++)
499              {
500                  if (IsNonAsciiByte(bytes[offset + i]))
501                      cNonAscii++;
502              }
503              if (!alwaysCreateNewReturnValue && cNonAscii == 0)
504                  return bytes;
505              byte[] expandedBytes = new byte[count + cNonAscii * 2];
506              int pos = 0;
507              for (int i = 0; i < count; i++)
508              {
509                  byte b = bytes[offset + i];
510                  if (IsNonAsciiByte(b))
511                  {
512                      expandedBytes[pos++] = (byte)'%';
513                      expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);
514                      expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);
515                  }
516                  else
517                  {
518                      expandedBytes[pos++] = b;
519                  }
520              }
521              return expandedBytes;
522          }
523          #endregion
524          #region UrlEncode public methods
525          public static string UrlEncode(string str)
526          {
527              if (str == null)
528                  return null;
529              return UrlEncode(str, Encoding.UTF8);
530          }
531          public static string Base64Encode(string str)
532          {
533              if (str == null)
534                  return null;
535              return Convert.ToBase64String(Encoding.UTF8.GetBytes(str));
536          }
537          public static string UrlEncode(string str, Encoding e)
538          {
539              if (str == null)
540                  return null;
541              return Encoding.ASCII.GetString(UrlEncodeToBytes(str, e));
542          }
543          public static string UrlEncode(byte[] bytes)
544          {
545              if (bytes == null)
546                  return null;
547              return Encoding.ASCII.GetString(UrlEncodeToBytes(bytes));
548          }
549          public static byte[] UrlEncodeToBytes(string str)
550          {
551              if (str == null)
552                  return null;
553              return UrlEncodeToBytes(str, Encoding.UTF8);
554          }
555          public static byte[] UrlEncodeToBytes(byte[] bytes)
556          {
557              if (bytes == null)
558                  return null;
559              return UrlEncodeToBytes(bytes, 0, bytes.Length);
560          }
561          public static byte[] UrlEncodeToBytes(string str, Encoding e)
562          {
563              if (str == null)
564                  return null;
565              byte[] bytes = e.GetBytes(str);
566              return UrlEncode(bytes, 0, bytes.Length, false &bsol;* alwaysCreateNewReturnValue */);
567          }
568          public static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count)
569          {
570              return UrlEncode(bytes, offset, count, true &bsol;* alwaysCreateNewReturnValue */);
571          }
572          public static string UrlPathEncode(string str)
573          {
574              if (String.IsNullOrEmpty(str))
575              {
576                  return str;
577              }
578              int i = str.IndexOf('?');
579              if (i >= 0)
580                  return UrlPathEncode(str.Substring(0, i)) + str.Substring(i);
581              return UrlEncodeSpaces(UrlEncodeNonAscii(str, Encoding.UTF8));
582          }
583          #endregion
584          #region UrlEncodeUnicode
585          public static string UrlEncodeUnicode(string value)
586          {
587              if (value == null)
588              {
589                  return null;
590              }
591              int l = value.Length;
592              StringBuilder sb = new StringBuilder(l);
593              for (int i = 0; i < l; i++)
594              {
595                  char ch = value[i];
596                  if ((ch & 0xff80) == 0)
597                  {  
598                      if (IsUrlSafeChar(ch))
599                      {
600                          sb.Append(ch);
601                      }
602                      else if (ch == ' ')
603                      {
604                          sb.Append('+');
605                      }
606                      else
607                      {
608                          sb.Append('%');
609                          sb.Append(IntToHex((ch >> 4) & 0xf));
610                          sb.Append(IntToHex((ch) & 0xf));
611                      }
612                  }
613                  else
614                  { 
615                      sb.Append("%u");
616                      sb.Append(IntToHex((ch >> 12) & 0xf));
617                      sb.Append(IntToHex((ch >> 8) & 0xf));
618                      sb.Append(IntToHex((ch >> 4) & 0xf));
619                      sb.Append(IntToHex((ch) & 0xf));
620                  }
621              }
622              return sb.ToString();
623          }
624          #endregion
625          #region HttpValueCollection nested class
626          [Serializable()]
627          internal class HttpValueCollection : NameValueCollection
628          {
629              internal HttpValueCollection()
630                  : base(StringComparer.OrdinalIgnoreCase)
631              {
632              }
633              internal HttpValueCollection(String str, bool readOnly, bool urlencoded, Encoding encoding)
634                  : base(StringComparer.OrdinalIgnoreCase)
635              {
636                  if (!String.IsNullOrEmpty(str))
637                      FillFromString(str, urlencoded, encoding);
638                  IsReadOnly = readOnly;
639              }
640              internal HttpValueCollection(int capacity)
641                  : base(capacity, StringComparer.OrdinalIgnoreCase)
642              {
643              }
644              protected HttpValueCollection(SerializationInfo info, StreamingContext context)
645                  : base(info, context)
646              {
647              }
648              internal void MakeReadOnly()
649              {
650                  IsReadOnly = true;
651              }
652              internal void MakeReadWrite()
653              {
654                  IsReadOnly = false;
655              }
656              internal void FillFromString(String s)
657              {
658                  FillFromString(s, false, null);
659              }
660              internal void FillFromString(String s, bool urlencoded, Encoding encoding)
661              {
662                  int l = (s != null) ? s.Length : 0;
663                  int i = 0;
664                  while (i < l)
665                  {
666                      int si = i;
667                      int ti = -1;
668                      while (i < l)
669                      {
670                          char ch = s[i];
671                          if (ch == '=')
672                          {
673                              if (ti < 0)
674                                  ti = i;
675                          }
676                          else if (ch == '&')
677                          {
678                              break;
679                          }
680                          i++;
681                      }
682                      String name = null;
683                      String value = null;
684                      if (ti >= 0)
685                      {
686                          name = s.Substring(si, ti - si);
687                          value = s.Substring(ti + 1, i - ti - 1);
688                      }
689                      else
690                      {
691                          value = s.Substring(si, i - si);
692                      }
693                      if (urlencoded)
694                          base.Add(
695                             UriUtility.UrlDecode(name, encoding),
696                             UriUtility.UrlDecode(value, encoding));
697                      else
698                          base.Add(name, value);
699                      if (i == l - 1 && s[i] == '&')
700                          base.Add(null, String.Empty);
701                      i++;
702                  }
703              }
704              internal void FillFromEncodedBytes(byte[] bytes, Encoding encoding)
705              {
706                  int l = (bytes != null) ? bytes.Length : 0;
707                  int i = 0;
708                  while (i < l)
709                  {
710                      int si = i;
711                      int ti = -1;
712                      while (i < l)
713                      {
714                          byte b = bytes[i];
715                          if (b == '=')
716                          {
717                              if (ti < 0)
718                                  ti = i;
719                          }
720                          else if (b == '&')
721                          {
722                              break;
723                          }
724                          i++;
725                      }
726                      String name, value;
727                      if (ti >= 0)
728                      {
729                          name = UriUtility.UrlDecode(bytes, si, ti - si, encoding);
730                          value = UriUtility.UrlDecode(bytes, ti + 1, i - ti - 1, encoding);
731                      }
732                      else
733                      {
734                          name = null;
735                          value = UriUtility.UrlDecode(bytes, si, i - si, encoding);
736                      }
737                      base.Add(name, value);
738                      if (i == l - 1 && bytes[i] == '&')
739                          base.Add(null, String.Empty);
740                      i++;
741                  }
742              }
743              internal void Reset()
744              {
745                  base.Clear();
746              }
747              public override String ToString()
748              {
749                  return ToString(true);
750              }
751              internal virtual String ToString(bool urlencoded)
752              {
753                  return ToString(urlencoded, null);
754              }
755              internal virtual String ToString(bool urlencoded, IDictionary excludeKeys)
756              {
757                  int n = Count;
758                  if (n == 0)
759                      return String.Empty;
760                  StringBuilder s = new StringBuilder();
761                  String key, keyPrefix, item;
762                  for (int i = 0; i < n; i++)
763                  {
764                      key = GetKey(i);
765                      if (excludeKeys != null && key != null && excludeKeys[key] != null)
766                          continue;
767                      if (urlencoded)
768                          key = UriUtility.UrlEncodeUnicode(key);
769                      keyPrefix = (key != null) ? (key + "=") : String.Empty;
770                      ArrayList values = (ArrayList)BaseGet(i);
771                      int numValues = (values != null) ? values.Count : 0;
772                      if (s.Length > 0)
773                          s.Append('&');
774                      if (numValues == 1)
775                      {
776                          s.Append(keyPrefix);
777                          item = (String)values[0];
778                          if (urlencoded)
779                              item = UriUtility.UrlEncodeUnicode(item);
780                          s.Append(item);
781                      }
782                      else if (numValues == 0)
783                      {
784                          s.Append(keyPrefix);
785                      }
786                      else
787                      {
788                          for (int j = 0; j < numValues; j++)
789                          {
790                              if (j > 0)
791                                  s.Append('&');
792                              s.Append(keyPrefix);
793                              item = (String)values[j];
794                              if (urlencoded)
795                                  item = UriUtility.UrlEncodeUnicode(item);
796                              s.Append(item);
797                          }
798                      }
799                  }
800                  return s.ToString();
801              }
802          }
803          #endregion
804          #region HtmlEncode
805          public static string HtmlEncode(string value)
806          {
807              if (String.IsNullOrEmpty(value))
808              {
809                  return value;
810              }
811              int index = IndexOfHtmlEncodingChars(value, 0);
812              if (index == -1)
813              {
814                  return value;
815              }
816              using (StringWriter writer = new StringWriter(CultureInfo.InvariantCulture))
817              {
818                  HtmlEncode(value, writer);
819                  return writer.ToString();
820              }
821          }
822          public static unsafe void HtmlEncode(string value, TextWriter output)
823          {
824              if (value == null)
825              {
826                  return;
827              }
828              if (output == null)
829              {
830                  throw new ArgumentNullException("output");
831              }
832              int index = IndexOfHtmlEncodingChars(value, 0);
833              if (index == -1)
834              {
835                  output.Write(value);
836                  return;
837              }
838              Debug.Assert(0 <= index && index <= value.Length, "0 <= index && index <= value.Length");
839              int cch = value.Length - index;
840              fixed (char* str = value)
841              {
842                  char* pch = str;
843                  while (index-- > 0)
844                  {
845                      output.Write(*pch++);
846                  }
847                  while (cch-- > 0)
848                  {
849                      char ch = *pch++;
850                      if (ch <= '>')
851                      {
852                          switch (ch)
853                          {
854                              case '<':
855                                  output.Write("&lt;");
856                                  break;
857                              case '>':
858                                  output.Write("&gt;");
859                                  break;
860                              case '"':
861                                  output.Write("&quot;");
862                                  break;
863                              case '\'':
864                                  output.Write("&#39;");
865                                  break;
866                              case '&':
867                                  output.Write("&amp;");
868                                  break;
869                              default:
870                                  output.Write(ch);
871                                  break;
872                          }
873                      }
874  #if ENTITY_ENCODE_HIGH_ASCII_CHARS
875                      else if (ch >= 160 && ch < 256)
876                      {
877                          output.Write("&#");
878                          output.Write(((int)ch).ToString(NumberFormatInfo.InvariantInfo));
879                          output.Write(';');
880                      }
881  #endif 
882                      else
883                      {
884                          output.Write(ch);
885                      }
886                  }
887              }
888          }
889          #endregion
890          #region HtmlEncode/Decode helper methods
891          private static unsafe int IndexOfHtmlEncodingChars(string s, int startPos)
892          {
893              Debug.Assert(0 <= startPos && startPos <= s.Length, "0 <= startPos && startPos <= s.Length");
894              int cch = s.Length - startPos;
895              fixed (char* str = s)
896              {
897                  for (char* pch = &str[startPos]; cch > 0; pch++, cch--)
898                  {
899                      char ch = *pch;
900                      if (ch <= '>')
901                      {
902                          switch (ch)
903                          {
904                              case '<':
905                              case '>':
906                              case '"':
907                              case '\'':
908                              case '&':
909                                  return s.Length - cch;
910                          }
911                      }
912  #if ENTITY_ENCODE_HIGH_ASCII_CHARS
913                      else if (ch >= 160 && ch < 256)
914                      {
915                          return s.Length - cch;
916                      }
917  #endif 
918                  }
919              }
920              return -1;
921          }
922          #endregion
923          #region UrlDecode implementation
924          private static string UrlDecodeInternal(string value, Encoding encoding)
925          {
926              if (value == null)
927              {
928                  return null;
929              }
930              int count = value.Length;
931              UrlDecoder helper = new UrlDecoder(count, encoding);
932              for (int pos = 0; pos < count; pos++)
933              {
934                  char ch = value[pos];
935                  if (ch == '+')
936                  {
937                      ch = ' ';
938                  }
939                  else if (ch == '%' && pos < count - 2)
940                  {
941                      if (value[pos + 1] == 'u' && pos < count - 5)
942                      {
943                          int h1 = HexToInt(value[pos + 2]);
944                          int h2 = HexToInt(value[pos + 3]);
945                          int h3 = HexToInt(value[pos + 4]);
946                          int h4 = HexToInt(value[pos + 5]);
947                          if (h1 >= 0 && h2 >= 0 && h3 >= 0 && h4 >= 0)
948                          {   
949                              ch = (char)((h1 << 12) | (h2 << 8) | (h3 << 4) | h4);
950                              pos += 5;
951                              helper.AddChar(ch);
952                              continue;
953                          }
954                      }
955                      else
956                      {
957                          int h1 = HexToInt(value[pos + 1]);
958                          int h2 = HexToInt(value[pos + 2]);
959                          if (h1 >= 0 && h2 >= 0)
960                          {     
961                              byte b = (byte)((h1 << 4) | h2);
962                              pos += 2;
963                              helper.AddByte(b);
964                              continue;
965                          }
966                      }
967                  }
968                  if ((ch & 0xFF80) == 0)
969                      helper.AddByte((byte)ch); 
970                  else
971                      helper.AddChar(ch);
972              }
973              return helper.GetString();
974          }
975          private static byte[] UrlDecodeInternal(byte[] bytes, int offset, int count)
976          {
977              if (!ValidateUrlEncodingParameters(bytes, offset, count))
978              {
979                  return null;
980              }
981              int decodedBytesCount = 0;
982              byte[] decodedBytes = new byte[count];
983              for (int i = 0; i < count; i++)
984              {
985                  int pos = offset + i;
986                  byte b = bytes[pos];
987                  if (b == '+')
988                  {
989                      b = (byte)' ';
990                  }
991                  else if (b == '%' && i < count - 2)
992                  {
993                      int h1 = HexToInt((char)bytes[pos + 1]);
994                      int h2 = HexToInt((char)bytes[pos + 2]);
995                      if (h1 >= 0 && h2 >= 0)
996                      {     
997                          b = (byte)((h1 << 4) | h2);
998                          i += 2;
999                      }
1000                  }
1001                  decodedBytes[decodedBytesCount++] = b;
1002              }
1003              if (decodedBytesCount < decodedBytes.Length)
1004              {
1005                  byte[] newDecodedBytes = new byte[decodedBytesCount];
1006                  Array.Copy(decodedBytes, newDecodedBytes, decodedBytesCount);
1007                  decodedBytes = newDecodedBytes;
1008              }
1009              return decodedBytes;
1010          }
1011          private static string UrlDecodeInternal(byte[] bytes, int offset, int count, Encoding encoding)
1012          {
1013              if (!ValidateUrlEncodingParameters(bytes, offset, count))
1014              {
1015                  return null;
1016              }
1017              UrlDecoder helper = new UrlDecoder(count, encoding);
1018              for (int i = 0; i < count; i++)
1019              {
1020                  int pos = offset + i;
1021                  byte b = bytes[pos];
1022                  if (b == '+')
1023                  {
1024                      b = (byte)' ';
1025                  }
1026                  else if (b == '%' && i < count - 2)
1027                  {
1028                      if (bytes[pos + 1] == 'u' && i < count - 5)
1029                      {
1030                          int h1 = HexToInt((char)bytes[pos + 2]);
1031                          int h2 = HexToInt((char)bytes[pos + 3]);
1032                          int h3 = HexToInt((char)bytes[pos + 4]);
1033                          int h4 = HexToInt((char)bytes[pos + 5]);
1034                          if (h1 >= 0 && h2 >= 0 && h3 >= 0 && h4 >= 0)
1035                          {   
1036                              char ch = (char)((h1 << 12) | (h2 << 8) | (h3 << 4) | h4);
1037                              i += 5;
1038                              helper.AddChar(ch);
1039                              continue;
1040                          }
1041                      }
1042                      else
1043                      {
1044                          int h1 = HexToInt((char)bytes[pos + 1]);
1045                          int h2 = HexToInt((char)bytes[pos + 2]);
1046                          if (h1 >= 0 && h2 >= 0)
1047                          {     
1048                              b = (byte)((h1 << 4) | h2);
1049                              i += 2;
1050                          }
1051                      }
1052                  }
1053                  helper.AddByte(b);
1054              }
1055              return helper.GetString();
1056          }
1057          #endregion
1058          #region UrlDecode public methods
1059          public static string UrlDecode(string str)
1060          {
1061              if (str == null)
1062                  return null;
1063              return UrlDecode(str, Encoding.UTF8);
1064          }
1065          public static string Base64Decode(string str)
1066          {
1067              if (str == null)
1068              {
1069                  return null;
1070              }
1071              return Encoding.UTF8.GetString(Convert.FromBase64String(str));
1072          }
1073          public static string UrlDecode(string str, Encoding e)
1074          {
1075              return UrlDecodeInternal(str, e);
1076          }
1077          public static string UrlDecode(byte[] bytes, Encoding e)
1078          {
1079              if (bytes == null)
1080                  return null;
1081              return UrlDecode(bytes, 0, bytes.Length, e);
1082          }
1083          public static string UrlDecode(byte[] bytes, int offset, int count, Encoding e)
1084          {
1085              return UrlDecodeInternal(bytes, offset, count, e);
1086          }
1087          public static byte[] UrlDecodeToBytes(string str)
1088          {
1089              if (str == null)
1090                  return null;
1091              return UrlDecodeToBytes(str, Encoding.UTF8);
1092          }
1093          public static byte[] UrlDecodeToBytes(string str, Encoding e)
1094          {
1095              if (str == null)
1096                  return null;
1097              return UrlDecodeToBytes(e.GetBytes(str));
1098          }
1099          public static byte[] UrlDecodeToBytes(byte[] bytes)
1100          {
1101              if (bytes == null)
1102                  return null;
1103              return UrlDecodeToBytes(bytes, 0, (bytes != null) ? bytes.Length : 0);
1104          }
1105          public static byte[] UrlDecodeToBytes(byte[] bytes, int offset, int count)
1106          {
1107              return UrlDecodeInternal(bytes, offset, count);
1108          }
1109          #endregion
1110          #region Helper methods
1111          public static int HexToInt(char h)
1112          {
1113              return (h >= '0' && h <= '9') ? h - '0' :
1114              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :
1115              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :
1116              -1;
1117          }
1118          public static char IntToHex(int n)
1119          {
1120              Debug.Assert(n < 0x10);
1121              if (n <= 9)
1122                  return (char)(n + (int)'0');
1123              else
1124                  return (char)(n - 10 + (int)'a');
1125          }
1126          public static bool IsUrlSafeChar(char ch)
1127          {
1128              if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')
1129                  return true;
1130              switch (ch)
1131              {
1132                  case '-':
1133                  case '_':
1134                  case '.':
1135                  case '!':
1136                  case '*':
1137                  case '(':
1138                  case ')':
1139                      return true;
1140              }
1141              return false;
1142          }
1143          internal static String UrlEncodeSpaces(string str)
1144          {
1145              if (str != null && str.IndexOf(' ') >= 0)
1146                  str = str.Replace(" ", "%20");
1147              return str;
1148          }
1149          private static bool ValidateUrlEncodingParameters(byte[] bytes, int offset, int count)
1150          {
1151              if (bytes == null && count == 0)
1152                  return false;
1153              if (bytes == null)
1154              {
1155                  throw new ArgumentNullException("bytes");
1156              }
1157              if (offset < 0 || offset > bytes.Length)
1158              {
1159                  throw new ArgumentOutOfRangeException("offset");
1160              }
1161              if (count < 0 || offset + count > bytes.Length)
1162              {
1163                  throw new ArgumentOutOfRangeException("count");
1164              }
1165              return true;
1166          }
1167          private static bool IsNonAsciiByte(byte b)
1168          {
1169              return (b >= 0x7F || b < 0x20);
1170          }
1171          #endregion
1172          #region UrlDecoder nested class
1173          private class UrlDecoder
1174          {
1175              private int _bufferSize;
1176              private int _numChars;
1177              private char[] _charBuffer;
1178              private int _numBytes;
1179              private byte[] _byteBuffer;
1180              private Encoding _encoding;
1181              private void FlushBytes()
1182              {
1183                  if (_numBytes > 0)
1184                  {
1185                      _numChars += _encoding.GetChars(_byteBuffer, 0, _numBytes, _charBuffer, _numChars);
1186                      _numBytes = 0;
1187                  }
1188              }
1189              internal UrlDecoder(int bufferSize, Encoding encoding)
1190              {
1191                  _bufferSize = bufferSize;
1192                  _encoding = encoding;
1193                  _charBuffer = new char[bufferSize];
1194              }
1195              internal void AddChar(char ch)
1196              {
1197                  if (_numBytes > 0)
1198                      FlushBytes();
1199                  _charBuffer[_numChars++] = ch;
1200              }
1201              internal void AddByte(byte b)
1202              {
1203                  if (_byteBuffer == null)
1204                      _byteBuffer = new byte[_bufferSize];
1205                  _byteBuffer[_numBytes++] = b;
1206              }
1207              internal String GetString()
1208              {
1209                  if (_numBytes > 0)
1210                      FlushBytes();
1211                  if (_numChars > 0)
1212                      return new String(_charBuffer, 0, _numChars);
1213                  else
1214                      return String.Empty;
1215              }
1216          }
1217          #endregion
1218          #region HtmlDecode
1219          public static string HtmlDecode(string value)
1220          {
1221              if (String.IsNullOrEmpty(value))
1222              {
1223                  return value;
1224              }
1225              if (value.IndexOf('&') < 0)
1226              {
1227                  return value;
1228              }
1229              using (StringWriter writer = new StringWriter(CultureInfo.InvariantCulture))
1230              {
1231                  HtmlDecode(value, writer);
1232                  return writer.ToString();
1233              }
1234          }
1235          [SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "System.UInt16.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.UInt16@)", Justification = "UInt16.TryParse guarantees that result is zero if the parse fails.")]
1236          public static void HtmlDecode(string value, TextWriter output)
1237          {
1238              if (value == null)
1239              {
1240                  return;
1241              }
1242              if (output == null)
1243              {
1244                  throw new ArgumentNullException("output");
1245              }
1246              if (value.IndexOf('&') < 0)
1247              {
1248                  output.Write(value);        
1249                  return;
1250              }
1251              int l = value.Length;
1252              for (int i = 0; i < l; i++)
1253              {
1254                  char ch = value[i];
1255                  if (ch == '&')
1256                  {
1257                      int index = value.IndexOfAny(_htmlEntityEndingChars, i + 1);
1258                      if (index > 0 && value[index] == ';')
1259                      {
1260                          string entity = value.Substring(i + 1, index - i - 1);
1261                          if (entity.Length > 1 && entity[0] == '#')
1262                          {
1263                              ushort parsed;
1264                              if (entity[1] == 'x' || entity[1] == 'X')
1265                              {
1266                                  UInt16.TryParse(entity.Substring(2), NumberStyles.AllowHexSpecifier, NumberFormatInfo.InvariantInfo, out parsed);
1267                              }
1268                              else
1269                              {
1270                                  UInt16.TryParse(entity.Substring(1), NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out parsed);
1271                              }
1272                              if (parsed != 0)
1273                              {
1274                                  ch = (char)parsed;
1275                                  i = index; 
1276                              }
1277                          }
1278                          else
1279                          {
1280                              i = index; 
1281                              char entityChar = HtmlEntities.Lookup(entity);
1282                              if (entityChar != (char)0)
1283                              {
1284                                  ch = entityChar;
1285                              }
1286                              else
1287                              {
1288                                  output.Write('&');
1289                                  output.Write(entity);
1290                                  output.Write(';');
1291                                  continue;
1292                              }
1293                          }
1294                      }
1295                  }
1296                  output.Write(ch);
1297              }
1298          }
1299          #endregion
1300          #region HtmlEntities nested class
1301          private static class HtmlEntities
1302          {
1303              private static String[] _entitiesList = new String[] {
1304                  "\x0022-quot",
1305                  "\x0026-amp",
1306                  "\x0027-apos",
1307                  "\x003c-lt",
1308                  "\x003e-gt",
1309                  "\x00a0-nbsp",
1310                  "\x00a1-iexcl",
1311                  "\x00a2-cent",
1312                  "\x00a3-pound",
1313                  "\x00a4-curren",
1314                  "\x00a5-yen",
1315                  "\x00a6-brvbar",
1316                  "\x00a7-sect",
1317                  "\x00a8-uml",
1318                  "\x00a9-copy",
1319                  "\x00aa-ordf",
1320                  "\x00ab-laquo",
1321                  "\x00ac-not",
1322                  "\x00ad-shy",
1323                  "\x00ae-reg",
1324                  "\x00af-macr",
1325                  "\x00b0-deg",
1326                  "\x00b1-plusmn",
1327                  "\x00b2-sup2",
1328                  "\x00b3-sup3",
1329                  "\x00b4-acute",
1330                  "\x00b5-micro",
1331                  "\x00b6-para",
1332                  "\x00b7-middot",
1333                  "\x00b8-cedil",
1334                  "\x00b9-sup1",
1335                  "\x00ba-ordm",
1336                  "\x00bb-raquo",
1337                  "\x00bc-frac14",
1338                  "\x00bd-frac12",
1339                  "\x00be-frac34",
1340                  "\x00bf-iquest",
1341                  "\x00c0-Agrave",
1342                  "\x00c1-Aacute",
1343                  "\x00c2-Acirc",
1344                  "\x00c3-Atilde",
1345                  "\x00c4-Auml",
1346                  "\x00c5-Aring",
1347                  "\x00c6-AElig",
1348                  "\x00c7-Ccedil",
1349                  "\x00c8-Egrave",
1350                  "\x00c9-Eacute",
1351                  "\x00ca-Ecirc",
1352                  "\x00cb-Euml",
1353                  "\x00cc-Igrave",
1354                  "\x00cd-Iacute",
1355                  "\x00ce-Icirc",
1356                  "\x00cf-Iuml",
1357                  "\x00d0-ETH",
1358                  "\x00d1-Ntilde",
1359                  "\x00d2-Ograve",
1360                  "\x00d3-Oacute",
1361                  "\x00d4-Ocirc",
1362                  "\x00d5-Otilde",
1363                  "\x00d6-Ouml",
1364                  "\x00d7-times",
1365                  "\x00d8-Oslash",
1366                  "\x00d9-Ugrave",
1367                  "\x00da-Uacute",
1368                  "\x00db-Ucirc",
1369                  "\x00dc-Uuml",
1370                  "\x00dd-Yacute",
1371                  "\x00de-THORN",
1372                  "\x00df-szlig",
1373                  "\x00e0-agrave",
1374                  "\x00e1-aacute",
1375                  "\x00e2-acirc",
1376                  "\x00e3-atilde",
1377                  "\x00e4-auml",
1378                  "\x00e5-aring",
1379                  "\x00e6-aelig",
1380                  "\x00e7-ccedil",
1381                  "\x00e8-egrave",
1382                  "\x00e9-eacute",
1383                  "\x00ea-ecirc",
1384                  "\x00eb-euml",
1385                  "\x00ec-igrave",
1386                  "\x00ed-iacute",
1387                  "\x00ee-icirc",
1388                  "\x00ef-iuml",
1389                  "\x00f0-eth",
1390                  "\x00f1-ntilde",
1391                  "\x00f2-ograve",
1392                  "\x00f3-oacute",
1393                  "\x00f4-ocirc",
1394                  "\x00f5-otilde",
1395                  "\x00f6-ouml",
1396                  "\x00f7-divide",
1397                  "\x00f8-oslash",
1398                  "\x00f9-ugrave",
1399                  "\x00fa-uacute",
1400                  "\x00fb-ucirc",
1401                  "\x00fc-uuml",
1402                  "\x00fd-yacute",
1403                  "\x00fe-thorn",
1404                  "\x00ff-yuml",
1405                  "\x0152-OElig",
1406                  "\x0153-oelig",
1407                  "\x0160-Scaron",
1408                  "\x0161-scaron",
1409                  "\x0178-Yuml",
1410                  "\x0192-fnof",
1411                  "\x02c6-circ",
1412                  "\x02dc-tilde",
1413                  "\x0391-Alpha",
1414                  "\x0392-Beta",
1415                  "\x0393-Gamma",
1416                  "\x0394-Delta",
1417                  "\x0395-Epsilon",
1418                  "\x0396-Zeta",
1419                  "\x0397-Eta",
1420                  "\x0398-Theta",
1421                  "\x0399-Iota",
1422                  "\x039a-Kappa",
1423                  "\x039b-Lambda",
1424                  "\x039c-Mu",
1425                  "\x039d-Nu",
1426                  "\x039e-Xi",
1427                  "\x039f-Omicron",
1428                  "\x03a0-Pi",
1429                  "\x03a1-Rho",
1430                  "\x03a3-Sigma",
1431                  "\x03a4-Tau",
1432                  "\x03a5-Upsilon",
1433                  "\x03a6-Phi",
1434                  "\x03a7-Chi",
1435                  "\x03a8-Psi",
1436                  "\x03a9-Omega",
1437                  "\x03b1-alpha",
1438                  "\x03b2-beta",
1439                  "\x03b3-gamma",
1440                  "\x03b4-delta",
1441                  "\x03b5-epsilon",
1442                  "\x03b6-zeta",
1443                  "\x03b7-eta",
1444                  "\x03b8-theta",
1445                  "\x03b9-iota",
1446                  "\x03ba-kappa",
1447                  "\x03bb-lambda",
1448                  "\x03bc-mu",
1449                  "\x03bd-nu",
1450                  "\x03be-xi",
1451                  "\x03bf-omicron",
1452                  "\x03c0-pi",
1453                  "\x03c1-rho",
1454                  "\x03c2-sigmaf",
1455                  "\x03c3-sigma",
1456                  "\x03c4-tau",
1457                  "\x03c5-upsilon",
1458                  "\x03c6-phi",
1459                  "\x03c7-chi",
1460                  "\x03c8-psi",
1461                  "\x03c9-omega",
1462                  "\x03d1-thetasym",
1463                  "\x03d2-upsih",
1464                  "\x03d6-piv",
1465                  "\x2002-ensp",
1466                  "\x2003-emsp",
1467                  "\x2009-thinsp",
1468                  "\x200c-zwnj",
1469                  "\x200d-zwj",
1470                  "\x200e-lrm",
1471                  "\x200f-rlm",
1472                  "\x2013-ndash",
1473                  "\x2014-mdash",
1474                  "\x2018-lsquo",
1475                  "\x2019-rsquo",
1476                  "\x201a-sbquo",
1477                  "\x201c-ldquo",
1478                  "\x201d-rdquo",
1479                  "\x201e-bdquo",
1480                  "\x2020-dagger",
1481                  "\x2021-Dagger",
1482                  "\x2022-bull",
1483                  "\x2026-hellip",
1484                  "\x2030-permil",
1485                  "\x2032-prime",
1486                  "\x2033-Prime",
1487                  "\x2039-lsaquo",
1488                  "\x203a-rsaquo",
1489                  "\x203e-oline",
1490                  "\x2044-frasl",
1491                  "\x20ac-euro",
1492                  "\x2111-image",
1493                  "\x2118-weierp",
1494                  "\x211c-real",
1495                  "\x2122-trade",
1496                  "\x2135-alefsym",
1497                  "\x2190-larr",
1498                  "\x2191-uarr",
1499                  "\x2192-rarr",
1500                  "\x2193-darr",
1501                  "\x2194-harr",
1502                  "\x21b5-crarr",
1503                  "\x21d0-lArr",
1504                  "\x21d1-uArr",
1505                  "\x21d2-rArr",
1506                  "\x21d3-dArr",
1507                  "\x21d4-hArr",
1508                  "\x2200-forall",
1509                  "\x2202-part",
1510                  "\x2203-exist",
1511                  "\x2205-empty",
1512                  "\x2207-nabla",
1513                  "\x2208-isin",
1514                  "\x2209-notin",
1515                  "\x220b-ni",
1516                  "\x220f-prod",
1517                  "\x2211-sum",
1518                  "\x2212-minus",
1519                  "\x2217-lowast",
1520                  "\x221a-radic",
1521                  "\x221d-prop",
1522                  "\x221e-infin",
1523                  "\x2220-ang",
1524                  "\x2227-and",
1525                  "\x2228-or",
1526                  "\x2229-cap",
1527                  "\x222a-cup",
1528                  "\x222b-int",
1529                  "\x2234-there4",
1530                  "\x223c-sim",
1531                  "\x2245-cong",
1532                  "\x2248-asymp",
1533                  "\x2260-ne",
1534                  "\x2261-equiv",
1535                  "\x2264-le",
1536                  "\x2265-ge",
1537                  "\x2282-sub",
1538                  "\x2283-sup",
1539                  "\x2284-nsub",
1540                  "\x2286-sube",
1541                  "\x2287-supe",
1542                  "\x2295-oplus",
1543                  "\x2297-otimes",
1544                  "\x22a5-perp",
1545                  "\x22c5-sdot",
1546                  "\x2308-lceil",
1547                  "\x2309-rceil",
1548                  "\x230a-lfloor",
1549                  "\x230b-rfloor",
1550                  "\x2329-lang",
1551                  "\x232a-rang",
1552                  "\x25ca-loz",
1553                  "\x2660-spades",
1554                  "\x2663-clubs",
1555                  "\x2665-hearts",
1556                  "\x2666-diams",
1557              };
1558              private static Dictionary<string, char> _lookupTable = GenerateLookupTable();
1559              private static Dictionary<string, char> GenerateLookupTable()
1560              {
1561                  Dictionary<string, char> lookupTable = new Dictionary<string, char>(StringComparer.Ordinal);
1562                  foreach (string e in _entitiesList)
1563                  {
1564                      lookupTable.Add(e.Substring(2), e[0]);
1565                  }
1566                  return lookupTable;
1567              }
1568              public static char Lookup(string entity)
1569              {
1570                  char theChar;
1571                  _lookupTable.TryGetValue(entity, out theChar);
1572                  return theChar;
1573              }
1574          }
1575          #endregion
1576          private static char[] _htmlEntityEndingChars = new char[] { ';', '&' };
1577          #endregion
1578      }
1579  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-OAuthTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-UriUtility.cs</div>
                </div>
                <div class="column column_space"><pre><code>279              Assert.Null(transaction.Response.Headers.Location);
280          }
</pre></code></div>
                <div class="column column_space"><pre><code>201              sb.Append(System.IO.Path.DirectorySeparatorChar);
202              sb.Append(System.IO.Path.DirectorySeparatorChar);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    