
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 40, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Security.Claims;
5  using System.Text.Encodings.Web;
6  using System.Threading.Tasks;
7  using Microsoft.AspNetCore.Http;
8  using Microsoft.Extensions.Logging;
9  using Microsoft.Extensions.Options;
10  using Microsoft.IdentityModel.Protocols.WsFederation;
11  using Microsoft.IdentityModel.Tokens;
12  namespace Microsoft.AspNetCore.Authentication.WsFederation
13  {
14      public class WsFederationHandler : RemoteAuthenticationHandler&lt;WsFederationOptions&gt;, IAuthenticationSignOutHandler
15      {
16          private const string CorrelationProperty = &quot;.xsrf&quot;;
17          private WsFederationConfiguration _configuration;
18          public WsFederationHandler(IOptionsMonitor&lt;WsFederationOptions&gt; options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
19              : base(options, logger, encoder, clock)
20          {
21          }
22          protected new WsFederationEvents Events
23          {
24              get { return (WsFederationEvents)base.Events; }
25              set { base.Events = value; }
26          }
27          protected override Task&lt;object&gt; CreateEventsAsync() =&gt; Task.FromResult&lt;object&gt;(new WsFederationEvents());
28          public override Task&lt;bool&gt; HandleRequestAsync()
29          {
30              if (Options.RemoteSignOutPath.HasValue &amp;&amp; Options.RemoteSignOutPath == Request.Path &amp;&amp; HttpMethods.IsGet(Request.Method)
31                  &amp;&amp; string.Equals(Request.Query[WsFederationConstants.WsFederationParameterNames.Wa],
32                      WsFederationConstants.WsFederationActions.SignOutCleanup, StringComparison.OrdinalIgnoreCase))
33              {
34                  return HandleRemoteSignOutAsync();
35              }
36              return base.HandleRequestAsync();
37          }
38          protected override async Task HandleChallengeAsync(AuthenticationProperties properties)
39          {
40              if (_configuration == null)
41              {
42                  _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
43              }
44              if (string.IsNullOrEmpty(properties.RedirectUri))
45              {
46                  properties.RedirectUri = OriginalPathBase + OriginalPath + Request.QueryString;
47              }
48              var wsFederationMessage = new WsFederationMessage()
49              {
50                  IssuerAddress = _configuration.TokenEndpoint ?? string.Empty,
51                  Wtrealm = Options.Wtrealm,
52                  Wa = WsFederationConstants.WsFederationActions.SignIn,
53              };
54              if (!string.IsNullOrEmpty(Options.Wreply))
55              {
56                  wsFederationMessage.Wreply = Options.Wreply;
57              }
58              else
59              {
60                  wsFederationMessage.Wreply = BuildRedirectUri(Options.CallbackPath);
61              }
<span onclick='openModal()' class='match'>62              GenerateCorrelationId(properties);
63              var redirectContext = new RedirectContext(Context, Scheme, Options, properties)
64              {
65                  ProtocolMessage = wsFederationMessage
66              };
67              await Events.RedirectToIdentityProvider(redirectContext);
68              if (redirectContext.Handled)
69              {
70                  return;
</span>71              }
72              wsFederationMessage = redirectContext.ProtocolMessage;
73              if (!string.IsNullOrEmpty(wsFederationMessage.Wctx))
74              {
75                  properties.Items[WsFederationDefaults.UserstatePropertiesKey] = wsFederationMessage.Wctx;
76              }
77              wsFederationMessage.Wctx = Uri.EscapeDataString(Options.StateDataFormat.Protect(properties));
78              var redirectUri = wsFederationMessage.CreateSignInUrl();
79              if (!Uri.IsWellFormedUriString(redirectUri, UriKind.Absolute))
80              {
81                  Logger.MalformedRedirectUri(redirectUri);
82              }
83              Response.Redirect(redirectUri);
84          }
85          protected override async Task&lt;HandleRequestResult&gt; HandleRemoteAuthenticateAsync()
86          {
87              WsFederationMessage wsFederationMessage = null;
88              AuthenticationProperties properties = null;
89              if (HttpMethods.IsPost(Request.Method)
90                &amp;&amp; !string.IsNullOrEmpty(Request.ContentType)
91                &amp;&amp; Request.ContentType.StartsWith(&quot;application/x-www-form-urlencoded&quot;, StringComparison.OrdinalIgnoreCase)
92                &amp;&amp; Request.Body.CanRead)
93              {
94                  var form = await Request.ReadFormAsync();
95                  wsFederationMessage = new WsFederationMessage(form.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
96              }
97              if (wsFederationMessage == null || !wsFederationMessage.IsSignInMessage)
98              {
99                  if (Options.SkipUnrecognizedRequests)
100                  {
101                      return HandleRequestResult.SkipHandler();
102                  }
103                  return HandleRequestResult.Fail(&quot;No message.&quot;);
104              }
105              try
106              {
107                  var state = wsFederationMessage.Wctx;
108                  properties = Options.StateDataFormat.Unprotect(state);
109                  if (properties == null)
110                  {
111                      if (!Options.AllowUnsolicitedLogins)
112                      {
113                          return HandleRequestResult.Fail(&quot;Unsolicited logins are not allowed.&quot;);
114                      }
115                  }
116                  else
117                  {
118                      properties.Items.TryGetValue(WsFederationDefaults.UserstatePropertiesKey, out var userState);
119                      wsFederationMessage.Wctx = userState;
120                  }
121                  var messageReceivedContext = new MessageReceivedContext(Context, Scheme, Options, properties)
122                  {
123                      ProtocolMessage = wsFederationMessage
124                  };
125                  await Events.MessageReceived(messageReceivedContext);
126                  if (messageReceivedContext.Result != null)
127                  {
128                      return messageReceivedContext.Result;
129                  }
130                  wsFederationMessage = messageReceivedContext.ProtocolMessage;
131                  properties = messageReceivedContext.Properties; 
132                  if (properties.Items.TryGetValue(CorrelationProperty, out string correlationId)
133                      &amp;&amp; !ValidateCorrelationId(properties))
134                  {
135                      return HandleRequestResult.Fail(&quot;Correlation failed.&quot;, properties);
136                  }
137                  if (wsFederationMessage.Wresult == null)
138                  {
139                      Logger.SignInWithoutWresult();
140                      return HandleRequestResult.Fail(Resources.SignInMessageWresultIsMissing, properties);
141                  }
142                  var token = wsFederationMessage.GetToken();
143                  if (string.IsNullOrEmpty(token))
144                  {
145                      Logger.SignInWithoutToken();
146                      return HandleRequestResult.Fail(Resources.SignInMessageTokenIsMissing, properties);
147                  }
148                  var securityTokenReceivedContext = new SecurityTokenReceivedContext(Context, Scheme, Options, properties)
149                  {
150                      ProtocolMessage = wsFederationMessage
151                  };
152                  await Events.SecurityTokenReceived(securityTokenReceivedContext);
153                  if (securityTokenReceivedContext.Result != null)
154                  {
155                      return securityTokenReceivedContext.Result;
156                  }
157                  wsFederationMessage = securityTokenReceivedContext.ProtocolMessage;
158                  properties = messageReceivedContext.Properties;
159                  if (_configuration == null)
160                  {
161                      _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
162                  }
163                  var tvp = Options.TokenValidationParameters.Clone();
164                  var issuers = new[] { _configuration.Issuer };
165                  tvp.ValidIssuers = (tvp.ValidIssuers == null ? issuers : tvp.ValidIssuers.Concat(issuers));
166                  tvp.IssuerSigningKeys = (tvp.IssuerSigningKeys == null ? _configuration.SigningKeys : tvp.IssuerSigningKeys.Concat(_configuration.SigningKeys));
167                  ClaimsPrincipal principal = null;
168                  SecurityToken parsedToken = null;
169                  foreach (var validator in Options.SecurityTokenHandlers)
170                  {
171                      if (validator.CanReadToken(token))
172                      {
173                          principal = validator.ValidateToken(token, tvp, out parsedToken);
174                          break;
175                      }
176                  }
177                  if (principal == null)
178                  {
179                      throw new SecurityTokenException(Resources.Exception_NoTokenValidatorFound);
180                  }
181                  if (Options.UseTokenLifetime &amp;&amp; parsedToken != null)
182                  {
183                      var issued = parsedToken.ValidFrom;
184                      if (issued != DateTime.MinValue)
185                      {
186                          properties.IssuedUtc = issued.ToUniversalTime();
187                      }
188                      var expires = parsedToken.ValidTo;
189                      if (expires != DateTime.MinValue)
190                      {
191                          properties.ExpiresUtc = expires.ToUniversalTime();
192                      }
193                      properties.AllowRefresh = false;
194                  }
195                  var securityTokenValidatedContext = new SecurityTokenValidatedContext(Context, Scheme, Options, principal, properties)
196                  {
197                      ProtocolMessage = wsFederationMessage,
198                      SecurityToken = parsedToken,
199                  };
200                  await Events.SecurityTokenValidated(securityTokenValidatedContext);
201                  if (securityTokenValidatedContext.Result != null)
202                  {
203                      return securityTokenValidatedContext.Result;
204                  }
205                  principal = securityTokenValidatedContext.Principal;
206                  properties = securityTokenValidatedContext.Properties;
207                  return HandleRequestResult.Success(new AuthenticationTicket(principal, properties, Scheme.Name));
208              }
209              catch (Exception exception)
210              {
211                  Logger.ExceptionProcessingMessage(exception);
212                  if (Options.RefreshOnIssuerKeyNotFound &amp;&amp; exception.GetType().Equals(typeof(SecurityTokenSignatureKeyNotFoundException)))
213                  {
214                      Options.ConfigurationManager.RequestRefresh();
215                  }
216                  var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
217                  {
218                      ProtocolMessage = wsFederationMessage,
219                      Exception = exception
220                  };
221                  await Events.AuthenticationFailed(authenticationFailedContext);
222                  if (authenticationFailedContext.Result != null)
223                  {
224                      return authenticationFailedContext.Result;
225                  }
226                  return HandleRequestResult.Fail(exception, properties);
227              }
228          }
229          public async virtual Task SignOutAsync(AuthenticationProperties properties)
230          {
231              var target = ResolveTarget(Options.ForwardSignOut);
232              if (target != null)
233              {
234                  await Context.SignOutAsync(target, properties);
235                  return;
236              }
237              if (_configuration == null)
238              {
239                  _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
240              }
241              var wsFederationMessage = new WsFederationMessage()
242              {
243                  IssuerAddress = _configuration.TokenEndpoint ?? string.Empty,
244                  Wtrealm = Options.Wtrealm,
245                  Wa = WsFederationConstants.WsFederationActions.SignOut,
246              };
247              if (properties != null &amp;&amp; !string.IsNullOrEmpty(properties.RedirectUri))
248              {
249                  wsFederationMessage.Wreply = BuildRedirectUriIfRelative(properties.RedirectUri);
250              }
251              else if (!string.IsNullOrEmpty(Options.SignOutWreply))
252              {
253                  wsFederationMessage.Wreply = BuildRedirectUriIfRelative(Options.SignOutWreply);
254              }
255              else if (!string.IsNullOrEmpty(Options.Wreply))
256              {
257                  wsFederationMessage.Wreply = BuildRedirectUriIfRelative(Options.Wreply);
258              }
259              var redirectContext = new RedirectContext(Context, Scheme, Options, properties)
260              {
261                  ProtocolMessage = wsFederationMessage
262              };
263              await Events.RedirectToIdentityProvider(redirectContext);
264              if (!redirectContext.Handled)
265              {
266                  var redirectUri = redirectContext.ProtocolMessage.CreateSignOutUrl();
267                  if (!Uri.IsWellFormedUriString(redirectUri, UriKind.Absolute))
268                  {
269                      Logger.MalformedRedirectUri(redirectUri);
270                  }
271                  Response.Redirect(redirectUri);
272              }
273          }
274          protected virtual async Task&lt;bool&gt; HandleRemoteSignOutAsync()
275          {
276              var message = new WsFederationMessage(Request.Query.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
277              var remoteSignOutContext = new RemoteSignOutContext(Context, Scheme, Options, message);
278              await Events.RemoteSignOut(remoteSignOutContext);
279              if (remoteSignOutContext.Result != null)
280              {
281                  if (remoteSignOutContext.Result.Handled)
282                  {
283                      Logger.RemoteSignOutHandledResponse();
284                      return true;
285                  }
286                  if (remoteSignOutContext.Result.Skipped)
287                  {
288                      Logger.RemoteSignOutSkipped();
289                      return false;
290                  }
291              }
292              Logger.RemoteSignOut();
293              await Context.SignOutAsync(Options.SignOutScheme);
294              return true;
295          }
296          private string BuildRedirectUriIfRelative(string uri)
297          {
298              if (string.IsNullOrEmpty(uri))
299              {
300                  return uri;
301              }
302              if (!uri.StartsWith(&quot;/&quot;, StringComparison.Ordinal))
303              {
304                  return uri;
305              }
306              return BuildRedirectUri(uri);
307          }
308      }
309  }
</code></pre>
        </div>
        <div class="column">
            <h3>Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-OpenIdConnectHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Globalization;
4  using System.IdentityModel.Tokens.Jwt;
5  using System.Linq;
6  using System.Net.Http;
7  using System.Net.Http.Headers;
8  using System.Security.Claims;
9  using System.Security.Cryptography;
10  using System.Text;
11  using System.Text.Encodings.Web;
12  using System.Threading.Tasks;
13  using Microsoft.AspNetCore.Http;
14  using Microsoft.Extensions.Logging;
15  using Microsoft.Extensions.Options;
16  using Microsoft.IdentityModel.Protocols.OpenIdConnect;
17  using Microsoft.IdentityModel.Tokens;
18  using Microsoft.Net.Http.Headers;
19  using Newtonsoft.Json.Linq;
20  namespace Microsoft.AspNetCore.Authentication.OpenIdConnect
21  {
22      public class OpenIdConnectHandler : RemoteAuthenticationHandler&lt;OpenIdConnectOptions&gt;, IAuthenticationSignOutHandler
23      {
24          private const string NonceProperty = &quot;N&quot;;
25          private const string HeaderValueEpocDate = &quot;Thu, 01 Jan 1970 00:00:00 GMT&quot;;
26          private static readonly RandomNumberGenerator CryptoRandom = RandomNumberGenerator.Create();
27          private OpenIdConnectConfiguration _configuration;
28          protected HttpClient Backchannel =&gt; Options.Backchannel;
29          protected HtmlEncoder HtmlEncoder { get; }
30          public OpenIdConnectHandler(IOptionsMonitor&lt;OpenIdConnectOptions&gt; options, ILoggerFactory logger, HtmlEncoder htmlEncoder, UrlEncoder encoder, ISystemClock clock)
31              : base(options, logger, encoder, clock)
32          {
33              HtmlEncoder = htmlEncoder;
34          }
35          protected new OpenIdConnectEvents Events
36          {
37              get { return (OpenIdConnectEvents)base.Events; }
38              set { base.Events = value; }
39          }
40          protected override Task&lt;object&gt; CreateEventsAsync() =&gt; Task.FromResult&lt;object&gt;(new OpenIdConnectEvents());
41          public override Task&lt;bool&gt; HandleRequestAsync()
42          {
43              if (Options.RemoteSignOutPath.HasValue &amp;&amp; Options.RemoteSignOutPath == Request.Path)
44              {
45                  return HandleRemoteSignOutAsync();
46              }
47              else if (Options.SignedOutCallbackPath.HasValue &amp;&amp; Options.SignedOutCallbackPath == Request.Path)
48              {
49                  return HandleSignOutCallbackAsync();
50              }
51              return base.HandleRequestAsync();
52          }
53          protected virtual async Task&lt;bool&gt; HandleRemoteSignOutAsync()
54          {
55              OpenIdConnectMessage message = null;
56              if (string.Equals(Request.Method, &quot;GET&quot;, StringComparison.OrdinalIgnoreCase))
57              {
58                  message = new OpenIdConnectMessage(Request.Query.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
59              }
60              else if (string.Equals(Request.Method, &quot;POST&quot;, StringComparison.OrdinalIgnoreCase)
61                &amp;&amp; !string.IsNullOrEmpty(Request.ContentType)
62                &amp;&amp; Request.ContentType.StartsWith(&quot;application/x-www-form-urlencoded&quot;, StringComparison.OrdinalIgnoreCase)
63                &amp;&amp; Request.Body.CanRead)
64              {
65                  var form = await Request.ReadFormAsync();
66                  message = new OpenIdConnectMessage(form.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
67              }
68              var remoteSignOutContext = new RemoteSignOutContext(Context, Scheme, Options, message);
69              await Events.RemoteSignOut(remoteSignOutContext);
70              if (remoteSignOutContext.Result != null)
71              {
72                  if (remoteSignOutContext.Result.Handled)
73                  {
74                      Logger.RemoteSignOutHandledResponse();
75                      return true;
76                  }
77                  if (remoteSignOutContext.Result.Skipped)
78                  {
79                      Logger.RemoteSignOutSkipped();
80                      return false;
81                  }
82                  if (remoteSignOutContext.Result.Failure != null)
83                  {
84                      throw new InvalidOperationException(&quot;An error was returned from the RemoteSignOut event.&quot;, remoteSignOutContext.Result.Failure);
85                  }
86              }
87              if (message == null)
88              {
89                  return false;
90              }
91              var sid = (await Context.AuthenticateAsync(Options.SignOutScheme))
92                            ?.Principal
93                            ?.FindFirst(JwtRegisteredClaimNames.Sid)
94                            ?.Value;
95              if (!string.IsNullOrEmpty(sid))
96              {
97                  if (string.IsNullOrEmpty(message.Sid))
98                  {
99                      Logger.RemoteSignOutSessionIdMissing();
100                      return true;
101                  }
102                  if (!string.Equals(sid, message.Sid, StringComparison.Ordinal))
103                  {
104                      Logger.RemoteSignOutSessionIdInvalid();
105                      return true;
106                  }
107              }
108              Logger.RemoteSignOut();
109              await Context.SignOutAsync(Options.SignOutScheme);
110              return true;
111          }
112          public async virtual Task SignOutAsync(AuthenticationProperties properties)
113          {
114              var target = ResolveTarget(Options.ForwardSignOut);
115              if (target != null)
116              {
117                  await Context.SignOutAsync(target, properties);
118                  return;
119              }
120              properties = properties ?? new AuthenticationProperties();
121              Logger.EnteringOpenIdAuthenticationHandlerHandleSignOutAsync(GetType().FullName);
122              if (_configuration == null &amp;&amp; Options.ConfigurationManager != null)
123              {
124                  _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
125              }
126              var message = new OpenIdConnectMessage()
127              {
128                  EnableTelemetryParameters = !Options.DisableTelemetry,
129                  IssuerAddress = _configuration?.EndSessionEndpoint ?? string.Empty,
130                  PostLogoutRedirectUri = BuildRedirectUriIfRelative(Options.SignedOutCallbackPath)
131              };
132              if (string.IsNullOrEmpty(properties.RedirectUri))
133              {
134                  properties.RedirectUri = BuildRedirectUriIfRelative(Options.SignedOutRedirectUri);
135                  if (string.IsNullOrWhiteSpace(properties.RedirectUri))
136                  {
137                      properties.RedirectUri = OriginalPathBase + OriginalPath + Request.QueryString;
138                  }
139              }
140              Logger.PostSignOutRedirect(properties.RedirectUri);
141              message.IdTokenHint = await Context.GetTokenAsync(Options.SignOutScheme, OpenIdConnectParameterNames.IdToken);
142              var redirectContext = new RedirectContext(Context, Scheme, Options, properties)
143              {
144                  ProtocolMessage = message
145              };
146              await Events.RedirectToIdentityProviderForSignOut(redirectContext);
147              if (redirectContext.Handled)
148              {
149                  Logger.RedirectToIdentityProviderForSignOutHandledResponse();
150                  return;
151              }
152              message = redirectContext.ProtocolMessage;
153              if (!string.IsNullOrEmpty(message.State))
154              {
155                  properties.Items[OpenIdConnectDefaults.UserstatePropertiesKey] = message.State;
156              }
157              message.State = Options.StateDataFormat.Protect(properties);
158              if (string.IsNullOrEmpty(message.IssuerAddress))
159              {
160                  throw new InvalidOperationException(&quot;Cannot redirect to the end session endpoint, the configuration may be missing or invalid.&quot;);
161              }
162              if (Options.AuthenticationMethod == OpenIdConnectRedirectBehavior.RedirectGet)
163              {
164                  var redirectUri = message.CreateLogoutRequestUrl();
165                  if (!Uri.IsWellFormedUriString(redirectUri, UriKind.Absolute))
166                  {
167                      Logger.InvalidLogoutQueryStringRedirectUrl(redirectUri);
168                  }
169                  Response.Redirect(redirectUri);
170              }
171              else if (Options.AuthenticationMethod == OpenIdConnectRedirectBehavior.FormPost)
172              {
173                  var content = message.BuildFormPost();
174                  var buffer = Encoding.UTF8.GetBytes(content);
175                  Response.ContentLength = buffer.Length;
176                  Response.ContentType = &quot;text/html;charset=UTF-8&quot;;
177                  Response.Headers[HeaderNames.CacheControl] = &quot;no-cache&quot;;
178                  Response.Headers[HeaderNames.Pragma] = &quot;no-cache&quot;;
179                  Response.Headers[HeaderNames.Expires] = HeaderValueEpocDate;
180                  await Response.Body.WriteAsync(buffer, 0, buffer.Length);
181              }
182              else
183              {
184                  throw new NotImplementedException($&quot;An unsupported authentication method has been configured: {Options.AuthenticationMethod}&quot;);
185              }
186              Logger.SignedOut(Scheme.Name);
187          }
188          protected async virtual Task&lt;bool&gt; HandleSignOutCallbackAsync()
189          {
190              var message = new OpenIdConnectMessage(Request.Query.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
191              AuthenticationProperties properties = null;
192              if (!string.IsNullOrEmpty(message.State))
193              {
194                  properties = Options.StateDataFormat.Unprotect(message.State);
195              }
196              var signOut = new RemoteSignOutContext(Context, Scheme, Options, message)
197              {
198                  Properties = properties,
199              };
200              await Events.SignedOutCallbackRedirect(signOut);
201              if (signOut.Result != null)
202              {
203                  if (signOut.Result.Handled)
204                  {
205                      Logger.SignoutCallbackRedirectHandledResponse();
206                      return true;
207                  }
208                  if (signOut.Result.Skipped)
209                  {
210                      Logger.SignoutCallbackRedirectSkipped();
211                      return false;
212                  }
213                  if (signOut.Result.Failure != null)
214                  {
215                      throw new InvalidOperationException(&quot;An error was returned from the SignedOutCallbackRedirect event.&quot;, signOut.Result.Failure);
216                  }
217              }
218              properties = signOut.Properties;
219              if (!string.IsNullOrEmpty(properties?.RedirectUri))
220              {
221                  Response.Redirect(properties.RedirectUri);
222              }
223              return true;
224          }
225          protected override async Task HandleChallengeAsync(AuthenticationProperties properties)
226          {
227              Logger.EnteringOpenIdAuthenticationHandlerHandleUnauthorizedAsync(GetType().FullName);
228              if (string.IsNullOrEmpty(properties.RedirectUri))
229              {
230                  properties.RedirectUri = OriginalPathBase + OriginalPath + Request.QueryString;
231              }
232              Logger.PostAuthenticationLocalRedirect(properties.RedirectUri);
233              if (_configuration == null &amp;&amp; Options.ConfigurationManager != null)
234              {
235                  _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
236              }
237              var message = new OpenIdConnectMessage
238              {
239                  ClientId = Options.ClientId,
240                  EnableTelemetryParameters = !Options.DisableTelemetry,
241                  IssuerAddress = _configuration?.AuthorizationEndpoint ?? string.Empty,
242                  RedirectUri = BuildRedirectUri(Options.CallbackPath),
243                  Resource = Options.Resource,
244                  ResponseType = Options.ResponseType,
245                  Prompt = properties.GetParameter&lt;string&gt;(OpenIdConnectParameterNames.Prompt) ?? Options.Prompt,
246                  Scope = string.Join(&quot; &quot;, properties.GetParameter&lt;ICollection&lt;string&gt;&gt;(OpenIdConnectParameterNames.Scope) ?? Options.Scope),
247              };
248              var maxAge = properties.GetParameter&lt;TimeSpan?&gt;(OpenIdConnectParameterNames.MaxAge) ?? Options.MaxAge;
249              if (maxAge.HasValue)
250              {
251                  message.MaxAge = Convert.ToInt64(Math.Floor((maxAge.Value).TotalSeconds))
252                      .ToString(CultureInfo.InvariantCulture);
253              }
254              if (!string.Equals(Options.ResponseType, OpenIdConnectResponseType.Code, StringComparison.Ordinal) ||
255                  !string.Equals(Options.ResponseMode, OpenIdConnectResponseMode.Query, StringComparison.Ordinal))
256              {
257                  message.ResponseMode = Options.ResponseMode;
258              }
259              if (Options.ProtocolValidator.RequireNonce)
260              {
261                  message.Nonce = Options.ProtocolValidator.GenerateNonce();
262                  WriteNonceCookie(message.Nonce);
263              }
<span onclick='openModal()' class='match'>264              GenerateCorrelationId(properties);
265              var redirectContext = new RedirectContext(Context, Scheme, Options, properties)
266              {
267                  ProtocolMessage = message
268              };
269              await Events.RedirectToIdentityProvider(redirectContext);
270              if (redirectContext.Handled)
271              {
272                  Logger.RedirectToIdentityProviderHandledResponse();
</span>273                  return;
274              }
275              message = redirectContext.ProtocolMessage;
276              if (!string.IsNullOrEmpty(message.State))
277              {
278                  properties.Items[OpenIdConnectDefaults.UserstatePropertiesKey] = message.State;
279              }
280              properties.Items.Add(OpenIdConnectDefaults.RedirectUriForCodePropertiesKey, message.RedirectUri);
281              message.State = Options.StateDataFormat.Protect(properties);
282              if (string.IsNullOrEmpty(message.IssuerAddress))
283              {
284                  throw new InvalidOperationException(
285                      &quot;Cannot redirect to the authorization endpoint, the configuration may be missing or invalid.&quot;);
286              }
287              if (Options.AuthenticationMethod == OpenIdConnectRedirectBehavior.RedirectGet)
288              {
289                  var redirectUri = message.CreateAuthenticationRequestUrl();
290                  if (!Uri.IsWellFormedUriString(redirectUri, UriKind.Absolute))
291                  {
292                      Logger.InvalidAuthenticationRequestUrl(redirectUri);
293                  }
294                  Response.Redirect(redirectUri);
295                  return;
296              }
297              else if (Options.AuthenticationMethod == OpenIdConnectRedirectBehavior.FormPost)
298              {
299                  var content = message.BuildFormPost();
300                  var buffer = Encoding.UTF8.GetBytes(content);
301                  Response.ContentLength = buffer.Length;
302                  Response.ContentType = &quot;text/html;charset=UTF-8&quot;;
303                  Response.Headers[HeaderNames.CacheControl] = &quot;no-cache&quot;;
304                  Response.Headers[HeaderNames.Pragma] = &quot;no-cache&quot;;
305                  Response.Headers[HeaderNames.Expires] = HeaderValueEpocDate;
306                  await Response.Body.WriteAsync(buffer, 0, buffer.Length);
307                  return;
308              }
309              throw new NotImplementedException($&quot;An unsupported authentication method has been configured: {Options.AuthenticationMethod}&quot;);
310          }
311          protected override async Task&lt;HandleRequestResult&gt; HandleRemoteAuthenticateAsync()
312          {
313              Logger.EnteringOpenIdAuthenticationHandlerHandleRemoteAuthenticateAsync(GetType().FullName);
314              OpenIdConnectMessage authorizationResponse = null;
315              if (string.Equals(Request.Method, &quot;GET&quot;, StringComparison.OrdinalIgnoreCase))
316              {
317                  authorizationResponse = new OpenIdConnectMessage(Request.Query.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
318                  if (!string.IsNullOrEmpty(authorizationResponse.IdToken) || !string.IsNullOrEmpty(authorizationResponse.AccessToken))
319                  {
320                      if (Options.SkipUnrecognizedRequests)
321                      {
322                          return HandleRequestResult.SkipHandler();
323                      }
324                      return HandleRequestResult.Fail(&quot;An OpenID Connect response cannot contain an &quot; +
325                              &quot;identity token or an access token when using response_mode=query&quot;);
326                  }
327              }
328              else if (string.Equals(Request.Method, &quot;POST&quot;, StringComparison.OrdinalIgnoreCase)
329                &amp;&amp; !string.IsNullOrEmpty(Request.ContentType)
330                &amp;&amp; Request.ContentType.StartsWith(&quot;application/x-www-form-urlencoded&quot;, StringComparison.OrdinalIgnoreCase)
331                &amp;&amp; Request.Body.CanRead)
332              {
333                  var form = await Request.ReadFormAsync();
334                  authorizationResponse = new OpenIdConnectMessage(form.Select(pair =&gt; new KeyValuePair&lt;string, string[]&gt;(pair.Key, pair.Value)));
335              }
336              if (authorizationResponse == null)
337              {
338                  if (Options.SkipUnrecognizedRequests)
339                  {
340                      return HandleRequestResult.SkipHandler();
341                  }
342                  return HandleRequestResult.Fail(&quot;No message.&quot;);
343              }
344              AuthenticationProperties properties = null;
345              try
346              {
347                  properties = ReadPropertiesAndClearState(authorizationResponse);
348                  var messageReceivedContext = await RunMessageReceivedEventAsync(authorizationResponse, properties);
349                  if (messageReceivedContext.Result != null)
350                  {
351                      return messageReceivedContext.Result;
352                  }
353                  authorizationResponse = messageReceivedContext.ProtocolMessage;
354                  properties = messageReceivedContext.Properties;
355                  if (properties == null)
356                  {
357                      if (string.IsNullOrEmpty(authorizationResponse.State))
358                      {
359                          Logger.NullOrEmptyAuthorizationResponseState();
360                          if (Options.SkipUnrecognizedRequests)
361                          {
362                              return HandleRequestResult.SkipHandler();
363                          }
364                          return HandleRequestResult.Fail(Resources.MessageStateIsNullOrEmpty);
365                      }
366                      properties = ReadPropertiesAndClearState(authorizationResponse);
367                  }
368                  if (properties == null)
369                  {
370                      Logger.UnableToReadAuthorizationResponseState();
371                      if (Options.SkipUnrecognizedRequests)
372                      {
373                          return HandleRequestResult.SkipHandler();
374                      }
375                      return HandleRequestResult.Fail(Resources.MessageStateIsInvalid);
376                  }
377                  if (!ValidateCorrelationId(properties))
378                  {
379                      return HandleRequestResult.Fail(&quot;Correlation failed.&quot;, properties);
380                  }
381                  if (!string.IsNullOrEmpty(authorizationResponse.Error))
382                  {
383                      if (string.Equals(authorizationResponse.Error, &quot;access_denied&quot;, StringComparison.Ordinal))
384                      {
385                          return await HandleAccessDeniedErrorAsync(properties);
386                      }
387                      return HandleRequestResult.Fail(CreateOpenIdConnectProtocolException(authorizationResponse, response: null), properties);
388                  }
389                  if (_configuration == null &amp;&amp; Options.ConfigurationManager != null)
390                  {
391                      Logger.UpdatingConfiguration();
392                      _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
393                  }
394                  PopulateSessionProperties(authorizationResponse, properties);
395                  ClaimsPrincipal user = null;
396                  JwtSecurityToken jwt = null;
397                  string nonce = null;
398                  var validationParameters = Options.TokenValidationParameters.Clone();
399                  if (!string.IsNullOrEmpty(authorizationResponse.IdToken))
400                  {
401                      Logger.ReceivedIdToken();
402                      user = ValidateToken(authorizationResponse.IdToken, properties, validationParameters, out jwt);
403                      nonce = jwt.Payload.Nonce;
404                      if (!string.IsNullOrEmpty(nonce))
405                      {
406                          nonce = ReadNonceCookie(nonce);
407                      }
408                      var tokenValidatedContext = await RunTokenValidatedEventAsync(authorizationResponse, null, user, properties, jwt, nonce);
409                      if (tokenValidatedContext.Result != null)
410                      {
411                          return tokenValidatedContext.Result;
412                      }
413                      authorizationResponse = tokenValidatedContext.ProtocolMessage;
414                      user = tokenValidatedContext.Principal;
415                      properties = tokenValidatedContext.Properties;
416                      jwt = tokenValidatedContext.SecurityToken;
417                      nonce = tokenValidatedContext.Nonce;
418                  }
419                  Options.ProtocolValidator.ValidateAuthenticationResponse(new OpenIdConnectProtocolValidationContext()
420                  {
421                      ClientId = Options.ClientId,
422                      ProtocolMessage = authorizationResponse,
423                      ValidatedIdToken = jwt,
424                      Nonce = nonce
425                  });
426                  OpenIdConnectMessage tokenEndpointResponse = null;
427                  if (!string.IsNullOrEmpty(authorizationResponse.Code))
428                  {
429                      var authorizationCodeReceivedContext = await RunAuthorizationCodeReceivedEventAsync(authorizationResponse, user, properties, jwt);
430                      if (authorizationCodeReceivedContext.Result != null)
431                      {
432                          return authorizationCodeReceivedContext.Result;
433                      }
434                      authorizationResponse = authorizationCodeReceivedContext.ProtocolMessage;
435                      user = authorizationCodeReceivedContext.Principal;
436                      properties = authorizationCodeReceivedContext.Properties;
437                      var tokenEndpointRequest = authorizationCodeReceivedContext.TokenEndpointRequest;
438                      tokenEndpointResponse = authorizationCodeReceivedContext.TokenEndpointResponse;
439                      jwt = authorizationCodeReceivedContext.JwtSecurityToken;
440                      if (!authorizationCodeReceivedContext.HandledCodeRedemption)
441                      {
442                          tokenEndpointResponse = await RedeemAuthorizationCodeAsync(tokenEndpointRequest);
443                      }
444                      var tokenResponseReceivedContext = await RunTokenResponseReceivedEventAsync(authorizationResponse, tokenEndpointResponse, user, properties);
445                      if (tokenResponseReceivedContext.Result != null)
446                      {
447                          return tokenResponseReceivedContext.Result;
448                      }
449                      authorizationResponse = tokenResponseReceivedContext.ProtocolMessage;
450                      tokenEndpointResponse = tokenResponseReceivedContext.TokenEndpointResponse;
451                      user = tokenResponseReceivedContext.Principal;
452                      properties = tokenResponseReceivedContext.Properties;
453                      validationParameters.RequireSignedTokens = false;
454                      var tokenEndpointUser = ValidateToken(tokenEndpointResponse.IdToken, properties, validationParameters, out var tokenEndpointJwt);
455                      if (user == null)
456                      {
457                          nonce = tokenEndpointJwt.Payload.Nonce;
458                          if (!string.IsNullOrEmpty(nonce))
459                          {
460                              nonce = ReadNonceCookie(nonce);
461                          }
462                          var tokenValidatedContext = await RunTokenValidatedEventAsync(authorizationResponse, tokenEndpointResponse, tokenEndpointUser, properties, tokenEndpointJwt, nonce);
463                          if (tokenValidatedContext.Result != null)
464                          {
465                              return tokenValidatedContext.Result;
466                          }
467                          authorizationResponse = tokenValidatedContext.ProtocolMessage;
468                          tokenEndpointResponse = tokenValidatedContext.TokenEndpointResponse;
469                          user = tokenValidatedContext.Principal;
470                          properties = tokenValidatedContext.Properties;
471                          jwt = tokenValidatedContext.SecurityToken;
472                          nonce = tokenValidatedContext.Nonce;
473                      }
474                      else
475                      {
476                          if (!string.Equals(jwt.Subject, tokenEndpointJwt.Subject, StringComparison.Ordinal))
477                          {
478                              throw new SecurityTokenException(&quot;The sub claim does not match in the id_token&#x27;s from the authorization and token endpoints.&quot;);
479                          }
480                          jwt = tokenEndpointJwt;
481                      }
482                      if (!authorizationCodeReceivedContext.HandledCodeRedemption)
483                      {
484                          Options.ProtocolValidator.ValidateTokenResponse(new OpenIdConnectProtocolValidationContext()
485                          {
486                              ClientId = Options.ClientId,
487                              ProtocolMessage = tokenEndpointResponse,
488                              ValidatedIdToken = jwt,
489                              Nonce = nonce
490                          });
491                      }
492                  }
493                  if (Options.SaveTokens)
494                  {
495                      SaveTokens(properties, tokenEndpointResponse ?? authorizationResponse);
496                  }
497                  if (Options.GetClaimsFromUserInfoEndpoint)
498                  {
499                      return await GetUserInformationAsync(tokenEndpointResponse ?? authorizationResponse, jwt, user, properties);
500                  }
501                  else
502                  {
503                      var identity = (ClaimsIdentity)user.Identity;
504                      foreach (var action in Options.ClaimActions)
505                      {
506                          action.Run(null, identity, ClaimsIssuer);
507                      }
508                  }
509                  return HandleRequestResult.Success(new AuthenticationTicket(user, properties, Scheme.Name));
510              }
511              catch (Exception exception)
512              {
513                  Logger.ExceptionProcessingMessage(exception);
514                  if (Options.RefreshOnIssuerKeyNotFound &amp;&amp; exception is SecurityTokenSignatureKeyNotFoundException)
515                  {
516                      if (Options.ConfigurationManager != null)
517                      {
518                          Logger.ConfigurationManagerRequestRefreshCalled();
519                          Options.ConfigurationManager.RequestRefresh();
520                      }
521                  }
522                  var authenticationFailedContext = await RunAuthenticationFailedEventAsync(authorizationResponse, exception);
523                  if (authenticationFailedContext.Result != null)
524                  {
525                      return authenticationFailedContext.Result;
526                  }
527                  return HandleRequestResult.Fail(exception, properties);
528              }
529          }
530          private AuthenticationProperties ReadPropertiesAndClearState(OpenIdConnectMessage message)
531          {
532              AuthenticationProperties properties = null;
533              if (!string.IsNullOrEmpty(message.State))
534              {
535                  properties = Options.StateDataFormat.Unprotect(message.State);
536                  if (properties != null)
537                  {
538                      properties.Items.TryGetValue(OpenIdConnectDefaults.UserstatePropertiesKey, out var userstate);
539                      message.State = userstate;
540                  }
541              }
542              return properties;
543          }
544          private void PopulateSessionProperties(OpenIdConnectMessage message, AuthenticationProperties properties)
545          {
546              if (!string.IsNullOrEmpty(message.SessionState))
547              {
548                  properties.Items[OpenIdConnectSessionProperties.SessionState] = message.SessionState;
549              }
550              if (!string.IsNullOrEmpty(_configuration.CheckSessionIframe))
551              {
552                  properties.Items[OpenIdConnectSessionProperties.CheckSessionIFrame] = _configuration.CheckSessionIframe;
553              }
554          }
555          protected virtual async Task&lt;OpenIdConnectMessage&gt; RedeemAuthorizationCodeAsync(OpenIdConnectMessage tokenEndpointRequest)
556          {
557              Logger.RedeemingCodeForTokens();
558              var requestMessage = new HttpRequestMessage(HttpMethod.Post, _configuration.TokenEndpoint);
559              requestMessage.Content = new FormUrlEncodedContent(tokenEndpointRequest.Parameters);
560              var responseMessage = await Backchannel.SendAsync(requestMessage);
561              var contentMediaType = responseMessage.Content.Headers.ContentType?.MediaType;
562              if (string.IsNullOrEmpty(contentMediaType))
563              {
564                  Logger.LogDebug($&quot;Unexpected token response format. Status Code: {(int)responseMessage.StatusCode}. Content-Type header is missing.&quot;);
565              }
566              else if (!string.Equals(contentMediaType, &quot;application/json&quot;, StringComparison.OrdinalIgnoreCase))
567              {
568                  Logger.LogDebug($&quot;Unexpected token response format. Status Code: {(int)responseMessage.StatusCode}. Content-Type {responseMessage.Content.Headers.ContentType}.&quot;);
569              }
570              OpenIdConnectMessage message;
571              try
572              {
573                  var responseContent = await responseMessage.Content.ReadAsStringAsync();
574                  message = new OpenIdConnectMessage(responseContent);
575              }
576              catch (Exception ex)
577              {
578                  throw new OpenIdConnectProtocolException($&quot;Failed to parse token response body as JSON. Status Code: {(int)responseMessage.StatusCode}. Content-Type: {responseMessage.Content.Headers.ContentType}&quot;, ex);
579              }
580              if (!responseMessage.IsSuccessStatusCode)
581              {
582                  throw CreateOpenIdConnectProtocolException(message, responseMessage);
583              }
584              return message;
585          }
586          protected virtual async Task&lt;HandleRequestResult&gt; GetUserInformationAsync(
587              OpenIdConnectMessage message, JwtSecurityToken jwt,
588              ClaimsPrincipal principal, AuthenticationProperties properties)
589          {
590              var userInfoEndpoint = _configuration?.UserInfoEndpoint;
591              if (string.IsNullOrEmpty(userInfoEndpoint))
592              {
593                  Logger.UserInfoEndpointNotSet();
594                  return HandleRequestResult.Success(new AuthenticationTicket(principal, properties, Scheme.Name));
595              }
596              if (string.IsNullOrEmpty(message.AccessToken))
597              {
598                  Logger.AccessTokenNotAvailable();
599                  return HandleRequestResult.Success(new AuthenticationTicket(principal, properties, Scheme.Name));
600              }
601              Logger.RetrievingClaims();
602              var requestMessage = new HttpRequestMessage(HttpMethod.Get, userInfoEndpoint);
603              requestMessage.Headers.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, message.AccessToken);
604              var responseMessage = await Backchannel.SendAsync(requestMessage);
605              responseMessage.EnsureSuccessStatusCode();
606              var userInfoResponse = await responseMessage.Content.ReadAsStringAsync();
607              JObject user;
608              var contentType = responseMessage.Content.Headers.ContentType;
609              if (contentType.MediaType.Equals(&quot;application/json&quot;, StringComparison.OrdinalIgnoreCase))
610              {
611                  user = JObject.Parse(userInfoResponse);
612              }
613              else if (contentType.MediaType.Equals(&quot;application/jwt&quot;, StringComparison.OrdinalIgnoreCase))
614              {
615                  var userInfoEndpointJwt = new JwtSecurityToken(userInfoResponse);
616                  user = JObject.FromObject(userInfoEndpointJwt.Payload);
617              }
618              else
619              {
620                  return HandleRequestResult.Fail(&quot;Unknown response type: &quot; + contentType.MediaType, properties);
621              }
622              var userInformationReceivedContext = await RunUserInformationReceivedEventAsync(principal, properties, message, user);
623              if (userInformationReceivedContext.Result != null)
624              {
625                  return userInformationReceivedContext.Result;
626              }
627              principal = userInformationReceivedContext.Principal;
628              properties = userInformationReceivedContext.Properties;
629              user = userInformationReceivedContext.User;
630              Options.ProtocolValidator.ValidateUserInfoResponse(new OpenIdConnectProtocolValidationContext()
631              {
632                  UserInfoEndpointResponse = userInfoResponse,
633                  ValidatedIdToken = jwt,
634              });
635              var identity = (ClaimsIdentity)principal.Identity;
636              foreach (var action in Options.ClaimActions)
637              {
638                  action.Run(user, identity, ClaimsIssuer);
639              }
640              return HandleRequestResult.Success(new AuthenticationTicket(principal, properties, Scheme.Name));
641          }
642          private void SaveTokens(AuthenticationProperties properties, OpenIdConnectMessage message)
643          {
644              var tokens = new List&lt;AuthenticationToken&gt;();
645              if (!string.IsNullOrEmpty(message.AccessToken))
646              {
647                  tokens.Add(new AuthenticationToken { Name = OpenIdConnectParameterNames.AccessToken, Value = message.AccessToken });
648              }
649              if (!string.IsNullOrEmpty(message.IdToken))
650              {
651                  tokens.Add(new AuthenticationToken { Name = OpenIdConnectParameterNames.IdToken, Value = message.IdToken });
652              }
653              if (!string.IsNullOrEmpty(message.RefreshToken))
654              {
655                  tokens.Add(new AuthenticationToken { Name = OpenIdConnectParameterNames.RefreshToken, Value = message.RefreshToken });
656              }
657              if (!string.IsNullOrEmpty(message.TokenType))
658              {
659                  tokens.Add(new AuthenticationToken { Name = OpenIdConnectParameterNames.TokenType, Value = message.TokenType });
660              }
661              if (!string.IsNullOrEmpty(message.ExpiresIn))
662              {
663                  if (int.TryParse(message.ExpiresIn, NumberStyles.Integer, CultureInfo.InvariantCulture, out int value))
664                  {
665                      var expiresAt = Clock.UtcNow + TimeSpan.FromSeconds(value);
666                      tokens.Add(new AuthenticationToken { Name = &quot;expires_at&quot;, Value = expiresAt.ToString(&quot;o&quot;, CultureInfo.InvariantCulture) });
667                  }
668              }
669              properties.StoreTokens(tokens);
670          }
671          private void WriteNonceCookie(string nonce)
672          {
673              if (string.IsNullOrEmpty(nonce))
674              {
675                  throw new ArgumentNullException(nameof(nonce));
676              }
677              var cookieOptions = Options.NonceCookie.Build(Context, Clock.UtcNow);
678              Response.Cookies.Append(
679                  Options.NonceCookie.Name + Options.StringDataFormat.Protect(nonce),
680                  NonceProperty,
681                  cookieOptions);
682          }
683          private string ReadNonceCookie(string nonce)
684          {
685              if (nonce == null)
686              {
687                  return null;
688              }
689              foreach (var nonceKey in Request.Cookies.Keys)
690              {
691                  if (nonceKey.StartsWith(Options.NonceCookie.Name))
692                  {
693                      try
694                      {
695                          var nonceDecodedValue = Options.StringDataFormat.Unprotect(nonceKey.Substring(Options.NonceCookie.Name.Length, nonceKey.Length - Options.NonceCookie.Name.Length));
696                          if (nonceDecodedValue == nonce)
697                          {
698                              var cookieOptions = Options.NonceCookie.Build(Context, Clock.UtcNow);
699                              Response.Cookies.Delete(nonceKey, cookieOptions);
700                              return nonce;
701                          }
702                      }
703                      catch (Exception ex)
704                      {
705                          Logger.UnableToProtectNonceCookie(ex);
706                      }
707                  }
708              }
709              return null;
710          }
711          private AuthenticationProperties GetPropertiesFromState(string state)
712          {
713              var startIndex = 0;
714              if (string.IsNullOrEmpty(state) || (startIndex = state.IndexOf(OpenIdConnectDefaults.AuthenticationPropertiesKey, StringComparison.Ordinal)) == -1)
715              {
716                  return null;
717              }
718              var authenticationIndex = startIndex + OpenIdConnectDefaults.AuthenticationPropertiesKey.Length;
719              if (authenticationIndex == -1 || authenticationIndex == state.Length || state[authenticationIndex] != &#x27;=&#x27;)
720              {
721                  return null;
722              }
723              authenticationIndex++;
724              var endIndex = state.Substring(authenticationIndex, state.Length - authenticationIndex).IndexOf(&quot;&amp;&quot;, StringComparison.Ordinal);
725              if (endIndex == -1)
726              {
727                  return Options.StateDataFormat.Unprotect(Uri.UnescapeDataString(state.Substring(authenticationIndex).Replace(&#x27;+&#x27;, &#x27; &#x27;)));
728              }
729              else
730              {
731                  return Options.StateDataFormat.Unprotect(Uri.UnescapeDataString(state.Substring(authenticationIndex, endIndex).Replace(&#x27;+&#x27;, &#x27; &#x27;)));
732              }
733          }
734          private async Task&lt;MessageReceivedContext&gt; RunMessageReceivedEventAsync(OpenIdConnectMessage message, AuthenticationProperties properties)
735          {
736              Logger.MessageReceived(message.BuildRedirectUrl());
737              var context = new MessageReceivedContext(Context, Scheme, Options, properties)
738              {
739                  ProtocolMessage = message,
740              };
741              await Events.MessageReceived(context);
742              if (context.Result != null)
743              {
744                  if (context.Result.Handled)
745                  {
746                      Logger.MessageReceivedContextHandledResponse();
747                  }
748                  else if (context.Result.Skipped)
749                  {
750                      Logger.MessageReceivedContextSkipped();
751                  }
752              }
753              return context;
754          }
755          private async Task&lt;TokenValidatedContext&gt; RunTokenValidatedEventAsync(OpenIdConnectMessage authorizationResponse, OpenIdConnectMessage tokenEndpointResponse, ClaimsPrincipal user, AuthenticationProperties properties, JwtSecurityToken jwt, string nonce)
756          {
757              var context = new TokenValidatedContext(Context, Scheme, Options, user, properties)
758              {
759                  ProtocolMessage = authorizationResponse,
760                  TokenEndpointResponse = tokenEndpointResponse,
761                  SecurityToken = jwt,
762                  Nonce = nonce,
763              };
764              await Events.TokenValidated(context);
765              if (context.Result != null)
766              {
767                  if (context.Result.Handled)
768                  {
769                      Logger.TokenValidatedHandledResponse();
770                  }
771                  else if (context.Result.Skipped)
772                  {
773                      Logger.TokenValidatedSkipped();
774                  }
775              }
776              return context;
777          }
778          private async Task&lt;AuthorizationCodeReceivedContext&gt; RunAuthorizationCodeReceivedEventAsync(OpenIdConnectMessage authorizationResponse, ClaimsPrincipal user, AuthenticationProperties properties, JwtSecurityToken jwt)
779          {
780              Logger.AuthorizationCodeReceived();
781              var tokenEndpointRequest = new OpenIdConnectMessage()
782              {
783                  ClientId = Options.ClientId,
784                  ClientSecret = Options.ClientSecret,
785                  Code = authorizationResponse.Code,
786                  GrantType = OpenIdConnectGrantTypes.AuthorizationCode,
787                  EnableTelemetryParameters = !Options.DisableTelemetry,
788                  RedirectUri = properties.Items[OpenIdConnectDefaults.RedirectUriForCodePropertiesKey]
789              };
790              var context = new AuthorizationCodeReceivedContext(Context, Scheme, Options, properties)
791              {
792                  ProtocolMessage = authorizationResponse,
793                  TokenEndpointRequest = tokenEndpointRequest,
794                  Principal = user,
795                  JwtSecurityToken = jwt,
796                  Backchannel = Backchannel
797              };
798              await Events.AuthorizationCodeReceived(context);
799              if (context.Result != null)
800              {
801                  if (context.Result.Handled)
802                  {
803                      Logger.AuthorizationCodeReceivedContextHandledResponse();
804                  }
805                  else if (context.Result.Skipped)
806                  {
807                      Logger.AuthorizationCodeReceivedContextSkipped();
808                  }
809              }
810              return context;
811          }
812          private async Task&lt;TokenResponseReceivedContext&gt; RunTokenResponseReceivedEventAsync(
813              OpenIdConnectMessage message,
814              OpenIdConnectMessage tokenEndpointResponse,
815              ClaimsPrincipal user,
816              AuthenticationProperties properties)
817          {
818              Logger.TokenResponseReceived();
819              var context = new TokenResponseReceivedContext(Context, Scheme, Options, user, properties)
820              {
821                  ProtocolMessage = message,
822                  TokenEndpointResponse = tokenEndpointResponse,
823              };
824              await Events.TokenResponseReceived(context);
825              if (context.Result != null)
826              {
827                  if (context.Result.Handled)
828                  {
829                      Logger.TokenResponseReceivedHandledResponse();
830                  }
831                  else if (context.Result.Skipped)
832                  {
833                      Logger.TokenResponseReceivedSkipped();
834                  }
835              }
836              return context;
837          }
838          private async Task&lt;UserInformationReceivedContext&gt; RunUserInformationReceivedEventAsync(ClaimsPrincipal principal, AuthenticationProperties properties, OpenIdConnectMessage message, JObject user)
839          {
840              Logger.UserInformationReceived(user.ToString());
841              var context = new UserInformationReceivedContext(Context, Scheme, Options, principal, properties)
842              {
843                  ProtocolMessage = message,
844                  User = user,
845              };
846              await Events.UserInformationReceived(context);
847              if (context.Result != null)
848              {
849                  if (context.Result.Handled)
850                  {
851                      Logger.UserInformationReceivedHandledResponse();
852                  }
853                  else if (context.Result.Skipped)
854                  {
855                      Logger.UserInformationReceivedSkipped();
856                  }
857              }
858              return context;
859          }
860          private async Task&lt;AuthenticationFailedContext&gt; RunAuthenticationFailedEventAsync(OpenIdConnectMessage message, Exception exception)
861          {
862              var context = new AuthenticationFailedContext(Context, Scheme, Options)
863              {
864                  ProtocolMessage = message,
865                  Exception = exception
866              };
867              await Events.AuthenticationFailed(context);
868              if (context.Result != null)
869              {
870                  if (context.Result.Handled)
871                  {
872                      Logger.AuthenticationFailedContextHandledResponse();
873                  }
874                  else if (context.Result.Skipped)
875                  {
876                      Logger.AuthenticationFailedContextSkipped();
877                  }
878              }
879              return context;
880          }
881          private ClaimsPrincipal ValidateToken(string idToken, AuthenticationProperties properties, TokenValidationParameters validationParameters, out JwtSecurityToken jwt)
882          {
883              if (!Options.SecurityTokenValidator.CanReadToken(idToken))
884              {
885                  Logger.UnableToReadIdToken(idToken);
886                  throw new SecurityTokenException(string.Format(CultureInfo.InvariantCulture, Resources.UnableToValidateToken, idToken));
887              }
888              if (_configuration != null)
889              {
890                  var issuer = new[] { _configuration.Issuer };
891                  validationParameters.ValidIssuers = validationParameters.ValidIssuers?.Concat(issuer) ?? issuer;
892                  validationParameters.IssuerSigningKeys = validationParameters.IssuerSigningKeys?.Concat(_configuration.SigningKeys)
893                      ?? _configuration.SigningKeys;
894              }
895              var principal = Options.SecurityTokenValidator.ValidateToken(idToken, validationParameters, out SecurityToken validatedToken);
896              jwt = validatedToken as JwtSecurityToken;
897              if (jwt == null)
898              {
899                  Logger.InvalidSecurityTokenType(validatedToken?.GetType().ToString());
900                  throw new SecurityTokenException(string.Format(CultureInfo.InvariantCulture, Resources.ValidatedSecurityTokenNotJwt, validatedToken?.GetType()));
901              }
902              if (validatedToken == null)
903              {
904                  Logger.UnableToValidateIdToken(idToken);
905                  throw new SecurityTokenException(string.Format(CultureInfo.InvariantCulture, Resources.UnableToValidateToken, idToken));
906              }
907              if (Options.UseTokenLifetime)
908              {
909                  var issued = validatedToken.ValidFrom;
910                  if (issued != DateTime.MinValue)
911                  {
912                      properties.IssuedUtc = issued;
913                  }
914                  var expires = validatedToken.ValidTo;
915                  if (expires != DateTime.MinValue)
916                  {
917                      properties.ExpiresUtc = expires;
918                  }
919              }
920              return principal;
921          }
922          private string BuildRedirectUriIfRelative(string uri)
923          {
924              if (string.IsNullOrEmpty(uri))
925              {
926                  return uri;
927              }
928              if (!uri.StartsWith(&quot;/&quot;, StringComparison.Ordinal))
929              {
930                  return uri;
931              }
932              return BuildRedirectUri(uri);
933          }
934          private OpenIdConnectProtocolException CreateOpenIdConnectProtocolException(OpenIdConnectMessage message, HttpResponseMessage response)
935          {
936              var description = message.ErrorDescription ?? &quot;error_description is null&quot;;
937              var errorUri = message.ErrorUri ?? &quot;error_uri is null&quot;;
938              if (response != null)
939              {
940                  Logger.ResponseErrorWithStatusCode(message.Error, description, errorUri, (int)response.StatusCode);
941              }
942              else
943              {
944                  Logger.ResponseError(message.Error, description, errorUri);
945              }
946              return new OpenIdConnectProtocolException(string.Format(
947                  CultureInfo.InvariantCulture,
948                  Resources.MessageContainsError,
949                  message.Error,
950                  description,
951                  errorUri));
952          }
953      }
954  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-WsFederationHandler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Security-MDEwOlJlcG9zaXRvcnkxNzcyMzY5OQ==-flat-OpenIdConnectHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>62              GenerateCorrelationId(properties);
63              var redirectContext = new RedirectContext(Context, Scheme, Options, properties)
64              {
65                  ProtocolMessage = wsFederationMessage
66              };
67              await Events.RedirectToIdentityProvider(redirectContext);
68              if (redirectContext.Handled)
69              {
70                  return;
</pre></code></div>
                <div class="column column_space"><pre><code>264              GenerateCorrelationId(properties);
265              var redirectContext = new RedirectContext(Context, Scheme, Options, properties)
266              {
267                  ProtocolMessage = message
268              };
269              await Events.RedirectToIdentityProvider(redirectContext);
270              if (redirectContext.Handled)
271              {
272                  Logger.RedirectToIdentityProviderHandledResponse();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    