
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 73, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlDataReader.cs</h3>
            <pre><code>1  using System;
2  using System.Collections;
3  using System.Collections.Generic;
4  using System.Collections.ObjectModel;
5  using System.Data;
6  using System.Data.Common;
7  using System.Diagnostics;
8  using System.Diagnostics.CodeAnalysis;
9  using System.IO;
10  using System.Linq;
11  using System.Runtime.CompilerServices;
12  using System.Runtime.ExceptionServices;
13  using System.Text;
14  using System.Threading;
15  using System.Threading.Tasks;
16  using Microsoft.Extensions.Logging;
17  using Npgsql.BackendMessages;
18  using Npgsql.Internal;
19  using Npgsql.Internal.TypeHandlers;
20  using Npgsql.Internal.TypeHandling;
21  using Npgsql.PostgresTypes;
22  using Npgsql.Schema;
23  using Npgsql.Util;
24  using NpgsqlTypes;
25  using static Npgsql.Util.Statics;
26  #pragma warning disable CA2222 
27  namespace Npgsql;
28  #pragma warning disable CA1010
29  public sealed class NpgsqlDataReader : DbDataReader, IDbColumnSchemaGenerator
30  #pragma warning restore CA1010
31  {
32      internal NpgsqlCommand Command { get; private set; } = default!;
33      internal NpgsqlConnector Connector { get; }
34      NpgsqlConnection? _connection;
35      CommandBehavior _behavior;
36      Task? _sendTask;
37      internal ReaderState State = ReaderState.Disposed;
38      internal NpgsqlReadBuffer Buffer = default!;
39      List&lt;NpgsqlBatchCommand&gt; _statements = default!;
40      internal int StatementIndex { get; private set; }
41      int _numColumns;
42      readonly List&lt;(int Offset, int Length)&gt; _columns = new();
43      int _column;
44      internal int ColumnLen;
45      internal int PosInColumn;
46      int _dataMsgEnd;
47      bool _canConsumeRowNonSequentially;
48      int _charPos;
49      internal RowDescriptionMessage? RowDescription;
50      ulong? _recordsAffected;
51      bool _hasRows;
52      public event EventHandler? ReaderClosed;
53      bool _isSchemaOnly;
54      bool _isSequential;
55      NpgsqlReadBuffer.ColumnStream? _columnStream;
56      internal ulong UniqueRowId;
57      internal NpgsqlNestedDataReader? CachedFreeNestedDataReader;
58      readonly ILogger _commandLogger;
59      internal NpgsqlDataReader(NpgsqlConnector connector)
60      {
61          Connector = connector;
62          _commandLogger = connector.CommandLogger;
63      }
64      internal void Init(
65          NpgsqlCommand command,
66          CommandBehavior behavior,
67          List&lt;NpgsqlBatchCommand&gt; statements,
68          Task? sendTask = null)
69      {
70          Command = command;
71          _connection = command.InternalConnection;
72          _behavior = behavior;
73          _isSchemaOnly = _behavior.HasFlag(CommandBehavior.SchemaOnly);
74          _isSequential = _behavior.HasFlag(CommandBehavior.SequentialAccess);
75          _statements = statements;
76          StatementIndex = -1;
77          _sendTask = sendTask;
78          State = ReaderState.BetweenResults;
79          _recordsAffected = null;
80      }
81      #region Read
82      public override bool Read()
83      {
84          CheckClosedOrDisposed();
85          UniqueRowId++;
86          var fastRead = TryFastRead();
87          return fastRead.HasValue
88              ? fastRead.Value
89              : Read(false).GetAwaiter().GetResult();
90      }
91      public override Task&lt;bool&gt; ReadAsync(CancellationToken cancellationToken)
92      {
93          CheckClosedOrDisposed();
94          UniqueRowId++;
95          var fastRead = TryFastRead();
96          if (fastRead.HasValue)
97              return fastRead.Value ? PGUtil.TrueTask : PGUtil.FalseTask;
98          using (NoSynchronizationContextScope.Enter())
99              return Read(true, cancellationToken);
100      }
101      bool? TryFastRead()
102      {
103          if (_behavior.HasFlag(CommandBehavior.SingleRow))
104              return null;
105          switch (State)
106          {
107          case ReaderState.BeforeResult:
108              State = ReaderState.InResult;
109              return true;
110          case ReaderState.InResult:
111              if (!_canConsumeRowNonSequentially)
112                  return null;
113              ConsumeRowNonSequential();
114              break;
115          case ReaderState.BetweenResults:
116          case ReaderState.Consumed:
117          case ReaderState.Closed:
118          case ReaderState.Disposed:
119              return false;
120          }
121          var readBuf = Connector.ReadBuffer;
122          if (readBuf.ReadBytesLeft &lt; 5)
123              return null;
124          var messageCode = (BackendMessageCode)readBuf.ReadByte();
125          var len = readBuf.ReadInt32() - 4;  
126          if (messageCode != BackendMessageCode.DataRow || readBuf.ReadBytesLeft &lt; len)
127          {
128              readBuf.ReadPosition -= 5;
129              return null;
130          }
131          var msg = Connector.ParseServerMessage(readBuf, BackendMessageCode.DataRow, len, false)!;
132          Debug.Assert(msg.Code == BackendMessageCode.DataRow);
133          ProcessMessage(msg);
134          return true;
135      }
136      async Task&lt;bool&gt; Read(bool async, CancellationToken cancellationToken = default)
137      {
138          var registration = Connector.StartNestedCancellableOperation(cancellationToken);
139          try
140          {
141              switch (State)
142              {
143              case ReaderState.BeforeResult:
144                  State = ReaderState.InResult;
145                  return true;
146              case ReaderState.InResult:
147                  await ConsumeRow(async);
148                  if (_behavior.HasFlag(CommandBehavior.SingleRow))
149                  {
150                      await Consume(async);
151                      return false;
152                  }
153                  break;
154              case ReaderState.BetweenResults:
155              case ReaderState.Consumed:
156              case ReaderState.Closed:
157              case ReaderState.Disposed:
158                  return false;
159              default:
160                  ThrowHelper.ThrowArgumentOutOfRangeException();
161                  return false;
162              }
163              var msg = await ReadMessage(async);
164              switch (msg.Code)
165              {
166              case BackendMessageCode.DataRow:
167                  ProcessMessage(msg);
168                  return true;
169              case BackendMessageCode.CommandComplete:
170              case BackendMessageCode.EmptyQueryResponse:
171                  ProcessMessage(msg);
172                  if (_statements[StatementIndex].AppendErrorBarrier ?? Command.EnableErrorBarriers)
173                      Expect&lt;ReadyForQueryMessage&gt;(await Connector.ReadMessage(async), Connector);
174                  return false;
175              default:
176                  throw Connector.UnexpectedMessageReceived(msg.Code);
177              }
178          }
179          catch
180          {
181              State = ReaderState.Consumed;
182              throw;
183          }
184          finally
185          {
186              registration.Dispose();
187          }
188      }
189      ValueTask&lt;IBackendMessage&gt; ReadMessage(bool async)
190      {
191          return _isSequential ? ReadMessageSequential(Connector, async) : Connector.ReadMessage(async);
192          static async ValueTask&lt;IBackendMessage&gt; ReadMessageSequential(NpgsqlConnector connector, bool async)
193          {
194              var msg = await connector.ReadMessage(async, DataRowLoadingMode.Sequential);
195              if (msg.Code == BackendMessageCode.DataRow)
196              {
197                  await connector.ReadBuffer.Ensure(2, async);
198                  return msg;
199              }
200              return msg;
201          }
202      }
203      #endregion
204      #region NextResult
205      public override bool NextResult() =&gt; (_isSchemaOnly ? NextResultSchemaOnly(false) : NextResult(false))
206          .GetAwaiter().GetResult();
207      public override Task&lt;bool&gt; NextResultAsync(CancellationToken cancellationToken)
208      {
209          using var _ = NoSynchronizationContextScope.Enter();
210          return _isSchemaOnly
211              ? NextResultSchemaOnly(async: true, cancellationToken: cancellationToken)
212              : NextResult(async: true, cancellationToken: cancellationToken);
213      }
214      [MethodImpl(MethodImplOptions.AggressiveInlining)]
215      async Task&lt;bool&gt; NextResult(bool async, bool isConsuming = false, CancellationToken cancellationToken = default)
216      {
217          CheckClosedOrDisposed();
218          IBackendMessage msg;
219          Debug.Assert(!_isSchemaOnly);
220          using var registration = isConsuming ? default : Connector.StartNestedCancellableOperation(cancellationToken);
221          try
222          {
223              switch (State)
224              {
225              case ReaderState.BeforeResult:
226              case ReaderState.InResult:
227                  await ConsumeRow(async);
228                  while (true)
229                  {
230                      var completedMsg = await Connector.ReadMessage(async, DataRowLoadingMode.Skip);
231                      switch (completedMsg.Code)
232                      {
233                      case BackendMessageCode.CommandComplete:
234                      case BackendMessageCode.EmptyQueryResponse:
235                          ProcessMessage(completedMsg);
236                          if (_statements[StatementIndex].AppendErrorBarrier ?? Command.EnableErrorBarriers)
237                              Expect&lt;ReadyForQueryMessage&gt;(await Connector.ReadMessage(async), Connector);
238                          break;
239                      default:
240                          continue;
241                      }
242                      break;
243                  }
244                  break;
245              case ReaderState.BetweenResults:
246                  break;
247              case ReaderState.Consumed:
248              case ReaderState.Closed:
249              case ReaderState.Disposed:
250                  return false;
251              default:
252                  ThrowHelper.ThrowArgumentOutOfRangeException();
253                  return false;
254              }
255              Debug.Assert(State == ReaderState.BetweenResults);
256              _hasRows = false;
257              if (_behavior.HasFlag(CommandBehavior.SingleResult) &amp;&amp; StatementIndex == 0 &amp;&amp; !isConsuming)
258              {
259                  await Consume(async);
260                  return false;
261              }
262              for (StatementIndex++; StatementIndex &lt; _statements.Count; StatementIndex++)
263              {
264                  var statement = _statements[StatementIndex];
265                  if (statement.TryGetPrepared(out var preparedStatement))
266                  {
267                      Expect&lt;BindCompleteMessage&gt;(await Connector.ReadMessage(async), Connector);
268                      RowDescription = preparedStatement.Description;
269                  }
270                  else 
271                  {
272                      var pStatement = statement.PreparedStatement;
273                      if (pStatement != null)
274                      {
275                          Debug.Assert(!pStatement.IsPrepared);
276                          if (pStatement.StatementBeingReplaced != null)
277                          {
278                              Expect&lt;CloseCompletedMessage&gt;(await Connector.ReadMessage(async), Connector);
279                              pStatement.StatementBeingReplaced.CompleteUnprepare();
280                              pStatement.StatementBeingReplaced = null;
281                          }
282                      }
283                      Expect&lt;ParseCompleteMessage&gt;(await Connector.ReadMessage(async), Connector);
284                      if (statement.IsPreparing)
285                      {
286                          pStatement!.State = PreparedState.Prepared;
287                          Connector.PreparedStatementManager.NumPrepared++;
288                          statement.IsPreparing = false;
289                      }
290                      Expect&lt;BindCompleteMessage&gt;(await Connector.ReadMessage(async), Connector);
291                      msg = await Connector.ReadMessage(async);
292                      RowDescription = statement.Description = msg.Code switch
293                      {
294                          BackendMessageCode.NoData =&gt; null,
295                          BackendMessageCode.RowDescription =&gt; pStatement == null
296                              ? (RowDescriptionMessage)msg
297                              : ((RowDescriptionMessage)msg).Clone(),
298                          _ =&gt; throw Connector.UnexpectedMessageReceived(msg.Code)
299                      };
300                  }
301                  if (RowDescription == null)
302                  {
303                      msg = await Connector.ReadMessage(async);
304                      switch (msg.Code)
305                      {
306                      case BackendMessageCode.CommandComplete:
307                      case BackendMessageCode.EmptyQueryResponse:
308                          break;
309                      case BackendMessageCode.CopyInResponse:
310                          throw Connector.Break(new NotSupportedException(
311                              &quot;COPY isn&#x27;t supported in regular command execution - see https:&amp;bsol;&amp;bsol;www.npgsql.org/doc/copy.html for documentation on COPY with Npgsql. &quot; +
312                              &quot;If you are trying to execute a SQL script created by pg_dump, pass the &#x27;--inserts&#x27; switch to disable generating COPY statements.&quot;));
313                      case BackendMessageCode.CopyOutResponse:
314                          throw Connector.Break(new NotSupportedException(
315                              &quot;COPY isn&#x27;t supported in regular command execution - see https:&amp;bsol;&amp;bsol;www.npgsql.org/doc/copy.html for documentation on COPY with Npgsql.&quot;));
316                      default:
317                          throw Connector.UnexpectedMessageReceived(msg.Code);
318                      }
319                      ProcessMessage(msg);
320                      if (statement.AppendErrorBarrier ?? Command.EnableErrorBarriers)
321                          Expect&lt;ReadyForQueryMessage&gt;(await Connector.ReadMessage(async), Connector);
322                      continue;
323                  }
324                  if (!Command.IsWrappedByBatch &amp;&amp; StatementIndex == 0 &amp;&amp; Command.Parameters.HasOutputParameters)
325                  {
326                      msg = await Connector.ReadMessage(async);
327                      ProcessMessage(msg);
328                      if (msg.Code == BackendMessageCode.DataRow)
329                          PopulateOutputParameters();
330                  }
331                  else
332                  {
333                      msg = await ReadMessage(async);
334                      ProcessMessage(msg);
335                  }
336                  switch (msg.Code)
337                  {
338                  case BackendMessageCode.DataRow:
339                      Connector.State = ConnectorState.Fetching;
340                      return true;
341                  case BackendMessageCode.CommandComplete:
342                      if (statement.AppendErrorBarrier ?? Command.EnableErrorBarriers)
343                          Expect&lt;ReadyForQueryMessage&gt;(await Connector.ReadMessage(async), Connector);
344                      return true;
345                  default:
346                      throw Connector.UnexpectedMessageReceived(msg.Code);
347                  }
348              }
349              if (_statements.Count == 0 || !(_statements[_statements.Count - 1].AppendErrorBarrier ?? Command.EnableErrorBarriers))
350                  Expect&lt;ReadyForQueryMessage&gt;(await Connector.ReadMessage(async), Connector);
351              State = ReaderState.Consumed;
352              RowDescription = null;
353              return false;
354          }
355          catch (Exception e)
356          {
357              if (e is PostgresException postgresException &amp;&amp; StatementIndex &gt;= 0 &amp;&amp; StatementIndex &lt; _statements.Count)
358              {
359                  var statement = _statements[StatementIndex];
360                  postgresException.BatchCommand = statement;
361                  Command.IsCacheable = false;
362                  if (postgresException.SqlState == PostgresErrorCodes.FeatureNotSupported &amp;&amp;
363                      statement.PreparedStatement is { } preparedStatement)
364                  {
365                      preparedStatement.State = PreparedState.Invalidated;
366                      Command.ResetPreparation();
367                      foreach (var s in Command.InternalBatchCommands)
368                          s.ResetPreparation();
369                  }
370              }
371              for (; StatementIndex &lt; _statements.Count; StatementIndex++)
372              {
373                  var statement = _statements[StatementIndex];
374                  if (statement.IsPreparing)
375                  {
376                      statement.IsPreparing = false;
377                      statement.PreparedStatement!.AbortPrepare();
378                  }
379                  if ((statement.AppendErrorBarrier ?? Command.EnableErrorBarriers) &amp;&amp; StatementIndex &lt; _statements.Count - 1)
380                  {
381                      if (isConsuming)
382                          throw;
383                      switch (State)
384                      {
385                      case ReaderState.Consumed:
386                      case ReaderState.Closed:
387                      case ReaderState.Disposed:
388                          break;
389                      default:
390                          await Consume(async, firstException: e);
391                          break; 
392                      }
393                  }
394              }
395              State = ReaderState.Consumed;
396              throw;
397          }
398      }
399      void PopulateOutputParameters()
400      {
401          Debug.Assert(Command.Parameters.Any(p =&gt; p.IsOutputDirection));
402          Debug.Assert(StatementIndex == 0);
403          Debug.Assert(RowDescription != null);
404          Debug.Assert(State == ReaderState.BeforeResult);
405          var currentPosition = Buffer.ReadPosition;
406          State = ReaderState.InResult;
407          var pending = new Queue&lt;object&gt;();
408          var taken = new List&lt;NpgsqlParameter&gt;();
409          for (var i = 0; i &lt; FieldCount; i++)
410          {
411              if (Command.Parameters.TryGetValue(GetName(i), out var p) &amp;&amp; p.IsOutputDirection)
412              {
413                  p.Value = GetValue(i);
414                  taken.Add(p);
415              }
416              else
417                  pending.Enqueue(GetValue(i));
418          }
419          foreach (var p in Command.Parameters.Where(p =&gt; p.IsOutputDirection &amp;&amp; !taken.Contains(p)))
420          {
421              if (pending.Count == 0)
422                  break;
423              p.Value = pending.Dequeue();
424          }
425          State = ReaderState.BeforeResult; 
426          Buffer.ReadPosition = currentPosition; 
427          _column = -1;
428          ColumnLen = -1;
429          PosInColumn = 0;
430      }
431      async Task&lt;bool&gt; NextResultSchemaOnly(bool async, bool isConsuming = false, CancellationToken cancellationToken = default)
432      {
433          Debug.Assert(_isSchemaOnly);
434          using var registration = isConsuming ? default : Connector.StartNestedCancellableOperation(cancellationToken);
435          try
436          {
437              switch (State)
438              {
439              case ReaderState.BeforeResult:
440              case ReaderState.InResult:
441              case ReaderState.BetweenResults:
442                  break;
443              case ReaderState.Consumed:
444              case ReaderState.Closed:
445              case ReaderState.Disposed:
446                  return false;
447              default:
448                  ThrowHelper.ThrowArgumentOutOfRangeException();
449                  return false;
450              }
451              for (StatementIndex++; StatementIndex &lt; _statements.Count; StatementIndex++)
452              {
453                  var statement = _statements[StatementIndex];
454                  if (statement.TryGetPrepared(out var preparedStatement))
455                  {
456                      RowDescription = preparedStatement.Description;
457                  }
458                  else
459                  {
460                      var pStatement = statement.PreparedStatement;
461                      if (pStatement != null)
462                      {
463                          Debug.Assert(!pStatement.IsPrepared);
464                          if (pStatement.StatementBeingReplaced != null)
465                          {
466                              Expect&lt;CloseCompletedMessage&gt;(await Connector.ReadMessage(async), Connector);
467                              pStatement.StatementBeingReplaced.CompleteUnprepare();
468                              pStatement.StatementBeingReplaced = null;
469                          }
470                      }
471                      Expect&lt;ParseCompleteMessage&gt;(await Connector.ReadMessage(async), Connector);
472                      if (statement.IsPreparing)
473                      {
474                          pStatement!.State = PreparedState.Prepared;
475                          Connector.PreparedStatementManager.NumPrepared++;
476                          statement.IsPreparing = false;
477                      }
478                      Expect&lt;ParameterDescriptionMessage&gt;(await Connector.ReadMessage(async), Connector);
479                      var msg = await Connector.ReadMessage(async);
480                      switch (msg.Code)
481                      {
482                      case BackendMessageCode.NoData:
483                          RowDescription = _statements[StatementIndex].Description = null;
484                          break;
485                      case BackendMessageCode.RowDescription:
486                          RowDescription = _statements[StatementIndex].Description = (RowDescriptionMessage)msg;
487                          Command.FixupRowDescription(RowDescription, StatementIndex == 0);
488                          break;
489                      default:
490                          throw Connector.UnexpectedMessageReceived(msg.Code);
491                      }
492                  }
493                  if (RowDescription != null)
494                      return true;
495              }
496              if (!_statements.All(s =&gt; s.IsPrepared))
497              {
498                  Expect&lt;ReadyForQueryMessage&gt;(await Connector.ReadMessage(async), Connector);
499                  RowDescription = null;
500                  State = ReaderState.Consumed;
501              }
502              return false;
503          }
504          catch (Exception e)
505          {
506              State = ReaderState.Consumed;
507              if (e is PostgresException postgresException &amp;&amp; StatementIndex &gt;= 0 &amp;&amp; StatementIndex &lt; _statements.Count)
508              {
509                  postgresException.BatchCommand = _statements[StatementIndex];
510                  Command.IsCacheable = false;
511              }
512              for (; StatementIndex &lt; _statements.Count; StatementIndex++)
513              {
514                  var statement = _statements[StatementIndex];
515                  if (statement.IsPreparing)
516                  {
517                      statement.IsPreparing = false;
518                      statement.PreparedStatement!.AbortPrepare();
519                  }
520              }
521              throw;
522          }
523      }
524      #endregion
525      #region ProcessMessage
526      internal void ProcessMessage(IBackendMessage msg)
527      {
528          switch (msg.Code)
529          {
530          case BackendMessageCode.DataRow:
531              ProcessDataRowMessage((DataRowMessage)msg);
532              return;
533          case BackendMessageCode.CommandComplete:
534              var completed = (CommandCompleteMessage)msg;
535              switch (completed.StatementType)
536              {
537              case StatementType.Update:
538              case StatementType.Insert:
539              case StatementType.Delete:
540              case StatementType.Copy:
541              case StatementType.Move:
542              case StatementType.Merge:
543                  if (!_recordsAffected.HasValue)
544                      _recordsAffected = 0;
545                  _recordsAffected += completed.Rows;
546                  break;
547              }
548              _statements[StatementIndex].ApplyCommandComplete(completed);
549              goto case BackendMessageCode.EmptyQueryResponse;
550          case BackendMessageCode.EmptyQueryResponse:
551              State = ReaderState.BetweenResults;
552              return;
553          default:
554              ThrowUnexpectedBackendMessage(msg.Code);
555              return;
556          }
557          static void ThrowUnexpectedBackendMessage(BackendMessageCode code)
558              =&gt; throw new Exception(&quot;Received unexpected backend message of type &quot; + code);
559      }
560      void ProcessDataRowMessage(DataRowMessage msg)
561      {
562          Buffer = Connector.ReadBuffer;
563          _hasRows = true;
564          _column = -1;
565          ColumnLen = -1;
566          PosInColumn = 0;
567          _numColumns = Buffer.ReadInt16();
568          Debug.Assert(_numColumns == RowDescription!.Count,
569              $&quot;Row&#x27;s number of columns ({_numColumns}) differs from the row description&#x27;s ({RowDescription.Count})&quot;);
570          _dataMsgEnd = Buffer.ReadPosition + msg.Length - 2;
571          _canConsumeRowNonSequentially = Buffer.ReadBytesLeft &gt;= msg.Length - 2;
572          if (!_isSequential)
573          {
574              Debug.Assert(_canConsumeRowNonSequentially);
575              _columns.Clear();
576              var len = Buffer.ReadInt32();
577              _columns.Add((Buffer.ReadPosition, len));
578          }
579          switch (State)
580          {
581          case ReaderState.BetweenResults:
582              State = ReaderState.BeforeResult;
583              break;
584          case ReaderState.BeforeResult:
585              State = ReaderState.InResult;
586              break;
587          case ReaderState.InResult:
588              break;
589          default:
590              throw Connector.UnexpectedMessageReceived(BackendMessageCode.DataRow);
591          }
592      }
593      #endregion
594      public override int Depth =&gt; 0;
595      public override bool IsClosed =&gt; State == ReaderState.Closed || State == ReaderState.Disposed;
596      public override int RecordsAffected
597          =&gt; !_recordsAffected.HasValue
598              ? -1
599              : _recordsAffected &gt; int.MaxValue
600                  ? throw new OverflowException(
601                      $&quot;The number of records affected exceeds int.MaxValue. Use {nameof(Rows)}.&quot;)
602                  : (int)_recordsAffected;
603      public ulong Rows =&gt; _recordsAffected ?? 0;
604      [Obsolete(&quot;Use the new DbBatch API&quot;)]
605      public IReadOnlyList&lt;NpgsqlBatchCommand&gt; Statements =&gt; _statements.AsReadOnly();
606      public override bool HasRows
607          =&gt; State switch
608          {
609              ReaderState.Closed =&gt; throw new InvalidOperationException(&quot;Invalid attempt to call HasRows when reader is closed.&quot;),
610              ReaderState.Disposed =&gt; throw new ObjectDisposedException(nameof(NpgsqlDataReader)),
611              _ =&gt; _hasRows
612          };
613      public bool IsOnRow =&gt; State == ReaderState.InResult;
614      public override string GetName(int ordinal) =&gt; GetField(ordinal).Name;
615      public override int FieldCount
616      {
617          get
618          {
619              CheckClosedOrDisposed();
620              return RowDescription?.Count ?? 0;
621          }
622      }
623      #region Cleanup / Dispose
624      async Task Consume(bool async, Exception? firstException = null)
625      {
626          var exceptions = firstException is null ? null : new List&lt;Exception&gt; { firstException };
627          while (true)
628          {
629              try
630              {
631                  if (!(_isSchemaOnly
632                          ? await NextResultSchemaOnly(async, isConsuming: true)
633                          : await NextResult(async, isConsuming: true)))
634                  {
635                      break;
636                  }
637              }
638              catch (Exception e)
639              {
640                  exceptions ??= new();
641                  exceptions.Add(e);
642              }
643          }
644          Debug.Assert(exceptions?.Count != 0);
645          switch (exceptions?.Count)
646          {
647          case null:
648              return;
649          case 1:
650              ExceptionDispatchInfo.Capture(exceptions[0]).Throw();
651              return;
652          default:
653              throw new NpgsqlException(
654                  &quot;Multiple exceptions occurred when consuming the result set&quot;,
655                  new AggregateException(exceptions));
656          }
657      }
658      protected override void Dispose(bool disposing)
659      {
660          try
661          {
662              Close(connectionClosing: false, async: false, isDisposing: true).GetAwaiter().GetResult();
663          }
664          catch (Exception ex)
665          {
666              if (!(ex is PostgresException ||
667                    ex is NpgsqlException { InnerException: AggregateException aggregateException } &amp;&amp;
668                    aggregateException.InnerExceptions.All(e =&gt; e is PostgresException)))
669              {
670                  State = ReaderState.Disposed;
671              }
672              throw;
673          }
674          finally
675          {
676              Command.TraceCommandStop();
677          }
678      }
679  #if NETSTANDARD2_0
680      public ValueTask DisposeAsync()
681  #else
682      public override ValueTask DisposeAsync()
683  #endif
684      {
685          using (NoSynchronizationContextScope.Enter())
686              return DisposeAsyncCore();
687          [MethodImpl(MethodImplOptions.AggressiveInlining)]
688          async ValueTask DisposeAsyncCore()
689          {
690              try
691              {
692                  await Close(connectionClosing: false, async: true, isDisposing: true);
693              }
694              catch (Exception ex)
695              {
696                  if (!(ex is PostgresException ||
697                        ex is NpgsqlException { InnerException: AggregateException aggregateException } &amp;&amp;
698                        aggregateException.InnerExceptions.All(e =&gt; e is PostgresException)))
699                  {
700                      State = ReaderState.Disposed;
701                  }
702                  throw;
703              }
704              finally
705              {
706                  Command.TraceCommandStop();
707              }
708          }
709      }
710      public override void Close() =&gt; Close(connectionClosing: false, async: false, isDisposing: false).GetAwaiter().GetResult();
711  #if NETSTANDARD2_0
712      public Task CloseAsync()
713  #else
714      public override Task CloseAsync()
715  #endif
716      {
717          using (NoSynchronizationContextScope.Enter())
718              return Close(connectionClosing: false, async: true, isDisposing: false);
719      }
720      internal async Task Close(bool connectionClosing, bool async, bool isDisposing)
721      {
722          if (State is ReaderState.Closed or ReaderState.Disposed)
723          {
724              if (isDisposing)
725                  State = ReaderState.Disposed;
726              return;
727          }
728          Connector.CurrentReader = null;
729          switch (Connector.State)
730          {
731          case ConnectorState.Ready:
732          case ConnectorState.Fetching:
733          case ConnectorState.Executing:
734          case ConnectorState.Connecting:
735              if (State != ReaderState.Consumed)
736              {
737                  try
738                  {
739                      await Consume(async);
740                  }
741                  catch (Exception ex) when (ex is OperationCanceledException or NpgsqlException { InnerException : TimeoutException })
742                  {
743                  }
744                  catch (Exception ex) when (
745                      ex is PostgresException ||
746                      ex is NpgsqlException { InnerException: AggregateException aggregateException } &amp;&amp;
747                      aggregateException.InnerExceptions.All(e =&gt; e is PostgresException))
748                  {
749                      await Cleanup(async, connectionClosing, isDisposing);
750                      throw;
751                  }
752                  catch
753                  {
754                      Debug.Assert(Connector.IsBroken);
755                      throw;
756                  }
757              }
758              break;
759          case ConnectorState.Closed:
760          case ConnectorState.Broken:
761              break;
762          case ConnectorState.Waiting:
763          case ConnectorState.Copy:
764          case ConnectorState.Replication:
765              Debug.Fail(&quot;Bad connector state when closing reader: &quot; + Connector.State);
766              break;
767          default:
768              throw new ArgumentOutOfRangeException();
769          }
770          await Cleanup(async, connectionClosing, isDisposing);
771      }
772      internal async Task Cleanup(bool async, bool connectionClosing = false, bool isDisposing = false)
773      {
774          LogMessages.ReaderCleanup(_commandLogger, Connector.Id);
775          if (_sendTask != null)
776          {
777              if (Connector.IsBroken)
778              {
779                  _ = _sendTask.ContinueWith(t =&gt; _ = t.Exception, CancellationToken.None, TaskContinuationOptions.OnlyOnFaulted, TaskScheduler.Current);
780              }
781              else
782              {
783                  try
784                  {
785                      if (async)
786                          await _sendTask;
787                      else
788                          _sendTask.GetAwaiter().GetResult();
789                  }
790                  catch (Exception e)
791                  {
792                      _commandLogger.LogDebug(e, &quot;Exception caught while sending the request&quot;, Connector.Id);
793                  }
794              }
795          }
796          State = ReaderState.Closed;
797          Command.State = CommandState.Idle;
798          Connector.CurrentReader = null;
799          if (_commandLogger.IsEnabled(LogLevel.Information))
800              Command.LogExecutingCompleted(Connector, executing: false);
801          NpgsqlEventSource.Log.CommandStop();
802          Connector.EndUserAction();
803          if (isDisposing)
804              State = ReaderState.Disposed;
805          if (_connection?.ConnectorBindingScope == ConnectorBindingScope.Reader)
806          {
807              UnbindIfNecessary();
808              _connection.Connector = null;
809              Connector.Connection = null;
810              _connection.ConnectorBindingScope = ConnectorBindingScope.None;
811              if (_behavior.HasFlag(CommandBehavior.CloseConnection) &amp;&amp; !connectionClosing)
812                  _connection.Close();
813              Connector.ReaderCompleted.SetResult(null);
814          }
815          else if (_behavior.HasFlag(CommandBehavior.CloseConnection) &amp;&amp; !connectionClosing)
816          {
817              Debug.Assert(_connection is not null);
818              _connection.Close();
819          }
820          if (ReaderClosed != null)
821          {
822              ReaderClosed(this, EventArgs.Empty);
823              ReaderClosed = null;
824          }
825      }
826      #endregion
827      #region Simple value getters
828      public override bool GetBoolean(int ordinal) =&gt; GetFieldValue&lt;bool&gt;(ordinal);
829      public override byte GetByte(int ordinal) =&gt; GetFieldValue&lt;byte&gt;(ordinal);
830      public override char GetChar(int ordinal) =&gt; GetFieldValue&lt;char&gt;(ordinal);
831      public override short GetInt16(int ordinal) =&gt; GetFieldValue&lt;short&gt;(ordinal);
832      public override int GetInt32(int ordinal) =&gt; GetFieldValue&lt;int&gt;(ordinal);
833      public override long GetInt64(int ordinal) =&gt; GetFieldValue&lt;long&gt;(ordinal);
834      public override DateTime GetDateTime(int ordinal) =&gt; GetFieldValue&lt;DateTime&gt;(ordinal);
835      public override string GetString(int ordinal) =&gt; GetFieldValue&lt;string&gt;(ordinal);
836      public override decimal GetDecimal(int ordinal) =&gt; GetFieldValue&lt;decimal&gt;(ordinal);
837      public override double GetDouble(int ordinal) =&gt; GetFieldValue&lt;double&gt;(ordinal);
838      public override float GetFloat(int ordinal) =&gt; GetFieldValue&lt;float&gt;(ordinal);
839      public override Guid GetGuid(int ordinal) =&gt; GetFieldValue&lt;Guid&gt;(ordinal);
<span onclick='openModal()' class='match'>840      public override int GetValues(object[] values)
841      {
842          if (values == null)
843              throw new ArgumentNullException(nameof(values));
844          CheckResultSet();
845          var count = Math.Min(FieldCount, values.Length);
846          for (var i = 0; i &lt; count; i++)
847              values[i] = GetValue(i);
848          return count;
849      }
850      public override object this[int ordinal] =&gt; GetValue(ordinal);
</span>851      #endregion
852      #region Provider-specific simple type getters
853      public TimeSpan GetTimeSpan(int ordinal) =&gt; GetFieldValue&lt;TimeSpan&gt;(ordinal);
854      protected override DbDataReader GetDbDataReader(int ordinal) =&gt; GetData(ordinal);
855      public new NpgsqlNestedDataReader GetData(int ordinal)
856      {
857          var field = CheckRowAndGetField(ordinal);
858          var type = field.PostgresType;
859          var isArray = type is PostgresArrayType;
860          var elementType = isArray ? ((PostgresArrayType)type).Element : type;
861          var compositeType = elementType as PostgresCompositeType;
862          if (elementType.InternalName != &quot;record&quot; &amp;&amp; compositeType == null)
863              throw new InvalidCastException(&quot;GetData() not supported for type &quot; + field.TypeDisplayName);
864          SeekToColumn(ordinal, false).GetAwaiter().GetResult();
865          if (ColumnLen == -1)
866              ThrowHelper.ThrowInvalidCastException_NoValue(field);
867          if (_isSequential)
868              throw new NotSupportedException(&quot;GetData() not supported in sequential mode.&quot;);
869          var reader = CachedFreeNestedDataReader;
870          if (reader != null)
871          {
872              CachedFreeNestedDataReader = null;
873              reader.Init(UniqueRowId, compositeType);
874          }
875          else
876          {
877              reader = new NpgsqlNestedDataReader(this, null, UniqueRowId, 1, compositeType);
878          }
879          if (isArray)
880              reader.InitArray();
881          else
882              reader.InitSingleRow();
883          return reader;
884      }
885      #endregion
886      #region Special binary getters
887      public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
888      {
889          if (dataOffset is &lt; 0 or &gt; int.MaxValue)
890              throw new ArgumentOutOfRangeException(nameof(dataOffset), dataOffset, $&quot;dataOffset must be between {0} and {int.MaxValue}&quot;);
891          if (buffer != null &amp;&amp; (bufferOffset &lt; 0 || bufferOffset &gt;= buffer.Length + 1))
892              throw new IndexOutOfRangeException($&quot;bufferOffset must be between 0 and {buffer.Length}&quot;);
893          if (buffer != null &amp;&amp; (length &lt; 0 || length &gt; buffer.Length - bufferOffset))
894              throw new IndexOutOfRangeException($&quot;length must be between 0 and {buffer.Length - bufferOffset}&quot;);
895          var field = CheckRowAndGetField(ordinal);
896          var handler = field.Handler;
897          if (!(handler is ByteaHandler))
898              throw new InvalidCastException(&quot;GetBytes() not supported for type &quot; + field.Name);
899          SeekToColumn(ordinal, false).GetAwaiter().GetResult();
900          if (ColumnLen is -1)
901              ThrowHelper.ThrowInvalidCastException_NoValue(field);
902          if (buffer is null)
903              return ColumnLen;
904          var dataOffset2 = (int)dataOffset;
905          SeekInColumn(dataOffset2, false).GetAwaiter().GetResult();
906          if (dataOffset2 + length &gt; ColumnLen)
907              length = Math.Max(ColumnLen - dataOffset2, 0);
908          var left = length;
909          while (left &gt; 0)
910          {
911              var read = Buffer.Read(new Span&lt;byte&gt;(buffer, bufferOffset, left));
912              bufferOffset += read;
913              left -= read;
914          }
915          PosInColumn += length;
916          return length;
917      }
918      public override Stream GetStream(int ordinal) =&gt; GetStream(ordinal, false).Result;
919      public Task&lt;Stream&gt; GetStreamAsync(int ordinal, CancellationToken cancellationToken = default)
920      {
921          using (NoSynchronizationContextScope.Enter())
922              return GetStream(ordinal, true, cancellationToken).AsTask();
923      }
924      ValueTask&lt;Stream&gt; GetStream(int ordinal, bool async, CancellationToken cancellationToken = default) =&gt;
925          GetStreamInternal(CheckRowAndGetField(ordinal), ordinal, async, cancellationToken);
926      async ValueTask&lt;Stream&gt; GetStreamInternal(FieldDescription field, int ordinal, bool async, CancellationToken cancellationToken = default)
927      {
928          if (_columnStream is { IsDisposed: false })
929              ThrowHelper.ThrowInvalidOperationException(&quot;A stream is already open for this reader&quot;);
930          using var registration = Connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
931          await SeekToColumn(ordinal, async, cancellationToken);
932          if (_isSequential)
933              CheckColumnStart();
934          if (ColumnLen == -1)
935              ThrowHelper.ThrowInvalidCastException_NoValue(field);
936          PosInColumn += ColumnLen;
937          return _columnStream = (NpgsqlReadBuffer.ColumnStream)Buffer.GetStream(ColumnLen, !_isSequential);
938      }
939      #endregion
940      #region Special text getters
941      public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
942      {
943          if (dataOffset is &lt; 0 or &gt; int.MaxValue)
944              throw new ArgumentOutOfRangeException(nameof(dataOffset), dataOffset, $&quot;dataOffset must be between 0 and {int.MaxValue}&quot;);
945          if (buffer != null &amp;&amp; (bufferOffset &lt; 0 || bufferOffset &gt;= buffer.Length + 1))
946              throw new IndexOutOfRangeException($&quot;bufferOffset must be between 0 and {buffer.Length}&quot;);
947          if (buffer != null &amp;&amp; (length &lt; 0 || length &gt; buffer.Length - bufferOffset))
948              throw new IndexOutOfRangeException($&quot;length must be between 0 and {buffer.Length - bufferOffset}&quot;);
949          var field = CheckRowAndGetField(ordinal);
950          var handler = field.Handler as TextHandler;
951          if (handler == null)
952              throw new InvalidCastException(&quot;The GetChars method is not supported for type &quot; + field.Name);
953          SeekToColumn(ordinal, false).GetAwaiter().GetResult();
954          if (ColumnLen == -1)
955              ThrowHelper.ThrowInvalidCastException_NoValue(field);
956          if (PosInColumn == 0)
957              _charPos = 0;
958          var decoder = Buffer.TextEncoding.GetDecoder();
959          if (buffer == null)
960          {
961              var (bytesSkipped, charsSkipped) = SkipChars(decoder, int.MaxValue, ColumnLen - PosInColumn);
962              Debug.Assert(bytesSkipped == ColumnLen - PosInColumn);
963              PosInColumn += bytesSkipped;
964              _charPos += charsSkipped;
965              return _charPos;
966          }
967          if (PosInColumn == ColumnLen || dataOffset &lt; _charPos)
968          {
969              SeekInColumn(0, false).GetAwaiter().GetResult();
970              _charPos = 0;
971          }
972          if (dataOffset &gt; _charPos)
973          {
974              var charsToSkip = (int)dataOffset - _charPos;
975              var (bytesSkipped, charsSkipped) = SkipChars(decoder, charsToSkip, ColumnLen - PosInColumn);
976              decoder.Reset();
977              PosInColumn += bytesSkipped;
978              _charPos += charsSkipped;
979              if (charsSkipped &lt; charsToSkip) 
980                  return 0;
981          }
982          if (length == 0)
983              return 0;
984          var (bytesRead, charsRead) = DecodeChars(decoder, buffer.AsSpan(bufferOffset, length), ColumnLen - PosInColumn);
985          PosInColumn += bytesRead;
986          _charPos += charsRead;
987          return charsRead;
988      }
989      (int BytesRead, int CharsRead) DecodeChars(Decoder decoder, Span&lt;char&gt; output, int byteCount)
990      {
991          var (bytesRead, charsRead) = (0, 0);
992          var outputLength = output.Length;
993          while (true)
994          {
995              Buffer.Ensure(1); 
996              var maxBytes = Math.Min(byteCount - bytesRead, Buffer.ReadBytesLeft);
997              var bytes = Buffer.Buffer.AsSpan(Buffer.ReadPosition, maxBytes);
998              decoder.Convert(bytes, output, false, out var bytesUsed, out var charsUsed, out _);
999              Buffer.ReadPosition += bytesUsed;
1000              bytesRead += bytesUsed;
1001              charsRead += charsUsed;
1002              if (charsRead == outputLength || bytesRead == byteCount)
1003                  break;
1004              output = output.Slice(charsUsed);
1005          }
1006          return (bytesRead, charsRead);
1007      }
1008      internal (int BytesSkipped, int CharsSkipped) SkipChars(Decoder decoder, int charCount, int byteCount)
1009      {
1010          Span&lt;char&gt; tempCharBuf = stackalloc char[512];
1011          var (charsSkipped, bytesSkipped) = (0, 0);
1012          while (charsSkipped &lt; charCount &amp;&amp; bytesSkipped &lt; byteCount)
1013          {
1014              var (bytesRead, charsRead) = DecodeChars(decoder, tempCharBuf.Slice(0, Math.Min(charCount, tempCharBuf.Length)), byteCount);
1015              bytesSkipped += bytesRead;
1016              charsSkipped += charsRead;
1017          }
1018          return (bytesSkipped, charsSkipped);
1019      }
1020      public override TextReader GetTextReader(int ordinal)
1021          =&gt; GetTextReader(ordinal, false).Result;
1022      public Task&lt;TextReader&gt; GetTextReaderAsync(int ordinal, CancellationToken cancellationToken = default)
1023      {
1024          using (NoSynchronizationContextScope.Enter())
1025              return GetTextReader(ordinal, true, cancellationToken).AsTask();
1026      }
1027      async ValueTask&lt;TextReader&gt; GetTextReader(int ordinal, bool async, CancellationToken cancellationToken = default)
1028      {
1029          var field = CheckRowAndGetField(ordinal);
1030          if (field.Handler is ITextReaderHandler handler)
1031          {
1032              var stream = async
1033                  ? await GetStreamInternal(field, ordinal, true, cancellationToken)
1034                  : GetStreamInternal(field, ordinal, false, CancellationToken.None).Result;
1035              return handler.GetTextReader(stream, Buffer);
1036          }
1037          throw new InvalidCastException($&quot;The GetTextReader method is not supported for type {field.PostgresType.DisplayName}&quot;);
1038      }
1039      #endregion
1040      #region GetFieldValue
1041      public override Task&lt;T&gt; GetFieldValueAsync&lt;T&gt;(int ordinal, CancellationToken cancellationToken)
1042      {
1043          if (typeof(T) == typeof(Stream))
1044              return (Task&lt;T&gt;)(object)GetStreamAsync(ordinal, cancellationToken);
1045          if (typeof(T) == typeof(TextReader))
1046              return (Task&lt;T&gt;)(object)GetTextReaderAsync(ordinal, cancellationToken);
1047          if (!_isSequential)
1048              return Task.FromResult(GetFieldValue&lt;T&gt;(ordinal));
1049          using (NoSynchronizationContextScope.Enter())
1050              return GetFieldValueSequential&lt;T&gt;(ordinal, true, cancellationToken).AsTask();
1051      }
1052      public override T GetFieldValue&lt;T&gt;(int ordinal)
1053      {
1054          if (typeof(T) == typeof(Stream))
1055              return (T)(object)GetStream(ordinal);
1056          if (typeof(T) == typeof(TextReader))
1057              return (T)(object)GetTextReader(ordinal);
1058          if (_isSequential)
1059              return GetFieldValueSequential&lt;T&gt;(ordinal, false).GetAwaiter().GetResult();
1060          var field = CheckRowAndGetField(ordinal);
1061          SeekToColumnNonSequential(ordinal);
1062          if (ColumnLen == -1)
1063          {
1064              if (NullableHandler&lt;T&gt;.Exists)
1065                  return default!;
1066              if (typeof(T) == typeof(object))
1067                  return (T)(object)DBNull.Value;
1068              ThrowHelper.ThrowInvalidCastException_NoValue(field);
1069          }
1070          return NullableHandler&lt;T&gt;.Exists
1071              ? NullableHandler&lt;T&gt;.Read(field.Handler, Buffer, ColumnLen, field)
1072              : typeof(T) == typeof(object)
1073                  ? (T)field.Handler.ReadAsObject(Buffer, ColumnLen, field)
1074                  : field.Handler.Read&lt;T&gt;(Buffer, ColumnLen, field);
1075      }
1076      async ValueTask&lt;T&gt; GetFieldValueSequential&lt;T&gt;(int column, bool async, CancellationToken cancellationToken = default)
1077      {
1078          using var registration = Connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
1079          var field = CheckRowAndGetField(column);
1080          await SeekToColumnSequential(column, async, CancellationToken.None);
1081          CheckColumnStart();
1082          if (ColumnLen == -1)
1083          {
1084              if (NullableHandler&lt;T&gt;.Exists)
1085                  return default!;
1086              if (typeof(T) == typeof(object))
1087                  return (T)(object)DBNull.Value;
1088              ThrowHelper.ThrowInvalidCastException_NoValue(field);
1089          }
1090          var position = Buffer.ReadPosition;
1091          try
1092          {
1093              return NullableHandler&lt;T&gt;.Exists
1094                  ? ColumnLen &lt;= Buffer.ReadBytesLeft
1095                      ? NullableHandler&lt;T&gt;.Read(field.Handler, Buffer, ColumnLen, field)
1096                      : await NullableHandler&lt;T&gt;.ReadAsync(field.Handler, Buffer, ColumnLen, async, field)
1097                  : typeof(T) == typeof(object)
1098                      ? ColumnLen &lt;= Buffer.ReadBytesLeft
1099                          ? (T)field.Handler.ReadAsObject(Buffer, ColumnLen, field)
1100                          : (T)await field.Handler.ReadAsObject(Buffer, ColumnLen, async, field)
1101                      : ColumnLen &lt;= Buffer.ReadBytesLeft
1102                          ? field.Handler.Read&lt;T&gt;(Buffer, ColumnLen, field)
1103                          : await field.Handler.Read&lt;T&gt;(Buffer, ColumnLen, async, field);
1104          }
1105          catch
1106          {
1107              if (Connector.State != ConnectorState.Broken)
1108              {
1109                  var writtenBytes = Buffer.ReadPosition - position;
1110                  var remainingBytes = ColumnLen - writtenBytes;
1111                  if (remainingBytes &gt; 0)
1112                      await Buffer.Skip(remainingBytes, async);
1113              }
1114              throw;
1115          }
1116          finally
1117          {
1118              PosInColumn += ColumnLen;
1119          }
1120      }
1121      #endregion
1122      #region GetValue
1123      public override object GetValue(int ordinal)
1124      {
1125          var fieldDescription = CheckRowAndGetField(ordinal);
1126          if (_isSequential)
1127          {
1128              SeekToColumnSequential(ordinal, false).GetAwaiter().GetResult();
1129              CheckColumnStart();
1130          }
1131          else
1132              SeekToColumnNonSequential(ordinal);
1133          if (ColumnLen == -1)
1134              return DBNull.Value;
1135          object result;
1136          var position = Buffer.ReadPosition;
1137          try
1138          {
1139              result = _isSequential
1140                  ? fieldDescription.Handler.ReadAsObject(Buffer, ColumnLen, false, fieldDescription).GetAwaiter().GetResult()
1141                  : fieldDescription.Handler.ReadAsObject(Buffer, ColumnLen, fieldDescription);
1142          }
1143          catch
1144          {
1145              if (Connector.State != ConnectorState.Broken)
1146              {
1147                  var writtenBytes = Buffer.ReadPosition - position;
1148                  var remainingBytes = ColumnLen - writtenBytes;
1149                  if (remainingBytes &gt; 0)
1150                      Buffer.Skip(remainingBytes, false).GetAwaiter().GetResult();
1151              }
1152              throw;
1153          }
1154          finally
1155          {
1156              PosInColumn += ColumnLen;
1157          }
1158          var objectResultType = Command.ObjectResultTypes?[ordinal];
1159          if (objectResultType != null)
1160          {
1161              result = objectResultType == typeof(DateTimeOffset)
1162                  ? new DateTimeOffset((DateTime)result)
1163                  : Convert.ChangeType(result, objectResultType)!;
1164          }
1165          return result;
1166      }
1167      public override object this[string name] =&gt; GetValue(GetOrdinal(name));
1168      #endregion
1169      #region IsDBNull
1170      public override bool IsDBNull(int ordinal)
1171      {
1172          CheckRowAndGetField(ordinal);
1173          if (_isSequential)
1174              SeekToColumnSequential(ordinal, false).GetAwaiter().GetResult();
1175          else
1176              SeekToColumnNonSequential(ordinal);
1177          return ColumnLen == -1;
1178      }
1179      public override Task&lt;bool&gt; IsDBNullAsync(int ordinal, CancellationToken cancellationToken)
1180      {
1181          CheckRowAndGetField(ordinal);
1182          if (!_isSequential)
1183              return IsDBNull(ordinal) ? PGUtil.TrueTask : PGUtil.FalseTask;
1184          using (NoSynchronizationContextScope.Enter())
1185              return IsDBNullAsyncInternal(ordinal, cancellationToken);
1186          async Task&lt;bool&gt; IsDBNullAsyncInternal(int ordinal, CancellationToken cancellationToken)
1187          {
1188              using var registration = Connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
1189              await SeekToColumn(ordinal, true, cancellationToken);
1190              return ColumnLen == -1;
1191          }
1192      }
1193      #endregion
1194      #region Other public accessors
1195      public override int GetOrdinal(string name)
1196      {
1197          if (string.IsNullOrEmpty(name))
1198              ThrowHelper.ThrowArgumentException($&quot;{nameof(name)} cannot be empty&quot;, nameof(name));
1199          CheckClosedOrDisposed();
1200          if (RowDescription is null)
1201              ThrowHelper.ThrowInvalidOperationException(&quot;No resultset is currently being traversed&quot;);
1202          return RowDescription.GetFieldIndex(name);
1203      }
1204      public PostgresType GetPostgresType(int ordinal) =&gt; GetField(ordinal).PostgresType;
1205      public override string GetDataTypeName(int ordinal) =&gt; GetField(ordinal).TypeDisplayName;
1206      public uint GetDataTypeOID(int ordinal) =&gt; GetField(ordinal).TypeOID;
1207      public override Type GetFieldType(int ordinal)
1208          =&gt; Command.ObjectResultTypes?[ordinal]
1209             ?? GetField(ordinal).FieldType;
1210      public override IEnumerator GetEnumerator()
1211          =&gt; new DbEnumerator(this);
1212      public ReadOnlyCollection&lt;NpgsqlDbColumn&gt; GetColumnSchema()
1213          =&gt; GetColumnSchema(async: false).GetAwaiter().GetResult();
1214      ReadOnlyCollection&lt;DbColumn&gt; IDbColumnSchemaGenerator.GetColumnSchema()
1215          =&gt; new(GetColumnSchema().Select(c =&gt; (DbColumn)c).ToList());
1216  #if NET5_0_OR_GREATER
1217      public new Task&lt;ReadOnlyCollection&lt;NpgsqlDbColumn&gt;&gt; GetColumnSchemaAsync(CancellationToken cancellationToken = default)
1218  #else
1219      public Task&lt;ReadOnlyCollection&lt;NpgsqlDbColumn&gt;&gt; GetColumnSchemaAsync(CancellationToken cancellationToken = default)
1220  #endif
1221      {
1222          using (NoSynchronizationContextScope.Enter())
1223              return GetColumnSchema(async: true, cancellationToken);
1224      }
1225      Task&lt;ReadOnlyCollection&lt;NpgsqlDbColumn&gt;&gt; GetColumnSchema(bool async, CancellationToken cancellationToken = default)
1226          =&gt; RowDescription == null || RowDescription.Count == 0
1227              ? Task.FromResult(new List&lt;NpgsqlDbColumn&gt;().AsReadOnly())
1228              : new DbColumnSchemaGenerator(_connection!, RowDescription, _behavior.HasFlag(CommandBehavior.KeyInfo))
1229                  .GetColumnSchema(async, cancellationToken);
1230      #endregion
1231      #region Schema metadata table
1232      [UnconditionalSuppressMessage(
1233          &quot;Composite type mapping currently isn&#x27;t trimming-safe, and warnings are generated at the MapComposite level.&quot;, &quot;IL2026&quot;)]
1234      public override DataTable? GetSchemaTable()
1235          =&gt; GetSchemaTable(async: false).GetAwaiter().GetResult();
1236      [UnconditionalSuppressMessage(
1237          &quot;Composite type mapping currently isn&#x27;t trimming-safe, and warnings are generated at the MapComposite level.&quot;, &quot;IL2026&quot;)]
1238  #if NET5_0_OR_GREATER
1239      public override Task&lt;DataTable?&gt; GetSchemaTableAsync(CancellationToken cancellationToken = default)
1240  #else
1241      public Task&lt;DataTable?&gt; GetSchemaTableAsync(CancellationToken cancellationToken = default)
1242  #endif
1243      {
1244          using (NoSynchronizationContextScope.Enter())
1245              return GetSchemaTable(async: true, cancellationToken);
1246      }
1247      [UnconditionalSuppressMessage(
1248          &quot;Composite type mapping currently isn&#x27;t trimming-safe, and warnings are generated at the MapComposite level.&quot;, &quot;IL2026&quot;)]
1249      async Task&lt;DataTable?&gt; GetSchemaTable(bool async, CancellationToken cancellationToken = default)
1250      {
1251          if (FieldCount == 0) 
1252              return null;
1253          var table = new DataTable(&quot;SchemaTable&quot;);
1254          table.Columns.Add(&quot;ColumnName&quot;, typeof(string));
1255          table.Columns.Add(&quot;ColumnOrdinal&quot;, typeof(int));
1256          table.Columns.Add(&quot;ColumnSize&quot;, typeof(int));
1257          table.Columns.Add(&quot;NumericPrecision&quot;, typeof(int));
1258          table.Columns.Add(&quot;NumericScale&quot;, typeof(int));
1259          table.Columns.Add(&quot;IsUnique&quot;, typeof(bool));
1260          table.Columns.Add(&quot;IsKey&quot;, typeof(bool));
1261          table.Columns.Add(&quot;BaseServerName&quot;, typeof(string));
1262          table.Columns.Add(&quot;BaseCatalogName&quot;, typeof(string));
1263          table.Columns.Add(&quot;BaseColumnName&quot;, typeof(string));
1264          table.Columns.Add(&quot;BaseSchemaName&quot;, typeof(string));
1265          table.Columns.Add(&quot;BaseTableName&quot;, typeof(string));
1266          table.Columns.Add(&quot;DataType&quot;, typeof(Type));
1267          table.Columns.Add(&quot;AllowDBNull&quot;, typeof(bool));
1268          table.Columns.Add(&quot;ProviderType&quot;, typeof(int));
1269          table.Columns.Add(&quot;IsAliased&quot;, typeof(bool));
1270          table.Columns.Add(&quot;IsExpression&quot;, typeof(bool));
1271          table.Columns.Add(&quot;IsIdentity&quot;, typeof(bool));
1272          table.Columns.Add(&quot;IsAutoIncrement&quot;, typeof(bool));
1273          table.Columns.Add(&quot;IsRowVersion&quot;, typeof(bool));
1274          table.Columns.Add(&quot;IsHidden&quot;, typeof(bool));
1275          table.Columns.Add(&quot;IsLong&quot;, typeof(bool));
1276          table.Columns.Add(&quot;IsReadOnly&quot;, typeof(bool));
1277          table.Columns.Add(&quot;ProviderSpecificDataType&quot;, typeof(Type));
1278          table.Columns.Add(&quot;DataTypeName&quot;, typeof(string));
1279          foreach (var column in await GetColumnSchema(async, cancellationToken))
1280          {
1281              var row = table.NewRow();
1282              row[&quot;ColumnName&quot;] = column.ColumnName;
1283              row[&quot;ColumnOrdinal&quot;] = column.ColumnOrdinal ?? -1;
1284              row[&quot;ColumnSize&quot;] = column.ColumnSize ?? -1;
1285              row[&quot;NumericPrecision&quot;] = column.NumericPrecision ?? 0;
1286              row[&quot;NumericScale&quot;] = column.NumericScale ?? 0;
1287              row[&quot;IsUnique&quot;] = column.IsUnique == true;
1288              row[&quot;IsKey&quot;] = column.IsKey == true;
1289              row[&quot;BaseServerName&quot;] = &quot;&quot;;
1290              row[&quot;BaseCatalogName&quot;] = column.BaseCatalogName;
1291              row[&quot;BaseColumnName&quot;] = column.BaseColumnName;
1292              row[&quot;BaseSchemaName&quot;] = column.BaseSchemaName;
1293              row[&quot;BaseTableName&quot;] = column.BaseTableName;
1294              row[&quot;DataType&quot;] = column.DataType;
1295              row[&quot;AllowDBNull&quot;] = (object?)column.AllowDBNull ?? DBNull.Value;
1296              row[&quot;ProviderType&quot;] = column.NpgsqlDbType ?? NpgsqlDbType.Unknown;
1297              row[&quot;IsAliased&quot;] = column.IsAliased == true;
1298              row[&quot;IsExpression&quot;] = column.IsExpression == true;
1299              row[&quot;IsIdentity&quot;] = column.IsIdentity == true;
1300              row[&quot;IsAutoIncrement&quot;] = column.IsAutoIncrement == true;
1301              row[&quot;IsRowVersion&quot;] = false;
1302              row[&quot;IsHidden&quot;] = column.IsHidden == true;
1303              row[&quot;IsLong&quot;] = column.IsLong == true;
1304              row[&quot;DataTypeName&quot;] = column.DataTypeName;
1305              table.Rows.Add(row);
1306          }
1307          return table;
1308      }
1309      #endregion Schema metadata table
1310      #region Seeking
1311      Task SeekToColumn(int column, bool async, CancellationToken cancellationToken = default)
1312      {
1313          if (_isSequential)
1314              return SeekToColumnSequential(column, async, cancellationToken);
1315          SeekToColumnNonSequential(column);
1316          return Task.CompletedTask;
1317      }
1318      void SeekToColumnNonSequential(int column)
1319      {
1320          if (_columnStream != null)
1321          {
1322              _columnStream.Dispose();
1323              _columnStream = null;
1324          }
1325          for (var lastColumnRead = _columns.Count; column &gt;= lastColumnRead; lastColumnRead++)
1326          {
1327              int lastColumnLen;
1328              (Buffer.ReadPosition, lastColumnLen) = _columns[lastColumnRead - 1];
1329              if (lastColumnLen != -1)
1330                  Buffer.ReadPosition += lastColumnLen;
1331              var len = Buffer.ReadInt32();
1332              _columns.Add((Buffer.ReadPosition, len));
1333          }
1334          (Buffer.ReadPosition, ColumnLen) = _columns[column];
1335          _column = column;
1336          PosInColumn = 0;
1337      }
1338      async Task SeekToColumnSequential(int column, bool async, CancellationToken cancellationToken = default)
1339      {
1340          if (column &lt; 0 || column &gt;= _numColumns)
1341              throw new IndexOutOfRangeException(&quot;Column index out of range&quot;);
1342          if (column &lt; _column)
1343              throw new InvalidOperationException($&quot;Invalid attempt to read from column ordinal &#x27;{column}&#x27;. With CommandBehavior.SequentialAccess, you may only read from column ordinal &#x27;{_column}&#x27; or greater.&quot;);
1344          if (column == _column)
1345              return;
1346          if (_columnStream != null)
1347          {
1348              _columnStream.Dispose();
1349              _columnStream = null;
1350              PosInColumn = ColumnLen;
1351          }
1352          var remainingInColumn = ColumnLen == -1 ? 0 : ColumnLen - PosInColumn;
1353          if (remainingInColumn &gt; 0)
1354              await Buffer.Skip(remainingInColumn, async);
1355          for (; _column &lt; column - 1; _column++)
1356          {
1357              await Buffer.Ensure(4, async);
1358              var len = Buffer.ReadInt32();
1359              if (len != -1)
1360                  await Buffer.Skip(len, async);
1361          }
1362          await Buffer.Ensure(4, async);
1363          ColumnLen = Buffer.ReadInt32();
1364          PosInColumn = 0;
1365          _column = column;
1366      }
1367      Task SeekInColumn(int dataOffset, bool async, CancellationToken cancellationToken = default)
1368      {
1369          if (_isSequential)
1370              return SeekInColumnSequential(dataOffset, async);
1371          if (dataOffset &gt;= ColumnLen)
1372              ThrowHelper.ThrowArgumentOutOfRange_OutOfColumnBounds(nameof(dataOffset), ColumnLen);
1373          Buffer.ReadPosition = _columns[_column].Offset + dataOffset;
1374          PosInColumn = dataOffset;
1375          return Task.CompletedTask;
1376          async Task SeekInColumnSequential(int dataOffset, bool async)
1377          {
1378              Debug.Assert(_column &gt; -1);
1379              if (dataOffset &lt; PosInColumn)
1380                  ThrowHelper.ThrowInvalidOperationException(&quot;Attempt to read a position in the column which has already been read&quot;);
1381              if (dataOffset &gt;= ColumnLen)
1382                  ThrowHelper.ThrowArgumentOutOfRange_OutOfColumnBounds(nameof(dataOffset), ColumnLen);
1383              if (dataOffset &gt; PosInColumn)
1384              {
1385                  await Buffer.Skip(dataOffset - PosInColumn, async);
1386                  PosInColumn = dataOffset;
1387              }
1388          }
1389      }
1390      #endregion
1391      #region ConsumeRow
1392      Task ConsumeRow(bool async)
1393      {
1394          Debug.Assert(State == ReaderState.InResult || State == ReaderState.BeforeResult);
1395          UniqueRowId++;
1396          if (!_canConsumeRowNonSequentially)
1397              return ConsumeRowSequential(async);
1398          ConsumeRowNonSequential();
1399          return Task.CompletedTask;
1400          async Task ConsumeRowSequential(bool async)
1401          {
1402              if (_columnStream != null)
1403              {
1404                  _columnStream.Dispose();
1405                  _columnStream = null;
1406                  PosInColumn = ColumnLen;
1407              }
1408              var remainingInColumn = ColumnLen == -1 ? 0 : ColumnLen - PosInColumn;
1409              if (remainingInColumn &gt; 0)
1410                  await Buffer.Skip(remainingInColumn, async);
1411              for (; _column &lt; _numColumns - 1; _column++)
1412              {
1413                  await Buffer.Ensure(4, async);
1414                  var len = Buffer.ReadInt32();
1415                  if (len != -1)
1416                      await Buffer.Skip(len, async);
1417              }
1418          }
1419      }
1420      [MethodImpl(MethodImplOptions.AggressiveInlining)]
1421      void ConsumeRowNonSequential()
1422      {
1423          Debug.Assert(State == ReaderState.InResult || State == ReaderState.BeforeResult);
1424          if (_columnStream is not null)
1425          {
1426              _columnStream.Dispose();
1427              _columnStream = null;
1428              PosInColumn = ColumnLen;
1429          }
1430          Buffer.ReadPosition = _dataMsgEnd;
1431      }
1432      #endregion
1433      #region Checks
1434      void CheckResultSet()
1435      {
1436          switch (State)
1437          {
1438          case ReaderState.BeforeResult:
1439          case ReaderState.InResult:
1440              return;
1441          case ReaderState.Closed:
1442              ThrowHelper.ThrowInvalidOperationException(&quot;The reader is closed&quot;);
1443              return;
1444          case ReaderState.Disposed:
1445              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlDataReader));
1446              return;
1447          default:
1448              ThrowHelper.ThrowInvalidOperationException(&quot;No resultset is currently being traversed&quot;);
1449              return;
1450          }
1451      }
1452      FieldDescription CheckRowAndGetField(int column)
1453      {
1454          switch (State)
1455          {
1456          case ReaderState.InResult:
1457              break;
1458          case ReaderState.Closed:
1459              ThrowHelper.ThrowInvalidOperationException(&quot;The reader is closed&quot;);
1460              break;
1461          case ReaderState.Disposed:
1462              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlDataReader));
1463              break;
1464          default:
1465              ThrowHelper.ThrowInvalidOperationException(&quot;No row is available&quot;);
1466              break;
1467          }
1468          if (column &lt; 0 || column &gt;= RowDescription!.Count)
1469              ThrowColumnOutOfRange(RowDescription!.Count);
1470          return RowDescription[column];
1471      }
1472      FieldDescription GetField(int column)
1473      {
1474          if (RowDescription is null)
1475              ThrowHelper.ThrowInvalidOperationException(&quot;No resultset is currently being traversed&quot;);
1476          if (column &lt; 0 || column &gt;= RowDescription.Count)
1477              ThrowColumnOutOfRange(RowDescription.Count);
1478          return RowDescription[column];
1479      }
1480      void CheckColumnStart()
1481      {
1482          Debug.Assert(_isSequential);
1483          if (PosInColumn != 0)
1484              ThrowHelper.ThrowInvalidOperationException(&quot;Attempt to read a position in the column which has already been read&quot;);
1485      }
1486      void CheckClosedOrDisposed()
1487      {
1488          switch (State)
1489          {
1490          case ReaderState.Closed:
1491              ThrowHelper.ThrowInvalidOperationException(&quot;The reader is closed&quot;);
1492              return;
1493          case ReaderState.Disposed:
1494              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlDataReader));
1495              return;
1496          }
1497      }
1498      static void ThrowColumnOutOfRange(int maxIndex) =&gt;
1499          throw new IndexOutOfRangeException($&quot;Column must be between {0} and {maxIndex - 1}&quot;);
1500      #endregion
1501      #region Misc
1502      internal void UnbindIfNecessary()
1503      {
1504          if (State != ReaderState.Disposed)
1505          {
1506              Connector.DataReader = Connector.UnboundDataReader is { State: ReaderState.Disposed } previousReader
1507                  ? previousReader
1508                  : new NpgsqlDataReader(Connector);
1509              Connector.UnboundDataReader = this;
1510          }
1511      }
1512      #endregion
1513  }
1514  enum ReaderState
1515  {
1516      BeforeResult,
1517      InResult,
1518      BetweenResults,
1519      Consumed,
1520      Closed,
1521      Disposed,
1522  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlNestedDataReader.cs</h3>
            <pre><code>1  using Npgsql.Internal;
2  using Npgsql.Internal.TypeHandlers;
3  using Npgsql.Internal.TypeHandling;
4  using Npgsql.PostgresTypes;
5  using Npgsql.TypeMapping;
6  using System;
7  using System.Collections;
8  using System.Collections.Generic;
9  using System.Data.Common;
10  using System.Globalization;
11  using System.IO;
12  using System.Runtime.CompilerServices;
13  using Npgsql.Internal.TypeMapping;
14  namespace Npgsql;
15  public sealed class NpgsqlNestedDataReader : DbDataReader
16  {
17      readonly NpgsqlDataReader _outermostReader;
18      ulong _uniqueOutermostReaderRowId;
19      readonly NpgsqlNestedDataReader? _outerNestedReader;
20      NpgsqlNestedDataReader? _cachedFreeNestedDataReader;
21      PostgresCompositeType? _compositeType;
22      readonly int _depth;
23      int _numRows;
24      int _nextRowIndex;
25      int _nextRowBufferPos;
26      ReaderState _readerState;
27      readonly List&lt;ColumnInfo&gt; _columns = new();
28      readonly struct ColumnInfo
29      {
30          public readonly uint TypeOid;
31          public readonly int BufferPos;
32          public readonly NpgsqlTypeHandler TypeHandler;
33          public ColumnInfo(uint typeOid, int bufferPos, NpgsqlTypeHandler typeHandler)
34          {
35              TypeOid = typeOid;
36              BufferPos = bufferPos;
37              TypeHandler = typeHandler;
38          }
39      }
40      NpgsqlReadBuffer Buffer =&gt; _outermostReader.Buffer;
41      TypeMapper TypeMapper =&gt; _outermostReader.Connector.TypeMapper;
42      internal NpgsqlNestedDataReader(NpgsqlDataReader outermostReader, NpgsqlNestedDataReader? outerNestedReader,
43          ulong uniqueOutermostReaderRowId, int depth, PostgresCompositeType? compositeType)
44      {
45          _outermostReader = outermostReader;
46          _outerNestedReader = outerNestedReader;
47          _uniqueOutermostReaderRowId = uniqueOutermostReaderRowId;
48          _depth = depth;
49          _compositeType = compositeType;
50      }
51      internal void Init(ulong uniqueOutermostReaderRowId, PostgresCompositeType? compositeType)
52      {
53          _uniqueOutermostReaderRowId = uniqueOutermostReaderRowId;
54          _columns.Clear();
55          _numRows = 0;
56          _nextRowIndex = 0;
57          _nextRowBufferPos = 0;
58          _readerState = ReaderState.BeforeFirstRow;
59          _compositeType = compositeType;
60      }
61      internal void InitArray()
62      {
63          var dimensions = Buffer.ReadInt32();
64          var containsNulls = Buffer.ReadInt32() == 1;
65          Buffer.ReadUInt32(); 
66          if (containsNulls)
67              throw new InvalidOperationException(&quot;Record array contains null record&quot;);
68          if (dimensions == 0)
69              return;
70          if (dimensions != 1)
71              throw new InvalidOperationException(&quot;Cannot read a multidimensional array with a nested DbDataReader&quot;);
72          _numRows = Buffer.ReadInt32();
73          Buffer.ReadInt32(); 
74          if (_numRows &gt; 0)
75              Buffer.ReadInt32(); 
76          _nextRowBufferPos = Buffer.ReadPosition;
77      }
78      internal void InitSingleRow()
79      {
80          _numRows = 1;
81          _nextRowBufferPos = Buffer.ReadPosition;
82      }
83      public override object this[int ordinal] =&gt; GetValue(ordinal);
84      public override object this[string name] =&gt; GetValue(GetOrdinal(name));
85      public override int Depth
86      {
87          get
88          {
89              CheckNotClosed();
90              return _depth;
91          }
92      }
93      public override int FieldCount
94      {
95          get
96          {
97              CheckNotClosed();
98              return _readerState == ReaderState.OnRow ? _columns.Count : 0;
99          }
100      }
101      public override bool HasRows
102      {
103          get
104          {
105              CheckNotClosed();
106              return _numRows &gt; 0;
107          }
108      }
109      public override bool IsClosed
110          =&gt; _readerState == ReaderState.Closed || _readerState == ReaderState.Disposed
111                                                || _outermostReader.IsClosed || _uniqueOutermostReaderRowId != _outermostReader.UniqueRowId;
112      public override int RecordsAffected =&gt; -1;
113      public override bool GetBoolean(int ordinal) =&gt; GetFieldValue&lt;bool&gt;(ordinal);
114      public override byte GetByte(int ordinal) =&gt; GetFieldValue&lt;byte&gt;(ordinal);
115      public override char GetChar(int ordinal) =&gt; GetFieldValue&lt;char&gt;(ordinal);
116      public override DateTime GetDateTime(int ordinal) =&gt; GetFieldValue&lt;DateTime&gt;(ordinal);
117      public override decimal GetDecimal(int ordinal) =&gt; GetFieldValue&lt;decimal&gt;(ordinal);
118      public override double GetDouble(int ordinal) =&gt; GetFieldValue&lt;double&gt;(ordinal);
119      public override float GetFloat(int ordinal) =&gt; GetFieldValue&lt;float&gt;(ordinal);
120      public override Guid GetGuid(int ordinal) =&gt; GetFieldValue&lt;Guid&gt;(ordinal);
121      public override short GetInt16(int ordinal) =&gt; GetFieldValue&lt;short&gt;(ordinal);
122      public override int GetInt32(int ordinal) =&gt; GetFieldValue&lt;int&gt;(ordinal);
123      public override long GetInt64(int ordinal) =&gt; GetFieldValue&lt;long&gt;(ordinal);
124      public override string GetString(int ordinal) =&gt; GetFieldValue&lt;string&gt;(ordinal);
125      public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
126      {
127          if (dataOffset is &lt; 0 or &gt; int.MaxValue)
128              throw new ArgumentOutOfRangeException(nameof(dataOffset), dataOffset, $&quot;dataOffset must be between 0 and {int.MaxValue}&quot;);
129          if (buffer != null &amp;&amp; (bufferOffset &lt; 0 || bufferOffset &gt;= buffer.Length + 1))
130              throw new IndexOutOfRangeException($&quot;bufferOffset must be between 0 and {buffer.Length}&quot;);
131          if (buffer != null &amp;&amp; (length &lt; 0 || length &gt; buffer.Length - bufferOffset))
132              throw new IndexOutOfRangeException($&quot;length must be between 0 and {buffer.Length - bufferOffset}&quot;);
133          var field = CheckRowAndColumnAndSeek(ordinal);
134          var handler = field.Handler;
135          if (!(handler is ByteaHandler))
136              throw new InvalidCastException(&quot;GetBytes() not supported for type &quot; + field.Handler.PgDisplayName);
137          if (field.Length == -1)
138              throw new InvalidCastException(&quot;field is null&quot;);
139          var dataOffset2 = (int)dataOffset;
140          if (dataOffset2 &gt;= field.Length)
141              ThrowHelper.ThrowArgumentOutOfRange_OutOfColumnBounds(nameof(dataOffset), field.Length);
142          Buffer.ReadPosition += dataOffset2;
143          length = Math.Min(length, field.Length - dataOffset2);
144          if (buffer == null)
145              return length;
146          return Buffer.Read(new Span&lt;byte&gt;(buffer, bufferOffset, length));
147      }
148      public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
149          =&gt; throw new NotSupportedException();
150      protected override DbDataReader GetDbDataReader(int ordinal) =&gt; GetData(ordinal);
151      public new NpgsqlNestedDataReader GetData(int ordinal)
152      {
153          var field = CheckRowAndColumnAndSeek(ordinal);
154          var type = field.Handler.PostgresType;
155          var isArray = type is PostgresArrayType;
156          var elementType = isArray ? ((PostgresArrayType)type).Element : type;
157          var compositeType = elementType as PostgresCompositeType;
158          if (elementType.InternalName != &quot;record&quot; &amp;&amp; compositeType == null)
159              throw new InvalidCastException(&quot;GetData() not supported for type &quot; + type.DisplayName);
160          if (field.Length == -1)
161              throw new InvalidCastException(&quot;field is null&quot;);
162          var reader = _cachedFreeNestedDataReader;
163          if (reader != null)
164          {
165              _cachedFreeNestedDataReader = null;
166              reader.Init(_uniqueOutermostReaderRowId, compositeType);
167          }
168          else
169          {
170              reader = new NpgsqlNestedDataReader(_outermostReader, this, _uniqueOutermostReaderRowId, _depth + 1, compositeType);
171          }
172          if (isArray)
173              reader.InitArray();
174          else
175              reader.InitSingleRow();
176          return reader;
177      }
178      public override string GetDataTypeName(int ordinal)
179      {
180          var column = CheckRowAndColumn(ordinal);
181          return column.TypeHandler.PgDisplayName;
182      }
183      public override IEnumerator GetEnumerator() =&gt; new DbEnumerator(this);
184      public override string GetName(int ordinal)
185      {
186          CheckRowAndColumn(ordinal);
187          return _compositeType?.Fields[ordinal].Name ?? &quot;?column?&quot;;
188      }
189      public override int GetOrdinal(string name)
190      {
191          if (_compositeType == null)
192              throw new NotSupportedException(&quot;GetOrdinal is not supported for the record type&quot;);
193          for (var i = 0; i &lt; _compositeType.Fields.Count; i++)
194          {
195              if (_compositeType.Fields[i].Name == name)
196                  return i;
197          }
198          for (var i = 0; i &lt; _compositeType.Fields.Count; i++)
199          {
200              if (string.Compare(_compositeType.Fields[i].Name, name, CultureInfo.InvariantCulture,
201                      CompareOptions.IgnoreWidth | CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType) == 0)
202                  return i;
203          }
204          throw new IndexOutOfRangeException(&quot;Field not found in row: &quot; + name);
205      }
206      public override Type GetFieldType(int ordinal)
207      {
208          var column = CheckRowAndColumn(ordinal);
209          return column.TypeHandler.GetFieldType();
210      }
211      public override object GetValue(int ordinal)
212      {
213          var column = CheckRowAndColumnAndSeek(ordinal);
214          if (column.Length == -1)
215              return DBNull.Value;
216          return column.Handler.ReadAsObject(Buffer, column.Length);
217      }
<span onclick='openModal()' class='match'>218      public override int GetValues(object[] values)
219      {
220          if (values == null)
221              throw new ArgumentNullException(nameof(values));
222          CheckOnRow();
223          var count = Math.Min(FieldCount, values.Length);
224          for (var i = 0; i &lt; count; i++)
225              values[i] = GetValue(i);
226          return count;
227      }
228      public override bool IsDBNull(int ordinal)
</span>229          =&gt; CheckRowAndColumnAndSeek(ordinal).Length == -1;
230      public override T GetFieldValue&lt;T&gt;(int ordinal)
231      {
232          if (typeof(T) == typeof(Stream))
233              return (T)(object)GetStream(ordinal);
234          if (typeof(T) == typeof(TextReader))
235              return (T)(object)GetTextReader(ordinal);
236          var field = CheckRowAndColumnAndSeek(ordinal);
237          if (field.Length == -1)
238          {
239              if (NullableHandler&lt;T&gt;.Exists)
240                  return default!;
241              if (typeof(T) == typeof(object))
242                  return (T)(object)DBNull.Value;
243              throw new InvalidCastException(&quot;field is null&quot;);
244          }
245          return NullableHandler&lt;T&gt;.Exists
246              ? NullableHandler&lt;T&gt;.Read(field.Handler, Buffer, field.Length, fieldDescription: null)
247              : typeof(T) == typeof(object)
248                  ? (T)field.Handler.ReadAsObject(Buffer, field.Length, fieldDescription: null)
249                  : field.Handler.Read&lt;T&gt;(Buffer, field.Length, fieldDescription: null);
250      }
251      public override bool Read()
252      {
253          CheckResultSet();
254          Buffer.ReadPosition = _nextRowBufferPos;
255          if (_nextRowIndex == _numRows)
256          {
257              _readerState = ReaderState.AfterRows;
258              return false;
259          }
260          if (_nextRowIndex++ != 0)
261              Buffer.ReadInt32(); 
262          var numColumns = Buffer.ReadInt32();
263          for (var i = 0; i &lt; numColumns; i++)
264          {
265              var typeOid = Buffer.ReadUInt32();
266              var bufferPos = Buffer.ReadPosition;
267              if (i &gt;= _columns.Count)
268                  _columns.Add(new ColumnInfo(typeOid, bufferPos, TypeMapper.ResolveByOID(typeOid)));
269              else
270                  _columns[i] = new ColumnInfo(typeOid, bufferPos,
271                      _columns[i].TypeOid == typeOid ? _columns[i].TypeHandler : TypeMapper.ResolveByOID(typeOid));
272              var columnLen = Buffer.ReadInt32();
273              if (columnLen &gt;= 0)
274                  Buffer.Skip(columnLen);
275          }
276          _columns.RemoveRange(numColumns, _columns.Count - numColumns);
277          _nextRowBufferPos = Buffer.ReadPosition;
278          _readerState = ReaderState.OnRow;
279          return true;
280      }
281      public override bool NextResult()
282      {
283          CheckNotClosed();
284          _numRows = 0;
285          _nextRowBufferPos = 0;
286          _nextRowIndex = 0;
287          _readerState = ReaderState.AfterResult;
288          return false;
289      }
290      public override void Close()
291      {
292          if (_readerState != ReaderState.Disposed)
293          {
294              _readerState = ReaderState.Closed;
295          }
296      }
297      protected override void Dispose(bool disposing)
298      {
299          if (disposing &amp;&amp; _readerState != ReaderState.Disposed)
300          {
301              Close();
302              _readerState = ReaderState.Disposed;
303              if (_outerNestedReader != null)
304              {
305                  _outerNestedReader._cachedFreeNestedDataReader ??= this;
306              }
307              else
308              {
309                  _outermostReader.CachedFreeNestedDataReader ??= this;
310              }
311          }
312      }
313      [MethodImpl(MethodImplOptions.AggressiveInlining)]
314      void CheckNotClosed()
315      {
316          if (IsClosed)
317              throw new InvalidOperationException(&quot;The reader is closed&quot;);
318      }
319      [MethodImpl(MethodImplOptions.AggressiveInlining)]
320      void CheckResultSet()
321      {
322          CheckNotClosed();
323          switch (_readerState)
324          {
325          case ReaderState.BeforeFirstRow:
326          case ReaderState.OnRow:
327          case ReaderState.AfterRows:
328              break;
329          default:
330              throw new InvalidOperationException(&quot;No resultset is currently being traversed&quot;);
331          }
332      }
333      [MethodImpl(MethodImplOptions.AggressiveInlining)]
334      void CheckOnRow()
335      {
336          CheckResultSet();
337          if (_readerState != ReaderState.OnRow)
338              throw new InvalidOperationException(&quot;No row is available&quot;);
339      }
340      ColumnInfo CheckRowAndColumn(int column)
341      {
342          CheckOnRow();
343          if (column &lt; 0 || column &gt;= _columns.Count)
344              throw new IndexOutOfRangeException($&quot;Column must be between {0} and {_columns.Count - 1}&quot;);
345          return _columns[column];
346      }
347      (NpgsqlTypeHandler Handler, int Length) CheckRowAndColumnAndSeek(int ordinal)
348      {
349          var column = CheckRowAndColumn(ordinal);
350          Buffer.ReadPosition = column.BufferPos;
351          var len = Buffer.ReadInt32();
352          return (column.TypeHandler, len);
353      }
354      enum ReaderState
355      {
356          BeforeFirstRow,
357          OnRow,
358          AfterRows,
359          AfterResult,
360          Closed,
361          Disposed
362      }
363  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlDataReader.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlNestedDataReader.cs</div>
                </div>
                <div class="column column_space"><pre><code>840      public override int GetValues(object[] values)
841      {
842          if (values == null)
843              throw new ArgumentNullException(nameof(values));
844          CheckResultSet();
845          var count = Math.Min(FieldCount, values.Length);
846          for (var i = 0; i &lt; count; i++)
847              values[i] = GetValue(i);
848          return count;
849      }
850      public override object this[int ordinal] =&gt; GetValue(ordinal);
</pre></code></div>
                <div class="column column_space"><pre><code>218      public override int GetValues(object[] values)
219      {
220          if (values == null)
221              throw new ArgumentNullException(nameof(values));
222          CheckOnRow();
223          var count = Math.Min(FieldCount, values.Length);
224          for (var i = 0; i &lt; count; i++)
225              values[i] = GetValue(i);
226          return count;
227      }
228      public override bool IsDBNull(int ordinal)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    