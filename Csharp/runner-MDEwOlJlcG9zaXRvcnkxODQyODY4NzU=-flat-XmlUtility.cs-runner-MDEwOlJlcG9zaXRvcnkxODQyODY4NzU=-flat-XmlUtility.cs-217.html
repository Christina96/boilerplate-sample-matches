
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-XmlUtility.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Diagnostics;
5  using System.Globalization;
6  using System.IO;
7  using System.Linq;
8  using System.Threading.Tasks;
9  using System.Xml;
10  using System.Xml.Linq;
11  namespace GitHub.Services.Common.Internal
12  {
13      [EditorBrowsable(EditorBrowsableState.Never)]
14      public static class XmlUtility
15      {
16          internal static FileStream OpenFile(String path, FileShare sharing, Boolean saveFile)
17          {
18              XmlDocument noXmlDocument;
19              return OpenFileHelper(path, sharing, saveFile, false, out noXmlDocument);
20          }
21          internal static XmlDocument OpenXmlFile(out FileStream file, String path, FileShare sharing, Boolean saveFile)
22          {
23              XmlDocument xmlDocument;
24              file = OpenFileHelper(path, sharing, saveFile, true, out xmlDocument);
25              return xmlDocument;
26          }
27          private static FileStream OpenFileHelper(String path, FileShare sharing, Boolean saveFile, Boolean loadAsXmlDocument, out XmlDocument xmlDocument)
28          {
29              const int RetryCount = 10;
30              FileStream file = null;
31              xmlDocument = null;
32              if (String.IsNullOrEmpty(path))
33              {
34                  return null;
35              }
36              if (!saveFile &amp;&amp; !File.Exists(path))
37              {
38                  return null;
39              }
40              int retries = 0;
41              Random random = null;
42              while (retries &lt;= RetryCount)
43              {
44                  try
45                  {
46                      FileAccess fileAccess = FileAccess.Read;
47                      FileMode fileMode = FileMode.Open;
48                      if (saveFile)
49                      {
50                          fileAccess = FileAccess.ReadWrite;
51                          fileMode = FileMode.OpenOrCreate;
52                      }
53                      file = new FileStream(path, fileMode, fileAccess, sharing);
54                      if (loadAsXmlDocument)
55                      {
56                          XmlReaderSettings settings = new XmlReaderSettings()
57                          {
58                              DtdProcessing = DtdProcessing.Prohibit,
59                              XmlResolver = null,
60                          };
61                          using (XmlReader xmlReader = XmlReader.Create(file, settings))
62                          {
63                              xmlDocument = new XmlDocument();
64                              xmlDocument.Load(xmlReader);
65                          }
66                      }
67                      return file;
68                  }
69                  catch (Exception exception)
70                  {
71                      if (file != null)
72                      {
73                          file.Dispose();
74                          file = null;
75                      }
76                      if (exception is OperationCanceledException)
77                      {
78                          throw;
79                      }
80                      else if (exception is IOException || exception is UnauthorizedAccessException || exception is XmlException)
81                      {
82                          if (saveFile)
83                          {
84                              try
85                              {
86                                  if (exception is DirectoryNotFoundException)
87                                  {
88                                      String dir = Path.GetDirectoryName(path);
89                                      Directory.CreateDirectory(dir);
90                                  }
91                                  if (exception is UnauthorizedAccessException)
92                                  {
93                                      File.SetAttributes(path, FileAttributes.Normal);
94                                  }
95                                  xmlDocument = null;
96                                  return new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None);
97                              }
98                              catch (Exception newException) when (newException is IOException || newException is UnauthorizedAccessException)
99                              {
100                                  if (retries &gt;= RetryCount)
101                                  {
102                                      throw new AggregateException(exception, newException);
103                                  }
104                              }
105                          }
106                          else
107                          {
108                              return null;
109                          }
110                      }
111                      else if (retries &gt;= RetryCount)
112                      {
113                          throw new VssServiceException(CommonResources.ErrorReadingFile(Path.GetFileName(path), exception.Message), exception);
114                      }
115                  }
116                  if (random == null)
117                  {
118                      random = new Random();
119                  }
120                  int sleepTime = random.Next(1, 150);
121                  Task.Delay(sleepTime).Wait();
122                  retries++;
123              }
124              Debug.Fail(&quot;Code should be unreachable.&quot;);
125              return null;
126          }
127          internal static void AddXmlAttribute(XmlNode node, String attrName, String value)
128          {
129              if (value != null)
130              {
131                  XmlAttribute attr = node.OwnerDocument.CreateAttribute(null, attrName, null);
132                  node.Attributes.Append(attr);
133                  attr.InnerText = value;
134              }
135          }
136          public static XmlReaderSettings SecureReaderSettings
137          {
138              get
139              {
140                  if (s_safeSettings == null)
141                  {
142                      XmlReaderSettings settings = new XmlReaderSettings()
143                      {
144                          DtdProcessing = DtdProcessing.Prohibit,
145                          XmlResolver = null,
146                      };
147                      s_safeSettings = settings;
148                  }
149                  return s_safeSettings;
150              }
151          }
152          public static XmlDocument GetDocument(Stream input)
153          {
154              XmlDocument doc = new XmlDocument();
155              using (XmlReader xmlReader = XmlReader.Create(input, SecureReaderSettings))
156              {
157                  doc.Load(xmlReader);
158              }
159              return doc;
160          }
161          public static XmlDocument GetDocument(string xml)
162          {
163              XmlDocument doc = new XmlDocument();
164              using (StringReader stringReader = new StringReader(xml))
165              using (XmlReader xmlReader = XmlReader.Create(stringReader, SecureReaderSettings))
166              {
167                  doc.Load(xmlReader);
168              }
169              return doc;
170          }
171          public static XmlDocument GetDocumentFromPath(string path)
172          {
173              XmlDocument doc = new XmlDocument();
174              using (XmlReader xmlReader = XmlReader.Create(path, SecureReaderSettings))
175              {
176                  doc.Load(xmlReader);
177              }
178              return doc;
179          }
180          public static DateTime ToDateTime(String s)
181          {
182              DateTime time = XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
183              if (time.Kind == DateTimeKind.Unspecified &amp;&amp;
184                  time != DateTime.MinValue &amp;&amp;
185                  time != DateTime.MaxValue)
186              {
187                  time = DateTime.SpecifyKind(time, DateTimeKind.Utc);
188              }
189              if (time.Year == 1)
190              {
191                  time = DateTime.MinValue;
192              }
193              else
194              {
195                  time = time.ToLocalTime();
196              }
197              return time;
198          }
199          public static DateTime ToDateOnly(String s)
200          {
201              return XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
202          }
203          public static String ToStringDateOnly(DateTime d)
204          {
205              return d.ToString(&quot;yyyy-MM-dd&quot;, CultureInfo.InvariantCulture);
206          }
207          public static String ToString(DateTime d)
208          {
209              Debug.Assert(d == DateTime.MinValue || d == DateTime.MaxValue || d.Kind != DateTimeKind.Unspecified, &quot;DateTime kind is unspecified instead of Local or Utc.&quot;);
210              return XmlConvert.ToString(d, XmlDateTimeSerializationMode.RoundtripKind);
211          }
212          public static void ObjectToXmlElement(XmlWriter writer, String element, Object o)
213          {
214              if (o == null)
215              {
216                  writer.WriteStartElement(element);
217                  writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
218                  writer.WriteEndElement();
219              }
220              else
221              {
222                  String clrTypeName = o.GetType().FullName;
223                  String soapType = null, soapValue = null, soapNamespaceUri = null;
224                  switch (clrTypeName)
225                  {
226                      case &quot;System.Boolean&quot;:
227                          soapType = &quot;boolean&quot;;
228                          soapValue = XmlConvert.ToString((Boolean)o);
229                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
230                          break;
231                      case &quot;System.Byte&quot;:
232                          soapType = &quot;unsignedByte&quot;;
233                          soapValue = XmlConvert.ToString((Byte)o);
234                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
235                          break;
236                      case &quot;System.Byte[]&quot;:
237                          soapType = &quot;base64Binary&quot;;
238                          byte[] array = (byte[])o;
239                          soapValue = Convert.ToBase64String(array, 0, array.Length);
240                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
241                          break;
242                      case &quot;System.Char&quot;:
243                          soapType = &quot;char&quot;;
244                          soapValue = XmlConvert.ToString((UInt16)((Char)o));
245                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;microsoft.com/wsdl/types/&quot;;
246                          break;
247                      case &quot;System.DateTime&quot;:
248                          soapType = &quot;dateTime&quot;;
249                          soapValue = ToString((DateTime)o);
250                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
251                          break;
252                      case &quot;System.Decimal&quot;:
253                          soapType = &quot;decimal&quot;;
254                          soapValue = XmlConvert.ToString((Decimal)o);
255                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
256                          break;
257                      case &quot;System.Double&quot;:
258                          soapType = &quot;double&quot;;
259                          soapValue = XmlConvert.ToString((Double)o);
260                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
261                          break;
262                      case &quot;System.Guid&quot;:
263                          soapType = &quot;guid&quot;;
264                          soapValue = XmlConvert.ToString((Guid)o);
265                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;microsoft.com/wsdl/types/&quot;;
266                          break;
267                      case &quot;System.Int16&quot;:
268                          soapType = &quot;short&quot;;
269                          soapValue = XmlConvert.ToString((Int16)o);
270                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
271                          break;
272                      case &quot;System.Int32&quot;:
273                          soapType = &quot;int&quot;;
274                          soapValue = XmlConvert.ToString((Int32)o);
275                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
276                          break;
277                      case &quot;System.Int64&quot;:
278                          soapType = &quot;long&quot;;
279                          soapValue = XmlConvert.ToString((Int64)o);
280                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
281                          break;
282                      case &quot;System.Single&quot;:
283                          soapType = &quot;float&quot;;
284                          soapValue = XmlConvert.ToString((Single)o);
285                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
286                          break;
287                      case &quot;System.String&quot;:
288                          soapType = &quot;string&quot;;
289                          soapValue = (String)o;
290                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
291                          break;
292                      default:
293                          if (o.GetType().IsArray)
294                          {
295                              Debug.Assert(o.GetType().GetArrayRank() == 1, &quot;ERROR: Cannot serialize multi-dimensional arrays&quot;);
296                              writer.WriteStartElement(element);
297                              writer.WriteAttributeString(&quot;type&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;ArrayOfAnyType&quot;);
298                              ArrayOfObjectToXml&lt;Object&gt;(writer, (Object[])o, null, &quot;anyType&quot;, true, false, ObjectToXmlElement);
299                              writer.WriteEndElement();
300                              return;
301                          }
302                          else
303                          {
304                              Debug.Fail(&quot;Unknown object type for serialization &quot; + clrTypeName);
305                              throw new ArgumentException(CommonResources.UnknownTypeForSerialization(clrTypeName));
306                          }
307                  }
308                  writer.WriteStartElement(element);
309                  writer.WriteStartAttribute(&quot;type&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;);
310                  writer.WriteQualifiedName(soapType, soapNamespaceUri);
311                  writer.WriteEndAttribute();
312                  writer.WriteValue(soapValue);
313                  writer.WriteEndElement();
314              }
315          }
316          public static Object ObjectFromXmlElement(XmlReader reader)
317          {
318              String soapTypeName = reader.GetAttribute(&quot;type&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;);
319              if (!String.IsNullOrEmpty(soapTypeName))
320              {
321                  String[] components = soapTypeName.Split(new char[] { &#x27;:&#x27; }, StringSplitOptions.None);
322                  if (components.Length == 2)
323                  {
324                      soapTypeName = components[1];
325  #if DEBUG
326                      String ns = reader.LookupNamespace(components[0]);
327                      if (!String.IsNullOrEmpty(ns) &amp;&amp;
328                          !ns.Equals(&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp;
329                          !ns.Equals(&quot;http:&amp;bsol;&amp;bsol;microsoft.com/wsdl/types/&quot;, StringComparison.OrdinalIgnoreCase))
330                      {
331                          Debug.Fail(&quot;Unknown namespace encountered for object type &quot; + ns);
332                          reader.ReadOuterXml();
333                          return null;
334                      }
335  #endif
336                  }
337                  switch (soapTypeName)
338                  {
339                      case &quot;base64Binary&quot;:
340                          String str = StringFromXmlElement(reader);
341                          if (str != null)
342                          {
343                              return Convert.FromBase64String(str);
344                          }
345                          return ZeroLengthArrayOfByte;
346                      case &quot;boolean&quot;:
347                          return XmlConvert.ToBoolean(StringFromXmlElement(reader));
348                      case &quot;char&quot;:
349                          return (Char)XmlConvert.ToInt16(StringFromXmlElement(reader));  
350                      case &quot;dateTime&quot;:
351                          return ToDateTime(StringFromXmlElement(reader));
352                      case &quot;decimal&quot;:
353                          return XmlConvert.ToDecimal(StringFromXmlElement(reader));
354                      case &quot;double&quot;:
355                          return XmlConvert.ToDouble(StringFromXmlElement(reader));
356                      case &quot;float&quot;:
<span onclick='openModal()' class='match'>357                          return XmlConvert.ToSingle(StringFromXmlElement(reader));
358                      case &quot;int&quot;:
359                          return XmlConvert.ToInt32(StringFromXmlElement(reader));
</span>360                      case &quot;guid&quot;:
361                          return XmlConvert.ToGuid(StringFromXmlElement(reader));
362                      case &quot;long&quot;:
363                          return XmlConvert.ToInt64(StringFromXmlElement(reader));
364                      case &quot;short&quot;:
365                          return XmlConvert.ToInt16(StringFromXmlElement(reader));
366                      case &quot;string&quot;:
367                          return StringFromXmlElement(reader);
368                      case &quot;unsignedByte&quot;:
369                          return XmlConvert.ToByte(StringFromXmlElement(reader));
370                      case &quot;ArrayOfAnyType&quot;:
371                          return ArrayOfObjectFromXml(reader);
372                      default:
373                          Debug.Fail(&quot;Unknown object type encountered &quot; + soapTypeName);
374                          throw new ArgumentException(CommonResources.UnknownTypeForSerialization(soapTypeName));
375                  }
376              }
377              else if (reader.GetAttribute(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;) == &quot;true&quot;)
378              {
379                  reader.ReadInnerXml();
380                  return null;
381              }
382              return null;
383          }
384          public static void ToXml(XmlWriter writer, String element, Object[] array)
385          {
386              if (array == null || array.Length == 0)
387              {
388                  return;
389              }
390              if (!String.IsNullOrEmpty(element))
391              {
392                  writer.WriteStartElement(element);
393              }
394              for (int i = 0; i &lt; array.Length; i++)
395              {
396                  if (array[i] == null)
397                  {
398                      throw new ArgumentNullException(&quot;array[&quot; + i + &quot;]&quot;);
399                  }
400                  ObjectToXmlElement(writer, &quot;anyType&quot;, array[i]);
401              }
402              if (!String.IsNullOrEmpty(element))
403              {
404                  writer.WriteEndElement();
405              }
406          }
407          public static Object[] ArrayOfObjectFromXml(XmlReader reader)
408          {
409              List&lt;Object&gt; list = new List&lt;Object&gt;();
410              bool empty = reader.IsEmptyElement;
411              Debug.Assert(reader.NodeType == XmlNodeType.Element, &quot;Expected a node.&quot;);
412              reader.Read();
413              if (!empty)
414              {
415                  while (reader.NodeType == XmlNodeType.Element)
416                  {
417                      if (reader.HasAttributes &amp;&amp;
418                          reader.GetAttribute(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;) == &quot;true&quot;)
419                      {
420                          list.Add(null);
421                          reader.Read();
422                      }
423                      else
424                      {
425                          list.Add(ObjectFromXmlElement(reader));
426                      }
427                  }
428                  reader.ReadEndElement();
429              }
430              return list.ToArray();
431          }
432          public static void ToXmlElement(XmlWriter writer, String elementName, XmlNode node)
433          {
434              if (node == null)
435              {
436                  return;
437              }
438              writer.WriteStartElement(elementName);
439              node.WriteTo(writer);
440              writer.WriteEndElement();
441          }
442          public static XmlNode XmlNodeFromXmlElement(XmlReader reader)
443          {
444              reader.Read();
445              XmlDocument document = new XmlDocument
446              {
447                  PreserveWhitespace = false
448              };
449              document.Load(reader);
450              document.Normalize();
451              reader.ReadEndElement();
452              return document.DocumentElement;
453          }
454          public static DateTime DateFromXmlAttribute(XmlReader reader)
455          {
456              return ToDateOnly(StringFromXmlAttribute(reader));
457          }
458          public static DateTime DateFromXmlElement(XmlReader reader)
459          {
460              return ToDateOnly(StringFromXmlElement(reader));
461          }
462          public static void DateToXmlAttribute(XmlWriter writer, String name, DateTime value)
463          {
464              StringToXmlAttribute(writer, name, ToStringDateOnly(value));
465          }
466          public static void DateToXmlElement(XmlWriter writer, String name, DateTime value)
467          {
468              StringToXmlElement(writer, name, ToStringDateOnly(value));
469          }
470          public static Boolean BooleanFromXmlAttribute(XmlReader reader)
471          {
472              return XmlConvert.ToBoolean(StringFromXmlAttribute(reader));
473          }
474          public static DateTime DateTimeFromXmlAttribute(XmlReader reader)
475          {
476              return ToDateTime(StringFromXmlAttribute(reader));
477          }
478          public static DateTime DateTimeFromXmlElement(XmlReader reader)
479          {
480              return ToDateTime(StringFromXmlElement(reader));
481          }
482          public static void ToXmlAttribute(XmlWriter writer, String name, DateTime value)
483          {
484              StringToXmlAttribute(writer, name, ToString(value));
485          }
486          public static void ToXmlElement(XmlWriter writer, String name, DateTime value)
487          {
488              StringToXmlElement(writer, name, ToString(value));
489          }
490          public static void ToXml(XmlWriter writer, String element, byte[] array)
491          {
492              if (array == null || array.Length == 0)
493              {
494                  return;
495              }
496              writer.WriteElementString(element, Convert.ToBase64String(array, 0, array.Length));
497          }
498          public static void ToXmlAttribute(XmlWriter writer, String attr, byte[] array)
499          {
500              if (array == null || array.Length == 0)
501              {
502                  return;
503              }
504              writer.WriteAttributeString(attr, Convert.ToBase64String(array, 0, array.Length));
505          }
506          private static XmlReaderSettings s_safeSettings;
507          public static String ToString(Uri uri)
508          {
509              return uri.AbsoluteUri;
510          }
511          public static Uri ToUri(String s)
512          {
513              if (String.IsNullOrEmpty(s))
514              {
515                  return null;
516              }
517              else
518              {
519                  return new Uri(s);
520              }
521          }
522          public static T EnumFromXmlText&lt;T&gt;(XmlReader reader)
523          {
524              String s = StringFromXmlText(reader);
525              s = s.Replace(&#x27; &#x27;, &#x27;,&#x27;);
526              return (T)Enum.Parse(typeof(T), s, true);
527          }
528          public static void EnumToXmlText&lt;T&gt;(XmlWriter writer, String ignored, T value)
529          {
530              String s = Enum.Format(typeof(T), value, &quot;G&quot;);
531              s = s.Replace(&quot;,&quot;, &quot;&quot;);
532              writer.WriteString(s);
533          }
534          public static void EnumToXmlAttribute&lt;T&gt;(XmlWriter writer, String attr, T value)
535          {
536              String s = Enum.Format(typeof(T), value, &quot;G&quot;);
537              s = s.Replace(&quot;,&quot;, &quot;&quot;);
538              writer.WriteAttributeString(attr, s);
539          }
540          public static T EnumFromXmlAttribute&lt;T&gt;(XmlReader reader)
541          {
542              String s = StringFromXmlAttribute(reader);
543              s = s.Replace(&#x27; &#x27;, &#x27;,&#x27;);
544              return (T)Enum.Parse(typeof(T), s, true);
545          }
546          public static void EnumToXmlElement&lt;T&gt;(XmlWriter writer, String element, T value)
547          {
548              String s = Enum.Format(typeof(T), value, &quot;G&quot;);
549              s = s.Replace(&quot;,&quot;, &quot;&quot;);
550              writer.WriteElementString(element, s);
551          }
552          public static T EnumFromXmlElement&lt;T&gt;(XmlReader reader)
553          {
554              String s = StringFromXmlElement(reader);
555              s = s.Replace(&#x27; &#x27;, &#x27;,&#x27;);
556              return (T)Enum.Parse(typeof(T), s, true);
557          }
558          public static T[] ArrayOfObjectFromXml&lt;T&gt;(
559              XmlReader reader,
560              String arrayElementName,
561              Boolean inline,
562              Func&lt;XmlReader, T&gt; objectFromXmlElement)
563          {
564              return ArrayOfObjectFromXml&lt;T&gt;(null, reader, arrayElementName, inline, (x, y) =&gt; objectFromXmlElement(y));
565          }
566          public static T[] ArrayOfObjectFromXml&lt;T&gt;(
567              IServiceProvider serviceProvider,
568              XmlReader reader,
569              String arrayElementName,
570              Boolean inline,
571              Func&lt;IServiceProvider, XmlReader, T&gt; objectFromXmlElement)
572          {
573              List&lt;T&gt; list = new List&lt;T&gt;();
574              bool empty = reader.IsEmptyElement;
575              Debug.Assert(reader.NodeType == XmlNodeType.Element, &quot;Expected a node.&quot;);
576              if (!inline)
577              {
578                  reader.Read();
579              }
580              if (!empty)
581              {
582                  while (reader.NodeType == XmlNodeType.Element &amp;&amp; (!inline || reader.Name == arrayElementName))
583                  {
584                      if (reader.HasAttributes &amp;&amp; reader.GetAttribute(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;) == &quot;true&quot;)
585                      {
586                          list.Add(default(T));
587                          reader.Read();
588                      }
589                      else
590                      {
591                          list.Add(objectFromXmlElement(serviceProvider, reader));
592                      }
593                  }
594                  reader.ReadEndElement();
595              }
596              return list.ToArray();
597          }
598          public static void ArrayOfObjectToXml&lt;T&gt;(
599              XmlWriter writer,
600              T[] array,
601              String arrayName,
602              String arrayElementName,
603              Boolean inline,
604              Boolean allowEmptyArrays,
605              Action&lt;XmlWriter, String, T&gt; objectToXmlElement)
606          {
607              if (array == null)
608              {
609                  return;
610              }
611              if (array.Length == 0)
612              {
613                  if (allowEmptyArrays &amp;&amp; !String.IsNullOrEmpty(arrayName))
614                  {
615                      writer.WriteStartElement(arrayName);
616                      writer.WriteEndElement();
617                  }
618                  return;
619              }
620              if (!inline)
621              {
622                  writer.WriteStartElement(arrayName);
623                  for (Int32 i = 0; i &lt; array.Length; i = i + 1)
624                  {
625                      if (array[i] == null)
626                      {
627                          writer.WriteStartElement(arrayElementName);
628                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
629                          writer.WriteEndElement();
630                      }
631                      else
632                      {
633                          objectToXmlElement(writer, arrayElementName, array[i]);
634                      }
635                  }
636                  writer.WriteEndElement();
637              }
638              else
639              {
640                  for (Int32 i = 0; i &lt; array.Length; i = i + 1)
641                  {
642                      if (array[i] == null)
643                      {
644                          writer.WriteStartElement(arrayElementName);
645                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
646                          writer.WriteEndElement();
647                      }
648                      else
649                      {
650                          objectToXmlElement(writer, arrayElementName, array[i]);
651                      }
652                  }
653              }
654          }
655          public static void EnumerableOfObjectToXml&lt;T&gt;(
656              XmlWriter writer,
657              IEnumerable&lt;T&gt; enumerable,
658              String arrayName,
659              String arrayElementName,
660              Boolean inline,
661              Boolean allowEmptyArrays,
662              Action&lt;XmlWriter, String, T&gt; objectToXmlElement)
663          {
664              if (enumerable == null)
665              {
666                  return;
667              }
668              if (!enumerable.Any())
669              {
670                  if (allowEmptyArrays &amp;&amp; !String.IsNullOrEmpty(arrayName))
671                  {
672                      writer.WriteStartElement(arrayName);
673                      writer.WriteEndElement();
674                  }
675                  return;
676              }
677              if (!inline)
678              {
679                  writer.WriteStartElement(arrayName);
680                  foreach (T item in enumerable)
681                  {
682                      if (item == null)
683                      {
684                          writer.WriteStartElement(arrayElementName);
685                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
686                          writer.WriteEndElement();
687                      }
688                      else
689                      {
690                          objectToXmlElement(writer, arrayElementName, item);
691                      }
692                  }
693                  writer.WriteEndElement();
694              }
695              else
696              {
697                  foreach (T item in enumerable)
698                  {
699                      if (item == null)
700                      {
701                          writer.WriteStartElement(arrayElementName);
702                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
703                          writer.WriteEndElement();
704                      }
705                      else
706                      {
707                          objectToXmlElement(writer, arrayElementName, item);
708                      }
709                  }
710              }
711          }
712          public static Boolean BooleanFromXmlElement(XmlReader reader)
713          {
714              return XmlConvert.ToBoolean(StringFromXmlElement(reader));
715          }
716          public static Byte ByteFromXmlAttribute(XmlReader reader)
717          {
718              return XmlConvert.ToByte(StringFromXmlAttribute(reader));
719          }
720          public static Byte ByteFromXmlElement(XmlReader reader)
721          {
722              return XmlConvert.ToByte(StringFromXmlElement(reader));
723          }
724          public static Char CharFromXmlAttribute(XmlReader reader)
725          {
726              return (Char)XmlConvert.ToInt32(StringFromXmlAttribute(reader));
727          }
728          public static Char CharFromXmlElement(XmlReader reader)
729          {
730              return (Char)XmlConvert.ToInt32(StringFromXmlElement(reader));
731          }
732          public static Double DoubleFromXmlAttribute(XmlReader reader)
733          {
734              return XmlConvert.ToDouble(StringFromXmlAttribute(reader));
735          }
736          public static Double DoubleFromXmlElement(XmlReader reader)
737          {
738              return XmlConvert.ToDouble(StringFromXmlElement(reader));
739          }
740          public static Guid GuidFromXmlAttribute(XmlReader reader)
741          {
742              return XmlConvert.ToGuid(StringFromXmlAttribute(reader));
743          }
744          public static Guid GuidFromXmlElement(XmlReader reader)
745          {
746              return XmlConvert.ToGuid(StringFromXmlElement(reader));
747          }
748          public static Int16 Int16FromXmlAttribute(XmlReader reader)
749          {
750              return XmlConvert.ToInt16(StringFromXmlAttribute(reader));
751          }
752          public static Int16 Int16FromXmlElement(XmlReader reader)
753          {
754              return XmlConvert.ToInt16(StringFromXmlElement(reader));
755          }
756          public static Int32 Int32FromXmlAttribute(XmlReader reader)
757          {
758              return XmlConvert.ToInt32(StringFromXmlAttribute(reader));
759          }
760          public static Int32 Int32FromXmlElement(XmlReader reader)
761          {
762              return XmlConvert.ToInt32(StringFromXmlElement(reader));
763          }
764          public static Int64 Int64FromXmlAttribute(XmlReader reader)
765          {
766              return XmlConvert.ToInt64(StringFromXmlAttribute(reader));
767          }
768          public static Int64 Int64FromXmlElement(XmlReader reader)
769          {
770              return XmlConvert.ToInt64(StringFromXmlElement(reader));
771          }
772          public static Single SingleFromXmlAttribute(XmlReader reader)
773          {
774              return XmlConvert.ToSingle(StringFromXmlAttribute(reader));
775          }
776          public static Single SingleFromXmlElement(XmlReader reader)
777          {
778              return XmlConvert.ToSingle(StringFromXmlElement(reader));
779          }
780          public static String StringFromXmlAttribute(XmlReader reader)
781          {
782              return GetCachedString(reader.Value);
783          }
784          public static String StringFromXmlElement(XmlReader reader)
785          {
786              String str = String.Empty;
787              Boolean isEmpty = reader.IsEmptyElement;
788              Debug.Assert(reader.NodeType == XmlNodeType.Element, &quot;Expected a node.&quot;);
789              reader.Read();
790              if (!isEmpty)
791              {
792                  if (reader.NodeType == XmlNodeType.CDATA ||
793                      reader.NodeType == XmlNodeType.Text ||
794                      reader.NodeType == XmlNodeType.Whitespace)
795                  {
796                      str = GetCachedString(reader.ReadContentAsString().Replace(&quot;\n&quot;, &quot;\r\n&quot;));
797                      reader.ReadEndElement();
798                  }
799                  else if (reader.NodeType == XmlNodeType.EndElement)
800                  {
801                      reader.ReadEndElement();
802                  }
803              }
804              return str;
805          }
806          public static String StringFromXmlText(XmlReader reader)
807          {
808              String str = String.Empty;
809              if (reader.NodeType == XmlNodeType.CDATA ||
810                  reader.NodeType == XmlNodeType.Text ||
811                  reader.NodeType == XmlNodeType.Whitespace)
812              {
813                  str = GetCachedString(reader.ReadContentAsString().Replace(&quot;\n&quot;, &quot;\r\n&quot;));
814              }
815              return str;
816          }
817          public static TimeSpan TimeSpanFromXmlAttribute(XmlReader reader)
818          {
819              return XmlConvert.ToTimeSpan(StringFromXmlAttribute(reader));
820          }
821          public static TimeSpan TimeSpanFromXmlElement(XmlReader reader)
822          {
823              return XmlConvert.ToTimeSpan(StringFromXmlElement(reader));
824          }
825          public static UInt16 UInt16FromXmlAttribute(XmlReader reader)
826          {
827              return XmlConvert.ToUInt16(StringFromXmlAttribute(reader));
828          }
829          public static UInt16 UInt16FromXmlElement(XmlReader reader)
830          {
831              return XmlConvert.ToUInt16(StringFromXmlElement(reader));
832          }
833          public static UInt32 UInt32FromXmlAttribute(XmlReader reader)
834          {
835              return XmlConvert.ToUInt32(StringFromXmlAttribute(reader));
836          }
837          public static UInt32 UInt32FromXmlElement(XmlReader reader)
838          {
839              return XmlConvert.ToUInt32(StringFromXmlElement(reader));
840          }
841          public static UInt64 UInt64FromXmlAttribute(XmlReader reader)
842          {
843              return XmlConvert.ToUInt64(StringFromXmlAttribute(reader));
844          }
845          public static UInt64 UInt64FromXmlElement(XmlReader reader)
846          {
847              return XmlConvert.ToUInt64(StringFromXmlElement(reader));
848          }
849          public static Uri UriFromXmlAttribute(XmlReader reader)
850          {
851              return ToUri(StringFromXmlAttribute(reader));
852          }
853          public static Uri UriFromXmlElement(XmlReader reader)
854          {
855              return ToUri(StringFromXmlElement(reader));
856          }
857          public static void ToXmlAttribute(XmlWriter writer, String name, Boolean value)
858          {
859              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
860          }
861          public static void ToXmlAttribute(XmlWriter writer, String name, Byte value)
862          {
863              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
864          }
865          public static void ToXmlAttribute(XmlWriter writer, String name, Char value)
866          {
867              StringToXmlAttribute(writer, name, XmlConvert.ToString((Int32)value));
868          }
869          public static void ToXmlAttribute(XmlWriter writer, String name, Double value)
870          {
871              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
872          }
873          public static void ToXmlAttribute(XmlWriter writer, String name, Guid value)
874          {
875              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
876          }
877          public static void ToXmlAttribute(XmlWriter writer, String name, Int16 value)
878          {
879              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
880          }
881          public static void ToXmlAttribute(XmlWriter writer, String name, Int32 value)
882          {
883              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
884          }
885          public static void ToXmlAttribute(XmlWriter writer, String name, Int64 value)
886          {
887              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
888          }
889          public static void ToXmlAttribute(XmlWriter writer, String name, Single value)
890          {
891              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
892          }
893          public static void ToXmlAttribute(XmlWriter writer, String name, String value)
894          {
895              StringToXmlAttribute(writer, name, value);
896          }
897          public static void ToXmlAttribute(XmlWriter writer, String name, TimeSpan value)
898          {
899              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
900          }
901          public static void ToXmlAttribute(XmlWriter writer, String name, UInt16 value)
902          {
903              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
904          }
905          public static void ToXmlAttribute(XmlWriter writer, String name, UInt32 value)
906          {
907              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
908          }
909          public static void ToXmlAttribute(XmlWriter writer, String name, UInt64 value)
910          {
911              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
912          }
913          public static void ToXmlAttribute(XmlWriter writer, String name, Uri value)
914          {
915              StringToXmlAttribute(writer, name, ToString(value));
916          }
917          public static void ToXmlElement(XmlWriter writer, String name, Boolean value)
918          {
919              StringToXmlElement(writer, name, XmlConvert.ToString(value));
920          }
921          public static void ToXmlElement(XmlWriter writer, String name, Byte value)
922          {
923              StringToXmlElement(writer, name, XmlConvert.ToString(value));
924          }
925          public static void ToXmlElement(XmlWriter writer, String name, Char value)
926          {
927              StringToXmlElement(writer, name, XmlConvert.ToString((Int32)value));
928          }
929          public static void ToXmlElement(XmlWriter writer, String name, Double value)
930          {
931              StringToXmlElement(writer, name, XmlConvert.ToString(value));
932          }
933          public static void ToXmlElement(XmlWriter writer, String name, Guid value)
934          {
935              StringToXmlElement(writer, name, XmlConvert.ToString(value));
936          }
937          public static void ToXmlElement(XmlWriter writer, String element, Int16 value)
938          {
939              StringToXmlElement(writer, element, XmlConvert.ToString(value));
940          }
941          public static void ToXmlElement(XmlWriter writer, String element, Int32 value)
942          {
943              StringToXmlElement(writer, element, XmlConvert.ToString(value));
944          }
945          public static void ToXmlElement(XmlWriter writer, String element, Int64 value)
946          {
947              StringToXmlElement(writer, element, XmlConvert.ToString(value));
948          }
949          public static void ToXmlElement(XmlWriter writer, String name, Single value)
950          {
951              StringToXmlElement(writer, name, XmlConvert.ToString(value));
952          }
953          public static void ToXmlElement(XmlWriter writer, String name, String value)
954          {
955              StringToXmlElement(writer, name, value);
956          }
957          public static void ToXmlElement(XmlWriter writer, String name, TimeSpan value)
958          {
959              StringToXmlElement(writer, name, XmlConvert.ToString(value));
960          }
961          public static void ToXmlElement(XmlWriter writer, String element, UInt16 value)
962          {
963              StringToXmlElement(writer, element, XmlConvert.ToString(value));
964          }
965          public static void ToXmlElement(XmlWriter writer, String element, UInt32 value)
966          {
967              StringToXmlElement(writer, element, XmlConvert.ToString(value));
968          }
969          public static void ToXmlElement(XmlWriter writer, String element, UInt64 value)
970          {
971              StringToXmlElement(writer, element, XmlConvert.ToString(value));
972          }
973          public static void ToXmlElement(XmlWriter writer, String name, Uri value)
974          {
975              StringToXmlElement(writer, name, ToString(value));
976          }
977          public static void StringToXmlAttribute(XmlWriter writer, String name, String value)
978          {
979              writer.WriteAttributeString(name, value);
980          }
981          public static void StringToXmlElement(XmlWriter writer, String name, String value)
982          {
983              try
984              {
985                  writer.WriteElementString(name, value);
986              }
987              catch (ArgumentException e)
988              {
989                  Debug.Assert(e.Message.IndexOf(&quot;invalid character&quot;, StringComparison.OrdinalIgnoreCase) &gt; 0, &quot;Unexpected exception: &quot; + e.ToString());
990                  throw new VssServiceException(CommonResources.StringContainsIllegalChars(), e);
991              }
992          }
993          public static void StringToXmlText(XmlWriter writer, String str)
994          {
995              if (str == null)
996              {
997                  return;
998              }
999              try
1000              {
1001                  writer.WriteString(str);
1002              }
1003              catch (ArgumentException e)
1004              {
1005                  Debug.Assert(e.Message.IndexOf(&quot;invalid character&quot;, StringComparison.OrdinalIgnoreCase) &gt; 0, &quot;Unexpected exception: &quot; + e.ToString());
1006                  throw new VssServiceException(CommonResources.StringContainsIllegalChars(), e);
1007              }
1008          }
1009          public static byte[] ArrayOfByteFromXml(XmlReader reader)
1010          {
1011              String str = StringFromXmlElement(reader);
1012              if (str != null)
1013              {
1014                  return Convert.FromBase64String(str);
1015              }
1016              return ZeroLengthArrayOfByte;
1017          }
1018          public static byte[] ArrayOfByteFromXmlAttribute(XmlReader reader)
1019          {
1020              if (reader.Value.Length != 0)
1021              {
1022                  return Convert.FromBase64String(reader.Value);
1023              }
1024              return ZeroLengthArrayOfByte;
1025          }
1026          public static byte[] ZeroLengthArrayOfByte
1027          {
1028              get
1029              {
1030                  if (s_zeroLengthArrayOfByte == null)
1031                  {
1032                      s_zeroLengthArrayOfByte = new byte[0];
1033                  }
1034                  return s_zeroLengthArrayOfByte;
1035              }
1036          }
1037          public static bool CompareXmlDocuments(string xml1, string xml2)
1038          {
1039              if (xml1 == xml2)
1040              {
1041                  return true;
1042              }
1043              else if (string.IsNullOrEmpty(xml1) || string.IsNullOrEmpty(xml2))
1044              {
1045                  return false;
1046              }
1047              XDocument x1 = XDocument.Parse(xml1);
1048              XDocument x2 = XDocument.Parse(xml2);
1049              return Compare(x1?.Root, x2?.Root);
1050          }
1051          private static bool Compare(XContainer x1, XContainer x2)
1052          {
1053              if (object.ReferenceEquals(x1, x2))
1054              {
1055                  return true;
1056              }
1057              XElement e1 = x1 as XElement;
1058              XElement e2 = x2 as XElement;
1059              if (e1 != null &amp;&amp; e2 != null)
1060              {
1061                  if (!VssStringComparer.XmlNodeName.Equals(e1.Name.ToString(), e2.Name.ToString()) ||
1062                      !e1.Attributes().OrderBy(a =&gt; a.Name.ToString()).SequenceEqual(e2.Attributes().OrderBy(a =&gt; a.Name.ToString()), s_xmlAttributeComparer) ||
1063                      !VssStringComparer.XmlElement.Equals(e1.Value, e2.Value))
1064                  {
1065                      return false;
1066                  }
1067                  return x1.Elements().OrderBy(xe =&gt; xe.Name.ToString()).SequenceEqual(x2.Elements().OrderBy(xe =&gt; xe.Name.ToString()), s_xmlElementComparer);
1068              }
1069              return false;
1070          }
1071          #region GetCachedString
1072          private static String GetCachedString(String fromXml)
1073          {
1074              if (null == fromXml)
1075              {
1076                  return null;
1077              }
1078              int fromXmlLength = fromXml.Length;
1079              if (fromXmlLength &gt; 256)
1080              {
1081                  return fromXml;
1082              }
1083              if (fromXmlLength == 0)
1084              {
1085                  return String.Empty;
1086              }
1087              String[] stringList = ts_stringList;
1088              if (null == stringList)
1089              {
1090                  stringList = new String[c_stringCacheSize];
1091                  ts_stringList = stringList;
1092              }
1093              for (int i = 0; i &lt; c_stringCacheSize; i++)
1094              {
1095                  String cachedString = stringList[i];
1096                  if (null == cachedString)
1097                  {
1098                      break;
1099                  }
1100                  if (cachedString.Length != fromXmlLength ||
1101                      fromXml[0] != cachedString[0])
1102                  {
1103                      continue;
1104                  }
1105                  if (fromXmlLength &gt; 5 &amp;&amp;
1106                      fromXml[fromXmlLength - 5] != cachedString[fromXmlLength - 5])
1107                  {
1108                      continue;
1109                  }
1110                  if (String.Equals(fromXml, cachedString, StringComparison.Ordinal))
1111                  {
1112                      for (int j = i - 1; j &gt;= 0; j--)
1113                      {
1114                          stringList[j + 1] = stringList[j];
1115                      }
1116                      stringList[0] = cachedString;
1117                      return cachedString;
1118                  }
1119              }
1120              for (int i = c_stringCacheSize - 2; i &gt;= 0; i--)
1121              {
1122                  stringList[i + 1] = stringList[i];
1123              }
1124              stringList[0] = fromXml;
1125              return fromXml;
1126          }
1127          [ThreadStatic]
1128          private static String[] ts_stringList;
1129          private const int c_stringCacheSize = 16;
1130          #endregion GetCachedString
1131          private class AttributeComparer : IEqualityComparer&lt;XAttribute&gt;
1132          {
1133              public bool Equals(XAttribute x, XAttribute y)
1134              {
1135                  if (x == y)
1136                  {
1137                      return true;
1138                  }
1139                  if (x == null || y == null)
1140                  {
1141                      return false;
1142                  }
1143                  return VssStringComparer.XmlAttributeName.Equals(x.Name.ToString(), y.Name.ToString()) &amp;&amp;
1144                      VssStringComparer.XmlAttributeValue.Equals(x.Value, y.Value);
1145              }
1146              public int GetHashCode(XAttribute obj)
1147              {
1148                  if (obj == null)
1149                  {
1150                      return 0;
1151                  }
1152                  return obj.GetHashCode();
1153              }
1154          }
1155          private class ElementComparer : IEqualityComparer&lt;XElement&gt;
1156          {
1157              public bool Equals(XElement x, XElement y)
1158              {
1159                  if (x == y)
1160                  {
1161                      return true;
1162                  }
1163                  if (x == null || y == null)
1164                  {
1165                      return false;
1166                  }
1167                  return XmlUtility.Compare(x, y);
1168              }
1169              public int GetHashCode(XElement obj)
1170              {
1171                  if (obj == null)
1172                  {
1173                      return 0;
1174                  }
1175                  return obj.GetHashCode();
1176              }
1177          }
1178          private static byte[] s_zeroLengthArrayOfByte;
1179          private static readonly AttributeComparer s_xmlAttributeComparer = new AttributeComparer();
1180          private static readonly ElementComparer s_xmlElementComparer = new ElementComparer();
1181      }
1182      [EditorBrowsable(EditorBrowsableState.Never)]
1183      public class XmlElementWriterUtility : IDisposable
1184      {
1185          private XmlWriter m_xmlWriter;
1186          public XmlElementWriterUtility(string elementName, XmlWriter xmlWriter)
1187          {
1188              m_xmlWriter = xmlWriter;
1189              m_xmlWriter.WriteStartElement(elementName);
1190          }
1191          public void Dispose()
1192          {
1193              m_xmlWriter.WriteEndElement();
1194          }
1195      }
1196  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-XmlUtility.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Diagnostics;
5  using System.Globalization;
6  using System.IO;
7  using System.Linq;
8  using System.Threading.Tasks;
9  using System.Xml;
10  using System.Xml.Linq;
11  namespace GitHub.Services.Common.Internal
12  {
13      [EditorBrowsable(EditorBrowsableState.Never)]
14      public static class XmlUtility
15      {
16          internal static FileStream OpenFile(String path, FileShare sharing, Boolean saveFile)
17          {
18              XmlDocument noXmlDocument;
19              return OpenFileHelper(path, sharing, saveFile, false, out noXmlDocument);
20          }
21          internal static XmlDocument OpenXmlFile(out FileStream file, String path, FileShare sharing, Boolean saveFile)
22          {
23              XmlDocument xmlDocument;
24              file = OpenFileHelper(path, sharing, saveFile, true, out xmlDocument);
25              return xmlDocument;
26          }
27          private static FileStream OpenFileHelper(String path, FileShare sharing, Boolean saveFile, Boolean loadAsXmlDocument, out XmlDocument xmlDocument)
28          {
29              const int RetryCount = 10;
30              FileStream file = null;
31              xmlDocument = null;
32              if (String.IsNullOrEmpty(path))
33              {
34                  return null;
35              }
36              if (!saveFile &amp;&amp; !File.Exists(path))
37              {
38                  return null;
39              }
40              int retries = 0;
41              Random random = null;
42              while (retries &lt;= RetryCount)
43              {
44                  try
45                  {
46                      FileAccess fileAccess = FileAccess.Read;
47                      FileMode fileMode = FileMode.Open;
48                      if (saveFile)
49                      {
50                          fileAccess = FileAccess.ReadWrite;
51                          fileMode = FileMode.OpenOrCreate;
52                      }
53                      file = new FileStream(path, fileMode, fileAccess, sharing);
54                      if (loadAsXmlDocument)
55                      {
56                          XmlReaderSettings settings = new XmlReaderSettings()
57                          {
58                              DtdProcessing = DtdProcessing.Prohibit,
59                              XmlResolver = null,
60                          };
61                          using (XmlReader xmlReader = XmlReader.Create(file, settings))
62                          {
63                              xmlDocument = new XmlDocument();
64                              xmlDocument.Load(xmlReader);
65                          }
66                      }
67                      return file;
68                  }
69                  catch (Exception exception)
70                  {
71                      if (file != null)
72                      {
73                          file.Dispose();
74                          file = null;
75                      }
76                      if (exception is OperationCanceledException)
77                      {
78                          throw;
79                      }
80                      else if (exception is IOException || exception is UnauthorizedAccessException || exception is XmlException)
81                      {
82                          if (saveFile)
83                          {
84                              try
85                              {
86                                  if (exception is DirectoryNotFoundException)
87                                  {
88                                      String dir = Path.GetDirectoryName(path);
89                                      Directory.CreateDirectory(dir);
90                                  }
91                                  if (exception is UnauthorizedAccessException)
92                                  {
93                                      File.SetAttributes(path, FileAttributes.Normal);
94                                  }
95                                  xmlDocument = null;
96                                  return new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None);
97                              }
98                              catch (Exception newException) when (newException is IOException || newException is UnauthorizedAccessException)
99                              {
100                                  if (retries &gt;= RetryCount)
101                                  {
102                                      throw new AggregateException(exception, newException);
103                                  }
104                              }
105                          }
106                          else
107                          {
108                              return null;
109                          }
110                      }
111                      else if (retries &gt;= RetryCount)
112                      {
113                          throw new VssServiceException(CommonResources.ErrorReadingFile(Path.GetFileName(path), exception.Message), exception);
114                      }
115                  }
116                  if (random == null)
117                  {
118                      random = new Random();
119                  }
120                  int sleepTime = random.Next(1, 150);
121                  Task.Delay(sleepTime).Wait();
122                  retries++;
123              }
124              Debug.Fail(&quot;Code should be unreachable.&quot;);
125              return null;
126          }
127          internal static void AddXmlAttribute(XmlNode node, String attrName, String value)
128          {
129              if (value != null)
130              {
131                  XmlAttribute attr = node.OwnerDocument.CreateAttribute(null, attrName, null);
132                  node.Attributes.Append(attr);
133                  attr.InnerText = value;
134              }
135          }
136          public static XmlReaderSettings SecureReaderSettings
137          {
138              get
139              {
140                  if (s_safeSettings == null)
141                  {
142                      XmlReaderSettings settings = new XmlReaderSettings()
143                      {
144                          DtdProcessing = DtdProcessing.Prohibit,
145                          XmlResolver = null,
146                      };
147                      s_safeSettings = settings;
148                  }
149                  return s_safeSettings;
150              }
151          }
152          public static XmlDocument GetDocument(Stream input)
153          {
154              XmlDocument doc = new XmlDocument();
155              using (XmlReader xmlReader = XmlReader.Create(input, SecureReaderSettings))
156              {
157                  doc.Load(xmlReader);
158              }
159              return doc;
160          }
161          public static XmlDocument GetDocument(string xml)
162          {
163              XmlDocument doc = new XmlDocument();
164              using (StringReader stringReader = new StringReader(xml))
165              using (XmlReader xmlReader = XmlReader.Create(stringReader, SecureReaderSettings))
166              {
167                  doc.Load(xmlReader);
168              }
169              return doc;
170          }
171          public static XmlDocument GetDocumentFromPath(string path)
172          {
173              XmlDocument doc = new XmlDocument();
174              using (XmlReader xmlReader = XmlReader.Create(path, SecureReaderSettings))
175              {
176                  doc.Load(xmlReader);
177              }
178              return doc;
179          }
180          public static DateTime ToDateTime(String s)
181          {
182              DateTime time = XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
183              if (time.Kind == DateTimeKind.Unspecified &amp;&amp;
184                  time != DateTime.MinValue &amp;&amp;
185                  time != DateTime.MaxValue)
186              {
187                  time = DateTime.SpecifyKind(time, DateTimeKind.Utc);
188              }
189              if (time.Year == 1)
190              {
191                  time = DateTime.MinValue;
192              }
193              else
194              {
195                  time = time.ToLocalTime();
196              }
197              return time;
198          }
199          public static DateTime ToDateOnly(String s)
200          {
201              return XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
202          }
203          public static String ToStringDateOnly(DateTime d)
204          {
205              return d.ToString(&quot;yyyy-MM-dd&quot;, CultureInfo.InvariantCulture);
206          }
207          public static String ToString(DateTime d)
208          {
209              Debug.Assert(d == DateTime.MinValue || d == DateTime.MaxValue || d.Kind != DateTimeKind.Unspecified, &quot;DateTime kind is unspecified instead of Local or Utc.&quot;);
210              return XmlConvert.ToString(d, XmlDateTimeSerializationMode.RoundtripKind);
211          }
212          public static void ObjectToXmlElement(XmlWriter writer, String element, Object o)
213          {
214              if (o == null)
215              {
216                  writer.WriteStartElement(element);
217                  writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
218                  writer.WriteEndElement();
219              }
220              else
221              {
222                  String clrTypeName = o.GetType().FullName;
223                  String soapType = null, soapValue = null, soapNamespaceUri = null;
224                  switch (clrTypeName)
225                  {
226                      case &quot;System.Boolean&quot;:
227                          soapType = &quot;boolean&quot;;
228                          soapValue = XmlConvert.ToString((Boolean)o);
229                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
230                          break;
231                      case &quot;System.Byte&quot;:
232                          soapType = &quot;unsignedByte&quot;;
233                          soapValue = XmlConvert.ToString((Byte)o);
234                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
235                          break;
236                      case &quot;System.Byte[]&quot;:
237                          soapType = &quot;base64Binary&quot;;
238                          byte[] array = (byte[])o;
239                          soapValue = Convert.ToBase64String(array, 0, array.Length);
240                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
241                          break;
242                      case &quot;System.Char&quot;:
243                          soapType = &quot;char&quot;;
244                          soapValue = XmlConvert.ToString((UInt16)((Char)o));
245                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;microsoft.com/wsdl/types/&quot;;
246                          break;
247                      case &quot;System.DateTime&quot;:
248                          soapType = &quot;dateTime&quot;;
249                          soapValue = ToString((DateTime)o);
250                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
251                          break;
252                      case &quot;System.Decimal&quot;:
253                          soapType = &quot;decimal&quot;;
254                          soapValue = XmlConvert.ToString((Decimal)o);
255                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
256                          break;
257                      case &quot;System.Double&quot;:
258                          soapType = &quot;double&quot;;
259                          soapValue = XmlConvert.ToString((Double)o);
260                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
261                          break;
262                      case &quot;System.Guid&quot;:
263                          soapType = &quot;guid&quot;;
264                          soapValue = XmlConvert.ToString((Guid)o);
265                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;microsoft.com/wsdl/types/&quot;;
266                          break;
267                      case &quot;System.Int16&quot;:
268                          soapType = &quot;short&quot;;
269                          soapValue = XmlConvert.ToString((Int16)o);
270                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
271                          break;
272                      case &quot;System.Int32&quot;:
273                          soapType = &quot;int&quot;;
274                          soapValue = XmlConvert.ToString((Int32)o);
275                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
276                          break;
277                      case &quot;System.Int64&quot;:
278                          soapType = &quot;long&quot;;
279                          soapValue = XmlConvert.ToString((Int64)o);
280                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
281                          break;
282                      case &quot;System.Single&quot;:
283                          soapType = &quot;float&quot;;
284                          soapValue = XmlConvert.ToString((Single)o);
285                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
286                          break;
287                      case &quot;System.String&quot;:
288                          soapType = &quot;string&quot;;
289                          soapValue = (String)o;
290                          soapNamespaceUri = &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;;
291                          break;
292                      default:
293                          if (o.GetType().IsArray)
294                          {
295                              Debug.Assert(o.GetType().GetArrayRank() == 1, &quot;ERROR: Cannot serialize multi-dimensional arrays&quot;);
296                              writer.WriteStartElement(element);
297                              writer.WriteAttributeString(&quot;type&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;ArrayOfAnyType&quot;);
298                              ArrayOfObjectToXml&lt;Object&gt;(writer, (Object[])o, null, &quot;anyType&quot;, true, false, ObjectToXmlElement);
299                              writer.WriteEndElement();
300                              return;
301                          }
302                          else
303                          {
304                              Debug.Fail(&quot;Unknown object type for serialization &quot; + clrTypeName);
305                              throw new ArgumentException(CommonResources.UnknownTypeForSerialization(clrTypeName));
306                          }
307                  }
308                  writer.WriteStartElement(element);
309                  writer.WriteStartAttribute(&quot;type&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;);
310                  writer.WriteQualifiedName(soapType, soapNamespaceUri);
311                  writer.WriteEndAttribute();
312                  writer.WriteValue(soapValue);
313                  writer.WriteEndElement();
314              }
315          }
316          public static Object ObjectFromXmlElement(XmlReader reader)
317          {
318              String soapTypeName = reader.GetAttribute(&quot;type&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;);
319              if (!String.IsNullOrEmpty(soapTypeName))
320              {
321                  String[] components = soapTypeName.Split(new char[] { &#x27;:&#x27; }, StringSplitOptions.None);
322                  if (components.Length == 2)
323                  {
324                      soapTypeName = components[1];
325  #if DEBUG
326                      String ns = reader.LookupNamespace(components[0]);
327                      if (!String.IsNullOrEmpty(ns) &amp;&amp;
328                          !ns.Equals(&quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp;
329                          !ns.Equals(&quot;http:&amp;bsol;&amp;bsol;microsoft.com/wsdl/types/&quot;, StringComparison.OrdinalIgnoreCase))
330                      {
331                          Debug.Fail(&quot;Unknown namespace encountered for object type &quot; + ns);
332                          reader.ReadOuterXml();
333                          return null;
334                      }
335  #endif
336                  }
337                  switch (soapTypeName)
338                  {
339                      case &quot;base64Binary&quot;:
340                          String str = StringFromXmlElement(reader);
341                          if (str != null)
342                          {
343                              return Convert.FromBase64String(str);
344                          }
345                          return ZeroLengthArrayOfByte;
346                      case &quot;boolean&quot;:
347                          return XmlConvert.ToBoolean(StringFromXmlElement(reader));
348                      case &quot;char&quot;:
349                          return (Char)XmlConvert.ToInt16(StringFromXmlElement(reader));  
350                      case &quot;dateTime&quot;:
351                          return ToDateTime(StringFromXmlElement(reader));
352                      case &quot;decimal&quot;:
353                          return XmlConvert.ToDecimal(StringFromXmlElement(reader));
354                      case &quot;double&quot;:
355                          return XmlConvert.ToDouble(StringFromXmlElement(reader));
356                      case &quot;float&quot;:
357                          return XmlConvert.ToSingle(StringFromXmlElement(reader));
358                      case &quot;int&quot;:
359                          return XmlConvert.ToInt32(StringFromXmlElement(reader));
360                      case &quot;guid&quot;:
361                          return XmlConvert.ToGuid(StringFromXmlElement(reader));
362                      case &quot;long&quot;:
363                          return XmlConvert.ToInt64(StringFromXmlElement(reader));
364                      case &quot;short&quot;:
365                          return XmlConvert.ToInt16(StringFromXmlElement(reader));
366                      case &quot;string&quot;:
367                          return StringFromXmlElement(reader);
368                      case &quot;unsignedByte&quot;:
<span onclick='openModal()' class='match'>369                          return XmlConvert.ToByte(StringFromXmlElement(reader));
370                      case &quot;ArrayOfAnyType&quot;:
371                          return ArrayOfObjectFromXml(reader);
</span>372                      default:
373                          Debug.Fail(&quot;Unknown object type encountered &quot; + soapTypeName);
374                          throw new ArgumentException(CommonResources.UnknownTypeForSerialization(soapTypeName));
375                  }
376              }
377              else if (reader.GetAttribute(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;) == &quot;true&quot;)
378              {
379                  reader.ReadInnerXml();
380                  return null;
381              }
382              return null;
383          }
384          public static void ToXml(XmlWriter writer, String element, Object[] array)
385          {
386              if (array == null || array.Length == 0)
387              {
388                  return;
389              }
390              if (!String.IsNullOrEmpty(element))
391              {
392                  writer.WriteStartElement(element);
393              }
394              for (int i = 0; i &lt; array.Length; i++)
395              {
396                  if (array[i] == null)
397                  {
398                      throw new ArgumentNullException(&quot;array[&quot; + i + &quot;]&quot;);
399                  }
400                  ObjectToXmlElement(writer, &quot;anyType&quot;, array[i]);
401              }
402              if (!String.IsNullOrEmpty(element))
403              {
404                  writer.WriteEndElement();
405              }
406          }
407          public static Object[] ArrayOfObjectFromXml(XmlReader reader)
408          {
409              List&lt;Object&gt; list = new List&lt;Object&gt;();
410              bool empty = reader.IsEmptyElement;
411              Debug.Assert(reader.NodeType == XmlNodeType.Element, &quot;Expected a node.&quot;);
412              reader.Read();
413              if (!empty)
414              {
415                  while (reader.NodeType == XmlNodeType.Element)
416                  {
417                      if (reader.HasAttributes &amp;&amp;
418                          reader.GetAttribute(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;) == &quot;true&quot;)
419                      {
420                          list.Add(null);
421                          reader.Read();
422                      }
423                      else
424                      {
425                          list.Add(ObjectFromXmlElement(reader));
426                      }
427                  }
428                  reader.ReadEndElement();
429              }
430              return list.ToArray();
431          }
432          public static void ToXmlElement(XmlWriter writer, String elementName, XmlNode node)
433          {
434              if (node == null)
435              {
436                  return;
437              }
438              writer.WriteStartElement(elementName);
439              node.WriteTo(writer);
440              writer.WriteEndElement();
441          }
442          public static XmlNode XmlNodeFromXmlElement(XmlReader reader)
443          {
444              reader.Read();
445              XmlDocument document = new XmlDocument
446              {
447                  PreserveWhitespace = false
448              };
449              document.Load(reader);
450              document.Normalize();
451              reader.ReadEndElement();
452              return document.DocumentElement;
453          }
454          public static DateTime DateFromXmlAttribute(XmlReader reader)
455          {
456              return ToDateOnly(StringFromXmlAttribute(reader));
457          }
458          public static DateTime DateFromXmlElement(XmlReader reader)
459          {
460              return ToDateOnly(StringFromXmlElement(reader));
461          }
462          public static void DateToXmlAttribute(XmlWriter writer, String name, DateTime value)
463          {
464              StringToXmlAttribute(writer, name, ToStringDateOnly(value));
465          }
466          public static void DateToXmlElement(XmlWriter writer, String name, DateTime value)
467          {
468              StringToXmlElement(writer, name, ToStringDateOnly(value));
469          }
470          public static Boolean BooleanFromXmlAttribute(XmlReader reader)
471          {
472              return XmlConvert.ToBoolean(StringFromXmlAttribute(reader));
473          }
474          public static DateTime DateTimeFromXmlAttribute(XmlReader reader)
475          {
476              return ToDateTime(StringFromXmlAttribute(reader));
477          }
478          public static DateTime DateTimeFromXmlElement(XmlReader reader)
479          {
480              return ToDateTime(StringFromXmlElement(reader));
481          }
482          public static void ToXmlAttribute(XmlWriter writer, String name, DateTime value)
483          {
484              StringToXmlAttribute(writer, name, ToString(value));
485          }
486          public static void ToXmlElement(XmlWriter writer, String name, DateTime value)
487          {
488              StringToXmlElement(writer, name, ToString(value));
489          }
490          public static void ToXml(XmlWriter writer, String element, byte[] array)
491          {
492              if (array == null || array.Length == 0)
493              {
494                  return;
495              }
496              writer.WriteElementString(element, Convert.ToBase64String(array, 0, array.Length));
497          }
498          public static void ToXmlAttribute(XmlWriter writer, String attr, byte[] array)
499          {
500              if (array == null || array.Length == 0)
501              {
502                  return;
503              }
504              writer.WriteAttributeString(attr, Convert.ToBase64String(array, 0, array.Length));
505          }
506          private static XmlReaderSettings s_safeSettings;
507          public static String ToString(Uri uri)
508          {
509              return uri.AbsoluteUri;
510          }
511          public static Uri ToUri(String s)
512          {
513              if (String.IsNullOrEmpty(s))
514              {
515                  return null;
516              }
517              else
518              {
519                  return new Uri(s);
520              }
521          }
522          public static T EnumFromXmlText&lt;T&gt;(XmlReader reader)
523          {
524              String s = StringFromXmlText(reader);
525              s = s.Replace(&#x27; &#x27;, &#x27;,&#x27;);
526              return (T)Enum.Parse(typeof(T), s, true);
527          }
528          public static void EnumToXmlText&lt;T&gt;(XmlWriter writer, String ignored, T value)
529          {
530              String s = Enum.Format(typeof(T), value, &quot;G&quot;);
531              s = s.Replace(&quot;,&quot;, &quot;&quot;);
532              writer.WriteString(s);
533          }
534          public static void EnumToXmlAttribute&lt;T&gt;(XmlWriter writer, String attr, T value)
535          {
536              String s = Enum.Format(typeof(T), value, &quot;G&quot;);
537              s = s.Replace(&quot;,&quot;, &quot;&quot;);
538              writer.WriteAttributeString(attr, s);
539          }
540          public static T EnumFromXmlAttribute&lt;T&gt;(XmlReader reader)
541          {
542              String s = StringFromXmlAttribute(reader);
543              s = s.Replace(&#x27; &#x27;, &#x27;,&#x27;);
544              return (T)Enum.Parse(typeof(T), s, true);
545          }
546          public static void EnumToXmlElement&lt;T&gt;(XmlWriter writer, String element, T value)
547          {
548              String s = Enum.Format(typeof(T), value, &quot;G&quot;);
549              s = s.Replace(&quot;,&quot;, &quot;&quot;);
550              writer.WriteElementString(element, s);
551          }
552          public static T EnumFromXmlElement&lt;T&gt;(XmlReader reader)
553          {
554              String s = StringFromXmlElement(reader);
555              s = s.Replace(&#x27; &#x27;, &#x27;,&#x27;);
556              return (T)Enum.Parse(typeof(T), s, true);
557          }
558          public static T[] ArrayOfObjectFromXml&lt;T&gt;(
559              XmlReader reader,
560              String arrayElementName,
561              Boolean inline,
562              Func&lt;XmlReader, T&gt; objectFromXmlElement)
563          {
564              return ArrayOfObjectFromXml&lt;T&gt;(null, reader, arrayElementName, inline, (x, y) =&gt; objectFromXmlElement(y));
565          }
566          public static T[] ArrayOfObjectFromXml&lt;T&gt;(
567              IServiceProvider serviceProvider,
568              XmlReader reader,
569              String arrayElementName,
570              Boolean inline,
571              Func&lt;IServiceProvider, XmlReader, T&gt; objectFromXmlElement)
572          {
573              List&lt;T&gt; list = new List&lt;T&gt;();
574              bool empty = reader.IsEmptyElement;
575              Debug.Assert(reader.NodeType == XmlNodeType.Element, &quot;Expected a node.&quot;);
576              if (!inline)
577              {
578                  reader.Read();
579              }
580              if (!empty)
581              {
582                  while (reader.NodeType == XmlNodeType.Element &amp;&amp; (!inline || reader.Name == arrayElementName))
583                  {
584                      if (reader.HasAttributes &amp;&amp; reader.GetAttribute(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;) == &quot;true&quot;)
585                      {
586                          list.Add(default(T));
587                          reader.Read();
588                      }
589                      else
590                      {
591                          list.Add(objectFromXmlElement(serviceProvider, reader));
592                      }
593                  }
594                  reader.ReadEndElement();
595              }
596              return list.ToArray();
597          }
598          public static void ArrayOfObjectToXml&lt;T&gt;(
599              XmlWriter writer,
600              T[] array,
601              String arrayName,
602              String arrayElementName,
603              Boolean inline,
604              Boolean allowEmptyArrays,
605              Action&lt;XmlWriter, String, T&gt; objectToXmlElement)
606          {
607              if (array == null)
608              {
609                  return;
610              }
611              if (array.Length == 0)
612              {
613                  if (allowEmptyArrays &amp;&amp; !String.IsNullOrEmpty(arrayName))
614                  {
615                      writer.WriteStartElement(arrayName);
616                      writer.WriteEndElement();
617                  }
618                  return;
619              }
620              if (!inline)
621              {
622                  writer.WriteStartElement(arrayName);
623                  for (Int32 i = 0; i &lt; array.Length; i = i + 1)
624                  {
625                      if (array[i] == null)
626                      {
627                          writer.WriteStartElement(arrayElementName);
628                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
629                          writer.WriteEndElement();
630                      }
631                      else
632                      {
633                          objectToXmlElement(writer, arrayElementName, array[i]);
634                      }
635                  }
636                  writer.WriteEndElement();
637              }
638              else
639              {
640                  for (Int32 i = 0; i &lt; array.Length; i = i + 1)
641                  {
642                      if (array[i] == null)
643                      {
644                          writer.WriteStartElement(arrayElementName);
645                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
646                          writer.WriteEndElement();
647                      }
648                      else
649                      {
650                          objectToXmlElement(writer, arrayElementName, array[i]);
651                      }
652                  }
653              }
654          }
655          public static void EnumerableOfObjectToXml&lt;T&gt;(
656              XmlWriter writer,
657              IEnumerable&lt;T&gt; enumerable,
658              String arrayName,
659              String arrayElementName,
660              Boolean inline,
661              Boolean allowEmptyArrays,
662              Action&lt;XmlWriter, String, T&gt; objectToXmlElement)
663          {
664              if (enumerable == null)
665              {
666                  return;
667              }
668              if (!enumerable.Any())
669              {
670                  if (allowEmptyArrays &amp;&amp; !String.IsNullOrEmpty(arrayName))
671                  {
672                      writer.WriteStartElement(arrayName);
673                      writer.WriteEndElement();
674                  }
675                  return;
676              }
677              if (!inline)
678              {
679                  writer.WriteStartElement(arrayName);
680                  foreach (T item in enumerable)
681                  {
682                      if (item == null)
683                      {
684                          writer.WriteStartElement(arrayElementName);
685                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
686                          writer.WriteEndElement();
687                      }
688                      else
689                      {
690                          objectToXmlElement(writer, arrayElementName, item);
691                      }
692                  }
693                  writer.WriteEndElement();
694              }
695              else
696              {
697                  foreach (T item in enumerable)
698                  {
699                      if (item == null)
700                      {
701                          writer.WriteStartElement(arrayElementName);
702                          writer.WriteAttributeString(&quot;nil&quot;, &quot;http:&amp;bsol;&amp;bsol;www.w3.org/2001/XMLSchema-instance&quot;, &quot;true&quot;);
703                          writer.WriteEndElement();
704                      }
705                      else
706                      {
707                          objectToXmlElement(writer, arrayElementName, item);
708                      }
709                  }
710              }
711          }
712          public static Boolean BooleanFromXmlElement(XmlReader reader)
713          {
714              return XmlConvert.ToBoolean(StringFromXmlElement(reader));
715          }
716          public static Byte ByteFromXmlAttribute(XmlReader reader)
717          {
718              return XmlConvert.ToByte(StringFromXmlAttribute(reader));
719          }
720          public static Byte ByteFromXmlElement(XmlReader reader)
721          {
722              return XmlConvert.ToByte(StringFromXmlElement(reader));
723          }
724          public static Char CharFromXmlAttribute(XmlReader reader)
725          {
726              return (Char)XmlConvert.ToInt32(StringFromXmlAttribute(reader));
727          }
728          public static Char CharFromXmlElement(XmlReader reader)
729          {
730              return (Char)XmlConvert.ToInt32(StringFromXmlElement(reader));
731          }
732          public static Double DoubleFromXmlAttribute(XmlReader reader)
733          {
734              return XmlConvert.ToDouble(StringFromXmlAttribute(reader));
735          }
736          public static Double DoubleFromXmlElement(XmlReader reader)
737          {
738              return XmlConvert.ToDouble(StringFromXmlElement(reader));
739          }
740          public static Guid GuidFromXmlAttribute(XmlReader reader)
741          {
742              return XmlConvert.ToGuid(StringFromXmlAttribute(reader));
743          }
744          public static Guid GuidFromXmlElement(XmlReader reader)
745          {
746              return XmlConvert.ToGuid(StringFromXmlElement(reader));
747          }
748          public static Int16 Int16FromXmlAttribute(XmlReader reader)
749          {
750              return XmlConvert.ToInt16(StringFromXmlAttribute(reader));
751          }
752          public static Int16 Int16FromXmlElement(XmlReader reader)
753          {
754              return XmlConvert.ToInt16(StringFromXmlElement(reader));
755          }
756          public static Int32 Int32FromXmlAttribute(XmlReader reader)
757          {
758              return XmlConvert.ToInt32(StringFromXmlAttribute(reader));
759          }
760          public static Int32 Int32FromXmlElement(XmlReader reader)
761          {
762              return XmlConvert.ToInt32(StringFromXmlElement(reader));
763          }
764          public static Int64 Int64FromXmlAttribute(XmlReader reader)
765          {
766              return XmlConvert.ToInt64(StringFromXmlAttribute(reader));
767          }
768          public static Int64 Int64FromXmlElement(XmlReader reader)
769          {
770              return XmlConvert.ToInt64(StringFromXmlElement(reader));
771          }
772          public static Single SingleFromXmlAttribute(XmlReader reader)
773          {
774              return XmlConvert.ToSingle(StringFromXmlAttribute(reader));
775          }
776          public static Single SingleFromXmlElement(XmlReader reader)
777          {
778              return XmlConvert.ToSingle(StringFromXmlElement(reader));
779          }
780          public static String StringFromXmlAttribute(XmlReader reader)
781          {
782              return GetCachedString(reader.Value);
783          }
784          public static String StringFromXmlElement(XmlReader reader)
785          {
786              String str = String.Empty;
787              Boolean isEmpty = reader.IsEmptyElement;
788              Debug.Assert(reader.NodeType == XmlNodeType.Element, &quot;Expected a node.&quot;);
789              reader.Read();
790              if (!isEmpty)
791              {
792                  if (reader.NodeType == XmlNodeType.CDATA ||
793                      reader.NodeType == XmlNodeType.Text ||
794                      reader.NodeType == XmlNodeType.Whitespace)
795                  {
796                      str = GetCachedString(reader.ReadContentAsString().Replace(&quot;\n&quot;, &quot;\r\n&quot;));
797                      reader.ReadEndElement();
798                  }
799                  else if (reader.NodeType == XmlNodeType.EndElement)
800                  {
801                      reader.ReadEndElement();
802                  }
803              }
804              return str;
805          }
806          public static String StringFromXmlText(XmlReader reader)
807          {
808              String str = String.Empty;
809              if (reader.NodeType == XmlNodeType.CDATA ||
810                  reader.NodeType == XmlNodeType.Text ||
811                  reader.NodeType == XmlNodeType.Whitespace)
812              {
813                  str = GetCachedString(reader.ReadContentAsString().Replace(&quot;\n&quot;, &quot;\r\n&quot;));
814              }
815              return str;
816          }
817          public static TimeSpan TimeSpanFromXmlAttribute(XmlReader reader)
818          {
819              return XmlConvert.ToTimeSpan(StringFromXmlAttribute(reader));
820          }
821          public static TimeSpan TimeSpanFromXmlElement(XmlReader reader)
822          {
823              return XmlConvert.ToTimeSpan(StringFromXmlElement(reader));
824          }
825          public static UInt16 UInt16FromXmlAttribute(XmlReader reader)
826          {
827              return XmlConvert.ToUInt16(StringFromXmlAttribute(reader));
828          }
829          public static UInt16 UInt16FromXmlElement(XmlReader reader)
830          {
831              return XmlConvert.ToUInt16(StringFromXmlElement(reader));
832          }
833          public static UInt32 UInt32FromXmlAttribute(XmlReader reader)
834          {
835              return XmlConvert.ToUInt32(StringFromXmlAttribute(reader));
836          }
837          public static UInt32 UInt32FromXmlElement(XmlReader reader)
838          {
839              return XmlConvert.ToUInt32(StringFromXmlElement(reader));
840          }
841          public static UInt64 UInt64FromXmlAttribute(XmlReader reader)
842          {
843              return XmlConvert.ToUInt64(StringFromXmlAttribute(reader));
844          }
845          public static UInt64 UInt64FromXmlElement(XmlReader reader)
846          {
847              return XmlConvert.ToUInt64(StringFromXmlElement(reader));
848          }
849          public static Uri UriFromXmlAttribute(XmlReader reader)
850          {
851              return ToUri(StringFromXmlAttribute(reader));
852          }
853          public static Uri UriFromXmlElement(XmlReader reader)
854          {
855              return ToUri(StringFromXmlElement(reader));
856          }
857          public static void ToXmlAttribute(XmlWriter writer, String name, Boolean value)
858          {
859              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
860          }
861          public static void ToXmlAttribute(XmlWriter writer, String name, Byte value)
862          {
863              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
864          }
865          public static void ToXmlAttribute(XmlWriter writer, String name, Char value)
866          {
867              StringToXmlAttribute(writer, name, XmlConvert.ToString((Int32)value));
868          }
869          public static void ToXmlAttribute(XmlWriter writer, String name, Double value)
870          {
871              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
872          }
873          public static void ToXmlAttribute(XmlWriter writer, String name, Guid value)
874          {
875              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
876          }
877          public static void ToXmlAttribute(XmlWriter writer, String name, Int16 value)
878          {
879              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
880          }
881          public static void ToXmlAttribute(XmlWriter writer, String name, Int32 value)
882          {
883              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
884          }
885          public static void ToXmlAttribute(XmlWriter writer, String name, Int64 value)
886          {
887              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
888          }
889          public static void ToXmlAttribute(XmlWriter writer, String name, Single value)
890          {
891              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
892          }
893          public static void ToXmlAttribute(XmlWriter writer, String name, String value)
894          {
895              StringToXmlAttribute(writer, name, value);
896          }
897          public static void ToXmlAttribute(XmlWriter writer, String name, TimeSpan value)
898          {
899              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
900          }
901          public static void ToXmlAttribute(XmlWriter writer, String name, UInt16 value)
902          {
903              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
904          }
905          public static void ToXmlAttribute(XmlWriter writer, String name, UInt32 value)
906          {
907              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
908          }
909          public static void ToXmlAttribute(XmlWriter writer, String name, UInt64 value)
910          {
911              StringToXmlAttribute(writer, name, XmlConvert.ToString(value));
912          }
913          public static void ToXmlAttribute(XmlWriter writer, String name, Uri value)
914          {
915              StringToXmlAttribute(writer, name, ToString(value));
916          }
917          public static void ToXmlElement(XmlWriter writer, String name, Boolean value)
918          {
919              StringToXmlElement(writer, name, XmlConvert.ToString(value));
920          }
921          public static void ToXmlElement(XmlWriter writer, String name, Byte value)
922          {
923              StringToXmlElement(writer, name, XmlConvert.ToString(value));
924          }
925          public static void ToXmlElement(XmlWriter writer, String name, Char value)
926          {
927              StringToXmlElement(writer, name, XmlConvert.ToString((Int32)value));
928          }
929          public static void ToXmlElement(XmlWriter writer, String name, Double value)
930          {
931              StringToXmlElement(writer, name, XmlConvert.ToString(value));
932          }
933          public static void ToXmlElement(XmlWriter writer, String name, Guid value)
934          {
935              StringToXmlElement(writer, name, XmlConvert.ToString(value));
936          }
937          public static void ToXmlElement(XmlWriter writer, String element, Int16 value)
938          {
939              StringToXmlElement(writer, element, XmlConvert.ToString(value));
940          }
941          public static void ToXmlElement(XmlWriter writer, String element, Int32 value)
942          {
943              StringToXmlElement(writer, element, XmlConvert.ToString(value));
944          }
945          public static void ToXmlElement(XmlWriter writer, String element, Int64 value)
946          {
947              StringToXmlElement(writer, element, XmlConvert.ToString(value));
948          }
949          public static void ToXmlElement(XmlWriter writer, String name, Single value)
950          {
951              StringToXmlElement(writer, name, XmlConvert.ToString(value));
952          }
953          public static void ToXmlElement(XmlWriter writer, String name, String value)
954          {
955              StringToXmlElement(writer, name, value);
956          }
957          public static void ToXmlElement(XmlWriter writer, String name, TimeSpan value)
958          {
959              StringToXmlElement(writer, name, XmlConvert.ToString(value));
960          }
961          public static void ToXmlElement(XmlWriter writer, String element, UInt16 value)
962          {
963              StringToXmlElement(writer, element, XmlConvert.ToString(value));
964          }
965          public static void ToXmlElement(XmlWriter writer, String element, UInt32 value)
966          {
967              StringToXmlElement(writer, element, XmlConvert.ToString(value));
968          }
969          public static void ToXmlElement(XmlWriter writer, String element, UInt64 value)
970          {
971              StringToXmlElement(writer, element, XmlConvert.ToString(value));
972          }
973          public static void ToXmlElement(XmlWriter writer, String name, Uri value)
974          {
975              StringToXmlElement(writer, name, ToString(value));
976          }
977          public static void StringToXmlAttribute(XmlWriter writer, String name, String value)
978          {
979              writer.WriteAttributeString(name, value);
980          }
981          public static void StringToXmlElement(XmlWriter writer, String name, String value)
982          {
983              try
984              {
985                  writer.WriteElementString(name, value);
986              }
987              catch (ArgumentException e)
988              {
989                  Debug.Assert(e.Message.IndexOf(&quot;invalid character&quot;, StringComparison.OrdinalIgnoreCase) &gt; 0, &quot;Unexpected exception: &quot; + e.ToString());
990                  throw new VssServiceException(CommonResources.StringContainsIllegalChars(), e);
991              }
992          }
993          public static void StringToXmlText(XmlWriter writer, String str)
994          {
995              if (str == null)
996              {
997                  return;
998              }
999              try
1000              {
1001                  writer.WriteString(str);
1002              }
1003              catch (ArgumentException e)
1004              {
1005                  Debug.Assert(e.Message.IndexOf(&quot;invalid character&quot;, StringComparison.OrdinalIgnoreCase) &gt; 0, &quot;Unexpected exception: &quot; + e.ToString());
1006                  throw new VssServiceException(CommonResources.StringContainsIllegalChars(), e);
1007              }
1008          }
1009          public static byte[] ArrayOfByteFromXml(XmlReader reader)
1010          {
1011              String str = StringFromXmlElement(reader);
1012              if (str != null)
1013              {
1014                  return Convert.FromBase64String(str);
1015              }
1016              return ZeroLengthArrayOfByte;
1017          }
1018          public static byte[] ArrayOfByteFromXmlAttribute(XmlReader reader)
1019          {
1020              if (reader.Value.Length != 0)
1021              {
1022                  return Convert.FromBase64String(reader.Value);
1023              }
1024              return ZeroLengthArrayOfByte;
1025          }
1026          public static byte[] ZeroLengthArrayOfByte
1027          {
1028              get
1029              {
1030                  if (s_zeroLengthArrayOfByte == null)
1031                  {
1032                      s_zeroLengthArrayOfByte = new byte[0];
1033                  }
1034                  return s_zeroLengthArrayOfByte;
1035              }
1036          }
1037          public static bool CompareXmlDocuments(string xml1, string xml2)
1038          {
1039              if (xml1 == xml2)
1040              {
1041                  return true;
1042              }
1043              else if (string.IsNullOrEmpty(xml1) || string.IsNullOrEmpty(xml2))
1044              {
1045                  return false;
1046              }
1047              XDocument x1 = XDocument.Parse(xml1);
1048              XDocument x2 = XDocument.Parse(xml2);
1049              return Compare(x1?.Root, x2?.Root);
1050          }
1051          private static bool Compare(XContainer x1, XContainer x2)
1052          {
1053              if (object.ReferenceEquals(x1, x2))
1054              {
1055                  return true;
1056              }
1057              XElement e1 = x1 as XElement;
1058              XElement e2 = x2 as XElement;
1059              if (e1 != null &amp;&amp; e2 != null)
1060              {
1061                  if (!VssStringComparer.XmlNodeName.Equals(e1.Name.ToString(), e2.Name.ToString()) ||
1062                      !e1.Attributes().OrderBy(a =&gt; a.Name.ToString()).SequenceEqual(e2.Attributes().OrderBy(a =&gt; a.Name.ToString()), s_xmlAttributeComparer) ||
1063                      !VssStringComparer.XmlElement.Equals(e1.Value, e2.Value))
1064                  {
1065                      return false;
1066                  }
1067                  return x1.Elements().OrderBy(xe =&gt; xe.Name.ToString()).SequenceEqual(x2.Elements().OrderBy(xe =&gt; xe.Name.ToString()), s_xmlElementComparer);
1068              }
1069              return false;
1070          }
1071          #region GetCachedString
1072          private static String GetCachedString(String fromXml)
1073          {
1074              if (null == fromXml)
1075              {
1076                  return null;
1077              }
1078              int fromXmlLength = fromXml.Length;
1079              if (fromXmlLength &gt; 256)
1080              {
1081                  return fromXml;
1082              }
1083              if (fromXmlLength == 0)
1084              {
1085                  return String.Empty;
1086              }
1087              String[] stringList = ts_stringList;
1088              if (null == stringList)
1089              {
1090                  stringList = new String[c_stringCacheSize];
1091                  ts_stringList = stringList;
1092              }
1093              for (int i = 0; i &lt; c_stringCacheSize; i++)
1094              {
1095                  String cachedString = stringList[i];
1096                  if (null == cachedString)
1097                  {
1098                      break;
1099                  }
1100                  if (cachedString.Length != fromXmlLength ||
1101                      fromXml[0] != cachedString[0])
1102                  {
1103                      continue;
1104                  }
1105                  if (fromXmlLength &gt; 5 &amp;&amp;
1106                      fromXml[fromXmlLength - 5] != cachedString[fromXmlLength - 5])
1107                  {
1108                      continue;
1109                  }
1110                  if (String.Equals(fromXml, cachedString, StringComparison.Ordinal))
1111                  {
1112                      for (int j = i - 1; j &gt;= 0; j--)
1113                      {
1114                          stringList[j + 1] = stringList[j];
1115                      }
1116                      stringList[0] = cachedString;
1117                      return cachedString;
1118                  }
1119              }
1120              for (int i = c_stringCacheSize - 2; i &gt;= 0; i--)
1121              {
1122                  stringList[i + 1] = stringList[i];
1123              }
1124              stringList[0] = fromXml;
1125              return fromXml;
1126          }
1127          [ThreadStatic]
1128          private static String[] ts_stringList;
1129          private const int c_stringCacheSize = 16;
1130          #endregion GetCachedString
1131          private class AttributeComparer : IEqualityComparer&lt;XAttribute&gt;
1132          {
1133              public bool Equals(XAttribute x, XAttribute y)
1134              {
1135                  if (x == y)
1136                  {
1137                      return true;
1138                  }
1139                  if (x == null || y == null)
1140                  {
1141                      return false;
1142                  }
1143                  return VssStringComparer.XmlAttributeName.Equals(x.Name.ToString(), y.Name.ToString()) &amp;&amp;
1144                      VssStringComparer.XmlAttributeValue.Equals(x.Value, y.Value);
1145              }
1146              public int GetHashCode(XAttribute obj)
1147              {
1148                  if (obj == null)
1149                  {
1150                      return 0;
1151                  }
1152                  return obj.GetHashCode();
1153              }
1154          }
1155          private class ElementComparer : IEqualityComparer&lt;XElement&gt;
1156          {
1157              public bool Equals(XElement x, XElement y)
1158              {
1159                  if (x == y)
1160                  {
1161                      return true;
1162                  }
1163                  if (x == null || y == null)
1164                  {
1165                      return false;
1166                  }
1167                  return XmlUtility.Compare(x, y);
1168              }
1169              public int GetHashCode(XElement obj)
1170              {
1171                  if (obj == null)
1172                  {
1173                      return 0;
1174                  }
1175                  return obj.GetHashCode();
1176              }
1177          }
1178          private static byte[] s_zeroLengthArrayOfByte;
1179          private static readonly AttributeComparer s_xmlAttributeComparer = new AttributeComparer();
1180          private static readonly ElementComparer s_xmlElementComparer = new ElementComparer();
1181      }
1182      [EditorBrowsable(EditorBrowsableState.Never)]
1183      public class XmlElementWriterUtility : IDisposable
1184      {
1185          private XmlWriter m_xmlWriter;
1186          public XmlElementWriterUtility(string elementName, XmlWriter xmlWriter)
1187          {
1188              m_xmlWriter = xmlWriter;
1189              m_xmlWriter.WriteStartElement(elementName);
1190          }
1191          public void Dispose()
1192          {
1193              m_xmlWriter.WriteEndElement();
1194          }
1195      }
1196  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-XmlUtility.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-XmlUtility.cs</div>
                </div>
                <div class="column column_space"><pre><code>357                          return XmlConvert.ToSingle(StringFromXmlElement(reader));
358                      case &quot;int&quot;:
359                          return XmlConvert.ToInt32(StringFromXmlElement(reader));
</pre></code></div>
                <div class="column column_space"><pre><code>369                          return XmlConvert.ToByte(StringFromXmlElement(reader));
370                      case &quot;ArrayOfAnyType&quot;:
371                          return ArrayOfObjectFromXml(reader);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    