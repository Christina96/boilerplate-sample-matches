
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Text;
4  #pragma warning disable CA1034
5  namespace NpgsqlTypes;
6  public abstract class NpgsqlTsQuery : IEquatable<NpgsqlTsQuery>
7  {
8      public NodeKind Kind { get; }
9      public enum NodeKind
10      {
11          Empty = -1,
12          Lexeme = 0,
13          Not = 1,
14          And = 2,
15          Or = 3,
16          Phrase = 4
17      }
18      protected NpgsqlTsQuery(NodeKind kind) => Kind = kind;
19      public void Write(StringBuilder stringBuilder) => WriteCore(stringBuilder, true);
20      internal abstract void WriteCore(StringBuilder sb, bool first = false);
21      public override string ToString()
22      {
23          var sb = new StringBuilder();
24          Write(sb);
25          return sb.ToString();
26      }
27      public static NpgsqlTsQuery Parse(string value)
28      {
29          if (value == null)
30              throw new ArgumentNullException(nameof(value));
31          var valStack = new Stack<NpgsqlTsQuery>();
32          var opStack = new Stack<NpgsqlTsQueryOperator>();
33          var sb = new StringBuilder();
34          var pos = 0;
35          var expectingBinOp = false;
36          var lastFollowedByOpDistance = -1;
37          NextToken:
38          if (pos >= value.Length)
39              goto Finish;
40          var ch = value[pos++];
41          if (ch == '\'')
42              goto WaitEndComplex;
43          if ((ch == ')' || ch == '|' || ch == '&') && !expectingBinOp || (ch == '(' || ch == '!') && expectingBinOp)
44              throw new FormatException("Syntax error in tsquery. Unexpected token.");
45          if (ch == '<')
46          {
47              var endOfOperatorConsumed = false;
48              var sbCurrentLength = sb.Length;
49              while (pos < value.Length)
50              {
51                  var c = value[pos++];
52                  if (c == '>')
53                  {
54                      endOfOperatorConsumed = true;
55                      break;
56                  }
57                  sb.Append(c);
58              }
59              if (sb.Length == sbCurrentLength || !endOfOperatorConsumed)
60                  throw new FormatException("Syntax error in tsquery. Malformed 'followed by' operator.");
61              var followedByOpDistanceString = sb.ToString(sbCurrentLength, sb.Length - sbCurrentLength);
62              if (followedByOpDistanceString == "-")
63              {
64                  lastFollowedByOpDistance = 1;
65              }
66              else if (!int.TryParse(followedByOpDistanceString, out lastFollowedByOpDistance)
67                       || lastFollowedByOpDistance < 0)
68              {
69                  throw new FormatException("Syntax error in tsquery. Malformed distance in 'followed by' operator.");
70              }
71              sb.Length -= followedByOpDistanceString.Length;
72          }
73          if (ch == '(' || ch == '!' || ch == '&' || ch == '<')
74          {
75              opStack.Push(new NpgsqlTsQueryOperator(ch, lastFollowedByOpDistance));
76              expectingBinOp = false;
77              lastFollowedByOpDistance = 0;
78              goto NextToken;
79          }
80          if (ch == '|')
81          {
82              if (opStack.Count > 0 && opStack.Peek() == '|')
83              {
84                  if (valStack.Count < 2)
85                      throw new FormatException("Syntax error in tsquery");
86                  var right = valStack.Pop();
87                  var left = valStack.Pop();
88                  valStack.Push(new NpgsqlTsQueryOr(left, right));
89              }
90              else
91                  opStack.Push('|');
92              expectingBinOp = false;
93              goto NextToken;
94          }
95          if (ch == ')')
96          {
97              while (opStack.Count > 0 && opStack.Peek() != '(')
98              {
99                  if (valStack.Count < 2 || opStack.Peek() == '!')
100                      throw new FormatException("Syntax error in tsquery");
101                  var right = valStack.Pop();
102                  var left = valStack.Pop();
103                  var tsOp = opStack.Pop();
104                  valStack.Push((char)tsOp switch
105                  {
106                      '&' => (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
107                      '|' => new NpgsqlTsQueryOr(left, right),
108                      '<' => new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
109                      _   => throw new FormatException("Syntax error in tsquery")
110                  });
111              }
112              if (opStack.Count == 0)
113                  throw new FormatException("Syntax error in tsquery: closing parenthesis without an opening parenthesis");
114              opStack.Pop();
115              goto PushedVal;
116          }
117          if (ch == ':')
118              throw new FormatException("Unexpected : while parsing tsquery");
119          if (char.IsWhiteSpace(ch))
120              goto NextToken;
121          pos--;
122          if (expectingBinOp)
123              throw new FormatException("Unexpected lexeme while parsing tsquery");
124          WaitEnd:
125          if (pos >= value.Length || char.IsWhiteSpace(ch = value[pos]) || ch == '!' || ch == '&' || ch == '|' || ch == '(' || ch == ')')
126          {
127              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
128              goto PushedVal;
129          }
130          pos++;
131          if (ch == ':')
132          {
133              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
134              sb.Clear();
135              goto InWeightInfo;
136          }
137          if (ch == '\\')
138          {
139              if (pos >= value.Length)
140                  throw new FormatException(@"Unexpected \ in end of value");
141              ch = value[pos++];
142          }
143          sb.Append(ch);
144          goto WaitEnd;
145          WaitEndComplex:
146          if (pos >= value.Length)
147              throw new FormatException("Missing terminating ' in string literal");
148          ch = value[pos++];
149          if (ch == '\'')
150          {
151              if (pos < value.Length && value[pos] == '\'')
152              {
153                  ch = '\'';
154                  pos++;
155              }
156              else
157              {
158                  valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
159                  if (pos < value.Length && value[pos] == ':')
160                  {
161                      pos++;
162                      goto InWeightInfo;
163                  }
164                  goto PushedVal;
165              }
166          }
167          if (ch == '\\')
168          {
169              if (pos >= value.Length)
170                  throw new FormatException(@"Unexpected \ in end of value");
171              ch = value[pos++];
172          }
173          sb.Append(ch);
174          goto WaitEndComplex;
175          InWeightInfo:
176          if (pos >= value.Length)
177              goto Finish;
178          ch = value[pos];
179          switch (ch)
180          {
181          case '*':
182              ((NpgsqlTsQueryLexeme)valStack.Peek()).IsPrefixSearch = true;
183              break;
184          case 'a' or 'A':
185              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.A;
186              break;
187          case 'b' or 'B':
188              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.B;
189              break;
190          case 'c' or 'C':
191              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.C;
192              break;
193          case 'd' or 'D':
194              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.D;
195              break;
196          default:
197              goto PushedVal;
198          }
199          pos++;
200          goto InWeightInfo;
201          PushedVal:
202          sb.Clear();
203          var processTightBindingOperator = true;
204          while (opStack.Count > 0 && processTightBindingOperator)
205          {
206              var tsOp = opStack.Peek();
207              switch (tsOp)
208              {
209              case '&':
210                  if (valStack.Count < 2)
211                      throw new FormatException("Syntax error in tsquery");
212                  var andRight = valStack.Pop();
213                  var andLeft = valStack.Pop();
214                  valStack.Push(new NpgsqlTsQueryAnd(andLeft, andRight));
215                  opStack.Pop();
216                  break;
217              case '!':
218                  if (valStack.Count == 0)
219                      throw new FormatException("Syntax error in tsquery");
220                  valStack.Push(new NpgsqlTsQueryNot(valStack.Pop()));
221                  opStack.Pop();
222                  break;
223              case '<':
224                  if (valStack.Count < 2)
225                      throw new FormatException("Syntax error in tsquery");
226                  var followedByRight = valStack.Pop();
227                  var followedByLeft = valStack.Pop();
228                  valStack.Push(
229                      new NpgsqlTsQueryFollowedBy(
230                          followedByLeft,
231                          tsOp.FollowedByDistance,
232                          followedByRight));
233                  opStack.Pop();
234                  break;
235              default:
236                  processTightBindingOperator = false;
237                  break;
238              }
239          }
240          expectingBinOp = true;
241          goto NextToken;
242          Finish:
243          while (opStack.Count > 0)
244          {
245              if (valStack.Count < 2)
246                  throw new FormatException("Syntax error in tsquery");
247              var right = valStack.Pop();
248              var left = valStack.Pop();
249              var tsOp = opStack.Pop();
250              var query = (char)tsOp switch
251              {
252                  '&' => (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
253                  '|' => new NpgsqlTsQueryOr(left, right),
254                  '<' => new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
255                  _   => throw new FormatException("Syntax error in tsquery")
256              };
257              valStack.Push(query);
258          }
259          if (valStack.Count != 1)
260              throw new FormatException("Syntax error in tsquery");
261          return valStack.Pop();
262      }
263      public override int GetHashCode()
264          => throw new NotSupportedException("Must be overridden");
265      public override bool Equals(object? obj)
266          => obj is NpgsqlTsQuery query && query.Equals(this);
267      public abstract bool Equals(NpgsqlTsQuery? other);
268      public static bool operator ==(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
269          => left is null ? right is null : left.Equals(right);
270      public static bool operator !=(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
271          => left is null ? right is not null : !left.Equals(right);
272  }
273  readonly struct NpgsqlTsQueryOperator
274  {
275      public readonly char Char;
276      public readonly int FollowedByDistance;
277      public NpgsqlTsQueryOperator(char character, int followedByDistance)
278      {
279          Char = character;
280          FollowedByDistance = followedByDistance;
281      }
282      public static implicit operator NpgsqlTsQueryOperator(char c) => new(c, 0);
283      public static implicit operator char(NpgsqlTsQueryOperator o) => o.Char;
284  }
285  public sealed class NpgsqlTsQueryLexeme : NpgsqlTsQuery
286  {
287      string _text;
288      public string Text
289      {
290          get => _text;
291          set
292          {
293              if (string.IsNullOrEmpty(value))
294                  throw new ArgumentException("Text is null or empty string", nameof(value));
295              _text = value;
296          }
297      }
298      Weight _weights;
299      public Weight Weights
300      {
301          get => _weights;
302          set
303          {
304              if (((byte)value >> 4) != 0)
305                  throw new ArgumentOutOfRangeException(nameof(value), "Illegal weights");
306              _weights = value;
307          }
308      }
309      public bool IsPrefixSearch { get; set; }
310      public NpgsqlTsQueryLexeme(string text) : this(text, Weight.None, false) { }
311      public NpgsqlTsQueryLexeme(string text, Weight weights) : this(text, weights, false) { }
312      public NpgsqlTsQueryLexeme(string text, Weight weights, bool isPrefixSearch)
313          : base(NodeKind.Lexeme)
314      {
315          _text = text;
316          Weights = weights;
317          IsPrefixSearch = isPrefixSearch;
318      }
319  #pragma warning disable CA1714
320      [Flags]
321      public enum Weight
322  #pragma warning restore CA1714
323      {
324          None = 0,
325          D = 1,
326          C = 2,
327          B = 4,
328          A = 8
329      }
330      internal override void WriteCore(StringBuilder sb, bool first = false)
331      {
332          sb.Append('\'').Append(Text.Replace(@"\", @"\\").Replace("'", "''")).Append('\'');
333          if (IsPrefixSearch || Weights != Weight.None)
334              sb.Append(':');
335          if (IsPrefixSearch)
336              sb.Append('*');
337          if ((Weights & Weight.A) != Weight.None)
338              sb.Append('A');
339          if ((Weights & Weight.B) != Weight.None)
340              sb.Append('B');
341          if ((Weights & Weight.C) != Weight.None)
342              sb.Append('C');
343          if ((Weights & Weight.D) != Weight.None)
344              sb.Append('D');
345      }
346      public override bool Equals(NpgsqlTsQuery? other)
347          => other is NpgsqlTsQueryLexeme lexeme &&
348             lexeme.Text == Text &&
349             lexeme.Weights == Weights &&
350             lexeme.IsPrefixSearch == IsPrefixSearch;
351      public override int GetHashCode()
352          => HashCode.Combine(Text, Weights, IsPrefixSearch);
353  }
354  public sealed class NpgsqlTsQueryNot : NpgsqlTsQuery
355  {
356      public NpgsqlTsQuery Child { get; set; }
357      public NpgsqlTsQueryNot(NpgsqlTsQuery child)
358          : base(NodeKind.Not)
359      {
<span onclick='openModal()' class='match'>360          Child = child;
361      }
362      internal override void WriteCore(StringBuilder sb, bool first = false)
363      {
364          sb.Append('!');
</span>365          if (Child == null)
366          {
367              sb.Append("''");
368          }
369          else
370          {
371              if (Child.Kind != NodeKind.Lexeme)
372                  sb.Append("( ");
373              Child.WriteCore(sb, true);
374              if (Child.Kind != NodeKind.Lexeme)
375                  sb.Append(" )");
376          }
377      }
378      public override bool Equals(NpgsqlTsQuery? other)
379          => other is NpgsqlTsQueryNot not && not.Child == Child;
380      public override int GetHashCode()
381          => Child?.GetHashCode() ?? 0;
382  }
383  public abstract class NpgsqlTsQueryBinOp : NpgsqlTsQuery
384  {
385      public NpgsqlTsQuery Left { get; set; }
386      public NpgsqlTsQuery Right { get; set; }
387      protected NpgsqlTsQueryBinOp(NodeKind kind, NpgsqlTsQuery left, NpgsqlTsQuery right)
388          : base(kind)
389      {
390          Left = left;
391          Right = right;
392      }
393  }
394  public sealed class NpgsqlTsQueryAnd : NpgsqlTsQueryBinOp
395  {
396      public NpgsqlTsQueryAnd(NpgsqlTsQuery left, NpgsqlTsQuery right)
397          : base(NodeKind.And, left, right) {}
398      internal override void WriteCore(StringBuilder sb, bool first = false)
399      {
400          Left.WriteCore(sb);
401          sb.Append(" & ");
402          Right.WriteCore(sb);
403      }
404      public override bool Equals(NpgsqlTsQuery? other)
405          => other is NpgsqlTsQueryAnd and && and.Left == Left && and.Right == Right;
406      public override int GetHashCode()
407          => HashCode.Combine(Left, Right);
408  }
409  public sealed class NpgsqlTsQueryOr : NpgsqlTsQueryBinOp
410  {
411      public NpgsqlTsQueryOr(NpgsqlTsQuery left, NpgsqlTsQuery right)
412          : base(NodeKind.Or, left, right) {}
413      internal override void WriteCore(StringBuilder sb, bool first = false)
414      {
415          if (!first)
416              sb.Append("( ");
417          Left.WriteCore(sb);
418          sb.Append(" | ");
419          Right.WriteCore(sb);
420          if (!first)
421              sb.Append(" )");
422      }
423      public override bool Equals(NpgsqlTsQuery? other)
424          => other is NpgsqlTsQueryOr or && or.Left == Left && or.Right == Right;
425      public override int GetHashCode()
426          => HashCode.Combine(Left, Right);
427  }
428  public sealed class NpgsqlTsQueryFollowedBy : NpgsqlTsQueryBinOp
429  {
430      public int Distance { get; set; }
431      public NpgsqlTsQueryFollowedBy(
432          NpgsqlTsQuery left,
433          int distance,
434          NpgsqlTsQuery right)
435          : base(NodeKind.Phrase, left, right)
436      {
437          if (distance < 0)
438              throw new ArgumentOutOfRangeException(nameof(distance));
439          Distance = distance;
440      }
441      internal override void WriteCore(StringBuilder sb, bool first = false)
442      {
443          if (!first)
444              sb.Append("( ");
445          Left.WriteCore(sb);
446          sb.Append(" <");
447          if (Distance == 1) sb.Append("-");
448          else sb.Append(Distance);
449          sb.Append("> ");
450          Right.WriteCore(sb);
451          if (!first)
452              sb.Append(" )");
453      }
454      public override bool Equals(NpgsqlTsQuery? other)
455          => other is NpgsqlTsQueryFollowedBy followedBy &&
456             followedBy.Left == Left &&
457             followedBy.Right == Right &&
458             followedBy.Distance == Distance;
459      public override int GetHashCode()
460          => HashCode.Combine(Left, Right, Distance);
461  }
462  public sealed class NpgsqlTsQueryEmpty : NpgsqlTsQuery
463  {
464      public NpgsqlTsQueryEmpty() : base(NodeKind.Empty) {}
465      internal override void WriteCore(StringBuilder sb, bool first = false) { }
466      public override bool Equals(NpgsqlTsQuery? other)
467          => other is NpgsqlTsQueryEmpty;
468      public override int GetHashCode()
469          => Kind.GetHashCode();
470  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Text;
4  #pragma warning disable CA1034
5  namespace NpgsqlTypes;
6  public abstract class NpgsqlTsQuery : IEquatable<NpgsqlTsQuery>
7  {
8      public NodeKind Kind { get; }
9      public enum NodeKind
10      {
11          Empty = -1,
12          Lexeme = 0,
13          Not = 1,
14          And = 2,
15          Or = 3,
16          Phrase = 4
17      }
18      protected NpgsqlTsQuery(NodeKind kind) => Kind = kind;
19      public void Write(StringBuilder stringBuilder) => WriteCore(stringBuilder, true);
20      internal abstract void WriteCore(StringBuilder sb, bool first = false);
21      public override string ToString()
22      {
23          var sb = new StringBuilder();
24          Write(sb);
25          return sb.ToString();
26      }
27      public static NpgsqlTsQuery Parse(string value)
28      {
29          if (value == null)
30              throw new ArgumentNullException(nameof(value));
31          var valStack = new Stack<NpgsqlTsQuery>();
32          var opStack = new Stack<NpgsqlTsQueryOperator>();
33          var sb = new StringBuilder();
34          var pos = 0;
35          var expectingBinOp = false;
36          var lastFollowedByOpDistance = -1;
37          NextToken:
38          if (pos >= value.Length)
39              goto Finish;
40          var ch = value[pos++];
41          if (ch == '\'')
42              goto WaitEndComplex;
43          if ((ch == ')' || ch == '|' || ch == '&') && !expectingBinOp || (ch == '(' || ch == '!') && expectingBinOp)
44              throw new FormatException("Syntax error in tsquery. Unexpected token.");
45          if (ch == '<')
46          {
47              var endOfOperatorConsumed = false;
48              var sbCurrentLength = sb.Length;
49              while (pos < value.Length)
50              {
51                  var c = value[pos++];
52                  if (c == '>')
53                  {
54                      endOfOperatorConsumed = true;
55                      break;
56                  }
57                  sb.Append(c);
58              }
59              if (sb.Length == sbCurrentLength || !endOfOperatorConsumed)
60                  throw new FormatException("Syntax error in tsquery. Malformed 'followed by' operator.");
61              var followedByOpDistanceString = sb.ToString(sbCurrentLength, sb.Length - sbCurrentLength);
62              if (followedByOpDistanceString == "-")
63              {
64                  lastFollowedByOpDistance = 1;
65              }
66              else if (!int.TryParse(followedByOpDistanceString, out lastFollowedByOpDistance)
67                       || lastFollowedByOpDistance < 0)
68              {
69                  throw new FormatException("Syntax error in tsquery. Malformed distance in 'followed by' operator.");
70              }
71              sb.Length -= followedByOpDistanceString.Length;
72          }
73          if (ch == '(' || ch == '!' || ch == '&' || ch == '<')
74          {
75              opStack.Push(new NpgsqlTsQueryOperator(ch, lastFollowedByOpDistance));
76              expectingBinOp = false;
77              lastFollowedByOpDistance = 0;
78              goto NextToken;
79          }
80          if (ch == '|')
81          {
82              if (opStack.Count > 0 && opStack.Peek() == '|')
83              {
84                  if (valStack.Count < 2)
85                      throw new FormatException("Syntax error in tsquery");
86                  var right = valStack.Pop();
87                  var left = valStack.Pop();
88                  valStack.Push(new NpgsqlTsQueryOr(left, right));
89              }
90              else
91                  opStack.Push('|');
92              expectingBinOp = false;
93              goto NextToken;
94          }
95          if (ch == ')')
96          {
97              while (opStack.Count > 0 && opStack.Peek() != '(')
98              {
99                  if (valStack.Count < 2 || opStack.Peek() == '!')
100                      throw new FormatException("Syntax error in tsquery");
101                  var right = valStack.Pop();
102                  var left = valStack.Pop();
103                  var tsOp = opStack.Pop();
104                  valStack.Push((char)tsOp switch
105                  {
106                      '&' => (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
107                      '|' => new NpgsqlTsQueryOr(left, right),
108                      '<' => new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
109                      _   => throw new FormatException("Syntax error in tsquery")
110                  });
111              }
112              if (opStack.Count == 0)
113                  throw new FormatException("Syntax error in tsquery: closing parenthesis without an opening parenthesis");
114              opStack.Pop();
115              goto PushedVal;
116          }
117          if (ch == ':')
118              throw new FormatException("Unexpected : while parsing tsquery");
119          if (char.IsWhiteSpace(ch))
120              goto NextToken;
121          pos--;
122          if (expectingBinOp)
123              throw new FormatException("Unexpected lexeme while parsing tsquery");
124          WaitEnd:
125          if (pos >= value.Length || char.IsWhiteSpace(ch = value[pos]) || ch == '!' || ch == '&' || ch == '|' || ch == '(' || ch == ')')
126          {
127              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
128              goto PushedVal;
129          }
130          pos++;
131          if (ch == ':')
132          {
133              valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
134              sb.Clear();
135              goto InWeightInfo;
136          }
137          if (ch == '\\')
138          {
139              if (pos >= value.Length)
140                  throw new FormatException(@"Unexpected \ in end of value");
141              ch = value[pos++];
142          }
143          sb.Append(ch);
144          goto WaitEnd;
145          WaitEndComplex:
146          if (pos >= value.Length)
147              throw new FormatException("Missing terminating ' in string literal");
148          ch = value[pos++];
149          if (ch == '\'')
150          {
151              if (pos < value.Length && value[pos] == '\'')
152              {
153                  ch = '\'';
154                  pos++;
155              }
156              else
157              {
158                  valStack.Push(new NpgsqlTsQueryLexeme(sb.ToString()));
159                  if (pos < value.Length && value[pos] == ':')
160                  {
161                      pos++;
162                      goto InWeightInfo;
163                  }
164                  goto PushedVal;
165              }
166          }
167          if (ch == '\\')
168          {
169              if (pos >= value.Length)
170                  throw new FormatException(@"Unexpected \ in end of value");
171              ch = value[pos++];
172          }
173          sb.Append(ch);
174          goto WaitEndComplex;
175          InWeightInfo:
176          if (pos >= value.Length)
177              goto Finish;
178          ch = value[pos];
179          switch (ch)
180          {
181          case '*':
182              ((NpgsqlTsQueryLexeme)valStack.Peek()).IsPrefixSearch = true;
183              break;
184          case 'a' or 'A':
185              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.A;
186              break;
187          case 'b' or 'B':
188              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.B;
189              break;
190          case 'c' or 'C':
191              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.C;
192              break;
193          case 'd' or 'D':
194              ((NpgsqlTsQueryLexeme)valStack.Peek()).Weights |= NpgsqlTsQueryLexeme.Weight.D;
195              break;
196          default:
197              goto PushedVal;
198          }
199          pos++;
200          goto InWeightInfo;
201          PushedVal:
202          sb.Clear();
203          var processTightBindingOperator = true;
204          while (opStack.Count > 0 && processTightBindingOperator)
205          {
206              var tsOp = opStack.Peek();
207              switch (tsOp)
208              {
209              case '&':
210                  if (valStack.Count < 2)
211                      throw new FormatException("Syntax error in tsquery");
212                  var andRight = valStack.Pop();
213                  var andLeft = valStack.Pop();
214                  valStack.Push(new NpgsqlTsQueryAnd(andLeft, andRight));
215                  opStack.Pop();
216                  break;
217              case '!':
218                  if (valStack.Count == 0)
219                      throw new FormatException("Syntax error in tsquery");
220                  valStack.Push(new NpgsqlTsQueryNot(valStack.Pop()));
221                  opStack.Pop();
222                  break;
223              case '<':
224                  if (valStack.Count < 2)
225                      throw new FormatException("Syntax error in tsquery");
226                  var followedByRight = valStack.Pop();
227                  var followedByLeft = valStack.Pop();
228                  valStack.Push(
229                      new NpgsqlTsQueryFollowedBy(
230                          followedByLeft,
231                          tsOp.FollowedByDistance,
232                          followedByRight));
233                  opStack.Pop();
234                  break;
235              default:
236                  processTightBindingOperator = false;
237                  break;
238              }
239          }
240          expectingBinOp = true;
241          goto NextToken;
242          Finish:
243          while (opStack.Count > 0)
244          {
245              if (valStack.Count < 2)
246                  throw new FormatException("Syntax error in tsquery");
247              var right = valStack.Pop();
248              var left = valStack.Pop();
249              var tsOp = opStack.Pop();
250              var query = (char)tsOp switch
251              {
252                  '&' => (NpgsqlTsQuery)new NpgsqlTsQueryAnd(left, right),
253                  '|' => new NpgsqlTsQueryOr(left, right),
254                  '<' => new NpgsqlTsQueryFollowedBy(left, tsOp.FollowedByDistance, right),
255                  _   => throw new FormatException("Syntax error in tsquery")
256              };
257              valStack.Push(query);
258          }
259          if (valStack.Count != 1)
260              throw new FormatException("Syntax error in tsquery");
261          return valStack.Pop();
262      }
263      public override int GetHashCode()
264          => throw new NotSupportedException("Must be overridden");
265      public override bool Equals(object? obj)
266          => obj is NpgsqlTsQuery query && query.Equals(this);
267      public abstract bool Equals(NpgsqlTsQuery? other);
268      public static bool operator ==(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
269          => left is null ? right is null : left.Equals(right);
270      public static bool operator !=(NpgsqlTsQuery? left, NpgsqlTsQuery? right)
271          => left is null ? right is not null : !left.Equals(right);
272  }
273  readonly struct NpgsqlTsQueryOperator
274  {
275      public readonly char Char;
276      public readonly int FollowedByDistance;
277      public NpgsqlTsQueryOperator(char character, int followedByDistance)
278      {
279          Char = character;
280          FollowedByDistance = followedByDistance;
281      }
282      public static implicit operator NpgsqlTsQueryOperator(char c) => new(c, 0);
283      public static implicit operator char(NpgsqlTsQueryOperator o) => o.Char;
284  }
285  public sealed class NpgsqlTsQueryLexeme : NpgsqlTsQuery
286  {
287      string _text;
288      public string Text
289      {
290          get => _text;
291          set
292          {
293              if (string.IsNullOrEmpty(value))
294                  throw new ArgumentException("Text is null or empty string", nameof(value));
295              _text = value;
296          }
297      }
298      Weight _weights;
299      public Weight Weights
300      {
301          get => _weights;
302          set
303          {
304              if (((byte)value >> 4) != 0)
305                  throw new ArgumentOutOfRangeException(nameof(value), "Illegal weights");
306              _weights = value;
307          }
308      }
309      public bool IsPrefixSearch { get; set; }
310      public NpgsqlTsQueryLexeme(string text) : this(text, Weight.None, false) { }
311      public NpgsqlTsQueryLexeme(string text, Weight weights) : this(text, weights, false) { }
312      public NpgsqlTsQueryLexeme(string text, Weight weights, bool isPrefixSearch)
313          : base(NodeKind.Lexeme)
314      {
315          _text = text;
316          Weights = weights;
317          IsPrefixSearch = isPrefixSearch;
318      }
319  #pragma warning disable CA1714
320      [Flags]
321      public enum Weight
322  #pragma warning restore CA1714
323      {
324          None = 0,
325          D = 1,
326          C = 2,
327          B = 4,
328          A = 8
329      }
330      internal override void WriteCore(StringBuilder sb, bool first = false)
331      {
332          sb.Append('\'').Append(Text.Replace(@"\", @"\\").Replace("'", "''")).Append('\'');
333          if (IsPrefixSearch || Weights != Weight.None)
334              sb.Append(':');
335          if (IsPrefixSearch)
336              sb.Append('*');
337          if ((Weights & Weight.A) != Weight.None)
338              sb.Append('A');
339          if ((Weights & Weight.B) != Weight.None)
340              sb.Append('B');
341          if ((Weights & Weight.C) != Weight.None)
342              sb.Append('C');
343          if ((Weights & Weight.D) != Weight.None)
344              sb.Append('D');
345      }
346      public override bool Equals(NpgsqlTsQuery? other)
347          => other is NpgsqlTsQueryLexeme lexeme &&
348             lexeme.Text == Text &&
349             lexeme.Weights == Weights &&
350             lexeme.IsPrefixSearch == IsPrefixSearch;
351      public override int GetHashCode()
352          => HashCode.Combine(Text, Weights, IsPrefixSearch);
353  }
354  public sealed class NpgsqlTsQueryNot : NpgsqlTsQuery
355  {
356      public NpgsqlTsQuery Child { get; set; }
357      public NpgsqlTsQueryNot(NpgsqlTsQuery child)
358          : base(NodeKind.Not)
359      {
360          Child = child;
361      }
362      internal override void WriteCore(StringBuilder sb, bool first = false)
363      {
364          sb.Append('!');
365          if (Child == null)
366          {
367              sb.Append("''");
368          }
369          else
370          {
371              if (Child.Kind != NodeKind.Lexeme)
372                  sb.Append("( ");
373              Child.WriteCore(sb, true);
374              if (Child.Kind != NodeKind.Lexeme)
375                  sb.Append(" )");
376          }
377      }
378      public override bool Equals(NpgsqlTsQuery? other)
379          => other is NpgsqlTsQueryNot not && not.Child == Child;
380      public override int GetHashCode()
381          => Child?.GetHashCode() ?? 0;
382  }
383  public abstract class NpgsqlTsQueryBinOp : NpgsqlTsQuery
384  {
385      public NpgsqlTsQuery Left { get; set; }
386      public NpgsqlTsQuery Right { get; set; }
387      protected NpgsqlTsQueryBinOp(NodeKind kind, NpgsqlTsQuery left, NpgsqlTsQuery right)
388          : base(kind)
389      {
390          Left = left;
391          Right = right;
392      }
393  }
394  public sealed class NpgsqlTsQueryAnd : NpgsqlTsQueryBinOp
395  {
396      public NpgsqlTsQueryAnd(NpgsqlTsQuery left, NpgsqlTsQuery right)
397          : base(NodeKind.And, left, right) {}
398      internal override void WriteCore(StringBuilder sb, bool first = false)
399      {
400          Left.WriteCore(sb);
401          sb.Append(" & ");
402          Right.WriteCore(sb);
403      }
404      public override bool Equals(NpgsqlTsQuery? other)
405          => other is NpgsqlTsQueryAnd and && and.Left == Left && and.Right == Right;
406      public override int GetHashCode()
407          => HashCode.Combine(Left, Right);
408  }
409  public sealed class NpgsqlTsQueryOr : NpgsqlTsQueryBinOp
410  {
411      public NpgsqlTsQueryOr(NpgsqlTsQuery left, NpgsqlTsQuery right)
412          : base(NodeKind.Or, left, right) {}
413      internal override void WriteCore(StringBuilder sb, bool first = false)
414      {
415          if (!first)
416              sb.Append("( ");
417          Left.WriteCore(sb);
418          sb.Append(" | ");
419          Right.WriteCore(sb);
420          if (!first)
421              sb.Append(" )");
422      }
423      public override bool Equals(NpgsqlTsQuery? other)
424          => other is NpgsqlTsQueryOr or && or.Left == Left && or.Right == Right;
425      public override int GetHashCode()
426          => HashCode.Combine(Left, Right);
427  }
428  public sealed class NpgsqlTsQueryFollowedBy : NpgsqlTsQueryBinOp
429  {
430      public int Distance { get; set; }
431      public NpgsqlTsQueryFollowedBy(
432          NpgsqlTsQuery left,
433          int distance,
434          NpgsqlTsQuery right)
435          : base(NodeKind.Phrase, left, right)
436      {
437          if (distance < 0)
438              throw new ArgumentOutOfRangeException(nameof(distance));
<span onclick='openModal()' class='match'>439          Distance = distance;
440      }
441      internal override void WriteCore(StringBuilder sb, bool first = false)
442      {
443          if (!first)
</span>444              sb.Append("( ");
445          Left.WriteCore(sb);
446          sb.Append(" <");
447          if (Distance == 1) sb.Append("-");
448          else sb.Append(Distance);
449          sb.Append("> ");
450          Right.WriteCore(sb);
451          if (!first)
452              sb.Append(" )");
453      }
454      public override bool Equals(NpgsqlTsQuery? other)
455          => other is NpgsqlTsQueryFollowedBy followedBy &&
456             followedBy.Left == Left &&
457             followedBy.Right == Right &&
458             followedBy.Distance == Distance;
459      public override int GetHashCode()
460          => HashCode.Combine(Left, Right, Distance);
461  }
462  public sealed class NpgsqlTsQueryEmpty : NpgsqlTsQuery
463  {
464      public NpgsqlTsQueryEmpty() : base(NodeKind.Empty) {}
465      internal override void WriteCore(StringBuilder sb, bool first = false) { }
466      public override bool Equals(NpgsqlTsQuery? other)
467          => other is NpgsqlTsQueryEmpty;
468      public override int GetHashCode()
469          => Kind.GetHashCode();
470  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlTsQuery.cs</div>
                </div>
                <div class="column column_space"><pre><code>360          Child = child;
361      }
362      internal override void WriteCore(StringBuilder sb, bool first = false)
363      {
364          sb.Append('!');
</pre></code></div>
                <div class="column column_space"><pre><code>439          Distance = distance;
440      }
441      internal override void WriteCore(StringBuilder sb, bool first = false)
442      {
443          if (!first)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    