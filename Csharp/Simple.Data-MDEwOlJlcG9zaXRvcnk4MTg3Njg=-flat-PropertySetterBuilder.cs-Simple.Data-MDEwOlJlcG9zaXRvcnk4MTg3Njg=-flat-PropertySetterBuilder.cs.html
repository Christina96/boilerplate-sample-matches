
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-PropertySetterBuilder.cs</h3>
            <pre><code>1  using System.ComponentModel;
2  namespace Simple.Data
3  {
4      using System;
5      using System.Collections;
6      using System.Collections.Generic;
7      using System.Linq;
8      using System.Linq.Expressions;
9      using System.Reflection;
10      class PropertySetterBuilder
11      {
12          private static readonly MethodInfo DictionaryContainsKeyMethod = typeof(IDictionary<string, object>).GetMethod("ContainsKey", new[] { typeof(string) });
13          private static readonly PropertyInfo DictionaryIndexerProperty = typeof(IDictionary<string, object>).GetProperty("Item");
14          private static readonly MethodInfo ToArrayDictionaryMethod = typeof(Enumerable).GetMethod("ToArray",
15                                                                                          BindingFlags.Public |
16                                                                                          BindingFlags.Static).MakeGenericMethod(typeof(IDictionary<string, object>));
17          private static readonly MethodInfo ToArrayObjectMethod = typeof(Enumerable).GetMethod("ToArray",
18                                                                                  BindingFlags.Public |
19                                                                                  BindingFlags.Static).MakeGenericMethod(typeof(object));
20          private static readonly PropertyInfo ArrayDictionaryLengthProperty =
21              typeof(IDictionary<string, object>[]).GetProperty("Length");
22          private static readonly PropertyInfo ArrayObjectLengthProperty =
23              typeof(object[]).GetProperty("Length");
24          private readonly ParameterExpression _param;
25          private readonly ParameterExpression _obj;
26          private readonly PropertyInfo _property;
27          private MemberExpression _nameProperty;
28          private IndexExpression _itemProperty;
29          private MethodCallExpression _containsKey;
30          private static readonly MethodInfo CreatorCreateMethod = typeof(ConcreteTypeCreator).GetMethod("Create");
31          public PropertySetterBuilder(ParameterExpression param, ParameterExpression obj, PropertyInfo property)
32          {
33              _param = param;
34              _obj = obj;
35              _property = property;
36          }
37          public ConditionalExpression CreatePropertySetter()
38          {
39              CreatePropertyExpressions();
40              if (PropertyIsPrimitive())
41              {
42                  return Expression.IfThen(_containsKey, CreateTrySimpleAssign());
43              }
44              if (_property.PropertyType.IsArray)
45              {
46                  return Expression.IfThen(_containsKey, CreateTrySimpleArrayAssign());
47              }
48              if (_property.PropertyType.IsGenericCollection())
49              {
50                  var collectionCreator = BuildCollectionCreator();
51                  if (collectionCreator != null)
52                  {
53                      return Expression.IfThen(_containsKey, collectionCreator);
54                  }
55              }
56              var isDictionary = Expression.TypeIs(_itemProperty, typeof(IDictionary<string, object>));
57              var tryComplexAssign = Expression.TryCatch(CreateComplexAssign(),
58                                                         CreateCatchBlock());
59              var ifThen = Expression.IfThen(_containsKey, 
60                                             Expression.IfThenElse(isDictionary, tryComplexAssign, CreateTrySimpleAssign()));
61              return ifThen;
62          }
63          private Expression BuildArrayCreator()
64          {
65              if (!_property.CanWrite) return null;
66              var genericType = _property.PropertyType.GetGenericArguments().Single();
67              var creatorInstance = ConcreteTypeCreator.Get(genericType);
68              var collection = Expression.Variable(_property.PropertyType);
69              var createCollection = MakeCreateNewCollection(collection, genericType);
70              if (createCollection == null) return null;
71              var addMethod = _property.PropertyType.GetMethod("Add");
72              if (addMethod == null) return null;
73              return BuildCollectionCreatorExpression(genericType, creatorInstance, collection, createCollection, addMethod);
74          }
75          private Expression BuildCollectionCreator()
76          {
77              var genericType = _property.PropertyType.GetGenericArguments().Single();
78              var creatorInstance = ConcreteTypeCreator.Get(genericType);
79              var collection = Expression.Variable(_property.PropertyType);
80              BinaryExpression createCollection = null;
81              if (_property.CanWrite)
82              {
83                  createCollection = MakeCreateNewCollection(collection, genericType);
84              }
85              else
86              {
87                  createCollection = Expression.Assign(collection, _nameProperty);
88              }
89              var addMethod = _property.PropertyType.GetInterfaceMethod("Add");
90              if (createCollection != null && addMethod != null)
91              {
92                  return BuildCollectionCreatorExpression(genericType, creatorInstance, collection, createCollection, addMethod);
93              }
94              return null;
95          }
96          private Expression BuildCollectionCreatorExpression(Type genericType, ConcreteTypeCreator creatorInstance, ParameterExpression collection, BinaryExpression createCollection, MethodInfo addMethod)
97          {
98              BlockExpression dictionaryBlock;
99              var isDictionaryCollection = BuildComplexTypeCollectionPopulator(collection, genericType, addMethod, createCollection, creatorInstance, out dictionaryBlock);
100              BlockExpression objectBlock;
101              var isObjectcollection = BuildSimpleTypeCollectionPopulator(collection, genericType, addMethod, createCollection, creatorInstance, out objectBlock);
102              return Expression.IfThenElse(isDictionaryCollection, dictionaryBlock,
103                  Expression.IfThen(isObjectcollection, objectBlock));
104          }
105          private TypeBinaryExpression BuildComplexTypeCollectionPopulator(ParameterExpression collection, Type genericType,
106                                                               MethodInfo addMethod, BinaryExpression createCollection,
107                                                               ConcreteTypeCreator creatorInstance, out BlockExpression block)
108          {
109              var creator = Expression.Constant(creatorInstance);
110              var array = Expression.Variable(typeof (IDictionary<string, object>[]));
111              var i = Expression.Variable(typeof (int));
112              var current = Expression.Variable(typeof (IDictionary<string, object>));
113              var isDictionaryCollection = Expression.TypeIs(_itemProperty,
114                                                             typeof (IEnumerable<IDictionary<string, object>>));
115              var toArray = Expression.Assign(array,
116                                              Expression.Call(ToArrayDictionaryMethod,
117                                                              Expression.Convert(_itemProperty,
118                                                                                 typeof (IEnumerable<IDictionary<string, object>>))));
119              var start = Expression.Assign(i, Expression.Constant(0));
120              var label = Expression.Label();
121              var loop = Expression.Loop(
122                  Expression.IfThenElse(
123                      Expression.LessThan(i, Expression.Property(array, ArrayDictionaryLengthProperty)),
124                      Expression.Block(
125                          Expression.Assign(current, Expression.ArrayIndex(array, i)),
126                          Expression.Call(collection, addMethod,
127                                          Expression.Convert(Expression.Call(creator, CreatorCreateMethod, current), genericType)),
128                          Expression.PreIncrementAssign(i)
129                          ),
130                      Expression.Break(label)
131                      ),
132                  label
133                  );
134              block = Expression.Block(
135                  new[] {array, i, collection, current},
136                  createCollection,
137                  toArray,
138                  start,
139                  loop,
140                  _property.CanWrite ? (Expression) Expression.Assign(_nameProperty, collection) : Expression.Empty());
141              return isDictionaryCollection;
142          }
143          private TypeBinaryExpression BuildSimpleTypeCollectionPopulator(ParameterExpression collection, Type genericType,
144                                                               MethodInfo addMethod, BinaryExpression createCollection, 
145                                                               ConcreteTypeCreator creatorInstance, out BlockExpression block)
146          {
147              var creator = Expression.Constant(creatorInstance);
148              var array = Expression.Variable(typeof(object[]));
149              var i = Expression.Variable(typeof(int));
<span onclick='openModal()' class='match'>150              var current = Expression.Variable(typeof(object));
151              var isObjectCollection = Expression.TypeIs(_itemProperty,
</span>152                                                             typeof(IEnumerable<object>));
153              var toArray = Expression.Assign(array,
154                                              Expression.Call(ToArrayObjectMethod,
155                                                              Expression.Convert(_itemProperty,
156                                                                                 typeof(IEnumerable<object>))));
157              var start = Expression.Assign(i, Expression.Constant(0));
158              var label = Expression.Label();
159              var loop = Expression.Loop(
160                  Expression.IfThenElse(
161                      Expression.LessThan(i, Expression.Property(array, ArrayObjectLengthProperty)),
162                      Expression.Block(
163                          Expression.Assign(current, Expression.ArrayIndex(array, i)),
164                          Expression.IfThenElse(
165                              Expression.TypeIs(current, typeof(IDictionary<string,object>)),
166                              Expression.Call(collection, addMethod,
167                                          Expression.Convert(Expression.Call(creator, CreatorCreateMethod, 
168                                                  Expression.Convert(current, typeof(IDictionary<string,object>))), 
169                                              genericType)),
170                              Expression.Call(collection, addMethod,
171                                              Expression.Convert(current, genericType))),
172                          Expression.PreIncrementAssign(i)
173                          ),
174                      Expression.Break(label)
175                      ),
176                  label
177                  );
178              block = Expression.Block(
179                  new[] { array, i, collection, current },
180                  createCollection,
181                  toArray,
182                  start,
183                  loop,
184                  _property.CanWrite ? (Expression)Expression.Assign(_nameProperty, collection) : Expression.Empty());
185              return isObjectCollection;
186          }
187          private BinaryExpression MakeCreateNewCollection(ParameterExpression collection, Type genericType)
188          {
189              BinaryExpression createCollection;
190              if (_property.PropertyType.IsInterface)
191              {
192                  createCollection = Expression.Assign(collection,
193                                                       Expression.Call(
194                                                           typeof (PropertySetterBuilder).GetMethod("CreateList",
195                                                                                                    BindingFlags.
196                                                                                                        NonPublic |
197                                                                                                    BindingFlags.
198                                                                                                        Static).
199                                                               MakeGenericMethod(genericType)));
200              }
201              else
202              {
203                  var defaultConstructor = _property.PropertyType.GetConstructor(Type.EmptyTypes);
204                  if (defaultConstructor != null)
205                  {
206                      createCollection = Expression.Assign(collection, Expression.New(defaultConstructor));
207                  }
208                  else
209                  {
210                      createCollection = null;
211                  }
212              }
213              return createCollection;
214          }
215          private bool PropertyIsPrimitive()
216          {
217              return _property.PropertyType.IsPrimitive || _property.PropertyType == typeof(string) ||
218                     _property.PropertyType == typeof(DateTime) || _property.PropertyType == typeof(byte[]) ||
219                     _property.PropertyType.IsEnum ||
220                     (_property.PropertyType.IsGenericType && _property.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>));
221          }
222          private void CreatePropertyExpressions()
223          {
224              var name = Expression.Constant(_property.Name, typeof(string));
225              _containsKey = Expression.Call(_param, DictionaryContainsKeyMethod, name);
226              _nameProperty = Expression.Property(_obj, _property);
227              _itemProperty = Expression.Property(_param, DictionaryIndexerProperty, name);
228          }
229          private CatchBlock CreateCatchBlock()
230          {
231              return Expression.Catch(typeof(Exception), Expression.Assign(_nameProperty,
232                                                                           Expression.Default(_property.PropertyType)));
233          }
234          private BinaryExpression CreateComplexAssign()
235          {
236              var creator = Expression.Constant(ConcreteTypeCreator.Get(_property.PropertyType));
237              var methodCallExpression = Expression.Call(creator, CreatorCreateMethod,
238                                                         Expression.Convert(_itemProperty,
239                                                                            typeof(IDictionary<string, object>)));
240              var complexAssign = Expression.Assign(_nameProperty,
241                                                    Expression.Convert(
242                                                        methodCallExpression, _property.PropertyType));
243              return complexAssign;
244          }
245          private TryExpression CreateTrySimpleAssign()
246          {
247              MethodCallExpression callConvert;
248              if (_property.PropertyType.IsEnum)
249              {
250                  var changeTypeMethod = typeof (PropertySetterBuilder).GetMethod("SafeConvert",
251                                                                                  BindingFlags.Static | BindingFlags.NonPublic);
252                  callConvert = Expression.Call(changeTypeMethod, _itemProperty,
253                                                Expression.Constant(_property.PropertyType.GetEnumUnderlyingType(), typeof(Type)));
254              }
255              else if (_property.PropertyType.IsGenericType && _property.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
256              {
257                  var changeTypeMethod = typeof (PropertySetterBuilder)
258                      .GetMethod("SafeConvertNullable", BindingFlags.Static | BindingFlags.NonPublic)
259                      .MakeGenericMethod(_property.PropertyType.GetGenericArguments().Single());
260                  callConvert = Expression.Call(changeTypeMethod, _itemProperty);
261              }
262              else
263              {
264                  var changeTypeMethod = typeof (PropertySetterBuilder).GetMethod("SafeConvert",
265                                                                                  BindingFlags.Static | BindingFlags.NonPublic);
266                  callConvert = Expression.Call(changeTypeMethod, _itemProperty,
267                                                Expression.Constant(_property.PropertyType, typeof(Type)));
268              }
269              var assign = Expression.Assign(_nameProperty, Expression.Convert(callConvert, _property.PropertyType));
270              if (_property.PropertyType.IsEnum)
271              {
272                  return Expression.TryCatch( 
273                      Expression.IfThenElse(Expression.TypeIs(_itemProperty, typeof (string)),
274                                            Expression.Assign(_nameProperty,
275                                                              Expression.Convert(Expression.Call(typeof (Enum).GetMethod("Parse", new[] {typeof(Type), typeof(string), typeof(bool)}),
276                                                                                                 Expression.Constant(_property.PropertyType, typeof(Type)),
277                                                                                                 Expression.Call(_itemProperty, typeof(object).GetMethod("ToString")), Expression.Constant(true)), _property.PropertyType)),
278                                            assign), Expression.Catch(typeof(Exception), Expression.Empty()));
279              }
280              return Expression.TryCatch( 
281                  assign, 
282                  CreateCatchBlock());
283          }
284          private TryExpression CreateTrySimpleArrayAssign()
285          {
286              var createArrayMethod = typeof (PropertySetterBuilder).GetMethod("CreateArray", BindingFlags.Static | BindingFlags.NonPublic)
287                  .MakeGenericMethod(_property.PropertyType.GetElementType());
288              var callConvert = Expression.Call(createArrayMethod, _itemProperty);
289              var assign = Expression.Assign(_nameProperty, Expression.Convert(callConvert, _property.PropertyType));
290              return Expression.TryCatch( 
291                  Expression.IfThenElse(Expression.TypeIs(_itemProperty, typeof (string)),
292                                        Expression.Assign(_nameProperty,
293                                                          Expression.Convert(Expression.Call(typeof (Enum).GetMethod("Parse", new[] {typeof(Type), typeof(string), typeof(bool)}),
294                                                                                             Expression.Constant(_property.PropertyType, typeof(Type)),
295                                                                                             Expression.Call(_itemProperty, typeof(object).GetMethod("ToString")), Expression.Constant(true)), _property.PropertyType)),
296                                        assign), Expression.Catch(typeof(Exception), Expression.Empty()));
297          }
298          internal static object SafeConvert(object source, Type targetType)
299          {
300              if (ReferenceEquals(source, null)) return null;
301              if (targetType.IsInstanceOfType(source)) return source;
302              if (source is string && targetType == typeof(Guid)) return TypeDescriptor.GetConverter(typeof(Guid)).ConvertFromInvariantString(source.ToString());
303              return Convert.ChangeType(source, targetType);
304          }
305          internal static T? SafeConvertNullable<T>(object source)
306              where T : struct 
307          {
308              if (ReferenceEquals(source, null)) return default(T?);
309              return (T) source;
310          }
311          private static T[] CreateArray<T>(object source)
312          {
313              if (ReferenceEquals(source, null)) return null;
314              var enumerable = source as IEnumerable;
315              if (ReferenceEquals(enumerable, null)) return null;
316              try
317              {
318                  return enumerable.Cast<T>().ToArray();
319              }
320              catch (InvalidCastException)
321              {
322                  return null;
323              }
324          }
325          private static List<T> CreateList<T>()
326          {
327              return new List<T>();
328          }
329      }
330  }
</code></pre>
        </div>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-PropertySetterBuilder.cs</h3>
            <pre><code>1  using System.ComponentModel;
2  namespace Simple.Data
3  {
4      using System;
5      using System.Collections;
6      using System.Collections.Generic;
7      using System.Linq;
8      using System.Linq.Expressions;
9      using System.Reflection;
10      class PropertySetterBuilder
11      {
12          private static readonly MethodInfo DictionaryContainsKeyMethod = typeof(IDictionary<string, object>).GetMethod("ContainsKey", new[] { typeof(string) });
13          private static readonly PropertyInfo DictionaryIndexerProperty = typeof(IDictionary<string, object>).GetProperty("Item");
14          private static readonly MethodInfo ToArrayDictionaryMethod = typeof(Enumerable).GetMethod("ToArray",
15                                                                                          BindingFlags.Public |
16                                                                                          BindingFlags.Static).MakeGenericMethod(typeof(IDictionary<string, object>));
17          private static readonly MethodInfo ToArrayObjectMethod = typeof(Enumerable).GetMethod("ToArray",
18                                                                                  BindingFlags.Public |
19                                                                                  BindingFlags.Static).MakeGenericMethod(typeof(object));
20          private static readonly PropertyInfo ArrayDictionaryLengthProperty =
21              typeof(IDictionary<string, object>[]).GetProperty("Length");
22          private static readonly PropertyInfo ArrayObjectLengthProperty =
23              typeof(object[]).GetProperty("Length");
24          private readonly ParameterExpression _param;
25          private readonly ParameterExpression _obj;
26          private readonly PropertyInfo _property;
27          private MemberExpression _nameProperty;
28          private IndexExpression _itemProperty;
29          private MethodCallExpression _containsKey;
30          private static readonly MethodInfo CreatorCreateMethod = typeof(ConcreteTypeCreator).GetMethod("Create");
31          public PropertySetterBuilder(ParameterExpression param, ParameterExpression obj, PropertyInfo property)
32          {
33              _param = param;
34              _obj = obj;
35              _property = property;
36          }
37          public ConditionalExpression CreatePropertySetter()
38          {
39              CreatePropertyExpressions();
40              if (PropertyIsPrimitive())
41              {
42                  return Expression.IfThen(_containsKey, CreateTrySimpleAssign());
43              }
44              if (_property.PropertyType.IsArray)
45              {
46                  return Expression.IfThen(_containsKey, CreateTrySimpleArrayAssign());
47              }
48              if (_property.PropertyType.IsGenericCollection())
49              {
50                  var collectionCreator = BuildCollectionCreator();
51                  if (collectionCreator != null)
52                  {
53                      return Expression.IfThen(_containsKey, collectionCreator);
54                  }
55              }
56              var isDictionary = Expression.TypeIs(_itemProperty, typeof(IDictionary<string, object>));
57              var tryComplexAssign = Expression.TryCatch(CreateComplexAssign(),
58                                                         CreateCatchBlock());
59              var ifThen = Expression.IfThen(_containsKey, 
60                                             Expression.IfThenElse(isDictionary, tryComplexAssign, CreateTrySimpleAssign()));
61              return ifThen;
62          }
63          private Expression BuildArrayCreator()
64          {
65              if (!_property.CanWrite) return null;
66              var genericType = _property.PropertyType.GetGenericArguments().Single();
67              var creatorInstance = ConcreteTypeCreator.Get(genericType);
68              var collection = Expression.Variable(_property.PropertyType);
69              var createCollection = MakeCreateNewCollection(collection, genericType);
70              if (createCollection == null) return null;
71              var addMethod = _property.PropertyType.GetMethod("Add");
72              if (addMethod == null) return null;
73              return BuildCollectionCreatorExpression(genericType, creatorInstance, collection, createCollection, addMethod);
74          }
75          private Expression BuildCollectionCreator()
76          {
77              var genericType = _property.PropertyType.GetGenericArguments().Single();
78              var creatorInstance = ConcreteTypeCreator.Get(genericType);
79              var collection = Expression.Variable(_property.PropertyType);
80              BinaryExpression createCollection = null;
81              if (_property.CanWrite)
82              {
83                  createCollection = MakeCreateNewCollection(collection, genericType);
84              }
85              else
86              {
87                  createCollection = Expression.Assign(collection, _nameProperty);
88              }
89              var addMethod = _property.PropertyType.GetInterfaceMethod("Add");
90              if (createCollection != null && addMethod != null)
91              {
92                  return BuildCollectionCreatorExpression(genericType, creatorInstance, collection, createCollection, addMethod);
93              }
94              return null;
95          }
96          private Expression BuildCollectionCreatorExpression(Type genericType, ConcreteTypeCreator creatorInstance, ParameterExpression collection, BinaryExpression createCollection, MethodInfo addMethod)
97          {
98              BlockExpression dictionaryBlock;
99              var isDictionaryCollection = BuildComplexTypeCollectionPopulator(collection, genericType, addMethod, createCollection, creatorInstance, out dictionaryBlock);
100              BlockExpression objectBlock;
101              var isObjectcollection = BuildSimpleTypeCollectionPopulator(collection, genericType, addMethod, createCollection, creatorInstance, out objectBlock);
102              return Expression.IfThenElse(isDictionaryCollection, dictionaryBlock,
103                  Expression.IfThen(isObjectcollection, objectBlock));
104          }
105          private TypeBinaryExpression BuildComplexTypeCollectionPopulator(ParameterExpression collection, Type genericType,
106                                                               MethodInfo addMethod, BinaryExpression createCollection,
107                                                               ConcreteTypeCreator creatorInstance, out BlockExpression block)
108          {
109              var creator = Expression.Constant(creatorInstance);
110              var array = Expression.Variable(typeof (IDictionary<string, object>[]));
111              var i = Expression.Variable(typeof (int));
112              var current = Expression.Variable(typeof (IDictionary<string, object>));
113              var isDictionaryCollection = Expression.TypeIs(_itemProperty,
114                                                             typeof (IEnumerable<IDictionary<string, object>>));
115              var toArray = Expression.Assign(array,
116                                              Expression.Call(ToArrayDictionaryMethod,
117                                                              Expression.Convert(_itemProperty,
118                                                                                 typeof (IEnumerable<IDictionary<string, object>>))));
119              var start = Expression.Assign(i, Expression.Constant(0));
120              var label = Expression.Label();
121              var loop = Expression.Loop(
122                  Expression.IfThenElse(
123                      Expression.LessThan(i, Expression.Property(array, ArrayDictionaryLengthProperty)),
124                      Expression.Block(
125                          Expression.Assign(current, Expression.ArrayIndex(array, i)),
126                          Expression.Call(collection, addMethod,
127                                          Expression.Convert(Expression.Call(creator, CreatorCreateMethod, current), genericType)),
128                          Expression.PreIncrementAssign(i)
129                          ),
130                      Expression.Break(label)
131                      ),
132                  label
133                  );
134              block = Expression.Block(
135                  new[] {array, i, collection, current},
136                  createCollection,
137                  toArray,
138                  start,
139                  loop,
140                  _property.CanWrite ? (Expression) Expression.Assign(_nameProperty, collection) : Expression.Empty());
141              return isDictionaryCollection;
142          }
143          private TypeBinaryExpression BuildSimpleTypeCollectionPopulator(ParameterExpression collection, Type genericType,
144                                                               MethodInfo addMethod, BinaryExpression createCollection, 
145                                                               ConcreteTypeCreator creatorInstance, out BlockExpression block)
146          {
147              var creator = Expression.Constant(creatorInstance);
148              var array = Expression.Variable(typeof(object[]));
149              var i = Expression.Variable(typeof(int));
<span onclick='openModal()' class='match'>150              var current = Expression.Variable(typeof(object));
151              var isObjectCollection = Expression.TypeIs(_itemProperty,
</span>152                                                             typeof(IEnumerable<object>));
153              var toArray = Expression.Assign(array,
154                                              Expression.Call(ToArrayObjectMethod,
155                                                              Expression.Convert(_itemProperty,
156                                                                                 typeof(IEnumerable<object>))));
157              var start = Expression.Assign(i, Expression.Constant(0));
158              var label = Expression.Label();
159              var loop = Expression.Loop(
160                  Expression.IfThenElse(
161                      Expression.LessThan(i, Expression.Property(array, ArrayObjectLengthProperty)),
162                      Expression.Block(
163                          Expression.Assign(current, Expression.ArrayIndex(array, i)),
164                          Expression.IfThenElse(
165                              Expression.TypeIs(current, typeof(IDictionary<string,object>)),
166                              Expression.Call(collection, addMethod,
167                                          Expression.Convert(Expression.Call(creator, CreatorCreateMethod, 
168                                                  Expression.Convert(current, typeof(IDictionary<string,object>))), 
169                                              genericType)),
170                              Expression.Call(collection, addMethod,
171                                              Expression.Convert(current, genericType))),
172                          Expression.PreIncrementAssign(i)
173                          ),
174                      Expression.Break(label)
175                      ),
176                  label
177                  );
178              block = Expression.Block(
179                  new[] { array, i, collection, current },
180                  createCollection,
181                  toArray,
182                  start,
183                  loop,
184                  _property.CanWrite ? (Expression)Expression.Assign(_nameProperty, collection) : Expression.Empty());
185              return isObjectCollection;
186          }
187          private BinaryExpression MakeCreateNewCollection(ParameterExpression collection, Type genericType)
188          {
189              BinaryExpression createCollection;
190              if (_property.PropertyType.IsInterface)
191              {
192                  createCollection = Expression.Assign(collection,
193                                                       Expression.Call(
194                                                           typeof (PropertySetterBuilder).GetMethod("CreateList",
195                                                                                                    BindingFlags.
196                                                                                                        NonPublic |
197                                                                                                    BindingFlags.
198                                                                                                        Static).
199                                                               MakeGenericMethod(genericType)));
200              }
201              else
202              {
203                  var defaultConstructor = _property.PropertyType.GetConstructor(Type.EmptyTypes);
204                  if (defaultConstructor != null)
205                  {
206                      createCollection = Expression.Assign(collection, Expression.New(defaultConstructor));
207                  }
208                  else
209                  {
210                      createCollection = null;
211                  }
212              }
213              return createCollection;
214          }
215          private bool PropertyIsPrimitive()
216          {
217              return _property.PropertyType.IsPrimitive || _property.PropertyType == typeof(string) ||
218                     _property.PropertyType == typeof(DateTime) || _property.PropertyType == typeof(byte[]) ||
219                     _property.PropertyType.IsEnum ||
220                     (_property.PropertyType.IsGenericType && _property.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>));
221          }
222          private void CreatePropertyExpressions()
223          {
224              var name = Expression.Constant(_property.Name, typeof(string));
225              _containsKey = Expression.Call(_param, DictionaryContainsKeyMethod, name);
226              _nameProperty = Expression.Property(_obj, _property);
227              _itemProperty = Expression.Property(_param, DictionaryIndexerProperty, name);
228          }
229          private CatchBlock CreateCatchBlock()
230          {
231              return Expression.Catch(typeof(Exception), Expression.Assign(_nameProperty,
232                                                                           Expression.Default(_property.PropertyType)));
233          }
234          private BinaryExpression CreateComplexAssign()
235          {
236              var creator = Expression.Constant(ConcreteTypeCreator.Get(_property.PropertyType));
237              var methodCallExpression = Expression.Call(creator, CreatorCreateMethod,
238                                                         Expression.Convert(_itemProperty,
239                                                                            typeof(IDictionary<string, object>)));
240              var complexAssign = Expression.Assign(_nameProperty,
241                                                    Expression.Convert(
242                                                        methodCallExpression, _property.PropertyType));
243              return complexAssign;
244          }
245          private TryExpression CreateTrySimpleAssign()
246          {
247              MethodCallExpression callConvert;
248              if (_property.PropertyType.IsEnum)
249              {
250                  var changeTypeMethod = typeof (PropertySetterBuilder).GetMethod("SafeConvert",
251                                                                                  BindingFlags.Static | BindingFlags.NonPublic);
252                  callConvert = Expression.Call(changeTypeMethod, _itemProperty,
253                                                Expression.Constant(_property.PropertyType.GetEnumUnderlyingType(), typeof(Type)));
254              }
255              else if (_property.PropertyType.IsGenericType && _property.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
256              {
257                  var changeTypeMethod = typeof (PropertySetterBuilder)
258                      .GetMethod("SafeConvertNullable", BindingFlags.Static | BindingFlags.NonPublic)
259                      .MakeGenericMethod(_property.PropertyType.GetGenericArguments().Single());
260                  callConvert = Expression.Call(changeTypeMethod, _itemProperty);
261              }
262              else
263              {
264                  var changeTypeMethod = typeof (PropertySetterBuilder).GetMethod("SafeConvert",
265                                                                                  BindingFlags.Static | BindingFlags.NonPublic);
266                  callConvert = Expression.Call(changeTypeMethod, _itemProperty,
267                                                Expression.Constant(_property.PropertyType, typeof(Type)));
268              }
269              var assign = Expression.Assign(_nameProperty, Expression.Convert(callConvert, _property.PropertyType));
270              if (_property.PropertyType.IsEnum)
271              {
272                  return Expression.TryCatch( 
273                      Expression.IfThenElse(Expression.TypeIs(_itemProperty, typeof (string)),
274                                            Expression.Assign(_nameProperty,
275                                                              Expression.Convert(Expression.Call(typeof (Enum).GetMethod("Parse", new[] {typeof(Type), typeof(string), typeof(bool)}),
276                                                                                                 Expression.Constant(_property.PropertyType, typeof(Type)),
277                                                                                                 Expression.Call(_itemProperty, typeof(object).GetMethod("ToString")), Expression.Constant(true)), _property.PropertyType)),
278                                            assign), Expression.Catch(typeof(Exception), Expression.Empty()));
279              }
280              return Expression.TryCatch( 
281                  assign, 
282                  CreateCatchBlock());
283          }
284          private TryExpression CreateTrySimpleArrayAssign()
285          {
286              var createArrayMethod = typeof (PropertySetterBuilder).GetMethod("CreateArray", BindingFlags.Static | BindingFlags.NonPublic)
287                  .MakeGenericMethod(_property.PropertyType.GetElementType());
288              var callConvert = Expression.Call(createArrayMethod, _itemProperty);
289              var assign = Expression.Assign(_nameProperty, Expression.Convert(callConvert, _property.PropertyType));
290              return Expression.TryCatch( 
291                  Expression.IfThenElse(Expression.TypeIs(_itemProperty, typeof (string)),
292                                        Expression.Assign(_nameProperty,
293                                                          Expression.Convert(Expression.Call(typeof (Enum).GetMethod("Parse", new[] {typeof(Type), typeof(string), typeof(bool)}),
294                                                                                             Expression.Constant(_property.PropertyType, typeof(Type)),
295                                                                                             Expression.Call(_itemProperty, typeof(object).GetMethod("ToString")), Expression.Constant(true)), _property.PropertyType)),
296                                        assign), Expression.Catch(typeof(Exception), Expression.Empty()));
297          }
298          internal static object SafeConvert(object source, Type targetType)
299          {
300              if (ReferenceEquals(source, null)) return null;
301              if (targetType.IsInstanceOfType(source)) return source;
302              if (source is string && targetType == typeof(Guid)) return TypeDescriptor.GetConverter(typeof(Guid)).ConvertFromInvariantString(source.ToString());
303              return Convert.ChangeType(source, targetType);
304          }
305          internal static T? SafeConvertNullable<T>(object source)
306              where T : struct 
307          {
308              if (ReferenceEquals(source, null)) return default(T?);
309              return (T) source;
310          }
311          private static T[] CreateArray<T>(object source)
312          {
313              if (ReferenceEquals(source, null)) return null;
314              var enumerable = source as IEnumerable;
315              if (ReferenceEquals(enumerable, null)) return null;
316              try
317              {
318                  return enumerable.Cast<T>().ToArray();
319              }
320              catch (InvalidCastException)
321              {
322                  return null;
323              }
324          }
325          private static List<T> CreateList<T>()
326          {
327              return new List<T>();
328          }
329      }
330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-PropertySetterBuilder.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-PropertySetterBuilder.cs</div>
                </div>
                <div class="column column_space"><pre><code>150              var current = Expression.Variable(typeof(object));
151              var isObjectCollection = Expression.TypeIs(_itemProperty,
</pre></code></div>
                <div class="column column_space"><pre><code>150              var current = Expression.Variable(typeof(object));
151              var isObjectCollection = Expression.TypeIs(_itemProperty,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    