
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.05924300603401%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-InternalTypeTests.cs</h3>
            <pre><code>1  using System.Threading.Tasks;
2  using NpgsqlTypes;
3  using NUnit.Framework;
4  namespace Npgsql.Tests.Types;
5  public class InternalTypeTests : MultiplexingTestBase
6  {
7      [Test]
8      public async Task Read_internal_char()
9      {
10          using var conn = await OpenConnectionAsync();
11          using var cmd = new NpgsqlCommand("SELECT typdelim FROM pg_type WHERE typname='int4'", conn);
12          using var reader = await cmd.ExecuteReaderAsync();
13          reader.Read();
14          Assert.That(reader.GetChar(0), Is.EqualTo(','));
15          Assert.That(reader.GetValue(0), Is.EqualTo(','));
16          Assert.That(reader.GetProviderSpecificValue(0), Is.EqualTo(','));
17          Assert.That(reader.GetFieldType(0), Is.EqualTo(typeof(char)));
18      }
19      [Test]
20      [TestCase(NpgsqlDbType.Oid)]
21      [TestCase(NpgsqlDbType.Regtype)]
22      [TestCase(NpgsqlDbType.Regconfig)]
23      public async Task Internal_uint_types(NpgsqlDbType npgsqlDbType)
24      {
25          var postgresType = npgsqlDbType.ToString().ToLowerInvariant();
26          using var conn = await OpenConnectionAsync();
27          using var cmd = new NpgsqlCommand($"SELECT @max, 4294967295::{postgresType}, @eight, 8::{postgresType}", conn);
28          cmd.Parameters.AddWithValue("max", npgsqlDbType, uint.MaxValue);
29          cmd.Parameters.AddWithValue("eight", npgsqlDbType, 8u);
30          using var reader = await cmd.ExecuteReaderAsync();
31          reader.Read();
32          for (var i = 0; i < reader.FieldCount; i++)
33              Assert.That(reader.GetFieldType(i), Is.EqualTo(typeof(uint)));
34          Assert.That(reader.GetValue(0), Is.EqualTo(uint.MaxValue));
35          Assert.That(reader.GetValue(1), Is.EqualTo(uint.MaxValue));
36          Assert.That(reader.GetValue(2), Is.EqualTo(8u));
37          Assert.That(reader.GetValue(3), Is.EqualTo(8u));
38      }
39      [Test]
40      public async Task Tid()
41      {
42          var expected = new NpgsqlTid(3, 5);
43          using var conn = await OpenConnectionAsync();
44          using var cmd = conn.CreateCommand();
45          cmd.CommandText = "SELECT '(1234,40000)'::tid, @p::tid";
46          cmd.Parameters.AddWithValue("p", NpgsqlDbType.Tid, expected);
47          using var reader = await cmd.ExecuteReaderAsync();
48          reader.Read();
49          Assert.AreEqual(1234, reader.GetFieldValue<NpgsqlTid>(0).BlockNumber);
50          Assert.AreEqual(40000, reader.GetFieldValue<NpgsqlTid>(0).OffsetNumber);
51          Assert.AreEqual(expected.BlockNumber, reader.GetFieldValue<NpgsqlTid>(1).BlockNumber);
52          Assert.AreEqual(expected.OffsetNumber, reader.GetFieldValue<NpgsqlTid>(1).OffsetNumber);
53      }
54      #region NpgsqlLogSequenceNumber / PgLsn
55      static readonly TestCaseData[] EqualsObjectCases = {
56          new TestCaseData(new NpgsqlLogSequenceNumber(1ul), null).Returns(false),
57          new TestCaseData(new NpgsqlLogSequenceNumber(1ul), new object()).Returns(false),
58          new TestCaseData(new NpgsqlLogSequenceNumber(1ul), 1ul).Returns(false), 
59          new TestCaseData(new NpgsqlLogSequenceNumber(1ul), "0/0").Returns(false), 
60          new TestCaseData(new NpgsqlLogSequenceNumber(1ul), new NpgsqlLogSequenceNumber(1ul)).Returns(true),
61      };
62      [Test, TestCaseSource(nameof(EqualsObjectCases))]
63      public bool NpgsqlLogSequenceNumber_equals(NpgsqlLogSequenceNumber lsn, object? obj)
64          => lsn.Equals(obj);
65      [Test]
66      public async Task NpgsqlLogSequenceNumber()
67      {
68          var expected1 = new NpgsqlLogSequenceNumber(42949672971ul);
69          Assert.AreEqual(expected1, NpgsqlTypes.NpgsqlLogSequenceNumber.Parse("A/B"));
70          await using var conn = await OpenConnectionAsync();
71          using var cmd = conn.CreateCommand();
72          cmd.CommandText = "SELECT 'A/B'::pg_lsn, @p::pg_lsn";
73          cmd.Parameters.AddWithValue("p", NpgsqlDbType.PgLsn, expected1);
74          await using var reader = await cmd.ExecuteReaderAsync();
<span onclick='openModal()' class='match'>75          reader.Read();
76          var result1 = reader.GetFieldValue<NpgsqlLogSequenceNumber>(0);
77          var result2 = reader.GetFieldValue<NpgsqlLogSequenceNumber>(1);
78          Assert.AreEqual(expected1, result1);
79          Assert.AreEqual(42949672971ul, (ulong)result1);
80          Assert.AreEqual("A/B", result1.ToString());
81          Assert.AreEqual(expected1, result2);
82          Assert.AreEqual(42949672971ul, (ulong)result2);
83          Assert.AreEqual("A/B", result2.ToString());
84      }
</span>85      #endregion NpgsqlLogSequenceNumber / PgLsn
86      public InternalTypeTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
87  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</h3>
            <pre><code>1  using Npgsql.BackendMessages;
2  using Npgsql.Internal;
3  using Npgsql.Tests.Support;
4  using Npgsql.TypeMapping;
5  using NpgsqlTypes;
6  using NUnit.Framework;
7  using System;
8  using System.Buffers.Binary;
9  using System.Data;
10  using System.Linq;
11  using System.Text;
12  using System.Threading;
13  using System.Threading.Tasks;
14  using static Npgsql.Tests.TestUtil;
15  namespace Npgsql.Tests;
16  public class CommandTests : MultiplexingTestBase
17  {
18      #region Legacy batching
19      [Test]
20      [TestCase(new[] { true }, TestName = "SingleQuery")]
21      [TestCase(new[] { false }, TestName = "SingleNonQuery")]
22      [TestCase(new[] { true, true }, TestName = "TwoQueries")]
23      [TestCase(new[] { false, false }, TestName = "TwoNonQueries")]
24      [TestCase(new[] { false, true }, TestName = "NonQueryQuery")]
25      [TestCase(new[] { true, false }, TestName = "QueryNonQuery")]
26      public async Task Multiple_statements(bool[] queries)
27      {
28          await using var conn = await OpenConnectionAsync();
29          var table = await CreateTempTable(conn, "name TEXT");
30          var sb = new StringBuilder();
31          foreach (var query in queries)
32              sb.Append(query ? "SELECT 1;" : $"UPDATE {table} SET name='yo' WHERE 1=0;");
33          var sql = sb.ToString();
34          foreach (var prepare in new[] { false, true })
35          {
36              await using var cmd = conn.CreateCommand();
37              cmd.CommandText = sql;
38              if (prepare && !IsMultiplexing)
39                  await cmd.PrepareAsync();
40              await using var reader = await cmd.ExecuteReaderAsync();
41              var numResultSets = queries.Count(q => q);
42              for (var i = 0; i < numResultSets; i++)
43              {
44                  Assert.That(await reader.ReadAsync(), Is.True);
45                  Assert.That(reader[0], Is.EqualTo(1));
46                  Assert.That(await reader.NextResultAsync(), Is.EqualTo(i != numResultSets - 1));
47              }
48          }
49      }
50      [Test]
51      public async Task Multiple_statements_with_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
52      {
53          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
54              return;
55          await using var conn = await OpenConnectionAsync();
56          await using var cmd = conn.CreateCommand();
57          cmd.CommandText = "SELECT @p1; SELECT @p2";
58          var p1 = new NpgsqlParameter("p1", NpgsqlDbType.Integer);
59          var p2 = new NpgsqlParameter("p2", NpgsqlDbType.Text);
60          cmd.Parameters.Add(p1);
61          cmd.Parameters.Add(p2);
62          if (prepare == PrepareOrNot.Prepared)
63              cmd.Prepare();
64          p1.Value = 8;
65          p2.Value = "foo";
66          await using var reader = await cmd.ExecuteReaderAsync();
67          Assert.That(await reader.ReadAsync(), Is.True);
68          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
69          Assert.That(await reader.NextResultAsync(), Is.True);
70          Assert.That(await reader.ReadAsync(), Is.True);
71          Assert.That(reader.GetString(0), Is.EqualTo("foo"));
72          Assert.That(await reader.NextResultAsync(), Is.False);
73      }
74      [Test]
75      public async Task SingleRow_legacy_batching([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
76      {
77          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
78              return;
79          using var conn = await OpenConnectionAsync();
80          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2", conn);
81          if (prepare == PrepareOrNot.Prepared)
82              cmd.Prepare();
83          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
84          Assert.That(reader.Read(), Is.True);
85          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
86          Assert.That(reader.Read(), Is.False);
87          Assert.That(reader.NextResult(), Is.False);
88      }
89      [Test, Description("Makes sure a later command can depend on an earlier one")]
90      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/641")]
91      public async Task Multiple_statements_with_dependencies()
92      {
93          using var conn = await OpenConnectionAsync();
94          var table = await CreateTempTable(conn, "a INT");
95          await conn.ExecuteNonQueryAsync($"ALTER TABLE {table} ADD COLUMN b INT; INSERT INTO {table} (b) VALUES (8)");
96          Assert.That(await conn.ExecuteScalarAsync($"SELECT b FROM {table}"), Is.EqualTo(8));
97      }
98      [Test, Description("Forces async write mode when the first statement in a multi-statement command is big")]
99      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/641")]
100      public async Task Multiple_statements_large_first_command()
101      {
102          using var conn = await OpenConnectionAsync();
103          using var cmd = new NpgsqlCommand($"SELECT repeat('X', {conn.Settings.WriteBufferSize}); SELECT @p", conn);
104          var expected1 = new string('X', conn.Settings.WriteBufferSize);
105          var expected2 = new string('Y', conn.Settings.WriteBufferSize);
106          cmd.Parameters.AddWithValue("p", expected2);
107          using var reader = await cmd.ExecuteReaderAsync();
108          reader.Read();
109          Assert.That(reader.GetString(0), Is.EqualTo(expected1));
110          reader.NextResult();
111          reader.Read();
112          Assert.That(reader.GetString(0), Is.EqualTo(expected2));
113      }
114      [Test]
115      [NonParallelizable] 
116      public async Task Legacy_batching_is_not_supported_when_EnableSqlParsing_is_disabled()
117      {
118          using var _ = DisableSqlRewriting();
119          using var conn = await OpenConnectionAsync();
120          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2", conn);
121          Assert.That(async () => await cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf<PostgresException>()
122              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
123      }
124      #endregion
125      #region Timeout
126      [Test, Description("Checks that CommandTimeout gets enforced as a socket timeout")]
127      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/327")]
128      public async Task Timeout()
129      {
130          if (IsMultiplexing)
131              return; 
132          await using var dataSource = CreateDataSource(csb => csb.CommandTimeout = 1);
133          await using var conn = await dataSource.OpenConnectionAsync();
134          await using var cmd = CreateSleepCommand(conn, 10);
135          Assert.That(() => cmd.ExecuteNonQuery(), Throws.Exception
136              .TypeOf<NpgsqlException>()
137              .With.InnerException.TypeOf<TimeoutException>()
138          );
139          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
140      }
141      [Test, Description("Times out an async operation, testing that cancellation occurs successfully")]
142      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/607")]
143      public async Task Timeout_async_soft()
144      {
145          if (IsMultiplexing)
146              return; 
147          await using var dataSource = CreateDataSource(csb => csb.CommandTimeout = 1);
148          await using var conn = await dataSource.OpenConnectionAsync();
149          await using var cmd = CreateSleepCommand(conn, 10);
150          Assert.That(async () => await cmd.ExecuteNonQueryAsync(),
151              Throws.Exception
152                  .TypeOf<NpgsqlException>()
153                  .With.InnerException.TypeOf<TimeoutException>());
154          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
155      }
156      [Test, Description("Times out an async operation, with unsuccessful cancellation (socket break)")]
157      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/607")]
158      public async Task Timeout_async_hard()
159      {
160          if (IsMultiplexing)
161              return; 
162          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
163          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
164          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
165          await using var conn = await dataSource.OpenConnectionAsync();
166          await postmasterMock.WaitForServerConnection();
167          var processId = conn.ProcessID;
168          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"),
169              Throws.Exception
170                  .TypeOf<NpgsqlException>()
171                  .With.InnerException.TypeOf<TimeoutException>());
172          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
173          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
174              Is.EqualTo(processId));
175      }
176      [Test]
177      public async Task Timeout_from_connection_string()
178      {
179          Assert.That(NpgsqlConnector.MinimumInternalCommandTimeout, Is.Not.EqualTo(NpgsqlCommand.DefaultTimeout));
180          var timeout = NpgsqlConnector.MinimumInternalCommandTimeout;
181          await using var dataSource = CreateDataSource(csb => csb.CommandTimeout = timeout);
182          await using var conn = await dataSource.OpenConnectionAsync();
183          await using var command = new NpgsqlCommand("SELECT 1", conn);
184          Assert.That(command.CommandTimeout, Is.EqualTo(timeout));
185          command.CommandTimeout = 10;
186          await command.ExecuteScalarAsync();
187          Assert.That(command.CommandTimeout, Is.EqualTo(10));
188      }
189      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/395")]
190      public async Task Timeout_switch_connection()
191      {
192          var csb = new NpgsqlConnectionStringBuilder(ConnectionString);
193          if (csb.CommandTimeout >= 100 && csb.CommandTimeout < 105)
194              IgnoreExceptOnBuildServer("Bad default command timeout");
195          await using var dataSource1 = CreateDataSource(ConnectionString + ";CommandTimeout=100");
196          await using var c1 = dataSource1.CreateConnection();
197          await using var cmd = c1.CreateCommand();
198          Assert.That(cmd.CommandTimeout, Is.EqualTo(100));
199          await using var dataSource2 = CreateDataSource(ConnectionString + ";CommandTimeout=101");
200          await using (var c2 = dataSource2.CreateConnection())
201          {
202              cmd.Connection = c2;
203              Assert.That(cmd.CommandTimeout, Is.EqualTo(101));
204          }
205          cmd.CommandTimeout = 102;
206          await using (var c2 = dataSource2.CreateConnection())
207          {
208              cmd.Connection = c2;
209              Assert.That(cmd.CommandTimeout, Is.EqualTo(102));
210          }
211      }
212      [Test]
213      public async Task Prepare_timeout_hard([Values] SyncOrAsync async)
214      {
215          if (IsMultiplexing)
216              return; 
217          var builder = new NpgsqlConnectionStringBuilder(ConnectionString) { CommandTimeout = 1 };
218          await using var postmasterMock = PgPostmasterMock.Start(builder.ConnectionString);
219          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
220          await using var conn = await dataSource.OpenConnectionAsync();
221          await postmasterMock.WaitForServerConnection();
222          var processId = conn.ProcessID;
223          var cmd = new NpgsqlCommand("SELECT 1", conn);
224          Assert.That(async () =>
225              {
226                  if (async == SyncOrAsync.Sync)
227                      cmd.Prepare();
228                  else
229                      await cmd.PrepareAsync();
230              },
231              Throws.Exception
232                  .TypeOf<NpgsqlException>()
233                  .With.InnerException.TypeOf<TimeoutException>());
234          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
235          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
236              Is.EqualTo(processId));
237      }
238      #endregion
239      #region Cancel
240      [Test, Description("Basic cancellation scenario")]
241      public async Task Cancel()
242      {
243          if (IsMultiplexing)
244              return;
<span onclick='openModal()' class='match'>245          await using var conn = await OpenConnectionAsync();
246          await using var cmd = CreateSleepCommand(conn, 5);
247          var queryTask = Task.Run(() => cmd.ExecuteNonQuery());
248          cmd.WaitUntilCommandIsInProgress();
249          cmd.Cancel();
250          Assert.That(async () => await queryTask, Throws
251              .TypeOf<OperationCanceledException>()
252              .With.InnerException.TypeOf<PostgresException>()
253              .With.InnerException.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled)
254          );
255      }
</span>256      [Test]
257      public async Task Cancel_async_immediately()
258      {
259          if (IsMultiplexing)
260              return; 
261          await using var conn = await OpenConnectionAsync();
262          await using var cmd = conn.CreateCommand();
263          cmd.CommandText = "SELECT 1";
264          var t = cmd.ExecuteScalarAsync(new(canceled: true));
265          Assert.That(t.IsCompleted, Is.True); 
266          Assert.That(t.Status, Is.EqualTo(TaskStatus.Canceled));
267          Assert.ThrowsAsync<OperationCanceledException>(async () => await t);
268          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
269          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
270      }
271      [Test, Description("Cancels an async query with the cancellation token, with successful PG cancellation")]
272      [Explicit("Flaky due to #5033")]
273      public async Task Cancel_async_soft()
274      {
275          if (IsMultiplexing)
276              return; 
277          await using var conn = await OpenConnectionAsync();
278          await using var cmd = CreateSleepCommand(conn);
279          using var cancellationSource = new CancellationTokenSource();
280          var t = cmd.ExecuteNonQueryAsync(cancellationSource.Token);
281          cancellationSource.Cancel();
282          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await t)!;
283          Assert.That(exception.InnerException,
284              Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
285          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
286          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
287          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
288      }
289      [Test, Description("Cancels an async query with the cancellation token, with unsuccessful PG cancellation (socket break)")]
290      public async Task Cancel_async_hard()
291      {
292          if (IsMultiplexing)
293              return; 
294          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
295          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
296          await using var conn = await dataSource.OpenConnectionAsync();
297          await postmasterMock.WaitForServerConnection();
298          var processId = conn.ProcessID;
299          using var cancellationSource = new CancellationTokenSource();
300          using var cmd = new NpgsqlCommand("SELECT 1", conn);
301          var t = cmd.ExecuteScalarAsync(cancellationSource.Token);
302          cancellationSource.Cancel();
303          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await t)!;
304          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
305          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
306          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
307          Assert.That((await postmasterMock.WaitForCancellationRequest()).ProcessId,
308              Is.EqualTo(processId));
309      }
310      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3466")]
311      [Ignore("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4668")]
312      public async Task Bug3466([Values(false, true)] bool isBroken)
313      {
314          if (IsMultiplexing)
315              return; 
316          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
317          {
318              Pooling = false
319          };
320          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString(), completeCancellationImmediately: false);
321          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
322          await using var conn = await dataSource.OpenConnectionAsync();
323          var serverMock = await postmasterMock.WaitForServerConnection();
324          var processId = conn.ProcessID;
325          using var cancellationSource = new CancellationTokenSource();
326          await using var cmd = new NpgsqlCommand("SELECT 1", conn)
327          {
328              CommandTimeout = 4
329          };
330          var t = Task.Run(() => cmd.ExecuteScalar());
331          cmd.WaitUntilCommandIsInProgress();
332          var cancelTask = Task.Run(() => cmd.Cancel());
333          var cancellationRequest = await postmasterMock.WaitForCancellationRequest();
334          if (isBroken)
335          {
336              Assert.ThrowsAsync<OperationCanceledException>(async () => await t);
337              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
338          }
339          else
340          {
341              await serverMock
342                  .WriteParseComplete()
343                  .WriteBindComplete()
344                  .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
345                  .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
346                  .WriteCommandComplete()
347                  .WriteReadyForQuery()
348                  .FlushAsync();
349              Assert.DoesNotThrowAsync(async () => await t);
350              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
351              await conn.CloseAsync();
352          }
353          cancellationRequest.Complete();
354          Assert.DoesNotThrowAsync(async () => await cancelTask);
355      }
356      [Test, Description("Check that cancel only affects the command on which its was invoked")]
357      [Explicit("Timing-sensitive")]
358      public async Task Cancel_cross_command()
359      {
360          await using var conn = await OpenConnectionAsync();
361          await using var cmd1 = CreateSleepCommand(conn, 2);
362          await using var cmd2 = new NpgsqlCommand("SELECT 1", conn);
363          var cancelTask = Task.Factory.StartNew(() =>
364          {
365              Thread.Sleep(300);
366              cmd2.Cancel();
367          });
368          Assert.That(() => cmd1.ExecuteNonQueryAsync(), Throws.Nothing);
369          cancelTask.Wait();
370      }
371      #endregion
372      #region Cursors
373      [Test]
374      public async Task Cursor_statement()
375      {
376          using var conn = await OpenConnectionAsync();
377          var table = await CreateTempTable(conn, "name TEXT");
378          using var t = conn.BeginTransaction();
379          for (var x = 0; x < 5; x++)
380              await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES ('X')");
381          var i = 0;
382          var command = new NpgsqlCommand($"DECLARE TE CURSOR FOR SELECT * FROM {table}", conn);
383          command.ExecuteNonQuery();
384          command.CommandText = "FETCH FORWARD 3 IN TE";
385          var dr = command.ExecuteReader();
386          while (dr.Read())
387              i++;
388          Assert.AreEqual(3, i);
389          dr.Close();
390          i = 0;
391          command.CommandText = "FETCH BACKWARD 1 IN TE";
392          var dr2 = command.ExecuteReader();
393          while (dr2.Read())
394              i++;
395          Assert.AreEqual(1, i);
396          dr2.Close();
397          command.CommandText = "close te;";
398          command.ExecuteNonQuery();
399      }
400      [Test]
401      public async Task Cursor_move_RecordsAffected()
402      {
403          using var connection = await OpenConnectionAsync();
404          using var transaction = connection.BeginTransaction();
405          var command = new NpgsqlCommand("DECLARE curs CURSOR FOR SELECT * FROM (VALUES (1), (2), (3)) as t", connection);
406          command.ExecuteNonQuery();
407          command.CommandText = "MOVE FORWARD ALL IN curs";
408          var count = command.ExecuteNonQuery();
409          Assert.AreEqual(3, count);
410      }
411      #endregion
412      #region CommandBehavior.CloseConnection
413      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/693")]
414      public async Task CloseConnection()
415      {
416          using var conn = await OpenConnectionAsync();
417          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
418          using (var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection))
419              while (reader.Read()) {}
420          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
421      }
422      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1194")]
423      public async Task CloseConnection_with_open_reader_with_CloseConnection()
424      {
425          using var conn = await OpenConnectionAsync();
426          var cmd = new NpgsqlCommand("SELECT 1", conn);
427          var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection);
428          var wasClosed = false;
429          reader.ReaderClosed += (sender, args) => { wasClosed = true; };
430          conn.Close();
431          Assert.That(wasClosed, Is.True);
432      }
433      [Test]
434      public async Task CloseConnection_with_exception()
435      {
436          using var conn = await OpenConnectionAsync();
437          using (var cmd = new NpgsqlCommand("SE", conn))
438              Assert.That(() => cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection), Throws.Exception.TypeOf<PostgresException>());
439          Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
440      }
441      #endregion
442      [Test]
443      public async Task SingleRow([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
444      {
445          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
446              return;
447          await using var conn = await OpenConnectionAsync();
448          await using var cmd = new NpgsqlCommand("SELECT 1, 2 UNION SELECT 3, 4", conn);
449          if (prepare == PrepareOrNot.Prepared)
450              cmd.Prepare();
451          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SingleRow);
452          Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidOperationException>());
453          Assert.That(reader.Read(), Is.True);
454          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
455          Assert.That(reader.Read(), Is.False);
456      }
457      #region Parameters
458      [Test]
459      public async Task Positional_parameter()
460      {
461          await using var conn = await OpenConnectionAsync();
462          await using var cmd = new NpgsqlCommand("SELECT $1", conn);
463          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
464          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
465      }
466      [Test]
467      public async Task Positional_parameters_are_not_supported_with_legacy_batching()
468      {
469          await using var conn = await OpenConnectionAsync();
470          await using var cmd = new NpgsqlCommand("SELECT $1; SELECT $1", conn);
471          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
472          Assert.That(async () => await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<PostgresException>()
473              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.SyntaxError));
474      }
475      [Test]
476      [NonParallelizable] 
477      public async Task Positional_parameters_are_supported_when_EnableSqlParsing_is_disabled()
478      {
479          using var _ = DisableSqlRewriting();
480          using var conn = await OpenConnectionAsync();
481          using var cmd = new NpgsqlCommand("SELECT $1", conn);
482          cmd.Parameters.Add(new NpgsqlParameter { NpgsqlDbType = NpgsqlDbType.Integer, Value = 8 });
483          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(8));
484      }
485      [Test]
486      [NonParallelizable] 
487      public async Task Named_parameters_are_not_supported_when_EnableSqlParsing_is_disabled()
488      {
489          using var _ = DisableSqlRewriting();
490          using var conn = await OpenConnectionAsync();
491          using var cmd = new NpgsqlCommand("SELECT @p", conn);
492          cmd.Parameters.Add(new NpgsqlParameter("p", 8));
493          Assert.That(async () => await cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<NotSupportedException>());
494      }
495      [Test, Description("Makes sure writing an unset parameter isn't allowed")]
496      public async Task Parameter_without_Value()
497      {
498          using var conn = await OpenConnectionAsync();
499          using var cmd = new NpgsqlCommand("SELECT @p", conn);
500          cmd.Parameters.Add(new NpgsqlParameter("@p", NpgsqlDbType.Integer));
501          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<InvalidCastException>());
502      }
503      [Test]
504      public async Task Unreferenced_named_parameter_works()
505      {
506          await using var conn = await OpenConnectionAsync();
507          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
508          cmd.Parameters.AddWithValue("not_used", 8);
509          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
510      }
511      [Test]
512      public async Task Unreferenced_positional_parameter_works()
513      {
514          await using var conn = await OpenConnectionAsync();
515          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
516          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
517          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
518      }
519      [Test]
520      public async Task Mixing_positional_and_named_parameters_is_not_supported()
521      {
522          await using var conn = await OpenConnectionAsync();
523          await using var cmd = new NpgsqlCommand("SELECT $1, @p", conn);
524          cmd.Parameters.Add(new NpgsqlParameter { Value = 8 });
525          cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p", Value = 9 });
526          Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf<NotSupportedException>());
527      }
528      [Test]
529      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4171")]
530      public async Task Cached_command_clears_parameters_placeholder_type()
531      {
532          await using var conn = await OpenConnectionAsync();
533          await using (var cmd1 = conn.CreateCommand())
534          {
535              cmd1.CommandText = "SELECT @p1";
536              cmd1.Parameters.AddWithValue("@p1", 8);
537              await using var reader1 = await cmd1.ExecuteReaderAsync();
538              reader1.Read();
539              Assert.That(reader1[0], Is.EqualTo(8));
540          }
541          await using (var cmd2 = conn.CreateCommand())
542          {
543              cmd2.CommandText = "SELECT $1";
544              cmd2.Parameters.AddWithValue(8);
545              await using var reader2 = await cmd2.ExecuteReaderAsync();
546              reader2.Read();
547              Assert.That(reader2[0], Is.EqualTo(8));
548          }
549      }
550      [Test]
551      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4171")]
552      public async Task Reuse_command_with_different_parameter_placeholder_types()
553      {
554          await using var conn = await OpenConnectionAsync();
555          await using var cmd = conn.CreateCommand();
556          cmd.CommandText = "SELECT @p1";
557          cmd.Parameters.AddWithValue("@p1", 8);
558          _ = await cmd.ExecuteScalarAsync();
559          cmd.CommandText = "SELECT $1";
560          cmd.Parameters[0].ParameterName = null;
561          _ = await cmd.ExecuteScalarAsync();
562      }
563      [Test]
564      public async Task Positional_output_parameters_are_not_supported()
565      {
566          await using var conn = await OpenConnectionAsync();
567          await using var cmd = new NpgsqlCommand("SELECT $1", conn);
568          cmd.Parameters.Add(new NpgsqlParameter { Value = 8, Direction = ParameterDirection.InputOutput });
569          Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf<NotSupportedException>());
570      }
571      [Test]
572      public void Parameters_get_name()
573      {
574          var command = new NpgsqlCommand();
575          command.Parameters.Add(new NpgsqlParameter(":Parameter1", DbType.Boolean));
576          command.Parameters.Add(new NpgsqlParameter(":Parameter2", DbType.Int32));
577          command.Parameters.Add(new NpgsqlParameter(":Parameter3", DbType.DateTime));
578          command.Parameters.Add(new NpgsqlParameter("Parameter4", DbType.DateTime));
579          var idbPrmtr = command.Parameters["Parameter1"];
580          Assert.IsNotNull(idbPrmtr);
581          command.Parameters[0].Value = 1;
582          Assert.AreEqual(":Parameter1", command.Parameters["Parameter1"].ParameterName);
583          Assert.AreEqual(":Parameter2", command.Parameters["Parameter2"].ParameterName);
584          Assert.AreEqual(":Parameter3", command.Parameters["Parameter3"].ParameterName);
585          Assert.AreEqual("Parameter4", command.Parameters["Parameter4"].ParameterName); 
586          Assert.AreEqual(":Parameter1", command.Parameters[0].ParameterName);
587          Assert.AreEqual(":Parameter2", command.Parameters[1].ParameterName);
588          Assert.AreEqual(":Parameter3", command.Parameters[2].ParameterName);
589          Assert.AreEqual("Parameter4", command.Parameters[3].ParameterName);
590      }
591      [Test]
592      public async Task Same_param_multiple_times()
593      {
594          using var conn = await OpenConnectionAsync();
595          using var cmd = new NpgsqlCommand("SELECT @p1, @p1", conn);
596          cmd.Parameters.AddWithValue("@p1", 8);
597          using var reader = await cmd.ExecuteReaderAsync();
598          reader.Read();
599          Assert.That(reader[0], Is.EqualTo(8));
600          Assert.That(reader[1], Is.EqualTo(8));
601      }
602      [Test]
603      public async Task Generic_parameter()
604      {
605          using var conn = await OpenConnectionAsync();
606          using var cmd = new NpgsqlCommand("SELECT @p1, @p2, @p3, @p4", conn);
607          cmd.Parameters.Add(new NpgsqlParameter<int>("p1", 8));
608          cmd.Parameters.Add(new NpgsqlParameter<short>("p2", 8) { NpgsqlDbType = NpgsqlDbType.Integer });
609          cmd.Parameters.Add(new NpgsqlParameter<string>("p3", "hello"));
610          cmd.Parameters.Add(new NpgsqlParameter<char[]>("p4", new[] { 'f', 'o', 'o' }));
611          using var reader = await cmd.ExecuteReaderAsync();
612          reader.Read();
613          Assert.That(reader.GetInt32(0), Is.EqualTo(8));
614          Assert.That(reader.GetInt32(1), Is.EqualTo(8));
615          Assert.That(reader.GetString(2), Is.EqualTo("hello"));
616          Assert.That(reader.GetString(3), Is.EqualTo("foo"));
617      }
618      #endregion Parameters
619      [Test]
620      public async Task CommandText_not_set()
621      {
622          await using var conn = await OpenConnectionAsync();
623          await using (var cmd = new NpgsqlCommand())
624          {
625              cmd.Connection = conn;
626              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf<InvalidOperationException>());
627              cmd.CommandText = null;
628              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf<InvalidOperationException>());
629              cmd.CommandText = "";
630          }
631          await using (var cmd = conn.CreateCommand())
632              Assert.That(cmd.ExecuteNonQueryAsync, Throws.Exception.TypeOf<InvalidOperationException>());
633      }
634      [Test]
635      public async Task ExecuteScalar()
636      {
637          await using var conn = await OpenConnectionAsync();
638          var table = await CreateTempTable(conn, "name TEXT");
639          await using var command = new NpgsqlCommand($"SELECT name FROM {table}", conn);
640          Assert.That(command.ExecuteScalarAsync, Is.Null);
641          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES (NULL)");
642          Assert.That(command.ExecuteScalarAsync, Is.EqualTo(DBNull.Value));
643          await conn.ExecuteNonQueryAsync($"TRUNCATE {table}");
644          for (var i = 0; i < 2; i++)
645              await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES ('X')");
646          Assert.That(command.ExecuteScalarAsync, Is.EqualTo("X"));
647      }
648      [Test]
649      public async Task ExecuteNonQuery()
650      {
651          await using var conn = await OpenConnectionAsync();
652          await using var cmd = new NpgsqlCommand { Connection = conn };
653          var table = await CreateTempTable(conn, "name TEXT");
654          cmd.CommandText = $"INSERT INTO {table} (name) VALUES ('John')";
655          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
656          cmd.CommandText = $"INSERT INTO {table} (name) VALUES ('John'); INSERT INTO {table} (name) VALUES ('John')";
657          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(2));
658          cmd.CommandText = $"INSERT INTO {table} (name) VALUES ('{new string('x', conn.Settings.WriteBufferSize)}')";
659          Assert.That(cmd.ExecuteNonQueryAsync, Is.EqualTo(1));
660      }
661      [Test, Description("Makes sure a command is unusable after it is disposed")]
662      public async Task Dispose()
663      {
664          await using var conn = await OpenConnectionAsync();
665          var cmd = new NpgsqlCommand("SELECT 1", conn);
666          cmd.Dispose();
667          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
668          Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
669          Assert.That(() => cmd.ExecuteReaderAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
670          Assert.That(() => cmd.PrepareAsync(), Throws.Exception.TypeOf<ObjectDisposedException>());
671      }
672      [Test, Description("Disposing a command with an open reader does not close the reader. This is the SqlClient behavior.")]
673      public async Task Command_Dispose_does_not_close_reader()
674      {
675          await using var conn = await OpenConnectionAsync();
676          var cmd = new NpgsqlCommand("SELECT 1, 2", conn);
677          await cmd.ExecuteReaderAsync();
678          cmd.Dispose();
679          cmd = new NpgsqlCommand("SELECT 3", conn);
680          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
681      }
682      [Test]
683      public async Task Non_standards_conforming_strings()
684      {
685          await using var dataSource = CreateDataSource();
686          await using var conn = await dataSource.OpenConnectionAsync();
687          if (IsMultiplexing)
688          {
689              Assert.That(async () => await conn.ExecuteNonQueryAsync("set standard_conforming_strings=off"),
690                  Throws.Exception.TypeOf<NotSupportedException>());
691          }
692          else
693          {
694              await conn.ExecuteNonQueryAsync("set standard_conforming_strings=off");
695              Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
696              await conn.ExecuteNonQueryAsync("set standard_conforming_strings=on");
697          }
698      }
699      [Test]
700      public async Task Parameter_and_operator_unclear()
701      {
702          await using var conn = await OpenConnectionAsync();
703          await using var command = new NpgsqlCommand("select :arr[2]", conn);
704          command.Parameters.AddWithValue(":arr", new int[] {5, 4, 3, 2, 1});
705          await using var rdr = await command.ExecuteReaderAsync();
706          rdr.Read();
707          Assert.AreEqual(rdr.GetInt32(0), 4);
708      }
709      [Test]
710      [TestCase(CommandBehavior.Default)]
711      [TestCase(CommandBehavior.SequentialAccess)]
712      public async Task Statement_mapped_output_parameters(CommandBehavior behavior)
713      {
714          await using var conn = await OpenConnectionAsync();
715          var command = new NpgsqlCommand("select 3, 4 as param1, 5 as param2, 6;", conn);
716          var p = new NpgsqlParameter("param2", NpgsqlDbType.Integer);
717          p.Direction = ParameterDirection.Output;
718          p.Value = -1;
719          command.Parameters.Add(p);
720          p = new NpgsqlParameter("param1", NpgsqlDbType.Integer);
721          p.Direction = ParameterDirection.Output;
722          p.Value = -1;
723          command.Parameters.Add(p);
724          p = new NpgsqlParameter("p", NpgsqlDbType.Integer);
725          p.Direction = ParameterDirection.Output;
726          p.Value = -1;
727          command.Parameters.Add(p);
728          await using var reader = await command.ExecuteReaderAsync(behavior);
729          Assert.AreEqual(4, command.Parameters["param1"].Value);
730          Assert.AreEqual(5, command.Parameters["param2"].Value);
731          reader.Read();
732          Assert.AreEqual(3, reader.GetInt32(0));
733          Assert.AreEqual(4, reader.GetInt32(1));
734          Assert.AreEqual(5, reader.GetInt32(2));
735          Assert.AreEqual(6, reader.GetInt32(3));
736      }
737      [Test]
738      public async Task Bug1006158_output_parameters()
739      {
740          await using var conn = await OpenConnectionAsync();
741          MinimumPgVersion(conn, "14.0", "Stored procedure OUT parameters are only support starting with version 14");
742          var sproc = await GetTempProcedureName(conn);
743          var createFunction = $@"
744  CREATE PROCEDURE {sproc}(OUT a integer, OUT b boolean) AS $$
745  BEGIN
746      a := 3;
747      b := true;
748  END
749  $$ LANGUAGE plpgsql;";
750          var command = new NpgsqlCommand(createFunction, conn);
751          await command.ExecuteNonQueryAsync();
752          command = new NpgsqlCommand(sproc, conn);
753          command.CommandType = CommandType.StoredProcedure;
754          command.Parameters.Add(new NpgsqlParameter("a", DbType.Int32));
755          command.Parameters[0].Direction = ParameterDirection.Output;
756          command.Parameters.Add(new NpgsqlParameter("b", DbType.Boolean));
757          command.Parameters[1].Direction = ParameterDirection.Output;
758          _ = await command.ExecuteScalarAsync();
759          Assert.AreEqual(3, command.Parameters[0].Value);
760          Assert.AreEqual(true, command.Parameters[1].Value);
761      }
762      [Test]
763      public async Task Bug1010788_UpdateRowSource()
764      {
765          if (IsMultiplexing)
766              return;
767          using var conn = await OpenConnectionAsync();
768          var table = await CreateTempTable(conn, "id SERIAL PRIMARY KEY, name TEXT");
769          var command = new NpgsqlCommand($"SELECT * FROM {table}", conn);
770          Assert.AreEqual(UpdateRowSource.Both, command.UpdatedRowSource);
771          var cmdBuilder = new NpgsqlCommandBuilder();
772          var da = new NpgsqlDataAdapter(command);
773          cmdBuilder.DataAdapter = da;
774          Assert.IsNotNull(da.SelectCommand);
775          Assert.IsNotNull(cmdBuilder.DataAdapter);
776          var updateCommand = cmdBuilder.GetUpdateCommand();
777          Assert.AreEqual(UpdateRowSource.None, updateCommand.UpdatedRowSource);
778      }
779      [Test]
780      public async Task TableDirect()
781      {
782          using var conn = await OpenConnectionAsync();
783          var table = await CreateTempTable(conn, "name TEXT");
784          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (name) VALUES ('foo')");
785          using var cmd = new NpgsqlCommand(table, conn) { CommandType = CommandType.TableDirect };
786          using var rdr = await cmd.ExecuteReaderAsync();
787          Assert.That(rdr.Read(), Is.True);
788          Assert.That(rdr["name"], Is.EqualTo("foo"));
789      }
790      [Test]
791      [TestCase(CommandBehavior.Default)]
792      [TestCase(CommandBehavior.SequentialAccess)]
793      public async Task Input_and_output_parameters(CommandBehavior behavior)
794      {
795          using var conn = await OpenConnectionAsync();
796          using var cmd = new NpgsqlCommand("SELECT @c-1 AS c, @a+2 AS b", conn);
797          cmd.Parameters.Add(new NpgsqlParameter("a", 3));
798          var b = new NpgsqlParameter { ParameterName = "b", Direction = ParameterDirection.Output };
799          cmd.Parameters.Add(b);
800          var c = new NpgsqlParameter { ParameterName = "c", Direction = ParameterDirection.InputOutput, Value = 4 };
801          cmd.Parameters.Add(c);
802          using (await cmd.ExecuteReaderAsync(behavior))
803          {
804              Assert.AreEqual(5, b.Value);
805              Assert.AreEqual(3, c.Value);
806          }
807      }
808      [Test]
809      public async Task Send_NpgsqlDbType_Unknown([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
810      {
811          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
812              return;
813          using var conn = await OpenConnectionAsync();
814          using var cmd = new NpgsqlCommand("SELECT @p::TIMESTAMP", conn);
815          cmd.CommandText = "SELECT @p::TIMESTAMP";
816          cmd.Parameters.Add(new NpgsqlParameter("p", NpgsqlDbType.Unknown) { Value = "2008-1-1" });
817          if (prepare == PrepareOrNot.Prepared)
818              cmd.Prepare();
819          using var reader = await cmd.ExecuteReaderAsync();
820          reader.Read();
821          Assert.That(reader.GetValue(0), Is.EqualTo(new DateTime(2008, 1, 1)));
822      }
823      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/503")]
824      public async Task Invalid_UTF8()
825      {
826          const string badString = "SELECT 'abc\uD801\uD802d'";
827          await using var dataSource = CreateDataSource();
828          using var conn = await dataSource.OpenConnectionAsync();
829          Assert.That(() => conn.ExecuteScalarAsync(badString), Throws.Exception.TypeOf<EncoderFallbackException>());
830      }
831      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/395")]
832      public async Task Use_across_connection_change([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
833      {
834          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
835              return;
836          using var conn1 = await OpenConnectionAsync();
837          using var conn2 = await OpenConnectionAsync();
838          using var cmd = new NpgsqlCommand("SELECT 1", conn1);
839          if (prepare == PrepareOrNot.Prepared)
840              cmd.Prepare();
841          cmd.Connection = conn2;
842          Assert.That(cmd.IsPrepared, Is.False);
843          if (prepare == PrepareOrNot.Prepared)
844              cmd.Prepare();
845          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
846      }
847      [Test, Description("CreateCommand before connection open")]
848      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/565")]
849      public async Task Create_command_before_connection_open()
850      {
851          using var conn = new NpgsqlConnection(ConnectionString);
852          var cmd = new NpgsqlCommand("SELECT 1", conn);
853          conn.Open();
854          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(1));
855      }
856      [Test]
857      public void Connection_not_set_throws()
858      {
859          var cmd = new NpgsqlCommand("SELECT 1");
860          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<InvalidOperationException>());
861      }
862      [Test]
863      public void Connection_not_open_throws()
864      {
865          using var conn = CreateConnection();
866          var cmd = new NpgsqlCommand("SELECT 1", conn);
867          Assert.That(() => cmd.ExecuteScalarAsync(), Throws.Exception.TypeOf<InvalidOperationException>());
868      }
869      [Test]
870      public async Task ExecuteNonQuery_Throws_PostgresException([Values] bool async)
871      {
872          if (!async && IsMultiplexing)
873              return;
874          await using var conn = await OpenConnectionAsync();
875          var table1 = await CreateTempTable(conn, "id integer PRIMARY key, t varchar(40)");
876          var table2 = await CreateTempTable(conn, $"id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED");
877          var sql = $"insert into {table2} ({table1}_id) values (1) returning id";
878          var ex = async
879              ? Assert.ThrowsAsync<PostgresException>(async () => await conn.ExecuteNonQueryAsync(sql))
880              : Assert.Throws<PostgresException>(() => conn.ExecuteNonQuery(sql));
881          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
882      }
883      [Test]
884      public async Task ExecuteScalar_Throws_PostgresException([Values] bool async)
885      {
886          if (!async && IsMultiplexing)
887              return;
888          await using var conn = await OpenConnectionAsync();
889          var table1 = await CreateTempTable(conn, "id integer PRIMARY key, t varchar(40)");
890          var table2 = await CreateTempTable(conn, $"id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED");
891          var sql = $"insert into {table2} ({table1}_id) values (1) returning id";
892          var ex = async
893              ? Assert.ThrowsAsync<PostgresException>(async () => await conn.ExecuteScalarAsync(sql))
894              : Assert.Throws<PostgresException>(() => conn.ExecuteScalar(sql));
895          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
896      }
897      [Test]
898      public async Task ExecuteReader_Throws_PostgresException([Values] bool async)
899      {
900          if (!async && IsMultiplexing)
901              return;
902          await using var conn = await OpenConnectionAsync();
903          var table1 = await CreateTempTable(conn, "id integer PRIMARY key, t varchar(40)");
904          var table2 = await CreateTempTable(conn, $"id SERIAL primary key, {table1}_id integer references {table1}(id) INITIALLY DEFERRED");
905          await using var cmd = conn.CreateCommand();
906          cmd.CommandText = $"insert into {table2} ({table1}_id) values (1) returning id";
907          await using var reader = async
908              ? await cmd.ExecuteReaderAsync()
909              : cmd.ExecuteReader();
910          Assert.IsTrue(async ? await reader.ReadAsync() : reader.Read());
911          var value = reader.GetInt32(0);
912          Assert.That(value, Is.EqualTo(1));
913          Assert.IsFalse(async ? await reader.ReadAsync() : reader.Read());
914          var ex = async
915              ? Assert.ThrowsAsync<PostgresException>(async () => await reader.NextResultAsync())
916              : Assert.Throws<PostgresException>(() => reader.NextResult());
917          Assert.That(ex!.SqlState, Is.EqualTo(PostgresErrorCodes.ForeignKeyViolation));
918      }
919      [Test]
920      public void Command_is_recycled()
921      {
922          using var conn = OpenConnection();
923          var cmd1 = conn.CreateCommand();
924          cmd1.CommandText = "SELECT @p1";
925          var tx = conn.BeginTransaction();
926          cmd1.Transaction = tx;
927          cmd1.Parameters.AddWithValue("p1", 8);
928          _ = cmd1.ExecuteScalar();
929          cmd1.Dispose();
930          var cmd2 = conn.CreateCommand();
931          Assert.That(cmd2, Is.SameAs(cmd1));
932          Assert.That(cmd2.CommandText, Is.Empty);
933          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
934          Assert.That(cmd2.Transaction, Is.Null);
935          Assert.That(cmd2.Parameters, Is.Empty);
936      }
937      [Test]
938      public void Command_recycled_resets_CommandType()
939      {
940          using var conn = CreateConnection();
941          var cmd1 = conn.CreateCommand();
942          cmd1.CommandType = CommandType.StoredProcedure;
943          cmd1.Dispose();
944          var cmd2 = conn.CreateCommand();
945          Assert.That(cmd2.CommandType, Is.EqualTo(CommandType.Text));
946      }
947      [Test]
948      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/831")]
949      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2795")]
950      public async Task Many_parameters([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
951      {
952          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
953              return;
954          using var conn = await OpenConnectionAsync();
955          var table = await CreateTempTable(conn, "some_column INT");
956          using var cmd = new NpgsqlCommand { Connection = conn };
957          var sb = new StringBuilder($"INSERT INTO {table} (some_column) VALUES ");
958          for (var i = 0; i < ushort.MaxValue; i++)
959          {
960              var paramName = "p" + i;
961              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
962              if (i > 0)
963                  sb.Append(", ");
964              sb.Append($"(@{paramName})");
965          }
966          cmd.CommandText = sb.ToString();
967          if (prepare == PrepareOrNot.Prepared)
968              cmd.Prepare();
969          await cmd.ExecuteNonQueryAsync();
970      }
971      [Test, Description("Bypasses PostgreSQL's uint16 limitation on the number of parameters")]
972      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/831")]
973      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/858")]
974      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2703")]
975      public async Task Too_many_parameters_throws([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
976      {
977          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
978              return;
979          using var conn = await OpenConnectionAsync();
980          using var cmd = new NpgsqlCommand { Connection = conn };
981          var sb = new StringBuilder("SOME RANDOM SQL ");
982          for (var i = 0; i < ushort.MaxValue + 1; i++)
983          {
984              var paramName = "p" + i;
985              cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
986              if (i > 0)
987                  sb.Append(", ");
988              sb.Append('@');
989              sb.Append(paramName);
990          }
991          cmd.CommandText = sb.ToString();
992          if (prepare == PrepareOrNot.Prepared)
993          {
994              Assert.That(() => cmd.Prepare(), Throws.Exception
995                  .InstanceOf<NpgsqlException>()
996                  .With.Message.EqualTo("A statement cannot have more than 65535 parameters"));
997          }
998          else
999          {
1000              Assert.That(() => cmd.ExecuteNonQueryAsync(), Throws.Exception
1001                  .InstanceOf<NpgsqlException>()
1002                  .With.Message.EqualTo("A statement cannot have more than 65535 parameters"));
1003          }
1004      }
1005      [Test, Description("An individual statement cannot have more than 65535 parameters, but a command can (across multiple statements).")]
1006      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1199")]
1007      public async Task Many_parameters_across_statements()
1008      {
1009          using var conn = await OpenConnectionAsync();
1010          using var cmd = new NpgsqlCommand { Connection = conn };
1011          var paramIndex = 0;
1012          var sb = new StringBuilder();
1013          for (var statementIndex = 0; statementIndex < 1000; statementIndex++)
1014          {
1015              if (statementIndex > 0)
1016                  sb.Append("; ");
1017              sb.Append("SELECT ");
1018              var startIndex = paramIndex;
1019              var endIndex = paramIndex + 70;
1020              for (; paramIndex < endIndex; paramIndex++)
1021              {
1022                  var paramName = "p" + paramIndex;
1023                  cmd.Parameters.Add(new NpgsqlParameter(paramName, 8));
1024                  if (paramIndex > startIndex)
1025                      sb.Append(", ");
1026                  sb.Append('@');
1027                  sb.Append(paramName);
1028              }
1029          }
1030          cmd.CommandText = sb.ToString();
1031          await cmd.ExecuteNonQueryAsync();
1032      }
1033      [Test, Description("Makes sure that Npgsql doesn't attempt to send all data before the user can start reading. That would cause a deadlock.")]
1034      public async Task Batched_big_statements_do_not_deadlock()
1035      {
1036          var data = new string('x', 1024);
1037          using var conn = await OpenConnectionAsync();
1038          var sb = new StringBuilder();
1039          for (var i = 0; i < 500; i++)
1040              sb.Append("SELECT @p;");
1041          using var cmd = new NpgsqlCommand(sb.ToString(), conn);
1042          cmd.Parameters.AddWithValue("p", NpgsqlDbType.Text, data);
1043          using var reader = await cmd.ExecuteReaderAsync();
1044          for (var i = 0; i < 500; i++)
1045          {
1046              reader.Read();
1047              Assert.That(reader.GetString(0), Is.EqualTo(data));
1048              reader.NextResult();
1049          }
1050      }
1051      [Test]
1052      public void Batched_small_then_big_statements_do_not_deadlock_in_sync_io()
1053      {
1054          if (IsMultiplexing)
1055              return; 
1056          using var conn = OpenConnection();
1057          var data = new string('x', 5_000_000);
1058          using var cmd = new NpgsqlCommand("SELECT generate_series(1, 500000); SELECT @p", conn);
1059          cmd.Parameters.AddWithValue("p", NpgsqlDbType.Text, data);
1060          cmd.ExecuteNonQuery();
1061      }
1062      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1429")]
1063      public async Task Same_command_different_param_values()
1064      {
1065          using var conn = await OpenConnectionAsync();
1066          using var cmd = new NpgsqlCommand("SELECT @p", conn);
1067          cmd.Parameters.AddWithValue("p", 8);
1068          await cmd.ExecuteNonQueryAsync();
1069          cmd.Parameters[0].Value = 9;
1070          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1071      }
1072      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1429")]
1073      public async Task Same_command_different_param_instances()
1074      {
1075          using var conn = await OpenConnectionAsync();
1076          using var cmd = new NpgsqlCommand("SELECT @p", conn);
1077          cmd.Parameters.AddWithValue("p", 8);
1078          await cmd.ExecuteNonQueryAsync();
1079          cmd.Parameters.RemoveAt(0);
1080          cmd.Parameters.AddWithValue("p", 9);
1081          Assert.That(await cmd.ExecuteScalarAsync(), Is.EqualTo(9));
1082      }
1083      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3509"), Ignore("Flaky")]
1084      public async Task Bug3509()
1085      {
1086          if (IsMultiplexing)
1087              return;
1088          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1089          {
1090              KeepAlive = 1,
1091          };
1092          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1093          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1094          await using var conn = await dataSource.OpenConnectionAsync();
1095          var serverMock = await postmasterMock.WaitForServerConnection();
1096          await serverMock.WaitForData();
1097          var queryTask = Task.Run(async () => await conn.ExecuteNonQueryAsync("SELECT 1"));
1098          await Task.Delay(300);
1099          await serverMock
1100              .WriteErrorResponse("42")
1101              .WriteReadyForQuery()
1102              .FlushAsync();
1103          await serverMock
1104              .WriteScalarResponseAndFlush(1);
1105          var ex = Assert.ThrowsAsync<NpgsqlException>(async () => await queryTask)!;
1106          Assert.That(ex.InnerException, Is.TypeOf<NpgsqlException>()
1107              .With.InnerException.TypeOf<PostgresException>());
1108      }
1109      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4134")]
1110      public async Task Cached_command_double_dispose()
1111      {
1112          await using var conn = await OpenConnectionAsync();
1113          var cmd1 = conn.CreateCommand();
1114          cmd1.Dispose();
1115          cmd1.Dispose();
1116          var cmd2 = conn.CreateCommand();
1117          Assert.That(cmd2, Is.SameAs(cmd1));
1118          cmd2.CommandText = "SELECT 1";
1119          Assert.That(await cmd2.ExecuteScalarAsync(), Is.EqualTo(1));
1120      }
1121      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4330")]
1122      public async Task Prepare_with_positional_placeholders_after_named()
1123      {
1124          if (IsMultiplexing)
1125              return; 
1126          await using var conn = await OpenConnectionAsync();
1127          await using var command = new NpgsqlCommand("SELECT @p", conn);
1128          command.Parameters.AddWithValue("p", 10);
1129          await command.ExecuteNonQueryAsync();
1130          command.Parameters.Clear();
1131          command.CommandText = "SELECT $1";
1132          command.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer });
1133          Assert.DoesNotThrowAsync(() => command.PrepareAsync());
1134      }
1135      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4621")]
1136      [Description("Most of 08* errors are coming whenever there was an error while connecting to a remote server from a cluster, so the connection to the cluster is still OK")]
1137      public async Task Postgres_connection_errors_not_break_connection()
1138      {
1139          if (IsMultiplexing)
1140              return;
1141          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1142          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1143          await using var conn = await dataSource.OpenConnectionAsync();
1144          await using var cmd = conn.CreateCommand();
1145          cmd.CommandText = "SELECT 1";
1146          var queryTask = cmd.ExecuteNonQueryAsync();
1147          var server = await postmasterMock.WaitForServerConnection();
1148          await server
1149              .WriteErrorResponse(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection)
1150              .WriteReadyForQuery()
1151              .FlushAsync();
1152          var ex = Assert.ThrowsAsync<PostgresException>(async () => await queryTask)!;
1153          Assert.That(ex.SqlState, Is.EqualTo(PostgresErrorCodes.SqlClientUnableToEstablishSqlConnection));
1154          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open));
1155      }
1156      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4804")]
1157      [Description("Concurrent write and read failure can lead to deadlocks while cleaning up the connector.")]
1158      public async Task Concurrent_read_write_failure_deadlock()
1159      {
1160          if (IsMultiplexing)
1161              return;
1162          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1163          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1164          await using var conn = await dataSource.OpenConnectionAsync();
1165          await using var cmd = conn.CreateCommand();
1166          cmd.CommandText = new string('a', 8_000_000);
1167          var queryTask = cmd.ExecuteNonQueryAsync();
1168          var server = await postmasterMock.WaitForServerConnection();
1169          server.Close();
1170          Assert.ThrowsAsync<NpgsqlException>(async () => await queryTask);
1171      }
1172      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4906")]
1173      [Description("Make sure we don't cancel a prepended query (and do not deadlock in case of a failure)")]
1174      [Explicit("Flaky due to #5033")]
1175      public async Task Not_cancel_prepended_query([Values] bool failPrependedQuery)
1176      {
1177          if (IsMultiplexing)
1178              return;
1179          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1180          var csb = new NpgsqlConnectionStringBuilder(postmasterMock.ConnectionString)
1181          {
1182              NoResetOnClose = false
1183          };
1184          await using var dataSource = CreateDataSource(csb.ConnectionString);
1185          await using var conn = await dataSource.OpenConnectionAsync();
1186          await conn.CloseAsync();
1187          await conn.OpenAsync();
1188          using var cts = new CancellationTokenSource();
1189          var queryTask = conn.ExecuteNonQueryAsync("SELECT 1", cancellationToken: cts.Token);
1190          var server = await postmasterMock.WaitForServerConnection();
1191          await server.ExpectSimpleQuery("DISCARD ALL");
1192          await server.ExpectExtendedQuery();
1193          var cancelTask = Task.Run(cts.Cancel);
1194          var cancellationRequestTask = postmasterMock.WaitForCancellationRequest().AsTask();
1195          await Task.Delay(1000);
1196          Assert.IsFalse(cancelTask.IsCompleted);
1197          Assert.IsFalse(cancellationRequestTask.IsCompleted);
1198          if (failPrependedQuery)
1199          {
1200              await server
1201                  .WriteErrorResponse(PostgresErrorCodes.SyntaxError)
1202                  .WriteReadyForQuery()
1203                  .FlushAsync();
1204              await cancelTask;
1205              await cancellationRequestTask;
1206              Assert.ThrowsAsync<PostgresException>(async () => await queryTask);
1207              Assert.That(conn.State, Is.EqualTo(ConnectionState.Closed));
1208              return;
1209          }
1210          await server
1211              .WriteCommandComplete()
1212              .WriteReadyForQuery()
1213              .FlushAsync();
1214          await cancelTask;
1215          await cancellationRequestTask;
1216          await server
1217              .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1218              .WriteReadyForQuery()
1219              .FlushAsync();
1220          Assert.ThrowsAsync<OperationCanceledException>(async () => await queryTask);
1221          queryTask = conn.ExecuteNonQueryAsync("SELECT 1");
1222          await server.ExpectExtendedQuery();
1223          await server
1224              .WriteParseComplete()
1225              .WriteBindComplete()
1226              .WriteNoData()
1227              .WriteCommandComplete()
1228              .WriteReadyForQuery()
1229              .FlushAsync();
1230          await queryTask;
1231      }
1232      #region Logging
1233      [Test]
1234      public async Task Log_ExecuteScalar_single_statement_without_parameters()
1235      {
1236          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1237          await using var conn = await dataSource.OpenConnectionAsync();
1238          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
1239          using (listLoggerProvider.Record())
1240          {
1241              await cmd.ExecuteScalarAsync();
1242          }
1243          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1244          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains("SELECT 1"));
1245          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT 1");
1246          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
1247          if (!IsMultiplexing)
1248              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
1249      }
1250      [Test]
1251      public async Task Log_ExecuteScalar_single_statement_with_positional_parameters()
1252      {
1253          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1254          await using var conn = await dataSource.OpenConnectionAsync();
1255          await using var cmd = new NpgsqlCommand("SELECT $1, $2", conn);
1256          cmd.Parameters.Add(new() { Value = 8 });
1257          cmd.Parameters.Add(new() { NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1258          using (listLoggerProvider.Record())
1259          {
1260              await cmd.ExecuteScalarAsync();
1261          }
1262          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1263          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed")
1264              .And.Contains("SELECT $1, $2")
1265              .And.Contains("Parameters: [8, NULL]"));
1266          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT $1, $2");
1267          AssertLoggingStateContains(executingCommandEvent, "Parameters", new object[] { 8, "NULL" });
1268          if (!IsMultiplexing)
1269              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
1270      }
1271      [Test]
1272      public async Task Log_ExecuteScalar_single_statement_with_named_parameters()
1273      {
1274          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider);
1275          await using var conn = await dataSource.OpenConnectionAsync();
1276          await using var cmd = new NpgsqlCommand("SELECT @p1, @p2", conn);
1277          cmd.Parameters.Add(new() { ParameterName = "p1", Value = 8 });
1278          cmd.Parameters.Add(new() { ParameterName = "p2", NpgsqlDbType = NpgsqlDbType.Integer, Value = DBNull.Value });
1279          using (listLoggerProvider.Record())
1280          {
1281              await cmd.ExecuteScalarAsync();
1282          }
1283          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1284          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed")
1285              .And.Contains("SELECT $1, $2")
1286              .And.Contains("Parameters: [8, NULL]"));
1287          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT $1, $2");
1288          AssertLoggingStateContains(executingCommandEvent, "Parameters", new object[] { 8, "NULL" });
1289          if (!IsMultiplexing)
1290              AssertLoggingStateContains(executingCommandEvent, "ConnectorId", conn.ProcessID);
1291      }
1292      [Test]
1293      public async Task Log_ExecuteScalar_single_statement_with_parameter_logging_off()
1294      {
1295          await using var dataSource = CreateLoggingDataSource(out var listLoggerProvider, sensitiveDataLoggingEnabled: false);
1296          await using var conn = await dataSource.OpenConnectionAsync();
1297          await using var cmd = new NpgsqlCommand("SELECT $1, $2", conn);
1298          cmd.Parameters.Add(new() { Value = 8 });
1299          cmd.Parameters.Add(new() { Value = 9 });
1300          using (listLoggerProvider.Record())
1301          {
1302              await cmd.ExecuteScalarAsync();
1303          }
1304          var executingCommandEvent = listLoggerProvider.Log.Single(l => l.Id == NpgsqlEventId.CommandExecutionCompleted);
1305          Assert.That(executingCommandEvent.Message, Does.Contain("Command execution completed").And.Contains($"SELECT $1, $2"));
1306          AssertLoggingStateContains(executingCommandEvent, "CommandText", "SELECT $1, $2");
1307          AssertLoggingStateDoesNotContain(executingCommandEvent, "Parameters");
1308      }
1309      #endregion Logging
1310      public CommandTests(MultiplexingMode multiplexingMode) : base(multiplexingMode) {}
1311  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-InternalTypeTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommandTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>75          reader.Read();
76          var result1 = reader.GetFieldValue<NpgsqlLogSequenceNumber>(0);
77          var result2 = reader.GetFieldValue<NpgsqlLogSequenceNumber>(1);
78          Assert.AreEqual(expected1, result1);
79          Assert.AreEqual(42949672971ul, (ulong)result1);
80          Assert.AreEqual("A/B", result1.ToString());
81          Assert.AreEqual(expected1, result2);
82          Assert.AreEqual(42949672971ul, (ulong)result2);
83          Assert.AreEqual("A/B", result2.ToString());
84      }
</pre></code></div>
                <div class="column column_space"><pre><code>245          await using var conn = await OpenConnectionAsync();
246          await using var cmd = CreateSleepCommand(conn, 5);
247          var queryTask = Task.Run(() => cmd.ExecuteNonQuery());
248          cmd.WaitUntilCommandIsInProgress();
249          cmd.Cancel();
250          Assert.That(async () => await queryTask, Throws
251              .TypeOf<OperationCanceledException>()
252              .With.InnerException.TypeOf<PostgresException>()
253              .With.InnerException.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled)
254          );
255      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    