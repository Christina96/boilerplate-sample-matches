
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateMemory.cs</h3>
            <pre><code>1  using System;
2  using GitHub.DistributedTask.ObjectTemplating.Tokens;
3  using Newtonsoft.Json.Linq;
4  namespace GitHub.DistributedTask.ObjectTemplating
5  {
6      internal sealed class TemplateMemory
7      {
8          internal TemplateMemory(
9              Int32 maxDepth,
10              Int32 maxEvents,
11              Int32 maxBytes)
12          {
13              m_maxDepth = maxDepth;
14              m_maxEvents = maxEvents;
15              m_maxBytes = maxBytes;
16          }
17          public Int32 CurrentBytes => m_currentBytes;
18          public Int32 MaxBytes => m_maxBytes;
19          internal void AddBytes(Int32 bytes)
20          {
21              checked
22              {
23                  m_currentBytes += bytes;
24              }
25              if (m_currentBytes > m_maxBytes)
26              {
27                  throw new InvalidOperationException(TemplateStrings.MaxObjectSizeExceeded());
28              }
29          }
30          internal void AddBytes(String value)
31          {
32              var bytes = CalculateBytes(value);
33              AddBytes(bytes);
34          }
35          internal void AddBytes(
36              JToken value,
37              Boolean traverse)
38          {
39              var bytes = CalculateBytes(value, traverse);
40              AddBytes(bytes);
41          }
42          internal void AddBytes(
43              TemplateToken value,
44              Boolean traverse = false)
45          {
46              var bytes = CalculateBytes(value, traverse);
47              AddBytes(bytes);
48          }
49          internal void AddBytes(LiteralToken literal)
50          {
51              var bytes = CalculateBytes(literal);
52              AddBytes(bytes);
53          }
54          internal void AddBytes(SequenceToken sequence)
55          {
<span onclick='openModal()' class='match'>56              var bytes = CalculateBytes(sequence);
57              AddBytes(bytes);
58          }
</span>59          internal void AddBytes(MappingToken mapping)
60          {
61              var bytes = CalculateBytes(mapping);
62              AddBytes(bytes);
63          }
64          internal void AddBytes(BasicExpressionToken basicExpression)
65          {
66              var bytes = CalculateBytes(basicExpression);
67              AddBytes(bytes);
68          }
69          internal void AddBytes(InsertExpressionToken insertExpression)
70          {
71              var bytes = CalculateBytes(insertExpression);
72              AddBytes(bytes);
73          }
74          internal Int32 CalculateBytes(String value)
75          {
76              checked
77              {
78                  return StringBaseOverhead + ((value?.Length ?? 0) * sizeof(Char));
79              }
80          }
81          internal Int32 CalculateBytes(
82              JToken value,
83              Boolean traverse)
84          {
85              if (value is null)
86              {
87                  return MinObjectSize;
88              }
89              if (!traverse)
90              {
91                  switch (value.Type)
92                  {
93                      case JTokenType.String:
94                          checked
95                          {
96                              return StringBaseOverhead + (value.ToObject<String>().Length * sizeof(Char));
97                          }
98                      case JTokenType.Property:
99                          var property = value as JProperty;
100                          checked
101                          {
102                              return StringBaseOverhead + ((property.Name?.Length ?? 0) * sizeof(Char));
103                          }
104                      case JTokenType.Array:
105                      case JTokenType.Boolean:
106                      case JTokenType.Float:
107                      case JTokenType.Integer:
108                      case JTokenType.Null:
109                      case JTokenType.Object:
110                          return MinObjectSize;
111                      default:
112                          throw new NotSupportedException($"Unexpected JToken type '{value.Type}' when traversing object");
113                  }
114              }
115              var result = 0;
116              do
117              {
118                  while (true)
119                  {
120                      var bytes = CalculateBytes(value, false);
121                      checked
122                      {
123                          result += bytes;
124                      }
125                      if (value.HasValues)
126                      {
127                          value = value.First;
128                      }
129                      else
130                      {
131                          break;
132                      }
133                  }
134                  do
135                  {
136                      var sibling = value.Next;
137                      if (sibling != null)
138                      {
139                          value = sibling;
140                          break;
141                      }
142                      value = value.Parent;
143                  } while (value != null);
144              } while (value != null);
145              return result;
146          }
147          internal Int32 CalculateBytes(
148              TemplateToken value,
149              Boolean traverse = false)
150          {
151              var enumerable = traverse ? value.Traverse() : new[] { value };
152              var result = 0;
153              foreach (var item in enumerable)
154              {
155                  switch (item.Type)
156                  {
157                      case TokenType.Null:
158                      case TokenType.Boolean:
159                      case TokenType.Number:
160                          checked
161                          {
162                              result += MinObjectSize;
163                          }
164                          break;
165                      case TokenType.String:
166                          var stringToken = item as StringToken;
167                          checked
168                          {
169                              result += MinObjectSize + StringBaseOverhead + ((stringToken.Value?.Length ?? 0) * sizeof(Char));
170                          }
171                          break;
172                      case TokenType.Sequence:
173                      case TokenType.Mapping:
174                      case TokenType.InsertExpression:
175                          checked
176                          {
177                              result += MinObjectSize;
178                          }
179                          break;
180                      case TokenType.BasicExpression:
181                          var basicExpression = item as BasicExpressionToken;
182                          checked
183                          {
184                              result += MinObjectSize + StringBaseOverhead + ((basicExpression.Expression?.Length ?? 0) * sizeof(Char));
185                          }
186                          break;
187                      default:
188                          throw new NotSupportedException($"Unexpected template type '{item.Type}'");
189                  }
190              }
191              return result;
192          }
193          internal void SubtractBytes(Int32 bytes)
194          {
195              if (bytes > m_currentBytes)
196              {
197                  throw new InvalidOperationException("Bytes to subtract exceeds total bytes");
198              }
199              m_currentBytes -= bytes;
200          }
201          internal void SubtractBytes(
202              JToken value,
203              Boolean traverse)
204          {
205              var bytes = CalculateBytes(value, traverse);
206              SubtractBytes(bytes);
207          }
208          internal void SubtractBytes(
209              TemplateToken value,
210              Boolean traverse = false)
211          {
212              var bytes = CalculateBytes(value, traverse);
213              SubtractBytes(bytes);
214          }
215          internal void IncrementDepth()
216          {
217              if (m_depth++ >= m_maxDepth)
218              {
219                  throw new InvalidOperationException(TemplateStrings.MaxObjectDepthExceeded());
220              }
221          }
222          internal void DecrementDepth()
223          {
224              m_depth--;
225          }
226          internal void IncrementEvents()
227          {
228              if (m_events++ >= m_maxEvents)
229              {
230                  throw new InvalidOperationException(TemplateStrings.MaxTemplateEventsExceeded());
231              }
232          }
233          internal const Int32 MinObjectSize = 24;
234          internal const Int32 StringBaseOverhead = 26;
235          private readonly Int32 m_maxDepth;
236          private readonly Int32 m_maxEvents;
237          private readonly Int32 m_maxBytes;
238          private Int32 m_depth;
239          private Int32 m_events;
240          private Int32 m_currentBytes;
241      }
242  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlDataReader.cs</h3>
            <pre><code>1  using System;
2  using System.Collections;
3  using System.Collections.Generic;
4  using System.Collections.ObjectModel;
5  using System.Data;
6  using System.Data.Common;
7  using System.Diagnostics;
8  using System.Diagnostics.CodeAnalysis;
9  using System.IO;
10  using System.Linq;
11  using System.Runtime.CompilerServices;
12  using System.Runtime.ExceptionServices;
13  using System.Text;
14  using System.Threading;
15  using System.Threading.Tasks;
16  using Microsoft.Extensions.Logging;
17  using Npgsql.BackendMessages;
18  using Npgsql.Internal;
19  using Npgsql.Internal.TypeHandlers;
20  using Npgsql.Internal.TypeHandling;
21  using Npgsql.PostgresTypes;
22  using Npgsql.Schema;
23  using Npgsql.Util;
24  using NpgsqlTypes;
25  using static Npgsql.Util.Statics;
26  #pragma warning disable CA2222 
27  namespace Npgsql;
28  #pragma warning disable CA1010
29  public sealed class NpgsqlDataReader : DbDataReader, IDbColumnSchemaGenerator
30  #pragma warning restore CA1010
31  {
32      internal NpgsqlCommand Command { get; private set; } = default!;
33      internal NpgsqlConnector Connector { get; }
34      NpgsqlConnection? _connection;
35      CommandBehavior _behavior;
36      Task? _sendTask;
37      internal ReaderState State = ReaderState.Disposed;
38      internal NpgsqlReadBuffer Buffer = default!;
39      List<NpgsqlBatchCommand> _statements = default!;
40      internal int StatementIndex { get; private set; }
41      int _numColumns;
42      readonly List<(int Offset, int Length)> _columns = new();
43      int _column;
44      internal int ColumnLen;
45      internal int PosInColumn;
46      int _dataMsgEnd;
47      bool _canConsumeRowNonSequentially;
48      int _charPos;
49      internal RowDescriptionMessage? RowDescription;
50      ulong? _recordsAffected;
51      bool _hasRows;
52      public event EventHandler? ReaderClosed;
53      bool _isSchemaOnly;
54      bool _isSequential;
55      NpgsqlReadBuffer.ColumnStream? _columnStream;
56      internal ulong UniqueRowId;
57      internal NpgsqlNestedDataReader? CachedFreeNestedDataReader;
58      readonly ILogger _commandLogger;
59      internal NpgsqlDataReader(NpgsqlConnector connector)
60      {
61          Connector = connector;
62          _commandLogger = connector.CommandLogger;
63      }
64      internal void Init(
65          NpgsqlCommand command,
66          CommandBehavior behavior,
67          List<NpgsqlBatchCommand> statements,
68          Task? sendTask = null)
69      {
70          Command = command;
71          _connection = command.InternalConnection;
72          _behavior = behavior;
73          _isSchemaOnly = _behavior.HasFlag(CommandBehavior.SchemaOnly);
74          _isSequential = _behavior.HasFlag(CommandBehavior.SequentialAccess);
75          _statements = statements;
76          StatementIndex = -1;
77          _sendTask = sendTask;
78          State = ReaderState.BetweenResults;
79          _recordsAffected = null;
80      }
81      #region Read
82      public override bool Read()
83      {
84          CheckClosedOrDisposed();
85          UniqueRowId++;
86          var fastRead = TryFastRead();
87          return fastRead.HasValue
88              ? fastRead.Value
89              : Read(false).GetAwaiter().GetResult();
90      }
91      public override Task<bool> ReadAsync(CancellationToken cancellationToken)
92      {
93          CheckClosedOrDisposed();
94          UniqueRowId++;
95          var fastRead = TryFastRead();
96          if (fastRead.HasValue)
97              return fastRead.Value ? PGUtil.TrueTask : PGUtil.FalseTask;
98          using (NoSynchronizationContextScope.Enter())
99              return Read(true, cancellationToken);
100      }
101      bool? TryFastRead()
102      {
103          if (_behavior.HasFlag(CommandBehavior.SingleRow))
104              return null;
105          switch (State)
106          {
107          case ReaderState.BeforeResult:
108              State = ReaderState.InResult;
109              return true;
110          case ReaderState.InResult:
111              if (!_canConsumeRowNonSequentially)
112                  return null;
113              ConsumeRowNonSequential();
114              break;
115          case ReaderState.BetweenResults:
116          case ReaderState.Consumed:
117          case ReaderState.Closed:
118          case ReaderState.Disposed:
119              return false;
120          }
121          var readBuf = Connector.ReadBuffer;
122          if (readBuf.ReadBytesLeft < 5)
123              return null;
124          var messageCode = (BackendMessageCode)readBuf.ReadByte();
125          var len = readBuf.ReadInt32() - 4;  
126          if (messageCode != BackendMessageCode.DataRow || readBuf.ReadBytesLeft < len)
127          {
128              readBuf.ReadPosition -= 5;
129              return null;
130          }
131          var msg = Connector.ParseServerMessage(readBuf, BackendMessageCode.DataRow, len, false)!;
132          Debug.Assert(msg.Code == BackendMessageCode.DataRow);
133          ProcessMessage(msg);
134          return true;
135      }
136      async Task<bool> Read(bool async, CancellationToken cancellationToken = default)
137      {
138          var registration = Connector.StartNestedCancellableOperation(cancellationToken);
139          try
140          {
141              switch (State)
142              {
143              case ReaderState.BeforeResult:
144                  State = ReaderState.InResult;
145                  return true;
146              case ReaderState.InResult:
147                  await ConsumeRow(async);
148                  if (_behavior.HasFlag(CommandBehavior.SingleRow))
149                  {
150                      await Consume(async);
151                      return false;
152                  }
153                  break;
154              case ReaderState.BetweenResults:
155              case ReaderState.Consumed:
156              case ReaderState.Closed:
157              case ReaderState.Disposed:
158                  return false;
159              default:
160                  ThrowHelper.ThrowArgumentOutOfRangeException();
161                  return false;
162              }
163              var msg = await ReadMessage(async);
164              switch (msg.Code)
165              {
166              case BackendMessageCode.DataRow:
167                  ProcessMessage(msg);
168                  return true;
169              case BackendMessageCode.CommandComplete:
170              case BackendMessageCode.EmptyQueryResponse:
171                  ProcessMessage(msg);
172                  if (_statements[StatementIndex].AppendErrorBarrier ?? Command.EnableErrorBarriers)
173                      Expect<ReadyForQueryMessage>(await Connector.ReadMessage(async), Connector);
174                  return false;
175              default:
176                  throw Connector.UnexpectedMessageReceived(msg.Code);
177              }
178          }
179          catch
180          {
181              State = ReaderState.Consumed;
182              throw;
183          }
184          finally
185          {
186              registration.Dispose();
187          }
188      }
189      ValueTask<IBackendMessage> ReadMessage(bool async)
190      {
191          return _isSequential ? ReadMessageSequential(Connector, async) : Connector.ReadMessage(async);
192          static async ValueTask<IBackendMessage> ReadMessageSequential(NpgsqlConnector connector, bool async)
193          {
194              var msg = await connector.ReadMessage(async, DataRowLoadingMode.Sequential);
195              if (msg.Code == BackendMessageCode.DataRow)
196              {
197                  await connector.ReadBuffer.Ensure(2, async);
198                  return msg;
199              }
200              return msg;
201          }
202      }
203      #endregion
204      #region NextResult
205      public override bool NextResult() => (_isSchemaOnly ? NextResultSchemaOnly(false) : NextResult(false))
206          .GetAwaiter().GetResult();
207      public override Task<bool> NextResultAsync(CancellationToken cancellationToken)
208      {
209          using var _ = NoSynchronizationContextScope.Enter();
210          return _isSchemaOnly
211              ? NextResultSchemaOnly(async: true, cancellationToken: cancellationToken)
212              : NextResult(async: true, cancellationToken: cancellationToken);
213      }
214      [MethodImpl(MethodImplOptions.AggressiveInlining)]
215      async Task<bool> NextResult(bool async, bool isConsuming = false, CancellationToken cancellationToken = default)
216      {
217          CheckClosedOrDisposed();
218          IBackendMessage msg;
219          Debug.Assert(!_isSchemaOnly);
220          using var registration = isConsuming ? default : Connector.StartNestedCancellableOperation(cancellationToken);
221          try
222          {
223              switch (State)
224              {
225              case ReaderState.BeforeResult:
226              case ReaderState.InResult:
227                  await ConsumeRow(async);
228                  while (true)
229                  {
230                      var completedMsg = await Connector.ReadMessage(async, DataRowLoadingMode.Skip);
231                      switch (completedMsg.Code)
232                      {
233                      case BackendMessageCode.CommandComplete:
234                      case BackendMessageCode.EmptyQueryResponse:
235                          ProcessMessage(completedMsg);
236                          if (_statements[StatementIndex].AppendErrorBarrier ?? Command.EnableErrorBarriers)
237                              Expect<ReadyForQueryMessage>(await Connector.ReadMessage(async), Connector);
238                          break;
239                      default:
240                          continue;
241                      }
242                      break;
243                  }
244                  break;
245              case ReaderState.BetweenResults:
246                  break;
247              case ReaderState.Consumed:
248              case ReaderState.Closed:
249              case ReaderState.Disposed:
250                  return false;
251              default:
252                  ThrowHelper.ThrowArgumentOutOfRangeException();
253                  return false;
254              }
255              Debug.Assert(State == ReaderState.BetweenResults);
256              _hasRows = false;
257              if (_behavior.HasFlag(CommandBehavior.SingleResult) && StatementIndex == 0 && !isConsuming)
258              {
259                  await Consume(async);
260                  return false;
261              }
262              for (StatementIndex++; StatementIndex < _statements.Count; StatementIndex++)
263              {
264                  var statement = _statements[StatementIndex];
265                  if (statement.TryGetPrepared(out var preparedStatement))
266                  {
267                      Expect<BindCompleteMessage>(await Connector.ReadMessage(async), Connector);
268                      RowDescription = preparedStatement.Description;
269                  }
270                  else 
271                  {
272                      var pStatement = statement.PreparedStatement;
273                      if (pStatement != null)
274                      {
275                          Debug.Assert(!pStatement.IsPrepared);
276                          if (pStatement.StatementBeingReplaced != null)
277                          {
278                              Expect<CloseCompletedMessage>(await Connector.ReadMessage(async), Connector);
279                              pStatement.StatementBeingReplaced.CompleteUnprepare();
280                              pStatement.StatementBeingReplaced = null;
281                          }
282                      }
283                      Expect<ParseCompleteMessage>(await Connector.ReadMessage(async), Connector);
284                      if (statement.IsPreparing)
285                      {
286                          pStatement!.State = PreparedState.Prepared;
287                          Connector.PreparedStatementManager.NumPrepared++;
288                          statement.IsPreparing = false;
289                      }
290                      Expect<BindCompleteMessage>(await Connector.ReadMessage(async), Connector);
291                      msg = await Connector.ReadMessage(async);
292                      RowDescription = statement.Description = msg.Code switch
293                      {
294                          BackendMessageCode.NoData => null,
295                          BackendMessageCode.RowDescription => pStatement == null
296                              ? (RowDescriptionMessage)msg
297                              : ((RowDescriptionMessage)msg).Clone(),
298                          _ => throw Connector.UnexpectedMessageReceived(msg.Code)
299                      };
300                  }
301                  if (RowDescription == null)
302                  {
303                      msg = await Connector.ReadMessage(async);
304                      switch (msg.Code)
305                      {
306                      case BackendMessageCode.CommandComplete:
307                      case BackendMessageCode.EmptyQueryResponse:
308                          break;
309                      case BackendMessageCode.CopyInResponse:
310                          throw Connector.Break(new NotSupportedException(
311                              "COPY isn't supported in regular command execution - see https:&bsol;&bsol;www.npgsql.org/doc/copy.html for documentation on COPY with Npgsql. " +
312                              "If you are trying to execute a SQL script created by pg_dump, pass the '--inserts' switch to disable generating COPY statements."));
313                      case BackendMessageCode.CopyOutResponse:
314                          throw Connector.Break(new NotSupportedException(
315                              "COPY isn't supported in regular command execution - see https:&bsol;&bsol;www.npgsql.org/doc/copy.html for documentation on COPY with Npgsql."));
316                      default:
317                          throw Connector.UnexpectedMessageReceived(msg.Code);
318                      }
319                      ProcessMessage(msg);
320                      if (statement.AppendErrorBarrier ?? Command.EnableErrorBarriers)
321                          Expect<ReadyForQueryMessage>(await Connector.ReadMessage(async), Connector);
322                      continue;
323                  }
324                  if (!Command.IsWrappedByBatch && StatementIndex == 0 && Command.Parameters.HasOutputParameters)
325                  {
326                      msg = await Connector.ReadMessage(async);
327                      ProcessMessage(msg);
328                      if (msg.Code == BackendMessageCode.DataRow)
329                          PopulateOutputParameters();
330                  }
331                  else
332                  {
333                      msg = await ReadMessage(async);
334                      ProcessMessage(msg);
335                  }
336                  switch (msg.Code)
337                  {
338                  case BackendMessageCode.DataRow:
339                      Connector.State = ConnectorState.Fetching;
340                      return true;
341                  case BackendMessageCode.CommandComplete:
342                      if (statement.AppendErrorBarrier ?? Command.EnableErrorBarriers)
343                          Expect<ReadyForQueryMessage>(await Connector.ReadMessage(async), Connector);
344                      return true;
345                  default:
346                      throw Connector.UnexpectedMessageReceived(msg.Code);
347                  }
348              }
349              if (_statements.Count == 0 || !(_statements[_statements.Count - 1].AppendErrorBarrier ?? Command.EnableErrorBarriers))
350                  Expect<ReadyForQueryMessage>(await Connector.ReadMessage(async), Connector);
351              State = ReaderState.Consumed;
352              RowDescription = null;
353              return false;
354          }
355          catch (Exception e)
356          {
357              if (e is PostgresException postgresException && StatementIndex >= 0 && StatementIndex < _statements.Count)
358              {
359                  var statement = _statements[StatementIndex];
360                  postgresException.BatchCommand = statement;
361                  Command.IsCacheable = false;
362                  if (postgresException.SqlState == PostgresErrorCodes.FeatureNotSupported &&
363                      statement.PreparedStatement is { } preparedStatement)
364                  {
365                      preparedStatement.State = PreparedState.Invalidated;
366                      Command.ResetPreparation();
367                      foreach (var s in Command.InternalBatchCommands)
368                          s.ResetPreparation();
369                  }
370              }
371              for (; StatementIndex < _statements.Count; StatementIndex++)
372              {
373                  var statement = _statements[StatementIndex];
374                  if (statement.IsPreparing)
375                  {
376                      statement.IsPreparing = false;
377                      statement.PreparedStatement!.AbortPrepare();
378                  }
379                  if ((statement.AppendErrorBarrier ?? Command.EnableErrorBarriers) && StatementIndex < _statements.Count - 1)
380                  {
381                      if (isConsuming)
382                          throw;
383                      switch (State)
384                      {
385                      case ReaderState.Consumed:
386                      case ReaderState.Closed:
387                      case ReaderState.Disposed:
388                          break;
389                      default:
390                          await Consume(async, firstException: e);
391                          break; 
392                      }
393                  }
394              }
395              State = ReaderState.Consumed;
396              throw;
397          }
398      }
399      void PopulateOutputParameters()
400      {
401          Debug.Assert(Command.Parameters.Any(p => p.IsOutputDirection));
402          Debug.Assert(StatementIndex == 0);
403          Debug.Assert(RowDescription != null);
404          Debug.Assert(State == ReaderState.BeforeResult);
405          var currentPosition = Buffer.ReadPosition;
406          State = ReaderState.InResult;
407          var pending = new Queue<object>();
408          var taken = new List<NpgsqlParameter>();
409          for (var i = 0; i < FieldCount; i++)
410          {
411              if (Command.Parameters.TryGetValue(GetName(i), out var p) && p.IsOutputDirection)
412              {
413                  p.Value = GetValue(i);
414                  taken.Add(p);
415              }
416              else
417                  pending.Enqueue(GetValue(i));
418          }
419          foreach (var p in Command.Parameters.Where(p => p.IsOutputDirection && !taken.Contains(p)))
420          {
421              if (pending.Count == 0)
422                  break;
423              p.Value = pending.Dequeue();
424          }
425          State = ReaderState.BeforeResult; 
426          Buffer.ReadPosition = currentPosition; 
427          _column = -1;
428          ColumnLen = -1;
429          PosInColumn = 0;
430      }
431      async Task<bool> NextResultSchemaOnly(bool async, bool isConsuming = false, CancellationToken cancellationToken = default)
432      {
433          Debug.Assert(_isSchemaOnly);
434          using var registration = isConsuming ? default : Connector.StartNestedCancellableOperation(cancellationToken);
435          try
436          {
437              switch (State)
438              {
439              case ReaderState.BeforeResult:
440              case ReaderState.InResult:
441              case ReaderState.BetweenResults:
442                  break;
443              case ReaderState.Consumed:
444              case ReaderState.Closed:
445              case ReaderState.Disposed:
446                  return false;
447              default:
448                  ThrowHelper.ThrowArgumentOutOfRangeException();
449                  return false;
450              }
451              for (StatementIndex++; StatementIndex < _statements.Count; StatementIndex++)
452              {
453                  var statement = _statements[StatementIndex];
454                  if (statement.TryGetPrepared(out var preparedStatement))
455                  {
456                      RowDescription = preparedStatement.Description;
457                  }
458                  else
459                  {
460                      var pStatement = statement.PreparedStatement;
461                      if (pStatement != null)
462                      {
463                          Debug.Assert(!pStatement.IsPrepared);
464                          if (pStatement.StatementBeingReplaced != null)
465                          {
466                              Expect<CloseCompletedMessage>(await Connector.ReadMessage(async), Connector);
467                              pStatement.StatementBeingReplaced.CompleteUnprepare();
468                              pStatement.StatementBeingReplaced = null;
469                          }
470                      }
471                      Expect<ParseCompleteMessage>(await Connector.ReadMessage(async), Connector);
472                      if (statement.IsPreparing)
473                      {
474                          pStatement!.State = PreparedState.Prepared;
475                          Connector.PreparedStatementManager.NumPrepared++;
476                          statement.IsPreparing = false;
477                      }
478                      Expect<ParameterDescriptionMessage>(await Connector.ReadMessage(async), Connector);
479                      var msg = await Connector.ReadMessage(async);
480                      switch (msg.Code)
481                      {
482                      case BackendMessageCode.NoData:
483                          RowDescription = _statements[StatementIndex].Description = null;
484                          break;
485                      case BackendMessageCode.RowDescription:
486                          RowDescription = _statements[StatementIndex].Description = (RowDescriptionMessage)msg;
487                          Command.FixupRowDescription(RowDescription, StatementIndex == 0);
488                          break;
489                      default:
490                          throw Connector.UnexpectedMessageReceived(msg.Code);
491                      }
492                  }
493                  if (RowDescription != null)
494                      return true;
495              }
496              if (!_statements.All(s => s.IsPrepared))
497              {
498                  Expect<ReadyForQueryMessage>(await Connector.ReadMessage(async), Connector);
499                  RowDescription = null;
500                  State = ReaderState.Consumed;
501              }
502              return false;
503          }
504          catch (Exception e)
505          {
506              State = ReaderState.Consumed;
507              if (e is PostgresException postgresException && StatementIndex >= 0 && StatementIndex < _statements.Count)
508              {
509                  postgresException.BatchCommand = _statements[StatementIndex];
510                  Command.IsCacheable = false;
511              }
512              for (; StatementIndex < _statements.Count; StatementIndex++)
513              {
514                  var statement = _statements[StatementIndex];
515                  if (statement.IsPreparing)
516                  {
517                      statement.IsPreparing = false;
518                      statement.PreparedStatement!.AbortPrepare();
519                  }
520              }
521              throw;
522          }
523      }
524      #endregion
525      #region ProcessMessage
526      internal void ProcessMessage(IBackendMessage msg)
527      {
528          switch (msg.Code)
529          {
530          case BackendMessageCode.DataRow:
531              ProcessDataRowMessage((DataRowMessage)msg);
532              return;
533          case BackendMessageCode.CommandComplete:
534              var completed = (CommandCompleteMessage)msg;
535              switch (completed.StatementType)
536              {
537              case StatementType.Update:
538              case StatementType.Insert:
539              case StatementType.Delete:
540              case StatementType.Copy:
541              case StatementType.Move:
542              case StatementType.Merge:
543                  if (!_recordsAffected.HasValue)
544                      _recordsAffected = 0;
545                  _recordsAffected += completed.Rows;
546                  break;
547              }
548              _statements[StatementIndex].ApplyCommandComplete(completed);
549              goto case BackendMessageCode.EmptyQueryResponse;
550          case BackendMessageCode.EmptyQueryResponse:
551              State = ReaderState.BetweenResults;
552              return;
553          default:
554              ThrowUnexpectedBackendMessage(msg.Code);
555              return;
556          }
557          static void ThrowUnexpectedBackendMessage(BackendMessageCode code)
558              => throw new Exception("Received unexpected backend message of type " + code);
559      }
560      void ProcessDataRowMessage(DataRowMessage msg)
561      {
562          Buffer = Connector.ReadBuffer;
563          _hasRows = true;
564          _column = -1;
565          ColumnLen = -1;
566          PosInColumn = 0;
567          _numColumns = Buffer.ReadInt16();
568          Debug.Assert(_numColumns == RowDescription!.Count,
569              $"Row's number of columns ({_numColumns}) differs from the row description's ({RowDescription.Count})");
570          _dataMsgEnd = Buffer.ReadPosition + msg.Length - 2;
571          _canConsumeRowNonSequentially = Buffer.ReadBytesLeft >= msg.Length - 2;
572          if (!_isSequential)
573          {
574              Debug.Assert(_canConsumeRowNonSequentially);
575              _columns.Clear();
576              var len = Buffer.ReadInt32();
577              _columns.Add((Buffer.ReadPosition, len));
578          }
579          switch (State)
580          {
581          case ReaderState.BetweenResults:
582              State = ReaderState.BeforeResult;
583              break;
584          case ReaderState.BeforeResult:
585              State = ReaderState.InResult;
586              break;
587          case ReaderState.InResult:
588              break;
589          default:
590              throw Connector.UnexpectedMessageReceived(BackendMessageCode.DataRow);
591          }
592      }
593      #endregion
594      public override int Depth => 0;
595      public override bool IsClosed => State == ReaderState.Closed || State == ReaderState.Disposed;
596      public override int RecordsAffected
597          => !_recordsAffected.HasValue
598              ? -1
599              : _recordsAffected > int.MaxValue
600                  ? throw new OverflowException(
601                      $"The number of records affected exceeds int.MaxValue. Use {nameof(Rows)}.")
602                  : (int)_recordsAffected;
603      public ulong Rows => _recordsAffected ?? 0;
604      [Obsolete("Use the new DbBatch API")]
605      public IReadOnlyList<NpgsqlBatchCommand> Statements => _statements.AsReadOnly();
606      public override bool HasRows
607          => State switch
608          {
609              ReaderState.Closed => throw new InvalidOperationException("Invalid attempt to call HasRows when reader is closed."),
610              ReaderState.Disposed => throw new ObjectDisposedException(nameof(NpgsqlDataReader)),
611              _ => _hasRows
612          };
613      public bool IsOnRow => State == ReaderState.InResult;
614      public override string GetName(int ordinal) => GetField(ordinal).Name;
615      public override int FieldCount
616      {
617          get
618          {
619              CheckClosedOrDisposed();
620              return RowDescription?.Count ?? 0;
621          }
622      }
623      #region Cleanup / Dispose
624      async Task Consume(bool async, Exception? firstException = null)
625      {
626          var exceptions = firstException is null ? null : new List<Exception> { firstException };
627          while (true)
628          {
629              try
630              {
631                  if (!(_isSchemaOnly
632                          ? await NextResultSchemaOnly(async, isConsuming: true)
633                          : await NextResult(async, isConsuming: true)))
634                  {
635                      break;
636                  }
637              }
638              catch (Exception e)
639              {
640                  exceptions ??= new();
641                  exceptions.Add(e);
642              }
643          }
644          Debug.Assert(exceptions?.Count != 0);
645          switch (exceptions?.Count)
646          {
647          case null:
648              return;
649          case 1:
650              ExceptionDispatchInfo.Capture(exceptions[0]).Throw();
651              return;
652          default:
653              throw new NpgsqlException(
654                  "Multiple exceptions occurred when consuming the result set",
655                  new AggregateException(exceptions));
656          }
657      }
658      protected override void Dispose(bool disposing)
659      {
660          try
661          {
662              Close(connectionClosing: false, async: false, isDisposing: true).GetAwaiter().GetResult();
663          }
664          catch (Exception ex)
665          {
666              if (!(ex is PostgresException ||
667                    ex is NpgsqlException { InnerException: AggregateException aggregateException } &&
668                    aggregateException.InnerExceptions.All(e => e is PostgresException)))
669              {
670                  State = ReaderState.Disposed;
671              }
672              throw;
673          }
674          finally
675          {
676              Command.TraceCommandStop();
677          }
678      }
679  #if NETSTANDARD2_0
680      public ValueTask DisposeAsync()
681  #else
682      public override ValueTask DisposeAsync()
683  #endif
684      {
685          using (NoSynchronizationContextScope.Enter())
686              return DisposeAsyncCore();
687          [MethodImpl(MethodImplOptions.AggressiveInlining)]
688          async ValueTask DisposeAsyncCore()
689          {
690              try
691              {
692                  await Close(connectionClosing: false, async: true, isDisposing: true);
693              }
694              catch (Exception ex)
695              {
696                  if (!(ex is PostgresException ||
697                        ex is NpgsqlException { InnerException: AggregateException aggregateException } &&
698                        aggregateException.InnerExceptions.All(e => e is PostgresException)))
699                  {
700                      State = ReaderState.Disposed;
701                  }
702                  throw;
703              }
704              finally
705              {
706                  Command.TraceCommandStop();
707              }
708          }
709      }
710      public override void Close() => Close(connectionClosing: false, async: false, isDisposing: false).GetAwaiter().GetResult();
711  #if NETSTANDARD2_0
712      public Task CloseAsync()
713  #else
714      public override Task CloseAsync()
715  #endif
716      {
717          using (NoSynchronizationContextScope.Enter())
718              return Close(connectionClosing: false, async: true, isDisposing: false);
719      }
720      internal async Task Close(bool connectionClosing, bool async, bool isDisposing)
721      {
722          if (State is ReaderState.Closed or ReaderState.Disposed)
723          {
724              if (isDisposing)
725                  State = ReaderState.Disposed;
726              return;
727          }
728          Connector.CurrentReader = null;
729          switch (Connector.State)
730          {
731          case ConnectorState.Ready:
732          case ConnectorState.Fetching:
733          case ConnectorState.Executing:
734          case ConnectorState.Connecting:
735              if (State != ReaderState.Consumed)
736              {
737                  try
738                  {
739                      await Consume(async);
740                  }
741                  catch (Exception ex) when (ex is OperationCanceledException or NpgsqlException { InnerException : TimeoutException })
742                  {
743                  }
744                  catch (Exception ex) when (
745                      ex is PostgresException ||
746                      ex is NpgsqlException { InnerException: AggregateException aggregateException } &&
747                      aggregateException.InnerExceptions.All(e => e is PostgresException))
748                  {
749                      await Cleanup(async, connectionClosing, isDisposing);
750                      throw;
751                  }
752                  catch
753                  {
754                      Debug.Assert(Connector.IsBroken);
755                      throw;
756                  }
757              }
758              break;
759          case ConnectorState.Closed:
760          case ConnectorState.Broken:
761              break;
762          case ConnectorState.Waiting:
763          case ConnectorState.Copy:
764          case ConnectorState.Replication:
765              Debug.Fail("Bad connector state when closing reader: " + Connector.State);
766              break;
767          default:
768              throw new ArgumentOutOfRangeException();
769          }
770          await Cleanup(async, connectionClosing, isDisposing);
771      }
772      internal async Task Cleanup(bool async, bool connectionClosing = false, bool isDisposing = false)
773      {
774          LogMessages.ReaderCleanup(_commandLogger, Connector.Id);
775          if (_sendTask != null)
776          {
777              if (Connector.IsBroken)
778              {
779                  _ = _sendTask.ContinueWith(t => _ = t.Exception, CancellationToken.None, TaskContinuationOptions.OnlyOnFaulted, TaskScheduler.Current);
780              }
781              else
782              {
783                  try
784                  {
785                      if (async)
786                          await _sendTask;
787                      else
788                          _sendTask.GetAwaiter().GetResult();
789                  }
790                  catch (Exception e)
791                  {
792                      _commandLogger.LogDebug(e, "Exception caught while sending the request", Connector.Id);
793                  }
794              }
795          }
796          State = ReaderState.Closed;
797          Command.State = CommandState.Idle;
798          Connector.CurrentReader = null;
799          if (_commandLogger.IsEnabled(LogLevel.Information))
800              Command.LogExecutingCompleted(Connector, executing: false);
801          NpgsqlEventSource.Log.CommandStop();
802          Connector.EndUserAction();
803          if (isDisposing)
804              State = ReaderState.Disposed;
805          if (_connection?.ConnectorBindingScope == ConnectorBindingScope.Reader)
806          {
807              UnbindIfNecessary();
808              _connection.Connector = null;
809              Connector.Connection = null;
810              _connection.ConnectorBindingScope = ConnectorBindingScope.None;
811              if (_behavior.HasFlag(CommandBehavior.CloseConnection) && !connectionClosing)
812                  _connection.Close();
813              Connector.ReaderCompleted.SetResult(null);
814          }
815          else if (_behavior.HasFlag(CommandBehavior.CloseConnection) && !connectionClosing)
816          {
817              Debug.Assert(_connection is not null);
818              _connection.Close();
819          }
820          if (ReaderClosed != null)
821          {
822              ReaderClosed(this, EventArgs.Empty);
823              ReaderClosed = null;
824          }
825      }
826      #endregion
827      #region Simple value getters
828      public override bool GetBoolean(int ordinal) => GetFieldValue<bool>(ordinal);
829      public override byte GetByte(int ordinal) => GetFieldValue<byte>(ordinal);
830      public override char GetChar(int ordinal) => GetFieldValue<char>(ordinal);
831      public override short GetInt16(int ordinal) => GetFieldValue<short>(ordinal);
832      public override int GetInt32(int ordinal) => GetFieldValue<int>(ordinal);
833      public override long GetInt64(int ordinal) => GetFieldValue<long>(ordinal);
834      public override DateTime GetDateTime(int ordinal) => GetFieldValue<DateTime>(ordinal);
835      public override string GetString(int ordinal) => GetFieldValue<string>(ordinal);
836      public override decimal GetDecimal(int ordinal) => GetFieldValue<decimal>(ordinal);
837      public override double GetDouble(int ordinal) => GetFieldValue<double>(ordinal);
838      public override float GetFloat(int ordinal) => GetFieldValue<float>(ordinal);
839      public override Guid GetGuid(int ordinal) => GetFieldValue<Guid>(ordinal);
840      public override int GetValues(object[] values)
841      {
842          if (values == null)
843              throw new ArgumentNullException(nameof(values));
844          CheckResultSet();
845          var count = Math.Min(FieldCount, values.Length);
846          for (var i = 0; i < count; i++)
847              values[i] = GetValue(i);
848          return count;
849      }
850      public override object this[int ordinal] => GetValue(ordinal);
851      #endregion
852      #region Provider-specific simple type getters
853      public TimeSpan GetTimeSpan(int ordinal) => GetFieldValue<TimeSpan>(ordinal);
854      protected override DbDataReader GetDbDataReader(int ordinal) => GetData(ordinal);
855      public new NpgsqlNestedDataReader GetData(int ordinal)
856      {
857          var field = CheckRowAndGetField(ordinal);
858          var type = field.PostgresType;
859          var isArray = type is PostgresArrayType;
860          var elementType = isArray ? ((PostgresArrayType)type).Element : type;
861          var compositeType = elementType as PostgresCompositeType;
862          if (elementType.InternalName != "record" && compositeType == null)
863              throw new InvalidCastException("GetData() not supported for type " + field.TypeDisplayName);
864          SeekToColumn(ordinal, false).GetAwaiter().GetResult();
865          if (ColumnLen == -1)
866              ThrowHelper.ThrowInvalidCastException_NoValue(field);
867          if (_isSequential)
868              throw new NotSupportedException("GetData() not supported in sequential mode.");
869          var reader = CachedFreeNestedDataReader;
870          if (reader != null)
871          {
872              CachedFreeNestedDataReader = null;
873              reader.Init(UniqueRowId, compositeType);
874          }
875          else
876          {
877              reader = new NpgsqlNestedDataReader(this, null, UniqueRowId, 1, compositeType);
878          }
879          if (isArray)
880              reader.InitArray();
881          else
882              reader.InitSingleRow();
883          return reader;
884      }
885      #endregion
886      #region Special binary getters
887      public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
888      {
889          if (dataOffset is < 0 or > int.MaxValue)
890              throw new ArgumentOutOfRangeException(nameof(dataOffset), dataOffset, $"dataOffset must be between {0} and {int.MaxValue}");
891          if (buffer != null && (bufferOffset < 0 || bufferOffset >= buffer.Length + 1))
892              throw new IndexOutOfRangeException($"bufferOffset must be between 0 and {buffer.Length}");
893          if (buffer != null && (length < 0 || length > buffer.Length - bufferOffset))
894              throw new IndexOutOfRangeException($"length must be between 0 and {buffer.Length - bufferOffset}");
895          var field = CheckRowAndGetField(ordinal);
896          var handler = field.Handler;
897          if (!(handler is ByteaHandler))
898              throw new InvalidCastException("GetBytes() not supported for type " + field.Name);
899          SeekToColumn(ordinal, false).GetAwaiter().GetResult();
900          if (ColumnLen is -1)
901              ThrowHelper.ThrowInvalidCastException_NoValue(field);
902          if (buffer is null)
903              return ColumnLen;
904          var dataOffset2 = (int)dataOffset;
905          SeekInColumn(dataOffset2, false).GetAwaiter().GetResult();
906          if (dataOffset2 + length > ColumnLen)
907              length = Math.Max(ColumnLen - dataOffset2, 0);
908          var left = length;
909          while (left > 0)
910          {
911              var read = Buffer.Read(new Span<byte>(buffer, bufferOffset, left));
912              bufferOffset += read;
913              left -= read;
914          }
915          PosInColumn += length;
916          return length;
917      }
918      public override Stream GetStream(int ordinal) => GetStream(ordinal, false).Result;
919      public Task<Stream> GetStreamAsync(int ordinal, CancellationToken cancellationToken = default)
920      {
921          using (NoSynchronizationContextScope.Enter())
922              return GetStream(ordinal, true, cancellationToken).AsTask();
923      }
924      ValueTask<Stream> GetStream(int ordinal, bool async, CancellationToken cancellationToken = default) =>
925          GetStreamInternal(CheckRowAndGetField(ordinal), ordinal, async, cancellationToken);
926      async ValueTask<Stream> GetStreamInternal(FieldDescription field, int ordinal, bool async, CancellationToken cancellationToken = default)
927      {
928          if (_columnStream is { IsDisposed: false })
929              ThrowHelper.ThrowInvalidOperationException("A stream is already open for this reader");
930          using var registration = Connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
931          await SeekToColumn(ordinal, async, cancellationToken);
932          if (_isSequential)
933              CheckColumnStart();
934          if (ColumnLen == -1)
935              ThrowHelper.ThrowInvalidCastException_NoValue(field);
936          PosInColumn += ColumnLen;
937          return _columnStream = (NpgsqlReadBuffer.ColumnStream)Buffer.GetStream(ColumnLen, !_isSequential);
938      }
939      #endregion
940      #region Special text getters
941      public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
942      {
943          if (dataOffset is < 0 or > int.MaxValue)
944              throw new ArgumentOutOfRangeException(nameof(dataOffset), dataOffset, $"dataOffset must be between 0 and {int.MaxValue}");
945          if (buffer != null && (bufferOffset < 0 || bufferOffset >= buffer.Length + 1))
946              throw new IndexOutOfRangeException($"bufferOffset must be between 0 and {buffer.Length}");
947          if (buffer != null && (length < 0 || length > buffer.Length - bufferOffset))
948              throw new IndexOutOfRangeException($"length must be between 0 and {buffer.Length - bufferOffset}");
949          var field = CheckRowAndGetField(ordinal);
950          var handler = field.Handler as TextHandler;
951          if (handler == null)
952              throw new InvalidCastException("The GetChars method is not supported for type " + field.Name);
953          SeekToColumn(ordinal, false).GetAwaiter().GetResult();
954          if (ColumnLen == -1)
955              ThrowHelper.ThrowInvalidCastException_NoValue(field);
956          if (PosInColumn == 0)
957              _charPos = 0;
958          var decoder = Buffer.TextEncoding.GetDecoder();
959          if (buffer == null)
960          {
961              var (bytesSkipped, charsSkipped) = SkipChars(decoder, int.MaxValue, ColumnLen - PosInColumn);
962              Debug.Assert(bytesSkipped == ColumnLen - PosInColumn);
963              PosInColumn += bytesSkipped;
964              _charPos += charsSkipped;
965              return _charPos;
966          }
967          if (PosInColumn == ColumnLen || dataOffset < _charPos)
968          {
969              SeekInColumn(0, false).GetAwaiter().GetResult();
970              _charPos = 0;
971          }
972          if (dataOffset > _charPos)
973          {
974              var charsToSkip = (int)dataOffset - _charPos;
975              var (bytesSkipped, charsSkipped) = SkipChars(decoder, charsToSkip, ColumnLen - PosInColumn);
976              decoder.Reset();
977              PosInColumn += bytesSkipped;
978              _charPos += charsSkipped;
979              if (charsSkipped < charsToSkip) 
980                  return 0;
981          }
982          if (length == 0)
983              return 0;
984          var (bytesRead, charsRead) = DecodeChars(decoder, buffer.AsSpan(bufferOffset, length), ColumnLen - PosInColumn);
985          PosInColumn += bytesRead;
986          _charPos += charsRead;
987          return charsRead;
988      }
989      (int BytesRead, int CharsRead) DecodeChars(Decoder decoder, Span<char> output, int byteCount)
990      {
991          var (bytesRead, charsRead) = (0, 0);
992          var outputLength = output.Length;
993          while (true)
994          {
995              Buffer.Ensure(1); 
996              var maxBytes = Math.Min(byteCount - bytesRead, Buffer.ReadBytesLeft);
997              var bytes = Buffer.Buffer.AsSpan(Buffer.ReadPosition, maxBytes);
998              decoder.Convert(bytes, output, false, out var bytesUsed, out var charsUsed, out _);
999              Buffer.ReadPosition += bytesUsed;
1000              bytesRead += bytesUsed;
1001              charsRead += charsUsed;
1002              if (charsRead == outputLength || bytesRead == byteCount)
1003                  break;
1004              output = output.Slice(charsUsed);
1005          }
1006          return (bytesRead, charsRead);
1007      }
1008      internal (int BytesSkipped, int CharsSkipped) SkipChars(Decoder decoder, int charCount, int byteCount)
1009      {
1010          Span<char> tempCharBuf = stackalloc char[512];
1011          var (charsSkipped, bytesSkipped) = (0, 0);
1012          while (charsSkipped < charCount && bytesSkipped < byteCount)
1013          {
1014              var (bytesRead, charsRead) = DecodeChars(decoder, tempCharBuf.Slice(0, Math.Min(charCount, tempCharBuf.Length)), byteCount);
1015              bytesSkipped += bytesRead;
1016              charsSkipped += charsRead;
1017          }
1018          return (bytesSkipped, charsSkipped);
1019      }
1020      public override TextReader GetTextReader(int ordinal)
1021          => GetTextReader(ordinal, false).Result;
1022      public Task<TextReader> GetTextReaderAsync(int ordinal, CancellationToken cancellationToken = default)
1023      {
1024          using (NoSynchronizationContextScope.Enter())
1025              return GetTextReader(ordinal, true, cancellationToken).AsTask();
1026      }
1027      async ValueTask<TextReader> GetTextReader(int ordinal, bool async, CancellationToken cancellationToken = default)
1028      {
1029          var field = CheckRowAndGetField(ordinal);
1030          if (field.Handler is ITextReaderHandler handler)
1031          {
1032              var stream = async
1033                  ? await GetStreamInternal(field, ordinal, true, cancellationToken)
1034                  : GetStreamInternal(field, ordinal, false, CancellationToken.None).Result;
1035              return handler.GetTextReader(stream, Buffer);
1036          }
1037          throw new InvalidCastException($"The GetTextReader method is not supported for type {field.PostgresType.DisplayName}");
1038      }
1039      #endregion
1040      #region GetFieldValue
1041      public override Task<T> GetFieldValueAsync<T>(int ordinal, CancellationToken cancellationToken)
1042      {
1043          if (typeof(T) == typeof(Stream))
1044              return (Task<T>)(object)GetStreamAsync(ordinal, cancellationToken);
1045          if (typeof(T) == typeof(TextReader))
1046              return (Task<T>)(object)GetTextReaderAsync(ordinal, cancellationToken);
1047          if (!_isSequential)
1048              return Task.FromResult(GetFieldValue<T>(ordinal));
1049          using (NoSynchronizationContextScope.Enter())
1050              return GetFieldValueSequential<T>(ordinal, true, cancellationToken).AsTask();
1051      }
1052      public override T GetFieldValue<T>(int ordinal)
1053      {
1054          if (typeof(T) == typeof(Stream))
1055              return (T)(object)GetStream(ordinal);
1056          if (typeof(T) == typeof(TextReader))
1057              return (T)(object)GetTextReader(ordinal);
1058          if (_isSequential)
1059              return GetFieldValueSequential<T>(ordinal, false).GetAwaiter().GetResult();
<span onclick='openModal()' class='match'>1060          var field = CheckRowAndGetField(ordinal);
1061          SeekToColumnNonSequential(ordinal);
1062          if (ColumnLen == -1)
</span>1063          {
1064              if (NullableHandler<T>.Exists)
1065                  return default!;
1066              if (typeof(T) == typeof(object))
1067                  return (T)(object)DBNull.Value;
1068              ThrowHelper.ThrowInvalidCastException_NoValue(field);
1069          }
1070          return NullableHandler<T>.Exists
1071              ? NullableHandler<T>.Read(field.Handler, Buffer, ColumnLen, field)
1072              : typeof(T) == typeof(object)
1073                  ? (T)field.Handler.ReadAsObject(Buffer, ColumnLen, field)
1074                  : field.Handler.Read<T>(Buffer, ColumnLen, field);
1075      }
1076      async ValueTask<T> GetFieldValueSequential<T>(int column, bool async, CancellationToken cancellationToken = default)
1077      {
1078          using var registration = Connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
1079          var field = CheckRowAndGetField(column);
1080          await SeekToColumnSequential(column, async, CancellationToken.None);
1081          CheckColumnStart();
1082          if (ColumnLen == -1)
1083          {
1084              if (NullableHandler<T>.Exists)
1085                  return default!;
1086              if (typeof(T) == typeof(object))
1087                  return (T)(object)DBNull.Value;
1088              ThrowHelper.ThrowInvalidCastException_NoValue(field);
1089          }
1090          var position = Buffer.ReadPosition;
1091          try
1092          {
1093              return NullableHandler<T>.Exists
1094                  ? ColumnLen <= Buffer.ReadBytesLeft
1095                      ? NullableHandler<T>.Read(field.Handler, Buffer, ColumnLen, field)
1096                      : await NullableHandler<T>.ReadAsync(field.Handler, Buffer, ColumnLen, async, field)
1097                  : typeof(T) == typeof(object)
1098                      ? ColumnLen <= Buffer.ReadBytesLeft
1099                          ? (T)field.Handler.ReadAsObject(Buffer, ColumnLen, field)
1100                          : (T)await field.Handler.ReadAsObject(Buffer, ColumnLen, async, field)
1101                      : ColumnLen <= Buffer.ReadBytesLeft
1102                          ? field.Handler.Read<T>(Buffer, ColumnLen, field)
1103                          : await field.Handler.Read<T>(Buffer, ColumnLen, async, field);
1104          }
1105          catch
1106          {
1107              if (Connector.State != ConnectorState.Broken)
1108              {
1109                  var writtenBytes = Buffer.ReadPosition - position;
1110                  var remainingBytes = ColumnLen - writtenBytes;
1111                  if (remainingBytes > 0)
1112                      await Buffer.Skip(remainingBytes, async);
1113              }
1114              throw;
1115          }
1116          finally
1117          {
1118              PosInColumn += ColumnLen;
1119          }
1120      }
1121      #endregion
1122      #region GetValue
1123      public override object GetValue(int ordinal)
1124      {
1125          var fieldDescription = CheckRowAndGetField(ordinal);
1126          if (_isSequential)
1127          {
1128              SeekToColumnSequential(ordinal, false).GetAwaiter().GetResult();
1129              CheckColumnStart();
1130          }
1131          else
1132              SeekToColumnNonSequential(ordinal);
1133          if (ColumnLen == -1)
1134              return DBNull.Value;
1135          object result;
1136          var position = Buffer.ReadPosition;
1137          try
1138          {
1139              result = _isSequential
1140                  ? fieldDescription.Handler.ReadAsObject(Buffer, ColumnLen, false, fieldDescription).GetAwaiter().GetResult()
1141                  : fieldDescription.Handler.ReadAsObject(Buffer, ColumnLen, fieldDescription);
1142          }
1143          catch
1144          {
1145              if (Connector.State != ConnectorState.Broken)
1146              {
1147                  var writtenBytes = Buffer.ReadPosition - position;
1148                  var remainingBytes = ColumnLen - writtenBytes;
1149                  if (remainingBytes > 0)
1150                      Buffer.Skip(remainingBytes, false).GetAwaiter().GetResult();
1151              }
1152              throw;
1153          }
1154          finally
1155          {
1156              PosInColumn += ColumnLen;
1157          }
1158          var objectResultType = Command.ObjectResultTypes?[ordinal];
1159          if (objectResultType != null)
1160          {
1161              result = objectResultType == typeof(DateTimeOffset)
1162                  ? new DateTimeOffset((DateTime)result)
1163                  : Convert.ChangeType(result, objectResultType)!;
1164          }
1165          return result;
1166      }
1167      public override object this[string name] => GetValue(GetOrdinal(name));
1168      #endregion
1169      #region IsDBNull
1170      public override bool IsDBNull(int ordinal)
1171      {
1172          CheckRowAndGetField(ordinal);
1173          if (_isSequential)
1174              SeekToColumnSequential(ordinal, false).GetAwaiter().GetResult();
1175          else
1176              SeekToColumnNonSequential(ordinal);
1177          return ColumnLen == -1;
1178      }
1179      public override Task<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken)
1180      {
1181          CheckRowAndGetField(ordinal);
1182          if (!_isSequential)
1183              return IsDBNull(ordinal) ? PGUtil.TrueTask : PGUtil.FalseTask;
1184          using (NoSynchronizationContextScope.Enter())
1185              return IsDBNullAsyncInternal(ordinal, cancellationToken);
1186          async Task<bool> IsDBNullAsyncInternal(int ordinal, CancellationToken cancellationToken)
1187          {
1188              using var registration = Connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
1189              await SeekToColumn(ordinal, true, cancellationToken);
1190              return ColumnLen == -1;
1191          }
1192      }
1193      #endregion
1194      #region Other public accessors
1195      public override int GetOrdinal(string name)
1196      {
1197          if (string.IsNullOrEmpty(name))
1198              ThrowHelper.ThrowArgumentException($"{nameof(name)} cannot be empty", nameof(name));
1199          CheckClosedOrDisposed();
1200          if (RowDescription is null)
1201              ThrowHelper.ThrowInvalidOperationException("No resultset is currently being traversed");
1202          return RowDescription.GetFieldIndex(name);
1203      }
1204      public PostgresType GetPostgresType(int ordinal) => GetField(ordinal).PostgresType;
1205      public override string GetDataTypeName(int ordinal) => GetField(ordinal).TypeDisplayName;
1206      public uint GetDataTypeOID(int ordinal) => GetField(ordinal).TypeOID;
1207      public override Type GetFieldType(int ordinal)
1208          => Command.ObjectResultTypes?[ordinal]
1209             ?? GetField(ordinal).FieldType;
1210      public override IEnumerator GetEnumerator()
1211          => new DbEnumerator(this);
1212      public ReadOnlyCollection<NpgsqlDbColumn> GetColumnSchema()
1213          => GetColumnSchema(async: false).GetAwaiter().GetResult();
1214      ReadOnlyCollection<DbColumn> IDbColumnSchemaGenerator.GetColumnSchema()
1215          => new(GetColumnSchema().Select(c => (DbColumn)c).ToList());
1216  #if NET5_0_OR_GREATER
1217      public new Task<ReadOnlyCollection<NpgsqlDbColumn>> GetColumnSchemaAsync(CancellationToken cancellationToken = default)
1218  #else
1219      public Task<ReadOnlyCollection<NpgsqlDbColumn>> GetColumnSchemaAsync(CancellationToken cancellationToken = default)
1220  #endif
1221      {
1222          using (NoSynchronizationContextScope.Enter())
1223              return GetColumnSchema(async: true, cancellationToken);
1224      }
1225      Task<ReadOnlyCollection<NpgsqlDbColumn>> GetColumnSchema(bool async, CancellationToken cancellationToken = default)
1226          => RowDescription == null || RowDescription.Count == 0
1227              ? Task.FromResult(new List<NpgsqlDbColumn>().AsReadOnly())
1228              : new DbColumnSchemaGenerator(_connection!, RowDescription, _behavior.HasFlag(CommandBehavior.KeyInfo))
1229                  .GetColumnSchema(async, cancellationToken);
1230      #endregion
1231      #region Schema metadata table
1232      [UnconditionalSuppressMessage(
1233          "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.", "IL2026")]
1234      public override DataTable? GetSchemaTable()
1235          => GetSchemaTable(async: false).GetAwaiter().GetResult();
1236      [UnconditionalSuppressMessage(
1237          "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.", "IL2026")]
1238  #if NET5_0_OR_GREATER
1239      public override Task<DataTable?> GetSchemaTableAsync(CancellationToken cancellationToken = default)
1240  #else
1241      public Task<DataTable?> GetSchemaTableAsync(CancellationToken cancellationToken = default)
1242  #endif
1243      {
1244          using (NoSynchronizationContextScope.Enter())
1245              return GetSchemaTable(async: true, cancellationToken);
1246      }
1247      [UnconditionalSuppressMessage(
1248          "Composite type mapping currently isn't trimming-safe, and warnings are generated at the MapComposite level.", "IL2026")]
1249      async Task<DataTable?> GetSchemaTable(bool async, CancellationToken cancellationToken = default)
1250      {
1251          if (FieldCount == 0) 
1252              return null;
1253          var table = new DataTable("SchemaTable");
1254          table.Columns.Add("ColumnName", typeof(string));
1255          table.Columns.Add("ColumnOrdinal", typeof(int));
1256          table.Columns.Add("ColumnSize", typeof(int));
1257          table.Columns.Add("NumericPrecision", typeof(int));
1258          table.Columns.Add("NumericScale", typeof(int));
1259          table.Columns.Add("IsUnique", typeof(bool));
1260          table.Columns.Add("IsKey", typeof(bool));
1261          table.Columns.Add("BaseServerName", typeof(string));
1262          table.Columns.Add("BaseCatalogName", typeof(string));
1263          table.Columns.Add("BaseColumnName", typeof(string));
1264          table.Columns.Add("BaseSchemaName", typeof(string));
1265          table.Columns.Add("BaseTableName", typeof(string));
1266          table.Columns.Add("DataType", typeof(Type));
1267          table.Columns.Add("AllowDBNull", typeof(bool));
1268          table.Columns.Add("ProviderType", typeof(int));
1269          table.Columns.Add("IsAliased", typeof(bool));
1270          table.Columns.Add("IsExpression", typeof(bool));
1271          table.Columns.Add("IsIdentity", typeof(bool));
1272          table.Columns.Add("IsAutoIncrement", typeof(bool));
1273          table.Columns.Add("IsRowVersion", typeof(bool));
1274          table.Columns.Add("IsHidden", typeof(bool));
1275          table.Columns.Add("IsLong", typeof(bool));
1276          table.Columns.Add("IsReadOnly", typeof(bool));
1277          table.Columns.Add("ProviderSpecificDataType", typeof(Type));
1278          table.Columns.Add("DataTypeName", typeof(string));
1279          foreach (var column in await GetColumnSchema(async, cancellationToken))
1280          {
1281              var row = table.NewRow();
1282              row["ColumnName"] = column.ColumnName;
1283              row["ColumnOrdinal"] = column.ColumnOrdinal ?? -1;
1284              row["ColumnSize"] = column.ColumnSize ?? -1;
1285              row["NumericPrecision"] = column.NumericPrecision ?? 0;
1286              row["NumericScale"] = column.NumericScale ?? 0;
1287              row["IsUnique"] = column.IsUnique == true;
1288              row["IsKey"] = column.IsKey == true;
1289              row["BaseServerName"] = "";
1290              row["BaseCatalogName"] = column.BaseCatalogName;
1291              row["BaseColumnName"] = column.BaseColumnName;
1292              row["BaseSchemaName"] = column.BaseSchemaName;
1293              row["BaseTableName"] = column.BaseTableName;
1294              row["DataType"] = column.DataType;
1295              row["AllowDBNull"] = (object?)column.AllowDBNull ?? DBNull.Value;
1296              row["ProviderType"] = column.NpgsqlDbType ?? NpgsqlDbType.Unknown;
1297              row["IsAliased"] = column.IsAliased == true;
1298              row["IsExpression"] = column.IsExpression == true;
1299              row["IsIdentity"] = column.IsIdentity == true;
1300              row["IsAutoIncrement"] = column.IsAutoIncrement == true;
1301              row["IsRowVersion"] = false;
1302              row["IsHidden"] = column.IsHidden == true;
1303              row["IsLong"] = column.IsLong == true;
1304              row["DataTypeName"] = column.DataTypeName;
1305              table.Rows.Add(row);
1306          }
1307          return table;
1308      }
1309      #endregion Schema metadata table
1310      #region Seeking
1311      Task SeekToColumn(int column, bool async, CancellationToken cancellationToken = default)
1312      {
1313          if (_isSequential)
1314              return SeekToColumnSequential(column, async, cancellationToken);
1315          SeekToColumnNonSequential(column);
1316          return Task.CompletedTask;
1317      }
1318      void SeekToColumnNonSequential(int column)
1319      {
1320          if (_columnStream != null)
1321          {
1322              _columnStream.Dispose();
1323              _columnStream = null;
1324          }
1325          for (var lastColumnRead = _columns.Count; column >= lastColumnRead; lastColumnRead++)
1326          {
1327              int lastColumnLen;
1328              (Buffer.ReadPosition, lastColumnLen) = _columns[lastColumnRead - 1];
1329              if (lastColumnLen != -1)
1330                  Buffer.ReadPosition += lastColumnLen;
1331              var len = Buffer.ReadInt32();
1332              _columns.Add((Buffer.ReadPosition, len));
1333          }
1334          (Buffer.ReadPosition, ColumnLen) = _columns[column];
1335          _column = column;
1336          PosInColumn = 0;
1337      }
1338      async Task SeekToColumnSequential(int column, bool async, CancellationToken cancellationToken = default)
1339      {
1340          if (column < 0 || column >= _numColumns)
1341              throw new IndexOutOfRangeException("Column index out of range");
1342          if (column < _column)
1343              throw new InvalidOperationException($"Invalid attempt to read from column ordinal '{column}'. With CommandBehavior.SequentialAccess, you may only read from column ordinal '{_column}' or greater.");
1344          if (column == _column)
1345              return;
1346          if (_columnStream != null)
1347          {
1348              _columnStream.Dispose();
1349              _columnStream = null;
1350              PosInColumn = ColumnLen;
1351          }
1352          var remainingInColumn = ColumnLen == -1 ? 0 : ColumnLen - PosInColumn;
1353          if (remainingInColumn > 0)
1354              await Buffer.Skip(remainingInColumn, async);
1355          for (; _column < column - 1; _column++)
1356          {
1357              await Buffer.Ensure(4, async);
1358              var len = Buffer.ReadInt32();
1359              if (len != -1)
1360                  await Buffer.Skip(len, async);
1361          }
1362          await Buffer.Ensure(4, async);
1363          ColumnLen = Buffer.ReadInt32();
1364          PosInColumn = 0;
1365          _column = column;
1366      }
1367      Task SeekInColumn(int dataOffset, bool async, CancellationToken cancellationToken = default)
1368      {
1369          if (_isSequential)
1370              return SeekInColumnSequential(dataOffset, async);
1371          if (dataOffset >= ColumnLen)
1372              ThrowHelper.ThrowArgumentOutOfRange_OutOfColumnBounds(nameof(dataOffset), ColumnLen);
1373          Buffer.ReadPosition = _columns[_column].Offset + dataOffset;
1374          PosInColumn = dataOffset;
1375          return Task.CompletedTask;
1376          async Task SeekInColumnSequential(int dataOffset, bool async)
1377          {
1378              Debug.Assert(_column > -1);
1379              if (dataOffset < PosInColumn)
1380                  ThrowHelper.ThrowInvalidOperationException("Attempt to read a position in the column which has already been read");
1381              if (dataOffset >= ColumnLen)
1382                  ThrowHelper.ThrowArgumentOutOfRange_OutOfColumnBounds(nameof(dataOffset), ColumnLen);
1383              if (dataOffset > PosInColumn)
1384              {
1385                  await Buffer.Skip(dataOffset - PosInColumn, async);
1386                  PosInColumn = dataOffset;
1387              }
1388          }
1389      }
1390      #endregion
1391      #region ConsumeRow
1392      Task ConsumeRow(bool async)
1393      {
1394          Debug.Assert(State == ReaderState.InResult || State == ReaderState.BeforeResult);
1395          UniqueRowId++;
1396          if (!_canConsumeRowNonSequentially)
1397              return ConsumeRowSequential(async);
1398          ConsumeRowNonSequential();
1399          return Task.CompletedTask;
1400          async Task ConsumeRowSequential(bool async)
1401          {
1402              if (_columnStream != null)
1403              {
1404                  _columnStream.Dispose();
1405                  _columnStream = null;
1406                  PosInColumn = ColumnLen;
1407              }
1408              var remainingInColumn = ColumnLen == -1 ? 0 : ColumnLen - PosInColumn;
1409              if (remainingInColumn > 0)
1410                  await Buffer.Skip(remainingInColumn, async);
1411              for (; _column < _numColumns - 1; _column++)
1412              {
1413                  await Buffer.Ensure(4, async);
1414                  var len = Buffer.ReadInt32();
1415                  if (len != -1)
1416                      await Buffer.Skip(len, async);
1417              }
1418          }
1419      }
1420      [MethodImpl(MethodImplOptions.AggressiveInlining)]
1421      void ConsumeRowNonSequential()
1422      {
1423          Debug.Assert(State == ReaderState.InResult || State == ReaderState.BeforeResult);
1424          if (_columnStream is not null)
1425          {
1426              _columnStream.Dispose();
1427              _columnStream = null;
1428              PosInColumn = ColumnLen;
1429          }
1430          Buffer.ReadPosition = _dataMsgEnd;
1431      }
1432      #endregion
1433      #region Checks
1434      void CheckResultSet()
1435      {
1436          switch (State)
1437          {
1438          case ReaderState.BeforeResult:
1439          case ReaderState.InResult:
1440              return;
1441          case ReaderState.Closed:
1442              ThrowHelper.ThrowInvalidOperationException("The reader is closed");
1443              return;
1444          case ReaderState.Disposed:
1445              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlDataReader));
1446              return;
1447          default:
1448              ThrowHelper.ThrowInvalidOperationException("No resultset is currently being traversed");
1449              return;
1450          }
1451      }
1452      FieldDescription CheckRowAndGetField(int column)
1453      {
1454          switch (State)
1455          {
1456          case ReaderState.InResult:
1457              break;
1458          case ReaderState.Closed:
1459              ThrowHelper.ThrowInvalidOperationException("The reader is closed");
1460              break;
1461          case ReaderState.Disposed:
1462              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlDataReader));
1463              break;
1464          default:
1465              ThrowHelper.ThrowInvalidOperationException("No row is available");
1466              break;
1467          }
1468          if (column < 0 || column >= RowDescription!.Count)
1469              ThrowColumnOutOfRange(RowDescription!.Count);
1470          return RowDescription[column];
1471      }
1472      FieldDescription GetField(int column)
1473      {
1474          if (RowDescription is null)
1475              ThrowHelper.ThrowInvalidOperationException("No resultset is currently being traversed");
1476          if (column < 0 || column >= RowDescription.Count)
1477              ThrowColumnOutOfRange(RowDescription.Count);
1478          return RowDescription[column];
1479      }
1480      void CheckColumnStart()
1481      {
1482          Debug.Assert(_isSequential);
1483          if (PosInColumn != 0)
1484              ThrowHelper.ThrowInvalidOperationException("Attempt to read a position in the column which has already been read");
1485      }
1486      void CheckClosedOrDisposed()
1487      {
1488          switch (State)
1489          {
1490          case ReaderState.Closed:
1491              ThrowHelper.ThrowInvalidOperationException("The reader is closed");
1492              return;
1493          case ReaderState.Disposed:
1494              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlDataReader));
1495              return;
1496          }
1497      }
1498      static void ThrowColumnOutOfRange(int maxIndex) =>
1499          throw new IndexOutOfRangeException($"Column must be between {0} and {maxIndex - 1}");
1500      #endregion
1501      #region Misc
1502      internal void UnbindIfNecessary()
1503      {
1504          if (State != ReaderState.Disposed)
1505          {
1506              Connector.DataReader = Connector.UnboundDataReader is { State: ReaderState.Disposed } previousReader
1507                  ? previousReader
1508                  : new NpgsqlDataReader(Connector);
1509              Connector.UnboundDataReader = this;
1510          }
1511      }
1512      #endregion
1513  }
1514  enum ReaderState
1515  {
1516      BeforeResult,
1517      InResult,
1518      BetweenResults,
1519      Consumed,
1520      Closed,
1521      Disposed,
1522  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-TemplateMemory.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlDataReader.cs</div>
                </div>
                <div class="column column_space"><pre><code>56              var bytes = CalculateBytes(sequence);
57              AddBytes(bytes);
58          }
</pre></code></div>
                <div class="column column_space"><pre><code>1060          var field = CheckRowAndGetField(ordinal);
1061          SeekToColumnNonSequential(ordinal);
1062          if (ColumnLen == -1)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    