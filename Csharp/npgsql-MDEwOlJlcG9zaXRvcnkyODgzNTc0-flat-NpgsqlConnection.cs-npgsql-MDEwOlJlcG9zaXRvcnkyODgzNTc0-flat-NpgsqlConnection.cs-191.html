
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnection.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Data;
5  using System.Data.Common;
6  using System.Diagnostics;
7  using System.Diagnostics.CodeAnalysis;
8  using System.IO;
9  using System.Net.Security;
10  using System.Net.Sockets;
11  using System.Runtime.CompilerServices;
12  using System.Security.Cryptography.X509Certificates;
13  using System.Threading;
14  using System.Threading.Tasks;
15  using System.Transactions;
16  using Microsoft.Extensions.Logging;
17  using Npgsql.Internal;
18  using Npgsql.TypeMapping;
19  using Npgsql.Util;
20  using IsolationLevel = System.Data.IsolationLevel;
21  namespace Npgsql;
22  [System.ComponentModel.DesignerCategory(&quot;&quot;)]
23  public sealed class NpgsqlConnection : DbConnection, ICloneable, IComponent
24  {
25      #region Fields
26      bool _disposed;
27      string _userFacingConnectionString = string.Empty;
28      string _connectionString = string.Empty;
29      ConnectionState _fullState;
30      internal NpgsqlConnector? Connector { get; set; }
31      internal NpgsqlConnectionStringBuilder Settings { get; private set; } = DefaultSettings;
32      static readonly NpgsqlConnectionStringBuilder DefaultSettings = new();
33      NpgsqlDataSource? _dataSource;
34      internal NpgsqlDataSource NpgsqlDataSource
35      {
36          get
37          {
38              Debug.Assert(_dataSource is not null);
39              return _dataSource;
40          }
41      }
42      int _closing;
43      internal Transaction? EnlistedTransaction { get; set; }
44      [Obsolete(&quot;Global-level type mapping has been replaced with data source mapping, see the 7.0 release notes.&quot;)]
45      public static INpgsqlTypeMapper GlobalTypeMapper =&gt; TypeMapping.GlobalTypeMapper.Instance;
46      [Obsolete(&quot;Connection-level type mapping is no longer supported. See the 7.0 release notes for configuring type mapping on NpgsqlDataSource.&quot;, true)]
47      public INpgsqlTypeMapper TypeMapper
48          =&gt; throw new NotSupportedException();
49      static Func&lt;string, NpgsqlConnection&gt;? _cloningInstantiator;
50      public const int DefaultPort = 5432;
51      internal const int TimeoutLimit = 1024;
52      internal ConnectorBindingScope ConnectorBindingScope { get; set; }
53      ILogger _connectionLogger = default!; 
54      static readonly StateChangeEventArgs ClosedToOpenEventArgs = new(ConnectionState.Closed, ConnectionState.Open);
55      static readonly StateChangeEventArgs OpenToClosedEventArgs = new(ConnectionState.Open, ConnectionState.Closed);
56      #endregion Fields
57      #region Constructors / Init / Open
58      public NpgsqlConnection()
59          =&gt; GC.SuppressFinalize(this);
60      public NpgsqlConnection(string? connectionString) : this()
61          =&gt; ConnectionString = connectionString;
62      internal NpgsqlConnection(NpgsqlDataSource dataSource, NpgsqlConnector connector) : this()
63      {
64          _dataSource = dataSource;
65          Settings = dataSource.Settings;
66          _userFacingConnectionString = dataSource.ConnectionString;
67          Connector = connector;
68          connector.Connection = this;
69          ConnectorBindingScope = ConnectorBindingScope.Connection;
70          FullState = ConnectionState.Open;
71      }
72      internal static NpgsqlConnection FromDataSource(NpgsqlDataSource dataSource)
73          =&gt; new()
74          {
75              _dataSource = dataSource,
76              Settings = dataSource.Settings,
77              _userFacingConnectionString = dataSource.ConnectionString,
78          };
79      public override void Open() =&gt; Open(false, CancellationToken.None).GetAwaiter().GetResult();
80      public override Task OpenAsync(CancellationToken cancellationToken)
81      {
82          using (NoSynchronizationContextScope.Enter())
83              return Open(true, cancellationToken);
84      }
85      void SetupDataSource()
86      {
87          if (PoolManager.Pools.TryGetValue(_connectionString, out _dataSource))
88          {
89              Settings = _dataSource.Settings;  
90              return;
91          }
92          if (_connectionString == string.Empty)
93          {
94              Settings = DefaultSettings;
95              _dataSource = null;
96              return;
97          }
98          var settings = new NpgsqlConnectionStringBuilder(_connectionString);
99          settings.PostProcessAndValidate();
100          Settings = settings;
101          var canonical = settings.ConnectionStringForMultipleHosts;
102          if (PoolManager.Pools.TryGetValue(canonical, out _dataSource))
103          {
104              if (_dataSource is NpgsqlMultiHostDataSource multiHostDataSource &amp;&amp; settings.TargetSessionAttributesParsed.HasValue)
105                  _dataSource = multiHostDataSource.WithTargetSession(settings.TargetSessionAttributesParsed.Value);
106              _dataSource = PoolManager.Pools.GetOrAdd(_connectionString, _dataSource);
107              return;
108          }
109          var dataSourceBuilder = new NpgsqlDataSourceBuilder(canonical);
110          dataSourceBuilder.UseLoggerFactory(NpgsqlLoggingConfiguration.GlobalLoggerFactory);
111          dataSourceBuilder.EnableParameterLogging(NpgsqlLoggingConfiguration.GlobalIsParameterLoggingEnabled);
112          var newDataSource = dataSourceBuilder.Build();
113          _cloningInstantiator = s =&gt; new NpgsqlConnection(s);
114          _dataSource = PoolManager.Pools.GetOrAdd(canonical, newDataSource);
115          if (_dataSource == newDataSource)
116          {
117              Debug.Assert(_dataSource is not MultiHostDataSourceWrapper);
118              if (_dataSource is NpgsqlMultiHostDataSource multiHostConnectorPool)
119                  foreach (var hostPool in multiHostConnectorPool.Pools)
120                      NpgsqlEventSource.Log.DataSourceCreated(hostPool);
121              else
122                  NpgsqlEventSource.Log.DataSourceCreated(newDataSource);
123          }
124          else
125              newDataSource.Dispose();
126          if (_dataSource is NpgsqlMultiHostDataSource multiHostDataSource2 &amp;&amp; settings.TargetSessionAttributesParsed.HasValue)
127              _dataSource = multiHostDataSource2.WithTargetSession(settings.TargetSessionAttributesParsed.Value);
128          _dataSource = PoolManager.Pools.GetOrAdd(_connectionString, _dataSource);
129      }
130      internal Task Open(bool async, CancellationToken cancellationToken)
131      {
132          CheckClosed();
133          Debug.Assert(Connector == null);
134          if (_dataSource is null)
135          {
136              Debug.Assert(string.IsNullOrEmpty(_connectionString));
137              throw new InvalidOperationException(&quot;The ConnectionString property has not been initialized.&quot;);
138          }
139          FullState = ConnectionState.Connecting;
140          _userFacingConnectionString = _dataSource.ConnectionString;
141          _connectionLogger = _dataSource.LoggingConfiguration.ConnectionLogger;
142          LogMessages.OpeningConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
143          if (Settings.Multiplexing)
144          {
145              if (Settings.Enlist &amp;&amp; Transaction.Current != null)
146              {
147                  throw new NotSupportedException();
148              }
149              if (!((MultiplexingDataSource)_dataSource).StartupCheckPerformed)
150                  return PerformMultiplexingStartupCheck(async, cancellationToken);
151              LogMessages.OpenedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
152              FullState = ConnectionState.Open;
153              return Task.CompletedTask;
154          }
155          return OpenAsync(async, cancellationToken);
156          async Task OpenAsync(bool async, CancellationToken cancellationToken)
157          {
158              Debug.Assert(!Settings.Multiplexing);
159              NpgsqlConnector? connector = null;
160              try
161              {
162                  var connectionTimeout = TimeSpan.FromSeconds(ConnectionTimeout);
163                  var timeout = new NpgsqlTimeout(connectionTimeout);
164                  var enlistToTransaction = Settings.Enlist ? Transaction.Current : null;
165                  if (enlistToTransaction is not null &amp;&amp; _dataSource.TryRentEnlistedPending(enlistToTransaction, this, out connector))
166                  {
167                      EnlistedTransaction = enlistToTransaction;
168                      enlistToTransaction = null;
169                  }
170                  else
171                      connector = await _dataSource.Get(this, timeout, async, cancellationToken);
172                  Debug.Assert(connector.Connection is null,
173                      $&quot;Connection for opened connector &#x27;{Connector?.Id.ToString() ?? &quot;???&quot;}&#x27; is bound to another connection&quot;);
174                  ConnectorBindingScope = ConnectorBindingScope.Connection;
175                  connector.Connection = this;
176                  Connector = connector;
177                  if (enlistToTransaction is not null)
178                      EnlistTransaction(enlistToTransaction);
179                  LogMessages.OpenedConnection(_connectionLogger, Host!, Port, Database, _userFacingConnectionString, connector.Id);
180                  FullState = ConnectionState.Open;
181              }
182              catch
183              {
184                  FullState = ConnectionState.Closed;
185                  ConnectorBindingScope = ConnectorBindingScope.None;
186                  Connector = null;
187                  EnlistedTransaction = null;
188                  if (connector is not null)
189                  {
190                      connector.Connection = null;
191                      connector.Return();
192                  }
193                  throw;
194              }
195          }
196          async Task PerformMultiplexingStartupCheck(bool async, CancellationToken cancellationToken)
197          {
198              try
199              {
200                  var timeout = new NpgsqlTimeout(TimeSpan.FromSeconds(ConnectionTimeout));
201                  _ = await StartBindingScope(ConnectorBindingScope.Connection, timeout, async, cancellationToken);
202                  EndBindingScope(ConnectorBindingScope.Connection);
203                  LogMessages.OpenedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
204                  ((MultiplexingDataSource)NpgsqlDataSource).StartupCheckPerformed = true;
205                  FullState = ConnectionState.Open;
206              }
207              catch
208              {
209                  FullState = ConnectionState.Closed;
210                  throw;
211              }
212          }
213      }
214      #endregion Open / Init
215      #region Connection string management
216      [AllowNull]
217      public override string ConnectionString
218      {
219          get =&gt; _userFacingConnectionString;
220          set
221          {
222              CheckClosed();
223              _userFacingConnectionString = _connectionString = value ?? string.Empty;
224              SetupDataSource();
225          }
226      }
227      [Obsolete(&quot;Use NpgsqlDataSourceBuilder.UsePeriodicPasswordProvider or inject passwords directly into NpgsqlDataSource.Password&quot;)]
228      public ProvidePasswordCallback? ProvidePasswordCallback { get; set; }
229      #endregion Connection string management
230      #region Configuration settings
231      [Browsable(true)]
232      public string? Host =&gt; Connector?.Host;
233      [Browsable(true)]
234      public int Port =&gt; Connector?.Port ?? 0;
235      public override int ConnectionTimeout =&gt; Settings.Timeout;
236      public int CommandTimeout =&gt; Settings.CommandTimeout;
237      public override string Database =&gt; Settings.Database ?? Settings.Username ?? &quot;&quot;;
238      public override string DataSource =&gt; Connector?.Settings.DataSourceCached ?? _dataSource?.Settings.DataSourceCached ?? string.Empty;
239      [Obsolete(&quot;The IntegratedSecurity parameter is no longer needed and does nothing.&quot;)]
240      public bool IntegratedSecurity =&gt; Settings.IntegratedSecurity;
241      public string? UserName =&gt; Settings.Username;
242      internal string? EntityTemplateDatabase =&gt; Settings.EntityTemplateDatabase;
243      internal string? EntityAdminDatabase =&gt; Settings.EntityAdminDatabase;
244      #endregion Configuration settings
245      #region State management
246      [Browsable(false)]
247      public ConnectionState FullState
248      {
249          get
250          {
251              if (_fullState != ConnectionState.Open)
252                  return _fullState;
253              if (Connector is null)
254                  return ConnectionState.Open; 
255              switch (Connector.State)
256              {
257              case ConnectorState.Ready:
258                  return ConnectionState.Open;
259              case ConnectorState.Executing:
260                  return ConnectionState.Open | ConnectionState.Executing;
261              case ConnectorState.Fetching:
262                  return ConnectionState.Open | ConnectionState.Fetching;
263              case ConnectorState.Copy:
264                  return ConnectionState.Open | ConnectionState.Fetching;
265              case ConnectorState.Replication:
266                  return ConnectionState.Open | ConnectionState.Fetching;
267              case ConnectorState.Waiting:
268                  return ConnectionState.Open | ConnectionState.Fetching;
269              case ConnectorState.Connecting:
270                  return ConnectionState.Connecting;
271              case ConnectorState.Broken:
272                  return ConnectionState.Broken;
273              case ConnectorState.Closed:
274                  ThrowHelper.ThrowInvalidOperationException(&quot;Internal Npgsql bug: connection is in state Open but connector is in state Closed&quot;);
275                  return ConnectionState.Broken;
276              default:
277                  ThrowHelper.ThrowInvalidOperationException($&quot;Internal Npgsql bug: unexpected value {{0}} of enum {nameof(ConnectorState)}. Please file a bug.&quot;, Connector.State);
278                  return ConnectionState.Broken;
279              }
280          }
281          internal set
282          {
283              var originalOpen = _fullState.HasFlag(ConnectionState.Open);
284              _fullState = value;
285              var currentOpen = _fullState.HasFlag(ConnectionState.Open);
286              if (currentOpen != originalOpen)
287              {
288                  OnStateChange(currentOpen
289                      ? ClosedToOpenEventArgs
290                      : OpenToClosedEventArgs);
291              }
292          }
293      }
294      [Browsable(false)]
295      public override ConnectionState State
296      {
297          get
298          {
299              var fullState = FullState;
300              if (fullState.HasFlag(ConnectionState.Connecting))
301                  return ConnectionState.Connecting;
302              if (fullState.HasFlag(ConnectionState.Open))
303                  return ConnectionState.Open;
304              return ConnectionState.Closed;
305          }
306      }
307      #endregion State management
308      #region Command / Batch creation
309      internal NpgsqlCommand? CachedCommand { get; set; }
310      protected override DbCommand CreateDbCommand() =&gt; CreateCommand();
311      public new NpgsqlCommand CreateCommand()
312      {
313          CheckDisposed();
314          var cachedCommand = CachedCommand;
315          if (cachedCommand is not null)
316          {
317              CachedCommand = null;
318              cachedCommand.State = CommandState.Idle;
319              return cachedCommand;
320          }
321          return NpgsqlCommand.CreateCachedCommand(this);
322      }
323      internal NpgsqlBatch? CachedBatch { get; set; }
324  #if NET6_0_OR_GREATER
325      public override bool CanCreateBatch =&gt; true;
326      protected override DbBatch CreateDbBatch() =&gt; CreateBatch();
327      public new NpgsqlBatch CreateBatch()
328      {
329          CheckDisposed();
330          var cachedBatch = CachedBatch;
331          if (cachedBatch is not null)
332          {
333              CachedBatch = null;
334              return cachedBatch;
335          }
336          return NpgsqlBatch.CreateCachedBatch(this);
337      }
338  #else
339      public NpgsqlBatch CreateBatch() =&gt; new(this);
340  #endif
341      #endregion Command / Batch creation
342      #region Transactions
343      protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel) =&gt; BeginTransaction(isolationLevel);
344      public new NpgsqlTransaction BeginTransaction()
345          =&gt; BeginTransaction(IsolationLevel.Unspecified);
346      public new NpgsqlTransaction BeginTransaction(IsolationLevel level)
347          =&gt; BeginTransaction(level, async: false, CancellationToken.None).GetAwaiter().GetResult();
348      async ValueTask&lt;NpgsqlTransaction&gt; BeginTransaction(IsolationLevel level, bool async, CancellationToken cancellationToken)
349      {
350          if (level == IsolationLevel.Chaos)
351              ThrowHelper.ThrowNotSupportedException($&quot;Unsupported IsolationLevel: {nameof(IsolationLevel.Chaos)}&quot;);
352          CheckReady();
353          if (Connector is { InTransaction: true })
354              ThrowHelper.ThrowInvalidOperationException(&quot;A transaction is already in progress; nested/concurrent transactions aren&#x27;t supported.&quot;);
355          var connector = ConnectorBindingScope == ConnectorBindingScope.Transaction
356              ? Connector
357              : await StartBindingScope(ConnectorBindingScope.Transaction, NpgsqlTimeout.Infinite, async, cancellationToken);
358          Debug.Assert(connector != null);
359          try
360          {
361              using var _ = connector.StartUserAction(cancellationToken);
362              connector.Transaction ??= new NpgsqlTransaction(connector);
363              connector.Transaction.Init(level);
364              return connector.Transaction;
365          }
366          catch
367          {
368              EndBindingScope(ConnectorBindingScope.Transaction);
369              throw;
370          }
371      }
372  #if !NETSTANDARD2_0
373      protected override async ValueTask&lt;DbTransaction&gt; BeginDbTransactionAsync(IsolationLevel isolationLevel, CancellationToken cancellationToken)
374          =&gt; await BeginTransactionAsync(isolationLevel, cancellationToken);
375      public new ValueTask&lt;NpgsqlTransaction&gt; BeginTransactionAsync(CancellationToken cancellationToken = default)
376          =&gt; BeginTransactionAsync(IsolationLevel.Unspecified, cancellationToken);
377      public new ValueTask&lt;NpgsqlTransaction&gt; BeginTransactionAsync(IsolationLevel level, CancellationToken cancellationToken = default)
378      {
379          using (NoSynchronizationContextScope.Enter())
380              return BeginTransaction(level, async: true, cancellationToken);
381      }
382  #endif
383      public override void EnlistTransaction(Transaction? transaction)
384      {
385          if (Settings.Multiplexing)
386              throw new NotSupportedException(&quot;Ambient transactions aren&#x27;t yet implemented for multiplexing&quot;);
387          if (EnlistedTransaction != null)
388          {
389              if (EnlistedTransaction.Equals(transaction))
390                  return;
391              try
392              {
393                  if (EnlistedTransaction.TransactionInformation.Status == System.Transactions.TransactionStatus.Active)
394                      throw new InvalidOperationException($&quot;Already enlisted to transaction (localid={EnlistedTransaction.TransactionInformation.LocalIdentifier})&quot;);
395              }
396              catch (ObjectDisposedException)
397              {
398              }
399          }
400          CheckReady();
401          var connector = StartBindingScope(ConnectorBindingScope.Transaction);
402          EnlistedTransaction = transaction;
403          if (transaction == null)
404          {
405              EndBindingScope(ConnectorBindingScope.Transaction);
406              return;
407          }
408          var volatileResourceManager = new VolatileResourceManager(this, transaction);
409          transaction.EnlistVolatile(volatileResourceManager, EnlistmentOptions.None);
410          volatileResourceManager.Init();
411          EnlistedTransaction = transaction;
412          LogMessages.EnlistedVolatileResourceManager(
413              Connector!.LoggingConfiguration.TransactionLogger,
414              transaction.TransactionInformation.LocalIdentifier,
415              connector.Id);
416      }
417      #endregion
418      #region Close
419      public override void Close() =&gt; Close(async: false).GetAwaiter().GetResult();
420  #if NETSTANDARD2_0
421      public Task CloseAsync()
422  #else
423      public override Task CloseAsync()
424  #endif
425      {
426          using (NoSynchronizationContextScope.Enter())
427              return Close(async: true);
428      }
429      internal bool TakeCloseLock() =&gt; Interlocked.Exchange(ref _closing, 1) == 0;
430      internal void ReleaseCloseLock() =&gt; Volatile.Write(ref _closing, 0);
431      internal Task Close(bool async)
432      {
433          if (!TakeCloseLock())
434              return Task.CompletedTask;
435          switch (FullState)
436          {
437          case ConnectionState.Open:
438          case ConnectionState.Open | ConnectionState.Executing:
439          case ConnectionState.Open | ConnectionState.Fetching:
440              break;
441          case ConnectionState.Broken:
442              FullState = ConnectionState.Closed;
443              goto case ConnectionState.Closed;
444          case ConnectionState.Closed:
445              ReleaseCloseLock();
446              return Task.CompletedTask;
447          case ConnectionState.Connecting:
<span onclick='openModal()' class='match'>448              ReleaseCloseLock();
449              throw new InvalidOperationException(&quot;Can&#x27;t close, connection is in state &quot; + FullState);
450          default:
</span>451              ReleaseCloseLock();
452              throw new ArgumentOutOfRangeException(&quot;Unknown connection state: &quot; + FullState);
453          }
454          if (Settings.Multiplexing &amp;&amp; ConnectorBindingScope == ConnectorBindingScope.None)
455          {
456              Debug.Assert(Connector == null);
457              ReleaseCloseLock();
458              FullState = ConnectionState.Closed;
459              LogMessages.ClosedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
460              return Task.CompletedTask;
461          }
462          return CloseAsync(async);            
463      }
464      async Task CloseAsync(bool async)
465      {
466          Debug.Assert(Connector != null);
467          Debug.Assert(ConnectorBindingScope != ConnectorBindingScope.None);
468          try
469          {
470              var connector = Connector;
471              LogMessages.ClosingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString, connector.Id);
472              if (connector.CurrentReader != null || connector.CurrentCopyOperation != null)
473              {
474                  await connector.CloseOngoingOperations(async);
475                  if (ConnectorBindingScope == ConnectorBindingScope.None)
476                  {
477                      Debug.Assert(Settings.Multiplexing);
478                      Debug.Assert(Connector is null);
479                      FullState = ConnectionState.Closed;
480                      LogMessages.ClosedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
481                      return;
482                  }
483              }
484              Debug.Assert(connector.IsReady || connector.IsBroken);
485              Debug.Assert(connector.CurrentReader == null);
486              Debug.Assert(connector.CurrentCopyOperation == null);
487              if (EnlistedTransaction != null)
488              {
489                  connector.Connection = null;
490                  _dataSource?.AddPendingEnlistedConnector(connector, EnlistedTransaction);
491                  EnlistedTransaction = null;
492              }
493              else
494              {
495                  if (Settings.Pooling)
496                  {
497                      await connector.Reset(async);
498                  }
499                  else
500                  {
501                      connector.Transaction?.UnbindIfNecessary();
502                  }  
503                  if (Settings.Multiplexing)
504                  {
505                      Debug.Assert(ConnectorBindingScope == ConnectorBindingScope.None,
506                          $&quot;When closing a multiplexed connection, the connection was supposed to be unbound, but {nameof(ConnectorBindingScope)} was {ConnectorBindingScope}&quot;);
507                  }
508                  else
509                  {
510                      connector.Connection = null;
511                      connector.Return();
512                  }
513              }
514              LogMessages.ClosedConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString, connector.Id);
515              Connector = null;
516              ConnectorBindingScope = ConnectorBindingScope.None;
517              FullState = ConnectionState.Closed;
518          }
519          finally
520          {
521              ReleaseCloseLock();
522          }
523      }
524      protected override void Dispose(bool disposing)
525      {
526          if (_disposed)
527              return;
528          if (disposing)
529              Close();
530          _disposed = true;
531      }
532  #if NETSTANDARD2_0
533      public ValueTask DisposeAsync()
534  #else
535      public override ValueTask DisposeAsync()
536  #endif
537      {
538          using (NoSynchronizationContextScope.Enter())
539              return DisposeAsyncCore();
540          [MethodImpl(MethodImplOptions.AggressiveInlining)]
541          async ValueTask DisposeAsyncCore()
542          {
543              if (_disposed)
544                  return;
545              await CloseAsync();
546              _disposed = true;
547          }
548      }
549      internal void MakeDisposed()
550          =&gt; _disposed = true;
551      #endregion
552      #region Notifications and Notices
553      public event NoticeEventHandler? Notice;
554      public event NotificationEventHandler? Notification;
555      internal void OnNotice(PostgresNotice e)
556      {
557          try
558          {
559              Notice?.Invoke(this, new NpgsqlNoticeEventArgs(e));
560          }
561          catch (Exception ex)
562          {
563              LogMessages.CaughtUserExceptionInNoticeEventHandler(_connectionLogger, ex);
564          }
565      }
566      internal void OnNotification(NpgsqlNotificationEventArgs e)
567      {
568          try
569          {
570              Notification?.Invoke(this, e);
571          }
572          catch (Exception ex)
573          {
574              LogMessages.CaughtUserExceptionInNotificationEventHandler(_connectionLogger, ex);
575          }
576      }
577      #endregion Notifications and Notices
578      #region SSL
579      internal bool IsSecure =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.IsSecure);
580      internal bool IsScram =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.IsScram);
581      internal bool IsScramPlus =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.IsScramPlus);
582      public ProvideClientCertificatesCallback? ProvideClientCertificatesCallback { get; set; }
583      public RemoteCertificateValidationCallback? UserCertificateValidationCallback { get; set; }
584      #endregion SSL
585      #region Backend version, capabilities, settings
586      [Browsable(false)]
587      public Version PostgreSqlVersion =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.DatabaseInfo.Version);
588      public override string ServerVersion =&gt; CheckOpenAndRunInTemporaryScope(
589          c =&gt; c.DatabaseInfo.ServerVersion);
590      [Browsable(false)]
591      public int ProcessID
592      {
593          get
594          {
595              CheckOpen();
596              return TryGetBoundConnector(out var connector)
597                  ? connector.BackendProcessId
598                  : throw new InvalidOperationException(&quot;No bound physical connection (using multiplexing)&quot;);
599          }
600      }
601      [Browsable(false)]
602      public bool HasIntegerDateTimes =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.DatabaseInfo.HasIntegerDateTimes);
603      [Browsable(false)]
604      public string Timezone =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.Timezone);
605      [Browsable(false)]
606      public IReadOnlyDictionary&lt;string, string&gt; PostgresParameters
607          =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.PostgresParameters);
608      #endregion Backend version, capabilities, settings
609      #region Copy
610      public NpgsqlBinaryImporter BeginBinaryImport(string copyFromCommand)
611          =&gt; BeginBinaryImport(copyFromCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
612      public Task&lt;NpgsqlBinaryImporter&gt; BeginBinaryImportAsync(string copyFromCommand, CancellationToken cancellationToken = default)
613      {
614          using (NoSynchronizationContextScope.Enter())
615              return BeginBinaryImport(copyFromCommand, async: true, cancellationToken);
616      }
617      async Task&lt;NpgsqlBinaryImporter&gt; BeginBinaryImport(string copyFromCommand, bool async, CancellationToken cancellationToken = default)
618      {
619          if (copyFromCommand == null)
620              throw new ArgumentNullException(nameof(copyFromCommand));
621          if (!IsValidCopyCommand(copyFromCommand))
622              throw new ArgumentException(&quot;Must contain a COPY FROM STDIN command!&quot;, nameof(copyFromCommand));
623          CheckReady();
624          var connector = StartBindingScope(ConnectorBindingScope.Copy);
625          LogMessages.StartingBinaryImport(connector.LoggingConfiguration.CopyLogger, connector.Id);
626          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
627          try
628          {
629              var importer = new NpgsqlBinaryImporter(connector);
630              await importer.Init(copyFromCommand, async, cancellationToken);
631              connector.CurrentCopyOperation = importer;
632              return importer;
633          }
634          catch
635          {
636              connector.EndUserAction();
637              EndBindingScope(ConnectorBindingScope.Copy);
638              throw;
639          }
640      }
641      public NpgsqlBinaryExporter BeginBinaryExport(string copyToCommand)
642          =&gt; BeginBinaryExport(copyToCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
643      public Task&lt;NpgsqlBinaryExporter&gt; BeginBinaryExportAsync(string copyToCommand, CancellationToken cancellationToken = default)
644      {
645          using (NoSynchronizationContextScope.Enter())
646              return BeginBinaryExport(copyToCommand, async: true, cancellationToken);
647      } 
648      async Task&lt;NpgsqlBinaryExporter&gt; BeginBinaryExport(string copyToCommand, bool async, CancellationToken cancellationToken = default)
649      {
650          if (copyToCommand == null)
651              throw new ArgumentNullException(nameof(copyToCommand));
652          if (!IsValidCopyCommand(copyToCommand))
653              throw new ArgumentException(&quot;Must contain a COPY TO STDOUT command!&quot;, nameof(copyToCommand));
654          CheckReady();
655          var connector = StartBindingScope(ConnectorBindingScope.Copy);
656          LogMessages.StartingBinaryExport(connector.LoggingConfiguration.CopyLogger, connector.Id);
657          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
658          try
659          {
660              var exporter = new NpgsqlBinaryExporter(connector);
661              await exporter.Init(copyToCommand, async, cancellationToken);
662              connector.CurrentCopyOperation = exporter;
663              return exporter;
664          }
665          catch
666          {
667              connector.EndUserAction();
668              EndBindingScope(ConnectorBindingScope.Copy);
669              throw;
670          }
671      }
672      public TextWriter BeginTextImport(string copyFromCommand)
673          =&gt; BeginTextImport(copyFromCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
674      public Task&lt;TextWriter&gt; BeginTextImportAsync(string copyFromCommand, CancellationToken cancellationToken = default)
675      {
676          using (NoSynchronizationContextScope.Enter())
677              return BeginTextImport(copyFromCommand, async: true, cancellationToken);
678      }
679      async Task&lt;TextWriter&gt; BeginTextImport(string copyFromCommand, bool async, CancellationToken cancellationToken = default)
680      {
681          if (copyFromCommand == null)
682              throw new ArgumentNullException(nameof(copyFromCommand));
683          if (!IsValidCopyCommand(copyFromCommand))
684              throw new ArgumentException(&quot;Must contain a COPY FROM STDIN command!&quot;, nameof(copyFromCommand));
685          CheckReady();
686          var connector = StartBindingScope(ConnectorBindingScope.Copy);
687          LogMessages.StartingTextImport(connector.LoggingConfiguration.CopyLogger, connector.Id);
688          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
689          try
690          {
691              var copyStream = new NpgsqlRawCopyStream(connector);
692              await copyStream.Init(copyFromCommand, async, cancellationToken);
693              var writer = new NpgsqlCopyTextWriter(connector, copyStream);
694              connector.CurrentCopyOperation = writer;
695              return writer;
696          }
697          catch
698          {
699              connector.EndUserAction();
700              EndBindingScope(ConnectorBindingScope.Copy);
701              throw;
702          }
703      }
704      public TextReader BeginTextExport(string copyToCommand)
705          =&gt; BeginTextExport(copyToCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
706      public Task&lt;TextReader&gt; BeginTextExportAsync(string copyToCommand, CancellationToken cancellationToken = default)
707      {
708          using (NoSynchronizationContextScope.Enter())
709              return BeginTextExport(copyToCommand, async: true, cancellationToken);
710      }
711      async Task&lt;TextReader&gt; BeginTextExport(string copyToCommand, bool async, CancellationToken cancellationToken = default)
712      {
713          if (copyToCommand == null)
714              throw new ArgumentNullException(nameof(copyToCommand));
715          if (!IsValidCopyCommand(copyToCommand))
716              throw new ArgumentException(&quot;Must contain a COPY TO STDOUT command!&quot;, nameof(copyToCommand));
717          CheckReady();
718          var connector = StartBindingScope(ConnectorBindingScope.Copy);
719          LogMessages.StartingTextExport(connector.LoggingConfiguration.CopyLogger, connector.Id);
720          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
721          try
722          {
723              var copyStream = new NpgsqlRawCopyStream(connector);
724              await copyStream.Init(copyToCommand, async, cancellationToken);
725              var reader = new NpgsqlCopyTextReader(connector, copyStream);
726              connector.CurrentCopyOperation = reader;
727              return reader;
728          }
729          catch
730          {
731              connector.EndUserAction();
732              EndBindingScope(ConnectorBindingScope.Copy);
733              throw;
734          }
735      }
736      public NpgsqlRawCopyStream BeginRawBinaryCopy(string copyCommand)
737          =&gt; BeginRawBinaryCopy(copyCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
738      public Task&lt;NpgsqlRawCopyStream&gt; BeginRawBinaryCopyAsync(string copyCommand, CancellationToken cancellationToken = default)
739      {
740          using (NoSynchronizationContextScope.Enter())
741              return BeginRawBinaryCopy(copyCommand, async: true, cancellationToken);
742      }
743      async Task&lt;NpgsqlRawCopyStream&gt; BeginRawBinaryCopy(string copyCommand, bool async, CancellationToken cancellationToken = default)
744      {
745          if (copyCommand == null)
746              throw new ArgumentNullException(nameof(copyCommand));
747          if (!IsValidCopyCommand(copyCommand))
748              throw new ArgumentException(&quot;Must contain a COPY TO STDOUT OR COPY FROM STDIN command!&quot;, nameof(copyCommand));
749          CheckReady();
750          var connector = StartBindingScope(ConnectorBindingScope.Copy);
751          LogMessages.StartingRawCopy(connector.LoggingConfiguration.CopyLogger, connector.Id);
752          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
753          try
754          {
755              var stream = new NpgsqlRawCopyStream(connector);
756              await stream.Init(copyCommand, async, cancellationToken);
757              if (!stream.IsBinary)
758              {
759                  throw connector.Break(new ArgumentException(
760                      &quot;copyToCommand triggered a text transfer, only binary is allowed&quot;, nameof(copyCommand)));
761              }
762              connector.CurrentCopyOperation = stream;
763              return stream;
764          }
765          catch
766          {
767              connector.EndUserAction();
768              EndBindingScope(ConnectorBindingScope.Copy);
769              throw;
770          }
771      }
772      static bool IsValidCopyCommand(string copyCommand)
773      {
774      #if NET6_0_OR_GREATER || NETSTANDARD2_1
775          return copyCommand.AsSpan().TrimStart().StartsWith(&quot;COPY&quot;, StringComparison.OrdinalIgnoreCase);
776      #else
777          return copyCommand.TrimStart().StartsWith(&quot;COPY&quot;, StringComparison.OrdinalIgnoreCase);
778      #endif
779      }
780      #endregion
781      #region Wait
782      public bool Wait(int timeout)
783      {
784          if (timeout != -1 &amp;&amp; timeout &lt; 0)
785              throw new ArgumentException(&quot;Argument must be -1, 0 or positive&quot;, nameof(timeout));
786          if (Settings.Multiplexing)
787              throw new NotSupportedException($&quot;{nameof(Wait)} isn&#x27;t supported in multiplexing mode&quot;);
788          CheckReady();
789          LogMessages.StartingWait(_connectionLogger, timeout, Connector!.Id);
790          return Connector!.Wait(async: false, timeout, CancellationToken.None).GetAwaiter().GetResult();
791      }
792      public bool Wait(TimeSpan timeout) =&gt; Wait((int)timeout.TotalMilliseconds);
793      public void Wait() =&gt; Wait(0);
794      public Task&lt;bool&gt; WaitAsync(int timeout, CancellationToken cancellationToken = default)
795      {
796          if (Settings.Multiplexing)
797              throw new NotSupportedException($&quot;{nameof(Wait)} isn&#x27;t supported in multiplexing mode&quot;);
798          CheckReady();
799          LogMessages.StartingWait(_connectionLogger, timeout, Connector!.Id);
800          using (NoSynchronizationContextScope.Enter())
801              return Connector!.Wait(async: true, timeout, cancellationToken);
802      }
803      public Task&lt;bool&gt; WaitAsync(TimeSpan timeout, CancellationToken cancellationToken = default) =&gt; WaitAsync((int)timeout.TotalMilliseconds, cancellationToken);
804      public Task WaitAsync(CancellationToken cancellationToken = default) =&gt; WaitAsync(0, cancellationToken);
805      #endregion
806      #region State checks
807      [MethodImpl(MethodImplOptions.AggressiveInlining)]
808      void CheckOpen()
809      {
810          CheckDisposed();
811          switch (FullState)
812          {
813          case ConnectionState.Open:
814          case ConnectionState.Open | ConnectionState.Executing:
815          case ConnectionState.Open | ConnectionState.Fetching:
816          case ConnectionState.Connecting:
817              return;
818          case ConnectionState.Closed:
819          case ConnectionState.Broken:
820              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is not open&quot;);
821              return;
822          default:
823              ThrowHelper.ThrowArgumentOutOfRangeException();
824              return;
825          }
826      }
827      void CheckClosed()
828      {
829          CheckDisposed();
830          switch (FullState)
831          {
832          case ConnectionState.Closed:
833          case ConnectionState.Broken:
834              return;
835          case ConnectionState.Open:
836          case ConnectionState.Connecting:
837          case ConnectionState.Open | ConnectionState.Executing:
838          case ConnectionState.Open | ConnectionState.Fetching:
839              ThrowHelper.ThrowInvalidOperationException(&quot;Connection already open&quot;);
840              return;
841          default:
842              ThrowHelper.ThrowArgumentOutOfRangeException();
843              return;
844          }
845      }
846      void CheckDisposed()
847      {
848          if (_disposed)
849              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlConnection));
850      }
851      internal void CheckReady()
852      {
853          CheckDisposed();
854          switch (FullState)
855          {
856          case ConnectionState.Open:
857          case ConnectionState.Connecting:  
858              return;
859          case ConnectionState.Closed:
860          case ConnectionState.Broken:
861              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is not open&quot;);
862              return;
863          case ConnectionState.Open | ConnectionState.Executing:
864          case ConnectionState.Open | ConnectionState.Fetching:
865              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is busy&quot;);
866              return;
867          default:
868              ThrowHelper.ThrowArgumentOutOfRangeException();
869              return;
870          }
871      }
872      #endregion State checks
873      #region Connector binding
874      internal bool TryGetBoundConnector([NotNullWhen(true)] out NpgsqlConnector? connector)
875      {
876          if (ConnectorBindingScope == ConnectorBindingScope.None)
877          {
878              Debug.Assert(Connector == null, $&quot;Binding scope is None but {Connector} exists&quot;);
879              connector = null;
880              return false;
881          }
882          Debug.Assert(Connector != null, $&quot;Binding scope is {ConnectorBindingScope} but {Connector} is null&quot;);
883          Debug.Assert(Connector.Connection == this, $&quot;Bound connector {Connector} does not reference this connection&quot;);
884          connector = Connector;
885          return true;
886      }
887      internal ValueTask&lt;NpgsqlConnector&gt; StartBindingScope(
888          ConnectorBindingScope scope, NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken)
889      {
890          if (ConnectorBindingScope != ConnectorBindingScope.None)
891          {
892              Debug.Assert(Connector != null, $&quot;Connection bound with scope {ConnectorBindingScope} but has no connector&quot;);
893              Debug.Assert(scope != ConnectorBindingScope, $&quot;Binding scopes aren&#x27;t reentrant ({ConnectorBindingScope})&quot;);
894              return new ValueTask&lt;NpgsqlConnector&gt;(Connector);
895          }
896          return StartBindingScopeAsync();
897          async ValueTask&lt;NpgsqlConnector&gt; StartBindingScopeAsync()
898          {
899              try
900              {
901                  Debug.Assert(Settings.Multiplexing);
902                  Debug.Assert(_dataSource != null);
903                  var connector = await _dataSource.Get(this, timeout, async, cancellationToken);
904                  Connector = connector;
905                  connector.Connection = this;
906                  ConnectorBindingScope = scope;
907                  return connector;
908              }
909              catch
910              {
911                  FullState = ConnectionState.Broken;
912                  throw;
913              }
914          }
915      }
916      internal NpgsqlConnector StartBindingScope(ConnectorBindingScope scope)
917          =&gt; StartBindingScope(scope, NpgsqlTimeout.Infinite, async: false, CancellationToken.None)
918              .GetAwaiter().GetResult();
919      internal EndScopeDisposable StartTemporaryBindingScope(out NpgsqlConnector connector)
920      {
921          connector = StartBindingScope(ConnectorBindingScope.Temporary);
922          return new EndScopeDisposable(this);
923      }
924      internal T CheckOpenAndRunInTemporaryScope&lt;T&gt;(Func&lt;NpgsqlConnector, T&gt; func)
925      {
926          CheckOpen();
927          using var _ = StartTemporaryBindingScope(out var connector);
928          var result = func(connector);
929          return result;
930      }
931      internal void EndBindingScope(ConnectorBindingScope scope)
932      {
933          Debug.Assert(ConnectorBindingScope != ConnectorBindingScope.None || FullState == ConnectionState.Broken,
934              $&quot;Ending binding scope {scope} but connection&#x27;s scope is null&quot;);
935          if (scope != ConnectorBindingScope)
936              return;
937          Debug.Assert(Connector != null, $&quot;Ending binding scope {scope} but connector is null&quot;);
938          Debug.Assert(_dataSource != null, $&quot;Ending binding scope {scope} but _pool is null&quot;);
939          Debug.Assert(Settings.Multiplexing, $&quot;Ending binding scope {scope} but multiplexing is disabled&quot;);
940          var connector = Connector;
941          Connector = null;
942          connector.Connection = null;
943          connector.Transaction?.UnbindIfNecessary();
944          connector.Return();
945          ConnectorBindingScope = ConnectorBindingScope.None;
946      }
947      #endregion Connector binding
948      #region Schema operations
949      [UnconditionalSuppressMessage(
950          &quot;Composite type mapping currently isn&#x27;t trimming-safe, and warnings are generated at the MapComposite level.&quot;, &quot;IL2026&quot;)]
951      public override DataTable GetSchema()
952          =&gt; GetSchema(&quot;MetaDataCollections&quot;, null);
953      public override DataTable GetSchema(string? collectionName) =&gt; GetSchema(collectionName, null);
954      public override DataTable GetSchema(string? collectionName, string?[]? restrictions)
955          =&gt; NpgsqlSchema.GetSchema(this, collectionName, restrictions, async: false).GetAwaiter().GetResult();
956  #if NET5_0_OR_GREATER
957      public override Task&lt;DataTable&gt; GetSchemaAsync(CancellationToken cancellationToken = default)
958  #else
959      public Task&lt;DataTable&gt; GetSchemaAsync(CancellationToken cancellationToken = default)
960  #endif
961          =&gt; GetSchemaAsync(&quot;MetaDataCollections&quot;, null, cancellationToken);
962  #if NET5_0_OR_GREATER
963      public override Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default)
964  #else
965      public Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default)
966  #endif
967          =&gt; GetSchemaAsync(collectionName, null, cancellationToken);
968  #if NET5_0_OR_GREATER
969      public override Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, string?[]? restrictions, CancellationToken cancellationToken = default)
970  #else
971      public Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, string?[]? restrictions, CancellationToken cancellationToken = default)
972  #endif
973      {
974          using (NoSynchronizationContextScope.Enter())
975              return NpgsqlSchema.GetSchema(this, collectionName, restrictions, async: true, cancellationToken);
976      }
977      #endregion Schema operations
978      #region Misc
979      object ICloneable.Clone()
980      {
981          CheckDisposed();
982          Debug.Assert(_dataSource is not null || _cloningInstantiator is not null);
983          var conn = _dataSource is null
984              ? _cloningInstantiator!(_connectionString)
985              : _dataSource.CreateConnection();
986          conn.ProvideClientCertificatesCallback = ProvideClientCertificatesCallback;
987          conn.UserCertificateValidationCallback = UserCertificateValidationCallback;
988  #pragma warning disable CS0618 
989          conn.ProvidePasswordCallback = ProvidePasswordCallback;
990  #pragma warning restore CS0618
991          conn._userFacingConnectionString = _userFacingConnectionString;
992          return conn;
993      }
994      public NpgsqlConnection CloneWith(string connectionString)
995      {
996          CheckDisposed();
997          var csb = new NpgsqlConnectionStringBuilder(connectionString);
998          csb.Password ??= _dataSource?.GetPassword(async: false).GetAwaiter().GetResult();
999          if (csb.PersistSecurityInfo &amp;&amp; !Settings.PersistSecurityInfo)
1000              csb.PersistSecurityInfo = false;
1001          return new NpgsqlConnection(csb.ToString())
1002          {
1003              ProvideClientCertificatesCallback =
1004                  ProvideClientCertificatesCallback ??
1005                  (_dataSource?.ClientCertificatesCallback is { } clientCertificatesCallback
1006                      ? (ProvideClientCertificatesCallback)(certs =&gt; clientCertificatesCallback(certs))
1007                      : null),
1008              UserCertificateValidationCallback = UserCertificateValidationCallback ?? _dataSource?.UserCertificateValidationCallback,
1009  #pragma warning disable CS0618 
1010              ProvidePasswordCallback = ProvidePasswordCallback,
1011  #pragma warning restore CS0618
1012          };
1013      }
1014      public override void ChangeDatabase(string dbName)
1015      {
1016          if (dbName == null)
1017              throw new ArgumentNullException(nameof(dbName));
1018          if (string.IsNullOrEmpty(dbName))
1019              throw new ArgumentOutOfRangeException(nameof(dbName), dbName, $&quot;Invalid database name: {dbName}&quot;);
1020          CheckOpen();
1021          Close();
1022          _dataSource = null;
1023          Settings = Settings.Clone();
1024          Settings.Database = dbName;
1025          ConnectionString = Settings.ToString();
1026          Open();
1027      }
1028      protected override DbProviderFactory DbProviderFactory =&gt; NpgsqlFactory.Instance;
1029      public static void ClearPool(NpgsqlConnection connection) =&gt; PoolManager.Clear(connection._connectionString);
1030      public static void ClearAllPools() =&gt; PoolManager.ClearAll();
1031      public void UnprepareAll()
1032      {
1033          if (Settings.Multiplexing)
1034              throw new NotSupportedException(&quot;Explicit preparation not supported with multiplexing&quot;);
1035          CheckReady();
1036          using (Connector!.StartUserAction())
1037              Connector.UnprepareAll();
1038      }
1039      public void ReloadTypes()
1040      {
1041          CheckReady();
1042          using var scope = StartTemporaryBindingScope(out var connector);
1043          _dataSource!.Bootstrap(
1044              connector,
1045              NpgsqlTimeout.Infinite,
1046              forceReload: true,
1047              async: false,
1048              CancellationToken.None)
1049              .GetAwaiter().GetResult();
1050      }
1051      public async Task ReloadTypesAsync()
1052      {
1053          CheckReady();
1054          using var scope = StartTemporaryBindingScope(out var connector);
1055          await _dataSource!.Bootstrap(
1056                  connector,
1057                  NpgsqlTimeout.Infinite,
1058                  forceReload: true,
1059                  async: true,
1060                  CancellationToken.None);
1061      }
1062      [EditorBrowsable(EditorBrowsableState.Never)]
1063      public new event EventHandler? Disposed
1064      {
1065          add =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1066          remove =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1067      }
1068      event EventHandler? IComponent.Disposed
1069      {
1070          add =&gt; Disposed += value;
1071          remove =&gt; Disposed -= value;
1072      }
1073      #endregion Misc
1074  }
1075  enum ConnectorBindingScope
1076  {
1077      None,
1078      Connection,
1079      Transaction,
1080      Copy,
1081      Reader,
1082      Temporary
1083  }
1084  readonly struct EndScopeDisposable : IDisposable
1085  {
1086      readonly NpgsqlConnection _connection;
1087      public EndScopeDisposable(NpgsqlConnection connection) =&gt; _connection = connection;
1088      public void Dispose() =&gt; _connection.EndBindingScope(ConnectorBindingScope.Temporary);
1089  }
1090  #region Delegates
1091  public delegate void NoticeEventHandler(object sender, NpgsqlNoticeEventArgs e);
1092  public delegate void NotificationEventHandler(object sender, NpgsqlNotificationEventArgs e);
1093  public delegate void ProvideClientCertificatesCallback(X509CertificateCollection certificates);
1094  [Obsolete(&quot;Use NpgsqlDataSourceBuilder.UsePeriodicPasswordProvider or inject passwords directly into NpgsqlDataSource.Password&quot;)]
1095  public delegate string ProvidePasswordCallback(string host, int port, string database, string username);
1096  #endregion
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnection.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Data;
5  using System.Data.Common;
6  using System.Diagnostics;
7  using System.Diagnostics.CodeAnalysis;
8  using System.IO;
9  using System.Net.Security;
10  using System.Net.Sockets;
11  using System.Runtime.CompilerServices;
12  using System.Security.Cryptography.X509Certificates;
13  using System.Threading;
14  using System.Threading.Tasks;
15  using System.Transactions;
16  using Microsoft.Extensions.Logging;
17  using Npgsql.Internal;
18  using Npgsql.TypeMapping;
19  using Npgsql.Util;
20  using IsolationLevel = System.Data.IsolationLevel;
21  namespace Npgsql;
22  [System.ComponentModel.DesignerCategory(&quot;&quot;)]
23  public sealed class NpgsqlConnection : DbConnection, ICloneable, IComponent
24  {
25      #region Fields
26      bool _disposed;
27      string _userFacingConnectionString = string.Empty;
28      string _connectionString = string.Empty;
29      ConnectionState _fullState;
30      internal NpgsqlConnector? Connector { get; set; }
31      internal NpgsqlConnectionStringBuilder Settings { get; private set; } = DefaultSettings;
32      static readonly NpgsqlConnectionStringBuilder DefaultSettings = new();
33      NpgsqlDataSource? _dataSource;
34      internal NpgsqlDataSource NpgsqlDataSource
35      {
36          get
37          {
38              Debug.Assert(_dataSource is not null);
39              return _dataSource;
40          }
41      }
42      int _closing;
43      internal Transaction? EnlistedTransaction { get; set; }
44      [Obsolete(&quot;Global-level type mapping has been replaced with data source mapping, see the 7.0 release notes.&quot;)]
45      public static INpgsqlTypeMapper GlobalTypeMapper =&gt; TypeMapping.GlobalTypeMapper.Instance;
46      [Obsolete(&quot;Connection-level type mapping is no longer supported. See the 7.0 release notes for configuring type mapping on NpgsqlDataSource.&quot;, true)]
47      public INpgsqlTypeMapper TypeMapper
48          =&gt; throw new NotSupportedException();
49      static Func&lt;string, NpgsqlConnection&gt;? _cloningInstantiator;
50      public const int DefaultPort = 5432;
51      internal const int TimeoutLimit = 1024;
52      internal ConnectorBindingScope ConnectorBindingScope { get; set; }
53      ILogger _connectionLogger = default!; 
54      static readonly StateChangeEventArgs ClosedToOpenEventArgs = new(ConnectionState.Closed, ConnectionState.Open);
55      static readonly StateChangeEventArgs OpenToClosedEventArgs = new(ConnectionState.Open, ConnectionState.Closed);
56      #endregion Fields
57      #region Constructors / Init / Open
58      public NpgsqlConnection()
59          =&gt; GC.SuppressFinalize(this);
60      public NpgsqlConnection(string? connectionString) : this()
61          =&gt; ConnectionString = connectionString;
62      internal NpgsqlConnection(NpgsqlDataSource dataSource, NpgsqlConnector connector) : this()
63      {
64          _dataSource = dataSource;
65          Settings = dataSource.Settings;
66          _userFacingConnectionString = dataSource.ConnectionString;
67          Connector = connector;
68          connector.Connection = this;
69          ConnectorBindingScope = ConnectorBindingScope.Connection;
70          FullState = ConnectionState.Open;
71      }
72      internal static NpgsqlConnection FromDataSource(NpgsqlDataSource dataSource)
73          =&gt; new()
74          {
75              _dataSource = dataSource,
76              Settings = dataSource.Settings,
77              _userFacingConnectionString = dataSource.ConnectionString,
78          };
79      public override void Open() =&gt; Open(false, CancellationToken.None).GetAwaiter().GetResult();
80      public override Task OpenAsync(CancellationToken cancellationToken)
81      {
82          using (NoSynchronizationContextScope.Enter())
83              return Open(true, cancellationToken);
84      }
85      void SetupDataSource()
86      {
87          if (PoolManager.Pools.TryGetValue(_connectionString, out _dataSource))
88          {
89              Settings = _dataSource.Settings;  
90              return;
91          }
92          if (_connectionString == string.Empty)
93          {
94              Settings = DefaultSettings;
95              _dataSource = null;
96              return;
97          }
98          var settings = new NpgsqlConnectionStringBuilder(_connectionString);
99          settings.PostProcessAndValidate();
100          Settings = settings;
101          var canonical = settings.ConnectionStringForMultipleHosts;
102          if (PoolManager.Pools.TryGetValue(canonical, out _dataSource))
103          {
104              if (_dataSource is NpgsqlMultiHostDataSource multiHostDataSource &amp;&amp; settings.TargetSessionAttributesParsed.HasValue)
105                  _dataSource = multiHostDataSource.WithTargetSession(settings.TargetSessionAttributesParsed.Value);
106              _dataSource = PoolManager.Pools.GetOrAdd(_connectionString, _dataSource);
107              return;
108          }
109          var dataSourceBuilder = new NpgsqlDataSourceBuilder(canonical);
110          dataSourceBuilder.UseLoggerFactory(NpgsqlLoggingConfiguration.GlobalLoggerFactory);
111          dataSourceBuilder.EnableParameterLogging(NpgsqlLoggingConfiguration.GlobalIsParameterLoggingEnabled);
112          var newDataSource = dataSourceBuilder.Build();
113          _cloningInstantiator = s =&gt; new NpgsqlConnection(s);
114          _dataSource = PoolManager.Pools.GetOrAdd(canonical, newDataSource);
115          if (_dataSource == newDataSource)
116          {
117              Debug.Assert(_dataSource is not MultiHostDataSourceWrapper);
118              if (_dataSource is NpgsqlMultiHostDataSource multiHostConnectorPool)
119                  foreach (var hostPool in multiHostConnectorPool.Pools)
120                      NpgsqlEventSource.Log.DataSourceCreated(hostPool);
121              else
122                  NpgsqlEventSource.Log.DataSourceCreated(newDataSource);
123          }
124          else
125              newDataSource.Dispose();
126          if (_dataSource is NpgsqlMultiHostDataSource multiHostDataSource2 &amp;&amp; settings.TargetSessionAttributesParsed.HasValue)
127              _dataSource = multiHostDataSource2.WithTargetSession(settings.TargetSessionAttributesParsed.Value);
128          _dataSource = PoolManager.Pools.GetOrAdd(_connectionString, _dataSource);
129      }
130      internal Task Open(bool async, CancellationToken cancellationToken)
131      {
132          CheckClosed();
133          Debug.Assert(Connector == null);
134          if (_dataSource is null)
135          {
136              Debug.Assert(string.IsNullOrEmpty(_connectionString));
137              throw new InvalidOperationException(&quot;The ConnectionString property has not been initialized.&quot;);
138          }
139          FullState = ConnectionState.Connecting;
140          _userFacingConnectionString = _dataSource.ConnectionString;
141          _connectionLogger = _dataSource.LoggingConfiguration.ConnectionLogger;
142          LogMessages.OpeningConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
143          if (Settings.Multiplexing)
144          {
145              if (Settings.Enlist &amp;&amp; Transaction.Current != null)
146              {
147                  throw new NotSupportedException();
148              }
149              if (!((MultiplexingDataSource)_dataSource).StartupCheckPerformed)
150                  return PerformMultiplexingStartupCheck(async, cancellationToken);
151              LogMessages.OpenedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
152              FullState = ConnectionState.Open;
153              return Task.CompletedTask;
154          }
155          return OpenAsync(async, cancellationToken);
156          async Task OpenAsync(bool async, CancellationToken cancellationToken)
157          {
158              Debug.Assert(!Settings.Multiplexing);
159              NpgsqlConnector? connector = null;
160              try
161              {
162                  var connectionTimeout = TimeSpan.FromSeconds(ConnectionTimeout);
163                  var timeout = new NpgsqlTimeout(connectionTimeout);
164                  var enlistToTransaction = Settings.Enlist ? Transaction.Current : null;
165                  if (enlistToTransaction is not null &amp;&amp; _dataSource.TryRentEnlistedPending(enlistToTransaction, this, out connector))
166                  {
167                      EnlistedTransaction = enlistToTransaction;
168                      enlistToTransaction = null;
169                  }
170                  else
171                      connector = await _dataSource.Get(this, timeout, async, cancellationToken);
172                  Debug.Assert(connector.Connection is null,
173                      $&quot;Connection for opened connector &#x27;{Connector?.Id.ToString() ?? &quot;???&quot;}&#x27; is bound to another connection&quot;);
174                  ConnectorBindingScope = ConnectorBindingScope.Connection;
175                  connector.Connection = this;
176                  Connector = connector;
177                  if (enlistToTransaction is not null)
178                      EnlistTransaction(enlistToTransaction);
179                  LogMessages.OpenedConnection(_connectionLogger, Host!, Port, Database, _userFacingConnectionString, connector.Id);
180                  FullState = ConnectionState.Open;
181              }
182              catch
183              {
184                  FullState = ConnectionState.Closed;
185                  ConnectorBindingScope = ConnectorBindingScope.None;
186                  Connector = null;
187                  EnlistedTransaction = null;
188                  if (connector is not null)
189                  {
190                      connector.Connection = null;
191                      connector.Return();
192                  }
193                  throw;
194              }
195          }
196          async Task PerformMultiplexingStartupCheck(bool async, CancellationToken cancellationToken)
197          {
198              try
199              {
200                  var timeout = new NpgsqlTimeout(TimeSpan.FromSeconds(ConnectionTimeout));
201                  _ = await StartBindingScope(ConnectorBindingScope.Connection, timeout, async, cancellationToken);
202                  EndBindingScope(ConnectorBindingScope.Connection);
203                  LogMessages.OpenedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
204                  ((MultiplexingDataSource)NpgsqlDataSource).StartupCheckPerformed = true;
205                  FullState = ConnectionState.Open;
206              }
207              catch
208              {
209                  FullState = ConnectionState.Closed;
210                  throw;
211              }
212          }
213      }
214      #endregion Open / Init
215      #region Connection string management
216      [AllowNull]
217      public override string ConnectionString
218      {
219          get =&gt; _userFacingConnectionString;
220          set
221          {
222              CheckClosed();
223              _userFacingConnectionString = _connectionString = value ?? string.Empty;
224              SetupDataSource();
225          }
226      }
227      [Obsolete(&quot;Use NpgsqlDataSourceBuilder.UsePeriodicPasswordProvider or inject passwords directly into NpgsqlDataSource.Password&quot;)]
228      public ProvidePasswordCallback? ProvidePasswordCallback { get; set; }
229      #endregion Connection string management
230      #region Configuration settings
231      [Browsable(true)]
232      public string? Host =&gt; Connector?.Host;
233      [Browsable(true)]
234      public int Port =&gt; Connector?.Port ?? 0;
235      public override int ConnectionTimeout =&gt; Settings.Timeout;
236      public int CommandTimeout =&gt; Settings.CommandTimeout;
237      public override string Database =&gt; Settings.Database ?? Settings.Username ?? &quot;&quot;;
238      public override string DataSource =&gt; Connector?.Settings.DataSourceCached ?? _dataSource?.Settings.DataSourceCached ?? string.Empty;
239      [Obsolete(&quot;The IntegratedSecurity parameter is no longer needed and does nothing.&quot;)]
240      public bool IntegratedSecurity =&gt; Settings.IntegratedSecurity;
241      public string? UserName =&gt; Settings.Username;
242      internal string? EntityTemplateDatabase =&gt; Settings.EntityTemplateDatabase;
243      internal string? EntityAdminDatabase =&gt; Settings.EntityAdminDatabase;
244      #endregion Configuration settings
245      #region State management
246      [Browsable(false)]
247      public ConnectionState FullState
248      {
249          get
250          {
251              if (_fullState != ConnectionState.Open)
252                  return _fullState;
253              if (Connector is null)
254                  return ConnectionState.Open; 
255              switch (Connector.State)
256              {
257              case ConnectorState.Ready:
258                  return ConnectionState.Open;
259              case ConnectorState.Executing:
260                  return ConnectionState.Open | ConnectionState.Executing;
261              case ConnectorState.Fetching:
262                  return ConnectionState.Open | ConnectionState.Fetching;
263              case ConnectorState.Copy:
264                  return ConnectionState.Open | ConnectionState.Fetching;
265              case ConnectorState.Replication:
266                  return ConnectionState.Open | ConnectionState.Fetching;
267              case ConnectorState.Waiting:
268                  return ConnectionState.Open | ConnectionState.Fetching;
269              case ConnectorState.Connecting:
270                  return ConnectionState.Connecting;
271              case ConnectorState.Broken:
272                  return ConnectionState.Broken;
273              case ConnectorState.Closed:
274                  ThrowHelper.ThrowInvalidOperationException(&quot;Internal Npgsql bug: connection is in state Open but connector is in state Closed&quot;);
275                  return ConnectionState.Broken;
276              default:
277                  ThrowHelper.ThrowInvalidOperationException($&quot;Internal Npgsql bug: unexpected value {{0}} of enum {nameof(ConnectorState)}. Please file a bug.&quot;, Connector.State);
278                  return ConnectionState.Broken;
279              }
280          }
281          internal set
282          {
283              var originalOpen = _fullState.HasFlag(ConnectionState.Open);
284              _fullState = value;
285              var currentOpen = _fullState.HasFlag(ConnectionState.Open);
286              if (currentOpen != originalOpen)
287              {
288                  OnStateChange(currentOpen
289                      ? ClosedToOpenEventArgs
290                      : OpenToClosedEventArgs);
291              }
292          }
293      }
294      [Browsable(false)]
295      public override ConnectionState State
296      {
297          get
298          {
299              var fullState = FullState;
300              if (fullState.HasFlag(ConnectionState.Connecting))
301                  return ConnectionState.Connecting;
302              if (fullState.HasFlag(ConnectionState.Open))
303                  return ConnectionState.Open;
304              return ConnectionState.Closed;
305          }
306      }
307      #endregion State management
308      #region Command / Batch creation
309      internal NpgsqlCommand? CachedCommand { get; set; }
310      protected override DbCommand CreateDbCommand() =&gt; CreateCommand();
311      public new NpgsqlCommand CreateCommand()
312      {
313          CheckDisposed();
314          var cachedCommand = CachedCommand;
315          if (cachedCommand is not null)
316          {
317              CachedCommand = null;
318              cachedCommand.State = CommandState.Idle;
319              return cachedCommand;
320          }
321          return NpgsqlCommand.CreateCachedCommand(this);
322      }
323      internal NpgsqlBatch? CachedBatch { get; set; }
324  #if NET6_0_OR_GREATER
325      public override bool CanCreateBatch =&gt; true;
326      protected override DbBatch CreateDbBatch() =&gt; CreateBatch();
327      public new NpgsqlBatch CreateBatch()
328      {
329          CheckDisposed();
330          var cachedBatch = CachedBatch;
331          if (cachedBatch is not null)
332          {
333              CachedBatch = null;
334              return cachedBatch;
335          }
336          return NpgsqlBatch.CreateCachedBatch(this);
337      }
338  #else
339      public NpgsqlBatch CreateBatch() =&gt; new(this);
340  #endif
341      #endregion Command / Batch creation
342      #region Transactions
343      protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel) =&gt; BeginTransaction(isolationLevel);
344      public new NpgsqlTransaction BeginTransaction()
345          =&gt; BeginTransaction(IsolationLevel.Unspecified);
346      public new NpgsqlTransaction BeginTransaction(IsolationLevel level)
347          =&gt; BeginTransaction(level, async: false, CancellationToken.None).GetAwaiter().GetResult();
348      async ValueTask&lt;NpgsqlTransaction&gt; BeginTransaction(IsolationLevel level, bool async, CancellationToken cancellationToken)
349      {
350          if (level == IsolationLevel.Chaos)
351              ThrowHelper.ThrowNotSupportedException($&quot;Unsupported IsolationLevel: {nameof(IsolationLevel.Chaos)}&quot;);
352          CheckReady();
353          if (Connector is { InTransaction: true })
354              ThrowHelper.ThrowInvalidOperationException(&quot;A transaction is already in progress; nested/concurrent transactions aren&#x27;t supported.&quot;);
355          var connector = ConnectorBindingScope == ConnectorBindingScope.Transaction
356              ? Connector
357              : await StartBindingScope(ConnectorBindingScope.Transaction, NpgsqlTimeout.Infinite, async, cancellationToken);
358          Debug.Assert(connector != null);
359          try
360          {
361              using var _ = connector.StartUserAction(cancellationToken);
362              connector.Transaction ??= new NpgsqlTransaction(connector);
363              connector.Transaction.Init(level);
364              return connector.Transaction;
365          }
366          catch
367          {
368              EndBindingScope(ConnectorBindingScope.Transaction);
369              throw;
370          }
371      }
372  #if !NETSTANDARD2_0
373      protected override async ValueTask&lt;DbTransaction&gt; BeginDbTransactionAsync(IsolationLevel isolationLevel, CancellationToken cancellationToken)
374          =&gt; await BeginTransactionAsync(isolationLevel, cancellationToken);
375      public new ValueTask&lt;NpgsqlTransaction&gt; BeginTransactionAsync(CancellationToken cancellationToken = default)
376          =&gt; BeginTransactionAsync(IsolationLevel.Unspecified, cancellationToken);
377      public new ValueTask&lt;NpgsqlTransaction&gt; BeginTransactionAsync(IsolationLevel level, CancellationToken cancellationToken = default)
378      {
379          using (NoSynchronizationContextScope.Enter())
380              return BeginTransaction(level, async: true, cancellationToken);
381      }
382  #endif
383      public override void EnlistTransaction(Transaction? transaction)
384      {
385          if (Settings.Multiplexing)
386              throw new NotSupportedException(&quot;Ambient transactions aren&#x27;t yet implemented for multiplexing&quot;);
387          if (EnlistedTransaction != null)
388          {
389              if (EnlistedTransaction.Equals(transaction))
390                  return;
391              try
392              {
393                  if (EnlistedTransaction.TransactionInformation.Status == System.Transactions.TransactionStatus.Active)
394                      throw new InvalidOperationException($&quot;Already enlisted to transaction (localid={EnlistedTransaction.TransactionInformation.LocalIdentifier})&quot;);
395              }
396              catch (ObjectDisposedException)
397              {
398              }
399          }
400          CheckReady();
401          var connector = StartBindingScope(ConnectorBindingScope.Transaction);
402          EnlistedTransaction = transaction;
403          if (transaction == null)
404          {
405              EndBindingScope(ConnectorBindingScope.Transaction);
406              return;
407          }
408          var volatileResourceManager = new VolatileResourceManager(this, transaction);
409          transaction.EnlistVolatile(volatileResourceManager, EnlistmentOptions.None);
410          volatileResourceManager.Init();
411          EnlistedTransaction = transaction;
412          LogMessages.EnlistedVolatileResourceManager(
413              Connector!.LoggingConfiguration.TransactionLogger,
414              transaction.TransactionInformation.LocalIdentifier,
415              connector.Id);
416      }
417      #endregion
418      #region Close
419      public override void Close() =&gt; Close(async: false).GetAwaiter().GetResult();
420  #if NETSTANDARD2_0
421      public Task CloseAsync()
422  #else
423      public override Task CloseAsync()
424  #endif
425      {
426          using (NoSynchronizationContextScope.Enter())
427              return Close(async: true);
428      }
429      internal bool TakeCloseLock() =&gt; Interlocked.Exchange(ref _closing, 1) == 0;
430      internal void ReleaseCloseLock() =&gt; Volatile.Write(ref _closing, 0);
431      internal Task Close(bool async)
432      {
433          if (!TakeCloseLock())
434              return Task.CompletedTask;
435          switch (FullState)
436          {
437          case ConnectionState.Open:
438          case ConnectionState.Open | ConnectionState.Executing:
439          case ConnectionState.Open | ConnectionState.Fetching:
440              break;
441          case ConnectionState.Broken:
442              FullState = ConnectionState.Closed;
443              goto case ConnectionState.Closed;
444          case ConnectionState.Closed:
445              ReleaseCloseLock();
446              return Task.CompletedTask;
447          case ConnectionState.Connecting:
448              ReleaseCloseLock();
449              throw new InvalidOperationException(&quot;Can&#x27;t close, connection is in state &quot; + FullState);
450          default:
<span onclick='openModal()' class='match'>451              ReleaseCloseLock();
452              throw new ArgumentOutOfRangeException(&quot;Unknown connection state: &quot; + FullState);
453          }
</span>454          if (Settings.Multiplexing &amp;&amp; ConnectorBindingScope == ConnectorBindingScope.None)
455          {
456              Debug.Assert(Connector == null);
457              ReleaseCloseLock();
458              FullState = ConnectionState.Closed;
459              LogMessages.ClosedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
460              return Task.CompletedTask;
461          }
462          return CloseAsync(async);            
463      }
464      async Task CloseAsync(bool async)
465      {
466          Debug.Assert(Connector != null);
467          Debug.Assert(ConnectorBindingScope != ConnectorBindingScope.None);
468          try
469          {
470              var connector = Connector;
471              LogMessages.ClosingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString, connector.Id);
472              if (connector.CurrentReader != null || connector.CurrentCopyOperation != null)
473              {
474                  await connector.CloseOngoingOperations(async);
475                  if (ConnectorBindingScope == ConnectorBindingScope.None)
476                  {
477                      Debug.Assert(Settings.Multiplexing);
478                      Debug.Assert(Connector is null);
479                      FullState = ConnectionState.Closed;
480                      LogMessages.ClosedMultiplexingConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString);
481                      return;
482                  }
483              }
484              Debug.Assert(connector.IsReady || connector.IsBroken);
485              Debug.Assert(connector.CurrentReader == null);
486              Debug.Assert(connector.CurrentCopyOperation == null);
487              if (EnlistedTransaction != null)
488              {
489                  connector.Connection = null;
490                  _dataSource?.AddPendingEnlistedConnector(connector, EnlistedTransaction);
491                  EnlistedTransaction = null;
492              }
493              else
494              {
495                  if (Settings.Pooling)
496                  {
497                      await connector.Reset(async);
498                  }
499                  else
500                  {
501                      connector.Transaction?.UnbindIfNecessary();
502                  }  
503                  if (Settings.Multiplexing)
504                  {
505                      Debug.Assert(ConnectorBindingScope == ConnectorBindingScope.None,
506                          $&quot;When closing a multiplexed connection, the connection was supposed to be unbound, but {nameof(ConnectorBindingScope)} was {ConnectorBindingScope}&quot;);
507                  }
508                  else
509                  {
510                      connector.Connection = null;
511                      connector.Return();
512                  }
513              }
514              LogMessages.ClosedConnection(_connectionLogger, Settings.Host!, Settings.Port, Settings.Database!, _userFacingConnectionString, connector.Id);
515              Connector = null;
516              ConnectorBindingScope = ConnectorBindingScope.None;
517              FullState = ConnectionState.Closed;
518          }
519          finally
520          {
521              ReleaseCloseLock();
522          }
523      }
524      protected override void Dispose(bool disposing)
525      {
526          if (_disposed)
527              return;
528          if (disposing)
529              Close();
530          _disposed = true;
531      }
532  #if NETSTANDARD2_0
533      public ValueTask DisposeAsync()
534  #else
535      public override ValueTask DisposeAsync()
536  #endif
537      {
538          using (NoSynchronizationContextScope.Enter())
539              return DisposeAsyncCore();
540          [MethodImpl(MethodImplOptions.AggressiveInlining)]
541          async ValueTask DisposeAsyncCore()
542          {
543              if (_disposed)
544                  return;
545              await CloseAsync();
546              _disposed = true;
547          }
548      }
549      internal void MakeDisposed()
550          =&gt; _disposed = true;
551      #endregion
552      #region Notifications and Notices
553      public event NoticeEventHandler? Notice;
554      public event NotificationEventHandler? Notification;
555      internal void OnNotice(PostgresNotice e)
556      {
557          try
558          {
559              Notice?.Invoke(this, new NpgsqlNoticeEventArgs(e));
560          }
561          catch (Exception ex)
562          {
563              LogMessages.CaughtUserExceptionInNoticeEventHandler(_connectionLogger, ex);
564          }
565      }
566      internal void OnNotification(NpgsqlNotificationEventArgs e)
567      {
568          try
569          {
570              Notification?.Invoke(this, e);
571          }
572          catch (Exception ex)
573          {
574              LogMessages.CaughtUserExceptionInNotificationEventHandler(_connectionLogger, ex);
575          }
576      }
577      #endregion Notifications and Notices
578      #region SSL
579      internal bool IsSecure =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.IsSecure);
580      internal bool IsScram =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.IsScram);
581      internal bool IsScramPlus =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.IsScramPlus);
582      public ProvideClientCertificatesCallback? ProvideClientCertificatesCallback { get; set; }
583      public RemoteCertificateValidationCallback? UserCertificateValidationCallback { get; set; }
584      #endregion SSL
585      #region Backend version, capabilities, settings
586      [Browsable(false)]
587      public Version PostgreSqlVersion =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.DatabaseInfo.Version);
588      public override string ServerVersion =&gt; CheckOpenAndRunInTemporaryScope(
589          c =&gt; c.DatabaseInfo.ServerVersion);
590      [Browsable(false)]
591      public int ProcessID
592      {
593          get
594          {
595              CheckOpen();
596              return TryGetBoundConnector(out var connector)
597                  ? connector.BackendProcessId
598                  : throw new InvalidOperationException(&quot;No bound physical connection (using multiplexing)&quot;);
599          }
600      }
601      [Browsable(false)]
602      public bool HasIntegerDateTimes =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.DatabaseInfo.HasIntegerDateTimes);
603      [Browsable(false)]
604      public string Timezone =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.Timezone);
605      [Browsable(false)]
606      public IReadOnlyDictionary&lt;string, string&gt; PostgresParameters
607          =&gt; CheckOpenAndRunInTemporaryScope(c =&gt; c.PostgresParameters);
608      #endregion Backend version, capabilities, settings
609      #region Copy
610      public NpgsqlBinaryImporter BeginBinaryImport(string copyFromCommand)
611          =&gt; BeginBinaryImport(copyFromCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
612      public Task&lt;NpgsqlBinaryImporter&gt; BeginBinaryImportAsync(string copyFromCommand, CancellationToken cancellationToken = default)
613      {
614          using (NoSynchronizationContextScope.Enter())
615              return BeginBinaryImport(copyFromCommand, async: true, cancellationToken);
616      }
617      async Task&lt;NpgsqlBinaryImporter&gt; BeginBinaryImport(string copyFromCommand, bool async, CancellationToken cancellationToken = default)
618      {
619          if (copyFromCommand == null)
620              throw new ArgumentNullException(nameof(copyFromCommand));
621          if (!IsValidCopyCommand(copyFromCommand))
622              throw new ArgumentException(&quot;Must contain a COPY FROM STDIN command!&quot;, nameof(copyFromCommand));
623          CheckReady();
624          var connector = StartBindingScope(ConnectorBindingScope.Copy);
625          LogMessages.StartingBinaryImport(connector.LoggingConfiguration.CopyLogger, connector.Id);
626          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
627          try
628          {
629              var importer = new NpgsqlBinaryImporter(connector);
630              await importer.Init(copyFromCommand, async, cancellationToken);
631              connector.CurrentCopyOperation = importer;
632              return importer;
633          }
634          catch
635          {
636              connector.EndUserAction();
637              EndBindingScope(ConnectorBindingScope.Copy);
638              throw;
639          }
640      }
641      public NpgsqlBinaryExporter BeginBinaryExport(string copyToCommand)
642          =&gt; BeginBinaryExport(copyToCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
643      public Task&lt;NpgsqlBinaryExporter&gt; BeginBinaryExportAsync(string copyToCommand, CancellationToken cancellationToken = default)
644      {
645          using (NoSynchronizationContextScope.Enter())
646              return BeginBinaryExport(copyToCommand, async: true, cancellationToken);
647      } 
648      async Task&lt;NpgsqlBinaryExporter&gt; BeginBinaryExport(string copyToCommand, bool async, CancellationToken cancellationToken = default)
649      {
650          if (copyToCommand == null)
651              throw new ArgumentNullException(nameof(copyToCommand));
652          if (!IsValidCopyCommand(copyToCommand))
653              throw new ArgumentException(&quot;Must contain a COPY TO STDOUT command!&quot;, nameof(copyToCommand));
654          CheckReady();
655          var connector = StartBindingScope(ConnectorBindingScope.Copy);
656          LogMessages.StartingBinaryExport(connector.LoggingConfiguration.CopyLogger, connector.Id);
657          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
658          try
659          {
660              var exporter = new NpgsqlBinaryExporter(connector);
661              await exporter.Init(copyToCommand, async, cancellationToken);
662              connector.CurrentCopyOperation = exporter;
663              return exporter;
664          }
665          catch
666          {
667              connector.EndUserAction();
668              EndBindingScope(ConnectorBindingScope.Copy);
669              throw;
670          }
671      }
672      public TextWriter BeginTextImport(string copyFromCommand)
673          =&gt; BeginTextImport(copyFromCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
674      public Task&lt;TextWriter&gt; BeginTextImportAsync(string copyFromCommand, CancellationToken cancellationToken = default)
675      {
676          using (NoSynchronizationContextScope.Enter())
677              return BeginTextImport(copyFromCommand, async: true, cancellationToken);
678      }
679      async Task&lt;TextWriter&gt; BeginTextImport(string copyFromCommand, bool async, CancellationToken cancellationToken = default)
680      {
681          if (copyFromCommand == null)
682              throw new ArgumentNullException(nameof(copyFromCommand));
683          if (!IsValidCopyCommand(copyFromCommand))
684              throw new ArgumentException(&quot;Must contain a COPY FROM STDIN command!&quot;, nameof(copyFromCommand));
685          CheckReady();
686          var connector = StartBindingScope(ConnectorBindingScope.Copy);
687          LogMessages.StartingTextImport(connector.LoggingConfiguration.CopyLogger, connector.Id);
688          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
689          try
690          {
691              var copyStream = new NpgsqlRawCopyStream(connector);
692              await copyStream.Init(copyFromCommand, async, cancellationToken);
693              var writer = new NpgsqlCopyTextWriter(connector, copyStream);
694              connector.CurrentCopyOperation = writer;
695              return writer;
696          }
697          catch
698          {
699              connector.EndUserAction();
700              EndBindingScope(ConnectorBindingScope.Copy);
701              throw;
702          }
703      }
704      public TextReader BeginTextExport(string copyToCommand)
705          =&gt; BeginTextExport(copyToCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
706      public Task&lt;TextReader&gt; BeginTextExportAsync(string copyToCommand, CancellationToken cancellationToken = default)
707      {
708          using (NoSynchronizationContextScope.Enter())
709              return BeginTextExport(copyToCommand, async: true, cancellationToken);
710      }
711      async Task&lt;TextReader&gt; BeginTextExport(string copyToCommand, bool async, CancellationToken cancellationToken = default)
712      {
713          if (copyToCommand == null)
714              throw new ArgumentNullException(nameof(copyToCommand));
715          if (!IsValidCopyCommand(copyToCommand))
716              throw new ArgumentException(&quot;Must contain a COPY TO STDOUT command!&quot;, nameof(copyToCommand));
717          CheckReady();
718          var connector = StartBindingScope(ConnectorBindingScope.Copy);
719          LogMessages.StartingTextExport(connector.LoggingConfiguration.CopyLogger, connector.Id);
720          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
721          try
722          {
723              var copyStream = new NpgsqlRawCopyStream(connector);
724              await copyStream.Init(copyToCommand, async, cancellationToken);
725              var reader = new NpgsqlCopyTextReader(connector, copyStream);
726              connector.CurrentCopyOperation = reader;
727              return reader;
728          }
729          catch
730          {
731              connector.EndUserAction();
732              EndBindingScope(ConnectorBindingScope.Copy);
733              throw;
734          }
735      }
736      public NpgsqlRawCopyStream BeginRawBinaryCopy(string copyCommand)
737          =&gt; BeginRawBinaryCopy(copyCommand, async: false, CancellationToken.None).GetAwaiter().GetResult();
738      public Task&lt;NpgsqlRawCopyStream&gt; BeginRawBinaryCopyAsync(string copyCommand, CancellationToken cancellationToken = default)
739      {
740          using (NoSynchronizationContextScope.Enter())
741              return BeginRawBinaryCopy(copyCommand, async: true, cancellationToken);
742      }
743      async Task&lt;NpgsqlRawCopyStream&gt; BeginRawBinaryCopy(string copyCommand, bool async, CancellationToken cancellationToken = default)
744      {
745          if (copyCommand == null)
746              throw new ArgumentNullException(nameof(copyCommand));
747          if (!IsValidCopyCommand(copyCommand))
748              throw new ArgumentException(&quot;Must contain a COPY TO STDOUT OR COPY FROM STDIN command!&quot;, nameof(copyCommand));
749          CheckReady();
750          var connector = StartBindingScope(ConnectorBindingScope.Copy);
751          LogMessages.StartingRawCopy(connector.LoggingConfiguration.CopyLogger, connector.Id);
752          connector.StartUserAction(ConnectorState.Copy, attemptPgCancellation: false);
753          try
754          {
755              var stream = new NpgsqlRawCopyStream(connector);
756              await stream.Init(copyCommand, async, cancellationToken);
757              if (!stream.IsBinary)
758              {
759                  throw connector.Break(new ArgumentException(
760                      &quot;copyToCommand triggered a text transfer, only binary is allowed&quot;, nameof(copyCommand)));
761              }
762              connector.CurrentCopyOperation = stream;
763              return stream;
764          }
765          catch
766          {
767              connector.EndUserAction();
768              EndBindingScope(ConnectorBindingScope.Copy);
769              throw;
770          }
771      }
772      static bool IsValidCopyCommand(string copyCommand)
773      {
774      #if NET6_0_OR_GREATER || NETSTANDARD2_1
775          return copyCommand.AsSpan().TrimStart().StartsWith(&quot;COPY&quot;, StringComparison.OrdinalIgnoreCase);
776      #else
777          return copyCommand.TrimStart().StartsWith(&quot;COPY&quot;, StringComparison.OrdinalIgnoreCase);
778      #endif
779      }
780      #endregion
781      #region Wait
782      public bool Wait(int timeout)
783      {
784          if (timeout != -1 &amp;&amp; timeout &lt; 0)
785              throw new ArgumentException(&quot;Argument must be -1, 0 or positive&quot;, nameof(timeout));
786          if (Settings.Multiplexing)
787              throw new NotSupportedException($&quot;{nameof(Wait)} isn&#x27;t supported in multiplexing mode&quot;);
788          CheckReady();
789          LogMessages.StartingWait(_connectionLogger, timeout, Connector!.Id);
790          return Connector!.Wait(async: false, timeout, CancellationToken.None).GetAwaiter().GetResult();
791      }
792      public bool Wait(TimeSpan timeout) =&gt; Wait((int)timeout.TotalMilliseconds);
793      public void Wait() =&gt; Wait(0);
794      public Task&lt;bool&gt; WaitAsync(int timeout, CancellationToken cancellationToken = default)
795      {
796          if (Settings.Multiplexing)
797              throw new NotSupportedException($&quot;{nameof(Wait)} isn&#x27;t supported in multiplexing mode&quot;);
798          CheckReady();
799          LogMessages.StartingWait(_connectionLogger, timeout, Connector!.Id);
800          using (NoSynchronizationContextScope.Enter())
801              return Connector!.Wait(async: true, timeout, cancellationToken);
802      }
803      public Task&lt;bool&gt; WaitAsync(TimeSpan timeout, CancellationToken cancellationToken = default) =&gt; WaitAsync((int)timeout.TotalMilliseconds, cancellationToken);
804      public Task WaitAsync(CancellationToken cancellationToken = default) =&gt; WaitAsync(0, cancellationToken);
805      #endregion
806      #region State checks
807      [MethodImpl(MethodImplOptions.AggressiveInlining)]
808      void CheckOpen()
809      {
810          CheckDisposed();
811          switch (FullState)
812          {
813          case ConnectionState.Open:
814          case ConnectionState.Open | ConnectionState.Executing:
815          case ConnectionState.Open | ConnectionState.Fetching:
816          case ConnectionState.Connecting:
817              return;
818          case ConnectionState.Closed:
819          case ConnectionState.Broken:
820              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is not open&quot;);
821              return;
822          default:
823              ThrowHelper.ThrowArgumentOutOfRangeException();
824              return;
825          }
826      }
827      void CheckClosed()
828      {
829          CheckDisposed();
830          switch (FullState)
831          {
832          case ConnectionState.Closed:
833          case ConnectionState.Broken:
834              return;
835          case ConnectionState.Open:
836          case ConnectionState.Connecting:
837          case ConnectionState.Open | ConnectionState.Executing:
838          case ConnectionState.Open | ConnectionState.Fetching:
839              ThrowHelper.ThrowInvalidOperationException(&quot;Connection already open&quot;);
840              return;
841          default:
842              ThrowHelper.ThrowArgumentOutOfRangeException();
843              return;
844          }
845      }
846      void CheckDisposed()
847      {
848          if (_disposed)
849              ThrowHelper.ThrowObjectDisposedException(nameof(NpgsqlConnection));
850      }
851      internal void CheckReady()
852      {
853          CheckDisposed();
854          switch (FullState)
855          {
856          case ConnectionState.Open:
857          case ConnectionState.Connecting:  
858              return;
859          case ConnectionState.Closed:
860          case ConnectionState.Broken:
861              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is not open&quot;);
862              return;
863          case ConnectionState.Open | ConnectionState.Executing:
864          case ConnectionState.Open | ConnectionState.Fetching:
865              ThrowHelper.ThrowInvalidOperationException(&quot;Connection is busy&quot;);
866              return;
867          default:
868              ThrowHelper.ThrowArgumentOutOfRangeException();
869              return;
870          }
871      }
872      #endregion State checks
873      #region Connector binding
874      internal bool TryGetBoundConnector([NotNullWhen(true)] out NpgsqlConnector? connector)
875      {
876          if (ConnectorBindingScope == ConnectorBindingScope.None)
877          {
878              Debug.Assert(Connector == null, $&quot;Binding scope is None but {Connector} exists&quot;);
879              connector = null;
880              return false;
881          }
882          Debug.Assert(Connector != null, $&quot;Binding scope is {ConnectorBindingScope} but {Connector} is null&quot;);
883          Debug.Assert(Connector.Connection == this, $&quot;Bound connector {Connector} does not reference this connection&quot;);
884          connector = Connector;
885          return true;
886      }
887      internal ValueTask&lt;NpgsqlConnector&gt; StartBindingScope(
888          ConnectorBindingScope scope, NpgsqlTimeout timeout, bool async, CancellationToken cancellationToken)
889      {
890          if (ConnectorBindingScope != ConnectorBindingScope.None)
891          {
892              Debug.Assert(Connector != null, $&quot;Connection bound with scope {ConnectorBindingScope} but has no connector&quot;);
893              Debug.Assert(scope != ConnectorBindingScope, $&quot;Binding scopes aren&#x27;t reentrant ({ConnectorBindingScope})&quot;);
894              return new ValueTask&lt;NpgsqlConnector&gt;(Connector);
895          }
896          return StartBindingScopeAsync();
897          async ValueTask&lt;NpgsqlConnector&gt; StartBindingScopeAsync()
898          {
899              try
900              {
901                  Debug.Assert(Settings.Multiplexing);
902                  Debug.Assert(_dataSource != null);
903                  var connector = await _dataSource.Get(this, timeout, async, cancellationToken);
904                  Connector = connector;
905                  connector.Connection = this;
906                  ConnectorBindingScope = scope;
907                  return connector;
908              }
909              catch
910              {
911                  FullState = ConnectionState.Broken;
912                  throw;
913              }
914          }
915      }
916      internal NpgsqlConnector StartBindingScope(ConnectorBindingScope scope)
917          =&gt; StartBindingScope(scope, NpgsqlTimeout.Infinite, async: false, CancellationToken.None)
918              .GetAwaiter().GetResult();
919      internal EndScopeDisposable StartTemporaryBindingScope(out NpgsqlConnector connector)
920      {
921          connector = StartBindingScope(ConnectorBindingScope.Temporary);
922          return new EndScopeDisposable(this);
923      }
924      internal T CheckOpenAndRunInTemporaryScope&lt;T&gt;(Func&lt;NpgsqlConnector, T&gt; func)
925      {
926          CheckOpen();
927          using var _ = StartTemporaryBindingScope(out var connector);
928          var result = func(connector);
929          return result;
930      }
931      internal void EndBindingScope(ConnectorBindingScope scope)
932      {
933          Debug.Assert(ConnectorBindingScope != ConnectorBindingScope.None || FullState == ConnectionState.Broken,
934              $&quot;Ending binding scope {scope} but connection&#x27;s scope is null&quot;);
935          if (scope != ConnectorBindingScope)
936              return;
937          Debug.Assert(Connector != null, $&quot;Ending binding scope {scope} but connector is null&quot;);
938          Debug.Assert(_dataSource != null, $&quot;Ending binding scope {scope} but _pool is null&quot;);
939          Debug.Assert(Settings.Multiplexing, $&quot;Ending binding scope {scope} but multiplexing is disabled&quot;);
940          var connector = Connector;
941          Connector = null;
942          connector.Connection = null;
943          connector.Transaction?.UnbindIfNecessary();
944          connector.Return();
945          ConnectorBindingScope = ConnectorBindingScope.None;
946      }
947      #endregion Connector binding
948      #region Schema operations
949      [UnconditionalSuppressMessage(
950          &quot;Composite type mapping currently isn&#x27;t trimming-safe, and warnings are generated at the MapComposite level.&quot;, &quot;IL2026&quot;)]
951      public override DataTable GetSchema()
952          =&gt; GetSchema(&quot;MetaDataCollections&quot;, null);
953      public override DataTable GetSchema(string? collectionName) =&gt; GetSchema(collectionName, null);
954      public override DataTable GetSchema(string? collectionName, string?[]? restrictions)
955          =&gt; NpgsqlSchema.GetSchema(this, collectionName, restrictions, async: false).GetAwaiter().GetResult();
956  #if NET5_0_OR_GREATER
957      public override Task&lt;DataTable&gt; GetSchemaAsync(CancellationToken cancellationToken = default)
958  #else
959      public Task&lt;DataTable&gt; GetSchemaAsync(CancellationToken cancellationToken = default)
960  #endif
961          =&gt; GetSchemaAsync(&quot;MetaDataCollections&quot;, null, cancellationToken);
962  #if NET5_0_OR_GREATER
963      public override Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default)
964  #else
965      public Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default)
966  #endif
967          =&gt; GetSchemaAsync(collectionName, null, cancellationToken);
968  #if NET5_0_OR_GREATER
969      public override Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, string?[]? restrictions, CancellationToken cancellationToken = default)
970  #else
971      public Task&lt;DataTable&gt; GetSchemaAsync(string collectionName, string?[]? restrictions, CancellationToken cancellationToken = default)
972  #endif
973      {
974          using (NoSynchronizationContextScope.Enter())
975              return NpgsqlSchema.GetSchema(this, collectionName, restrictions, async: true, cancellationToken);
976      }
977      #endregion Schema operations
978      #region Misc
979      object ICloneable.Clone()
980      {
981          CheckDisposed();
982          Debug.Assert(_dataSource is not null || _cloningInstantiator is not null);
983          var conn = _dataSource is null
984              ? _cloningInstantiator!(_connectionString)
985              : _dataSource.CreateConnection();
986          conn.ProvideClientCertificatesCallback = ProvideClientCertificatesCallback;
987          conn.UserCertificateValidationCallback = UserCertificateValidationCallback;
988  #pragma warning disable CS0618 
989          conn.ProvidePasswordCallback = ProvidePasswordCallback;
990  #pragma warning restore CS0618
991          conn._userFacingConnectionString = _userFacingConnectionString;
992          return conn;
993      }
994      public NpgsqlConnection CloneWith(string connectionString)
995      {
996          CheckDisposed();
997          var csb = new NpgsqlConnectionStringBuilder(connectionString);
998          csb.Password ??= _dataSource?.GetPassword(async: false).GetAwaiter().GetResult();
999          if (csb.PersistSecurityInfo &amp;&amp; !Settings.PersistSecurityInfo)
1000              csb.PersistSecurityInfo = false;
1001          return new NpgsqlConnection(csb.ToString())
1002          {
1003              ProvideClientCertificatesCallback =
1004                  ProvideClientCertificatesCallback ??
1005                  (_dataSource?.ClientCertificatesCallback is { } clientCertificatesCallback
1006                      ? (ProvideClientCertificatesCallback)(certs =&gt; clientCertificatesCallback(certs))
1007                      : null),
1008              UserCertificateValidationCallback = UserCertificateValidationCallback ?? _dataSource?.UserCertificateValidationCallback,
1009  #pragma warning disable CS0618 
1010              ProvidePasswordCallback = ProvidePasswordCallback,
1011  #pragma warning restore CS0618
1012          };
1013      }
1014      public override void ChangeDatabase(string dbName)
1015      {
1016          if (dbName == null)
1017              throw new ArgumentNullException(nameof(dbName));
1018          if (string.IsNullOrEmpty(dbName))
1019              throw new ArgumentOutOfRangeException(nameof(dbName), dbName, $&quot;Invalid database name: {dbName}&quot;);
1020          CheckOpen();
1021          Close();
1022          _dataSource = null;
1023          Settings = Settings.Clone();
1024          Settings.Database = dbName;
1025          ConnectionString = Settings.ToString();
1026          Open();
1027      }
1028      protected override DbProviderFactory DbProviderFactory =&gt; NpgsqlFactory.Instance;
1029      public static void ClearPool(NpgsqlConnection connection) =&gt; PoolManager.Clear(connection._connectionString);
1030      public static void ClearAllPools() =&gt; PoolManager.ClearAll();
1031      public void UnprepareAll()
1032      {
1033          if (Settings.Multiplexing)
1034              throw new NotSupportedException(&quot;Explicit preparation not supported with multiplexing&quot;);
1035          CheckReady();
1036          using (Connector!.StartUserAction())
1037              Connector.UnprepareAll();
1038      }
1039      public void ReloadTypes()
1040      {
1041          CheckReady();
1042          using var scope = StartTemporaryBindingScope(out var connector);
1043          _dataSource!.Bootstrap(
1044              connector,
1045              NpgsqlTimeout.Infinite,
1046              forceReload: true,
1047              async: false,
1048              CancellationToken.None)
1049              .GetAwaiter().GetResult();
1050      }
1051      public async Task ReloadTypesAsync()
1052      {
1053          CheckReady();
1054          using var scope = StartTemporaryBindingScope(out var connector);
1055          await _dataSource!.Bootstrap(
1056                  connector,
1057                  NpgsqlTimeout.Infinite,
1058                  forceReload: true,
1059                  async: true,
1060                  CancellationToken.None);
1061      }
1062      [EditorBrowsable(EditorBrowsableState.Never)]
1063      public new event EventHandler? Disposed
1064      {
1065          add =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1066          remove =&gt; throw new NotSupportedException(&quot;The Disposed event isn&#x27;t supported by Npgsql. Use DbConnection.StateChange instead.&quot;);
1067      }
1068      event EventHandler? IComponent.Disposed
1069      {
1070          add =&gt; Disposed += value;
1071          remove =&gt; Disposed -= value;
1072      }
1073      #endregion Misc
1074  }
1075  enum ConnectorBindingScope
1076  {
1077      None,
1078      Connection,
1079      Transaction,
1080      Copy,
1081      Reader,
1082      Temporary
1083  }
1084  readonly struct EndScopeDisposable : IDisposable
1085  {
1086      readonly NpgsqlConnection _connection;
1087      public EndScopeDisposable(NpgsqlConnection connection) =&gt; _connection = connection;
1088      public void Dispose() =&gt; _connection.EndBindingScope(ConnectorBindingScope.Temporary);
1089  }
1090  #region Delegates
1091  public delegate void NoticeEventHandler(object sender, NpgsqlNoticeEventArgs e);
1092  public delegate void NotificationEventHandler(object sender, NpgsqlNotificationEventArgs e);
1093  public delegate void ProvideClientCertificatesCallback(X509CertificateCollection certificates);
1094  [Obsolete(&quot;Use NpgsqlDataSourceBuilder.UsePeriodicPasswordProvider or inject passwords directly into NpgsqlDataSource.Password&quot;)]
1095  public delegate string ProvidePasswordCallback(string host, int port, string database, string username);
1096  #endregion
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnection.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlConnection.cs</div>
                </div>
                <div class="column column_space"><pre><code>448              ReleaseCloseLock();
449              throw new InvalidOperationException(&quot;Can&#x27;t close, connection is in state &quot; + FullState);
450          default:
</pre></code></div>
                <div class="column column_space"><pre><code>451              ReleaseCloseLock();
452              throw new ArgumentOutOfRangeException(&quot;Unknown connection state: &quot; + FullState);
453          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    