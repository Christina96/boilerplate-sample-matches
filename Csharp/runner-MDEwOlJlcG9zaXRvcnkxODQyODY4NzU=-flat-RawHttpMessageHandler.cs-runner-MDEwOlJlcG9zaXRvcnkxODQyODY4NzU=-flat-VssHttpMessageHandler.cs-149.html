
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 199, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-RawHttpMessageHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Net;
3  using System.Net.Http;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using GitHub.Services.Common.Diagnostics;
7  using GitHub.Services.Common.Internal;
8  using GitHub.Services.OAuth;
9  namespace GitHub.Services.Common
10  {
11      public class RawHttpMessageHandler : HttpMessageHandler
12      {
13          public RawHttpMessageHandler(
14              FederatedCredential credentials)
15              : this(credentials, new RawClientHttpRequestSettings())
16          {
17          }
18          public RawHttpMessageHandler(
19              FederatedCredential credentials,
20              RawClientHttpRequestSettings settings)
21              : this(credentials, settings, new HttpClientHandler())
22          {
23          }
24          public RawHttpMessageHandler(
25              FederatedCredential credentials,
26              RawClientHttpRequestSettings settings,
27              HttpMessageHandler innerHandler)
28          {
29              this.Credentials = credentials;
30              this.Settings = settings;
31              m_messageInvoker = new HttpMessageInvoker(innerHandler);
32              m_credentialWrapper = new CredentialWrapper();
33              {
34                  HttpMessageHandler transportHandler = innerHandler;
35                  DelegatingHandler delegatingHandler = transportHandler as DelegatingHandler;
36                  while (delegatingHandler != null)
37                  {
38                      transportHandler = delegatingHandler.InnerHandler;
39                      delegatingHandler = transportHandler as DelegatingHandler;
40                  }
41                  m_transportHandler = transportHandler;
42              }
43              ApplySettings(m_transportHandler, m_credentialWrapper, this.Settings);
44              m_thisLock = new Object();
45          }
46          public FederatedCredential Credentials
47          {
48              get;
49              private set;
50          }
51          public RawClientHttpRequestSettings Settings
52          {
53              get;
54              private set;
55          }
56          private static IWebProxy s_defaultWebProxy = null;
57          public static IWebProxy DefaultWebProxy
58          {
59              get
60              {
61                  var toReturn = WebProxyWrapper.Wrap(s_defaultWebProxy);
62                  if (null != toReturn &amp;&amp;
63                      toReturn.Credentials == null)
64                  {
65                      toReturn.Credentials = CredentialCache.DefaultCredentials;
66                  }
67                  return toReturn;
68              }
69              set
70              {
71                  s_defaultWebProxy = value;
72              }
73          }
74          protected override async Task&lt;HttpResponseMessage&gt; SendAsync(
75              HttpRequestMessage request,
76              CancellationToken cancellationToken)
77          {
78              VssTraceActivity traceActivity = VssTraceActivity.Current;
79              lock (m_thisLock)
80              {
81                  if (m_tokenProvider == null)
82                  {
83                      m_tokenProvider = this.Credentials.CreateTokenProvider(request.RequestUri, null, null);
84                  }
85              }
86              CancellationTokenSource tokenSource = null;
87              HttpResponseMessage response = null;
88              Boolean succeeded = false;
89              HttpResponseMessageWrapper responseWrapper;
90              Boolean lastResponseDemandedProxyAuth = false;
91              Int32 retries = m_maxAuthRetries;
92              try
93              {
94                  tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
95                  if (this.Settings.SendTimeout &gt; TimeSpan.Zero)
96                  {
97                      tokenSource.CancelAfter(this.Settings.SendTimeout);
98                  }
99                  do
100                  {
101                      if (response != null)
102                      {
103                          response.Dispose();
104                      }
105                      IssuedToken token = await m_tokenProvider.GetTokenAsync(null, tokenSource.Token).ConfigureAwait(false);
106                      ApplyToken(request, token, applyICredentialsToWebProxy: lastResponseDemandedProxyAuth);
107                      await BufferRequestContentAsync(request, tokenSource.Token).ConfigureAwait(false);
108                      response = await m_messageInvoker.SendAsync(request, tokenSource.Token).ConfigureAwait(false);
109                      responseWrapper = new HttpResponseMessageWrapper(response);
110                      var isUnAuthorized = responseWrapper.StatusCode == HttpStatusCode.Unauthorized;
111                      lastResponseDemandedProxyAuth = responseWrapper.StatusCode == HttpStatusCode.ProxyAuthenticationRequired;
112                      if (!isUnAuthorized &amp;&amp; !lastResponseDemandedProxyAuth)
113                      {
114                          m_tokenProvider?.ValidateToken(token, responseWrapper);
115                          succeeded = true;
116                          break;
117                      }
118                      else
119                      {
120                          m_tokenProvider?.InvalidateToken(token);
121                          if (retries == 0 || retries &lt; m_maxAuthRetries)
122                          {
123                              break;
124                          }
125                          token = await m_tokenProvider.GetTokenAsync(token, tokenSource.Token).ConfigureAwait(false);
126                          retries--;
127                      }
128                  }
129                  while (retries &gt;= 0);
130                  if (!succeeded &amp;&amp; response != null &amp;&amp; responseWrapper.StatusCode == HttpStatusCode.Unauthorized)
131                  {
132                      if (response != null)
133                      {
134                          response.Dispose();
135                      }
136                      var message = CommonResources.VssUnauthorized(request.RequestUri.GetLeftPart(UriPartial.Authority));
137                      VssHttpEventSource.Log.HttpRequestUnauthorized(traceActivity, request, message);
138                      VssUnauthorizedException unauthorizedException = new VssUnauthorizedException(message);
139                      throw unauthorizedException;
140                  }
141                  return response;
142              }
143              catch (OperationCanceledException ex)
144              {
145                  if (cancellationToken.IsCancellationRequested)
146                  {
147                      VssHttpEventSource.Log.HttpRequestCancelled(traceActivity, request);
148                      throw;
149                  }
150                  else
151                  {
152                      VssHttpEventSource.Log.HttpRequestTimedOut(traceActivity, request, this.Settings.SendTimeout);
153                      throw new TimeoutException(CommonResources.HttpRequestTimeout(this.Settings.SendTimeout), ex);
154                  }
155              }
156              finally
157              {
158                  if (tokenSource != null)
159                  {
160                      tokenSource.Dispose();
161                  }
162              }
163          }
164          private static async Task BufferRequestContentAsync(
165               HttpRequestMessage request,
166               CancellationToken cancellationToken)
167          {
168              if (request.Content != null &amp;&amp;
169                  request.Headers.TransferEncodingChunked != true)
170              {
171                  Int64? contentLength = request.Content.Headers.ContentLength;
172                  if (contentLength == null)
173                  {
174                      await request.Content.LoadIntoBufferAsync().EnforceCancellation(cancellationToken).ConfigureAwait(false);
175                  }
176                  request.Headers.TransferEncodingChunked = false;
177              }
178          }
179          private void ApplyToken(
180              HttpRequestMessage request,
181              IssuedToken token,
182              bool applyICredentialsToWebProxy = false)
183          {
184              switch (token)
185              {
186                  case null:
187                      return;
188                  case ICredentials credentialsToken:
189                      if (applyICredentialsToWebProxy)
190                      {
191                          HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
192                          if (httpClientHandler != null &amp;&amp; httpClientHandler.Proxy != null)
193                          {
194                              httpClientHandler.Proxy.Credentials = credentialsToken;
195                          }
196                      }
197                      m_credentialWrapper.InnerCredentials = credentialsToken;
198                      break;
199                  default:
200                      token.ApplyTo(new HttpRequestMessageWrapper(request));
201                      break;
202              }
203          }
204          private static void ApplySettings(
205              HttpMessageHandler handler,
206              ICredentials defaultCredentials,
207              RawClientHttpRequestSettings settings)
208          {
209              HttpClientHandler httpClientHandler = handler as HttpClientHandler;
210              if (httpClientHandler != null)
211              {
212                  httpClientHandler.ClientCertificateOptions = ClientCertificateOption.Manual;
213                  httpClientHandler.UseDefaultCredentials = false;
214                  httpClientHandler.Credentials = defaultCredentials;
215                  httpClientHandler.PreAuthenticate = false;
216                  httpClientHandler.Proxy = DefaultWebProxy;
217                  httpClientHandler.UseCookies = false;
218                  httpClientHandler.UseProxy = true;
219              }
220          }
221          private readonly HttpMessageHandler m_transportHandler;
222          private HttpMessageInvoker m_messageInvoker;
223          private CredentialWrapper m_credentialWrapper;
224          private object m_thisLock;
225          private const Int32 m_maxAuthRetries = 3;
226          private IssuedTokenProvider m_tokenProvider;
227          private sealed class CredentialWrapper : CredentialCache, ICredentials
228          {
229              public ICredentials InnerCredentials
230              {
231                  get;
232                  set;
233              }
234              NetworkCredential ICredentials.GetCredential(
235                  Uri uri,
<span onclick='openModal()' class='match'>236                  String authType)
237              {
238                  return InnerCredentials != null ? InnerCredentials.GetCredential(uri, authType) : null;
239              }
240          }
241          private sealed class WebProxyWrapper : IWebProxy
242          {
243              private WebProxyWrapper(IWebProxy toWrap)
244              {
245                  m_wrapped = toWrap;
246                  m_credentials = null;
247              }
248              public static WebProxyWrapper Wrap(IWebProxy toWrap)
249              {
250                  if (null == toWrap)
251                  {
252                      return null;
253                  }
254                  return new WebProxyWrapper(toWrap);
255              }
256              public ICredentials Credentials
257              {
258                  get
259                  {
260                      ICredentials credentials = m_credentials;
261                      if (null == credentials)
262                      {
263                          credentials = m_wrapped.Credentials;
264                      }
265                      else if (Object.ReferenceEquals(credentials, m_nullCredentials))
266                      {
267                          credentials = null;
268                      }
269                      return credentials;
270                  }
271                  set
272                  {
273                      if (null == value)
274                      {
275                          m_credentials = m_nullCredentials;
276                      }
277                      else
278                      {
279                          m_credentials = value;
280                      }
281                  }
282              }
283              public Uri GetProxy(Uri destination)
284              {
285                  return m_wrapped.GetProxy(destination);
286              }
287              public bool IsBypassed(Uri host)
288              {
289                  return m_wrapped.IsBypassed(host);
290              }
291              private readonly IWebProxy m_wrapped;
292              private ICredentials m_credentials;
293              private static readonly ICredentials m_nullCredentials = new CredentialWrapper();
294          }
295      }
296  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssHttpMessageHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Net;
5  using System.Net.Http;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.Services.Common.Diagnostics;
9  using GitHub.Services.Common.Internal;
10  namespace GitHub.Services.Common
11  {
12      public class VssHttpMessageHandler : HttpMessageHandler
13      {
14          public VssHttpMessageHandler()
15              : this(new VssCredentials(), new VssHttpRequestSettings())
16          {
17          }
18          public VssHttpMessageHandler(
19              VssCredentials credentials,
20              VssHttpRequestSettings settings)
21              : this(credentials, settings, new HttpClientHandler())
22          {
23          }
24          public VssHttpMessageHandler(
25              VssCredentials credentials,
26              VssHttpRequestSettings settings,
27              HttpMessageHandler innerHandler)
28          {
29              this.Credentials = credentials;
30              this.Settings = settings;
31              this.ExpectContinue = settings.ExpectContinue;
32              m_credentialWrapper = new CredentialWrapper();
33              m_messageInvoker = new HttpMessageInvoker(innerHandler);
34              {
35                  HttpMessageHandler transportHandler = innerHandler;
36                  DelegatingHandler delegatingHandler = transportHandler as DelegatingHandler;
37                  while (delegatingHandler != null)
38                  {
39                      transportHandler = delegatingHandler.InnerHandler;
40                      delegatingHandler = transportHandler as DelegatingHandler;
41                  }
42                  m_transportHandler = transportHandler;
43              }
44              ApplySettings(m_transportHandler, m_credentialWrapper, this.Settings);
45          }
46          public VssCredentials Credentials
47          {
48              get;
49              private set;
50          }
51          public VssHttpRequestSettings Settings
52          {
53              get;
54              private set;
55          }
56          private Boolean ExpectContinue
57          {
58              get;
59              set;
60          }
61          protected override void Dispose(Boolean disposing)
62          {
63              base.Dispose(disposing);
64              if (disposing)
65              {
66                  if (m_messageInvoker != null)
67                  {
68                      m_messageInvoker.Dispose();
69                  }
70              }
71          }
72          internal static readonly String PropertyName = &quot;MS.VS.MessageHandler&quot;;
73          protected override async Task&lt;HttpResponseMessage&gt; SendAsync(
74              HttpRequestMessage request,
75              CancellationToken cancellationToken)
76          {
77              VssTraceActivity traceActivity = VssTraceActivity.Current;
78              var traceInfo = VssHttpMessageHandlerTraceInfo.GetTraceInfo(request);
79              traceInfo?.TraceHandlerStartTime();
80              if (!m_appliedClientCertificatesToTransportHandler &amp;&amp;
81                  request.RequestUri.Scheme == &quot;https&quot;)
82              {
83                  HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
84                  if (httpClientHandler != null &amp;&amp;
85                      this.Settings.ClientCertificateManager != null &amp;&amp;
86                      this.Settings.ClientCertificateManager.ClientCertificates != null &amp;&amp;
87                      this.Settings.ClientCertificateManager.ClientCertificates.Count &gt; 0)
88                  {
89                      httpClientHandler.ClientCertificates.AddRange(this.Settings.ClientCertificateManager.ClientCertificates);
90                  }
91                  m_appliedClientCertificatesToTransportHandler = true;
92              }
93              if (!m_appliedServerCertificateValidationCallbackToTransportHandler &amp;&amp;
94                  request.RequestUri.Scheme == &quot;https&quot;)
95              {
96                  HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
97                  if (httpClientHandler != null &amp;&amp;
98                      this.Settings.ServerCertificateValidationCallback != null)
99                  {
100                      httpClientHandler.ServerCertificateCustomValidationCallback = this.Settings.ServerCertificateValidationCallback;
101                  }
102                  m_appliedServerCertificateValidationCallbackToTransportHandler = true;
103              }
104              if (Settings.UseHttp11)
105              {
106                  request.Version = HttpVersion.Version11;
107              }
108              IssuedToken token = null;
109              IssuedTokenProvider provider;
110              if (this.Credentials.TryGetTokenProvider(request.RequestUri, out provider))
111              {
112                  token = provider.CurrentToken;
113              }
114              request.Options.Set(new HttpRequestOptionsKey&lt;VssHttpMessageHandler&gt;(VssHttpMessageHandler.PropertyName), this);
115              Boolean succeeded = false;
116              Boolean lastResponseDemandedProxyAuth = false;
117              Int32 retries = m_maxAuthRetries;
118              HttpResponseMessage response = null;
119              HttpResponseMessageWrapper responseWrapper;
120              CancellationTokenSource tokenSource = null;
121              try
122              {
123                  tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
124                  if (this.Settings.SendTimeout &gt; TimeSpan.Zero)
125                  {
126                      tokenSource.CancelAfter(this.Settings.SendTimeout);
127                  }
128                  do
129                  {
130                      if (response != null)
131                      {
132                          response.Dispose();
133                      }
134                      ApplyHeaders(request);
135                      ApplyToken(request, token, applyICredentialsToWebProxy: lastResponseDemandedProxyAuth);
136                      lastResponseDemandedProxyAuth = false;
137                      await BufferRequestContentAsync(request, tokenSource.Token).ConfigureAwait(false);
138                      traceInfo?.TraceBufferedRequestTime();
139                      var tmpResponse = await m_messageInvoker.SendAsync(request, tokenSource.Token).ConfigureAwait(false);
140                      if (Settings.AllowAutoRedirectForBroker &amp;&amp; tmpResponse.StatusCode == HttpStatusCode.Redirect)
141                      {
142                          tmpResponse?.Dispose();
143                          var location = tmpResponse.Headers.Location;
144                          request = new HttpRequestMessage(HttpMethod.Get, location);
145                          ApplyToken(request, token, applyICredentialsToWebProxy: lastResponseDemandedProxyAuth);
146                          response = await m_messageInvoker.SendAsync(request, tokenSource.Token).ConfigureAwait(false);
147                      }
148                      else
149                      {
150                          response = tmpResponse;
151                      }
152                      traceInfo?.TraceRequestSendTime();
153                      await BufferResponseContentAsync(request, response, () =&gt; $&quot;[ContentType: {response.Content.GetType().Name}]&quot;, tokenSource.Token).ConfigureAwait(false);
154                      traceInfo?.TraceResponseContentTime();
155                      responseWrapper = new HttpResponseMessageWrapper(response);
156                      if (!this.Credentials.IsAuthenticationChallenge(responseWrapper))
157                      {
158                          if (provider != null)
159                          {
160                              provider.ValidateToken(token, responseWrapper);
161                          }
162                          this.ExpectContinue = false;
163                          succeeded = true;
164                          break;
165                      }
166                      else
167                      {
168                          lastResponseDemandedProxyAuth = responseWrapper.StatusCode == HttpStatusCode.ProxyAuthenticationRequired;
169                          if (retries &lt; m_maxAuthRetries)
170                          {
171                              VssHttpEventSource.Log.AuthenticationFailed(traceActivity, response);
172                          }
173                          else
174                          {
175                              VssHttpEventSource.Log.AuthenticationFailedOnFirstRequest(traceActivity, response);
176                          }
177                          if (provider != null)
178                          {
179                              provider.InvalidateToken(token);
180                          }
181                          provider = this.Credentials.CreateTokenProvider(request.RequestUri, responseWrapper, token);
182                          if (provider == null)
183                          {
184                              VssHttpEventSource.Log.IssuedTokenProviderNotFound(traceActivity);
185                              break;
186                          }
187                          else if (provider.GetTokenIsInteractive &amp;&amp; this.Credentials.PromptType == CredentialPromptType.DoNotPrompt)
188                          {
189                              VssHttpEventSource.Log.IssuedTokenProviderPromptRequired(traceActivity, provider);
190                              break;
191                          }
192                          IEnumerable&lt;String&gt; headerValues;
193                          Boolean hasAuthenticateError =
194                              response.Headers.TryGetValues(HttpHeaders.VssAuthenticateError, out headerValues) &amp;&amp;
195                              !String.IsNullOrEmpty(headerValues.FirstOrDefault());
196                          if (retries == 0 || (retries &lt; m_maxAuthRetries &amp;&amp; hasAuthenticateError))
197                          {
198                              break;
199                          }
200                          token = await provider.GetTokenAsync(token, tokenSource.Token).ConfigureAwait(false);
201                          traceInfo?.TraceGetTokenTime();
202                          request.Headers.Add(HttpHeaders.VssUserData, String.Empty);
203                          retries--;
204                      }
205                  }
206                  while (retries &gt;= 0);
207                  if (traceInfo != null)
208                  {
209                      traceInfo.TokenRetries = m_maxAuthRetries - retries;
210                  }
211                  if (!succeeded &amp;&amp; response != null &amp;&amp; this.Credentials.IsAuthenticationChallenge(responseWrapper))
212                  {
213                      String message = null;
214                      IEnumerable&lt;String&gt; serviceError;
215                      if (response.Headers.TryGetValues(HttpHeaders.TfsServiceError, out serviceError))
216                      {
217                          message = UriUtility.UrlDecode(serviceError.FirstOrDefault());
218                      }
219                      else
220                      {
221                          message = CommonResources.VssUnauthorized(request.RequestUri.GetLeftPart(UriPartial.Authority));
222                      }
223                      if (response != null)
224                      {
225                          response.Dispose();
226                      }
227                      VssHttpEventSource.Log.HttpRequestUnauthorized(traceActivity, request, message);
228                      VssUnauthorizedException unauthorizedException = new VssUnauthorizedException(message);
229                      if (provider != null)
230                      {
231                          unauthorizedException.Data.Add(CredentialsType, provider.CredentialType);
232                      }
233                      throw unauthorizedException;
234                  }
235                  return response;
236              }
237              catch (OperationCanceledException ex)
238              {
239                  if (cancellationToken.IsCancellationRequested)
240                  {
241                      VssHttpEventSource.Log.HttpRequestCancelled(traceActivity, request);
242                      throw;
243                  }
244                  else
245                  {
246                      VssHttpEventSource.Log.HttpRequestTimedOut(traceActivity, request, this.Settings.SendTimeout);
247                      throw new TimeoutException(CommonResources.HttpRequestTimeout(this.Settings.SendTimeout), ex);
248                  }
249              }
250              finally
251              {
252                  if (tokenSource != null)
253                  {
254                      tokenSource.Dispose();
255                  }
256                  traceInfo?.TraceTrailingTime();
257              }
258          }
259          private static async Task BufferRequestContentAsync(
260              HttpRequestMessage request,
261              CancellationToken cancellationToken)
262          {
263              if (request.Content != null &amp;&amp;
264                  request.Headers.TransferEncodingChunked != true)
265              {
266                  Int64? contentLength = request.Content.Headers.ContentLength;
267                  if (contentLength == null)
268                  {
269                      await request.Content.LoadIntoBufferAsync().EnforceCancellation(cancellationToken).ConfigureAwait(false);
270                  }
271                  request.Headers.TransferEncodingChunked = false;
272              }
273          }
274          protected virtual async Task BufferResponseContentAsync(
275              HttpRequestMessage request,
276              HttpResponseMessage response,
277              Func&lt;string&gt; makeErrorMessage,
278              CancellationToken cancellationToken)
279          {
280              if (response == null || response.StatusCode == HttpStatusCode.NoContent || response.Content == null)
281              {
282                  return;
283              }
284              if (this.Settings.MaxContentBufferSize == 0)
285              {
286                  return;
287              }
288              HttpCompletionOption completionOption;
289              if (!request.Options.TryGetValue(VssHttpRequestSettings.HttpCompletionOptionPropertyName, out completionOption))
290              {
291                  completionOption = HttpCompletionOption.ResponseContentRead;
292              }
293              if (completionOption == HttpCompletionOption.ResponseContentRead)
294              {
295                  await response.Content.LoadIntoBufferAsync(this.Settings.MaxContentBufferSize).EnforceCancellation(cancellationToken, makeErrorMessage).ConfigureAwait(false);
296              }
297          }
298          private void ApplyHeaders(HttpRequestMessage request)
299          {
300              if (this.Settings.ApplyTo(request))
301              {
302                  VssTraceActivity activity = request.GetActivity();
303                  if (activity != null &amp;&amp;
304                      activity != VssTraceActivity.Empty &amp;&amp;
305                      !request.Headers.Contains(HttpHeaders.TfsSessionHeader))
306                  {
307                      request.Headers.Add(HttpHeaders.TfsSessionHeader, activity.Id.ToString(&quot;D&quot;));
308                  }
309                  request.Headers.ExpectContinue = this.ExpectContinue;
310              }
311          }
312          private void ApplyToken(
313              HttpRequestMessage request,
314              IssuedToken token,
315              bool applyICredentialsToWebProxy = false)
316          {
317              if (token == null)
318              {
319                  return;
320              }
321              ICredentials credentialsToken = token as ICredentials;
322              if (credentialsToken != null)
323              {
324                  if (applyICredentialsToWebProxy)
325                  {
326                      HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
327                      if (httpClientHandler != null &amp;&amp;
328                          httpClientHandler.Proxy != null)
329                      {
330                          httpClientHandler.Proxy.Credentials = credentialsToken;
331                      }
332                  }
333                  m_credentialWrapper.InnerCredentials = credentialsToken;
334              }
335              else
336              {
337                  token.ApplyTo(new HttpRequestMessageWrapper(request));
338              }
339          }
340          private static void ApplySettings(
341              HttpMessageHandler handler,
342              ICredentials defaultCredentials,
343              VssHttpRequestSettings settings)
344          {
345              HttpClientHandler httpClientHandler = handler as HttpClientHandler;
346              if (httpClientHandler != null)
347              {
348                  httpClientHandler.AllowAutoRedirect = settings.AllowAutoRedirect;
349                  httpClientHandler.ClientCertificateOptions = ClientCertificateOption.Manual;
350                  httpClientHandler.UseDefaultCredentials = false;
351                  httpClientHandler.Credentials = defaultCredentials;
352                  httpClientHandler.PreAuthenticate = false;
353                  httpClientHandler.Proxy = DefaultWebProxy;
354                  httpClientHandler.UseCookies = false;
355                  httpClientHandler.UseProxy = true;
356                  if (settings.CompressionEnabled)
357                  {
358                      httpClientHandler.AutomaticDecompression = DecompressionMethods.GZip;
359                  }
360              }
361          }
362          private static IWebProxy s_defaultWebProxy = null;
363          public static IWebProxy DefaultWebProxy
364          {
365              get
366              {
367                  var toReturn = WebProxyWrapper.Wrap(s_defaultWebProxy);
368                  if (null != toReturn &amp;&amp;
369                      toReturn.Credentials == null)
370                  {
371                      toReturn.Credentials = CredentialCache.DefaultCredentials;
372                  }
373                  return toReturn;
374              }
375              set
376              {
377                  s_defaultWebProxy = value;
378              }
379          }
380          internal const String CredentialsType = nameof(CredentialsType);
381          private const Int32 m_maxAuthRetries = 3;
382          private HttpMessageInvoker m_messageInvoker;
383          private CredentialWrapper m_credentialWrapper;
384          private bool m_appliedClientCertificatesToTransportHandler;
385          private bool m_appliedServerCertificateValidationCallbackToTransportHandler;
386          private readonly HttpMessageHandler m_transportHandler;
387          private sealed class CredentialWrapper : CredentialCache, ICredentials
388          {
389              public ICredentials InnerCredentials
390              {
391                  get;
392                  set;
393              }
394              NetworkCredential ICredentials.GetCredential(
395                  Uri uri,
<span onclick='openModal()' class='match'>396                  String authType)
397              {
398                  return InnerCredentials != null ? InnerCredentials.GetCredential(uri, authType) : null;
399              }
400          }
401          private sealed class WebProxyWrapper : IWebProxy
402          {
403              private WebProxyWrapper(IWebProxy toWrap)
404              {
405                  m_wrapped = toWrap;
406                  m_credentials = null;
407              }
408              public static WebProxyWrapper Wrap(IWebProxy toWrap)
409              {
410                  if (null == toWrap)
411                  {
412                      return null;
413                  }
414                  return new WebProxyWrapper(toWrap);
415              }
416              public ICredentials Credentials
417              {
418                  get
419                  {
420                      ICredentials credentials = m_credentials;
421                      if (null == credentials)
422                      {
423                          credentials = m_wrapped.Credentials;
424                      }
425                      else if (Object.ReferenceEquals(credentials, m_nullCredentials))
426                      {
427                          credentials = null;
428                      }
429                      return credentials;
430                  }
431                  set
432                  {
433                      if (null == value)
434                      {
435                          m_credentials = m_nullCredentials;
436                      }
437                      else
438                      {
439                          m_credentials = value;
440                      }
441                  }
442              }
443              public Uri GetProxy(Uri destination)
444              {
445                  return m_wrapped.GetProxy(destination);
446              }
447              public bool IsBypassed(Uri host)
448              {
449                  return m_wrapped.IsBypassed(host);
450              }
451              private readonly IWebProxy m_wrapped;
452              private ICredentials m_credentials;
453              private static readonly ICredentials m_nullCredentials = new CredentialWrapper();
454          }
455      }
456  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-RawHttpMessageHandler.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssHttpMessageHandler.cs</div>
                </div>
                <div class="column column_space"><pre><code>236                  String authType)
237              {
238                  return InnerCredentials != null ? InnerCredentials.GetCredential(uri, authType) : null;
239              }
240          }
241          private sealed class WebProxyWrapper : IWebProxy
242          {
243              private WebProxyWrapper(IWebProxy toWrap)
244              {
245                  m_wrapped = toWrap;
246                  m_credentials = null;
247              }
248              public static WebProxyWrapper Wrap(IWebProxy toWrap)
249              {
250                  if (null == toWrap)
251                  {
252                      return null;
253                  }
254                  return new WebProxyWrapper(toWrap);
255              }
256              public ICredentials Credentials
257              {
258                  get
259                  {
260                      ICredentials credentials = m_credentials;
261                      if (null == credentials)
262                      {
263                          credentials = m_wrapped.Credentials;
264                      }
265                      else if (Object.ReferenceEquals(credentials, m_nullCredentials))
266                      {
267                          credentials = null;
268                      }
269                      return credentials;
270                  }
271                  set
272                  {
273                      if (null == value)
274                      {
275                          m_credentials = m_nullCredentials;
276                      }
277                      else
278                      {
279                          m_credentials = value;
280                      }
281                  }
282              }
283              public Uri GetProxy(Uri destination)
284              {
285                  return m_wrapped.GetProxy(destination);
286              }
287              public bool IsBypassed(Uri host)
288              {
289                  return m_wrapped.IsBypassed(host);
290              }
291              private readonly IWebProxy m_wrapped;
292              private ICredentials m_credentials;
293              private static readonly ICredentials m_nullCredentials = new CredentialWrapper();
294          }
295      }
296  }
</pre></code></div>
                <div class="column column_space"><pre><code>396                  String authType)
397              {
398                  return InnerCredentials != null ? InnerCredentials.GetCredential(uri, authType) : null;
399              }
400          }
401          private sealed class WebProxyWrapper : IWebProxy
402          {
403              private WebProxyWrapper(IWebProxy toWrap)
404              {
405                  m_wrapped = toWrap;
406                  m_credentials = null;
407              }
408              public static WebProxyWrapper Wrap(IWebProxy toWrap)
409              {
410                  if (null == toWrap)
411                  {
412                      return null;
413                  }
414                  return new WebProxyWrapper(toWrap);
415              }
416              public ICredentials Credentials
417              {
418                  get
419                  {
420                      ICredentials credentials = m_credentials;
421                      if (null == credentials)
422                      {
423                          credentials = m_wrapped.Credentials;
424                      }
425                      else if (Object.ReferenceEquals(credentials, m_nullCredentials))
426                      {
427                          credentials = null;
428                      }
429                      return credentials;
430                  }
431                  set
432                  {
433                      if (null == value)
434                      {
435                          m_credentials = m_nullCredentials;
436                      }
437                      else
438                      {
439                          m_credentials = value;
440                      }
441                  }
442              }
443              public Uri GetProxy(Uri destination)
444              {
445                  return m_wrapped.GetProxy(destination);
446              }
447              public bool IsBypassed(Uri host)
448              {
449                  return m_wrapped.IsBypassed(host);
450              }
451              private readonly IWebProxy m_wrapped;
452              private ICredentials m_credentials;
453              private static readonly ICredentials m_nullCredentials = new CredentialWrapper();
454          }
455      }
456  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    