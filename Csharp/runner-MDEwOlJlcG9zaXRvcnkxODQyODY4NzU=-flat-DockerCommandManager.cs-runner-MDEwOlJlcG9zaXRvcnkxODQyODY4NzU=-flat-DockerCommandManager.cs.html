
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Text.RegularExpressions;
6  using System.Threading;
7  using System.Threading.Channels;
8  using System.Threading.Tasks;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  namespace GitHub.Runner.Worker.Container
12  {
13      [ServiceLocator(Default = typeof(DockerCommandManager))]
14      public interface IDockerCommandManager : IRunnerService
15      {
16          string DockerPath { get; }
17          string DockerInstanceLabel { get; }
18          Task<DockerVersion> DockerVersion(IExecutionContext context);
19          Task<int> DockerPull(IExecutionContext context, string image);
20          Task<int> DockerPull(IExecutionContext context, string image, string configFileDirectory);
21          Task<int> DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag);
22          Task<string> DockerCreate(IExecutionContext context, ContainerInfo container);
23          Task<int> DockerRun(IExecutionContext context, ContainerInfo container, EventHandler<ProcessDataReceivedEventArgs> stdoutDataReceived, EventHandler<ProcessDataReceivedEventArgs> stderrDataReceived);
24          Task<int> DockerStart(IExecutionContext context, string containerId);
25          Task<int> DockerLogs(IExecutionContext context, string containerId);
26          Task<List<string>> DockerPS(IExecutionContext context, string options);
27          Task<int> DockerRemove(IExecutionContext context, string containerId);
28          Task<int> DockerNetworkCreate(IExecutionContext context, string network);
29          Task<int> DockerNetworkRemove(IExecutionContext context, string network);
30          Task<int> DockerNetworkPrune(IExecutionContext context);
31          Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command);
32          Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command, List<string> outputs);
33          Task<List<string>> DockerInspect(IExecutionContext context, string dockerObject, string options);
34          Task<List<PortMapping>> DockerPort(IExecutionContext context, string containerId);
35          Task<int> DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password);
36      }
37      public class DockerCommandManager : RunnerService, IDockerCommandManager
38      {
39          public string DockerPath { get; private set; }
40          public string DockerInstanceLabel { get; private set; }
41          public override void Initialize(IHostContext hostContext)
42          {
43              base.Initialize(hostContext);
44              DockerPath = WhichUtil.Which("docker", true, Trace);
45              DockerInstanceLabel = IOUtil.GetSha256Hash(hostContext.GetDirectory(WellKnownDirectory.Root)).Substring(0, 6);
46          }
47          public async Task<DockerVersion> DockerVersion(IExecutionContext context)
48          {
49              string serverVersionStr = (await ExecuteDockerCommandAsync(context, "version", "--format '{{.Server.APIVersion}}'")).FirstOrDefault();
50              ArgUtil.NotNullOrEmpty(serverVersionStr, "Docker.Server.Version");
51              context.Output($"Docker daemon API version: {serverVersionStr}");
52              string clientVersionStr = (await ExecuteDockerCommandAsync(context, "version", "--format '{{.Client.APIVersion}}'")).FirstOrDefault();
53              ArgUtil.NotNullOrEmpty(serverVersionStr, "Docker.Client.Version");
54              context.Output($"Docker client API version: {clientVersionStr}");
55              Regex verRegex = new("\\d+\\.\\d+(\\.\\d+)?", RegexOptions.IgnoreCase);
56              Version serverVersion = null;
57              var serverVersionMatchResult = verRegex.Match(serverVersionStr);
58              if (serverVersionMatchResult.Success && !string.IsNullOrEmpty(serverVersionMatchResult.Value))
59              {
60                  if (!Version.TryParse(serverVersionMatchResult.Value, out serverVersion))
61                  {
62                      serverVersion = null;
63                  }
64              }
65              Version clientVersion = null;
66              var clientVersionMatchResult = verRegex.Match(serverVersionStr);
67              if (clientVersionMatchResult.Success && !string.IsNullOrEmpty(clientVersionMatchResult.Value))
68              {
69                  if (!Version.TryParse(clientVersionMatchResult.Value, out clientVersion))
70                  {
71                      clientVersion = null;
72                  }
73              }
74              return new DockerVersion(serverVersion, clientVersion);
75          }
76          public Task<int> DockerPull(IExecutionContext context, string image)
77          {
78              return DockerPull(context, image, null);
79          }
80          public async Task<int> DockerPull(IExecutionContext context, string image, string configFileDirectory)
81          {
82              if (string.IsNullOrEmpty(configFileDirectory))
83              {
84                  return await ExecuteDockerCommandAsync(context, $"pull", image, context.CancellationToken);
85              }
86              return await ExecuteDockerCommandAsync(context, $"--config {configFileDirectory} pull", image, context.CancellationToken);
87          }
88          public async Task<int> DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag)
89          {
90              return await ExecuteDockerCommandAsync(context, "build", $"-t {tag} -f \"{dockerFile}\" \"{dockerContext}\"", workingDirectory, context.CancellationToken);
91          }
92          public async Task<string> DockerCreate(IExecutionContext context, ContainerInfo container)
93          {
94              IList<string> dockerOptions = new List<string>();
95              dockerOptions.Add($"--name {container.ContainerDisplayName}");
96              dockerOptions.Add($"--label {DockerInstanceLabel}");
97              if (!string.IsNullOrEmpty(container.ContainerWorkDirectory))
98              {
99                  dockerOptions.Add($"--workdir {container.ContainerWorkDirectory}");
100              }
101              if (!string.IsNullOrEmpty(container.ContainerNetwork))
102              {
103                  dockerOptions.Add($"--network {container.ContainerNetwork}");
104              }
105              if (!string.IsNullOrEmpty(container.ContainerNetworkAlias))
106              {
107                  dockerOptions.Add($"--network-alias {container.ContainerNetworkAlias}");
108              }
109              foreach (var port in container.UserPortMappings)
110              {
111                  dockerOptions.Add($"-p {port.Value}");
112              }
113              dockerOptions.Add($"{container.ContainerCreateOptions}");
114              foreach (var env in container.ContainerEnvironmentVariables)
115              {
116                  if (String.IsNullOrEmpty(env.Value))
117                  {
118                      dockerOptions.Add(DockerUtil.CreateEscapedOption("-e", env.Key));
119                  }
120                  else
121                  {
122                      dockerOptions.Add(DockerUtil.CreateEscapedOption("-e", env.Key, env.Value));
123                  }
124              }
125              dockerOptions.Add("-e GITHUB_ACTIONS=true");
126              if (!container.ContainerEnvironmentVariables.ContainsKey("CI"))
127              {
128                  dockerOptions.Add("-e CI=true");
129              }
130              foreach (var volume in container.MountVolumes)
131              {
132                  String volumeArg;
133                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
134                  {
135                      volumeArg = $"-v \"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
136                  }
137                  else
138                  {
139                      volumeArg = $"-v \"{volume.SourceVolumePath.Replace("\"", "\\\"")}\":\"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
140                  }
141                  if (volume.ReadOnly)
142                  {
143                      volumeArg += ":ro";
144                  }
145                  dockerOptions.Add(volumeArg);
146              }
147              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
148              {
149                  dockerOptions.Add($"--entrypoint \"{container.ContainerEntryPoint}\"");
150              }
151              dockerOptions.Add($"{container.ContainerImage}");
<span onclick='openModal()' class='match'>152              dockerOptions.Add($"{container.ContainerEntryPointArgs}");
153              var optionsString = string.Join(" ", dockerOptions);
154              List<string> outputStrings = await ExecuteDockerCommandAsync(context, "create", optionsString);
</span>155              return outputStrings.FirstOrDefault();
156          }
157          public async Task<int> DockerRun(IExecutionContext context, ContainerInfo container, EventHandler<ProcessDataReceivedEventArgs> stdoutDataReceived, EventHandler<ProcessDataReceivedEventArgs> stderrDataReceived)
158          {
159              IList<string> dockerOptions = new List<string>();
160              dockerOptions.Add($"--name {container.ContainerDisplayName}");
161              dockerOptions.Add($"--label {DockerInstanceLabel}");
162              dockerOptions.Add($"--workdir {container.ContainerWorkDirectory}");
163              dockerOptions.Add($"--rm");
164              foreach (var env in container.ContainerEnvironmentVariables)
165              {
166                  dockerOptions.Add(DockerUtil.CreateEscapedOption("-e", env.Key));
167              }
168              dockerOptions.Add("-e GITHUB_ACTIONS=true");
169              if (!container.ContainerEnvironmentVariables.ContainsKey("CI"))
170              {
171                  dockerOptions.Add("-e CI=true");
172              }
173              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
174              {
175                  dockerOptions.Add($"--entrypoint \"{container.ContainerEntryPoint}\"");
176              }
177              if (!string.IsNullOrEmpty(container.ContainerNetwork))
178              {
179                  dockerOptions.Add($"--network {container.ContainerNetwork}");
180              }
181              foreach (var volume in container.MountVolumes)
182              {
183                  String volumeArg;
184                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
185                  {
186                      volumeArg = $"-v \"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
187                  }
188                  else
189                  {
190                      volumeArg = $"-v \"{volume.SourceVolumePath.Replace("\"", "\\\"")}\":\"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
191                  }
192                  if (volume.ReadOnly)
193                  {
194                      volumeArg += ":ro";
195                  }
196                  dockerOptions.Add(volumeArg);
197              }
198              dockerOptions.Add($"{container.ContainerImage}");
199              dockerOptions.Add($"{container.ContainerEntryPointArgs}");
200              var optionsString = string.Join(" ", dockerOptions);
201              return await ExecuteDockerCommandAsync(context, "run", optionsString, container.ContainerEnvironmentVariables, stdoutDataReceived, stderrDataReceived, context.CancellationToken);
202          }
203          public async Task<int> DockerStart(IExecutionContext context, string containerId)
204          {
205              return await ExecuteDockerCommandAsync(context, "start", containerId, context.CancellationToken);
206          }
207          public async Task<int> DockerRemove(IExecutionContext context, string containerId)
208          {
209              return await ExecuteDockerCommandAsync(context, "rm", $"--force {containerId}", context.CancellationToken);
210          }
211          public async Task<int> DockerLogs(IExecutionContext context, string containerId)
212          {
213              return await ExecuteDockerCommandAsync(context, "logs", $"--details {containerId}", context.CancellationToken);
214          }
215          public async Task<List<string>> DockerPS(IExecutionContext context, string options)
216          {
217              return await ExecuteDockerCommandAsync(context, "ps", options);
218          }
219          public async Task<int> DockerNetworkCreate(IExecutionContext context, string network)
220          {
221  #if OS_WINDOWS
222              return await ExecuteDockerCommandAsync(context, "network", $"create --label {DockerInstanceLabel} {network} --driver nat", context.CancellationToken);
223  #else
224              return await ExecuteDockerCommandAsync(context, "network", $"create --label {DockerInstanceLabel} {network}", context.CancellationToken);
225  #endif
226          }
227          public async Task<int> DockerNetworkRemove(IExecutionContext context, string network)
228          {
229              return await ExecuteDockerCommandAsync(context, "network", $"rm {network}", context.CancellationToken);
230          }
231          public async Task<int> DockerNetworkPrune(IExecutionContext context)
232          {
233              return await ExecuteDockerCommandAsync(context, "network", $"prune --force --filter \"label={DockerInstanceLabel}\"", context.CancellationToken);
234          }
235          public async Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command)
236          {
237              return await ExecuteDockerCommandAsync(context, "exec", $"{options} {containerId} {command}", context.CancellationToken);
238          }
239          public async Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command, List<string> output)
240          {
241              ArgUtil.NotNull(output, nameof(output));
242              string arg = $"exec {options} {containerId} {command}".Trim();
243              context.Command($"{DockerPath} {arg}");
244              object outputLock = new();
245              var processInvoker = HostContext.CreateService<IProcessInvoker>();
246              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
247              {
248                  if (!string.IsNullOrEmpty(message.Data))
249                  {
250                      lock (outputLock)
251                      {
252                          output.Add(message.Data);
253                      }
254                  }
255              };
256              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
257              {
258                  if (!string.IsNullOrEmpty(message.Data))
259                  {
260                      lock (outputLock)
261                      {
262                          output.Add(message.Data);
263                      }
264                  }
265              };
266              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
267              {
268                  throw new NotSupportedException("Container operations are only supported on Linux runners");
269              }
270              return await processInvoker.ExecuteAsync(
271                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
272                              fileName: DockerPath,
273                              arguments: arg,
274                              environment: null,
275                              requireExitCodeZero: false,
276                              outputEncoding: null,
277                              cancellationToken: CancellationToken.None);
278          }
279          public async Task<List<string>> DockerInspect(IExecutionContext context, string dockerObject, string options)
280          {
281              return await ExecuteDockerCommandAsync(context, "inspect", $"{options} {dockerObject}");
282          }
283          public async Task<List<PortMapping>> DockerPort(IExecutionContext context, string containerId)
284          {
285              List<string> portMappingLines = await ExecuteDockerCommandAsync(context, "port", containerId);
286              return DockerUtil.ParseDockerPort(portMappingLines);
287          }
288          public Task<int> DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password)
289          {
290              string args = $"--config {configFileDirectory} login {registry} -u {username} --password-stdin";
291              context.Command($"{DockerPath} {args}");
292              var input = Channel.CreateBounded<string>(new BoundedChannelOptions(1) { SingleReader = true, SingleWriter = true });
293              input.Writer.TryWrite(password);
294              var processInvoker = HostContext.CreateService<IProcessInvoker>();
295              return processInvoker.ExecuteAsync(
296                  workingDirectory: context.GetGitHubContext("workspace"),
297                  fileName: DockerPath,
298                  arguments: args,
299                  environment: null,
300                  requireExitCodeZero: false,
301                  outputEncoding: null,
302                  killProcessOnCancel: false,
303                  redirectStandardIn: input,
304                  cancellationToken: context.CancellationToken);
305          }
306          private Task<int> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, CancellationToken cancellationToken = default(CancellationToken))
307          {
308              return ExecuteDockerCommandAsync(context, command, options, null, cancellationToken);
309          }
310          private async Task<int> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, IDictionary<string, string> environment, EventHandler<ProcessDataReceivedEventArgs> stdoutDataReceived, EventHandler<ProcessDataReceivedEventArgs> stderrDataReceived, CancellationToken cancellationToken = default(CancellationToken))
311          {
312              string arg = $"{command} {options}".Trim();
313              context.Command($"{DockerPath} {arg}");
314              var processInvoker = HostContext.CreateService<IProcessInvoker>();
315              processInvoker.OutputDataReceived += stdoutDataReceived;
316              processInvoker.ErrorDataReceived += stderrDataReceived;
317              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
318              {
319                  throw new NotSupportedException("Container operations are only supported on Linux runners");
320              }
321              return await processInvoker.ExecuteAsync(
322                  workingDirectory: context.GetGitHubContext("workspace"),
323                  fileName: DockerPath,
324                  arguments: arg,
325                  environment: environment,
326                  requireExitCodeZero: false,
327                  outputEncoding: null,
328                  killProcessOnCancel: false,
329                  cancellationToken: cancellationToken);
330          }
331          private async Task<int> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, string workingDirectory, CancellationToken cancellationToken = default(CancellationToken))
332          {
333              string arg = $"{command} {options}".Trim();
334              context.Command($"{DockerPath} {arg}");
335              var processInvoker = HostContext.CreateService<IProcessInvoker>();
336              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
337              {
338                  context.Output(message.Data);
339              };
340              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
341              {
342                  context.Output(message.Data);
343              };
344              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
345              {
346                  throw new NotSupportedException("Container operations are only supported on Linux runners");
347              }
348              return await processInvoker.ExecuteAsync(
349                  workingDirectory: workingDirectory ?? context.GetGitHubContext("workspace"),
350                  fileName: DockerPath,
351                  arguments: arg,
352                  environment: null,
353                  requireExitCodeZero: false,
354                  outputEncoding: null,
355                  killProcessOnCancel: false,
356                  redirectStandardIn: null,
357                  cancellationToken: cancellationToken);
358          }
359          private async Task<List<string>> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options)
360          {
361              string arg = $"{command} {options}".Trim();
362              context.Command($"{DockerPath} {arg}");
363              List<string> output = new();
364              var processInvoker = HostContext.CreateService<IProcessInvoker>();
365              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
366              {
367                  if (!string.IsNullOrEmpty(message.Data))
368                  {
369                      output.Add(message.Data);
370                      context.Output(message.Data);
371                  }
372              };
373              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
374              {
375                  if (!string.IsNullOrEmpty(message.Data))
376                  {
377                      context.Output(message.Data);
378                  }
379              };
380              await processInvoker.ExecuteAsync(
381                              workingDirectory: context.GetGitHubContext("workspace"),
382                              fileName: DockerPath,
383                              arguments: arg,
384                              environment: null,
385                              requireExitCodeZero: true,
386                              outputEncoding: null,
387                              cancellationToken: CancellationToken.None);
388              return output;
389          }
390      }
391  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Text.RegularExpressions;
6  using System.Threading;
7  using System.Threading.Channels;
8  using System.Threading.Tasks;
9  using GitHub.Runner.Common;
10  using GitHub.Runner.Sdk;
11  namespace GitHub.Runner.Worker.Container
12  {
13      [ServiceLocator(Default = typeof(DockerCommandManager))]
14      public interface IDockerCommandManager : IRunnerService
15      {
16          string DockerPath { get; }
17          string DockerInstanceLabel { get; }
18          Task<DockerVersion> DockerVersion(IExecutionContext context);
19          Task<int> DockerPull(IExecutionContext context, string image);
20          Task<int> DockerPull(IExecutionContext context, string image, string configFileDirectory);
21          Task<int> DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag);
22          Task<string> DockerCreate(IExecutionContext context, ContainerInfo container);
23          Task<int> DockerRun(IExecutionContext context, ContainerInfo container, EventHandler<ProcessDataReceivedEventArgs> stdoutDataReceived, EventHandler<ProcessDataReceivedEventArgs> stderrDataReceived);
24          Task<int> DockerStart(IExecutionContext context, string containerId);
25          Task<int> DockerLogs(IExecutionContext context, string containerId);
26          Task<List<string>> DockerPS(IExecutionContext context, string options);
27          Task<int> DockerRemove(IExecutionContext context, string containerId);
28          Task<int> DockerNetworkCreate(IExecutionContext context, string network);
29          Task<int> DockerNetworkRemove(IExecutionContext context, string network);
30          Task<int> DockerNetworkPrune(IExecutionContext context);
31          Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command);
32          Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command, List<string> outputs);
33          Task<List<string>> DockerInspect(IExecutionContext context, string dockerObject, string options);
34          Task<List<PortMapping>> DockerPort(IExecutionContext context, string containerId);
35          Task<int> DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password);
36      }
37      public class DockerCommandManager : RunnerService, IDockerCommandManager
38      {
39          public string DockerPath { get; private set; }
40          public string DockerInstanceLabel { get; private set; }
41          public override void Initialize(IHostContext hostContext)
42          {
43              base.Initialize(hostContext);
44              DockerPath = WhichUtil.Which("docker", true, Trace);
45              DockerInstanceLabel = IOUtil.GetSha256Hash(hostContext.GetDirectory(WellKnownDirectory.Root)).Substring(0, 6);
46          }
47          public async Task<DockerVersion> DockerVersion(IExecutionContext context)
48          {
49              string serverVersionStr = (await ExecuteDockerCommandAsync(context, "version", "--format '{{.Server.APIVersion}}'")).FirstOrDefault();
50              ArgUtil.NotNullOrEmpty(serverVersionStr, "Docker.Server.Version");
51              context.Output($"Docker daemon API version: {serverVersionStr}");
52              string clientVersionStr = (await ExecuteDockerCommandAsync(context, "version", "--format '{{.Client.APIVersion}}'")).FirstOrDefault();
53              ArgUtil.NotNullOrEmpty(serverVersionStr, "Docker.Client.Version");
54              context.Output($"Docker client API version: {clientVersionStr}");
55              Regex verRegex = new("\\d+\\.\\d+(\\.\\d+)?", RegexOptions.IgnoreCase);
56              Version serverVersion = null;
57              var serverVersionMatchResult = verRegex.Match(serverVersionStr);
58              if (serverVersionMatchResult.Success && !string.IsNullOrEmpty(serverVersionMatchResult.Value))
59              {
60                  if (!Version.TryParse(serverVersionMatchResult.Value, out serverVersion))
61                  {
62                      serverVersion = null;
63                  }
64              }
65              Version clientVersion = null;
66              var clientVersionMatchResult = verRegex.Match(serverVersionStr);
67              if (clientVersionMatchResult.Success && !string.IsNullOrEmpty(clientVersionMatchResult.Value))
68              {
69                  if (!Version.TryParse(clientVersionMatchResult.Value, out clientVersion))
70                  {
71                      clientVersion = null;
72                  }
73              }
74              return new DockerVersion(serverVersion, clientVersion);
75          }
76          public Task<int> DockerPull(IExecutionContext context, string image)
77          {
78              return DockerPull(context, image, null);
79          }
80          public async Task<int> DockerPull(IExecutionContext context, string image, string configFileDirectory)
81          {
82              if (string.IsNullOrEmpty(configFileDirectory))
83              {
84                  return await ExecuteDockerCommandAsync(context, $"pull", image, context.CancellationToken);
85              }
86              return await ExecuteDockerCommandAsync(context, $"--config {configFileDirectory} pull", image, context.CancellationToken);
87          }
88          public async Task<int> DockerBuild(IExecutionContext context, string workingDirectory, string dockerFile, string dockerContext, string tag)
89          {
90              return await ExecuteDockerCommandAsync(context, "build", $"-t {tag} -f \"{dockerFile}\" \"{dockerContext}\"", workingDirectory, context.CancellationToken);
91          }
92          public async Task<string> DockerCreate(IExecutionContext context, ContainerInfo container)
93          {
94              IList<string> dockerOptions = new List<string>();
95              dockerOptions.Add($"--name {container.ContainerDisplayName}");
96              dockerOptions.Add($"--label {DockerInstanceLabel}");
97              if (!string.IsNullOrEmpty(container.ContainerWorkDirectory))
98              {
99                  dockerOptions.Add($"--workdir {container.ContainerWorkDirectory}");
100              }
101              if (!string.IsNullOrEmpty(container.ContainerNetwork))
102              {
103                  dockerOptions.Add($"--network {container.ContainerNetwork}");
104              }
105              if (!string.IsNullOrEmpty(container.ContainerNetworkAlias))
106              {
107                  dockerOptions.Add($"--network-alias {container.ContainerNetworkAlias}");
108              }
109              foreach (var port in container.UserPortMappings)
110              {
111                  dockerOptions.Add($"-p {port.Value}");
112              }
113              dockerOptions.Add($"{container.ContainerCreateOptions}");
114              foreach (var env in container.ContainerEnvironmentVariables)
115              {
116                  if (String.IsNullOrEmpty(env.Value))
117                  {
118                      dockerOptions.Add(DockerUtil.CreateEscapedOption("-e", env.Key));
119                  }
120                  else
121                  {
122                      dockerOptions.Add(DockerUtil.CreateEscapedOption("-e", env.Key, env.Value));
123                  }
124              }
125              dockerOptions.Add("-e GITHUB_ACTIONS=true");
126              if (!container.ContainerEnvironmentVariables.ContainsKey("CI"))
127              {
128                  dockerOptions.Add("-e CI=true");
129              }
130              foreach (var volume in container.MountVolumes)
131              {
132                  String volumeArg;
133                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
134                  {
135                      volumeArg = $"-v \"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
136                  }
137                  else
138                  {
139                      volumeArg = $"-v \"{volume.SourceVolumePath.Replace("\"", "\\\"")}\":\"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
140                  }
141                  if (volume.ReadOnly)
142                  {
143                      volumeArg += ":ro";
144                  }
145                  dockerOptions.Add(volumeArg);
146              }
147              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
148              {
149                  dockerOptions.Add($"--entrypoint \"{container.ContainerEntryPoint}\"");
150              }
151              dockerOptions.Add($"{container.ContainerImage}");
152              dockerOptions.Add($"{container.ContainerEntryPointArgs}");
153              var optionsString = string.Join(" ", dockerOptions);
154              List<string> outputStrings = await ExecuteDockerCommandAsync(context, "create", optionsString);
155              return outputStrings.FirstOrDefault();
156          }
157          public async Task<int> DockerRun(IExecutionContext context, ContainerInfo container, EventHandler<ProcessDataReceivedEventArgs> stdoutDataReceived, EventHandler<ProcessDataReceivedEventArgs> stderrDataReceived)
158          {
159              IList<string> dockerOptions = new List<string>();
160              dockerOptions.Add($"--name {container.ContainerDisplayName}");
161              dockerOptions.Add($"--label {DockerInstanceLabel}");
162              dockerOptions.Add($"--workdir {container.ContainerWorkDirectory}");
163              dockerOptions.Add($"--rm");
164              foreach (var env in container.ContainerEnvironmentVariables)
165              {
166                  dockerOptions.Add(DockerUtil.CreateEscapedOption("-e", env.Key));
167              }
168              dockerOptions.Add("-e GITHUB_ACTIONS=true");
169              if (!container.ContainerEnvironmentVariables.ContainsKey("CI"))
170              {
171                  dockerOptions.Add("-e CI=true");
172              }
173              if (!string.IsNullOrEmpty(container.ContainerEntryPoint))
174              {
175                  dockerOptions.Add($"--entrypoint \"{container.ContainerEntryPoint}\"");
176              }
177              if (!string.IsNullOrEmpty(container.ContainerNetwork))
178              {
179                  dockerOptions.Add($"--network {container.ContainerNetwork}");
180              }
181              foreach (var volume in container.MountVolumes)
182              {
183                  String volumeArg;
184                  if (String.IsNullOrEmpty(volume.SourceVolumePath))
185                  {
186                      volumeArg = $"-v \"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
187                  }
188                  else
189                  {
190                      volumeArg = $"-v \"{volume.SourceVolumePath.Replace("\"", "\\\"")}\":\"{volume.TargetVolumePath.Replace("\"", "\\\"")}\"";
191                  }
192                  if (volume.ReadOnly)
193                  {
194                      volumeArg += ":ro";
195                  }
196                  dockerOptions.Add(volumeArg);
197              }
198              dockerOptions.Add($"{container.ContainerImage}");
<span onclick='openModal()' class='match'>199              dockerOptions.Add($"{container.ContainerEntryPointArgs}");
200              var optionsString = string.Join(" ", dockerOptions);
201              return await ExecuteDockerCommandAsync(context, "run", optionsString, container.ContainerEnvironmentVariables, stdoutDataReceived, stderrDataReceived, context.CancellationToken);
</span>202          }
203          public async Task<int> DockerStart(IExecutionContext context, string containerId)
204          {
205              return await ExecuteDockerCommandAsync(context, "start", containerId, context.CancellationToken);
206          }
207          public async Task<int> DockerRemove(IExecutionContext context, string containerId)
208          {
209              return await ExecuteDockerCommandAsync(context, "rm", $"--force {containerId}", context.CancellationToken);
210          }
211          public async Task<int> DockerLogs(IExecutionContext context, string containerId)
212          {
213              return await ExecuteDockerCommandAsync(context, "logs", $"--details {containerId}", context.CancellationToken);
214          }
215          public async Task<List<string>> DockerPS(IExecutionContext context, string options)
216          {
217              return await ExecuteDockerCommandAsync(context, "ps", options);
218          }
219          public async Task<int> DockerNetworkCreate(IExecutionContext context, string network)
220          {
221  #if OS_WINDOWS
222              return await ExecuteDockerCommandAsync(context, "network", $"create --label {DockerInstanceLabel} {network} --driver nat", context.CancellationToken);
223  #else
224              return await ExecuteDockerCommandAsync(context, "network", $"create --label {DockerInstanceLabel} {network}", context.CancellationToken);
225  #endif
226          }
227          public async Task<int> DockerNetworkRemove(IExecutionContext context, string network)
228          {
229              return await ExecuteDockerCommandAsync(context, "network", $"rm {network}", context.CancellationToken);
230          }
231          public async Task<int> DockerNetworkPrune(IExecutionContext context)
232          {
233              return await ExecuteDockerCommandAsync(context, "network", $"prune --force --filter \"label={DockerInstanceLabel}\"", context.CancellationToken);
234          }
235          public async Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command)
236          {
237              return await ExecuteDockerCommandAsync(context, "exec", $"{options} {containerId} {command}", context.CancellationToken);
238          }
239          public async Task<int> DockerExec(IExecutionContext context, string containerId, string options, string command, List<string> output)
240          {
241              ArgUtil.NotNull(output, nameof(output));
242              string arg = $"exec {options} {containerId} {command}".Trim();
243              context.Command($"{DockerPath} {arg}");
244              object outputLock = new();
245              var processInvoker = HostContext.CreateService<IProcessInvoker>();
246              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
247              {
248                  if (!string.IsNullOrEmpty(message.Data))
249                  {
250                      lock (outputLock)
251                      {
252                          output.Add(message.Data);
253                      }
254                  }
255              };
256              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
257              {
258                  if (!string.IsNullOrEmpty(message.Data))
259                  {
260                      lock (outputLock)
261                      {
262                          output.Add(message.Data);
263                      }
264                  }
265              };
266              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
267              {
268                  throw new NotSupportedException("Container operations are only supported on Linux runners");
269              }
270              return await processInvoker.ExecuteAsync(
271                              workingDirectory: HostContext.GetDirectory(WellKnownDirectory.Work),
272                              fileName: DockerPath,
273                              arguments: arg,
274                              environment: null,
275                              requireExitCodeZero: false,
276                              outputEncoding: null,
277                              cancellationToken: CancellationToken.None);
278          }
279          public async Task<List<string>> DockerInspect(IExecutionContext context, string dockerObject, string options)
280          {
281              return await ExecuteDockerCommandAsync(context, "inspect", $"{options} {dockerObject}");
282          }
283          public async Task<List<PortMapping>> DockerPort(IExecutionContext context, string containerId)
284          {
285              List<string> portMappingLines = await ExecuteDockerCommandAsync(context, "port", containerId);
286              return DockerUtil.ParseDockerPort(portMappingLines);
287          }
288          public Task<int> DockerLogin(IExecutionContext context, string configFileDirectory, string registry, string username, string password)
289          {
290              string args = $"--config {configFileDirectory} login {registry} -u {username} --password-stdin";
291              context.Command($"{DockerPath} {args}");
292              var input = Channel.CreateBounded<string>(new BoundedChannelOptions(1) { SingleReader = true, SingleWriter = true });
293              input.Writer.TryWrite(password);
294              var processInvoker = HostContext.CreateService<IProcessInvoker>();
295              return processInvoker.ExecuteAsync(
296                  workingDirectory: context.GetGitHubContext("workspace"),
297                  fileName: DockerPath,
298                  arguments: args,
299                  environment: null,
300                  requireExitCodeZero: false,
301                  outputEncoding: null,
302                  killProcessOnCancel: false,
303                  redirectStandardIn: input,
304                  cancellationToken: context.CancellationToken);
305          }
306          private Task<int> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, CancellationToken cancellationToken = default(CancellationToken))
307          {
308              return ExecuteDockerCommandAsync(context, command, options, null, cancellationToken);
309          }
310          private async Task<int> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, IDictionary<string, string> environment, EventHandler<ProcessDataReceivedEventArgs> stdoutDataReceived, EventHandler<ProcessDataReceivedEventArgs> stderrDataReceived, CancellationToken cancellationToken = default(CancellationToken))
311          {
312              string arg = $"{command} {options}".Trim();
313              context.Command($"{DockerPath} {arg}");
314              var processInvoker = HostContext.CreateService<IProcessInvoker>();
315              processInvoker.OutputDataReceived += stdoutDataReceived;
316              processInvoker.ErrorDataReceived += stderrDataReceived;
317              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
318              {
319                  throw new NotSupportedException("Container operations are only supported on Linux runners");
320              }
321              return await processInvoker.ExecuteAsync(
322                  workingDirectory: context.GetGitHubContext("workspace"),
323                  fileName: DockerPath,
324                  arguments: arg,
325                  environment: environment,
326                  requireExitCodeZero: false,
327                  outputEncoding: null,
328                  killProcessOnCancel: false,
329                  cancellationToken: cancellationToken);
330          }
331          private async Task<int> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options, string workingDirectory, CancellationToken cancellationToken = default(CancellationToken))
332          {
333              string arg = $"{command} {options}".Trim();
334              context.Command($"{DockerPath} {arg}");
335              var processInvoker = HostContext.CreateService<IProcessInvoker>();
336              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
337              {
338                  context.Output(message.Data);
339              };
340              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
341              {
342                  context.Output(message.Data);
343              };
344              if (!Constants.Runner.Platform.Equals(Constants.OSPlatform.Linux))
345              {
346                  throw new NotSupportedException("Container operations are only supported on Linux runners");
347              }
348              return await processInvoker.ExecuteAsync(
349                  workingDirectory: workingDirectory ?? context.GetGitHubContext("workspace"),
350                  fileName: DockerPath,
351                  arguments: arg,
352                  environment: null,
353                  requireExitCodeZero: false,
354                  outputEncoding: null,
355                  killProcessOnCancel: false,
356                  redirectStandardIn: null,
357                  cancellationToken: cancellationToken);
358          }
359          private async Task<List<string>> ExecuteDockerCommandAsync(IExecutionContext context, string command, string options)
360          {
361              string arg = $"{command} {options}".Trim();
362              context.Command($"{DockerPath} {arg}");
363              List<string> output = new();
364              var processInvoker = HostContext.CreateService<IProcessInvoker>();
365              processInvoker.OutputDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
366              {
367                  if (!string.IsNullOrEmpty(message.Data))
368                  {
369                      output.Add(message.Data);
370                      context.Output(message.Data);
371                  }
372              };
373              processInvoker.ErrorDataReceived += delegate (object sender, ProcessDataReceivedEventArgs message)
374              {
375                  if (!string.IsNullOrEmpty(message.Data))
376                  {
377                      context.Output(message.Data);
378                  }
379              };
380              await processInvoker.ExecuteAsync(
381                              workingDirectory: context.GetGitHubContext("workspace"),
382                              fileName: DockerPath,
383                              arguments: arg,
384                              environment: null,
385                              requireExitCodeZero: true,
386                              outputEncoding: null,
387                              cancellationToken: CancellationToken.None);
388              return output;
389          }
390      }
391  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-DockerCommandManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>152              dockerOptions.Add($"{container.ContainerEntryPointArgs}");
153              var optionsString = string.Join(" ", dockerOptions);
154              List<string> outputStrings = await ExecuteDockerCommandAsync(context, "create", optionsString);
</pre></code></div>
                <div class="column column_space"><pre><code>199              dockerOptions.Add($"{container.ContainerEntryPointArgs}");
200              var optionsString = string.Join(" ", dockerOptions);
201              return await ExecuteDockerCommandAsync(context, "run", optionsString, container.ContainerEnvironmentVariables, stdoutDataReceived, stderrDataReceived, context.CancellationToken);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    