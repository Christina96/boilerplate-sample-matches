
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-GitCheck.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.IO;
4  using System.Linq;
5  using System.Threading;
6  using System.Threading.Tasks;
7  using GitHub.Runner.Common;
8  using GitHub.Runner.Sdk;
9  namespace GitHub.Runner.Listener.Check
10  {
11      public sealed class GitCheck : RunnerService, ICheckExtension
12      {
13          private string _logFile = null;
14          private string _gitPath = null;
15          public int Order => 3;
16          public string CheckName => "Git Certificate/Proxy Validation";
17          public string CheckDescription => "Check if the Git CLI can access GitHub.com or GitHub Enterprise Server.";
18          public string CheckLog => _logFile;
<span onclick='openModal()' class='match'>19          public string HelpLink => "https:&bsol;&bsol;github.com/actions/runner/blob/main/docs/checks/git.md";
20          public Type ExtensionType => typeof(ICheckExtension);
21          public override void Initialize(IHostContext hostContext)
</span>22          {
23              base.Initialize(hostContext);
24              _logFile = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Diag), StringUtil.Format("{0}_{1:yyyyMMdd-HHmmss}-utc.log", nameof(GitCheck), DateTime.UtcNow));
25              _gitPath = WhichUtil.Which("git");
26          }
27          public async Task<bool> RunCheck(string url, string pat)
28          {
29              await File.AppendAllLinesAsync(_logFile, HostContext.WarnLog());
30              await File.AppendAllLinesAsync(_logFile, HostContext.CheckProxy());
31              if (string.IsNullOrEmpty(_gitPath))
32              {
33                  await File.AppendAllLinesAsync(_logFile, new[] { $"{DateTime.UtcNow.ToString("O")} Can't verify git with GitHub.com or GitHub Enterprise Server since git is not installed." });
34                  return false;
35              }
36              var checkGit = await CheckGit(url, pat);
37              var result = checkGit.Pass;
38              await File.AppendAllLinesAsync(_logFile, checkGit.Logs);
39              if (checkGit.SslError)
40              {
41                  await File.AppendAllLinesAsync(_logFile, new[] { $"{DateTime.UtcNow.ToString("O")} Try fix SSL error by providing extra CA certificate." });
42                  var downloadCert = await HostContext.DownloadExtraCA(url, pat);
43                  await File.AppendAllLinesAsync(_logFile, downloadCert.Logs);
44                  if (downloadCert.Pass)
45                  {
46                      var recheckGit = await CheckGit(url, pat, extraCA: true);
47                      await File.AppendAllLinesAsync(_logFile, recheckGit.Logs);
48                      if (recheckGit.Pass)
49                      {
50                          await File.AppendAllLinesAsync(_logFile, new[] { $"{DateTime.UtcNow.ToString("O")} Fixed SSL error by providing extra CA certs." });
51                      }
52                  }
53              }
54              return result;
55          }
56          private async Task<CheckResult> CheckGit(string url, string pat, bool extraCA = false)
57          {
58              var result = new CheckResult();
59              try
60              {
61                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ***************************************************************************************************************");
62                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****                                                                                                       ****");
63                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****     Validate server cert and proxy configuration with Git ");
64                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****                                                                                                       ****");
65                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ***************************************************************************************************************");
66                  var repoUrlBuilder = new UriBuilder(url);
67                  repoUrlBuilder.Path = "actions/checkout";
68                  repoUrlBuilder.UserName = "gh";
69                  repoUrlBuilder.Password = pat;
70                  var gitProxy = "";
71                  var proxy = HostContext.WebProxy.GetProxy(repoUrlBuilder.Uri);
72                  if (proxy != null)
73                  {
74                      result.Logs.Add($"{DateTime.UtcNow.ToString("O")} Runner is behind http proxy '{proxy.AbsoluteUri}'");
75                      if (HostContext.WebProxy.HttpProxyUsername != null ||
76                          HostContext.WebProxy.HttpsProxyUsername != null)
77                      {
78                          var proxyUrlWithCred = UrlUtil.GetCredentialEmbeddedUrl(
79                              proxy,
80                              HostContext.WebProxy.HttpProxyUsername ?? HostContext.WebProxy.HttpsProxyUsername,
81                              HostContext.WebProxy.HttpProxyPassword ?? HostContext.WebProxy.HttpsProxyPassword);
82                          gitProxy = $"-c http.proxy={proxyUrlWithCred}";
83                      }
84                      else
85                      {
86                          gitProxy = $"-c http.proxy={proxy.AbsoluteUri}";
87                      }
88                  }
89                  using (var processInvoker = HostContext.CreateService<IProcessInvoker>())
90                  {
91                      processInvoker.OutputDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
92                      {
93                          if (!string.IsNullOrEmpty(args.Data))
94                          {
95                              result.Logs.Add($"{DateTime.UtcNow.ToString("O")} {args.Data}");
96                          }
97                      });
98                      processInvoker.ErrorDataReceived += new EventHandler<ProcessDataReceivedEventArgs>((sender, args) =>
99                      {
100                          if (!string.IsNullOrEmpty(args.Data))
101                          {
102                              result.Logs.Add($"{DateTime.UtcNow.ToString("O")} {args.Data}");
103                          }
104                      });
105                      var gitArgs = $"{gitProxy} ls-remote --exit-code {repoUrlBuilder.Uri.AbsoluteUri} HEAD";
106                      result.Logs.Add($"{DateTime.UtcNow.ToString("O")} Run 'git {gitArgs}' ");
107                      var env = new Dictionary<string, string>
108                      {
109                          { "GIT_TRACE", "1" },
110                          { "GIT_CURL_VERBOSE", "1" }
111                      };
112                      if (extraCA)
113                      {
114                          env["GIT_SSL_CAINFO"] = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Root), "download_ca_cert.pem");
115                      }
116                      await processInvoker.ExecuteAsync(
117                          HostContext.GetDirectory(WellKnownDirectory.Root),
118                          _gitPath,
119                          gitArgs,
120                          env,
121                          true,
122                          CancellationToken.None);
123                  }
124                  result.Pass = true;
125              }
126              catch (Exception ex)
127              {
128                  result.Pass = false;
129                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ***************************************************************************************************************");
130                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****                                                                                                       ****");
131                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****     git ls-remote failed with error: {ex}");
132                  if (result.Logs.Any(x => x.Contains("SSL Certificate problem", StringComparison.OrdinalIgnoreCase)))
133                  {
134                      result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****     git ls-remote failed due to SSL cert issue.");
135                      result.SslError = true;
136                  }
137                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ****                                                                                                       ****");
138                  result.Logs.Add($"{DateTime.UtcNow.ToString("O")} ***************************************************************************************************************");
139              }
140              return result;
141          }
142      }
143  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-FileCommandManager.cs</h3>
            <pre><code>1  using GitHub.DistributedTask.WebApi;
2  using GitHub.Runner.Worker.Container;
3  using GitHub.Runner.Common;
4  using System;
5  using System.Collections.Generic;
6  using System.IO;
7  using System.Text;
8  namespace GitHub.Runner.Worker
9  {
10      [ServiceLocator(Default = typeof(FileCommandManager))]
11      public interface IFileCommandManager : IRunnerService
12      {
13          void InitializeFiles(IExecutionContext context, ContainerInfo container);
14          void ProcessFiles(IExecutionContext context, ContainerInfo container);
15      }
16      public sealed class FileCommandManager : RunnerService, IFileCommandManager
17      {
18          private const string _folderName = "_runner_file_commands";
19          private List<IFileCommandExtension> _commandExtensions;
20          private string _fileSuffix = String.Empty;
21          private string _fileCommandDirectory;
22          private Tracing _trace;
23          public override void Initialize(IHostContext hostContext)
24          {
25              base.Initialize(hostContext);
26              _trace = HostContext.GetTrace(nameof(FileCommandManager));
27              _fileCommandDirectory = Path.Combine(HostContext.GetDirectory(WellKnownDirectory.Temp), _folderName);
28              if (!Directory.Exists(_fileCommandDirectory))
29              {
30                  Directory.CreateDirectory(_fileCommandDirectory);
31              }
32              var extensionManager = hostContext.GetService<IExtensionManager>();
33              _commandExtensions = extensionManager.GetExtensions<IFileCommandExtension>() ?? new List<IFileCommandExtension>();
34          }
35          public void InitializeFiles(IExecutionContext context, ContainerInfo container)
36          {
37              var oldSuffix = _fileSuffix;
38              _fileSuffix = Guid.NewGuid().ToString();
39              foreach (var fileCommand in _commandExtensions)
40              {
41                  var oldPath = Path.Combine(_fileCommandDirectory, fileCommand.FilePrefix + oldSuffix);
42                  if (oldSuffix != String.Empty && File.Exists(oldPath))
43                  {
44                      TryDeleteFile(oldPath);
45                  }
46                  var newPath = Path.Combine(_fileCommandDirectory, fileCommand.FilePrefix + _fileSuffix);
47                  TryDeleteFile(newPath);
48                  File.Create(newPath).Dispose();
49                  var pathToSet = container != null ? container.TranslateToContainerPath(newPath) : newPath;
50                  context.SetGitHubContext(fileCommand.ContextName, pathToSet);
51              }
52          }
53          public void ProcessFiles(IExecutionContext context, ContainerInfo container)
54          {
55              foreach (var fileCommand in _commandExtensions)
56              {
57                  try
58                  {
59                      fileCommand.ProcessCommand(context, Path.Combine(_fileCommandDirectory, fileCommand.FilePrefix + _fileSuffix), container);
60                  }
61                  catch (Exception ex)
62                  {
63                      context.Error($"Unable to process file command '{fileCommand.ContextName}' successfully.");
64                      context.Error(ex);
65                      context.CommandResult = TaskResult.Failed;
66                  }
67              }
68          }
69          private bool TryDeleteFile(string path)
70          {
71              if (!File.Exists(path))
72              {
73                  return true;
74              }
75              try
76              {
77                  File.Delete(path);
78              }
79              catch (Exception e)
80              {
81                  _trace.Warning($"Unable to delete file {path} for reason: {e.ToString()}");
82                  return false;
83              }
84              return true;
85          }
86      }
87      public interface IFileCommandExtension : IExtension
88      {
89          string ContextName { get; }
90          string FilePrefix { get; }
91          void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container);
92      }
93      public sealed class AddPathFileCommand : RunnerService, IFileCommandExtension
94      {
95          public string ContextName => "path";
96          public string FilePrefix => "add_path_";
97          public Type ExtensionType => typeof(IFileCommandExtension);
98          public void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container)
99          {
100              if (File.Exists(filePath))
101              {
102                  var lines = File.ReadAllLines(filePath, Encoding.UTF8);
103                  foreach (var line in lines)
104                  {
105                      if (line == string.Empty)
106                      {
107                          continue;
108                      }
109                      context.Global.PrependPath.RemoveAll(x => string.Equals(x, line, StringComparison.CurrentCulture));
110                      context.Global.PrependPath.Add(line);
111                  }
112              }
113          }
114      }
115      public sealed class SetEnvFileCommand : RunnerService, IFileCommandExtension
116      {
117          public string ContextName => "env";
118          public string FilePrefix => "set_env_";
119          public Type ExtensionType => typeof(IFileCommandExtension);
120          public void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container)
121          {
122              var pairs = new EnvFileKeyValuePairs(context, filePath);
123              foreach (var pair in pairs)
124              {
125                  SetEnvironmentVariable(context, pair.Key, pair.Value);
126              }
127          }
128          private static void SetEnvironmentVariable(
129              IExecutionContext context,
130              string name,
131              string value)
132          {
133              context.Global.EnvironmentVariables[name] = value;
134              context.SetEnvContext(name, value);
135              context.Debug($"{name}='{value}'");
136          }
137      }
138      public sealed class CreateStepSummaryCommand : RunnerService, IFileCommandExtension
139      {
140          public const int AttachmentSizeLimit = 1024 * 1024;
141          public string ContextName => "step_summary";
142          public string FilePrefix => "step_summary_";
143          public Type ExtensionType => typeof(IFileCommandExtension);
144          public void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container)
145          {
146              if (String.IsNullOrEmpty(filePath) || !File.Exists(filePath))
147              {
148                  Trace.Info($"Step Summary file ({filePath}) does not exist; skipping attachment upload");
149                  return;
150              }
151              try
152              {
153                  var fileSize = new FileInfo(filePath).Length;
154                  if (fileSize == 0)
155                  {
156                      Trace.Info($"Step Summary file ({filePath}) is empty; skipping attachment upload");
157                      return;
158                  }
159                  if (fileSize > AttachmentSizeLimit)
160                  {
161                      context.Error(String.Format(Constants.Runner.UnsupportedSummarySize, AttachmentSizeLimit / 1024, fileSize / 1024));
162                      Trace.Info($"Step Summary file ({filePath}) is too large ({fileSize} bytes); skipping attachment upload");
163                      return;
164                  }
165                  Trace.Verbose($"Step Summary file exists: {filePath} and has a file size of {fileSize} bytes");
166                  var scrubbedFilePath = filePath + "-scrubbed";
167                  using (var streamReader = new StreamReader(filePath))
168                  using (var streamWriter = new StreamWriter(scrubbedFilePath))
169                  {
170                      string line;
171                      while ((line = streamReader.ReadLine()) != null)
172                      {
173                          var maskedLine = HostContext.SecretMasker.MaskSecrets(line);
174                          streamWriter.WriteLine(maskedLine);
175                      }
176                  }
177                  var attachmentName = !context.IsEmbedded
178                      ? context.Id.ToString()
179                      : context.EmbeddedId.ToString();
180                  Trace.Info($"Queueing file ({filePath}) for attachment upload ({attachmentName})");
181                  context.Root.QueueAttachFile(ChecksAttachmentType.StepSummary, attachmentName, scrubbedFilePath);
182                  context.Global.Variables.TryGetValue("system.github.results_endpoint", out string resultsReceiverEndpoint);
183                  if (resultsReceiverEndpoint != null)
184                  {
185                      Trace.Info($"Queueing results file ({filePath}) for attachment upload ({attachmentName})");
186                      var stepId = context.Id;
187                      context.Root.QueueSummaryFile(attachmentName, scrubbedFilePath, stepId);
188                  }
189              }
190              catch (Exception e)
191              {
192                  Trace.Error($"Error while processing file ({filePath}): {e}");
193                  context.Error($"Failed to create step summary using 'GITHUB_STEP_SUMMARY': {e.Message}");
194              }
195          }
196      }
197      public sealed class SaveStateFileCommand : RunnerService, IFileCommandExtension
198      {
199          public string ContextName => "state";
200          public string FilePrefix => "save_state_";
201          public Type ExtensionType => typeof(IFileCommandExtension);
202          public void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container)
203          {
204              var pairs = new EnvFileKeyValuePairs(context, filePath);
205              foreach (var pair in pairs)
206              {
207                  if (context.IsEmbedded)
208                  {
209                      var id = context.EmbeddedId;
210                      if (!context.Root.EmbeddedIntraActionState.ContainsKey(id))
211                      {
212                          context.Root.EmbeddedIntraActionState[id] = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
213                      }
214                      context.Root.EmbeddedIntraActionState[id][pair.Key] = pair.Value;
215                  }
216                  else
217                  {
218                      context.IntraActionState[pair.Key] = pair.Value;
219                  }
220                  context.Debug($"Save intra-action state {pair.Key} = {pair.Value}");
221              }
222          }
223      }
224      public sealed class SetOutputFileCommand : RunnerService, IFileCommandExtension
225      {
226          public string ContextName => "output";
<span onclick='openModal()' class='match'>227          public string FilePrefix => "set_output_";
228          public Type ExtensionType => typeof(IFileCommandExtension);
229          public void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container)
</span>230          {
231              var pairs = new EnvFileKeyValuePairs(context, filePath);
232              foreach (var pair in pairs)
233              {
234                  context.SetOutput(pair.Key, pair.Value, out var reference);
235                  context.Debug($"Set output {pair.Key} = {pair.Value}");
236              }
237          }
238      }
239      public sealed class EnvFileKeyValuePairs : IEnumerable<KeyValuePair<string, string>>
240      {
241          private IExecutionContext _context;
242          private string _filePath;
243          public EnvFileKeyValuePairs(IExecutionContext context, string filePath)
244          {
245              _context = context;
246              _filePath = filePath;
247          }
248          public IEnumerator<KeyValuePair<string, string>> GetEnumerator()
249          {
250              var text = string.Empty;
251              try
252              {
253                  text = File.ReadAllText(_filePath) ?? string.Empty;
254              }
255              catch (DirectoryNotFoundException)
256              {
257                  _context.Debug($"File does not exist '{_filePath}'");
258                  yield break;
259              }
260              catch (FileNotFoundException)
261              {
262                  _context.Debug($"File does not exist '{_filePath}'");
263                  yield break;
264              }
265              var index = 0;
266              var line = ReadLine(text, ref index);
267              while (line != null)
268              {
269                  if (!string.IsNullOrEmpty(line))
270                  {
271                      var key = string.Empty;
272                      var output = string.Empty;
273                      var equalsIndex = line.IndexOf("=", StringComparison.Ordinal);
274                      var heredocIndex = line.IndexOf("<<", StringComparison.Ordinal);
275                      if (equalsIndex >= 0 && (heredocIndex < 0 || equalsIndex < heredocIndex))
276                      {
277                          var split = line.Split(new[] { '=' }, 2, StringSplitOptions.None);
278                          if (string.IsNullOrEmpty(line))
279                          {
280                              throw new Exception($"Invalid format '{line}'. Name must not be empty");
281                          }
282                          key = split[0];
283                          output = split[1];
284                      }
285                      else if (heredocIndex >= 0 && (equalsIndex < 0 || heredocIndex < equalsIndex))
286                      {
287                          var split = line.Split(new[] { "<<" }, 2, StringSplitOptions.None);
288                          if (string.IsNullOrEmpty(split[0]) || string.IsNullOrEmpty(split[1]))
289                          {
290                              throw new Exception($"Invalid format '{line}'. Name must not be empty and delimiter must not be empty");
291                          }
292                          key = split[0];
293                          var delimiter = split[1];
294                          var startIndex = index; 
295                          var endIndex = index;   
296                          var tempLine = ReadLine(text, ref index, out var newline);
297                          while (!string.Equals(tempLine, delimiter, StringComparison.Ordinal))
298                          {
299                              if (tempLine == null)
300                              {
301                                  throw new Exception($"Invalid value. Matching delimiter not found '{delimiter}'");
302                              }
303                              if (newline == null)
304                              {
305                                  throw new Exception($"Invalid value. EOF marker missing new line.");
306                              }
307                              endIndex = index - newline.Length;
308                              tempLine = ReadLine(text, ref index, out newline);
309                          }
310                          output = endIndex > startIndex ? text.Substring(startIndex, endIndex - startIndex) : string.Empty;
311                      }
312                      else
313                      {
314                          throw new Exception($"Invalid format '{line}'");
315                      }
316                      yield return new KeyValuePair<string, string>(key, output);
317                  }
318                  line = ReadLine(text, ref index);
319              }
320          }
321          System.Collections.IEnumerator
322              System.Collections.IEnumerable.GetEnumerator()
323          {
324              return GetEnumerator();
325          }
326          private static string ReadLine(
327                  string text,
328                  ref int index)
329          {
330              return ReadLine(text, ref index, out _);
331          }
332          private static string ReadLine(
333                  string text,
334                  ref int index,
335                  out string newline)
336          {
337              if (index >= text.Length)
338              {
339                  newline = null;
340                  return null;
341              }
342              var originalIndex = index;
343              var lfIndex = text.IndexOf("\n", index, StringComparison.Ordinal);
344              if (lfIndex < 0)
345              {
346                  index = text.Length;
347                  newline = null;
348                  return text.Substring(originalIndex);
349              }
350  #if OS_WINDOWS
351              var crLFIndex = text.IndexOf("\r\n", index, StringComparison.Ordinal);
352              if (crLFIndex >= 0 && crLFIndex < lfIndex)
353              {
354                  index = crLFIndex + 2; 
355                  newline = "\r\n";
356                  return text.Substring(originalIndex, crLFIndex - originalIndex);
357              }
358  #endif
359              index = lfIndex + 1; 
360              newline = "\n";
361              return text.Substring(originalIndex, lfIndex - originalIndex);
362          }
363      }
364  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-GitCheck.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-FileCommandManager.cs</div>
                </div>
                <div class="column column_space"><pre><code>19          public string HelpLink => "https:&bsol;&bsol;github.com/actions/runner/blob/main/docs/checks/git.md";
20          public Type ExtensionType => typeof(ICheckExtension);
21          public override void Initialize(IHostContext hostContext)
</pre></code></div>
                <div class="column column_space"><pre><code>227          public string FilePrefix => "set_output_";
228          public Type ExtensionType => typeof(IFileCommandExtension);
229          public void ProcessCommand(IExecutionContext context, string filePath, ContainerInfo container)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    