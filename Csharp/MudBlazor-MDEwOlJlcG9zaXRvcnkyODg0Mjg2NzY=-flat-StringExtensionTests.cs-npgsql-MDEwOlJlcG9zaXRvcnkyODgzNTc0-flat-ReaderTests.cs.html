
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.6447908121411%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-StringExtensionTests.cs</h3>
            <pre><code>1  using FluentAssertions;
2  using MudBlazor.Docs.Extensions;
3  using NUnit.Framework;
4  namespace MudBlazor.UnitTests.Utilities
5  {
6      [TestFixture]
7      public class StringExtensionsTests
8      {
9          [Test]
10          public void ToKebabCaseTest()
11          {
<span onclick='openModal()' class='match'>12              default(string).ToKebabCase().Should().Be(null);
13              "".ToKebabCase().Should().Be("");
14              "I".ToKebabCase().Should().Be("i");
15              "IO".ToKebabCase().Should().Be("io");
16              "FileIO".ToKebabCase().Should().Be("file-io");
</span>17              "SignalR".ToKebabCase().Should().Be("signal-r");
18              "IOStream".ToKebabCase().Should().Be("io-stream");
19              "COMObject".ToKebabCase().Should().Be("com-object");
20              "WebAPI".ToKebabCase().Should().Be("web-api");
21              "awesome".ToKebabCase().Should().Be("awesome");
22              "kebab-case".ToKebabCase().Should().Be("kebab-case");
23          }
24          [Test]
25          public void ToPascalCaseTest()
26          {
27              default(string).ToPascalCase().Should().Be(null);
28              "".ToPascalCase().Should().Be("");
29              "i".ToPascalCase().Should().Be("I");
30              "I".ToPascalCase().Should().Be("I");
31              "io".ToPascalCase().Should().Be("Io");
32              "IO".ToPascalCase().Should().Be("IO");
33              "file-io".ToPascalCase().Should().Be("FileIo");
34              "FileIO".ToPascalCase().Should().Be("FileIO");
35              "signal-r".ToPascalCase().Should().Be("SignalR");
36              "SignalR".ToPascalCase().Should().Be("SignalR");
37              "COMObject".ToPascalCase().Should().Be("COMObject");
38              "WebAPI".ToPascalCase().Should().Be("WebAPI");
39              "awesome".ToPascalCase().Should().Be("Awesome");
40              "kebab-case".ToPascalCase().Should().Be("KebabCase");
41              "snake_case".ToPascalCase().Should().Be("SnakeCase");
42          }
43      }
44  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ReaderTests.cs</h3>
            <pre><code>1  using System;
2  using System.Buffers.Binary;
3  using System.Collections;
4  using System.Data;
5  using System.IO;
6  using System.Linq;
7  using System.Runtime.InteropServices;
8  using System.Text;
9  using System.Threading;
10  using System.Threading.Tasks;
11  using Npgsql.BackendMessages;
12  using Npgsql.Internal;
13  using Npgsql.Internal.TypeHandling;
14  using Npgsql.Internal.TypeMapping;
15  using Npgsql.PostgresTypes;
16  using Npgsql.Tests.Support;
17  using Npgsql.TypeMapping;
18  using Npgsql.Util;
19  using NpgsqlTypes;
20  using NUnit.Framework;
21  using static Npgsql.Tests.TestUtil;
22  namespace Npgsql.Tests;
23  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.Default)]
24  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.Default)]
25  [TestFixture(MultiplexingMode.NonMultiplexing, CommandBehavior.SequentialAccess)]
26  [TestFixture(MultiplexingMode.Multiplexing, CommandBehavior.SequentialAccess)]
27  public class ReaderTests : MultiplexingTestBase
28  {
29      [Test]
30      public async Task Seek_columns()
31      {
32          using var conn = await OpenConnectionAsync();
33          using var cmd = new NpgsqlCommand("SELECT 1,2,3", conn);
34          using var reader = await cmd.ExecuteReaderAsync(Behavior);
35          Assert.That(reader.Read(), Is.True);
36          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
37          if (IsSequential)
38              Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidOperationException>());
39          else
40              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
41          Assert.That(reader.GetInt32(1), Is.EqualTo(2));
42          if (IsSequential)
43              Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidOperationException>());
44          else
45              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
46      }
47      [Test]
48      public async Task No_resultset()
49      {
50          using var conn = await OpenConnectionAsync();
51          var table = await CreateTempTable(conn, "id INT");
52          using (var cmd = new NpgsqlCommand($"INSERT INTO {table} VALUES (8)", conn))
<span onclick='openModal()' class='match'>53          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
54          {
55              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
56              Assert.That(reader.Read(), Is.False);
57              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
58              Assert.That(reader.FieldCount, Is.EqualTo(0));
59              Assert.That(reader.NextResult(), Is.False);
60              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
</span>61          }
62          using (var cmd = new NpgsqlCommand($"SELECT 1; INSERT INTO {table} VALUES (8)", conn))
63          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
64          {
65              await reader.NextResultAsync();
66              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
67              Assert.That(reader.Read(), Is.False);
68              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
69              Assert.That(reader.FieldCount, Is.EqualTo(0));
70          }
71      }
72      [Test]
73      public async Task Empty_resultset()
74      {
75          using var conn = await OpenConnectionAsync();
76          using var cmd = new NpgsqlCommand("SELECT 1 AS foo WHERE FALSE", conn);
77          using var reader = await cmd.ExecuteReaderAsync(Behavior);
78          Assert.That(reader.Read(), Is.False);
79          Assert.That(reader.FieldCount, Is.EqualTo(1));
80          Assert.That(reader.GetOrdinal("foo"), Is.EqualTo(0));
81          Assert.That(() => reader[0], Throws.Exception.TypeOf<InvalidOperationException>());
82      }
83      [Test]
84      public async Task FieldCount()
85      {
86          using var conn = await OpenConnectionAsync();
87          var table = await CreateTempTable(conn, "int INT");
88          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2,3", conn);
89          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
90          {
91              Assert.That(reader.FieldCount, Is.EqualTo(1));
92              Assert.That(reader.Read(), Is.True);
93              Assert.That(reader.FieldCount, Is.EqualTo(1));
94              Assert.That(reader.Read(), Is.False);
95              Assert.That(reader.FieldCount, Is.EqualTo(1));
96              Assert.That(reader.NextResult(), Is.True);
97              Assert.That(reader.FieldCount, Is.EqualTo(2));
98              Assert.That(reader.NextResult(), Is.False);
99              Assert.That(reader.FieldCount, Is.EqualTo(0));
100          }
101          cmd.CommandText = $"INSERT INTO {table} (int) VALUES (1)";
102          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
103          {
104              Assert.That(() => reader.FieldCount, Is.EqualTo(0));
105          }
106      }
107      [Test]
108      public async Task RecordsAffected()
109      {
110          using var conn = await OpenConnectionAsync();
111          var table = await CreateTempTable(conn, "int INT");
112          var sb = new StringBuilder();
113          for (var i = 0; i < 10; i++)
114              sb.Append($"INSERT INTO {table} (int) VALUES ({i});");
115          sb.Append("SELECT 1;"); 
116          for (var i = 10; i < 15; i++)
117              sb.Append($"INSERT INTO {table} (int) VALUES ({i});");
118          var cmd = new NpgsqlCommand(sb.ToString(), conn);
119          var reader = await cmd.ExecuteReaderAsync(Behavior);
120          reader.Close();
121          Assert.That(reader.RecordsAffected, Is.EqualTo(15));
122          cmd = new NpgsqlCommand($"SELECT * FROM {table}", conn);
123          reader = await cmd.ExecuteReaderAsync(Behavior);
124          reader.Close();
125          Assert.That(reader.RecordsAffected, Is.EqualTo(-1));
126          cmd = new NpgsqlCommand($"UPDATE {table} SET int=int+1 WHERE int > 10", conn);
127          reader = await cmd.ExecuteReaderAsync(Behavior);
128          reader.Close();
129          Assert.That(reader.RecordsAffected, Is.EqualTo(4));
130          cmd = new NpgsqlCommand($"UPDATE {table} SET int=8 WHERE int=666", conn);
131          reader = await cmd.ExecuteReaderAsync(Behavior);
132          reader.Close();
133          Assert.That(reader.RecordsAffected, Is.EqualTo(0));
134          cmd = new NpgsqlCommand($"DELETE FROM {table} WHERE int > 10", conn);
135          reader = await cmd.ExecuteReaderAsync(Behavior);
136          reader.Close();
137          Assert.That(reader.RecordsAffected, Is.EqualTo(4));
138          if (conn.PostgreSqlVersion.IsGreaterOrEqual(15))
139          {
140              cmd = new NpgsqlCommand($"MERGE INTO {table} S USING (SELECT 2 as int) T ON T.int = S.int WHEN MATCHED THEN UPDATE SET int = S.int", conn);
141              reader = await cmd.ExecuteReaderAsync(Behavior);
142              reader.Close();
143              Assert.That(reader.RecordsAffected, Is.EqualTo(1));
144          }
145      }
146  #pragma warning disable CS0618
147      [Test]
148      public async Task StatementOID_legacy_batching()
149      {
150          using var conn = await OpenConnectionAsync();
151          MaximumPgVersionExclusive(conn, "12.0",
152              "Support for 'CREATE TABLE ... WITH OIDS' has been removed in 12.0. See https:&bsol;&bsol;www.postgresql.org/docs/12/release-12.html#id-1.11.6.5.4");
153          var table = await GetTempTableName(conn);
154          var query = $@"
155  CREATE TABLE {table} (name TEXT) WITH OIDS;
156  INSERT INTO {table} (name) VALUES ('a');
157  UPDATE {table} SET name='b' WHERE name='doesnt_exist';";
158          using (var cmd = new NpgsqlCommand(query,conn))
159          {
160              using var reader = await cmd.ExecuteReaderAsync(Behavior);
161              Assert.That(reader.Statements[0].OID, Is.EqualTo(0));
162              Assert.That(reader.Statements[1].OID, Is.Not.EqualTo(0));
163              Assert.That(reader.Statements[0].OID, Is.EqualTo(0));
164          }
165          using (var cmd = new NpgsqlCommand($"SELECT name FROM {table}; DELETE FROM {table}", conn))
166          {
167              using var reader = await cmd.ExecuteReaderAsync(Behavior);
168              await reader.NextResultAsync(); 
169              Assert.That(reader.Statements[0].OID, Is.EqualTo(0));
170              Assert.That(reader.Statements[1].OID, Is.EqualTo(0));
171          }
172      }
173  #pragma warning restore CS0618
174      [Test]
175      public async Task Get_string_with_parameter()
176      {
177          using var conn = await OpenConnectionAsync();
178          var table = await CreateTempTable(conn, "name TEXT");
179          const string text = "Random text";
180          await conn.ExecuteNonQueryAsync($@"INSERT INTO {table} (name) VALUES ('{text}')");
181          var command = new NpgsqlCommand($"SELECT name FROM {table} WHERE name = :value;", conn);
182          var param = new NpgsqlParameter
183          {
184              ParameterName = "value",
185              DbType = DbType.String,
186              Size = text.Length,
187              Value = text
188          };
189          command.Parameters.Add(param);
190          using var dr = await command.ExecuteReaderAsync(Behavior);
191          dr.Read();
192          var result = dr.GetString(0);
193          Assert.AreEqual(text, result);
194      }
195      [Test]
196      public async Task Get_string_with_quote_with_parameter()
197      {
198          using var conn = await OpenConnectionAsync();
199          var table = await GetTempTableName(conn);
200          await conn.ExecuteNonQueryAsync($@"
201  CREATE TABLE {table} (name TEXT);
202  INSERT INTO {table} (name) VALUES ('Text with '' single quote');");
203          const string test = "Text with ' single quote";
204          var command = new NpgsqlCommand($"SELECT name FROM {table} WHERE name = :value;", conn);
205          var param = new NpgsqlParameter();
206          param.ParameterName = "value";
207          param.DbType = DbType.String;
208          param.Size = test.Length;
209          param.Value = test;
210          command.Parameters.Add(param);
211          using var dr = await command.ExecuteReaderAsync(Behavior);
212          dr.Read();
213          var result = dr.GetString(0);
214          Assert.AreEqual(test, result);
215      }
216      [Test]
217      public async Task Get_value_by_name()
218      {
219          using var conn = await OpenConnectionAsync();
220          using var command = new NpgsqlCommand(@"SELECT 'Random text' AS real_column", conn);
221          using var dr = await command.ExecuteReaderAsync(Behavior);
222          dr.Read();
223          Assert.That(dr["real_column"], Is.EqualTo("Random text"));
224          Assert.That(() => dr["non_existing"], Throws.Exception.TypeOf<IndexOutOfRangeException>());
225      }
226      [Test]
227      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/794")]
228      public async Task GetFieldType()
229      {
230          using var conn = await OpenConnectionAsync();
231          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
232          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
233          {
234              reader.Read();
235              Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
236          }
237          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
238          {
239              cmd.AllResultTypesAreUnknown = true;
240              using (var reader = await cmd.ExecuteReaderAsync(Behavior))
241              {
242                  reader.Read();
243                  Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(string)));
244              }
245          }
246      }
247      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1096")]
248      public async Task GetFieldType_SchemaOnly()
249      {
250          await using var conn = await OpenConnectionAsync();
251          await using var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn);
252          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
253          reader.Read();
254          Assert.That(reader.GetFieldType(0), Is.SameAs(typeof(int)));
255      }
256      [Test]
257      public async Task GetPostgresType()
258      {
259          if (IsMultiplexing)
260              Assert.Ignore("Multiplexing: Fails");
261          using var conn = await OpenConnectionAsync();
262          PostgresType intType;
263          using (var cmd = new NpgsqlCommand(@"SELECT 1::INTEGER AS some_column", conn))
264          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
265          {
266              reader.Read();
267              intType = (PostgresBaseType)reader.GetPostgresType(0);
268              Assert.That(intType.Namespace, Is.EqualTo("pg_catalog"));
269              Assert.That(intType.Name, Is.EqualTo("integer"));
270              Assert.That(intType.FullName, Is.EqualTo("pg_catalog.integer"));
271              Assert.That(intType.DisplayName, Is.EqualTo("integer"));
272              Assert.That(intType.InternalName, Is.EqualTo("int4"));
273          }
274          using (var cmd = new NpgsqlCommand(@"SELECT '{1}'::INTEGER[] AS some_column", conn))
275          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
276          {
277              reader.Read();
278              var intArrayType = (PostgresArrayType)reader.GetPostgresType(0);
279              Assert.That(intArrayType.Name, Is.EqualTo("integer[]"));
280              Assert.That(intArrayType.Element, Is.SameAs(intType));
281              Assert.That(intArrayType.DisplayName, Is.EqualTo("integer[]"));
282              Assert.That(intArrayType.InternalName, Is.EqualTo("_int4"));
283              Assert.That(intType.Array, Is.SameAs(intArrayType));
284          }
285      }
286      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/787")]
287      [TestCase("integer")]
288      [TestCase("real")]
289      [TestCase("integer[]")]
290      [TestCase("character varying(10)")]
291      [TestCase("character varying")]
292      [TestCase("character varying(10)[]")]
293      [TestCase("character(10)")]
294      [TestCase("character")]
295      [TestCase("character(1)", "character")]
296      [TestCase("numeric(1000, 2)")]
297      [TestCase("numeric(1000)")]
298      [TestCase("numeric")]
299      [TestCase("timestamp without time zone")]
300      [TestCase("timestamp(2) without time zone")]
301      [TestCase("timestamp(2) with time zone")]
302      [TestCase("time without time zone")]
303      [TestCase("time(2) without time zone")]
304      [TestCase("time(2) with time zone")]
305      [TestCase("interval")]
306      [TestCase("interval(2)")]
307      [TestCase("bit", "bit(1)")]
308      [TestCase("bit(3)")]
309      [TestCase("bit varying")]
310      [TestCase("bit varying(3)")]
311      public async Task GetDataTypeName(string typeName, string? normalizedName = null)
312      {
313          if (normalizedName == null)
314              normalizedName = typeName;
315          using var conn = await OpenConnectionAsync();
316          using var cmd = new NpgsqlCommand($"SELECT NULL::{typeName} AS some_column", conn);
317          using var reader = await cmd.ExecuteReaderAsync(Behavior);
318          reader.Read();
319          Assert.That(reader.GetDataTypeName(0), Is.EqualTo(normalizedName));
320      }
321      [Test]
322      public async Task GetDataTypeName_enum()
323      {
324          await using var dataSource = CreateDataSource(csb => csb.MaxPoolSize = 1);
325          await using var conn = await dataSource.OpenConnectionAsync();
326          var typeName = await GetTempTypeName(conn);
327          await conn.ExecuteNonQueryAsync($"CREATE TYPE {typeName} AS ENUM ('one')");
328          await Task.Yield(); 
329          conn.ReloadTypes();
330          await using var cmd = new NpgsqlCommand($"SELECT 'one'::{typeName}", conn);
331          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
332          await reader.ReadAsync();
333          Assert.That(reader.GetDataTypeName(0), Is.EqualTo($"public.{typeName}"));
334      }
335      [Test]
336      public async Task GetDataTypeName_domain()
337      {
338          await using var dataSource = CreateDataSource(csb => csb.MaxPoolSize = 1);
339          await using var conn = await dataSource.OpenConnectionAsync();
340          var typeName = await GetTempTypeName(conn);
341          await conn.ExecuteNonQueryAsync($"CREATE DOMAIN {typeName} AS VARCHAR(10)");
342          await Task.Yield(); 
343          conn.ReloadTypes();
344          await using var cmd = new NpgsqlCommand($"SELECT 'one'::{typeName}", conn);
345          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
346          await reader.ReadAsync();
347          Assert.That(reader.GetDataTypeName(0), Is.EqualTo("character varying(10)"));
348      }
349      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/794")]
350      public async Task GetDataTypeNameTypes_unknown()
351      {
352          using var conn = await OpenConnectionAsync();
353          using var cmd = new NpgsqlCommand(@"SELECT 1::INTEGER AS some_column", conn);
354          cmd.AllResultTypesAreUnknown = true;
355          using var reader = await cmd.ExecuteReaderAsync(Behavior);
356          reader.Read();
357          Assert.That(reader.GetDataTypeName(0), Is.EqualTo("integer"));
358      }
359      [Test]
360      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/791")]
361      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/794")]
362      public async Task GetDataTypeOID()
363      {
364          using var conn = await OpenConnectionAsync();
365          var int4OID = await conn.ExecuteScalarAsync("SELECT oid FROM pg_type WHERE typname = 'int4'");
366          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
367          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
368          {
369              reader.Read();
370              Assert.That(reader.GetDataTypeOID(0), Is.EqualTo(int4OID));
371          }
372          using (var cmd = new NpgsqlCommand(@"SELECT 1::INT4 AS some_column", conn))
373          {
374              cmd.AllResultTypesAreUnknown = true;
375              using (var reader = await cmd.ExecuteReaderAsync(Behavior))
376              {
377                  reader.Read();
378                  Assert.That(reader.GetDataTypeOID(0), Is.EqualTo(int4OID));
379              }
380          }
381      }
382      [Test]
383      public async Task GetName()
384      {
385          using var conn = await OpenConnectionAsync();
386          using var command = new NpgsqlCommand(@"SELECT 1 AS some_column", conn);
387          using var dr = await command.ExecuteReaderAsync(Behavior);
388          dr.Read();
389          Assert.That(dr.GetName(0), Is.EqualTo("some_column"));
390      }
391      [Test]
392      public async Task GetFieldValue_as_object()
393      {
394          using var conn = await OpenConnectionAsync();
395          using var cmd = new NpgsqlCommand("SELECT 'foo'::TEXT", conn);
396          using var reader = await cmd.ExecuteReaderAsync(Behavior);
397          reader.Read();
398          Assert.That(reader.GetFieldValue<object>(0), Is.EqualTo("foo"));
399      }
400      [Test]
401      public async Task GetValues()
402      {
403          using var conn = await OpenConnectionAsync();
404          using var command = new NpgsqlCommand(@"SELECT 'hello', 1, '2014-01-01'::DATE", conn);
405          using (var dr = await command.ExecuteReaderAsync(Behavior))
406          {
407              dr.Read();
408              var values = new object[4];
409              Assert.That(dr.GetValues(values), Is.EqualTo(3));
410              Assert.That(values, Is.EqualTo(new object?[] { "hello", 1, new DateTime(2014, 1, 1), null }));
411          }
412          using (var dr = await command.ExecuteReaderAsync(Behavior))
413          {
414              dr.Read();
415              var values = new object[2];
416              Assert.That(dr.GetValues(values), Is.EqualTo(2));
417              Assert.That(values, Is.EqualTo(new object[] { "hello", 1 }));
418          }
419      }
420      [Test]
421      public async Task ExecuteReader_getting_empty_resultset_with_output_parameter()
422      {
423          using var conn = await OpenConnectionAsync();
424          var table = await CreateTempTable(conn, "name TEXT");
425          var command = new NpgsqlCommand($"SELECT * FROM {table} WHERE name = NULL;", conn);
426          var param = new NpgsqlParameter("some_param", NpgsqlDbType.Varchar);
427          param.Direction = ParameterDirection.Output;
428          command.Parameters.Add(param);
429          using var dr = await command.ExecuteReaderAsync(Behavior);
430          Assert.IsFalse(dr.NextResult());
431      }
432      [Test]
433      public async Task Get_value_from_empty_resultset()
434      {
435          using var conn = await OpenConnectionAsync();
436          var table = await CreateTempTable(conn, "name TEXT");
437          using var command = new NpgsqlCommand($"SELECT * FROM {table} WHERE name = :value;", conn);
438          const string test = "Text single quote";
439          var param = new NpgsqlParameter();
440          param.ParameterName = "value";
441          param.DbType = DbType.String;
442          param.Size = test.Length;
443          param.Value = test;
444          command.Parameters.Add(param);
445          using var dr = await command.ExecuteReaderAsync(Behavior);
446          dr.Read();
447          Assert.That(() => Console.WriteLine(dr.IsDBNull(1)),
448              Throws.Exception.TypeOf<InvalidOperationException>());
449      }
450      [Test]
451      public async Task Read_past_reader_end()
452      {
453          using var conn = await OpenConnectionAsync();
454          var command = new NpgsqlCommand("SELECT 1", conn);
455          using var dr = await command.ExecuteReaderAsync(Behavior);
456          while (dr.Read()) {}
457          Assert.That(() => dr[0], Throws.Exception.TypeOf<InvalidOperationException>());
458      }
459      [Test]
460      public async Task Reader_dispose_state_does_not_leak()
461      {
462          if (IsMultiplexing || Behavior != CommandBehavior.Default)
463              return;
464          var startReaderClosedTcs = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);
465          var continueReaderClosedTcs = new TaskCompletionSource<object>(TaskCreationOptions.RunContinuationsAsynchronously);
466          await using var dataSource = CreateDataSource();
467          await using var conn1 = await dataSource.OpenConnectionAsync();
468          var connID = conn1.Connector!.Id;
469          var readerCloseTask = Task.Run(async () =>
470          {
471              using var cmd = conn1.CreateCommand();
472              cmd.CommandText = "SELECT 1";
473              await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.CloseConnection);
474              reader.ReaderClosed += (s, e) =>
475              {
476                  startReaderClosedTcs.SetResult(new());
477                  continueReaderClosedTcs.Task.GetAwaiter().GetResult();
478              };
479          });
480          await startReaderClosedTcs.Task;
481          await using var conn2 = await dataSource.OpenConnectionAsync();
482          Assert.That(conn2.Connector!.Id, Is.EqualTo(connID));
483          using var cmd = conn2.CreateCommand();
484          cmd.CommandText = "SELECT 1";
485          await using var reader = await cmd.ExecuteReaderAsync();
486          Assert.That(reader.State, Is.EqualTo(ReaderState.BeforeResult));
487          continueReaderClosedTcs.SetResult(new());
488          await readerCloseTask;
489          Assert.That(reader.State, Is.EqualTo(ReaderState.BeforeResult));
490      }
491      [Test]
492      public async Task SingleResult()
493      {
494          await using var conn = await OpenConnectionAsync();
495          await using var command = new NpgsqlCommand(@"SELECT 1; SELECT 2", conn);
496          var reader = await command.ExecuteReaderAsync(CommandBehavior.SingleResult | Behavior);
497          Assert.That(reader.Read(), Is.True);
498          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
499          Assert.That(reader.NextResult(), Is.False);
500      }
501      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/400")]
502      public async Task Exception_thrown_from_ExecuteReaderAsync([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
503      {
504          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
505              return;
506          using var conn = await OpenConnectionAsync();
507          var function = await GetTempFunctionName(conn);
508          await conn.ExecuteNonQueryAsync($@"
509  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
510     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
511  LANGUAGE 'plpgsql';
512                  ");
513          using var cmd = new NpgsqlCommand($"SELECT {function}()", conn);
514          if (prepare == PrepareOrNot.Prepared)
515              cmd.Prepare();
516          Assert.That(async () => await cmd.ExecuteReaderAsync(Behavior), Throws.Exception.TypeOf<PostgresException>());
517      }
518      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1032")]
519      public async Task Exception_thrown_from_NextResult([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
520      {
521          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
522              return;
523          using var conn = await OpenConnectionAsync();
524          var function = await GetTempFunctionName(conn);
525          await conn.ExecuteNonQueryAsync($@"
526  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
527     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
528  LANGUAGE 'plpgsql';
529                  ");
530          using var cmd = new NpgsqlCommand($"SELECT 1; SELECT {function}()", conn);
531          if (prepare == PrepareOrNot.Prepared)
532              cmd.Prepare();
533          using var reader = await cmd.ExecuteReaderAsync(Behavior);
534          Assert.That(() => reader.NextResult(), Throws.Exception.TypeOf<PostgresException>());
535      }
536      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
537      public async Task NpgsqlException_references_BatchCommand_with_single_command()
538      {
539          await using var conn = await OpenConnectionAsync();
540          var function = await GetTempFunctionName(conn);
541          await conn.ExecuteNonQueryAsync($@"
542  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
543     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
544  LANGUAGE 'plpgsql'");
545          var cmd = conn.CreateCommand();
546          cmd.CommandText = $"SELECT {function}()";
547          var exception = Assert.ThrowsAsync<PostgresException>(() => cmd.ExecuteReaderAsync(Behavior))!;
548          Assert.That(exception.BatchCommand, Is.SameAs(cmd.InternalBatchCommands[0]));
549          cmd.Dispose();
550          var cmd2 = conn.CreateCommand();
551          Assert.AreNotSame(cmd2, cmd);
552      }
553      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/967")]
554      public async Task NpgsqlException_references_BatchCommand_with_multiple_commands()
555      {
556          await using var conn = await OpenConnectionAsync();
557          var function = await GetTempFunctionName(conn);
558          await conn.ExecuteNonQueryAsync($@"
559  CREATE OR REPLACE FUNCTION {function}() RETURNS VOID AS
560     'BEGIN RAISE EXCEPTION ''testexception'' USING ERRCODE = ''12345''; END;'
561  LANGUAGE 'plpgsql'");
562          var cmd = conn.CreateCommand();
563          cmd.CommandText = $"SELECT 1; {function}()";
564          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
565          {
566              var exception = Assert.ThrowsAsync<PostgresException>(() => reader.NextResultAsync())!;
567              Assert.That(exception.BatchCommand, Is.SameAs(cmd.InternalBatchCommands[1]));
568          }
569          cmd.Dispose();
570          var cmd2 = conn.CreateCommand();
571          Assert.AreNotSame(cmd2, cmd);
572      }
573      #region SchemaOnly
574      [Test]
575      public async Task SchemaOnly_returns_no_data()
576      {
577          await using var conn = await OpenConnectionAsync();
578          await using var cmd = new NpgsqlCommand("SELECT 1", conn);
579          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
580          Assert.That(reader.Read(), Is.False);
581      }
582      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2827")]
583      public async Task SchemaOnly_next_result_beyond_end()
584      {
585          using var conn = await OpenConnectionAsync();
586          var table = await CreateTempTable(conn, "id INT");
587          using var cmd = new NpgsqlCommand($"SELECT * FROM {table}", conn);
588          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
589          Assert.False(reader.NextResult());
590          Assert.False(reader.NextResult());
591      }
592      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4124")]
593      public async Task SchemaOnly_GetDataTypeName_with_unsupported_type()
594      {
595          using var conn = await OpenConnectionAsync();
596          using var cmd = new NpgsqlCommand(@"select aggfnoid from pg_aggregate", conn);
597          using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly);
598          Assert.That(reader.GetDataTypeName(0), Is.EqualTo("regproc"));
599      }
600      #endregion SchemaOnly
601      #region GetOrdinal
602      [Test]
603      public async Task GetOrdinal()
604      {
605          using var conn = await OpenConnectionAsync();
606          using var command = new NpgsqlCommand(@"SELECT 0, 1 AS some_column WHERE 1=0", conn);
607          using var reader = await command.ExecuteReaderAsync(Behavior);
608          Assert.That(reader.GetOrdinal("some_column"), Is.EqualTo(1));
609          Assert.That(() => reader.GetOrdinal("doesn't_exist"), Throws.Exception.TypeOf<IndexOutOfRangeException>());
610      }
611      [Test]
612      public async Task GetOrdinal_case_insensitive()
613      {
614          using var conn = await OpenConnectionAsync();
615          using var command = new NpgsqlCommand("select 123 as FIELD1", conn);
616          using var reader = await command.ExecuteReaderAsync(Behavior);
617          reader.Read();
618          Assert.That(reader.GetOrdinal("fieLd1"), Is.EqualTo(0));
619      }
620      [Test]
621      public async Task GetOrdinal_kana_insensitive()
622      {
623          using var conn = await OpenConnectionAsync();
624          using var command = new NpgsqlCommand("select 123 as ｦｧｨｩｪｫｬ", conn);
625          using var reader = await command.ExecuteReaderAsync(Behavior);
626          reader.Read();
627          Assert.That(reader["ヲァィゥェォャ"], Is.EqualTo(123));
628      }
629      #endregion GetOrdinal
630      [Test]
631      public async Task Field_index_does_not_exist()
632      {
633          using var conn = await OpenConnectionAsync();
634          using var command = new NpgsqlCommand("SELECT 1", conn);
635          using var dr = await command.ExecuteReaderAsync(Behavior);
636          dr.Read();
637          Assert.That(() => dr[5], Throws.Exception.TypeOf<IndexOutOfRangeException>());
638      }
639      [Test, Description("Performs some operations while a reader is still open and checks for exceptions")]
640      public async Task Reader_is_still_open()
641      {
642          await using var conn = await OpenConnectionAsync();
643          if (!IsMultiplexing)
644              conn.UnprepareAll();
645          using var cmd1 = new NpgsqlCommand("SELECT 1", conn);
646          await using var reader1 = await cmd1.ExecuteReaderAsync(Behavior);
647          Assert.That(() => conn.ExecuteNonQuery("SELECT 1"), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
648          Assert.That(async () => await conn.ExecuteScalarAsync("SELECT 1"), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
649          using var cmd2 = new NpgsqlCommand("SELECT 2", conn);
650          Assert.That(() => cmd2.ExecuteReader(Behavior), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
651          if (!IsMultiplexing)
652              Assert.That(() => cmd2.Prepare(), Throws.Exception.TypeOf<NpgsqlOperationInProgressException>());
653      }
654      [Test]
655      public async Task Cleans_up_ok_with_dispose_calls([Values(PrepareOrNot.Prepared, PrepareOrNot.NotPrepared)] PrepareOrNot prepare)
656      {
657          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
658              return;
659          using var conn = await OpenConnectionAsync();
660          using var command = new NpgsqlCommand("SELECT 1", conn);
661          using var dr = await command.ExecuteReaderAsync(Behavior);
662          dr.Read();
663          dr.Close();
664          using var upd = conn.CreateCommand();
665          upd.CommandText = "SELECT 1";
666          if (prepare == PrepareOrNot.Prepared)
667              upd.Prepare();
668      }
669      [Test]
670      public async Task Null()
671      {
672          using var conn = await OpenConnectionAsync();
673          using var cmd = new NpgsqlCommand("SELECT @p1, @p2::TEXT", conn);
674          cmd.Parameters.Add(new NpgsqlParameter("p1", DbType.String) { Value = DBNull.Value });
675          cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p2", Value = DBNull.Value });
676          using var reader = await cmd.ExecuteReaderAsync(Behavior);
677          reader.Read();
678          for (var i = 0; i < cmd.Parameters.Count; i++)
679          {
680              Assert.That(reader.IsDBNull(i), Is.True);
681              Assert.That(reader.IsDBNullAsync(i).Result, Is.True);
682              Assert.That(reader.GetValue(i), Is.EqualTo(DBNull.Value));
683              Assert.That(reader.GetFieldValue<object>(i), Is.EqualTo(DBNull.Value));
684              Assert.That(reader.GetProviderSpecificValue(i), Is.EqualTo(DBNull.Value));
685              Assert.That(() => reader.GetString(i), Throws.Exception.TypeOf<InvalidCastException>());
686          }
687      }
688      [Test]
689      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/742")]
690      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/800")]
691      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1234")]
692      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1898")]
693      public async Task HasRows([Values(PrepareOrNot.NotPrepared, PrepareOrNot.Prepared)] PrepareOrNot prepare)
694      {
695          if (prepare == PrepareOrNot.Prepared && IsMultiplexing)
696              return;
697          using var conn = await OpenConnectionAsync();
698          var table = await CreateTempTable(conn, "name TEXT");
699          var command = new NpgsqlCommand($"SELECT 1; SELECT * FROM {table} WHERE name='does_not_exist'", conn);
700          if (prepare == PrepareOrNot.Prepared)
701              command.Prepare();
702          using (var reader = await command.ExecuteReaderAsync(Behavior))
703          {
704              Assert.That(reader.HasRows, Is.True);
705              Assert.That(reader.HasRows, Is.True);
706              Assert.That(reader.Read(), Is.True);
707              Assert.That(reader.HasRows, Is.True);
708              Assert.That(reader.Read(), Is.False);
709              Assert.That(reader.HasRows, Is.True);
710              await reader.NextResultAsync();
711              Assert.That(reader.HasRows, Is.False);
712          }
713          command.CommandText = $"SELECT * FROM {table}";
714          if (prepare == PrepareOrNot.Prepared)
715              command.Prepare();
716          using (var reader = await command.ExecuteReaderAsync(Behavior))
717          {
718              reader.Read();
719              Assert.That(reader.HasRows, Is.False);
720          }
721          command.CommandText = "SELECT 1";
722          if (prepare == PrepareOrNot.Prepared)
723              command.Prepare();
724          using (var reader = await command.ExecuteReaderAsync(Behavior))
725          {
726              reader.Read();
727              reader.Close();
728              Assert.That(() => reader.HasRows, Throws.Exception.TypeOf<InvalidOperationException>());
729          }
730          command.CommandText = $"INSERT INTO {table} (name) VALUES ('foo'); SELECT * FROM {table}";
731          if (prepare == PrepareOrNot.Prepared)
732              command.Prepare();
733          using (var reader = await command.ExecuteReaderAsync(Behavior))
734          {
735              Assert.That(reader.HasRows, Is.True);
736              reader.Read();
737              Assert.That(reader.GetString(0), Is.EqualTo("foo"));
738          }
739          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
740      }
741      [Test]
742      public async Task HasRows_without_resultset()
743      {
744          using var conn = await OpenConnectionAsync();
745          var table = await CreateTempTable(conn, "name TEXT");
746          using var command = new NpgsqlCommand($"DELETE FROM {table} WHERE name = 'unknown'", conn);
747          using var reader = await command.ExecuteReaderAsync(Behavior);
748          Assert.IsFalse(reader.HasRows);
749      }
750      [Test]
751      public async Task Interval_as_TimeSpan()
752      {
753          using var conn = await OpenConnectionAsync();
754          using var command = new NpgsqlCommand("SELECT CAST('1 hour' AS interval) AS dauer", conn);
755          using var dr = await command.ExecuteReaderAsync(Behavior);
756          Assert.IsTrue(dr.HasRows);
757          Assert.IsTrue(dr.Read());
758          Assert.IsTrue(dr.HasRows);
759          var ts = dr.GetTimeSpan(0);
760      }
761      [Test]
762      public async Task Close_connection_in_middle_of_row()
763      {
764          using var conn = await OpenConnectionAsync();
765          using var cmd = new NpgsqlCommand("SELECT 1, 2", conn);
766          using var reader = await cmd.ExecuteReaderAsync(Behavior);
767          reader.Read();
768      }
769      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/pull/1266")]
770      [Description("NextResult was throwing an ArgumentOutOfRangeException when trying to determine the statement to associate with the PostgresException")]
771      public async Task Reader_next_result_exception_handling()
772      {
773          using var conn = await OpenConnectionAsync();
774          var table1 = await GetTempTableName(conn);
775          var table2 = await GetTempTableName(conn);
776          var function = await GetTempFunctionName(conn);
777          var initializeTablesSql = $@"
778  CREATE TABLE {table1} (value int NOT NULL);
779  CREATE TABLE {table2} (value int UNIQUE);
780  ALTER TABLE ONLY {table1} ADD CONSTRAINT {table1}_{table2}_fk FOREIGN KEY (value) REFERENCES {table2}(value) DEFERRABLE INITIALLY DEFERRED;
781  CREATE OR REPLACE FUNCTION {function}(_value int) RETURNS int AS $BODY$
782  BEGIN
783      INSERT INTO {table1}(value) VALUES(_value);
784      RETURN _value;
785  END;
786  $BODY$
787  LANGUAGE plpgsql VOLATILE";
788          await conn.ExecuteNonQueryAsync(initializeTablesSql);
789          using var cmd = new NpgsqlCommand($"SELECT {function}(1)", conn);
790          using var reader = await cmd.ExecuteReaderAsync(Behavior);
791          Assert.That(() => reader.NextResult(),
792              Throws.Exception.TypeOf<PostgresException>()
793                  .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.ForeignKeyViolation));
794      }
795      [Test]
796      public async Task Invalid_cast()
797      {
798          using var conn = await OpenConnectionAsync();
799          using (var cmd = new NpgsqlCommand("SELECT 'foo'", conn))
800          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
801          {
802              reader.Read();
803              Assert.That(() => reader.GetInt32(0), Throws.Exception.TypeOf<InvalidCastException>());
804          }
805          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
806          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
807          {
808              reader.Read();
809              Assert.That(() => reader.GetDateTime(0), Throws.Exception.TypeOf<InvalidCastException>());
810          }
811          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
812      }
813      [Test, Description("Reads a lot of rows to make sure the long unoptimized path for Read() works")]
814      public async Task Many_reads()
815      {
816          using var conn = await OpenConnectionAsync();
817          using var cmd = new NpgsqlCommand($"SELECT generate_series(1, {conn.Settings.ReadBufferSize})", conn);
818          using var reader = await cmd.ExecuteReaderAsync(Behavior);
819          for (var i = 1; i <= conn.Settings.ReadBufferSize; i++)
820          {
821              Assert.That(reader.Read(), Is.True);
822              Assert.That(reader.GetInt32(0), Is.EqualTo(i));
823          }
824          Assert.That(reader.Read(), Is.False);
825      }
826      [Test]
827      public async Task Nullable_scalar()
828      {
829          if (IsSequential)
830              return;
831          using var conn = await OpenConnectionAsync();
832          using var cmd = new NpgsqlCommand("SELECT @p1, @p2", conn);
833          var p1 = new NpgsqlParameter { ParameterName = "p1", Value = DBNull.Value, NpgsqlDbType = NpgsqlDbType.Smallint };
834          var p2 = new NpgsqlParameter { ParameterName = "p2", Value = (short)8 };
835          Assert.That(p2.NpgsqlDbType, Is.EqualTo(NpgsqlDbType.Smallint));
836          Assert.That(p2.DbType, Is.EqualTo(DbType.Int16));
837          cmd.Parameters.Add(p1);
838          cmd.Parameters.Add(p2);
839          using var reader = await cmd.ExecuteReaderAsync(Behavior);
840          reader.Read();
841          for (var i = 0; i < cmd.Parameters.Count; i++)
842          {
843              Assert.That(reader.GetFieldType(i), Is.EqualTo(typeof(short)));
844              Assert.That(reader.GetDataTypeName(i), Is.EqualTo("smallint"));
845          }
846          Assert.That(() => reader.GetFieldValue<object>(0), Is.EqualTo(DBNull.Value));
847          Assert.That(() => reader.GetFieldValue<int>(0), Throws.TypeOf<InvalidCastException>());
848          Assert.That(() => reader.GetFieldValue<int?>(0), Throws.Nothing);
849          Assert.That(reader.GetFieldValue<int?>(0), Is.Null);
850          Assert.That(() => reader.GetFieldValue<object>(1), Throws.Nothing);
851          Assert.That(() => reader.GetFieldValue<int>(1), Throws.Nothing);
852          Assert.That(() => reader.GetFieldValue<int?>(1), Throws.Nothing);
853          Assert.That(reader.GetFieldValue<object>(1), Is.EqualTo(8));
854          Assert.That(reader.GetFieldValue<int>(1), Is.EqualTo(8));
855          Assert.That(reader.GetFieldValue<int?>(1), Is.EqualTo(8));
856      }
857      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2913")]
858      public async Task Bug2913_reading_previous_query_messages()
859      {
860          if (IsMultiplexing)
861              return;
862          var firstMrs = new ManualResetEventSlim(false);
863          var secondMrs = new ManualResetEventSlim(false);
864          var secondQuery = Task.Run(async () =>
865          {
866              firstMrs.Wait();
867              await using var secondConn = await OpenConnectionAsync();
868              using var secondCmd = new NpgsqlCommand(@"SELECT 1; SELECT 2;", secondConn);
869              await using var secondReader = await secondCmd.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
870              Assert.That(secondReader.StatementIndex, Is.EqualTo(0));
871              secondMrs.Wait();
872              Assert.That(secondReader.StatementIndex, Is.EqualTo(0));
873          });
874          await using (var firstConn = await OpenConnectionAsync())
875          {
876              using var firstCmd = new NpgsqlCommand(@"SELECT 1; SELECT * FROM NotExistingTable;", firstConn);
877              await using var firstReader = await firstCmd.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
878              Assert.That(firstReader.StatementIndex, Is.EqualTo(0));
879              firstReader.ReaderClosed += (s, e) =>
880              {
881                  firstMrs.Set();
882                  Thread.Sleep(100);
883              };
884              Assert.ThrowsAsync<PostgresException>(firstReader.NextResultAsync);
885              secondMrs.Set();
886          }
887          await secondQuery;
888          await using var thirdConn = OpenConnection();
889          using var thirdCmd = new NpgsqlCommand(@"SELECT 1; SELECT 2;", thirdConn);
890          await using var thirdReader = await thirdCmd.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
891      }
892      [Test]
893      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2913")]
894      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3289")]
895      public async Task Reader_close_and_dispose()
896      {
897          await using var conn = await OpenConnectionAsync();
898          using var cmd1 = conn.CreateCommand();
899          cmd1.CommandText = "SELECT 1";
900          var reader1 = await cmd1.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
901          await reader1.CloseAsync();
902          await conn.OpenAsync();
903          cmd1.Connection = conn;
904          var reader2 = await cmd1.ExecuteReaderAsync(Behavior | CommandBehavior.CloseConnection);
905          Assert.That(reader1, Is.Not.SameAs(reader2));
906          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
907          await reader1.DisposeAsync();
908          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
909      }
910      [Test]
911      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2964")]
912      public async Task Bug2964_connection_close_and_reader_dispose()
913      {
914          await using var conn = await OpenConnectionAsync();
915          using var cmd1 = conn.CreateCommand();
916          cmd1.CommandText = "SELECT 1";
917          var reader1 = await cmd1.ExecuteReaderAsync(Behavior);
918          await conn.CloseAsync();
919          await conn.OpenAsync();
920          var reader2 = await cmd1.ExecuteReaderAsync(Behavior);
921          Assert.That(reader1, Is.Not.SameAs(reader2));
922          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
923          await reader1.DisposeAsync();
924          Assert.That(reader2.State, Is.EqualTo(ReaderState.BeforeResult));
925      }
926      [Test]
927      public async Task Reader_reuse_on_dispose()
928      {
929          await using var conn = await OpenConnectionAsync();
930          await using var tx = await conn.BeginTransactionAsync();
931          using var cmd = conn.CreateCommand();
932          cmd.CommandText = "SELECT 1";
933          var reader1 = await cmd.ExecuteReaderAsync(Behavior);
934          await reader1.ReadAsync();
935          await reader1.DisposeAsync();
936          var reader2 = await cmd.ExecuteReaderAsync(Behavior);
937          Assert.That(reader1, Is.SameAs(reader2));
938          await reader2.DisposeAsync();
939      }
940      [Test]
941      public async Task Unbound_reader_reuse()
942      {
943          await using var dataSource = CreateDataSource(csb =>
944          {
945              csb.MinPoolSize = 1;
946              csb.MaxPoolSize = 1;
947          });
948          await using var conn1 = await dataSource.OpenConnectionAsync();
949          using var cmd1 = conn1.CreateCommand();
950          cmd1.CommandText = "SELECT 1";
951          var reader1 = await cmd1.ExecuteReaderAsync(Behavior);
952          await using (var __ = reader1)
953          {
954              Assert.That(async () => await reader1.ReadAsync(), Is.EqualTo(true));
955              Assert.That(() => reader1.GetInt32(0), Is.EqualTo(1));
956              await reader1.CloseAsync();
957              await conn1.CloseAsync();
958          }
959          await using var conn2 = await dataSource.OpenConnectionAsync();
960          using var cmd2 = conn2.CreateCommand();
961          cmd2.CommandText = "SELECT 2";
962          var reader2 = await cmd2.ExecuteReaderAsync(Behavior);
963          await using (var __ = reader2)
964          {
965              Assert.That(async () => await reader2.ReadAsync(), Is.EqualTo(true));
966              Assert.That(() => reader2.GetInt32(0), Is.EqualTo(2));
967              Assert.That(reader1, Is.Not.SameAs(reader2));
968              await reader2.CloseAsync();
969              await conn2.CloseAsync();
970          }
971          await using var conn3 = await dataSource.OpenConnectionAsync();
972          using var cmd3 = conn3.CreateCommand();
973          cmd3.CommandText = "SELECT 3";
974          var reader3 = await cmd3.ExecuteReaderAsync(Behavior);
975          await using (var __ = reader3)
976          {
977              Assert.That(async () => await reader3.ReadAsync(), Is.EqualTo(true));
978              Assert.That(() => reader3.GetInt32(0), Is.EqualTo(3));
979              Assert.That(reader1, Is.SameAs(reader3));
980              await reader3.CloseAsync();
981              await conn3.CloseAsync();
982          }
983      }
984      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3772")]
985      public async Task Bug3772()
986      {
987          if (!IsSequential)
988              return;
989          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
990          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
991          await using var conn = await dataSource.OpenConnectionAsync();
992          var pgMock = await postmasterMock.WaitForServerConnection();
993          pgMock
994              .WriteParseComplete()
995              .WriteBindComplete()
996              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4), new FieldDescription(PostgresTypeOIDs.Bytea));
997          var intValue = new byte[] { 0, 0, 0, 1 };
998          var byteValue = new byte[] { 1, 2, 3, 4 };
999          var writeBuffer = pgMock.WriteBuffer;
1000          writeBuffer.WriteByte((byte)BackendMessageCode.DataRow);
1001          writeBuffer.WriteInt32(4 + 2 + intValue.Length + byteValue.Length + 8);
1002          writeBuffer.WriteInt16(2);
1003          writeBuffer.WriteInt32(intValue.Length);
1004          writeBuffer.WriteBytes(intValue);
1005          await pgMock.FlushAsync();
1006          using var cmd = new NpgsqlCommand("SELECT some_int, some_byte FROM some_table", conn);
1007          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1008          await reader.ReadAsync();
1009          reader.GetInt32(0);
1010          Assert.Zero(reader.Connector.ReadBuffer.ReadBytesLeft);
1011          Assert.NotZero(reader.Connector.ReadBuffer.ReadPosition);
1012          writeBuffer.WriteInt32(byteValue.Length);
1013          writeBuffer.WriteBytes(byteValue);
1014          await pgMock
1015              .WriteDataRow(intValue, Enumerable.Range(1, 100).Select(x => (byte)x).ToArray())
1016              .WriteCommandComplete()
1017              .WriteReadyForQuery()
1018              .FlushAsync();
1019          await reader.GetFieldValueAsync<byte[]>(1);
1020          Assert.DoesNotThrowAsync(reader.ReadAsync);
1021      }
1022      [Test] 
1023      public async Task Dispose_does_not_swallow_exceptions([Values(true, false)] bool async)
1024      {
1025          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1026          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1027          await using var conn = await dataSource.OpenConnectionAsync();
1028          var pgMock = await postmasterMock.WaitForServerConnection();
1029          await pgMock
1030              .WriteParseComplete()
1031              .WriteBindComplete()
1032              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1033              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1034              .FlushAsync();
1035          using var cmd = new NpgsqlCommand("SELECT 1", conn);
1036          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1037          await reader.ReadAsync();
1038          pgMock.Close();
1039          if (async)
1040              Assert.Throws<NpgsqlException>(() => reader.Dispose());
1041          else
1042              Assert.ThrowsAsync<NpgsqlException>(async () => await reader.DisposeAsync());
1043      }
1044      #region GetBytes / GetStream
1045      [Test]
1046      public async Task GetBytes()
1047      {
1048          using var conn = await OpenConnectionAsync();
1049          var table = await CreateTempTable(conn, "bytes BYTEA");
1050          byte[] expected = { 1, 2, 3, 4, 5 };
1051          var actual = new byte[expected.Length];
1052          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (bytes) VALUES ({EncodeByteaHex(expected)})");
1053          var query = $"SELECT bytes, 'foo', bytes, 'bar', bytes, bytes FROM {table}";
1054          using var cmd = new NpgsqlCommand(query, conn);
1055          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1056          reader.Read();
1057          Assert.That(reader.GetBytes(0, 0, actual, 0, 2), Is.EqualTo(2));
1058          Assert.That(actual[0], Is.EqualTo(expected[0]));
1059          Assert.That(actual[1], Is.EqualTo(expected[1]));
1060          Assert.That(reader.GetBytes(0, 0, null, 0, 0), Is.EqualTo(expected.Length), "Bad column length");
1061          if (IsSequential)
1062              Assert.That(() => reader.GetBytes(0, 0, actual, 4, 1),
1063                  Throws.Exception.TypeOf<InvalidOperationException>(), "Seek back sequential");
1064          else
1065          {
1066              Assert.That(reader.GetBytes(0, 0, actual, 4, 1), Is.EqualTo(1));
1067              Assert.That(actual[4], Is.EqualTo(expected[0]));
1068          }
1069          Assert.That(reader.GetBytes(0, 2, actual, 2, 3), Is.EqualTo(3));
1070          Assert.That(actual, Is.EqualTo(expected));
1071          Assert.That(reader.GetBytes(0, 0, null, 0, 0), Is.EqualTo(expected.Length), "Bad column length");
1072          Assert.That(() => reader.GetBytes(1, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(),
1073              "GetBytes on non-bytea");
1074          Assert.That(() => reader.GetBytes(1, 0, actual, 0, 1),
1075              Throws.Exception.TypeOf<InvalidCastException>(),
1076              "GetBytes on non-bytea");
1077          Assert.That(reader.GetString(1), Is.EqualTo("foo"));
1078          reader.GetBytes(2, 0, actual, 0, 2);
1079          reader.GetBytes(4, 0, actual, 0, 2);
1080          Assert.That(reader.GetBytes(4, expected.Length - 1, actual, 0, 2), Is.EqualTo(1),
1081              "Length greater than data length");
1082          Assert.That(actual[0], Is.EqualTo(expected[expected.Length - 1]), "Length greater than data length");
1083          Assert.That(() => reader.GetBytes(4, 0, actual, 0, actual.Length + 1),
1084              Throws.Exception.TypeOf<IndexOutOfRangeException>(), "Length great than output buffer length");
1085          reader.GetBytes(5, 0, actual, 0, 2);
1086      }
1087      [Test]
1088      public async Task GetStream_second_time_throws([Values(true, false)] bool isAsync)
1089      {
1090          var expected = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
1091          var streamGetter = BuildStreamGetter(isAsync);
1092          using var conn = await OpenConnectionAsync();
1093          using var cmd = new NpgsqlCommand($"SELECT {EncodeByteaHex(expected)}::bytea", conn);
1094          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1095          await reader.ReadAsync();
1096          using var stream = await streamGetter(reader, 0);
1097          Assert.That(async () => await streamGetter(reader, 0),
1098              Throws.Exception.TypeOf<InvalidOperationException>());
1099      }
1100      public static IEnumerable GetStreamCases()
1101      {
1102          var binary = MemoryMarshal
1103              .AsBytes<int>(Enumerable.Range(0, 1024).ToArray())
1104              .ToArray();
1105          yield return (binary, binary);
1106          var bigBinary = MemoryMarshal
1107              .AsBytes<int>(Enumerable.Range(0, 8193).ToArray())
1108              .ToArray();
1109          yield return (bigBinary, bigBinary);
1110          var bigint = 0xDEADBEEFL;
1111          var bigintBinary = BitConverter.GetBytes(
1112              BitConverter.IsLittleEndian
1113                  ? BinaryPrimitives.ReverseEndianness(bigint)
1114                  : bigint);
1115          yield return (bigint, bigintBinary);
1116      }
1117      [Test]
1118      public async Task GetStream<T>(
1119          [Values] bool isAsync,
1120          [ValueSource(nameof(GetStreamCases))] (T Generic, byte[] Binary) value)
1121      {
1122          var streamGetter = BuildStreamGetter(isAsync);
1123          var expected = value.Binary;
1124          var actual = new byte[expected.Length];
1125          using var conn = await OpenConnectionAsync();
1126          using var cmd = new NpgsqlCommand("SELECT @p, @p", conn) { Parameters = { new NpgsqlParameter("p", value.Generic) } };
1127          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1128          await reader.ReadAsync();
1129          using var stream = await streamGetter(reader, 0);
1130          Assert.That(stream.CanSeek, Is.EqualTo(Behavior == CommandBehavior.Default));
1131          Assert.That(stream.Length, Is.EqualTo(expected.Length));
1132          var position = 0;
1133          while (position < actual.Length)
1134          {
1135              if (isAsync)
1136                  position += await stream.ReadAsync(actual, position, actual.Length - position);
1137              else
1138                  position += stream.Read(actual, position, actual.Length - position);
1139          }
1140          Assert.That(actual, Is.EqualTo(expected));
1141      }
1142      [Test]
1143      public async Task Open_stream_when_changing_columns([Values(true, false)] bool isAsync)
1144      {
1145          var streamGetter = BuildStreamGetter(isAsync);
1146          using var conn = await OpenConnectionAsync();
1147          using var cmd = new NpgsqlCommand(@"SELECT @p, @p", conn);
1148          var data = new byte[] { 1, 2, 3 };
1149          cmd.Parameters.Add(new NpgsqlParameter("p", data));
1150          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1151          reader.Read();
1152          var stream = await streamGetter(reader, 0);
1153          var v = reader.GetValue(1);
1154          Assert.That(() => stream.ReadByte(), Throws.Exception.TypeOf<ObjectDisposedException>());
1155      }
1156      [Test]
1157      public async Task Open_stream_when_changing_rows([Values(true, false)] bool isAsync)
1158      {
1159          var streamGetter = BuildStreamGetter(isAsync);
1160          using var conn = await OpenConnectionAsync();
1161          using var cmd = new NpgsqlCommand(@"SELECT @p", conn);
1162          var data = new byte[] { 1, 2, 3 };
1163          cmd.Parameters.Add(new NpgsqlParameter("p", data));
1164          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1165          reader.Read();
1166          var s1 = await streamGetter(reader, 0);
1167          reader.Read();
1168          Assert.That(() => s1.ReadByte(), Throws.Exception.TypeOf<ObjectDisposedException>());
1169      }
1170      [Test]
1171      public async Task GetBytes_with_null([Values(true, false)] bool isAsync)
1172      {
1173          var streamGetter = BuildStreamGetter(isAsync);
1174          using var conn = await OpenConnectionAsync();
1175          var table = await CreateTempTable(conn, "bytes BYTEA");
1176          var buf = new byte[8];
1177          await conn.ExecuteNonQueryAsync($"INSERT INTO {table} (bytes) VALUES (NULL)");
1178          using var cmd = new NpgsqlCommand($"SELECT bytes FROM {table}", conn);
1179          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1180          reader.Read();
1181          Assert.That(reader.IsDBNull(0), Is.True);
1182          Assert.That(() => reader.GetBytes(0, 0, buf, 0, 1), Throws.Exception.TypeOf<InvalidCastException>(), "GetBytes");
1183          Assert.That(async () => await streamGetter(reader, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetStream");
1184          Assert.That(() => reader.GetBytes(0, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetBytes with null buffer");
1185      }
1186      static Func<NpgsqlDataReader, int, Task<Stream>> BuildStreamGetter(bool isAsync)
1187          => isAsync
1188              ? (r, index) => r.GetStreamAsync(index)
1189              : (r, index) => Task.FromResult(r.GetStream(index));
1190      [Test]
1191      public async Task GetStream_after_consuming_column_throws([Values] bool async)
1192      {
1193          if (!IsSequential)
1194              return;
1195          await using var conn = await OpenConnectionAsync();
1196          await using var cmd = new NpgsqlCommand(@"SELECT '\xDEADBEEF'::bytea", conn);
1197          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1198          await reader.ReadAsync();
1199          _ = reader.GetFieldValue<byte[]>(0);
1200          if (async)
1201              Assert.That(() => reader.GetStreamAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1202          else
1203              Assert.That(() => reader.GetStream(0), Throws.Exception.TypeOf<InvalidOperationException>());
1204      }
1205      [Test]
1206      public async Task GetStream_in_middle_of_column_throws([Values] bool async)
1207      {
1208          if (!IsSequential)
1209              return;
1210          await using var conn = await OpenConnectionAsync();
1211          await using var cmd = new NpgsqlCommand(@"SELECT '\xDEADBEEF'::bytea", conn);
1212          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1213          await reader.ReadAsync();
1214          _ = reader.GetBytes(0, 0, new byte[2], 0, 2);
1215          if (async)
1216              Assert.That(() => reader.GetStreamAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1217          else
1218              Assert.That(() => reader.GetStream(0), Throws.Exception.TypeOf<InvalidOperationException>());
1219      }
1220      #endregion GetBytes / GetStream
1221      #region GetChars / GetTextReader
1222      [Test]
1223      public async Task GetChars()
1224      {
1225          using var conn = await OpenConnectionAsync();
1226          const string str = "ABCDE";
1227          var expected = str.ToCharArray();
1228          var actual = new char[expected.Length];
1229          var queryText = $@"SELECT '{str}', 3, '{str}', 4, '{str}', '{str}', '{str}'";
1230          using var cmd = new NpgsqlCommand(queryText, conn);
1231          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1232          reader.Read();
1233          Assert.That(reader.GetChars(0, 0, actual, 0, 2), Is.EqualTo(2));
1234          Assert.That(actual[0], Is.EqualTo(expected[0]));
1235          Assert.That(actual[1], Is.EqualTo(expected[1]));
1236          Assert.That(reader.GetChars(0, 0, null, 0, 0), Is.EqualTo(expected.Length), "Bad column length");
1237          Assert.That(reader.GetChars(2, 0, actual, 0, 2), Is.EqualTo(2));
1238          if (IsSequential)
1239              Assert.That(() => reader.GetChars(2, 0, actual, 4, 1), Throws.Exception.TypeOf<InvalidOperationException>(), "Seek back sequential");
1240          else
1241          {
1242              Assert.That(reader.GetChars(2, 0, actual, 4, 1), Is.EqualTo(1));
1243              Assert.That(actual[4], Is.EqualTo(expected[0]));
1244          }
1245          Assert.That(reader.GetChars(2, 2, actual, 2, 3), Is.EqualTo(3));
1246          Assert.That(actual, Is.EqualTo(expected));
1247          Assert.That(() => reader.GetChars(3, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars on non-text");
1248          Assert.That(() => reader.GetChars(3, 0, actual, 0, 1), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars on non-text");
1249          Assert.That(reader.GetInt32(3), Is.EqualTo(4));
1250          reader.GetChars(4, 0, actual, 0, 2);
1251          reader.GetChars(5, 0, actual, 0, 2);
1252          Assert.That(reader.GetChars(5, expected.Length - 1, actual, 0, 2), Is.EqualTo(1), "Length greater than data length");
1253          Assert.That(actual[0], Is.EqualTo(expected[expected.Length - 1]), "Length greater than data length");
1254          Assert.That(() => reader.GetChars(5, 0, actual, 0, actual.Length + 1), Throws.Exception.TypeOf<IndexOutOfRangeException>(), "Length great than output buffer length");
1255          reader.GetChars(6, 0, actual, 0, 2);
1256      }
1257      [Test]
1258      public async Task GetTextReader([Values(true, false)] bool isAsync)
1259      {
1260          Func<NpgsqlDataReader, int, Task<TextReader>> textReaderGetter;
1261          if (isAsync)
1262              textReaderGetter = (r, index) => r.GetTextReaderAsync(index);
1263          else
1264              textReaderGetter = (r, index) => Task.FromResult(r.GetTextReader(index));
1265          using var conn = await OpenConnectionAsync();
1266          const string str = "ABCDE";
1267          var expected = str.ToCharArray();
1268          var actual = new char[expected.Length];
1269          var queryText = $@"SELECT '{str}', 'foo'";
1270          using var cmd = new NpgsqlCommand(queryText, conn);
1271          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1272          reader.Read();
1273          var textReader = await textReaderGetter(reader, 0);
1274          textReader.Read(actual, 0, 2);
1275          Assert.That(actual[0], Is.EqualTo(expected[0]));
1276          Assert.That(actual[1], Is.EqualTo(expected[1]));
1277          Assert.That(async () => await textReaderGetter(reader, 0),
1278              Throws.Exception.TypeOf<InvalidOperationException>(),
1279              "Sequential text reader twice on same column");
1280          textReader.Read(actual, 2, 1);
1281          Assert.That(actual[2], Is.EqualTo(expected[2]));
1282          textReader.Dispose();
1283          if (IsSequential)
1284              Assert.That(() => reader.GetChars(0, 0, actual, 4, 1),
1285                  Throws.Exception.TypeOf<InvalidOperationException>(), "Seek back sequential");
1286          else
1287          {
1288              Assert.That(reader.GetChars(0, 0, actual, 4, 1), Is.EqualTo(1));
1289              Assert.That(actual[4], Is.EqualTo(expected[0]));
1290          }
1291          Assert.That(reader.GetString(1), Is.EqualTo("foo"));
1292      }
1293      [Test]
1294      public async Task TextReader_zero_length_column()
1295      {
1296          await using var conn = await OpenConnectionAsync();
1297          await using var cmd = conn.CreateCommand();
1298          cmd.CommandText = "SELECT ''";
1299          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1300          Assert.IsTrue(await reader.ReadAsync());
1301          using var textReader = reader.GetTextReader(0);
1302          Assert.That(textReader.Peek(), Is.EqualTo(-1));
1303          Assert.That(textReader.ReadToEnd(), Is.EqualTo(string.Empty));
1304      }
1305      [Test]
1306      public async Task Open_TextReader_when_changing_columns()
1307      {
1308          using var conn = await OpenConnectionAsync();
1309          using var cmd = new NpgsqlCommand(@"SELECT 'some_text', 'some_text'", conn);
1310          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1311          reader.Read();
1312          var textReader = reader.GetTextReader(0);
1313          var v = reader.GetValue(1);
1314          Assert.That(() => textReader.Peek(), Throws.Exception.TypeOf<ObjectDisposedException>());
1315      }
1316      [Test]
1317      public async Task Open_TextReader_when_changing_rows()
1318      {
1319          using var conn = await OpenConnectionAsync();
1320          using var cmd = new NpgsqlCommand(@"SELECT 'some_text', 'some_text'", conn);
1321          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1322          reader.Read();
1323          var tr1 = reader.GetTextReader(0);
1324          reader.Read();
1325          Assert.That(() => tr1.Peek(), Throws.Exception.TypeOf<ObjectDisposedException>());
1326      }
1327      [Test]
1328      public async Task GetChars_when_null()
1329      {
1330          var buf = new char[8];
1331          using var conn = await OpenConnectionAsync();
1332          using var cmd = new NpgsqlCommand("SELECT NULL::TEXT", conn);
1333          using var reader = await cmd.ExecuteReaderAsync(Behavior);
1334          reader.Read();
1335          Assert.That(reader.IsDBNull(0), Is.True);
1336          Assert.That(() => reader.GetChars(0, 0, buf, 0, 1), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars");
1337          Assert.That(() => reader.GetTextReader(0), Throws.Exception.TypeOf<InvalidCastException>(), "GetTextReader");
1338          Assert.That(() => reader.GetChars(0, 0, null, 0, 0), Throws.Exception.TypeOf<InvalidCastException>(), "GetChars with null buffer");
1339      }
1340      [Test]
1341      public async Task Reader_is_reused()
1342      {
1343          if (IsMultiplexing)
1344              Assert.Ignore("Multiplexing: Fails");
1345          using var conn = await OpenConnectionAsync();
1346          NpgsqlDataReader reader1;
1347          using (var cmd = new NpgsqlCommand("SELECT 8", conn))
1348          using (reader1 = await cmd.ExecuteReaderAsync(Behavior))
1349          {
1350              reader1.Read();
1351              Assert.That(reader1.GetInt32(0), Is.EqualTo(8));
1352          }
1353          using (var cmd = new NpgsqlCommand("SELECT 9", conn))
1354          using (var reader2 = await cmd.ExecuteReaderAsync(Behavior))
1355          {
1356              Assert.That(reader2, Is.SameAs(reader1));
1357              reader2.Read();
1358              Assert.That(reader2.GetInt32(0), Is.EqualTo(9));
1359          }
1360      }
1361      [Test]
1362      public async Task GetTextReader_after_consuming_column_throws([Values] bool async)
1363      {
1364          if (!IsSequential)
1365              return;
1366          await using var conn = await OpenConnectionAsync();
1367          await using var cmd = new NpgsqlCommand("SELECT 'foo'", conn);
1368          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1369          await reader.ReadAsync();
1370          _ = reader.GetString(0);
1371          if (async)
1372              Assert.That(() => reader.GetTextReaderAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1373          else
1374              Assert.That(() => reader.GetTextReader(0), Throws.Exception.TypeOf<InvalidOperationException>());
1375      }
1376      [Test]
1377      public async Task GetTextReader_in_middle_of_column_throws([Values] bool async)
1378      {
1379          if (!IsSequential)
1380              return;
1381          await using var conn = await OpenConnectionAsync();
1382          await using var cmd = new NpgsqlCommand("SELECT 'foo'", conn);
1383          await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess);
1384          await reader.ReadAsync();
1385          _ = reader.GetChars(0, 0, new char[2], 0, 2);
1386          if (async)
1387              Assert.That(() => reader.GetTextReaderAsync(0), Throws.Exception.TypeOf<InvalidOperationException>());
1388          else
1389              Assert.That(() => reader.GetTextReader(0), Throws.Exception.TypeOf<InvalidOperationException>());
1390      }
1391      #endregion GetChars / GetTextReader
1392      [Test, Description("Tests that everything goes well when a type handler generates a NpgsqlSafeReadException")]
1393      public async Task SafeReadException()
1394      {
1395          var dataSourceBuilder = CreateDataSourceBuilder();
1396          dataSourceBuilder.AddTypeResolverFactory(new ExplodingTypeHandlerResolverFactory(safe: true));
1397          await using var dataSource = dataSourceBuilder.Build();
1398          await using var connection = await dataSource.OpenConnectionAsync();
1399          await using var cmd = new NpgsqlCommand(@"SELECT 1, 'hello'", connection);
1400          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1401          await reader.ReadAsync();
1402          Assert.That(() => reader.GetInt32(0),
1403              Throws.Exception.With.Message.EqualTo("Safe read exception as requested"));
1404          Assert.That(reader.GetString(1), Is.EqualTo("hello"));
1405      }
1406      [Test, Description("Tests that when a type handler generates an exception that isn't a NpgsqlSafeReadException, the connection is properly broken")]
1407      public async Task Non_SafeReadException()
1408      {
1409          var dataSourceBuilder = CreateDataSourceBuilder();
1410          dataSourceBuilder.AddTypeResolverFactory(new ExplodingTypeHandlerResolverFactory(safe: false));
1411          await using var dataSource = dataSourceBuilder.Build();
1412          await using var connection = await dataSource.OpenConnectionAsync();
1413          await using var cmd = new NpgsqlCommand(@"SELECT 1, 'hello'", connection);
1414          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1415          await reader.ReadAsync();
1416          Assert.That(() => reader.GetInt32(0), Throws.Exception.With.Message.EqualTo("Non-safe read exception as requested"));
1417          Assert.That(connection.FullState, Is.EqualTo(ConnectionState.Broken));
1418          Assert.That(connection.State, Is.EqualTo(ConnectionState.Closed));
1419      }
1420      #region Cancellation
1421      [Test, Description("Cancels ReadAsync via the NpgsqlCommand.Cancel, with successful PG cancellation")]
1422      public async Task ReadAsync_cancel_command_soft()
1423      {
1424          if (IsMultiplexing)
1425              return; 
1426          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1427          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1428          await using var conn = await dataSource.OpenConnectionAsync();
1429          var pgMock = await postmasterMock.WaitForServerConnection();
1430          await pgMock
1431              .WriteParseComplete()
1432              .WriteBindComplete()
1433              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1434              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1435              .FlushAsync();
1436          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1437          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1438          {
1439              Assert.True(await reader.ReadAsync());
1440              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1441              var task = reader.ReadAsync();
1442              cmd.Cancel();
1443              var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1444              Assert.That(processId, Is.EqualTo(conn.ProcessID));
1445              await pgMock
1446                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1447                  .WriteReadyForQuery()
1448                  .FlushAsync();
1449              var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1450              Assert.That(exception.InnerException,
1451                  Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
1452              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
1453          }
1454          await pgMock.WriteScalarResponseAndFlush(1);
1455          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1456      }
1457      [Test, Description("Cancels ReadAsync via the cancellation token, with successful PG cancellation")]
1458      public async Task ReadAsync_cancel_soft()
1459      {
1460          if (IsMultiplexing)
1461              return; 
1462          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1463          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1464          await using var conn = await dataSource.OpenConnectionAsync();
1465          var pgMock = await postmasterMock.WaitForServerConnection();
1466          await pgMock
1467              .WriteParseComplete()
1468              .WriteBindComplete()
1469              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1470              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1471              .FlushAsync();
1472          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1473          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1474          {
1475              Assert.True(await reader.ReadAsync());
1476              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1477              var cancellationSource = new CancellationTokenSource();
1478              var task = reader.ReadAsync(cancellationSource.Token);
1479              cancellationSource.Cancel();
1480              var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1481              Assert.That(processId, Is.EqualTo(conn.ProcessID));
1482              await pgMock
1483                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1484                  .WriteReadyForQuery()
1485                  .FlushAsync();
1486              var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1487              Assert.That(exception.InnerException,
1488                  Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
1489              Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1490              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
1491          }
1492          await pgMock.WriteScalarResponseAndFlush(1);
1493          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1494      }
1495      [Test, Description("Cancels NextResultAsync via the cancellation token, with successful PG cancellation")]
1496      public async Task NextResult_cancel_soft()
1497      {
1498          if (IsMultiplexing)
1499              return; 
1500          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1501          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1502          await using var conn = await dataSource.OpenConnectionAsync();
1503          var pgMock = await postmasterMock.WaitForServerConnection();
1504          await pgMock
1505              .WriteParseComplete()
1506              .WriteBindComplete()
1507              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1508              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1509              .WriteCommandComplete()
1510              .FlushAsync();
1511          using var cmd = new NpgsqlCommand("SELECT 1; SELECT 2", conn);
1512          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1513          {
1514              Assert.True(await reader.ReadAsync());
1515              Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1516              var cancellationSource = new CancellationTokenSource();
1517              var task = reader.NextResultAsync(cancellationSource.Token);
1518              cancellationSource.Cancel();
1519              var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1520              Assert.That(processId, Is.EqualTo(conn.ProcessID));
1521              await pgMock
1522                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1523                  .WriteReadyForQuery()
1524                  .FlushAsync();
1525              var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1526              Assert.That(exception.InnerException,
1527                  Is.TypeOf<PostgresException>().With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.QueryCanceled));
1528              Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1529              Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Open | ConnectionState.Fetching));
1530          }
1531          await pgMock.WriteScalarResponseAndFlush(1);
1532          Assert.That(await conn.ExecuteScalarAsync("SELECT 1"), Is.EqualTo(1));
1533      }
1534      [Test, Description("Cancels ReadAsync via the cancellation token, with unsuccessful PG cancellation (socket break)")]
1535      public async Task ReadAsync_cancel_hard([Values(true, false)] bool passCancelledToken)
1536      {
1537          if (IsMultiplexing)
1538              return; 
1539          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1540          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1541          await using var conn = await dataSource.OpenConnectionAsync();
1542          var pgMock = await postmasterMock.WaitForServerConnection();
1543          await pgMock
1544              .WriteParseComplete()
1545              .WriteBindComplete()
1546              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1547              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1548              .FlushAsync();
1549          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1550          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1551          Assert.True(await reader.ReadAsync());
1552          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1553          var cancellationSource = new CancellationTokenSource();
1554          if (passCancelledToken)
1555              cancellationSource.Cancel();
1556          var task = reader.ReadAsync(cancellationSource.Token);
1557          cancellationSource.Cancel();
1558          var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1559          Assert.That(processId, Is.EqualTo(conn.ProcessID));
1560          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1561          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1562          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1563          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1564      }
1565      [Test, Description("Cancels NextResultAsync via the cancellation token, with unsuccessful PG cancellation (socket break)")]
1566      public async Task NextResultAsync_cancel_hard([Values(true, false)] bool passCancelledToken)
1567      {
1568          if (IsMultiplexing)
1569              return; 
1570          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1571          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1572          await using var conn = await dataSource.OpenConnectionAsync();
1573          var pgMock = await postmasterMock.WaitForServerConnection();
1574          await pgMock
1575              .WriteParseComplete()
1576              .WriteBindComplete()
1577              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1578              .WriteDataRow(BitConverter.GetBytes(BinaryPrimitives.ReverseEndianness(1)))
1579              .WriteCommandComplete()
1580              .FlushAsync();
1581          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1582          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1583          Assert.True(await reader.ReadAsync());
1584          Assert.That(reader.GetInt32(0), Is.EqualTo(1));
1585          var cancellationSource = new CancellationTokenSource();
1586          if (passCancelledToken)
1587              cancellationSource.Cancel();
1588          var task = reader.NextResultAsync(cancellationSource.Token);
1589          cancellationSource.Cancel();
1590          var processId = (await postmasterMock.WaitForCancellationRequest()).ProcessId;
1591          Assert.That(processId, Is.EqualTo(conn.ProcessID));
1592          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1593          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1594          Assert.That(exception.CancellationToken, Is.EqualTo(cancellationSource.Token));
1595          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1596      }
1597      [Test, Description("Cancels sequential ReadAsGetFieldValueAsync")]
1598      public async Task GetFieldValueAsync_sequential_cancel([Values(true, false)] bool passCancelledToken)
1599      {
1600          if (IsMultiplexing)
1601              return; 
1602          if (!IsSequential)
1603              return;
1604          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1605          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1606          await using var conn = await dataSource.OpenConnectionAsync();
1607          var pgMock = await postmasterMock.WaitForServerConnection();
1608          await pgMock
1609              .WriteParseComplete()
1610              .WriteBindComplete()
1611              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea))
1612              .WriteDataRowWithFlush(new byte[10000]);
1613          using var cmd = new NpgsqlCommand("SELECT some_bytea FROM some_table", conn);
1614          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1615          await reader.ReadAsync();
1616          using var cts = new CancellationTokenSource();
1617          if (passCancelledToken)
1618              cts.Cancel();
1619          var task = reader.GetFieldValueAsync<byte[]>(0, cts.Token);
1620          cts.Cancel();
1621          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1622          Assert.That(exception.InnerException, Is.Null);
1623          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1624      }
1625      [Test, Description("Cancels sequential ReadAsGetFieldValueAsync")]
1626      public async Task IsDBNullAsync_sequential_cancel([Values(true, false)] bool passCancelledToken)
1627      {
1628          if (IsMultiplexing)
1629              return; 
1630          if (!IsSequential)
1631              return;
1632          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1633          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1634          await using var conn = await dataSource.OpenConnectionAsync();
1635          var pgMock = await postmasterMock.WaitForServerConnection();
1636          await pgMock
1637              .WriteParseComplete()
1638              .WriteBindComplete()
1639              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea), new FieldDescription(PostgresTypeOIDs.Int4))
1640              .WriteDataRowWithFlush(new byte[10000], new byte[4]);
1641          using var cmd = new NpgsqlCommand("SELECT some_bytea, some_int FROM some_table", conn);
1642          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1643          await reader.ReadAsync();
1644          using var cts = new CancellationTokenSource();
1645          if (passCancelledToken)
1646              cts.Cancel();
1647          var task = reader.IsDBNullAsync(1, cts.Token);
1648          cts.Cancel();
1649          var exception = Assert.ThrowsAsync<OperationCanceledException>(async () => await task)!;
1650          Assert.That(exception.InnerException, Is.Null);
1651          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1652      }
1653      [Test, Description("Cancellation does not work with the multiplexing")]
1654      public async Task Cancel_multiplexing_disabled()
1655      {
1656          if (!IsMultiplexing)
1657              return;
1658          await using var dataSource = CreateDataSource();
1659          await using var conn = await dataSource.OpenConnectionAsync();
1660          await using var cmd = new NpgsqlCommand("SELECT generate_series(1, 100); SELECT generate_series(1, 100)", conn);
1661          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1662          var cancelledToken = new CancellationToken(canceled: true);
1663          Assert.IsTrue(await reader.ReadAsync());
1664          while (await reader.ReadAsync(cancelledToken)) { }
1665          Assert.IsTrue(await reader.NextResultAsync(cancelledToken));
1666          while (await reader.ReadAsync(cancelledToken)) { }
1667          Assert.IsFalse(conn.Connector!.UserCancellationRequested);
1668      }
1669      #endregion Cancellation
1670      #region Timeout
1671      [Test, Description("Timeouts sequential ReadAsGetFieldValueAsync")]
1672      public async Task GetFieldValueAsync_sequential_timeout()
1673      {
1674          if (IsMultiplexing)
1675              return; 
1676          if (!IsSequential)
1677              return;
1678          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1679          {
1680              CommandTimeout = 3,
1681              CancellationTimeout = 15000
1682          };
1683          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1684          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1685          await using var conn = await dataSource.OpenConnectionAsync();
1686          var pgMock = await postmasterMock.WaitForServerConnection();
1687          await pgMock
1688              .WriteParseComplete()
1689              .WriteBindComplete()
1690              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea))
1691              .WriteDataRowWithFlush(new byte[10000]);
1692          using var cmd = new NpgsqlCommand("SELECT some_bytea FROM some_table", conn);
1693          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1694          await reader.ReadAsync();
1695          var task = reader.GetFieldValueAsync<byte[]>(0);
1696          var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await task)!;
1697          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1698          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1699      }
1700      [Test, Description("Timeouts sequential IsDBNullAsync")]
1701      public async Task IsDBNullAsync_sequential_timeout()
1702      {
1703          if (IsMultiplexing)
1704              return; 
1705          if (!IsSequential)
1706              return;
1707          var csb = new NpgsqlConnectionStringBuilder(ConnectionString)
1708          {
1709              CommandTimeout = 3,
1710              CancellationTimeout = 15000
1711          };
1712          await using var postmasterMock = PgPostmasterMock.Start(csb.ToString());
1713          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1714          await using var conn = await dataSource.OpenConnectionAsync();
1715          var pgMock = await postmasterMock.WaitForServerConnection();
1716          await pgMock
1717              .WriteParseComplete()
1718              .WriteBindComplete()
1719              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Bytea), new FieldDescription(PostgresTypeOIDs.Int4))
1720              .WriteDataRowWithFlush(new byte[10000], new byte[4]);
1721          using var cmd = new NpgsqlCommand("SELECT some_bytea, some_int FROM some_table", conn);
1722          await using var reader = await cmd.ExecuteReaderAsync(Behavior);
1723          await reader.ReadAsync();
1724          var task = reader.GetFieldValueAsync<byte[]>(0);
1725          var exception = Assert.ThrowsAsync<NpgsqlException>(async () => await task)!;
1726          Assert.That(exception.InnerException, Is.TypeOf<TimeoutException>());
1727          Assert.That(conn.FullState, Is.EqualTo(ConnectionState.Broken));
1728      }
1729      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3446")]
1730      public async Task Bug3446()
1731      {
1732          if (IsMultiplexing)
1733              return; 
1734          await using var postmasterMock = PgPostmasterMock.Start(ConnectionString);
1735          await using var dataSource = CreateDataSource(postmasterMock.ConnectionString);
1736          await using var conn = await dataSource.OpenConnectionAsync();
1737          var pgMock = await postmasterMock.WaitForServerConnection();
1738          await pgMock
1739              .WriteParseComplete()
1740              .WriteBindComplete()
1741              .WriteRowDescription(new FieldDescription(PostgresTypeOIDs.Int4))
1742              .WriteDataRow(new byte[4])
1743              .FlushAsync();
1744          using var cmd = new NpgsqlCommand("SELECT some_int FROM some_table", conn);
1745          await using (var reader = await cmd.ExecuteReaderAsync(Behavior))
1746          {
1747              await reader.ReadAsync();
1748              cmd.Cancel();
1749              await postmasterMock.WaitForCancellationRequest();
1750              await pgMock
1751                  .WriteErrorResponse(PostgresErrorCodes.QueryCanceled)
1752                  .WriteReadyForQuery()
1753                  .FlushAsync();
1754          }
1755          Assert.That(conn.Connector!.State, Is.EqualTo(ConnectorState.Ready));
1756      }
1757      #endregion
1758      #region Initialization / setup / teardown
1759      readonly bool IsSequential;
1760      readonly CommandBehavior Behavior;
1761      public ReaderTests(MultiplexingMode multiplexingMode, CommandBehavior behavior) : base(multiplexingMode)
1762      {
1763          Behavior = behavior;
1764          IsSequential = (Behavior & CommandBehavior.SequentialAccess) != 0;
1765      }
1766      #endregion
1767  }
1768  #region Mock Type Handlers
1769  class ExplodingTypeHandlerResolverFactory : TypeHandlerResolverFactory
1770  {
1771      readonly bool _safe;
1772      public ExplodingTypeHandlerResolverFactory(bool safe) => _safe = safe;
1773      public override TypeHandlerResolver Create(TypeMapper typeMapper, NpgsqlConnector connector) => new ExplodingTypeHandlerResolver(_safe);
1774      class ExplodingTypeHandlerResolver : TypeHandlerResolver
1775      {
1776          readonly bool _safe;
1777          public ExplodingTypeHandlerResolver(bool safe) => _safe = safe;
1778          public override NpgsqlTypeHandler? ResolveByDataTypeName(string typeName) =>
1779              typeName == "integer" ? new ExplodingTypeHandler(null!, _safe) : null;
1780          public override NpgsqlTypeHandler? ResolveByClrType(Type type) => null;
1781      }
1782  }
1783  class ExplodingTypeHandler : NpgsqlSimpleTypeHandler<int>
1784  {
1785      readonly bool _safe;
1786      internal ExplodingTypeHandler(PostgresType postgresType, bool safe) : base(postgresType) => _safe = safe;
1787      public override int Read(NpgsqlReadBuffer buf, int len, FieldDescription? fieldDescription = null)
1788      {
1789          buf.ReadInt32();
1790          throw _safe
1791              ? new Exception("Safe read exception as requested")
1792              : buf.Connector.Break(new Exception("Non-safe read exception as requested"));
1793      }
1794      public override int ValidateAndGetLength(int value, NpgsqlParameter? parameter) => throw new NotSupportedException();
1795      public override int ValidateObjectAndGetLength(object? value, ref NpgsqlLengthCache? lengthCache, NpgsqlParameter? parameter)
1796          => throw new NotSupportedException();
1797      public override void Write(int value, NpgsqlWriteBuffer buf, NpgsqlParameter? parameter) => throw new NotSupportedException();
1798      public override Task WriteObjectWithLength(
1799          object? value,
1800          NpgsqlWriteBuffer buf,
1801          NpgsqlLengthCache? lengthCache,
1802          NpgsqlParameter? parameter,
1803          bool async,
1804          CancellationToken cancellationToken = default)
1805          => throw new NotSupportedException();
1806  }
1807  #endregion
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MudBlazor-MDEwOlJlcG9zaXRvcnkyODg0Mjg2NzY=-flat-StringExtensionTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-ReaderTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>12              default(string).ToKebabCase().Should().Be(null);
13              "".ToKebabCase().Should().Be("");
14              "I".ToKebabCase().Should().Be("i");
15              "IO".ToKebabCase().Should().Be("io");
16              "FileIO".ToKebabCase().Should().Be("file-io");
</pre></code></div>
                <div class="column column_space"><pre><code>53          using (var reader = await cmd.ExecuteReaderAsync(Behavior))
54          {
55              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
56              Assert.That(reader.Read(), Is.False);
57              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
58              Assert.That(reader.FieldCount, Is.EqualTo(0));
59              Assert.That(reader.NextResult(), Is.False);
60              Assert.That(() => reader.GetOrdinal("foo"), Throws.Exception.TypeOf<InvalidOperationException>());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    