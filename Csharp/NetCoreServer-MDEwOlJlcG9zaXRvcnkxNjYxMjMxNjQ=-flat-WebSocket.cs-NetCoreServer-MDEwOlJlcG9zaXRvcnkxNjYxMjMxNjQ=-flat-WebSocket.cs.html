
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WebSocket.cs</h3>
            <pre><code>1  using System;
2  using System.Text;
3  using System.Security.Cryptography;
4  using System.Collections.Generic;
5  using System.Threading;
6  namespace NetCoreServer
7  {
8      public class WebSocket : IWebSocket
9      {
10          private readonly IWebSocket _wsHandler;
11          public WebSocket(IWebSocket wsHandler) { _wsHandler = wsHandler; ClearWsBuffers(); InitWsNonce(); }
12          public const byte WS_FIN = 0x80;
13          public const byte WS_TEXT = 0x01;
14          public const byte WS_BINARY = 0x02;
15          public const byte WS_CLOSE = 0x08;
16          public const byte WS_PING = 0x09;
17          public const byte WS_PONG = 0x0A;
18          public bool PerformClientUpgrade(HttpResponse response, Guid id)
19          {
20              if (response.Status != 101)
21                  return false;
22              bool error = false;
23              bool accept = false;
24              bool connection = false;
25              bool upgrade = false;
26              for (int i = 0; i < response.Headers; i++)
27              {
28                  var header = response.Header(i);
29                  var key = header.Item1;
30                  var value = header.Item2;
31                  if (string.Compare(key, "Connection", StringComparison.OrdinalIgnoreCase) == 0)
32                  {
33                      if (string.Compare(value, "Upgrade", StringComparison.OrdinalIgnoreCase) != 0)
34                      {
35                          error = true;
36                          _wsHandler.OnWsError("Invalid WebSocket handshaked response: 'Connection' header value must be 'Upgrade'");
37                          break;
38                      }
39                      connection = true;
40                  }
41                  else if (string.Compare(key, "Upgrade", StringComparison.OrdinalIgnoreCase) == 0)
42                  {
43                      if (string.Compare(value, "websocket", StringComparison.OrdinalIgnoreCase) != 0)
44                      {
45                          error = true;
46                          _wsHandler.OnWsError("Invalid WebSocket handshaked response: 'Upgrade' header value must be 'websocket'");
47                          break;
48                      }
49                      upgrade = true;
50                  }
51                  else if (string.Compare(key, "Sec-WebSocket-Accept", StringComparison.OrdinalIgnoreCase) == 0)
52                  {
53                      string wskey = Convert.ToBase64String(WsNonce) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
54                      string wshash;
55                      using (SHA1 sha1 = SHA1.Create())
56                      {
57                          wshash = Encoding.UTF8.GetString(sha1.ComputeHash(Encoding.UTF8.GetBytes(wskey)));
58                      }
59                      wskey = Encoding.UTF8.GetString(Convert.FromBase64String(value));
60                      if (string.Compare(wskey, wshash, StringComparison.InvariantCulture) != 0)
61                      {
62                          error = true;
63                          _wsHandler.OnWsError("Invalid WebSocket handshaked response: 'Sec-WebSocket-Accept' value validation failed");
64                          break;
65                      }
66                      accept = true;
67                  }
68              }
69              if (!accept || !connection || !upgrade)
70              {
71                  if (!error)
72                      _wsHandler.OnWsError("Invalid WebSocket response");
73                  return false;
74              }
75              WsHandshaked = true;
76              WsRandom.NextBytes(WsSendMask);
77              _wsHandler.OnWsConnected(response);
78              return true;
79          }
80          public bool PerformServerUpgrade(HttpRequest request, HttpResponse response)
81          {
82              if (request.Method != "GET")
83                  return false;
84              bool error = false;
85              bool connection = false;
86              bool upgrade = false;
87              bool wsKey = false;
88              bool wsVersion = false;
89              string accept = "";
90              for (int i = 0; i < request.Headers; i++)
91              {
92                  var header = request.Header(i);
93                  var key = header.Item1;
94                  var value = header.Item2;
95                  if (string.Compare(key, "Connection", StringComparison.OrdinalIgnoreCase) == 0)
96                  {
97                      if ((string.Compare(value, "Upgrade", StringComparison.OrdinalIgnoreCase) != 0) && (string.Compare(value, "keep-alive, Upgrade", StringComparison.OrdinalIgnoreCase) != 0))
98                      {
99                          error = true;
100                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Connection' header value must be 'Upgrade' or 'keep-alive, Upgrade'");
101                          break;
102                      }
103                      connection = true;
104                  }
105                  else if (string.Compare(key, "Upgrade", StringComparison.OrdinalIgnoreCase) == 0)
106                  {
107                      if (string.Compare(value, "websocket", StringComparison.OrdinalIgnoreCase) != 0)
108                      {
109                          error = true;
110                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Upgrade' header value must be 'websocket'");
111                          break;
112                      }
113                      upgrade = true;
114                  }
115                  else if (string.Compare(key, "Sec-WebSocket-Key", StringComparison.OrdinalIgnoreCase) == 0)
116                  {
117                      if (string.IsNullOrEmpty(value))
118                      {
119                          error = true;
120                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Sec-WebSocket-Key' header value must be non empty");
121                          break;
122                      }
123                      string wskey = value + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
124                      byte[] wshash;
125                      using (SHA1 sha1 = SHA1.Create())
126                      {
127                          wshash = sha1.ComputeHash(Encoding.UTF8.GetBytes(wskey));
128                      }
129                      accept = Convert.ToBase64String(wshash);
130                      wsKey = true;
131                  }
132                  else if (string.Compare(key, "Sec-WebSocket-Version", StringComparison.OrdinalIgnoreCase) == 0)
133                  {
134                      if (string.Compare(value, "13", StringComparison.OrdinalIgnoreCase) != 0)
135                      {
136                          error = true;
137                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Sec-WebSocket-Version' header value must be '13'");
138                          break;
139                      }
140                      wsVersion = true;
141                  }
142              }
143              if (!connection && !upgrade && !wsKey && !wsVersion)
144                  return false;
145              if (!connection || !upgrade || !wsKey || !wsVersion)
146              {
147                  if (!error)
148                      response.MakeErrorResponse(400, "Invalid WebSocket response");
149                  _wsHandler.SendUpgrade(response);
150                  return false;
151              }
152              response.Clear();
153              response.SetBegin(101);
154              response.SetHeader("Connection", "Upgrade");
155              response.SetHeader("Upgrade", "websocket");
156              response.SetHeader("Sec-WebSocket-Accept", accept);
157              response.SetBody();
158              if (!_wsHandler.OnWsConnecting(request, response))
159                  return false;
160              _wsHandler.SendUpgrade(response);
161              WsHandshaked = true;
162              Array.Fill(WsSendMask, (byte)0);
163              _wsHandler.OnWsConnected(request);
164              return true;
165          }
166          public void PrepareSendFrame(byte opcode, bool mask, ReadOnlySpan<byte> buffer, int status = 0)
167          {
168              bool storeWSCloseStatus = ((opcode & WS_CLOSE) == WS_CLOSE) && (buffer.Length > 0);
169              long size = storeWSCloseStatus ? (buffer.Length + 2) : buffer.Length;
170              WsSendBuffer.Clear();
171              WsSendBuffer.Append(opcode);
172              if (size <= 125)
173                  WsSendBuffer.Append((byte)(((int)size & 0xFF) | (mask ? 0x80 : 0)));
174              else if (size <= 65535)
175              {
176                  WsSendBuffer.Append((byte)(126 | (mask ? 0x80 : 0)));
177                  WsSendBuffer.Append((byte)((size >> 8) & 0xFF));
178                  WsSendBuffer.Append((byte)(size & 0xFF));
179              }
180              else
181              {
182                  WsSendBuffer.Append((byte)(127 | (mask ? 0x80 : 0)));
183                  for (int i = 7; i >= 0; i--)
184                      WsSendBuffer.Append((byte)((size >> (8 * i)) & 0xFF));
185              }
186              if (mask)
187              {
188                  WsSendBuffer.Append(WsSendMask);
189              }
190              long offset = WsSendBuffer.Size;
191              WsSendBuffer.Resize(WsSendBuffer.Size + size);
192              int index = 0;
193              if (storeWSCloseStatus)
194              {
195                  index += 2;
196                  WsSendBuffer.Append((byte)((status >> 8) & 0xFF));
<span onclick='openModal()' class='match'>197                  WsSendBuffer.Append((byte)(status & 0xFF));
198              }
199              for (int i = index; i < size; i++)
</span>200                  WsSendBuffer.Data[offset + i] = (byte)(buffer[i] ^ WsSendMask[i % 4]);
201          }
202          public void PrepareReceiveFrame(byte[] buffer, long offset, long size)
203          {
204              lock (WsReceiveLock)
205              {
206                  int index = 0;
207                  if (WsFrameReceived)
208                  {
209                      WsFrameReceived = false;
210                      WsHeaderSize = 0;
211                      WsPayloadSize = 0;
212                      WsReceiveFrameBuffer.Clear();
213                      Array.Clear(WsReceiveMask, 0, WsReceiveMask.Length);
214                  }
215                  if (WsFinalReceived)
216                  {
217                      WsFinalReceived = false;
218                      WsReceiveFinalBuffer.Clear();
219                  }
220                  while (size > 0)
221                  {
222                      if (WsFrameReceived)
223                      {
224                          WsFrameReceived = false;
225                          WsHeaderSize = 0;
226                          WsPayloadSize = 0;
227                          WsReceiveFrameBuffer.Clear();
228                          Array.Clear(WsReceiveMask, 0, WsReceiveMask.Length);
229                      }
230                      if (WsFinalReceived)
231                      {
232                          WsFinalReceived = false;
233                          WsReceiveFinalBuffer.Clear();
234                      }
235                      if (WsReceiveFrameBuffer.Size < 2)
236                      {
237                          for (long i = 0; i < 2; i++, index++, size--)
238                          {
239                              if (size == 0)
240                                  return;
241                              WsReceiveFrameBuffer.Append(buffer[offset + index]);
242                          }
243                      }
244                      byte opcode = (byte)(WsReceiveFrameBuffer[0] & 0x0F);
245                      bool fin = ((WsReceiveFrameBuffer[0] >> 7) & 0x01) != 0;
246                      bool mask = ((WsReceiveFrameBuffer[1] >> 7) & 0x01) != 0;
247                      long payload = WsReceiveFrameBuffer[1] & (~0x80);
248                      WsOpcode = (opcode != 0) ? opcode : WsOpcode;
249                      if (payload <= 125)
250                      {
251                          WsHeaderSize = 2 + (mask ? 4 : 0);
252                          WsPayloadSize = payload;
253                      }
254                      else if (payload == 126)
255                      {
256                          if (WsReceiveFrameBuffer.Size < 4)
257                          {
258                              for (long i = 0; i < 2; i++, index++, size--)
259                              {
260                                  if (size == 0)
261                                      return;
262                                  WsReceiveFrameBuffer.Append(buffer[offset + index]);
263                              }
264                          }
265                          payload = ((WsReceiveFrameBuffer[2] << 8) | (WsReceiveFrameBuffer[3] << 0));
266                          WsHeaderSize = 4 + (mask ? 4 : 0);
267                          WsPayloadSize = payload;
268                      }
269                      else if (payload == 127)
270                      {
271                          if (WsReceiveFrameBuffer.Size < 10)
272                          {
273                              for (long i = 0; i < 8; i++, index++, size--)
274                              {
275                                  if (size == 0)
276                                      return;
277                                  WsReceiveFrameBuffer.Append(buffer[offset + index]);
278                              }
279                          }
280                          payload = ((WsReceiveFrameBuffer[2] << 56) | (WsReceiveFrameBuffer[3] << 48) | (WsReceiveFrameBuffer[4] << 40) | (WsReceiveFrameBuffer[5] << 32) | (WsReceiveFrameBuffer[6] << 24) | (WsReceiveFrameBuffer[7] << 16) | (WsReceiveFrameBuffer[8] << 8) | (WsReceiveFrameBuffer[9] << 0));
281                          WsHeaderSize = 10 + (mask ? 4 : 0);
282                          WsPayloadSize = payload;
283                      }
284                      if (mask)
285                      {
286                          if (WsReceiveFrameBuffer.Size < WsHeaderSize)
287                          {
288                              for (long i = 0; i < 4; i++, index++, size--)
289                              {
290                                  if (size == 0)
291                                      return;
292                                  WsReceiveFrameBuffer.Append(buffer[offset + index]);
293                                  WsReceiveMask[i] = buffer[offset + index];
294                              }
295                          }
296                      }
297                      long total = WsHeaderSize + WsPayloadSize;
298                      long length = Math.Min(total - WsReceiveFrameBuffer.Size, size);
299                      WsReceiveFrameBuffer.Append(buffer[((int)offset + index)..((int)offset + index + (int)length)]);
300                      index += (int)length;
301                      size -= length;
302                      if (WsReceiveFrameBuffer.Size == total)
303                      {
304                          if (mask)
305                          {
306                              for (long i = 0; i < WsPayloadSize; i++)
307                                  WsReceiveFinalBuffer.Append((byte)(WsReceiveFrameBuffer[WsHeaderSize + i] ^ WsReceiveMask[i % 4]));
308                          }
309                          else
310                              WsReceiveFinalBuffer.Append(WsReceiveFrameBuffer.AsSpan().Slice((int)WsHeaderSize, (int)WsPayloadSize));
311                          WsFrameReceived = true;
312                          if (fin)
313                          {
314                              WsFinalReceived = true;
315                              switch (WsOpcode)
316                              {
317                                  case WS_PING:
318                                  {
319                                      _wsHandler.OnWsPing(WsReceiveFinalBuffer.Data, 0, WsReceiveFinalBuffer.Size);
320                                      break;
321                                  }
322                                  case WS_PONG:
323                                  {
324                                      _wsHandler.OnWsPong(WsReceiveFinalBuffer.Data, 0, WsReceiveFinalBuffer.Size);
325                                      break;
326                                  }
327                                  case WS_CLOSE:
328                                  {
329                                      int sindex = 0;
330                                      int status = 1000;
331                                      if (WsReceiveFinalBuffer.Size > 2)
332                                      {
333                                          sindex += 2;
334                                          status = ((WsReceiveFinalBuffer[0] << 8) | (WsReceiveFinalBuffer[1] << 0));
335                                      }
336                                      _wsHandler.OnWsClose(WsReceiveFinalBuffer.Data, sindex, WsReceiveFinalBuffer.Size - sindex, status);
337                                      break;
338                                  }
339                                  case WS_BINARY:
340                                  case WS_TEXT:
341                                  {
342                                      _wsHandler.OnWsReceived(WsReceiveFinalBuffer.Data, 0, WsReceiveFinalBuffer.Size);
343                                      break;
344                                  }
345                              }
346                          }
347                      }
348                  }
349              }
350          }
351          public long RequiredReceiveFrameSize()
352          {
353              lock (WsReceiveLock)
354              {
355                  if (WsFrameReceived)
356                      return 0;
357                  if (WsReceiveFrameBuffer.Size < 2)
358                      return 2 - WsReceiveFrameBuffer.Size;
359                  bool mask = ((WsReceiveFrameBuffer[1] >> 7) & 0x01) != 0;
360                  long payload = WsReceiveFrameBuffer[1] & (~0x80);
361                  if ((payload == 126) && (WsReceiveFrameBuffer.Size < 4))
362                      return 4 - WsReceiveFrameBuffer.Size;
363                  if ((payload == 127) && (WsReceiveFrameBuffer.Size < 10))
364                      return 10 - WsReceiveFrameBuffer.Size;
365                  if ((mask) && (WsReceiveFrameBuffer.Size < WsHeaderSize))
366                      return WsHeaderSize - WsReceiveFrameBuffer.Size;
367                  return WsHeaderSize + WsPayloadSize - WsReceiveFrameBuffer.Size;
368              }
369          }
370          public void ClearWsBuffers()
371          {
372              bool acquiredReceiveLock = false;
373              try
374              {
375                  Monitor.TryEnter(WsReceiveLock, ref acquiredReceiveLock);
376                  if (acquiredReceiveLock)
377                  {
378                      WsFrameReceived = false;
379                      WsFinalReceived = false;
380                      WsHeaderSize = 0;
381                      WsPayloadSize = 0;
382                      WsReceiveFrameBuffer.Clear();
383                      WsReceiveFinalBuffer.Clear();
384                      Array.Clear(WsReceiveMask, 0, WsReceiveMask.Length);
385                  }
386              }
387              finally
388              {
389                  if (acquiredReceiveLock)
390                      Monitor.Exit(WsReceiveLock);
391              }
392              lock (WsSendLock)
393              {
394                  WsSendBuffer.Clear();
395                  Array.Clear(WsSendMask, 0, WsSendMask.Length);
396              }
397          }
398          public void InitWsNonce() => WsRandom.NextBytes(WsNonce);
399          internal bool WsHandshaked;
400          internal bool WsFrameReceived;
401          internal bool WsFinalReceived;
402          internal byte WsOpcode;
403          internal long WsHeaderSize;
404          internal long WsPayloadSize;
405          internal readonly object WsReceiveLock = new object();
406          internal readonly Buffer WsReceiveFrameBuffer = new Buffer();
407          internal readonly Buffer WsReceiveFinalBuffer = new Buffer();
408          internal readonly byte[] WsReceiveMask = new byte[4];
409          internal readonly object WsSendLock = new object();
410          internal readonly Buffer WsSendBuffer = new Buffer();
411          internal readonly byte[] WsSendMask = new byte[4];
412          internal readonly Random WsRandom = new Random();
413          internal readonly byte[] WsNonce = new byte[16];
414      }
415  }
</code></pre>
        </div>
        <div class="column">
            <h3>NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WebSocket.cs</h3>
            <pre><code>1  using System;
2  using System.Text;
3  using System.Security.Cryptography;
4  using System.Collections.Generic;
5  using System.Threading;
6  namespace NetCoreServer
7  {
8      public class WebSocket : IWebSocket
9      {
10          private readonly IWebSocket _wsHandler;
11          public WebSocket(IWebSocket wsHandler) { _wsHandler = wsHandler; ClearWsBuffers(); InitWsNonce(); }
12          public const byte WS_FIN = 0x80;
13          public const byte WS_TEXT = 0x01;
14          public const byte WS_BINARY = 0x02;
15          public const byte WS_CLOSE = 0x08;
16          public const byte WS_PING = 0x09;
17          public const byte WS_PONG = 0x0A;
18          public bool PerformClientUpgrade(HttpResponse response, Guid id)
19          {
20              if (response.Status != 101)
21                  return false;
22              bool error = false;
23              bool accept = false;
24              bool connection = false;
25              bool upgrade = false;
26              for (int i = 0; i < response.Headers; i++)
27              {
28                  var header = response.Header(i);
29                  var key = header.Item1;
30                  var value = header.Item2;
31                  if (string.Compare(key, "Connection", StringComparison.OrdinalIgnoreCase) == 0)
32                  {
33                      if (string.Compare(value, "Upgrade", StringComparison.OrdinalIgnoreCase) != 0)
34                      {
35                          error = true;
36                          _wsHandler.OnWsError("Invalid WebSocket handshaked response: 'Connection' header value must be 'Upgrade'");
37                          break;
38                      }
39                      connection = true;
40                  }
41                  else if (string.Compare(key, "Upgrade", StringComparison.OrdinalIgnoreCase) == 0)
42                  {
43                      if (string.Compare(value, "websocket", StringComparison.OrdinalIgnoreCase) != 0)
44                      {
45                          error = true;
46                          _wsHandler.OnWsError("Invalid WebSocket handshaked response: 'Upgrade' header value must be 'websocket'");
47                          break;
48                      }
49                      upgrade = true;
50                  }
51                  else if (string.Compare(key, "Sec-WebSocket-Accept", StringComparison.OrdinalIgnoreCase) == 0)
52                  {
53                      string wskey = Convert.ToBase64String(WsNonce) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
54                      string wshash;
55                      using (SHA1 sha1 = SHA1.Create())
56                      {
57                          wshash = Encoding.UTF8.GetString(sha1.ComputeHash(Encoding.UTF8.GetBytes(wskey)));
58                      }
59                      wskey = Encoding.UTF8.GetString(Convert.FromBase64String(value));
60                      if (string.Compare(wskey, wshash, StringComparison.InvariantCulture) != 0)
61                      {
62                          error = true;
63                          _wsHandler.OnWsError("Invalid WebSocket handshaked response: 'Sec-WebSocket-Accept' value validation failed");
64                          break;
65                      }
66                      accept = true;
67                  }
68              }
69              if (!accept || !connection || !upgrade)
70              {
71                  if (!error)
72                      _wsHandler.OnWsError("Invalid WebSocket response");
73                  return false;
74              }
75              WsHandshaked = true;
76              WsRandom.NextBytes(WsSendMask);
77              _wsHandler.OnWsConnected(response);
78              return true;
79          }
80          public bool PerformServerUpgrade(HttpRequest request, HttpResponse response)
81          {
82              if (request.Method != "GET")
83                  return false;
84              bool error = false;
85              bool connection = false;
86              bool upgrade = false;
87              bool wsKey = false;
88              bool wsVersion = false;
89              string accept = "";
90              for (int i = 0; i < request.Headers; i++)
91              {
92                  var header = request.Header(i);
93                  var key = header.Item1;
94                  var value = header.Item2;
95                  if (string.Compare(key, "Connection", StringComparison.OrdinalIgnoreCase) == 0)
96                  {
97                      if ((string.Compare(value, "Upgrade", StringComparison.OrdinalIgnoreCase) != 0) && (string.Compare(value, "keep-alive, Upgrade", StringComparison.OrdinalIgnoreCase) != 0))
98                      {
99                          error = true;
100                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Connection' header value must be 'Upgrade' or 'keep-alive, Upgrade'");
101                          break;
102                      }
103                      connection = true;
104                  }
105                  else if (string.Compare(key, "Upgrade", StringComparison.OrdinalIgnoreCase) == 0)
106                  {
107                      if (string.Compare(value, "websocket", StringComparison.OrdinalIgnoreCase) != 0)
108                      {
109                          error = true;
110                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Upgrade' header value must be 'websocket'");
111                          break;
112                      }
113                      upgrade = true;
114                  }
115                  else if (string.Compare(key, "Sec-WebSocket-Key", StringComparison.OrdinalIgnoreCase) == 0)
116                  {
117                      if (string.IsNullOrEmpty(value))
118                      {
119                          error = true;
120                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Sec-WebSocket-Key' header value must be non empty");
121                          break;
122                      }
123                      string wskey = value + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
124                      byte[] wshash;
125                      using (SHA1 sha1 = SHA1.Create())
126                      {
127                          wshash = sha1.ComputeHash(Encoding.UTF8.GetBytes(wskey));
128                      }
129                      accept = Convert.ToBase64String(wshash);
130                      wsKey = true;
131                  }
132                  else if (string.Compare(key, "Sec-WebSocket-Version", StringComparison.OrdinalIgnoreCase) == 0)
133                  {
134                      if (string.Compare(value, "13", StringComparison.OrdinalIgnoreCase) != 0)
135                      {
136                          error = true;
137                          response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Sec-WebSocket-Version' header value must be '13'");
138                          break;
139                      }
140                      wsVersion = true;
141                  }
142              }
143              if (!connection && !upgrade && !wsKey && !wsVersion)
144                  return false;
145              if (!connection || !upgrade || !wsKey || !wsVersion)
146              {
147                  if (!error)
148                      response.MakeErrorResponse(400, "Invalid WebSocket response");
149                  _wsHandler.SendUpgrade(response);
150                  return false;
151              }
152              response.Clear();
153              response.SetBegin(101);
154              response.SetHeader("Connection", "Upgrade");
155              response.SetHeader("Upgrade", "websocket");
156              response.SetHeader("Sec-WebSocket-Accept", accept);
157              response.SetBody();
158              if (!_wsHandler.OnWsConnecting(request, response))
159                  return false;
160              _wsHandler.SendUpgrade(response);
161              WsHandshaked = true;
162              Array.Fill(WsSendMask, (byte)0);
163              _wsHandler.OnWsConnected(request);
164              return true;
165          }
166          public void PrepareSendFrame(byte opcode, bool mask, ReadOnlySpan<byte> buffer, int status = 0)
167          {
168              bool storeWSCloseStatus = ((opcode & WS_CLOSE) == WS_CLOSE) && (buffer.Length > 0);
169              long size = storeWSCloseStatus ? (buffer.Length + 2) : buffer.Length;
170              WsSendBuffer.Clear();
171              WsSendBuffer.Append(opcode);
172              if (size <= 125)
173                  WsSendBuffer.Append((byte)(((int)size & 0xFF) | (mask ? 0x80 : 0)));
174              else if (size <= 65535)
175              {
176                  WsSendBuffer.Append((byte)(126 | (mask ? 0x80 : 0)));
177                  WsSendBuffer.Append((byte)((size >> 8) & 0xFF));
<span onclick='openModal()' class='match'>178                  WsSendBuffer.Append((byte)(size & 0xFF));
179              }
180              else
</span>181              {
182                  WsSendBuffer.Append((byte)(127 | (mask ? 0x80 : 0)));
183                  for (int i = 7; i >= 0; i--)
184                      WsSendBuffer.Append((byte)((size >> (8 * i)) & 0xFF));
185              }
186              if (mask)
187              {
188                  WsSendBuffer.Append(WsSendMask);
189              }
190              long offset = WsSendBuffer.Size;
191              WsSendBuffer.Resize(WsSendBuffer.Size + size);
192              int index = 0;
193              if (storeWSCloseStatus)
194              {
195                  index += 2;
196                  WsSendBuffer.Append((byte)((status >> 8) & 0xFF));
197                  WsSendBuffer.Append((byte)(status & 0xFF));
198              }
199              for (int i = index; i < size; i++)
200                  WsSendBuffer.Data[offset + i] = (byte)(buffer[i] ^ WsSendMask[i % 4]);
201          }
202          public void PrepareReceiveFrame(byte[] buffer, long offset, long size)
203          {
204              lock (WsReceiveLock)
205              {
206                  int index = 0;
207                  if (WsFrameReceived)
208                  {
209                      WsFrameReceived = false;
210                      WsHeaderSize = 0;
211                      WsPayloadSize = 0;
212                      WsReceiveFrameBuffer.Clear();
213                      Array.Clear(WsReceiveMask, 0, WsReceiveMask.Length);
214                  }
215                  if (WsFinalReceived)
216                  {
217                      WsFinalReceived = false;
218                      WsReceiveFinalBuffer.Clear();
219                  }
220                  while (size > 0)
221                  {
222                      if (WsFrameReceived)
223                      {
224                          WsFrameReceived = false;
225                          WsHeaderSize = 0;
226                          WsPayloadSize = 0;
227                          WsReceiveFrameBuffer.Clear();
228                          Array.Clear(WsReceiveMask, 0, WsReceiveMask.Length);
229                      }
230                      if (WsFinalReceived)
231                      {
232                          WsFinalReceived = false;
233                          WsReceiveFinalBuffer.Clear();
234                      }
235                      if (WsReceiveFrameBuffer.Size < 2)
236                      {
237                          for (long i = 0; i < 2; i++, index++, size--)
238                          {
239                              if (size == 0)
240                                  return;
241                              WsReceiveFrameBuffer.Append(buffer[offset + index]);
242                          }
243                      }
244                      byte opcode = (byte)(WsReceiveFrameBuffer[0] & 0x0F);
245                      bool fin = ((WsReceiveFrameBuffer[0] >> 7) & 0x01) != 0;
246                      bool mask = ((WsReceiveFrameBuffer[1] >> 7) & 0x01) != 0;
247                      long payload = WsReceiveFrameBuffer[1] & (~0x80);
248                      WsOpcode = (opcode != 0) ? opcode : WsOpcode;
249                      if (payload <= 125)
250                      {
251                          WsHeaderSize = 2 + (mask ? 4 : 0);
252                          WsPayloadSize = payload;
253                      }
254                      else if (payload == 126)
255                      {
256                          if (WsReceiveFrameBuffer.Size < 4)
257                          {
258                              for (long i = 0; i < 2; i++, index++, size--)
259                              {
260                                  if (size == 0)
261                                      return;
262                                  WsReceiveFrameBuffer.Append(buffer[offset + index]);
263                              }
264                          }
265                          payload = ((WsReceiveFrameBuffer[2] << 8) | (WsReceiveFrameBuffer[3] << 0));
266                          WsHeaderSize = 4 + (mask ? 4 : 0);
267                          WsPayloadSize = payload;
268                      }
269                      else if (payload == 127)
270                      {
271                          if (WsReceiveFrameBuffer.Size < 10)
272                          {
273                              for (long i = 0; i < 8; i++, index++, size--)
274                              {
275                                  if (size == 0)
276                                      return;
277                                  WsReceiveFrameBuffer.Append(buffer[offset + index]);
278                              }
279                          }
280                          payload = ((WsReceiveFrameBuffer[2] << 56) | (WsReceiveFrameBuffer[3] << 48) | (WsReceiveFrameBuffer[4] << 40) | (WsReceiveFrameBuffer[5] << 32) | (WsReceiveFrameBuffer[6] << 24) | (WsReceiveFrameBuffer[7] << 16) | (WsReceiveFrameBuffer[8] << 8) | (WsReceiveFrameBuffer[9] << 0));
281                          WsHeaderSize = 10 + (mask ? 4 : 0);
282                          WsPayloadSize = payload;
283                      }
284                      if (mask)
285                      {
286                          if (WsReceiveFrameBuffer.Size < WsHeaderSize)
287                          {
288                              for (long i = 0; i < 4; i++, index++, size--)
289                              {
290                                  if (size == 0)
291                                      return;
292                                  WsReceiveFrameBuffer.Append(buffer[offset + index]);
293                                  WsReceiveMask[i] = buffer[offset + index];
294                              }
295                          }
296                      }
297                      long total = WsHeaderSize + WsPayloadSize;
298                      long length = Math.Min(total - WsReceiveFrameBuffer.Size, size);
299                      WsReceiveFrameBuffer.Append(buffer[((int)offset + index)..((int)offset + index + (int)length)]);
300                      index += (int)length;
301                      size -= length;
302                      if (WsReceiveFrameBuffer.Size == total)
303                      {
304                          if (mask)
305                          {
306                              for (long i = 0; i < WsPayloadSize; i++)
307                                  WsReceiveFinalBuffer.Append((byte)(WsReceiveFrameBuffer[WsHeaderSize + i] ^ WsReceiveMask[i % 4]));
308                          }
309                          else
310                              WsReceiveFinalBuffer.Append(WsReceiveFrameBuffer.AsSpan().Slice((int)WsHeaderSize, (int)WsPayloadSize));
311                          WsFrameReceived = true;
312                          if (fin)
313                          {
314                              WsFinalReceived = true;
315                              switch (WsOpcode)
316                              {
317                                  case WS_PING:
318                                  {
319                                      _wsHandler.OnWsPing(WsReceiveFinalBuffer.Data, 0, WsReceiveFinalBuffer.Size);
320                                      break;
321                                  }
322                                  case WS_PONG:
323                                  {
324                                      _wsHandler.OnWsPong(WsReceiveFinalBuffer.Data, 0, WsReceiveFinalBuffer.Size);
325                                      break;
326                                  }
327                                  case WS_CLOSE:
328                                  {
329                                      int sindex = 0;
330                                      int status = 1000;
331                                      if (WsReceiveFinalBuffer.Size > 2)
332                                      {
333                                          sindex += 2;
334                                          status = ((WsReceiveFinalBuffer[0] << 8) | (WsReceiveFinalBuffer[1] << 0));
335                                      }
336                                      _wsHandler.OnWsClose(WsReceiveFinalBuffer.Data, sindex, WsReceiveFinalBuffer.Size - sindex, status);
337                                      break;
338                                  }
339                                  case WS_BINARY:
340                                  case WS_TEXT:
341                                  {
342                                      _wsHandler.OnWsReceived(WsReceiveFinalBuffer.Data, 0, WsReceiveFinalBuffer.Size);
343                                      break;
344                                  }
345                              }
346                          }
347                      }
348                  }
349              }
350          }
351          public long RequiredReceiveFrameSize()
352          {
353              lock (WsReceiveLock)
354              {
355                  if (WsFrameReceived)
356                      return 0;
357                  if (WsReceiveFrameBuffer.Size < 2)
358                      return 2 - WsReceiveFrameBuffer.Size;
359                  bool mask = ((WsReceiveFrameBuffer[1] >> 7) & 0x01) != 0;
360                  long payload = WsReceiveFrameBuffer[1] & (~0x80);
361                  if ((payload == 126) && (WsReceiveFrameBuffer.Size < 4))
362                      return 4 - WsReceiveFrameBuffer.Size;
363                  if ((payload == 127) && (WsReceiveFrameBuffer.Size < 10))
364                      return 10 - WsReceiveFrameBuffer.Size;
365                  if ((mask) && (WsReceiveFrameBuffer.Size < WsHeaderSize))
366                      return WsHeaderSize - WsReceiveFrameBuffer.Size;
367                  return WsHeaderSize + WsPayloadSize - WsReceiveFrameBuffer.Size;
368              }
369          }
370          public void ClearWsBuffers()
371          {
372              bool acquiredReceiveLock = false;
373              try
374              {
375                  Monitor.TryEnter(WsReceiveLock, ref acquiredReceiveLock);
376                  if (acquiredReceiveLock)
377                  {
378                      WsFrameReceived = false;
379                      WsFinalReceived = false;
380                      WsHeaderSize = 0;
381                      WsPayloadSize = 0;
382                      WsReceiveFrameBuffer.Clear();
383                      WsReceiveFinalBuffer.Clear();
384                      Array.Clear(WsReceiveMask, 0, WsReceiveMask.Length);
385                  }
386              }
387              finally
388              {
389                  if (acquiredReceiveLock)
390                      Monitor.Exit(WsReceiveLock);
391              }
392              lock (WsSendLock)
393              {
394                  WsSendBuffer.Clear();
395                  Array.Clear(WsSendMask, 0, WsSendMask.Length);
396              }
397          }
398          public void InitWsNonce() => WsRandom.NextBytes(WsNonce);
399          internal bool WsHandshaked;
400          internal bool WsFrameReceived;
401          internal bool WsFinalReceived;
402          internal byte WsOpcode;
403          internal long WsHeaderSize;
404          internal long WsPayloadSize;
405          internal readonly object WsReceiveLock = new object();
406          internal readonly Buffer WsReceiveFrameBuffer = new Buffer();
407          internal readonly Buffer WsReceiveFinalBuffer = new Buffer();
408          internal readonly byte[] WsReceiveMask = new byte[4];
409          internal readonly object WsSendLock = new object();
410          internal readonly Buffer WsSendBuffer = new Buffer();
411          internal readonly byte[] WsSendMask = new byte[4];
412          internal readonly Random WsRandom = new Random();
413          internal readonly byte[] WsNonce = new byte[16];
414      }
415  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WebSocket.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from NetCoreServer-MDEwOlJlcG9zaXRvcnkxNjYxMjMxNjQ=-flat-WebSocket.cs</div>
                </div>
                <div class="column column_space"><pre><code>197                  WsSendBuffer.Append((byte)(status & 0xFF));
198              }
199              for (int i = index; i < size; i++)
</pre></code></div>
                <div class="column column_space"><pre><code>178                  WsSendBuffer.Append((byte)(size & 0xFF));
179              }
180              else
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    