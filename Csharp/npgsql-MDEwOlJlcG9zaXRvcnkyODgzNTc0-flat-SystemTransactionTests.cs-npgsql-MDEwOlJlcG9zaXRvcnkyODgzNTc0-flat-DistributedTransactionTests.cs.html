
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-SystemTransactionTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading;
4  using System.Transactions;
5  using NUnit.Framework;
6  using static Npgsql.Tests.TestUtil;
7  namespace Npgsql.Tests;
8  public class SystemTransactionTests : TestBase
9  {
10      [Test, Description("Single connection enlisting explicitly, committing")]
11      public void Explicit_enlist()
12      {
13          var dataSource = EnlistOffDataSource;
14          var tableName = CreateTempTable(dataSource, "name TEXT");
15          using var conn = dataSource.OpenConnection();
16          using (var scope = new TransactionScope())
17          {
18              conn.EnlistTransaction(Transaction.Current);
19              Assert.That(conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test')"), Is.EqualTo(1), "Unexpected insert rowcount");
20              AssertNoDistributedIdentifier();
21              AssertNoPreparedTransactions();
22              scope.Complete();
23          }
24          AssertNoDistributedIdentifier();
25          AssertNoPreparedTransactions();
26          using (var tx = conn.BeginTransaction())
27          {
28              Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(1), "Unexpected data count");
29              tx.Rollback();
30          }
31      }
32      [Test, Description("Single connection enlisting implicitly, committing")]
33      public void Implicit_enlist()
34      {
35          var dataSource = EnlistOnDataSource;
36          var tableName = CreateTempTable(dataSource, "name TEXT");
37          using var conn = dataSource.CreateConnection();
38          using (var scope = new TransactionScope())
39          {
40              conn.Open();
41              Assert.That(conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test')"), Is.EqualTo(1), "Unexpected insert rowcount");
42              AssertNoDistributedIdentifier();
43              AssertNoPreparedTransactions();
44              scope.Complete();
45          }
46          using (var tx = conn.BeginTransaction())
47          {
48              Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(1), "Unexpected data count");
49              tx.Rollback();
50          }
51      }
52      [Test]
53      public void Enlist_Off()
54      {
55          var dataSource = EnlistOffDataSource;
56          var tableName = CreateTempTable(dataSource, "name TEXT");
57          using (new TransactionScope())
58          using (var conn1 = dataSource.OpenConnection())
59          using (var conn2 = dataSource.OpenConnection())
60          {
61              Assert.That(conn1.EnlistedTransaction, Is.Null);
62              Assert.That(conn1.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test')"), Is.EqualTo(1), "Unexpected insert rowcount");
63              Assert.That(conn2.ExecuteScalar($"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(1), "Unexpected data count");
64          }
65          using (var conn3 = dataSource.OpenConnection())
66          {
67              Assert.That(conn3.ExecuteScalar($"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(1), "Insert unexpectedly rollback-ed");
68          }
69      }
70      [Test, Description("Single connection enlisting explicitly, rollback")]
71      public void Rollback_explicit_enlist()
72      {
73          using var dataSource = CreateDataSource();
74          var tableName = CreateTempTable(dataSource, "name TEXT");
75          using var conn = dataSource.OpenConnection();
76          using (new TransactionScope())
77          {
78              conn.EnlistTransaction(Transaction.Current);
79              Assert.That(conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test')"), Is.EqualTo(1), "Unexpected insert rowcount");
80          }
81          AssertNoDistributedIdentifier();
82          AssertNoPreparedTransactions();
83          using (var tx = conn.BeginTransaction())
84          {
85              Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(0), "Unexpected data count");
86              tx.Rollback();
87          }
88      }
89      [Test, Description("Single connection enlisting implicitly, rollback")]
90      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/2408")]
91      public void Rollback_implicit_enlist([Values(true, false)] bool pooling)
92      {
93          using var dataSource = CreateDataSource(csb => csb.Pooling = pooling);
94          var tableName = CreateTempTable(dataSource, "name TEXT");
95          using (new TransactionScope())
96          using (var conn = dataSource.OpenConnection())
97          {
98              Assert.That(conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test')"), Is.EqualTo(1), "Unexpected insert rowcount");
99              AssertNoDistributedIdentifier();
100              AssertNoPreparedTransactions();
101          }
102          AssertNumberOfRows(0, tableName);
103      }
104      [Test]
105      public void Two_consecutive_connections()
106      {
107          var dataSource = EnlistOnDataSource;
108          var tableName = CreateTempTable(dataSource, "name TEXT");
109          using (var scope = new TransactionScope())
110          {
111              using (var conn1 = dataSource.OpenConnection())
112              {
113                  Assert.That(conn1.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test1')"), Is.EqualTo(1), "Unexpected first insert rowcount");
114              }
115              using (var conn2 = dataSource.OpenConnection())
116              {
117                  Assert.That(conn2.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test2')"), Is.EqualTo(1), "Unexpected second insert rowcount");
118              }
119              AssertNoDistributedIdentifier();
120              AssertNoPreparedTransactions();
121              scope.Complete();
122          }
123          AssertNumberOfRows(2, tableName);
124      }
125      [Test]
126      public void Close_connection()
127      {
128          using var dataSource = CreateDataSource(csb => csb.Enlist = true);
129          var tableName = CreateTempTable(dataSource, "name TEXT");
130          using (var scope = new TransactionScope())
131          using (var conn = dataSource.OpenConnection())
132          {
133              Assert.That(conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test')"), Is.EqualTo(1), "Unexpected insert rowcount");
134              conn.Close();
135              AssertNoDistributedIdentifier();
136              AssertNoPreparedTransactions();
137              scope.Complete();
138          }
139          AssertNumberOfRows(1, tableName);
140          Assert.That(dataSource.Statistics.Idle, Is.EqualTo(1));
141      }
142      [Test]
143      public void Enlist_to_two_transactions()
144      {
145          var dataSource = EnlistOffDataSource;
146          var tableName = CreateTempTable(dataSource, "name TEXT");
147          using var conn = dataSource.OpenConnection();
148          var ctx = new CommittableTransaction();
149          conn.EnlistTransaction(ctx);
150          Assert.That(() => conn.EnlistTransaction(new CommittableTransaction()), Throws.Exception.TypeOf<InvalidOperationException>());
151          ctx.Rollback();
152          using var tx = conn.BeginTransaction();
153          Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(0));
154          tx.Rollback();
155      }
156      [Test]
157      public void Enlist_twice_to_same_transaction()
158      {
159          var dataSource = EnlistOffDataSource;
160          var tableName = CreateTempTable(dataSource, "name TEXT");
161          using var conn = dataSource.OpenConnection();
162          var ctx = new CommittableTransaction();
163          conn.EnlistTransaction(ctx);
164          conn.EnlistTransaction(ctx);
165          ctx.Rollback();
166          using var tx = conn.BeginTransaction();
167          Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(0));
168          tx.Rollback();
169      }
170      [Test]
171      public void Scope_after_scope()
172      {
173          var dataSource = EnlistOffDataSource;
174          var tableName = CreateTempTable(dataSource, "name TEXT");
175          using var conn = dataSource.OpenConnection();
176          using (new TransactionScope())
177              conn.EnlistTransaction(Transaction.Current);
178          using (new TransactionScope())
179              conn.EnlistTransaction(Transaction.Current);
180          using (var tx = conn.BeginTransaction())
181          {
182              Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(0));
183              tx.Rollback();
184          }
185      }
186      [Test]
187      public void Reuse_connection()
188      {
189          using var dataSource = CreateDataSource(csb => csb.Enlist = true);
190          var tableName = CreateTempTable(dataSource, "name TEXT");
191          using (var scope = new TransactionScope())
192          using (var conn = dataSource.CreateConnection())
193          {
194              conn.Open();
195              var processId = conn.ProcessID;
196              conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test1')");
197              conn.Close();
198              conn.Open();
199              Assert.That(conn.ProcessID, Is.EqualTo(processId));
200              conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test2')");
201              conn.Close();
202              scope.Complete();
203          }
204          AssertNumberOfRows(2, tableName);
205      }
206      [Test]
207      public void Reuse_connection_rollback()
208      {
209          using var dataSource = CreateDataSource(csb => csb.Enlist = true);
210          var tableName = CreateTempTable(dataSource, "name TEXT");
211          using (new TransactionScope())
212          using (var conn = dataSource.CreateConnection())
213          {
214              conn.Open();
215              var processId = conn.ProcessID;
216              conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test1')");
217              conn.Close();
218              conn.Open();
219              Assert.That(conn.ProcessID, Is.EqualTo(processId));
220              conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test2')");
221              conn.Close();
222          }
223          AssertNumberOfRows(0, tableName);
224      }
225      [Test, Ignore("Timeout doesn't seem to fire on .NET Core / Linux")]
226      public void Timeout_triggers_rollback_while_busy()
227      {
228          var dataSource = EnlistOffDataSource;
229          var tableName = CreateTempTable(dataSource, "name TEXT");
230          using (var conn = dataSource.OpenConnection())
231          {
232              using (new TransactionScope(TransactionScopeOption.Required, TimeSpan.FromSeconds(1)))
233              {
234                  conn.EnlistTransaction(Transaction.Current);
235                  Assert.That(() => CreateSleepCommand(conn, 5).ExecuteNonQuery(),
236                      Throws.Exception.TypeOf<PostgresException>()
237                          .With.Property(nameof(PostgresException.SqlState))
238                          .EqualTo(PostgresErrorCodes.QueryCanceled));
239              }
240          }
241          AssertNumberOfRows(0, tableName);
242      }
243      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1579")]
244      public void Schema_connection_should_not_enlist()
245      {
246          var dataSource = EnlistOnDataSource;
247          var tableName = CreateTempTable(dataSource, "name TEXT");
248          using var tran = new TransactionScope();
249          using var conn = dataSource.OpenConnection();
250          using var cmd = new NpgsqlCommand($"SELECT * FROM {tableName}", conn);
251          using var reader = cmd.ExecuteReader(CommandBehavior.KeyInfo);
252          reader.GetColumnSchema();
253          AssertNoDistributedIdentifier();
254          AssertNoPreparedTransactions();
255          tran.Complete();
256      }
257      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1737")]
258      public void Single_unpooled_connection()
259      {
260          using var dataSource = CreateDataSource(csb =>
261          {
262              csb.Pooling = false;
263              csb.Enlist = true;
264          });
265          using var scope = new TransactionScope();
266          using (var conn = dataSource.OpenConnection())
267          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
268              cmd.ExecuteNonQuery();
269          scope.Complete();
270      }
271      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4963")]
272      public void Single_unpooled_closed_connection()
273      {
274          using var dataSource = CreateDataSource(csb =>
275          {
276              csb.Pooling = false;
277              csb.Enlist = true;
278          });
279          using (var scope = new TransactionScope())
280          using (var conn = dataSource.OpenConnection())
281          using (var cmd = new NpgsqlCommand("SELECT 1", conn))
282          {
283              cmd.ExecuteNonQuery();
284              conn.Close();
285              Assert.That(dataSource.Statistics.Total, Is.EqualTo(1));
286              scope.Complete();
287          }
288          Assert.That(dataSource.Statistics.Total, Is.EqualTo(0));
289      }
290      [Test]
291      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3863")]
292      public void Break_connector_while_in_transaction_scope_with_rollback([Values] bool pooling)
293      {
294          using var dataSource = CreateDataSource(csb => csb.Pooling = pooling);
295          using var scope = new TransactionScope();
296          var conn = dataSource.OpenConnection();
297          conn.ExecuteNonQuery("SELECT 1");
298          conn.Connector!.Break(new Exception(nameof(Break_connector_while_in_transaction_scope_with_rollback)));
299      }
300      [Test]
301      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3863")]
302      public void Break_connector_while_in_transaction_scope_with_commit([Values] bool pooling)
303      {
304          using var dataSource = CreateDataSource(csb => csb.Pooling = pooling);
305          var ex = Assert.Throws<TransactionInDoubtException>(() =>
306          {
307              using var scope = new TransactionScope();
308              var conn = dataSource.OpenConnection();
309              conn.ExecuteNonQuery("SELECT 1");
310              conn.Connector!.Break(new Exception(nameof(Break_connector_while_in_transaction_scope_with_commit)));
311              scope.Complete();
312          })!;
313          Assert.That(ex.InnerException, Is.TypeOf<ObjectDisposedException>());
314          Assert.That(ex.InnerException!.InnerException, Is.TypeOf<Exception>());
315          Assert.That(ex.InnerException!.InnerException!.Message, Is.EqualTo(nameof(Break_connector_while_in_transaction_scope_with_commit)));
316      }
317      [Test]
318      [IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/4085")]
319      public void Open_connection_with_enlist_and_aborted_TransactionScope()
320      {
321          var dataSource = EnlistOnDataSource;
322          for (var i = 0; i < 2; i++)
323          {
324              using var outerScope = new TransactionScope();
325              try
326              {
327                  using var innerScope = new TransactionScope();
328                  throw new Exception("Random exception to abort the transaction scope");
329              }
330              catch (Exception)
331              {
332              }
333              var ex = Assert.Throws<TransactionException>(() => dataSource.OpenConnection())!;
334              Assert.That(ex.Message, Is.EqualTo("The operation is not valid for the state of the transaction."));
335          }
336      }
337      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/1594")]
338      public void Bug1594()
339      {
340          var dataSource = EnlistOnDataSource;
341          var tableName = CreateTempTable(dataSource, "name TEXT");
342          using var outerScope = new TransactionScope();
343          using (var conn = dataSource.OpenConnection())
344          using (var innerScope1 = new TransactionScope())
345          {
346              conn.ExecuteNonQuery(@$"INSERT INTO {tableName} (name) VALUES ('test1')");
347              innerScope1.Complete();
348          }
349          using (dataSource.OpenConnection())
350          using (new TransactionScope())
351          {
352          }
353      }
354      #region Utilities
355      void AssertNoPreparedTransactions()
356          => Assert.That(GetNumberOfPreparedTransactions(), Is.EqualTo(0), "Prepared transactions found");
357      int GetNumberOfPreparedTransactions()
358      {
359          var dataSource = EnlistOffDataSource;
360          using var conn = dataSource.OpenConnection();
361          using var cmd = new NpgsqlCommand("SELECT COUNT(*) FROM pg_prepared_xacts WHERE database = @database", conn);
362          cmd.Parameters.Add(new NpgsqlParameter("database", conn.Database));
363          return (int)(long)cmd.ExecuteScalar()!;
364      }
365      void AssertNumberOfRows(int expected, string tableName)
366      {
367          using var conn = OpenConnection();
368          Assert.That(conn.ExecuteScalar(@$"SELECT COUNT(*) FROM {tableName}"), Is.EqualTo(expected), "Unexpected data count");
369      }
370      static void AssertNoDistributedIdentifier()
371          => Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.EqualTo(Guid.Empty), "Distributed identifier found");
372      #endregion Utilities
373      #region Setup
374      NpgsqlDataSource EnlistOnDataSource { get; set; } = default!;
375      NpgsqlDataSource EnlistOffDataSource { get; set; } = default!;
376      [OneTimeSetUp]
377      public void OneTimeSetUp()
378      {
379          EnlistOnDataSource = CreateDataSource(csb => csb.Enlist = true);
<span onclick='openModal()' class='match'>380          EnlistOffDataSource = CreateDataSource(csb => csb.Enlist = false);
381      }
382      [OneTimeTearDown]
383      public void OnTimeTearDown()
384      {
385          EnlistOnDataSource?.Dispose();
386          EnlistOnDataSource = null!;
387          EnlistOffDataSource?.Dispose();
388          EnlistOffDataSource = null!;
389      }
390      internal static string CreateTempTable(NpgsqlDataSource dataSource, string columns)
</span>391      {
392          var tableName = "temp_table" + Interlocked.Increment(ref _tempTableCounter);
393          dataSource.ExecuteNonQuery(@$"
394  START TRANSACTION; SELECT pg_advisory_xact_lock(0);
395  DROP TABLE IF EXISTS {tableName} CASCADE;
396  COMMIT;
397  CREATE TABLE {tableName} ({columns})");
398          return tableName;
399      }
400      #endregion
401  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</h3>
            <pre><code>1  #if NET7_0_OR_GREATER
2  using System;
3  using System.Collections.Concurrent;
4  using System.Collections.Generic;
5  using System.Runtime.InteropServices;
6  using System.Text;
7  using System.Threading;
8  using System.Transactions;
9  using NUnit.Framework;
10  using static Npgsql.Tests.TestUtil;
11  namespace Npgsql.Tests;
12  [NonParallelizable]
13  public class DistributedTransactionTests : TestBase
14  {
15      [Test]
16      public void Two_connections_rollback_implicit_enlistment()
17      {
18          using var adminConn = OpenConnection();
19          var table = CreateTempTable(adminConn, "name TEXT");
20          var dataSource = EnlistOnDataSource;
21          using (new TransactionScope())
22          using (var conn1 = dataSource.OpenConnection())
23          using (var conn2 = dataSource.OpenConnection())
24          {
25              conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
26              conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')");
27          }
28          Retry(() =>
29          {
30              AssertNoDistributedIdentifier();
31              AssertNoPreparedTransactions();
32              AssertNumberOfRows(adminConn, table, 0);
33          });
34      }
35      [Test]
36      public void Two_connections_rollback_explicit_enlistment()
37      {
38          using var adminConn = OpenConnection();
39          var table = CreateTempTable(adminConn, "name TEXT");
40          var dataSource = EnlistOffDataSource;
41          using (var conn1 = dataSource.OpenConnection())
42          using (var conn2 = dataSource.OpenConnection())
43          using (new TransactionScope())
44          {
45              conn1.EnlistTransaction(Transaction.Current);
46              conn2.EnlistTransaction(Transaction.Current);
47              Assert.That(conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')"), Is.EqualTo(1), "Unexpected first insert rowcount");
48              Assert.That(conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')"), Is.EqualTo(1), "Unexpected second insert rowcount");
49          }
50          Retry(() =>
51          {
52              AssertNoDistributedIdentifier();
53              AssertNoPreparedTransactions();
54              AssertNumberOfRows(adminConn, table, 0);
55          });
56      }
57      [Test]
58      public void Two_connections_commit()
59      {
60          using var adminConn = OpenConnection();
61          var table = CreateTempTable(adminConn, "name TEXT");
62          var dataSource = EnlistOnDataSource;
63          using (var scope = new TransactionScope())
64          using (var conn1 = dataSource.OpenConnection())
65          using (var conn2 = dataSource.OpenConnection())
66          {
67              conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
68              conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')");
69              scope.Complete();
70          }
71          Retry(() =>
72          {
73              AssertNoDistributedIdentifier();
74              AssertNoPreparedTransactions();
75              AssertNumberOfRows(adminConn, table, 2);
76          });
77      }
78      [Test]
79      public void Two_connections_with_failure()
80      {
81          using var dataSource = CreateDataSource(csb => csb.Enlist = true);
82          using var adminConn = dataSource.OpenConnection();
83          var table = CreateTempTable(adminConn, "name TEXT");
84          using var scope = new TransactionScope();
85          using var conn1 = dataSource.OpenConnection();
86          using var conn2 = dataSource.OpenConnection();
87          conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
88          conn2.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test2')");
89          conn1.ExecuteNonQuery($"SELECT pg_terminate_backend({conn2.ProcessID})");
90          scope.Complete();
91          Assert.That(() => scope.Dispose(), Throws.Exception.TypeOf<TransactionAbortedException>());
92          AssertNoDistributedIdentifier();
93          AssertNoPreparedTransactions();
94          AssertNumberOfRows(adminConn, table, 0);
95      }
96      [Test(Description = "Transaction race, bool distributed")]
97      [Explicit("Fails on Appveyor (https:&bsol;&bsol;ci.appveyor.com/project/roji/npgsql/build/3.3.0-250)")]
98      public void Transaction_race([Values(false, true)] bool distributed)
99      {
100          using var adminConn = OpenConnection();
101          var table = CreateTempTable(adminConn, "name TEXT");
102          var dataSource = EnlistOnDataSource;
103          for (var i = 1; i <= 100; i++)
104          {
105              var eventQueue = new ConcurrentQueue<TransactionEvent>();
106              try
107              {
108                  using (var tx = new TransactionScope())
109                  using (var conn1 = dataSource.OpenConnection())
110                  {
111                      eventQueue.Enqueue(new TransactionEvent("Scope started, connection enlisted"));
112                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
113                      eventQueue.Enqueue(new TransactionEvent("Insert done"));
114                      if (distributed)
115                      {
116                          EnlistResource.EscalateToDistributed(eventQueue);
117                          AssertHasDistributedIdentifier();
118                      }
119                      else
120                      {
121                          EnlistResource.EnlistVolatile(eventQueue);
122                          AssertNoDistributedIdentifier();
123                      }
124                      tx.Complete();
125                      eventQueue.Enqueue(new TransactionEvent("Scope completed"));
126                  }
127                  eventQueue.Enqueue(new TransactionEvent("Scope disposed"));
128                  AssertNoDistributedIdentifier();
129                  if (distributed)
130                  {
131                      const int maxLoop = 20;
132                      for (var j = 0; j < maxLoop; j++)
133                      {
134                          Thread.Sleep(10);
135                          try
136                          {
137                              AssertNumberOfRows(adminConn, table, i);
138                              break;
139                          }
140                          catch
141                          {
142                              if (j == maxLoop - 1)
143                                  throw;
144                          }
145                      }
146                  }
147                  else
148                      AssertNumberOfRows(adminConn, table, i);
149              }
150              catch (Exception ex)
151              {
152                  Assert.Fail(
153                      @"Failed at iteration {0}.
154  Events:
155  {1}
156  Exception {2}",
157                      i, FormatEventQueue(eventQueue), ex);
158              }
159          }
160      }
161      [Test(Description = "Connection reuse race after transaction, bool distributed"), Explicit]
162      public void Connection_reuse_race_after_transaction([Values(false, true)] bool distributed)
163      {
164          using var adminConn = OpenConnection();
165          var table = CreateTempTable(adminConn, "name TEXT");
166          var dataSource = EnlistOffDataSource;
167          for (var i = 1; i <= 100; i++)
168          {
169              var eventQueue = new ConcurrentQueue<TransactionEvent>();
170              try
171              {
172                  using var conn1 = dataSource.OpenConnection();
173                  using (var scope = new TransactionScope())
174                  {
175                      conn1.EnlistTransaction(Transaction.Current);
176                      eventQueue.Enqueue(new TransactionEvent("Scope started, connection enlisted"));
177                      if (distributed)
178                      {
179                          EnlistResource.EscalateToDistributed(eventQueue);
180                          AssertHasDistributedIdentifier();
181                      }
182                      else
183                      {
184                          EnlistResource.EnlistVolatile(eventQueue);
185                          AssertNoDistributedIdentifier();
186                      }
187                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
188                      eventQueue.Enqueue(new TransactionEvent("Insert done"));
189                      scope.Complete();
190                      eventQueue.Enqueue(new TransactionEvent("Scope completed"));
191                  }
192                  eventQueue.Enqueue(new TransactionEvent("Scope disposed"));
193                  Assert.DoesNotThrow(() => conn1.ExecuteScalar($"SELECT COUNT(*) FROM {table}"));
194              }
195              catch (Exception ex)
196              {
197                  Assert.Fail(
198                      @"Failed at iteration {0}.
199  Events:
200  {1}
201  Exception {2}",
202                      i, FormatEventQueue(eventQueue), ex);
203              }
204          }
205      }
206      [Test(Description = "Connection reuse race after rollback, bool distributed"), Explicit("Currently failing.")]
207      public void Connection_reuse_race_after_rollback([Values(false, true)] bool distributed)
208      {
209          using var adminConn = OpenConnection();
210          var table = CreateTempTable(adminConn, "name TEXT");
211          var dataSource = EnlistOffDataSource;
212          for (var i = 1; i <= 100; i++)
213          {
214              var eventQueue = new ConcurrentQueue<TransactionEvent>();
215              try
216              {
217                  using var conn1 = dataSource.OpenConnection();
218                  using (new TransactionScope())
219                  {
220                      conn1.EnlistTransaction(Transaction.Current);
221                      eventQueue.Enqueue(new TransactionEvent("Scope started, connection enlisted"));
222                      if (distributed)
223                      {
224                          EnlistResource.EscalateToDistributed(eventQueue);
225                          AssertHasDistributedIdentifier();
226                      }
227                      else
228                      {
229                          EnlistResource.EnlistVolatile(eventQueue);
230                          AssertNoDistributedIdentifier();
231                      }
232                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
233                      eventQueue.Enqueue(new TransactionEvent("Insert done"));
234                      eventQueue.Enqueue(new TransactionEvent("Scope not completed"));
235                  }
236                  eventQueue.Enqueue(new TransactionEvent("Scope disposed"));
237                  conn1.EnlistTransaction(null);
238                  eventQueue.Enqueue(new TransactionEvent("Connection enlisted with null"));
239                  Assert.DoesNotThrow(() => conn1.ExecuteScalar($"SELECT COUNT(*) FROM {table}"));
240              }
241              catch (Exception ex)
242              {
243                  Assert.Fail(
244                      @"Failed at iteration {0}.
245  Events:
246  {1}
247  Exception {2}",
248                      i, FormatEventQueue(eventQueue), ex);
249              }
250          }
251      }
252      [Test(Description = "Connection reuse race chaining transactions, bool distributed")]
253      [Explicit]
254      public void Connection_reuse_race_chaining_transaction([Values(false, true)] bool distributed)
255      {
256          using var adminConn = OpenConnection();
257          var table = CreateTempTable(adminConn, "name TEXT");
258          var dataSource = EnlistOffDataSource;
259          for (var i = 1; i <= 100; i++)
260          {
261              var eventQueue = new ConcurrentQueue<TransactionEvent>();
262              try
263              {
264                  using var conn1 = dataSource.OpenConnection();
265                  using (var scope = new TransactionScope())
266                  {
267                      eventQueue.Enqueue(new TransactionEvent("First scope started"));
268                      conn1.EnlistTransaction(Transaction.Current);
269                      eventQueue.Enqueue(new TransactionEvent("First scope, connection enlisted"));
270                      if (distributed)
271                      {
272                          EnlistResource.EscalateToDistributed(eventQueue);
273                          AssertHasDistributedIdentifier();
274                      }
275                      else
276                      {
277                          EnlistResource.EnlistVolatile(eventQueue);
278                          AssertNoDistributedIdentifier();
279                      }
280                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
281                      eventQueue.Enqueue(new TransactionEvent("First insert done"));
282                      scope.Complete();
283                      eventQueue.Enqueue(new TransactionEvent("First scope completed"));
284                  }
285                  eventQueue.Enqueue(new TransactionEvent("First scope disposed"));
286                  using (var scope = new TransactionScope())
287                  {
288                      eventQueue.Enqueue(new TransactionEvent("Second scope started"));
289                      conn1.EnlistTransaction(Transaction.Current);
290                      eventQueue.Enqueue(new TransactionEvent("Second scope, connection enlisted"));
291                      if (distributed)
292                      {
293                          EnlistResource.EscalateToDistributed(eventQueue);
294                          AssertHasDistributedIdentifier();
295                      }
296                      else
297                      {
298                          EnlistResource.EnlistVolatile(eventQueue);
299                          AssertNoDistributedIdentifier();
300                      }
301                      conn1.ExecuteNonQuery($"INSERT INTO {table} (name) VALUES ('test1')");
302                      eventQueue.Enqueue(new TransactionEvent("Second insert done"));
303                      scope.Complete();
304                      eventQueue.Enqueue(new TransactionEvent("Second scope completed"));
305                  }
306                  eventQueue.Enqueue(new TransactionEvent("Second scope disposed"));
307              }
308              catch (Exception ex)
309              {
310                  Assert.Fail(
311                      @"Failed at iteration {0}.
312  Events:
313  {1}
314  Exception {2}",
315                      i, FormatEventQueue(eventQueue), ex);
316              }
317          }
318      }
319      #region Utilities
320      static void Retry(Action action)
321      {
322          const int Retries = 50;
323          for (var i = 0; i < Retries; i++)
324          {
325              try
326              {
327                  action();
328                  return;
329              }
330              catch (AssertionException)
331              {
332                  if (i == Retries - 1)
333                  {
334                      throw;
335                  }
336                  Thread.Sleep(100);
337              }
338          }
339      }
340      void AssertNoPreparedTransactions()
341          => Assert.That(GetNumberOfPreparedTransactions(), Is.EqualTo(0), "Prepared transactions found");
342      int GetNumberOfPreparedTransactions()
343      {
344          var dataSource = EnlistOffDataSource;
345          using (var conn = dataSource.OpenConnection())
346          using (var cmd = new NpgsqlCommand("SELECT COUNT(*) FROM pg_prepared_xacts WHERE database = @database", conn))
347          {
348              cmd.Parameters.Add(new NpgsqlParameter("database", conn.Database));
349              return (int)(long)cmd.ExecuteScalar()!;
350          }
351      }
352      void AssertNumberOfRows(NpgsqlConnection connection, string table, int expected)
353          => Assert.That(connection.ExecuteScalar($"SELECT COUNT(*) FROM {table}"), Is.EqualTo(expected), "Unexpected data count");
354      static void AssertNoDistributedIdentifier()
355          => Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.EqualTo(Guid.Empty), "Distributed identifier found");
356      static void AssertHasDistributedIdentifier()
357          => Assert.That(Transaction.Current?.TransactionInformation.DistributedIdentifier ?? Guid.Empty, Is.Not.EqualTo(Guid.Empty), "Distributed identifier not found");
358      NpgsqlDataSource EnlistOnDataSource { get; set; } = default!;
359      NpgsqlDataSource EnlistOffDataSource { get; set; } = default!;
360      static string FormatEventQueue(ConcurrentQueue<TransactionEvent> eventQueue)
361      {
362          eventQueue.Enqueue(new TransactionEvent(@"-------------
363  Start formatting event queue, going to sleep a bit for late events
364  -------------"));
365          Thread.Sleep(20);
366          var eventsMessage = new StringBuilder();
367          foreach (var evt in eventQueue)
368          {
369              eventsMessage.AppendLine(evt.Message);
370          }
371          return eventsMessage.ToString();
372      }
373      public class EnlistResource : IEnlistmentNotification
374      {
375          public static int Counter { get; set; }
376          readonly bool _shouldRollBack;
377          readonly string _name;
378          readonly ConcurrentQueue<TransactionEvent>? _eventQueue;
379          public static void EnlistVolatile(ConcurrentQueue<TransactionEvent> eventQueue)
380              => EnlistVolatile(false, eventQueue);
381          public static void EnlistVolatile(bool shouldRollBack = false, ConcurrentQueue<TransactionEvent>? eventQueue = null)
382              => Enlist(false, shouldRollBack, eventQueue);
383          public static void EscalateToDistributed(ConcurrentQueue<TransactionEvent> eventQueue)
384              => EscalateToDistributed(false, eventQueue);
385          public static void EscalateToDistributed(bool shouldRollBack = false, ConcurrentQueue<TransactionEvent>? eventQueue = null)
386              => Enlist(true, shouldRollBack, eventQueue);
387          static void Enlist(bool durable, bool shouldRollBack, ConcurrentQueue<TransactionEvent>? eventQueue)
388          {
389              Counter++;
390              var name = $"{(durable ? "Durable" : "Volatile")} resource {Counter}";
391              var resource = new EnlistResource(shouldRollBack, name, eventQueue);
392              if (durable)
393                  Transaction.Current!.EnlistDurable(Guid.NewGuid(), resource, EnlistmentOptions.None);
394              else
395                  Transaction.Current!.EnlistVolatile(resource, EnlistmentOptions.None);
396              Transaction.Current.TransactionCompleted += resource.Current_TransactionCompleted!;
397              eventQueue?.Enqueue(new TransactionEvent(name + ": enlisted"));
398          }
399          EnlistResource(bool shouldRollBack, string name, ConcurrentQueue<TransactionEvent>? eventQueue)
400          {
401              _shouldRollBack = shouldRollBack;
402              _name = name;
403              _eventQueue = eventQueue;
404          }
405          public void Prepare(PreparingEnlistment preparingEnlistment)
406          {
407              _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase start"));
408              Thread.Sleep(1);
409              if (_shouldRollBack)
410              {
411                  _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase, calling rollback-ed"));
412                  preparingEnlistment.ForceRollback();
413              }
414              else
415              {
416                  _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase, calling prepared"));
417                  preparingEnlistment.Prepared();
418              }
419              Thread.Sleep(1);
420              _eventQueue?.Enqueue(new TransactionEvent(_name + ": prepare phase end"));
421          }
422          public void Commit(Enlistment enlistment)
423          {
424              _eventQueue?.Enqueue(new TransactionEvent(_name + ": commit phase start"));
425              Thread.Sleep(1);
426              _eventQueue?.Enqueue(new TransactionEvent(_name + ": commit phase, calling done"));
427              enlistment.Done();
428              Thread.Sleep(1);
429              _eventQueue?.Enqueue(new TransactionEvent(_name + ": commit phase end"));
430          }
431          public void Rollback(Enlistment enlistment)
432          {
433              _eventQueue?.Enqueue(new TransactionEvent(_name + ": rollback phase start"));
434              Thread.Sleep(1);
435              _eventQueue?.Enqueue(new TransactionEvent(_name + ": rollback phase, calling done"));
436              enlistment.Done();
437              Thread.Sleep(1);
438              _eventQueue?.Enqueue(new TransactionEvent(_name + ": rollback phase end"));
439          }
440          public void InDoubt(Enlistment enlistment)
441          {
442              _eventQueue?.Enqueue(new TransactionEvent(_name + ": in-doubt phase start"));
443              Thread.Sleep(1);
444              _eventQueue?.Enqueue(new TransactionEvent(_name + ": in-doubt phase, calling done"));
445              enlistment.Done();
446              Thread.Sleep(1);
447              _eventQueue?.Enqueue(new TransactionEvent(_name + ": in-doubt phase end"));
448          }
449          void Current_TransactionCompleted(object sender, TransactionEventArgs e)
450          {
451              _eventQueue?.Enqueue(new TransactionEvent(_name + ": transaction completed start"));
452              Thread.Sleep(1);
453              _eventQueue?.Enqueue(new TransactionEvent(_name + ": transaction completed middle"));
454              Thread.Sleep(1);
455              _eventQueue?.Enqueue(new TransactionEvent(_name + ": transaction completed end"));
456          }
457      }
458      public class TransactionEvent
459      {
460          public TransactionEvent(string message)
461              => Message = $"{message} (TId {Thread.CurrentThread.ManagedThreadId})";
462          public string Message { get; }
463      }
464      #endregion Utilities
465      #region Setup
466      [OneTimeSetUp]
467      public void OneTimeSetUp()
468      {
469          if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
470          {
471              Assert.Ignore("Distributed transactions are only supported on Windows");
472              return;
473          }
474          using var connection = OpenConnection();
475          if (int.Parse((string)connection.ExecuteScalar("SHOW max_prepared_transactions")!) == 0)
476          {
477              IgnoreExceptOnBuildServer("max_prepared_transactions is set to 0 in your postgresql.conf");
478              return;
479          }
480          var lingeringTransactions = new List<string>();
481          using (var cmd = new NpgsqlCommand("SELECT gid FROM pg_prepared_xacts WHERE database=@database", connection))
482          {
483              cmd.Parameters.AddWithValue("database", new NpgsqlConnectionStringBuilder(ConnectionString).Database!);
484              using var reader = cmd.ExecuteReader();
485              while (reader.Read())
486                  lingeringTransactions.Add(reader.GetString(0));
487          }
488          foreach (var xactGid in lingeringTransactions)
489              connection.ExecuteNonQuery($"ROLLBACK PREPARED '{xactGid}'");
490          EnlistOnDataSource = CreateDataSource(csb => csb.Enlist = true);
<span onclick='openModal()' class='match'>491          EnlistOffDataSource = CreateDataSource(csb => csb.Enlist = false);
492      }
493      [OneTimeTearDown]
494      public void OnTimeTearDown()
495      {
496          EnlistOnDataSource?.Dispose();
497          EnlistOnDataSource = null!;
498          EnlistOffDataSource?.Dispose();
499          EnlistOffDataSource = null!;
500      }
501      [SetUp]
</span>502      public void SetUp()
503          => EnlistResource.Counter = 0;
504      internal static string CreateTempTable(NpgsqlConnection conn, string columns)
505      {
506          var tableName = "temp_table" + Interlocked.Increment(ref _tempTableCounter);
507          conn.ExecuteNonQuery(@$"
508  START TRANSACTION; SELECT pg_advisory_xact_lock(0);
509  DROP TABLE IF EXISTS {tableName} CASCADE;
510  COMMIT;
511  CREATE TABLE {tableName} ({columns})");
512          return tableName;
513      }
514      #endregion
515  }
516  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-SystemTransactionTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-DistributedTransactionTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>380          EnlistOffDataSource = CreateDataSource(csb => csb.Enlist = false);
381      }
382      [OneTimeTearDown]
383      public void OnTimeTearDown()
384      {
385          EnlistOnDataSource?.Dispose();
386          EnlistOnDataSource = null!;
387          EnlistOffDataSource?.Dispose();
388          EnlistOffDataSource = null!;
389      }
390      internal static string CreateTempTable(NpgsqlDataSource dataSource, string columns)
</pre></code></div>
                <div class="column column_space"><pre><code>491          EnlistOffDataSource = CreateDataSource(csb => csb.Enlist = false);
492      }
493      [OneTimeTearDown]
494      public void OnTimeTearDown()
495      {
496          EnlistOnDataSource?.Dispose();
497          EnlistOnDataSource = null!;
498          EnlistOffDataSource?.Dispose();
499          EnlistOffDataSource = null!;
500      }
501      [SetUp]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    