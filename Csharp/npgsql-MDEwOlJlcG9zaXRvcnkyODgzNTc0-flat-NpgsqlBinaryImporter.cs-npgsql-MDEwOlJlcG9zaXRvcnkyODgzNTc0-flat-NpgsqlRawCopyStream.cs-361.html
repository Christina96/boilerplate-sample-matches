
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 29, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlBinaryImporter.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics;
3  using System.Diagnostics.CodeAnalysis;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Microsoft.Extensions.Logging;
7  using Npgsql.BackendMessages;
8  using Npgsql.Internal;
9  using NpgsqlTypes;
10  using static Npgsql.Util.Statics;
11  namespace Npgsql;
12  public sealed class NpgsqlBinaryImporter : ICancelable
13  {
14      #region Fields and Properties
15      NpgsqlConnector _connector;
16      NpgsqlWriteBuffer _buf;
17      ImporterState _state;
18      short _column;
19      ulong _rowsImported;
20      internal int NumColumns { get; private set; }
21      bool InMiddleOfRow =&gt; _column != -1 &amp;&amp; _column != NumColumns;
22      NpgsqlParameter?[] _params;
23      readonly ILogger _copyLogger;
24      public TimeSpan Timeout
25      {
26          set
27          {
28              _buf.Timeout = value;
29              _connector.UserTimeout = (int)value.TotalMilliseconds;
30          }
31      }
32      #endregion
33      #region Construction / Initialization
34      internal NpgsqlBinaryImporter(NpgsqlConnector connector)
35      {
36          _connector = connector;
37          _buf = connector.WriteBuffer;
38          _column = -1;
39          _params = null!;
40          _copyLogger = connector.LoggingConfiguration.CopyLogger;
41      }
42      internal async Task Init(string copyFromCommand, bool async, CancellationToken cancellationToken = default)
43      {
44          await _connector.WriteQuery(copyFromCommand, async, cancellationToken);
45          await _connector.Flush(async, cancellationToken);
46          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
47          CopyInResponseMessage copyInResponse;
48          var msg = await _connector.ReadMessage(async);
49          switch (msg.Code)
50          {
51          case BackendMessageCode.CopyInResponse:
52              copyInResponse = (CopyInResponseMessage) msg;
53              if (!copyInResponse.IsBinary)
54              {
55                  throw _connector.Break(
56                      new ArgumentException(&quot;copyFromCommand triggered a text transfer, only binary is allowed&quot;,
57                          nameof(copyFromCommand)));
58              }
59              break;
<span onclick='openModal()' class='match'>60          case BackendMessageCode.CommandComplete:
61              throw new InvalidOperationException(
62                  &quot;This API only supports import/export from the client, i.e. COPY commands containing TO/FROM STDIN. &quot; +
63                  &quot;To import/export with files on your PostgreSQL machine, simply execute the command with ExecuteNonQuery. &quot; +
64                  &quot;Note that your data has been successfully imported/exported.&quot;);
65          default:
66              throw _connector.UnexpectedMessageReceived(msg.Code);
67          }
68          NumColumns = copyInResponse.NumColumns;
</span>69          _params = new NpgsqlParameter[NumColumns];
70          _rowsImported = 0;
71          _buf.StartCopyMode();
72          WriteHeader();
73      }
74      void WriteHeader()
75      {
76          _buf.WriteBytes(NpgsqlRawCopyStream.BinarySignature, 0, NpgsqlRawCopyStream.BinarySignature.Length);
77          _buf.WriteInt32(0);   
78          _buf.WriteInt32(0);   
79      }
80      #endregion
81      #region Write
82      public void StartRow() =&gt; StartRow(false).GetAwaiter().GetResult();
83      public Task StartRowAsync(CancellationToken cancellationToken = default)
84      {
85          if (cancellationToken.IsCancellationRequested)
86              return Task.FromCanceled(cancellationToken);
87          using (NoSynchronizationContextScope.Enter())
88              return StartRow(true, cancellationToken);
89      }
90      async Task StartRow(bool async, CancellationToken cancellationToken = default)
91      {
92          CheckReady();
93          if (_column != -1 &amp;&amp; _column != NumColumns)
94              ThrowHelper.ThrowInvalidOperationException_BinaryImportParametersMismatch(NumColumns, _column);
95          if (_buf.WriteSpaceLeft &lt; 2)
96              await _buf.Flush(async, cancellationToken);
97          _buf.WriteInt16(NumColumns);
98          _column = 0;
99          _rowsImported++;
100      }
101      public void Write&lt;T&gt;(T value) =&gt; Write(value, false).GetAwaiter().GetResult();
102      public Task WriteAsync&lt;T&gt;(T value, CancellationToken cancellationToken = default)
103      {
104          if (cancellationToken.IsCancellationRequested)
105              return Task.FromCanceled(cancellationToken);
106          using (NoSynchronizationContextScope.Enter())
107              return Write(value, true, cancellationToken);
108      }
109      Task Write&lt;T&gt;(T value, bool async, CancellationToken cancellationToken = default)
110      {
111          CheckColumnIndex();
112          var p = _params[_column];
113          if (p == null)
114          {
115              _params[_column] = p = typeof(T) == typeof(object)
116                  ? new NpgsqlParameter()
117                  : new NpgsqlParameter&lt;T&gt;();
118          }
119          return Write(value, p, async, cancellationToken);
120      }
121      public void Write&lt;T&gt;(T value, NpgsqlDbType npgsqlDbType) =&gt;
122          Write(value, npgsqlDbType, false).GetAwaiter().GetResult();
123      public Task WriteAsync&lt;T&gt;(T value, NpgsqlDbType npgsqlDbType, CancellationToken cancellationToken = default)
124      {
125          if (cancellationToken.IsCancellationRequested)
126              return Task.FromCanceled(cancellationToken);
127          using (NoSynchronizationContextScope.Enter())
128              return Write(value, npgsqlDbType, true, cancellationToken);
129      }
130      Task Write&lt;T&gt;(T value, NpgsqlDbType npgsqlDbType, bool async, CancellationToken cancellationToken = default)
131      {
132          CheckColumnIndex();
133          var p = _params[_column];
134          if (p == null)
135          {
136              _params[_column] = p = typeof(T) == typeof(object)
137                  ? new NpgsqlParameter()
138                  : new NpgsqlParameter&lt;T&gt;();
139              p.NpgsqlDbType = npgsqlDbType;
140          }
141          if (npgsqlDbType != p.NpgsqlDbType)
142              throw new InvalidOperationException($&quot;Can&#x27;t change {nameof(p.NpgsqlDbType)} from {p.NpgsqlDbType} to {npgsqlDbType}&quot;);
143          return Write(value, p, async, cancellationToken);
144      }
145      public void Write&lt;T&gt;(T value, string dataTypeName) =&gt;
146          Write(value, dataTypeName, false).GetAwaiter().GetResult();
147      public Task WriteAsync&lt;T&gt;(T value, string dataTypeName, CancellationToken cancellationToken = default)
148      {
149          if (cancellationToken.IsCancellationRequested)
150              return Task.FromCanceled(cancellationToken);
151          using (NoSynchronizationContextScope.Enter())
152              return Write(value, dataTypeName, true, cancellationToken);
153      }
154      Task Write&lt;T&gt;(T value, string dataTypeName, bool async, CancellationToken cancellationToken = default)
155      {
156          CheckColumnIndex();
157          var p = _params[_column];
158          if (p == null)
159          {
160              _params[_column] = p = typeof(T) == typeof(object)
161                  ? new NpgsqlParameter()
162                  : new NpgsqlParameter&lt;T&gt;();
163              p.DataTypeName = dataTypeName;
164          }
165          return Write(value, p, async, cancellationToken);
166      }
167      async Task Write&lt;T&gt;(T value, NpgsqlParameter param, bool async, CancellationToken cancellationToken = default)
168      {
169          CheckReady();
170          if (_column == -1)
171              throw new InvalidOperationException(&quot;A row hasn&#x27;t been started&quot;);
172          if (value == null || value is DBNull)
173          {
174              await WriteNull(async, cancellationToken);
175              return;
176          }
177          if (typeof(T) == typeof(object))
178          {
179              param.Value = value;
180          }
181          else
182          {
183              if (param is not NpgsqlParameter&lt;T&gt; typedParam)
184              {
185                  _params[_column] = typedParam = new NpgsqlParameter&lt;T&gt;();
186                  typedParam.NpgsqlDbType = param.NpgsqlDbType;
187                  param = typedParam;
188              }
189              typedParam.TypedValue = value;
190          }
191          param.ResolveHandler(_connector.TypeMapper);
192          param.ValidateAndGetLength();
193          param.LengthCache?.Rewind();
194          await param.WriteWithLength(_buf, async, cancellationToken);
195          param.LengthCache?.Clear();
196          _column++;
197      }
198      public void WriteNull() =&gt; WriteNull(false).GetAwaiter().GetResult();
199      public Task WriteNullAsync(CancellationToken cancellationToken = default)
200      {
201          if (cancellationToken.IsCancellationRequested)
202              return Task.FromCanceled(cancellationToken);
203          using (NoSynchronizationContextScope.Enter())
204              return WriteNull(true, cancellationToken);
205      }
206      async Task WriteNull(bool async, CancellationToken cancellationToken = default)
207      {
208          CheckReady();
209          if (_column == -1)
210              throw new InvalidOperationException(&quot;A row hasn&#x27;t been started&quot;);
211          if (_buf.WriteSpaceLeft &lt; 4)
212              await _buf.Flush(async, cancellationToken);
213          _buf.WriteInt32(-1);
214          _column++;
215      }
216      public void WriteRow(params object?[] values) =&gt; WriteRow(false, CancellationToken.None, values).GetAwaiter().GetResult();
217      public Task WriteRowAsync(CancellationToken cancellationToken = default, params object?[] values)
218      {
219          if (cancellationToken.IsCancellationRequested)
220              return Task.FromCanceled(cancellationToken);
221          using (NoSynchronizationContextScope.Enter())
222              return WriteRow(true, cancellationToken, values);
223      }
224      async Task WriteRow(bool async, CancellationToken cancellationToken = default, params object?[] values)
225      {
226          await StartRow(async, cancellationToken);
227          foreach (var value in values)
228              await Write(value, async, cancellationToken);
229      }
230      void CheckColumnIndex()
231      {
232          if (_column &gt;= NumColumns)
233              ThrowHelper.ThrowInvalidOperationException_BinaryImportParametersMismatch(NumColumns, _column + 1);
234      }
235      #endregion
236      #region Commit / Cancel / Close / Dispose
237      public ulong Complete() =&gt; Complete(false).GetAwaiter().GetResult();
238      public ValueTask&lt;ulong&gt; CompleteAsync(CancellationToken cancellationToken = default)
239      {
240          if (cancellationToken.IsCancellationRequested)
241              return new ValueTask&lt;ulong&gt;(Task.FromCanceled&lt;ulong&gt;(cancellationToken));
242          using (NoSynchronizationContextScope.Enter())
243              return Complete(true, cancellationToken);
244      }
245      async ValueTask&lt;ulong&gt; Complete(bool async, CancellationToken cancellationToken = default)
246      {
247          CheckReady();
248          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
249          if (InMiddleOfRow)
250          {
251              await Cancel(async, cancellationToken);
252              throw new InvalidOperationException(&quot;Binary importer closed in the middle of a row, cancelling import.&quot;);
253          }
254          try
255          {
256              await WriteTrailer(async, cancellationToken);
257              await _buf.Flush(async, cancellationToken);
258              _buf.EndCopyMode();
259              await _connector.WriteCopyDone(async, cancellationToken);
260              await _connector.Flush(async, cancellationToken);
261              var cmdComplete = Expect&lt;CommandCompleteMessage&gt;(await _connector.ReadMessage(async), _connector);
262              Expect&lt;ReadyForQueryMessage&gt;(await _connector.ReadMessage(async), _connector);
263              _state = ImporterState.Committed;
264              return cmdComplete.Rows;
265          }
266          catch
267          {
268              Cleanup();
269              throw;
270          }
271      }
272      void ICancelable.Cancel() =&gt; Close();
273      async Task ICancelable.CancelAsync() =&gt; await CloseAsync();
274      public void Dispose() =&gt; Close();
275      public ValueTask DisposeAsync()
276      {
277          using (NoSynchronizationContextScope.Enter())
278              return CloseAsync(true);
279      }
280      async Task Cancel(bool async, CancellationToken cancellationToken = default)
281      {
282          _state = ImporterState.Cancelled;
283          _buf.Clear();
284          _buf.EndCopyMode();
285          await _connector.WriteCopyFail(async, cancellationToken);
286          await _connector.Flush(async, cancellationToken);
287          try
288          {
289              using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
290              var msg = await _connector.ReadMessage(async);
291              throw _connector.Break(
292                  new NpgsqlException(&quot;Expected ErrorResponse when cancelling COPY but got: &quot; + msg.Code));
293          }
294          catch (PostgresException e)
295          {
296              if (e.SqlState != PostgresErrorCodes.QueryCanceled)
297                  throw;
298          }
299      }
300      public void Close() =&gt; CloseAsync(false).GetAwaiter().GetResult();
301      public ValueTask CloseAsync(CancellationToken cancellationToken = default)
302      {
303          if (cancellationToken.IsCancellationRequested)
304              return new ValueTask(Task.FromCanceled(cancellationToken));
305          using (NoSynchronizationContextScope.Enter())
306              return CloseAsync(true, cancellationToken);
307      }
308      async ValueTask CloseAsync(bool async, CancellationToken cancellationToken = default)
309      {
310          switch (_state)
311          {
312          case ImporterState.Disposed:
313              return;
314          case ImporterState.Ready:
315              await Cancel(async, cancellationToken);
316              break;
317          case ImporterState.Cancelled:
318          case ImporterState.Committed:
319              break;
320          default:
321              throw new Exception(&quot;Invalid state: &quot; + _state);
322          }
323          Cleanup();
324      }
325  #pragma warning disable CS8625
326      void Cleanup()
327      {
328          if (_state == ImporterState.Disposed)
329              return;
330          var connector = _connector;
331          LogMessages.BinaryCopyOperationCompleted(_copyLogger, _rowsImported, connector?.Id ?? -1);
332          if (connector != null)
333          {
334              connector.EndUserAction();
335              connector.CurrentCopyOperation = null;
336              connector.Connection?.EndBindingScope(ConnectorBindingScope.Copy);
337              _connector = null;
338          }
339          _buf = null;
340          _state = ImporterState.Disposed;
341      }
342  #pragma warning restore CS8625
343      async Task WriteTrailer(bool async, CancellationToken cancellationToken = default)
344      {
345          if (_buf.WriteSpaceLeft &lt; 2)
346              await _buf.Flush(async, cancellationToken);
347          _buf.WriteInt16(-1);
348      }
349      void CheckReady()
350      {
351          switch (_state)
352          {
353          case ImporterState.Ready:
354              return;
355          case ImporterState.Disposed:
356              throw new ObjectDisposedException(GetType().FullName, &quot;The COPY operation has already ended.&quot;);
357          case ImporterState.Cancelled:
358              throw new InvalidOperationException(&quot;The COPY operation has already been cancelled.&quot;);
359          case ImporterState.Committed:
360              throw new InvalidOperationException(&quot;The COPY operation has already been committed.&quot;);
361          default:
362              throw new Exception(&quot;Invalid state: &quot; + _state);
363          }
364      }
365      #endregion
366      #region Enums
367      enum ImporterState
368      {
369          Ready,
370          Committed,
371          Cancelled,
372          Disposed
373      }
374      #endregion Enums
375  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRawCopyStream.cs</h3>
            <pre><code>1  using System;
2  using System.Diagnostics;
3  using System.IO;
4  using System.Threading;
5  using System.Threading.Tasks;
6  using Microsoft.Extensions.Logging;
7  using Npgsql.BackendMessages;
8  using Npgsql.Internal;
9  using static Npgsql.Util.Statics;
10  #pragma warning disable 1591
11  namespace Npgsql;
12  public sealed class NpgsqlRawCopyStream : Stream, ICancelable
13  {
14      #region Fields and Properties
15      NpgsqlConnector _connector;
16      NpgsqlReadBuffer _readBuf;
17      NpgsqlWriteBuffer _writeBuf;
18      int _leftToReadInDataMsg;
19      bool _isDisposed, _isConsumed;
20      bool _canRead;
21      bool _canWrite;
22      internal bool IsBinary { get; private set; }
23      public override bool CanWrite =&gt; _canWrite;
24      public override bool CanRead =&gt; _canRead;
25      public override bool CanTimeout =&gt; true;
26      public override int WriteTimeout
27      {
28          get =&gt; (int) _writeBuf.Timeout.TotalMilliseconds;
29          set =&gt; _writeBuf.Timeout = TimeSpan.FromMilliseconds(value);
30      }
31      public override int ReadTimeout
32      {
33          get =&gt; (int) _readBuf.Timeout.TotalMilliseconds;
34          set
35          {
36              _readBuf.Timeout = TimeSpan.FromMilliseconds(value);
37              _connector.UserTimeout = value;
38          }
39      }
40      internal static readonly byte[] BinarySignature =
41      {
42          (byte)&#x27;P&#x27;,(byte)&#x27;G&#x27;,(byte)&#x27;C&#x27;,(byte)&#x27;O&#x27;,(byte)&#x27;P&#x27;,(byte)&#x27;Y&#x27;,
43          (byte)&#x27;\n&#x27;, 255, (byte)&#x27;\r&#x27;, (byte)&#x27;\n&#x27;, 0
44      };
45      readonly ILogger _copyLogger;
46      #endregion
47      #region Constructor / Initializer
48      internal NpgsqlRawCopyStream(NpgsqlConnector connector)
49      {
50          _connector = connector;
51          _readBuf = connector.ReadBuffer;
52          _writeBuf = connector.WriteBuffer;
53          _copyLogger = connector.LoggingConfiguration.CopyLogger;
54      }
55      internal async Task Init(string copyCommand, bool async, CancellationToken cancellationToken = default)
56      {
57          await _connector.WriteQuery(copyCommand, async, cancellationToken);
58          await _connector.Flush(async, cancellationToken);
59          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
60          var msg = await _connector.ReadMessage(async);
61          switch (msg.Code)
62          {
63          case BackendMessageCode.CopyInResponse:
64              var copyInResponse = (CopyInResponseMessage) msg;
65              IsBinary = copyInResponse.IsBinary;
66              _canWrite = true;
67              _writeBuf.StartCopyMode();
68              break;
69          case BackendMessageCode.CopyOutResponse:
70              var copyOutResponse = (CopyOutResponseMessage) msg;
71              IsBinary = copyOutResponse.IsBinary;
72              _canRead = true;
73              break;
<span onclick='openModal()' class='match'>74          case BackendMessageCode.CommandComplete:
75              throw new InvalidOperationException(
76                  &quot;This API only supports import/export from the client, i.e. COPY commands containing TO/FROM STDIN. &quot; +
77                  &quot;To import/export with files on your PostgreSQL machine, simply execute the command with ExecuteNonQuery. &quot; +
78                  &quot;Note that your data has been successfully imported/exported.&quot;);
79          default:
80              throw _connector.UnexpectedMessageReceived(msg.Code);
81          }
82      }
</span>83      #endregion
84      #region Write
85      public override void Write(byte[] buffer, int offset, int count)
86      {
87          ValidateArguments(buffer, offset, count);
88          Write(new ReadOnlySpan&lt;byte&gt;(buffer, offset, count));
89      }
90      public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
91      {
92          ValidateArguments(buffer, offset, count);
93          return WriteAsync(new Memory&lt;byte&gt;(buffer, offset, count), cancellationToken).AsTask();
94      }
95  #if NETSTANDARD2_0
96      public void Write(ReadOnlySpan&lt;byte&gt; buffer)
97  #else
98      public override void Write(ReadOnlySpan&lt;byte&gt; buffer)
99  #endif
100      {
101          CheckDisposed();
102          if (!CanWrite)
103              throw new InvalidOperationException(&quot;Stream not open for writing&quot;);
104          if (buffer.Length == 0) { return; }
105          if (buffer.Length &lt;= _writeBuf.WriteSpaceLeft)
106          {
107              _writeBuf.WriteBytes(buffer);
108              return;
109          }
110          try
111          {
112              Flush();
113              if (buffer.Length &lt;= _writeBuf.WriteSpaceLeft)
114              {
115                  _writeBuf.WriteBytes(buffer);
116                  return;
117              }
118              _writeBuf.DirectWrite(buffer);
119          }
120          catch (Exception e)
121          {
122              _connector.Break(e);
123              throw;
124          }
125      }
126  #if NETSTANDARD2_0
127      public ValueTask WriteAsync(ReadOnlyMemory&lt;byte&gt; buffer, CancellationToken cancellationToken = default)
128  #else
129      public override ValueTask WriteAsync(ReadOnlyMemory&lt;byte&gt; buffer, CancellationToken cancellationToken = default)
130  #endif
131      {
132          CheckDisposed();
133          if (!CanWrite)
134              throw new InvalidOperationException(&quot;Stream not open for writing&quot;);
135          cancellationToken.ThrowIfCancellationRequested();
136          using (NoSynchronizationContextScope.Enter())
137              return WriteAsyncInternal(buffer, cancellationToken);
138          async ValueTask WriteAsyncInternal(ReadOnlyMemory&lt;byte&gt; buffer, CancellationToken cancellationToken)
139          {
140              if (buffer.Length == 0)
141                  return;
142              if (buffer.Length &lt;= _writeBuf.WriteSpaceLeft)
143              {
144                  _writeBuf.WriteBytes(buffer.Span);
145                  return;
146              }
147              try
148              {
149                  await FlushAsync(true, cancellationToken);
150                  if (buffer.Length &lt;= _writeBuf.WriteSpaceLeft)
151                  {
152                      _writeBuf.WriteBytes(buffer.Span);
153                      return;
154                  }
155                  await _writeBuf.DirectWrite(buffer, true, cancellationToken);
156              }
157              catch (Exception e)
158              {
159                  _connector.Break(e);
160                  throw;
161              }
162          }
163      }
164      public override void Flush() =&gt; FlushAsync(false).GetAwaiter().GetResult();
165      public override Task FlushAsync(CancellationToken cancellationToken)
166      {
167          if (cancellationToken.IsCancellationRequested)
168              return Task.FromCanceled(cancellationToken);
169          using (NoSynchronizationContextScope.Enter())
170              return FlushAsync(true, cancellationToken);
171      }
172      Task FlushAsync(bool async, CancellationToken cancellationToken = default)
173      {
174          CheckDisposed();
175          return _writeBuf.Flush(async, cancellationToken);
176      }
177      #endregion
178      #region Read
179      public override int Read(byte[] buffer, int offset, int count)
180      {
181          ValidateArguments(buffer, offset, count);
182          return Read(new Span&lt;byte&gt;(buffer, offset, count));
183      }
184      public override Task&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
185      {
186          ValidateArguments(buffer, offset, count);
187          return ReadAsync(new Memory&lt;byte&gt;(buffer, offset, count), cancellationToken).AsTask();
188      }
189  #if NETSTANDARD2_0
190      public int Read(Span&lt;byte&gt; span)
191  #else
192      public override int Read(Span&lt;byte&gt; span)
193  #endif
194      {
195          CheckDisposed();
196          if (!CanRead)
197              throw new InvalidOperationException(&quot;Stream not open for reading&quot;);
198          var count = ReadCore(span.Length, false).GetAwaiter().GetResult();
199          if (count &gt; 0)
200              _readBuf.ReadBytes(span.Slice(0, count));
201          return count;
202      }
203  #if NETSTANDARD2_0
204      public ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken)
205  #else
206      public override ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken)
207  #endif
208      {
209          CheckDisposed();
210          if (!CanRead)
211              throw new InvalidOperationException(&quot;Stream not open for reading&quot;);
212          cancellationToken.ThrowIfCancellationRequested();
213          using (NoSynchronizationContextScope.Enter())
214              return ReadAsyncInternal();
215          async ValueTask&lt;int&gt; ReadAsyncInternal()
216          {
217              var count = await ReadCore(buffer.Length, true, cancellationToken);
218              if (count &gt; 0)
219                  _readBuf.ReadBytes(buffer.Slice(0, count).Span);
220              return count;
221          }
222      }
223      async ValueTask&lt;int&gt; ReadCore(int count, bool async, CancellationToken cancellationToken = default)
224      {
225          if (_isConsumed)
226              return 0;
227          using var registration = _connector.StartNestedCancellableOperation(cancellationToken, attemptPgCancellation: false);
228          if (_leftToReadInDataMsg == 0)
229          {
230              IBackendMessage msg;
231              try
232              {
233                  msg = await _connector.ReadMessage(async);
234              }
235              catch
236              {
237                  if (!_isDisposed)
238                      Cleanup();
239                  throw;
240              }
241              switch (msg.Code)
242              {
243              case BackendMessageCode.CopyData:
244                  _leftToReadInDataMsg = ((CopyDataMessage)msg).Length;
245                  break;
246              case BackendMessageCode.CopyDone:
247                  Expect&lt;CommandCompleteMessage&gt;(await _connector.ReadMessage(async), _connector);
248                  Expect&lt;ReadyForQueryMessage&gt;(await _connector.ReadMessage(async), _connector);
249                  _isConsumed = true;
250                  return 0;
251              default:
252                  throw _connector.UnexpectedMessageReceived(msg.Code);
253              }
254          }
255          Debug.Assert(_leftToReadInDataMsg &gt; 0);
256          if (_readBuf.ReadBytesLeft == 0)
257              await _readBuf.ReadMore(async);
258          Debug.Assert(_readBuf.ReadBytesLeft &gt; 0);
259          var maxCount = Math.Min(_readBuf.ReadBytesLeft, _leftToReadInDataMsg);
260          if (count &gt; maxCount)
261              count = maxCount;
262          _leftToReadInDataMsg -= count;
263          return count;
264      }
265      #endregion
266      #region Cancel
267      public void Cancel() =&gt; Cancel(false).GetAwaiter().GetResult();
268      public Task CancelAsync()
269      {
270          using (NoSynchronizationContextScope.Enter())
271              return Cancel(true);
272      }
273      async Task Cancel(bool async)
274      {
275          CheckDisposed();
276          if (CanWrite)
277          {
278              _writeBuf.EndCopyMode();
279              _writeBuf.Clear();
280              await _connector.WriteCopyFail(async);
281              await _connector.Flush(async);
282              try
283              {
284                  var msg = await _connector.ReadMessage(async);
285                  throw _connector.Break(
286                      new NpgsqlException(&quot;Expected ErrorResponse when cancelling COPY but got: &quot; + msg.Code));
287              }
288              catch (PostgresException e)
289              {
290                  Cleanup();
291                  if (e.SqlState != PostgresErrorCodes.QueryCanceled)
292                      throw;
293              }
294          }
295          else
296          {
297              _connector.PerformPostgresCancellation();
298          }
299      }
300      #endregion
301      #region Dispose
302      protected override void Dispose(bool disposing) =&gt; DisposeAsync(disposing, false).GetAwaiter().GetResult();
303  #if NETSTANDARD2_0
304      public ValueTask DisposeAsync()
305  #else
306      public override ValueTask DisposeAsync()
307  #endif
308          =&gt; DisposeAsync(disposing: true, async: true);
309      async ValueTask DisposeAsync(bool disposing, bool async)
310      {
311          if (_isDisposed || !disposing)
312              return;
313          try
314          {
315              _connector.CurrentCopyOperation = null;
316              if (CanWrite)
317              {
318                  await FlushAsync(async);
319                  _writeBuf.EndCopyMode();
320                  await _connector.WriteCopyDone(async);
321                  await _connector.Flush(async);
322                  Expect&lt;CommandCompleteMessage&gt;(await _connector.ReadMessage(async), _connector);
323                  Expect&lt;ReadyForQueryMessage&gt;(await _connector.ReadMessage(async), _connector);
324              }
325              else
326              {
327                  if (!_isConsumed)
328                  {
329                      try
330                      {
331                          if (_leftToReadInDataMsg &gt; 0)
332                          {
333                              await _readBuf.Skip(_leftToReadInDataMsg, async);
334                          }
335                          _connector.SkipUntil(BackendMessageCode.ReadyForQuery);
336                      }
337                      catch (OperationCanceledException e) when (e.InnerException is PostgresException pg &amp;&amp; pg.SqlState == PostgresErrorCodes.QueryCanceled)
338                      {
339                          LogMessages.CopyOperationCancelled(_copyLogger, _connector.Id);
340                      }
341                      catch (Exception e)
342                      {
343                          LogMessages.ExceptionWhenDisposingCopyOperation(_copyLogger, _connector.Id, e);
344                      }
345                  }
346              }
347          }
348          finally
349          {
350              Cleanup();
351          }
352      }
353  #pragma warning disable CS8625
354      void Cleanup()
355      {
356          Debug.Assert(!_isDisposed);
357          LogMessages.CopyOperationCompleted(_copyLogger, _connector.Id);
358          _connector.EndUserAction();
359          _connector.CurrentCopyOperation = null;
360          _connector.Connection?.EndBindingScope(ConnectorBindingScope.Copy);
361          _connector = null;
362          _readBuf = null;
363          _writeBuf = null;
364          _isDisposed = true;
365      }
366  #pragma warning restore CS8625
367      void CheckDisposed()
368      {
369          if (_isDisposed) {
370              throw new ObjectDisposedException(nameof(NpgsqlRawCopyStream), &quot;The COPY operation has already ended.&quot;);
371          }
372      }
373      #endregion
374      #region Unsupported
375      public override bool CanSeek =&gt; false;
376      public override long Seek(long offset, SeekOrigin origin)
377      {
378          throw new NotSupportedException();
379      }
380      public override void SetLength(long value)
381      {
382          throw new NotSupportedException();
383      }
384      public override long Length =&gt; throw new NotSupportedException();
385      public override long Position
386      {
387          get =&gt; throw new NotSupportedException();
388          set =&gt; throw new NotSupportedException();
389      }
390      #endregion
391      #region Input validation
392      static void ValidateArguments(byte[] buffer, int offset, int count)
393      {
394          if (buffer == null)
395              throw new ArgumentNullException(nameof(buffer));
396          if (offset &lt; 0)
397              throw new ArgumentNullException(nameof(offset));
398          if (count &lt; 0)
399              throw new ArgumentNullException(nameof(count));
400          if (buffer.Length - offset &lt; count)
401              throw new ArgumentException(&quot;Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.&quot;);
402      }
403      #endregion
404  }
405  public sealed class NpgsqlCopyTextWriter : StreamWriter, ICancelable
406  {
407      internal NpgsqlCopyTextWriter(NpgsqlConnector connector, NpgsqlRawCopyStream underlying) : base(underlying)
408      {
409          if (underlying.IsBinary)
410              throw connector.Break(new Exception(&quot;Can&#x27;t use a binary copy stream for text writing&quot;));
411      }
412      public void Cancel()
413          =&gt; ((NpgsqlRawCopyStream)BaseStream).Cancel();
414      public Task CancelAsync()
415      {
416          using (NoSynchronizationContextScope.Enter())
417              return ((NpgsqlRawCopyStream)BaseStream).CancelAsync();
418      }
419  #if NETSTANDARD2_0
420      public ValueTask DisposeAsync()
421      {
422          Dispose();
423          return default;
424      }
425  #endif
426  }
427  public sealed class NpgsqlCopyTextReader : StreamReader, ICancelable
428  {
429      internal NpgsqlCopyTextReader(NpgsqlConnector connector, NpgsqlRawCopyStream underlying) : base(underlying)
430      {
431          if (underlying.IsBinary)
432              throw connector.Break(new Exception(&quot;Can&#x27;t use a binary copy stream for text reading&quot;));
433      }
434      public void Cancel()
435          =&gt; ((NpgsqlRawCopyStream)BaseStream).Cancel();
436      public Task CancelAsync()
437      {
438          using (NoSynchronizationContextScope.Enter())
439              return ((NpgsqlRawCopyStream)BaseStream).CancelAsync();
440      }
441      public ValueTask DisposeAsync()
442      {
443          Dispose();
444          return default;
445      }
446  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlBinaryImporter.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-NpgsqlRawCopyStream.cs</div>
                </div>
                <div class="column column_space"><pre><code>60          case BackendMessageCode.CommandComplete:
61              throw new InvalidOperationException(
62                  &quot;This API only supports import/export from the client, i.e. COPY commands containing TO/FROM STDIN. &quot; +
63                  &quot;To import/export with files on your PostgreSQL machine, simply execute the command with ExecuteNonQuery. &quot; +
64                  &quot;Note that your data has been successfully imported/exported.&quot;);
65          default:
66              throw _connector.UnexpectedMessageReceived(msg.Code);
67          }
68          NumColumns = copyInResponse.NumColumns;
</pre></code></div>
                <div class="column column_space"><pre><code>74          case BackendMessageCode.CommandComplete:
75              throw new InvalidOperationException(
76                  &quot;This API only supports import/export from the client, i.e. COPY commands containing TO/FROM STDIN. &quot; +
77                  &quot;To import/export with files on your PostgreSQL machine, simply execute the command with ExecuteNonQuery. &quot; +
78                  &quot;Note that your data has been successfully imported/exported.&quot;);
79          default:
80              throw _connector.UnexpectedMessageReceived(msg.Code);
81          }
82      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    