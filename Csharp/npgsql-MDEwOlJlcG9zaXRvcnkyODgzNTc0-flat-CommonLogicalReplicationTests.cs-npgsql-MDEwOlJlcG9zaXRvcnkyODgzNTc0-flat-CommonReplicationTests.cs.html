
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonLogicalReplicationTests.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Threading.Tasks;
4  using NUnit.Framework;
5  using Npgsql.Replication;
6  using Npgsql.Replication.Internal;
7  using NpgsqlTypes;
8  namespace Npgsql.Tests.Replication;
9  [Platform(Exclude = "MacOsX", Reason = "Replication tests are flaky in CI on Mac")]
10  [NonParallelizable]
11  public class CommonLogicalReplicationTests : SafeReplicationTestBase<LogicalReplicationConnection>
12  {
13      const string OutputPlugin = "test_decoding";
14      [Test]
15      public Task CreateLogicalReplicationSlot([Values]bool temporary, [Values]bool twoPhase)
16          => SafeReplicationTest(
17              async (slotName, _) =>
18              {
19                  await using var c = await OpenConnectionAsync();
20                  if (twoPhase)
21                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
22                  if (temporary)
23                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
24                  await using var rc = await OpenReplicationConnectionAsync();
25                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, twoPhase: twoPhase);
26                  using var cmd =
27                      new NpgsqlCommand($"SELECT * FROM pg_replication_slots WHERE slot_name = '{options.SlotName}'",
28                          c);
29                  await using var reader = await cmd.ExecuteReaderAsync();
30                  Assert.That(reader.Read, Is.True);
31                  Assert.That(reader.GetFieldValue<string>(reader.GetOrdinal("slot_type")), Is.EqualTo("logical"));
32                  if (c.PostgreSqlVersion >= Version.Parse("15.0"))
33                      Assert.That(reader.GetFieldValue<bool>(reader.GetOrdinal("two_phase")), Is.EqualTo(twoPhase));
34                  if (c.PostgreSqlVersion >= Version.Parse("10.0"))
35                      Assert.That(reader.GetFieldValue<bool>(reader.GetOrdinal("temporary")), Is.EqualTo(temporary));
36                  Assert.That(reader.GetFieldValue<bool>(reader.GetOrdinal("active")), Is.EqualTo(temporary));
37                  if (c.PostgreSqlVersion >= Version.Parse("9.6"))
38                      Assert.That(reader.GetFieldValue<NpgsqlLogSequenceNumber>(reader.GetOrdinal("confirmed_flush_lsn")),
39                          Is.EqualTo(options.ConsistentPoint));
40                  Assert.That(reader.Read, Is.False);
41              }, nameof(CreateLogicalReplicationSlot) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : ""));
42      [Test]
43      public Task CreateLogicalReplicationSlot_NoExport([Values]bool temporary, [Values]bool twoPhase)
44          => SafeReplicationTest(
45              async (slotName, _) =>
46              {
47                  await using var c = await OpenConnectionAsync();
48                  if (temporary)
49                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
50                  if (twoPhase)
51                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
52                  TestUtil.MinimumPgVersion(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
53                  await using var rc = await OpenReplicationConnectionAsync();
54                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, LogicalSlotSnapshotInitMode.NoExport, twoPhase);
55                  Assert.That(options.SnapshotName, Is.Null);
56              }, nameof(CreateLogicalReplicationSlot_NoExport) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : ""));
57      [Test(Description = "Tests whether we throw a helpful exception about the unsupported *_SNAPSHOT syntax on old servers.")]
58      [TestCase(LogicalSlotSnapshotInitMode.Export)]
59      [TestCase(LogicalSlotSnapshotInitMode.NoExport)]
60      [TestCase(LogicalSlotSnapshotInitMode.Use)]
61      public Task CreateLogicalReplicationSlot_with_SnapshotInitMode_on_old_postgres_throws(LogicalSlotSnapshotInitMode mode)
62          => SafeReplicationTest(
63              async (slotName, _) =>
64              {
65                  await using var c = await OpenConnectionAsync();
66                  TestUtil.MaximumPgVersionExclusive(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
67                  Assert.That(async () =>
68                  {
69                      await using var rc = await OpenReplicationConnectionAsync();
70                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, slotSnapshotInitMode: mode);
71                  }, Throws.InstanceOf<NotSupportedException>()
72                      .With.Message.StartsWith("The EXPORT_SNAPSHOT, USE_SNAPSHOT and NOEXPORT_SNAPSHOT syntax was introduced in PostgreSQL")
73                      .And.InnerException.TypeOf<PostgresException>()
74                      .And.InnerException.Property("SqlState").EqualTo(PostgresErrorCodes.SyntaxError));
75              });
76      [Test(Description = "Tests whether we throw a helpful exception about unsupported temporary replication slots on old servers.")]
77      public Task CreateLogicalReplicationSlot_with_isTemporary_set_to_true_on_old_postgres_throws()
78          => SafeReplicationTest(
79              async (slotName, _) =>
80              {
81                  await using var c = await OpenConnectionAsync();
82                  TestUtil.MaximumPgVersionExclusive(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
83                  Assert.That(async () =>
84                  {
85                      await using var rc = await OpenReplicationConnectionAsync();
86                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, isTemporary: true);
87                  }, Throws.InstanceOf<NotSupportedException>()
88                      .With.Message.StartsWith("Temporary replication slots were introduced in PostgreSQL")
89                      .And.InnerException.TypeOf<PostgresException>()
90                      .And.InnerException.Property("SqlState").EqualTo(PostgresErrorCodes.SyntaxError));
91              });
92      [Test(Description = "Tests whether we throw a helpful exception about the unsupported TWO_PHASE syntax on old servers.")]
93      public Task CreateLogicalReplicationSlot_with_twoPhase_set_to_true_on_old_postgres_throws()
94          => SafeReplicationTest(
95              async (slotName, _) =>
96              {
97                  await using var c = await OpenConnectionAsync();
98                  TestUtil.MaximumPgVersionExclusive(c, "15.0",
99                      "Logical replication support for prepared transactions was  introduced in PostgreSQL 15");
100                  Assert.That(async () =>
101                  {
102                      await using var rc = await OpenReplicationConnectionAsync();
103                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, twoPhase: true);
104                  }, Throws.InstanceOf<NotSupportedException>()
105                      .With.Message.StartsWith("Logical replication support for prepared transactions was introduced in PostgreSQL")
106                      .And.InnerException.TypeOf<PostgresException>()
107                      .And.InnerException.Property("SqlState").EqualTo(PostgresErrorCodes.SyntaxError));
108              });
109      [Test(Description = "We can use the exported snapshot to query the database in the very moment the replication slot was created.")]
110      public Task CreateLogicalReplicationSlot_Export([Values]bool temporary, [Values]bool twoPhase, [Values]bool implicitInitMode)
111          => SafeReplicationTest(
112              async (slotName, tableName) =>
113              {
114                  await using var c = await OpenConnectionAsync();
115                  if (temporary)
116                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
117                  if (twoPhase)
118                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
119                  if (!implicitInitMode)
120                      TestUtil.MinimumPgVersion(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
121                  await using (var transaction = c.BeginTransaction())
122                  {
123                      await c.ExecuteNonQueryAsync($"CREATE TABLE {tableName} (value text)");
124                      await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} (value) VALUES('Before snapshot')");
125                      transaction.Commit();
126                  }
127                  await using var rc = await OpenReplicationConnectionAsync();
128                  var options = await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, implicitInitMode ? null : LogicalSlotSnapshotInitMode.Export, twoPhase);
129                  await using (var transaction = c.BeginTransaction())
130                  {
131                      await c.ExecuteNonQueryAsync($"INSERT INTO {tableName} (value) VALUES('After snapshot')");
132                      transaction.Commit();
133                  }
134                  await using (var transaction = c.BeginTransaction(IsolationLevel.RepeatableRead))
135                  {
136                      await c.ExecuteScalarAsync($"SET TRANSACTION SNAPSHOT '{options.SnapshotName}';", transaction);
137                      using var cmd = new NpgsqlCommand($"SELECT value FROM {tableName}", c, transaction);
138                      await using var reader = await cmd.ExecuteReaderAsync();
139                      Assert.That(reader.Read, Is.True);
140                      Assert.That(reader.GetFieldValue<string>(0), Is.EqualTo("Before snapshot"));
141                      Assert.That(reader.Read, Is.False);
142                  }
143              }, nameof(CreateLogicalReplicationSlot_Export) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : "") + (implicitInitMode ? "_i" : ""));
144      [Test(Description = "Since we currently don't provide an API to start a transaction on a logical replication connection, " +
145                          "USE_SNAPSHOT currently doesn't work and always leads to an exception. On the other hand, starting" +
146                          "a transaction would only be useful if we'd also provide an API to issue commands.")]
147      public Task CreateLogicalReplicationSlot_Use([Values]bool temporary, [Values]bool twoPhase)
148          => SafeReplicationTest(
149              async (slotName, _) =>
150              {
151                  await using var c = await OpenConnectionAsync();
152                  if (temporary)
153                      TestUtil.MinimumPgVersion(c, "10.0", "Temporary replication slots were introduced in PostgreSQL 10");
154                  if (twoPhase)
155                      TestUtil.MinimumPgVersion(c, "15.0", "Replication slots with two phase commit support were introduced in PostgreSQL 15");
156                  TestUtil.MinimumPgVersion(c, "10.0", "The *_SNAPSHOT syntax was introduced in PostgreSQL 10");
157                  Assert.That(async () =>
158                  {
159                      await using var rc = await OpenReplicationConnectionAsync();
160                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, temporary, LogicalSlotSnapshotInitMode.Use, twoPhase);
161                  }, Throws.InstanceOf<PostgresException>()
162                      .With.Property("SqlState")
163                      .EqualTo("XX000")
164                      .And.Message.Contains(
165                          c.PostgreSqlVersion.Major < 15
166                              ? "USE_SNAPSHOT"
167                              : "(SNAPSHOT 'use')"
168                          ));
169              }, nameof(CreateLogicalReplicationSlot_Use) + (temporary ? "_tmp" : "") + (twoPhase ? "_tp" : ""));
170      [Test]
171      public void CreateLogicalReplicationSlot_with_null_slot_throws()
172          => Assert.That(async () =>
173          {
174              await using var rc = await OpenReplicationConnectionAsync();
175              await rc.CreateLogicalReplicationSlot(null!, OutputPlugin);
176          }, Throws.ArgumentNullException
177              .With.Property("ParamName")
178              .EqualTo("slotName"));
179      [Test]
180      public Task CreateLogicalReplicationSlot_with_null_output_plugin_throws()
181          => SafeReplicationTest(
182              (slotName, _) =>
183              {
184                  Assert.That(async () =>
185                  {
186                      await using var rc = await OpenReplicationConnectionAsync();
187                      await rc.CreateLogicalReplicationSlot(slotName, null!);
188                  }, Throws.ArgumentNullException
189                      .With.Property("ParamName")
190                      .EqualTo("outputPlugin"));
191                  return Task.CompletedTask;
192              });
193      [Test]
194      public Task CreateLogicalReplicationSlot_with_cancelled_token()
195          => SafeReplicationTest(
196              (slotName, _) =>
197              {
198                  Assert.That(async () =>
199                  {
200                      await using var rc = await OpenReplicationConnectionAsync();
201                      var token = GetCancelledCancellationToken();
202                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, cancellationToken: token);
203                  }, Throws.Exception.AssignableTo<OperationCanceledException>());
204                  return Task.CompletedTask;
205              });
206      [Test]
207      public Task CreateLogicalReplicationSlot_with_invalid_SnapshotInitMode_throws()
208          => SafeReplicationTest(
209              (slotName, _) =>
210              {
211                  Assert.That(async () =>
212                  {
213                      await using var rc = await OpenReplicationConnectionAsync();
214                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin, slotSnapshotInitMode: (LogicalSlotSnapshotInitMode)42);
215                  }, Throws.InstanceOf<ArgumentOutOfRangeException>()
216                      .With.Property("ParamName")
217                      .EqualTo("slotSnapshotInitMode")
218                      .And.Property("ActualValue")
219                      .EqualTo((LogicalSlotSnapshotInitMode)42));
220                  return Task.CompletedTask;
221              });
222      [Test]
223      public Task CreateLogicalReplicationSlot_with_disposed_connection_throws()
224          => SafeReplicationTest(
225              (slotName, _) =>
226              {
227                  Assert.That(async () =>
228                  {
<span onclick='openModal()' class='match'>229                      var rc = await OpenReplicationConnectionAsync();
230                      await rc.DisposeAsync();
231                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin);
</span>232                  }, Throws.InstanceOf<ObjectDisposedException>()
233                      .With.Property(nameof(ObjectDisposedException.ObjectName))
234                      .EqualTo(nameof(LogicalReplicationConnection)));
235                  return Task.CompletedTask;
236              });
237      protected override string Postfix => "commonl_l";
238  }
</code></pre>
        </div>
        <div class="column">
            <h3>npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonReplicationTests.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Concurrent;
3  using System.Collections.Generic;
4  using System.IO;
5  using System.Runtime.CompilerServices;
6  using System.Text;
7  using System.Threading;
8  using System.Threading.Tasks;
9  using NUnit.Framework;
10  using Npgsql.Replication;
11  using Npgsql.Replication.TestDecoding;
12  using NpgsqlTypes;
13  namespace Npgsql.Tests.Replication;
14  [TestFixture(typeof(LogicalReplicationConnection))]
15  [TestFixture(typeof(PhysicalReplicationConnection))]
16  [Platform(Exclude = "MacOsX", Reason = "Replication tests are flaky in CI on Mac")]
17  [NonParallelizable]
18  public class CommonReplicationTests<TConnection> : SafeReplicationTestBase<TConnection>
19      where TConnection : ReplicationConnection, new()
20  {
21      #region Open
22      [Test, NonParallelizable]
23      public async Task Open()
24      {
25          await using var rc = await OpenReplicationConnectionAsync();
26      }
27      [Test]
28      public void Open_with_cancelled_token()
29          => Assert.That(async () =>
30          {
31              var token = GetCancelledCancellationToken();
32              await using var rc = await OpenReplicationConnectionAsync(cancellationToken: token);
33          }, Throws.Exception.AssignableTo<OperationCanceledException>());
34      [Test]
35      public void Open_on_disposed_connection()
36          => Assert.That(async () =>
37          {
38              var rc = await OpenReplicationConnectionAsync();
39              await rc.DisposeAsync();
40              await rc.Open();
41          }, Throws.InstanceOf<ObjectDisposedException>()
42              .With.Property(nameof(ObjectDisposedException.ObjectName))
43              .EqualTo(typeof(TConnection).Name));
44      #endregion Open
45      #region IdentifySystem
46      [Test]
47      public async Task IdentifySystem()
48      {
49          await using var rc = await OpenReplicationConnectionAsync();
50          var info = await rc.IdentifySystem();
51          Assert.That(info.Timeline, Is.GreaterThan(0));
52      }
53      [Test]
54      public void IdentifySystem_with_cancelled_token()
55          => Assert.That(async () =>
56          {
57              await using var rc = await OpenReplicationConnectionAsync();
58              var token = GetCancelledCancellationToken();
59              await rc.IdentifySystem(token);
60          }, Throws.Exception.AssignableTo<OperationCanceledException>());
61      [Test]
62      public void IdentifySystem_on_disposed_connection()
63          => Assert.That(async () =>
64          {
65              var rc = await OpenReplicationConnectionAsync();
66              await rc.DisposeAsync();
67              await rc.IdentifySystem();
68          }, Throws.InstanceOf<ObjectDisposedException>()
69              .With.Property(nameof(ObjectDisposedException.ObjectName))
70              .EqualTo(typeof(TConnection).Name));
71      #endregion IdentifySystem
72      #region Show
73      [Test]
74      public async Task Show()
75      {
76          await using var c = await OpenConnectionAsync();
77          TestUtil.MinimumPgVersion(c, "10.0", "The SHOW command was added to the Streaming Replication Protocol in PostgreSQL 10");
78          await using var rc = await OpenReplicationConnectionAsync();
79          Assert.That(await rc.Show("integer_datetimes"), Is.EqualTo("on"));
80      }
81      [Test]
82      public async Task Show_with_null_argument_throws()
83      {
84          await using var c = await OpenConnectionAsync();
85          TestUtil.MinimumPgVersion(c, "10.0", "The SHOW command was added to the Streaming Replication Protocol in PostgreSQL 10");
86          Assert.That(async () =>
87          {
88              await using var rc = await OpenReplicationConnectionAsync();
89              await rc.Show(null!);
90          }, Throws.ArgumentNullException
91              .With.Property("ParamName")
92              .EqualTo("parameterName"));
93      }
94      [Test]
95      public async Task Show_with_cancelled_token()
96      {
97          await using var c = await OpenConnectionAsync();
98          TestUtil.MinimumPgVersion(c, "10.0", "The SHOW command was added to the Streaming Replication Protocol in PostgreSQL 10");
99          Assert.That(async () =>
100          {
101              await using var rc = await OpenReplicationConnectionAsync();
102              var token = GetCancelledCancellationToken();
103              await rc.Show("integer_datetimes", token);
104          }, Throws.Exception.AssignableTo<OperationCanceledException>());
105      }
106      [Test]
107      public async Task Show_on_disposed_connection()
108      {
109          await using var c = await OpenConnectionAsync();
110          TestUtil.MinimumPgVersion(c, "10.0", "The SHOW command was added to the Streaming Replication Protocol in PostgreSQL 10");
111          Assert.That(async () =>
112          {
<span onclick='openModal()' class='match'>113              var rc = await OpenReplicationConnectionAsync();
114              await rc.DisposeAsync();
115              await rc.Show("integer_datetimes");
</span>116          }, Throws.InstanceOf<ObjectDisposedException>()
117              .With.Property(nameof(ObjectDisposedException.ObjectName))
118              .EqualTo(typeof(TConnection).Name));
119      }
120      #endregion Show
121      #region TimelineHistory
122      [Test, Explicit("After initdb a PostgreSQL cluster only has one timeline and no timeline history so this command fails. " +
123                      "You need to explicitly create multiple timelines (e. g. via PITR or by promoting a standby) for this test to work.")]
124      public async Task TimelineHistory()
125      {
126          await using var rc = await OpenReplicationConnectionAsync();
127          var systemInfo = await rc.IdentifySystem();
128          var info = await rc.TimelineHistory(systemInfo.Timeline);
129          Assert.That(info.FileName, Is.Not.Null);
130          Assert.That(info.Content.Length, Is.GreaterThan(0));
131      }
132      [Test]
133      public void TimelineHistory_with_cancelled_token()
134          => Assert.That(async () =>
135          {
136              await using var rc = await OpenReplicationConnectionAsync();
137              var systemInfo = await rc.IdentifySystem();
138              var token = GetCancelledCancellationToken();
139              await rc.TimelineHistory(systemInfo.Timeline, token);
140          }, Throws.Exception.AssignableTo<OperationCanceledException>());
141      [Test]
142      public void TimelineHistory_with_non_existing_timeline()
143          => Assert.That(async () =>
144          {
145              await using var rc = await OpenReplicationConnectionAsync();
146              await rc.TimelineHistory(uint.MaxValue);
147          }, Throws
148              .InstanceOf<PostgresException>()
149              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.UndefinedFile)
150              .Or
151              .InstanceOf<PostgresException>()
152              .With.Property(nameof(PostgresException.SqlState)).EqualTo(PostgresErrorCodes.CharacterNotInRepertoire));
153      [Test]
154      public void TimelineHistory_on_disposed_connection()
155          => Assert.That(async () =>
156          {
157              var rc = await OpenReplicationConnectionAsync();
158              var systemInfo = await rc.IdentifySystem();
159              await rc.DisposeAsync();
160              await rc.TimelineHistory(systemInfo.Timeline);
161          }, Throws.InstanceOf<ObjectDisposedException>()
162              .With.Property(nameof(ObjectDisposedException.ObjectName))
163              .EqualTo(typeof(TConnection).Name));
164      #endregion TimelineHistory
165      #region DropReplicationSlot
166      [Test]
167      public void DropReplicationSlot_with_null_slot_throws()
168          => Assert.That(async () =>
169          {
170              await using var rc = await OpenReplicationConnectionAsync();
171              await rc.DropReplicationSlot(null!);
172          }, Throws.ArgumentNullException
173              .With.Property("ParamName")
174              .EqualTo("slotName"));
175      [Test]
176      public Task DropReplicationSlot_with_cancelled_token()
177          => SafeReplicationTest(
178              async (slotName, _) =>
179              {
180                  await CreateReplicationSlot(slotName);
181                  await using var rc = await OpenReplicationConnectionAsync();
182                  var token = GetCancelledCancellationToken();
183                  Assert.That(async () => await rc.DropReplicationSlot(slotName, cancellationToken: token), Throws.Exception.AssignableTo<OperationCanceledException>());
184              });
185      [Test]
186      public Task DropReplicationSlot_on_disposed_connection()
187          => SafeReplicationTest(
188              async (slotName, _) =>
189              {
190                  await CreateReplicationSlot(slotName);
191                  var rc = await OpenReplicationConnectionAsync();
192                  await rc.DisposeAsync();
193                  Assert.That(async () => await rc.DropReplicationSlot(slotName), Throws.InstanceOf<ObjectDisposedException>()
194                      .With.Property(nameof(ObjectDisposedException.ObjectName))
195                      .EqualTo(typeof(TConnection).Name));
196              });
197      #endregion
198      [Test(Description = "Tests whether our automated feedback thread prevents the backend from disconnecting due to wal_sender_timeout")]
199      public Task Replication_survives_pauses_longer_than_wal_sender_timeout()
200          => SafeReplicationTest(
201              async (slotName, tableName) =>
202              {
203                  await using var c = await OpenConnectionAsync();
204                  TestUtil.MinimumPgVersion(c, "10.0", "The SHOW command, which is required to run this test was added to the Streaming Replication Protocol in PostgreSQL 10");
205                  await c.ExecuteNonQueryAsync($"CREATE TABLE {tableName} (id serial PRIMARY KEY, name TEXT NOT NULL);");
206                  await using var rc = await OpenReplicationConnectionAsync(new NpgsqlConnectionStringBuilder(ConnectionString));
207                  var walSenderTimeout = ParseTimespan(await rc.Show("wal_sender_timeout"));
208                  var info = await rc.IdentifySystem();
209                  if (walSenderTimeout > TimeSpan.FromSeconds(3) && !TestUtil.IsOnBuildServer)
210                      Assert.Ignore($"wal_sender_timeout is set to {walSenderTimeout}, skipping");
211                  var walReceiverStatusInterval = TimeSpan.FromTicks(walSenderTimeout.Ticks / 2L);
212                  rc.WalReceiverStatusInterval = walReceiverStatusInterval;
213                  await CreateReplicationSlot(slotName);
214                  await c.ExecuteNonQueryAsync($"INSERT INTO \"{tableName}\" (name) VALUES ('val1')");
215                  using var streamingCts = new CancellationTokenSource();
216                  var replicationEnumerator = StartReplication(rc, slotName, info.XLogPos, streamingCts.Token).GetAsyncEnumerator(streamingCts.Token);
217                  Assert.That(await replicationEnumerator.MoveNextAsync(), Is.True);
218                  await Task.Delay(walSenderTimeout * 1.1, CancellationToken.None);
219                  await c.ExecuteNonQueryAsync($"INSERT INTO \"{tableName}\" (name) VALUES ('val2')");
220                  Assert.That(await replicationEnumerator.MoveNextAsync(), Is.True);
221                  var message = replicationEnumerator.Current;
222                  Assert.That(message.WalStart, Is.GreaterThanOrEqualTo(info.XLogPos));
223                  Assert.That(message.WalEnd, Is.GreaterThanOrEqualTo(message.WalStart));
224                  streamingCts.Cancel();
225                  Assert.That(async () => { while (await replicationEnumerator.MoveNextAsync()){} }, Throws.Exception.AssignableTo<OperationCanceledException>()
226                      .With.InnerException.InstanceOf<PostgresException>()
227                      .And.InnerException.Property(nameof(PostgresException.SqlState))
228                      .EqualTo(PostgresErrorCodes.QueryCanceled));
229                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
230              });
231      [Test(Description = "Tests whether synchronous replication works the way it should.")]
232      [Explicit("Test is flaky (on Windows)")]
233      public Task Synchronous_replication()
234          => SafeReplicationTest(
235              async (slotName, tableName) =>
236              {
237                  await using var c = await OpenConnectionAsync();
238                  TestUtil.MinimumPgVersion(c, "12.0", "Setting wal_sender_timeout at runtime was introduced in in PostgreSQL 12");
239                  var synchronousCommit = (string)(await c.ExecuteScalarAsync("SHOW synchronous_commit"))!;
240                  if (synchronousCommit != "local")
241                      TestUtil.IgnoreExceptOnBuildServer("Ignoring because synchronous_commit isn't 'local'");
242                  var synchronousStandbyNames = (string)(await c.ExecuteScalarAsync("SHOW synchronous_standby_names"))!;
243                  if (synchronousStandbyNames != "npgsql_test_sync_standby")
244                      TestUtil.IgnoreExceptOnBuildServer("Ignoring because synchronous_standby_names isn't 'npgsql_test_sync_standby'");
245                  await c.ExecuteNonQueryAsync(@$"
246      CREATE TABLE {tableName} (id serial PRIMARY KEY, name TEXT NOT NULL);
247      ");
248                  await using var rc = await OpenReplicationConnectionAsync(new NpgsqlConnectionStringBuilder(ConnectionString)
249                  {
250                      ApplicationName = "npgsql_test_sync_standby",
251                      Options = "-c wal_sender_timeout=0"
252                  });
253                  var info = await rc.IdentifySystem();
254                  rc.WalReceiverStatusInterval = Timeout.InfiniteTimeSpan;
255                  await CreateReplicationSlot(slotName);
256                  using var streamingCts = new CancellationTokenSource();
257                  var messages = ParseMessages(
258                          StartReplication(rc, slotName, info.XLogPos, streamingCts.Token))
259                      .GetAsyncEnumerator();
260                  var value1String = Guid.NewGuid().ToString("B");
261                  var insertTask = Task.Run(async () =>
262                  {
263                      await using var dataSource = CreateDataSource(csb => csb.Options = "-c synchronous_commit=on");
264                      await using var insertConn = await dataSource.OpenConnectionAsync();
265                      await insertConn.ExecuteNonQueryAsync($"INSERT INTO {tableName} (name) VALUES ('{value1String}')");
266                  });
267                  var commitLsn = await GetCommitLsn(value1String);
268                  var result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
269                  Assert.That(result, Is.Null); 
270                  await rc.SendStatusUpdate(CancellationToken.None);
271                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
272                  Assert.That(result, Is.Null); 
273                  rc.LastAppliedLsn = commitLsn;
274                  await rc.SendStatusUpdate(CancellationToken.None);
275                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
276                  Assert.That(result, Is.Null); 
277                  rc.LastFlushedLsn = commitLsn;
278                  await rc.SendStatusUpdate(CancellationToken.None);
279                  await insertTask;
280                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
281                  Assert.That(result, Is.EqualTo(value1String)); 
282                  var value2String = Guid.NewGuid().ToString("B");
283                  insertTask = Task.Run(async () =>
284                  {
285                      await using var dataSource = CreateDataSource(csb => csb.Options = "-c synchronous_commit=remote_apply");
286                      await using var insertConn = await dataSource.OpenConnectionAsync();
287                      await insertConn.ExecuteNonQueryAsync($"INSERT INTO {tableName} (name) VALUES ('{value2String}')");
288                  });
289                  commitLsn = await GetCommitLsn(value2String);
290                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
291                  Assert.That(result, Is.EqualTo(value1String)); 
292                  await rc.SendStatusUpdate(CancellationToken.None);
293                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
294                  Assert.That(result, Is.EqualTo(value1String)); 
295                  rc.LastAppliedLsn = commitLsn;
296                  await rc.SendStatusUpdate(CancellationToken.None);
297                  await insertTask;
298                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
299                  Assert.That(result, Is.EqualTo(value2String)); 
300                  var value3String = Guid.NewGuid().ToString("B");
301                  insertTask = Task.Run(async () =>
302                  {
303                      await using var dataSource = CreateDataSource(csb => csb.Options = "-c synchronous_commit=remote_write");
304                      await using var insertConn = await dataSource.OpenConnectionAsync();
305                      await insertConn.ExecuteNonQueryAsync($"INSERT INTO {tableName} (name) VALUES ('{value3String}')");
306                  });
307                  await GetCommitLsn(value3String);
308                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
309                  Assert.That(result, Is.EqualTo(value2String)); 
310                  await rc.SendStatusUpdate(CancellationToken.None);
311                  await insertTask;
312                  result = await c.ExecuteScalarAsync($"SELECT name FROM {tableName} ORDER BY id DESC LIMIT 1;");
313                  Assert.That(result, Is.EqualTo(value3String)); 
314                  streamingCts.Cancel();
315                  Assert.That(async () => await messages.MoveNextAsync(), Throws.Exception.AssignableTo<OperationCanceledException>()
316                      .With.InnerException.InstanceOf<PostgresException>()
317                      .And.InnerException.Property(nameof(PostgresException.SqlState))
318                      .EqualTo(PostgresErrorCodes.QueryCanceled));
319                  await rc.DropReplicationSlot(slotName, cancellationToken: CancellationToken.None);
320                  static async IAsyncEnumerable<(NpgsqlLogSequenceNumber Lsn, string? MessageData)> ParseMessages(
321                      IAsyncEnumerable<ReplicationMessage> messages)
322                  {
323                      await foreach (var msg in messages)
324                      {
325                          if (typeof(TConnection) == typeof(PhysicalReplicationConnection))
326                          {
327                              var buffer = new MemoryStream();
328                              ((XLogDataMessage)msg).Data.CopyTo(buffer);
329                              var messageString = Encoding.ASCII.GetString(buffer.ToArray());
330                              yield return (msg.WalEnd, messageString);
331                          }
332                          else
333                          {
334                              yield return (msg.WalEnd, null);
335                          }
336                      }
337                  }
338                  async Task<NpgsqlLogSequenceNumber> GetCommitLsn(string valueString)
339                  {
340                      if (typeof(TConnection) == typeof(PhysicalReplicationConnection))
341                          while (await messages.MoveNextAsync())
342                              if (messages.Current.MessageData!.Contains(valueString))
343                                  return messages.Current.Lsn;
344                      for (var i = 0; i < 3; i++)
345                          Assert.True(await messages.MoveNextAsync());
346                      return messages.Current.Lsn;
347                  }
348              });
349      #region BaseBackup
350      #endregion
351      #region BugTests
352      [Test, IssueLink("https:&bsol;&bsol;github.com/npgsql/npgsql/issues/3534")]
353      [NonParallelizable]
354      public Task Bug3534()
355          => SafeReplicationTest(
356              async (slotName, _) =>
357              {
358                  await using var rc = await OpenReplicationConnectionAsync();
359                  var info = await rc.IdentifySystem();
360                  await CreateReplicationSlot(slotName);
361                  using var streamingCts = new CancellationTokenSource();
362                  rc.WalReceiverStatusInterval = TimeSpan.FromSeconds(1D);
363                  rc.WalReceiverTimeout = TimeSpan.FromSeconds(3D);
364                  await using var replicationEnumerator = StartReplication(rc, slotName, info.XLogPos, streamingCts.Token).GetAsyncEnumerator(streamingCts.Token);
365                  var replicationMessageTask = replicationEnumerator.MoveNextAsync();
366                  streamingCts.CancelAfter(rc.WalReceiverTimeout * 2);
367                  Assert.Multiple(() =>
368                  {
369                      Assert.That(async () =>
370                      {
371                          while (true)
372                          {
373                              await replicationMessageTask;
374                              replicationMessageTask = replicationEnumerator.MoveNextAsync();
375                          }
376                      }, Throws.Exception.AssignableTo<OperationCanceledException>());
377                      Assert.That(streamingCts.IsCancellationRequested);
378                  });
379              });
380      #endregion
381      async Task CreateReplicationSlot(string slotName)
382      {
383          await using var c = await OpenConnectionAsync();
384          await c.ExecuteNonQueryAsync(typeof(TConnection) == typeof(PhysicalReplicationConnection)
385              ? $"SELECT pg_create_physical_replication_slot('{slotName}')"
386              : $"SELECT pg_create_logical_replication_slot ('{slotName}', 'test_decoding')");
387      }
388      async IAsyncEnumerable<ReplicationMessage> StartReplication(TConnection connection, string slotName,
389          NpgsqlLogSequenceNumber xLogPos, [EnumeratorCancellation] CancellationToken cancellationToken)
390      {
391          if (typeof(TConnection) == typeof(PhysicalReplicationConnection))
392          {
393              var slot = new PhysicalReplicationSlot(slotName);
394              var rc = (PhysicalReplicationConnection)(ReplicationConnection)connection;
395              await foreach (var msg in rc.StartReplication(slot, xLogPos, cancellationToken))
396              {
397                  yield return msg;
398              }
399          }
400          else if (typeof(TConnection) == typeof(LogicalReplicationConnection))
401          {
402              var slot = new TestDecodingReplicationSlot(slotName);
403              var rc = (LogicalReplicationConnection)(ReplicationConnection)connection;
404              await foreach (var msg in rc.StartReplication(slot, cancellationToken, options: new TestDecodingOptions(skipEmptyXacts: true), walLocation: xLogPos))
405              {
406                  yield return msg;
407              }
408          }
409      }
410      static TimeSpan ParseTimespan(string str)
411      {
412          var span = str.AsSpan();
413          var pos = 0;
414          var number = 0;
415          while (pos < span.Length)
416          {
417              var c = span[pos];
418              if (!char.IsDigit(c))
419                  break;
420              number = number * 10 + (c - 0x30);
421              pos++;
422          }
423          if (number == 0)
424              return Timeout.InfiniteTimeSpan;
425          if ("ms".AsSpan().Equals(span.Slice(pos), StringComparison.Ordinal))
426              return TimeSpan.FromMilliseconds(number);
427          if ("s".AsSpan().Equals(span.Slice(pos), StringComparison.Ordinal))
428              return TimeSpan.FromSeconds(number);
429          if ("min".AsSpan().Equals(span.Slice(pos), StringComparison.Ordinal))
430              return TimeSpan.FromMinutes(number);
431          if ("h".AsSpan().Equals(span.Slice(pos), StringComparison.Ordinal))
432              return TimeSpan.FromHours(number);
433          if ("d".AsSpan().Equals(span.Slice(pos), StringComparison.Ordinal))
434              return TimeSpan.FromDays(number);
435          throw new ArgumentException($"Can not parse timestamp '{span.ToString()}'");
436      }
437      protected override string Postfix =>
438          "common_" +
439          new TConnection() switch
440          {
441              LogicalReplicationConnection _ => "_l",
442              PhysicalReplicationConnection _ => "_p",
443              _ => throw new ArgumentOutOfRangeException($"{typeof(TConnection)} is not expected.")
444          };
445  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonLogicalReplicationTests.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from npgsql-MDEwOlJlcG9zaXRvcnkyODgzNTc0-flat-CommonReplicationTests.cs</div>
                </div>
                <div class="column column_space"><pre><code>229                      var rc = await OpenReplicationConnectionAsync();
230                      await rc.DisposeAsync();
231                      await rc.CreateLogicalReplicationSlot(slotName, OutputPlugin);
</pre></code></div>
                <div class="column column_space"><pre><code>113              var rc = await OpenReplicationConnectionAsync();
114              await rc.DisposeAsync();
115              await rc.Show("integer_datetimes");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    