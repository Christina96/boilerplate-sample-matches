
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateEvaluator.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Linq;
5  using System.Threading;
6  using GitHub.DistributedTask.Expressions2;
7  using GitHub.DistributedTask.Expressions2.Sdk.Functions;
8  using GitHub.DistributedTask.ObjectTemplating;
9  using GitHub.DistributedTask.ObjectTemplating.Schema;
10  using GitHub.DistributedTask.ObjectTemplating.Tokens;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using ExpressionConstants = GitHub.DistributedTask.Expressions2.ExpressionConstants;
13  using ITraceWriter = GitHub.DistributedTask.ObjectTemplating.ITraceWriter;
14  namespace GitHub.DistributedTask.Pipelines.ObjectTemplating
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)]
17      public class PipelineTemplateEvaluator
18      {
19          public PipelineTemplateEvaluator(
20              ITraceWriter trace,
21              TemplateSchema schema,
22              IList<String> fileTable)
23          {
24              if (!String.Equals(schema.Version, PipelineTemplateConstants.Workflow_1_0, StringComparison.Ordinal))
25              {
26                  throw new NotSupportedException($"Unexpected template schema version '{schema.Version}'");
27              }
28              m_trace = trace;
29              m_schema = schema;
30              m_fileTable = fileTable;
31          }
32          public Int32 MaxDepth => 50;
33          public Int32 MaxErrorMessageLength { get; set; } = 500;
34          public Int32 MaxErrors => 10;
35          public Int32 MaxEvents => 1000000; 
36          public Int32 MaxResultSize { get; set; } = 10 * 1024 * 1024; 
37          public Boolean EvaluateStepContinueOnError(
38              TemplateToken token,
39              DictionaryContextData contextData,
40              IList<IFunctionInfo> expressionFunctions)
41          {
42              var result = default(Boolean?);
43              if (token != null && token.Type != TokenType.Null)
44              {
45                  var context = CreateContext(contextData, expressionFunctions);
46                  try
47                  {
48                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.BooleanStepsContext, token, 0, null, omitHeader: true);
49                      context.Errors.Check();
50                      result = PipelineTemplateConverter.ConvertToStepContinueOnError(context, token);
51                  }
52                  catch (Exception ex) when (!(ex is TemplateValidationException))
53                  {
54                      context.Errors.Add(ex);
55                  }
56                  context.Errors.Check();
57              }
58              return result ?? false;
59          }
60          public String EvaluateStepDisplayName(
61              TemplateToken token,
62              DictionaryContextData contextData,
63              IList<IFunctionInfo> expressionFunctions)
64          {
65              var result = default(String);
66              if (token != null && token.Type != TokenType.Null)
67              {
68                  var context = CreateContext(contextData, expressionFunctions);
69                  try
70                  {
71                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StringStepsContext, token, 0, null, omitHeader: true);
72                      context.Errors.Check();
73                      result = PipelineTemplateConverter.ConvertToStepDisplayName(context, token);
74                  }
75                  catch (Exception ex) when (!(ex is TemplateValidationException))
76                  {
77                      context.Errors.Add(ex);
78                  }
79                  context.Errors.Check();
80              }
81              return result;
82          }
83          public Dictionary<String, String> EvaluateStepEnvironment(
84              TemplateToken token,
85              DictionaryContextData contextData,
86              IList<IFunctionInfo> expressionFunctions,
87              StringComparer keyComparer)
88          {
89              var result = default(Dictionary<String, String>);
90              if (token != null && token.Type != TokenType.Null)
91              {
92                  var context = CreateContext(contextData, expressionFunctions);
93                  try
94                  {
95                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StepEnv, token, 0, null, omitHeader: true);
96                      context.Errors.Check();
97                      result = PipelineTemplateConverter.ConvertToStepEnvironment(context, token, keyComparer);
98                  }
99                  catch (Exception ex) when (!(ex is TemplateValidationException))
100                  {
101                      context.Errors.Add(ex);
102                  }
103                  context.Errors.Check();
104              }
105              return result ?? new Dictionary<String, String>(keyComparer);
106          }
107          public Boolean EvaluateStepIf(
108              TemplateToken token,
109              DictionaryContextData contextData,
110              IList<IFunctionInfo> expressionFunctions,
111              IEnumerable<KeyValuePair<String, Object>> expressionState)
112          {
113              var result = default(Boolean?);
114              if (token != null && token.Type != TokenType.Null)
115              {
116                  var context = CreateContext(contextData, expressionFunctions, expressionState);
117                  try
118                  {
119                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StepIfResult, token, 0, null, omitHeader: true);
120                      context.Errors.Check();
121                      result = PipelineTemplateConverter.ConvertToIfResult(context, token);
122                  }
123                  catch (Exception ex) when (!(ex is TemplateValidationException))
124                  {
125                      context.Errors.Add(ex);
126                  }
127                  context.Errors.Check();
128              }
129              return result ?? throw new InvalidOperationException("Step if cannot be null");
130          }
131          public Dictionary<String, String> EvaluateStepInputs(
132              TemplateToken token,
133              DictionaryContextData contextData,
134              IList<IFunctionInfo> expressionFunctions)
135          {
136              var result = default(Dictionary<String, String>);
137              if (token != null && token.Type != TokenType.Null)
138              {
139                  var context = CreateContext(contextData, expressionFunctions);
140                  try
141                  {
142                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StepWith, token, 0, null, omitHeader: true);
143                      context.Errors.Check();
144                      result = PipelineTemplateConverter.ConvertToStepInputs(context, token);
145                  }
146                  catch (Exception ex) when (!(ex is TemplateValidationException))
147                  {
148                      context.Errors.Add(ex);
149                  }
150                  context.Errors.Check();
151              }
152              return result ?? new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
153          }
154          public Int32 EvaluateStepTimeout(
155              TemplateToken token,
156              DictionaryContextData contextData,
157              IList<IFunctionInfo> expressionFunctions)
158          {
159              var result = default(Int32?);
160              if (token != null && token.Type != TokenType.Null)
161              {
162                  var context = CreateContext(contextData, expressionFunctions);
163                  try
164                  {
165                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.NumberStepsContext, token, 0, null, omitHeader: true);
166                      context.Errors.Check();
167                      result = PipelineTemplateConverter.ConvertToStepTimeout(context, token);
168                  }
169                  catch (Exception ex) when (!(ex is TemplateValidationException))
170                  {
171                      context.Errors.Add(ex);
172                  }
173                  context.Errors.Check();
174              }
175              return result ?? 0;
176          }
177          public JobContainer EvaluateJobContainer(
178              TemplateToken token,
179              DictionaryContextData contextData,
180              IList<IFunctionInfo> expressionFunctions)
181          {
182              var result = default(JobContainer);
183              if (token != null && token.Type != TokenType.Null)
184              {
185                  var context = CreateContext(contextData, expressionFunctions);
186                  try
187                  {
188                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.Container, token, 0, null, omitHeader: true);
189                      context.Errors.Check();
190                      result = PipelineTemplateConverter.ConvertToJobContainer(context, token);
191                  }
192                  catch (Exception ex) when (!(ex is TemplateValidationException))
193                  {
194                      context.Errors.Add(ex);
195                  }
196                  context.Errors.Check();
197              }
198              return result;
199          }
200          public Dictionary<String, String> EvaluateJobOutput(
201              TemplateToken token,
202              DictionaryContextData contextData,
203              IList<IFunctionInfo> expressionFunctions)
204          {
205              var result = default(Dictionary<String, String>);
206              if (token != null && token.Type != TokenType.Null)
207              {
208                  var context = CreateContext(contextData, expressionFunctions);
209                  try
210                  {
211                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.JobOutputs, token, 0, null, omitHeader: true);
212                      context.Errors.Check();
213                      result = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
214                      var mapping = token.AssertMapping("outputs");
215                      foreach (var pair in mapping)
216                      {
217                          var key = pair.Key.AssertString("output key");
218                          var value = pair.Value.AssertString("output value");
219                          result[key.Value] = value.Value;
220                      }
221                  }
222                  catch (Exception ex) when (!(ex is TemplateValidationException))
223                  {
224                      context.Errors.Add(ex);
225                  }
226                  context.Errors.Check();
227              }
228              return result;
229          }
230          public TemplateToken EvaluateEnvironmentUrl(
231              TemplateToken token,
232              DictionaryContextData contextData,
233              IList<IFunctionInfo> expressionFunctions)
234          {
235              var result = default(TemplateToken);
236              if (token != null && token.Type != TokenType.Null)
237              {
238                  var context = CreateContext(contextData, expressionFunctions);
239                  try
240                  {
241                      token = TemplateEvaluator.Evaluate(context, TemplateConstants.StringRunnerContextNoSecrets, token, 0, null, omitHeader: true);
242                      context.Errors.Check();
243                      result = token.AssertString("environment.url");
244                  }
245                  catch (Exception ex) when (!(ex is TemplateValidationException))
246                  {
247                      context.Errors.Add(ex);
248                  }
249                  context.Errors.Check();
250              }
251              return result;
252          }
253          public Dictionary<String, String> EvaluateJobDefaultsRun(
254              TemplateToken token,
255              DictionaryContextData contextData,
256              IList<IFunctionInfo> expressionFunctions)
257          {
258              var result = default(Dictionary<String, String>);
259              if (token != null && token.Type != TokenType.Null)
260              {
261                  var context = CreateContext(contextData, expressionFunctions);
262                  try
263                  {
264                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.JobDefaultsRun, token, 0, null, omitHeader: true);
265                      context.Errors.Check();
266                      result = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
267                      var mapping = token.AssertMapping("defaults run");
268                      foreach (var pair in mapping)
269                      {
270                          var key = pair.Key.AssertString("defaults run key");
271                          var value = pair.Value.AssertString("defaults run value");
272                          result[key.Value] = value.Value;
273                      }
274                  }
275                  catch (Exception ex) when (!(ex is TemplateValidationException))
276                  {
277                      context.Errors.Add(ex);
278                  }
279                  context.Errors.Check();
280              }
281              return result;
282          }
283          public IList<KeyValuePair<String, JobContainer>> EvaluateJobServiceContainers(
284              TemplateToken token,
285              DictionaryContextData contextData,
286              IList<IFunctionInfo> expressionFunctions)
287          {
288              var result = default(List<KeyValuePair<String, JobContainer>>);
289              if (token != null && token.Type != TokenType.Null)
290              {
<span onclick='openModal()' class='match'>291                  var context = CreateContext(contextData, expressionFunctions);
292                  try
293                  {
294                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.Services, token, 0, null, omitHeader: true);
</span>295                      context.Errors.Check();
296                      result = PipelineTemplateConverter.ConvertToJobServiceContainers(context, token);
297                  }
298                  catch (Exception ex) when (!(ex is TemplateValidationException))
299                  {
300                      context.Errors.Add(ex);
301                  }
302                  context.Errors.Check();
303              }
304              return result;
305          }
306          private TemplateContext CreateContext(
307              DictionaryContextData contextData,
308              IList<IFunctionInfo> expressionFunctions,
309              IEnumerable<KeyValuePair<String, Object>> expressionState = null)
310          {
311              var result = new TemplateContext
312              {
313                  CancellationToken = CancellationToken.None,
314                  Errors = new TemplateValidationErrors(MaxErrors, MaxErrorMessageLength),
315                  Memory = new TemplateMemory(
316                      maxDepth: MaxDepth,
317                      maxEvents: MaxEvents,
318                      maxBytes: MaxResultSize),
319                  Schema = m_schema,
320                  TraceWriter = m_trace,
321              };
322              if (m_fileTable?.Count > 0)
323              {
324                  foreach (var file in m_fileTable)
325                  {
326                      result.GetFileId(file);
327                  }
328              }
329              if (contextData != null)
330              {
331                  foreach (var pair in contextData)
332                  {
333                      result.ExpressionValues[pair.Key] = pair.Value;
334                  }
335              }
336              var functionNames = new HashSet<String>(StringComparer.OrdinalIgnoreCase);
337              if (expressionFunctions?.Count > 0)
338              {
339                  foreach (var function in expressionFunctions)
340                  {
341                      result.ExpressionFunctions.Add(function);
342                      functionNames.Add(function.Name);
343                  }
344              }
345              foreach (var name in s_expressionValueNames)
346              {
347                  if (!result.ExpressionValues.ContainsKey(name))
348                  {
349                      result.ExpressionValues[name] = null;
350                  }
351              }
352              foreach (var name in s_expressionFunctionNames)
353              {
354                  if (!functionNames.Contains(name))
355                  {
356                      result.ExpressionFunctions.Add(new FunctionInfo<NoOperation>(name, 0, Int32.MaxValue));
357                  }
358              }
359              if (expressionState != null)
360              {
361                  foreach (var pair in expressionState)
362                  {
363                      result.State[pair.Key] = pair.Value;
364                  }
365              }
366              return result;
367          }
368          private readonly ITraceWriter m_trace;
369          private readonly TemplateSchema m_schema;
370          private readonly IList<String> m_fileTable;
371          private readonly String[] s_expressionValueNames = new[]
372          {
373              PipelineTemplateConstants.GitHub,
374              PipelineTemplateConstants.Strategy,
375              PipelineTemplateConstants.Matrix,
376              PipelineTemplateConstants.Needs,
377              PipelineTemplateConstants.Secrets,
378              PipelineTemplateConstants.Steps,
379              PipelineTemplateConstants.Inputs,
380              PipelineTemplateConstants.Job,
381              PipelineTemplateConstants.Runner,
382              PipelineTemplateConstants.Env,
383              PipelineTemplateConstants.Vars,
384          };
385          private readonly String[] s_expressionFunctionNames = new[]
386          {
387              PipelineTemplateConstants.Always,
388              PipelineTemplateConstants.Cancelled,
389              PipelineTemplateConstants.Failure,
390              PipelineTemplateConstants.HashFiles,
391              PipelineTemplateConstants.Success,
392          };
393      }
394  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateEvaluator.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.ComponentModel;
4  using System.Linq;
5  using System.Threading;
6  using GitHub.DistributedTask.Expressions2;
7  using GitHub.DistributedTask.Expressions2.Sdk.Functions;
8  using GitHub.DistributedTask.ObjectTemplating;
9  using GitHub.DistributedTask.ObjectTemplating.Schema;
10  using GitHub.DistributedTask.ObjectTemplating.Tokens;
11  using GitHub.DistributedTask.Pipelines.ContextData;
12  using ExpressionConstants = GitHub.DistributedTask.Expressions2.ExpressionConstants;
13  using ITraceWriter = GitHub.DistributedTask.ObjectTemplating.ITraceWriter;
14  namespace GitHub.DistributedTask.Pipelines.ObjectTemplating
15  {
16      [EditorBrowsable(EditorBrowsableState.Never)]
17      public class PipelineTemplateEvaluator
18      {
19          public PipelineTemplateEvaluator(
20              ITraceWriter trace,
21              TemplateSchema schema,
22              IList<String> fileTable)
23          {
24              if (!String.Equals(schema.Version, PipelineTemplateConstants.Workflow_1_0, StringComparison.Ordinal))
25              {
26                  throw new NotSupportedException($"Unexpected template schema version '{schema.Version}'");
27              }
28              m_trace = trace;
29              m_schema = schema;
30              m_fileTable = fileTable;
31          }
32          public Int32 MaxDepth => 50;
33          public Int32 MaxErrorMessageLength { get; set; } = 500;
34          public Int32 MaxErrors => 10;
35          public Int32 MaxEvents => 1000000; 
36          public Int32 MaxResultSize { get; set; } = 10 * 1024 * 1024; 
37          public Boolean EvaluateStepContinueOnError(
38              TemplateToken token,
39              DictionaryContextData contextData,
40              IList<IFunctionInfo> expressionFunctions)
41          {
42              var result = default(Boolean?);
43              if (token != null && token.Type != TokenType.Null)
44              {
45                  var context = CreateContext(contextData, expressionFunctions);
46                  try
47                  {
48                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.BooleanStepsContext, token, 0, null, omitHeader: true);
49                      context.Errors.Check();
50                      result = PipelineTemplateConverter.ConvertToStepContinueOnError(context, token);
51                  }
52                  catch (Exception ex) when (!(ex is TemplateValidationException))
53                  {
54                      context.Errors.Add(ex);
55                  }
56                  context.Errors.Check();
57              }
58              return result ?? false;
59          }
60          public String EvaluateStepDisplayName(
61              TemplateToken token,
62              DictionaryContextData contextData,
63              IList<IFunctionInfo> expressionFunctions)
64          {
65              var result = default(String);
66              if (token != null && token.Type != TokenType.Null)
67              {
68                  var context = CreateContext(contextData, expressionFunctions);
69                  try
70                  {
71                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StringStepsContext, token, 0, null, omitHeader: true);
72                      context.Errors.Check();
73                      result = PipelineTemplateConverter.ConvertToStepDisplayName(context, token);
74                  }
75                  catch (Exception ex) when (!(ex is TemplateValidationException))
76                  {
77                      context.Errors.Add(ex);
78                  }
79                  context.Errors.Check();
80              }
81              return result;
82          }
83          public Dictionary<String, String> EvaluateStepEnvironment(
84              TemplateToken token,
85              DictionaryContextData contextData,
86              IList<IFunctionInfo> expressionFunctions,
87              StringComparer keyComparer)
88          {
89              var result = default(Dictionary<String, String>);
90              if (token != null && token.Type != TokenType.Null)
91              {
92                  var context = CreateContext(contextData, expressionFunctions);
93                  try
94                  {
95                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StepEnv, token, 0, null, omitHeader: true);
96                      context.Errors.Check();
97                      result = PipelineTemplateConverter.ConvertToStepEnvironment(context, token, keyComparer);
98                  }
99                  catch (Exception ex) when (!(ex is TemplateValidationException))
100                  {
101                      context.Errors.Add(ex);
102                  }
103                  context.Errors.Check();
104              }
105              return result ?? new Dictionary<String, String>(keyComparer);
106          }
107          public Boolean EvaluateStepIf(
108              TemplateToken token,
109              DictionaryContextData contextData,
110              IList<IFunctionInfo> expressionFunctions,
111              IEnumerable<KeyValuePair<String, Object>> expressionState)
112          {
113              var result = default(Boolean?);
114              if (token != null && token.Type != TokenType.Null)
115              {
116                  var context = CreateContext(contextData, expressionFunctions, expressionState);
117                  try
118                  {
119                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StepIfResult, token, 0, null, omitHeader: true);
120                      context.Errors.Check();
121                      result = PipelineTemplateConverter.ConvertToIfResult(context, token);
122                  }
123                  catch (Exception ex) when (!(ex is TemplateValidationException))
124                  {
125                      context.Errors.Add(ex);
126                  }
127                  context.Errors.Check();
128              }
129              return result ?? throw new InvalidOperationException("Step if cannot be null");
130          }
131          public Dictionary<String, String> EvaluateStepInputs(
132              TemplateToken token,
133              DictionaryContextData contextData,
134              IList<IFunctionInfo> expressionFunctions)
135          {
136              var result = default(Dictionary<String, String>);
137              if (token != null && token.Type != TokenType.Null)
138              {
139                  var context = CreateContext(contextData, expressionFunctions);
140                  try
141                  {
142                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.StepWith, token, 0, null, omitHeader: true);
143                      context.Errors.Check();
144                      result = PipelineTemplateConverter.ConvertToStepInputs(context, token);
145                  }
146                  catch (Exception ex) when (!(ex is TemplateValidationException))
147                  {
148                      context.Errors.Add(ex);
149                  }
150                  context.Errors.Check();
151              }
152              return result ?? new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
153          }
154          public Int32 EvaluateStepTimeout(
155              TemplateToken token,
156              DictionaryContextData contextData,
157              IList<IFunctionInfo> expressionFunctions)
158          {
159              var result = default(Int32?);
160              if (token != null && token.Type != TokenType.Null)
161              {
162                  var context = CreateContext(contextData, expressionFunctions);
163                  try
164                  {
165                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.NumberStepsContext, token, 0, null, omitHeader: true);
166                      context.Errors.Check();
167                      result = PipelineTemplateConverter.ConvertToStepTimeout(context, token);
168                  }
169                  catch (Exception ex) when (!(ex is TemplateValidationException))
170                  {
171                      context.Errors.Add(ex);
172                  }
173                  context.Errors.Check();
174              }
175              return result ?? 0;
176          }
177          public JobContainer EvaluateJobContainer(
178              TemplateToken token,
179              DictionaryContextData contextData,
180              IList<IFunctionInfo> expressionFunctions)
181          {
182              var result = default(JobContainer);
183              if (token != null && token.Type != TokenType.Null)
184              {
185                  var context = CreateContext(contextData, expressionFunctions);
186                  try
187                  {
188                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.Container, token, 0, null, omitHeader: true);
189                      context.Errors.Check();
190                      result = PipelineTemplateConverter.ConvertToJobContainer(context, token);
191                  }
192                  catch (Exception ex) when (!(ex is TemplateValidationException))
193                  {
194                      context.Errors.Add(ex);
195                  }
196                  context.Errors.Check();
197              }
198              return result;
199          }
200          public Dictionary<String, String> EvaluateJobOutput(
201              TemplateToken token,
202              DictionaryContextData contextData,
203              IList<IFunctionInfo> expressionFunctions)
204          {
205              var result = default(Dictionary<String, String>);
206              if (token != null && token.Type != TokenType.Null)
207              {
208                  var context = CreateContext(contextData, expressionFunctions);
209                  try
210                  {
211                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.JobOutputs, token, 0, null, omitHeader: true);
212                      context.Errors.Check();
213                      result = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
214                      var mapping = token.AssertMapping("outputs");
215                      foreach (var pair in mapping)
216                      {
217                          var key = pair.Key.AssertString("output key");
218                          var value = pair.Value.AssertString("output value");
219                          result[key.Value] = value.Value;
220                      }
221                  }
222                  catch (Exception ex) when (!(ex is TemplateValidationException))
223                  {
224                      context.Errors.Add(ex);
225                  }
226                  context.Errors.Check();
227              }
228              return result;
229          }
230          public TemplateToken EvaluateEnvironmentUrl(
231              TemplateToken token,
232              DictionaryContextData contextData,
233              IList<IFunctionInfo> expressionFunctions)
234          {
235              var result = default(TemplateToken);
236              if (token != null && token.Type != TokenType.Null)
237              {
<span onclick='openModal()' class='match'>238                  var context = CreateContext(contextData, expressionFunctions);
239                  try
240                  {
241                      token = TemplateEvaluator.Evaluate(context, TemplateConstants.StringRunnerContextNoSecrets, token, 0, null, omitHeader: true);
</span>242                      context.Errors.Check();
243                      result = token.AssertString("environment.url");
244                  }
245                  catch (Exception ex) when (!(ex is TemplateValidationException))
246                  {
247                      context.Errors.Add(ex);
248                  }
249                  context.Errors.Check();
250              }
251              return result;
252          }
253          public Dictionary<String, String> EvaluateJobDefaultsRun(
254              TemplateToken token,
255              DictionaryContextData contextData,
256              IList<IFunctionInfo> expressionFunctions)
257          {
258              var result = default(Dictionary<String, String>);
259              if (token != null && token.Type != TokenType.Null)
260              {
261                  var context = CreateContext(contextData, expressionFunctions);
262                  try
263                  {
264                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.JobDefaultsRun, token, 0, null, omitHeader: true);
265                      context.Errors.Check();
266                      result = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase);
267                      var mapping = token.AssertMapping("defaults run");
268                      foreach (var pair in mapping)
269                      {
270                          var key = pair.Key.AssertString("defaults run key");
271                          var value = pair.Value.AssertString("defaults run value");
272                          result[key.Value] = value.Value;
273                      }
274                  }
275                  catch (Exception ex) when (!(ex is TemplateValidationException))
276                  {
277                      context.Errors.Add(ex);
278                  }
279                  context.Errors.Check();
280              }
281              return result;
282          }
283          public IList<KeyValuePair<String, JobContainer>> EvaluateJobServiceContainers(
284              TemplateToken token,
285              DictionaryContextData contextData,
286              IList<IFunctionInfo> expressionFunctions)
287          {
288              var result = default(List<KeyValuePair<String, JobContainer>>);
289              if (token != null && token.Type != TokenType.Null)
290              {
291                  var context = CreateContext(contextData, expressionFunctions);
292                  try
293                  {
294                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.Services, token, 0, null, omitHeader: true);
295                      context.Errors.Check();
296                      result = PipelineTemplateConverter.ConvertToJobServiceContainers(context, token);
297                  }
298                  catch (Exception ex) when (!(ex is TemplateValidationException))
299                  {
300                      context.Errors.Add(ex);
301                  }
302                  context.Errors.Check();
303              }
304              return result;
305          }
306          private TemplateContext CreateContext(
307              DictionaryContextData contextData,
308              IList<IFunctionInfo> expressionFunctions,
309              IEnumerable<KeyValuePair<String, Object>> expressionState = null)
310          {
311              var result = new TemplateContext
312              {
313                  CancellationToken = CancellationToken.None,
314                  Errors = new TemplateValidationErrors(MaxErrors, MaxErrorMessageLength),
315                  Memory = new TemplateMemory(
316                      maxDepth: MaxDepth,
317                      maxEvents: MaxEvents,
318                      maxBytes: MaxResultSize),
319                  Schema = m_schema,
320                  TraceWriter = m_trace,
321              };
322              if (m_fileTable?.Count > 0)
323              {
324                  foreach (var file in m_fileTable)
325                  {
326                      result.GetFileId(file);
327                  }
328              }
329              if (contextData != null)
330              {
331                  foreach (var pair in contextData)
332                  {
333                      result.ExpressionValues[pair.Key] = pair.Value;
334                  }
335              }
336              var functionNames = new HashSet<String>(StringComparer.OrdinalIgnoreCase);
337              if (expressionFunctions?.Count > 0)
338              {
339                  foreach (var function in expressionFunctions)
340                  {
341                      result.ExpressionFunctions.Add(function);
342                      functionNames.Add(function.Name);
343                  }
344              }
345              foreach (var name in s_expressionValueNames)
346              {
347                  if (!result.ExpressionValues.ContainsKey(name))
348                  {
349                      result.ExpressionValues[name] = null;
350                  }
351              }
352              foreach (var name in s_expressionFunctionNames)
353              {
354                  if (!functionNames.Contains(name))
355                  {
356                      result.ExpressionFunctions.Add(new FunctionInfo<NoOperation>(name, 0, Int32.MaxValue));
357                  }
358              }
359              if (expressionState != null)
360              {
361                  foreach (var pair in expressionState)
362                  {
363                      result.State[pair.Key] = pair.Value;
364                  }
365              }
366              return result;
367          }
368          private readonly ITraceWriter m_trace;
369          private readonly TemplateSchema m_schema;
370          private readonly IList<String> m_fileTable;
371          private readonly String[] s_expressionValueNames = new[]
372          {
373              PipelineTemplateConstants.GitHub,
374              PipelineTemplateConstants.Strategy,
375              PipelineTemplateConstants.Matrix,
376              PipelineTemplateConstants.Needs,
377              PipelineTemplateConstants.Secrets,
378              PipelineTemplateConstants.Steps,
379              PipelineTemplateConstants.Inputs,
380              PipelineTemplateConstants.Job,
381              PipelineTemplateConstants.Runner,
382              PipelineTemplateConstants.Env,
383              PipelineTemplateConstants.Vars,
384          };
385          private readonly String[] s_expressionFunctionNames = new[]
386          {
387              PipelineTemplateConstants.Always,
388              PipelineTemplateConstants.Cancelled,
389              PipelineTemplateConstants.Failure,
390              PipelineTemplateConstants.HashFiles,
391              PipelineTemplateConstants.Success,
392          };
393      }
394  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateEvaluator.cs</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-PipelineTemplateEvaluator.cs</div>
                </div>
                <div class="column column_space"><pre><code>291                  var context = CreateContext(contextData, expressionFunctions);
292                  try
293                  {
294                      token = TemplateEvaluator.Evaluate(context, PipelineTemplateConstants.Services, token, 0, null, omitHeader: true);
</pre></code></div>
                <div class="column column_space"><pre><code>238                  var context = CreateContext(contextData, expressionFunctions);
239                  try
240                  {
241                      token = TemplateEvaluator.Evaluate(context, TemplateConstants.StringRunnerContextNoSecrets, token, 0, null, omitHeader: true);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    