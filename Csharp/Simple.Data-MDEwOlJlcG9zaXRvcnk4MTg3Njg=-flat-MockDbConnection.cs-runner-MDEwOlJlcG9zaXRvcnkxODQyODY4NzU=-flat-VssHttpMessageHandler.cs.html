
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.040404040404041%, Tokens: 10</h2>
        <div class="column">
            <h3>Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-MockDbConnection.cs</h3>
            <pre><code>1  using System;
2  using System.Data;
3  using System.Data.Common;
4  namespace Simple.Data.Mocking.Ado
5  {
6      public class MockDbConnection : DbConnection
7      {
8          private readonly MockDatabase _mockDatabase;
9          private ConnectionState _state = ConnectionState.Closed;
10          public MockDbConnection(MockDatabase mockDatabase)
11          {
12              _mockDatabase = mockDatabase;
13          }
14          public MockDatabase MockDatabase
15          {
<span onclick='openModal()' class='match'>16              get { return _mockDatabase; }
17          }
18          public DataTable DummyDataTable { get; set; }
19          protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel)
20          {
</span>21              return new MockDbTransaction(this, isolationLevel);
22          }
23          public override void Close()
24          {
25              _state = ConnectionState.Closed;
26          }
27          public override void ChangeDatabase(string databaseName)
28          {
29              throw new NotImplementedException();
30          }
31          public override string ConnectionString
32          {
33              get { return _mockDatabase.GetHashCode().ToString(); }
34              set
35              {
36              }
37          }
38          public override int ConnectionTimeout
39          {
40              get { throw new NotImplementedException(); }
41          }
42          protected override DbCommand CreateDbCommand()
43          {
44              return new MockDbCommand(this);
45          }
46          public override string Database
47          {
48              get { throw new NotImplementedException(); }
49          }
50          public override string DataSource
51          {
52              get { throw new NotImplementedException(); }
53          }
54          public override void Open()
55          {
56              _state = ConnectionState.Open;
57          }
58          public override string ServerVersion
59          {
60              get { throw new NotImplementedException(); }
61          }
62          public override ConnectionState State
63          {
64              get { return _state; }
65          }
66      }
67  }
</code></pre>
        </div>
        <div class="column">
            <h3>runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssHttpMessageHandler.cs</h3>
            <pre><code>1  using System;
2  using System.Collections.Generic;
3  using System.Linq;
4  using System.Net;
5  using System.Net.Http;
6  using System.Threading;
7  using System.Threading.Tasks;
8  using GitHub.Services.Common.Diagnostics;
9  using GitHub.Services.Common.Internal;
10  namespace GitHub.Services.Common
11  {
12      public class VssHttpMessageHandler : HttpMessageHandler
13      {
14          public VssHttpMessageHandler()
15              : this(new VssCredentials(), new VssHttpRequestSettings())
16          {
17          }
18          public VssHttpMessageHandler(
19              VssCredentials credentials,
20              VssHttpRequestSettings settings)
21              : this(credentials, settings, new HttpClientHandler())
22          {
23          }
24          public VssHttpMessageHandler(
25              VssCredentials credentials,
26              VssHttpRequestSettings settings,
27              HttpMessageHandler innerHandler)
28          {
29              this.Credentials = credentials;
30              this.Settings = settings;
31              this.ExpectContinue = settings.ExpectContinue;
32              m_credentialWrapper = new CredentialWrapper();
33              m_messageInvoker = new HttpMessageInvoker(innerHandler);
34              {
35                  HttpMessageHandler transportHandler = innerHandler;
36                  DelegatingHandler delegatingHandler = transportHandler as DelegatingHandler;
37                  while (delegatingHandler != null)
38                  {
39                      transportHandler = delegatingHandler.InnerHandler;
40                      delegatingHandler = transportHandler as DelegatingHandler;
41                  }
42                  m_transportHandler = transportHandler;
43              }
44              ApplySettings(m_transportHandler, m_credentialWrapper, this.Settings);
45          }
46          public VssCredentials Credentials
47          {
48              get;
49              private set;
50          }
51          public VssHttpRequestSettings Settings
52          {
<span onclick='openModal()' class='match'>53              get;
54              private set;
55          }
56          private Boolean ExpectContinue
57          {
58              get;
59              set;
60          }
61          protected override void Dispose(Boolean disposing)
62          {
</span>63              base.Dispose(disposing);
64              if (disposing)
65              {
66                  if (m_messageInvoker != null)
67                  {
68                      m_messageInvoker.Dispose();
69                  }
70              }
71          }
72          internal static readonly String PropertyName = "MS.VS.MessageHandler";
73          protected override async Task<HttpResponseMessage> SendAsync(
74              HttpRequestMessage request,
75              CancellationToken cancellationToken)
76          {
77              VssTraceActivity traceActivity = VssTraceActivity.Current;
78              var traceInfo = VssHttpMessageHandlerTraceInfo.GetTraceInfo(request);
79              traceInfo?.TraceHandlerStartTime();
80              if (!m_appliedClientCertificatesToTransportHandler &&
81                  request.RequestUri.Scheme == "https")
82              {
83                  HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
84                  if (httpClientHandler != null &&
85                      this.Settings.ClientCertificateManager != null &&
86                      this.Settings.ClientCertificateManager.ClientCertificates != null &&
87                      this.Settings.ClientCertificateManager.ClientCertificates.Count > 0)
88                  {
89                      httpClientHandler.ClientCertificates.AddRange(this.Settings.ClientCertificateManager.ClientCertificates);
90                  }
91                  m_appliedClientCertificatesToTransportHandler = true;
92              }
93              if (!m_appliedServerCertificateValidationCallbackToTransportHandler &&
94                  request.RequestUri.Scheme == "https")
95              {
96                  HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
97                  if (httpClientHandler != null &&
98                      this.Settings.ServerCertificateValidationCallback != null)
99                  {
100                      httpClientHandler.ServerCertificateCustomValidationCallback = this.Settings.ServerCertificateValidationCallback;
101                  }
102                  m_appliedServerCertificateValidationCallbackToTransportHandler = true;
103              }
104              if (Settings.UseHttp11)
105              {
106                  request.Version = HttpVersion.Version11;
107              }
108              IssuedToken token = null;
109              IssuedTokenProvider provider;
110              if (this.Credentials.TryGetTokenProvider(request.RequestUri, out provider))
111              {
112                  token = provider.CurrentToken;
113              }
114              request.Options.Set(new HttpRequestOptionsKey<VssHttpMessageHandler>(VssHttpMessageHandler.PropertyName), this);
115              Boolean succeeded = false;
116              Boolean lastResponseDemandedProxyAuth = false;
117              Int32 retries = m_maxAuthRetries;
118              HttpResponseMessage response = null;
119              HttpResponseMessageWrapper responseWrapper;
120              CancellationTokenSource tokenSource = null;
121              try
122              {
123                  tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
124                  if (this.Settings.SendTimeout > TimeSpan.Zero)
125                  {
126                      tokenSource.CancelAfter(this.Settings.SendTimeout);
127                  }
128                  do
129                  {
130                      if (response != null)
131                      {
132                          response.Dispose();
133                      }
134                      ApplyHeaders(request);
135                      ApplyToken(request, token, applyICredentialsToWebProxy: lastResponseDemandedProxyAuth);
136                      lastResponseDemandedProxyAuth = false;
137                      await BufferRequestContentAsync(request, tokenSource.Token).ConfigureAwait(false);
138                      traceInfo?.TraceBufferedRequestTime();
139                      response = await m_messageInvoker.SendAsync(request, tokenSource.Token).ConfigureAwait(false);
140                      traceInfo?.TraceRequestSendTime();
141                      await BufferResponseContentAsync(request, response, () => $"[ContentType: {response.Content.GetType().Name}]", tokenSource.Token).ConfigureAwait(false);
142                      traceInfo?.TraceResponseContentTime();
143                      responseWrapper = new HttpResponseMessageWrapper(response);
144                      if (!this.Credentials.IsAuthenticationChallenge(responseWrapper))
145                      {
146                          if (provider != null)
147                          {
148                              provider.ValidateToken(token, responseWrapper);
149                          }
150                          this.ExpectContinue = false;
151                          succeeded = true;
152                          break;
153                      }
154                      else
155                      {
156                          lastResponseDemandedProxyAuth = responseWrapper.StatusCode == HttpStatusCode.ProxyAuthenticationRequired;
157                          if (retries < m_maxAuthRetries)
158                          {
159                              VssHttpEventSource.Log.AuthenticationFailed(traceActivity, response);
160                          }
161                          else
162                          {
163                              VssHttpEventSource.Log.AuthenticationFailedOnFirstRequest(traceActivity, response);
164                          }
165                          if (provider != null)
166                          {
167                              provider.InvalidateToken(token);
168                          }
169                          provider = this.Credentials.CreateTokenProvider(request.RequestUri, responseWrapper, token);
170                          if (provider == null)
171                          {
172                              VssHttpEventSource.Log.IssuedTokenProviderNotFound(traceActivity);
173                              break;
174                          }
175                          else if (provider.GetTokenIsInteractive && this.Credentials.PromptType == CredentialPromptType.DoNotPrompt)
176                          {
177                              VssHttpEventSource.Log.IssuedTokenProviderPromptRequired(traceActivity, provider);
178                              break;
179                          }
180                          IEnumerable<String> headerValues;
181                          Boolean hasAuthenticateError =
182                              response.Headers.TryGetValues(HttpHeaders.VssAuthenticateError, out headerValues) &&
183                              !String.IsNullOrEmpty(headerValues.FirstOrDefault());
184                          if (retries == 0 || (retries < m_maxAuthRetries && hasAuthenticateError))
185                          {
186                              break;
187                          }
188                          token = await provider.GetTokenAsync(token, tokenSource.Token).ConfigureAwait(false);
189                          traceInfo?.TraceGetTokenTime();
190                          request.Headers.Add(HttpHeaders.VssUserData, String.Empty);
191                          retries--;
192                      }
193                  }
194                  while (retries >= 0);
195                  if (traceInfo != null)
196                  {
197                      traceInfo.TokenRetries = m_maxAuthRetries - retries;
198                  }
199                  if (!succeeded && response != null && this.Credentials.IsAuthenticationChallenge(responseWrapper))
200                  {
201                      String message = null;
202                      IEnumerable<String> serviceError;
203                      if (response.Headers.TryGetValues(HttpHeaders.TfsServiceError, out serviceError))
204                      {
205                          message = UriUtility.UrlDecode(serviceError.FirstOrDefault());
206                      }
207                      else
208                      {
209                          message = CommonResources.VssUnauthorized(request.RequestUri.GetLeftPart(UriPartial.Authority));
210                      }
211                      if (response != null)
212                      {
213                          response.Dispose();
214                      }
215                      VssHttpEventSource.Log.HttpRequestUnauthorized(traceActivity, request, message);
216                      VssUnauthorizedException unauthorizedException = new VssUnauthorizedException(message);
217                      if (provider != null)
218                      {
219                          unauthorizedException.Data.Add(CredentialsType, provider.CredentialType);
220                      }
221                      throw unauthorizedException;
222                  }
223                  return response;
224              }
225              catch (OperationCanceledException ex)
226              {
227                  if (cancellationToken.IsCancellationRequested)
228                  {
229                      VssHttpEventSource.Log.HttpRequestCancelled(traceActivity, request);
230                      throw;
231                  }
232                  else
233                  {
234                      VssHttpEventSource.Log.HttpRequestTimedOut(traceActivity, request, this.Settings.SendTimeout);
235                      throw new TimeoutException(CommonResources.HttpRequestTimeout(this.Settings.SendTimeout), ex);
236                  }
237              }
238              finally
239              {
240                  if (tokenSource != null)
241                  {
242                      tokenSource.Dispose();
243                  }
244                  traceInfo?.TraceTrailingTime();
245              }
246          }
247          private static async Task BufferRequestContentAsync(
248              HttpRequestMessage request,
249              CancellationToken cancellationToken)
250          {
251              if (request.Content != null &&
252                  request.Headers.TransferEncodingChunked != true)
253              {
254                  Int64? contentLength = request.Content.Headers.ContentLength;
255                  if (contentLength == null)
256                  {
257                      await request.Content.LoadIntoBufferAsync().EnforceCancellation(cancellationToken).ConfigureAwait(false);
258                  }
259                  request.Headers.TransferEncodingChunked = false;
260              }
261          }
262          protected virtual async Task BufferResponseContentAsync(
263              HttpRequestMessage request,
264              HttpResponseMessage response,
265              Func<string> makeErrorMessage,
266              CancellationToken cancellationToken)
267          {
268              if (response == null || response.StatusCode == HttpStatusCode.NoContent || response.Content == null)
269              {
270                  return;
271              }
272              if (this.Settings.MaxContentBufferSize == 0)
273              {
274                  return;
275              }
276              HttpCompletionOption completionOption;
277              if (!request.Options.TryGetValue(VssHttpRequestSettings.HttpCompletionOptionPropertyName, out completionOption))
278              {
279                  completionOption = HttpCompletionOption.ResponseContentRead;
280              }
281              if (completionOption == HttpCompletionOption.ResponseContentRead)
282              {
283                  await response.Content.LoadIntoBufferAsync(this.Settings.MaxContentBufferSize).EnforceCancellation(cancellationToken, makeErrorMessage).ConfigureAwait(false);
284              }
285          }
286          private void ApplyHeaders(HttpRequestMessage request)
287          {
288              if (this.Settings.ApplyTo(request))
289              {
290                  VssTraceActivity activity = request.GetActivity();
291                  if (activity != null &&
292                      activity != VssTraceActivity.Empty &&
293                      !request.Headers.Contains(HttpHeaders.TfsSessionHeader))
294                  {
295                      request.Headers.Add(HttpHeaders.TfsSessionHeader, activity.Id.ToString("D"));
296                  }
297                  request.Headers.ExpectContinue = this.ExpectContinue;
298              }
299          }
300          private void ApplyToken(
301              HttpRequestMessage request,
302              IssuedToken token,
303              bool applyICredentialsToWebProxy = false)
304          {
305              if (token == null)
306              {
307                  return;
308              }
309              ICredentials credentialsToken = token as ICredentials;
310              if (credentialsToken != null)
311              {
312                  if (applyICredentialsToWebProxy)
313                  {
314                      HttpClientHandler httpClientHandler = m_transportHandler as HttpClientHandler;
315                      if (httpClientHandler != null &&
316                          httpClientHandler.Proxy != null)
317                      {
318                          httpClientHandler.Proxy.Credentials = credentialsToken;
319                      }
320                  }
321                  m_credentialWrapper.InnerCredentials = credentialsToken;
322              }
323              else
324              {
325                  token.ApplyTo(new HttpRequestMessageWrapper(request));
326              }
327          }
328          private static void ApplySettings(
329              HttpMessageHandler handler,
330              ICredentials defaultCredentials,
331              VssHttpRequestSettings settings)
332          {
333              HttpClientHandler httpClientHandler = handler as HttpClientHandler;
334              if (httpClientHandler != null)
335              {
336                  httpClientHandler.AllowAutoRedirect = settings.AllowAutoRedirect;
337                  httpClientHandler.ClientCertificateOptions = ClientCertificateOption.Manual;
338                  httpClientHandler.UseDefaultCredentials = false;
339                  httpClientHandler.Credentials = defaultCredentials;
340                  httpClientHandler.PreAuthenticate = false;
341                  httpClientHandler.Proxy = DefaultWebProxy;
342                  httpClientHandler.UseCookies = false;
343                  httpClientHandler.UseProxy = true;
344                  if (settings.CompressionEnabled)
345                  {
346                      httpClientHandler.AutomaticDecompression = DecompressionMethods.GZip;
347                  }
348              }
349          }
350          private static IWebProxy s_defaultWebProxy = null;
351          public static IWebProxy DefaultWebProxy
352          {
353              get
354              {
355                  var toReturn = WebProxyWrapper.Wrap(s_defaultWebProxy);
356                  if (null != toReturn &&
357                      toReturn.Credentials == null)
358                  {
359                      toReturn.Credentials = CredentialCache.DefaultCredentials;
360                  }
361                  return toReturn;
362              }
363              set
364              {
365                  s_defaultWebProxy = value;
366              }
367          }
368          internal const String CredentialsType = nameof(CredentialsType);
369          private const Int32 m_maxAuthRetries = 3;
370          private HttpMessageInvoker m_messageInvoker;
371          private CredentialWrapper m_credentialWrapper;
372          private bool m_appliedClientCertificatesToTransportHandler;
373          private bool m_appliedServerCertificateValidationCallbackToTransportHandler;
374          private readonly HttpMessageHandler m_transportHandler;
375          private sealed class CredentialWrapper : CredentialCache, ICredentials
376          {
377              public ICredentials InnerCredentials
378              {
379                  get;
380                  set;
381              }
382              NetworkCredential ICredentials.GetCredential(
383                  Uri uri,
384                  String authType)
385              {
386                  return InnerCredentials != null ? InnerCredentials.GetCredential(uri, authType) : null;
387              }
388          }
389          private sealed class WebProxyWrapper : IWebProxy
390          {
391              private WebProxyWrapper(IWebProxy toWrap)
392              {
393                  m_wrapped = toWrap;
394                  m_credentials = null;
395              }
396              public static WebProxyWrapper Wrap(IWebProxy toWrap)
397              {
398                  if (null == toWrap)
399                  {
400                      return null;
401                  }
402                  return new WebProxyWrapper(toWrap);
403              }
404              public ICredentials Credentials
405              {
406                  get
407                  {
408                      ICredentials credentials = m_credentials;
409                      if (null == credentials)
410                      {
411                          credentials = m_wrapped.Credentials;
412                      }
413                      else if (Object.ReferenceEquals(credentials, m_nullCredentials))
414                      {
415                          credentials = null;
416                      }
417                      return credentials;
418                  }
419                  set
420                  {
421                      if (null == value)
422                      {
423                          m_credentials = m_nullCredentials;
424                      }
425                      else
426                      {
427                          m_credentials = value;
428                      }
429                  }
430              }
431              public Uri GetProxy(Uri destination)
432              {
433                  return m_wrapped.GetProxy(destination);
434              }
435              public bool IsBypassed(Uri host)
436              {
437                  return m_wrapped.IsBypassed(host);
438              }
439              private readonly IWebProxy m_wrapped;
440              private ICredentials m_credentials;
441              private static readonly ICredentials m_nullCredentials = new CredentialWrapper();
442          }
443      }
444  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Simple.Data-MDEwOlJlcG9zaXRvcnk4MTg3Njg=-flat-MockDbConnection.cs</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from runner-MDEwOlJlcG9zaXRvcnkxODQyODY4NzU=-flat-VssHttpMessageHandler.cs</div>
                <div class="column column_space"><pre><code>16              get { return _mockDatabase; }
17          }
18          public DataTable DummyDataTable { get; set; }
19          protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel)
20          {
</pre></code></div>
                <div class="column column_space"><pre><code>53              get;
54              private set;
55          }
56          private Boolean ExpectContinue
57          {
58              get;
59              set;
60          }
61          protected override void Dispose(Boolean disposing)
62          {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    